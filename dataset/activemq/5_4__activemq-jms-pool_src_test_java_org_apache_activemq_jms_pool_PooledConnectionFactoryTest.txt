4:cf914d1: /**
1:974f689:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:974f689:  * contributor license agreements.  See the NOTICE file distributed with
1:974f689:  * this work for additional information regarding copyright ownership.
1:974f689:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:974f689:  * (the "License"); you may not use this file except in compliance with
1:974f689:  * the License.  You may obtain a copy of the License at
1:5ac1540:  *
1:974f689:  *      http://www.apache.org/licenses/LICENSE-2.0
1:cf914d1:  *
1:974f689:  * Unless required by applicable law or agreed to in writing, software
1:974f689:  * distributed under the License is distributed on an "AS IS" BASIS,
1:974f689:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:974f689:  * See the License for the specific language governing permissions and
1:974f689:  * limitations under the License.
4:cf914d1:  */
1:b66559e: package org.apache.activemq.jms.pool;
3:5ac1540: 
1:77713d9: import static org.junit.Assert.assertEquals;
1:77713d9: import static org.junit.Assert.assertNotSame;
1:0706fd0: import static org.junit.Assert.assertNull;
1:77713d9: import static org.junit.Assert.assertSame;
1:77713d9: import static org.junit.Assert.assertTrue;
1:77713d9: import static org.junit.Assert.fail;
1:77713d9: 
1:a59c9ba: import java.util.concurrent.Callable;
1:be0311b: import java.util.concurrent.ConcurrentHashMap;
1:a59c9ba: import java.util.concurrent.ConcurrentLinkedQueue;
1:9ef4259: import java.util.concurrent.ConcurrentMap;
1:a59c9ba: import java.util.concurrent.ExecutorService;
1:a59c9ba: import java.util.concurrent.Executors;
1:a59c9ba: import java.util.concurrent.Future;
1:a59c9ba: import java.util.concurrent.TimeUnit;
1:5ac1540: 
1:cf914d1: import javax.jms.Connection;
1:cf914d1: import javax.jms.JMSException;
1:459593c: import javax.jms.QueueConnectionFactory;
1:cf914d1: import javax.jms.Session;
1:459593c: import javax.jms.TopicConnectionFactory;
1:a59c9ba: 
1:be0311b: import org.apache.activemq.ActiveMQConnection;
1:a59c9ba: import org.apache.activemq.ActiveMQConnectionFactory;
1:736ffc9: import org.apache.activemq.broker.BrokerService;
1:be0311b: import org.apache.activemq.command.ConnectionId;
1:a59c9ba: import org.apache.activemq.util.Wait;
1:a59c9ba: import org.apache.log4j.Logger;
1:77713d9: import org.junit.Test;
1:a59c9ba: 
1:cf914d1: /**
1:a59c9ba:  * Checks the behavior of the PooledConnectionFactory when the maximum amount of
1:a59c9ba:  * sessions is being reached.
1:cf914d1:  *
1:a59c9ba:  * Older versions simply block in the call to Connection.getSession(), which
1:a59c9ba:  * isn't good. An exception being returned is the better option, so JMS clients
1:a59c9ba:  * don't block. This test succeeds if an exception is returned and fails if the
1:a59c9ba:  * call to getSession() blocks.
1:cf914d1:  */
1:e6597c4: public class PooledConnectionFactoryTest extends JmsPoolTestSupport {
1:a59c9ba: 
1:a59c9ba:     public final static Logger LOG = Logger.getLogger(PooledConnectionFactoryTest.class);
1:a59c9ba: 
1:e6597c4:     @Test(timeout = 60000)
1:459593c:     public void testInstanceOf() throws  Exception {
1:459593c:         PooledConnectionFactory pcf = new PooledConnectionFactory();
1:459593c:         assertTrue(pcf instanceof QueueConnectionFactory);
1:459593c:         assertTrue(pcf instanceof TopicConnectionFactory);
1:27ce49f:         pcf.stop();
1:459593c:     }
1:459593c: 
1:e6597c4:     @Test(timeout = 60000)
1:a59c9ba:     public void testClearAllConnections() throws Exception {
1:a59c9ba: 
1:1ee5108:         ActiveMQConnectionFactory amq = new ActiveMQConnectionFactory(
1:1ee5108:             "vm://broker1?marshal=false&broker.persistent=false&broker.useJmx=false");
1:b66559e:         PooledConnectionFactory cf = new PooledConnectionFactory();
1:b66559e:         cf.setConnectionFactory(amq);
1:a59c9ba:         cf.setMaxConnections(3);
1:a59c9ba: 
1:a59c9ba:         PooledConnection conn1 = (PooledConnection) cf.createConnection();
1:a59c9ba:         PooledConnection conn2 = (PooledConnection) cf.createConnection();
1:a59c9ba:         PooledConnection conn3 = (PooledConnection) cf.createConnection();
1:a59c9ba: 
1:a59c9ba:         assertNotSame(conn1.getConnection(), conn2.getConnection());
1:a59c9ba:         assertNotSame(conn1.getConnection(), conn3.getConnection());
1:a59c9ba:         assertNotSame(conn2.getConnection(), conn3.getConnection());
1:27ce49f: 
1:a59c9ba:         assertEquals(3, cf.getNumConnections());
1:27ce49f: 
1:a59c9ba:         cf.clear();
1:a59c9ba: 
1:a59c9ba:         assertEquals(0, cf.getNumConnections());
1:a59c9ba: 
1:a59c9ba:         conn1 = (PooledConnection) cf.createConnection();
1:a59c9ba:         conn2 = (PooledConnection) cf.createConnection();
1:a59c9ba:         conn3 = (PooledConnection) cf.createConnection();
1:a59c9ba: 
1:a59c9ba:         assertNotSame(conn1.getConnection(), conn2.getConnection());
1:a59c9ba:         assertNotSame(conn1.getConnection(), conn3.getConnection());
1:a59c9ba:         assertNotSame(conn2.getConnection(), conn3.getConnection());
1:a59c9ba: 
1:27ce49f:         cf.stop();
1:be0311b:     }
1:be0311b: 
1:e6597c4:     @Test(timeout = 60000)
1:a59c9ba:     public void testMaxConnectionsAreCreated() throws Exception {
1:a59c9ba: 
1:1ee5108:         ActiveMQConnectionFactory amq = new ActiveMQConnectionFactory(
1:1ee5108:             "vm://broker1?marshal=false&broker.persistent=false&broker.useJmx=false");
1:b66559e:         PooledConnectionFactory cf = new PooledConnectionFactory();
1:b66559e:         cf.setConnectionFactory(amq);
1:a59c9ba:         cf.setMaxConnections(3);
1:a59c9ba: 
1:a59c9ba:         PooledConnection conn1 = (PooledConnection) cf.createConnection();
1:a59c9ba:         PooledConnection conn2 = (PooledConnection) cf.createConnection();
1:a59c9ba:         PooledConnection conn3 = (PooledConnection) cf.createConnection();
1:a59c9ba: 
1:a59c9ba:         assertNotSame(conn1.getConnection(), conn2.getConnection());
1:a59c9ba:         assertNotSame(conn1.getConnection(), conn3.getConnection());
1:a59c9ba:         assertNotSame(conn2.getConnection(), conn3.getConnection());
1:a59c9ba: 
1:a59c9ba:         assertEquals(3, cf.getNumConnections());
1:a59c9ba: 
1:27ce49f:         cf.stop();
1:a59c9ba:     }
1:5ac1540: 
1:e6597c4:     @Test(timeout = 60000)
1:0706fd0:     public void testFactoryStopStart() throws Exception {
1:0706fd0: 
1:0706fd0:         ActiveMQConnectionFactory amq = new ActiveMQConnectionFactory(
1:0706fd0:             "vm://broker1?marshal=false&broker.persistent=false&broker.useJmx=false");
1:0706fd0:         PooledConnectionFactory cf = new PooledConnectionFactory();
1:0706fd0:         cf.setConnectionFactory(amq);
1:0706fd0:         cf.setMaxConnections(1);
1:0706fd0: 
1:0706fd0:         PooledConnection conn1 = (PooledConnection) cf.createConnection();
1:0706fd0: 
1:0706fd0:         cf.stop();
1:0706fd0: 
1:0706fd0:         assertNull(cf.createConnection());
1:0706fd0: 
1:0706fd0:         cf.start();
1:0706fd0: 
1:0706fd0:         PooledConnection conn2 = (PooledConnection) cf.createConnection();
1:0706fd0: 
1:0706fd0:         assertNotSame(conn1.getConnection(), conn2.getConnection());
1:0706fd0: 
1:0706fd0:         assertEquals(1, cf.getNumConnections());
1:0706fd0: 
1:0706fd0:         cf.stop();
1:0706fd0:     }
1:0706fd0: 
1:0706fd0:     @Test(timeout = 60000)
1:a59c9ba:     public void testConnectionsAreRotated() throws Exception {
1:a59c9ba: 
1:1ee5108:         ActiveMQConnectionFactory amq = new ActiveMQConnectionFactory(
1:1ee5108:             "vm://broker1?marshal=false&broker.persistent=false&broker.useJmx=false");
1:b66559e:         PooledConnectionFactory cf = new PooledConnectionFactory();
1:b66559e:         cf.setConnectionFactory(amq);
1:a59c9ba:         cf.setMaxConnections(10);
1:a59c9ba: 
1:b66559e:         Connection previous = null;
1:a59c9ba: 
1:a59c9ba:         // Front load the pool.
1:a59c9ba:         for (int i = 0; i < 10; ++i) {
1:a59c9ba:             cf.createConnection();
1:a59c9ba:         }
1:a59c9ba: 
1:a59c9ba:         for (int i = 0; i < 100; ++i) {
1:b66559e:             Connection current = ((PooledConnection) cf.createConnection()).getConnection();
1:a59c9ba:             assertNotSame(previous, current);
1:a59c9ba:             previous = current;
1:a59c9ba:         }
1:27ce49f: 
1:27ce49f:         cf.stop();
1:a59c9ba:     }
1:a59c9ba: 
1:e6597c4:     @Test(timeout = 60000)
1:a59c9ba:     public void testConnectionsArePooled() throws Exception {
1:a59c9ba: 
4:a59c9ba:         ActiveMQConnectionFactory amq = new ActiveMQConnectionFactory("vm://broker1?marshal=false&broker.persistent=false");
1:b66559e:         PooledConnectionFactory cf = new PooledConnectionFactory();
1:b66559e:         cf.setConnectionFactory(amq);
1:a59c9ba:         cf.setMaxConnections(1);
1:a59c9ba: 
1:a59c9ba:         PooledConnection conn1 = (PooledConnection) cf.createConnection();
1:a59c9ba:         PooledConnection conn2 = (PooledConnection) cf.createConnection();
1:a59c9ba:         PooledConnection conn3 = (PooledConnection) cf.createConnection();
1:a59c9ba: 
1:a59c9ba:         assertSame(conn1.getConnection(), conn2.getConnection());
1:a59c9ba:         assertSame(conn1.getConnection(), conn3.getConnection());
1:a59c9ba:         assertSame(conn2.getConnection(), conn3.getConnection());
1:27ce49f: 
1:a59c9ba:         assertEquals(1, cf.getNumConnections());
1:a59c9ba: 
1:27ce49f:         cf.stop();
1:a59c9ba:     }
1:a59c9ba: 
1:e6597c4:     @Test(timeout = 60000)
1:a59c9ba:     public void testConnectionsArePooledAsyncCreate() throws Exception {
1:a59c9ba: 
1:1ee5108:         final ActiveMQConnectionFactory amq = new ActiveMQConnectionFactory(
1:1ee5108:             "vm://broker1?marshal=false&broker.persistent=false&broker.useJmx=false");
1:736ffc9:         final PooledConnectionFactory cf = new PooledConnectionFactory();
1:736ffc9:         cf.setConnectionFactory(amq);
1:a59c9ba:         cf.setMaxConnections(1);
1:a59c9ba: 
1:a59c9ba:         final ConcurrentLinkedQueue<PooledConnection> connections = new ConcurrentLinkedQueue<PooledConnection>();
1:a59c9ba: 
1:a59c9ba:         final PooledConnection primary = (PooledConnection) cf.createConnection();
1:a59c9ba:         final ExecutorService executor = Executors.newFixedThreadPool(10);
1:a59c9ba:         final int numConnections = 100;
1:a59c9ba: 
1:736ffc9:         for (int i = 0; i < numConnections; ++i) {
1:736ffc9:             executor.execute(new Runnable() {
1:a59c9ba: 
1:be0311b:                 @Override
1:736ffc9:                 public void run() {
1:a59c9ba:                     try {
1:a59c9ba:                         connections.add((PooledConnection) cf.createConnection());
1:736ffc9:                     } catch (JMSException e) {
1:a59c9ba:                     }
1:a59c9ba:                 }
1:736ffc9:             });
1:a59c9ba:         }
1:a59c9ba: 
1:e6597c4:         assertTrue("All connections should have been created.", Wait.waitFor(new Wait.Condition() {
1:1b38caa:             @Override
1:be0311b:             public boolean isSatisified() throws Exception {
1:be0311b:                 return connections.size() == numConnections;
1:a59c9ba:             }
1:e6597c4:         }, TimeUnit.SECONDS.toMillis(10), TimeUnit.MILLISECONDS.toMillis(50)));
1:a59c9ba: 
1:736ffc9:         executor.shutdown();
1:be0311b:         assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS));
1:a59c9ba: 
1:77713d9:         for (PooledConnection connection : connections) {
1:a59c9ba:             assertSame(primary.getConnection(), connection.getConnection());
1:a59c9ba:         }
1:a59c9ba: 
1:736ffc9:         connections.clear();
1:be0311b:         cf.stop();
1:a59c9ba:     }
1:a59c9ba: 
1:e6597c4:     @Test(timeout = 60000)
1:be0311b:     public void testConcurrentCreateGetsUniqueConnectionCreateOnDemand() throws Exception {
1:be0311b:         doTestConcurrentCreateGetsUniqueConnection(false);
1:be0311b:     }
1:be0311b: 
1:e6597c4:     @Test(timeout = 60000)
1:be0311b:     public void testConcurrentCreateGetsUniqueConnectionCreateOnStart() throws Exception {
1:be0311b:         doTestConcurrentCreateGetsUniqueConnection(true);
1:be0311b:     }
1:be0311b: 
1:be0311b:     private void doTestConcurrentCreateGetsUniqueConnection(boolean createOnStart) throws Exception {
1:be0311b: 
1:736ffc9:         BrokerService brokerService = new BrokerService();
1:736ffc9:         brokerService.setPersistent(false);
1:1ee5108:         brokerService.setUseJmx(false);
1:736ffc9:         brokerService.addConnector("tcp://localhost:0");
1:736ffc9:         brokerService.start();
1:77713d9:         brokerService.waitUntilStarted();
1:be0311b: 
1:736ffc9:         try {
1:736ffc9:             final int numConnections = 2;
1:be0311b: 
1:736ffc9:             final ActiveMQConnectionFactory amq = new ActiveMQConnectionFactory(brokerService.getTransportConnectors().get(0).getPublishableConnectString());
1:be0311b:             final PooledConnectionFactory cf = new PooledConnectionFactory();
1:be0311b:             cf.setConnectionFactory(amq);
1:be0311b:             cf.setMaxConnections(numConnections);
1:be0311b:             cf.setCreateConnectionOnStartup(createOnStart);
1:736ffc9:             cf.start();
1:be0311b: 
1:9ef4259:             final ConcurrentMap<ConnectionId, Connection> connections = new ConcurrentHashMap<ConnectionId, Connection>();
1:736ffc9:             final ExecutorService executor = Executors.newFixedThreadPool(numConnections);
1:be0311b: 
1:be0311b:             for (int i = 0; i < numConnections; ++i) {
1:be0311b:                 executor.execute(new Runnable() {
1:736ffc9: 
1:be0311b:                     @Override
1:be0311b:                     public void run() {
1:be0311b:                         try {
1:be0311b:                             PooledConnection pooled = (PooledConnection) cf.createConnection();
1:be0311b:                             ActiveMQConnection amq = (ActiveMQConnection) pooled.getConnection();
1:be0311b:                             connections.put(amq.getConnectionInfo().getConnectionId(), pooled);
1:be0311b:                         } catch (JMSException e) {
1:be0311b:                         }
1:be0311b:                     }
1:be0311b:                 });
1:be0311b:             }
1:be0311b: 
1:be0311b:             executor.shutdown();
1:77713d9:             assertTrue(executor.awaitTermination(30, TimeUnit.SECONDS));
1:be0311b: 
1:736ffc9:             assertEquals("Should have all unique connections", numConnections, connections.size());
1:736ffc9: 
1:be0311b:             connections.clear();
1:be0311b:             cf.stop();
1:736ffc9: 
1:736ffc9:         } finally {
1:736ffc9:             brokerService.stop();
1:be0311b:         }
1:736ffc9:     }
1:736ffc9: 
1:5ac1540:     /**
1:a59c9ba:      * Tests the behavior of the sessionPool of the PooledConnectionFactory when
1:a59c9ba:      * maximum number of sessions are reached.
1:5ac1540:      */
1:e6597c4:     @Test(timeout = 60000)
1:e6597c4:     public void testCreateSessionDoesNotBlockWhenNotConfiguredTo() throws Exception {
1:5ac1540:         // using separate thread for testing so that we can interrupt the test
1:5ac1540:         // if the call to get a new session blocks.
1:5ac1540: 
1:5ac1540:         // start test runner thread
1:5ac1540:         ExecutorService executor = Executors.newSingleThreadExecutor();
1:e6597c4:         final Future<Boolean> result = executor.submit(new TestRunner());
1:5ac1540: 
1:e6597c4:         boolean testPassed = Wait.waitFor(new Wait.Condition() {
1:5ac1540: 
1:e6597c4:             @Override
1:e6597c4:             public boolean isSatisified() throws Exception {
1:e6597c4:                 return result.isDone() && result.get().booleanValue();
1:e6597c4:             }
1:e6597c4:         }, TimeUnit.SECONDS.toMillis(10), TimeUnit.MILLISECONDS.toMillis(50));
1:e6597c4: 
1:e6597c4:         if (!testPassed) {
1:1b38caa:             PooledConnectionFactoryTest.LOG.error("2nd call to createSession() " +
1:1b38caa:                                                   "is blocking but should have returned an error instead.");
1:5ac1540:             executor.shutdownNow();
1:1b38caa:             fail("SessionPool inside PooledConnectionFactory is blocking if " +
1:1b38caa:                  "limit is exceeded but should return an exception instead.");
1:736ffc9:         }
1:a59c9ba:     }
1:5ac1540: 
1:a59c9ba:     static class TestRunner implements Callable<Boolean> {
1:5ac1540: 
1:a59c9ba:         public final static Logger LOG = Logger.getLogger(TestRunner.class);
1:5ac1540: 
1:a59c9ba:         /**
1:a59c9ba:          * @return true if test succeeded, false otherwise
1:a59c9ba:          */
1:736ffc9:         @Override
1:a59c9ba:         public Boolean call() {
1:5ac1540: 
1:a59c9ba:             Connection conn = null;
1:a59c9ba:             Session one = null;
1:5ac1540: 
1:27ce49f:             PooledConnectionFactory cf = null;
1:27ce49f: 
1:a59c9ba:             // wait at most 5 seconds for the call to createSession
1:736ffc9:             try {
1:e6597c4:                 ActiveMQConnectionFactory amq = new ActiveMQConnectionFactory(
1:e6597c4:                     "vm://broker1?marshal=false&broker.persistent=false&broker.useJmx=false");
1:27ce49f:                 cf = new PooledConnectionFactory();
1:b66559e:                 cf.setConnectionFactory(amq);
1:a59c9ba:                 cf.setMaxConnections(3);
1:a59c9ba:                 cf.setMaximumActiveSessionPerConnection(1);
1:a59c9ba:                 cf.setBlockIfSessionPoolIsFull(false);
1:a59c9ba: 
1:a59c9ba:                 conn = cf.createConnection();
1:a59c9ba:                 one = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:a59c9ba: 
1:a59c9ba:                 Session two = null;
1:a59c9ba:                 try {
1:77713d9:                     // this should raise an exception as we called setMaximumActive(1)
1:a59c9ba:                     two = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:a59c9ba:                     two.close();
1:a59c9ba: 
1:a59c9ba:                     LOG.error("Expected JMSException wasn't thrown.");
1:1b38caa:                     fail("seconds call to Connection.createSession() was supposed" +
1:1b38caa:                          "to raise an JMSException as internal session pool" +
1:1b38caa:                          "is exhausted. This did not happen and indiates a problem");
3:5ac1540:                     return new Boolean(false);
1:a59c9ba:                 } catch (JMSException ex) {
1:a59c9ba:                     if (ex.getCause().getClass() == java.util.NoSuchElementException.class) {
1:a59c9ba:                         // expected, ignore but log
1:a59c9ba:                         LOG.info("Caught expected " + ex);
1:a59c9ba:                     } else {
1:a59c9ba:                         LOG.error(ex);
1:a59c9ba:                         return new Boolean(false);
1:a59c9ba:                     }
1:a59c9ba:                 } finally {
1:77713d9:                     if (one != null) {
1:a59c9ba:                         one.close();
1:77713d9:                     }
1:77713d9:                     if (conn != null) {
1:a59c9ba:                         conn.close();
1:77713d9:                     }
2:5ac1540:                 }
1:a59c9ba:             } catch (Exception ex) {
1:a59c9ba:                 LOG.error(ex.getMessage());
1:a59c9ba:                 return new Boolean(false);
1:27ce49f:             } finally {
1:27ce49f:                 if (cf != null) {
1:27ce49f:                     cf.stop();
1:27ce49f:                 }
1:a59c9ba:             }
1:a59c9ba: 
1:a59c9ba:             // all good, test succeeded
1:a59c9ba:             return new Boolean(true);
1:5ac1540:         }
1:5ac1540:     }
1:5ac1540: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:0706fd0
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertNull;
/////////////////////////////////////////////////////////////////////////
1:     public void testFactoryStopStart() throws Exception {
1: 
1:         ActiveMQConnectionFactory amq = new ActiveMQConnectionFactory(
1:             "vm://broker1?marshal=false&broker.persistent=false&broker.useJmx=false");
1:         PooledConnectionFactory cf = new PooledConnectionFactory();
1:         cf.setConnectionFactory(amq);
1:         cf.setMaxConnections(1);
1: 
1:         PooledConnection conn1 = (PooledConnection) cf.createConnection();
1: 
1:         cf.stop();
1: 
1:         assertNull(cf.createConnection());
1: 
1:         cf.start();
1: 
1:         PooledConnection conn2 = (PooledConnection) cf.createConnection();
1: 
1:         assertNotSame(conn1.getConnection(), conn2.getConnection());
1: 
1:         assertEquals(1, cf.getNumConnections());
1: 
1:         cf.stop();
1:     }
1: 
1:     @Test(timeout = 60000)
commit:27ce49f
/////////////////////////////////////////////////////////////////////////
1:         pcf.stop();
/////////////////////////////////////////////////////////////////////////
1: 
1:         cf.stop();
/////////////////////////////////////////////////////////////////////////
1: 
1:         cf.stop();
/////////////////////////////////////////////////////////////////////////
1: 
1:         cf.stop();
/////////////////////////////////////////////////////////////////////////
1: 
1:         cf.stop();
/////////////////////////////////////////////////////////////////////////
1:             PooledConnectionFactory cf = null;
1: 
1:                 cf = new PooledConnectionFactory();
/////////////////////////////////////////////////////////////////////////
1:             } finally {
1:                 if (cf != null) {
1:                     cf.stop();
1:                 }
commit:9ef4259
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentMap;
/////////////////////////////////////////////////////////////////////////
1:             final ConcurrentMap<ConnectionId, Connection> connections = new ConcurrentHashMap<ConnectionId, Connection>();
commit:e6597c4
/////////////////////////////////////////////////////////////////////////
1: public class PooledConnectionFactoryTest extends JmsPoolTestSupport {
1:     @Test(timeout = 60000)
1:     @Test(timeout = 60000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60000)
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("All connections should have been created.", Wait.waitFor(new Wait.Condition() {
1:         }, TimeUnit.SECONDS.toMillis(10), TimeUnit.MILLISECONDS.toMillis(50)));
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60000)
1:     @Test(timeout = 60000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60000)
1:     public void testCreateSessionDoesNotBlockWhenNotConfiguredTo() throws Exception {
1:         final Future<Boolean> result = executor.submit(new TestRunner());
1:         boolean testPassed = Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return result.isDone() && result.get().booleanValue();
1:             }
1:         }, TimeUnit.SECONDS.toMillis(10), TimeUnit.MILLISECONDS.toMillis(50));
1: 
1:         if (!testPassed) {
/////////////////////////////////////////////////////////////////////////
1:                 ActiveMQConnectionFactory amq = new ActiveMQConnectionFactory(
1:                     "vm://broker1?marshal=false&broker.persistent=false&broker.useJmx=false");
commit:1ee5108
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQConnectionFactory amq = new ActiveMQConnectionFactory(
1:             "vm://broker1?marshal=false&broker.persistent=false&broker.useJmx=false");
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQConnectionFactory amq = new ActiveMQConnectionFactory(
1:             "vm://broker1?marshal=false&broker.persistent=false&broker.useJmx=false");
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQConnectionFactory amq = new ActiveMQConnectionFactory(
1:             "vm://broker1?marshal=false&broker.persistent=false&broker.useJmx=false");
/////////////////////////////////////////////////////////////////////////
1:         final ActiveMQConnectionFactory amq = new ActiveMQConnectionFactory(
1:             "vm://broker1?marshal=false&broker.persistent=false&broker.useJmx=false");
/////////////////////////////////////////////////////////////////////////
1:         brokerService.setUseJmx(false);
commit:459593c
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.QueueConnectionFactory;
1: import javax.jms.TopicConnectionFactory;
/////////////////////////////////////////////////////////////////////////
1:     public void testInstanceOf() throws  Exception {
1:         PooledConnectionFactory pcf = new PooledConnectionFactory();
1:         assertTrue(pcf instanceof QueueConnectionFactory);
1:         assertTrue(pcf instanceof TopicConnectionFactory);
1:     }
1: 
0:     @Test
commit:878e3a1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:77713d9
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertNotSame;
1: import static org.junit.Assert.assertSame;
1: import static org.junit.Assert.assertTrue;
1: import static org.junit.Assert.fail;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.junit.Test;
/////////////////////////////////////////////////////////////////////////
0: public class PooledConnectionFactoryTest {
0:     @Test
/////////////////////////////////////////////////////////////////////////
0:     @Test
/////////////////////////////////////////////////////////////////////////
0:     @Test
/////////////////////////////////////////////////////////////////////////
0:     @Test
/////////////////////////////////////////////////////////////////////////
0:     @Test
/////////////////////////////////////////////////////////////////////////
1:         for (PooledConnection connection : connections) {
/////////////////////////////////////////////////////////////////////////
0:     @Test
0:     @Test
/////////////////////////////////////////////////////////////////////////
1:         brokerService.waitUntilStarted();
/////////////////////////////////////////////////////////////////////////
0:             final ConcurrentHashMap<ConnectionId, Connection> connections = new ConcurrentHashMap<ConnectionId, Connection>();
/////////////////////////////////////////////////////////////////////////
1:             assertTrue(executor.awaitTermination(30, TimeUnit.SECONDS));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     // this should raise an exception as we called setMaximumActive(1)
/////////////////////////////////////////////////////////////////////////
1:                     if (one != null) {
1:                     }
1:                     if (conn != null) {
1:                     }
commit:be0311b
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentHashMap;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.command.ConnectionId;
/////////////////////////////////////////////////////////////////////////
1:         cf.stop();
1:     }
1: 
1:     public void testConcurrentCreateGetsUniqueConnectionCreateOnDemand() throws Exception {
1:         doTestConcurrentCreateGetsUniqueConnection(false);
1:     }
1: 
1:     public void testConcurrentCreateGetsUniqueConnectionCreateOnStart() throws Exception {
1:         doTestConcurrentCreateGetsUniqueConnection(true);
1:     }
1: 
1:     private void doTestConcurrentCreateGetsUniqueConnection(boolean createOnStart) throws Exception {
1: 
0:         final int numConnections = 50;
1: 
0:         final ActiveMQConnectionFactory amq = new ActiveMQConnectionFactory("vm://broker1?marshal=false&broker.persistent=false");
1:         final PooledConnectionFactory cf = new PooledConnectionFactory();
1:         cf.setConnectionFactory(amq);
1:         cf.setMaxConnections(numConnections);
1:         cf.setCreateConnectionOnStartup(createOnStart);
1: 
0:         final ConcurrentHashMap<ConnectionId, Connection> connections =
0:             new ConcurrentHashMap<ConnectionId, Connection>();
0:         final ExecutorService executor = Executors.newFixedThreadPool(numConnections / 2);
1: 
1:         for (int i = 0; i < numConnections; ++i) {
1:             executor.execute(new Runnable() {
1: 
1:                 @Override
1:                 public void run() {
1:                     try {
1:                         PooledConnection pooled = (PooledConnection) cf.createConnection();
1:                         ActiveMQConnection amq = (ActiveMQConnection) pooled.getConnection();
1:                         connections.put(amq.getConnectionInfo().getConnectionId(), pooled);
1:                     } catch (JMSException e) {
1:                     }
1:                 }
1:             });
1:         }
1: 
0:         assertTrue("Should have all unique connections", Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return connections.size() == numConnections;
1:             }
0:         }));
1: 
1:         executor.shutdown();
1:         assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS));
1:         connections.clear();
1:         cf.stop();
author:gtully
-------------------------------------------------------------------------------
commit:736ffc9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.BrokerService;
0: import org.junit.Ignore;
/////////////////////////////////////////////////////////////////////////
0:     @Ignore("something up - don't know why the start call to createConnection does not cause close - but that does not fix it either!")
1:         BrokerService brokerService = new BrokerService();
1:         brokerService.setPersistent(false);
1:         brokerService.addConnector("tcp://localhost:0");
1:         brokerService.start();
1:         try {
1:             final int numConnections = 2;
1:             final ActiveMQConnectionFactory amq = new ActiveMQConnectionFactory(brokerService.getTransportConnectors().get(0).getPublishableConnectString());
1:             final PooledConnectionFactory cf = new PooledConnectionFactory();
1:             cf.setConnectionFactory(amq);
0:             cf.setMaxConnections(numConnections);
0:             cf.setCreateConnectionOnStartup(createOnStart);
1:             cf.start();
0:             final ConcurrentHashMap<ConnectionId, Connection> connections =
0:                     new ConcurrentHashMap<ConnectionId, Connection>();
1:             final ExecutorService executor = Executors.newFixedThreadPool(numConnections);
1:             for (int i = 0; i < numConnections; ++i) {
1:                 executor.execute(new Runnable() {
1: 
1:                     @Override
1:                     public void run() {
1:                         try {
0:                             PooledConnection pooled = (PooledConnection) cf.createConnection();
0:                             ActiveMQConnection amq = (ActiveMQConnection) pooled.getConnection();
0:                             connections.put(amq.getConnectionInfo().getConnectionId(), pooled);
1:                         } catch (JMSException e) {
1:                         }
1:                 });
1:             executor.shutdown();
0:             assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS));
1: 
1:             assertEquals("Should have all unique connections", numConnections, connections.size());
1: 
1:             connections.clear();
0:             cf.stop();
1: 
1:         } finally {
1:             brokerService.stop();
1:         }
commit:b66559e
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.jms.pool;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         PooledConnectionFactory cf = new PooledConnectionFactory();
1:         cf.setConnectionFactory(amq);
/////////////////////////////////////////////////////////////////////////
1:         PooledConnectionFactory cf = new PooledConnectionFactory();
1:         cf.setConnectionFactory(amq);
/////////////////////////////////////////////////////////////////////////
1:         PooledConnectionFactory cf = new PooledConnectionFactory();
1:         cf.setConnectionFactory(amq);
1:         Connection previous = null;
/////////////////////////////////////////////////////////////////////////
1:             Connection current = ((PooledConnection) cf.createConnection()).getConnection();
/////////////////////////////////////////////////////////////////////////
1:         PooledConnectionFactory cf = new PooledConnectionFactory();
1:         cf.setConnectionFactory(amq);
/////////////////////////////////////////////////////////////////////////
0:         final PooledConnectionFactory cf = new PooledConnectionFactory();
1:         cf.setConnectionFactory(amq);
/////////////////////////////////////////////////////////////////////////
0:                 PooledConnectionFactory cf = new PooledConnectionFactory();
0:                 cf.setConnectionFactory(amq);
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:1b38caa
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         Future<Boolean> result = executor.submit(new TestRunner());
1:             PooledConnectionFactoryTest.LOG.error("2nd call to createSession() " +
1:                                                   "is blocking but should have returned an error instead.");
1:             fail("SessionPool inside PooledConnectionFactory is blocking if " +
1:                  "limit is exceeded but should return an exception instead.");
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:                     fail("seconds call to Connection.createSession() was supposed" +
1:                          "to raise an JMSException as internal session pool" +
1:                          "is exhausted. This did not happen and indiates a problem");
/////////////////////////////////////////////////////////////////////////
commit:a59c9ba
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.Callable;
1: import java.util.concurrent.ConcurrentLinkedQueue;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.Future;
1: import java.util.concurrent.TimeUnit;
0: import junit.framework.Assert;
0: import junit.framework.Test;
0: import junit.framework.TestCase;
0: import junit.framework.TestSuite;
1: 
0: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.util.Wait;
1: import org.apache.log4j.Logger;
1:  * Checks the behavior of the PooledConnectionFactory when the maximum amount of
1:  * sessions is being reached.
1:  * Older versions simply block in the call to Connection.getSession(), which
1:  * isn't good. An exception being returned is the better option, so JMS clients
1:  * don't block. This test succeeds if an exception is returned and fails if the
1:  * call to getSession() blocks.
0: public class PooledConnectionFactoryTest extends TestCase {
1:     public final static Logger LOG = Logger.getLogger(PooledConnectionFactoryTest.class);
0:      * @param testName
0:      *            name of the test case
0:     public PooledConnectionFactoryTest(String testName) {
0:         super(testName);
0:     public static Test suite() {
0:         return new TestSuite(PooledConnectionFactoryTest.class);
1:     }
1: 
1:     public void testClearAllConnections() throws Exception {
1: 
1:         ActiveMQConnectionFactory amq = new ActiveMQConnectionFactory("vm://broker1?marshal=false&broker.persistent=false");
0:         PooledConnectionFactory cf = new PooledConnectionFactory(amq);
1:         cf.setMaxConnections(3);
1: 
1:         PooledConnection conn1 = (PooledConnection) cf.createConnection();
1:         PooledConnection conn2 = (PooledConnection) cf.createConnection();
1:         PooledConnection conn3 = (PooledConnection) cf.createConnection();
1: 
1:         assertNotSame(conn1.getConnection(), conn2.getConnection());
1:         assertNotSame(conn1.getConnection(), conn3.getConnection());
1:         assertNotSame(conn2.getConnection(), conn3.getConnection());
1: 
1:         assertEquals(3, cf.getNumConnections());
1: 
1:         cf.clear();
1: 
1:         assertEquals(0, cf.getNumConnections());
1: 
1:         conn1 = (PooledConnection) cf.createConnection();
1:         conn2 = (PooledConnection) cf.createConnection();
1:         conn3 = (PooledConnection) cf.createConnection();
1: 
1:         assertNotSame(conn1.getConnection(), conn2.getConnection());
1:         assertNotSame(conn1.getConnection(), conn3.getConnection());
1:         assertNotSame(conn2.getConnection(), conn3.getConnection());
1:     }
1: 
1:     public void testMaxConnectionsAreCreated() throws Exception {
1: 
1:         ActiveMQConnectionFactory amq = new ActiveMQConnectionFactory("vm://broker1?marshal=false&broker.persistent=false");
0:         PooledConnectionFactory cf = new PooledConnectionFactory(amq);
1:         cf.setMaxConnections(3);
1: 
1:         PooledConnection conn1 = (PooledConnection) cf.createConnection();
1:         PooledConnection conn2 = (PooledConnection) cf.createConnection();
1:         PooledConnection conn3 = (PooledConnection) cf.createConnection();
1: 
1:         assertNotSame(conn1.getConnection(), conn2.getConnection());
1:         assertNotSame(conn1.getConnection(), conn3.getConnection());
1:         assertNotSame(conn2.getConnection(), conn3.getConnection());
1: 
1:         assertEquals(3, cf.getNumConnections());
1:     }
1: 
1:     public void testConnectionsAreRotated() throws Exception {
1: 
1:         ActiveMQConnectionFactory amq = new ActiveMQConnectionFactory("vm://broker1?marshal=false&broker.persistent=false");
0:         PooledConnectionFactory cf = new PooledConnectionFactory(amq);
1:         cf.setMaxConnections(10);
1: 
0:         ActiveMQConnection previous = null;
1: 
1:         // Front load the pool.
1:         for (int i = 0; i < 10; ++i) {
1:             cf.createConnection();
1:         }
1: 
1:         for (int i = 0; i < 100; ++i) {
0:             ActiveMQConnection current = ((PooledConnection) cf.createConnection()).getConnection();
1:             assertNotSame(previous, current);
1:             previous = current;
1:         }
1:     }
1: 
1:     public void testConnectionsArePooled() throws Exception {
1: 
1:         ActiveMQConnectionFactory amq = new ActiveMQConnectionFactory("vm://broker1?marshal=false&broker.persistent=false");
0:         PooledConnectionFactory cf = new PooledConnectionFactory(amq);
1:         cf.setMaxConnections(1);
1: 
1:         PooledConnection conn1 = (PooledConnection) cf.createConnection();
1:         PooledConnection conn2 = (PooledConnection) cf.createConnection();
1:         PooledConnection conn3 = (PooledConnection) cf.createConnection();
1: 
1:         assertSame(conn1.getConnection(), conn2.getConnection());
1:         assertSame(conn1.getConnection(), conn3.getConnection());
1:         assertSame(conn2.getConnection(), conn3.getConnection());
1: 
1:         assertEquals(1, cf.getNumConnections());
1:     }
1: 
1:     public void testConnectionsArePooledAsyncCreate() throws Exception {
1: 
0:         final ActiveMQConnectionFactory amq = new ActiveMQConnectionFactory("vm://broker1?marshal=false&broker.persistent=false");
0:         final PooledConnectionFactory cf = new PooledConnectionFactory(amq);
1:         cf.setMaxConnections(1);
1: 
1:         final ConcurrentLinkedQueue<PooledConnection> connections = new ConcurrentLinkedQueue<PooledConnection>();
1: 
1:         final PooledConnection primary = (PooledConnection) cf.createConnection();
1:         final ExecutorService executor = Executors.newFixedThreadPool(10);
1:         final int numConnections = 100;
1: 
0:         for (int i = 0; i < numConnections; ++i) {
0:             executor.execute(new Runnable() {
1: 
0:                 @Override
0:                 public void run() {
1:                     try {
1:                         connections.add((PooledConnection) cf.createConnection());
0:                     } catch (JMSException e) {
1:                     }
1:                 }
0:             });
1:         }
1: 
0:         assertTrue("", Wait.waitFor(new Wait.Condition() {
1: 
0:             @Override
0:             public boolean isSatisified() throws Exception {
0:                 return connections.size() == numConnections;
1:             }
0:         }));
1: 
0:         executor.shutdown();
0:         assertTrue(executor.awaitTermination(5, TimeUnit.SECONDS));
1: 
0:         for(PooledConnection connection : connections) {
1:             assertSame(primary.getConnection(), connection.getConnection());
1:         }
1: 
0:         connections.clear();
1:      * Tests the behavior of the sessionPool of the PooledConnectionFactory when
1:      * maximum number of sessions are reached.
0:     public void testApp() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:         Thread.sleep(5 * 1000);
0:             PooledConnectionFactoryTest.LOG.error("2nd call to createSession()" + " is blocking but should have returned an error instead.");
0:             Assert.fail("SessionPool inside PooledConnectionFactory is blocking if " + "limit is exceeded but should return an exception instead.");
1:     static class TestRunner implements Callable<Boolean> {
1:         public final static Logger LOG = Logger.getLogger(TestRunner.class);
1:         /**
1:          * @return true if test succeeded, false otherwise
1:          */
1:         public Boolean call() {
1:             Connection conn = null;
1:             Session one = null;
1:             // wait at most 5 seconds for the call to createSession
0:                 ActiveMQConnectionFactory amq = new ActiveMQConnectionFactory("vm://broker1?marshal=false&broker.persistent=false");
0:                 PooledConnectionFactory cf = new PooledConnectionFactory(amq);
1:                 cf.setMaxConnections(3);
1:                 cf.setMaximumActiveSessionPerConnection(1);
1:                 cf.setBlockIfSessionPoolIsFull(false);
1:                 conn = cf.createConnection();
1:                 one = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:                 Session two = null;
1:                 try {
0:                     // this should raise an exception as we called
0:                     // setMaximumActive(1)
1:                     two = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:                     two.close();
1: 
1:                     LOG.error("Expected JMSException wasn't thrown.");
0:                     Assert.fail("seconds call to Connection.createSession() was supposed" + "to raise an JMSException as internal session pool"
0:                             + "is exhausted. This did not happen and indiates a problem");
1:                 } catch (JMSException ex) {
1:                     if (ex.getCause().getClass() == java.util.NoSuchElementException.class) {
1:                         // expected, ignore but log
1:                         LOG.info("Caught expected " + ex);
1:                     } else {
1:                         LOG.error(ex);
1:                         return new Boolean(false);
1:                     }
1:                 } finally {
0:                     if (one != null)
1:                         one.close();
0:                     if (conn != null)
1:                         conn.close();
1:             } catch (Exception ex) {
1:                 LOG.error(ex.getMessage());
1:                 return new Boolean(false);
1:             // all good, test succeeded
1:             return new Boolean(true);
1:         }
1: 
1: 
commit:5ac1540
/////////////////////////////////////////////////////////////////////////
0:  * of sessions is being reached.
0:  * This test succeeds if an exception is returned and fails if the call to getSession()
1:  *
0:     public final static Logger LOG = Logger.getLogger(PooledConnectionFactoryTest.class);
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:      * Tests the behavior of the sessionPool of the PooledConnectionFactory
0:      * when maximum number of sessions are reached.
0:     {
1:         // using separate thread for testing so that we can interrupt the test
1:         // if the call to get a new session blocks.
1:         // start test runner thread
1:         ExecutorService executor = Executors.newSingleThreadExecutor();
0:         Future<Boolean> result = (Future<Boolean>) executor.submit(new TestRunner());
0:         // test should not take > 5secs, so test fails i
0:         Thread.sleep(5*1000);
1: 
0:         if (!result.isDone() || !result.get().booleanValue()) {
0:             PooledConnectionFactoryTest.LOG.error("2nd call to createSession()" +
0:             " is blocking but should have returned an error instead.");
1: 
1:             executor.shutdownNow();
1: 
0:             Assert.fail("SessionPool inside PooledConnectionFactory is blocking if " +
0:             "limit is exceeded but should return an exception instead.");
1:         }
1: 
0:     public final static Logger LOG = Logger.getLogger(TestRunner.class);
1: 
1:     /**
0:      * @return true if test succeeded, false otherwise
1:      */
0:     public Boolean call() {
1: 
0:         Connection conn = null;
0:         Session one = null;
1: 
0:         // wait at most 5 seconds for the call to createSession
0:         try {
0:             ActiveMQConnectionFactory amq = new ActiveMQConnectionFactory("vm://broker1?marshal=false&broker.persistent=false");
0:             PooledConnectionFactory cf = new PooledConnectionFactory(amq);
0:             cf.setMaxConnections(3);
0:             cf.setMaximumActive(1);
0:             cf.setBlockIfSessionPoolIsFull(false);
1: 
0:             conn = cf.createConnection();
0:             one = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
0:             Session two = null;
0:             try {
0:                 // this should raise an exception as we called setMaximumActive(1)
0:                 two = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:                 two.close();
1: 
0:                 LOG.error("Expected JMSException wasn't thrown.");
0:                 Assert.fail("seconds call to Connection.createSession() was supposed" +
0:                         "to raise an JMSException as internal session pool" +
0:                         "is exhausted. This did not happen and indiates a problem");
1:                 return new Boolean(false);
0:             } catch (JMSException ex) {
0:                 if (ex.getCause().getClass() == java.util.NoSuchElementException.class) {
0:                     //expected, ignore but log
0:                     LOG.info("Caught expected " + ex);
0:                 } else {
0:                     LOG.error(ex);
1:                     return new Boolean(false);
1:                 }
0:             } finally {
0:                 if (one != null)
0:                     one.close();
0:                 if (conn != null)
0:                     conn.close();
1:             }
0:         } catch (Exception ex) {
0:             LOG.error(ex.getMessage());
1:             return new Boolean(false);
1:         }
1: 
0:         // all good, test succeeded
0:         return new Boolean(true);
1:     }
commit:cf914d1
/////////////////////////////////////////////////////////////////////////
0: package org.apache.activemq.pool;
0: 
0: import java.util.concurrent.Callable;
0: import java.util.concurrent.ExecutorService;
0: import java.util.concurrent.Executors;
0: import java.util.concurrent.Future;
0: 
0: import junit.framework.Assert;
0: import junit.framework.Test;
0: import junit.framework.TestCase;
0: import junit.framework.TestSuite;
0: 
1: import javax.jms.Connection;
1: import javax.jms.JMSException;
1: import javax.jms.Session;
0: 
0: import org.apache.activemq.pool.PooledConnectionFactory;
0: import org.apache.activemq.ActiveMQConnectionFactory;
0: 
0: import org.apache.log4j.Logger;
0: 
0: 
1: /**
0:  * Checks the behavior of the PooledConnectionFactory when the maximum amount
0:  * of sessions is being reached. 
0:  * Older versions simply block in the call to Connection.getSession(), which isn't good.
0:  * An exception being returned is the better option, so JMS clients don't block.
0:  * This test succeeds if an exception is returned and fails if the call to getSession() 
0:  * blocks.
1:  * 
1:  */
0: public class PooledConnectionFactoryTest extends TestCase
0: {
0: 	public final static Logger LOG = Logger.getLogger(PooledConnectionFactoryTest.class);
0: 	
0: 	
1:     /**
0:      * Create the test case
1:      *
0:      * @param testName name of the test case
1:      */
0:     public PooledConnectionFactoryTest( String testName )
0:     {
0:         super( testName );
0:     }
0: 
1:     /**
0:      * @return the suite of tests being tested
1:      */
0:     public static Test suite()
0:     {
0:         return new TestSuite( PooledConnectionFactoryTest.class );
0:     }
0: 
1:     /**
0:      * Tests the behavior of the sessionPool of the PooledConnectionFactory 
0:      * when maximum number of sessions are reached. In older versions the call to
0:      * Connection.createSession() would simply block indefinitely if the maximum
0:      * number of sessions got reached (controled by 
0:      * PooledConnectionFactory.setMaximumActive()).
0:      * Rather than blocking the entire thread, it should raise an exception 
0:      * instead.
1:      */
0:     public void testApp() throws Exception
0:     {	
0:     	// using separate thread for testing so that we can interrupt the test
0:     	// if the call to get a new session blocks.
0:     	
0:     	// start test runner thread
0:     	ExecutorService executor = Executors.newSingleThreadExecutor();
0:     	Future<Boolean> result = (Future<Boolean>) executor.submit(new TestRunner());
0:     	
0:     	// test should not take > 5secs, so test fails i
0:     	Thread.sleep(5*1000);
0:     	
0:     	if (!result.isDone() || !result.get().booleanValue()) {
0:     		PooledConnectionFactoryTest.LOG.error("2nd call to createSession()" +
0: 			" is blocking but should have returned an error instead.");
0: 
0:     		executor.shutdownNow();
0: 
0:     		Assert.fail("SessionPool inside PooledConnectionFactory is blocking if " +
0: 			"limit is exceeded but should return an exception instead.");		
0:     	}
0:     }
0: }
0: 
0: class TestRunner implements Callable<Boolean> {
0: 	
0: 	public final static Logger LOG = Logger.getLogger(TestRunner.class);
0: 	
1: 	/**
0: 	 * @return true if test succeeded, false otherwise
1: 	 */
0: 	public Boolean call() {
0: 		
0: 		Connection conn = null;
0: 		Session one = null;
0: 		
0: 		// wait at most 5 seconds for the call to createSession
0: 		try {
0: 			ActiveMQConnectionFactory amq = new ActiveMQConnectionFactory("vm://broker1?marshal=false&broker.persistent=false");
0: 	        PooledConnectionFactory cf = new PooledConnectionFactory(amq);
0: 	        cf.setMaxConnections(3);
0: 	        cf.setMaximumActive(1);
0: 	        
0: 	        // default should be false already but lets make sure a change to the default
0: 	        // setting does not make this test fail.
0: 	        cf.setBlockIfSessionPoolIsFull(false);
0: 	        
0: 	        conn = cf.createConnection();
0: 	        one = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 	    	
0: 	        Session two = null;
0: 	        try {
0: 	        	// this should raise an exception as we called setMaximumActive(1)
0: 	        	two = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 	        	two.close();
0: 	        	
0: 	        	LOG.error("Expected JMSException wasn't thrown.");
0: 	        	Assert.fail("seconds call to Connection.createSession() was supposed" +
0: 	        			"to raise an JMSException as internal session pool" +
0: 	        			"is exhausted. This did not happen and indiates a problem");
0: 	        	return new Boolean(false);
0: 	        } catch (JMSException ex) {
0: 	        	if (ex.getCause().getClass() == java.util.NoSuchElementException.class) {
0: 		        	//expected, ignore but log
0: 		        	LOG.info("Caught expected " + ex);
0: 	        	} else {
0: 	        		LOG.error(ex);
0: 	        		return new Boolean(false);
0: 	        	}
0: 	        } finally {
0: 	        	if (one != null)
0: 	        		one.close();
0: 	        	if (conn != null)
0: 	        		conn.close();
0: 	        } 
0: 		} catch (Exception ex) {
0: 			LOG.error(ex.getMessage());
0: 			return new Boolean(false);
0: 		} 
0: 		
0: 		// all good, test succeeded
0: 		return new Boolean(true);
0: 	}
0: }
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:dd2556b
/////////////////////////////////////////////////////////////////////////
0:             cf.setMaximumActiveSessionPerConnection(1);
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:974f689
/////////////////////////////////////////////////////////////////////////
0: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
0:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
0: import org.apache.activemq.ActiveMQConnectionFactory;
0: import org.apache.log4j.Logger;
0: import java.util.concurrent.Callable;
0: import java.util.concurrent.ExecutorService;
0: import java.util.concurrent.Executors;
0: import java.util.concurrent.Future;
============================================================================