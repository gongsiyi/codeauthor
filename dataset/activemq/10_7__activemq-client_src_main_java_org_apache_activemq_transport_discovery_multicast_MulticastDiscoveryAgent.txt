6:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
5:d29ca2a:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:d29ca2a:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
6:d29ca2a:  */
1:af5d8d1: 
1:d29ca2a: package org.apache.activemq.transport.discovery.multicast;
1:7c94a73: 
1:d29ca2a: import java.io.IOException;
1:d29ca2a: import java.net.DatagramPacket;
1:d29ca2a: import java.net.InetAddress;
1:d29ca2a: import java.net.InetSocketAddress;
1:f4eade2: import java.net.InterfaceAddress;
1:d29ca2a: import java.net.MulticastSocket;
1:673fee1: import java.net.NetworkInterface;
1:d29ca2a: import java.net.SocketAddress;
1:f4eade2: import java.net.SocketException;
1:d29ca2a: import java.net.SocketTimeoutException;
1:d29ca2a: import java.net.URI;
1:f4eade2: import java.util.ArrayList;
1:f4eade2: import java.util.Enumeration;
1:d29ca2a: import java.util.Iterator;
1:f4eade2: import java.util.List;
1:d29ca2a: import java.util.Map;
1:86cbdfd: import java.util.concurrent.ConcurrentHashMap;
1:bd1b10c: import java.util.concurrent.ExecutorService;
1:86cbdfd: import java.util.concurrent.LinkedBlockingQueue;
1:86cbdfd: import java.util.concurrent.ThreadFactory;
1:86cbdfd: import java.util.concurrent.ThreadPoolExecutor;
1:86cbdfd: import java.util.concurrent.TimeUnit;
1:86cbdfd: import java.util.concurrent.atomic.AtomicBoolean;
1:74a7a8b: 
1:74a7a8b: import org.apache.activemq.command.DiscoveryEvent;
1:74a7a8b: import org.apache.activemq.transport.discovery.DiscoveryAgent;
1:74a7a8b: import org.apache.activemq.transport.discovery.DiscoveryListener;
1:6c1676b: import org.apache.activemq.util.ThreadPoolUtils;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:230a86c: 
1:d29ca2a: /**
1:230a86c:  * A {@link DiscoveryAgent} using a multicast address and heartbeat packets
1:230a86c:  * encoded using any wireformat, but openwire by default.
1:b0c2a40:  * 
1:d29ca2a:  * 
1:d29ca2a:  */
1:230a86c: public class MulticastDiscoveryAgent implements DiscoveryAgent, Runnable {
1:933eb2f: 
1:230a86c:     public static final String DEFAULT_DISCOVERY_URI_STRING = "multicast://239.255.2.3:6155";
1:78aac70:     public static final String DEFAULT_HOST_STR = "default"; 
1:8e06b20:     public static final String DEFAULT_HOST_IP  = System.getProperty("activemq.partition.discovery", "239.255.2.3"); 
1:78aac70:     public static final int    DEFAULT_PORT  = 6155; 
1:673fee1:         
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(MulticastDiscoveryAgent.class);
1:230a86c:     private static final String TYPE_SUFFIX = "ActiveMQ-4.";
1:230a86c:     private static final String ALIVE = "alive.";
1:230a86c:     private static final String DEAD = "dead.";
1:d29ca2a:     private static final String DELIMITER = "%";
1:230a86c:     private static final int BUFF_SIZE = 8192;
1:230a86c:     private static final int DEFAULT_IDLE_TIME = 500;
1:230a86c:     private static final int HEARTBEAT_MISS_BEFORE_DEATH = 10;
1:230a86c: 
1:230a86c:     private long initialReconnectDelay = 1000 * 5;
1:7c94a73:     private long maxReconnectDelay = 1000 * 30;
1:7c94a73:     private long backOffMultiplier = 2;
1:933eb2f:     private boolean useExponentialBackOff;
1:7c94a73:     private int maxReconnectAttempts;
1:230a86c: 
1:673fee1:     private int timeToLive = 1;
1:673fee1:     private boolean loopBackMode;
1:673fee1:     private Map<String, RemoteBrokerData> brokersByService = new ConcurrentHashMap<String, RemoteBrokerData>();
1:673fee1:     private String group = "default";
1:673fee1:     private URI discoveryURI;
1:673fee1:     private InetAddress inetAddress;
1:673fee1:     private SocketAddress sockAddress;
1:673fee1:     private DiscoveryListener discoveryListener;
1:673fee1:     private String selfService;
1:673fee1:     private MulticastSocket mcast;
1:673fee1:     private Thread runner;
1:673fee1:     private long keepAliveInterval = DEFAULT_IDLE_TIME;
1:673fee1:     private String mcInterface;
1:673fee1:     private String mcNetworkInterface;
1:af5d8d1:     private String mcJoinNetworkInterface;
1:673fee1:     private long lastAdvertizeTime;
1:673fee1:     private AtomicBoolean started = new AtomicBoolean(false);
1:673fee1:     private boolean reportAdvertizeFailed = true;
1:673fee1:     private ExecutorService executor = null;
1:673fee1: 
1:e5d616d:     class RemoteBrokerData extends DiscoveryEvent {
1:230a86c:         long lastHeartBeat;
1:230a86c:         long recoveryTime;
1:230a86c:         int failureCount;
1:230a86c:         boolean failed;
1:230a86c: 
1:230a86c:         public RemoteBrokerData(String brokerName, String service) {
1:e5d616d:             super(service);
1:e5d616d:             setBrokerName(brokerName);
1:230a86c:             this.lastHeartBeat = System.currentTimeMillis();
1:fc00993:         }
1:230a86c: 
1:fc00993:         public synchronized void updateHeartBeat() {
1:230a86c:             lastHeartBeat = System.currentTimeMillis();
1:230a86c: 
1:230a86c:             // Consider that the broker recovery has succeeded if it has not
1:230a86c:             // failed in 60 seconds.
1:230a86c:             if (!failed && failureCount > 0 && (lastHeartBeat - recoveryTime) > 1000 * 60) {
1:fc00993:                 if (LOG.isDebugEnabled()) {
1:e5d616d:                     LOG.debug("I now think that the " + serviceName + " service has recovered.");
1:fc00993:                 }
1:230a86c:                 failureCount = 0;
1:230a86c:                 recoveryTime = 0;
1:230a86c:             }
1:230a86c:         }
1:7c94a73: 
1:fc00993:         public synchronized long getLastHeartBeat() {
1:230a86c:             return lastHeartBeat;
1:230a86c:         }
1:7c94a73: 
1:fc00993:         public synchronized boolean markFailed() {
1:230a86c:             if (!failed) {
1:230a86c:                 failed = true;
1:230a86c:                 failureCount++;
1:7c94a73: 
1:230a86c:                 long reconnectDelay;
1:230a86c:                 if (!useExponentialBackOff) {
1:230a86c:                     reconnectDelay = initialReconnectDelay;
1:230a86c:                 } else {
1:230a86c:                     reconnectDelay = (long)Math.pow(backOffMultiplier, failureCount);
1:fc00993:                     if (reconnectDelay > maxReconnectDelay) {
1:230a86c:                         reconnectDelay = maxReconnectDelay;
1:fc00993:                     }
1:230a86c:                 }
1:7c94a73: 
1:fc00993:                 if (LOG.isDebugEnabled()) {
1:e5d616d:                     LOG.debug("Remote failure of " + serviceName + " while still receiving multicast advertisements.  Advertising events will be suppressed for " + reconnectDelay
1:fc00993:                               + " ms, the current failure count is: " + failureCount);
1:fc00993:                 }
1:7c94a73: 
1:230a86c:                 recoveryTime = System.currentTimeMillis() + reconnectDelay;
1:230a86c:                 return true;
1:230a86c:             }
1:230a86c:             return false;
1:230a86c:         }
1:7c94a73: 
1:230a86c:         /**
1:230a86c:          * @return true if this broker is marked failed and it is now the right
1:230a86c:          *         time to start recovery.
1:230a86c:          */
1:fc00993:         public synchronized boolean doRecovery() {
1:fc00993:             if (!failed) {
1:230a86c:                 return false;
1:fc00993:             }
1:230a86c: 
1:230a86c:             // Are we done trying to recover this guy?
1:230a86c:             if (maxReconnectAttempts > 0 && failureCount > maxReconnectAttempts) {
1:fc00993:                 if (LOG.isDebugEnabled()) {
1:e5d616d:                     LOG.debug("Max reconnect attempts of the " + serviceName + " service has been reached.");
1:fc00993:                 }
1:230a86c:                 return false;
1:230a86c:             }
1:230a86c: 
1:230a86c:             // Is it not yet time?
1:fc00993:             if (System.currentTimeMillis() < recoveryTime) {
1:230a86c:                 return false;
1:fc00993:             }
1:230a86c: 
1:fc00993:             if (LOG.isDebugEnabled()) {
1:e5d616d:                 LOG.debug("Resuming event advertisement of the " + serviceName + " service.");
1:fc00993:             }
1:230a86c:             failed = false;
1:230a86c:             return true;
1:230a86c:         }
1:230a86c: 
1:230a86c:         public boolean isFailed() {
1:230a86c:             return failed;
1:230a86c:         }
1:230a86c:     }
1:230a86c: 
1:7c94a73:     /**
1:d29ca2a:      * Set the discovery listener
1:d29ca2a:      * 
1:d29ca2a:      * @param listener
1:7c94a73:      */
1:230a86c:     public void setDiscoveryListener(DiscoveryListener listener) {
1:230a86c:         this.discoveryListener = listener;
1:7c94a73:     }
1:230a86c: 
1:d29ca2a:     /**
1:d29ca2a:      * register a service
1:d29ca2a:      */
1:230a86c:     public void registerService(String name) throws IOException {
1:230a86c:         this.selfService = name;
1:230a86c:         if (started.get()) {
1:d29ca2a:             doAdvertizeSelf();
1:7c94a73:         }
1:7c94a73:     }
1:f4eade2: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the loopBackMode.
1:d29ca2a:      */
1:230a86c:     public boolean isLoopBackMode() {
1:d29ca2a:         return loopBackMode;
1:7c94a73:     }
1:7c94a73: 
1:d29ca2a:     /**
1:230a86c:      * @param loopBackMode The loopBackMode to set.
1:d29ca2a:      */
1:230a86c:     public void setLoopBackMode(boolean loopBackMode) {
1:230a86c:         this.loopBackMode = loopBackMode;
1:7c94a73:     }
1:7c94a73: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the timeToLive.
1:d29ca2a:      */
1:230a86c:     public int getTimeToLive() {
1:d29ca2a:         return timeToLive;
1:7c94a73:     }
1:7c94a73: 
1:d29ca2a:     /**
1:230a86c:      * @param timeToLive The timeToLive to set.
1:d29ca2a:      */
1:230a86c:     public void setTimeToLive(int timeToLive) {
1:230a86c:         this.timeToLive = timeToLive;
1:7c94a73:     }
1:7c94a73: 
1:d29ca2a:     /**
1:d29ca2a:      * @return the discoveryURI
1:d29ca2a:      */
1:230a86c:     public URI getDiscoveryURI() {
1:d29ca2a:         return discoveryURI;
1:7c94a73:     }
1:7c94a73: 
1:d29ca2a:     /**
1:d29ca2a:      * Set the discoveryURI
1:d29ca2a:      * 
1:d29ca2a:      * @param discoveryURI
1:d29ca2a:      */
1:230a86c:     public void setDiscoveryURI(URI discoveryURI) {
1:230a86c:         this.discoveryURI = discoveryURI;
1:7c94a73:     }
1:7c94a73: 
1:230a86c:     public long getKeepAliveInterval() {
1:d29ca2a:         return keepAliveInterval;
1:7c94a73:     }
1:7c94a73: 
1:230a86c:     public void setKeepAliveInterval(long keepAliveInterval) {
1:230a86c:         this.keepAliveInterval = keepAliveInterval;
1:7c94a73:     }
1:673fee1:     
1:673fee1:     public void setInterface(String mcInterface) {
1:673fee1:         this.mcInterface = mcInterface;
1:673fee1:     }
1:673fee1:     
1:673fee1:     public void setNetworkInterface(String mcNetworkInterface) {
1:673fee1:         this.mcNetworkInterface = mcNetworkInterface;    
1:673fee1:     }
1:673fee1:     
1:af5d8d1:     public void setJoinNetworkInterface(String mcJoinNetwrokInterface) {
1:af5d8d1:     	this.mcJoinNetworkInterface = mcJoinNetwrokInterface;
1:af5d8d1:     }
1:af5d8d1:     
1:d29ca2a:     /**
1:d29ca2a:      * start the discovery agent
1:d29ca2a:      * 
1:d29ca2a:      * @throws Exception
1:d29ca2a:      */
1:230a86c:     public void start() throws Exception {
1:7c94a73:     	
1:230a86c:         if (started.compareAndSet(false, true)) {        	
1:7c94a73:         	         	
1:230a86c:             if (group == null || group.length() == 0) {
1:d29ca2a:                 throw new IOException("You must specify a group to discover");
1:7c94a73:             }
1:230a86c:             String type = getType();
1:230a86c:             if (!type.endsWith(".")) {
1:fc00993:                 LOG.warn("The type '" + type + "' should end with '.' to be a valid Discovery type");
1:230a86c:                 type += ".";
1:d77e665:             }
1:7c94a73:             
1:230a86c:             if (discoveryURI == null) {
1:230a86c:                 discoveryURI = new URI(DEFAULT_DISCOVERY_URI_STRING);
48:d29ca2a:             }
1:7c94a73:             
1:78aac70:             if (LOG.isTraceEnabled()) 
1:78aac70:         	  	LOG.trace("start - discoveryURI = " + discoveryURI);        	  	        	  
1:7c94a73:         	  
1:78aac70:         	  String myHost = discoveryURI.getHost();
1:78aac70:         	  int    myPort = discoveryURI.getPort(); 
1:d77e665:         	     
1:78aac70:         	  if( DEFAULT_HOST_STR.equals(myHost) ) 
1:78aac70:         	  	myHost = DEFAULT_HOST_IP;       	      	  
1:d77e665:         	  
1:78aac70:         	  if(myPort < 0 )
1:78aac70:         	    myPort = DEFAULT_PORT;        	    
1:d77e665:         	  
1:78aac70:         	  if (LOG.isTraceEnabled()) {
2:78aac70:         	  	LOG.trace("start - myHost = " + myHost); 
1:78aac70:         	  	LOG.trace("start - myPort = " + myPort);   	
1:673fee1:         	  	LOG.trace("start - group  = " + group );		       	  	
1:673fee1:         	  	LOG.trace("start - interface  = " + mcInterface );
1:673fee1:         	  	LOG.trace("start - network interface  = " + mcNetworkInterface );
1:af5d8d1:         	  	LOG.trace("start - join network interface  = " + mcJoinNetworkInterface );
1:d29ca2a:         	  }	
1:d77e665:         	  
1:78aac70:             this.inetAddress = InetAddress.getByName(myHost);
1:78aac70:             this.sockAddress = new InetSocketAddress(this.inetAddress, myPort);
1:78aac70:             mcast = new MulticastSocket(myPort);
1:d29ca2a:             mcast.setLoopbackMode(loopBackMode);
1:d29ca2a:             mcast.setTimeToLive(getTimeToLive());
1:af5d8d1:             if (mcJoinNetworkInterface != null) {
1:af5d8d1:                 mcast.joinGroup(sockAddress, NetworkInterface.getByName(mcJoinNetworkInterface));
1:af5d8d1:             }
1:af5d8d1:             else {
1:f4eade2:                 mcast.setNetworkInterface(findNetworkInterface());
1:af5d8d1:             	mcast.joinGroup(inetAddress);
1:af5d8d1:             }
1:230a86c:             mcast.setSoTimeout((int)keepAliveInterval);
1:673fee1:             if (mcInterface != null) {
1:673fee1:                 mcast.setInterface(InetAddress.getByName(mcInterface));
1:673fee1:             }
1:673fee1:             if (mcNetworkInterface != null) {
1:673fee1:                 mcast.setNetworkInterface(NetworkInterface.getByName(mcNetworkInterface));
1:673fee1:             }
1:230a86c:             runner = new Thread(this);
1:6d1f57b:             runner.setName(this.toString() + ":" + runner.getName());
1:d29ca2a:             runner.setDaemon(true);
1:d29ca2a:             runner.start();
1:d29ca2a:             doAdvertizeSelf();
1:d29ca2a:         }
1:d29ca2a:     }
26:d29ca2a:     
1:f4eade2:     private NetworkInterface findNetworkInterface() throws SocketException {
1:f4eade2:         Enumeration<NetworkInterface> ifcs = NetworkInterface.getNetworkInterfaces();
1:f4eade2:         List<NetworkInterface> possibles = new ArrayList<NetworkInterface>();
1:f4eade2:         while (ifcs.hasMoreElements()) {
1:f4eade2:             NetworkInterface ni = ifcs.nextElement();
1:07338e7:             try {
1:07338e7:                 if (ni.supportsMulticast()
1:07338e7:                         && ni.isUp()) {
1:07338e7:                     for (InterfaceAddress ia : ni.getInterfaceAddresses()) {
1:daf7e85:                         if (ia != null && ia.getAddress() instanceof java.net.Inet4Address
1:07338e7:                                 && !ia.getAddress().isLoopbackAddress()
1:5cc5022:                                 && (ni.getDisplayName()==null || !ni.getDisplayName().startsWith("vnic"))) {
1:07338e7:                             possibles.add(ni);
1:07338e7:                         }
1:f4eade2:                     }
1:f4eade2:                 }
1:07338e7:             } catch (SocketException ignored) {}
1:f4eade2:         }
1:f4eade2:         return possibles.isEmpty() ? null : possibles.get(possibles.size() - 1);
1:f4eade2:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * stop the channel
1:d29ca2a:      * 
1:d29ca2a:      * @throws Exception
1:d29ca2a:      */
1:230a86c:     public void stop() throws Exception {
1:230a86c:         if (started.compareAndSet(true, false)) {
1:d29ca2a:             doAdvertizeSelf();
1:8469d75:             if (mcast != null) {
1:8469d75:                 mcast.close();
1:f4eade2:             }
1:c808beb:             if (runner != null) {
1:c808beb:                 runner.interrupt();
1:c808beb:             }
1:6c1676b:             if (executor != null) {
1:6c1676b:                 ThreadPoolUtils.shutdownNow(executor);
1:6c1676b:                 executor = null;
1:8469d75:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:230a86c:     public String getType() {
1:230a86c:         return group + "." + TYPE_SUFFIX;
1:d29ca2a:     }
1:d29ca2a: 
1:230a86c:     public void run() {
1:230a86c:         byte[] buf = new byte[BUFF_SIZE];
1:230a86c:         DatagramPacket packet = new DatagramPacket(buf, 0, buf.length);
1:230a86c:         while (started.get()) {
1:d29ca2a:             doTimeKeepingServices();
1:230a86c:             try {
1:d29ca2a:                 mcast.receive(packet);
1:230a86c:                 if (packet.getLength() > 0) {
1:230a86c:                     String str = new String(packet.getData(), packet.getOffset(), packet.getLength());
1:d29ca2a:                     processData(str);
1:7c94a73:                 }
1:230a86c:             } catch (SocketTimeoutException se) {
1:d29ca2a:                 // ignore
1:230a86c:             } catch (IOException e) {
1:230a86c:                 if (started.get()) {
1:fc00993:                     LOG.error("failed to process packet: " + e);
1:230a86c:                 }
1:7c94a73:             }
1:7c94a73:         }
1:7c94a73:     }
1:7c94a73: 
1:230a86c:     private void processData(String str) {
1:230a86c:         if (discoveryListener != null) {
1:230a86c:             if (str.startsWith(getType())) {
1:230a86c:                 String payload = str.substring(getType().length());
1:230a86c:                 if (payload.startsWith(ALIVE)) {
1:230a86c:                     String brokerName = getBrokerName(payload.substring(ALIVE.length()));
1:230a86c:                     String service = payload.substring(ALIVE.length() + brokerName.length() + 2);
1:43b808d:                     processAlive(brokerName, service);
1:230a86c:                 } else {
1:230a86c:                     String brokerName = getBrokerName(payload.substring(DEAD.length()));
1:230a86c:                     String service = payload.substring(DEAD.length() + brokerName.length() + 2);
1:43b808d:                     processDead(service);
1:230a86c:                 }
1:230a86c:             }
1:7c94a73:         }
1:7c94a73:     }
1:6d1f57b: 
1:230a86c:     private void doTimeKeepingServices() {
1:230a86c:         if (started.get()) {
1:230a86c:             long currentTime = System.currentTimeMillis();
1:230a86c:             if (currentTime < lastAdvertizeTime || ((currentTime - keepAliveInterval) > lastAdvertizeTime)) {
1:d29ca2a:                 doAdvertizeSelf();
1:d29ca2a:                 lastAdvertizeTime = currentTime;
1:7c94a73:             }
1:d29ca2a:             doExpireOldServices();
1:f5ffb39:         }
1:d77e665:     }
1:7c94a73: 
1:230a86c:     private void doAdvertizeSelf() {
1:230a86c:         if (selfService != null) {
1:230a86c:             String payload = getType();
1:230a86c:             payload += started.get() ? ALIVE : DEAD;
1:43b808d:             payload += DELIMITER + "localhost" + DELIMITER;
1:230a86c:             payload += selfService;
1:230a86c:             try {
1:230a86c:                 byte[] data = payload.getBytes();
1:230a86c:                 DatagramPacket packet = new DatagramPacket(data, 0, data.length, sockAddress);
1:d29ca2a:                 mcast.send(packet);
1:230a86c:             } catch (IOException e) {
1:230a86c:                 // If a send fails, chances are all subsequent sends will fail
1:230a86c:                 // too.. No need to keep reporting the
1:700ba75:                 // same error over and over.
1:230a86c:                 if (reportAdvertizeFailed) {
1:230a86c:                     reportAdvertizeFailed = false;
1:fc00993:                     LOG.error("Failed to advertise our service: " + payload, e);
1:230a86c:                     if ("Operation not permitted".equals(e.getMessage())) {
1:fc00993:                         LOG.error("The 'Operation not permitted' error has been know to be caused by improper firewall/network setup.  "
1:230a86c:                                   + "Please make sure that the OS is properly configured to allow multicast traffic over: " + mcast.getLocalAddress());
1:700ba75:                     }
1:700ba75:                 }
1:d77e665:             }
1:d77e665:         }
1:d77e665:     }
1:230a86c: 
1:230a86c:     private void processAlive(String brokerName, String service) {
1:230a86c:         if (selfService == null || !service.equals(selfService)) {
1:933eb2f:             RemoteBrokerData data = brokersByService.get(service);
1:230a86c:             if (data == null) {
1:230a86c:                 data = new RemoteBrokerData(brokerName, service);
1:6d1f57b:                 brokersByService.put(service, data);      
1:230a86c:                 fireServiceAddEvent(data);
1:d29ca2a:                 doAdvertizeSelf();
1:7c94a73:             } else {
1:230a86c:                 data.updateHeartBeat();
1:230a86c:                 if (data.doRecovery()) {
1:230a86c:                     fireServiceAddEvent(data);
1:230a86c:                 }
1:7c94a73:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:74a7a8b: 
1:43b808d:     private void processDead(String service) {
1:230a86c:         if (!service.equals(selfService)) {
1:933eb2f:             RemoteBrokerData data = brokersByService.remove(service);
1:230a86c:             if (data != null && !data.isFailed()) {
1:7c94a73:                 fireServiceRemovedEvent(data);
1:7c94a73:             }
1:7c94a73:         }
1:7c94a73:     }
1:7c94a73: 
1:230a86c:     private void doExpireOldServices() {
1:6d1f57b:         long expireTime = System.currentTimeMillis() - (keepAliveInterval * HEARTBEAT_MISS_BEFORE_DEATH); 
1:933eb2f:         for (Iterator<RemoteBrokerData> i = brokersByService.values().iterator(); i.hasNext();) {
1:933eb2f:             RemoteBrokerData data = i.next();
1:230a86c:             if (data.getLastHeartBeat() < expireTime) {
1:e5d616d:                 processDead(data.getServiceName());
1:7c94a73:             }
1:7c94a73:         }
1:7c94a73:     }
1:230a86c: 
1:230a86c:     private String getBrokerName(String str) {
1:d29ca2a:         String result = null;
1:d29ca2a:         int start = str.indexOf(DELIMITER);
1:230a86c:         if (start >= 0) {
1:230a86c:             int end = str.indexOf(DELIMITER, start + 1);
1:230a86c:             result = str.substring(start + 1, end);
1:7c94a73:         }
1:d29ca2a:         return result;
1:7c94a73:     }
1:7c94a73: 
1:d29ca2a:     public void serviceFailed(DiscoveryEvent event) throws IOException {
1:933eb2f:         RemoteBrokerData data = brokersByService.get(event.getServiceName());
1:230a86c:         if (data != null && data.markFailed()) {
1:7c94a73:             fireServiceRemovedEvent(data);
1:230a86c:         }
1:7c94a73:     }
1:7c94a73: 
1:e5d616d:     private void fireServiceRemovedEvent(final RemoteBrokerData data) {
1:7f46be9:         if (discoveryListener != null && started.get()) {
1:230a86c:             // Have the listener process the event async so that
1:230a86c:             // he does not block this thread since we are doing time sensitive
1:230a86c:             // processing of events.
1:6d1f57b:             getExecutor().execute(new Runnable() {
1:230a86c:                 public void run() {
1:230a86c:                     DiscoveryListener discoveryListener = MulticastDiscoveryAgent.this.discoveryListener;
3:230a86c:                     if (discoveryListener != null) {
1:e5d616d:                         discoveryListener.onServiceRemove(data);
1:230a86c:                     }
1:230a86c:                 }
1:fc00993:             });
1:230a86c:         }
1:230a86c:     }
1:7c94a73: 
1:e5d616d:     private void fireServiceAddEvent(final RemoteBrokerData data) {
1:7f46be9:         if (discoveryListener != null && started.get()) {
1:e5d616d: 
1:230a86c:             // Have the listener process the event async so that
1:230a86c:             // he does not block this thread since we are doing time sensitive
1:230a86c:             // processing of events.
1:6d1f57b:             getExecutor().execute(new Runnable() {
1:230a86c:                 public void run() {
1:230a86c:                     DiscoveryListener discoveryListener = MulticastDiscoveryAgent.this.discoveryListener;
1:230a86c:                     if (discoveryListener != null) {
1:e5d616d:                         discoveryListener.onServiceAdd(data);
1:230a86c:                     }
1:230a86c:                 }
1:230a86c:             });
1:230a86c:         }
1:7c94a73:     }
1:7c94a73: 
1:bd1b10c:     private ExecutorService getExecutor() {
1:6d1f57b:         if (executor == null) {
1:6d1f57b:             final String threadName = "Notifier-" + this.toString();
1:6d1f57b:             executor = new ThreadPoolExecutor(1, 1, 30, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new ThreadFactory() {
1:6d1f57b:                 public Thread newThread(Runnable runable) {
1:6d1f57b:                     Thread t = new Thread(runable,  threadName);
1:6d1f57b:                     t.setDaemon(true);
1:6d1f57b:                     return t;
1:6d1f57b:                 }
1:6d1f57b:             });
1:6d1f57b:         }
1:6d1f57b:         return executor;
1:6d1f57b:     }
1:6d1f57b: 
1:230a86c:     public long getBackOffMultiplier() {
1:230a86c:         return backOffMultiplier;
1:230a86c:     }
1:7c94a73: 
1:230a86c:     public void setBackOffMultiplier(long backOffMultiplier) {
1:230a86c:         this.backOffMultiplier = backOffMultiplier;
1:230a86c:     }
1:7c94a73: 
1:230a86c:     public long getInitialReconnectDelay() {
1:230a86c:         return initialReconnectDelay;
1:230a86c:     }
1:7c94a73: 
1:230a86c:     public void setInitialReconnectDelay(long initialReconnectDelay) {
1:230a86c:         this.initialReconnectDelay = initialReconnectDelay;
1:230a86c:     }
1:7c94a73: 
1:230a86c:     public int getMaxReconnectAttempts() {
1:230a86c:         return maxReconnectAttempts;
1:230a86c:     }
1:7c94a73: 
1:230a86c:     public void setMaxReconnectAttempts(int maxReconnectAttempts) {
1:230a86c:         this.maxReconnectAttempts = maxReconnectAttempts;
1:230a86c:     }
1:7c94a73: 
1:230a86c:     public long getMaxReconnectDelay() {
1:230a86c:         return maxReconnectDelay;
1:230a86c:     }
1:230a86c: 
1:230a86c:     public void setMaxReconnectDelay(long maxReconnectDelay) {
1:230a86c:         this.maxReconnectDelay = maxReconnectDelay;
1:230a86c:     }
1:230a86c: 
1:230a86c:     public boolean isUseExponentialBackOff() {
1:230a86c:         return useExponentialBackOff;
1:230a86c:     }
1:230a86c: 
1:230a86c:     public void setUseExponentialBackOff(boolean useExponentialBackOff) {
1:230a86c:         this.useExponentialBackOff = useExponentialBackOff;
1:230a86c:     }
1:43b808d: 
1:43b808d:     public void setGroup(String group) {
1:43b808d:         this.group = group;
1:43b808d:     }
1:6d1f57b:     
1:6d1f57b:     @Override
1:6d1f57b:     public String toString() {
1:6d1f57b:         return  "MulticastDiscoveryAgent-"
1:6d1f57b:             + (selfService != null ? "advertise:" + selfService : "listener:" + this.discoveryListener);
1:6d1f57b:     }
1:7c94a73: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:gtully
-------------------------------------------------------------------------------
commit:5cc5022
/////////////////////////////////////////////////////////////////////////
1:                                 && (ni.getDisplayName()==null || !ni.getDisplayName().startsWith("vnic"))) {
commit:daf7e85
/////////////////////////////////////////////////////////////////////////
1:                         if (ia != null && ia.getAddress() instanceof java.net.Inet4Address
commit:07338e7
/////////////////////////////////////////////////////////////////////////
1:             try {
1:                 if (ni.supportsMulticast()
1:                         && ni.isUp()) {
1:                     for (InterfaceAddress ia : ni.getInterfaceAddresses()) {
0:                         if (ia.getAddress() instanceof java.net.Inet4Address
1:                                 && !ia.getAddress().isLoopbackAddress()
0:                                 && !ni.getDisplayName().startsWith("vnic")) {
1:                             possibles.add(ni);
1:                         }
1:             } catch (SocketException ignored) {}
author:Daniel Kulp
-------------------------------------------------------------------------------
commit:f4eade2
/////////////////////////////////////////////////////////////////////////
1: import java.net.InterfaceAddress;
1: import java.net.SocketException;
1: import java.util.ArrayList;
1: import java.util.Enumeration;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:                 mcast.setNetworkInterface(findNetworkInterface());
/////////////////////////////////////////////////////////////////////////
1:     
1:     private NetworkInterface findNetworkInterface() throws SocketException {
1:         Enumeration<NetworkInterface> ifcs = NetworkInterface.getNetworkInterfaces();
1:         List<NetworkInterface> possibles = new ArrayList<NetworkInterface>();
1:         while (ifcs.hasMoreElements()) {
1:             NetworkInterface ni = ifcs.nextElement();
0:             if (ni.supportsMulticast()
0:                 && ni.isUp()) {
0:                 for (InterfaceAddress ia : ni.getInterfaceAddresses()) {
0:                     if (ia.getAddress() instanceof java.net.Inet4Address
0:                         && !ia.getAddress().isLoopbackAddress()
0:                         && !ni.getDisplayName().startsWith("vnic")) {
0:                         possibles.add(ni);
1:                     }
1:                 }
1:             }
1:         }
1:         return possibles.isEmpty() ? null : possibles.get(possibles.size() - 1);
1:     }
author:Gary Tully
-------------------------------------------------------------------------------
commit:e5d616d
/////////////////////////////////////////////////////////////////////////
1:     class RemoteBrokerData extends DiscoveryEvent {
1:             super(service);
1:             setBrokerName(brokerName);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.debug("I now think that the " + serviceName + " service has recovered.");
/////////////////////////////////////////////////////////////////////////
1:                     LOG.debug("Remote failure of " + serviceName + " while still receiving multicast advertisements.  Advertising events will be suppressed for " + reconnectDelay
/////////////////////////////////////////////////////////////////////////
1:                     LOG.debug("Max reconnect attempts of the " + serviceName + " service has been reached.");
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Resuming event advertisement of the " + serviceName + " service.");
/////////////////////////////////////////////////////////////////////////
1:                 processDead(data.getServiceName());
/////////////////////////////////////////////////////////////////////////
1:     private void fireServiceRemovedEvent(final RemoteBrokerData data) {
/////////////////////////////////////////////////////////////////////////
1:                         discoveryListener.onServiceRemove(data);
1:     private void fireServiceAddEvent(final RemoteBrokerData data) {
1: 
/////////////////////////////////////////////////////////////////////////
1:                         discoveryListener.onServiceAdd(data);
commit:af5d8d1
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     private String mcJoinNetworkInterface;
/////////////////////////////////////////////////////////////////////////
1:     public void setJoinNetworkInterface(String mcJoinNetwrokInterface) {
1:     	this.mcJoinNetworkInterface = mcJoinNetwrokInterface;
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:         	  	LOG.trace("start - join network interface  = " + mcJoinNetworkInterface );
/////////////////////////////////////////////////////////////////////////
1:             if (mcJoinNetworkInterface != null) {
1:                 mcast.joinGroup(sockAddress, NetworkInterface.getByName(mcJoinNetworkInterface));
1:             }
1:             else {
1:             	mcast.joinGroup(inetAddress);
1:             }
commit:c808beb
/////////////////////////////////////////////////////////////////////////
1:             if (runner != null) {
1:                 runner.interrupt();
1:             }
commit:7f46be9
/////////////////////////////////////////////////////////////////////////
1:         if (discoveryListener != null && started.get()) {
/////////////////////////////////////////////////////////////////////////
1:         if (discoveryListener != null && started.get()) {
commit:673fee1
/////////////////////////////////////////////////////////////////////////
1: import java.net.NetworkInterface;
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
1:     private int timeToLive = 1;
1:     private boolean loopBackMode;
1:     private Map<String, RemoteBrokerData> brokersByService = new ConcurrentHashMap<String, RemoteBrokerData>();
1:     private String group = "default";
1:     private URI discoveryURI;
1:     private InetAddress inetAddress;
1:     private SocketAddress sockAddress;
1:     private DiscoveryListener discoveryListener;
1:     private String selfService;
1:     private MulticastSocket mcast;
1:     private Thread runner;
1:     private long keepAliveInterval = DEFAULT_IDLE_TIME;
1:     private String mcInterface;
1:     private String mcNetworkInterface;
1:     private long lastAdvertizeTime;
1:     private AtomicBoolean started = new AtomicBoolean(false);
1:     private boolean reportAdvertizeFailed = true;
1:     private ExecutorService executor = null;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     
1:     public void setInterface(String mcInterface) {
1:         this.mcInterface = mcInterface;
1:     }
1:     
1:     public void setNetworkInterface(String mcNetworkInterface) {
1:         this.mcNetworkInterface = mcNetworkInterface;    
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:         	  	LOG.trace("start - group  = " + group );		       	  	
1:         	  	LOG.trace("start - interface  = " + mcInterface );
1:         	  	LOG.trace("start - network interface  = " + mcNetworkInterface );
/////////////////////////////////////////////////////////////////////////
1:             if (mcInterface != null) {
1:                 mcast.setInterface(InetAddress.getByName(mcInterface));
1:             }
1:             if (mcNetworkInterface != null) {
1:                 mcast.setNetworkInterface(NetworkInterface.getByName(mcNetworkInterface));
1:             }
commit:39e63c0
/////////////////////////////////////////////////////////////////////////
commit:bd1b10c
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ExecutorService;
/////////////////////////////////////////////////////////////////////////
0:     private ExecutorService executor = null;
/////////////////////////////////////////////////////////////////////////
0:             runner.interrupt();
0:             getExecutor().shutdownNow();
/////////////////////////////////////////////////////////////////////////
1:     private ExecutorService getExecutor() {
commit:6d1f57b
/////////////////////////////////////////////////////////////////////////
0:     private Executor executor = null;
/////////////////////////////////////////////////////////////////////////
1:             runner.setName(this.toString() + ":" + runner.getName());
/////////////////////////////////////////////////////////////////////////
1:                 brokersByService.put(service, data);      
/////////////////////////////////////////////////////////////////////////
1:         long expireTime = System.currentTimeMillis() - (keepAliveInterval * HEARTBEAT_MISS_BEFORE_DEATH); 
/////////////////////////////////////////////////////////////////////////
1:             getExecutor().execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
1:             
1:             getExecutor().execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
0:     private Executor getExecutor() {
1:         if (executor == null) {
1:             final String threadName = "Notifier-" + this.toString();
1:             executor = new ThreadPoolExecutor(1, 1, 30, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new ThreadFactory() {
1:                 public Thread newThread(Runnable runable) {
1:                     Thread t = new Thread(runable,  threadName);
1:                     t.setDaemon(true);
1:                     return t;
1:                 }
1:             });
1:         }
1:         return executor;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     
1:     @Override
1:     public String toString() {
1:         return  "MulticastDiscoveryAgent-"
1:             + (selfService != null ? "advertise:" + selfService : "listener:" + this.discoveryListener);
1:     }
commit:8469d75
/////////////////////////////////////////////////////////////////////////
1:             if (mcast != null) {
1:                 mcast.close();
1:             }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:9a8f6e4
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:43b808d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     processAlive(brokerName, service);
1:                     processDead(service);
/////////////////////////////////////////////////////////////////////////
1:             payload += DELIMITER + "localhost" + DELIMITER;
/////////////////////////////////////////////////////////////////////////
1:     private void processDead(String service) {
/////////////////////////////////////////////////////////////////////////
0:                 processDead(data.service);
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void setGroup(String group) {
1:         this.group = group;
1:     }
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
1: 
0:     private static final Log LOG = LogFactory.getLog(MulticastDiscoveryAgent.class);
/////////////////////////////////////////////////////////////////////////
1:     private boolean useExponentialBackOff;
/////////////////////////////////////////////////////////////////////////
0:     private boolean loopBackMode;
0:     private Map<String, RemoteBrokerData> brokersByService = new ConcurrentHashMap<String, RemoteBrokerData>();
/////////////////////////////////////////////////////////////////////////
0:     private long lastAdvertizeTime;
0:     private final Executor executor = new ThreadPoolExecutor(1, 1, 30, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new ThreadFactory() {
/////////////////////////////////////////////////////////////////////////
1:             RemoteBrokerData data = brokersByService.get(service);
/////////////////////////////////////////////////////////////////////////
1:             RemoteBrokerData data = brokersByService.remove(service);
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<RemoteBrokerData> i = brokersByService.values().iterator(); i.hasNext();) {
1:             RemoteBrokerData data = i.next();
/////////////////////////////////////////////////////////////////////////
1:         RemoteBrokerData data = brokersByService.get(event.getServiceName());
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(MulticastDiscoveryAgent.class);
/////////////////////////////////////////////////////////////////////////
1:         public synchronized void updateHeartBeat() {
1:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug("I now think that the " + service + " service has recovered.");
1:                 }
1:         public synchronized long getLastHeartBeat() {
1:         public synchronized boolean markFailed() {
/////////////////////////////////////////////////////////////////////////
1:                     if (reconnectDelay > maxReconnectDelay) {
1:                     }
1:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug("Remote failure of " + service + " while still receiving multicast advertisements.  Advertising events will be suppressed for " + reconnectDelay
1:                               + " ms, the current failure count is: " + failureCount);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:         public synchronized boolean doRecovery() {
1:             if (!failed) {
1:             }
1:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug("Max reconnect attempts of the " + service + " service has been reached.");
1:                 }
1:             if (System.currentTimeMillis() < recoveryTime) {
1:             }
1:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("Resuming event advertisement of the " + service + " service.");
1:             }
/////////////////////////////////////////////////////////////////////////
0:     private final Executor executor = new ThreadPoolExecutor(1, 1, 30, TimeUnit.SECONDS, new LinkedBlockingQueue(), new ThreadFactory() {
0:         public Thread newThread(Runnable runable) {
0:             Thread t = new Thread(runable, "Multicast Discovery Agent Notifier");
0:             t.setDaemon(true);
0:             return t;
1:         }
1:     });
/////////////////////////////////////////////////////////////////////////
0:                 LOG.warn("brokerName not set");
1:                 LOG.warn("The type '" + type + "' should end with '.' to be a valid Discovery type");
/////////////////////////////////////////////////////////////////////////
1:                     LOG.error("failed to process packet: " + e);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.error("Failed to advertise our service: " + payload, e);
1:                         LOG.error("The 'Operation not permitted' error has been know to be caused by improper firewall/network setup.  "
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.activemq.command.DiscoveryEvent;
1: import org.apache.activemq.transport.discovery.DiscoveryAgent;
1: import org.apache.activemq.transport.discovery.DiscoveryListener;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
/////////////////////////////////////////////////////////////////////////
1: 
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
1: 
1:  * A {@link DiscoveryAgent} using a multicast address and heartbeat packets
1:  * encoded using any wireformat, but openwire by default.
1: public class MulticastDiscoveryAgent implements DiscoveryAgent, Runnable {
0:     private static final Log log = LogFactory.getLog(MulticastDiscoveryAgent.class);
1:     public static final String DEFAULT_DISCOVERY_URI_STRING = "multicast://239.255.2.3:6155";
1:     private static final String TYPE_SUFFIX = "ActiveMQ-4.";
1:     private static final String ALIVE = "alive.";
1:     private static final String DEAD = "dead.";
1:     private static final int BUFF_SIZE = 8192;
1:     private static final int DEFAULT_IDLE_TIME = 500;
1:     private static final int HEARTBEAT_MISS_BEFORE_DEATH = 10;
1: 
1:     private long initialReconnectDelay = 1000 * 5;
1: 
0:         final String brokerName;
0:         final String service;
1:         long lastHeartBeat;
1:         long recoveryTime;
1:         int failureCount;
1:         boolean failed;
1:         public RemoteBrokerData(String brokerName, String service) {
0:             this.brokerName = brokerName;
0:             this.service = service;
1:             this.lastHeartBeat = System.currentTimeMillis();
1:         }
1: 
0:         synchronized public void updateHeartBeat() {
1:             lastHeartBeat = System.currentTimeMillis();
1: 
1:             // Consider that the broker recovery has succeeded if it has not
1:             // failed in 60 seconds.
1:             if (!failed && failureCount > 0 && (lastHeartBeat - recoveryTime) > 1000 * 60) {
0:                 if (log.isDebugEnabled())
0:                     log.debug("I now think that the " + service + " service has recovered.");
1:                 failureCount = 0;
1:                 recoveryTime = 0;
1:         }
0:         synchronized public long getLastHeartBeat() {
1:             return lastHeartBeat;
1:         }
0:         synchronized public boolean markFailed() {
1:             if (!failed) {
1:                 failed = true;
1:                 failureCount++;
1:                 long reconnectDelay;
1:                 if (!useExponentialBackOff) {
1:                     reconnectDelay = initialReconnectDelay;
1:                 } else {
1:                     reconnectDelay = (long)Math.pow(backOffMultiplier, failureCount);
0:                     if (reconnectDelay > maxReconnectDelay)
1:                         reconnectDelay = maxReconnectDelay;
1:                 }
0:                 if (log.isDebugEnabled())
0:                     log
0:                         .debug("Remote failure of "
0:                                + service
0:                                + " while still receiving multicast advertisements.  Advertising events will be suppressed for "
0:                                + reconnectDelay + " ms, the current failure count is: " + failureCount);
1:                 recoveryTime = System.currentTimeMillis() + reconnectDelay;
1:                 return true;
1:             }
1:             return false;
1:         }
1:         /**
1:          * @return true if this broker is marked failed and it is now the right
1:          *         time to start recovery.
1:          */
0:         synchronized public boolean doRecovery() {
0:             if (!failed)
1:                 return false;
1: 
1:             // Are we done trying to recover this guy?
1:             if (maxReconnectAttempts > 0 && failureCount > maxReconnectAttempts) {
0:                 if (log.isDebugEnabled())
0:                     log.debug("Max reconnect attempts of the " + service + " service has been reached.");
1:                 return false;
1:             }
1: 
1:             // Is it not yet time?
0:             if (System.currentTimeMillis() < recoveryTime)
1:                 return false;
1: 
0:             if (log.isDebugEnabled())
0:                 log.debug("Resuming event advertisement of the " + service + " service.");
1: 
1:             failed = false;
1:             return true;
1:         }
1: 
1:         public boolean isFailed() {
1:             return failed;
1:         }
1: 
0:     private int timeToLive = 1;
0:     private boolean loopBackMode = false;
0:     private Map brokersByService = new ConcurrentHashMap();
0:     private String group = "default";
/////////////////////////////////////////////////////////////////////////
0:     private long keepAliveInterval = DEFAULT_IDLE_TIME;
0:     private long lastAdvertizeTime = 0;
0:     private AtomicBoolean started = new AtomicBoolean(false);
0:     private boolean reportAdvertizeFailed = true;
1: 
0:     private final Executor executor = new ThreadPoolExecutor(1, 1, 30, TimeUnit.SECONDS,
0:                                                              new LinkedBlockingQueue(), new ThreadFactory() {
0:                                                                  public Thread newThread(Runnable runable) {
0:                                                                      Thread t = new Thread(runable,
0:                                                                                            "Multicast Discovery Agent Notifier");
0:                                                                      t.setDaemon(true);
0:                                                                      return t;
1:                                                                  }
1:                                                              });
1:     public void setDiscoveryListener(DiscoveryListener listener) {
1:         this.discoveryListener = listener;
1:     public void registerService(String name) throws IOException {
1:         this.selfService = name;
1:         if (started.get()) {
/////////////////////////////////////////////////////////////////////////
0:     public String getGroup() {
/////////////////////////////////////////////////////////////////////////
0:     public void setGroup(String group) {
0:         this.group = group;
0:     public String getBrokerName() {
0:     public void setBrokerName(String brokerName) {
0:         if (brokerName != null) {
0:             brokerName = brokerName.replace('.', '-');
0:             brokerName = brokerName.replace(':', '-');
0:             brokerName = brokerName.replace('%', '-');
0:             this.brokerName = brokerName;
1:     public boolean isLoopBackMode() {
1:      * @param loopBackMode The loopBackMode to set.
1:     public void setLoopBackMode(boolean loopBackMode) {
1:         this.loopBackMode = loopBackMode;
1:     public int getTimeToLive() {
1:      * @param timeToLive The timeToLive to set.
1:     public void setTimeToLive(int timeToLive) {
1:         this.timeToLive = timeToLive;
1:     public URI getDiscoveryURI() {
/////////////////////////////////////////////////////////////////////////
1:     public void setDiscoveryURI(URI discoveryURI) {
1:         this.discoveryURI = discoveryURI;
1:     public long getKeepAliveInterval() {
1:     public void setKeepAliveInterval(long keepAliveInterval) {
1:         this.keepAliveInterval = keepAliveInterval;
/////////////////////////////////////////////////////////////////////////
1:     public void start() throws Exception {
1:         if (started.compareAndSet(false, true)) {
1:             if (group == null || group.length() == 0) {
0:             if (brokerName == null || brokerName.length() == 0) {
1:             String type = getType();
1:             if (!type.endsWith(".")) {
0:                 log.warn("The type '" + type + "' should end with '.' to be a valid Discovery type");
1:                 type += ".";
1:             if (discoveryURI == null) {
1:                 discoveryURI = new URI(DEFAULT_DISCOVERY_URI_STRING);
0:             this.inetAddress = InetAddress.getByName(discoveryURI.getHost());
0:             this.sockAddress = new InetSocketAddress(this.inetAddress, discoveryURI.getPort());
0:             mcast = new MulticastSocket(discoveryURI.getPort());
1:             mcast.setSoTimeout((int)keepAliveInterval);
1:             runner = new Thread(this);
0:             runner.setName("MulticastDiscovery: " + selfService);
/////////////////////////////////////////////////////////////////////////
1:     public void stop() throws Exception {
1:         if (started.compareAndSet(true, false)) {
1:     public String getType() {
1:         return group + "." + TYPE_SUFFIX;
1:     public void run() {
1:         byte[] buf = new byte[BUFF_SIZE];
1:         DatagramPacket packet = new DatagramPacket(buf, 0, buf.length);
1:         while (started.get()) {
1:             try {
1:                 if (packet.getLength() > 0) {
1:                     String str = new String(packet.getData(), packet.getOffset(), packet.getLength());
1:             } catch (SocketTimeoutException se) {
1:             } catch (IOException e) {
1:                 if (started.get()) {
0:                     log.error("failed to process packet: " + e);
1:                 }
1:     private void processData(String str) {
1:         if (discoveryListener != null) {
1:             if (str.startsWith(getType())) {
1:                 String payload = str.substring(getType().length());
1:                 if (payload.startsWith(ALIVE)) {
1:                     String brokerName = getBrokerName(payload.substring(ALIVE.length()));
1:                     String service = payload.substring(ALIVE.length() + brokerName.length() + 2);
0:                     if (!brokerName.equals(this.brokerName)) {
0:                         processAlive(brokerName, service);
1:                     }
1:                 } else {
1:                     String brokerName = getBrokerName(payload.substring(DEAD.length()));
1:                     String service = payload.substring(DEAD.length() + brokerName.length() + 2);
0:                     if (!brokerName.equals(this.brokerName)) {
0:                         processDead(brokerName, service);
1:                     }
1:     private void doTimeKeepingServices() {
1:         if (started.get()) {
1:             long currentTime = System.currentTimeMillis();
1:             if (currentTime < lastAdvertizeTime || ((currentTime - keepAliveInterval) > lastAdvertizeTime)) {
/////////////////////////////////////////////////////////////////////////
1:     private void doAdvertizeSelf() {
1:         if (selfService != null) {
1:             String payload = getType();
1:             payload += started.get() ? ALIVE : DEAD;
0:             payload += DELIMITER + brokerName + DELIMITER;
1:             payload += selfService;
1:             try {
1:                 byte[] data = payload.getBytes();
1:                 DatagramPacket packet = new DatagramPacket(data, 0, data.length, sockAddress);
1:             } catch (IOException e) {
1:                 // If a send fails, chances are all subsequent sends will fail
1:                 // too.. No need to keep reporting the
1:                 if (reportAdvertizeFailed) {
1:                     reportAdvertizeFailed = false;
0:                     log.error("Failed to advertise our service: " + payload, e);
1:                     if ("Operation not permitted".equals(e.getMessage())) {
0:                         log.error("The 'Operation not permitted' error has been know to be caused by improper firewall/network setup.  "
1:                                   + "Please make sure that the OS is properly configured to allow multicast traffic over: " + mcast.getLocalAddress());
1:     private void processAlive(String brokerName, String service) {
1:         if (selfService == null || !service.equals(selfService)) {
0:             RemoteBrokerData data = (RemoteBrokerData)brokersByService.get(service);
1:             if (data == null) {
1:                 data = new RemoteBrokerData(brokerName, service);
0:                 brokersByService.put(service, data);
0:                 ;
1:                 fireServiceAddEvent(data);
1: 
1:                 data.updateHeartBeat();
1:                 if (data.doRecovery()) {
1:                     fireServiceAddEvent(data);
1:                 }
0:     private void processDead(String brokerName, String service) {
1:         if (!service.equals(selfService)) {
0:             RemoteBrokerData data = (RemoteBrokerData)brokersByService.remove(service);
1:             if (data != null && !data.isFailed()) {
1:     private void doExpireOldServices() {
0:         long expireTime = System.currentTimeMillis() - (keepAliveInterval * HEARTBEAT_MISS_BEFORE_DEATH);
0:         for (Iterator i = brokersByService.values().iterator(); i.hasNext();) {
0:             RemoteBrokerData data = (RemoteBrokerData)i.next();
1:             if (data.getLastHeartBeat() < expireTime) {
1: 
1:     private String getBrokerName(String str) {
1:         if (start >= 0) {
1:             int end = str.indexOf(DELIMITER, start + 1);
1:             result = str.substring(start + 1, end);
0:         RemoteBrokerData data = (RemoteBrokerData)brokersByService.get(event.getServiceName());
1:         if (data != null && data.markFailed()) {
0:     private void fireServiceRemovedEvent(RemoteBrokerData data) {
1:         if (discoveryListener != null) {
0:             final DiscoveryEvent event = new DiscoveryEvent(data.service);
0:             event.setBrokerName(data.brokerName);
1:             // Have the listener process the event async so that
1:             // he does not block this thread since we are doing time sensitive
1:             // processing of events.
0:             executor.execute(new Runnable() {
1:                 public void run() {
1:                     DiscoveryListener discoveryListener = MulticastDiscoveryAgent.this.discoveryListener;
1:                     if (discoveryListener != null) {
0:                         discoveryListener.onServiceRemove(event);
1:                     }
1:                 }
0:             });
1:         }
1:     }
0:     private void fireServiceAddEvent(RemoteBrokerData data) {
1:         if (discoveryListener != null) {
0:             final DiscoveryEvent event = new DiscoveryEvent(data.service);
0:             event.setBrokerName(data.brokerName);
1:             // Have the listener process the event async so that
1:             // he does not block this thread since we are doing time sensitive
1:             // processing of events.
0:             executor.execute(new Runnable() {
1:                 public void run() {
1:                     DiscoveryListener discoveryListener = MulticastDiscoveryAgent.this.discoveryListener;
1:                     if (discoveryListener != null) {
0:                         discoveryListener.onServiceAdd(event);
1:                     }
1:                 }
0:             });
1:         }
1:     }
1:     public long getBackOffMultiplier() {
1:         return backOffMultiplier;
1:     }
1:     public void setBackOffMultiplier(long backOffMultiplier) {
1:         this.backOffMultiplier = backOffMultiplier;
1:     }
1:     public long getInitialReconnectDelay() {
1:         return initialReconnectDelay;
1:     }
1:     public void setInitialReconnectDelay(long initialReconnectDelay) {
1:         this.initialReconnectDelay = initialReconnectDelay;
1:     }
1:     public int getMaxReconnectAttempts() {
1:         return maxReconnectAttempts;
1:     }
1:     public void setMaxReconnectAttempts(int maxReconnectAttempts) {
1:         this.maxReconnectAttempts = maxReconnectAttempts;
1:     }
1:     public long getMaxReconnectDelay() {
1:         return maxReconnectDelay;
1:     }
1: 
1:     public void setMaxReconnectDelay(long maxReconnectDelay) {
1:         this.maxReconnectDelay = maxReconnectDelay;
1:     }
1: 
1:     public boolean isUseExponentialBackOff() {
1:         return useExponentialBackOff;
1:     }
1: 
1:     public void setUseExponentialBackOff(boolean useExponentialBackOff) {
1:         this.useExponentialBackOff = useExponentialBackOff;
1:     }
commit:7c94a73
/////////////////////////////////////////////////////////////////////////
0:     private static final int HEARTBEAT_MISS_BEFORE_DEATH=10;
1:     
0:     private long initialReconnectDelay = 1000*5;
1:     private long maxReconnectDelay = 1000 * 30;
1:     private long backOffMultiplier = 2;
0:     private boolean useExponentialBackOff = false;
1:     private int maxReconnectAttempts;
1:     
1:     
0:     class RemoteBrokerData {
0: 		final String brokerName;
0: 		final String service;
0:     	long lastHeartBeat;
0:     	long recoveryTime;
0:     	int failureCount;
0:     	boolean failed;
1:     	
0:     	public RemoteBrokerData(String brokerName, String service) {
0: 			this.brokerName=brokerName;
0: 			this.service=service;
0: 			this.lastHeartBeat=System.currentTimeMillis();
1: 		}
1: 
0: 		synchronized public void updateHeartBeat() {
0:             lastHeartBeat= System.currentTimeMillis();
1:             
0:             // Consider that the broker recovery has succeeded if it has not failed in 60 seconds. 
0:             if( !failed && failureCount>0 && (lastHeartBeat-recoveryTime) > 1000*60 ) {
0: 	            if(log.isDebugEnabled())
0: 	            	log.debug("I now think that the "+service+" service has recovered.");
0:             	failureCount=0;
0:             	recoveryTime=0;
1:             }
1: 		}
1: 
0: 		synchronized public long getLastHeartBeat() {
0: 			return lastHeartBeat;
1: 		}
1: 
0: 		synchronized public boolean markFailed() {
0: 			if ( !failed ) {
0: 				failed=true;
0: 				failureCount++;
1: 				
0: 				long reconnectDelay;
0: 	            if (!useExponentialBackOff) {
0: 	            	reconnectDelay = initialReconnectDelay;
1: 	            } else {
0: 	            	reconnectDelay = (long)Math.pow(backOffMultiplier, failureCount);
0: 	                if(reconnectDelay>maxReconnectDelay)
0: 	                	reconnectDelay=maxReconnectDelay;
1: 	            }
1: 	            
0: 	            if(log.isDebugEnabled())
0: 	            	log.debug("Remote failure of "+service+" while still receiving multicast advertisements.  Advertising events will be suppressed for "+reconnectDelay+" ms, the current failure count is: "+failureCount);
1: 
0: 	            recoveryTime = System.currentTimeMillis()+reconnectDelay;
0: 	            return true;
1: 			}
0: 			return false;
1: 		}
1: 
1: 		/**
0: 		 * @return true if this broker is marked failed and it is now the right time to start recovery.
1: 		 */
0: 		synchronized public boolean doRecovery() {
0: 			if( !failed )
0: 				return false;
1: 			
0: 			// Are we done trying to recover this guy?
0: 			if( maxReconnectAttempts>0 && failureCount > maxReconnectAttempts ) { 
0: 	            if(log.isDebugEnabled())
0: 	            	log.debug("Max reconnect attempts of the "+service+" service has been reached.");
0: 				return false;
1: 			}
1: 			
0: 			// Is it not yet time?
0: 			if( System.currentTimeMillis() < recoveryTime )
0: 				return false;
1: 
0:             if(log.isDebugEnabled())
0:             	log.debug("Resuming event advertisement of the "+service+" service.");
1: 			
1: 			
0: 			failed=false;
0: 			return true;
1: 		}
1: 
0: 		public boolean isFailed() {
0: 			return failed;
1: 		}
1:     }
1:     
0:     private Map brokersByService=new ConcurrentHashMap();
/////////////////////////////////////////////////////////////////////////
0:         	RemoteBrokerData data = (RemoteBrokerData)brokersByService.get(service);
0:             if(data==null){
0:             	data = new RemoteBrokerData(brokerName, service);
0:                 brokersByService.put(service,data);;
0:         		fireServiceAddEvent(data);
0:             } else {
0:             	data.updateHeartBeat();
0:             	if( data.doRecovery() ) {
0:             		fireServiceAddEvent(data);
1:             	}
0:         	RemoteBrokerData data = (RemoteBrokerData) brokersByService.remove(service);
0:             if(data!=null && !data.isFailed() ){
1:                 fireServiceRemovedEvent(data);
0:         for(Iterator i=brokersByService.values().iterator();i.hasNext();){
0:         	RemoteBrokerData data=(RemoteBrokerData)i.next();
0:             if( data.getLastHeartBeat() < expireTime){
0:                 processDead(brokerName, data.service);
/////////////////////////////////////////////////////////////////////////
0:     	RemoteBrokerData data = (RemoteBrokerData)brokersByService.get(event.getServiceName());
0:         if(data!=null && data.markFailed() ) {
1:             fireServiceRemovedEvent(data);
1:         }
1: 
0: 	private void fireServiceRemovedEvent(RemoteBrokerData data) {
0: 		if( discoveryListener!=null){
0: 		    final DiscoveryEvent event=new DiscoveryEvent(data.service);
0: 		    event.setBrokerName(data.brokerName);
1: 		    
0: 		    // Have the listener process the event async so that 
0: 		    // he does not block this thread since we are doing time sensitive
0: 		    // processing of events.
0: 		    executor.execute(new Runnable() {
0: 		        public void run() {
0: 		            DiscoveryListener discoveryListener = MulticastDiscoveryAgent.this.discoveryListener;
0: 		            if(discoveryListener!=null){
0: 		                discoveryListener.onServiceRemove(event);
1: 		            }
1: 		        }
0: 		    });
1: 		}
1: 	}
0: 	private void fireServiceAddEvent(RemoteBrokerData data) {
0: 		if( discoveryListener!=null){
0: 		    final DiscoveryEvent event=new DiscoveryEvent(data.service);
0: 		    event.setBrokerName(data.brokerName);
1: 		    
0: 		    // Have the listener process the event async so that 
0: 		    // he does not block this thread since we are doing time sensitive
0: 		    // processing of events.
0: 		    executor.execute(new Runnable() {
0: 		        public void run() {
0: 		            DiscoveryListener discoveryListener = MulticastDiscoveryAgent.this.discoveryListener;
0: 		            if(discoveryListener!=null){
0: 		                discoveryListener.onServiceAdd(event);
1: 		            }
1: 		        }
0: 		    });
1: 		}
1: 	}
1: 
0: 	public long getBackOffMultiplier() {
0: 		return backOffMultiplier;
1: 	}
1: 
0: 	public void setBackOffMultiplier(long backOffMultiplier) {
0: 		this.backOffMultiplier = backOffMultiplier;
1: 	}
1: 
0: 	public long getInitialReconnectDelay() {
0: 		return initialReconnectDelay;
1: 	}
1: 
0: 	public void setInitialReconnectDelay(long initialReconnectDelay) {
0: 		this.initialReconnectDelay = initialReconnectDelay;
1: 	}
1: 
0: 	public int getMaxReconnectAttempts() {
0: 		return maxReconnectAttempts;
1: 	}
1: 
0: 	public void setMaxReconnectAttempts(int maxReconnectAttempts) {
0: 		this.maxReconnectAttempts = maxReconnectAttempts;
1: 	}
1: 
0: 	public long getMaxReconnectDelay() {
0: 		return maxReconnectDelay;
1: 	}
1: 
0: 	public void setMaxReconnectDelay(long maxReconnectDelay) {
0: 		this.maxReconnectDelay = maxReconnectDelay;
1: 	}
1: 
0: 	public boolean isUseExponentialBackOff() {
0: 		return useExponentialBackOff;
1: 	}
1: 
0: 	public void setUseExponentialBackOff(boolean useExponentialBackOff) {
0: 		this.useExponentialBackOff = useExponentialBackOff;
1: 	}
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.Executor;
1: import java.util.concurrent.LinkedBlockingQueue;
1: import java.util.concurrent.ThreadFactory;
1: import java.util.concurrent.ThreadPoolExecutor;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicBoolean;
0: import java.util.concurrent.atomic.AtomicLong;
commit:349d0f2
/////////////////////////////////////////////////////////////////////////
0:  * A {@link DiscoveryAgent} using a multicast address and heartbeat packets encoded using any 
0:  * wireformat, but openwire by default.
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:f5ffb39
/////////////////////////////////////////////////////////////////////////
0:             } catch(SocketTimeoutException se){
0:             } catch(IOException e){
0:             	if( started.get() ) {
0:             		log.error("failed to process packet: "+e);
1:             	}
commit:700ba75
/////////////////////////////////////////////////////////////////////////
0:     private boolean reportAdvertizeFailed=true;
/////////////////////////////////////////////////////////////////////////
0:         if(selfService!=null ){
/////////////////////////////////////////////////////////////////////////
0:             } catch(IOException e) {
0:                 // If a send fails, chances are all subsequent sends will fail too.. No need to keep reporting the
1:                 // same error over and over.
0:                 if( reportAdvertizeFailed ) {
0:                     reportAdvertizeFailed=false;
0:                     log.error("Failed to advertise our service: "+payload,e);
0:                     if( "Operation not permitted".equals(e.getMessage()) ) {
0:                         log.error("The 'Operation not permitted' error has been know to be caused by improper firewall/network setup.  Please make sure that the OS is properly configured to allow multicast traffic over: "+mcast.getLocalAddress());
1:                     }
1:                 }
commit:d77e665
/////////////////////////////////////////////////////////////////////////
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.Executor;
0: import edu.emory.mathcs.backport.java.util.concurrent.LinkedBlockingQueue;
0: import edu.emory.mathcs.backport.java.util.concurrent.ThreadFactory;
0: import edu.emory.mathcs.backport.java.util.concurrent.ThreadPoolExecutor;
0: import edu.emory.mathcs.backport.java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
1:     
0:     private final Executor executor = new ThreadPoolExecutor(1, 1, 30, TimeUnit.SECONDS, new LinkedBlockingQueue(), new ThreadFactory() {
0:         public Thread newThread(Runnable runable) {
0:             Thread t = new Thread(runable, "Multicast Discovery Agent Notifier");
0:             t.setDaemon(true);
0:             return t;
1:         }            
0:     });
/////////////////////////////////////////////////////////////////////////
0:                     final DiscoveryEvent event=new DiscoveryEvent(service);
1:                     
0:                     // Have the listener process the event async so that 
0:                     // he does not block this thread since we are doing time sensitive
0:                     // processing of events.
0:                     executor.execute(new Runnable() {
0:                         public void run() {
0:                             DiscoveryListener discoveryListener = MulticastDiscoveryAgent.this.discoveryListener;
0:                             if(discoveryListener!=null){
0:                                 discoveryListener.onServiceAdd(event);
1:                             }
1:                         }
0:                     });
0:                 lastKeepAlive=new AtomicLong(System.currentTimeMillis());
0:                 services.put(service,lastKeepAlive);
/////////////////////////////////////////////////////////////////////////
0:                     final DiscoveryEvent event=new DiscoveryEvent(service);
1:                     
0:                     // Have the listener process the event async so that 
0:                     // he does not block this thread since we are doing time sensitive
0:                     // processing of events.
0:                     executor.execute(new Runnable() {
0:                         public void run() {
0:                             DiscoveryListener discoveryListener = MulticastDiscoveryAgent.this.discoveryListener;
0:                             if(discoveryListener!=null){
0:                                 discoveryListener.onServiceRemove(event);
1:                             }
1:                         }
0:                     });
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport.discovery.multicast;
1: 
1: import java.io.IOException;
1: import java.net.DatagramPacket;
1: import java.net.InetAddress;
1: import java.net.InetSocketAddress;
1: import java.net.MulticastSocket;
1: import java.net.SocketAddress;
1: import java.net.SocketTimeoutException;
1: import java.net.URI;
1: import java.util.Iterator;
1: import java.util.Map;
1: 
0: import org.apache.activemq.command.DiscoveryEvent;
0: import org.apache.activemq.transport.discovery.DiscoveryAgent;
0: import org.apache.activemq.transport.discovery.DiscoveryListener;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean;
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicLong;
1: /**
0:  * A {@link DiscoveryAgent} using <a href="http://www.zeroconf.org/">Zeroconf</a> via the <a
0:  * href="http://jmdns.sf.net/">jmDNS</a> library
1:  * 
0:  * @version $Revision$
1:  */
0: public class MulticastDiscoveryAgent implements DiscoveryAgent,Runnable{
0:     private static final Log log=LogFactory.getLog(MulticastDiscoveryAgent.class);
0:     public static final String DEFAULT_DISCOVERY_URI_STRING="multicast://224.1.2.3:6155";
0:     private static final String TYPE_SUFFIX="ActiveMQ-4.";
0:     private static final String ALIVE="alive.";
0:     private static final String DEAD="dead.";
1:     private static final String DELIMITER = "%";
0:     private static final int BUFF_SIZE=8192;
0:     private static final int DEFAULT_IDLE_TIME=500;
0:     private static final int HEARTBEAT_MISS_BEFORE_DEATH=4;
0:     private int timeToLive=1;
0:     private boolean loopBackMode=false;
0:     private Map services=new ConcurrentHashMap();
0:     private Map brokers = new ConcurrentHashMap();
0:     private String group="default";
0:     private String brokerName;
0:     private URI discoveryURI;
0:     private InetAddress inetAddress;
0:     private SocketAddress sockAddress;
0:     private DiscoveryListener discoveryListener;
0:     private String selfService;
0:     private MulticastSocket mcast;
0:     private Thread runner;
0:     private long keepAliveInterval=DEFAULT_IDLE_TIME;
0:     private long lastAdvertizeTime=0;
0:     private AtomicBoolean started=new AtomicBoolean(false);
1: 
1:     /**
1:      * Set the discovery listener
1:      * 
1:      * @param listener
1:      */
0:     public void setDiscoveryListener(DiscoveryListener listener){
0:         this.discoveryListener=listener;
1:     }
1: 
1:     /**
1:      * register a service
1:      */
0:     public void registerService(String name) throws IOException{
0:         this.selfService=name;
0:         if (started.get()){
1:             doAdvertizeSelf();
1:         }
1:     }
1: 
1:     /**
0:      * Get the group used for discovery
1:      * 
0:      * @return the group
1:      */
0:     public String getGroup(){
0:         return group;
1:     }
1: 
1:     /**
0:      * Set the group for discovery
1:      * 
0:      * @param group
1:      */
0:     public void setGroup(String group){
0:         this.group=group;
1:     }
1: 
1:     /**
0:      * @return Returns the brokerName.
1:      */
0:     public String getBrokerName(){
0:         return brokerName;
1:     }
1: 
1:     /**
0:      * @param brokerName The brokerName to set.
1:      */
0:     public void setBrokerName(String brokerName){
0:         if (brokerName != null){
0:             brokerName = brokerName.replace('.','-');
0:             brokerName = brokerName.replace(':','-');
0:             brokerName = brokerName.replace('%','-');
0:         this.brokerName=brokerName;
1:         }
1:     }
1: 
1:     /**
1:      * @return Returns the loopBackMode.
1:      */
0:     public boolean isLoopBackMode(){
1:         return loopBackMode;
1:     }
1: 
1:     /**
0:      * @param loopBackMode
0:      *            The loopBackMode to set.
1:      */
0:     public void setLoopBackMode(boolean loopBackMode){
0:         this.loopBackMode=loopBackMode;
1:     }
1: 
1:     /**
1:      * @return Returns the timeToLive.
1:      */
0:     public int getTimeToLive(){
1:         return timeToLive;
1:     }
1: 
1:     /**
0:      * @param timeToLive
0:      *            The timeToLive to set.
1:      */
0:     public void setTimeToLive(int timeToLive){
0:         this.timeToLive=timeToLive;
1:     }
1: 
1:     /**
1:      * @return the discoveryURI
1:      */
0:     public URI getDiscoveryURI(){
1:         return discoveryURI;
1:     }
1: 
1:     /**
1:      * Set the discoveryURI
1:      * 
1:      * @param discoveryURI
1:      */
0:     public void setDiscoveryURI(URI discoveryURI){
0:         this.discoveryURI=discoveryURI;
1:     }
1: 
0:     public long getKeepAliveInterval(){
1:         return keepAliveInterval;
1:     }
1: 
0:     public void setKeepAliveInterval(long keepAliveInterval){
0:         this.keepAliveInterval=keepAliveInterval;
1:     }
1: 
1:     /**
1:      * start the discovery agent
1:      * 
1:      * @throws Exception
1:      */
0:     public void start() throws Exception{
0:         if(started.compareAndSet(false,true)){
0:             if(group==null|| group.length()==0){
1:                 throw new IOException("You must specify a group to discover");
1:             }
0:             if (brokerName == null || brokerName.length()==0){
0:                 log.warn("brokerName not set");
1:             }
0:             String type=getType();
0:             if(!type.endsWith(".")){
0:                 log.warn("The type '"+type+"' should end with '.' to be a valid Discovery type");
0:                 type+=".";
1:             }
0:             if(discoveryURI==null){
0:                 discoveryURI=new URI(DEFAULT_DISCOVERY_URI_STRING);
1:             }
0:             this.inetAddress=InetAddress.getByName(discoveryURI.getHost());
0:             this.sockAddress=new InetSocketAddress(this.inetAddress,discoveryURI.getPort());
0:             mcast=new MulticastSocket(discoveryURI.getPort());
1:             mcast.setLoopbackMode(loopBackMode);
1:             mcast.setTimeToLive(getTimeToLive());
0:             mcast.joinGroup(inetAddress);
0:             mcast.setSoTimeout((int) keepAliveInterval);
0:             runner=new Thread(this);
0:             runner.setName("MulticastDiscovery: "+selfService);
1:             runner.setDaemon(true);
1:             runner.start();
1:             doAdvertizeSelf();
1:         }
1:     }
1: 
1:     /**
1:      * stop the channel
1:      * 
1:      * @throws Exception
1:      */
0:     public void stop() throws Exception{
0:         if(started.compareAndSet(true,false)){
1:             doAdvertizeSelf();
0:             mcast.close();
1:         }
1:     }
1: 
0:     public String getType(){
0:         return group+"."+TYPE_SUFFIX;
1:     }
1: 
0:     public void run(){
0:         byte[] buf=new byte[BUFF_SIZE];
0:         DatagramPacket packet=new DatagramPacket(buf,0,buf.length);
0:         while(started.get()){
1:             doTimeKeepingServices();
0:             try{
1:                 mcast.receive(packet);
0:                 if(packet.getLength()>0){
0:                     String str=new String(packet.getData(),packet.getOffset(),packet.getLength());
1:                     processData(str);
1:                 }
0:             }catch(SocketTimeoutException se){
1:                 // ignore
0:             }catch(IOException e){
0:                 log.error("failed to process packet: "+e);
1:             }
1:         }
1:     }
1: 
0:     private void processData(String str){
0:         if (discoveryListener != null){
0:         if(str.startsWith(getType())){
0:             String payload=str.substring(getType().length());
0:             if(payload.startsWith(ALIVE)){
0:                 String brokerName=getBrokerName(payload.substring(ALIVE.length()));
0:                 String service=payload.substring(ALIVE.length()+brokerName.length()+2);
0:                 if(!brokerName.equals(this.brokerName)){
0:                     processAlive(brokerName,service);
1:                 }
0:             }else{
0:                 String brokerName=getBrokerName(payload.substring(DEAD.length()));
0:                 String service=payload.substring(DEAD.length()+brokerName.length()+2);
0:                 if(!brokerName.equals(this.brokerName)){
0:                     processDead(brokerName,service);
1:                 }
1:             }
1:         }
1:         }
1:     }
1: 
0:     private void doTimeKeepingServices(){
0:         if(started.get()){
0:             long currentTime=System.currentTimeMillis();
0:             if((currentTime-keepAliveInterval)>lastAdvertizeTime){
1:                 doAdvertizeSelf();
1:                 lastAdvertizeTime = currentTime;
1:             }
1:             doExpireOldServices();
1:         }
1:     }
1: 
0:     private void doAdvertizeSelf(){
0:         if(selfService!=null){
0:             String payload=getType();
0:             payload+=started.get()?ALIVE:DEAD;
0:             payload+=DELIMITER+brokerName+DELIMITER;
0:             payload+=selfService;
0:             try{
0:                 byte[] data=payload.getBytes();
0:                 DatagramPacket packet=new DatagramPacket(data,0,data.length,sockAddress);
1:                 mcast.send(packet);
0:             }catch(IOException e){
0:                 log.error("Failed to advertise our service: "+payload,e);
1:             }
1:         }
1:     }
1: 
0:     private void processAlive(String brokerName,String service){
0:         if(selfService == null || !service.equals(selfService)){
0:             AtomicLong lastKeepAlive=(AtomicLong) services.get(service);
0:             if(lastKeepAlive==null){
0:                 lastKeepAlive=new AtomicLong(System.currentTimeMillis());
0:                 services.put(service,lastKeepAlive);
0:                 brokers.put(service, brokerName);
0:                 if(discoveryListener!=null){
0:                     DiscoveryEvent event=new DiscoveryEvent(service);
0:                     event.setBrokerName(brokerName);
0:                     discoveryListener.onServiceAdd(event);
1:                 }
1:                 doAdvertizeSelf();
1:                 
1:             }
0:             lastKeepAlive.set(System.currentTimeMillis());
1:         }
1:     }
1: 
0:     private void processDead(String brokerName,String service){
0:         if(!service.equals(selfService)){
0:             if(services.remove(service)!=null){
0:                 brokers.remove(service);
0:                 if(discoveryListener!=null){
0:                     DiscoveryEvent event=new DiscoveryEvent(service);
0:                     event.setBrokerName(brokerName);
0:                     discoveryListener.onServiceRemove(event);
1:                 }
1:             }
1:         }
1:     }
1: 
0:     private void doExpireOldServices(){
0:         long expireTime=System.currentTimeMillis()-(keepAliveInterval*HEARTBEAT_MISS_BEFORE_DEATH);
0:         for(Iterator i=services.entrySet().iterator();i.hasNext();){
0:             Map.Entry entry=(Map.Entry) i.next();
0:             AtomicLong lastHeartBeat=(AtomicLong) entry.getValue();
0:             if(lastHeartBeat.get()<expireTime){
0:                 String brokerName = (String)brokers.get(entry.getKey());
0:                 processDead(brokerName,entry.getKey().toString());
1:             }
1:         }
1:     }
1:     
0:     private String getBrokerName(String str){
1:         String result = null;
1:         int start = str.indexOf(DELIMITER);
0:         if (start >= 0 ){
0:             int end = str.indexOf(DELIMITER,start+1);
0:             result=str.substring(start+1, end);
1:         }
1:         return result;
1:     }
1: 
1:     public void serviceFailed(DiscoveryEvent event) throws IOException {
0:         processDead(event.getBrokerName(), event.getServiceName());
1:     }
1: }
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:6c1676b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.ThreadPoolUtils;
/////////////////////////////////////////////////////////////////////////
1:             if (executor != null) {
1:                 ThreadPoolUtils.shutdownNow(executor);
1:                 executor = null;
0:             }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(MulticastDiscoveryAgent.class);
author:Robert Davies
-------------------------------------------------------------------------------
commit:8e06b20
/////////////////////////////////////////////////////////////////////////
1:     public static final String DEFAULT_HOST_IP  = System.getProperty("activemq.partition.discovery", "239.255.2.3"); 
/////////////////////////////////////////////////////////////////////////
commit:78aac70
/////////////////////////////////////////////////////////////////////////
1:     public static final String DEFAULT_HOST_STR = "default"; 
0:     public static final String DEFAULT_HOST_IP  = "239.255.2.3"; 
1:     public static final int    DEFAULT_PORT  = 6155; 
0:     
0:     
/////////////////////////////////////////////////////////////////////////
0:     	
0:         if (started.compareAndSet(false, true)) {        	
0:         	         	
/////////////////////////////////////////////////////////////////////////
0:             
0:             
1:             if (LOG.isTraceEnabled()) 
1:         	  	LOG.trace("start - discoveryURI = " + discoveryURI);        	  	        	  
0:         	  
1:         	  String myHost = discoveryURI.getHost();
1:         	  int    myPort = discoveryURI.getPort(); 
0:         	     
1:         	  if( DEFAULT_HOST_STR.equals(myHost) ) 
1:         	  	myHost = DEFAULT_HOST_IP;       	      	  
0:         	  
1:         	  if(myPort < 0 )
1:         	    myPort = DEFAULT_PORT;        	    
0:         	  
1:         	  if (LOG.isTraceEnabled()) {
1:         	  	LOG.trace("start - myHost = " + myHost); 
1:         	  	LOG.trace("start - myPort = " + myPort);   	
1:         	  	LOG.trace("start - myHost = " + myHost); 
0:         	  	LOG.trace("start - group  = " + group );   		       	  	
0:         	  }	
0:         	  
1:             this.inetAddress = InetAddress.getByName(myHost);
1:             this.sockAddress = new InetSocketAddress(this.inetAddress, myPort);
1:             mcast = new MulticastSocket(myPort);
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:46d98e1
/////////////////////////////////////////////////////////////////////////
0:             if (currentTime < lastAdvertizeTime || ((currentTime-keepAliveInterval)>lastAdvertizeTime)) {
author:Brian McCallister
-------------------------------------------------------------------------------
commit:47a97ef
/////////////////////////////////////////////////////////////////////////
0:     public static final String DEFAULT_DISCOVERY_URI_STRING="multicast://239.255.2.3:6155";
============================================================================