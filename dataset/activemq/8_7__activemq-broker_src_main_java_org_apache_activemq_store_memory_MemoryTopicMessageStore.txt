1:bb8d32c: /*
1:fc00993:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:fc00993:  * contributor license agreements.  See the NOTICE file distributed with
1:fc00993:  * this work for additional information regarding copyright ownership.
1:fc00993:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:fc00993:  * (the "License"); you may not use this file except in compliance with
1:fc00993:  * the License.  You may obtain a copy of the License at
1:a49d46e:  *
1:fc00993:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b0c2a40:  *
1:fc00993:  * Unless required by applicable law or agreed to in writing, software
1:fc00993:  * distributed under the License is distributed on an "AS IS" BASIS,
1:fc00993:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:fc00993:  * See the License for the specific language governing permissions and
1:fc00993:  * limitations under the License.
2:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.store.memory;
1:d29ca2a: 
1:d29ca2a: import java.io.IOException;
1:d29ca2a: import java.util.Collections;
1:d29ca2a: import java.util.HashMap;
1:bb8d32c: import java.util.List;
1:d29ca2a: import java.util.Map;
1:a49d46e: 
1:d29ca2a: import org.apache.activemq.broker.ConnectionContext;
1:d29ca2a: import org.apache.activemq.command.ActiveMQDestination;
1:d29ca2a: import org.apache.activemq.command.Message;
1:3432a75: import org.apache.activemq.command.MessageAck;
1:d29ca2a: import org.apache.activemq.command.MessageId;
1:d29ca2a: import org.apache.activemq.command.SubscriptionInfo;
1:d29ca2a: import org.apache.activemq.store.MessageRecoveryListener;
1:a49d46e: import org.apache.activemq.store.MessageStoreStatistics;
1:cf3d419: import org.apache.activemq.store.MessageStoreSubscriptionStatistics;
1:d29ca2a: import org.apache.activemq.store.TopicMessageStore;
1:b1c94aa: import org.apache.activemq.util.LRUCache;
1:d29ca2a: import org.apache.activemq.util.SubscriptionKey;
1:d29ca2a: 
1:f812e34: public class MemoryTopicMessageStore extends MemoryMessageStore implements TopicMessageStore {
1:d29ca2a: 
1:933eb2f:     private Map<SubscriptionKey, SubscriptionInfo> subscriberDatabase;
1:933eb2f:     private Map<SubscriptionKey, MemoryTopicSub> topicSubMap;
1:a49d46e:     private final Map<MessageId, Message> originalMessageTable;
1:d29ca2a: 
1:f812e34:     public MemoryTopicMessageStore(ActiveMQDestination destination) {
1:a49d46e:         this(destination, new MemoryTopicMessageStoreLRUCache(100, 100, 0.75f, false), makeSubscriptionInfoMap());
1:a49d46e: 
1:bb8d32c:         // Set the messageStoreStatistics after the super class is initialized
1:bb8d32c:         // so that the stats can be properly updated on cache eviction
1:a49d46e:         MemoryTopicMessageStoreLRUCache cache = (MemoryTopicMessageStoreLRUCache) originalMessageTable;
1:a49d46e:         cache.setMessageStoreStatistics(messageStoreStatistics);
1:d29ca2a:     }
1:d29ca2a: 
1:bb8d32c:     public MemoryTopicMessageStore(ActiveMQDestination destination, Map<MessageId, Message> messageTable,
1:bb8d32c:         Map<SubscriptionKey, SubscriptionInfo> subscriberDatabase) {
1:f812e34:         super(destination, messageTable);
1:f812e34:         this.subscriberDatabase = subscriberDatabase;
1:933eb2f:         this.topicSubMap = makeSubMap();
1:bb8d32c:         // this is only necessary so that messageStoreStatistics can be set if
1:bb8d32c:         // necessary We need the original reference since messageTable is wrapped
1:bb8d32c:         // in a synchronized map in the parent class
1:a49d46e:         this.originalMessageTable = messageTable;
1:933eb2f:     }
1:933eb2f: 
1:933eb2f:     protected static Map<SubscriptionKey, SubscriptionInfo> makeSubscriptionInfoMap() {
1:933eb2f:         return Collections.synchronizedMap(new HashMap<SubscriptionKey, SubscriptionInfo>());
1:933eb2f:     }
1:a49d46e: 
1:933eb2f:     protected static Map<SubscriptionKey, MemoryTopicSub> makeSubMap() {
1:933eb2f:         return Collections.synchronizedMap(new HashMap<SubscriptionKey, MemoryTopicSub>());
1:d29ca2a:     }
1:933eb2f: 
1:a49d46e:     @Override
1:f812e34:     public synchronized void addMessage(ConnectionContext context, Message message) throws IOException {
1:f812e34:         super.addMessage(context, message);
1:bb8d32c:         for (MemoryTopicSub sub : topicSubMap.values()) {
1:f812e34:             sub.addMessage(message.getMessageId(), message);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:a49d46e:     @Override
1:bb8d32c:     public synchronized void acknowledge(ConnectionContext context, String clientId, String subscriptionName, MessageId messageId, MessageAck ack) throws IOException {
1:bb8d32c:         super.removeMessage(messageId);
1:f812e34:         SubscriptionKey key = new SubscriptionKey(clientId, subscriptionName);
1:933eb2f:         MemoryTopicSub sub = topicSubMap.get(key);
1:f812e34:         if (sub != null) {
1:b1c94aa:             sub.removeMessage(messageId);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:a49d46e:     @Override
1:2a153b0:     public synchronized SubscriptionInfo lookupSubscription(String clientId, String subscriptionName) throws IOException {
1:933eb2f:         return subscriberDatabase.get(new SubscriptionKey(clientId, subscriptionName));
1:d29ca2a:     }
1:d29ca2a: 
1:a49d46e:     @Override
1:c0090f6:     public synchronized void addSubscription(SubscriptionInfo info, boolean retroactive) throws IOException {
1:f812e34:         SubscriptionKey key = new SubscriptionKey(info);
1:bb8d32c:         MemoryTopicSub sub = new MemoryTopicSub(key);
1:f812e34:         topicSubMap.put(key, sub);
1:f812e34:         if (retroactive) {
1:bb8d32c:             for (Map.Entry<MessageId, Message> entry : messageTable.entrySet()) {
1:bb8d32c:                 sub.addMessage(entry.getKey(), entry.getValue());
1:d29ca2a:             }
1:d29ca2a:         }
1:f812e34:         subscriberDatabase.put(key, info);
1:d29ca2a:     }
1:d29ca2a: 
1:a49d46e:     @Override
1:2a153b0:     public synchronized void deleteSubscription(String clientId, String subscriptionName) {
1:bb8d32c:         SubscriptionKey key = new SubscriptionKey(clientId, subscriptionName);
1:bb8d32c:         subscriberDatabase.remove(key);
1:bb8d32c:         MemoryTopicSub subscription = topicSubMap.get(key);
1:bb8d32c:         if (subscription != null) {
1:bb8d32c:             List<Message> storedMessages = subscription.getStoredMessages();
1:bb8d32c:             for (Message message : storedMessages) {
1:bb8d32c:                 try {
1:bb8d32c:                     acknowledge(null, key.getClientId(), key.getSubscriptionName(), message.getMessageId(), null);
1:bb8d32c:                 } catch (IOException e) {
1:bb8d32c:                 }
1:bb8d32c:             }
1:bb8d32c:         }
1:bb8d32c: 
1:d29ca2a:         subscriberDatabase.remove(key);
1:b1c94aa:         topicSubMap.remove(key);
1:d29ca2a:     }
1:d29ca2a: 
1:a49d46e:     @Override
1:2a153b0:     public synchronized void recoverSubscription(String clientId, String subscriptionName, MessageRecoveryListener listener) throws Exception {
1:933eb2f:         MemoryTopicSub sub = topicSubMap.get(new SubscriptionKey(clientId, subscriptionName));
1:f812e34:         if (sub != null) {
1:b1c94aa:             sub.recoverSubscription(listener);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:a49d46e:     @Override
1:2a153b0:     public synchronized void delete() {
1:d29ca2a:         super.delete();
1:d29ca2a:         subscriberDatabase.clear();
1:b1c94aa:         topicSubMap.clear();
1:d29ca2a:     }
1:9b64c37: 
1:a49d46e:     @Override
1:f812e34:     public SubscriptionInfo[] getAllSubscriptions() throws IOException {
1:933eb2f:         return subscriberDatabase.values().toArray(new SubscriptionInfo[subscriberDatabase.size()]);
1:9b64c37:     }
1:d29ca2a: 
1:a49d46e:     @Override
1:f812e34:     public synchronized int getMessageCount(String clientId, String subscriberName) throws IOException {
1:f812e34:         int result = 0;
1:933eb2f:         MemoryTopicSub sub = topicSubMap.get(new SubscriptionKey(clientId, subscriberName));
1:f812e34:         if (sub != null) {
1:f812e34:             result = sub.size();
1:b1c94aa:         }
1:4eef609:         return result;
1:b1c94aa:     }
1:d29ca2a: 
1:a49d46e:     @Override
1:734fb7d:     public synchronized long getMessageSize(String clientId, String subscriberName) throws IOException {
1:734fb7d:         long result = 0;
1:734fb7d:         MemoryTopicSub sub = topicSubMap.get(new SubscriptionKey(clientId, subscriberName));
1:734fb7d:         if (sub != null) {
1:734fb7d:             result = sub.messageSize();
1:734fb7d:         }
1:734fb7d:         return result;
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     @Override
1:2a153b0:     public synchronized void recoverNextMessages(String clientId, String subscriptionName, int maxReturned, MessageRecoveryListener listener) throws Exception {
1:149428b:         MemoryTopicSub sub = this.topicSubMap.get(new SubscriptionKey(clientId, subscriptionName));
1:f812e34:         if (sub != null) {
1:f812e34:             sub.recoverNextMessages(maxReturned, listener);
1:b1c94aa:         }
7:a110604:     }
2:a110604: 
1:a49d46e:     @Override
1:f812e34:     public void resetBatching(String clientId, String subscriptionName) {
2:933eb2f:         MemoryTopicSub sub = topicSubMap.get(new SubscriptionKey(clientId, subscriptionName));
1:f812e34:         if (sub != null) {
1:b1c94aa:             sub.resetBatching();
1:a49d46e:         }
1:b1c94aa:     }
1:a49d46e: 
1:bb8d32c:     // Disabled for the memory store, can be enabled later if necessary
1:cf3d419:     private final MessageStoreSubscriptionStatistics stats = new MessageStoreSubscriptionStatistics(false);
1:cf3d419: 
1:cf3d419:     @Override
1:cf3d419:     public MessageStoreSubscriptionStatistics getMessageStoreSubStatistics() {
1:cf3d419:         return stats;
1:cf3d419:     }
1:cf3d419: 
1:a49d46e:     /**
1:bb8d32c:      * Since we initialize the store with a LRUCache in some cases, we need to
1:bb8d32c:      * account for cache evictions when computing the message store statistics.
1:a49d46e:      *
1:a49d46e:      */
1:a49d46e:     private static class MemoryTopicMessageStoreLRUCache extends LRUCache<MessageId, Message> {
1:a49d46e:         private static final long serialVersionUID = -342098639681884413L;
1:a49d46e:         private MessageStoreStatistics messageStoreStatistics;
1:a49d46e: 
1:bb8d32c:         public MemoryTopicMessageStoreLRUCache(int initialCapacity, int maximumCacheSize, float loadFactor, boolean accessOrder) {
1:a49d46e:             super(initialCapacity, maximumCacheSize, loadFactor, accessOrder);
1:a49d46e:         }
1:a49d46e: 
1:bb8d32c:         public void setMessageStoreStatistics(MessageStoreStatistics messageStoreStatistics) {
1:a49d46e:             this.messageStoreStatistics = messageStoreStatistics;
1:a49d46e:         }
1:a49d46e: 
1:a49d46e:         @Override
1:a49d46e:         protected void onCacheEviction(Map.Entry<MessageId, Message> eldest) {
1:c6542a9:             decMessageStoreStatistics(messageStoreStatistics, eldest.getValue());
1:bb8d32c: 
1:bb8d32c:             // We aren't tracking this anymore so remove our reference to it.
1:bb8d32c:             eldest.getValue().decrementReferenceCount();
1:a49d46e:         }
1:a49d46e:     }
1:d29ca2a: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Timothy Bish
-------------------------------------------------------------------------------
commit:bb8d32c
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // Set the messageStoreStatistics after the super class is initialized
1:         // so that the stats can be properly updated on cache eviction
1:     public MemoryTopicMessageStore(ActiveMQDestination destination, Map<MessageId, Message> messageTable,
1:         Map<SubscriptionKey, SubscriptionInfo> subscriberDatabase) {
1:         // this is only necessary so that messageStoreStatistics can be set if
1:         // necessary We need the original reference since messageTable is wrapped
1:         // in a synchronized map in the parent class
/////////////////////////////////////////////////////////////////////////
1:         for (MemoryTopicSub sub : topicSubMap.values()) {
1:     public synchronized void acknowledge(ConnectionContext context, String clientId, String subscriptionName, MessageId messageId, MessageAck ack) throws IOException {
1:         super.removeMessage(messageId);
/////////////////////////////////////////////////////////////////////////
1:         MemoryTopicSub sub = new MemoryTopicSub(key);
1:             for (Map.Entry<MessageId, Message> entry : messageTable.entrySet()) {
1:                 sub.addMessage(entry.getKey(), entry.getValue());
/////////////////////////////////////////////////////////////////////////
1:         SubscriptionKey key = new SubscriptionKey(clientId, subscriptionName);
1:         subscriberDatabase.remove(key);
1:         MemoryTopicSub subscription = topicSubMap.get(key);
1:         if (subscription != null) {
1:             List<Message> storedMessages = subscription.getStoredMessages();
1:             for (Message message : storedMessages) {
1:                 try {
1:                     acknowledge(null, key.getClientId(), key.getSubscriptionName(), message.getMessageId(), null);
1:                 } catch (IOException e) {
1:                 }
1:             }
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:     // Disabled for the memory store, can be enabled later if necessary
/////////////////////////////////////////////////////////////////////////
1:      * Since we initialize the store with a LRUCache in some cases, we need to
1:      * account for cache evictions when computing the message store statistics.
1:         public MemoryTopicMessageStoreLRUCache(int initialCapacity, int maximumCacheSize, float loadFactor, boolean accessOrder) {
1:         public void setMessageStoreStatistics(MessageStoreStatistics messageStoreStatistics) {
1: 
1:             // We aren't tracking this anymore so remove our reference to it.
1:             eldest.getValue().decrementReferenceCount();
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:cf3d419
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.MessageStoreSubscriptionStatistics;
/////////////////////////////////////////////////////////////////////////
0:     //Disabled for the memory store, can be enabled later if necessary
1:     private final MessageStoreSubscriptionStatistics stats = new MessageStoreSubscriptionStatistics(false);
1: 
1:     @Override
1:     public MessageStoreSubscriptionStatistics getMessageStoreSubStatistics() {
1:         return stats;
1:     }
1: 
commit:734fb7d
/////////////////////////////////////////////////////////////////////////
1:     public synchronized long getMessageSize(String clientId, String subscriberName) throws IOException {
1:         long result = 0;
1:         MemoryTopicSub sub = topicSubMap.get(new SubscriptionKey(clientId, subscriberName));
1:         if (sub != null) {
1:             result = sub.messageSize();
1:         }
1:         return result;
1:     }
1: 
1:     @Override
commit:a49d46e
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.MessageStoreStatistics;
1:  *
1:     private final Map<MessageId, Message> originalMessageTable;
1:         this(destination, new MemoryTopicMessageStoreLRUCache(100, 100, 0.75f, false), makeSubscriptionInfoMap());
1: 
0:         //Set the messageStoreStatistics after the super class is initialized so that the stats can be
0:         //properly updated on cache eviction
1:         MemoryTopicMessageStoreLRUCache cache = (MemoryTopicMessageStoreLRUCache) originalMessageTable;
1:         cache.setMessageStoreStatistics(messageStoreStatistics);
0:         //this is only necessary so that messageStoreStatistics can be set if necessary
0:         //We need the original reference since messageTable is wrapped in a synchronized map in the parent class
1:         this.originalMessageTable = messageTable;
1: 
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1: 
1:     /**
0:      * Since we initialize the store with a LRUCache in some cases, we need to account for cache evictions
0:      * when computing the message store statistics.
1:      *
1:      */
1:     private static class MemoryTopicMessageStoreLRUCache extends LRUCache<MessageId, Message> {
1:         private static final long serialVersionUID = -342098639681884413L;
1:         private MessageStoreStatistics messageStoreStatistics;
1: 
0:         public MemoryTopicMessageStoreLRUCache(int initialCapacity, int maximumCacheSize,
0:                 float loadFactor, boolean accessOrder) {
1:             super(initialCapacity, maximumCacheSize, loadFactor, accessOrder);
1:         }
1: 
0:         public void setMessageStoreStatistics(
0:                 MessageStoreStatistics messageStoreStatistics) {
1:             this.messageStoreStatistics = messageStoreStatistics;
1:         }
1: 
1:         @Override
1:         protected void onCacheEviction(Map.Entry<MessageId, Message> eldest) {
0:             if (messageStoreStatistics != null) {
0:                 messageStoreStatistics.getMessageCount().decrement();
0:                 messageStoreStatistics.getMessageSize().addSize(-eldest.getValue().getSize());
1:             }
1:         }
1:     }
author:Christopher L. Shannon
-------------------------------------------------------------------------------
commit:c6542a9
/////////////////////////////////////////////////////////////////////////
1:             decMessageStoreStatistics(messageStoreStatistics, eldest.getValue());
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:c0090f6
/////////////////////////////////////////////////////////////////////////
1:     public synchronized void addSubscription(SubscriptionInfo info, boolean retroactive) throws IOException {
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
1:     private Map<SubscriptionKey, SubscriptionInfo> subscriberDatabase;
1:     private Map<SubscriptionKey, MemoryTopicSub> topicSubMap;
0:         this(destination, new LRUCache<MessageId, Message>(100, 100, 0.75f, false), makeSubscriptionInfoMap());
0:     public MemoryTopicMessageStore(ActiveMQDestination destination, Map<MessageId, Message> messageTable, Map<SubscriptionKey, SubscriptionInfo> subscriberDatabase) {
1:         this.topicSubMap = makeSubMap();
1:     }
1: 
1:     protected static Map<SubscriptionKey, SubscriptionInfo> makeSubscriptionInfoMap() {
1:         return Collections.synchronizedMap(new HashMap<SubscriptionKey, SubscriptionInfo>());
1:     }
1:     
1:     protected static Map<SubscriptionKey, MemoryTopicSub> makeSubMap() {
1:         return Collections.synchronizedMap(new HashMap<SubscriptionKey, MemoryTopicSub>());
0:         for (Iterator<MemoryTopicSub> i = topicSubMap.values().iterator(); i.hasNext();) {
0:             MemoryTopicSub sub = i.next();
1:         MemoryTopicSub sub = topicSubMap.get(key);
1:         return subscriberDatabase.get(new SubscriptionKey(clientId, subscriptionName));
/////////////////////////////////////////////////////////////////////////
1:         MemoryTopicSub sub = topicSubMap.get(new SubscriptionKey(clientId, subscriptionName));
/////////////////////////////////////////////////////////////////////////
1:         return subscriberDatabase.values().toArray(new SubscriptionInfo[subscriberDatabase.size()]);
1:         MemoryTopicSub sub = topicSubMap.get(new SubscriptionKey(clientId, subscriberName));
/////////////////////////////////////////////////////////////////////////
1:         MemoryTopicSub sub = topicSubMap.get(new SubscriptionKey(clientId, subscriptionName));
1:         MemoryTopicSub sub = topicSubMap.get(new SubscriptionKey(clientId, subscriptionName));
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
0:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1: public class MemoryTopicMessageStore extends MemoryMessageStore implements TopicMessageStore {
1:     public MemoryTopicMessageStore(ActiveMQDestination destination) {
0:         this(destination, new LRUCache(100, 100, 0.75f, false), makeMap());
0:     protected static Map makeMap() {
0:     public MemoryTopicMessageStore(ActiveMQDestination destination, Map messageTable, Map subscriberDatabase) {
1:         super(destination, messageTable);
1:         this.subscriberDatabase = subscriberDatabase;
0:         this.topicSubMap = makeMap();
1:     public synchronized void addMessage(ConnectionContext context, Message message) throws IOException {
1:         super.addMessage(context, message);
0:         for (Iterator i = topicSubMap.values().iterator(); i.hasNext();) {
0:             MemoryTopicSub sub = (MemoryTopicSub)i.next();
1:             sub.addMessage(message.getMessageId(), message);
0:     public synchronized void acknowledge(ConnectionContext context, String clientId, String subscriptionName, MessageId messageId) throws IOException {
1:         SubscriptionKey key = new SubscriptionKey(clientId, subscriptionName);
0:         MemoryTopicSub sub = (MemoryTopicSub)topicSubMap.get(key);
1:         if (sub != null) {
0:     public SubscriptionInfo lookupSubscription(String clientId, String subscriptionName) throws IOException {
0:         return (SubscriptionInfo)subscriberDatabase.get(new SubscriptionKey(clientId, subscriptionName));
0:     public synchronized void addSubsciption(SubscriptionInfo info, boolean retroactive) throws IOException {
1:         SubscriptionKey key = new SubscriptionKey(info);
0:         MemoryTopicSub sub = new MemoryTopicSub();
1:         topicSubMap.put(key, sub);
1:         if (retroactive) {
0:             for (Iterator i = messageTable.entrySet().iterator(); i.hasNext();) {
0:                 Map.Entry entry = (Entry)i.next();
0:                 sub.addMessage((MessageId)entry.getKey(), (Message)entry.getValue());
1:         subscriberDatabase.put(key, info);
0:     public void deleteSubscription(String clientId, String subscriptionName) {
0:         org.apache.activemq.util.SubscriptionKey key = new SubscriptionKey(clientId, subscriptionName);
0:     public void recoverSubscription(String clientId, String subscriptionName, MessageRecoveryListener listener) throws Exception {
0:         MemoryTopicSub sub = (MemoryTopicSub)topicSubMap.get(new SubscriptionKey(clientId, subscriptionName));
1:         if (sub != null) {
0:     public void delete() {
1:     public SubscriptionInfo[] getAllSubscriptions() throws IOException {
1:     public synchronized int getMessageCount(String clientId, String subscriberName) throws IOException {
1:         int result = 0;
0:         MemoryTopicSub sub = (MemoryTopicSub)topicSubMap.get(new SubscriptionKey(clientId, subscriberName));
1:         if (sub != null) {
1:             result = sub.size();
0:     public void recoverNextMessages(String clientId, String subscriptionName, int maxReturned, MessageRecoveryListener listener) throws Exception {
0:         MemoryTopicSub sub = (MemoryTopicSub)topicSubMap.get(new SubscriptionKey(clientId, subscriptionName));
1:         if (sub != null) {
1:             sub.recoverNextMessages(maxReturned, listener);
1:     public void resetBatching(String clientId, String subscriptionName) {
0:         MemoryTopicSub sub = (MemoryTopicSub)topicSubMap.get(new SubscriptionKey(clientId, subscriptionName));
1:         if (sub != null) {
commit:2728ccb
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void addSubsciption(SubscriptionInfo info,boolean retroactive)
0:         SubscriptionKey key=new SubscriptionKey(info);
commit:57b4941
/////////////////////////////////////////////////////////////////////////
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
0:  * contributor license agreements.  See the NOTICE file distributed with
0:  * this work for additional information regarding copyright ownership.
0:  * The ASF licenses this file to You under the Apache License, Version 2.0
0:  * (the "License"); you may not use this file except in compliance with
0:  * the License.  You may obtain a copy of the License at
commit:7f5213b
/////////////////////////////////////////////////////////////////////////
0:                     throws Exception{
commit:9b64c37
/////////////////////////////////////////////////////////////////////////
1:     
0:     public SubscriptionInfo[] getAllSubscriptions() throws IOException {
0:         return (SubscriptionInfo[]) subscriberDatabase.values().toArray(new SubscriptionInfo[subscriberDatabase.size()]);
1:     }
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
0: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
1:  */
1: package org.apache.activemq.store.memory;
1: 
1: import java.io.IOException;
1: import java.util.Collections;
1: import java.util.HashMap;
0: import java.util.Iterator;
0: import java.util.LinkedHashMap;
1: import java.util.Map;
0: import java.util.Map.Entry;
1: 
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.command.SubscriptionInfo;
1: import org.apache.activemq.store.MessageRecoveryListener;
1: import org.apache.activemq.store.TopicMessageStore;
1: import org.apache.activemq.util.SubscriptionKey;
1: 
0: /**
0:  * @version $Revision: 1.5 $
1:  */
0: public class MemoryTopicMessageStore extends MemoryMessageStore implements TopicMessageStore {
1: 
0:     private Map ackDatabase;
0:     private Map subscriberDatabase;
0:     MessageId lastMessageId;
1:     
0:     public MemoryTopicMessageStore(ActiveMQDestination destination) {
0:         this(destination, new LinkedHashMap(), makeMap(), makeMap());
1:     }
0:     protected static Map makeMap() {
0:         return Collections.synchronizedMap(new HashMap());
1:     }
1:     
0:     public MemoryTopicMessageStore(ActiveMQDestination destination, Map messageTable, Map subscriberDatabase, Map ackDatabase) {
0:         super(destination, messageTable);
0:         this.subscriberDatabase = subscriberDatabase;
0:         this.ackDatabase = ackDatabase;
1:     }
1: 
0:     public synchronized void addMessage(ConnectionContext context, Message message) throws IOException {
0:         super.addMessage(context, message);
0:         lastMessageId = message.getMessageId();
1:     }
1: 
0:     public void acknowledge(ConnectionContext context, String clientId, String subscriptionName, MessageId messageId) throws IOException {
0:         ackDatabase.put(new SubscriptionKey(clientId, subscriptionName), messageId);
1:     }
1: 
0:     public SubscriptionInfo lookupSubscription(String clientId, String subscriptionName) throws IOException {
0:         return (SubscriptionInfo) subscriberDatabase.get(new SubscriptionKey(clientId, subscriptionName));
1:     }
1: 
0:     public void addSubsciption(String clientId, String subscriptionName, String selector, boolean retroactive) throws IOException {
0:         SubscriptionInfo info = new SubscriptionInfo();
0:         info.setDestination(destination);
0:         info.setClientId(clientId);
0:         info.setSelector(selector);
0:         info.setSubcriptionName(subscriptionName);
0:         SubscriptionKey key = new SubscriptionKey(clientId, subscriptionName);
0:         subscriberDatabase.put(key, info);
0:         MessageId l=retroactive ? null : lastMessageId;
0:         if( l!=null ) {
0:             ackDatabase.put(key, l);
1:         }
1:     }
1:     
0:     public void deleteSubscription(String clientId, String subscriptionName) {
0:         org.apache.activemq.util.SubscriptionKey key = new SubscriptionKey(clientId, subscriptionName);
0:         ackDatabase.remove(key);
1:         subscriberDatabase.remove(key);
1:     }
1:     
0:     public void recoverSubscription(String clientId, String subscriptionName, MessageRecoveryListener listener) throws Throwable {
0:         MessageId lastAck = (MessageId) ackDatabase.get(new SubscriptionKey(clientId, subscriptionName));
0:         boolean pastLastAck = lastAck==null;        
0:         for (Iterator iter = messageTable.entrySet().iterator(); iter.hasNext();) {
0:             Map.Entry entry = (Entry) iter.next();
0:             if( pastLastAck ) {
0:                 Object msg = entry.getValue();
0:                 if( msg.getClass() == String.class ) {
0:                     listener.recoverMessageReference((String) msg);
0:                 } else {
0:                     listener.recoverMessage((Message) msg);
1:                 }
0:             } else {
0:                 pastLastAck = entry.getKey().equals(lastAck);
1:             }
1:         }
1:     }
1: 
0:     public void delete() {
1:         super.delete();
0:         ackDatabase.clear();
1:         subscriberDatabase.clear();
0:         lastMessageId=null;
1:     }
1: }
author:Gary Tully
-------------------------------------------------------------------------------
commit:3432a75
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.MessageAck;
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void acknowledge(ConnectionContext context, String clientId, String subscriptionName,
0:                                          MessageId messageId, MessageAck ack) throws IOException {
author:Robert Davies
-------------------------------------------------------------------------------
commit:2a153b0
/////////////////////////////////////////////////////////////////////////
1:     public synchronized SubscriptionInfo lookupSubscription(String clientId, String subscriptionName) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     public synchronized void deleteSubscription(String clientId, String subscriptionName) {
1:     public synchronized void recoverSubscription(String clientId, String subscriptionName, MessageRecoveryListener listener) throws Exception {
1:     public synchronized void delete() {
/////////////////////////////////////////////////////////////////////////
1:     public synchronized void recoverNextMessages(String clientId, String subscriptionName, int maxReturned, MessageRecoveryListener listener) throws Exception {
commit:149428b
/////////////////////////////////////////////////////////////////////////
1:         MemoryTopicSub sub = this.topicSubMap.get(new SubscriptionKey(clientId, subscriptionName));
commit:b1c94aa
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.LRUCache;
/////////////////////////////////////////////////////////////////////////
0:     private Map topicSubMap;
0:         this(destination,new LRUCache(100,100,0.75f,false),makeMap());
0:     public MemoryTopicMessageStore(ActiveMQDestination destination,Map messageTable,Map subscriberDatabase){
0:         this.topicSubMap=makeMap();
0:         for(Iterator i=topicSubMap.values().iterator();i.hasNext();){
0:             MemoryTopicSub sub=(MemoryTopicSub)i.next();
0:             sub.addMessage(message.getMessageId(),message);
1:         }
0:     public synchronized void acknowledge(ConnectionContext context,String clientId,String subscriptionName,
0:             MessageId messageId) throws IOException{
0:         SubscriptionKey key=new SubscriptionKey(clientId,subscriptionName);
0:         MemoryTopicSub sub=(MemoryTopicSub)topicSubMap.get(key);
0:         if(sub!=null){
1:             sub.removeMessage(messageId);
1:         }
0:     public synchronized void addSubsciption(String clientId,String subscriptionName,String selector,boolean retroactive)
/////////////////////////////////////////////////////////////////////////
0:         MemoryTopicSub sub=new MemoryTopicSub();
0:         topicSubMap.put(key,sub);
0:         if(retroactive){
0:             for(Iterator i=messageTable.entrySet().iterator();i.hasNext();){
0:                 Map.Entry entry=(Entry)i.next();
0:                 sub.addMessage((MessageId)entry.getKey(),(Message)entry.getValue());
1:             }
0:         subscriberDatabase.put(key,info);
1:         topicSubMap.remove(key);
0:         MemoryTopicSub sub=(MemoryTopicSub)topicSubMap.get(new SubscriptionKey(clientId,subscriptionName));
0:         if(sub!=null){
1:             sub.recoverSubscription(listener);
1:         topicSubMap.clear();
0:     public synchronized int getMessageCount(String clientId,String subscriberName) throws IOException{
0:         MemoryTopicSub sub=(MemoryTopicSub)topicSubMap.get(new SubscriptionKey(clientId,subscriberName));
0:         if(sub!=null){
0:             result=sub.size();
0:         MemoryTopicSub sub=(MemoryTopicSub)topicSubMap.get(new SubscriptionKey(clientId,subscriptionName));
0:         if(sub!=null){
0:             sub.recoverNextMessages(maxReturned,listener);
0:         MemoryTopicSub sub=(MemoryTopicSub)topicSubMap.get(new SubscriptionKey(clientId,subscriptionName));
0:         if(sub!=null){
1:             sub.resetBatching();
1:         }
commit:a110604
/////////////////////////////////////////////////////////////////////////
0:     private Map batchDatabase;
0:         this(destination,new LinkedHashMap(),makeMap(),makeMap(),makeMap());
/////////////////////////////////////////////////////////////////////////
0:             Map ackDatabase, Map batchDatabase){
0:         this.batchDatabase=batchDatabase;
/////////////////////////////////////////////////////////////////////////
1:        
1:    
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             if(lastAck!=null){
0:                 for(Iterator iter=messageTable.entrySet().iterator();iter.hasNext();){
0:                     Map.Entry entry=(Entry)iter.next();
0:                     if(entry.getKey().equals(lastAck)){
0:                         break;
1:                     }
0:                     result--;
0:     
0:         SubscriptionKey key = new SubscriptionKey(clientId,subscriptionName);
0:         MessageId lastBatch = (MessageId)batchDatabase.get(key);
0:         if (lastBatch==null) {
0:             //if last batch null - start from last ack
0:             lastBatch = (MessageId)ackDatabase.get(key);
1:         }
0:         boolean pastLackBatch=lastBatch==null;
0:         MessageId lastId = null;
0:         // the message table is a synchronizedMap - so just have to synchronize here
0:         int count = 0;
0:         synchronized(messageTable){
0:             for(Iterator iter=messageTable.entrySet().iterator();iter.hasNext() &&count < maxReturned ;){
0:                 Map.Entry entry=(Entry)iter.next();
0:                 if(pastLackBatch){
0:                     count++;
0:                     Object msg=entry.getValue();
0:                     lastId = (MessageId)entry.getKey();
0:                     if(msg.getClass()==String.class){
0:                         listener.recoverMessageReference((String)msg);
0:                     }else{
0:                         listener.recoverMessage((Message)msg);
1:                     }
0:                 }else{
0:                     pastLackBatch=entry.getKey().equals(lastBatch);
1:                 }
1:             }
0:             if (lastId != null) {
0:                 batchDatabase.put(key,lastId);
1:             }
0:             listener.finished();
1:         }
0:         batchDatabase.remove(new SubscriptionKey(clientId,subscriptionName));
commit:629bc81
/////////////////////////////////////////////////////////////////////////
0:  * 
0:  * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE
0:  * file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file
0:  * to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
0:  * License. You may obtain a copy of the License at
0:  * 
0:  * 
0:  * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
0:  * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
0:  * specific language governing permissions and limitations under the License.
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: public class MemoryTopicMessageStore extends MemoryMessageStore implements TopicMessageStore{
0: 
0:     public MemoryTopicMessageStore(ActiveMQDestination destination){
0:         this(destination,new LinkedHashMap(),makeMap(),makeMap());
0: 
0:     protected static Map makeMap(){
0: 
0:     public MemoryTopicMessageStore(ActiveMQDestination destination,Map messageTable,Map subscriberDatabase,
0:             Map ackDatabase){
0:         super(destination,messageTable);
0:         this.subscriberDatabase=subscriberDatabase;
0:         this.ackDatabase=ackDatabase;
0:     public synchronized void addMessage(ConnectionContext context,Message message) throws IOException{
0:         super.addMessage(context,message);
0:         lastMessageId=message.getMessageId();
0:     public void acknowledge(ConnectionContext context,String clientId,String subscriptionName,MessageId messageId)
0:             throws IOException{
0:         ackDatabase.put(new SubscriptionKey(clientId,subscriptionName),messageId);
0:     public SubscriptionInfo lookupSubscription(String clientId,String subscriptionName) throws IOException{
0:         return (SubscriptionInfo)subscriberDatabase.get(new SubscriptionKey(clientId,subscriptionName));
0:     public void addSubsciption(String clientId,String subscriptionName,String selector,boolean retroactive)
0:             throws IOException{
0:         SubscriptionInfo info=new SubscriptionInfo();
0:         SubscriptionKey key=new SubscriptionKey(clientId,subscriptionName);
0:         subscriberDatabase.put(key,info);
0:         MessageId l=retroactive?null:lastMessageId;
0:         if(l!=null){
0:             ackDatabase.put(key,l);
0: 
0:     public void deleteSubscription(String clientId,String subscriptionName){
0:         org.apache.activemq.util.SubscriptionKey key=new SubscriptionKey(clientId,subscriptionName);
0: 
0:             throws Exception{
0:         MessageId lastAck=(MessageId)ackDatabase.get(new SubscriptionKey(clientId,subscriptionName));
0:                 Map.Entry entry=(Entry)iter.next();
0:                         listener.recoverMessageReference((String)msg);
0:                         listener.recoverMessage((Message)msg);
/////////////////////////////////////////////////////////////////////////
0: 
0:     public void recoverNextMessages(String clientId,String subscriptionName,MessageId lastMessageId,int maxReturned,
0:             MessageRecoveryListener listener) throws Exception{
0:         listener.finished();
0:     public void delete(){
0: 
0:     public SubscriptionInfo[] getAllSubscriptions() throws IOException{
0:         return (SubscriptionInfo[])subscriberDatabase.values().toArray(new SubscriptionInfo[subscriberDatabase.size()]);
0: 
0: 
0:     public MessageId getPreviousMessageIdToDeliver(String clientId,String subscriptionName,MessageId id)
0:             throws IOException{
0: 
0:         int result=0;
0:         MessageId lastAck=(MessageId)ackDatabase.get(new SubscriptionKey(clientId,subscriberName));
0:             result=messageTable.size();
0:                 Map.Entry entry=(Entry)iter.next();
/////////////////////////////////////////////////////////////////////////
0: 
0:     public void resetBatching(String clientId,String subscriptionName,MessageId id){
0: 
0:     public void recoverNextMessages(String clientId,String subscriptionName,int maxReturned,
0:             MessageRecoveryListener listener) throws Exception{
0:     }
0: 
0:     public void resetBatching(String clientId,String subscriptionName){
0:     }
commit:b6ba20b
/////////////////////////////////////////////////////////////////////////
0:     public MessageId getNextMessageIdToDeliver(String clientId,String subscriptionName,MessageId id) throws IOException{
0:         boolean matchFound = false;
0:                 if(!matchFound && entry.getKey().equals(id)){
0:                     matchFound = true;
0:                 }else if (matchFound) {
0:                     Message msg =  (Message) entry.getValue();
0:                     return msg.getMessageId();
0:                 }
0:             }
0:         }
0:         return null;
0:     }
0:     
0:     public MessageId getPreviousMessageIdToDeliver(String clientId,String subscriptionName,MessageId id) throws IOException{
0:         // the message table is a synchronizedMap - so just have to synchronize here
0:         Message last= null;
0:         synchronized(messageTable){
0:             for(Iterator iter=messageTable.entrySet().iterator();iter.hasNext();){
0:                 Map.Entry entry=(Entry) iter.next();
0:                 
0:                 if(entry.getKey().equals(id)){
0:                     return last != null ? last.getMessageId() : null;
0:                 }else {
0:                     last = (Message)entry.getValue();
/////////////////////////////////////////////////////////////////////////
0:     public void resetBatching(String clientId,String subscriptionName,MessageId id) {
0:     }
0:     
commit:4eef609
/////////////////////////////////////////////////////////////////////////
0:     
0:     public void recoverNextMessages(String clientId,String subscriptionName,MessageId lastMessageId,int maxReturned,MessageRecoveryListener listener) throws Exception{
0:         MessageId lastAck=(MessageId) ackDatabase.get(new SubscriptionKey(clientId,subscriptionName));
0:         boolean startFound=false;
0:         // the message table is a synchronizedMap - so just have to synchronize here
0:         synchronized(messageTable){
0:             int count = 0;
0:             for(Iterator iter=messageTable.entrySet().iterator();iter.hasNext() && count < maxReturned;){
0:                 Map.Entry entry=(Entry) iter.next();
0:                
0:                     Object msg=entry.getValue();
0:                     if(msg.getClass()==String.class){
0:                         String ref=msg.toString();
0:                         if(startFound||ref.equals(lastMessageId.toString())){
0:                             startFound=true;
0:                         }else if (startFound){
0:                             listener.recoverMessageReference(ref);
0:                             count++;
0:                         }
0:                     }else{
0:                         Message message=(Message) msg;
0:                         if(startFound||message.getMessageId().equals(lastMessageId)){
0:                             startFound=true;
0:                         }else if (startFound){
0:                             listener.recoverMessage(message);
0:                             count++;
0:                         }
0:                     }
0:                 
0:             }
0:             listener.finished();
0:         }
0:         
0:     }
/////////////////////////////////////////////////////////////////////////
0:     public Message getNextMessageToDeliver(String clientId,String subscriptionName) throws IOException{
0:         MessageId lastAck=(MessageId) ackDatabase.get(new SubscriptionKey(clientId,subscriptionName));
0:         // the message table is a synchronizedMap - so just have to synchronize here
0:         synchronized(messageTable){
0:             for(Iterator iter=messageTable.entrySet().iterator();iter.hasNext();){
0:                 Map.Entry entry=(Entry) iter.next();
0:                 if(entry.getKey().equals(lastAck)){
0:                     return (Message) entry.getValue();
0:                 }
0:             }
0:         }
0:         return null;
0:     }
0:     public int getMessageCount(String clientId,String subscriberName) throws IOException{
0:         int result = 0;
0:         MessageId lastAck=(MessageId) ackDatabase.get(new SubscriptionKey(clientId,subscriberName));
0:         // the message table is a synchronizedMap - so just have to synchronize here
0:         synchronized(messageTable){
0:             result = messageTable.size();
0:             for(Iterator iter=messageTable.entrySet().iterator();iter.hasNext();){
0:                 Map.Entry entry=(Entry) iter.next();
0:                 if(entry.getKey().equals(lastAck)){
0:                     break;
0:                 }
0:                 result--;
0:             }
0:         }
1:         return result;
0:     }
0:     
commit:2748ae1
/////////////////////////////////////////////////////////////////////////
0:             listener.finished();
commit:7f384b6
/////////////////////////////////////////////////////////////////////////
0:     public void recoverSubscription(String clientId,String subscriptionName,MessageRecoveryListener listener)
0:                     throws Throwable{
0:         MessageId lastAck=(MessageId) ackDatabase.get(new SubscriptionKey(clientId,subscriptionName));
0:         boolean pastLastAck=lastAck==null;
0:         // the message table is a synchronizedMap - so just have to synchronize here
0:         synchronized(messageTable){
0:             for(Iterator iter=messageTable.entrySet().iterator();iter.hasNext();){
0:                 Map.Entry entry=(Entry) iter.next();
0:                 if(pastLastAck){
0:                     Object msg=entry.getValue();
0:                     if(msg.getClass()==String.class){
0:                         listener.recoverMessageReference((String) msg);
0:                     }else{
0:                         listener.recoverMessage((Message) msg);
0:                     }
0:                 }else{
0:                     pastLastAck=entry.getKey().equals(lastAck);
============================================================================