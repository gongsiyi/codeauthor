1:d8c2eda: /**
1:88dfe00:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:88dfe00:  * contributor license agreements.  See the NOTICE file distributed with
1:88dfe00:  * this work for additional information regarding copyright ownership.
1:88dfe00:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:88dfe00:  * (the "License"); you may not use this file except in compliance with
1:88dfe00:  * the License.  You may obtain a copy of the License at
1:d8c2eda:  *
1:88dfe00:  *      http://www.apache.org/licenses/LICENSE-2.0
2:88dfe00:  *
1:88dfe00:  * Unless required by applicable law or agreed to in writing, software
1:88dfe00:  * distributed under the License is distributed on an "AS IS" BASIS,
1:88dfe00:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:88dfe00:  * See the License for the specific language governing permissions and
1:88dfe00:  * limitations under the License.
1:d8c2eda:  */
1:88dfe00: package org.apache.activemq.transport.amqp;
3:87420cc: 
1:61a3eab: import static org.junit.Assert.assertEquals;
1:61a3eab: import static org.junit.Assert.assertFalse;
1:61a3eab: import static org.junit.Assert.assertNotNull;
1:61a3eab: import static org.junit.Assert.assertNull;
1:61a3eab: import static org.junit.Assert.assertTrue;
1:61a3eab: import static org.junit.Assert.fail;
1:61a3eab: 
1:cf2083f: import java.util.ArrayList;
1:0766a18: import java.util.Enumeration;
1:9edf907: import java.util.HashSet;
1:9edf907: import java.util.Set;
1:e1e8c5b: import java.util.concurrent.CountDownLatch;
1:f033486: import java.util.concurrent.TimeUnit;
1:e1e8c5b: import java.util.concurrent.atomic.AtomicReference;
1:3d63ca7: 
1:1e5dac1: import javax.jms.Connection;
1:1e5dac1: import javax.jms.DeliveryMode;
1:7bafa7d: import javax.jms.Destination;
1:1e5dac1: import javax.jms.ExceptionListener;
1:1e5dac1: import javax.jms.JMSException;
1:9ec6ee4: import javax.jms.MapMessage;
1:1e5dac1: import javax.jms.Message;
1:1e5dac1: import javax.jms.MessageConsumer;
1:e1e8c5b: import javax.jms.MessageListener;
1:1e5dac1: import javax.jms.MessageProducer;
1:3d63ca7: import javax.jms.Queue;
1:1e5dac1: import javax.jms.QueueBrowser;
1:1e5dac1: import javax.jms.Session;
1:2ec586f: import javax.jms.TemporaryQueue;
1:2ec586f: import javax.jms.TemporaryTopic;
1:1e5dac1: import javax.jms.TextMessage;
1:3d63ca7: import javax.jms.Topic;
1:4fa420b: import javax.jms.TopicConnection;
1:4fa420b: import javax.jms.TopicSession;
1:4fa420b: import javax.jms.TopicSubscriber;
1:87420cc: 
1:4fa420b: import org.apache.activemq.broker.jmx.BrokerView;
1:226e012: import org.apache.activemq.broker.jmx.BrokerViewMBean;
1:cf2083f: import org.apache.activemq.broker.jmx.ConnectorViewMBean;
1:c5c4caa: import org.apache.activemq.broker.jmx.QueueViewMBean;
1:a35e8dc: import org.apache.activemq.broker.jmx.SubscriptionViewMBean;
1:2db73e2: import org.apache.activemq.transport.amqp.joram.ActiveMQAdmin;
1:e1e8c5b: import org.apache.activemq.util.Wait;
1:31c55f7: import org.apache.qpid.jms.JmsConnectionFactory;
1:88dfe00: import org.junit.Test;
1:3016b39: import org.objectweb.jtests.jms.framework.TestConfig;
1:da63f3f: import org.slf4j.Logger;
1:da63f3f: import org.slf4j.LoggerFactory;
1:0ca376d: 
1:1dd34a1: public class JMSClientTest extends JMSClientTestSupport {
1:87420cc: 
1:1dd34a1:     protected static final Logger LOG = LoggerFactory.getLogger(JMSClientTest.class);
1:1dd34a1: 
1:1dd34a1:     protected java.util.logging.Logger frameLoggger = java.util.logging.Logger.getLogger("FRM");
1:87420cc: 
1:1e5dac1:     @SuppressWarnings("rawtypes")
1:f555d90:     @Test(timeout=30000)
1:c5c4caa:     public void testProducerConsume() throws Exception {
1:f555d90:         ActiveMQAdmin.enableJMSFrameTracing();
1:f555d90: 
1:1dd34a1:         connection = createConnection();
2:c5c4caa:         {
1:f555d90:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:1dd34a1:             Queue queue = session.createQueue(getDestinationName());
1:2db73e2:             MessageProducer p = session.createProducer(queue);
1:f555d90: 
1:f555d90:             TextMessage message = session.createTextMessage();
1:f555d90:             message.setText("hello");
1:3016b39:             p.send(message);
1:0ca376d: 
1:6a253eb:             QueueBrowser browser = session.createBrowser(queue);
1:6a253eb:             Enumeration enumeration = browser.getEnumeration();
1:6a253eb:             while (enumeration.hasMoreElements()) {
1:3016b39:                 Message m = (Message) enumeration.nextElement();
1:3016b39:                 assertTrue(m instanceof TextMessage);
1:a165054:             }
1:226e012: 
1:ed5d841:             MessageConsumer consumer = session.createConsumer(queue);
2:c5c4caa:             Message msg = consumer.receive(TestConfig.TIMEOUT);
3:c5c4caa:             assertNotNull(msg);
2:c5c4caa:             assertTrue(msg instanceof TextMessage);
1:d8c2eda:         }
1:efc51fa:     }
1:226e012: 
1:9ec6ee4:     @Test(timeout = 60000)
1:9ec6ee4:     public void testSendJMSMapMessage() throws Exception {
1:9ec6ee4:         ActiveMQAdmin.enableJMSFrameTracing();
1:9ec6ee4: 
1:9ec6ee4:         connection = createConnection();
1:9ec6ee4:         {
1:9ec6ee4:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:9ec6ee4:             assertNotNull(session);
1:9ec6ee4:             Queue queue = session.createQueue(name.getMethodName());
1:9ec6ee4:             MessageProducer producer = session.createProducer(queue);
1:9ec6ee4:             MapMessage message = session.createMapMessage();
1:9ec6ee4:             message.setBoolean("Boolean", false);
1:9ec6ee4:             message.setString("STRING", "TEST");
1:9ec6ee4:             producer.send(message);
1:9ec6ee4:             QueueViewMBean proxy = getProxyToQueue(name.getMethodName());
1:9ec6ee4:             assertEquals(1, proxy.getQueueSize());
1:9ec6ee4: 
1:9ec6ee4:             MessageConsumer consumer = session.createConsumer(queue);
1:9ec6ee4:             Message received = consumer.receive(5000);
1:9ec6ee4:             assertNotNull(received);
1:9ec6ee4:             assertTrue(received instanceof MapMessage);
1:9ec6ee4:             MapMessage map = (MapMessage) received;
1:9ec6ee4:             assertEquals("TEST", map.getString("STRING"));
1:9ec6ee4:             assertEquals(false, map.getBooleanProperty("Boolean"));
1:9ec6ee4:         }
1:9ec6ee4:     }
1:9ec6ee4: 
1:90afa24:     @Test(timeout=30000)
1:f555d90:     public void testAnonymousProducerConsume() throws Exception {
1:226e012:         ActiveMQAdmin.enableJMSFrameTracing();
1:41ca0d9: 
1:bbb17da:         connection = createConnection();
1:f555d90:         {
1:90afa24:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:90afa24:             Queue queue1 = session.createQueue(getDestinationName() + "1");
1:90afa24:             Queue queue2 = session.createQueue(getDestinationName() + "2");
1:90afa24:             MessageProducer p = session.createProducer(null);
1:90afa24: 
1:90afa24:             TextMessage message = session.createTextMessage();
1:90afa24:             message.setText("hello");
1:90afa24:             p.send(queue1, message);
1:90afa24:             p.send(queue2, message);
1:90afa24: 
1:90afa24:             {
1:90afa24:                 MessageConsumer consumer = session.createConsumer(queue1);
1:90afa24:                 Message msg = consumer.receive(TestConfig.TIMEOUT);
1:90afa24:                 assertNotNull(msg);
1:90afa24:                 assertTrue(msg instanceof TextMessage);
1:90afa24:                 consumer.close();
1:90afa24:             }
1:90afa24:             {
1:90afa24:                 MessageConsumer consumer = session.createConsumer(queue2);
1:90afa24:                 Message msg = consumer.receive(TestConfig.TIMEOUT);
1:90afa24:                 assertNotNull(msg);
1:90afa24:                 assertTrue(msg instanceof TextMessage);
1:90afa24:                 consumer.close();
1:90afa24:             }
1:f555d90:         }
1:f555d90:     }
1:41ca0d9: 
1:76e29bd:     @Test(timeout=30*1000)
1:c5c4caa:     public void testTransactedConsumer() throws Exception {
1:41ca0d9:         ActiveMQAdmin.enableJMSFrameTracing();
1:ed5d841:         final int msgCount = 1;
1:f555d90: 
1:226e012:         connection = createConnection();
1:9edf907:         Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:1dd34a1:         Queue queue = session.createQueue(getDestinationName());
1:c5c4caa:         sendMessages(connection, queue, msgCount);
1:d8c2eda: 
1:1dd34a1:         QueueViewMBean queueView = getProxyToQueue(getDestinationName());
1:c5c4caa:         LOG.info("Queue size after produce is: {}", queueView.getQueueSize());
1:c5c4caa:         assertEquals(msgCount, queueView.getQueueSize());
1:1e7dc12: 
1:e1e8c5b:         MessageConsumer consumer = session.createConsumer(queue);
1:1e7dc12: 
1:f555d90:         Message msg = consumer.receive(TestConfig.TIMEOUT);
1:f555d90:         assertNotNull(msg);
1:f555d90:         assertTrue(msg instanceof TextMessage);
1:1e7dc12: 
1:ed5d841:         LOG.info("Queue size before session commit is: {}", queueView.getQueueSize());
1:ed5d841:         assertEquals(msgCount, queueView.getQueueSize());
1:69e6ad8: 
1:ed5d841:         session.commit();
1:69e6ad8: 
1:ed5d841:         LOG.info("Queue size after session commit is: {}", queueView.getQueueSize());
1:c5c4caa:         assertEquals(0, queueView.getQueueSize());
1:efc51fa:     }
1:69e6ad8: 
1:2ec586f:     @Test(timeout=30000)
1:c5c4caa:     public void testRollbackRececeivedMessage() throws Exception {
1:69e6ad8: 
1:efc51fa:         ActiveMQAdmin.enableJMSFrameTracing();
1:c5c4caa:         final int msgCount = 1;
1:69e6ad8: 
1:41ca0d9:         connection = createConnection();
1:9edf907:         Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:1dd34a1:         Queue queue = session.createQueue(getDestinationName());
1:c5c4caa:         sendMessages(connection, queue, msgCount);
1:efc51fa: 
1:1dd34a1:         QueueViewMBean queueView = getProxyToQueue(getDestinationName());
1:c5c4caa:         LOG.info("Queue size after produce is: {}", queueView.getQueueSize());
1:c5c4caa:         assertEquals(msgCount, queueView.getQueueSize());
1:efc51fa: 
1:0ca376d:         MessageConsumer consumer = session.createConsumer(queue);
1:efc51fa: 
1:c5c4caa:         // Receive and roll back, first receive should not show redelivered.
1:f555d90:         Message msg = consumer.receive(TestConfig.TIMEOUT);
1:ed5d841:         LOG.info("Test received msg: {}", msg);
1:f555d90:         assertNotNull(msg);
1:f555d90:         assertTrue(msg instanceof TextMessage);
1:c5c4caa:         assertEquals(false, msg.getJMSRedelivered());
1:efc51fa: 
1:c5c4caa:         session.rollback();
1:94937e8: 
1:c5c4caa:         // Receive and roll back, first receive should not show redelivered.
1:c5c4caa:         msg = consumer.receive(TestConfig.TIMEOUT);
1:1e7dc12:         assertNotNull(msg);
1:ed5d841:         assertTrue(msg instanceof TextMessage);
1:c5c4caa:         assertEquals(true, msg.getJMSRedelivered());
1:e1e8c5b: 
1:c5c4caa:         LOG.info("Queue size after produce is: {}", queueView.getQueueSize());
1:c5c4caa:         assertEquals(msgCount, queueView.getQueueSize());
1:f033486: 
2:c5c4caa:         session.commit();
1:f033486: 
1:c5c4caa:         LOG.info("Queue size after produce is: {}", queueView.getQueueSize());
1:c5c4caa:         assertEquals(0, queueView.getQueueSize());
1:f033486: 
1:ed5d841:         session.close();
1:87420cc:     }
1:f033486: 
1:bbb17da:     @Test(timeout = 60000)
1:9edf907:     public void testRollbackSomeThenReceiveAndCommit() throws Exception {
1:9edf907:         int totalCount = 5;
1:9edf907:         int consumeBeforeRollback = 2;
1:9edf907: 
1:9edf907:         connection = createConnection();
1:9edf907:         Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:9edf907:         Queue queue = session.createQueue(getDestinationName());
1:9edf907:         sendMessages(connection, queue, totalCount);
1:9edf907: 
1:9edf907:         QueueViewMBean proxy = getProxyToQueue(name.getMethodName());
1:9edf907:         assertEquals(totalCount, proxy.getQueueSize());
1:9edf907: 
1:9edf907:         MessageConsumer consumer = session.createConsumer(queue);
1:9edf907: 
1:94937e8:         for (int i = 1; i <= consumeBeforeRollback; i++) {
1:9edf907:             Message message = consumer.receive(1000);
1:9edf907:             assertNotNull(message);
1:9edf907:             assertEquals("Unexpected message number", i, message.getIntProperty(AmqpTestSupport.MESSAGE_NUMBER));
1:9edf907:         }
1:9edf907: 
1:9edf907:         session.rollback();
1:9edf907: 
1:9edf907:         assertEquals(totalCount, proxy.getQueueSize());
1:9edf907: 
1:9edf907:         // Consume again..check we receive all the messages.
1:e050519:         Set<Integer> messageNumbers = new HashSet<>();
1:94937e8:         for (int i = 1; i <= totalCount; i++) {
1:9edf907:             messageNumbers.add(i);
1:9edf907:         }
1:9edf907: 
1:94937e8:         for (int i = 1; i <= totalCount; i++) {
1:9edf907:             Message message = consumer.receive(1000);
1:9edf907:             assertNotNull(message);
1:9edf907:             int msgNum = message.getIntProperty(AmqpTestSupport.MESSAGE_NUMBER);
1:9edf907:             messageNumbers.remove(msgNum);
1:9edf907:         }
1:9edf907: 
1:9edf907:         session.commit();
1:9edf907: 
1:9edf907:         assertTrue("Did not consume all expected messages, missing messages: " + messageNumbers, messageNumbers.isEmpty());
1:9edf907:         assertEquals("Queue should have no messages left after commit", 0, proxy.getQueueSize());
1:9edf907:     }
1:9edf907: 
1:cf2083f:     @Test(timeout=60000)
1:c5c4caa:     public void testTXConsumerAndLargeNumberOfMessages() throws Exception {
1:f033486: 
1:e1e8c5b:         ActiveMQAdmin.enableJMSFrameTracing();
1:94937e8:         final int msgCount = 300;
1:f033486: 
1:1dd34a1:         connection = createConnection();
1:9edf907:         Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:1dd34a1:         Queue queue = session.createQueue(getDestinationName());
1:c5c4caa:         sendMessages(connection, queue, msgCount);
1:f033486: 
1:1dd34a1:         QueueViewMBean queueView = getProxyToQueue(getDestinationName());
1:c5c4caa:         LOG.info("Queue size after produce is: {}", queueView.getQueueSize());
1:c5c4caa:         assertEquals(msgCount, queueView.getQueueSize());
1:f033486: 
2:c5c4caa:         // Consumer all in TX and commit.
1:f555d90:         {
1:f033486:             MessageConsumer consumer = session.createConsumer(queue);
1:f033486: 
2:c5c4caa:             for (int i = 0; i < msgCount; ++i) {
1:c5c4caa:                 if ((i % 100) == 0) {
1:c5c4caa:                     LOG.info("Attempting receive of Message #{}", i);
1:87420cc:                 }
1:ed5d841:                 Message msg = consumer.receive(TestConfig.TIMEOUT);
1:c5c4caa:                 assertNotNull("Should receive message: " + i, msg);
1:c5c4caa:                 assertTrue(msg instanceof TextMessage);
1:7fe23bc:             }
1:f033486: 
1:c5c4caa:             session.commit();
1:41ca0d9:             consumer.close();
1:ed5d841:             session.close();
1:7fe23bc:         }
1:f033486: 
1:c5c4caa:         LOG.info("Queue size after produce is: {}", queueView.getQueueSize());
1:c5c4caa:         assertEquals(0, queueView.getQueueSize());
1:7fe23bc:     }
1:f033486: 
1:6b18857:     @SuppressWarnings("rawtypes")
1:226e012:     @Test(timeout=30000)
1:25d774b:     public void testSelectors() throws Exception{
1:c5c4caa:         ActiveMQAdmin.enableJMSFrameTracing();
1:f033486: 
1:1dd34a1:         connection = createConnection();
1:f555d90:         {
1:69e6ad8:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:1dd34a1:             Queue queue = session.createQueue(getDestinationName());
1:25d774b:             MessageProducer p = session.createProducer(queue);
1:f033486: 
1:25d774b:             TextMessage message = session.createTextMessage();
1:25d774b:             message.setText("hello");
1:25d774b:             p.send(message, DeliveryMode.PERSISTENT, 5, 0);
1:6b18857: 
1:25d774b:             message = session.createTextMessage();
1:25d774b:             message.setText("hello + 9");
1:25d774b:             p.send(message, DeliveryMode.PERSISTENT, 9, 0);
1:0ca376d: 
1:25d774b:             QueueBrowser browser = session.createBrowser(queue);
1:25d774b:             Enumeration enumeration = browser.getEnumeration();
1:25d774b:             int count = 0;
1:25d774b:             while (enumeration.hasMoreElements()) {
1:25d774b:                 Message m = (Message) enumeration.nextElement();
1:25d774b:                 assertTrue(m instanceof TextMessage);
1:25d774b:                 count ++;
1:7fe23bc:             }
1:0ca376d: 
1:25d774b:             assertEquals(2, count);
1:0ca376d: 
1:25d774b:             MessageConsumer consumer = session.createConsumer(queue, "JMSPriority > 8");
1:c5c4caa:             Message msg = consumer.receive(TestConfig.TIMEOUT);
1:ed5d841:             assertNotNull(msg);
1:c5c4caa:             assertTrue(msg instanceof TextMessage);
1:25d774b:             assertEquals("hello + 9", ((TextMessage) msg).getText());
2:7fe23bc:         }
1:7fe23bc:     }
1:3afde7b: 
1:1e5dac1:     @SuppressWarnings("rawtypes")
1:99d533c:     @Test(timeout=30000)
1:6b18857:     public void testSelectorsWithJMSType() throws Exception{
1:6b18857:         ActiveMQAdmin.enableJMSFrameTracing();
1:6b18857: 
1:1dd34a1:         connection = createConnection();
1:6b18857:         {
2:f033486:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:1dd34a1:             Queue queue = session.createQueue(getDestinationName());
1:6b18857:             MessageProducer p = session.createProducer(queue);
1:6b18857: 
1:6b18857:             TextMessage message = session.createTextMessage();
1:6b18857:             message.setText("text");
1:6b18857:             p.send(message, DeliveryMode.NON_PERSISTENT, Message.DEFAULT_PRIORITY, Message.DEFAULT_TIME_TO_LIVE);
1:6b18857: 
1:6b18857:             TextMessage message2 = session.createTextMessage();
1:6b18857:             String type = "myJMSType";
1:6b18857:             message2.setJMSType(type);
1:6b18857:             message2.setText("text + type");
1:6b18857:             p.send(message2, DeliveryMode.NON_PERSISTENT, Message.DEFAULT_PRIORITY, Message.DEFAULT_TIME_TO_LIVE);
1:6b18857: 
1:6b18857:             QueueBrowser browser = session.createBrowser(queue);
1:6b18857:             Enumeration enumeration = browser.getEnumeration();
1:6b18857:             int count = 0;
1:6b18857:             while (enumeration.hasMoreElements()) {
1:6b18857:                 Message m = (Message) enumeration.nextElement();
1:6b18857:                 assertTrue(m instanceof TextMessage);
1:6b18857:                 count ++;
1:6b18857:             }
1:6b18857: 
1:6b18857:             assertEquals(2, count);
1:0ca376d: 
1:6b18857:             MessageConsumer consumer = session.createConsumer(queue, "JMSType = '"+ type +"'");
1:6b18857:             Message msg = consumer.receive(TestConfig.TIMEOUT);
1:6b18857:             assertNotNull(msg);
1:6b18857:             assertTrue(msg instanceof TextMessage);
1:6b18857:             assertEquals("Unexpected JMSType value", type, msg.getJMSType());
1:6b18857:             assertEquals("Unexpected message content", "text + type", ((TextMessage) msg).getText());
1:6b18857:         }
1:6b18857:     }
1:6b18857: 
1:7fe23bc:     abstract class Testable implements Runnable {
1:7fe23bc:         protected String msg;
1:7fe23bc:         synchronized boolean passed() {
1:7fe23bc:             if (msg != null) {
1:7fe23bc:                 fail(msg);
1:7fe23bc:             }
1:7fe23bc:             return true;
1:7fe23bc:         }
1:7fe23bc:     }
1:0ca376d: 
1:99d533c:     @Test(timeout=30000)
1:69e6ad8:     public void testProducerThrowsWhenBrokerStops() throws Exception {
1:69e6ad8: 
1:1dd34a1:         connection = createConnection();
1:69e6ad8:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:1dd34a1:         Queue queue = session.createQueue(getDestinationName());
1:41ca0d9:         connection.start();
1:226e012: 
1:7fe23bc:         final MessageProducer producer = session.createProducer(queue);
1:69e6ad8:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:41ca0d9: 
1:7fe23bc:         final Message m = session.createTextMessage("Sample text");
1:3afde7b: 
1:7fe23bc:         Testable t = new Testable() {
1:3afde7b:             @Override
1:7fe23bc:             public synchronized void run() {
1:69e6ad8:                 try {
1:7fe23bc:                     for (int i = 0; i < 30; ++i) {
1:69e6ad8:                         producer.send(m);
1:7fe23bc:                         synchronized (producer) {
1:7fe23bc:                             producer.notifyAll();
1:69e6ad8:                         }
1:7fe23bc:                         TimeUnit.MILLISECONDS.sleep(100);
1:69e6ad8:                     }
1:7fe23bc:                     msg = "Should have thrown an IllegalStateException";
1:69e6ad8:                 } catch (Exception ex) {
1:69e6ad8:                     LOG.info("Caught exception on send: {}", ex);
1:e1e8c5b:                 }
1:e1e8c5b:             }
1:7fe23bc:         };
1:7fe23bc:         synchronized(producer) {
1:7fe23bc:             new Thread(t).start();
1:94937e8:             // wait until we know that the producer was able to send a message
1:7fe23bc:             producer.wait(10000);
1:e1e8c5b:         }
1:3afde7b: 
1:69e6ad8:         stopBroker();
1:7fe23bc:         assertTrue(t.passed());
1:69e6ad8:     }
1:3afde7b: 
1:69e6ad8:     @Test(timeout=30000)
1:69e6ad8:     public void testProducerCreateThrowsWhenBrokerStops() throws Exception {
1:1dd34a1:         connection = createConnection();
1:7fe23bc:         final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:7fe23bc:         final Queue queue = session.createQueue(getDestinationName());
1:1e7dc12:         connection.start();
1:3afde7b: 
1:7fe23bc:         Testable t = new Testable() {
1:3afde7b:             @Override
1:7fe23bc:             public synchronized void run() {
1:69e6ad8:                 try {
1:69e6ad8:                     for (int i = 0; i < 10; ++i) {
1:69e6ad8:                         MessageProducer producer = session.createProducer(queue);
1:7fe23bc:                         synchronized (session) {
1:7fe23bc:                             session.notifyAll();
1:69e6ad8:                         }
1:7fe23bc:                         if (producer == null) {
1:7fe23bc:                             msg = "Producer should not be null";
1:69e6ad8:                         }
2:69e6ad8:                         TimeUnit.SECONDS.sleep(1);
1:e1e8c5b:                     }
1:7fe23bc:                     msg = "Should have thrown an IllegalStateException";
1:f033486:                 } catch (Exception ex) {
1:69e6ad8:                     LOG.info("Caught exception on create producer: {}", ex);
1:0ca376d:                 }
1:0ca376d:             }
1:7fe23bc:         };
1:7fe23bc:         synchronized (session) {
1:7fe23bc:             new Thread(t).start();
1:7fe23bc:             session.wait(10000);
1:0ca376d:         }
1:69e6ad8:         stopBroker();
1:7fe23bc:         assertTrue(t.passed());
1:0ca376d:     }
1:69e6ad8: 
1:e1e8c5b:     @Test(timeout=30000)
1:69e6ad8:     public void testConsumerCreateThrowsWhenBrokerStops() throws Exception {
1:1dd34a1:         connection = createConnection();
1:41ca0d9:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:1dd34a1:         Queue queue = session.createQueue(getDestinationName());
1:69e6ad8:         connection.start();
1:69e6ad8: 
1:69e6ad8:         MessageProducer producer = session.createProducer(queue);
1:efc51fa:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:69e6ad8: 
1:69e6ad8:         Message m = session.createTextMessage("Sample text");
1:f033486:         producer.send(m);
1:69e6ad8: 
1:69e6ad8:         stopBroker();
1:69e6ad8:         try {
1:f033486:             session.createConsumer(queue);
2:69e6ad8:             fail("Should have thrown an IllegalStateException");
1:f033486:         } catch (Exception ex) {
1:b444b6c:             LOG.info("Caught exception on consumer create: {}", ex);
1:f033486:         }
1:f033486:     }
1:69e6ad8: 
1:e1e8c5b:     @Test(timeout=30000)
1:69e6ad8:     public void testConsumerReceiveNoWaitThrowsWhenBrokerStops() throws Exception {
1:1dd34a1:         connection = createConnection();
1:69e6ad8:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:1dd34a1:         Queue queue = session.createQueue(getDestinationName());
1:69e6ad8:         connection.start();
1:69e6ad8: 
1:7fe23bc:         final MessageConsumer consumer=session.createConsumer(queue);
1:7fe23bc:         Testable t = new Testable() {
1:3afde7b:             @Override
1:7fe23bc:             public synchronized void run() {
1:69e6ad8:                 try {
1:69e6ad8:                     for (int i = 0; i < 10; ++i) {
1:69e6ad8:                         consumer.receiveNoWait();
1:7fe23bc:                         synchronized (consumer) {
1:7fe23bc:                             consumer.notifyAll();
1:f033486:                         }
1:2360fb8:                         TimeUnit.MILLISECONDS.sleep(1000 + (i * 100));
1:f033486:                     }
1:7fe23bc:                     msg = "Should have thrown an IllegalStateException";
1:f033486:                 } catch (Exception ex) {
1:69e6ad8:                     LOG.info("Caught exception on receiveNoWait: {}", ex);
1:69e6ad8:                 }
1:69e6ad8:             }
1:3afde7b: 
1:7fe23bc:         };
1:7fe23bc:         synchronized (consumer) {
1:7fe23bc:             new Thread(t).start();
1:7fe23bc:             consumer.wait(10000);
1:69e6ad8:         }
1:69e6ad8:         stopBroker();
1:7fe23bc:         assertTrue(t.passed());
1:f033486:     }
1:3afde7b: 
1:69e6ad8:     @Test(timeout=30000)
1:69e6ad8:     public void testConsumerReceiveTimedThrowsWhenBrokerStops() throws Exception {
1:1dd34a1:         connection = createConnection();
1:69e6ad8:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:1dd34a1:         Queue queue = session.createQueue(getDestinationName());
1:69e6ad8:         connection.start();
1:69e6ad8: 
1:7fe23bc:         final MessageConsumer consumer=session.createConsumer(queue);
1:7fe23bc:         Testable t = new Testable() {
1:3afde7b:             @Override
1:7fe23bc:             public synchronized void run() {
2:69e6ad8:                 try {
1:69e6ad8:                     for (int i = 0; i < 10; ++i) {
1:7fe23bc:                         consumer.receive(100 + (i * 1000));
1:7fe23bc:                         synchronized (consumer) {
1:7fe23bc:                             consumer.notifyAll();
1:69e6ad8:                         }
1:f033486:                     }
1:7fe23bc:                     msg = "Should have thrown an IllegalStateException";
1:69e6ad8:                 } catch (Exception ex) {
2:69e6ad8:                     LOG.info("Caught exception on receive(1000): {}", ex);
1:f033486:                 }
1:f033486:             }
1:7fe23bc:         };
1:7fe23bc:         synchronized (consumer) {
1:7fe23bc:             new Thread(t).start();
1:7fe23bc:             consumer.wait(10000);
1:7fe23bc:             consumer.notifyAll();
1:f033486:         }
1:69e6ad8:         stopBroker();
1:7fe23bc:         assertTrue(t.passed());
1:f033486:     }
1:69e6ad8: 
1:e1e8c5b:     @Test(timeout=30000)
1:69e6ad8:     public void testConsumerReceiveReturnsBrokerStops() throws Exception {
1:1dd34a1:         connection = createConnection();
1:e1e8c5b:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:1dd34a1:         Queue queue = session.createQueue(getDestinationName());
1:e1e8c5b:         connection.start();
1:69e6ad8: 
1:7fe23bc:         final MessageConsumer consumer=session.createConsumer(queue);
1:e1e8c5b: 
1:7fe23bc:         Testable t = new Testable() {
1:3afde7b:             @Override
1:7fe23bc:             public synchronized void run() {
1:69e6ad8:                 try {
1:7fe23bc:                     Message m = consumer.receive(1);
1:7fe23bc:                     synchronized (consumer) {
1:7fe23bc:                         consumer.notifyAll();
1:7fe23bc:                         if (m != null) {
1:7fe23bc:                             msg = "Should have returned null";
1:7fe23bc:                             return;
1:f033486:                         }
1:f033486:                     }
1:7fe23bc:                     m = consumer.receive();
1:7fe23bc:                     if (m != null) {
1:7fe23bc:                         msg = "Should have returned null";
1:87420cc:                     }
1:69e6ad8:                 } catch (Exception ex) {
1:b444b6c:                     LOG.info("Caught exception on receive(): {}", ex);
1:da63f3f:                 }
1:7fe23bc:             }
1:7fe23bc:         };
1:7fe23bc:         synchronized (consumer) {
1:7fe23bc:             new Thread(t).start();
1:7fe23bc:             consumer.wait(10000);
1:7fe23bc:         }
1:69e6ad8:         stopBroker();
1:7fe23bc:         assertTrue(t.passed());
1:e1e8c5b: 
1:7fe23bc:     }
1:e1e8c5b: 
1:f033486:     @Test(timeout=30000)
1:f033486:     public void testBrokerRestartWontHangConnectionClose() throws Exception {
1:1dd34a1:         connection = createConnection();
1:f033486:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:1dd34a1:         Queue queue = session.createQueue(getDestinationName());
3:f033486:         connection.start();
1:e1e8c5b: 
1:e1e8c5b:         MessageProducer producer = session.createProducer(queue);
2:f033486:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:e1e8c5b: 
3:f033486:         Message m = session.createTextMessage("Sample text");
1:f033486:         producer.send(m);
1:e1e8c5b: 
3:f033486:         restartBroker();
1:e1e8c5b: 
1:69e6ad8:         try {
1:1e7dc12:             connection.close();
1:69e6ad8:         } catch (Exception ex) {
1:f033486:             LOG.error("Should not thrown on disconnected connection close(): {}", ex);
1:f033486:             fail("Should not have thrown an exception.");
1:f555d90:         }
1:f555d90:     }
1:6972d37: 
1:76e29bd:     @Test(timeout=30 * 1000)
1:94937e8:     public void testProduceAndConsumeLargeNumbersOfMessages() throws Exception {
1:94937e8:         int count = 1000;
1:1dd34a1:         connection = createConnection();
1:f033486:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:1dd34a1:         Queue queue = session.createQueue(getDestinationName());
1:6972d37:         connection.start();
1:6972d37: 
1:f033486:         MessageProducer producer= session.createProducer(queue);
1:f033486:         for (int i = 0; i < count; i++) {
1:f033486:             Message m=session.createTextMessage("Test-Message:"+i);
1:f033486:             producer.send(m);
1:e1e8c5b:         }
1:6972d37: 
1:94937e8:         MessageConsumer consumer=session.createConsumer(queue);
1:f033486:         for(int i = 0; i < count; i++) {
2:f033486:             Message message = consumer.receive(5000);
1:f033486:             assertNotNull(message);
1:f033486:             assertEquals("Test-Message:" + i,((TextMessage) message).getText());
1:e1e8c5b:         }
1:f555d90: 
1:94937e8:         assertNull(consumer.receiveNoWait());
1:e1e8c5b:     }
1:cf2083f: 
1:6972d37:     @Test(timeout=30000)
1:efc51fa:     public void testSyncSends() throws Exception {
1:6972d37:         ActiveMQAdmin.enableJMSFrameTracing();
1:1dd34a1:         connection = createConnection(true);
1:1dd34a1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:1dd34a1:         Queue queue = session.createQueue(getDestinationName());
1:1dd34a1:         connection.start();
1:1dd34a1:         MessageProducer producer = session.createProducer(queue);
1:1dd34a1:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:1dd34a1:         Message toSend = session.createTextMessage("Sample text");
1:1dd34a1:         producer.send(toSend);
1:1dd34a1:         MessageConsumer consumer = session.createConsumer(queue);
1:1dd34a1:         Message received = consumer.receive(5000);
1:1dd34a1:         assertNotNull(received);
1:e1e8c5b:     }
1:cf2083f: 
1:99d533c:     @Test(timeout=30000)
1:e1e8c5b:     public void testDurableConsumerAsync() throws Exception {
1:cf2083f:         ActiveMQAdmin.enableJMSFrameTracing();
1:e1e8c5b:         final CountDownLatch latch = new CountDownLatch(1);
1:e050519:         final AtomicReference<Message> received = new AtomicReference<>();
1:adef03e:         String durableClientId = getDestinationName() + "-ClientId";
1:cf2083f: 
1:adef03e:         connection = createConnection(durableClientId);
1:e1e8c5b:         {
1:e1e8c5b:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:41ca0d9:             Topic topic = session.createTopic(getDestinationName());
1:41ca0d9:             MessageConsumer consumer = session.createDurableSubscriber(topic, "DurbaleTopic");
1:e1e8c5b:             consumer.setMessageListener(new MessageListener() {
1:41ca0d9: 
1:69e6ad8:                 @Override
1:e1e8c5b:                 public void onMessage(Message message) {
1:e1e8c5b:                     received.set(message);
1:e1e8c5b:                     latch.countDown();
1:e1e8c5b:                 }
1:69e6ad8:             });
1:69e6ad8: 
1:e1e8c5b:             MessageProducer producer = session.createProducer(topic);
1:e1e8c5b:             producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:69e6ad8:             connection.start();
1:69e6ad8: 
1:e1e8c5b:             TextMessage message = session.createTextMessage();
1:e1e8c5b:             message.setText("hello");
1:e1e8c5b:             producer.send(message);
1:69e6ad8: 
1:e1e8c5b:             assertTrue(latch.await(10, TimeUnit.SECONDS));
1:e1e8c5b:             assertNotNull("Should have received a message by now.", received.get());
1:e1e8c5b:             assertTrue("Should be an instance of TextMessage", received.get() instanceof TextMessage);
1:69e6ad8:         }
1:69e6ad8:     }
1:69e6ad8: 
1:99d533c:     @Test(timeout=30000)
1:e1e8c5b:     public void testDurableConsumerSync() throws Exception {
1:e1e8c5b:         ActiveMQAdmin.enableJMSFrameTracing();
1:adef03e:         String durableClientId = getDestinationName() + "-ClientId";
1:69e6ad8: 
1:adef03e:         connection = createConnection(durableClientId);
1:e1e8c5b:         {
1:69e6ad8:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:1dd34a1:             Topic topic = session.createTopic(getDestinationName());
1:e1e8c5b:             final MessageConsumer consumer = session.createDurableSubscriber(topic, "DurbaleTopic");
1:e1e8c5b:             MessageProducer producer = session.createProducer(topic);
1:e1e8c5b:             producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:e1e8c5b:             connection.start();
1:69e6ad8: 
1:e1e8c5b:             TextMessage message = session.createTextMessage();
1:e1e8c5b:             message.setText("hello");
1:e1e8c5b:             producer.send(message);
1:cf2083f: 
1:e050519:             final AtomicReference<Message> msg = new AtomicReference<>();
2:41ca0d9:             assertTrue(Wait.waitFor(new Wait.Condition() {
1:41ca0d9: 
1:41ca0d9:                 @Override
1:41ca0d9:                 public boolean isSatisified() throws Exception {
1:e1e8c5b:                     msg.set(consumer.receiveNoWait());
1:e1e8c5b:                     return msg.get() != null;
1:41ca0d9:                 }
1:94937e8:             }, TimeUnit.SECONDS.toMillis(25), TimeUnit.MILLISECONDS.toMillis(200)));
1:41ca0d9: 
1:e1e8c5b:             assertNotNull("Should have received a message by now.", msg.get());
1:e1e8c5b:             assertTrue("Should be an instance of TextMessage", msg.get() instanceof TextMessage);
1:41ca0d9:         }
1:69e6ad8:     }
1:41ca0d9: 
1:69e6ad8:     @Test(timeout=30000)
1:e1e8c5b:     public void testTopicConsumerAsync() throws Exception {
1:e1e8c5b:         ActiveMQAdmin.enableJMSFrameTracing();
1:e1e8c5b:         final CountDownLatch latch = new CountDownLatch(1);
1:e050519:         final AtomicReference<Message> received = new AtomicReference<>();
1:e1e8c5b: 
1:1dd34a1:         connection = createConnection();
1:e1e8c5b:         {
1:e1e8c5b:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:1dd34a1:             Topic topic = session.createTopic(getDestinationName());
1:e1e8c5b:             MessageConsumer consumer = session.createConsumer(topic);
1:e1e8c5b:             consumer.setMessageListener(new MessageListener() {
1:e1e8c5b: 
1:69e6ad8:                 @Override
1:e1e8c5b:                 public void onMessage(Message message) {
1:e1e8c5b:                     received.set(message);
1:e1e8c5b:                     latch.countDown();
1:cf2083f:                 }
1:69e6ad8:             });
1:e1e8c5b: 
1:e1e8c5b:             MessageProducer producer = session.createProducer(topic);
1:e1e8c5b:             producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:e1e8c5b:             connection.start();
1:e1e8c5b: 
1:e1e8c5b:             TextMessage message = session.createTextMessage();
1:e1e8c5b:             message.setText("hello");
1:e1e8c5b:             producer.send(message);
1:e1e8c5b: 
1:e1e8c5b:             assertTrue(latch.await(10, TimeUnit.SECONDS));
1:e1e8c5b:             assertNotNull("Should have received a message by now.", received.get());
1:e1e8c5b:             assertTrue("Should be an instance of TextMessage", received.get() instanceof TextMessage);
1:e1e8c5b:         }
1:f555d90:         connection.close();
1:e1e8c5b:     }
1:e1e8c5b: 
1:e1e8c5b:     @Test(timeout=45000)
1:e1e8c5b:     public void testTopicConsumerSync() throws Exception {
1:e1e8c5b:         ActiveMQAdmin.enableJMSFrameTracing();
1:e1e8c5b: 
1:1dd34a1:         connection = createConnection();
1:e1e8c5b:         {
1:e1e8c5b:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:1dd34a1:             Topic topic = session.createTopic(getDestinationName());
1:e1e8c5b:             final MessageConsumer consumer = session.createConsumer(topic);
1:e1e8c5b:             MessageProducer producer = session.createProducer(topic);
1:e1e8c5b:             producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:e1e8c5b:             connection.start();
1:e1e8c5b: 
1:e1e8c5b:             TextMessage message = session.createTextMessage();
1:e1e8c5b:             message.setText("hello");
1:e1e8c5b:             producer.send(message);
1:e1e8c5b: 
1:e050519:             final AtomicReference<Message> msg = new AtomicReference<>();
1:41ca0d9:             assertTrue(Wait.waitFor(new Wait.Condition() {
1:e1e8c5b: 
2:69e6ad8:                 @Override
1:41ca0d9:                 public boolean isSatisified() throws Exception {
1:e1e8c5b:                     msg.set(consumer.receiveNoWait());
1:e1e8c5b:                     return msg.get() != null;
1:e1e8c5b:                 }
1:0045682:             }));
1:0045682: 
1:e1e8c5b:             assertNotNull("Should have received a message by now.", msg.get());
1:e1e8c5b:             assertTrue("Should be an instance of TextMessage", msg.get() instanceof TextMessage);
1:e1e8c5b:         }
1:e1e8c5b:     }
1:0045682: 
1:0045682:     @Test(timeout=30000)
1:cf2083f:     public void testConnectionsAreClosed() throws Exception {
1:0045682:         ActiveMQAdmin.enableJMSFrameTracing();
1:0045682: 
1:6d8449f:         final ConnectorViewMBean connector = getProxyToConnectionView(getTargetConnectorName());
1:cf2083f:         LOG.info("Current number of Connections is: {}", connector.connectionCount());
1:0045682: 
1:e050519:         ArrayList<Connection> connections = new ArrayList<>();
1:0045682: 
1:cf2083f:         for (int i = 0; i < 10; i++) {
1:cf2083f:             connections.add(createConnection(null));
1:cf2083f:         }
1:0045682: 
1:cf2083f:         LOG.info("Current number of Connections is: {}", connector.connectionCount());
1:cf2083f: 
1:cf2083f:         for (Connection connection : connections) {
1:6972d37:             connection.close();
1:cf2083f:         }
1:cf2083f: 
1:cf2083f:         assertTrue("Should have no connections left.", Wait.waitFor(new Wait.Condition() {
1:cf2083f: 
1:0045682:             @Override
1:0045682:             public boolean isSatisified() throws Exception {
1:cf2083f:                 LOG.info("Current number of Connections is: {}", connector.connectionCount());
1:cf2083f:                 return connector.connectionCount() == 0;
1:cf2083f:             }
1:0045682:         }));
1:cf2083f:     }
1:cf2083f: 
1:6d8449f:     protected String getTargetConnectorName() {
1:6d8449f:         return "amqp";
1:6d8449f:     }
1:6d8449f: 
1:69e6ad8:     @Test(timeout=30000)
1:69e6ad8:     public void testExecptionListenerCalledOnBrokerStop() throws Exception {
1:301866d:         ActiveMQAdmin.enableJMSFrameTracing();
1:69e6ad8: 
1:1dd34a1:         connection = createConnection();
1:7fe23bc:         Session s = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:69e6ad8:         connection.start();
1:69e6ad8: 
1:69e6ad8:         final CountDownLatch called = new CountDownLatch(1);
1:69e6ad8: 
1:69e6ad8:         connection.setExceptionListener(new ExceptionListener() {
1:69e6ad8: 
1:41ca0d9:             @Override
1:69e6ad8:             public void onException(JMSException exception) {
1:69e6ad8:                 LOG.info("Exception listener called: ", exception);
1:69e6ad8:                 called.countDown();
1:69e6ad8:             }
2:69e6ad8:         });
1:7bafa7d: 
1:7bafa7d:         // This makes sure the connection is completely up and connected
1:7bafa7d:         Destination destination = s.createTemporaryQueue();
1:7bafa7d:         MessageProducer producer = s.createProducer(destination);
1:7bafa7d:         assertNotNull(producer);
1:69e6ad8: 
1:69e6ad8:         stopBroker();
1:69e6ad8: 
1:69e6ad8:         assertTrue("No exception listener event fired.", called.await(15, TimeUnit.SECONDS));
1:69e6ad8:     }
1:69e6ad8: 
1:301866d:     @Test(timeout=30000)
1:94937e8:     public void testSessionTransactedCommit() throws Exception {
1:301866d:         ActiveMQAdmin.enableJMSFrameTracing();
1:69e6ad8: 
1:1dd34a1:         connection = createConnection();
1:9edf907:         Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:6b18857:         Queue queue = session.createQueue(getDestinationName());
1:69e6ad8: 
1:e1e8c5b:         connection.start();
1:cf2083f: 
1:1e7dc12:         // transacted producer
1:1e7dc12:         MessageProducer pr = session.createProducer(queue);
1:1e7dc12:         for (int i = 0; i < 10; i++) {
1:1e7dc12:             Message m = session.createTextMessage("TestMessage" + i);
1:1e7dc12:             pr.send(m);
1:6972d37:         }
1:1e7dc12: 
1:94937e8:         // No commit in place, so no message should be dispatched.
1:94937e8:         QueueViewMBean queueView = getProxyToQueue(getDestinationName());
1:94937e8:         assertEquals(0, queueView.getQueueSize());
1:94937e8: 
1:1e7dc12:         session.commit();
1:1e7dc12: 
1:94937e8:         // No commit in place, so no message should be dispatched.
1:94937e8:         assertEquals(10, queueView.getQueueSize());
1:1e7dc12: 
1:1e7dc12:         session.close();
1:1e7dc12:     }
1:e1e8c5b: 
1:69e6ad8:     @Test(timeout=30000)
1:94937e8:     public void testSessionTransactedRollback() throws Exception {
1:c5c4caa:         ActiveMQAdmin.enableJMSFrameTracing();
1:e1e8c5b: 
1:1dd34a1:         connection = createConnection();
1:6972d37:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:1dd34a1:         Queue queue = session.createQueue(getDestinationName());
1:6972d37: 
1:f033486:         connection.start();
1:6972d37: 
1:6972d37:         // transacted producer
1:6972d37:         MessageProducer pr = session.createProducer(queue);
1:6972d37:         for (int i = 0; i < 10; i++) {
1:6972d37:             Message m = session.createTextMessage("TestMessage" + i);
1:6972d37:             pr.send(m);
1:6972d37:         }
1:6972d37: 
1:6972d37:         session.rollback();
1:6972d37: 
1:6972d37:         MessageConsumer consumer = session.createConsumer(queue);
1:1e7dc12: 
1:6972d37:         // No commit in place, so no message should be dispatched.
1:94937e8:         QueueViewMBean queueView = getProxyToQueue(getDestinationName());
1:94937e8:         assertEquals(0, queueView.getQueueSize());
1:1e7dc12: 
1:94937e8:         assertNull(consumer.receive(100));
1:94937e8:         consumer.close();
1:1e7dc12: 
1:6972d37:         session.close();
1:1e7dc12:     }
1:e1e8c5b: 
1:87420cc:     private String createLargeString(int sizeInBytes) {
1:87420cc:         byte[] base = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};
1:87420cc:         StringBuilder builder = new StringBuilder();
1:87420cc:         for (int i = 0; i < sizeInBytes; i++) {
1:87420cc:             builder.append(base[i % base.length]);
1:1e7dc12:         }
1:e1e8c5b: 
1:87420cc:         LOG.debug("Created string with size : " + builder.toString().getBytes().length + " bytes");
1:87420cc:         return builder.toString();
1:69e6ad8:     }
1:e1e8c5b: 
1:76e29bd:     @Test(timeout = 30 * 1000)
1:87420cc:     public void testSendLargeMessage() throws JMSException, InterruptedException {
1:1dd34a1:         connection = createConnection();
1:e1e8c5b:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:1dd34a1:         String queueName = getDestinationName();
1:87420cc:         Queue queue = session.createQueue(queueName);
1:e1e8c5b: 
1:87420cc:         MessageProducer producer=session.createProducer(queue);
1:87420cc:         int messageSize = 1024 * 1024;
1:87420cc:         String messageText = createLargeString(messageSize);
1:87420cc:         Message m=session.createTextMessage(messageText);
1:87420cc:         LOG.debug("Sending message of {} bytes on queue {}", messageSize, queueName);
1:f033486:         producer.send(m);
1:f033486: 
1:f033486:         MessageConsumer  consumer=session.createConsumer(queue);
1:87420cc:         Message message = consumer.receive();
1:87420cc:         assertNotNull(message);
1:87420cc:         assertTrue(message instanceof TextMessage);
1:87420cc:         TextMessage textMessage = (TextMessage) message;
1:87420cc:         LOG.debug(">>>> Received message of length {}", textMessage.getText().length());
1:87420cc:         assertEquals(messageSize, textMessage.getText().length());
1:87420cc:         assertEquals(messageText, textMessage.getText());
1:69e6ad8:     }
1:f033486: 
1:4fa420b:     @Test(timeout=30*1000)
1:eaf773d:     public void testDurableTopicStateAfterSubscriberClosed() throws Exception {
1:4fa420b:         String durableClientId = getDestinationName() + "-ClientId";
1:4fa420b:         String durableSubscriberName = getDestinationName() + "-SubscriptionName";
1:4fa420b: 
1:4fa420b:         BrokerView adminView = this.brokerService.getAdminView();
1:4fa420b:         int durableSubscribersAtStart = adminView.getDurableTopicSubscribers().length;
1:4fa420b:         int inactiveSubscribersAtStart = adminView.getInactiveDurableTopicSubscribers().length;
1:4fa420b:         LOG.debug(">>>> At Start, durable Subscribers {} inactiveDurableSubscribers {}", durableSubscribersAtStart, inactiveSubscribersAtStart);
1:4fa420b: 
1:4fa420b:         TopicConnection subscriberConnection =
1:eaf773d:             JMSClientContext.INSTANCE.createTopicConnection(getBrokerURI(), "admin", "password");
1:4fa420b:         subscriberConnection.setClientID(durableClientId);
1:4fa420b:         TopicSession subscriberSession = subscriberConnection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);
1:4fa420b:         Topic topic = subscriberSession.createTopic(getDestinationName());
1:4fa420b:         TopicSubscriber messageConsumer = subscriberSession.createDurableSubscriber(topic, durableSubscriberName);
1:4fa420b: 
1:4fa420b:         assertNotNull(messageConsumer);
1:4fa420b: 
1:4fa420b:         int durableSubscribers = adminView.getDurableTopicSubscribers().length;
1:4fa420b:         int inactiveSubscribers = adminView.getInactiveDurableTopicSubscribers().length;
1:4fa420b:         LOG.debug(">>>> durable Subscribers after creation {} inactiveDurableSubscribers {}", durableSubscribers, inactiveSubscribers);
1:4fa420b:         assertEquals("Wrong number of durable subscribers after first subscription", 1, (durableSubscribers - durableSubscribersAtStart));
1:4fa420b:         assertEquals("Wrong number of inactive durable subscribers after first subscription", 0, (inactiveSubscribers - inactiveSubscribersAtStart));
1:4fa420b: 
1:4fa420b:         subscriberConnection.close();
1:4fa420b: 
1:4fa420b:         durableSubscribers = adminView.getDurableTopicSubscribers().length;
1:4fa420b:         inactiveSubscribers = adminView.getInactiveDurableTopicSubscribers().length;
1:4fa420b:         LOG.debug(">>>> durable Subscribers after close {} inactiveDurableSubscribers {}", durableSubscribers, inactiveSubscribers);
1:4fa420b:         assertEquals("Wrong number of durable subscribers after close", 0, (durableSubscribersAtStart));
1:4fa420b:         assertEquals("Wrong number of inactive durable subscribers after close", 1, (inactiveSubscribers - inactiveSubscribersAtStart));
1:4fa420b:     }
1:4fa420b: 
1:f033486:     @Test(timeout=30000)
1:226e012:     public void testDurableConsumerUnsubscribe() throws Exception {
1:c5c4caa:         ActiveMQAdmin.enableJMSFrameTracing();
1:adef03e: 
1:adef03e:         String durableClientId = getDestinationName() + "-ClientId";
1:f033486: 
1:226e012:         final BrokerViewMBean broker = getProxyToBroker();
1:2ec586f: 
1:adef03e:         connection = createConnection(durableClientId);
1:226e012:         connection.start();
1:226e012: 
1:226e012:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:226e012:         Topic topic = session.createTopic(getDestinationName());
1:226e012:         MessageConsumer consumer = session.createDurableSubscriber(topic, "DurbaleTopic");
1:226e012: 
1:226e012:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:226e012: 
1:226e012:             @Override
1:226e012:             public boolean isSatisified() throws Exception {
1:226e012:                 return broker.getInactiveDurableTopicSubscribers().length == 0 &&
1:226e012:                        broker.getDurableTopicSubscribers().length == 1;
1:226e012:             }
1:94937e8:         }, TimeUnit.SECONDS.toMillis(20), TimeUnit.MILLISECONDS.toMillis(250)));
1:226e012: 
1:226e012:         consumer.close();
1:226e012: 
1:226e012:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:226e012: 
1:226e012:             @Override
1:226e012:             public boolean isSatisified() throws Exception {
1:226e012:                 return broker.getInactiveDurableTopicSubscribers().length == 1 &&
1:226e012:                        broker.getDurableTopicSubscribers().length == 0;
1:0045682:             }
1:94937e8:         }, TimeUnit.SECONDS.toMillis(20), TimeUnit.MILLISECONDS.toMillis(250)));
1:226e012: 
1:226e012:         session.unsubscribe("DurbaleTopic");
1:226e012:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:226e012: 
1:226e012:             @Override
1:226e012:             public boolean isSatisified() throws Exception {
1:226e012:                 return broker.getInactiveDurableTopicSubscribers().length == 0 &&
1:226e012:                        broker.getDurableTopicSubscribers().length == 0;
1:226e012:             }
1:94937e8:         }, TimeUnit.SECONDS.toMillis(20), TimeUnit.MILLISECONDS.toMillis(250)));
1:226e012:     }
1:41ca0d9: 
1:41ca0d9:     @Test(timeout=30000)
1:0045682:     public void testDurableConsumerUnsubscribeWhileNoSubscription() throws Exception {
1:25d774b:         ActiveMQAdmin.enableJMSFrameTracing();
1:0045682: 
1:0045682:         final BrokerViewMBean broker = getProxyToBroker();
1:41ca0d9: 
1:0045682:         connection = createConnection();
1:0045682:         connection.start();
1:41ca0d9: 
1:0045682:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:41ca0d9: 
1:0045682:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:f033486: 
1:41ca0d9:             @Override
1:41ca0d9:             public boolean isSatisified() throws Exception {
1:0045682:                 return broker.getInactiveDurableTopicSubscribers().length == 0 &&
1:0045682:                        broker.getDurableTopicSubscribers().length == 0;
1:0045682:             }
1:94937e8:         }, TimeUnit.SECONDS.toMillis(20), TimeUnit.MILLISECONDS.toMillis(250)));
1:f033486: 
1:0045682:         try {
1:0045682:             session.unsubscribe("DurbaleTopic");
1:0045682:             fail("Should have thrown as subscription is in use.");
1:0045682:         } catch (JMSException ex) {
1:0045682:         }
1:0045682:     }
1:0045682: 
1:0045682:     @Test(timeout=30000)
1:0045682:     public void testDurableConsumerUnsubscribeWhileActive() throws Exception {
1:0045682:         ActiveMQAdmin.enableJMSFrameTracing();
1:adef03e:         String durableClientId = getDestinationName() + "-ClientId";
1:0045682: 
1:0045682:         final BrokerViewMBean broker = getProxyToBroker();
1:0045682: 
1:adef03e:         connection = createConnection(durableClientId);
1:0045682:         connection.start();
1:0045682: 
1:0045682:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:0045682:         Topic topic = session.createTopic(getDestinationName());
1:0045682:         session.createDurableSubscriber(topic, "DurbaleTopic");
1:0045682: 
1:0045682:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:0045682: 
1:0045682:             @Override
1:0045682:             public boolean isSatisified() throws Exception {
1:0045682:                 return broker.getInactiveDurableTopicSubscribers().length == 0 &&
1:0045682:                        broker.getDurableTopicSubscribers().length == 1;
1:0045682:             }
1:94937e8:         }, TimeUnit.SECONDS.toMillis(20), TimeUnit.MILLISECONDS.toMillis(250)));
1:0045682: 
1:0045682:         try {
1:0045682:             session.unsubscribe("DurbaleTopic");
1:0045682:             fail("Should have thrown as subscription is in use.");
1:0045682:         } catch (JMSException ex) {
1:0045682:         }
1:226e012:     }
1:f033486: 
1:f033486:     @Test(timeout=30000)
1:0ca376d:     public void testRedeliveredHeader() throws Exception {
1:0045682:         connection = createConnection();
1:f033486:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:1dd34a1:         Queue queue = session.createQueue(getDestinationName());
1:f033486:         connection.start();
1:f033486: 
4:f033486:         MessageProducer producer = session.createProducer(queue);
1:f033486:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:f033486: 
1:0ca376d:         for (int i = 1; i < 100; i++) {
1:0ca376d:             Message m = session.createTextMessage(i + ". Sample text");
1:0ca376d:             producer.send(m);
1:41ca0d9:         }
1:f033486: 
1:1e7dc12:         MessageConsumer consumer = session.createConsumer(queue);
1:0ca376d:         receiveMessages(consumer);
1:f555d90:         consumer.close();
1:f033486: 
1:0ca376d:         consumer = session.createConsumer(queue);
1:0ca376d:         receiveMessages(consumer);
1:f555d90:         consumer.close();
1:41ca0d9:     }
1:f033486: 
1:f033486:     @Test(timeout=30000)
1:2ec586f:     public void testCreateTemporaryQueue() throws Exception {
1:2ec586f:         ActiveMQAdmin.enableJMSFrameTracing();
1:2ec586f: 
1:2ec586f:         connection = createConnection();
1:2ec586f:         {
1:2ec586f:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:2ec586f:             Queue queue = session.createTemporaryQueue();
1:2ec586f:             assertNotNull(queue);
1:2ec586f:             assertTrue(queue instanceof TemporaryQueue);
1:2ec586f: 
1:2ec586f:             final BrokerViewMBean broker = getProxyToBroker();
1:2ec586f:             assertEquals(1, broker.getTemporaryQueues().length);
1:2ec586f:         }
1:2ec586f:     }
1:2ec586f: 
1:2ec586f:     @Test(timeout=30000)
1:2ec586f:     public void testDeleteTemporaryQueue() throws Exception {
1:2ec586f:         ActiveMQAdmin.enableJMSFrameTracing();
1:2ec586f: 
1:2ec586f:         connection = createConnection();
1:2ec586f:         {
1:2ec586f:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:2ec586f:             Queue queue = session.createTemporaryQueue();
1:2ec586f:             assertNotNull(queue);
1:2ec586f:             assertTrue(queue instanceof TemporaryQueue);
1:2ec586f: 
1:2ec586f:             final BrokerViewMBean broker = getProxyToBroker();
1:2ec586f:             assertEquals(1, broker.getTemporaryQueues().length);
1:2ec586f: 
1:2ec586f:             TemporaryQueue tempQueue = (TemporaryQueue) queue;
1:2ec586f:             tempQueue.delete();
1:2ec586f: 
1:2ec586f:             assertTrue("Temp Queue should be deleted.", Wait.waitFor(new Wait.Condition() {
1:2ec586f: 
1:2ec586f:                 @Override
1:2ec586f:                 public boolean isSatisified() throws Exception {
1:2ec586f:                     return broker.getTemporaryQueues().length == 0;
1:2ec586f:                 }
1:2ec586f:             }, TimeUnit.SECONDS.toMillis(30), TimeUnit.MILLISECONDS.toMillis(50)));
1:2ec586f:         }
1:2ec586f:     }
1:2ec586f: 
1:2ec586f:     @Test(timeout=30000)
1:2ec586f:     public void testCreateTemporaryTopic() throws Exception {
1:2ec586f:         ActiveMQAdmin.enableJMSFrameTracing();
1:2ec586f: 
1:2ec586f:         connection = createConnection();
1:2ec586f:         {
1:2ec586f:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:2ec586f:             Topic topic = session.createTemporaryTopic();
1:2ec586f:             assertNotNull(topic);
1:2ec586f:             assertTrue(topic instanceof TemporaryTopic);
1:2ec586f: 
1:2ec586f:             final BrokerViewMBean broker = getProxyToBroker();
1:2ec586f:             assertEquals(1, broker.getTemporaryTopics().length);
1:2ec586f:         }
1:2ec586f:     }
1:2ec586f: 
1:2ec586f:     @Test(timeout=30000)
1:2ec586f:     public void testDeleteTemporaryTopic() throws Exception {
1:2ec586f:         ActiveMQAdmin.enableJMSFrameTracing();
1:2ec586f: 
1:2ec586f:         connection = createConnection();
1:2ec586f:         {
1:2ec586f:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:2ec586f:             Topic topic = session.createTemporaryTopic();
1:2ec586f:             assertNotNull(topic);
1:2ec586f:             assertTrue(topic instanceof TemporaryTopic);
1:2ec586f: 
1:2ec586f:             final BrokerViewMBean broker = getProxyToBroker();
1:2ec586f:             assertEquals(1, broker.getTemporaryTopics().length);
1:f033486: 
1:2ec586f:             TemporaryTopic tempTopic = (TemporaryTopic) topic;
1:2ec586f:             tempTopic.delete();
1:2ec586f: 
1:2ec586f:             assertTrue("Temp Topic should be deleted.", Wait.waitFor(new Wait.Condition() {
1:2ec586f: 
1:2ec586f:                 @Override
1:2ec586f:                 public boolean isSatisified() throws Exception {
1:2ec586f:                     return broker.getTemporaryTopics().length == 0;
1:2ec586f:                 }
1:2ec586f:             }, TimeUnit.SECONDS.toMillis(30), TimeUnit.MILLISECONDS.toMillis(50)));
1:2ec586f:         }
1:2ec586f:     }
1:2ec586f: 
1:9edf907:     @Test(timeout = 60000)
1:bbb17da:     public void testZeroPrefetchWithTwoConsumers() throws Exception {
1:31c55f7:         JmsConnectionFactory cf = new JmsConnectionFactory(getAmqpURI("jms.prefetchPolicy.all=0"));
1:31c55f7:         connection = cf.createConnection();
1:bbb17da:         connection.start();
1:bbb17da: 
1:bbb17da:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:bbb17da:         Queue queue = session.createQueue(getDestinationName());
1:bbb17da: 
1:bbb17da:         MessageProducer producer = session.createProducer(queue);
1:bbb17da:         producer.send(session.createTextMessage("Msg1"));
1:bbb17da:         producer.send(session.createTextMessage("Msg2"));
1:bbb17da: 
1:bbb17da:         // now lets receive it
1:bbb17da:         MessageConsumer consumer1 = session.createConsumer(queue);
1:bbb17da:         MessageConsumer consumer2 = session.createConsumer(queue);
1:bbb17da:         TextMessage answer = (TextMessage)consumer1.receive(5000);
1:bbb17da:         assertNotNull(answer);
1:bbb17da:         assertEquals("Should have received a message!", answer.getText(), "Msg1");
1:bbb17da:         answer = (TextMessage)consumer2.receive(5000);
1:bbb17da:         assertNotNull(answer);
1:bbb17da:         assertEquals("Should have received a message!", answer.getText(), "Msg2");
1:bbb17da: 
1:bbb17da:         answer = (TextMessage)consumer2.receiveNoWait();
1:bbb17da:         assertNull("Should have not received a message!", answer);
1:bbb17da:     }
1:bbb17da: 
1:a35e8dc:     @Test(timeout=30000)
1:a35e8dc:     public void testRetroactiveConsumerSupported() throws Exception {
1:a35e8dc:         ActiveMQAdmin.enableJMSFrameTracing();
1:a35e8dc: 
1:a35e8dc:         connection = createConnection();
1:a35e8dc:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:a35e8dc:         Queue queue = session.createQueue(getDestinationName() + "?consumer.retroactive=true");
1:a35e8dc:         MessageConsumer consumer = session.createConsumer(queue);
1:a35e8dc: 
1:a35e8dc:         QueueViewMBean queueView = getProxyToQueue(getDestinationName());
1:a35e8dc:         assertNotNull(queueView);
1:a35e8dc:         assertEquals(1, queueView.getSubscriptions().length);
1:a35e8dc: 
1:a35e8dc:         SubscriptionViewMBean subscriber = getProxyToQueueSubscriber(getDestinationName());
1:a35e8dc:         assertTrue(subscriber.isRetroactive());
1:a35e8dc: 
1:a35e8dc:         consumer.close();
1:a35e8dc:     }
1:a35e8dc: 
1:a35e8dc:     @Test(timeout=30000)
1:a35e8dc:     public void testExclusiveConsumerSupported() throws Exception {
1:a35e8dc:         ActiveMQAdmin.enableJMSFrameTracing();
1:a35e8dc: 
1:a35e8dc:         connection = createConnection();
1:a35e8dc:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:a35e8dc:         Queue queue = session.createQueue(getDestinationName() + "?consumer.exclusive=true");
1:a35e8dc:         MessageConsumer consumer = session.createConsumer(queue);
1:a35e8dc: 
1:a35e8dc:         QueueViewMBean queueView = getProxyToQueue(getDestinationName());
1:a35e8dc:         assertNotNull(queueView);
1:a35e8dc:         assertEquals(1, queueView.getSubscriptions().length);
1:a35e8dc: 
1:a35e8dc:         SubscriptionViewMBean subscriber = getProxyToQueueSubscriber(getDestinationName());
1:a35e8dc:         assertTrue(subscriber.isExclusive());
1:a35e8dc: 
1:a35e8dc:         consumer.close();
1:a35e8dc:     }
1:a35e8dc: 
1:a35e8dc:     @Test(timeout=30000)
1:a35e8dc:     public void testUnpplicableDestinationOption() throws Exception {
1:a35e8dc:         ActiveMQAdmin.enableJMSFrameTracing();
1:a35e8dc: 
1:a35e8dc:         connection = createConnection();
1:a35e8dc:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:a35e8dc:         Queue queue = session.createQueue(getDestinationName() + "?consumer.unknoen=true");
1:a35e8dc:         try {
1:a35e8dc:             session.createConsumer(queue);
1:a35e8dc:             fail("Should have failed to create consumer");
1:a35e8dc:         } catch (JMSException jmsEx) {
1:a35e8dc:         }
1:a35e8dc:     }
1:a35e8dc: 
1:0ca376d:     protected void receiveMessages(MessageConsumer consumer) throws Exception {
1:1e7dc12:         for (int i = 0; i < 10; i++) {
1:0ca376d:             Message message = consumer.receive(1000);
1:0ca376d:             assertNotNull(message);
1:0ca376d:             assertFalse(message.getJMSRedelivered());
1:69e6ad8:         }
1:69e6ad8:     }
1:e050519: 
1:e050519:     @Test(timeout = 30000)
1:e050519:     public void testProduceAndConsumeLargeNumbersOfTopicMessagesClientAck() throws Exception {
1:e050519:         doTestProduceAndConsumeLargeNumbersOfMessages(true, Session.CLIENT_ACKNOWLEDGE);
1:e050519:     }
1:e050519: 
1:e050519:     @Test(timeout = 30000)
1:e050519:     public void testProduceAndConsumeLargeNumbersOfQueueMessagesClientAck() throws Exception {
1:e050519:         doTestProduceAndConsumeLargeNumbersOfMessages(false, Session.CLIENT_ACKNOWLEDGE);
1:e050519:     }
1:e050519: 
1:e050519:     @Test(timeout = 30000)
1:e050519:     public void testProduceAndConsumeLargeNumbersOfTopicMessagesAutoAck() throws Exception {
1:e050519:         doTestProduceAndConsumeLargeNumbersOfMessages(true, Session.AUTO_ACKNOWLEDGE);
1:e050519:     }
1:e050519: 
1:e050519:     @Test(timeout = 30000)
1:e050519:     public void testProduceAndConsumeLargeNumbersOfQueueMessagesAutoAck() throws Exception {
1:e050519:         doTestProduceAndConsumeLargeNumbersOfMessages(false, Session.AUTO_ACKNOWLEDGE);
1:e050519:     }
1:e050519: 
1:e050519:     public void doTestProduceAndConsumeLargeNumbersOfMessages(boolean topic, int ackMode) throws Exception {
1:e050519: 
1:e050519:         final int MSG_COUNT = 1000;
1:e050519:         final CountDownLatch done = new CountDownLatch(MSG_COUNT);
1:e050519: 
1:e050519:         JmsConnectionFactory factory = new JmsConnectionFactory(getAmqpURI());
1:e050519:         factory.setForceSyncSend(true);
1:e050519: 
1:e050519:         connection = factory.createConnection();
1:e050519:         connection.start();
1:e050519: 
1:e050519:         Session session = connection.createSession(false, ackMode);
1:e050519:         final Destination destination;
1:e050519:         if (topic) {
1:e050519:             destination = session.createTopic(getDestinationName());
1:e050519:         } else {
1:e050519:             destination = session.createQueue(getDestinationName());
1:e050519:         }
1:e050519: 
1:e050519:         MessageConsumer consumer = session.createConsumer(destination);
1:e050519:         consumer.setMessageListener(new MessageListener() {
1:e050519: 
1:e050519:             @Override
1:e050519:             public void onMessage(Message message) {
1:e050519:                 try {
1:e050519:                     message.acknowledge();
1:e050519:                     done.countDown();
1:e050519:                 } catch (JMSException ex) {
1:e050519:                     LOG.info("Caught exception.", ex);
1:e050519:                 }
1:e050519:             }
1:e050519:         });
1:e050519: 
1:e050519:         MessageProducer producer = session.createProducer(destination);
1:e050519: 
1:e050519:         TextMessage textMessage = session.createTextMessage();
1:e050519:         textMessage.setText("messageText");
1:e050519: 
1:e050519:         for (int i = 0; i < MSG_COUNT; i++) {
1:e050519:             producer.send(textMessage);
1:e050519:         }
1:e050519: 
1:e050519:         assertTrue("Did not receive all messages: " + MSG_COUNT, done.await(15, TimeUnit.SECONDS));
1:e050519:     }
1:cf2083f: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:9ec6ee4
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.MapMessage;
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60000)
1:     public void testSendJMSMapMessage() throws Exception {
1:         ActiveMQAdmin.enableJMSFrameTracing();
1: 
1:         connection = createConnection();
1:         {
1:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             assertNotNull(session);
1:             Queue queue = session.createQueue(name.getMethodName());
1:             MessageProducer producer = session.createProducer(queue);
1:             MapMessage message = session.createMapMessage();
1:             message.setBoolean("Boolean", false);
1:             message.setString("STRING", "TEST");
1:             producer.send(message);
1:             QueueViewMBean proxy = getProxyToQueue(name.getMethodName());
1:             assertEquals(1, proxy.getQueueSize());
1: 
1:             MessageConsumer consumer = session.createConsumer(queue);
1:             Message received = consumer.receive(5000);
1:             assertNotNull(received);
1:             assertTrue(received instanceof MapMessage);
1:             MapMessage map = (MapMessage) received;
1:             assertEquals("TEST", map.getString("STRING"));
1:             assertEquals(false, map.getBooleanProperty("Boolean"));
1:         }
1:     }
1: 
commit:e050519
/////////////////////////////////////////////////////////////////////////
1:         Set<Integer> messageNumbers = new HashSet<>();
/////////////////////////////////////////////////////////////////////////
1:         final AtomicReference<Message> received = new AtomicReference<>();
/////////////////////////////////////////////////////////////////////////
1:             final AtomicReference<Message> msg = new AtomicReference<>();
/////////////////////////////////////////////////////////////////////////
1:         final AtomicReference<Message> received = new AtomicReference<>();
/////////////////////////////////////////////////////////////////////////
1:             final AtomicReference<Message> msg = new AtomicReference<>();
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<Connection> connections = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test(timeout = 30000)
1:     public void testProduceAndConsumeLargeNumbersOfTopicMessagesClientAck() throws Exception {
1:         doTestProduceAndConsumeLargeNumbersOfMessages(true, Session.CLIENT_ACKNOWLEDGE);
1:     }
1: 
1:     @Test(timeout = 30000)
1:     public void testProduceAndConsumeLargeNumbersOfQueueMessagesClientAck() throws Exception {
1:         doTestProduceAndConsumeLargeNumbersOfMessages(false, Session.CLIENT_ACKNOWLEDGE);
1:     }
1: 
1:     @Test(timeout = 30000)
1:     public void testProduceAndConsumeLargeNumbersOfTopicMessagesAutoAck() throws Exception {
1:         doTestProduceAndConsumeLargeNumbersOfMessages(true, Session.AUTO_ACKNOWLEDGE);
1:     }
1: 
1:     @Test(timeout = 30000)
1:     public void testProduceAndConsumeLargeNumbersOfQueueMessagesAutoAck() throws Exception {
1:         doTestProduceAndConsumeLargeNumbersOfMessages(false, Session.AUTO_ACKNOWLEDGE);
1:     }
1: 
1:     public void doTestProduceAndConsumeLargeNumbersOfMessages(boolean topic, int ackMode) throws Exception {
1: 
1:         final int MSG_COUNT = 1000;
1:         final CountDownLatch done = new CountDownLatch(MSG_COUNT);
1: 
1:         JmsConnectionFactory factory = new JmsConnectionFactory(getAmqpURI());
1:         factory.setForceSyncSend(true);
1: 
1:         connection = factory.createConnection();
1:         connection.start();
1: 
1:         Session session = connection.createSession(false, ackMode);
1:         final Destination destination;
1:         if (topic) {
1:             destination = session.createTopic(getDestinationName());
1:         } else {
1:             destination = session.createQueue(getDestinationName());
1:         }
1: 
1:         MessageConsumer consumer = session.createConsumer(destination);
1:         consumer.setMessageListener(new MessageListener() {
1: 
1:             @Override
1:             public void onMessage(Message message) {
1:                 try {
1:                     message.acknowledge();
1:                     done.countDown();
1:                 } catch (JMSException ex) {
1:                     LOG.info("Caught exception.", ex);
1:                 }
1:             }
1:         });
1: 
1:         MessageProducer producer = session.createProducer(destination);
1: 
1:         TextMessage textMessage = session.createTextMessage();
1:         textMessage.setText("messageText");
1: 
1:         for (int i = 0; i < MSG_COUNT; i++) {
1:             producer.send(textMessage);
1:         }
1: 
1:         assertTrue("Did not receive all messages: " + MSG_COUNT, done.await(15, TimeUnit.SECONDS));
1:     }
commit:a35e8dc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.jmx.SubscriptionViewMBean;
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=30000)
1:     public void testRetroactiveConsumerSupported() throws Exception {
1:         ActiveMQAdmin.enableJMSFrameTracing();
1: 
1:         connection = createConnection();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         Queue queue = session.createQueue(getDestinationName() + "?consumer.retroactive=true");
1:         MessageConsumer consumer = session.createConsumer(queue);
1: 
1:         QueueViewMBean queueView = getProxyToQueue(getDestinationName());
1:         assertNotNull(queueView);
1:         assertEquals(1, queueView.getSubscriptions().length);
1: 
1:         SubscriptionViewMBean subscriber = getProxyToQueueSubscriber(getDestinationName());
1:         assertTrue(subscriber.isRetroactive());
1: 
1:         consumer.close();
1:     }
1: 
1:     @Test(timeout=30000)
1:     public void testExclusiveConsumerSupported() throws Exception {
1:         ActiveMQAdmin.enableJMSFrameTracing();
1: 
1:         connection = createConnection();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         Queue queue = session.createQueue(getDestinationName() + "?consumer.exclusive=true");
1:         MessageConsumer consumer = session.createConsumer(queue);
1: 
1:         QueueViewMBean queueView = getProxyToQueue(getDestinationName());
1:         assertNotNull(queueView);
1:         assertEquals(1, queueView.getSubscriptions().length);
1: 
1:         SubscriptionViewMBean subscriber = getProxyToQueueSubscriber(getDestinationName());
1:         assertTrue(subscriber.isExclusive());
1: 
1:         consumer.close();
1:     }
1: 
1:     @Test(timeout=30000)
1:     public void testUnpplicableDestinationOption() throws Exception {
1:         ActiveMQAdmin.enableJMSFrameTracing();
1: 
1:         connection = createConnection();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         Queue queue = session.createQueue(getDestinationName() + "?consumer.unknoen=true");
1:         try {
1:             session.createConsumer(queue);
1:             fail("Should have failed to create consumer");
1:         } catch (JMSException jmsEx) {
1:         }
1:     }
1: 
commit:31c55f7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.qpid.jms.JmsConnectionFactory;
/////////////////////////////////////////////////////////////////////////
1:         JmsConnectionFactory cf = new JmsConnectionFactory(getAmqpURI("jms.prefetchPolicy.all=0"));
1:         connection = cf.createConnection();
commit:bbb17da
/////////////////////////////////////////////////////////////////////////
0: import org.apache.qpid.jms.JmsConnection;
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60000)
1:     public void testZeroPrefetchWithTwoConsumers() throws Exception {
1:         connection = createConnection();
0:         ((JmsConnection)connection).getPrefetchPolicy().setAll(0);
1:         connection.start();
1: 
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         Queue queue = session.createQueue(getDestinationName());
1: 
1:         MessageProducer producer = session.createProducer(queue);
1:         producer.send(session.createTextMessage("Msg1"));
1:         producer.send(session.createTextMessage("Msg2"));
1: 
1:         // now lets receive it
1:         MessageConsumer consumer1 = session.createConsumer(queue);
1:         MessageConsumer consumer2 = session.createConsumer(queue);
1:         TextMessage answer = (TextMessage)consumer1.receive(5000);
1:         assertNotNull(answer);
1:         assertEquals("Should have received a message!", answer.getText(), "Msg1");
1:         answer = (TextMessage)consumer2.receive(5000);
1:         assertNotNull(answer);
1:         assertEquals("Should have received a message!", answer.getText(), "Msg2");
1: 
1:         answer = (TextMessage)consumer2.receiveNoWait();
1:         assertNull("Should have not received a message!", answer);
1:     }
1: 
commit:5c5ced8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:b444b6c
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("Caught exception on consumer create: {}", ex);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.info("Caught exception on receive(): {}", ex);
commit:197dcb1
/////////////////////////////////////////////////////////////////////////
commit:3051882
/////////////////////////////////////////////////////////////////////////
0:     @Ignore("Legacy QPid client does not support creation of TemporaryTopics correctly")
/////////////////////////////////////////////////////////////////////////
commit:ad57cc6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     @Ignore("Legacy QPid client does not support creation of TemporaryTopics correctly")
commit:2ec586f
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.TemporaryQueue;
1: import javax.jms.TemporaryTopic;
/////////////////////////////////////////////////////////////////////////
0: import org.junit.Ignore;
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=30000)
1:     public void testCreateTemporaryQueue() throws Exception {
1:         ActiveMQAdmin.enableJMSFrameTracing();
1: 
1:         connection = createConnection();
1:         {
1:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             Queue queue = session.createTemporaryQueue();
1:             assertNotNull(queue);
1:             assertTrue(queue instanceof TemporaryQueue);
1: 
1:             final BrokerViewMBean broker = getProxyToBroker();
1:             assertEquals(1, broker.getTemporaryQueues().length);
1:         }
1:     }
1: 
0:     @Ignore("Broker cannot currently tell if it should delete a temp destination")
1:     @Test(timeout=30000)
1:     public void testDeleteTemporaryQueue() throws Exception {
1:         ActiveMQAdmin.enableJMSFrameTracing();
1: 
1:         connection = createConnection();
1:         {
1:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             Queue queue = session.createTemporaryQueue();
1:             assertNotNull(queue);
1:             assertTrue(queue instanceof TemporaryQueue);
1: 
1:             final BrokerViewMBean broker = getProxyToBroker();
1:             assertEquals(1, broker.getTemporaryQueues().length);
1: 
1:             TemporaryQueue tempQueue = (TemporaryQueue) queue;
1:             tempQueue.delete();
1: 
1:             assertTrue("Temp Queue should be deleted.", Wait.waitFor(new Wait.Condition() {
1: 
1:                 @Override
1:                 public boolean isSatisified() throws Exception {
1:                     return broker.getTemporaryQueues().length == 0;
1:                 }
1:             }, TimeUnit.SECONDS.toMillis(30), TimeUnit.MILLISECONDS.toMillis(50)));
1:         }
1:     }
1: 
0:     @Ignore("Legacy QPid client does not support creation of TemporaryTopics correctly")
1:     @Test(timeout=30000)
1:     public void testCreateTemporaryTopic() throws Exception {
1:         ActiveMQAdmin.enableJMSFrameTracing();
1: 
1:         connection = createConnection();
1:         {
1:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             Topic topic = session.createTemporaryTopic();
1:             assertNotNull(topic);
1:             assertTrue(topic instanceof TemporaryTopic);
1: 
1:             final BrokerViewMBean broker = getProxyToBroker();
1:             assertEquals(1, broker.getTemporaryTopics().length);
1:         }
1:     }
1: 
0:     @Ignore("Broker cannot currently tell if it should delete a temp destination")
1:     @Test(timeout=30000)
1:     public void testDeleteTemporaryTopic() throws Exception {
1:         ActiveMQAdmin.enableJMSFrameTracing();
1: 
1:         connection = createConnection();
1:         {
1:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             Topic topic = session.createTemporaryTopic();
1:             assertNotNull(topic);
1:             assertTrue(topic instanceof TemporaryTopic);
1: 
1:             final BrokerViewMBean broker = getProxyToBroker();
1:             assertEquals(1, broker.getTemporaryTopics().length);
1: 
1:             TemporaryTopic tempTopic = (TemporaryTopic) topic;
1:             tempTopic.delete();
1: 
1:             assertTrue("Temp Topic should be deleted.", Wait.waitFor(new Wait.Condition() {
1: 
1:                 @Override
1:                 public boolean isSatisified() throws Exception {
1:                     return broker.getTemporaryTopics().length == 0;
1:                 }
1:             }, TimeUnit.SECONDS.toMillis(30), TimeUnit.MILLISECONDS.toMillis(50)));
1:         }
1:     }
1: 
commit:adef03e
/////////////////////////////////////////////////////////////////////////
1:         String durableClientId = getDestinationName() + "-ClientId";
1:         connection = createConnection(durableClientId);
/////////////////////////////////////////////////////////////////////////
1:         String durableClientId = getDestinationName() + "-ClientId";
1:         connection = createConnection(durableClientId);
/////////////////////////////////////////////////////////////////////////
1:         String durableClientId = getDestinationName() + "-ClientId";
1: 
1:         connection = createConnection(durableClientId);
/////////////////////////////////////////////////////////////////////////
1:         String durableClientId = getDestinationName() + "-ClientId";
1:         connection = createConnection(durableClientId);
commit:eaf773d
/////////////////////////////////////////////////////////////////////////
1:     public void testDurableTopicStateAfterSubscriberClosed() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:             JMSClientContext.INSTANCE.createTopicConnection(getBrokerURI(), "admin", "password");
commit:240278d
/////////////////////////////////////////////////////////////////////////
0:             JMSClientContext.INSTANCE.createTopicConnection(amqpURI, "admin", "password");
commit:4fa420b
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.TopicConnection;
1: import javax.jms.TopicSession;
1: import javax.jms.TopicSubscriber;
1: import org.apache.activemq.broker.jmx.BrokerView;
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=30*1000)
0:     public void simpleDurableTopicTest() throws Exception {
1:         String durableClientId = getDestinationName() + "-ClientId";
1:         String durableSubscriberName = getDestinationName() + "-SubscriptionName";
1: 
1:         BrokerView adminView = this.brokerService.getAdminView();
1:         int durableSubscribersAtStart = adminView.getDurableTopicSubscribers().length;
1:         int inactiveSubscribersAtStart = adminView.getInactiveDurableTopicSubscribers().length;
1:         LOG.debug(">>>> At Start, durable Subscribers {} inactiveDurableSubscribers {}", durableSubscribersAtStart, inactiveSubscribersAtStart);
1: 
1:         TopicConnection subscriberConnection =
0:             JmsClientContext.INSTANCE.createTopicConnection(amqpURI, "admin", "password");
1:         subscriberConnection.setClientID(durableClientId);
1:         TopicSession subscriberSession = subscriberConnection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);
1:         Topic topic = subscriberSession.createTopic(getDestinationName());
1:         TopicSubscriber messageConsumer = subscriberSession.createDurableSubscriber(topic, durableSubscriberName);
1: 
1:         assertNotNull(messageConsumer);
1: 
1:         int durableSubscribers = adminView.getDurableTopicSubscribers().length;
1:         int inactiveSubscribers = adminView.getInactiveDurableTopicSubscribers().length;
1:         LOG.debug(">>>> durable Subscribers after creation {} inactiveDurableSubscribers {}", durableSubscribers, inactiveSubscribers);
1:         assertEquals("Wrong number of durable subscribers after first subscription", 1, (durableSubscribers - durableSubscribersAtStart));
1:         assertEquals("Wrong number of inactive durable subscribers after first subscription", 0, (inactiveSubscribers - inactiveSubscribersAtStart));
1: 
1:         subscriberConnection.close();
1: 
1:         durableSubscribers = adminView.getDurableTopicSubscribers().length;
1:         inactiveSubscribers = adminView.getInactiveDurableTopicSubscribers().length;
1:         LOG.debug(">>>> durable Subscribers after close {} inactiveDurableSubscribers {}", durableSubscribers, inactiveSubscribers);
1:         assertEquals("Wrong number of durable subscribers after close", 0, (durableSubscribersAtStart));
1:         assertEquals("Wrong number of inactive durable subscribers after close", 1, (inactiveSubscribers - inactiveSubscribersAtStart));
1:     }
1: 
commit:94937e8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 1; i <= consumeBeforeRollback; i++) {
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 1; i <= totalCount; i++) {
1:         for (int i = 1; i <= totalCount; i++) {
/////////////////////////////////////////////////////////////////////////
1:         final int msgCount = 300;
/////////////////////////////////////////////////////////////////////////
1:             // wait until we know that the producer was able to send a message
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void testProduceAndConsumeLargeNumbersOfMessages() throws Exception {
1:         int count = 1000;
/////////////////////////////////////////////////////////////////////////
1:         MessageConsumer consumer=session.createConsumer(queue);
1:         assertNull(consumer.receiveNoWait());
/////////////////////////////////////////////////////////////////////////
1:             }, TimeUnit.SECONDS.toMillis(25), TimeUnit.MILLISECONDS.toMillis(200)));
/////////////////////////////////////////////////////////////////////////
1:     public void testSessionTransactedCommit() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         QueueViewMBean queueView = getProxyToQueue(getDestinationName());
1:         assertEquals(0, queueView.getQueueSize());
1:         // No commit in place, so no message should be dispatched.
1:         assertEquals(10, queueView.getQueueSize());
1:     public void testSessionTransactedRollback() throws Exception {
/////////////////////////////////////////////////////////////////////////
1: 
1:         // No commit in place, so no message should be dispatched.
1:         QueueViewMBean queueView = getProxyToQueue(getDestinationName());
1:         assertEquals(0, queueView.getQueueSize());
1: 
1:         assertNull(consumer.receive(100));
1:         consumer.close();
/////////////////////////////////////////////////////////////////////////
1:         }, TimeUnit.SECONDS.toMillis(20), TimeUnit.MILLISECONDS.toMillis(250)));
/////////////////////////////////////////////////////////////////////////
1:         }, TimeUnit.SECONDS.toMillis(20), TimeUnit.MILLISECONDS.toMillis(250)));
/////////////////////////////////////////////////////////////////////////
1:         }, TimeUnit.SECONDS.toMillis(20), TimeUnit.MILLISECONDS.toMillis(250)));
/////////////////////////////////////////////////////////////////////////
1:         }, TimeUnit.SECONDS.toMillis(20), TimeUnit.MILLISECONDS.toMillis(250)));
/////////////////////////////////////////////////////////////////////////
1:         }, TimeUnit.SECONDS.toMillis(20), TimeUnit.MILLISECONDS.toMillis(250)));
commit:90afa24
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=30000)
1:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             Queue queue1 = session.createQueue(getDestinationName() + "1");
1:             Queue queue2 = session.createQueue(getDestinationName() + "2");
1:             MessageProducer p = session.createProducer(null);
1: 
1:             TextMessage message = session.createTextMessage();
1:             message.setText("hello");
1:             p.send(queue1, message);
1:             p.send(queue2, message);
1: 
1:             {
1:                 MessageConsumer consumer = session.createConsumer(queue1);
1:                 Message msg = consumer.receive(TestConfig.TIMEOUT);
1:                 assertNotNull(msg);
1:                 assertTrue(msg instanceof TextMessage);
1:                 consumer.close();
1:             }
1:             {
1:                 MessageConsumer consumer = session.createConsumer(queue2);
1:                 Message msg = consumer.receive(TestConfig.TIMEOUT);
1:                 assertNotNull(msg);
1:                 assertTrue(msg instanceof TextMessage);
1:                 consumer.close();
1:             }
commit:61a3eab
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertFalse;
1: import static org.junit.Assert.assertNotNull;
1: import static org.junit.Assert.assertNull;
1: import static org.junit.Assert.assertTrue;
1: import static org.junit.Assert.fail;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     @Test // (timeout=30000)
0: //            Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //            Queue queue1 = session.createQueue(getDestinationName() + "1");
0: //            Queue queue2 = session.createQueue(getDestinationName() + "2");
0: //            MessageProducer p = session.createProducer(null);
0: //
0: //            TextMessage message = session.createTextMessage();
0: //            message.setText("hello");
0: //            p.send(queue1, message);
0: //            p.send(queue2, message);
0: //
0: //            {
0: //                MessageConsumer consumer = session.createConsumer(queue1);
0: //                Message msg = consumer.receive(TestConfig.TIMEOUT);
0: //                assertNotNull(msg);
0: //                assertTrue(msg instanceof TextMessage);
0: //                consumer.close();
0: //            }
0: //            {
0: //                MessageConsumer consumer = session.createConsumer(queue2);
0: //                Message msg = consumer.receive(TestConfig.TIMEOUT);
0: //                assertNotNull(msg);
0: //                assertTrue(msg instanceof TextMessage);
0: //                consumer.close();
0: //            }
commit:7bafa7d
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.Destination;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         // This makes sure the connection is completely up and connected
1:         Destination destination = s.createTemporaryQueue();
1:         MessageProducer producer = s.createProducer(destination);
1:         assertNotNull(producer);
/////////////////////////////////////////////////////////////////////////
commit:9edf907
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
0: import java.util.List;
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1:         Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
/////////////////////////////////////////////////////////////////////////
1:         Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60000)
1:     public void testRollbackSomeThenReceiveAndCommit() throws Exception {
1:         int totalCount = 5;
1:         int consumeBeforeRollback = 2;
1: 
1:         connection = createConnection();
1:         Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:         Queue queue = session.createQueue(getDestinationName());
1:         sendMessages(connection, queue, totalCount);
1: 
1:         QueueViewMBean proxy = getProxyToQueue(name.getMethodName());
1:         assertEquals(totalCount, proxy.getQueueSize());
1: 
1:         MessageConsumer consumer = session.createConsumer(queue);
1: 
0:         for(int i = 1; i <= consumeBeforeRollback; i++) {
1:             Message message = consumer.receive(1000);
1:             assertNotNull(message);
1:             assertEquals("Unexpected message number", i, message.getIntProperty(AmqpTestSupport.MESSAGE_NUMBER));
1:         }
1: 
1:         session.rollback();
1: 
1:         assertEquals(totalCount, proxy.getQueueSize());
1: 
1:         // Consume again..check we receive all the messages.
0:         Set<Integer> messageNumbers = new HashSet<Integer>();
0:         for(int i = 1; i <= totalCount; i++) {
1:             messageNumbers.add(i);
1:         }
1: 
0:         for(int i = 1; i <= totalCount; i++) {
1:             Message message = consumer.receive(1000);
1:             assertNotNull(message);
1:             int msgNum = message.getIntProperty(AmqpTestSupport.MESSAGE_NUMBER);
1:             messageNumbers.remove(msgNum);
1:         }
1: 
1:         session.commit();
1: 
1:         assertTrue("Did not consume all expected messages, missing messages: " + messageNumbers, messageNumbers.isEmpty());
1:         assertEquals("Queue should have no messages left after commit", 0, proxy.getQueueSize());
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
/////////////////////////////////////////////////////////////////////////
1:         Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
commit:0045682
/////////////////////////////////////////////////////////////////////////
0: import org.junit.Ignore;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test(timeout=30000)
1:     public void testDurableConsumerUnsubscribeWhileNoSubscription() throws Exception {
1:         ActiveMQAdmin.enableJMSFrameTracing();
1: 
1:         final BrokerViewMBean broker = getProxyToBroker();
1: 
1:         connection = createConnection();
1:         connection.start();
1: 
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return broker.getInactiveDurableTopicSubscribers().length == 0 &&
1:                        broker.getDurableTopicSubscribers().length == 0;
1:             }
1:         }));
1: 
1:         try {
1:             session.unsubscribe("DurbaleTopic");
1:             fail("Should have thrown as subscription is in use.");
1:         } catch (JMSException ex) {
1:         }
1:     }
1: 
0:     @Ignore("Requires version 0.30 or higher to work.") // TODO
1:     @Test(timeout=30000)
1:     public void testDurableConsumerUnsubscribeWhileActive() throws Exception {
1:         ActiveMQAdmin.enableJMSFrameTracing();
1: 
1:         final BrokerViewMBean broker = getProxyToBroker();
1: 
1:         connection = createConnection();
1:         connection.start();
1: 
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         Topic topic = session.createTopic(getDestinationName());
1:         session.createDurableSubscriber(topic, "DurbaleTopic");
1: 
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return broker.getInactiveDurableTopicSubscribers().length == 0 &&
1:                        broker.getDurableTopicSubscribers().length == 1;
1:             }
1:         }));
1: 
1:         try {
1:             session.unsubscribe("DurbaleTopic");
1:             fail("Should have thrown as subscription is in use.");
1:         } catch (JMSException ex) {
1:         }
1:     }
commit:226e012
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.jmx.BrokerViewMBean;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test(timeout=30000)
1:     public void testDurableConsumerUnsubscribe() throws Exception {
1:         ActiveMQAdmin.enableJMSFrameTracing();
1: 
1:         final BrokerViewMBean broker = getProxyToBroker();
1: 
1:         connection = createConnection();
1:         connection.start();
1: 
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         Topic topic = session.createTopic(getDestinationName());
1:         MessageConsumer consumer = session.createDurableSubscriber(topic, "DurbaleTopic");
1: 
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return broker.getInactiveDurableTopicSubscribers().length == 0 &&
1:                        broker.getDurableTopicSubscribers().length == 1;
1:             }
0:         }));
1: 
1:         consumer.close();
1: 
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return broker.getInactiveDurableTopicSubscribers().length == 1 &&
1:                        broker.getDurableTopicSubscribers().length == 0;
1:             }
0:         }));
1: 
1:         session.unsubscribe("DurbaleTopic");
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return broker.getInactiveDurableTopicSubscribers().length == 0 &&
1:                        broker.getDurableTopicSubscribers().length == 0;
1:             }
0:         }));
1:     }
commit:41ca0d9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.jmx.BrokerViewMBean;
/////////////////////////////////////////////////////////////////////////
0:     public void testDurableConsumerUnsubscribe() throws Exception {
1:         ActiveMQAdmin.enableJMSFrameTracing();
1: 
0:         final BrokerViewMBean broker = getProxyToBroker();
1: 
1:         connection = createConnection();
1:         connection.start();
1: 
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         Topic topic = session.createTopic(getDestinationName());
1:         MessageConsumer consumer = session.createDurableSubscriber(topic, "DurbaleTopic");
1: 
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
0:                 return broker.getInactiveDurableTopicSubscribers().length == 0 &&
0:                        broker.getDurableTopicSubscribers().length == 1;
1:             }
0:         }));
1: 
1:         consumer.close();
1: 
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
0:                 return broker.getInactiveDurableTopicSubscribers().length == 1 &&
0:                        broker.getDurableTopicSubscribers().length == 0;
1:             }
0:         }));
1: 
0:         session.unsubscribe("DurbaleTopic");
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
0:                 return broker.getInactiveDurableTopicSubscribers().length == 0 &&
0:                        broker.getDurableTopicSubscribers().length == 0;
1:             }
0:         }));
1:     }
1: 
1:     @Test(timeout=30000)
commit:3afde7b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:             @Override
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1: 
1:             @Override
/////////////////////////////////////////////////////////////////////////
1: 
commit:1dd34a1
/////////////////////////////////////////////////////////////////////////
1: public class JMSClientTest extends JMSClientTestSupport {
1:     protected static final Logger LOG = LoggerFactory.getLogger(JMSClientTest.class);
1: 
1:     protected java.util.logging.Logger frameLoggger = java.util.logging.Logger.getLogger("FRM");
/////////////////////////////////////////////////////////////////////////
1:         connection = createConnection();
1:             Queue queue = session.createQueue(getDestinationName());
/////////////////////////////////////////////////////////////////////////
1:         connection = createConnection();
0:             Queue queue1 = session.createQueue(getDestinationName() + "1");
0:             Queue queue2 = session.createQueue(getDestinationName() + "2");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         connection = createConnection();
1:         Queue queue = session.createQueue(getDestinationName());
1:         QueueViewMBean queueView = getProxyToQueue(getDestinationName());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         connection = createConnection();
1:         Queue queue = session.createQueue(getDestinationName());
1:         QueueViewMBean queueView = getProxyToQueue(getDestinationName());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         connection = createConnection();
1:         Queue queue = session.createQueue(getDestinationName());
1:         QueueViewMBean queueView = getProxyToQueue(getDestinationName());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         connection = createConnection();
1:             Queue queue = session.createQueue(getDestinationName());
/////////////////////////////////////////////////////////////////////////
1:         connection = createConnection();
1:         Queue queue = session.createQueue(getDestinationName());
/////////////////////////////////////////////////////////////////////////
1:         connection = createConnection();
1:         Queue queue = session.createQueue(getDestinationName());
/////////////////////////////////////////////////////////////////////////
1:         connection = createConnection();
1:         Queue queue = session.createQueue(getDestinationName());
/////////////////////////////////////////////////////////////////////////
1:         connection = createConnection();
1:         Queue queue = session.createQueue(getDestinationName());
/////////////////////////////////////////////////////////////////////////
1:         connection = createConnection();
1:         Queue queue = session.createQueue(getDestinationName());
/////////////////////////////////////////////////////////////////////////
1:         connection = createConnection();
1:         Queue queue = session.createQueue(getDestinationName());
/////////////////////////////////////////////////////////////////////////
1:         connection = createConnection();
1:         Queue queue = session.createQueue(getDestinationName());
/////////////////////////////////////////////////////////////////////////
1:         connection = createConnection();
1:         Queue queue = session.createQueue(getDestinationName());
/////////////////////////////////////////////////////////////////////////
1:         connection = createConnection(true);
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         Queue queue = session.createQueue(getDestinationName());
1:         connection.start();
1:         MessageProducer producer = session.createProducer(queue);
1:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:         Message toSend = session.createTextMessage("Sample text");
1:         producer.send(toSend);
1:         MessageConsumer consumer = session.createConsumer(queue);
1:         Message received = consumer.receive(5000);
1:         assertNotNull(received);
/////////////////////////////////////////////////////////////////////////
1:         connection = createConnection();
1:             Topic topic = session.createTopic(getDestinationName());
/////////////////////////////////////////////////////////////////////////
1:         connection = createConnection();
1:             Topic topic = session.createTopic(getDestinationName());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         connection = createConnection();
1:             Topic topic = session.createTopic(getDestinationName());
/////////////////////////////////////////////////////////////////////////
1:         connection = createConnection();
0:             Topic topic = session.createTopic(getDestinationName());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         connection = createConnection();
/////////////////////////////////////////////////////////////////////////
0:         connection = createConnection();
1:         Queue queue = session.createQueue(getDestinationName());
/////////////////////////////////////////////////////////////////////////
0:         connection = createConnection();
1:         Queue queue = session.createQueue(getDestinationName());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         connection = createConnection();
1:         String queueName = getDestinationName();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:6d8449f
/////////////////////////////////////////////////////////////////////////
1:         final ConnectorViewMBean connector = getProxyToConnectionView(getTargetConnectorName());
/////////////////////////////////////////////////////////////////////////
1:     protected String getTargetConnectorName() {
1:         return "amqp";
1:     }
1: 
commit:6972d37
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=30000)
0:     public void testSessionTransactedRollback() throws JMSException, InterruptedException {
1:         ActiveMQAdmin.enableJMSFrameTracing();
1: 
0:         Connection connection = createConnection();
1:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
0:         Queue queue = session.createQueue(name.toString());
1: 
1:         connection.start();
1: 
1:         // transacted producer
1:         MessageProducer pr = session.createProducer(queue);
1:         for (int i = 0; i < 10; i++) {
1:             Message m = session.createTextMessage("TestMessage" + i);
1:             pr.send(m);
1:         }
1: 
1:         session.rollback();
1: 
1:         // No commit in place, so no message should be dispatched.
1:         MessageConsumer consumer = session.createConsumer(queue);
0:         TextMessage m = (TextMessage) consumer.receive(5000);
0:         assertNull(m);
1: 
1:         session.close();
1:         connection.close();
1:     }
1: 
commit:f555d90
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=30000)
1:     public void testAnonymousProducerConsume() throws Exception {
1:         ActiveMQAdmin.enableJMSFrameTracing();
1: 
0:         Connection connection = createConnection();
1:         {
1:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             Queue queue1 = session.createQueue(name.toString() + "1");
0:             Queue queue2 = session.createQueue(name.toString() + "2");
0:             MessageProducer p = session.createProducer(null);
1: 
1:             TextMessage message = session.createTextMessage();
1:             message.setText("hello");
0:             p.send(queue1, message);
0:             p.send(queue2, message);
1: 
1:             {
0:                 MessageConsumer consumer = session.createConsumer(queue1);
1:                 Message msg = consumer.receive(TestConfig.TIMEOUT);
1:                 assertNotNull(msg);
1:                 assertTrue(msg instanceof TextMessage);
1:                 consumer.close();
1:             }
1:             {
0:                 MessageConsumer consumer = session.createConsumer(queue2);
1:                 Message msg = consumer.receive(TestConfig.TIMEOUT);
1:                 assertNotNull(msg);
1:                 assertTrue(msg instanceof TextMessage);
1:                 consumer.close();
1:             }
1:         }
1:         connection.close();
1:     }
1: 
commit:99d533c
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=30000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=30000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=30000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=30000)
commit:d8c2eda
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Can be overridden in subclasses to test against a different transport suchs as NIO.
1:      *
0:      * @return the port to connect to on the Broker.
1:      */
0:     protected int getBrokerPort() {
0:         return port;
1:     }
1: 
0:         final ConnectionFactoryImpl factory = new ConnectionFactoryImpl("localhost", getBrokerPort(), "admin", "password");
commit:be6b483
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         final ConnectionFactoryImpl factory = new ConnectionFactoryImpl("localhost", port, "admin", "password");
commit:301866d
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQAdmin.enableJMSFrameTracing();
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=30000)
1:         ActiveMQAdmin.enableJMSFrameTracing();
/////////////////////////////////////////////////////////////////////////
0:         final ConnectionFactoryImpl factory = new ConnectionFactoryImpl("localhost", nioPort, "admin", "password");
commit:cdfb562
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=40000)
commit:1e7dc12
/////////////////////////////////////////////////////////////////////////
0:     @Test
0:     public void testSessionTransactedCommit() throws JMSException, InterruptedException {
1: 
0:         Connection connection = createConnection();
0:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
0:         Queue queue = session.createQueue(name.toString());
1: 
1:         connection.start();
1: 
1:         // transacted producer
1:         MessageProducer pr = session.createProducer(queue);
1:         for (int i = 0; i < 10; i++) {
1:             Message m = session.createTextMessage("TestMessage" + i);
1:             pr.send(m);
1:         }
1: 
0:         // No commit in place, so no message should be dispatched.
1:         MessageConsumer consumer = session.createConsumer(queue);
0:         TextMessage m = (TextMessage) consumer.receive(5000);
1: 
0:         assertNull(m);
1: 
1:         session.commit();
1: 
0:         // Messages should be available now.
1:         for (int i = 0; i < 10; i++) {
0:             Message msg = consumer.receive(5000);
1:             assertNotNull(msg);
1:         }
1: 
1:         session.close();
1:         connection.close();
1:     }
1: 
commit:69e6ad8
/////////////////////////////////////////////////////////////////////////
1:     public void testProducerThrowsWhenBrokerStops() throws Exception {
1: 
0:         Connection connection = createConnection();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         Queue queue = session.createQueue(name.toString());
1:         connection.start();
1: 
1:         MessageProducer producer = session.createProducer(queue);
1:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1: 
1:         Message m = session.createTextMessage("Sample text");
1: 
0:         Thread stopper = new Thread(new Runnable() {
1: 
1:             @Override
0:             public void run() {
1:                 try {
0:                     TimeUnit.SECONDS.sleep(5);
1:                     stopBroker();
0:                 } catch (Exception ex) {}
1:             }
1:         });
0:         stopper.start();
1: 
1:         try {
1:             for (int i = 0; i < 10; ++i) {
1:                 producer.send(m);
1:                 TimeUnit.SECONDS.sleep(1);
1:             }
1:             fail("Should have thrown an IllegalStateException");
1:         } catch (Exception ex) {
1:             LOG.info("Caught exception on send: {}", ex);
1:         }
1:     }
1: 
1:     @Test(timeout=30000)
1:     public void testProducerCreateThrowsWhenBrokerStops() throws Exception {
1: 
0:         Connection connection = createConnection();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         Queue queue = session.createQueue(name.toString());
1:         connection.start();
1: 
0:         Thread stopper = new Thread(new Runnable() {
1: 
1:             @Override
0:             public void run() {
1:                 try {
0:                     TimeUnit.SECONDS.sleep(5);
1:                     stopBroker();
0:                 } catch (Exception ex) {}
1:             }
1:         });
0:         stopper.start();
1: 
1:         try {
1:             for (int i = 0; i < 10; ++i) {
1:                 MessageProducer producer = session.createProducer(queue);
0:                 assertNotNull(producer);
1:                 TimeUnit.SECONDS.sleep(1);
1:             }
1:             fail("Should have thrown an IllegalStateException");
1:         } catch (Exception ex) {
1:             LOG.info("Caught exception on create producer: {}", ex);
1:         }
1:     }
1: 
1:     @Test(timeout=30000)
1:     public void testConsumerCreateThrowsWhenBrokerStops() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         stopBroker();
/////////////////////////////////////////////////////////////////////////
1:     public void testConsumerReceiveNoWaitThrowsWhenBrokerStops() throws Exception {
0:         MessageConsumer consumer=session.createConsumer(queue);
0:         Thread stopper = new Thread(new Runnable() {
1:                     stopBroker();
0:         stopper.start();
1:                 consumer.receiveNoWait();
1:             LOG.info("Caught exception on receiveNoWait: {}", ex);
1:         }
1:     }
1: 
1:     @Test(timeout=30000)
1:     public void testConsumerReceiveTimedThrowsWhenBrokerStops() throws Exception {
1: 
0:         Connection connection = createConnection();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         Queue queue = session.createQueue(name.toString());
1:         connection.start();
1: 
0:         MessageConsumer consumer=session.createConsumer(queue);
0:         Thread stopper = new Thread(new Runnable() {
1: 
1:             @Override
0:             public void run() {
1:                 try {
0:                     TimeUnit.SECONDS.sleep(5);
1:                     stopBroker();
0:                 } catch (Exception ex) {}
1:             }
1:         });
0:         stopper.start();
1: 
1:         try {
1:             for (int i = 0; i < 10; ++i) {
0:                 consumer.receive(1000);
1:             }
0:             fail("Should have thrown an IllegalStateException");
1:         } catch (Exception ex) {
1:             LOG.info("Caught exception on receive(1000): {}", ex);
1:         }
1:     }
1: 
1:     @Test(timeout=30000)
1:     public void testConsumerReceiveReturnsBrokerStops() throws Exception {
1: 
0:         Connection connection = createConnection();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         Queue queue = session.createQueue(name.toString());
1:         connection.start();
1: 
0:         MessageConsumer consumer=session.createConsumer(queue);
0:         Thread stopper = new Thread(new Runnable() {
1: 
1:             @Override
0:             public void run() {
1:                 try {
0:                     TimeUnit.SECONDS.sleep(5);
1:                     stopBroker();
0:                 } catch (Exception ex) {}
1:             }
1:         });
0:         stopper.start();
1: 
1:         try {
0:             Message m = consumer.receive();
0:             assertNull(m);
1:         } catch (Exception ex) {
1:             LOG.info("Caught exception on receive(1000): {}", ex);
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=30000)
1:     public void testExecptionListenerCalledOnBrokerStop() throws Exception {
1: 
0:         Connection connection = createConnection();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         Queue queue = session.createQueue(name.toString());
1:         connection.start();
1: 
1:         final CountDownLatch called = new CountDownLatch(1);
1: 
1:         connection.setExceptionListener(new ExceptionListener() {
1: 
0:             @Override
1:             public void onException(JMSException exception) {
1:                 LOG.info("Exception listener called: ", exception);
1:                 called.countDown();
1:             }
0:         });
1: 
0:         Thread stopper = new Thread(new Runnable() {
1: 
0:             @Override
0:             public void run() {
0:                 try {
0:                     TimeUnit.SECONDS.sleep(5);
1:                     stopBroker();
0:                 } catch (Exception ex) {}
1:             }
0:         });
0:         stopper.start();
1: 
1:         assertTrue("No exception listener event fired.", called.await(15, TimeUnit.SECONDS));
1:     }
1: 
commit:3d63ca7
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.Queue;
1: import javax.jms.Topic;
/////////////////////////////////////////////////////////////////////////
0:             Queue queue = session.createQueue(name.toString());
/////////////////////////////////////////////////////////////////////////
0:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
0:         Queue queue = session.createQueue(name.toString());
/////////////////////////////////////////////////////////////////////////
0:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
0:         Queue queue = session.createQueue(name.toString());
/////////////////////////////////////////////////////////////////////////
0:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
0:         Queue queue = session.createQueue(name.toString());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             Queue queue = session.createQueue(name.toString());
/////////////////////////////////////////////////////////////////////////
0:         Queue queue = session.createQueue(name.toString());
/////////////////////////////////////////////////////////////////////////
0:         Queue queue = session.createQueue(name.toString());
/////////////////////////////////////////////////////////////////////////
0:         Queue queue = session.createQueue(name.toString());
/////////////////////////////////////////////////////////////////////////
0:         Queue queue = session.createQueue(name.toString());
/////////////////////////////////////////////////////////////////////////
0:             Queue queue = session.createQueue(name.toString());
/////////////////////////////////////////////////////////////////////////
0:             Topic topic = session.createTopic(name.toString());
/////////////////////////////////////////////////////////////////////////
0:             Topic topic = session.createTopic(name.toString());
/////////////////////////////////////////////////////////////////////////
0:             Topic topic = session.createTopic(name.toString());
/////////////////////////////////////////////////////////////////////////
0:             Topic topic = session.createTopic(name.toString());
/////////////////////////////////////////////////////////////////////////
1: 
0:         factory.setTopicPrefix("topic://");
0:         factory.setQueuePrefix("queue://");
commit:efc51fa
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void testSyncSends() throws Exception {
1:         ActiveMQAdmin.enableJMSFrameTracing();
0:             connection = createConnection(true);
1:             producer.setDeliveryMode(DeliveryMode.PERSISTENT);
/////////////////////////////////////////////////////////////////////////
0:         return createConnection(name.toString(), false);
1:     }
1: 
0:     private Connection createConnection(boolean syncPublish) throws JMSException {
0:         return createConnection(name.toString(), syncPublish);
0:         return createConnection(clientId, false);
1:     }
1: 
0:     private Connection createConnection(String clientId, boolean syncPublish) throws JMSException {
1: 
0:         factory.setSyncPublish(syncPublish);
1: 
commit:cf2083f
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.jmx.ConnectorViewMBean;
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=60000)
1:     public void testConnectionsAreClosed() throws Exception {
1:         ActiveMQAdmin.enableJMSFrameTracing();
1: 
0:         final ConnectorViewMBean connector = getProxyToConnectionView("amqp");
1:         LOG.info("Current number of Connections is: {}", connector.connectionCount());
1: 
0:         ArrayList<Connection> connections = new ArrayList<Connection>();
1: 
1:         for (int i = 0; i < 10; i++) {
1:             connections.add(createConnection(null));
1:         }
1: 
1:         LOG.info("Current number of Connections is: {}", connector.connectionCount());
1: 
1:         for (Connection connection : connections) {
0:             connection.close();
1:         }
1: 
1:         assertTrue("Should have no connections left.", Wait.waitFor(new Wait.Condition() {
1: 
0:             @Override
0:             public boolean isSatisified() throws Exception {
1:                 LOG.info("Current number of Connections is: {}", connector.connectionCount());
1:                 return connector.connectionCount() == 0;
1:             }
0:         }));
1:     }
1: 
0:         return createConnection(name.toString());
1:     }
1: 
0:     private Connection createConnection(String clientId) throws JMSException {
0:         if (clientId != null && !clientId.isEmpty()) {
0:             connection.setClientID(clientId);
1:         }
commit:7c01c9b
/////////////////////////////////////////////////////////////////////////
0: import org.junit.Ignore;
/////////////////////////////////////////////////////////////////////////
0:     @Ignore
commit:e1e8c5b
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.atomic.AtomicReference;
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.MessageListener;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.Wait;
0: import org.apache.qpid.amqp_1_0.jms.impl.TopicImpl;
/////////////////////////////////////////////////////////////////////////
0:         Connection connection = null;
0:         try {
0:             QueueImpl queue = new QueueImpl("queue://" + name);
0:             connection = createConnection();
1:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             connection.start();
1:             MessageProducer producer = session.createProducer(queue);
0:             producer.setTimeToLive(1000);
0:             Message toSend = session.createTextMessage("Sample text");
0:             producer.send(toSend);
1:             MessageConsumer consumer = session.createConsumer(queue);
0:             Message received = consumer.receive(5000);
0:             assertNotNull(received);
0:             LOG.info("Message JMSExpiration = {}", received.getJMSExpiration());
0:             producer.setTimeToLive(100);
0:             producer.send(toSend);
0:             TimeUnit.SECONDS.sleep(2);
0:             received = consumer.receive(5000);
0:             if (received != null) {
0:                 LOG.info("Message JMSExpiration = {} JMSTimeStamp = {} TTL = {}",
0:                          new Object[] { received.getJMSExpiration(), received.getJMSTimestamp(),
0:                                         received.getJMSExpiration() - received.getJMSTimestamp()});
1:             }
0:             assertNull(received);
0:         } finally {
0:             connection.close();
1:         }
1:     }
1: 
1:     @Test(timeout=30000)
1:     public void testDurableConsumerAsync() throws Exception {
1:         ActiveMQAdmin.enableJMSFrameTracing();
0:         TopicImpl topic = new TopicImpl("topic://"+name);
1:         final CountDownLatch latch = new CountDownLatch(1);
0:         final AtomicReference<Message> received = new AtomicReference<Message>();
1: 
1:         {
1:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             MessageConsumer consumer = session.createDurableSubscriber(topic, "DurbaleTopic");
1:             consumer.setMessageListener(new MessageListener() {
1: 
0:                 @Override
1:                 public void onMessage(Message message) {
1:                     received.set(message);
1:                     latch.countDown();
1:                 }
0:             });
1: 
1:             MessageProducer producer = session.createProducer(topic);
1:             producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:             connection.start();
1: 
1:             TextMessage message = session.createTextMessage();
1:             message.setText("hello");
1:             producer.send(message);
1: 
1:             assertTrue(latch.await(10, TimeUnit.SECONDS));
1:             assertNotNull("Should have received a message by now.", received.get());
1:             assertTrue("Should be an instance of TextMessage", received.get() instanceof TextMessage);
1:         }
0:         connection.close();
1:     }
1: 
1:     @Test(timeout=30000)
1:     public void testDurableConsumerSync() throws Exception {
1:         ActiveMQAdmin.enableJMSFrameTracing();
0:         TopicImpl topic = new TopicImpl("topic://"+name);
1: 
0:         Connection connection = createConnection();
1:         {
1:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             final MessageConsumer consumer = session.createDurableSubscriber(topic, "DurbaleTopic");
1:             MessageProducer producer = session.createProducer(topic);
1:             producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:             connection.start();
1: 
1:             TextMessage message = session.createTextMessage();
1:             message.setText("hello");
1:             producer.send(message);
1: 
0:             final AtomicReference<Message> msg = new AtomicReference<Message>();
0:             assertTrue(Wait.waitFor(new Wait.Condition() {
1: 
0:                 @Override
0:                 public boolean isSatisified() throws Exception {
1:                     msg.set(consumer.receiveNoWait());
1:                     return msg.get() != null;
1:                 }
0:             }));
1: 
1:             assertNotNull("Should have received a message by now.", msg.get());
1:             assertTrue("Should be an instance of TextMessage", msg.get() instanceof TextMessage);
1:         }
0:         connection.close();
1:     }
1: 
1:     @Test(timeout=30000)
1:     public void testTopicConsumerAsync() throws Exception {
1:         ActiveMQAdmin.enableJMSFrameTracing();
0:         TopicImpl topic = new TopicImpl("topic://"+name);
1:         final CountDownLatch latch = new CountDownLatch(1);
0:         final AtomicReference<Message> received = new AtomicReference<Message>();
1: 
0:         Connection connection = createConnection();
1:         {
1:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             MessageConsumer consumer = session.createConsumer(topic);
1:             consumer.setMessageListener(new MessageListener() {
1: 
0:                 @Override
1:                 public void onMessage(Message message) {
1:                     received.set(message);
1:                     latch.countDown();
1:                 }
0:             });
1: 
1:             MessageProducer producer = session.createProducer(topic);
1:             producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:             connection.start();
1: 
1:             TextMessage message = session.createTextMessage();
1:             message.setText("hello");
1:             producer.send(message);
1: 
1:             assertTrue(latch.await(10, TimeUnit.SECONDS));
1:             assertNotNull("Should have received a message by now.", received.get());
1:             assertTrue("Should be an instance of TextMessage", received.get() instanceof TextMessage);
1:         }
0:         connection.close();
1:     }
1: 
1:     @Test(timeout=45000)
1:     public void testTopicConsumerSync() throws Exception {
1:         ActiveMQAdmin.enableJMSFrameTracing();
0:         TopicImpl topic = new TopicImpl("topic://"+name);
1: 
0:         Connection connection = createConnection();
1:         {
1:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             final MessageConsumer consumer = session.createConsumer(topic);
1:             MessageProducer producer = session.createProducer(topic);
1:             producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:             connection.start();
1: 
1:             TextMessage message = session.createTextMessage();
1:             message.setText("hello");
1:             producer.send(message);
1: 
0:             final AtomicReference<Message> msg = new AtomicReference<Message>();
0:             assertTrue(Wait.waitFor(new Wait.Condition() {
1: 
0:                 @Override
0:                 public boolean isSatisified() throws Exception {
1:                     msg.set(consumer.receiveNoWait());
1:                     return msg.get() != null;
1:                 }
0:             }));
1: 
1:             assertNotNull("Should have received a message by now.", msg.get());
1:             assertTrue("Should be an instance of TextMessage", msg.get() instanceof TextMessage);
1:         }
0:         connection.close();
0:         connection.setClientID(name.toString());
commit:f033486
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertNull;
0: import static org.junit.Assert.fail;
1: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
0:     //should through exception IllegalStateException:The session is closed
1:     @Test(timeout=30000)
0:     public void testBrokerRestartPersistentQueueException() throws Exception {
0:         QueueImpl queue = new QueueImpl("queue://" + name);
1: 
0:         Connection connection = createConnection();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         connection.start();
1: 
1:         MessageProducer producer = session.createProducer(queue);
1:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1: 
1:         Message m = session.createTextMessage("Sample text");
1:         producer.send(m);
1: 
1:         restartBroker();
1: 
0:         try {
1:             session.createConsumer(queue);
0:             fail("Should have thrown an IllegalStateException");
1:         } catch (Exception ex) {
0:             LOG.info("Caught exception on receive: {}", ex);
1:         }
1:     }
1: 
1:     @Test(timeout=30000)
0:     public void testProducerThrowsWhenBrokerRestarted() throws Exception {
0:         QueueImpl queue = new QueueImpl("queue://" + name);
1: 
0:         Connection connection = createConnection();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         connection.start();
1: 
1:         MessageProducer producer = session.createProducer(queue);
1:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1: 
1:         Message m = session.createTextMessage("Sample text");
1: 
0:         Thread restart = new Thread(new Runnable() {
1: 
0:             @Override
0:             public void run() {
0:                 try {
0:                     TimeUnit.SECONDS.sleep(5);
1:                     restartBroker();
0:                 } catch (Exception ex) {}
1:             }
0:         });
0:         restart.start();
1: 
0:         try {
0:             for (int i = 0; i < 10; ++i) {
1:                 producer.send(m);
0:                 TimeUnit.SECONDS.sleep(1);
1:             }
0:             fail("Should have thrown an IllegalStateException");
1:         } catch (Exception ex) {
0:             LOG.info("Caught exception on send: {}", ex);
1:         }
1:     }
1: 
1:     @Test(timeout=30000)
1:     public void testBrokerRestartWontHangConnectionClose() throws Exception {
0:         QueueImpl queue = new QueueImpl("queue://" + name);
1: 
0:         Connection connection = createConnection();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         connection.start();
1: 
1:         MessageProducer producer = session.createProducer(queue);
1:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1: 
1:         Message m = session.createTextMessage("Sample text");
1:         producer.send(m);
1: 
1:         restartBroker();
1: 
0:         try {
0:             connection.close();
1:         } catch (Exception ex) {
1:             LOG.error("Should not thrown on disconnected connection close(): {}", ex);
1:             fail("Should not have thrown an exception.");
1:         }
1:     }
1: 
0:     @Test(timeout=120000)
0:     public void testProduceAndConsumeLargeNumbersOfMessages() throws JMSException {
1: 
0:         int count = 2000;
1: 
0:         QueueImpl queue = new QueueImpl("queue://" + name);
0:         Connection connection = createConnection();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         connection.start();
1: 
1:         MessageProducer producer= session.createProducer(queue);
1:         for (int i = 0; i < count; i++) {
1:             Message m=session.createTextMessage("Test-Message:"+i);
1:             producer.send(m);
1:         }
1: 
1:         MessageConsumer  consumer=session.createConsumer(queue);
1:         for(int i = 0; i < count; i++) {
1:             Message message = consumer.receive(5000);
1:             assertNotNull(message);
0:             System.out.println(((TextMessage) message).getText());
1:             assertEquals("Test-Message:" + i,((TextMessage) message).getText());
1:         }
1: 
1:         Message message = consumer.receive(5000);
0:         assertNull(message);
1:     }
1: 
1:     @Test(timeout=30000)
0:     public void testTTL() throws Exception {
0:         QueueImpl queue = new QueueImpl("queue://" + name);
0:         Connection connection = createConnection();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         connection.start();
1:         MessageProducer producer = session.createProducer(queue);
0:         producer.setTimeToLive(1000);
0:         Message toSend = session.createTextMessage("Sample text");
0:         producer.send(toSend);
1:         MessageConsumer consumer = session.createConsumer(queue);
0:         Message received = consumer.receive(5000);
0:         assertNotNull(received);
0:         producer.setTimeToLive(100);
0:         producer.send(toSend);
0:         TimeUnit.SECONDS.sleep(1);
0:         assertNull(consumer.receive(5000));
1:     }
1: 
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
author:Robert Gemmell
-------------------------------------------------------------------------------
commit:6b18857
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("rawtypes")
0:     @Test(timeout=30000)
1:     public void testSelectorsWithJMSType() throws Exception{
1:         ActiveMQAdmin.enableJMSFrameTracing();
1: 
0:         connection = createConnection();
1:         {
0:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             Queue queue = session.createQueue(getDestinationName());
1:             MessageProducer p = session.createProducer(queue);
1: 
1:             TextMessage message = session.createTextMessage();
1:             message.setText("text");
1:             p.send(message, DeliveryMode.NON_PERSISTENT, Message.DEFAULT_PRIORITY, Message.DEFAULT_TIME_TO_LIVE);
1: 
1:             TextMessage message2 = session.createTextMessage();
1:             String type = "myJMSType";
1:             message2.setJMSType(type);
1:             message2.setText("text + type");
1:             p.send(message2, DeliveryMode.NON_PERSISTENT, Message.DEFAULT_PRIORITY, Message.DEFAULT_TIME_TO_LIVE);
1: 
1:             QueueBrowser browser = session.createBrowser(queue);
1:             Enumeration enumeration = browser.getEnumeration();
1:             int count = 0;
1:             while (enumeration.hasMoreElements()) {
1:                 Message m = (Message) enumeration.nextElement();
1:                 assertTrue(m instanceof TextMessage);
1:                 count ++;
1:             }
1: 
1:             assertEquals(2, count);
1: 
1:             MessageConsumer consumer = session.createConsumer(queue, "JMSType = '"+ type +"'");
1:             Message msg = consumer.receive(TestConfig.TIMEOUT);
1:             assertNotNull(msg);
1:             assertTrue(msg instanceof TextMessage);
1:             assertEquals("Unexpected JMSType value", type, msg.getJMSType());
1:             assertEquals("Unexpected message content", "text + type", ((TextMessage) msg).getText());
1:         }
1:     }
1: 
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:0ca376d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.*;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:     @Test(timeout=30000)
1:     public void testRedeliveredHeader() throws Exception {
0:         connection = createConnection();
0:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         Queue queue = session.createQueue(getDestinationName());
0:         connection.start();
1: 
0:         MessageProducer producer = session.createProducer(queue);
0:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1: 
1:         for (int i = 1; i < 100; i++) {
1:             Message m = session.createTextMessage(i + ". Sample text");
1:             producer.send(m);
1:         }
1: 
1:         MessageConsumer consumer = session.createConsumer(queue);
1:         receiveMessages(consumer);
0:         consumer.close();
1: 
1:         consumer = session.createConsumer(queue);
1:         receiveMessages(consumer);
0:         consumer.close();
1:     }
1: 
1:     protected void receiveMessages(MessageConsumer consumer) throws Exception {
0:         for (int i = 0; i < 10; i++) {
1:             Message message = consumer.receive(1000);
1:             assertNotNull(message);
1:             assertFalse(message.getJMSRedelivered());
1:         }
1:     }
author:Kevin Earls
-------------------------------------------------------------------------------
commit:76e29bd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=30*1000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=30000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=30000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=30 * 1000)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=30000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 30 * 1000)
commit:87420cc
/////////////////////////////////////////////////////////////////////////
1:     private String createLargeString(int sizeInBytes) {
1:         byte[] base = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};
1:         StringBuilder builder = new StringBuilder();
1:         for (int i = 0; i < sizeInBytes; i++) {
1:             builder.append(base[i % base.length]);
1:         }
1: 
1:         LOG.debug("Created string with size : " + builder.toString().getBytes().length + " bytes");
1:         return builder.toString();
1:     }
1: 
0:     @Test(timeout = 60 * 1000)
1:     public void testSendLargeMessage() throws JMSException, InterruptedException {
0:         Connection connection = createConnection();
0:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         String queueName = name.toString();
1:         Queue queue = session.createQueue(queueName);
1: 
1:         MessageProducer producer=session.createProducer(queue);
1:         int messageSize = 1024 * 1024;
1:         String messageText = createLargeString(messageSize);
1:         Message m=session.createTextMessage(messageText);
1:         LOG.debug("Sending message of {} bytes on queue {}", messageSize, queueName);
0:         producer.send(m);
1: 
0:         MessageConsumer  consumer=session.createConsumer(queue);
1: 
1:         Message message = consumer.receive();
1:         assertNotNull(message);
1:         assertTrue(message instanceof TextMessage);
1:         TextMessage textMessage = (TextMessage) message;
1:         LOG.debug(">>>> Received message of length {}", textMessage.getText().length());
1:         assertEquals(messageSize, textMessage.getText().length());
1:         assertEquals(messageText, textMessage.getText());
1:     }
1: 
commit:2360fb8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=90000)
/////////////////////////////////////////////////////////////////////////
1:                 TimeUnit.MILLISECONDS.sleep(1000 + (i * 100));
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=60000)
/////////////////////////////////////////////////////////////////////////
0:                 consumer.receive(1000 + (i * 100));
/////////////////////////////////////////////////////////////////////////
0:         return createConnection(name.toString(), false, false);
0:         return createConnection(name.toString(), syncPublish, false);
0:         return createConnection(clientId, false, false);
/////////////////////////////////////////////////////////////////////////
0:     protected Connection createConnection(String clientId, boolean syncPublish, boolean useSsl) throws JMSException {
0:         final ConnectionFactoryImpl factory = new ConnectionFactoryImpl("localhost", brokerPort, "admin", "password", null, useSsl);
commit:28c565c
/////////////////////////////////////////////////////////////////////////
0: import org.junit.Ignore;
/////////////////////////////////////////////////////////////////////////
0: @Ignore
commit:da63f3f
/////////////////////////////////////////////////////////////////////////
0: /**                           >>>>>> pumping
/////////////////////////////////////////////////////////////////////////
0: import org.junit.After;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
0:     protected static final Logger LOG = LoggerFactory.getLogger(JMSClientTest.class);
0:     java.util.logging.Logger frameLoggger = java.util.logging.Logger.getLogger("FRM");
0: 
0:         LOG.debug("in setUp of {}", name.getMethodName());
0:     @Override
0:     @After
0:     public void tearDown() throws Exception {
0:         LOG.debug("in tearDown of {}", name.getMethodName());
0:         super.tearDown();
0:         Thread.sleep(500);
1:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=60000)
/////////////////////////////////////////////////////////////////////////
0:         int brokerPort = getBrokerPort();
0:         LOG.debug("Creating connection on port {}", brokerPort);
0:         final ConnectionFactoryImpl factory = new ConnectionFactoryImpl("localhost", brokerPort, "admin", "password");
commit:a165054
/////////////////////////////////////////////////////////////////////////
0: import org.junit.Before;
0: import org.junit.Ignore;
/////////////////////////////////////////////////////////////////////////
0:     @Override
0:     @Before
0:     public void setUp() throws Exception {
0:         LOG.debug("Starting test {}", name.getMethodName());
0:         super.setUp();
1:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     @Ignore("AMQ-5041")
/////////////////////////////////////////////////////////////////////////
0:     @Ignore("AMQ-5041")
/////////////////////////////////////////////////////////////////////////
0:     @Ignore("AMQ-5041")
/////////////////////////////////////////////////////////////////////////
0:     @Ignore("AMQ-5041")
/////////////////////////////////////////////////////////////////////////
0:     @Ignore("AMQ-5041")
/////////////////////////////////////////////////////////////////////////
0:     @Ignore("AMQ-5041")
/////////////////////////////////////////////////////////////////////////
0:     @Ignore("AMQ-5041")
/////////////////////////////////////////////////////////////////////////
0:     @Ignore("AMQ-5041")
/////////////////////////////////////////////////////////////////////////
0:     @Ignore("AMQ-5041")
author:Daniel Kulp
-------------------------------------------------------------------------------
commit:7fe23bc
/////////////////////////////////////////////////////////////////////////
0: /**
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0:     
1:     abstract class Testable implements Runnable {
1:         protected String msg;
1:         synchronized boolean passed() {
1:             if (msg != null) {
1:                 fail(msg);
1:             }
1:             return true;
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:         final MessageProducer producer = session.createProducer(queue);
1:         final Message m = session.createTextMessage("Sample text");
0:         
1:         Testable t = new Testable() {
1:             public synchronized void run() {
1:                     for (int i = 0; i < 30; ++i) {
0:                         producer.send(m);
1:                         synchronized (producer) {
1:                             producer.notifyAll();
1:                         }
1:                         TimeUnit.MILLISECONDS.sleep(100);
1:                     }
1:                     msg = "Should have thrown an IllegalStateException";
0:                 } catch (Exception ex) {
0:                     LOG.info("Caught exception on send: {}", ex);
1:                 }
1:         };
1:         synchronized(producer) {
1:             new Thread(t).start();
0:             //wait until we know that the producer was able to send a message
1:             producer.wait(10000);
0:             
0:         stopBroker();
1:         assertTrue(t.passed());
1:         final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         final Queue queue = session.createQueue(getDestinationName());
0:         
1:         Testable t = new Testable() {
1:             public synchronized void run() {
0:                     for (int i = 0; i < 10; ++i) {
0:                         MessageProducer producer = session.createProducer(queue);
1:                         synchronized (session) {
1:                             session.notifyAll();
1:                         }
1:                         if (producer == null) {
1:                             msg = "Producer should not be null";
1:                         }
0:                         TimeUnit.SECONDS.sleep(1);
1:                     }
1:                     msg = "Should have thrown an IllegalStateException";
0:                 } catch (Exception ex) {
0:                     LOG.info("Caught exception on create producer: {}", ex);
1:                 }
1:         };
1:         synchronized (session) {
1:             new Thread(t).start();
1:             session.wait(10000);
0:         stopBroker();
1:         assertTrue(t.passed());
/////////////////////////////////////////////////////////////////////////
1:         final MessageConsumer consumer=session.createConsumer(queue);
1:         Testable t = new Testable() {
1:             public synchronized void run() {
0:                     for (int i = 0; i < 10; ++i) {
0:                         consumer.receiveNoWait();
1:                         synchronized (consumer) {
1:                             consumer.notifyAll();
1:                         }
0:                         TimeUnit.MILLISECONDS.sleep(1000 + (i * 100));
1:                     }
1:                     msg = "Should have thrown an IllegalStateException";
0:                 } catch (Exception ex) {
0:                     LOG.info("Caught exception on receiveNoWait: {}", ex);
1:                 }
0:             
1:         };
1:         synchronized (consumer) {
1:             new Thread(t).start();
1:             consumer.wait(10000);
0:         stopBroker();
1:         assertTrue(t.passed());
/////////////////////////////////////////////////////////////////////////
1:         final MessageConsumer consumer=session.createConsumer(queue);
1:         Testable t = new Testable() {
1:             public synchronized void run() {
0:                     for (int i = 0; i < 10; ++i) {
1:                         consumer.receive(100 + (i * 1000));
1:                         synchronized (consumer) {
1:                             consumer.notifyAll();
0:                         }
0:                     }
1:                     msg = "Should have thrown an IllegalStateException";
0:                 } catch (Exception ex) {
0:                     LOG.info("Caught exception on receive(1000): {}", ex);
0:                 }
1:         };
1:         synchronized (consumer) {
1:             new Thread(t).start();
1:             consumer.wait(10000);
1:             consumer.notifyAll();
0:         stopBroker();
1:         assertTrue(t.passed());
/////////////////////////////////////////////////////////////////////////
1:         final MessageConsumer consumer=session.createConsumer(queue);
0:         
1:         Testable t = new Testable() {
1:             public synchronized void run() {
1:                     Message m = consumer.receive(1);
1:                     synchronized (consumer) {
1:                         consumer.notifyAll();
1:                         if (m != null) {
1:                             msg = "Should have returned null";
1:                             return;
0:                         }
0:                     }
1:                     m = consumer.receive();
1:                     if (m != null) {
1:                         msg = "Should have returned null";
0:                     }
0:                 } catch (Exception ex) {
0:                     LOG.info("Caught exception on receive(1000): {}", ex);
0:                 }
1:         };
1:         synchronized (consumer) {
1:             new Thread(t).start();
1:             consumer.wait(10000);
0:         stopBroker();
1:         assertTrue(t.passed());
0: 
/////////////////////////////////////////////////////////////////////////
0:         Message message = consumer.receive(500);
/////////////////////////////////////////////////////////////////////////
1:         Session s = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
/////////////////////////////////////////////////////////////////////////
0:         //This makes sure the connection is completely up and connected
0:         s.createTemporaryQueue().delete();
0:         stopBroker();
0:         
/////////////////////////////////////////////////////////////////////////
0:         TextMessage m = (TextMessage) consumer.receive(500);
/////////////////////////////////////////////////////////////////////////
0:         TextMessage m = (TextMessage) consumer.receive(500);
author:gtully
-------------------------------------------------------------------------------
commit:efb9886
/////////////////////////////////////////////////////////////////////////
0:         factory.setSyncPublish(syncPublish);
commit:a33a4e7
/////////////////////////////////////////////////////////////////////////
0:         // seems to require unreleased .026
0:         // factory.setSyncPublish(syncPublish);
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ed5d841
/////////////////////////////////////////////////////////////////////////
0: import org.junit.Rule;
0: import org.junit.rules.TestName;
/////////////////////////////////////////////////////////////////////////
0:     @Rule public TestName name = new TestName();
0: 
0:         QueueImpl queue = new QueueImpl("queue://" + name);
/////////////////////////////////////////////////////////////////////////
0:         QueueImpl queue = new QueueImpl("queue://" + name);
1:         final int msgCount = 1;
0:         QueueViewMBean queueView = getProxyToQueue(name.toString());
0:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:         MessageConsumer consumer = session.createConsumer(queue);
1:         Message msg = consumer.receive(TestConfig.TIMEOUT);
1:         assertNotNull(msg);
1:         assertTrue(msg instanceof TextMessage);
1:         LOG.info("Queue size before session commit is: {}", queueView.getQueueSize());
1:         assertEquals(msgCount, queueView.getQueueSize());
1:         session.commit();
0: 
1:         LOG.info("Queue size after session commit is: {}", queueView.getQueueSize());
/////////////////////////////////////////////////////////////////////////
0:         QueueImpl queue = new QueueImpl("queue://" + name);
0:         QueueViewMBean queueView = getProxyToQueue(name.toString());
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("Test received msg: {}", msg);
/////////////////////////////////////////////////////////////////////////
0: 
1:         session.close();
0:         connection.close();
0:         QueueImpl queue = new QueueImpl("queue://" + name);
0:         QueueViewMBean queueView = getProxyToQueue(name.toString());
/////////////////////////////////////////////////////////////////////////
0:             consumer.close();
1:             session.close();
0:         connection.close();
0: 
/////////////////////////////////////////////////////////////////////////
0:         QueueImpl queue = new QueueImpl("queue://" + name);
commit:c5c4caa
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.jmx.QueueViewMBean;
/////////////////////////////////////////////////////////////////////////
1:     public void testProducerConsume() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     }
0:     @Test
1:     public void testTransactedConsumer() throws Exception {
1:         ActiveMQAdmin.enableJMSFrameTracing();
0:         QueueImpl queue = new QueueImpl("queue://txqueue");
0:         final int msgCount = 10;
0: 
0:         Connection connection = createConnection();
1:         sendMessages(connection, queue, msgCount);
0: 
0:         QueueViewMBean queueView = getProxyToQueue("txqueue");
1:         LOG.info("Queue size after produce is: {}", queueView.getQueueSize());
1:         assertEquals(msgCount, queueView.getQueueSize());
0: 
1:         // Consumer all in TX and commit.
1:         {
0:             Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
0:             MessageConsumer consumer = session.createConsumer(queue);
0: 
1:             for (int i = 0; i < msgCount; ++i) {
1:                 Message msg = consumer.receive(TestConfig.TIMEOUT);
1:                 assertNotNull(msg);
1:                 assertTrue(msg instanceof TextMessage);
0:             }
0: 
0:             consumer.close();
1:             session.commit();
0:         }
0: 
0:         LOG.info("Queue size after consumer commit is: {}", queueView.getQueueSize());
1:         assertEquals(0, queueView.getQueueSize());
0: 
0:         connection.close();
0:     }
0: 
0:     @Test
1:     public void testRollbackRececeivedMessage() throws Exception {
0: 
1:         ActiveMQAdmin.enableJMSFrameTracing();
0:         QueueImpl queue = new QueueImpl("queue://txqueue");
1:         final int msgCount = 1;
0: 
0:         Connection connection = createConnection();
1:         sendMessages(connection, queue, msgCount);
0: 
0:         QueueViewMBean queueView = getProxyToQueue("txqueue");
1:         LOG.info("Queue size after produce is: {}", queueView.getQueueSize());
1:         assertEquals(msgCount, queueView.getQueueSize());
0: 
0:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer = session.createConsumer(queue);
0: 
1:         // Receive and roll back, first receive should not show redelivered.
1:         Message msg = consumer.receive(TestConfig.TIMEOUT);
1:         assertNotNull(msg);
1:         assertTrue(msg instanceof TextMessage);
1:         assertEquals(false, msg.getJMSRedelivered());
0: 
1:         session.rollback();
0: 
1:         // Receive and roll back, first receive should not show redelivered.
1:         msg = consumer.receive(TestConfig.TIMEOUT);
1:         assertNotNull(msg);
1:         assertTrue(msg instanceof TextMessage);
1:         assertEquals(true, msg.getJMSRedelivered());
0: 
1:         LOG.info("Queue size after produce is: {}", queueView.getQueueSize());
1:         assertEquals(msgCount, queueView.getQueueSize());
0: 
1:         session.commit();
0: 
1:         LOG.info("Queue size after produce is: {}", queueView.getQueueSize());
1:         assertEquals(0, queueView.getQueueSize());
0:     }
0: 
0:     @Test
1:     public void testTXConsumerAndLargeNumberOfMessages() throws Exception {
0: 
1:         ActiveMQAdmin.enableJMSFrameTracing();
0:         QueueImpl queue = new QueueImpl("queue://txqueue");
0:         final int msgCount = 500;
0: 
0:         Connection connection = createConnection();
1:         sendMessages(connection, queue, msgCount);
0: 
0:         QueueViewMBean queueView = getProxyToQueue("txqueue");
1:         LOG.info("Queue size after produce is: {}", queueView.getQueueSize());
1:         assertEquals(msgCount, queueView.getQueueSize());
0: 
1:         // Consumer all in TX and commit.
1:         {
0:             Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
0:             MessageConsumer consumer = session.createConsumer(queue);
0: 
1:             for (int i = 0; i < msgCount; ++i) {
1:                 if ((i % 100) == 0) {
1:                     LOG.info("Attempting receive of Message #{}", i);
0:                 }
1:                 Message msg = consumer.receive(TestConfig.TIMEOUT);
1:                 assertNotNull("Should receive message: " + i, msg);
1:                 assertTrue(msg instanceof TextMessage);
0:             }
0: 
0:             consumer.close();
1:             session.commit();
0:         }
0: 
1:         LOG.info("Queue size after produce is: {}", queueView.getQueueSize());
1:         assertEquals(0, queueView.getQueueSize());
commit:1e5dac1
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.Connection;
1: import javax.jms.DeliveryMode;
1: import javax.jms.ExceptionListener;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.QueueBrowser;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("rawtypes")
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("rawtypes")
/////////////////////////////////////////////////////////////////////////
commit:0766a18
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertNotNull;
0: import static org.junit.Assert.assertTrue;
0: 
1: import java.util.Enumeration;
0: 
0: import javax.jms.Connection;
0: import javax.jms.ExceptionListener;
0: import javax.jms.JMSException;
0: import javax.jms.Message;
0: import javax.jms.MessageConsumer;
0: import javax.jms.MessageProducer;
0: import javax.jms.QueueBrowser;
0: import javax.jms.Session;
0: import javax.jms.TextMessage;
0: 
/////////////////////////////////////////////////////////////////////////
0:             assertNotNull(msg);
0:             assertTrue(msg instanceof TextMessage);
author:Christian Posta
-------------------------------------------------------------------------------
commit:25d774b
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertEquals;
0: import javax.jms.*;
/////////////////////////////////////////////////////////////////////////
0:     @Test
1:     public void testSelectors() throws Exception{
1:         ActiveMQAdmin.enableJMSFrameTracing();
0:         QueueImpl queue = new QueueImpl("queue://txqueue");
0: 
0:         Connection connection = createConnection();
0:         {
0:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             MessageProducer p = session.createProducer(queue);
0: 
1:             TextMessage message = session.createTextMessage();
1:             message.setText("hello");
1:             p.send(message, DeliveryMode.PERSISTENT, 5, 0);
0: 
1:             message = session.createTextMessage();
1:             message.setText("hello + 9");
1:             p.send(message, DeliveryMode.PERSISTENT, 9, 0);
0: 
1:             QueueBrowser browser = session.createBrowser(queue);
1:             Enumeration enumeration = browser.getEnumeration();
1:             int count = 0;
1:             while (enumeration.hasMoreElements()) {
1:                 Message m = (Message) enumeration.nextElement();
1:                 assertTrue(m instanceof TextMessage);
1:                 count ++;
0:             }
0: 
1:             assertEquals(2, count);
0: 
1:             MessageConsumer consumer = session.createConsumer(queue, "JMSPriority > 8");
0:             Message msg = consumer.receive(TestConfig.TIMEOUT);
0:             assertNotNull(msg);
0:             assertTrue(msg instanceof TextMessage);
1:             assertEquals("hello + 9", ((TextMessage) msg).getText());
0:         }
0:         connection.close();
0:     }
0: 
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:943011e
/////////////////////////////////////////////////////////////////////////
commit:3016b39
/////////////////////////////////////////////////////////////////////////
1: import org.objectweb.jtests.jms.framework.TestConfig;
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertTrue;
/////////////////////////////////////////////////////////////////////////
0:             TextMessage message = session.createTextMessage();
0:             message.setText("hello");
1:             p.send(message);
1:                 Message m = (Message) enumeration.nextElement();
1:                 assertTrue(m instanceof TextMessage);
0:             MessageConsumer consumer = session.createConsumer(queue);
0:             Message msg = consumer.receive(TestConfig.TIMEOUT);
0:             assertTrue(message instanceof TextMessage);
commit:dc4ceb4
/////////////////////////////////////////////////////////////////////////
0:         final ConnectionFactoryImpl factory = new ConnectionFactoryImpl("localhost", port, "admin", "password");
commit:2db73e2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.amqp.joram.ActiveMQAdmin;
/////////////////////////////////////////////////////////////////////////
0:     public void testTransactions() throws Exception {
0:         ActiveMQAdmin.enableJMSFrameTracing();
0:         QueueImpl queue = new QueueImpl("queue://txqueue");
0:         Connection connection = createConnection();
0:         {
0:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             MessageProducer p = session.createProducer(queue);
0:             p.send(session.createTextMessage("Hello World"));
0: //            session.commit();
0:             MessageConsumer c = session.createConsumer(queue);
0:             Message msg = c.receive();
0:             System.out.println("first:"+msg);
0:             System.out.println(msg.getJMSRedelivered());
0: //            session.rollback();
0: //
0: //            msg = c.receive();
0: //            System.out.println("second:"+msg);
0: //            System.out.println(msg.getJMSRedelivered());
0:         connection.close();
0: //    @Test
0: //    public void testSendReceive() throws Exception {
0: //        ActiveMQAdmin.enableJMSFrameTracing();
0: //        QueueImpl queue = new QueueImpl("queue://testqueue");
0: //        int nMsgs = 1;
0: //        final String dataFormat = "%01024d";
0: //
0: //
0: //        try {
0: //            Connection connection = createConnection();
0: //            {
0: //                Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //                MessageProducer p = session.createProducer(queue);
0: //                for (int i = 0; i < nMsgs; i++) {
0: //                    System.out.println("Sending " + i);
0: //                    p.send(session.createTextMessage(String.format(dataFormat, i)));
0: //                }
0: //            }
0: //            connection.close();
0: //
0: //            System.out.println("=======================================================================================");
0: //            System.out.println(" failing a receive ");
0: //            System.out.println("=======================================================================================");
0: //            connection = createConnection();
0: //            {
0: //                Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
0: //                MessageConsumer c = session.createConsumer(queue);
0: //
0: //                // Receive messages non-transacted
0: //                int i = 0;
0: //                while ( i < 1) {
0: //                    TextMessage msg = (TextMessage) c.receive();
0: //                    if( msg!=null ) {
0: //                        String s = msg.getText();
0: //                        assertEquals(String.format(dataFormat, i), s);
0: //                        System.out.println("Received: " + i);
0: //                        i++;
0: //                    }
0: //                }
0: //            }
0: //            connection.close();
0: //
0: //
0: //            System.out.println("=======================================================================================");
0: //            System.out.println(" receiving ");
0: //            System.out.println("=======================================================================================");
0: //            connection = createConnection();
0: //            {
0: //                Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //                MessageConsumer c = session.createConsumer(queue);
0: //
0: //                // Receive messages non-transacted
0: //                int i = 0;
0: //                while ( i < nMsgs) {
0: //                    TextMessage msg = (TextMessage) c.receive();
0: //                    if( msg!=null ) {
0: //                        String s = msg.getText();
0: //                        assertEquals(String.format(dataFormat, i), s);
0: //                        System.out.println("Received: " + i);
0: //                        i++;
0: //                    }
0: //                }
0: //            }
0: //            connection.close();
0: //
0: //        } catch (Exception e) {
0: //            e.printStackTrace();
0: //        }
0: //
0: //    }
0: 
0:     private Connection createConnection() throws JMSException {
0:         final ConnectionFactoryImpl factory = new ConnectionFactoryImpl("localhost", port, null, null);
0:         final Connection connection = factory.createConnection();
0:         connection.setExceptionListener(new ExceptionListener() {
0:             @Override
0:             public void onException(JMSException exception) {
0:                 exception.printStackTrace();
0:             }
0:         });
0:         connection.start();
0:         return connection;
0:     }
0: 
commit:6baed7a
/////////////////////////////////////////////////////////////////////////
0:         final String dataFormat = "%010240d";
commit:f355b16
/////////////////////////////////////////////////////////////////////////
0:         QueueImpl queue = new QueueImpl("queue://testqueue");
commit:88dfe00
/////////////////////////////////////////////////////////////////////////
0: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
1: package org.apache.activemq.transport.amqp;
0: 
0: import org.apache.qpid.amqp_1_0.jms.impl.ConnectionFactoryImpl;
0: import org.apache.qpid.amqp_1_0.jms.impl.QueueImpl;
1: import org.junit.Test;
0: 
0: import javax.jms.*;
0: 
0: import static org.junit.Assert.assertEquals;
0: 
0: /**
0:  * @author <a href="http://hiramchirino.com">Hiram Chirino</a>
0:  */
0: public class JMSClientTest extends AmqpTestSupport {
0: 
0:     @Test
0:     public void testSendReceive() throws Exception {
0: 
0:         QueueImpl queue = new QueueImpl("BURL:direct://amq.direct//test");
0:         int nMsgs = 100;
0:         final String dataFormat = "%01024d";
0: 
0:         final ConnectionFactoryImpl factory = new ConnectionFactoryImpl("localhost", port, null, null);
0: 
0:         try {
0:             final Connection connection = factory.createConnection();
0:             connection.setExceptionListener(new ExceptionListener() {
0:                 @Override
0:                 public void onException(JMSException exception) {
0:                     exception.printStackTrace();
0:                 }
0:             });
0:             connection.start();
0:             {
0:                 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:                 MessageProducer p = session.createProducer(queue);
0:                 for (int i = 0; i < nMsgs; i++) {
0:                     System.out.println("Sending " + i);
0:                     p.send(session.createTextMessage(String.format(dataFormat, i)));
0:                 }
0:                 p.close();
0:                 session.close();
0:             }
0:             System.out.println("=======================================================================================");
0:             System.out.println(" receiving ");
0:             System.out.println("=======================================================================================");
0:             {
0:                 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:                 MessageConsumer c = session.createConsumer(queue);
0: 
0:                 // Receive messages non-transacted
0:                 int i = 0;
0:                 while ( i < nMsgs) {
0:                     TextMessage msg = (TextMessage) c.receive();
0:                     if( msg!=null ) {
0:                         String s = msg.getText();
0:                         assertEquals(String.format(dataFormat, i), s);
0:                         System.out.println("Received: " + i);
0:                         i++;
0:                     }
0:                 }
0:                 c.close();
0:                 session.close();
0:             }
0:             connection.close();
0:         } catch (Exception e) {
0:             e.printStackTrace();
0:         }
0: 
0:     }
0: 
0: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:6a253eb
/////////////////////////////////////////////////////////////////////////
0: import java.util.Enumeration;
0: 
/////////////////////////////////////////////////////////////////////////
0: /*            MessageConsumer c = session.createConsumer(queue, "x = 1");
0:             System.out.println(received.getJMSRedelivered());*/
0: 
0: 
1:             QueueBrowser browser = session.createBrowser(queue);
1:             Enumeration enumeration = browser.getEnumeration();
1:             while (enumeration.hasMoreElements()) {
0: 
0:                 System.out.println("BROWSE " + enumeration.nextElement());
0:             }
0: 
commit:2a0a0b6
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertNotNull;
/////////////////////////////////////////////////////////////////////////
0:             Message msg = session.createTextMessage("Hello World");
0:             msg.setObjectProperty("x", 1);
0:             p.send(msg);
0:             MessageConsumer c = session.createConsumer(queue, "x = 1");
0:             Message received = c.receive(2000);
0:             assertNotNull(received);
0:             System.out.println("first: " + ((TextMessage)received).getText());
0:             System.out.println(received.getJMSRedelivered());
============================================================================