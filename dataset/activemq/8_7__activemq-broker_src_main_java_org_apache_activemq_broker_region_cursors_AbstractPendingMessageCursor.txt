1:6895d00: /**
1:fc00993:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:fc00993:  * contributor license agreements.  See the NOTICE file distributed with
1:fc00993:  * this work for additional information regarding copyright ownership.
1:fc00993:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:fc00993:  * (the "License"); you may not use this file except in compliance with
1:fc00993:  * the License.  You may obtain a copy of the License at
2:fc00993:  *
1:fc00993:  *      http://www.apache.org/licenses/LICENSE-2.0
1:0bbc0ac:  *
1:fc00993:  * Unless required by applicable law or agreed to in writing, software
1:fc00993:  * distributed under the License is distributed on an "AS IS" BASIS,
1:fc00993:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:fc00993:  * See the License for the specific language governing permissions and
1:fc00993:  * limitations under the License.
1:6895d00:  */
1:4eef609: package org.apache.activemq.broker.region.cursors;
1:409902c: 
1:ae7de6c: import java.util.Collections;
1:0c0be94: import java.util.LinkedList;
1:ae7de6c: import java.util.List;
1:00879cf: import java.util.Set;
1:1ee0017: import org.apache.activemq.ActiveMQMessageAudit;
1:00879cf: import org.apache.activemq.broker.Broker;
1:4eef609: import org.apache.activemq.broker.ConnectionContext;
1:47cfa55: import org.apache.activemq.broker.region.BaseDestination;
1:4eef609: import org.apache.activemq.broker.region.Destination;
1:b6ba20b: import org.apache.activemq.broker.region.MessageReference;
1:00879cf: import org.apache.activemq.broker.region.Subscription;
1:1ee0017: import org.apache.activemq.command.MessageId;
1:6d8e2c5: import org.apache.activemq.usage.SystemUsage;
1:1ee0017: 
1:b036d4d: /**
1:230a86c:  * Abstract method holder for pending message (messages awaiting disptach to a
1:230a86c:  * consumer) cursor
1:cc6213e:  *
1:cc6213e:  *
1:b036d4d:  */
1:f42c91f: public abstract class AbstractPendingMessageCursor implements PendingMessageCursor {
1:1f9e67f:     protected int memoryUsageHighWaterMark = 70;
1:47cfa55:     protected int maxBatchSize = BaseDestination.MAX_PAGE_SIZE;
1:6d8e2c5:     protected SystemUsage systemUsage;
1:3ddb71c:     protected int maxProducersToAudit = BaseDestination.MAX_PRODUCERS_TO_AUDIT;
1:3ddb71c:     protected int maxAuditDepth = BaseDestination.MAX_AUDIT_DEPTH;
1:1ee0017:     protected boolean enableAudit=true;
1:1ee0017:     protected ActiveMQMessageAudit audit;
1:f2fc864:     protected boolean useCache=true;
1:09bf8f8:     protected boolean cacheEnabled=true;
1:8d3674b:     protected boolean started=false;
1:9b260dc:     protected MessageReference last = null;
1:00879cf:     protected final boolean prioritizedMessages;
1:cc6213e: 
1:00879cf:     public AbstractPendingMessageCursor(boolean prioritizedMessages) {
1:00879cf:         this.prioritizedMessages=prioritizedMessages;
1:00879cf:     }
1:cc6213e: 
1:00879cf: 
1:cc6213e:     @Override
1:1ee0017:     public synchronized void start() throws Exception  {
1:1ee0017:         if (!started && enableAudit && audit==null) {
1:1ee0017:             audit= new ActiveMQMessageAudit(maxAuditDepth,maxProducersToAudit);
1:1ee0017:         }
1:1ee0017:         started=true;
1:3a9299b:     }
1:00879cf: 
1:cc6213e:     @Override
1:1ee0017:     public synchronized void stop() throws Exception  {
1:1ee0017:         started=false;
1:3bf0245:         gc();
4:4eef609:     }
1:f42c91f: 
1:cc6213e:     @Override
1:230a86c:     public void add(ConnectionContext context, Destination destination) throws Exception {
1:4eef609:     }
1:071b4b1: 
1:cc6213e:     @Override
1:ae7de6c:     @SuppressWarnings("unchecked")
1:ae7de6c:     public List<MessageReference> remove(ConnectionContext context, Destination destination) throws Exception {
1:ae7de6c:         return Collections.EMPTY_LIST;
1:4eef609:     }
1:55810b3: 
1:cc6213e:     @Override
1:230a86c:     public boolean isRecoveryRequired() {
1:cc6213e:         return true;
1:f42c91f:     }
1:55810b3: 
1:cc6213e:     @Override
1:230a86c:     public void addMessageFirst(MessageReference node) throws Exception {
1:b6ba20b:     }
1:230a86c: 
1:cc6213e:     @Override
1:54e2e3b:     public boolean addMessageLast(MessageReference node) throws Exception {
1:cc6213e:         return tryAddMessageLast(node, INFINITE_WAIT);
1:b6ba20b:     }
1:55810b3: 
1:cc6213e:     @Override
1:cc6213e:     public boolean tryAddMessageLast(MessageReference node, long maxWaitTime) throws Exception {
1:54e2e3b:         return true;
1:cc6213e:     }
1:cc6213e: 
1:cc6213e:     @Override
1:230a86c:     public void addRecoveredMessage(MessageReference node) throws Exception {
1:f42c91f:         addMessageLast(node);
1:a110604:     }
1:409902c: 
1:cc6213e:     @Override
1:230a86c:     public void clear() {
1:b6ba20b:     }
1:9dd11cb: 
1:cc6213e:     @Override
1:230a86c:     public boolean hasNext() {
1:1ee0017:         return false;
1:b6ba20b:     }
1:d261412: 
1:cc6213e:     @Override
1:230a86c:     public boolean isEmpty() {
2:b6ba20b:         return false;
1:b6ba20b:     }
1:230a86c: 
1:cc6213e:     @Override
1:4597ddd:     public boolean isEmpty(Destination destination) {
1:4597ddd:         return isEmpty();
1:4597ddd:     }
1:9dd11cb: 
1:cc6213e:     @Override
1:230a86c:     public MessageReference next() {
1:b6ba20b:         return null;
1:b6ba20b:     }
1:36486fe: 
1:cc6213e:     @Override
1:230a86c:     public void remove() {
1:b6ba20b:     }
1:1ee0017: 
1:cc6213e:     @Override
1:230a86c:     public void reset() {
1:b6ba20b:     }
1:1ee0017: 
1:cc6213e:     @Override
1:230a86c:     public int size() {
1:b6ba20b:         return 0;
1:b6ba20b:     }
1:1ee0017: 
1:cc6213e:     @Override
1:230a86c:     public int getMaxBatchSize() {
1:b6ba20b:         return maxBatchSize;
1:b6ba20b:     }
1:1ee0017: 
1:cc6213e:     @Override
1:230a86c:     public void setMaxBatchSize(int maxBatchSize) {
1:230a86c:         this.maxBatchSize = maxBatchSize;
1:b6ba20b:     }
1:1ee0017: 
1:230a86c:     protected void fillBatch() throws Exception {
1:b6ba20b:     }
1:1ee0017: 
1:cc6213e:     @Override
1:230a86c:     public void resetForGC() {
1:3a9299b:         reset();
1:3bf0245:     }
1:1ee0017: 
1:cc6213e:     @Override
1:230a86c:     public void remove(MessageReference node) {
1:3bf0245:     }
1:1ee0017: 
1:cc6213e:     @Override
1:230a86c:     public void gc() {
1:230a86c:     }
1:230a86c: 
1:cc6213e:     @Override
1:6d8e2c5:     public void setSystemUsage(SystemUsage usageManager) {
1:6d8e2c5:         this.systemUsage = usageManager;
1:6895d00:     }
1:230a86c: 
1:cc6213e:     @Override
1:3bf0245:     public boolean hasSpace() {
1:c76f109:         // allow isFull to verify parent usage and otherwise enforce local memoryUsageHighWaterMark
1:25f112c:         return systemUsage != null ? (!isParentFull() && systemUsage.getMemoryUsage().getPercentUsage() < memoryUsageHighWaterMark) : true;
1:25f112c:     }
1:25f112c: 
1:25f112c:     private boolean isParentFull() {
1:25f112c:         boolean result = false;
1:25f112c:         if (systemUsage != null) {
1:25f112c:             if (systemUsage.getMemoryUsage().getParent() != null) {
1:25f112c:                 return systemUsage.getMemoryUsage().getParent().getPercentUsage() >= 100;
1:25f112c:             }
1:25f112c:         }
1:25f112c:         return result;
1:3bf0245:     }
1:230a86c: 
1:cc6213e:     @Override
1:9359e9f:     public boolean isFull() {
1:6d8e2c5:         return systemUsage != null ? systemUsage.getMemoryUsage().isFull() : false;
1:ec63977:     }
1:aad7e73: 
1:cc6213e:     @Override
1:230a86c:     public void release() {
1:9359e9f:     }
1:230a86c: 
1:cc6213e:     @Override
1:e5efc58:     public boolean hasMessagesBufferedToDeliver() {
1:e5efc58:         return false;
1:e5efc58:     }
1:0c0be94: 
1:55810b3:     /**
1:b036d4d:      * @return the memoryUsageHighWaterMark
1:9dd11cb:      */
1:cc6213e:     @Override
1:230a86c:     public int getMemoryUsageHighWaterMark() {
1:d8c14e0:         return memoryUsageHighWaterMark;
1:b036d4d:     }
1:0c0be94: 
1:0c0be94:     /**
1:b036d4d:      * @param memoryUsageHighWaterMark the memoryUsageHighWaterMark to set
1:b036d4d:      */
1:cc6213e:     @Override
1:230a86c:     public void setMemoryUsageHighWaterMark(int memoryUsageHighWaterMark) {
1:230a86c:         this.memoryUsageHighWaterMark = memoryUsageHighWaterMark;
1:b036d4d:     }
6:b036d4d: 
1:b036d4d:     /**
1:b036d4d:      * @return the usageManager
1:b036d4d:      */
1:cc6213e:     @Override
1:6d8e2c5:     public SystemUsage getSystemUsage() {
1:6d8e2c5:         return this.systemUsage;
1:b036d4d:     }
1:230a86c: 
1:b036d4d:     /**
1:0c0be94:      * destroy the cursor
1:cc6213e:      *
1:230a86c:      * @throws Exception
1:0c0be94:      */
1:cc6213e:     @Override
1:0c0be94:     public void destroy() throws Exception {
1:0c0be94:         stop();
1:0c0be94:     }
1:230a86c: 
1:0c0be94:     /**
1:0c0be94:      * Page in a restricted number of messages
1:cc6213e:      *
1:d8c14e0:      * @param maxItems maximum number of messages to return
1:0c0be94:      * @return a list of paged in messages
1:0c0be94:      */
1:cc6213e:     @Override
1:d8c14e0:     public LinkedList<MessageReference> pageInList(int maxItems) {
1:0c0be94:         throw new RuntimeException("Not supported");
1:0c0be94:     }
1:1ee0017: 
1:1ee0017:     /**
1:1ee0017:      * @return the maxProducersToAudit
1:1ee0017:      */
1:cc6213e:     @Override
1:1ee0017:     public int getMaxProducersToAudit() {
1:1ee0017:         return maxProducersToAudit;
1:1ee0017:     }
1:1ee0017: 
1:1ee0017:     /**
1:1ee0017:      * @param maxProducersToAudit the maxProducersToAudit to set
1:1ee0017:      */
1:cc6213e:     @Override
1:1ee0017:     public synchronized void setMaxProducersToAudit(int maxProducersToAudit) {
1:1ee0017:         this.maxProducersToAudit = maxProducersToAudit;
1:1ee0017:         if (audit != null) {
1:d8c14e0:             audit.setMaximumNumberOfProducersToTrack(maxProducersToAudit);
1:1ee0017:         }
1:1ee0017:     }
1:1ee0017: 
1:1ee0017:     /**
1:1ee0017:      * @return the maxAuditDepth
1:1ee0017:      */
1:cc6213e:     @Override
1:1ee0017:     public int getMaxAuditDepth() {
1:d8c14e0:         return maxAuditDepth;
1:1ee0017:     }
1:cc6213e: 
1:1ee0017: 
1:1ee0017:     /**
1:1ee0017:      * @param maxAuditDepth the maxAuditDepth to set
1:1ee0017:      */
1:cc6213e:     @Override
1:1ee0017:     public synchronized void setMaxAuditDepth(int maxAuditDepth) {
1:1ee0017:         this.maxAuditDepth = maxAuditDepth;
1:1ee0017:         if (audit != null) {
1:d8c14e0:             audit.setAuditDepth(maxAuditDepth);
1:1ee0017:         }
1:1ee0017:     }
1:cc6213e: 
1:cc6213e: 
1:1ee0017:     /**
1:1ee0017:      * @return the enableAudit
1:1ee0017:      */
1:cc6213e:     @Override
1:1ee0017:     public boolean isEnableAudit() {
1:d8c14e0:         return enableAudit;
1:1ee0017:     }
1:1ee0017: 
1:1ee0017:     /**
1:1ee0017:      * @param enableAudit the enableAudit to set
1:1ee0017:      */
1:cc6213e:     @Override
1:1ee0017:     public synchronized void setEnableAudit(boolean enableAudit) {
1:1ee0017:         this.enableAudit = enableAudit;
1:d8c14e0:         if (enableAudit && started && audit==null) {
1:1ee0017:             audit= new ActiveMQMessageAudit(maxAuditDepth,maxProducersToAudit);
1:1ee0017:         }
1:1ee0017:     }
1:cc6213e: 
1:cc6213e:     @Override
1:36486fe:     public boolean isTransient() {
1:36486fe:         return false;
1:9dd11cb:     }
1:cc6213e: 
1:cc6213e: 
1:9dd11cb:     /**
1:55810b3:      * set the audit
1:d8c14e0:      * @param audit new audit component
1:55810b3:      */
1:cc6213e:     @Override
1:55810b3:     public void setMessageAudit(ActiveMQMessageAudit audit) {
1:55810b3:     	this.audit=audit;
1:55810b3:     }
1:cc6213e: 
1:cc6213e: 
1:55810b3:     /**
1:55810b3:      * @return the audit
1:55810b3:      */
1:cc6213e:     @Override
1:55810b3:     public ActiveMQMessageAudit getMessageAudit() {
1:55810b3:     	return audit;
1:55810b3:     }
1:cc6213e: 
1:cc6213e:     @Override
1:071b4b1:     public boolean isUseCache() {
1:071b4b1:         return useCache;
1:071b4b1:     }
1:071b4b1: 
1:cc6213e:     @Override
1:071b4b1:     public void setUseCache(boolean useCache) {
1:071b4b1:         this.useCache = useCache;
1:071b4b1:     }
1:c8e518b: 
1:c8e518b:     public synchronized boolean isDuplicate(MessageId messageId) {
1:c8e518b:         boolean unique = recordUniqueId(messageId);
1:c8e518b:         rollback(messageId);
1:c8e518b:         return !unique;
1:c8e518b:     }
1:cc6213e: 
1:c8e518b:     /**
1:c8e518b:      * records a message id and checks if it is a duplicate
1:c8e518b:      * @param messageId
1:c8e518b:      * @return true if id is unique, false otherwise.
1:c8e518b:      */
1:c8e518b:     public synchronized boolean recordUniqueId(MessageId messageId) {
1:d8c14e0:         if (!enableAudit || audit==null) {
1:c8e518b:             return true;
1:36486fe:         }
1:c8e518b:         return !audit.isDuplicate(messageId);
1:1ee0017:     }
1:cc6213e: 
1:cc6213e:     @Override
1:47cfa55:     public synchronized void rollback(MessageId id) {
1:d8c14e0:         if (audit != null) {
1:9dd11cb:             audit.rollback(id);
1:9dd11cb:         }
1:9dd11cb:     }
1:cc6213e: 
1:a7533ba:     public synchronized boolean isStarted() {
1:409902c:         return started;
1:409902c:     }
1:cc6213e: 
1:00879cf:     public static boolean isPrioritizedMessageSubscriber(Broker broker,Subscription sub) {
1:00879cf:         boolean result = false;
1:00879cf:         Set<Destination> destinations = broker.getDestinations(sub.getActiveMQDestination());
1:00879cf:         if (destinations != null) {
1:00879cf:             for (Destination dest:destinations) {
1:00879cf:                 if (dest.isPrioritizedMessages()) {
1:00879cf:                     result = true;
1:00879cf:                     break;
1:00879cf:                 }
1:00879cf:             }
1:00879cf:         }
1:00879cf:         return result;
1:00879cf: 
1:00879cf:     }
1:9dd11cb: 
1:cc6213e:     @Override
1:cb96783:     public synchronized boolean isCacheEnabled() {
1:aad7e73:         return cacheEnabled;
1:aad7e73:     }
1:cb96783: 
1:cb96783:     public synchronized void setCacheEnabled(boolean val) {
1:cb96783:         cacheEnabled = val;
1:cb96783:     }
1:cfe099d: 
1:cc6213e:     @Override
1:cfe099d:     public void rebase() {
1:cfe099d:     }
1:1ee0017: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:8d3674b
/////////////////////////////////////////////////////////////////////////
1:     protected boolean started=false;
commit:09bf8f8
/////////////////////////////////////////////////////////////////////////
1:     protected boolean cacheEnabled=true;
commit:25f112c
/////////////////////////////////////////////////////////////////////////
1:         return systemUsage != null ? (!isParentFull() && systemUsage.getMemoryUsage().getPercentUsage() < memoryUsageHighWaterMark) : true;
1:     }
1: 
1:     private boolean isParentFull() {
1:         boolean result = false;
1:         if (systemUsage != null) {
1:             if (systemUsage.getMemoryUsage().getParent() != null) {
1:                 return systemUsage.getMemoryUsage().getParent().getPercentUsage() >= 100;
1:             }
1:         }
1:         return result;
commit:c76f109
/////////////////////////////////////////////////////////////////////////
1:         // allow isFull to verify parent usage and otherwise enforce local memoryUsageHighWaterMark
0:         return systemUsage != null ? (!isFull() && systemUsage.getMemoryUsage().getPercentUsage() < memoryUsageHighWaterMark) : true;
commit:54e2e3b
/////////////////////////////////////////////////////////////////////////
1:     public boolean addMessageLast(MessageReference node) throws Exception {
1:         return true;
0:         return addMessageLast(node);
commit:cfe099d
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void rebase() {
1:     }
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:cc6213e
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:         return tryAddMessageLast(node, INFINITE_WAIT);
1:     @Override
1:     public boolean tryAddMessageLast(MessageReference node, long maxWaitTime) throws Exception {
1:         return true;
1:     }
1: 
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:      *
1:     @Override
1:      *
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1: 
1:     @Override
1: 
1: 
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1: 
1:     @Override
1: 
1: 
1:     @Override
1: 
1: 
1:     @Override
1: 
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:a7533ba
/////////////////////////////////////////////////////////////////////////
1:     public synchronized boolean isStarted() {
commit:5cbb4bf
/////////////////////////////////////////////////////////////////////////
0:         return systemUsage != null ? (!systemUsage.getMemoryUsage().isFull(memoryUsageHighWaterMark)) : true;
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
commit:0bbc0ac
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:ae7de6c
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collections;
1: import java.util.List;
0: import org.apache.activemq.broker.region.QueueMessageReference;
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("unchecked")
1:     public List<MessageReference> remove(ConnectionContext context, Destination destination) throws Exception {
1:         return Collections.EMPTY_LIST;
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
commit:230a86c
/////////////////////////////////////////////////////////////////////////
1:  * Abstract method holder for pending message (messages awaiting disptach to a
1:  * consumer) cursor
0: public class AbstractPendingMessageCursor implements PendingMessageCursor {
0:     protected int maxBatchSize = 100;
/////////////////////////////////////////////////////////////////////////
1:     public void add(ConnectionContext context, Destination destination) throws Exception {
0:     public void remove(ConnectionContext context, Destination destination) throws Exception {
1:     public boolean isRecoveryRequired() {
1:     public void addMessageFirst(MessageReference node) throws Exception {
0:     public void addMessageLast(MessageReference node) throws Exception {
1: 
1:     public void addRecoveredMessage(MessageReference node) throws Exception {
1:     public void clear() {
1:     public boolean hasNext() {
1:     public boolean isEmpty() {
1: 
1:     public MessageReference next() {
1:     public void remove() {
1:     public void reset() {
1:     public int size() {
1:     public int getMaxBatchSize() {
1:     public void setMaxBatchSize(int maxBatchSize) {
1:         this.maxBatchSize = maxBatchSize;
1:     protected void fillBatch() throws Exception {
1:     public void resetForGC() {
1:     public void remove(MessageReference node) {
1:     public void gc() {
1: 
0:     public void setUsageManager(UsageManager usageManager) {
0:         this.usageManager = usageManager;
1:     }
1: 
0:         return usageManager != null ? (usageManager.getPercentUsage() < memoryUsageHighWaterMark) : true;
1: 
1:     public void release() {
1: 
1:     public int getMemoryUsageHighWaterMark() {
1:     public void setMemoryUsageHighWaterMark(int memoryUsageHighWaterMark) {
1:         this.memoryUsageHighWaterMark = memoryUsageHighWaterMark;
0:     public UsageManager getUsageManager() {
1: 
0:      * 
1:      * @throws Exception
1: 
0:      * 
author:Gary Tully
-------------------------------------------------------------------------------
commit:53b29a2
/////////////////////////////////////////////////////////////////////////
commit:cb96783
/////////////////////////////////////////////////////////////////////////
0:     private boolean cacheEnabled=true;
/////////////////////////////////////////////////////////////////////////
1:     public synchronized boolean isCacheEnabled() {
1: 
1:     public synchronized void setCacheEnabled(boolean val) {
1:         cacheEnabled = val;
1:     }
commit:aad7e73
/////////////////////////////////////////////////////////////////////////
0:     protected boolean cacheEnabled=true;
/////////////////////////////////////////////////////////////////////////
1: 
0:     public boolean isCacheEnabled() {
1:         return cacheEnabled;
1:     }
commit:3ddb71c
/////////////////////////////////////////////////////////////////////////
1:     protected int maxProducersToAudit = BaseDestination.MAX_PRODUCERS_TO_AUDIT;
1:     protected int maxAuditDepth = BaseDestination.MAX_AUDIT_DEPTH;
commit:9b260dc
/////////////////////////////////////////////////////////////////////////
1:     protected MessageReference last = null;
commit:c8e518b
/////////////////////////////////////////////////////////////////////////
1:     public synchronized boolean isDuplicate(MessageId messageId) {
1:         boolean unique = recordUniqueId(messageId);
1:         rollback(messageId);
1:         return !unique;
1:     }
1:     
1:     /**
1:      * records a message id and checks if it is a duplicate
1:      * @param messageId
1:      * @return true if id is unique, false otherwise.
1:      */
1:     public synchronized boolean recordUniqueId(MessageId messageId) {
1:             return true;
1:         return !audit.isDuplicate(messageId);
commit:132f662
/////////////////////////////////////////////////////////////////////////
0:     public synchronized boolean  isDuplicate(MessageId messageId) {
author:Robert Davies
-------------------------------------------------------------------------------
commit:00879cf
/////////////////////////////////////////////////////////////////////////
1: import java.util.Set;
1: import org.apache.activemq.broker.Broker;
1: import org.apache.activemq.broker.region.Subscription;
/////////////////////////////////////////////////////////////////////////
1:     protected final boolean prioritizedMessages;
1:     
1:     public AbstractPendingMessageCursor(boolean prioritizedMessages) {
1:         this.prioritizedMessages=prioritizedMessages;
1:     }
/////////////////////////////////////////////////////////////////////////
1:     
1:     public static boolean isPrioritizedMessageSubscriber(Broker broker,Subscription sub) {
1:         boolean result = false;
1:         Set<Destination> destinations = broker.getDestinations(sub.getActiveMQDestination());
1:         if (destinations != null) {
1:             for (Destination dest:destinations) {
1:                 if (dest.isPrioritizedMessages()) {
1:                     result = true;
1:                     break;
1:                 }
1:             }
1:         }
1:         return result;
1: 
1:     }
commit:f42c91f
/////////////////////////////////////////////////////////////////////////
1: public abstract class AbstractPendingMessageCursor implements PendingMessageCursor {
/////////////////////////////////////////////////////////////////////////
1:     
0:     public boolean tryAddMessageLast(MessageReference node, long maxWaitTime) throws Exception {
1:         addMessageLast(node);
0:         return true;
1:     }
commit:d261412
/////////////////////////////////////////////////////////////////////////
1:        
commit:f2fc864
/////////////////////////////////////////////////////////////////////////
1:     protected boolean useCache=true;
commit:47cfa55
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.BaseDestination;
/////////////////////////////////////////////////////////////////////////
1:     protected int maxBatchSize = BaseDestination.MAX_PAGE_SIZE;
/////////////////////////////////////////////////////////////////////////
1:     public synchronized void rollback(MessageId id) {
commit:1f9e67f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected int memoryUsageHighWaterMark = 70;
commit:6d0c552
/////////////////////////////////////////////////////////////////////////
0:     protected int maxAuditDepth=1000;
0:     protected boolean useCache=false;
commit:071b4b1
/////////////////////////////////////////////////////////////////////////
0:     protected boolean useCache=true;
/////////////////////////////////////////////////////////////////////////
1:     
1:     public boolean isUseCache() {
1:         return useCache;
1:     }
1: 
1:     public void setUseCache(boolean useCache) {
1:         this.useCache = useCache;
1:     }
commit:55810b3
/////////////////////////////////////////////////////////////////////////
0:     public void dispatched(MessageReference message) {
0:     	//add it to the audit
0:     	isDuplicate(message.getMessageId());
1:     
1:     /**
1:      * set the audit
0:      * @param audit
1:      */
1:     public void setMessageAudit(ActiveMQMessageAudit audit) {
1:     	this.audit=audit;
1:     }
1:     
1:     
1:     /**
1:      * @return the audit
1:      */
1:     public ActiveMQMessageAudit getMessageAudit() {
1:     	return audit;
1:     }
/////////////////////////////////////////////////////////////////////////
commit:409902c
/////////////////////////////////////////////////////////////////////////
1:   
/////////////////////////////////////////////////////////////////////////
1:     
0:     protected synchronized boolean isStarted() {
1:         return started;
1:     }
commit:9dd11cb
/////////////////////////////////////////////////////////////////////////
0:         audit=null;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
0:      * Mark a message as already dispatched
0:      * @param message
1:      */
0:     public void dispatched(MessageReference message) {   
1:     }
/////////////////////////////////////////////////////////////////////////
1:     
0:     protected synchronized void rollback(MessageId id) {
0:         if (this.audit != null) {
1:             audit.rollback(id);
1:         }
1:     }
1:   
commit:36486fe
/////////////////////////////////////////////////////////////////////////
1:     
1:     public boolean isTransient() {
1:         return false;
1:     }
commit:1ee0017
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.activemq.ActiveMQMessageAudit;
1: import org.apache.activemq.command.MessageId;
/////////////////////////////////////////////////////////////////////////
0:     protected int maxProducersToAudit=1024;
0:     protected int maxAuditDepth=1;
1:     protected boolean enableAudit=true;
1:     protected ActiveMQMessageAudit audit;
0:     private boolean started=false;
1:     public synchronized void start() throws Exception  {
1:         if (!started && enableAudit && audit==null) {
1:             audit= new ActiveMQMessageAudit(maxAuditDepth,maxProducersToAudit);
1:         }
1:         started=true;
1:     public synchronized void stop() throws Exception  {
1:         started=false;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * @return the maxProducersToAudit
1:      */
1:     public int getMaxProducersToAudit() {
1:         return maxProducersToAudit;
1:     }
1: 
1:     /**
1:      * @param maxProducersToAudit the maxProducersToAudit to set
1:      */
1:     public synchronized void setMaxProducersToAudit(int maxProducersToAudit) {
1:         this.maxProducersToAudit = maxProducersToAudit;
1:         if (audit != null) {
0:             this.audit.setMaximumNumberOfProducersToTrack(maxProducersToAudit);
1:         }
1:     }
1: 
1:     /**
1:      * @return the maxAuditDepth
1:      */
1:     public int getMaxAuditDepth() {
0:         return this.maxAuditDepth;
1:     }
1:     
1: 
1:     /**
1:      * @param maxAuditDepth the maxAuditDepth to set
1:      */
1:     public synchronized void setMaxAuditDepth(int maxAuditDepth) {
1:         this.maxAuditDepth = maxAuditDepth;
1:         if (audit != null) {
0:             this.audit.setAuditDepth(maxAuditDepth);
1:         }
1:     }
1:     
1:     
1:     /**
1:      * @return the enableAudit
1:      */
1:     public boolean isEnableAudit() {
0:         return this.enableAudit;
1:     }
1: 
1:     /**
1:      * @param enableAudit the enableAudit to set
1:      */
1:     public synchronized void setEnableAudit(boolean enableAudit) {
1:         this.enableAudit = enableAudit;
0:         if (this.enableAudit && started && audit==null) {
1:             audit= new ActiveMQMessageAudit(maxAuditDepth,maxProducersToAudit);
1:         }
1:     }
1: 
1: 
0:     protected synchronized boolean  isDuplicate(MessageId messageId) {
0:         if (!this.enableAudit || this.audit==null) {
1:             return false;
1:         }
0:         return this.audit.isDuplicate(messageId);
1:     }
1: 
1:    
1:    
commit:6d8e2c5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.SystemUsage;
/////////////////////////////////////////////////////////////////////////
1:     protected SystemUsage systemUsage;
/////////////////////////////////////////////////////////////////////////
1:     public void setSystemUsage(SystemUsage usageManager) {
1:         this.systemUsage = usageManager;
0:         return systemUsage != null ? (systemUsage.getMemoryUsage().getPercentUsage() < memoryUsageHighWaterMark) : true;
1:         return systemUsage != null ? systemUsage.getMemoryUsage().isFull() : false;
/////////////////////////////////////////////////////////////////////////
1:     public SystemUsage getSystemUsage() {
1:         return this.systemUsage;
commit:0c0be94
/////////////////////////////////////////////////////////////////////////
1: import java.util.LinkedList;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * destroy the cursor
0:      * @throws Exception 
1:      */
1:     public void destroy() throws Exception {
1:         stop();
1:     }
1:     
1:     /**
1:      * Page in a restricted number of messages
0:      * @param maxItems
1:      * @return a list of paged in messages
1:      */
0:     public LinkedList pageInList(int maxItems) {
1:         throw new RuntimeException("Not supported");
1:     }
commit:b036d4d
/////////////////////////////////////////////////////////////////////////
0:     protected int memoryUsageHighWaterMark = 90;
0:     public void start() throws Exception {
0:     public void stop() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:         return usageManager != null ? (usageManager.getPercentUsage() < memoryUsageHighWaterMark): true;
/////////////////////////////////////////////////////////////////////////
1: 
1:     
1:     /**
1:      * @return the memoryUsageHighWaterMark
1:      */
0:     public int getMemoryUsageHighWaterMark(){
0:         return this.memoryUsageHighWaterMark;
1:     }
1: 
1:     
1:     /**
1:      * @param memoryUsageHighWaterMark the memoryUsageHighWaterMark to set
1:      */
0:     public void setMemoryUsageHighWaterMark(int memoryUsageHighWaterMark){
0:         this.memoryUsageHighWaterMark=memoryUsageHighWaterMark;
1:     }
1: 
1:     
1:     /**
1:      * @return the usageManager
1:      */
0:     public UsageManager getUsageManager(){
0:         return this.usageManager;
1:     }
commit:e5efc58
/////////////////////////////////////////////////////////////////////////
0:     
1:     public boolean hasMessagesBufferedToDeliver() {
1:         return false;
1:     }
commit:4597ddd
/////////////////////////////////////////////////////////////////////////
0:     
1:     public boolean isEmpty(Destination destination) {
1:         return isEmpty();
1:     }
commit:a110604
/////////////////////////////////////////////////////////////////////////
0:     
0:     public void addRecoveredMessage(MessageReference node) throws Exception{
0:         addMessageLast(node);
1:     }
commit:ec63977
/////////////////////////////////////////////////////////////////////////
0: 
0:     
0:     public void release(){        
1:     }
commit:9359e9f
/////////////////////////////////////////////////////////////////////////
0:     
1:     public boolean isFull() {
0:         return usageManager != null ? usageManager.isFull() : false;
1:     }
commit:3bf0245
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.memory.UsageManager;
/////////////////////////////////////////////////////////////////////////
0:     protected UsageManager usageManager;
1:         gc();
/////////////////////////////////////////////////////////////////////////
0:     
0:     public void gc(){
1:     }
0: 
0:    
0:     public void setUsageManager(UsageManager usageManager){
0:        this.usageManager = usageManager; 
1:     }
0:     
1:     public boolean hasSpace() {
0:         return usageManager != null ? !usageManager.isFull() : true;
1:     }
commit:6895d00
/////////////////////////////////////////////////////////////////////////
0: 
1:     /**
0:      * @param node
0:      * @see org.apache.activemq.broker.region.cursors.PendingMessageCursor#remove(org.apache.activemq.broker.region.MessageReference)
1:      */
0:     public void remove(MessageReference node){
1:     }
commit:3a9299b
/////////////////////////////////////////////////////////////////////////
0:  * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE
0:  * file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file
0:  * to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
0:  * License. You may obtain a copy of the License at
0:  * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
0:  * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
0:  * specific language governing permissions and limitations under the License.
/////////////////////////////////////////////////////////////////////////
0:  * Abstract method holder for pending message (messages awaiting disptach to a consumer) cursor
0: public class AbstractPendingMessageCursor implements PendingMessageCursor{
0: 
0:     protected int maxBatchSize=100;
/////////////////////////////////////////////////////////////////////////
0:     public void add(ConnectionContext context,Destination destination) throws Exception{
0:     public void remove(ConnectionContext context,Destination destination) throws Exception{
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
0:      * Give the cursor a hint that we are about to remove messages from memory only
0:      */
0:     public void resetForGC(){
1:         reset();
1:     }
commit:b6ba20b
/////////////////////////////////////////////////////////////////////////
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
0:  * contributor license agreements. See the NOTICE file distributed with this
0:  * work for additional information regarding copyright ownership. The ASF
0:  * licenses this file to You under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
0:  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
0:  * License for the specific language governing permissions and limitations under
0:  * the License.
0: 
0: import java.io.IOException;
1: import org.apache.activemq.broker.region.MessageReference;
0:  * Abstract method holder for pending message (messages awaiting disptach to a
0:  * consumer) cursor
0: public class AbstractPendingMessageCursor implements PendingMessageCursor {
0:     protected int maxBatchSize = 100;
0: 
0: 
0: 
0:     public void add(ConnectionContext context,Destination destination)
0:             throws Exception{
0:     public void remove(ConnectionContext context,Destination destination)
0:             throws Exception{
0: 
0: 
0:     public void addMessageFirst(MessageReference node) throws Exception{
1:     }
0: 
0:     public void addMessageLast(MessageReference node) throws Exception{
1:     }
0: 
0:     public void clear(){
1:     }
0: 
0:     public boolean hasNext(){
1:         return false;
1:     }
0: 
0:     public boolean isEmpty(){
1:         return false;
1:     }
0: 
0:     public MessageReference next(){
1:         return null;
1:     }
0: 
0:     public void remove(){
1:     }
0: 
0:     public void reset(){
1:     }
0: 
0:     public int size(){
1:         return 0;
1:     }
0:     
0:     public int getMaxBatchSize(){
1:         return maxBatchSize;
1:     }
0: 
0:     public void setMaxBatchSize(int maxBatchSize){
0:         this.maxBatchSize=maxBatchSize;
1:     }
0: 
0:     protected void fillBatch() throws Exception{
1:     }
0:     
0:     
commit:4eef609
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * 
0:  * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE
0:  * file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file
0:  * to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
0:  * License. You may obtain a copy of the License at
0:  * 
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  * 
0:  * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
0:  * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
0:  * specific language governing permissions and limitations under the License.
0:  */
1: package org.apache.activemq.broker.region.cursors;
0: 
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.broker.region.Destination;
0: 
0: 
0: /**
0:  * Default method holder for pending message (messages awaiting disptach to a consumer) cursor
0:  * 
0:  * @version $Revision$
0:  */
0: public abstract class AbstractPendingMessageCursor implements  PendingMessageCursor{
0:     
0:     public void start() throws Exception{
1:     }
0:     
0:     public void stop() throws Exception{
1:     }
0:     
0:     public void add(ConnectionContext context, Destination destination) throws Exception{
1:     }
0: 
0:     public void remove(ConnectionContext context, Destination destination) throws Exception{
1:     }
0:     
0:     
0:     public boolean isRecoveryRequired(){
0:         return true;
1:     }
1: }
author:David Jencks
-------------------------------------------------------------------------------
commit:d8c14e0
/////////////////////////////////////////////////////////////////////////
1:         return memoryUsageHighWaterMark;
/////////////////////////////////////////////////////////////////////////
1:      * @param maxItems maximum number of messages to return
1:     public LinkedList<MessageReference> pageInList(int maxItems) {
/////////////////////////////////////////////////////////////////////////
1:             audit.setMaximumNumberOfProducersToTrack(maxProducersToAudit);
/////////////////////////////////////////////////////////////////////////
1:         return maxAuditDepth;
/////////////////////////////////////////////////////////////////////////
1:             audit.setAuditDepth(maxAuditDepth);
/////////////////////////////////////////////////////////////////////////
1:         return enableAudit;
/////////////////////////////////////////////////////////////////////////
1:         if (enableAudit && started && audit==null) {
/////////////////////////////////////////////////////////////////////////
1:      * @param audit new audit component
/////////////////////////////////////////////////////////////////////////
1:         if (!enableAudit || audit==null) {
0:         return audit.isDuplicate(messageId);
1:         if (audit != null) {
============================================================================