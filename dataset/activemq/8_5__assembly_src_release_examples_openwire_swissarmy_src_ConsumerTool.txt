1:40a7d3b: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
3:92a698f:  *
1:5f1adbe:  *      http://www.apache.org/licenses/LICENSE-2.0
1:92a698f:  *
1:40a7d3b:  * Unless required by applicable law or agreed to in writing, software
1:92a698f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:92a698f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:92a698f:  * See the License for the specific language governing permissions and
1:92a698f:  * limitations under the License.
1:92a698f:  */
1:d320676: 
1:540dd5c: import java.io.IOException;
1:540dd5c: import java.util.Arrays;
1:1eb339f: import java.util.ArrayList;
1:1eb339f: import java.util.Iterator;
1:540dd5c: 
1:40a7d3b: import javax.jms.Connection;
1:d320676: import javax.jms.DeliveryMode;
1:148f3bd: import javax.jms.Destination;
1:40a7d3b: import javax.jms.ExceptionListener;
1:40a7d3b: import javax.jms.JMSException;
1:40a7d3b: import javax.jms.Message;
1:40a7d3b: import javax.jms.MessageConsumer;
1:40a7d3b: import javax.jms.MessageListener;
1:d320676: import javax.jms.MessageProducer;
1:40a7d3b: import javax.jms.Session;
1:40a7d3b: import javax.jms.TextMessage;
1:40a7d3b: import javax.jms.Topic;
1:d320676: 
1:148f3bd: import org.apache.activemq.ActiveMQConnection;
1:148f3bd: import org.apache.activemq.ActiveMQConnectionFactory;
1:148f3bd: 
1:40a7d3b: /**
1:40a7d3b:  * A simple tool for consuming messages
1:b0c2a40:  * 
1:148f3bd:  * 
2:40a7d3b:  */
1:1eb339f: public class ConsumerTool extends Thread implements MessageListener, ExceptionListener {
1:da26ccb: 
1:540dd5c:     private boolean running;
1:148f3bd: 
1:540dd5c:     private Session session;
1:540dd5c:     private Destination destination;
1:540dd5c:     private MessageProducer replyProducer;
1:148f3bd: 
1:1eb339f:     private boolean pauseBeforeShutdown = false;
1:540dd5c:     private boolean verbose = true;
1:540dd5c:     private int maxiumMessages;
1:1eb339f:     private static int parallelThreads = 1;
1:540dd5c:     private String subject = "TOOL.DEFAULT";
1:540dd5c:     private boolean topic;
1:540dd5c:     private String user = ActiveMQConnection.DEFAULT_USER;
1:540dd5c:     private String password = ActiveMQConnection.DEFAULT_PASSWORD;
1:540dd5c:     private String url = ActiveMQConnection.DEFAULT_BROKER_URL;
1:540dd5c:     private boolean transacted;
1:540dd5c:     private boolean durable;
1:540dd5c:     private String clientId;
1:540dd5c:     private int ackMode = Session.AUTO_ACKNOWLEDGE;
1:540dd5c:     private String consumerName = "James";
1:540dd5c:     private long sleepTime;
1:540dd5c:     private long receiveTimeOut;
1:37bbad0: 	private long batch = 10; // Default batch size for CLIENT_ACKNOWLEDGEMENT or SESSION_TRANSACTED
1:37bbad0: 	private long messagesReceived = 0;
1:d320676: 
1:540dd5c:     public static void main(String[] args) {
1:1eb339f:         ArrayList<ConsumerTool> threads = new ArrayList();
1:540dd5c:         ConsumerTool consumerTool = new ConsumerTool();
1:540dd5c:         String[] unknown = CommandLineSupport.setOptions(consumerTool, args);
1:540dd5c:         if (unknown.length > 0) {
1:540dd5c:             System.out.println("Unknown options: " + Arrays.toString(unknown));
1:540dd5c:             System.exit(-1);
1:540dd5c:         }
1:1eb339f:         consumerTool.showParameters();
1:1eb339f:         for (int threadCount = 1; threadCount <= parallelThreads; threadCount++) {
1:1eb339f:             consumerTool = new ConsumerTool();
1:1eb339f:             CommandLineSupport.setOptions(consumerTool, args);
1:1eb339f:             consumerTool.start();
1:1eb339f:             threads.add(consumerTool);
1:540dd5c:         }
1:d320676: 
1:1eb339f:         while (true) {
1:1eb339f:             Iterator<ConsumerTool> itr = threads.iterator();
1:1eb339f:             int running = 0;
1:1eb339f:             while (itr.hasNext()) {
1:1eb339f:                 ConsumerTool thread = itr.next();
1:1eb339f:                 if (thread.isAlive()) {
1:1eb339f:                     running++;
39:148f3bd:                 }
1:148f3bd:             }
1:d320676: 
1:1eb339f:             if (running <= 0) {
1:1eb339f:                 System.out.println("All threads completed their work");
1:1eb339f:                 break;
1:148f3bd:             }
1:da26ccb: 
1:540dd5c:             try {
1:1eb339f:                 Thread.sleep(1000);
1:148f3bd:             } catch (Exception e) {
1:148f3bd:             }
1:148f3bd:         }
1:1eb339f:         Iterator<ConsumerTool> itr = threads.iterator();
1:1eb339f:         while (itr.hasNext()) {
1:1eb339f:             ConsumerTool thread = itr.next();
1:148f3bd:         }
1:148f3bd:     }
1:da26ccb: 
1:1eb339f:     public void showParameters() {
1:da0b3b5:         System.out.println("Connecting to URL: " + url + " (" + user + ":" + password + ")");
1:540dd5c:         System.out.println("Consuming " + (topic ? "topic" : "queue") + ": " + subject);
1:540dd5c:         System.out.println("Using a " + (durable ? "durable" : "non-durable") + " subscription");
1:1eb339f:         System.out.println("Running " + parallelThreads + " parallel threads");
1:148f3bd:     }
1:da26ccb: 
1:540dd5c:     public void run() {
3:148f3bd:         try {
1:540dd5c:             running = true;
1:148f3bd: 
1:540dd5c:             ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(user, password, url);
1:540dd5c:             Connection connection = connectionFactory.createConnection();
1:540dd5c:             if (durable && clientId != null && clientId.length() > 0 && !"null".equals(clientId)) {
1:540dd5c:                 connection.setClientID(clientId);
1:540dd5c:             }
1:540dd5c:             connection.setExceptionListener(this);
1:540dd5c:             connection.start();
1:148f3bd: 
1:540dd5c:             session = connection.createSession(transacted, ackMode);
1:540dd5c:             if (topic) {
1:540dd5c:                 destination = session.createTopic(subject);
1:540dd5c:             } else {
1:540dd5c:                 destination = session.createQueue(subject);
1:540dd5c:             }
1:148f3bd: 
1:540dd5c:             replyProducer = session.createProducer(null);
1:540dd5c:             replyProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:148f3bd: 
1:540dd5c:             MessageConsumer consumer = null;
1:540dd5c:             if (durable && topic) {
1:148f3bd:                 consumer = session.createDurableSubscriber((Topic) destination, consumerName);
1:540dd5c:             } else {
1:540dd5c:                 consumer = session.createConsumer(destination);
1:540dd5c:             }
1:148f3bd: 
1:540dd5c:             if (maxiumMessages > 0) {
1:540dd5c:                 consumeMessagesAndClose(connection, session, consumer);
1:540dd5c:             } else {
1:540dd5c:                 if (receiveTimeOut == 0) {
1:540dd5c:                     consumer.setMessageListener(this);
1:540dd5c:                 } else {
1:540dd5c:                     consumeMessagesAndClose(connection, session, consumer, receiveTimeOut);
1:540dd5c:                 }
1:540dd5c:             }
1:148f3bd: 
1:540dd5c:         } catch (Exception e) {
1:1eb339f:             System.out.println("[" + this.getName() + "] Caught: " + e);
1:540dd5c:             e.printStackTrace();
1:540dd5c:         }
1:540dd5c:     }
1:148f3bd: 
1:540dd5c:     public void onMessage(Message message) {
1:37bbad0: 
1:37bbad0: 		messagesReceived++;
1:37bbad0: 
1:540dd5c:         try {
1:148f3bd: 
1:540dd5c:             if (message instanceof TextMessage) {
1:148f3bd:                 TextMessage txtMsg = (TextMessage) message;
1:540dd5c:                 if (verbose) {
1:148f3bd: 
1:540dd5c:                     String msg = txtMsg.getText();
1:1eb339f:                     int length = msg.length();
1:1eb339f:                     if (length > 50) {
1:540dd5c:                         msg = msg.substring(0, 50) + "...";
1:540dd5c:                     }
1:1eb339f:                     System.out.println("[" + this.getName() + "] Received: '" + msg + "' (length " + length + ")");
1:540dd5c:                 }
1:540dd5c:             } else {
1:540dd5c:                 if (verbose) {
1:1eb339f:                     System.out.println("[" + this.getName() + "] Received: '" + message + "'");
1:540dd5c:                 }
1:540dd5c:             }
1:148f3bd: 
1:540dd5c:             if (message.getJMSReplyTo() != null) {
1:540dd5c:                 replyProducer.send(message.getJMSReplyTo(), session.createTextMessage("Reply: " + message.getJMSMessageID()));
1:540dd5c:             }
1:148f3bd: 
1:540dd5c:             if (transacted) {
1:37bbad0: 				if ((messagesReceived % batch) == 0) {
1:37bbad0: 					System.out.println("Commiting transaction for last " + batch + " messages; messages so far = " + messagesReceived);
1:37bbad0: 					session.commit();
1:37bbad0: 				}
1:540dd5c:             } else if (ackMode == Session.CLIENT_ACKNOWLEDGE) {
1:37bbad0: 				if ((messagesReceived % batch) == 0) {
1:37bbad0: 					System.out.println("Acknowledging last " + batch + " messages; messages so far = " + messagesReceived);
1:37bbad0: 					message.acknowledge();
1:37bbad0: 				}
1:540dd5c:             }
1:148f3bd: 
1:540dd5c:         } catch (JMSException e) {
1:1eb339f:             System.out.println("[" + this.getName() + "] Caught: " + e);
1:540dd5c:             e.printStackTrace();
1:540dd5c:         } finally {
1:540dd5c:             if (sleepTime > 0) {
1:540dd5c:                 try {
1:540dd5c:                     Thread.sleep(sleepTime);
1:540dd5c:                 } catch (InterruptedException e) {
1:540dd5c:                 }
1:540dd5c:             }
1:540dd5c:         }
1:540dd5c:     }
1:148f3bd: 
1:540dd5c:     public synchronized void onException(JMSException ex) {
1:1eb339f:         System.out.println("[" + this.getName() + "] JMS Exception occured.  Shutting down client.");
1:540dd5c:         running = false;
1:540dd5c:     }
1:148f3bd: 
1:540dd5c:     synchronized boolean isRunning() {
1:540dd5c:         return running;
1:540dd5c:     }
1:540dd5c: 
1:148f3bd:     protected void consumeMessagesAndClose(Connection connection, Session session, MessageConsumer consumer) throws JMSException,
1:148f3bd:             IOException {
1:1eb339f:         System.out.println("[" + this.getName() + "] We are about to wait until we consume: " + maxiumMessages
1:1eb339f:                 + " message(s) then we will shutdown");
1:540dd5c: 
1:540dd5c:         for (int i = 0; i < maxiumMessages && isRunning();) {
1:540dd5c:             Message message = consumer.receive(1000);
1:540dd5c:             if (message != null) {
1:540dd5c:                 i++;
1:540dd5c:                 onMessage(message);
1:540dd5c:             }
1:540dd5c:         }
1:1eb339f:         System.out.println("[" + this.getName() + "] Closing connection");
1:540dd5c:         consumer.close();
1:540dd5c:         session.close();
1:540dd5c:         connection.close();
1:540dd5c:         if (pauseBeforeShutdown) {
1:1eb339f:             System.out.println("[" + this.getName() + "] Press return to shut down");
1:540dd5c:             System.in.read();
1:540dd5c:         }
1:540dd5c:     }
1:540dd5c: 
1:148f3bd:     protected void consumeMessagesAndClose(Connection connection, Session session, MessageConsumer consumer, long timeout)
1:148f3bd:             throws JMSException, IOException {
1:1eb339f:         System.out.println("[" + this.getName() + "] We will consume messages while they continue to be delivered within: " + timeout
1:148f3bd:                 + " ms, and then we will shutdown");
1:540dd5c: 
1:540dd5c:         Message message;
1:540dd5c:         while ((message = consumer.receive(timeout)) != null) {
1:540dd5c:             onMessage(message);
1:540dd5c:         }
1:540dd5c: 
1:1eb339f:         System.out.println("[" + this.getName() + "] Closing connection");
1:540dd5c:         consumer.close();
1:540dd5c:         session.close();
1:540dd5c:         connection.close();
1:540dd5c:         if (pauseBeforeShutdown) {
1:1eb339f:             System.out.println("[" + this.getName() + "] Press return to shut down");
1:540dd5c:             System.in.read();
1:540dd5c:         }
1:540dd5c:     }
1:540dd5c: 
1:540dd5c:     public void setAckMode(String ackMode) {
1:540dd5c:         if ("CLIENT_ACKNOWLEDGE".equals(ackMode)) {
1:540dd5c:             this.ackMode = Session.CLIENT_ACKNOWLEDGE;
1:540dd5c:         }
1:540dd5c:         if ("AUTO_ACKNOWLEDGE".equals(ackMode)) {
1:540dd5c:             this.ackMode = Session.AUTO_ACKNOWLEDGE;
1:540dd5c:         }
1:540dd5c:         if ("DUPS_OK_ACKNOWLEDGE".equals(ackMode)) {
1:540dd5c:             this.ackMode = Session.DUPS_OK_ACKNOWLEDGE;
1:540dd5c:         }
1:540dd5c:         if ("SESSION_TRANSACTED".equals(ackMode)) {
1:540dd5c:             this.ackMode = Session.SESSION_TRANSACTED;
1:540dd5c:         }
1:540dd5c:     }
1:540dd5c: 
1:540dd5c:     public void setClientId(String clientID) {
1:540dd5c:         this.clientId = clientID;
1:540dd5c:     }
1:540dd5c: 
1:540dd5c:     public void setConsumerName(String consumerName) {
1:540dd5c:         this.consumerName = consumerName;
1:540dd5c:     }
1:540dd5c: 
1:540dd5c:     public void setDurable(boolean durable) {
1:540dd5c:         this.durable = durable;
1:540dd5c:     }
1:540dd5c: 
1:540dd5c:     public void setMaxiumMessages(int maxiumMessages) {
1:540dd5c:         this.maxiumMessages = maxiumMessages;
1:540dd5c:     }
1:540dd5c: 
1:540dd5c:     public void setPauseBeforeShutdown(boolean pauseBeforeShutdown) {
1:540dd5c:         this.pauseBeforeShutdown = pauseBeforeShutdown;
1:540dd5c:     }
1:540dd5c: 
1:540dd5c:     public void setPassword(String pwd) {
1:540dd5c:         this.password = pwd;
1:540dd5c:     }
1:540dd5c: 
1:540dd5c:     public void setReceiveTimeOut(long receiveTimeOut) {
1:540dd5c:         this.receiveTimeOut = receiveTimeOut;
1:540dd5c:     }
1:540dd5c: 
1:540dd5c:     public void setSleepTime(long sleepTime) {
1:540dd5c:         this.sleepTime = sleepTime;
1:540dd5c:     }
1:540dd5c: 
1:540dd5c:     public void setSubject(String subject) {
1:540dd5c:         this.subject = subject;
1:540dd5c:     }
1:540dd5c: 
1:1eb339f:     public void setParallelThreads(int parallelThreads) {
1:1eb339f:         if (parallelThreads < 1) {
1:1eb339f:             parallelThreads = 1;
1:148f3bd:         }
1:1eb339f:         this.parallelThreads = parallelThreads;
1:148f3bd:     }
1:148f3bd: 
1:540dd5c:     public void setTopic(boolean topic) {
1:540dd5c:         this.topic = topic;
1:540dd5c:     }
1:540dd5c: 
1:540dd5c:     public void setQueue(boolean queue) {
1:540dd5c:         this.topic = !queue;
1:540dd5c:     }
1:540dd5c: 
1:540dd5c:     public void setTransacted(boolean transacted) {
1:540dd5c:         this.transacted = transacted;
1:540dd5c:     }
1:540dd5c: 
1:540dd5c:     public void setUrl(String url) {
1:540dd5c:         this.url = url;
1:540dd5c:     }
1:540dd5c: 
1:540dd5c:     public void setUser(String user) {
1:540dd5c:         this.user = user;
1:540dd5c:     }
1:540dd5c: 
1:540dd5c:     public void setVerbose(boolean verbose) {
1:540dd5c:         this.verbose = verbose;
1:540dd5c:     }
1:37bbad0: 
1:37bbad0:     public void setBatch(long batch) {
1:37bbad0:         this.batch = batch;
1:37bbad0:     }
1:86cbdfd: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Hiram Chirino
-------------------------------------------------------------------------------
commit:2ecf41d
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:da0b3b5
/////////////////////////////////////////////////////////////////////////
1:         System.out.println("Connecting to URL: " + url + " (" + user + ":" + password + ")");
commit:37bbad0
/////////////////////////////////////////////////////////////////////////
1: 	private long batch = 10; // Default batch size for CLIENT_ACKNOWLEDGEMENT or SESSION_TRANSACTED
1: 	private long messagesReceived = 0;
/////////////////////////////////////////////////////////////////////////
1: 
1: 		messagesReceived++;
1: 
/////////////////////////////////////////////////////////////////////////
1: 				if ((messagesReceived % batch) == 0) {
1: 					System.out.println("Commiting transaction for last " + batch + " messages; messages so far = " + messagesReceived);
1: 					session.commit();
1: 				}
1: 				if ((messagesReceived % batch) == 0) {
1: 					System.out.println("Acknowledging last " + batch + " messages; messages so far = " + messagesReceived);
1: 					message.acknowledge();
1: 				}
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void setBatch(long batch) {
1:         this.batch = batch;
1:     }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:540dd5c
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.util.Arrays;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private boolean running;
1:     private Session session;
1:     private Destination destination;
1:     private MessageProducer replyProducer;
0:     private boolean pauseBeforeShutdown;
1:     private boolean verbose = true;
1:     private int maxiumMessages;
1:     private String subject = "TOOL.DEFAULT";
1:     private boolean topic;
1:     private String user = ActiveMQConnection.DEFAULT_USER;
1:     private String password = ActiveMQConnection.DEFAULT_PASSWORD;
1:     private String url = ActiveMQConnection.DEFAULT_BROKER_URL;
1:     private boolean transacted;
1:     private boolean durable;
1:     private String clientId;
1:     private int ackMode = Session.AUTO_ACKNOWLEDGE;
1:     private String consumerName = "James";
1:     private long sleepTime;
1:     private long receiveTimeOut;
1:     public static void main(String[] args) {
1:         ConsumerTool consumerTool = new ConsumerTool();
1:         String[] unknown = CommandLineSupport.setOptions(consumerTool, args);
1:         if (unknown.length > 0) {
1:             System.out.println("Unknown options: " + Arrays.toString(unknown));
1:             System.exit(-1);
1:         }
0:         consumerTool.run();
1:     }
1:     public void run() {
1:         try {
1:             running = true;
0:             System.out.println("Connecting to URL: " + url);
1:             System.out.println("Consuming " + (topic ? "topic" : "queue") + ": " + subject);
1:             System.out.println("Using a " + (durable ? "durable" : "non-durable") + " subscription");
1:             ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(user, password, url);
1:             Connection connection = connectionFactory.createConnection();
1:             if (durable && clientId != null && clientId.length() > 0 && !"null".equals(clientId)) {
1:                 connection.setClientID(clientId);
1:             }
1:             connection.setExceptionListener(this);
1:             connection.start();
1:             session = connection.createSession(transacted, ackMode);
1:             if (topic) {
1:                 destination = session.createTopic(subject);
1:             } else {
1:                 destination = session.createQueue(subject);
1:             }
1:             replyProducer = session.createProducer(null);
1:             replyProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:             MessageConsumer consumer = null;
1:             if (durable && topic) {
0:                 consumer = session.createDurableSubscriber((Topic)destination, consumerName);
1:             } else {
1:                 consumer = session.createConsumer(destination);
1:             }
1:             if (maxiumMessages > 0) {
1:                 consumeMessagesAndClose(connection, session, consumer);
1:             } else {
1:                 if (receiveTimeOut == 0) {
1:                     consumer.setMessageListener(this);
1:                 } else {
1:                     consumeMessagesAndClose(connection, session, consumer, receiveTimeOut);
1:                 }
1:             }
1:         } catch (Exception e) {
0:             System.out.println("Caught: " + e);
1:             e.printStackTrace();
1:         }
1:     }
1:     public void onMessage(Message message) {
1:         try {
1:             if (message instanceof TextMessage) {
0:                 TextMessage txtMsg = (TextMessage)message;
1:                 if (verbose) {
1:                     String msg = txtMsg.getText();
0:                     if (msg.length() > 50) {
1:                         msg = msg.substring(0, 50) + "...";
1:                     }
0:                     System.out.println("Received: " + msg);
1:                 }
1:             } else {
1:                 if (verbose) {
0:                     System.out.println("Received: " + message);
1:                 }
1:             }
1:             if (message.getJMSReplyTo() != null) {
1:                 replyProducer.send(message.getJMSReplyTo(), session.createTextMessage("Reply: " + message.getJMSMessageID()));
1:             }
1:             if (transacted) {
0:                 session.commit();
1:             } else if (ackMode == Session.CLIENT_ACKNOWLEDGE) {
0:                 message.acknowledge();
1:             }
1:         } catch (JMSException e) {
0:             System.out.println("Caught: " + e);
1:             e.printStackTrace();
1:         } finally {
1:             if (sleepTime > 0) {
1:                 try {
1:                     Thread.sleep(sleepTime);
1:                 } catch (InterruptedException e) {
1:                 }
1:             }
1:         }
1:     }
1:     public synchronized void onException(JMSException ex) {
0:         System.out.println("JMS Exception occured.  Shutting down client.");
1:         running = false;
1:     }
1:     synchronized boolean isRunning() {
1:         return running;
1:     }
1: 
0:     protected void consumeMessagesAndClose(Connection connection, Session session, MessageConsumer consumer) throws JMSException, IOException {
0:         System.out.println("We are about to wait until we consume: " + maxiumMessages + " message(s) then we will shutdown");
1: 
1:         for (int i = 0; i < maxiumMessages && isRunning();) {
1:             Message message = consumer.receive(1000);
1:             if (message != null) {
1:                 i++;
1:                 onMessage(message);
1:             }
1:         }
0:         System.out.println("Closing connection");
1:         consumer.close();
1:         session.close();
1:         connection.close();
1:         if (pauseBeforeShutdown) {
0:             System.out.println("Press return to shut down");
1:             System.in.read();
1:         }
1:     }
1: 
0:     protected void consumeMessagesAndClose(Connection connection, Session session, MessageConsumer consumer, long timeout) throws JMSException, IOException {
0:         System.out.println("We will consume messages while they continue to be delivered within: " + timeout + " ms, and then we will shutdown");
1: 
1:         Message message;
1:         while ((message = consumer.receive(timeout)) != null) {
1:             onMessage(message);
1:         }
1: 
0:         System.out.println("Closing connection");
1:         consumer.close();
1:         session.close();
1:         connection.close();
1:         if (pauseBeforeShutdown) {
0:             System.out.println("Press return to shut down");
1:             System.in.read();
1:         }
1:     }
1: 
1:     public void setAckMode(String ackMode) {
1:         if ("CLIENT_ACKNOWLEDGE".equals(ackMode)) {
1:             this.ackMode = Session.CLIENT_ACKNOWLEDGE;
1:         }
1:         if ("AUTO_ACKNOWLEDGE".equals(ackMode)) {
1:             this.ackMode = Session.AUTO_ACKNOWLEDGE;
1:         }
1:         if ("DUPS_OK_ACKNOWLEDGE".equals(ackMode)) {
1:             this.ackMode = Session.DUPS_OK_ACKNOWLEDGE;
1:         }
1:         if ("SESSION_TRANSACTED".equals(ackMode)) {
1:             this.ackMode = Session.SESSION_TRANSACTED;
1:         }
1:     }
1: 
1:     public void setClientId(String clientID) {
1:         this.clientId = clientID;
1:     }
1: 
1:     public void setConsumerName(String consumerName) {
1:         this.consumerName = consumerName;
1:     }
1: 
1:     public void setDurable(boolean durable) {
1:         this.durable = durable;
1:     }
1: 
1:     public void setMaxiumMessages(int maxiumMessages) {
1:         this.maxiumMessages = maxiumMessages;
1:     }
1: 
1:     public void setPauseBeforeShutdown(boolean pauseBeforeShutdown) {
1:         this.pauseBeforeShutdown = pauseBeforeShutdown;
1:     }
1: 
1:     public void setPassword(String pwd) {
1:         this.password = pwd;
1:     }
1: 
1:     public void setReceiveTimeOut(long receiveTimeOut) {
1:         this.receiveTimeOut = receiveTimeOut;
1:     }
1: 
1:     public void setSleepTime(long sleepTime) {
1:         this.sleepTime = sleepTime;
1:     }
1: 
1:     public void setSubject(String subject) {
1:         this.subject = subject;
1:     }
1: 
1:     public void setTopic(boolean topic) {
1:         this.topic = topic;
1:     }
1: 
1:     public void setQueue(boolean queue) {
1:         this.topic = !queue;
1:     }
1: 
1:     public void setTransacted(boolean transacted) {
1:         this.transacted = transacted;
1:     }
1: 
1:     public void setUrl(String url) {
1:         this.url = url;
1:     }
1: 
1:     public void setUser(String user) {
1:         this.user = user;
1:     }
1: 
1:     public void setVerbose(boolean verbose) {
1:         this.verbose = verbose;
1:     }
commit:5f1adbe
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
1: }
commit:148f3bd
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.Destination;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: 
0: import java.util.Arrays;
1:  * 
0: public class ConsumerTool implements MessageListener, ExceptionListener {
0: 	private boolean running;
1: 	
0: 	private Session session;
0: 	private Destination destination;
1: 	
0: 	private boolean pauseBeforeShutdown;
0: 	private boolean verbose = true;
0: 	private int maxiumMessages = 0;
0: 	private String subject = "TOOL.DEFAULT";
0: 	private boolean topic = false;
0: 	private String user = ActiveMQConnection.DEFAULT_USER;
0: 	private String password = ActiveMQConnection.DEFAULT_PASSWORD;
0: 	private String url = ActiveMQConnection.DEFAULT_BROKER_URL;
0: 	private boolean transacted = false;
0: 	private boolean durable = false;
0: 	private String clientId;
0: 	private int ackMode = Session.AUTO_ACKNOWLEDGE;
0: 	private String consumerName = "James";
0: 	private long sleepTime = 0;
0: 	private long receiveTimeOut = 0;
0: 	public static void main(String[] args) {
0: 		ConsumerTool consumerTool = new ConsumerTool();
0: 		String[] unknonwn = CommnadLineSupport.setOptions(consumerTool, args);
0: 		if (unknonwn.length > 0) {
0: 			System.out.println("Unknown options: " + Arrays.toString(unknonwn));
0: 			System.exit(-1);
1: 		}
0: 		consumerTool.run();
1: 	}
0: 	public void run() {
1: 		try {
0: 			running = true;
0: 			System.out.println("Connecting to URL: " + url);
0: 			System.out.println("Consuming " + (topic ? "topic" : "queue") + ": " + subject);
0: 			System.out.println("Using a " + (durable ? "durable" : "non-durable") + " subscription");
0: 			ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(user, password, url);
0: 			Connection connection = connectionFactory.createConnection();
0: 			if (durable && clientId != null && clientId.length()>0 && !"null".equals(clientId) ) {
0: 				connection.setClientID(clientId);
1: 			}
0: 			connection.setExceptionListener(this);
0: 			connection.start();
0: 			Session session = connection.createSession(transacted, ackMode);
0: 			if (topic) {
0: 				destination = session.createTopic(subject);
0: 			} else {
0: 				destination = session.createQueue(subject);
1: 			}
0: 			replyProducer = session.createProducer(null);
0: 			replyProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
0: 			MessageConsumer consumer = null;
0: 			if (durable && topic) {
1: 				consumer = session.createDurableSubscriber((Topic) destination, consumerName);
0: 			} else {
0: 				consumer = session.createConsumer(destination);
1: 			}
1: 			
0: 			if (maxiumMessages > 0) {
0: 				consumeMessagesAndClose(connection, session, consumer);
0: 			} else {
0: 				if (receiveTimeOut == 0) {
0: 					consumer.setMessageListener(this);
0: 				} else {
0: 					consumeMessagesAndClose(connection, session, consumer, receiveTimeOut);
1: 				}
1: 			}
1: 			
1: 		} catch (Exception e) {
0: 			System.out.println("Caught: " + e);
0: 			e.printStackTrace();
1: 		}
1: 	}
0: 	public void onMessage(Message message) {
1: 		try {
1: 			
0: 			if (message instanceof TextMessage) {
1: 				TextMessage txtMsg = (TextMessage) message;
0: 				if (verbose) {
0: 					String msg = txtMsg.getText();
0: 					if (msg.length() > 50) {
0: 						msg = msg.substring(0, 50) + "...";
1: 					}
0: 					System.out.println("Received: " + msg);
1: 				}
0: 			} else {
0: 				if (verbose) {
0: 					System.out.println("Received: " + message);
1: 				}
1: 			}
1: 
0: 			if (message.getJMSReplyTo() != null) {
0: 				replyProducer.send(message.getJMSReplyTo(), session.createTextMessage("Reply: " + message.getJMSMessageID()));
1: 			}
1: 			
0: 			if (transacted) {
0: 				session.commit();
0: 			} else if ( ackMode  == Session.CLIENT_ACKNOWLEDGE ) {
0: 				message.acknowledge();
1: 			}
1: 
0: 		} catch (JMSException e) {
0: 			System.out.println("Caught: " + e);
0: 			e.printStackTrace();
0: 		} finally {
0: 			if (sleepTime > 0) {
1: 				try {
0: 					Thread.sleep(sleepTime);
0: 				} catch (InterruptedException e) {
1: 				}
1: 			}
1: 		}
1: 	}
1: 
0: 	synchronized public void onException(JMSException ex) {
0: 		System.out.println("JMS Exception occured.  Shutting down client.");
0: 		running = false;
1: 	}
1: 
0: 	synchronized boolean isRunning() {
0: 		return running;
1: 	}
1: 
1: 	protected void consumeMessagesAndClose(Connection connection, Session session, MessageConsumer consumer) throws JMSException,
1: 			IOException {
0: 		System.out.println("We are about to wait until we consume: " + maxiumMessages + " message(s) then we will shutdown");
1: 
0: 		for (int i = 0; i < maxiumMessages && isRunning();) {
0: 			Message message = consumer.receive(1000);
0: 			if (message != null) {
0: 				i++;
0: 				onMessage(message);
1: 			}
1: 		}
0: 		System.out.println("Closing connection");
0: 		consumer.close();
0: 		session.close();
0: 		connection.close();
0: 		if (pauseBeforeShutdown) {
0: 			System.out.println("Press return to shut down");
0: 			System.in.read();
1: 		}
1: 	}
1: 
1: 	protected void consumeMessagesAndClose(Connection connection, Session session, MessageConsumer consumer, long timeout)
1: 			throws JMSException, IOException {
0: 		System.out.println("We will consume messages while they continue to be delivered within: " + timeout
1: 				+ " ms, and then we will shutdown");
1: 
0: 		Message message;
0: 		while ((message = consumer.receive(timeout)) != null) {
0: 			onMessage(message);
1: 		}
1: 
0: 		System.out.println("Closing connection");
0: 		consumer.close();
0: 		session.close();
0: 		connection.close();
0: 		if (pauseBeforeShutdown) {
0: 			System.out.println("Press return to shut down");
0: 			System.in.read();
1: 		}
1: 	}
1: 
0: 	public void setAckMode(String ackMode) {
0: 		if( "CLIENT_ACKNOWLEDGE".equals(ackMode) ) {
0: 			this.ackMode = Session.CLIENT_ACKNOWLEDGE;
1: 		}
0: 		if( "AUTO_ACKNOWLEDGE".equals(ackMode) ) {
0: 			this.ackMode = Session.AUTO_ACKNOWLEDGE;
1: 		}
0: 		if( "DUPS_OK_ACKNOWLEDGE".equals(ackMode) ) {
0: 			this.ackMode = Session.DUPS_OK_ACKNOWLEDGE;
1: 		}
0: 		if( "SESSION_TRANSACTED".equals(ackMode) ) {
0: 			this.ackMode = Session.SESSION_TRANSACTED;
1: 		}
1: 	}
1: 	
0: 	public void setClientId(String clientID) {
0: 		this.clientId = clientID;
1: 	}
0: 	public void setConsumerName(String consumerName) {
0: 		this.consumerName = consumerName;
1: 	}
0: 	public void setDurable(boolean durable) {
0: 		this.durable = durable;
1: 	}
0: 	public void setMaxiumMessages(int maxiumMessages) {
0: 		this.maxiumMessages = maxiumMessages;
1: 	}
0: 	public void setPauseBeforeShutdown(boolean pauseBeforeShutdown) {
0: 		this.pauseBeforeShutdown = pauseBeforeShutdown;
1: 	}
0: 	public void setPassword(String pwd) {
0: 		this.password = pwd;
1: 	}
0: 	public void setReceiveTimeOut(long receiveTimeOut) {
0: 		this.receiveTimeOut = receiveTimeOut;
1: 	}
0: 	public void setSleepTime(long sleepTime) {
0: 		this.sleepTime = sleepTime;
1: 	}
0: 	public void setSubject(String subject) {
0: 		this.subject = subject;
1: 	}
0: 	public void setTopic(boolean topic) {
0: 		this.topic = topic;
1: 	}
0: 	public void setQueue(boolean queue) {
0: 		this.topic = !queue;
1: 	}
0: 	public void setTransacted(boolean transacted) {
0: 		this.transacted = transacted;
1: 	}
0: 	public void setUrl(String url) {
0: 		this.url = url;
1: 	}
0: 	public void setUser(String user) {
0: 		this.user = user;
1: 	}
0: 	public void setVerbose(boolean verbose) {
0: 		this.verbose = verbose;
1: 	}
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:d320676
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.DeliveryMode;
1: import javax.jms.MessageProducer;
/////////////////////////////////////////////////////////////////////////
1: 
0: 	private MessageProducer replyProducer;
/////////////////////////////////////////////////////////////////////////
1:             
0:             replyProducer = session.createProducer(null);
0:             replyProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:             
/////////////////////////////////////////////////////////////////////////
1:             
0:             if ( message.getJMSReplyTo() !=null ) {            	
0:             	replyProducer.send(message.getJMSReplyTo(), session.createTextMessage("Reply: "+message.getJMSMessageID()));
0:                 if(transacted) {
0:                     session.commit();
0:                 }
0:             }
1:             
commit:cd0fb61
/////////////////////////////////////////////////////////////////////////
0: 		tool.run();
commit:da26ccb
/////////////////////////////////////////////////////////////////////////
0:     private long receiveTimeOut=0;
/////////////////////////////////////////////////////////////////////////
0:         if (args.length > 8) {
0:             tool.receiveTimeOut = Long.parseLong(args[8]);
0:         }
1:         
/////////////////////////////////////////////////////////////////////////
0:             if ( maxiumMessages > 0 ) {
0:             } else  {
0:                 if(receiveTimeOut==0) {
0:                     consumer.setMessageListener(this);
0:                 } else {
0:                     consumeMessagesAndClose(connection, session, consumer, receiveTimeOut);
0:                 }
/////////////////////////////////////////////////////////////////////////
1:     
0:     protected void consumeMessagesAndClose(Connection connection, Session session, MessageConsumer consumer, long timeout) throws JMSException, IOException {
0:         System.out.println("We will consume messages while they continue to be delivered within: " + timeout + " ms, and then we will shutdown");
1: 
0:         Message message;
0:         while ( (message = consumer.receive(timeout)) != null ) {
0:             onMessage(message);
0:         }
1:         
0:         System.out.println("Closing connection");
0:         consumer.close();
0:         session.close();
0:         connection.close();
0:         if (pauseBeforeShutdown) {
0:             System.out.println("Press return to shut down");
0:             System.in.read();
0:         }
0:     }
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
author:Gary Tully
-------------------------------------------------------------------------------
commit:1eb339f
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
1: public class ConsumerTool extends Thread implements MessageListener, ExceptionListener {
/////////////////////////////////////////////////////////////////////////
1:     private boolean pauseBeforeShutdown = false;
1:     private static int parallelThreads = 1;
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<ConsumerTool> threads = new ArrayList();
1:         consumerTool.showParameters();
1:         for (int threadCount = 1; threadCount <= parallelThreads; threadCount++) {
1:             consumerTool = new ConsumerTool();
1:             CommandLineSupport.setOptions(consumerTool, args);
1:             consumerTool.start();
1:             threads.add(consumerTool);
0:         }
0: 
1:         while (true) {
1:             Iterator<ConsumerTool> itr = threads.iterator();
1:             int running = 0;
1:             while (itr.hasNext()) {
1:                 ConsumerTool thread = itr.next();
1:                 if (thread.isAlive()) {
1:                     running++;
0:                 }
0:             }
0: 
1:             if (running <= 0) {
1:                 System.out.println("All threads completed their work");
1:                 break;
0:             }
0: 
0:             try {
1:                 Thread.sleep(1000);
0:             } catch (Exception e) {
0:             }
0:         }
1:         Iterator<ConsumerTool> itr = threads.iterator();
1:         while (itr.hasNext()) {
1:             ConsumerTool thread = itr.next();
0:         }
0:     }
0: 
1:     public void showParameters() {
0:         System.out.println("Connecting to URL: " + url);
0:         System.out.println("Consuming " + (topic ? "topic" : "queue") + ": " + subject);
0:         System.out.println("Using a " + (durable ? "durable" : "non-durable") + " subscription");
1:         System.out.println("Running " + parallelThreads + " parallel threads");
/////////////////////////////////////////////////////////////////////////
0:                 consumer = session.createDurableSubscriber((Topic) destination, consumerName);
/////////////////////////////////////////////////////////////////////////
1:             System.out.println("[" + this.getName() + "] Caught: " + e);
/////////////////////////////////////////////////////////////////////////
0:                 TextMessage txtMsg = (TextMessage) message;
1:                     int length = msg.length();
1:                     if (length > 50) {
1:                     System.out.println("[" + this.getName() + "] Received: '" + msg + "' (length " + length + ")");
1:                     System.out.println("[" + this.getName() + "] Received: '" + message + "'");
/////////////////////////////////////////////////////////////////////////
1:             System.out.println("[" + this.getName() + "] Caught: " + e);
/////////////////////////////////////////////////////////////////////////
1:         System.out.println("[" + this.getName() + "] JMS Exception occured.  Shutting down client.");
/////////////////////////////////////////////////////////////////////////
0:     protected void consumeMessagesAndClose(Connection connection, Session session, MessageConsumer consumer) throws JMSException,
0:             IOException {
1:         System.out.println("[" + this.getName() + "] We are about to wait until we consume: " + maxiumMessages
1:                 + " message(s) then we will shutdown");
/////////////////////////////////////////////////////////////////////////
1:         System.out.println("[" + this.getName() + "] Closing connection");
1:             System.out.println("[" + this.getName() + "] Press return to shut down");
0:     protected void consumeMessagesAndClose(Connection connection, Session session, MessageConsumer consumer, long timeout)
0:             throws JMSException, IOException {
1:         System.out.println("[" + this.getName() + "] We will consume messages while they continue to be delivered within: " + timeout
0:                 + " ms, and then we will shutdown");
1:         System.out.println("[" + this.getName() + "] Closing connection");
1:             System.out.println("[" + this.getName() + "] Press return to shut down");
/////////////////////////////////////////////////////////////////////////
1:     public void setParallelThreads(int parallelThreads) {
1:         if (parallelThreads < 1) {
1:             parallelThreads = 1;
0:         }
1:         this.parallelThreads = parallelThreads;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
author:Adrian T. Co
-------------------------------------------------------------------------------
commit:0ef421d
/////////////////////////////////////////////////////////////////////////
0: 		String[] unknown = CommandLineSupport.setOptions(consumerTool, args);
0: 		if (unknown.length > 0) {
0: 			System.out.println("Unknown options: " + Arrays.toString(unknown));
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:c1d82a4
/////////////////////////////////////////////////////////////////////////
0: 			session = connection.createSession(transacted, ackMode);
commit:92a698f
/////////////////////////////////////////////////////////////////////////
1:  *
0:  * Copyright 2004 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
1:  *
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
author:James Strachan
-------------------------------------------------------------------------------
commit:e733125
/////////////////////////////////////////////////////////////////////////
0: 
commit:40a7d3b
/////////////////////////////////////////////////////////////////////////
1: /**
0:  * 
0:  * Copyright 2004 Protique Ltd
0:  * 
0:  * Licensed under the Apache License, Version 2.0 (the "License"); 
0:  * you may not use this file except in compliance with the License. 
0:  * You may obtain a copy of the License at 
0:  * 
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  * 
1:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS, 
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
0:  * See the License for the specific language governing permissions and 
0:  * limitations under the License. 
0:  * 
0:  **/
0: 
1: import javax.jms.Connection;
1: import javax.jms.ExceptionListener;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageListener;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
1: import javax.jms.Topic;
0: import java.io.IOException;
0: 
1: /**
1:  * A simple tool for consuming messages
0:  *
0:  * @version $Revision: 1.1.1.1 $
1:  */
0: public class ConsumerTool extends ToolSupport implements MessageListener, ExceptionListener {
0: 
0:     protected int count = 0;
0:     protected int dumpCount = 10;
0:     protected boolean verbose = true;
0:     protected int maxiumMessages = 0;
0:     private boolean pauseBeforeShutdown;
0:     private boolean running;
0:     private Session session;
0:     private long sleepTime=0;
0: 
0: 
0:     public static void main(String[] args) {
0:         ConsumerTool tool = new ConsumerTool();
0:         if (args.length > 0) {
0:             tool.url = args[0];
0:         }
0:         if (args.length > 1) {
0:             tool.topic = args[1].equalsIgnoreCase("true");
0:         }
0:         if (args.length > 2) {
0:             tool.subject = args[2];
0:         }
0:         if (args.length > 3) {
0:             tool.durable = args[3].equalsIgnoreCase("true");
0:         }
0:         if (args.length > 4) {
0:             tool.maxiumMessages = Integer.parseInt(args[4]);
0:         }
0:         if (args.length > 5) {
0:             tool.clientID = args[5];
0:         }
0:         if (args.length > 6) {
0:             tool.transacted = "true".equals(args[6]);
0:         }
0:         if (args.length > 7) {
0:             tool.sleepTime = Long.parseLong(args[7]);
0:         }
0:         
0:         tool.run();
0:     }
0: 
0:     public void run() {
0:         try {
0:             running = true;
0:             
0:             System.out.println("Connecting to URL: " + url);
0:             System.out.println("Consuming " + (topic ? "topic" : "queue") + ": " + subject);
0:             System.out.println("Using " + (durable ? "durable" : "non-durable") + " subscription");
0: 
0:             Connection connection = createConnection();
0:             connection.setExceptionListener(this);
0:             session = createSession(connection);
0:             MessageConsumer consumer = null;
0:             if (durable && topic) {
0:                 consumer = session.createDurableSubscriber((Topic) destination, consumerName);
0:             }
0:             else {
0:                 consumer = session.createConsumer(destination);
0:             }
0:             if (maxiumMessages <= 0) {
0:                 consumer.setMessageListener(this);
0:             }
0: 
0:             if (maxiumMessages > 0) {
0:                 consumeMessagesAndClose(connection, session, consumer);
0:             }
0:         }
0:         catch (Exception e) {
0:             System.out.println("Caught: " + e);
0:             e.printStackTrace();
0:         }
0:     }
0: 
0:     public void onMessage(Message message) {
0:         try {
0:             if (message instanceof TextMessage) {
0:                 TextMessage txtMsg = (TextMessage) message;
0:                 if (verbose) {
0: 
0:                     String msg = txtMsg.getText();
0:                     if (msg.length() > 50) {
0:                         msg = msg.substring(0, 50) + "...";
0:                     }
0: 
0:                     System.out.println("Received: " + msg);
0:                 }
0:             }
0:             else {
0:                 if (verbose) {
0:                     System.out.println("Received: " + message);
0:                 }
0:             }
0:             if(transacted) {
0:                 session.commit();
0:             }
0:             /*
0:             if (++count % dumpCount == 0) {
0:                 dumpStats(connection);
0:             }
1:             */
0:         }
0:         catch (JMSException e) {
0:             System.out.println("Caught: " + e);
0:             e.printStackTrace();
0:         } finally {
0:             if( sleepTime> 0 ) {
0:                 try {
0:                     Thread.sleep(sleepTime);
0:                 } catch (InterruptedException e) {
0:                 }
0:             }
0:         }
0:     }
0: 
0:     synchronized public void onException(JMSException ex) {
0:         System.out.println("JMS Exception occured.  Shutting down client.");
0:         running=false;
0:     }
0: 
0:     synchronized boolean isRunning() {
0:         return running;
0:     }
0:     
0:     protected void consumeMessagesAndClose(Connection connection, Session session, MessageConsumer consumer) throws JMSException, IOException {
0:         System.out.println("We are about to wait until we consume: " + maxiumMessages + " message(s) then we will shutdown");
0: 
0:         for (int i = 0; i < maxiumMessages && isRunning(); ) {
0:             Message message = consumer.receive(1000);
0:             if( message!=null ) {
0:                 i++;
0:                 onMessage(message);
0:             }
0:         }
0:         System.out.println("Closing connection");
0:         consumer.close();
0:         session.close();
0:         connection.close();
0:         if (pauseBeforeShutdown) {
0:             System.out.println("Press return to shut down");
0:             System.in.read();
0:         }
0:     }
0: 
0: }
============================================================================