1:734fb7d: /**
1:734fb7d:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:734fb7d:  * contributor license agreements.  See the NOTICE file distributed with
1:734fb7d:  * this work for additional information regarding copyright ownership.
1:734fb7d:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:734fb7d:  * (the "License"); you may not use this file except in compliance with
1:734fb7d:  * the License.  You may obtain a copy of the License at
1:734fb7d:  *
1:734fb7d:  *      http://www.apache.org/licenses/LICENSE-2.0
1:734fb7d:  *
1:734fb7d:  * Unless required by applicable law or agreed to in writing, software
1:734fb7d:  * distributed under the License is distributed on an "AS IS" BASIS,
1:734fb7d:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:734fb7d:  * See the License for the specific language governing permissions and
1:734fb7d:  * limitations under the License.
1:734fb7d:  */
1:734fb7d: package org.apache.activemq.broker.region.cursors;
1:734fb7d: 
1:25ff569: import static org.junit.Assert.assertEquals;
1:5ec4513: import static org.junit.Assert.assertTrue;
1:25ff569: 
1:734fb7d: import java.io.IOException;
1:734fb7d: import java.net.URI;
1:cf3d419: import java.util.concurrent.TimeUnit;
1:734fb7d: import java.util.concurrent.atomic.AtomicLong;
1:734fb7d: 
1:734fb7d: import javax.jms.Connection;
1:734fb7d: import javax.jms.DeliveryMode;
1:734fb7d: import javax.jms.MessageConsumer;
1:734fb7d: import javax.jms.MessageProducer;
1:734fb7d: import javax.jms.Session;
1:734fb7d: import javax.jms.Topic;
1:734fb7d: import javax.jms.TopicSession;
1:734fb7d: 
1:734fb7d: import org.apache.activemq.ActiveMQConnectionFactory;
1:734fb7d: import org.apache.activemq.broker.BrokerService;
1:734fb7d: import org.apache.activemq.broker.TransportConnector;
1:734fb7d: import org.apache.activemq.broker.region.Destination;
1:734fb7d: import org.apache.activemq.broker.region.DurableTopicSubscription;
1:734fb7d: import org.apache.activemq.broker.region.TopicSubscription;
1:734fb7d: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:734fb7d: import org.apache.activemq.broker.region.policy.PolicyMap;
1:734fb7d: import org.apache.activemq.command.ActiveMQDestination;
1:734fb7d: import org.apache.activemq.command.ActiveMQTopic;
1:734fb7d: import org.apache.activemq.store.AbstractStoreStatTestSupport;
1:734fb7d: import org.apache.activemq.store.MessageStore;
1:734fb7d: import org.apache.activemq.util.SubscriptionKey;
1:734fb7d: import org.apache.activemq.util.Wait;
1:734fb7d: import org.apache.activemq.util.Wait.Condition;
1:734fb7d: import org.junit.After;
1:cf3d419: import org.junit.Assume;
1:734fb7d: import org.junit.Before;
1:cf3d419: import org.junit.Rule;
1:734fb7d: import org.junit.Test;
1:cf3d419: import org.junit.rules.Timeout;
1:734fb7d: import org.slf4j.Logger;
1:734fb7d: import org.slf4j.LoggerFactory;
1:734fb7d: 
1:734fb7d: /**
1:734fb7d:  * This test checks that KahaDB properly sets the new storeMessageSize statistic.
1:734fb7d:  *
1:734fb7d:  * AMQ-5748
1:734fb7d:  *
1:734fb7d:  */
1:734fb7d: public abstract class AbstractPendingMessageCursorTest extends AbstractStoreStatTestSupport {
1:734fb7d:     protected static final Logger LOG = LoggerFactory
1:734fb7d:             .getLogger(AbstractPendingMessageCursorTest.class);
1:734fb7d: 
1:734fb7d: 
1:734fb7d:     protected BrokerService broker;
1:734fb7d:     protected URI brokerConnectURI;
1:734fb7d:     protected String defaultQueueName = "test.queue";
1:734fb7d:     protected String defaultTopicName = "test.topic";
1:734fb7d:     protected static int maxMessageSize = 1000;
1:cf3d419:     protected final boolean prioritizedMessages;
1:cf3d419:     protected boolean enableSubscriptionStatistics;
1:485fcaf: 
1:cf3d419:     @Rule
1:cf3d419:     public Timeout globalTimeout= new Timeout(60, TimeUnit.SECONDS);
1:485fcaf: 
1:485fcaf:     /**
1:485fcaf:      * @param prioritizedMessages
1:485fcaf:      */
1:cf3d419:     public AbstractPendingMessageCursorTest(final boolean prioritizedMessages) {
1:485fcaf:         super();
1:485fcaf:         this.prioritizedMessages = prioritizedMessages;
1:485fcaf:     }
1:734fb7d: 
1:734fb7d:     @Before
1:734fb7d:     public void startBroker() throws Exception {
1:734fb7d:         setUpBroker(true);
1:485fcaf:     }
1:734fb7d: 
1:734fb7d:     protected void setUpBroker(boolean clearDataDir) throws Exception {
1:734fb7d: 
1:734fb7d:         broker = new BrokerService();
1:734fb7d:         this.initPersistence(broker);
1:734fb7d:         //set up a transport
1:734fb7d:         TransportConnector connector = broker
1:734fb7d:                 .addConnector(new TransportConnector());
1:734fb7d:         connector.setUri(new URI("tcp://0.0.0.0:0"));
1:734fb7d:         connector.setName("tcp");
1:734fb7d: 
1:734fb7d:         PolicyEntry policy = new PolicyEntry();
1:734fb7d:         policy.setTopicPrefetch(100);
1:734fb7d:         policy.setDurableTopicPrefetch(100);
1:485fcaf:         policy.setPrioritizedMessages(isPrioritizedMessages());
1:734fb7d:         PolicyMap pMap = new PolicyMap();
1:734fb7d:         pMap.setDefaultEntry(policy);
1:734fb7d:         broker.setDestinationPolicy(pMap);
1:734fb7d: 
1:734fb7d:         broker.start();
1:734fb7d:         broker.waitUntilStarted();
1:734fb7d:         brokerConnectURI = broker.getConnectorByName("tcp").getConnectUri();
1:734fb7d: 
2:734fb7d:     }
1:734fb7d: 
1:734fb7d:     @After
1:734fb7d:     public void stopBroker() throws Exception {
1:734fb7d:         broker.stop();
1:734fb7d:         broker.waitUntilStopped();
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     @Override
1:734fb7d:     protected BrokerService getBroker() {
1:734fb7d:         return this.broker;
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     @Override
1:734fb7d:     protected URI getBrokerConnectURI() {
1:734fb7d:         return this.brokerConnectURI;
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     protected abstract void initPersistence(BrokerService brokerService) throws IOException;
1:734fb7d: 
1:485fcaf:     protected boolean isPrioritizedMessages() {
1:485fcaf:         return prioritizedMessages;
1:485fcaf:     }
1:485fcaf: 
1:734fb7d:     @Test
1:734fb7d:     public void testQueueMessageSize() throws Exception {
1:cf3d419:         //doesn't apply to queues, only run once
1:cf3d419:         Assume.assumeFalse(enableSubscriptionStatistics);
1:cf3d419: 
1:734fb7d:         AtomicLong publishedMessageSize = new AtomicLong();
1:734fb7d: 
1:734fb7d:         org.apache.activemq.broker.region.Queue dest = publishTestQueueMessages(200, publishedMessageSize);
1:734fb7d:         verifyPendingStats(dest, 200, publishedMessageSize.get());
1:734fb7d:         verifyStoreStats(dest, 200, publishedMessageSize.get());
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     @Test
1:734fb7d:     public void testQueueBrowserMessageSize() throws Exception {
1:cf3d419:         //doesn't apply to queues, only run once
1:cf3d419:         Assume.assumeFalse(enableSubscriptionStatistics);
1:cf3d419: 
1:734fb7d:         AtomicLong publishedMessageSize = new AtomicLong();
1:734fb7d: 
1:734fb7d:         org.apache.activemq.broker.region.Queue dest = publishTestQueueMessages(200, publishedMessageSize);
1:734fb7d:         browseTestQueueMessages(dest.getName());
1:734fb7d:         verifyPendingStats(dest, 200, publishedMessageSize.get());
1:734fb7d:         verifyStoreStats(dest, 200, publishedMessageSize.get());
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     @Test
1:734fb7d:     public void testQueueMessageSizeNonPersistent() throws Exception {
1:cf3d419:         //doesn't apply to queues, only run once
1:cf3d419:         Assume.assumeFalse(enableSubscriptionStatistics);
1:cf3d419: 
1:734fb7d:         AtomicLong publishedMessageSize = new AtomicLong();
1:734fb7d: 
1:734fb7d:         org.apache.activemq.broker.region.Queue dest = publishTestQueueMessages(200,
1:734fb7d:                 DeliveryMode.NON_PERSISTENT, publishedMessageSize);
1:734fb7d:         verifyPendingStats(dest, 200, publishedMessageSize.get());
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     @Test
1:734fb7d:     public void testQueueMessageSizePersistentAndNonPersistent() throws Exception {
1:cf3d419:         //doesn't apply to queues, only run once
1:cf3d419:         Assume.assumeFalse(enableSubscriptionStatistics);
1:cf3d419: 
1:734fb7d:         AtomicLong publishedNonPersistentMessageSize = new AtomicLong();
1:734fb7d:         AtomicLong publishedMessageSize = new AtomicLong();
1:734fb7d: 
1:734fb7d:         org.apache.activemq.broker.region.Queue dest = publishTestQueueMessages(100,
1:734fb7d:                 DeliveryMode.PERSISTENT, publishedMessageSize);
1:734fb7d:         dest = publishTestQueueMessages(100,
1:734fb7d:                 DeliveryMode.NON_PERSISTENT, publishedNonPersistentMessageSize);
1:734fb7d:         verifyPendingStats(dest, 200, publishedMessageSize.get() + publishedNonPersistentMessageSize.get());
1:734fb7d:         verifyStoreStats(dest, 100, publishedMessageSize.get());
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     @Test
1:734fb7d:     public void testQueueMessageSizeAfterConsumption() throws Exception {
1:cf3d419:         //doesn't apply to queues, only run once
1:cf3d419:         Assume.assumeFalse(enableSubscriptionStatistics);
1:cf3d419: 
1:734fb7d:         AtomicLong publishedMessageSize = new AtomicLong();
1:734fb7d: 
1:734fb7d:         org.apache.activemq.broker.region.Queue dest = publishTestQueueMessages(200, publishedMessageSize);
1:734fb7d:         verifyPendingStats(dest, 200, publishedMessageSize.get());
1:734fb7d: 
1:734fb7d:         consumeTestQueueMessages();
1:734fb7d: 
1:734fb7d:         verifyPendingStats(dest, 0, 0);
1:734fb7d:         verifyStoreStats(dest, 0, 0);
1:734fb7d:     }
1:734fb7d: 
1:cf3d419:     @Test
1:734fb7d:     public void testQueueMessageSizeAfterConsumptionNonPersistent() throws Exception {
1:cf3d419:         //doesn't apply to queues, only run once
1:cf3d419:         Assume.assumeFalse(enableSubscriptionStatistics);
1:cf3d419: 
1:734fb7d:         AtomicLong publishedMessageSize = new AtomicLong();
1:734fb7d: 
1:734fb7d:         org.apache.activemq.broker.region.Queue dest = publishTestQueueMessages(200, DeliveryMode.NON_PERSISTENT, publishedMessageSize);
1:734fb7d:         verifyPendingStats(dest, 200, publishedMessageSize.get());
1:734fb7d: 
1:734fb7d:         consumeTestQueueMessages();
1:734fb7d: 
1:734fb7d:         verifyPendingStats(dest, 0, 0);
1:734fb7d:         verifyStoreStats(dest, 0, 0);
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     @Test
1:734fb7d:     public void testTopicMessageSize() throws Exception {
1:734fb7d:         AtomicLong publishedMessageSize = new AtomicLong();
1:734fb7d: 
1:734fb7d:         Connection connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:734fb7d:         connection.setClientID("clientId");
1:734fb7d:         connection.start();
1:734fb7d:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:734fb7d:         MessageConsumer consumer = session.createConsumer(new ActiveMQTopic(this.defaultTopicName));
1:734fb7d: 
1:734fb7d:         org.apache.activemq.broker.region.Topic dest = publishTestTopicMessages(200, publishedMessageSize);
1:734fb7d: 
1:734fb7d:         //verify the count and size - there is a prefetch of 100 so only 100 are pending and 100
1:734fb7d:         //are dispatched because we have an active consumer online
1:734fb7d:         //verify that the size is greater than 100 messages times the minimum size of 100
1:734fb7d:         verifyPendingStats(dest, 100, 100 * 100);
1:734fb7d: 
1:734fb7d:         //consume all messages
1:734fb7d:         consumeTestMessages(consumer, 200);
1:734fb7d: 
1:734fb7d:         //All messages should now be gone
1:734fb7d:         verifyPendingStats(dest, 0, 0);
1:734fb7d: 
1:734fb7d:         connection.close();
1:734fb7d:     }
1:734fb7d: 
1:cf3d419:     @Test
1:734fb7d:     public void testTopicNonPersistentMessageSize() throws Exception {
1:734fb7d:         AtomicLong publishedMessageSize = new AtomicLong();
1:734fb7d: 
1:734fb7d:         Connection connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:734fb7d:         connection.setClientID("clientId");
1:734fb7d:         connection.start();
1:734fb7d:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:734fb7d:         MessageConsumer consumer = session.createConsumer(new ActiveMQTopic(this.defaultTopicName));
1:734fb7d: 
1:734fb7d:         org.apache.activemq.broker.region.Topic dest = publishTestTopicMessages(200,
1:734fb7d:                 DeliveryMode.NON_PERSISTENT, publishedMessageSize);
1:734fb7d: 
1:734fb7d:         //verify the count and size - there is a prefetch of 100 so only 100 are pending and 100
1:734fb7d:         //are dispatched because we have an active consumer online
1:734fb7d:         //verify the size is at least as big as 100 messages times the minimum of 100 size
1:734fb7d:         verifyPendingStats(dest, 100, 100 * 100);
1:734fb7d: 
1:734fb7d:         //consume all messages
1:734fb7d:         consumeTestMessages(consumer, 200);
1:734fb7d: 
1:734fb7d:         //All messages should now be gone
1:734fb7d:         verifyPendingStats(dest, 0, 0);
1:734fb7d: 
1:734fb7d:         connection.close();
1:734fb7d:     }
1:734fb7d: 
1:cf3d419:     @Test
1:734fb7d:     public void testTopicPersistentAndNonPersistentMessageSize() throws Exception {
1:734fb7d:         AtomicLong publishedMessageSize = new AtomicLong();
1:734fb7d: 
1:734fb7d:         Connection connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:734fb7d:         connection.setClientID("clientId");
1:734fb7d:         connection.start();
1:734fb7d:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:734fb7d:         MessageConsumer consumer = session.createConsumer(new ActiveMQTopic(this.defaultTopicName));
1:734fb7d: 
1:734fb7d:         org.apache.activemq.broker.region.Topic dest = publishTestTopicMessages(100,
1:734fb7d:                 DeliveryMode.NON_PERSISTENT, publishedMessageSize);
1:734fb7d: 
1:734fb7d:         dest = publishTestTopicMessages(100, DeliveryMode.PERSISTENT, publishedMessageSize);
1:734fb7d: 
1:734fb7d:         //verify the count and size - there is a prefetch of 100 so only 100 are pending and 100
1:734fb7d:         //are dispatched because we have an active consumer online
1:734fb7d:       //verify the size is at least as big as 100 messages times the minimum of 100 size
1:734fb7d:         verifyPendingStats(dest, 100, 100 * 100);
1:734fb7d: 
1:734fb7d:         //consume all messages
1:734fb7d:         consumeTestMessages(consumer, 200);
1:734fb7d: 
1:734fb7d:         //All messages should now be gone
1:734fb7d:         verifyPendingStats(dest, 0, 0);
1:734fb7d: 
1:734fb7d:         connection.close();
1:734fb7d:     }
1:734fb7d: 
1:cf3d419:     @Test
1:734fb7d:     public void testMessageSizeOneDurable() throws Exception {
1:734fb7d:         AtomicLong publishedMessageSize = new AtomicLong();
1:734fb7d:         Connection connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:734fb7d:         connection.setClientID("clientId");
1:734fb7d:         connection.start();
1:734fb7d: 
1:734fb7d:         SubscriptionKey subKey = new SubscriptionKey("clientId", "sub1");
1:734fb7d:         org.apache.activemq.broker.region.Topic dest = publishTestMessagesDurable(connection,
1:734fb7d:                 new String[] {"sub1"}, 200, publishedMessageSize, DeliveryMode.PERSISTENT);
1:734fb7d: 
1:734fb7d:         //verify the count and size - durable is offline so all 200 should be pending since none are in prefetch
1:734fb7d:         verifyPendingStats(dest, subKey, 200, publishedMessageSize.get());
1:734fb7d:         verifyStoreStats(dest, 200, publishedMessageSize.get());
1:734fb7d: 
1:25ff569:         //should be equal in this case
1:25ff569:         assertEquals(dest.getDurableTopicSubs().get(subKey).getPendingMessageSize(),
1:25ff569:                 dest.getMessageStore().getMessageStoreStatistics().getMessageSize().getTotalSize());
1:25ff569: 
1:734fb7d:         //consume all messages
1:734fb7d:         consumeDurableTestMessages(connection, "sub1", 200, publishedMessageSize);
1:734fb7d: 
1:734fb7d:         //All messages should now be gone
1:734fb7d:         verifyPendingStats(dest, subKey, 0, 0);
1:734fb7d:         verifyStoreStats(dest, 0, 0);
1:734fb7d: 
1:734fb7d:         connection.close();
1:734fb7d:     }
1:734fb7d: 
1:cf3d419:     @Test
1:734fb7d:     public void testMessageSizeOneDurablePartialConsumption() throws Exception {
1:734fb7d:         AtomicLong publishedMessageSize = new AtomicLong();
1:734fb7d: 
1:734fb7d:         Connection connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:734fb7d:         connection.setClientID("clientId");
1:734fb7d:         connection.start();
1:734fb7d: 
1:734fb7d:         SubscriptionKey subKey = new SubscriptionKey("clientId", "sub1");
1:734fb7d:         org.apache.activemq.broker.region.Topic dest = publishTestMessagesDurable(
1:734fb7d:                 connection, new String[] {"sub1"}, 200, publishedMessageSize, DeliveryMode.PERSISTENT);
1:734fb7d: 
1:734fb7d:         //verify the count and size - durable is offline so all 200 should be pending since none are in prefetch
1:734fb7d:         verifyPendingStats(dest, subKey, 200, publishedMessageSize.get());
1:734fb7d:         verifyStoreStats(dest, 200, publishedMessageSize.get());
1:734fb7d: 
1:734fb7d:         //consume all messages
1:734fb7d:         consumeDurableTestMessages(connection, "sub1", 50, publishedMessageSize);
1:734fb7d: 
1:734fb7d:         //150 should be left
1:734fb7d:         verifyPendingStats(dest, subKey, 150, publishedMessageSize.get());
1:734fb7d:         verifyStoreStats(dest, 150, publishedMessageSize.get());
1:734fb7d: 
1:734fb7d:         connection.close();
1:734fb7d:     }
1:734fb7d: 
1:cf3d419:     @Test
1:734fb7d:     public void testMessageSizeTwoDurables() throws Exception {
1:734fb7d:         AtomicLong publishedMessageSize = new AtomicLong();
1:734fb7d: 
1:734fb7d:         Connection connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:734fb7d:         connection.setClientID("clientId");
1:734fb7d:         connection.start();
1:734fb7d: 
1:734fb7d:         org.apache.activemq.broker.region.Topic dest =
1:734fb7d:                 publishTestMessagesDurable(connection, new String[] {"sub1", "sub2"}, 200,
1:734fb7d:                         publishedMessageSize, DeliveryMode.PERSISTENT);
1:734fb7d: 
1:734fb7d:         //verify the count and size
1:734fb7d:         SubscriptionKey subKey = new SubscriptionKey("clientId", "sub1");
1:734fb7d:         verifyPendingStats(dest, subKey, 200, publishedMessageSize.get());
1:734fb7d: 
1:734fb7d:         //consume messages just for sub1
1:734fb7d:         consumeDurableTestMessages(connection, "sub1", 200, publishedMessageSize);
1:734fb7d: 
1:734fb7d:         //There is still a durable that hasn't consumed so the messages should exist
1:734fb7d:         SubscriptionKey subKey2 = new SubscriptionKey("clientId", "sub2");
1:734fb7d:         verifyPendingStats(dest, subKey, 0, 0);
1:734fb7d:         verifyPendingStats(dest, subKey2, 200, publishedMessageSize.get());
1:734fb7d:         verifyStoreStats(dest, 200, publishedMessageSize.get());
1:734fb7d: 
1:734fb7d:         connection.stop();
1:734fb7d:     }
1:734fb7d: 
1:734fb7d: 
1:734fb7d:     protected void verifyPendingStats(final org.apache.activemq.broker.region.Queue queue,
1:734fb7d:             final int count, final long minimumSize) throws Exception {
1:734fb7d:         this.verifyPendingStats(queue, count, minimumSize, count, minimumSize);
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     protected void verifyPendingStats(final org.apache.activemq.broker.region.Queue queue,
1:734fb7d:             final int count, final long minimumSize, final int storeCount, final long minimumStoreSize) throws Exception {
1:734fb7d: 
1:5ec4513:         assertTrue(Wait.waitFor(new Condition() {
1:734fb7d:             @Override
1:734fb7d:             public boolean isSatisified() throws Exception {
1:734fb7d:                 return queue.getPendingMessageCount() == count;
1:734fb7d:             }
1:5ec4513:         }));
1:734fb7d: 
1:734fb7d:         verifySize(count, new MessageSizeCalculator() {
1:734fb7d:             @Override
1:734fb7d:             public long getMessageSize() throws Exception {
1:734fb7d:                 return queue.getPendingMessageSize();
1:734fb7d:             }
1:734fb7d:         }, minimumSize);
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     //For a non-durable there won't necessarily be a message store
1:734fb7d:     protected void verifyPendingStats(org.apache.activemq.broker.region.Topic topic,
1:734fb7d:             final int count, final long minimumSize) throws Exception {
1:734fb7d: 
1:734fb7d:         final TopicSubscription sub = (TopicSubscription) topic.getConsumers().get(0);
1:734fb7d: 
1:5ec4513:         assertTrue(Wait.waitFor(new Condition() {
1:734fb7d:             @Override
1:734fb7d:             public boolean isSatisified() throws Exception {
1:734fb7d:                 return sub.getPendingQueueSize() == count;
1:734fb7d:             }
1:5ec4513:         }));
1:734fb7d: 
1:734fb7d:         verifySize(count, new MessageSizeCalculator() {
1:734fb7d:             @Override
1:734fb7d:             public long getMessageSize() throws Exception {
1:734fb7d:                 return sub.getPendingMessageSize();
1:734fb7d:             }
1:734fb7d:         }, minimumSize);
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     protected void verifyPendingStats(org.apache.activemq.broker.region.Topic topic, SubscriptionKey subKey,
1:734fb7d:             final int count, final long minimumSize) throws Exception {
1:734fb7d: 
1:734fb7d:         final DurableTopicSubscription sub = topic.getDurableTopicSubs().get(subKey);
1:734fb7d: 
1:734fb7d:         //verify message count
1:5ec4513:         assertTrue(Wait.waitFor(new Condition() {
1:734fb7d:             @Override
1:734fb7d:             public boolean isSatisified() throws Exception {
1:734fb7d:                 return sub.getPendingQueueSize() == count;
1:734fb7d:             }
1:5ec4513:         }));
1:734fb7d: 
1:734fb7d:         //verify message size
1:734fb7d:         verifySize(count, new MessageSizeCalculator() {
1:734fb7d:             @Override
1:734fb7d:             public long getMessageSize() throws Exception {
1:734fb7d:                 return sub.getPendingMessageSize();
1:734fb7d:             }
1:734fb7d:         }, minimumSize);
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     protected void verifyStoreStats(org.apache.activemq.broker.region.Destination dest,
1:734fb7d:             final int storeCount, final long minimumStoreSize) throws Exception {
1:734fb7d:         final MessageStore messageStore = dest.getMessageStore();
1:734fb7d: 
1:5ec4513:         assertTrue(Wait.waitFor(new Condition() {
1:734fb7d:             @Override
1:734fb7d:             public boolean isSatisified() throws Exception {
1:734fb7d:                 return messageStore.getMessageCount() == storeCount;
1:734fb7d:             }
1:5ec4513:         }));
1:734fb7d:         verifySize(storeCount, new MessageSizeCalculator() {
1:734fb7d:             @Override
1:734fb7d:             public long getMessageSize() throws Exception {
1:734fb7d:                 return messageStore.getMessageSize();
1:734fb7d:             }
1:734fb7d:         }, minimumStoreSize);
1:734fb7d: 
1:734fb7d:     }
1:734fb7d: 
1:734fb7d: 
1:734fb7d:     protected void verifySize(final int count, final MessageSizeCalculator messageSizeCalculator,
1:734fb7d:             final long minimumSize) throws Exception {
1:734fb7d:         if (count > 0) {
1:5ec4513:             assertTrue(Wait.waitFor(new Condition() {
1:734fb7d:                 @Override
1:734fb7d:                 public boolean isSatisified() throws Exception {
1:734fb7d:                     return messageSizeCalculator.getMessageSize() > minimumSize ;
1:734fb7d:                 }
1:5ec4513:             }));
1:734fb7d:         } else {
1:5ec4513:             assertTrue(Wait.waitFor(new Condition() {
1:734fb7d:                 @Override
1:734fb7d:                 public boolean isSatisified() throws Exception {
1:734fb7d:                     return messageSizeCalculator.getMessageSize() == 0;
1:734fb7d:                 }
1:5ec4513:             }));
1:734fb7d:         }
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     protected static interface MessageSizeCalculator {
1:734fb7d:         long getMessageSize() throws Exception;
1:734fb7d:     }
1:734fb7d: 
1:734fb7d: 
1:734fb7d:     protected Destination consumeTestMessages(MessageConsumer consumer, int size) throws Exception {
1:734fb7d:         return consumeTestMessages(consumer, size, defaultTopicName);
1:734fb7d:     }
1:734fb7d: 
1:734fb7d: 
1:734fb7d:     protected Destination consumeTestMessages(MessageConsumer consumer, int size, String topicName) throws Exception {
1:734fb7d:         // create a new queue
1:734fb7d:         final ActiveMQDestination activeMqTopic = new ActiveMQTopic(
1:734fb7d:                 topicName);
1:734fb7d: 
1:734fb7d:         Destination dest = broker.getDestination(activeMqTopic);
1:734fb7d: 
1:734fb7d:         //Topic topic = session.createTopic(topicName);
1:734fb7d: 
1:734fb7d:         try {
1:734fb7d:             for (int i = 0; i < size; i++) {
1:734fb7d:                 consumer.receive();
1:734fb7d:             }
1:734fb7d: 
1:734fb7d:         } finally {
1:734fb7d:             //session.close();
1:734fb7d:         }
1:734fb7d: 
1:734fb7d:         return dest;
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     protected Destination consumeDurableTestMessages(Connection connection, String sub, int size, AtomicLong publishedMessageSize) throws Exception {
1:734fb7d:         return consumeDurableTestMessages(connection, sub, size, defaultTopicName, publishedMessageSize);
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     protected org.apache.activemq.broker.region.Topic publishTestMessagesDurable(Connection connection,
1:734fb7d:             String[] subNames, int publishSize, AtomicLong publishedMessageSize, int deliveryMode) throws Exception {
1:734fb7d: 
1:734fb7d:         return publishTestMessagesDurable(connection, subNames, defaultTopicName,
1:734fb7d:                 publishSize, 0, AbstractStoreStatTestSupport.defaultMessageSize,
1:734fb7d:                 publishedMessageSize, false, deliveryMode);
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     protected org.apache.activemq.broker.region.Topic publishTestTopicMessages(int publishSize,
1:734fb7d:             AtomicLong publishedMessageSize) throws Exception {
1:734fb7d:         return publishTestTopicMessages(publishSize, DeliveryMode.PERSISTENT, publishedMessageSize);
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     protected org.apache.activemq.broker.region.Topic publishTestTopicMessages(int publishSize,
1:734fb7d:             int deliveryMode, AtomicLong publishedMessageSize) throws Exception {
1:734fb7d:         // create a new queue
1:734fb7d:         Connection connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:734fb7d:         connection.setClientID("clientId2");
1:734fb7d:         connection.start();
1:734fb7d: 
1:734fb7d:         final ActiveMQDestination activeMqTopic = new ActiveMQTopic(
1:734fb7d:                 defaultTopicName);
1:734fb7d: 
1:734fb7d:         org.apache.activemq.broker.region.Topic dest =
1:734fb7d:                 (org.apache.activemq.broker.region.Topic) broker.getDestination(activeMqTopic);
1:734fb7d: 
1:734fb7d:         // Start the connection
1:734fb7d:         Session session = connection.createSession(false,
1:734fb7d:                 TopicSession.AUTO_ACKNOWLEDGE);
1:734fb7d:         Topic topic = session.createTopic(defaultTopicName);
1:734fb7d: 
1:734fb7d:         try {
1:734fb7d:             // publish a bunch of non-persistent messages to fill up the temp
1:734fb7d:             // store
1:734fb7d:             MessageProducer prod = session.createProducer(topic);
1:734fb7d:             prod.setDeliveryMode(deliveryMode);
1:734fb7d:             for (int i = 0; i < publishSize; i++) {
1:8a09b7e:                 prod.send(createMessage(i, session, AbstractPendingMessageCursorTest.maxMessageSize, publishedMessageSize));
1:734fb7d:             }
1:734fb7d: 
1:734fb7d:         } finally {
1:734fb7d:             connection.close();
1:734fb7d:         }
1:734fb7d: 
1:734fb7d:         return dest;
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     protected org.apache.activemq.broker.region.Queue publishTestQueueMessages(int count,
1:734fb7d:             AtomicLong publishedMessageSize) throws Exception {
1:734fb7d:         return publishTestQueueMessages(count, defaultQueueName, DeliveryMode.PERSISTENT,
1:734fb7d:                 AbstractPendingMessageCursorTest.maxMessageSize, publishedMessageSize);
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     protected org.apache.activemq.broker.region.Queue publishTestQueueMessages(int count, int deliveryMode,
1:734fb7d:             AtomicLong publishedMessageSize) throws Exception {
1:734fb7d:         return publishTestQueueMessages(count, defaultQueueName, deliveryMode,
1:734fb7d:                 AbstractPendingMessageCursorTest.maxMessageSize, publishedMessageSize);
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     protected Destination consumeTestQueueMessages() throws Exception {
1:734fb7d:         return consumeTestQueueMessages(defaultQueueName);
1:734fb7d:     }
1:734fb7d: 
1:734fb7d: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:cf3d419
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
1: import org.junit.Assume;
1: import org.junit.Rule;
1: import org.junit.rules.Timeout;
/////////////////////////////////////////////////////////////////////////
1:     protected final boolean prioritizedMessages;
1:     protected boolean enableSubscriptionStatistics;
1:     @Rule
1:     public Timeout globalTimeout= new Timeout(60, TimeUnit.SECONDS);
1:     public AbstractPendingMessageCursorTest(final boolean prioritizedMessages) {
/////////////////////////////////////////////////////////////////////////
1:         //doesn't apply to queues, only run once
1:         Assume.assumeFalse(enableSubscriptionStatistics);
1: 
/////////////////////////////////////////////////////////////////////////
1:         //doesn't apply to queues, only run once
1:         Assume.assumeFalse(enableSubscriptionStatistics);
1: 
/////////////////////////////////////////////////////////////////////////
1:         //doesn't apply to queues, only run once
1:         Assume.assumeFalse(enableSubscriptionStatistics);
1: 
/////////////////////////////////////////////////////////////////////////
1:         //doesn't apply to queues, only run once
1:         Assume.assumeFalse(enableSubscriptionStatistics);
1: 
/////////////////////////////////////////////////////////////////////////
1:         //doesn't apply to queues, only run once
1:         Assume.assumeFalse(enableSubscriptionStatistics);
1: 
/////////////////////////////////////////////////////////////////////////
1:         //doesn't apply to queues, only run once
1:         Assume.assumeFalse(enableSubscriptionStatistics);
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:     @Test
commit:5ec4513
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertTrue;
/////////////////////////////////////////////////////////////////////////
1:         assertTrue(Wait.waitFor(new Condition() {
1:         }));
/////////////////////////////////////////////////////////////////////////
1:         assertTrue(Wait.waitFor(new Condition() {
1:         }));
/////////////////////////////////////////////////////////////////////////
1:         assertTrue(Wait.waitFor(new Condition() {
1:         }));
/////////////////////////////////////////////////////////////////////////
1:         assertTrue(Wait.waitFor(new Condition() {
1:         }));
/////////////////////////////////////////////////////////////////////////
1:             assertTrue(Wait.waitFor(new Condition() {
1:             }));
1:             assertTrue(Wait.waitFor(new Condition() {
1:             }));
commit:485fcaf
/////////////////////////////////////////////////////////////////////////
0: import java.util.Arrays;
0: import java.util.Collection;
/////////////////////////////////////////////////////////////////////////
0: import org.junit.runners.Parameterized.Parameters;
/////////////////////////////////////////////////////////////////////////
0:     protected boolean prioritizedMessages;
1: 
0:     @Parameters(name="prioritizedMessages={0}")
0:     public static Collection<Object[]> data() {
0:         return Arrays.asList(new Object[][] {
0:                 // use priority messages
0:                 {true},
0:                 // don't use priority messages
0:                 {false}
0:         });
1:     }
1: 
1:     /**
1:      * @param prioritizedMessages
1:      */
0:     public AbstractPendingMessageCursorTest(boolean prioritizedMessages) {
1:         super();
1:         this.prioritizedMessages = prioritizedMessages;
1:     }
/////////////////////////////////////////////////////////////////////////
1:         policy.setPrioritizedMessages(isPrioritizedMessages());
/////////////////////////////////////////////////////////////////////////
1:     protected boolean isPrioritizedMessages() {
1:         return prioritizedMessages;
1:     }
1: 
commit:25ff569
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertEquals;
1: 
/////////////////////////////////////////////////////////////////////////
1:         //should be equal in this case
1:         assertEquals(dest.getDurableTopicSubs().get(subKey).getPendingMessageSize(),
1:                 dest.getMessageStore().getMessageStoreStatistics().getMessageSize().getTotalSize());
1: 
commit:d2bd152
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=60000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=60000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=60000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=60000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=60000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=60000)
commit:8a09b7e
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=30000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=30000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=30000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=30000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=30000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=30000)
/////////////////////////////////////////////////////////////////////////
1:                 prod.send(createMessage(i, session, AbstractPendingMessageCursorTest.maxMessageSize, publishedMessageSize));
commit:d27b192
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=10000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=10000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=10000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=10000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=10000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=10000)
commit:d1dface
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=200000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=200000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=200000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=20000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=20000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=20000)
commit:734fb7d
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker.region.cursors;
1: 
1: import java.io.IOException;
1: import java.net.URI;
1: import java.util.concurrent.atomic.AtomicLong;
1: 
1: import javax.jms.Connection;
1: import javax.jms.DeliveryMode;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: import javax.jms.Topic;
1: import javax.jms.TopicSession;
1: 
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.TransportConnector;
1: import org.apache.activemq.broker.region.Destination;
1: import org.apache.activemq.broker.region.DurableTopicSubscription;
1: import org.apache.activemq.broker.region.TopicSubscription;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.store.AbstractStoreStatTestSupport;
1: import org.apache.activemq.store.MessageStore;
1: import org.apache.activemq.util.SubscriptionKey;
1: import org.apache.activemq.util.Wait;
1: import org.apache.activemq.util.Wait.Condition;
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Test;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * This test checks that KahaDB properly sets the new storeMessageSize statistic.
1:  *
1:  * AMQ-5748
1:  *
1:  */
1: public abstract class AbstractPendingMessageCursorTest extends AbstractStoreStatTestSupport {
1:     protected static final Logger LOG = LoggerFactory
1:             .getLogger(AbstractPendingMessageCursorTest.class);
1: 
1: 
1:     protected BrokerService broker;
1:     protected URI brokerConnectURI;
1:     protected String defaultQueueName = "test.queue";
1:     protected String defaultTopicName = "test.topic";
1:     protected static int maxMessageSize = 1000;
1: 
1:     @Before
1:     public void startBroker() throws Exception {
1:         setUpBroker(true);
1:     }
1: 
1:     protected void setUpBroker(boolean clearDataDir) throws Exception {
1: 
1:         broker = new BrokerService();
1:         this.initPersistence(broker);
1:         //set up a transport
1:         TransportConnector connector = broker
1:                 .addConnector(new TransportConnector());
1:         connector.setUri(new URI("tcp://0.0.0.0:0"));
1:         connector.setName("tcp");
1: 
1:         PolicyEntry policy = new PolicyEntry();
1:         policy.setTopicPrefetch(100);
1:         policy.setDurableTopicPrefetch(100);
1:         PolicyMap pMap = new PolicyMap();
1:         pMap.setDefaultEntry(policy);
1:         broker.setDestinationPolicy(pMap);
1: 
1:         broker.start();
1:         broker.waitUntilStarted();
1:         brokerConnectURI = broker.getConnectorByName("tcp").getConnectUri();
1: 
1:     }
1: 
1:     @After
1:     public void stopBroker() throws Exception {
1:         broker.stop();
1:         broker.waitUntilStopped();
1:     }
1: 
1:     @Override
1:     protected BrokerService getBroker() {
1:         return this.broker;
1:     }
1: 
1:     @Override
1:     protected URI getBrokerConnectURI() {
1:         return this.brokerConnectURI;
1:     }
1: 
1:     protected abstract void initPersistence(BrokerService brokerService) throws IOException;
1: 
1:     @Test
1:     public void testQueueMessageSize() throws Exception {
1:         AtomicLong publishedMessageSize = new AtomicLong();
1: 
1:         org.apache.activemq.broker.region.Queue dest = publishTestQueueMessages(200, publishedMessageSize);
1:         verifyPendingStats(dest, 200, publishedMessageSize.get());
1:         verifyStoreStats(dest, 200, publishedMessageSize.get());
1:     }
1: 
1:     @Test
1:     public void testQueueBrowserMessageSize() throws Exception {
1:         AtomicLong publishedMessageSize = new AtomicLong();
1: 
1:         org.apache.activemq.broker.region.Queue dest = publishTestQueueMessages(200, publishedMessageSize);
1:         browseTestQueueMessages(dest.getName());
1:         verifyPendingStats(dest, 200, publishedMessageSize.get());
1:         verifyStoreStats(dest, 200, publishedMessageSize.get());
1:     }
1: 
1:     @Test
1:     public void testQueueMessageSizeNonPersistent() throws Exception {
1:         AtomicLong publishedMessageSize = new AtomicLong();
1: 
1:         org.apache.activemq.broker.region.Queue dest = publishTestQueueMessages(200,
1:                 DeliveryMode.NON_PERSISTENT, publishedMessageSize);
1:         verifyPendingStats(dest, 200, publishedMessageSize.get());
1:     }
1: 
1:     @Test
1:     public void testQueueMessageSizePersistentAndNonPersistent() throws Exception {
1:         AtomicLong publishedNonPersistentMessageSize = new AtomicLong();
1:         AtomicLong publishedMessageSize = new AtomicLong();
1: 
1:         org.apache.activemq.broker.region.Queue dest = publishTestQueueMessages(100,
1:                 DeliveryMode.PERSISTENT, publishedMessageSize);
1:         dest = publishTestQueueMessages(100,
1:                 DeliveryMode.NON_PERSISTENT, publishedNonPersistentMessageSize);
1:         verifyPendingStats(dest, 200, publishedMessageSize.get() + publishedNonPersistentMessageSize.get());
1:         verifyStoreStats(dest, 100, publishedMessageSize.get());
1:     }
1: 
1:     @Test
1:     public void testQueueMessageSizeAfterConsumption() throws Exception {
1:         AtomicLong publishedMessageSize = new AtomicLong();
1: 
1:         org.apache.activemq.broker.region.Queue dest = publishTestQueueMessages(200, publishedMessageSize);
1:         verifyPendingStats(dest, 200, publishedMessageSize.get());
1: 
1:         consumeTestQueueMessages();
1: 
1:         verifyPendingStats(dest, 0, 0);
1:         verifyStoreStats(dest, 0, 0);
1:     }
1: 
1:     @Test
1:     public void testQueueMessageSizeAfterConsumptionNonPersistent() throws Exception {
1:         AtomicLong publishedMessageSize = new AtomicLong();
1: 
1:         org.apache.activemq.broker.region.Queue dest = publishTestQueueMessages(200, DeliveryMode.NON_PERSISTENT, publishedMessageSize);
1:         verifyPendingStats(dest, 200, publishedMessageSize.get());
1: 
1:         consumeTestQueueMessages();
1: 
1:         verifyPendingStats(dest, 0, 0);
1:         verifyStoreStats(dest, 0, 0);
1:     }
1: 
0:     @Test(timeout=100000)
1:     public void testTopicMessageSize() throws Exception {
1:         AtomicLong publishedMessageSize = new AtomicLong();
1: 
1:         Connection connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:         connection.setClientID("clientId");
1:         connection.start();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageConsumer consumer = session.createConsumer(new ActiveMQTopic(this.defaultTopicName));
1: 
1:         org.apache.activemq.broker.region.Topic dest = publishTestTopicMessages(200, publishedMessageSize);
1: 
1:         //verify the count and size - there is a prefetch of 100 so only 100 are pending and 100
1:         //are dispatched because we have an active consumer online
1:         //verify that the size is greater than 100 messages times the minimum size of 100
1:         verifyPendingStats(dest, 100, 100 * 100);
1: 
1:         //consume all messages
1:         consumeTestMessages(consumer, 200);
1: 
1:         //All messages should now be gone
1:         verifyPendingStats(dest, 0, 0);
1: 
1:         connection.close();
1:     }
1: 
0:     @Test(timeout=100000)
1:     public void testTopicNonPersistentMessageSize() throws Exception {
1:         AtomicLong publishedMessageSize = new AtomicLong();
1: 
1:         Connection connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:         connection.setClientID("clientId");
1:         connection.start();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageConsumer consumer = session.createConsumer(new ActiveMQTopic(this.defaultTopicName));
1: 
1:         org.apache.activemq.broker.region.Topic dest = publishTestTopicMessages(200,
1:                 DeliveryMode.NON_PERSISTENT, publishedMessageSize);
1: 
1:         //verify the count and size - there is a prefetch of 100 so only 100 are pending and 100
1:         //are dispatched because we have an active consumer online
1:         //verify the size is at least as big as 100 messages times the minimum of 100 size
1:         verifyPendingStats(dest, 100, 100 * 100);
1: 
1:         //consume all messages
1:         consumeTestMessages(consumer, 200);
1: 
1:         //All messages should now be gone
1:         verifyPendingStats(dest, 0, 0);
1: 
1:         connection.close();
1:     }
1: 
0:     @Test(timeout=100000)
1:     public void testTopicPersistentAndNonPersistentMessageSize() throws Exception {
1:         AtomicLong publishedMessageSize = new AtomicLong();
1: 
1:         Connection connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:         connection.setClientID("clientId");
1:         connection.start();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageConsumer consumer = session.createConsumer(new ActiveMQTopic(this.defaultTopicName));
1: 
1:         org.apache.activemq.broker.region.Topic dest = publishTestTopicMessages(100,
1:                 DeliveryMode.NON_PERSISTENT, publishedMessageSize);
1: 
1:         dest = publishTestTopicMessages(100, DeliveryMode.PERSISTENT, publishedMessageSize);
1: 
1:         //verify the count and size - there is a prefetch of 100 so only 100 are pending and 100
1:         //are dispatched because we have an active consumer online
1:       //verify the size is at least as big as 100 messages times the minimum of 100 size
1:         verifyPendingStats(dest, 100, 100 * 100);
1: 
1:         //consume all messages
1:         consumeTestMessages(consumer, 200);
1: 
1:         //All messages should now be gone
1:         verifyPendingStats(dest, 0, 0);
1: 
1:         connection.close();
1:     }
1: 
0:     @Test(timeout=10000)
1:     public void testMessageSizeOneDurable() throws Exception {
1:         AtomicLong publishedMessageSize = new AtomicLong();
1:         Connection connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:         connection.setClientID("clientId");
1:         connection.start();
1: 
1:         SubscriptionKey subKey = new SubscriptionKey("clientId", "sub1");
1:         org.apache.activemq.broker.region.Topic dest = publishTestMessagesDurable(connection,
1:                 new String[] {"sub1"}, 200, publishedMessageSize, DeliveryMode.PERSISTENT);
1: 
1:         //verify the count and size - durable is offline so all 200 should be pending since none are in prefetch
1:         verifyPendingStats(dest, subKey, 200, publishedMessageSize.get());
1:         verifyStoreStats(dest, 200, publishedMessageSize.get());
1: 
1:         //consume all messages
1:         consumeDurableTestMessages(connection, "sub1", 200, publishedMessageSize);
1: 
1:         //All messages should now be gone
1:         verifyPendingStats(dest, subKey, 0, 0);
1:         verifyStoreStats(dest, 0, 0);
1: 
1:         connection.close();
1:     }
1: 
0:     @Test(timeout=10000)
1:     public void testMessageSizeOneDurablePartialConsumption() throws Exception {
1:         AtomicLong publishedMessageSize = new AtomicLong();
1: 
1:         Connection connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:         connection.setClientID("clientId");
1:         connection.start();
1: 
1:         SubscriptionKey subKey = new SubscriptionKey("clientId", "sub1");
1:         org.apache.activemq.broker.region.Topic dest = publishTestMessagesDurable(
1:                 connection, new String[] {"sub1"}, 200, publishedMessageSize, DeliveryMode.PERSISTENT);
1: 
1:         //verify the count and size - durable is offline so all 200 should be pending since none are in prefetch
1:         verifyPendingStats(dest, subKey, 200, publishedMessageSize.get());
1:         verifyStoreStats(dest, 200, publishedMessageSize.get());
1: 
1:         //consume all messages
1:         consumeDurableTestMessages(connection, "sub1", 50, publishedMessageSize);
1: 
1:         //150 should be left
1:         verifyPendingStats(dest, subKey, 150, publishedMessageSize.get());
1:         verifyStoreStats(dest, 150, publishedMessageSize.get());
1: 
1:         connection.close();
1:     }
1: 
0:     @Test(timeout=10000)
1:     public void testMessageSizeTwoDurables() throws Exception {
1:         AtomicLong publishedMessageSize = new AtomicLong();
1: 
1:         Connection connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:         connection.setClientID("clientId");
1:         connection.start();
1: 
1:         org.apache.activemq.broker.region.Topic dest =
1:                 publishTestMessagesDurable(connection, new String[] {"sub1", "sub2"}, 200,
1:                         publishedMessageSize, DeliveryMode.PERSISTENT);
1: 
1:         //verify the count and size
1:         SubscriptionKey subKey = new SubscriptionKey("clientId", "sub1");
1:         verifyPendingStats(dest, subKey, 200, publishedMessageSize.get());
1: 
1:         //consume messages just for sub1
1:         consumeDurableTestMessages(connection, "sub1", 200, publishedMessageSize);
1: 
1:         //There is still a durable that hasn't consumed so the messages should exist
1:         SubscriptionKey subKey2 = new SubscriptionKey("clientId", "sub2");
1:         verifyPendingStats(dest, subKey, 0, 0);
1:         verifyPendingStats(dest, subKey2, 200, publishedMessageSize.get());
1:         verifyStoreStats(dest, 200, publishedMessageSize.get());
1: 
1:         connection.stop();
1:     }
1: 
1: 
1:     protected void verifyPendingStats(final org.apache.activemq.broker.region.Queue queue,
1:             final int count, final long minimumSize) throws Exception {
1:         this.verifyPendingStats(queue, count, minimumSize, count, minimumSize);
1:     }
1: 
1:     protected void verifyPendingStats(final org.apache.activemq.broker.region.Queue queue,
1:             final int count, final long minimumSize, final int storeCount, final long minimumStoreSize) throws Exception {
1: 
0:         Wait.waitFor(new Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return queue.getPendingMessageCount() == count;
1:             }
0:         });
1: 
1:         verifySize(count, new MessageSizeCalculator() {
1:             @Override
1:             public long getMessageSize() throws Exception {
1:                 return queue.getPendingMessageSize();
1:             }
1:         }, minimumSize);
1:     }
1: 
1:     //For a non-durable there won't necessarily be a message store
1:     protected void verifyPendingStats(org.apache.activemq.broker.region.Topic topic,
1:             final int count, final long minimumSize) throws Exception {
1: 
1:         final TopicSubscription sub = (TopicSubscription) topic.getConsumers().get(0);
1: 
0:         Wait.waitFor(new Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return sub.getPendingQueueSize() == count;
1:             }
0:         });
1: 
1:         verifySize(count, new MessageSizeCalculator() {
1:             @Override
1:             public long getMessageSize() throws Exception {
1:                 return sub.getPendingMessageSize();
1:             }
1:         }, minimumSize);
1:     }
1: 
1:     protected void verifyPendingStats(org.apache.activemq.broker.region.Topic topic, SubscriptionKey subKey,
1:             final int count, final long minimumSize) throws Exception {
1: 
1:         final DurableTopicSubscription sub = topic.getDurableTopicSubs().get(subKey);
1: 
1:         //verify message count
0:         Wait.waitFor(new Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return sub.getPendingQueueSize() == count;
1:             }
0:         });
1: 
1:         //verify message size
1:         verifySize(count, new MessageSizeCalculator() {
1:             @Override
1:             public long getMessageSize() throws Exception {
1:                 return sub.getPendingMessageSize();
1:             }
1:         }, minimumSize);
1:     }
1: 
1:     protected void verifyStoreStats(org.apache.activemq.broker.region.Destination dest,
1:             final int storeCount, final long minimumStoreSize) throws Exception {
1:         final MessageStore messageStore = dest.getMessageStore();
1: 
0:         Wait.waitFor(new Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return messageStore.getMessageCount() == storeCount;
1:             }
0:         });
1:         verifySize(storeCount, new MessageSizeCalculator() {
1:             @Override
1:             public long getMessageSize() throws Exception {
1:                 return messageStore.getMessageSize();
1:             }
1:         }, minimumStoreSize);
1: 
1:     }
1: 
1: 
1:     protected void verifySize(final int count, final MessageSizeCalculator messageSizeCalculator,
1:             final long minimumSize) throws Exception {
1:         if (count > 0) {
0:             Wait.waitFor(new Condition() {
1:                 @Override
1:                 public boolean isSatisified() throws Exception {
1:                     return messageSizeCalculator.getMessageSize() > minimumSize ;
1:                 }
0:             });
1:         } else {
0:             Wait.waitFor(new Condition() {
1:                 @Override
1:                 public boolean isSatisified() throws Exception {
1:                     return messageSizeCalculator.getMessageSize() == 0;
1:                 }
0:             });
1:         }
1:     }
1: 
1:     protected static interface MessageSizeCalculator {
1:         long getMessageSize() throws Exception;
1:     }
1: 
1: 
1:     protected Destination consumeTestMessages(MessageConsumer consumer, int size) throws Exception {
1:         return consumeTestMessages(consumer, size, defaultTopicName);
1:     }
1: 
1: 
1:     protected Destination consumeTestMessages(MessageConsumer consumer, int size, String topicName) throws Exception {
1:         // create a new queue
1:         final ActiveMQDestination activeMqTopic = new ActiveMQTopic(
1:                 topicName);
1: 
1:         Destination dest = broker.getDestination(activeMqTopic);
1: 
1:         //Topic topic = session.createTopic(topicName);
1: 
1:         try {
1:             for (int i = 0; i < size; i++) {
1:                 consumer.receive();
1:             }
1: 
1:         } finally {
1:             //session.close();
1:         }
1: 
1:         return dest;
1:     }
1: 
1:     protected Destination consumeDurableTestMessages(Connection connection, String sub, int size, AtomicLong publishedMessageSize) throws Exception {
1:         return consumeDurableTestMessages(connection, sub, size, defaultTopicName, publishedMessageSize);
1:     }
1: 
1:     protected org.apache.activemq.broker.region.Topic publishTestMessagesDurable(Connection connection,
1:             String[] subNames, int publishSize, AtomicLong publishedMessageSize, int deliveryMode) throws Exception {
1: 
1:         return publishTestMessagesDurable(connection, subNames, defaultTopicName,
1:                 publishSize, 0, AbstractStoreStatTestSupport.defaultMessageSize,
1:                 publishedMessageSize, false, deliveryMode);
1:     }
1: 
1:     protected org.apache.activemq.broker.region.Topic publishTestTopicMessages(int publishSize,
1:             AtomicLong publishedMessageSize) throws Exception {
1:         return publishTestTopicMessages(publishSize, DeliveryMode.PERSISTENT, publishedMessageSize);
1:     }
1: 
1:     protected org.apache.activemq.broker.region.Topic publishTestTopicMessages(int publishSize,
1:             int deliveryMode, AtomicLong publishedMessageSize) throws Exception {
1:         // create a new queue
1:         Connection connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:         connection.setClientID("clientId2");
1:         connection.start();
1: 
1:         final ActiveMQDestination activeMqTopic = new ActiveMQTopic(
1:                 defaultTopicName);
1: 
1:         org.apache.activemq.broker.region.Topic dest =
1:                 (org.apache.activemq.broker.region.Topic) broker.getDestination(activeMqTopic);
1: 
1:         // Start the connection
1:         Session session = connection.createSession(false,
1:                 TopicSession.AUTO_ACKNOWLEDGE);
1:         Topic topic = session.createTopic(defaultTopicName);
1: 
1:         try {
1:             // publish a bunch of non-persistent messages to fill up the temp
1:             // store
1:             MessageProducer prod = session.createProducer(topic);
1:             prod.setDeliveryMode(deliveryMode);
1:             for (int i = 0; i < publishSize; i++) {
0:                 prod.send(createMessage(session, AbstractPendingMessageCursorTest.maxMessageSize, publishedMessageSize));
1:             }
1: 
1:         } finally {
1:             connection.close();
1:         }
1: 
1:         return dest;
1:     }
1: 
1:     protected org.apache.activemq.broker.region.Queue publishTestQueueMessages(int count,
1:             AtomicLong publishedMessageSize) throws Exception {
1:         return publishTestQueueMessages(count, defaultQueueName, DeliveryMode.PERSISTENT,
1:                 AbstractPendingMessageCursorTest.maxMessageSize, publishedMessageSize);
1:     }
1: 
1:     protected org.apache.activemq.broker.region.Queue publishTestQueueMessages(int count, int deliveryMode,
1:             AtomicLong publishedMessageSize) throws Exception {
1:         return publishTestQueueMessages(count, defaultQueueName, deliveryMode,
1:                 AbstractPendingMessageCursorTest.maxMessageSize, publishedMessageSize);
1:     }
1: 
1:     protected Destination consumeTestQueueMessages() throws Exception {
1:         return consumeTestQueueMessages(defaultQueueName);
1:     }
1: 
1: }
============================================================================