1:9c2b1d2: /**
1:9c2b1d2:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:9c2b1d2:  * contributor license agreements.  See the NOTICE file distributed with
1:9c2b1d2:  * this work for additional information regarding copyright ownership.
1:9c2b1d2:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:9c2b1d2:  * (the "License"); you may not use this file except in compliance with
1:9c2b1d2:  * the License.  You may obtain a copy of the License at
1:9c2b1d2:  *
1:9c2b1d2:  *      http://www.apache.org/licenses/LICENSE-2.0
1:9c2b1d2:  *
1:9c2b1d2:  * Unless required by applicable law or agreed to in writing, software
1:9c2b1d2:  * distributed under the License is distributed on an "AS IS" BASIS,
1:9c2b1d2:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:9c2b1d2:  * See the License for the specific language governing permissions and
1:9c2b1d2:  * limitations under the License.
1:9c2b1d2:  */
1:9c2b1d2: 
1:9c2b1d2: package org.apache.activemq.broker.region.cursors;
1:9c2b1d2: 
1:9c2b1d2: import java.io.IOException;
1:9c2b1d2: import java.util.concurrent.Executors;
1:9c2b1d2: import java.util.concurrent.FutureTask;
1:9c2b1d2: import java.util.concurrent.atomic.AtomicLong;
1:9c2b1d2: import org.apache.activemq.broker.BrokerService;
1:9c2b1d2: import org.apache.activemq.broker.ConnectionContext;
1:9c2b1d2: import org.apache.activemq.broker.region.DestinationStatistics;
1:9c2b1d2: import org.apache.activemq.broker.region.MessageReference;
1:9c2b1d2: import org.apache.activemq.broker.region.Queue;
1:9c2b1d2: import org.apache.activemq.command.ActiveMQDestination;
1:9c2b1d2: import org.apache.activemq.command.ActiveMQQueue;
1:9c2b1d2: import org.apache.activemq.command.ActiveMQTextMessage;
1:9c2b1d2: import org.apache.activemq.command.ConsumerInfo;
1:9c2b1d2: import org.apache.activemq.command.Message;
1:9c2b1d2: import org.apache.activemq.command.MessageAck;
1:9c2b1d2: import org.apache.activemq.command.MessageId;
1:9c2b1d2: import org.apache.activemq.store.AbstractMessageStore;
1:9c2b1d2: import org.apache.activemq.store.MessageRecoveryListener;
1:9c2b1d2: import org.apache.activemq.usage.SystemUsage;
1:9c2b1d2: import org.junit.After;
1:9c2b1d2: import org.junit.Before;
1:9c2b1d2: import org.junit.Test;
1:9c2b1d2: import org.slf4j.Logger;
1:9c2b1d2: import org.slf4j.LoggerFactory;
1:9c2b1d2: 
1:9c2b1d2: 
1:9c2b1d2: import static org.junit.Assert.assertEquals;
1:9c2b1d2: import static org.junit.Assert.assertTrue;
1:9c2b1d2: 
1:9c2b1d2: public class StoreQueueCursorOrderTest {
1:9c2b1d2:     private static final Logger LOG = LoggerFactory.getLogger(StoreQueueCursorOrderTest.class);
1:9c2b1d2: 
1:9c2b1d2:     ActiveMQQueue destination = new ActiveMQQueue("queue-"
1:9c2b1d2:             + StoreQueueCursorOrderTest.class.getSimpleName());
1:9c2b1d2:     BrokerService brokerService;
1:9c2b1d2: 
1:9c2b1d2:     final static String mesageIdRoot = "11111:22222:0:";
1:9c2b1d2:     final int messageBytesSize = 1024;
1:9c2b1d2:     final String text = new String(new byte[messageBytesSize]);
1:9c2b1d2: 
1:9c2b1d2:     @Before
1:9c2b1d2:     public void setUp() throws Exception {
1:9c2b1d2:         brokerService = createBroker();
1:9c2b1d2:         brokerService.setUseJmx(false);
1:9c2b1d2:         brokerService.deleteAllMessages();
1:9c2b1d2:         brokerService.start();
1:9c2b1d2:     }
1:9c2b1d2: 
1:9c2b1d2:     protected BrokerService createBroker() throws Exception {
1:9c2b1d2:         return new BrokerService();
1:9c2b1d2:     }
1:9c2b1d2: 
1:9c2b1d2:     @After
1:9c2b1d2:     public void tearDown() throws Exception {
1:9c2b1d2:         brokerService.stop();
1:9c2b1d2:     }
1:9c2b1d2: 
1:9c2b1d2:     @Test
1:9c2b1d2:     public void tesBlockedFuture() throws Exception {
1:9c2b1d2:         final int count = 2;
1:9c2b1d2:         final Message[] messages = new Message[count];
1:9c2b1d2:         final TestMessageStore queueMessageStore = new TestMessageStore(messages, destination);
1:9c2b1d2:         final ConsumerInfo consumerInfo = new ConsumerInfo();
1:9c2b1d2:         final DestinationStatistics destinationStatistics = new DestinationStatistics();
1:9c2b1d2:         consumerInfo.setExclusive(true);
1:9c2b1d2: 
1:9c2b1d2:         final Queue queue = new Queue(brokerService, destination,
1:9c2b1d2:                 queueMessageStore, destinationStatistics, null);
1:9c2b1d2: 
1:9c2b1d2:         queueMessageStore.start();
1:9c2b1d2:         queueMessageStore.registerIndexListener(null);
1:9c2b1d2: 
1:13ec994:         QueueStorePrefetch underTest = new QueueStorePrefetch(queue, brokerService.getBroker());
1:9c2b1d2:         SystemUsage systemUsage = new SystemUsage();
1:9c2b1d2:         // ensure memory limit is reached
1:9c2b1d2:         systemUsage.getMemoryUsage().setLimit(messageBytesSize * 1);
1:9c2b1d2:         underTest.setSystemUsage(systemUsage);
1:9c2b1d2:         underTest.setEnableAudit(false);
1:9c2b1d2:         underTest.start();
1:9c2b1d2:         assertTrue("cache enabled", underTest.isUseCache() && underTest.isCacheEnabled());
1:9c2b1d2: 
1:9c2b1d2:         ActiveMQTextMessage msg = getMessage(0);
1:9c2b1d2:         messages[1] = msg;
1:9c2b1d2:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
1:9c2b1d2:         msg.setRecievedByDFBridge(true);
1:9c2b1d2:         FutureTask<Long> future = new FutureTask<Long>(new Runnable() {
1:9c2b1d2:             @Override
1:9c2b1d2:             public void run() {
1:9c2b1d2:             }
1:9c2b1d2:         }, 2l) {};
1:9c2b1d2:         msg.getMessageId().setFutureOrSequenceLong(future);
1:9c2b1d2:         underTest.addMessageLast(msg);
1:9c2b1d2: 
1:9c2b1d2:         assertTrue("cache enabled", underTest.isUseCache() && underTest.isCacheEnabled());
1:9c2b1d2: 
1:9c2b1d2:         // second message will flip the cache but will be stored before the future task
1:9c2b1d2:         msg = getMessage(1);
1:9c2b1d2:         messages[0] = msg;
1:9c2b1d2:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
2:9c2b1d2:         msg.getMessageId().setFutureOrSequenceLong(1l);
1:9c2b1d2:         underTest.addMessageLast(msg);
1:9c2b1d2: 
1:9c2b1d2: 
1:9c2b1d2:         assertTrue("cache is disabled as limit reached", !underTest.isCacheEnabled());
1:9c2b1d2:         assertEquals("setBatch unset", 0l, queueMessageStore.batch.get());
1:9c2b1d2: 
1:9c2b1d2:         int dequeueCount = 0;
1:9c2b1d2: 
1:9c2b1d2:         underTest.setMaxBatchSize(2);
1:9c2b1d2:         underTest.reset();
1:9c2b1d2:         while (underTest.hasNext() && dequeueCount < count) {
1:9c2b1d2:             MessageReference ref = underTest.next();
1:9c2b1d2:             ref.decrementReferenceCount();
1:9c2b1d2:             underTest.remove();
1:9c2b1d2:             LOG.info("Received message: {} with body: {}",
1:9c2b1d2:                      ref.getMessageId(), ((ActiveMQTextMessage)ref.getMessage()).getText());
1:9c2b1d2:             assertEquals(dequeueCount++, ref.getMessageId().getProducerSequenceId());
1:9c2b1d2:         }
1:9c2b1d2:         underTest.release();
1:9c2b1d2:         assertEquals(count, dequeueCount);
1:9c2b1d2:     }
1:a0ba0bf: 
1:9c2b1d2:     @Test
1:9c2b1d2:     public void testNoSetBatchWithUnOrderedFutureCurrentSync() throws Exception {
1:9c2b1d2:         final int count = 2;
1:9c2b1d2:         final Message[] messages = new Message[count];
1:9c2b1d2:         final TestMessageStore queueMessageStore = new TestMessageStore(messages, destination);
1:9c2b1d2:         final ConsumerInfo consumerInfo = new ConsumerInfo();
1:9c2b1d2:         final DestinationStatistics destinationStatistics = new DestinationStatistics();
1:9c2b1d2:         consumerInfo.setExclusive(true);
1:9c2b1d2: 
1:9c2b1d2:         final Queue queue = new Queue(brokerService, destination,
1:9c2b1d2:                 queueMessageStore, destinationStatistics, null);
1:9c2b1d2: 
1:9c2b1d2:         queueMessageStore.start();
1:9c2b1d2:         queueMessageStore.registerIndexListener(null);
1:9c2b1d2: 
1:13ec994:         QueueStorePrefetch underTest = new QueueStorePrefetch(queue, brokerService.getBroker());
1:9c2b1d2:         SystemUsage systemUsage = new SystemUsage();
1:9c2b1d2:         // ensure memory limit is reached
1:9c2b1d2:         systemUsage.getMemoryUsage().setLimit(messageBytesSize * 1);
1:9c2b1d2:         underTest.setSystemUsage(systemUsage);
1:9c2b1d2:         underTest.setEnableAudit(false);
1:9c2b1d2:         underTest.start();
1:9c2b1d2:         assertTrue("cache enabled", underTest.isUseCache() && underTest.isCacheEnabled());
1:9c2b1d2: 
1:9c2b1d2:         ActiveMQTextMessage msg = getMessage(0);
1:9c2b1d2:         messages[1] = msg;
1:9c2b1d2:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
1:9c2b1d2:         msg.setRecievedByDFBridge(true);
1:9c2b1d2:         final ActiveMQTextMessage msgRef = msg;
1:9c2b1d2:         FutureTask<Long> future = new FutureTask<Long>(new Runnable() {
1:9c2b1d2:             @Override
1:9c2b1d2:             public void run() {
1:9c2b1d2:                 msgRef.getMessageId().setFutureOrSequenceLong(1l);
1:9c2b1d2:             }
1:9c2b1d2:         }, 1l) {};
1:9c2b1d2:         msg.getMessageId().setFutureOrSequenceLong(future);
1:9c2b1d2:         Executors.newSingleThreadExecutor().submit(future);
1:9c2b1d2:         underTest.addMessageLast(msg);
1:9c2b1d2: 
1:9c2b1d2:         assertTrue("cache enabled", underTest.isUseCache() && underTest.isCacheEnabled());
1:9c2b1d2: 
1:9c2b1d2:         // second message will flip the cache but will be stored before the future task
1:9c2b1d2:         msg = getMessage(1);
1:9c2b1d2:         messages[0] = msg;
1:9c2b1d2:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
1:a0ba0bf:         msg.getMessageId().setFutureOrSequenceLong(0l);
1:9c2b1d2:         underTest.addMessageLast(msg);
1:9c2b1d2: 
1:9c2b1d2: 
1:9c2b1d2:         assertTrue("cache is disabled as limit reached", !underTest.isCacheEnabled());
1:9c2b1d2:         assertEquals("setBatch unset", 0l, queueMessageStore.batch.get());
1:9c2b1d2: 
1:9c2b1d2:         int dequeueCount = 0;
1:9c2b1d2: 
1:9c2b1d2:         underTest.setMaxBatchSize(2);
1:9c2b1d2:         underTest.reset();
1:9c2b1d2:         while (underTest.hasNext() && dequeueCount < count) {
1:9c2b1d2:             MessageReference ref = underTest.next();
1:9c2b1d2:             ref.decrementReferenceCount();
1:9c2b1d2:             underTest.remove();
1:9c2b1d2:             LOG.info("Received message: {} with body: {}",
1:9c2b1d2:                      ref.getMessageId(), ((ActiveMQTextMessage)ref.getMessage()).getText());
1:9c2b1d2:             assertEquals(dequeueCount++, ref.getMessageId().getProducerSequenceId());
1:9c2b1d2:         }
1:9c2b1d2:         underTest.release();
1:9c2b1d2:         assertEquals(count, dequeueCount);
1:9c2b1d2:     }
1:9c2b1d2: 
1:9c2b1d2:     @Test
1:9c2b1d2:     public void testSetBatchWithOrderedFutureCurrentFuture() throws Exception {
1:9c2b1d2:         final int count = 2;
1:9c2b1d2:         final Message[] messages = new Message[count];
1:9c2b1d2:         final TestMessageStore queueMessageStore = new TestMessageStore(messages, destination);
1:9c2b1d2:         final ConsumerInfo consumerInfo = new ConsumerInfo();
1:9c2b1d2:         final DestinationStatistics destinationStatistics = new DestinationStatistics();
1:9c2b1d2:         consumerInfo.setExclusive(true);
1:9c2b1d2: 
1:9c2b1d2:         final Queue queue = new Queue(brokerService, destination,
1:9c2b1d2:                 queueMessageStore, destinationStatistics, null);
1:9c2b1d2: 
1:9c2b1d2:         queueMessageStore.start();
1:9c2b1d2:         queueMessageStore.registerIndexListener(null);
1:9c2b1d2: 
1:13ec994:         QueueStorePrefetch underTest = new QueueStorePrefetch(queue, brokerService.getBroker());
1:9c2b1d2:         SystemUsage systemUsage = new SystemUsage();
1:9c2b1d2:         // ensure memory limit is reached
1:9c2b1d2:         systemUsage.getMemoryUsage().setLimit(messageBytesSize * 1);
1:9c2b1d2:         underTest.setSystemUsage(systemUsage);
1:9c2b1d2:         underTest.setEnableAudit(false);
1:9c2b1d2:         underTest.start();
1:9c2b1d2:         assertTrue("cache enabled", underTest.isUseCache() && underTest.isCacheEnabled());
1:9c2b1d2: 
1:9c2b1d2:         ActiveMQTextMessage msg = getMessage(0);
1:9c2b1d2:         messages[0] = msg;
1:9c2b1d2:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
1:9c2b1d2:         msg.setRecievedByDFBridge(true);
1:9c2b1d2:         final ActiveMQTextMessage msgRef = msg;
1:9c2b1d2:         FutureTask<Long> future = new FutureTask<Long>(new Runnable() {
1:9c2b1d2:             @Override
1:9c2b1d2:             public void run() {
1:9c2b1d2:                 msgRef.getMessageId().setFutureOrSequenceLong(0l);
1:9c2b1d2:             }
1:9c2b1d2:         }, 0l) {};
1:9c2b1d2:         msg.getMessageId().setFutureOrSequenceLong(future);
1:9c2b1d2:         Executors.newSingleThreadExecutor().submit(future);
1:9c2b1d2:         underTest.addMessageLast(msg);
1:9c2b1d2: 
1:9c2b1d2:         assertTrue("cache enabled", underTest.isUseCache() && underTest.isCacheEnabled());
1:9c2b1d2: 
1:9c2b1d2:         // second message will flip the cache but will be stored before the future task
1:9c2b1d2:         msg = getMessage(1);
1:9c2b1d2:         messages[1] = msg;
1:9c2b1d2:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
1:9c2b1d2:         msg.setRecievedByDFBridge(true);
1:9c2b1d2:         final ActiveMQTextMessage msgRe2f = msg;
1:9c2b1d2:         FutureTask<Long> future2 = new FutureTask<Long>(new Runnable() {
1:9c2b1d2:             @Override
1:9c2b1d2:             public void run() {
1:9c2b1d2:                 msgRe2f.getMessageId().setFutureOrSequenceLong(1l);
1:9c2b1d2:             }
1:9c2b1d2:         }, 1l) {};
1:9c2b1d2:         msg.getMessageId().setFutureOrSequenceLong(future2);
1:9c2b1d2:         Executors.newSingleThreadExecutor().submit(future2);
1:9c2b1d2:         underTest.addMessageLast(msg);
1:9c2b1d2: 
1:9c2b1d2: 
1:9c2b1d2:         assertTrue("cache is disabled as limit reached", !underTest.isCacheEnabled());
1:9c2b1d2:         assertEquals("setBatch set", 1l, queueMessageStore.batch.get());
1:9c2b1d2: 
1:9c2b1d2:         int dequeueCount = 0;
1:9c2b1d2: 
1:9c2b1d2:         underTest.setMaxBatchSize(2);
1:9c2b1d2:         underTest.reset();
1:9c2b1d2:         while (underTest.hasNext() && dequeueCount < count) {
1:9c2b1d2:             MessageReference ref = underTest.next();
1:9c2b1d2:             ref.decrementReferenceCount();
1:9c2b1d2:             underTest.remove();
1:9c2b1d2:             LOG.info("Received message: {} with body: {}",
1:9c2b1d2:                      ref.getMessageId(), ((ActiveMQTextMessage)ref.getMessage()).getText());
1:9c2b1d2:             assertEquals(dequeueCount++, ref.getMessageId().getProducerSequenceId());
1:9c2b1d2:         }
1:9c2b1d2:         underTest.release();
1:9c2b1d2:         assertEquals(count, dequeueCount);
1:9c2b1d2:     }
1:9c2b1d2: 
1:9c2b1d2:     @Test
1:9c2b1d2:     public void testSetBatchWithFuture() throws Exception {
1:9c2b1d2:         final int count = 4;
1:9c2b1d2:         final Message[] messages = new Message[count];
1:9c2b1d2:         final TestMessageStore queueMessageStore = new TestMessageStore(messages, destination);
1:9c2b1d2:         final ConsumerInfo consumerInfo = new ConsumerInfo();
1:9c2b1d2:         final DestinationStatistics destinationStatistics = new DestinationStatistics();
1:9c2b1d2:         consumerInfo.setExclusive(true);
1:9c2b1d2: 
1:9c2b1d2:         final Queue queue = new Queue(brokerService, destination,
1:9c2b1d2:                 queueMessageStore, destinationStatistics, null);
1:9c2b1d2: 
1:9c2b1d2:         queueMessageStore.start();
1:9c2b1d2:         queueMessageStore.registerIndexListener(null);
1:9c2b1d2: 
1:13ec994:         QueueStorePrefetch underTest = new QueueStorePrefetch(queue, brokerService.getBroker());
1:9c2b1d2:         SystemUsage systemUsage = new SystemUsage();
1:9c2b1d2:         // ensure memory limit is reached
1:9c2b1d2:         systemUsage.getMemoryUsage().setLimit(messageBytesSize * (count + 6));
1:9c2b1d2:         underTest.setSystemUsage(systemUsage);
1:9c2b1d2:         underTest.setEnableAudit(false);
1:9c2b1d2:         underTest.start();
1:9c2b1d2:         assertTrue("cache enabled", underTest.isUseCache() && underTest.isCacheEnabled());
1:9c2b1d2: 
1:9c2b1d2:         ActiveMQTextMessage msg = getMessage(0);
1:9c2b1d2:         messages[0] = msg;
1:9c2b1d2:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
1:9c2b1d2:         msg.setRecievedByDFBridge(true);
1:9c2b1d2:         final ActiveMQTextMessage msgRef = msg;
1:9c2b1d2:         FutureTask<Long> future0 = new FutureTask<Long>(new Runnable() {
1:9c2b1d2:             @Override
1:9c2b1d2:             public void run() {
1:9c2b1d2:                 msgRef.getMessageId().setFutureOrSequenceLong(0l);
1:9c2b1d2:             }
1:9c2b1d2:         }, 0l) {};
1:9c2b1d2:         msg.getMessageId().setFutureOrSequenceLong(future0);
1:9c2b1d2:         underTest.addMessageLast(msg);
1:9c2b1d2:         Executors.newSingleThreadExecutor().submit(future0);
1:9c2b1d2: 
1:9c2b1d2: 
1:9c2b1d2:         msg = getMessage(1);
1:9c2b1d2:         messages[3] = msg;
1:9c2b1d2:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
1:9c2b1d2:         msg.setRecievedByDFBridge(true);
1:9c2b1d2:         final ActiveMQTextMessage msgRef1 = msg;
1:9c2b1d2:         FutureTask<Long> future1 = new FutureTask<Long>(new Runnable() {
1:9c2b1d2:             @Override
1:9c2b1d2:             public void run() {
1:9c2b1d2:                 msgRef1.getMessageId().setFutureOrSequenceLong(3l);
1:9c2b1d2:             }
1:9c2b1d2:         }, 3l) {};
1:9c2b1d2:         msg.getMessageId().setFutureOrSequenceLong(future1);
1:9c2b1d2:         underTest.addMessageLast(msg);
1:9c2b1d2: 
1:9c2b1d2: 
1:9c2b1d2:         msg = getMessage(2);
1:9c2b1d2:         messages[1] = msg;
1:9c2b1d2:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
1:9c2b1d2:         msg.getMessageId().setFutureOrSequenceLong(1l);
1:9c2b1d2:         underTest.addMessageLast(msg);
1:9c2b1d2: 
1:9c2b1d2:         assertTrue("cache enabled", underTest.isUseCache() && underTest.isCacheEnabled());
1:9c2b1d2: 
1:9c2b1d2:         // out of order future
1:9c2b1d2:         Executors.newSingleThreadExecutor().submit(future1);
1:9c2b1d2: 
1:9c2b1d2:         // sync add to flip cache
1:9c2b1d2:         msg = getMessage(3);
1:9c2b1d2:         messages[2] = msg;
1:9c2b1d2:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
1:a0ba0bf:         msg.getMessageId().setFutureOrSequenceLong(2l);
1:9c2b1d2:         underTest.addMessageLast(msg);
1:9c2b1d2: 
1:9c2b1d2: 
1:9c2b1d2:         assertTrue("cache is disabled as limit reached", !underTest.isCacheEnabled());
1:9c2b1d2:         assertEquals("setBatch set", 2l, queueMessageStore.batch.get());
1:9c2b1d2: 
1:9c2b1d2:         int dequeueCount = 0;
1:9c2b1d2: 
1:9c2b1d2:         underTest.setMaxBatchSize(count);
1:9c2b1d2:         underTest.reset();
1:9c2b1d2:         while (underTest.hasNext() && dequeueCount < count) {
1:9c2b1d2:             MessageReference ref = underTest.next();
1:9c2b1d2:             ref.decrementReferenceCount();
1:9c2b1d2:             underTest.remove();
1:9c2b1d2:             LOG.info("Received message: {} with body: {}",
1:9c2b1d2:                      ref.getMessageId(), ((ActiveMQTextMessage)ref.getMessage()).getText());
1:9c2b1d2:             assertEquals(dequeueCount++, ref.getMessageId().getProducerSequenceId());
1:9c2b1d2:         }
1:9c2b1d2:         underTest.release();
1:9c2b1d2:         assertEquals(count, dequeueCount);
1:9c2b1d2: 
1:a0ba0bf:         msg = getMessage(4);
1:a0ba0bf:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
1:a0ba0bf:         msg.getMessageId().setFutureOrSequenceLong(4l);
1:a0ba0bf:         underTest.addMessageLast(msg);
1:a0ba0bf: 
1:a0ba0bf:         assertTrue("cache enabled on empty store",  underTest.isCacheEnabled());
1:a0ba0bf: 
1:9c2b1d2:     }
1:9c2b1d2: 
1:9c2b1d2:     @Test
1:9c2b1d2:     public void testSetBatch() throws Exception {
1:9c2b1d2:         final int count = 3;
1:9c2b1d2:         final Message[] messages = new Message[count];
1:9c2b1d2:         final TestMessageStore queueMessageStore = new TestMessageStore(messages, destination);
1:9c2b1d2:         final ConsumerInfo consumerInfo = new ConsumerInfo();
1:9c2b1d2:         final DestinationStatistics destinationStatistics = new DestinationStatistics();
1:9c2b1d2:         consumerInfo.setExclusive(true);
1:9c2b1d2: 
1:9c2b1d2:         final Queue queue = new Queue(brokerService, destination,
1:9c2b1d2:                 queueMessageStore, destinationStatistics, null);
1:9c2b1d2: 
1:9c2b1d2:         queueMessageStore.start();
1:9c2b1d2:         queueMessageStore.registerIndexListener(null);
1:9c2b1d2: 
1:13ec994:         QueueStorePrefetch underTest = new QueueStorePrefetch(queue, brokerService.getBroker());
1:9c2b1d2:         SystemUsage systemUsage = new SystemUsage();
1:9c2b1d2:         // ensure memory limit is reached
1:9c2b1d2:         systemUsage.getMemoryUsage().setLimit(messageBytesSize * 5);
1:9c2b1d2:         underTest.setSystemUsage(systemUsage);
1:9c2b1d2:         underTest.setEnableAudit(false);
1:9c2b1d2:         underTest.start();
1:9c2b1d2:         assertTrue("cache enabled", underTest.isUseCache() && underTest.isCacheEnabled());
1:9c2b1d2: 
1:9c2b1d2: 
1:9c2b1d2:         ActiveMQTextMessage msg = getMessage(0);
1:9c2b1d2:         messages[0] = msg;
1:9c2b1d2:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
1:9c2b1d2:         msg.getMessageId().setFutureOrSequenceLong(0l);
1:9c2b1d2:         underTest.addMessageLast(msg);
1:9c2b1d2: 
1:9c2b1d2:         msg = getMessage(1);
1:9c2b1d2:         messages[1] = msg;
1:9c2b1d2:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
1:9c2b1d2:         msg.getMessageId().setFutureOrSequenceLong(1l);
1:9c2b1d2:         underTest.addMessageLast(msg);
1:9c2b1d2: 
1:9c2b1d2:         assertTrue("cache enabled", underTest.isUseCache() && underTest.isCacheEnabled());
1:9c2b1d2: 
1:9c2b1d2:         msg = getMessage(2);
1:9c2b1d2:         messages[2] = msg;
1:9c2b1d2:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
1:9c2b1d2:         msg.getMessageId().setFutureOrSequenceLong(2l);
1:9c2b1d2:         underTest.addMessageLast(msg);
1:9c2b1d2: 
1:9c2b1d2: 
1:9c2b1d2:         assertTrue("cache is disabled as limit reached", !underTest.isCacheEnabled());
1:9c2b1d2:         assertEquals("setBatch set", 2l, queueMessageStore.batch.get());
1:9c2b1d2: 
1:9c2b1d2:         int dequeueCount = 0;
1:9c2b1d2: 
1:9c2b1d2:         underTest.setMaxBatchSize(2);
1:9c2b1d2:         underTest.reset();
1:9c2b1d2:         while (underTest.hasNext() && dequeueCount < count) {
1:9c2b1d2:             MessageReference ref = underTest.next();
1:9c2b1d2:             ref.decrementReferenceCount();
1:9c2b1d2:             underTest.remove();
1:9c2b1d2:             LOG.info("Received message: {} with body: {}",
1:9c2b1d2:                      ref.getMessageId(), ((ActiveMQTextMessage)ref.getMessage()).getText());
1:9c2b1d2:             assertEquals(dequeueCount++, ref.getMessageId().getProducerSequenceId());
1:9c2b1d2:         }
1:9c2b1d2:         underTest.release();
1:9c2b1d2:         assertEquals(count, dequeueCount);
1:9c2b1d2:     }
1:9c2b1d2: 
1:9c2b1d2:     private ActiveMQTextMessage getMessage(int i) throws Exception {
1:9c2b1d2:         ActiveMQTextMessage message = new ActiveMQTextMessage();
1:9c2b1d2:         MessageId id = new MessageId(mesageIdRoot + i);
1:9c2b1d2:         id.setBrokerSequenceId(i);
1:9c2b1d2:         id.setProducerSequenceId(i);
1:9c2b1d2:         message.setMessageId(id);
1:9c2b1d2:         message.setDestination(destination);
1:9c2b1d2:         message.setPersistent(true);
1:9c2b1d2:         message.setResponseRequired(true);
1:9c2b1d2:         message.setText("Msg:" + i + " " + text);
1:9c2b1d2:         assertEquals(message.getMessageId().getProducerSequenceId(), i);
1:9c2b1d2:         return message;
1:9c2b1d2:     }
1:9c2b1d2: 
1:9c2b1d2:     class TestMessageStore extends AbstractMessageStore {
1:9c2b1d2:         final Message[] messages;
1:9c2b1d2:         public AtomicLong batch = new AtomicLong();
1:9c2b1d2: 
1:9c2b1d2:         public TestMessageStore(Message[] messages, ActiveMQDestination dest) {
1:9c2b1d2:             super(dest);
1:9c2b1d2:             this.messages = messages;
1:9c2b1d2:         }
1:9c2b1d2: 
1:9c2b1d2:         @Override
1:9c2b1d2:         public void addMessage(ConnectionContext context, Message message) throws IOException {
1:9c2b1d2: 
1:9c2b1d2:         }
1:9c2b1d2: 
1:9c2b1d2:         @Override
1:9c2b1d2:         public Message getMessage(MessageId identity) throws IOException {
1:9c2b1d2:             return null;
1:9c2b1d2:         }
1:9c2b1d2: 
1:9c2b1d2:         @Override
1:9c2b1d2:         public void removeMessage(ConnectionContext context, MessageAck ack) throws IOException {
1:9c2b1d2: 
1:9c2b1d2:         }
1:9c2b1d2: 
1:9c2b1d2:         @Override
1:9c2b1d2:         public void removeAllMessages(ConnectionContext context) throws IOException {
1:9c2b1d2: 
1:9c2b1d2:         }
1:9c2b1d2: 
1:9c2b1d2:         @Override
1:9c2b1d2:         public void recover(MessageRecoveryListener container) throws Exception {
1:9c2b1d2: 
1:9c2b1d2:         }
1:9c2b1d2: 
1:9c2b1d2:         @Override
1:9c2b1d2:         public void resetBatching() {
1:9c2b1d2: 
1:9c2b1d2:         }
1:9c2b1d2:         @Override
1:9c2b1d2:         public void recoverNextMessages(int maxReturned, MessageRecoveryListener listener) throws Exception {
1:9c2b1d2:             for (int i=batch.intValue();i<messages.length;i++) {
1:9c2b1d2:                 LOG.info("recovered index:" + i);
1:9c2b1d2:                 listener.recoverMessage(messages[i]);
1:9c2b1d2:             }
1:9c2b1d2:         }
1:9c2b1d2: 
1:9c2b1d2:         @Override
1:9c2b1d2:         public void setBatch(MessageId message) {
1:9c2b1d2:             batch.set((Long)message.getFutureOrSequenceLong());
1:9c2b1d2:             batch.incrementAndGet();
1:9c2b1d2:         }
1:9c2b1d2: 
1:9c2b1d2:         @Override
1:785b16b:         public void recoverMessageStoreStatistics() throws IOException {
1:785b16b:             this.getMessageStoreStatistics().reset();
1:9c2b1d2:         }
1:9c2b1d2: 
1:9c2b1d2:     }
1:9c2b1d2: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:a0ba0bf
/////////////////////////////////////////////////////////////////////////
1:         msg.getMessageId().setFutureOrSequenceLong(0l);
/////////////////////////////////////////////////////////////////////////
1:         msg.getMessageId().setFutureOrSequenceLong(2l);
/////////////////////////////////////////////////////////////////////////
1: 
1:         msg = getMessage(4);
1:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
1:         msg.getMessageId().setFutureOrSequenceLong(4l);
1:         underTest.addMessageLast(msg);
1: 
1:         assertTrue("cache enabled on empty store",  underTest.isCacheEnabled());
1: 
commit:13ec994
/////////////////////////////////////////////////////////////////////////
1:         QueueStorePrefetch underTest = new QueueStorePrefetch(queue, brokerService.getBroker());
/////////////////////////////////////////////////////////////////////////
1:         QueueStorePrefetch underTest = new QueueStorePrefetch(queue, brokerService.getBroker());
/////////////////////////////////////////////////////////////////////////
1:         QueueStorePrefetch underTest = new QueueStorePrefetch(queue, brokerService.getBroker());
/////////////////////////////////////////////////////////////////////////
1:         QueueStorePrefetch underTest = new QueueStorePrefetch(queue, brokerService.getBroker());
/////////////////////////////////////////////////////////////////////////
1:         QueueStorePrefetch underTest = new QueueStorePrefetch(queue, brokerService.getBroker());
commit:d8cf54b
/////////////////////////////////////////////////////////////////////////
0:         QueueStorePrefetch underTest = new QueueStorePrefetch(queue);
/////////////////////////////////////////////////////////////////////////
0:         QueueStorePrefetch underTest = new QueueStorePrefetch(queue);
/////////////////////////////////////////////////////////////////////////
0:         QueueStorePrefetch underTest = new QueueStorePrefetch(queue);
/////////////////////////////////////////////////////////////////////////
0:         QueueStorePrefetch underTest = new QueueStorePrefetch(queue);
/////////////////////////////////////////////////////////////////////////
0:         QueueStorePrefetch underTest = new QueueStorePrefetch(queue);
commit:9c2b1d2
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.activemq.broker.region.cursors;
1: 
1: import java.io.IOException;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.FutureTask;
1: import java.util.concurrent.atomic.AtomicLong;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.broker.region.DestinationStatistics;
1: import org.apache.activemq.broker.region.MessageReference;
1: import org.apache.activemq.broker.region.Queue;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.command.ActiveMQTextMessage;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.store.AbstractMessageStore;
1: import org.apache.activemq.store.MessageRecoveryListener;
1: import org.apache.activemq.usage.SystemUsage;
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Test;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: 
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertTrue;
1: 
1: public class StoreQueueCursorOrderTest {
1:     private static final Logger LOG = LoggerFactory.getLogger(StoreQueueCursorOrderTest.class);
1: 
1:     ActiveMQQueue destination = new ActiveMQQueue("queue-"
1:             + StoreQueueCursorOrderTest.class.getSimpleName());
1:     BrokerService brokerService;
1: 
1:     final static String mesageIdRoot = "11111:22222:0:";
1:     final int messageBytesSize = 1024;
1:     final String text = new String(new byte[messageBytesSize]);
1: 
1:     @Before
1:     public void setUp() throws Exception {
1:         brokerService = createBroker();
1:         brokerService.setUseJmx(false);
1:         brokerService.deleteAllMessages();
1:         brokerService.start();
1:     }
1: 
1:     protected BrokerService createBroker() throws Exception {
1:         return new BrokerService();
1:     }
1: 
1:     @After
1:     public void tearDown() throws Exception {
1:         brokerService.stop();
1:     }
1: 
1:     @Test
1:     public void tesBlockedFuture() throws Exception {
1:         final int count = 2;
1:         final Message[] messages = new Message[count];
1:         final TestMessageStore queueMessageStore = new TestMessageStore(messages, destination);
1:         final ConsumerInfo consumerInfo = new ConsumerInfo();
1:         final DestinationStatistics destinationStatistics = new DestinationStatistics();
1:         consumerInfo.setExclusive(true);
1: 
1:         final Queue queue = new Queue(brokerService, destination,
1:                 queueMessageStore, destinationStatistics, null);
1: 
1:         queueMessageStore.start();
1:         queueMessageStore.registerIndexListener(null);
1: 
0:         QueueStorePrefetch underTest = new QueueStorePrefetch(queue, brokerService.getBroker());
1:         SystemUsage systemUsage = new SystemUsage();
1:         // ensure memory limit is reached
1:         systemUsage.getMemoryUsage().setLimit(messageBytesSize * 1);
1:         underTest.setSystemUsage(systemUsage);
1:         underTest.setEnableAudit(false);
1:         underTest.start();
1:         assertTrue("cache enabled", underTest.isUseCache() && underTest.isCacheEnabled());
1: 
1:         ActiveMQTextMessage msg = getMessage(0);
1:         messages[1] = msg;
1:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
1:         msg.setRecievedByDFBridge(true);
1:         FutureTask<Long> future = new FutureTask<Long>(new Runnable() {
1:             @Override
1:             public void run() {
1:             }
1:         }, 2l) {};
1:         msg.getMessageId().setFutureOrSequenceLong(future);
1:         underTest.addMessageLast(msg);
1: 
1:         assertTrue("cache enabled", underTest.isUseCache() && underTest.isCacheEnabled());
1: 
1:         // second message will flip the cache but will be stored before the future task
1:         msg = getMessage(1);
1:         messages[0] = msg;
1:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
1:         msg.getMessageId().setFutureOrSequenceLong(1l);
1:         underTest.addMessageLast(msg);
1: 
1: 
1:         assertTrue("cache is disabled as limit reached", !underTest.isCacheEnabled());
1:         assertEquals("setBatch unset", 0l, queueMessageStore.batch.get());
1: 
1:         int dequeueCount = 0;
1: 
1:         underTest.setMaxBatchSize(2);
1:         underTest.reset();
1:         while (underTest.hasNext() && dequeueCount < count) {
1:             MessageReference ref = underTest.next();
1:             ref.decrementReferenceCount();
1:             underTest.remove();
1:             LOG.info("Received message: {} with body: {}",
1:                      ref.getMessageId(), ((ActiveMQTextMessage)ref.getMessage()).getText());
1:             assertEquals(dequeueCount++, ref.getMessageId().getProducerSequenceId());
1:         }
1:         underTest.release();
1:         assertEquals(count, dequeueCount);
1:     }
1: 
1:     @Test
1:     public void testNoSetBatchWithUnOrderedFutureCurrentSync() throws Exception {
1:         final int count = 2;
1:         final Message[] messages = new Message[count];
1:         final TestMessageStore queueMessageStore = new TestMessageStore(messages, destination);
1:         final ConsumerInfo consumerInfo = new ConsumerInfo();
1:         final DestinationStatistics destinationStatistics = new DestinationStatistics();
1:         consumerInfo.setExclusive(true);
1: 
1:         final Queue queue = new Queue(brokerService, destination,
1:                 queueMessageStore, destinationStatistics, null);
1: 
1:         queueMessageStore.start();
1:         queueMessageStore.registerIndexListener(null);
1: 
0:         QueueStorePrefetch underTest = new QueueStorePrefetch(queue, brokerService.getBroker());
1:         SystemUsage systemUsage = new SystemUsage();
1:         // ensure memory limit is reached
1:         systemUsage.getMemoryUsage().setLimit(messageBytesSize * 1);
1:         underTest.setSystemUsage(systemUsage);
1:         underTest.setEnableAudit(false);
1:         underTest.start();
1:         assertTrue("cache enabled", underTest.isUseCache() && underTest.isCacheEnabled());
1: 
1:         ActiveMQTextMessage msg = getMessage(0);
1:         messages[1] = msg;
1:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
1:         msg.setRecievedByDFBridge(true);
1:         final ActiveMQTextMessage msgRef = msg;
1:         FutureTask<Long> future = new FutureTask<Long>(new Runnable() {
1:             @Override
1:             public void run() {
1:                 msgRef.getMessageId().setFutureOrSequenceLong(1l);
1:             }
1:         }, 1l) {};
1:         msg.getMessageId().setFutureOrSequenceLong(future);
1:         Executors.newSingleThreadExecutor().submit(future);
1:         underTest.addMessageLast(msg);
1: 
1:         assertTrue("cache enabled", underTest.isUseCache() && underTest.isCacheEnabled());
1: 
1:         // second message will flip the cache but will be stored before the future task
1:         msg = getMessage(1);
1:         messages[0] = msg;
1:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
1:         msg.getMessageId().setFutureOrSequenceLong(1l);
1:         underTest.addMessageLast(msg);
1: 
1: 
1:         assertTrue("cache is disabled as limit reached", !underTest.isCacheEnabled());
1:         assertEquals("setBatch unset", 0l, queueMessageStore.batch.get());
1: 
1:         int dequeueCount = 0;
1: 
1:         underTest.setMaxBatchSize(2);
1:         underTest.reset();
1:         while (underTest.hasNext() && dequeueCount < count) {
1:             MessageReference ref = underTest.next();
1:             ref.decrementReferenceCount();
1:             underTest.remove();
1:             LOG.info("Received message: {} with body: {}",
1:                      ref.getMessageId(), ((ActiveMQTextMessage)ref.getMessage()).getText());
1:             assertEquals(dequeueCount++, ref.getMessageId().getProducerSequenceId());
1:         }
1:         underTest.release();
1:         assertEquals(count, dequeueCount);
1:     }
1: 
1:     @Test
1:     public void testSetBatchWithOrderedFutureCurrentFuture() throws Exception {
1:         final int count = 2;
1:         final Message[] messages = new Message[count];
1:         final TestMessageStore queueMessageStore = new TestMessageStore(messages, destination);
1:         final ConsumerInfo consumerInfo = new ConsumerInfo();
1:         final DestinationStatistics destinationStatistics = new DestinationStatistics();
1:         consumerInfo.setExclusive(true);
1: 
1:         final Queue queue = new Queue(brokerService, destination,
1:                 queueMessageStore, destinationStatistics, null);
1: 
1:         queueMessageStore.start();
1:         queueMessageStore.registerIndexListener(null);
1: 
0:         QueueStorePrefetch underTest = new QueueStorePrefetch(queue, brokerService.getBroker());
1:         SystemUsage systemUsage = new SystemUsage();
1:         // ensure memory limit is reached
1:         systemUsage.getMemoryUsage().setLimit(messageBytesSize * 1);
1:         underTest.setSystemUsage(systemUsage);
1:         underTest.setEnableAudit(false);
1:         underTest.start();
1:         assertTrue("cache enabled", underTest.isUseCache() && underTest.isCacheEnabled());
1: 
1:         ActiveMQTextMessage msg = getMessage(0);
1:         messages[0] = msg;
1:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
1:         msg.setRecievedByDFBridge(true);
1:         final ActiveMQTextMessage msgRef = msg;
1:         FutureTask<Long> future = new FutureTask<Long>(new Runnable() {
1:             @Override
1:             public void run() {
1:                 msgRef.getMessageId().setFutureOrSequenceLong(0l);
1:             }
1:         }, 0l) {};
1:         msg.getMessageId().setFutureOrSequenceLong(future);
1:         Executors.newSingleThreadExecutor().submit(future);
1:         underTest.addMessageLast(msg);
1: 
1:         assertTrue("cache enabled", underTest.isUseCache() && underTest.isCacheEnabled());
1: 
1:         // second message will flip the cache but will be stored before the future task
1:         msg = getMessage(1);
1:         messages[1] = msg;
1:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
1:         msg.setRecievedByDFBridge(true);
1:         final ActiveMQTextMessage msgRe2f = msg;
1:         FutureTask<Long> future2 = new FutureTask<Long>(new Runnable() {
1:             @Override
1:             public void run() {
1:                 msgRe2f.getMessageId().setFutureOrSequenceLong(1l);
1:             }
1:         }, 1l) {};
1:         msg.getMessageId().setFutureOrSequenceLong(future2);
1:         Executors.newSingleThreadExecutor().submit(future2);
1:         underTest.addMessageLast(msg);
1: 
1: 
1:         assertTrue("cache is disabled as limit reached", !underTest.isCacheEnabled());
1:         assertEquals("setBatch set", 1l, queueMessageStore.batch.get());
1: 
1:         int dequeueCount = 0;
1: 
1:         underTest.setMaxBatchSize(2);
1:         underTest.reset();
1:         while (underTest.hasNext() && dequeueCount < count) {
1:             MessageReference ref = underTest.next();
1:             ref.decrementReferenceCount();
1:             underTest.remove();
1:             LOG.info("Received message: {} with body: {}",
1:                      ref.getMessageId(), ((ActiveMQTextMessage)ref.getMessage()).getText());
1:             assertEquals(dequeueCount++, ref.getMessageId().getProducerSequenceId());
1:         }
1:         underTest.release();
1:         assertEquals(count, dequeueCount);
1:     }
1: 
1:     @Test
1:     public void testSetBatchWithFuture() throws Exception {
1:         final int count = 4;
1:         final Message[] messages = new Message[count];
1:         final TestMessageStore queueMessageStore = new TestMessageStore(messages, destination);
1:         final ConsumerInfo consumerInfo = new ConsumerInfo();
1:         final DestinationStatistics destinationStatistics = new DestinationStatistics();
1:         consumerInfo.setExclusive(true);
1: 
1:         final Queue queue = new Queue(brokerService, destination,
1:                 queueMessageStore, destinationStatistics, null);
1: 
1:         queueMessageStore.start();
1:         queueMessageStore.registerIndexListener(null);
1: 
0:         QueueStorePrefetch underTest = new QueueStorePrefetch(queue, brokerService.getBroker());
1:         SystemUsage systemUsage = new SystemUsage();
1:         // ensure memory limit is reached
1:         systemUsage.getMemoryUsage().setLimit(messageBytesSize * (count + 6));
1:         underTest.setSystemUsage(systemUsage);
1:         underTest.setEnableAudit(false);
1:         underTest.start();
1:         assertTrue("cache enabled", underTest.isUseCache() && underTest.isCacheEnabled());
1: 
1:         ActiveMQTextMessage msg = getMessage(0);
1:         messages[0] = msg;
1:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
1:         msg.setRecievedByDFBridge(true);
1:         final ActiveMQTextMessage msgRef = msg;
1:         FutureTask<Long> future0 = new FutureTask<Long>(new Runnable() {
1:             @Override
1:             public void run() {
1:                 msgRef.getMessageId().setFutureOrSequenceLong(0l);
1:             }
1:         }, 0l) {};
1:         msg.getMessageId().setFutureOrSequenceLong(future0);
1:         underTest.addMessageLast(msg);
1:         Executors.newSingleThreadExecutor().submit(future0);
1: 
1: 
1:         msg = getMessage(1);
1:         messages[3] = msg;
1:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
1:         msg.setRecievedByDFBridge(true);
1:         final ActiveMQTextMessage msgRef1 = msg;
1:         FutureTask<Long> future1 = new FutureTask<Long>(new Runnable() {
1:             @Override
1:             public void run() {
1:                 msgRef1.getMessageId().setFutureOrSequenceLong(3l);
1:             }
1:         }, 3l) {};
1:         msg.getMessageId().setFutureOrSequenceLong(future1);
1:         underTest.addMessageLast(msg);
1: 
1: 
1:         msg = getMessage(2);
1:         messages[1] = msg;
1:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
1:         msg.getMessageId().setFutureOrSequenceLong(1l);
1:         underTest.addMessageLast(msg);
1: 
1:         assertTrue("cache enabled", underTest.isUseCache() && underTest.isCacheEnabled());
1: 
1:         // out of order future
1:         Executors.newSingleThreadExecutor().submit(future1);
1: 
1:         // sync add to flip cache
1:         msg = getMessage(3);
1:         messages[2] = msg;
1:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
0:         msg.getMessageId().setFutureOrSequenceLong(3l);
1:         underTest.addMessageLast(msg);
1: 
1: 
1:         assertTrue("cache is disabled as limit reached", !underTest.isCacheEnabled());
1:         assertEquals("setBatch set", 2l, queueMessageStore.batch.get());
1: 
1:         int dequeueCount = 0;
1: 
1:         underTest.setMaxBatchSize(count);
1:         underTest.reset();
1:         while (underTest.hasNext() && dequeueCount < count) {
1:             MessageReference ref = underTest.next();
1:             ref.decrementReferenceCount();
1:             underTest.remove();
1:             LOG.info("Received message: {} with body: {}",
1:                      ref.getMessageId(), ((ActiveMQTextMessage)ref.getMessage()).getText());
1:             assertEquals(dequeueCount++, ref.getMessageId().getProducerSequenceId());
1:         }
1:         underTest.release();
1:         assertEquals(count, dequeueCount);
1:     }
1: 
1:     @Test
1:     public void testSetBatch() throws Exception {
1:         final int count = 3;
1:         final Message[] messages = new Message[count];
1:         final TestMessageStore queueMessageStore = new TestMessageStore(messages, destination);
1:         final ConsumerInfo consumerInfo = new ConsumerInfo();
1:         final DestinationStatistics destinationStatistics = new DestinationStatistics();
1:         consumerInfo.setExclusive(true);
1: 
1:         final Queue queue = new Queue(brokerService, destination,
1:                 queueMessageStore, destinationStatistics, null);
1: 
1:         queueMessageStore.start();
1:         queueMessageStore.registerIndexListener(null);
1: 
0:         QueueStorePrefetch underTest = new QueueStorePrefetch(queue, brokerService.getBroker());
1:         SystemUsage systemUsage = new SystemUsage();
1:         // ensure memory limit is reached
1:         systemUsage.getMemoryUsage().setLimit(messageBytesSize * 5);
1:         underTest.setSystemUsage(systemUsage);
1:         underTest.setEnableAudit(false);
1:         underTest.start();
1:         assertTrue("cache enabled", underTest.isUseCache() && underTest.isCacheEnabled());
1: 
1: 
1:         ActiveMQTextMessage msg = getMessage(0);
1:         messages[0] = msg;
1:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
1:         msg.getMessageId().setFutureOrSequenceLong(0l);
1:         underTest.addMessageLast(msg);
1: 
1:         msg = getMessage(1);
1:         messages[1] = msg;
1:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
1:         msg.getMessageId().setFutureOrSequenceLong(1l);
1:         underTest.addMessageLast(msg);
1: 
1:         assertTrue("cache enabled", underTest.isUseCache() && underTest.isCacheEnabled());
1: 
1:         msg = getMessage(2);
1:         messages[2] = msg;
1:         msg.setMemoryUsage(systemUsage.getMemoryUsage());
1:         msg.getMessageId().setFutureOrSequenceLong(2l);
1:         underTest.addMessageLast(msg);
1: 
1: 
1:         assertTrue("cache is disabled as limit reached", !underTest.isCacheEnabled());
1:         assertEquals("setBatch set", 2l, queueMessageStore.batch.get());
1: 
1:         int dequeueCount = 0;
1: 
1:         underTest.setMaxBatchSize(2);
1:         underTest.reset();
1:         while (underTest.hasNext() && dequeueCount < count) {
1:             MessageReference ref = underTest.next();
1:             ref.decrementReferenceCount();
1:             underTest.remove();
1:             LOG.info("Received message: {} with body: {}",
1:                      ref.getMessageId(), ((ActiveMQTextMessage)ref.getMessage()).getText());
1:             assertEquals(dequeueCount++, ref.getMessageId().getProducerSequenceId());
1:         }
1:         underTest.release();
1:         assertEquals(count, dequeueCount);
1:     }
1: 
1:     private ActiveMQTextMessage getMessage(int i) throws Exception {
1:         ActiveMQTextMessage message = new ActiveMQTextMessage();
1:         MessageId id = new MessageId(mesageIdRoot + i);
1:         id.setBrokerSequenceId(i);
1:         id.setProducerSequenceId(i);
1:         message.setMessageId(id);
1:         message.setDestination(destination);
1:         message.setPersistent(true);
1:         message.setResponseRequired(true);
1:         message.setText("Msg:" + i + " " + text);
1:         assertEquals(message.getMessageId().getProducerSequenceId(), i);
1:         return message;
1:     }
1: 
1:     class TestMessageStore extends AbstractMessageStore {
1:         final Message[] messages;
1:         public AtomicLong batch = new AtomicLong();
1: 
1:         public TestMessageStore(Message[] messages, ActiveMQDestination dest) {
1:             super(dest);
1:             this.messages = messages;
1:         }
1: 
1:         @Override
1:         public void addMessage(ConnectionContext context, Message message) throws IOException {
1: 
1:         }
1: 
1:         @Override
1:         public Message getMessage(MessageId identity) throws IOException {
1:             return null;
1:         }
1: 
1:         @Override
1:         public void removeMessage(ConnectionContext context, MessageAck ack) throws IOException {
1: 
1:         }
1: 
1:         @Override
1:         public void removeAllMessages(ConnectionContext context) throws IOException {
1: 
1:         }
1: 
1:         @Override
1:         public void recover(MessageRecoveryListener container) throws Exception {
1: 
1:         }
1: 
1:         @Override
0:         public int getMessageCount() throws IOException {
0:             return 0;
1:         }
1: 
1:         @Override
1:         public void resetBatching() {
1: 
1:         }
1:         @Override
1:         public void recoverNextMessages(int maxReturned, MessageRecoveryListener listener) throws Exception {
1:             for (int i=batch.intValue();i<messages.length;i++) {
1:                 LOG.info("recovered index:" + i);
1:                 listener.recoverMessage(messages[i]);
1:             }
1:         }
1: 
1:         @Override
1:         public void setBatch(MessageId message) {
1:             batch.set((Long)message.getFutureOrSequenceLong());
1:             batch.incrementAndGet();
1:         }
1: 
1:     }
1: }
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:785b16b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         @Override
1:         public void recoverMessageStoreStatistics() throws IOException {
1:             this.getMessageStoreStatistics().reset();
0:         }
0: 
============================================================================