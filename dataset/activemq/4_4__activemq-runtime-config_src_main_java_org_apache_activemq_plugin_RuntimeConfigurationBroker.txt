1:3630a41: /**
1:3630a41:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:3630a41:  * contributor license agreements.  See the NOTICE file distributed with
1:3630a41:  * this work for additional information regarding copyright ownership.
1:3630a41:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:3630a41:  * (the "License"); you may not use this file except in compliance with
1:3630a41:  * the License.  You may obtain a copy of the License at
1:3630a41:  *
1:3630a41:  *      http://www.apache.org/licenses/LICENSE-2.0
1:3630a41:  *
1:3630a41:  * Unless required by applicable law or agreed to in writing, software
1:3630a41:  * distributed under the License is distributed on an "AS IS" BASIS,
1:3630a41:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:3630a41:  * See the License for the specific language governing permissions and
1:3630a41:  * limitations under the License.
1:3630a41:  */
1:3630a41: package org.apache.activemq.plugin;
1:8d4fef8: 
1:43c3cae: import java.io.IOException;
1:43c3cae: import java.util.ArrayList;
1:43c3cae: import java.util.Date;
1:43c3cae: import java.util.Properties;
1:713250f: 
1:8b8e726: import javax.management.JMException;
1:8b8e726: import javax.management.ObjectName;
1:8b8e726: import javax.xml.XMLConstants;
1:3630a41: import javax.xml.bind.JAXBContext;
1:3630a41: import javax.xml.bind.JAXBElement;
1:3630a41: import javax.xml.bind.JAXBException;
1:3630a41: import javax.xml.bind.Unmarshaller;
1:3630a41: import javax.xml.parsers.DocumentBuilder;
1:3630a41: import javax.xml.parsers.DocumentBuilderFactory;
1:3630a41: import javax.xml.parsers.ParserConfigurationException;
1:2ea02bc: import javax.xml.transform.Source;
1:2ea02bc: import javax.xml.transform.stream.StreamSource;
1:8b8e726: import javax.xml.validation.Schema;
1:8b8e726: import javax.xml.validation.SchemaFactory;
1:634a818: 
1:43c3cae: import org.apache.activemq.broker.Broker;
1:43c3cae: import org.apache.activemq.broker.BrokerContext;
1:43c3cae: import org.apache.activemq.broker.jmx.ManagementContext;
1:43c3cae: import org.apache.activemq.plugin.jmx.RuntimeConfigurationView;
1:43c3cae: import org.apache.activemq.schema.core.DtoBroker;
1:43c3cae: import org.apache.activemq.spring.Utils;
1:43c3cae: import org.slf4j.Logger;
1:43c3cae: import org.slf4j.LoggerFactory;
1:43c3cae: import org.springframework.core.io.Resource;
1:43c3cae: import org.w3c.dom.Document;
1:43c3cae: import org.w3c.dom.Node;
1:43c3cae: import org.xml.sax.SAXException;
1:43c3cae: 
1:43c3cae: public class RuntimeConfigurationBroker extends AbstractRuntimeConfigurationBroker {
1:bbc039f: 
1:3630a41:     public static final Logger LOG = LoggerFactory.getLogger(RuntimeConfigurationBroker.class);
1:8b8e726:     public static final String objectNamePropsAppendage = ",service=RuntimeConfiguration,name=Plugin";
1:634a818:     PropertiesPlaceHolderUtil placeHolderUtil = null;
1:3630a41:     private long checkPeriod;
1:3630a41:     private long lastModified = -1;
1:3630a41:     private Resource configToMonitor;
1:8d480b4:     private DtoBroker currentConfiguration;
1:a52c014:     private Schema schema;
1:634a818: 
1:8d480b4:     public RuntimeConfigurationBroker(Broker next) {
1:3630a41:         super(next);
1:4109b79:     }
1:bbc039f: 
1:43c3cae:     @Override
1:3630a41:     public void start() throws Exception {
1:3630a41:         super.start();
1:67a7d30:         try {
1:634a818:             BrokerContext brokerContext = next.getBrokerService().getBrokerContext();
1:634a818:             if (brokerContext != null) {
1:634a818:                 configToMonitor = Utils.resourceFromString(brokerContext.getConfigurationUrl());
1:77a9ade:                 info("Configuration " + configToMonitor);
1:67a7d30:             } else {
1:634a818:                 LOG.error("Null BrokerContext; impossible to determine configuration url resource from broker, updates cannot be tracked");
1:bbc039f:             }
1:3630a41:         } catch (Exception error) {
1:3630a41:             LOG.error("failed to determine configuration url resource from broker, updates cannot be tracked", error);
1:14fcd7c:         }
1:67a7d30: 
1:3630a41:         currentConfiguration = loadConfiguration(configToMonitor);
1:3630a41:         monitorModification(configToMonitor);
1:8b8e726:         registerMbean();
1:67a7d30:     }
1:67a7d30: 
1:67a7d30:     @Override
1:43c3cae:     protected void registerMbean() {
1:8b8e726:         if (getBrokerService().isUseJmx()) {
1:8b8e726:             ManagementContext managementContext = getBrokerService().getManagementContext();
1:67a7d30:             try {
1:8b8e726:                 objectName = new ObjectName(getBrokerService().getBrokerObjectName().toString() + objectNamePropsAppendage);
1:8b8e726:                 managementContext.registerMBean(new RuntimeConfigurationView(this), objectName);
1:8b8e726:             } catch (Exception ignored) {
1:8b8e726:                 LOG.debug("failed to register RuntimeConfigurationMBean", ignored);
1:67a7d30:             }
1:67a7d30:         }
1:67a7d30:     }
1:da45d99: 
1:92860ae:     @Override
1:43c3cae:     protected void unregisterMbean() {
1:8d480b4:         if (objectName != null) {
1:67a7d30:             try {
1:8b8e726:                 getBrokerService().getManagementContext().unregisterMBean(objectName);
1:8b8e726:             } catch (JMException ignored) {
1:67a7d30:             }
1:da45d99:         }
1:da45d99:     }
1:77a9ade: 
1:8b8e726:     public String updateNow() {
1:8b8e726:         LOG.info("Manual configuration update triggered");
1:8b8e726:         infoString = "";
1:8b8e726:         applyModifications(configToMonitor);
1:8b8e726:         String result = infoString;
1:8b8e726:         infoString = null;
1:634a818:         return result;
1:da45d99:     }
1:77a9ade: 
1:3630a41:     private void monitorModification(final Resource configToMonitor) {
1:92860ae:         monitorTask = new Runnable() {
3:3630a41:             @Override
1:67a7d30:             public void run() {
1:4109b79:                 try {
1:3630a41:                     if (configToMonitor.lastModified() > lastModified) {
1:3630a41:                         applyModifications(configToMonitor);
1:67a7d30:                     }
1:da45d99:                 } catch (Throwable e) {
1:3630a41:                     LOG.error("Failed to determine lastModified time on configuration: " + configToMonitor, e);
1:da45d99:                 }
1:da45d99:             }
1:3630a41:         };
1:8b8e726:         if (lastModified > 0 && checkPeriod > 0) {
1:3630a41:             this.getBrokerService().getScheduler().executePeriodically(monitorTask, checkPeriod);
1:8550f93:             info("Monitoring for updates (every " + checkPeriod + "millis) : " + configToMonitor + ", lastUpdate: " + new Date(lastModified));
1:da45d99:         }
1:77a9ade:     }
1:634a818: 
1:634a818: 
1:634a818: 
1:3630a41:     private void applyModifications(Resource configToMonitor) {
1:8d480b4:         DtoBroker changed = loadConfiguration(configToMonitor);
1:8b8e726:         if (changed != null && !currentConfiguration.equals(changed)) {
1:8b8e726:             LOG.info("change in " + configToMonitor + " at: " + new Date(lastModified));
1:67a7d30:             LOG.debug("current:" + filterPasswords(currentConfiguration));
1:67a7d30:             LOG.debug("new    :" + filterPasswords(changed));
1:92860ae:             processSelectiveChanges(currentConfiguration, changed);
1:3630a41:             currentConfiguration = changed;
1:77a9ade:         } else {
1:8b8e726:             info("No material change to configuration in " + configToMonitor + " at: " + new Date(lastModified));
1:77a9ade:         }
1:77a9ade:     }
1:634a818: 
1:8d480b4:     private void processSelectiveChanges(DtoBroker currentConfiguration, DtoBroker modifiedConfiguration) {
1:634a818: 
1:8d480b4:         for (Class upDatable : new Class[]{
1:e8ea6cd:                 DtoBroker.DestinationPolicy.class,
1:8d480b4:                 DtoBroker.NetworkConnectors.class,
1:8d480b4:                 DtoBroker.DestinationInterceptors.class,
1:bbc039f:                 DtoBroker.Plugins.class,
1:bbc039f:                 DtoBroker.Destinations.class}) {
1:8d480b4:             processChanges(currentConfiguration, modifiedConfiguration, upDatable);
1:77a9ade:         }
1:77a9ade:     }
1:634a818: 
1:8d480b4:     private void processChanges(DtoBroker currentConfiguration, DtoBroker modifiedConfiguration, Class upDatable) {
1:bbc039f:         ConfigurationProcessor processor = ProcessorFactory.createProcessor(this, upDatable);
1:bbc039f:         processor.processChanges(currentConfiguration, modifiedConfiguration);
1:77a9ade:     }
1:43c3cae: 
1:634a818: 
1:634a818: 
1:8d480b4:     private DtoBroker loadConfiguration(Resource configToMonitor) {
1:8d480b4:         DtoBroker jaxbConfig = null;
1:3630a41:         if (configToMonitor != null) {
1:da45d99:             try {
1:8d480b4:                 JAXBContext context = JAXBContext.newInstance(DtoBroker.class);
1:3630a41:                 Unmarshaller unMarshaller = context.createUnmarshaller();
1:8b8e726:                 unMarshaller.setSchema(getSchema());
1:634a818: 
1:3630a41:                 // skip beans and pull out the broker node to validate
1:3630a41:                 DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
1:3630a41:                 dbf.setNamespaceAware(true);
1:3630a41:                 DocumentBuilder db = dbf.newDocumentBuilder();
1:3630a41:                 Document doc = db.parse(configToMonitor.getInputStream());
1:043a4ad:                 Node brokerRootNode = doc.getElementsByTagNameNS("*","broker").item(0);
1:634a818: 
1:043a4ad:                 if (brokerRootNode != null) {
1:e8ea6cd: 
1:043a4ad:                     JAXBElement<DtoBroker> brokerJAXBElement =
1:043a4ad:                             unMarshaller.unmarshal(brokerRootNode, DtoBroker.class);
1:043a4ad:                     jaxbConfig = brokerJAXBElement.getValue();
1:e8ea6cd: 
1:043a4ad:                     // if we can parse we can track mods
1:043a4ad:                     lastModified = configToMonitor.lastModified();
1:043a4ad: 
1:043a4ad:                     loadPropertiesPlaceHolderSupport(doc);
1:043a4ad: 
1:043a4ad:                 } else {
1:043a4ad:                     info("Failed to find 'broker' element by tag in: " + configToMonitor);
1:043a4ad:                 }
1:634a818: 
1:634a818:             } catch (IOException e) {
1:8b8e726:                 info("Failed to access: " + configToMonitor, e);
1:3630a41:             } catch (JAXBException e) {
1:8b8e726:                 info("Failed to parse: " + configToMonitor, e);
1:3630a41:             } catch (ParserConfigurationException e) {
1:8b8e726:                 info("Failed to document parse: " + configToMonitor, e);
1:3630a41:             } catch (SAXException e) {
1:8b8e726:                 info("Failed to find broker element in: " + configToMonitor, e);
1:67a7d30:             } catch (Exception e) {
1:043a4ad:                 info("Unexpected exception during load of: " + configToMonitor, e);
1:67a7d30:             }
1:634a818:         }
1:3630a41:         return jaxbConfig;
4:634a818:     }
1:67a7d30: 
1:634a818:     private void loadPropertiesPlaceHolderSupport(Document doc) {
1:634a818:         BrokerContext brokerContext = getBrokerService().getBrokerContext();
1:77a9ade:         if (brokerContext != null) {
1:634a818:             Properties initialProperties = new Properties(System.getProperties());
1:634a818:             placeHolderUtil = new PropertiesPlaceHolderUtil(initialProperties);
1:bbc039f:             placeHolderUtil.mergeProperties(doc, initialProperties, brokerContext);
1:634a818:         }
1:634a818:     }
1:634a818: 
1:634a818:     private Schema getSchema() throws SAXException, IOException {
1:8b8e726:         if (schema == null) {
1:8b8e726:             SchemaFactory schemaFactory = SchemaFactory.newInstance(
1:a52c014:                     XMLConstants.W3C_XML_SCHEMA_NS_URI);
1:77a9ade: 
1:77a9ade:             ArrayList<StreamSource> schemas = new ArrayList<StreamSource>();
1:77a9ade:             schemas.add(new StreamSource(getClass().getResource("/activemq.xsd").toExternalForm()));
1:eead6e5:             schemas.add(new StreamSource(getClass().getResource("/org/springframework/beans/factory/xml/spring-beans-3.0.xsd").toExternalForm()));
1:77a9ade:             schema = schemaFactory.newSchema(schemas.toArray(new Source[]{}));
1:77a9ade:         }
1:8b8e726:         return schema;
1:634a818:     }
1:634a818: 
1:8b8e726:     public long getLastModified() {
1:8b8e726:         return lastModified;
1:634a818:     }
1:634a818: 
1:8b8e726:     public Resource getConfigToMonitor() {
1:8b8e726:         return configToMonitor;
1:634a818:     }
1:634a818: 
1:8b8e726:     public long getCheckPeriod() {
1:8b8e726:         return checkPeriod;
1:634a818:     }
1:634a818: 
1:8d480b4:     public void setCheckPeriod(long checkPeriod) {
1:8d480b4:         this.checkPeriod = checkPeriod;
1:634a818:     }
1:634a818: 
1:634a818: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:43c3cae
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.util.ArrayList;
1: import java.util.Date;
1: import java.util.Properties;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.Broker;
1: import org.apache.activemq.broker.BrokerContext;
1: import org.apache.activemq.broker.jmx.ManagementContext;
1: import org.apache.activemq.plugin.jmx.RuntimeConfigurationView;
1: import org.apache.activemq.schema.core.DtoBroker;
1: import org.apache.activemq.spring.Utils;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: import org.springframework.core.io.Resource;
1: import org.w3c.dom.Document;
1: import org.w3c.dom.Node;
1: import org.xml.sax.SAXException;
1: 
1: public class RuntimeConfigurationBroker extends AbstractRuntimeConfigurationBroker {
/////////////////////////////////////////////////////////////////////////
1:     protected void registerMbean() {
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     protected void unregisterMbean() {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:bbc039f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.Broker;
0: import org.apache.activemq.broker.BrokerContext;
0: import org.apache.activemq.broker.BrokerFilter;
0: import org.apache.activemq.broker.ConnectionContext;
0: import org.apache.activemq.broker.jmx.ManagementContext;
0: import org.apache.activemq.broker.region.Destination;
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ConnectionInfo;
0: import org.apache.activemq.plugin.jmx.RuntimeConfigurationView;
0: import org.apache.activemq.schema.core.DtoBroker;
0: import org.apache.activemq.spring.Utils;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
0: import org.springframework.core.io.Resource;
0: import org.w3c.dom.Document;
0: import org.w3c.dom.Node;
0: import org.xml.sax.SAXException;
1: 
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.util.ArrayList;
0: import java.util.Date;
0: import java.util.Properties;
0: import java.util.concurrent.ConcurrentLinkedQueue;
0: import java.util.concurrent.locks.ReentrantReadWriteLock;
0: import java.util.regex.Pattern;
/////////////////////////////////////////////////////////////////////////
0:     protected ConcurrentLinkedQueue<Runnable> addDestinationWork = new ConcurrentLinkedQueue<Runnable>();
0:     protected ConcurrentLinkedQueue<Runnable> addConnectionWork = new ConcurrentLinkedQueue<Runnable>();
/////////////////////////////////////////////////////////////////////////
0:     protected void debug(String s) {
0:         LOG.debug(s);
1:     }
1: 
0:     protected void info(String s) {
/////////////////////////////////////////////////////////////////////////
0:     protected void info(String s, Throwable t) {
/////////////////////////////////////////////////////////////////////////
1:                 DtoBroker.Plugins.class,
1:                 DtoBroker.Destinations.class}) {
1:         ConfigurationProcessor processor = ProcessorFactory.createProcessor(this, upDatable);
1:         processor.processChanges(currentConfiguration, modifiedConfiguration);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             placeHolderUtil.mergeProperties(doc, initialProperties, brokerContext);
/////////////////////////////////////////////////////////////////////////
commit:14fcd7c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.*;
/////////////////////////////////////////////////////////////////////////
0:             Destination target = destination;
0:             if (destination instanceof DestinationFilter) {
0:                 target = ((DestinationFilter)destination).getNext();
0:             if (target.getActiveMQDestination().isQueue()) {
0:                 updatedEntry.update((Queue) target);
0:             } else if (target.getActiveMQDestination().isTopic()) {
0:                 updatedEntry.update((Topic) target);
1:             }
0:             LOG.debug("applied update to:" + target);
commit:713250f
/////////////////////////////////////////////////////////////////////////
0:                     RegionBroker regionBroker = (RegionBroker) getBrokerService().getRegionBroker();
/////////////////////////////////////////////////////////////////////////
1: 
0:                     regionBroker.reapplyInterceptor();
commit:55da9bc
/////////////////////////////////////////////////////////////////////////
0:                         regionBroker.reapplyInterceptor();
author:gtully
-------------------------------------------------------------------------------
commit:eead6e5
/////////////////////////////////////////////////////////////////////////
0:                     initialProperties.putAll((Properties) FactoryBean.class.getMethod("getObject", (Class<?>[]) null).invoke(springBean));
/////////////////////////////////////////////////////////////////////////
1:             schemas.add(new StreamSource(getClass().getResource("/org/springframework/beans/factory/xml/spring-beans-3.0.xsd").toExternalForm()));
commit:67a7d30
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ConnectionInfo;
0: import org.apache.activemq.schema.core.DtoAuthenticationUser;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.schema.core.DtoSimpleAuthenticationPlugin;
0: import org.apache.activemq.security.AuthenticationUser;
0: import org.apache.activemq.security.SimpleAuthenticationBroker;
0: import org.apache.activemq.security.SimpleAuthenticationPlugin;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private final ReentrantReadWriteLock addConnectionBarrier = new ReentrantReadWriteLock();
0:     private ConcurrentLinkedQueue<Runnable> addDestinationWork = new ConcurrentLinkedQueue<Runnable>();
0:     private ConcurrentLinkedQueue<Runnable> addConnectionWork = new ConcurrentLinkedQueue<Runnable>();
/////////////////////////////////////////////////////////////////////////
0:         Runnable work = addDestinationWork.poll();
0:                     work = addDestinationWork.poll();
/////////////////////////////////////////////////////////////////////////
0:     // modification to authentication plugin needs exclusive access to connection add
1:     @Override
0:     public void addConnection(ConnectionContext context, ConnectionInfo info) throws Exception {
0:         Runnable work = addConnectionWork.poll();
0:         if (work != null) {
1:             try {
0:                 addConnectionBarrier.writeLock().lockInterruptibly();
0:                 do {
0:                     work.run();
0:                     work = addConnectionWork.poll();
0:                 } while (work != null);
0:                 super.addConnection(context, info);
0:             } finally {
0:                 addConnectionBarrier.writeLock().unlock();
1:             }
1:         } else {
1:             try {
0:                 addConnectionBarrier.readLock().lockInterruptibly();
0:                 super.addConnection(context, info);
0:             } finally {
0:                 addConnectionBarrier.readLock().unlock();
1:             }
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         LOG.info(filterPasswords(s));
/////////////////////////////////////////////////////////////////////////
0:         LOG.info(filterPasswords(s), t);
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug("current:" + filterPasswords(currentConfiguration));
1:             LOG.debug("new    :" + filterPasswords(changed));
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug(filterPasswords(o) + " has no modifiable elements");
/////////////////////////////////////////////////////////////////////////
0:         } else if (candidate instanceof DtoSimpleAuthenticationPlugin) {
1:             try {
0:                 final SimpleAuthenticationPlugin updatedPlugin = fromDto(candidate, new SimpleAuthenticationPlugin());
0:                 final SimpleAuthenticationBroker authenticationBroker =
0:                     (SimpleAuthenticationBroker) getBrokerService().getBroker().getAdaptor(SimpleAuthenticationBroker.class);
0:                 addConnectionWork.add(new Runnable() {
1:                     public void run() {
0:                         authenticationBroker.setUserGroups(updatedPlugin.getUserGroups());
0:                         authenticationBroker.setUserPasswords(updatedPlugin.getUserPasswords());
0:                         authenticationBroker.setAnonymousAccessAllowed(updatedPlugin.isAnonymousAccessAllowed());
0:                         authenticationBroker.setAnonymousUser(updatedPlugin.getAnonymousUser());
0:                         authenticationBroker.setAnonymousGroup(updatedPlugin.getAnonymousGroup());
1:                     }
0:                 });
1:             } catch (Exception e) {
0:                 info("failed to apply SimpleAuthenticationPlugin modifications to SimpleAuthenticationBroker", e);
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
0:             addDestinationWork.add(new Runnable() {
/////////////////////////////////////////////////////////////////////////
0:             addDestinationWork.add(new Runnable() {
/////////////////////////////////////////////////////////////////////////
0:         LOG.trace("applying props: " + filterPasswords(properties) + ", to " + instance.getClass().getSimpleName());
/////////////////////////////////////////////////////////////////////////
0:     Pattern matchPassword = Pattern.compile("password=.*,");
0:     private String filterPasswords(Object toEscape) {
0:         return matchPassword.matcher(toEscape.toString()).replaceAll("password=???,");
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         } else if (DtoAuthenticationUser.class.isAssignableFrom(elementContent.getClass())) {
0:             return new AuthenticationUser();
commit:4109b79
/////////////////////////////////////////////////////////////////////////
0:             Method setter = findSetter(instance, elementName);
0:             if (setter != null) {
0:                 List<Object> argument = new LinkedList<Object>();
0:                 for (Object elementContent : filter(nested, Object.class)) {
0:                     argument.add(fromDto(elementContent, inferTargetObject(elementContent)));
1:                 }
1:                 try {
0:                     setter.invoke(instance, matchType(argument, setter.getParameterTypes()[0]));
0:                 } catch (Exception e) {
0:                     info("failed to invoke " + setter + " on " + instance, e);
0:                 info("failed to find setter for " + elementName + " on :" + instance);
commit:da45d99
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.InvocationTargetException;
/////////////////////////////////////////////////////////////////////////
0: import org.springframework.beans.factory.BeanFactory;
0: import org.springframework.beans.factory.FactoryBean;
/////////////////////////////////////////////////////////////////////////
0:             mergeProperties(doc, initialProperties, brokerContext);
0:     private void mergeProperties(Document doc, Properties initialProperties, BrokerContext brokerContext) {
0:         //            <property name="locations" || name="properties">
0:         LinkedList<String> resources = new LinkedList<String>();
0:         LinkedList<String> propertiesClazzes = new LinkedList<String>();
0:         NodeList beans = doc.getElementsByTagNameNS("*", "bean");
/////////////////////////////////////////////////////////////////////////
0:                         if (Node.ELEMENT_NODE == beanProp.getNodeType() && beanProp.hasAttributes() && beanProp.getAttributes().getNamedItem("name") != null) {
0:                             String propertyName = beanProp.getAttributes().getNamedItem("name").getTextContent();
0:                             if ("locations".equals(propertyName)) {
0:                                 // interested in value or list/value of locations property
0:                                 Element beanPropElement = (Element) beanProp;
0:                                 NodeList values = beanPropElement.getElementsByTagNameNS("*", "value");
0:                                 for (int k = 0; k < values.getLength(); k++) {
0:                                     Node value = values.item(k);
0:                                     resources.add(value.getFirstChild().getTextContent());
0:                             } else if ("properties".equals(propertyName)) {
1: 
0:                                 // bean or beanFactory
0:                                 Element beanPropElement = (Element) beanProp;
0:                                 NodeList values = beanPropElement.getElementsByTagNameNS("*", "bean");
0:                                 for (int k = 0; k < values.getLength(); k++) {
0:                                     Node value = values.item(k);
0:                                     if (value.hasAttributes()) {
0:                                         Node beanClassTypeNode = value.getAttributes().getNamedItem("class");
0:                                         if (beanClassTypeNode != null) {
0:                                             propertiesClazzes.add(beanClassTypeNode.getFirstChild().getTextContent());
1:                                         }
1:                                     }
1:                                 }
0:         for (String value : propertiesClazzes) {
1:             try {
0:                 Object springBean = getClass().getClassLoader().loadClass(value).newInstance();
0:                 if (springBean instanceof FactoryBean) {
0:                     // can't access the factory or created properties from spring context so we got to recreate
0:                     initialProperties.putAll((Properties) FactoryBean.class.getMethod("getObject", null).invoke(springBean));
1:                 }
1:             } catch (Throwable e) {
0:                 LOG.debug("unexpected exception processing properties bean class: " + propertiesClazzes, e);
1:             }
1:         }
0:         for (String value : resources) {
commit:043a4ad
/////////////////////////////////////////////////////////////////////////
1:                 Node brokerRootNode = doc.getElementsByTagNameNS("*","broker").item(0);
1:                 if (brokerRootNode != null) {
1:                     JAXBElement<DtoBroker> brokerJAXBElement =
1:                             unMarshaller.unmarshal(brokerRootNode, DtoBroker.class);
1:                     jaxbConfig = brokerJAXBElement.getValue();
1:                     // if we can parse we can track mods
1:                     lastModified = configToMonitor.lastModified();
1: 
1:                     loadPropertiesPlaceHolderSupport(doc);
1: 
1:                 } else {
1:                     info("Failed to find 'broker' element by tag in: " + configToMonitor);
1:                 }
/////////////////////////////////////////////////////////////////////////
0:             } catch (Exception e) {
1:                 info("Unexpected exception during load of: " + configToMonitor, e);
commit:77a9ade
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 info("Configuration " + configToMonitor);
/////////////////////////////////////////////////////////////////////////
1:         if (brokerContext != null) {
/////////////////////////////////////////////////////////////////////////
0:                 if (!value.isEmpty()) {
0:                     propResources.add(Utils.resourceFromString(replacePlaceHolders(value)));
1:                 }
/////////////////////////////////////////////////////////////////////////
1:             ArrayList<StreamSource> schemas = new ArrayList<StreamSource>();
1:             schemas.add(new StreamSource(getClass().getResource("/activemq.xsd").toExternalForm()));
1: 
0:             // avoid going to the net to pull down the spring schema,
0:             // REVISIT may need to be smarter in osgi
0:                             "http://www.springframework.org/schema/beans/spring-beans.xsd");
0:             if (beanInputSource != null) {
0:                 schemas.add(new StreamSource(beanInputSource.getByteStream()));
1:             } else {
0:                 schemas.add(new StreamSource("http://www.springframework.org/schema/beans/spring-beans.xsd"));
1:             }
1:             schema = schemaFactory.newSchema(schemas.toArray(new Source[]{}));
/////////////////////////////////////////////////////////////////////////
0:             return replaceBytePostfix(str);
1:         }
1: 
0:         static Pattern[] byteMatchers = new Pattern[] {
0:                 Pattern.compile("^\\s*(\\d+)\\s*(b)?\\s*$", Pattern.CASE_INSENSITIVE),
0:                 Pattern.compile("^\\s*(\\d+)\\s*k(b)?\\s*$", Pattern.CASE_INSENSITIVE),
0:                 Pattern.compile("^\\s*(\\d+)\\s*m(b)?\\s*$", Pattern.CASE_INSENSITIVE),
0:                 Pattern.compile("^\\s*(\\d+)\\s*g(b)?\\s*$", Pattern.CASE_INSENSITIVE)};
1: 
0:         // xbean can Xb, Xkb, Xmb, Xg etc
0:         private String replaceBytePostfix(String str) {
0:             try {
0:                 for (int i=0; i< byteMatchers.length; i++) {
0:                     Matcher matcher = byteMatchers[i].matcher(str);
0:                     if (matcher.matches()) {
0:                         long value = Long.parseLong(matcher.group(1));
0:                         for (int j=1; j<=i; j++) {
0:                             value *= 1024;
1:                         }
0:                         return String.valueOf(value);
1:                     }
1:                 }
0:             } catch (NumberFormatException ignored) {
0:                 LOG.debug("nfe on: " + str, ignored);
1:             }
commit:531d67c
/////////////////////////////////////////////////////////////////////////
0:         } catch (NoSuchMethodException mappingIncomplete) {
0:             LOG.debug(o + " has no modifiable elements");
commit:4a01e40
/////////////////////////////////////////////////////////////////////////
0:                 } catch (Throwable e) {
commit:8550f93
/////////////////////////////////////////////////////////////////////////
1:             info("Monitoring for updates (every " + checkPeriod + "millis) : " + configToMonitor + ", lastUpdate: " + new Date(lastModified));
commit:8d4fef8
/////////////////////////////////////////////////////////////////////////
0: import org.w3c.dom.Element;
/////////////////////////////////////////////////////////////////////////
0:         //              ...
0:         String resourcesString = "";
/////////////////////////////////////////////////////////////////////////
0:                         if (Node.ELEMENT_NODE == beanProp.getNodeType() &&
0:                                 beanProp.hasAttributes() && beanProp.getAttributes().getNamedItem("name").getTextContent().equals("locations")) {
1: 
0:                             // interested in value or list/value of locations property
0:                             Element beanPropElement = (Element) beanProp;
0:                             NodeList values = beanPropElement.getElementsByTagName("value");
0:                             for (int k = 0; k < values.getLength(); k++) {
0:                                 Node value = values.item(k);
0:                                 if (!resourcesString.isEmpty()) {
0:                                     resourcesString += ",";
0:                                 resourcesString += value.getFirstChild().getTextContent();
/////////////////////////////////////////////////////////////////////////
0:         for (String value : resourcesString.split(",")) {
0:             try {
0:                 propResources.add(Utils.resourceFromString(replacePlaceHolders(value)));
0:             } catch (MalformedURLException e) {
0:                 info("failed to resolve resource: " + value, e);
commit:634a818
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.InvocationTargetException;
0: import java.lang.reflect.Method;
0: import java.net.MalformedURLException;
0: import java.util.HashSet;
0: import java.util.Map;
0: import java.util.regex.Matcher;
0: import java.util.regex.Pattern;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.BrokerContext;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ActiveMQQueue;
0: import org.apache.activemq.command.ActiveMQTopic;
0: import org.apache.activemq.network.DiscoveryNetworkConnector;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.schema.core.DtoQueue;
0: import org.apache.activemq.schema.core.DtoTopic;
/////////////////////////////////////////////////////////////////////////
0: import org.springframework.beans.factory.config.PropertyPlaceholderConfigurer;
0: import org.springframework.beans.factory.xml.PluggableSchemaResolver;
0: import org.w3c.dom.NodeList;
0: import org.xml.sax.InputSource;
/////////////////////////////////////////////////////////////////////////
1:     PropertiesPlaceHolderUtil placeHolderUtil = null;
/////////////////////////////////////////////////////////////////////////
1:             BrokerContext brokerContext = next.getBrokerService().getBrokerContext();
1:             if (brokerContext != null) {
1:                 configToMonitor = Utils.resourceFromString(brokerContext.getConfigurationUrl());
0:             } else {
1:                 LOG.error("Null BrokerContext; impossible to determine configuration url resource from broker, updates cannot be tracked");
1:             }
/////////////////////////////////////////////////////////////////////////
0:                     DiscoveryNetworkConnector nc = fromDto(networkConnector, new DiscoveryNetworkConnector());
0:                     getBrokerService().addNetworkConnector(nc);
/////////////////////////////////////////////////////////////////////////
0:         replacePlaceHolders(properties);
1: 
0:         // deal with nested elements
0:         for (Object nested : filter(dto, Object.class)) {
0:             String elementName = nested.getClass().getSimpleName();
0:             if (elementName.endsWith("s")) {
0:                 Method setter = findSetter(instance, elementName);
0:                 if (setter != null) {
1: 
0:                     List<Object> argument = new LinkedList<Object>();
0:                     for (Object elementContent : filter(nested, Object.class)) {
0:                         argument.add(fromDto(elementContent, inferTargetObject(elementContent)));
1:                     }
0:                     try {
0:                         setter.invoke(instance, matchType(argument, setter.getParameterTypes()[0]));
0:                     } catch (Exception e) {
0:                         info("failed to invoke " + setter + " on " + instance, e);
1:                     }
0:                 } else {
0:                     info("failed to find setter for " + elementName + " on :" + instance);
1:                 }
0:             } else {
0:                 info("unsupported mapping of element for non plural:" + elementName);
1:             }
1:         }
0:     private Object matchType(List<Object> parameterValues, Class<?> aClass) {
0:         Object result = parameterValues;
0:         if (Set.class.isAssignableFrom(aClass)) {
0:             result = new HashSet(parameterValues);
1:         }
1:         return result;
1:     }
1: 
0:     private Object inferTargetObject(Object elementContent) {
0:         if (DtoTopic.class.isAssignableFrom(elementContent.getClass())) {
0:             return new ActiveMQTopic();
0:         } else if (DtoQueue.class.isAssignableFrom(elementContent.getClass())) {
0:             return new ActiveMQQueue();
0:         } else {
0:             info("update not supported for dto: " + elementContent);
0:             return new Object();
1:         }
1:     }
1: 
0:     private Method findSetter(Object instance, String elementName) {
0:         String setter = "set" + elementName;
0:         for (Method m : instance.getClass().getMethods()) {
0:             if (setter.equals(m.getName())) {
0:                 return m;
1:             }
1:         }
0:         return null;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:                 if (type.isAssignableFrom(element.getDeclaredType())) {
/////////////////////////////////////////////////////////////////////////
0:                 loadPropertiesPlaceHolderSupport(doc);
1: 
/////////////////////////////////////////////////////////////////////////
1:     private void loadPropertiesPlaceHolderSupport(Document doc) {
1:         BrokerContext brokerContext = getBrokerService().getBrokerContext();
0:         if (brokerContext != null && !brokerContext.getBeansOfType(PropertyPlaceholderConfigurer.class).isEmpty()) {
1: 
1:             Properties initialProperties = new Properties(System.getProperties());
1:             placeHolderUtil = new PropertiesPlaceHolderUtil(initialProperties);
0:             mergeProperties(doc, initialProperties);
0:         }
0:     }
1: 
0:     private void mergeProperties(Document doc, Properties initialProperties) {
0:         // find resources
0:         //        <bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
0:         //            <property name="locations">
0:         //              <value>${props.base}users.properties</value>
0:         //            </property>
0:         //          </bean>
0:         String resourcesString = null;
0:         NodeList beans = doc.getElementsByTagName("bean");
0:         for (int i = 0; i < beans.getLength(); i++) {
0:             Node bean = beans.item(0);
0:             if (bean.hasAttributes() && bean.getAttributes().getNamedItem("class").getTextContent().contains("PropertyPlaceholderConfigurer")) {
0:                 if (bean.hasChildNodes()) {
0:                     NodeList beanProps = bean.getChildNodes();
0:                     for (int j = 0; j < beanProps.getLength(); j++) {
0:                         Node beanProp = beanProps.item(j);
0:                         if (beanProp.hasAttributes() && beanProp.getAttributes().getNamedItem("name").getTextContent().equals("locations")) {
0:                             NodeList locationsPropNodes = beanProp.getChildNodes();
0:                             for (int k = 0; k < locationsPropNodes.getLength(); k++) {
0:                                 Node location = locationsPropNodes.item(k);
0:                                 if (Node.ELEMENT_NODE == location.getNodeType() && location.getLocalName().equals("value")) {
0:                                     resourcesString = location.getFirstChild().getTextContent();
0:                                     break;
0:                                 }
0:                             }
0:                         }
0:                     }
0:                 }
0:             }
0:         }
0:         List<Resource> propResources = new LinkedList<Resource>();
0:         if (resourcesString != null) {
0:             for (String value : resourcesString.split(",")) {
0:                 try {
0:                     propResources.add(Utils.resourceFromString(replacePlaceHolders(value)));
0:                 } catch (MalformedURLException e) {
0:                     info("failed to resolve resource: " + value, e);
0:                 }
0:             }
0:         }
0:         for (Resource resource : propResources) {
0:             Properties properties = new Properties();
0:             try {
0:                 properties.load(resource.getInputStream());
1:             } catch (IOException e) {
0:                 info("failed to load properties resource: " + resource, e);
0:             }
0:             initialProperties.putAll(properties);
0:         }
0:     }
1: 
0:     private void replacePlaceHolders(Properties properties) {
0:         if (placeHolderUtil != null) {
0:             placeHolderUtil.filter(properties);
0:         }
0:     }
1: 
0:     private String replacePlaceHolders(String s) {
0:         if (placeHolderUtil != null) {
0:             s = placeHolderUtil.filter(s);
0:         }
0:         return s;
0:     }
1: 
1:     private Schema getSchema() throws SAXException, IOException {
1: 
0:             // avoid going to the net to pull down the spring schema
0:             final PluggableSchemaResolver springResolver =
0:                     new PluggableSchemaResolver(getClass().getClassLoader());
0:             final InputSource beanInputSource =
0:                     springResolver.resolveEntity(
0:                             "http://www.springframework.org/schema/beans",
0:                             "http://www.springframework.org/schema/beans/spring-beans-2.0.xsd");
1: 
0:             schema = schemaFactory.newSchema(new Source[]{
0:                     new StreamSource(getClass().getResource("/activemq.xsd").toExternalForm()),
0:                     new StreamSource(beanInputSource.getByteStream())
0:             });
/////////////////////////////////////////////////////////////////////////
1: 
0:     static public class PropertiesPlaceHolderUtil {
1: 
0:         static final Pattern pattern = Pattern.compile("\\$\\{([^\\}]+)\\}");
0:         final Properties properties;
1: 
0:         public PropertiesPlaceHolderUtil(Properties properties) {
0:             this.properties = properties;
0:         }
1: 
0:         public void filter(Properties toFilter) {
0:             for (Map.Entry<Object, Object> entry : toFilter.entrySet()) {
0:                 String val = (String) entry.getValue();
0:                 String newVal = filter(val);
0:                 if (!val.equals(newVal)) {
0:                     toFilter.put(entry.getKey(), newVal);
0:                 }
0:             }
0:         }
1: 
0:         public String filter(String str) {
0:             int start = 0;
0:             while (true) {
0:                 Matcher matcher = pattern.matcher(str);
0:                 if (!matcher.find(start)) {
0:                     break;
0:                 }
0:                 String group = matcher.group(1);
0:                 String property = properties.getProperty(group);
0:                 if (property != null) {
0:                     str = matcher.replaceFirst(Matcher.quoteReplacement(property));
0:                 } else {
0:                     start = matcher.end();
0:                 }
0:             }
0:             return str;
0:         }
1: 
0:     }
author:Gary Tully
-------------------------------------------------------------------------------
commit:2ea02bc
/////////////////////////////////////////////////////////////////////////
1: import javax.xml.transform.Source;
1: import javax.xml.transform.stream.StreamSource;
/////////////////////////////////////////////////////////////////////////
0:             // need to pull the spring schemas from the classpath and find reelvant
0:             // constants for the system id etc something like ...
0:             //PluggableSchemaResolver resolver =
0:             //        new PluggableSchemaResolver(getClass().getClassLoader());
0:             //InputSource springBeans = resolver.resolveEntity("http://www.springframework.org/schema/beans",
0:             //                                                "http://www.springframework.org/schema/beans/spring-beans-2.0.xsd");
0:             //LOG.trace("Beans schema:" + springBeans);
0:             schema = schemaFactory.newSchema(
0:                     new Source[]{new StreamSource(getClass().getResource("/activemq.xsd").toExternalForm()),
0:                             new StreamSource("http://www.springframework.org/schema/beans/spring-beans-2.0.xsd")});
commit:e8ea6cd
/////////////////////////////////////////////////////////////////////////
0: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.Queue;
0: import org.apache.activemq.broker.region.Topic;
0: import org.apache.activemq.broker.region.policy.PolicyEntry;
0: import org.apache.activemq.broker.region.policy.PolicyMap;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.schema.core.DtoPolicyEntry;
0: import org.apache.activemq.schema.core.DtoPolicyMap;
/////////////////////////////////////////////////////////////////////////
1:                 DtoBroker.DestinationPolicy.class,
/////////////////////////////////////////////////////////////////////////
0:         if (current.equals(modified)) {
0:             LOG.debug("no changes to " + upDatable.getSimpleName());
0:             return;
0:         } else {
0:             info("changes to " + upDatable.getSimpleName());
0:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:         List<Object> answer = new ArrayList<Object>();
0:             Object val = o.getClass().getMethod("getContents", new Class[]{}).invoke(o, new Object[]{});
0:             if (val instanceof List) {
0:                 answer = (List<Object>) val;
0:             } else {
0:                 answer.add(val);
0:             }
0:         return answer;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0: 
0:         } else if (candidate instanceof DtoPolicyMap) {
0: 
0:             List<Object> existingEntries = filter(existing, DtoPolicyMap.PolicyEntries.class);
0:             List<Object> candidateEntries = filter(candidate, DtoPolicyMap.PolicyEntries.class);
0:             // walk the map for mods
0:             applyModifications(getContents(existingEntries.get(0)), getContents(candidateEntries.get(0)));
0: 
0:         } else if (candidate instanceof DtoPolicyEntry) {
0: 
0:             PolicyMap existingMap = getBrokerService().getDestinationPolicy();
0: 
0:             PolicyEntry updatedEntry = fromDto(candidate, new PolicyEntry());
0: 
0:             Set existingEntry = existingMap.get(updatedEntry.getDestination());
0:             if (existingEntry.size() == 1) {
0:                 updatedEntry = fromDto(candidate, (PolicyEntry) existingEntry.iterator().next());
0:                 applyRetrospectively(updatedEntry);
0:                 info("updated policy for: " + updatedEntry.getDestination());
0:             } else {
0:                 info("cannot modify policy matching multiple destinations: " + existingEntry + ", destination:" + updatedEntry.getDestination());
0:             }
0: 
0:     private void applyRetrospectively(PolicyEntry updatedEntry) {
0:         RegionBroker regionBroker = (RegionBroker) getBrokerService().getRegionBroker();
0:         for (Destination destination : regionBroker.getDestinations(updatedEntry.getDestination())) {
0:             if (destination.getActiveMQDestination().isQueue()) {
0:                 updatedEntry.update((Queue) destination);
0:             } else if (destination.getActiveMQDestination().isTopic()) {
0:                 updatedEntry.update((Topic) destination);
0:             }
0:             LOG.debug("applied update to:" + destination);
0:         }
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         } else if (o instanceof DtoPolicyEntry) {
0: 
0:             PolicyEntry addition = fromDto(o, new PolicyEntry());
0:             PolicyMap existingMap = getBrokerService().getDestinationPolicy();
0:             existingMap.put(addition.getDestination(), addition);
0:             applyRetrospectively(addition);
0:             info("added policy for: " + addition.getDestination());
0: 
0:             info("No runtime support for additions of " + o);
commit:4d3923a
/////////////////////////////////////////////////////////////////////////
commit:8d480b4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.Broker;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.virtual.CompositeQueue;
0: import org.apache.activemq.broker.region.virtual.CompositeTopic;
0: import org.apache.activemq.broker.region.virtual.VirtualDestinationInterceptor;
0: import org.apache.activemq.broker.region.virtual.VirtualTopic;
0: import org.apache.activemq.filter.DestinationMapEntry;
0: import org.apache.activemq.network.NetworkConnector;
0: import org.apache.activemq.schema.core.DtoAuthorizationEntry;
0: import org.apache.activemq.schema.core.DtoAuthorizationMap;
0: import org.apache.activemq.schema.core.DtoAuthorizationPlugin;
0: import org.apache.activemq.schema.core.DtoBroker;
0: import org.apache.activemq.schema.core.DtoCompositeQueue;
0: import org.apache.activemq.schema.core.DtoCompositeTopic;
0: import org.apache.activemq.schema.core.DtoNetworkConnector;
0: import org.apache.activemq.schema.core.DtoVirtualDestinationInterceptor;
0: import org.apache.activemq.schema.core.DtoVirtualTopic;
0: import org.apache.activemq.security.AuthorizationBroker;
0: import org.apache.activemq.security.AuthorizationMap;
0: import org.apache.activemq.security.TempDestinationAuthorizationEntry;
0: import org.apache.activemq.security.XBeanAuthorizationEntry;
0: import org.apache.activemq.security.XBeanAuthorizationMap;
/////////////////////////////////////////////////////////////////////////
0:     private final ReentrantReadWriteLock addDestinationBarrier = new ReentrantReadWriteLock();
1:     private DtoBroker currentConfiguration;
1:     public RuntimeConfigurationBroker(Broker next) {
/////////////////////////////////////////////////////////////////////////
1:         if (objectName != null) {
/////////////////////////////////////////////////////////////////////////
1:         DtoBroker changed = loadConfiguration(configToMonitor);
/////////////////////////////////////////////////////////////////////////
1:     private void processSelectiveChanges(DtoBroker currentConfiguration, DtoBroker modifiedConfiguration) {
1:         for (Class upDatable : new Class[]{
1:                 DtoBroker.NetworkConnectors.class,
1:                 DtoBroker.DestinationInterceptors.class,
0:                 DtoBroker.Plugins.class}) {
1:             processChanges(currentConfiguration, modifiedConfiguration, upDatable);
1:     private void processChanges(DtoBroker currentConfiguration, DtoBroker modifiedConfiguration, Class upDatable) {
/////////////////////////////////////////////////////////////////////////
0:             if (!existing.equals(candidate)) {
0:                 modify(existing, candidate);
/////////////////////////////////////////////////////////////////////////
0:     private void modify(Object existing, Object candidate) {
0:         if (candidate instanceof DtoAuthorizationPlugin) {
0:             try {
0:                 // replace authorization map - need exclusive write lock to total broker
0:                 AuthorizationBroker authorizationBroker =
0:                         (AuthorizationBroker) getBrokerService().getBroker().getAdaptor(AuthorizationBroker.class);
0: 
0:                 authorizationBroker.setAuthorizationMap(fromDto(filter(candidate, DtoAuthorizationPlugin.Map.class)));
0:             } catch (Exception e) {
0:                 info("failed to apply modified AuthorizationMap to AuthorizationBroker", e);
0:             }
0:         } else {
0:             remove(existing);
0:             addNew(candidate);
0:         }
0:     }
0: 
0:     private AuthorizationMap fromDto(List<Object> map) {
0:         XBeanAuthorizationMap xBeanAuthorizationMap = new XBeanAuthorizationMap();
0:         for (Object o : map) {
0:             if (o instanceof DtoAuthorizationPlugin.Map) {
0:                 DtoAuthorizationPlugin.Map dtoMap = (DtoAuthorizationPlugin.Map) o;
0:                 List<DestinationMapEntry> entries = new LinkedList<DestinationMapEntry>();
0:                 // revisit - would like to map getAuthorizationMap to generic getContents
0:                 for (Object authMap : filter(dtoMap.getAuthorizationMap(), DtoAuthorizationMap.AuthorizationEntries.class)) {
0:                     for (Object entry : filter(getContents(authMap), DtoAuthorizationEntry.class)) {
0:                         entries.add(fromDto(entry, new XBeanAuthorizationEntry()));
0:                     }
0:                 }
0:                 xBeanAuthorizationMap.setAuthorizationEntries(entries);
0:                 try {
0:                     xBeanAuthorizationMap.afterPropertiesSet();
0:                 } catch (Exception e) {
0:                     info("failed to update xBeanAuthorizationMap auth entries:", e);
0:                 }
0: 
0:                 for (Object entry : filter(dtoMap.getAuthorizationMap(), DtoAuthorizationMap.TempDestinationAuthorizationEntry.class)) {
0:                     // another restriction - would like to be getContents
0:                     DtoAuthorizationMap.TempDestinationAuthorizationEntry dtoEntry = (DtoAuthorizationMap.TempDestinationAuthorizationEntry) entry;
0:                     xBeanAuthorizationMap.setTempDestinationAuthorizationEntry(fromDto(dtoEntry.getTempDestinationAuthorizationEntry(), new TempDestinationAuthorizationEntry()));
0:                 }
0: 
0:             } else {
0:                 info("No support for updates to: " + o);
0:             }
0:         }
0:         return xBeanAuthorizationMap;
0:     }
0: 
0:         if (o instanceof DtoNetworkConnector) {
0:             DtoNetworkConnector toRemove = (DtoNetworkConnector) o;
0:             for (NetworkConnector existingCandidate :
/////////////////////////////////////////////////////////////////////////
0:         } else if (o instanceof DtoVirtualDestinationInterceptor) {
0:                         if (!(candidate instanceof VirtualDestinationInterceptor)) {
/////////////////////////////////////////////////////////////////////////
0:     private boolean configMatch(DtoNetworkConnector dto, NetworkConnector candidate) {
/////////////////////////////////////////////////////////////////////////
0:         if (o instanceof DtoNetworkConnector) {
0:             DtoNetworkConnector networkConnector = (DtoNetworkConnector) o;
0:                     NetworkConnector nc =
/////////////////////////////////////////////////////////////////////////
0:         } else if (o instanceof DtoVirtualDestinationInterceptor) {
0:             final DtoVirtualDestinationInterceptor dto = (DtoVirtualDestinationInterceptor) o;
0:                         if (destinationInterceptor instanceof VirtualDestinationInterceptor) {
0:                             final VirtualDestinationInterceptor virtualDestinationInterceptor =
0:                                     (VirtualDestinationInterceptor) destinationInterceptor;
/////////////////////////////////////////////////////////////////////////
0:                         VirtualDestinationInterceptor virtualDestinationInterceptor =
0:                                 new VirtualDestinationInterceptor();
/////////////////////////////////////////////////////////////////////////
0:                         RegionBroker regionBroker = (RegionBroker) getBrokerService().getRegionBroker();
0:                         ((CompositeDestinationInterceptor) regionBroker.getDestinationInterceptor()).setInterceptors(destinationInterceptors);
0:                         Thread.dumpStack();
/////////////////////////////////////////////////////////////////////////
0:     private VirtualDestination[] fromDto(DtoVirtualDestinationInterceptor virtualDestinationInterceptor) {
0:         for (Object vd : filter(virtualDestinationInterceptor, DtoVirtualDestinationInterceptor.VirtualDestinations.class)) {
0:             for (Object vt : filter(vd, DtoVirtualTopic.class)) {
0:                 answer.add(fromDto(vt, new VirtualTopic()));
0:             for (Object vt : filter(vd, DtoCompositeTopic.class)) {
0:                 answer.add(fromDto(vt, new CompositeTopic()));
0:             for (Object vt : filter(vd, DtoCompositeQueue.class)) {
0:                 answer.add(fromDto(vt, new CompositeQueue()));
/////////////////////////////////////////////////////////////////////////
0:     private <T> T fromDto(Object dto, T instance) {
/////////////////////////////////////////////////////////////////////////
1:     private DtoBroker loadConfiguration(Resource configToMonitor) {
1:         DtoBroker jaxbConfig = null;
1:                 JAXBContext context = JAXBContext.newInstance(DtoBroker.class);
/////////////////////////////////////////////////////////////////////////
0:                 JAXBElement<DtoBroker> brokerJAXBElement =
0:                         unMarshaller.unmarshal(brokerRootNode, DtoBroker.class);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
1:     public void setCheckPeriod(long checkPeriod) {
1:         this.checkPeriod = checkPeriod;
0:     }
commit:a52c014
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private Schema schema;
/////////////////////////////////////////////////////////////////////////
1:                     XMLConstants.W3C_XML_SCHEMA_NS_URI);
0:             schema = schemaFactory.newSchema(getClass().getResource("/activemq.xsd"));
commit:8b8e726
/////////////////////////////////////////////////////////////////////////
0: import java.net.URL;
/////////////////////////////////////////////////////////////////////////
1: import javax.management.JMException;
1: import javax.management.ObjectName;
1: import javax.xml.XMLConstants;
/////////////////////////////////////////////////////////////////////////
1: import javax.xml.validation.Schema;
1: import javax.xml.validation.SchemaFactory;
0: import javax.xml.validation.Validator;
0: import javax.xml.validation.ValidatorHandler;
0: import org.apache.activemq.broker.jmx.ManagementContext;
0: import org.apache.activemq.plugin.jmx.RuntimeConfigurationView;
/////////////////////////////////////////////////////////////////////////
1:     public static final String objectNamePropsAppendage = ",service=RuntimeConfiguration,name=Plugin";
/////////////////////////////////////////////////////////////////////////
0:     private ObjectName objectName;
0:     private String infoString;
/////////////////////////////////////////////////////////////////////////
1:         registerMbean();
/////////////////////////////////////////////////////////////////////////
0:         unregisterMbean();
0:     private void registerMbean() {
1:         if (getBrokerService().isUseJmx()) {
1:             ManagementContext managementContext = getBrokerService().getManagementContext();
0:             try {
1:                 objectName = new ObjectName(getBrokerService().getBrokerObjectName().toString() + objectNamePropsAppendage);
1:                 managementContext.registerMBean(new RuntimeConfigurationView(this), objectName);
1:             } catch (Exception ignored) {
1:                 LOG.debug("failed to register RuntimeConfigurationMBean", ignored);
0:             }
0:         }
0:     }
0: 
0:     private void unregisterMbean() {
0:         if  (objectName != null) {
0:             try {
1:                 getBrokerService().getManagementContext().unregisterMBean(objectName);
1:             } catch (JMException ignored) {
0:             }
0:         }
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:     public String updateNow() {
1:         LOG.info("Manual configuration update triggered");
1:         infoString = "";
1:         applyModifications(configToMonitor);
1:         String result = infoString;
1:         infoString = null;
0:         return result;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:         if (lastModified > 0 && checkPeriod > 0) {
0:             info("Monitoring for updates (every " + checkPeriod + "millis) : " + configToMonitor);
0:     private void info(String s) {
0:         LOG.info(s);
0:         if (infoString != null) {
0:             infoString += s;
0:             infoString += ";";
0:         }
0:     }
0: 
0:     private void info(String s, Throwable t) {
0:         LOG.info(s, t);
0:         if (infoString != null) {
0:             infoString += s;
0:             infoString += ", " + t;
0:             infoString += ";";
0:         }
0:     }
0: 
0: 
1:         if (changed != null && !currentConfiguration.equals(changed)) {
1:             LOG.info("change in " + configToMonitor + " at: " + new Date(lastModified));
0:             LOG.debug("current:" + currentConfiguration);
0:             LOG.debug("new    :" + changed);
1:             info("No material change to configuration in " + configToMonitor + " at: " + new Date(lastModified));
/////////////////////////////////////////////////////////////////////////
0:             info("Failed to access getContents for " + o + ", runtime modifications not supported", e);
/////////////////////////////////////////////////////////////////////////
0:                 info("modification to:" + existing + " , with: " + candidate);
/////////////////////////////////////////////////////////////////////////
0:                             info("stopped and removed networkConnector: " + existingCandidate);
0:                             info("Failed to stop removed network connector: " + existingCandidate);
/////////////////////////////////////////////////////////////////////////
0:                     info("removed VirtualDestinationInterceptor from: " + interceptorsList);
0:             info("No runtime support for removal of: " + o);
/////////////////////////////////////////////////////////////////////////
0:                     info("started new network connector: " + nc);
0:                     info("Failed to add new networkConnector " + networkConnector, e);
/////////////////////////////////////////////////////////////////////////
0:                             info("applied updates to: " + virtualDestinationInterceptor);
/////////////////////////////////////////////////////////////////////////
0:                         info("applied new: " + interceptorsList);
0:             info("No runtime support for modifications to " + o);
/////////////////////////////////////////////////////////////////////////
1:                 unMarshaller.setSchema(getSchema());
/////////////////////////////////////////////////////////////////////////
1:                 info("Failed to access: " + configToMonitor, e);
1:                 info("Failed to parse: " + configToMonitor, e);
1:                 info("Failed to document parse: " + configToMonitor, e);
1:                 info("Failed to find broker element in: " + configToMonitor, e);
0:     private Schema schema;
0:     private Schema getSchema() throws SAXException {
1:         if (schema == null) {
1:             SchemaFactory schemaFactory = SchemaFactory.newInstance(
0:                                     XMLConstants.W3C_XML_SCHEMA_NS_URI);
0:                 schema = schemaFactory.newSchema(getClass().getResource("/activemq.xsd"));
0:         }
1:         return schema;
0:     }
0: 
0: 
1:     public long getLastModified() {
1:         return lastModified;
0:     }
0: 
1:     public Resource getConfigToMonitor() {
1:         return configToMonitor;
0:     }
0: 
1:     public long getCheckPeriod() {
1:         return checkPeriod;
0:     }
commit:92860ae
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
0: import java.util.Arrays;
0: import java.util.concurrent.ConcurrentLinkedQueue;
0: import java.util.concurrent.locks.ReentrantReadWriteLock;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.ConnectionContext;
0: import org.apache.activemq.broker.region.CompositeDestinationInterceptor;
0: import org.apache.activemq.broker.region.Destination;
0: import org.apache.activemq.broker.region.DestinationInterceptor;
0: import org.apache.activemq.broker.region.RegionBroker;
0: import org.apache.activemq.broker.region.virtual.VirtualDestination;
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.schema.core.CompositeQueue;
0: import org.apache.activemq.schema.core.CompositeTopic;
0: import org.apache.activemq.schema.core.VirtualDestinationInterceptor;
0: import org.apache.activemq.schema.core.VirtualTopic;
/////////////////////////////////////////////////////////////////////////
0:     private ConcurrentLinkedQueue<Runnable> destinationInterceptorUpdateWork = new ConcurrentLinkedQueue<Runnable>();
0:     private final ReentrantReadWriteLock addDestinationBarrier = new ReentrantReadWriteLock();
/////////////////////////////////////////////////////////////////////////
0:     // modification to virtual destinations interceptor needs exclusive access to destination add
1:     @Override
0:     public Destination addDestination(ConnectionContext context, ActiveMQDestination destination, boolean createIfTemporary) throws Exception {
0:         Runnable work = destinationInterceptorUpdateWork.poll();
0:         if (work != null) {
0:             try {
0:                 addDestinationBarrier.writeLock().lockInterruptibly();
0:                 do {
0:                     work.run();
0:                     work = destinationInterceptorUpdateWork.poll();
0:                 } while (work != null);
0:                 return super.addDestination(context, destination, createIfTemporary);
0:             } finally {
0:                 addDestinationBarrier.writeLock().unlock();
0:             }
0:         } else {
0:             try {
0:                 addDestinationBarrier.readLock().lockInterruptibly();
0:                 return super.addDestination(context, destination, createIfTemporary);
0:             } finally {
0:                 addDestinationBarrier.readLock().unlock();
0:             }
0:         }
0:     }
0: 
1:         monitorTask = new Runnable() {
/////////////////////////////////////////////////////////////////////////
1:             processSelectiveChanges(currentConfiguration, changed);
0:     private void processSelectiveChanges(Broker currentConfiguration, Broker modifiedConfiguration) {
0: 
0:         for (Class upDatable : new Class[]{Broker.NetworkConnectors.class, Broker.DestinationInterceptors.class}) {
0:              processChanges(currentConfiguration, modifiedConfiguration, upDatable);
0:         }
0:     }
0: 
0:     private void processChanges(Broker currentConfiguration, Broker modifiedConfiguration, Class upDatable) {
0: 
0:         List current = filter(currentConfiguration, upDatable);
0:         List modified = filter(modifiedConfiguration, upDatable);
0:         for (; modIndex < modified.size() && currentIndex < current.size(); modIndex++, currentIndex++) {
0:             // walk the list for mods
0:             applyModifications(getContents(current.get(currentIndex)),
0:                     getContents(modified.get(modIndex)));
0:         for (; modIndex < modified.size(); modIndex++) {
0:             // new element; add all
0:             for (Object nc : getContents(modified.get(modIndex))) {
0:                 addNew(nc);
0:         for (; currentIndex < current.size(); currentIndex++) {
0:             // removal of element; remove all
0:             for (Object nc : getContents(current.get(currentIndex))) {
0:                 remove(nc);
0:     // mapping all supported updatable elements to support getContents
0:     private List<Object> getContents(Object o) {
0:         try {
0:             return (List<Object>) o.getClass().getMethod("getContents", new Class[]{}).invoke(o, new Object[]{});
0:         } catch (Exception e) {
0:             LOG.info("Failed to access getContents for " + o + ", runtime modifications not supported", e);
0:         }
0:         return new ArrayList<Object>();
0:     }
0: 
0:             Object existing = current.get(currentIndex);
0:             Object candidate = modification.get(modIndex);
0:             if (! existing.equals(candidate)) {
0:                 LOG.info("modification to:" + existing + " , with: " + candidate);
0:                 remove(existing);
0:                 addNew(candidate);
0:             addNew(modification.get(modIndex));
0:             remove(current.get(currentIndex));
0:     private void remove(Object o) {
/////////////////////////////////////////////////////////////////////////
0:         } else if (o instanceof VirtualDestinationInterceptor) {
0:             // whack it
0:             destinationInterceptorUpdateWork.add(new Runnable() {
0:                 public void run() {
0:                     List<DestinationInterceptor> interceptorsList = new ArrayList<DestinationInterceptor>();
0:                     for (DestinationInterceptor candidate : getBrokerService().getDestinationInterceptors()) {
0:                         if (!(candidate instanceof org.apache.activemq.broker.region.virtual.VirtualDestinationInterceptor)) {
0:                             interceptorsList.add(candidate);
0:                         }
0:                     }
0:                     DestinationInterceptor[] destinationInterceptors = interceptorsList.toArray(new DestinationInterceptor[]{});
0:                     getBrokerService().setDestinationInterceptors(destinationInterceptors);
0:                     ((CompositeDestinationInterceptor) ((RegionBroker) getBrokerService().getRegionBroker()).getDestinationInterceptor()).setInterceptors(destinationInterceptors);
0:                     LOG.trace("removed VirtualDestinationInterceptor from: " + interceptorsList);
0:                 }
0:             });
0:         } else {
0:             LOG.info("No runtime support for removal of: " + o);
/////////////////////////////////////////////////////////////////////////
0:     private void addNew(Object o) {
/////////////////////////////////////////////////////////////////////////
0:                     LOG.trace("applying networkConnector props: " + properties);
/////////////////////////////////////////////////////////////////////////
0:         } else if (o instanceof VirtualDestinationInterceptor) {
0:             final VirtualDestinationInterceptor dto = (VirtualDestinationInterceptor) o;
0:             destinationInterceptorUpdateWork.add(new Runnable() {
0:                 public void run() {
0: 
0:                     boolean updatedExistingInterceptor = false;
0: 
0:                     for (DestinationInterceptor destinationInterceptor : getBrokerService().getDestinationInterceptors()) {
0:                         if (destinationInterceptor instanceof org.apache.activemq.broker.region.virtual.VirtualDestinationInterceptor) {
0:                             // update existing interceptor
0:                             final org.apache.activemq.broker.region.virtual.VirtualDestinationInterceptor virtualDestinationInterceptor =
0:                                     (org.apache.activemq.broker.region.virtual.VirtualDestinationInterceptor) destinationInterceptor;
0: 
0:                             virtualDestinationInterceptor.setVirtualDestinations(fromDto(dto));
0:                             LOG.trace("applied updates to: " + virtualDestinationInterceptor);
0:                             updatedExistingInterceptor = true;
0:                         }
0:                     }
0: 
0:                     if (!updatedExistingInterceptor) {
0:                         // add
0:                         org.apache.activemq.broker.region.virtual.VirtualDestinationInterceptor virtualDestinationInterceptor =
0:                                 new org.apache.activemq.broker.region.virtual.VirtualDestinationInterceptor();
0:                         virtualDestinationInterceptor.setVirtualDestinations(fromDto(dto));
0: 
0:                         List<DestinationInterceptor> interceptorsList = new ArrayList<DestinationInterceptor>();
0:                         interceptorsList.addAll(Arrays.asList(getBrokerService().getDestinationInterceptors()));
0:                         interceptorsList.add(virtualDestinationInterceptor);
0: 
0:                         DestinationInterceptor[] destinationInterceptors = interceptorsList.toArray(new DestinationInterceptor[]{});
0:                         getBrokerService().setDestinationInterceptors(destinationInterceptors);
0:                         ((CompositeDestinationInterceptor) ((RegionBroker) getBrokerService().getRegionBroker()).getDestinationInterceptor()).setInterceptors(destinationInterceptors);
0:                         LOG.trace("applied new: " + interceptorsList);
0:                     }
0:                 }
0:             });
0:     private VirtualDestination[] fromDto(VirtualDestinationInterceptor virtualDestinationInterceptor) {
0:         List<VirtualDestination> answer = new ArrayList<VirtualDestination>();
0:         for (Object vd : filter(virtualDestinationInterceptor, VirtualDestinationInterceptor.VirtualDestinations.class)) {
0:             for (Object vt : filter(vd, VirtualTopic.class)) {
0:                 answer.add(fromDto(vt, new org.apache.activemq.broker.region.virtual.VirtualTopic()));
0:             }
0:             for (Object vt : filter(vd, CompositeTopic.class)) {
0:                 answer.add(fromDto(vt, new org.apache.activemq.broker.region.virtual.CompositeTopic()));
0:             }
0:             for (Object vt : filter(vd, CompositeQueue.class)) {
0:                 answer.add(fromDto(vt, new org.apache.activemq.broker.region.virtual.CompositeQueue()));
0:             }
0:         }
0:         VirtualDestination[] array = new VirtualDestination[answer.size()];
0:         answer.toArray(array);
0:         return array;
0:     }
0: 
0:     private VirtualDestination fromDto(Object dto, VirtualDestination instance) {
0:         Properties properties = new Properties();
0:         IntrospectionSupport.getProperties(dto, properties, null);
0:         LOG.trace("applying props: " + properties + ", to " + instance.getClass().getSimpleName());
0:         IntrospectionSupport.setProperties(instance, properties);
0:         return instance;
0:     }
0: 
0:     private <T> List<Object> filter(Object obj, Class<T> type) {
0:         return filter(getContents(obj), type);
0:     }
0: 
0:     private <T> List<Object> filter(List<Object> objectList, Class<T> type) {
0:         List<Object> result = new LinkedList<Object>();
0:             } else if (type.isAssignableFrom(o.getClass())) {
0:                 result.add((T) o);
commit:25a1dd0
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collections;
0: import java.util.TreeMap;
/////////////////////////////////////////////////////////////////////////
0:         List<Broker.NetworkConnectors> currentNCsElems = filterElement(
0:         List<Broker.NetworkConnectors> modifiedNCsElems = filterElement(
0:         for (; modIndex < modifiedNCsElems.size() && currentIndex < currentNCsElems.size(); modIndex++, currentIndex++) {
0:             // walk the list of individual nc's...
0:             applyModifications(currentNCsElems.get(currentIndex).getContents(),
0:                     modifiedNCsElems.get(modIndex).getContents());
0:         }
0: 
0:         for (; modIndex < modifiedNCsElems.size(); modIndex++) {
0:             // new networkConnectors element; add all
0:             for (Object nc : modifiedNCsElems.get(modIndex).getContents()) {
0:                 addNetworkConnector(nc);
0:         for (; currentIndex < currentNCsElems.size(); currentIndex++) {
0:             // removal of networkConnectors element; remove all
0:             for (Object nc : modifiedNCsElems.get(modIndex).getContents()) {
0:                 removeNetworkConnector(nc);
0:             }
0:     private void applyModifications(List<Object> current, List<Object> modification) {
0:         int modIndex = 0, currentIndex = 0;
0:         for (; modIndex < modification.size() && currentIndex < current.size(); modIndex++, currentIndex++) {
0:             Object currentNc = current.get(currentIndex);
0:             Object candidateNc = modification.get(modIndex);
0:             if (! currentNc.equals(candidateNc)) {
0:                 LOG.info("modification to:" + currentNc + " , with: " + candidateNc);
0:                 removeNetworkConnector(currentNc);
0:                 addNetworkConnector(candidateNc);
0:             }
0:         }
0: 
0:         for (; modIndex < modification.size(); modIndex++) {
0:             addNetworkConnector(modification.get(modIndex));
0:         }
0: 
0:         for (; currentIndex < current.size(); currentIndex++) {
0:             removeNetworkConnector(current.get(currentIndex));
0:         }
0:     }
0: 
0:     private void removeNetworkConnector(Object o) {
0:         if (o instanceof NetworkConnector) {
0:             NetworkConnector toRemove = (NetworkConnector) o;
0:             for (org.apache.activemq.network.NetworkConnector existingCandidate :
0:                     getBrokerService().getNetworkConnectors()) {
0:                 if (configMatch(toRemove, existingCandidate)) {
0:                     if (getBrokerService().removeNetworkConnector(existingCandidate)) {
0:                         try {
0:                             existingCandidate.stop();
0:                             LOG.info("stopped and removed networkConnector: " + existingCandidate);
0:                         } catch (Exception e) {
0:                             LOG.error("Failed to stop removed network connector: " + existingCandidate);
0:                         }
0:                     }
0:                 }
0:             }
0:         }
0:     }
0: 
0:     private boolean configMatch(NetworkConnector dto, org.apache.activemq.network.NetworkConnector candidate) {
0:         TreeMap<String, String> dtoProps = new TreeMap<String, String>();
0:         IntrospectionSupport.getProperties(dto, dtoProps, null);
0: 
0:         TreeMap<String, String> candidateProps = new TreeMap<String, String>();
0:         IntrospectionSupport.getProperties(candidate, candidateProps, null);
0: 
0:         // every dto prop must be present in the candidate
0:         for (String key : dtoProps.keySet()) {
0:             if (!candidateProps.containsKey(key) || !candidateProps.get(key).equals(dtoProps.get(key))) {
0:                 return false;
0:             }
0:         }
0:         return true;
0:     }
0: 
commit:3630a41
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.plugin;
0: 
0: import java.io.IOException;
0: import java.util.Date;
0: import java.util.LinkedList;
0: import java.util.List;
0: import java.util.Properties;
1: import javax.xml.bind.JAXBContext;
1: import javax.xml.bind.JAXBElement;
1: import javax.xml.bind.JAXBException;
1: import javax.xml.bind.Unmarshaller;
1: import javax.xml.parsers.DocumentBuilder;
1: import javax.xml.parsers.DocumentBuilderFactory;
1: import javax.xml.parsers.ParserConfigurationException;
0: import org.apache.activemq.broker.BrokerFilter;
0: import org.apache.activemq.schema.core.Broker;
0: import org.apache.activemq.schema.core.NetworkConnector;
0: import org.apache.activemq.spring.Utils;
0: import org.apache.activemq.util.IntrospectionSupport;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
0: import org.springframework.core.io.Resource;
0: import org.w3c.dom.Document;
0: import org.w3c.dom.Node;
0: import org.xml.sax.SAXException;
0: 
0: public class RuntimeConfigurationBroker extends BrokerFilter {
0: 
1:     public static final Logger LOG = LoggerFactory.getLogger(RuntimeConfigurationBroker.class);
1:     private long checkPeriod;
1:     private long lastModified = -1;
1:     private Resource configToMonitor;
0:     private Broker currentConfiguration;
0:     private Runnable monitorTask;
0: 
0:     public RuntimeConfigurationBroker(org.apache.activemq.broker.Broker next) {
1:         super(next);
0:     }
0: 
1:     @Override
1:     public void start() throws Exception {
1:         super.start();
0:         try {
0:             configToMonitor = Utils.resourceFromString(next.getBrokerService().getConfigurationUrl());
1:         } catch (Exception error) {
1:             LOG.error("failed to determine configuration url resource from broker, updates cannot be tracked", error);
0:         }
0: 
1:         currentConfiguration = loadConfiguration(configToMonitor);
1:         monitorModification(configToMonitor);
0:     }
0: 
1:     @Override
0:     public void stop() throws Exception {
0:         if (monitorTask != null) {
0:             try {
0:                 this.getBrokerService().getScheduler().cancel(monitorTask);
0:             } catch (Exception letsNotStopStop) {
0:                 LOG.warn("Failed to cancel config monitor task", letsNotStopStop);
0:             }
0:         }
0:         super.stop();
0:     }
0: 
1:     private void monitorModification(final Resource configToMonitor) {
0:         Runnable monitorTask = new Runnable() {
1:             @Override
0:             public void run() {
0:                 try {
1:                     if (configToMonitor.lastModified() > lastModified) {
1:                         applyModifications(configToMonitor);
0:                     }
0:                 } catch (IOException e) {
1:                     LOG.error("Failed to determine lastModified time on configuration: " + configToMonitor, e);
0:                 }
0:             }
1:         };
0:         if (lastModified > 0) {
1:             this.getBrokerService().getScheduler().executePeriodically(monitorTask, checkPeriod);
0:             LOG.info("Monitoring for updates (every " + checkPeriod + "millis) : " + configToMonitor);
0:         }
0:     }
0: 
1:     private void applyModifications(Resource configToMonitor) {
0:         Broker changed = loadConfiguration(configToMonitor);
0:         if (!currentConfiguration.equals(changed)) {
0:             LOG.info("configuration change in " + configToMonitor + " at: " + new Date(lastModified));
0:             LOG.info("current:" + currentConfiguration);
0:             LOG.info("new    :" + changed);
0:             processNetworkConnectors(currentConfiguration, changed);
1:             currentConfiguration = changed;
0:         } else {
0:             LOG.info("file modification but no material change to configuration in " + configToMonitor + " at: " + new Date(lastModified));
0:         }
0:     }
0: 
0:     private void processNetworkConnectors(Broker currentConfiguration, Broker modifiedConfiguration) {
0:         List<Broker.NetworkConnectors> currentNc = filterElement(
0:                 currentConfiguration.getContents(), Broker.NetworkConnectors.class);
0:         List<Broker.NetworkConnectors> modNc = filterElement(
0:                 modifiedConfiguration.getContents(), Broker.NetworkConnectors.class);
0: 
0:         int modIndex = 0, currentIndex = 0;
0:         for (; modIndex < modNc.size() && currentIndex < currentNc.size(); modIndex++, currentIndex++) {
0:             if (!modNc.get(modIndex).getContents().get(0).equals(
0:                     currentNc.get(currentIndex).getContents().get(0))) {
0:                 // change in order will fool this logic
0:                 LOG.error("not supported: mod to existing network Connector, new: "
0:                         + modNc.get(modIndex).getContents().get(0));
0:             }
0:         }
0: 
0:         for (; modIndex < modNc.size(); modIndex++) {
0:             // additions
0:             addNetworkConnector(modNc.get(modIndex).getContents().get(0));
0:         }
0:     }
0: 
0:     private void addNetworkConnector(Object o) {
0:         if (o instanceof NetworkConnector) {
0:             NetworkConnector networkConnector = (NetworkConnector) o;
0:             if (networkConnector.getUri() != null) {
0:                 try {
0:                     org.apache.activemq.network.NetworkConnector nc =
0:                             getBrokerService().addNetworkConnector(networkConnector.getUri());
0:                     Properties properties = new Properties();
0:                     IntrospectionSupport.getProperties(networkConnector, properties, null);
0:                     properties.remove("uri");
0:                     LOG.trace("Applying props: " + properties);
0:                     IntrospectionSupport.setProperties(nc, properties);
0:                     nc.start();
0:                     LOG.info("started new network connector: " + nc);
0:                 } catch (Exception e) {
0:                     LOG.error("Failed to add new networkConnector " + networkConnector, e);
0:                 }
0:             }
0:         } else {
0:             LOG.info("No runtime support for modifications to " + o);
0:         }
0:     }
0: 
0:     private <T> List<T> filterElement(List<Object> objectList, Class<T> type) {
0:         List<T> result = new LinkedList<T>();
0:         for (Object o : objectList) {
0:             if (o instanceof JAXBElement) {
0:                 JAXBElement element = (JAXBElement) o;
0:                 if (element.getDeclaredType() == type) {
0:                     result.add((T) element.getValue());
0:                 }
0:             }
0:         }
0:         return result;
0:     }
0: 
0:     private Broker loadConfiguration(Resource configToMonitor) {
0:         Broker jaxbConfig = null;
1:         if (configToMonitor != null) {
0:             try {
0:                 JAXBContext context = JAXBContext.newInstance(Broker.class);
1:                 Unmarshaller unMarshaller = context.createUnmarshaller();
0: 
1:                 // skip beans and pull out the broker node to validate
1:                 DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
1:                 dbf.setNamespaceAware(true);
1:                 DocumentBuilder db = dbf.newDocumentBuilder();
1:                 Document doc = db.parse(configToMonitor.getInputStream());
0:                 Node brokerRootNode = doc.getElementsByTagName("broker").item(0);
0: 
0:                 JAXBElement<Broker> brokerJAXBElement =
0:                         unMarshaller.unmarshal(brokerRootNode, Broker.class);
0:                 jaxbConfig = brokerJAXBElement.getValue();
0: 
0:                 // if we can parse we can track mods
0:                 lastModified = configToMonitor.lastModified();
0: 
0:             } catch (IOException e) {
0:                 LOG.error("Failed to access: " + configToMonitor, e);
1:             } catch (JAXBException e) {
0:                 LOG.error("Failed to parse: " + configToMonitor, e);
1:             } catch (ParserConfigurationException e) {
0:                 LOG.error("Failed to document parse: " + configToMonitor, e);
1:             } catch (SAXException e) {
0:                 LOG.error("Failed to find broker element in: " + configToMonitor, e);
0:             }
0:         }
1:         return jaxbConfig;
0:     }
0: 
0:     public void setCheckPeriod(long checkPeriod) {
0:         this.checkPeriod = checkPeriod;
0:     }
0: }
============================================================================