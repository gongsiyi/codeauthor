1:31c55f7: /*
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
5:eba4c9c:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:0bbc0ac:  *
1:eba4c9c:  * Unless required by applicable law or agreed to in writing, software
1:eba4c9c:  * distributed under the License is distributed on an "AS IS" BASIS,
1:eba4c9c:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:eba4c9c:  * See the License for the specific language governing permissions and
1:eba4c9c:  * limitations under the License.
5:eba4c9c:  */
1:eba4c9c: package org.apache.activemq.transport.udp;
1:72b382d: 
1:74a7a8b: import java.io.EOFException;
1:74a7a8b: import java.io.IOException;
1:74a7a8b: import java.net.BindException;
1:74a7a8b: import java.net.DatagramSocket;
1:74a7a8b: import java.net.InetSocketAddress;
1:74a7a8b: import java.net.SocketAddress;
1:74a7a8b: import java.net.SocketException;
1:74a7a8b: import java.net.URI;
1:74a7a8b: import java.net.UnknownHostException;
1:74a7a8b: import java.nio.channels.AsynchronousCloseException;
1:74a7a8b: import java.nio.channels.DatagramChannel;
1:31c55f7: import java.security.cert.X509Certificate;
1:74a7a8b: 
1:eba4c9c: import org.apache.activemq.Service;
1:eba4c9c: import org.apache.activemq.command.Command;
1:f51ac13: import org.apache.activemq.command.Endpoint;
1:eba4c9c: import org.apache.activemq.openwire.OpenWireFormat;
1:eba4c9c: import org.apache.activemq.transport.Transport;
1:eba4c9c: import org.apache.activemq.transport.TransportThreadSupport;
1:e6954f1: import org.apache.activemq.transport.reliable.ExceptionIfDroppedReplayStrategy;
1:f3ef1a9: import org.apache.activemq.transport.reliable.ReplayBuffer;
1:e6954f1: import org.apache.activemq.transport.reliable.ReplayStrategy;
1:8d589ec: import org.apache.activemq.transport.reliable.Replayer;
1:8a1f994: import org.apache.activemq.util.InetAddressUtil;
1:364337b: import org.apache.activemq.util.IntSequenceGenerator;
1:eba4c9c: import org.apache.activemq.util.ServiceStopper;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:f51ac13: 
5:eba4c9c: /**
1:eba4c9c:  * An implementation of the {@link Transport} interface using raw UDP
1:eba4c9c:  */
1:eba4c9c: public class UdpTransport extends TransportThreadSupport implements Transport, Service, Runnable {
1:31c55f7: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(UdpTransport.class);
1:4f446eb: 
1:f812e34:     private static final int MAX_BIND_ATTEMPTS = 50;
1:f812e34:     private static final long BIND_ATTEMPT_DELAY = 100;
1:a537902: 
1:eba4c9c:     private CommandChannel commandChannel;
1:eba4c9c:     private OpenWireFormat wireFormat;
1:eba4c9c:     private ByteBufferPool bufferPool;
1:8704338:     private ReplayStrategy replayStrategy = new ExceptionIfDroppedReplayStrategy();
1:f3ef1a9:     private ReplayBuffer replayBuffer;
1:eba4c9c:     private int datagramSize = 4 * 1024;
1:4f446eb:     private SocketAddress targetAddress;
1:4f446eb:     private SocketAddress originalTargetAddress;
1:eba4c9c:     private DatagramChannel channel;
1:933eb2f:     private boolean trace;
1:05101de:     private boolean useLocalHost = false;
1:187f884:     private int port;
1:4f446eb:     private int minmumWireFormatVersion;
1:933eb2f:     private String description;
1:364337b:     private IntSequenceGenerator sequenceGenerator;
1:8d589ec:     private boolean replayEnabled = true;
1:72b382d: 
1:187f884:     protected UdpTransport(OpenWireFormat wireFormat) throws IOException {
1:eba4c9c:         this.wireFormat = wireFormat;
1:72b382d:     }
1:f812e34: 
1:eba4c9c:     public UdpTransport(OpenWireFormat wireFormat, URI remoteLocation) throws UnknownHostException, IOException {
1:eba4c9c:         this(wireFormat);
1:187f884:         this.targetAddress = createAddress(remoteLocation);
1:4f446eb:         description = remoteLocation.toString() + "@";
1:0f1dcce:     }
1:a537902: 
1:4f446eb:     public UdpTransport(OpenWireFormat wireFormat, SocketAddress socketAddress) throws IOException {
1:eba4c9c:         this(wireFormat);
1:187f884:         this.targetAddress = socketAddress;
1:df26287:         this.description = getProtocolName() + "ServerConnection@";
1:72b382d:     }
1:364337b: 
1:df26287:     /**
1:4f446eb:      * Used by the server transport
1:4f446eb:      */
1:4f446eb:     public UdpTransport(OpenWireFormat wireFormat, int port) throws UnknownHostException, IOException {
1:4f446eb:         this(wireFormat);
1:4f446eb:         this.port = port;
1:4f446eb:         this.targetAddress = null;
1:df26287:         this.description = getProtocolName() + "Server@";
1:72b382d:     }
1:8d589ec: 
1:8d589ec:     /**
1:8d589ec:      * Creates a replayer for working with the reliable transport
1:8d589ec:      */
1:f3ef1a9:     public Replayer createReplayer() throws IOException {
1:f812e34:         if (replayEnabled) {
1:f3ef1a9:             return getCommandChannel();
1:8d589ec:         }
1:0f1dcce:         return null;
1:8d589ec:     }
1:8978ac0: 
1:4f446eb:     /**
1:72b382d:      * A one way asynchronous send
1:72b382d:      */
1:31c55f7:     @Override
1:9ca56a0:     public void oneway(Object command) throws IOException {
1:08f4639:         oneway(command, targetAddress);
1:72b382d:     }
1:72b382d: 
1:72b382d:     /**
1:364337b:      * A one way asynchronous send to a given address
1:08f4639:      */
1:9ca56a0:     public void oneway(Object command, SocketAddress address) throws IOException {
1:fc00993:         if (LOG.isDebugEnabled()) {
1:fc00993:             LOG.debug("Sending oneway from: " + this + " to target: " + targetAddress + " command: " + command);
1:72b382d:         }
1:9ca56a0:         checkStarted();
1:f812e34:         commandChannel.write((Command)command, address);
1:72b382d:     }
1:72b382d: 
1:4f446eb:     /**
1:eba4c9c:      * @return pretty print of 'this'
1:187f884:      */
1:31c55f7:     @Override
1:eba4c9c:     public String toString() {
1:4f446eb:         if (description != null) {
1:4f446eb:             return description + port;
1:f812e34:         } else {
1:df26287:             return getProtocolUriScheme() + targetAddress + "@" + port;
1:72b382d:         }
1:72b382d:     }
1:72b382d: 
1:08f4639:     /**
1:eba4c9c:      * reads packets from a Socket
1:eba4c9c:      */
1:31c55f7:     @Override
1:eba4c9c:     public void run() {
1:fc00993:         LOG.trace("Consumer thread starting for: " + toString());
1:08f4639:         while (!isStopped()) {
1:a537902:             try {
1:8704338:                 Command command = commandChannel.read();
1:8704338:                 doConsume(command);
1:f812e34:             } catch (AsynchronousCloseException e) {
1:5739c6c:                 // DatagramChannel closed
1:a537902:                 try {
1:5739c6c:                     stop();
1:f812e34:                 } catch (Exception e2) {
1:fc00993:                     LOG.warn("Caught in: " + this + " while closing: " + e2 + ". Now Closed", e2);
1:72b382d:                 }
1:f812e34:             } catch (SocketException e) {
1:5739c6c:                 // DatagramSocket closed
1:fc00993:                 LOG.debug("Socket closed: " + e, e);
1:5739c6c:                 try {
1:187f884:                     stop();
1:f812e34:                 } catch (Exception e2) {
1:fc00993:                     LOG.warn("Caught in: " + this + " while closing: " + e2 + ". Now Closed", e2);
1:72b382d:                 }
1:f812e34:             } catch (EOFException e) {
1:72b382d:                 // DataInputStream closed
1:fc00993:                 LOG.debug("Socket closed: " + e, e);
1:72b382d:                 try {
1:72b382d:                     stop();
1:f812e34:                 } catch (Exception e2) {
1:fc00993:                     LOG.warn("Caught in: " + this + " while closing: " + e2 + ". Now Closed", e2);
1:72b382d:                 }
1:f812e34:             } catch (Exception e) {
1:187f884:                 try {
1:eba4c9c:                     stop();
1:f812e34:                 } catch (Exception e2) {
1:fc00993:                     LOG.warn("Caught in: " + this + " while closing: " + e2 + ". Now Closed", e2);
1:72b382d:                 }
1:187f884:                 if (e instanceof IOException) {
1:f812e34:                     onException((IOException)e);
1:f812e34:                 } else {
1:fc00993:                     LOG.error("Caught: " + e, e);
1:72b382d:                     e.printStackTrace();
1:72b382d:                 }
1:72b382d:             }
1:72b382d:         }
1:72b382d:     }
1:72b382d: 
1:eba4c9c:     /**
1:df26287:      * We have received the WireFormatInfo from the server on the actual channel
1:df26287:      * we should use for all future communication with the server, so lets set
1:df26287:      * the target to be the actual channel that the server has chosen for us to
1:df26287:      * talk on.
1:df26287:      */
1:f51ac13:     public void setTargetEndpoint(Endpoint newTarget) {
1:f51ac13:         if (newTarget instanceof DatagramEndpoint) {
1:f812e34:             DatagramEndpoint endpoint = (DatagramEndpoint)newTarget;
1:f51ac13:             SocketAddress address = endpoint.getAddress();
1:f51ac13:             if (address != null) {
1:f51ac13:                 if (originalTargetAddress == null) {
1:f51ac13:                     originalTargetAddress = targetAddress;
1:72b382d:                 }
1:f51ac13:                 targetAddress = address;
1:72b382d:                 commandChannel.setTargetAddress(address);
1:72b382d:             }
1:5739c6c:         }
1:5739c6c:     }
1:72b382d: 
1:eba4c9c:     // Properties
1:eba4c9c:     // -------------------------------------------------------------------------
1:eba4c9c:     public boolean isTrace() {
1:eba4c9c:         return trace;
1:5739c6c:     }
1:72b382d: 
1:eba4c9c:     public void setTrace(boolean trace) {
1:eba4c9c:         this.trace = trace;
1:f51ac13:     }
1:72b382d: 
1:5739c6c:     public int getDatagramSize() {
1:5739c6c:         return datagramSize;
1:f51ac13:     }
1:72b382d: 
1:5739c6c:     public void setDatagramSize(int datagramSize) {
1:5739c6c:         this.datagramSize = datagramSize;
1:df26287:     }
1:72b382d: 
1:eba4c9c:     public boolean isUseLocalHost() {
1:eba4c9c:         return useLocalHost;
1:df26287:     }
1:df26287: 
1:eba4c9c:     /**
1:eba4c9c:      * Sets whether 'localhost' or the actual local host name should be used to
1:eba4c9c:      * make local connections. On some operating systems such as Macs its not
1:eba4c9c:      * possible to connect as the local host name so localhost is better.
1:4f446eb:      */
1:eba4c9c:     public void setUseLocalHost(boolean useLocalHost) {
1:eba4c9c:         this.useLocalHost = useLocalHost;
1:df26287:     }
1:4446d55: 
1:f3ef1a9:     public CommandChannel getCommandChannel() throws IOException {
1:f3ef1a9:         if (commandChannel == null) {
1:f3ef1a9:             commandChannel = createCommandChannel();
1:f3ef1a9:         }
1:8d589ec:         return commandChannel;
1:4446d55:     }
1:8d589ec: 
1:eba4c9c:     /**
1:eba4c9c:      * Sets the implementation of the command channel to use.
1:eba4c9c:      */
1:5739c6c:     public void setCommandChannel(CommandDatagramChannel commandChannel) {
1:5739c6c:         this.commandChannel = commandChannel;
1:4f446eb:     }
1:4446d55: 
1:8704338:     public ReplayStrategy getReplayStrategy() {
1:1c5ecb3:         return replayStrategy;
1:4f446eb:     }
1:4446d55: 
1:1c5ecb3:     /**
1:1c5ecb3:      * Sets the strategy used to replay missed datagrams
1:1c5ecb3:      */
1:8704338:     public void setReplayStrategy(ReplayStrategy replayStrategy) {
1:1c5ecb3:         this.replayStrategy = replayStrategy;
1:4f446eb:     }
1:4446d55: 
1:187f884:     public int getPort() {
1:187f884:         return port;
1:4f446eb:     }
1:4f446eb: 
1:187f884:     /**
1:187f884:      * Sets the port to connect on
1:187f884:      */
1:187f884:     public void setPort(int port) {
1:187f884:         this.port = port;
1:4f446eb:     }
1:4f446eb: 
1:4f446eb:     public int getMinmumWireFormatVersion() {
1:4f446eb:         return minmumWireFormatVersion;
1:4f446eb:     }
1:4f446eb: 
1:4f446eb:     public void setMinmumWireFormatVersion(int minmumWireFormatVersion) {
1:4f446eb:         this.minmumWireFormatVersion = minmumWireFormatVersion;
1:4f446eb:     }
1:4f446eb: 
1:4f446eb:     public OpenWireFormat getWireFormat() {
1:4f446eb:         return wireFormat;
1:4446d55:     }
1:df26287: 
1:364337b:     public IntSequenceGenerator getSequenceGenerator() {
1:f3ef1a9:         if (sequenceGenerator == null) {
1:f3ef1a9:             sequenceGenerator = new IntSequenceGenerator();
1:f3ef1a9:         }
1:364337b:         return sequenceGenerator;
1:364337b:     }
1:364337b: 
1:364337b:     public void setSequenceGenerator(IntSequenceGenerator sequenceGenerator) {
1:364337b:         this.sequenceGenerator = sequenceGenerator;
1:364337b:     }
1:f812e34: 
1:8d589ec:     public boolean isReplayEnabled() {
1:8d589ec:         return replayEnabled;
1:8d589ec:     }
1:8d589ec: 
1:8d589ec:     /**
1:f812e34:      * Sets whether or not replay should be enabled when using the reliable
1:f812e34:      * transport. i.e. should we maintain a buffer of messages that can be
1:f812e34:      * replayed?
1:8d589ec:      */
1:8d589ec:     public void setReplayEnabled(boolean replayEnabled) {
1:8d589ec:         this.replayEnabled = replayEnabled;
1:8d589ec:     }
1:f3ef1a9: 
1:f3ef1a9:     public ByteBufferPool getBufferPool() {
1:f3ef1a9:         if (bufferPool == null) {
1:f3ef1a9:             bufferPool = new DefaultBufferPool();
1:f3ef1a9:         }
1:f3ef1a9:         return bufferPool;
1:f3ef1a9:     }
1:f3ef1a9: 
1:f3ef1a9:     public void setBufferPool(ByteBufferPool bufferPool) {
1:f3ef1a9:         this.bufferPool = bufferPool;
1:f3ef1a9:     }
1:f812e34: 
1:f3ef1a9:     public ReplayBuffer getReplayBuffer() {
1:f3ef1a9:         return replayBuffer;
1:f3ef1a9:     }
1:f3ef1a9: 
1:f3ef1a9:     public void setReplayBuffer(ReplayBuffer replayBuffer) throws IOException {
1:f3ef1a9:         this.replayBuffer = replayBuffer;
1:f3ef1a9:         getCommandChannel().setReplayBuffer(replayBuffer);
1:f3ef1a9:     }
1:f3ef1a9: 
1:eba4c9c:     // Implementation methods
1:eba4c9c:     // -------------------------------------------------------------------------
1:8d589ec: 
1:eba4c9c:     /**
1:eba4c9c:      * Creates an address from the given URI
1:eba4c9c:      */
1:eba4c9c:     protected InetSocketAddress createAddress(URI remoteLocation) throws UnknownHostException, IOException {
1:eba4c9c:         String host = resolveHostName(remoteLocation.getHost());
1:eba4c9c:         return new InetSocketAddress(host, remoteLocation.getPort());
1:5739c6c:     }
1:8d589ec: 
1:eba4c9c:     protected String resolveHostName(String host) throws UnknownHostException {
1:8a1f994:         String localName = InetAddressUtil.getLocalHostName();
1:eba4c9c:         if (localName != null && isUseLocalHost()) {
1:eba4c9c:             if (localName.equals(host)) {
1:eba4c9c:                 return "localhost";
1:5739c6c:             }
1:4f446eb:         }
1:eba4c9c:         return host;
1:4f446eb:     }
1:364337b: 
1:31c55f7:     @Override
1:eba4c9c:     protected void doStart() throws Exception {
1:f3ef1a9:         getCommandChannel().start();
1:4f446eb: 
1:5739c6c:         super.doStart();
1:5739c6c:     }
1:5739c6c: 
1:5739c6c:     protected CommandChannel createCommandChannel() throws IOException {
1:5739c6c:         SocketAddress localAddress = createLocalAddress();
1:5739c6c:         channel = DatagramChannel.open();
1:5739c6c: 
1:5739c6c:         channel = connect(channel, targetAddress);
1:4f446eb: 
1:187f884:         DatagramSocket socket = channel.socket();
1:5739c6c:         bind(socket, localAddress);
1:187f884:         if (port == 0) {
1:187f884:             port = socket.getLocalPort();
2:4f446eb:         }
1:4f446eb: 
1:f3ef1a9:         return createCommandDatagramChannel();
1:f3ef1a9:     }
1:f3ef1a9: 
1:f3ef1a9:     protected CommandChannel createCommandDatagramChannel() {
1:f3ef1a9:         return new CommandDatagramChannel(this, getWireFormat(), getDatagramSize(), getTargetAddress(), createDatagramHeaderMarshaller(), getChannel(), getBufferPool());
1:4f446eb:     }
1:4f446eb: 
1:5739c6c:     protected void bind(DatagramSocket socket, SocketAddress localAddress) throws IOException {
1:5739c6c:         channel.configureBlocking(true);
1:72b382d: 
1:fc00993:         if (LOG.isDebugEnabled()) {
1:fc00993:             LOG.debug("Binding to address: " + localAddress);
1:5739c6c:         }
1:5739c6c: 
2:a537902:         //
1:f812e34:         // We have noticed that on some platfoms like linux, after you close
1:f812e34:         // down
1:f812e34:         // a previously bound socket, it can take a little while before we can
1:f812e34:         // bind it again.
1:31c55f7:         //
1:f812e34:         for (int i = 0; i < MAX_BIND_ATTEMPTS; i++) {
1:f812e34:             try {
1:f812e34:                 socket.bind(localAddress);
1:f812e34:                 return;
1:f812e34:             } catch (BindException e) {
1:fc00993:                 if (i + 1 == MAX_BIND_ATTEMPTS) {
1:f812e34:                     throw e;
1:fc00993:                 }
1:f812e34:                 try {
1:f812e34:                     Thread.sleep(BIND_ATTEMPT_DELAY);
1:f812e34:                 } catch (InterruptedException e1) {
1:b75a6da:                     Thread.currentThread().interrupt();
1:f812e34:                     throw e;
1:f812e34:                 }
1:f812e34:             }
1:f812e34:         }
1:a537902: 
1:a537902:     }
1:5739c6c: 
1:5739c6c:     protected DatagramChannel connect(DatagramChannel channel, SocketAddress targetAddress2) throws IOException {
1:5739c6c:         // TODO
1:5739c6c:         // connect to default target address to avoid security checks each time
1:5739c6c:         // channel = channel.connect(targetAddress);
1:72b382d: 
1:5739c6c:         return channel;
1:a537902:     }
1:5739c6c: 
1:5739c6c:     protected SocketAddress createLocalAddress() {
1:5739c6c:         return new InetSocketAddress(port);
1:a537902:     }
1:5739c6c: 
1:31c55f7:     @Override
1:eba4c9c:     protected void doStop(ServiceStopper stopper) throws Exception {
1:eba4c9c:         if (channel != null) {
1:eba4c9c:             channel.close();
1:5739c6c:         }
1:4f446eb:     }
1:4f446eb: 
1:df26287:     protected DatagramHeaderMarshaller createDatagramHeaderMarshaller() {
1:df26287:         return new DatagramHeaderMarshaller();
1:df26287:     }
1:4f446eb: 
1:df26287:     protected String getProtocolName() {
1:df26287:         return "Udp";
1:df26287:     }
1:4f446eb: 
1:df26287:     protected String getProtocolUriScheme() {
1:df26287:         return "udp://";
1:5739c6c:     }
1:5739c6c: 
1:5739c6c:     protected SocketAddress getTargetAddress() {
1:5739c6c:         return targetAddress;
1:5739c6c:     }
1:f3ef1a9: 
1:f3ef1a9:     protected DatagramChannel getChannel() {
1:f3ef1a9:         return channel;
1:f3ef1a9:     }
1:f3ef1a9: 
1:f3ef1a9:     protected void setChannel(DatagramChannel channel) {
1:f3ef1a9:         this.channel = channel;
1:f3ef1a9:     }
1:26bb18b: 
1:26bb18b:     public InetSocketAddress getLocalSocketAddress() {
1:f812e34:         if (channel == null) {
1:26bb18b:             return null;
1:26bb18b:         } else {
1:26bb18b:             return (InetSocketAddress)channel.socket().getLocalSocketAddress();
1:26bb18b:         }
1:26bb18b:     }
1:0f1dcce: 
1:31c55f7:     @Override
1:f812e34:     public String getRemoteAddress() {
1:f812e34:         if (targetAddress != null) {
1:f812e34:             return "" + targetAddress;
1:f812e34:         }
1:f812e34:         return null;
1:f812e34:     }
1:5739c6c: 
1:31c55f7:     @Override
1:8978ac0:     public int getReceiveCounter() {
1:8978ac0:         if (commandChannel == null) {
1:8978ac0:             return 0;
1:8978ac0:         }
1:8978ac0:         return commandChannel.getReceiveCounter();
1:8978ac0:     }
1:31c55f7: 
1:31c55f7:     @Override
1:31c55f7:     public X509Certificate[] getPeerCertificates() {
1:31c55f7:         return null;
1:31c55f7:     }
1:31c55f7: 
1:31c55f7:     @Override
1:31c55f7:     public void setPeerCertificates(X509Certificate[] certificates) {
1:31c55f7:     }
1:0f1dcce: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Timothy Bish
-------------------------------------------------------------------------------
commit:31c55f7
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.security.cert.X509Certificate;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         //
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1: 
1:     @Override
1:     public X509Certificate[] getPeerCertificates() {
1:         return null;
1:     }
1: 
1:     @Override
1:     public void setPeerCertificates(X509Certificate[] certificates) {
1:     }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:9a8f6e4
commit:0bbc0ac
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:8978ac0
/////////////////////////////////////////////////////////////////////////
1: 
1:     public int getReceiveCounter() {
1:         if (commandChannel == null) {
1:             return 0;
1:         }
1:         return commandChannel.getReceiveCounter();
1:     }
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
1:     private boolean trace;
1:     private String description;
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(UdpTransport.class);
/////////////////////////////////////////////////////////////////////////
1:         if (LOG.isDebugEnabled()) {
1:             LOG.debug("Sending oneway from: " + this + " to target: " + targetAddress + " command: " + command);
/////////////////////////////////////////////////////////////////////////
1:         LOG.trace("Consumer thread starting for: " + toString());
/////////////////////////////////////////////////////////////////////////
1:                     LOG.warn("Caught in: " + this + " while closing: " + e2 + ". Now Closed", e2);
1:                 LOG.debug("Socket closed: " + e, e);
1:                     LOG.warn("Caught in: " + this + " while closing: " + e2 + ". Now Closed", e2);
1:                 LOG.debug("Socket closed: " + e, e);
1:                     LOG.warn("Caught in: " + this + " while closing: " + e2 + ". Now Closed", e2);
1:                     LOG.warn("Caught in: " + this + " while closing: " + e2 + ". Now Closed", e2);
1:                     LOG.error("Caught: " + e, e);
/////////////////////////////////////////////////////////////////////////
1:         if (LOG.isDebugEnabled()) {
1:             LOG.debug("Binding to address: " + localAddress);
/////////////////////////////////////////////////////////////////////////
1:                 if (i + 1 == MAX_BIND_ATTEMPTS) {
1:                 }
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
1: import java.io.EOFException;
1: import java.io.IOException;
1: import java.net.BindException;
1: import java.net.DatagramSocket;
0: import java.net.InetAddress;
1: import java.net.InetSocketAddress;
1: import java.net.SocketAddress;
1: import java.net.SocketException;
1: import java.net.URI;
1: import java.net.UnknownHostException;
1: import java.nio.channels.AsynchronousCloseException;
1: import java.nio.channels.DatagramChannel;
1: 
/////////////////////////////////////////////////////////////////////////
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1:     private static final int MAX_BIND_ATTEMPTS = 50;
1:     private static final long BIND_ATTEMPT_DELAY = 100;
/////////////////////////////////////////////////////////////////////////
1:         if (replayEnabled) {
/////////////////////////////////////////////////////////////////////////
1:         commandChannel.write((Command)command, address);
/////////////////////////////////////////////////////////////////////////
1:         } else {
/////////////////////////////////////////////////////////////////////////
1:             } catch (AsynchronousCloseException e) {
1:                 } catch (Exception e2) {
1:             } catch (SocketException e) {
1:                 } catch (Exception e2) {
1:             } catch (EOFException e) {
1:                 } catch (Exception e2) {
1:             } catch (Exception e) {
1:                 } catch (Exception e2) {
1:                     onException((IOException)e);
1:                 } else {
/////////////////////////////////////////////////////////////////////////
1:             DatagramEndpoint endpoint = (DatagramEndpoint)newTarget;
/////////////////////////////////////////////////////////////////////////
1: 
1:      * Sets whether or not replay should be enabled when using the reliable
1:      * transport. i.e. should we maintain a buffer of messages that can be
1:      * replayed?
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         // We have noticed that on some platfoms like linux, after you close
1:         // down
1:         // a previously bound socket, it can take a little while before we can
1:         // bind it again.
1:         for (int i = 0; i < MAX_BIND_ATTEMPTS; i++) {
1:             try {
1:                 socket.bind(localAddress);
1:                 return;
1:             } catch (BindException e) {
0:                 if (i + 1 == MAX_BIND_ATTEMPTS)
1:                     throw e;
1:                 try {
1:                     Thread.sleep(BIND_ATTEMPT_DELAY);
1:                 } catch (InterruptedException e1) {
1:                     throw e;
1:                 }
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (channel == null) {
1:     public String getRemoteAddress() {
1:         if (targetAddress != null) {
1:             return "" + targetAddress;
1:         }
1:         return null;
1:     }
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:9ca56a0
/////////////////////////////////////////////////////////////////////////
1:     public void oneway(Object command) throws IOException {
1:     public void oneway(Object command, SocketAddress address) throws IOException {
1:         checkStarted();
0:         commandChannel.write((Command) command, address);
commit:b75a6da
/////////////////////////////////////////////////////////////////////////
1:                     Thread.currentThread().interrupt();
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:a537902
/////////////////////////////////////////////////////////////////////////
0: import java.net.BindException;
/////////////////////////////////////////////////////////////////////////
0: 	private static final int MAX_BIND_ATTEMPTS = 50;
0: 	private static final long BIND_ATTEMPT_DELAY = 100;
1: 
/////////////////////////////////////////////////////////////////////////
1:         
1:         //
0:         // We have noticed that on some platfoms like linux, after you close down
0:         // a previously bound socket, it can take a little while before we can bind it again.
1:         // 
0:         for(int i=0; i < MAX_BIND_ATTEMPTS; i++){
1: 			try {
0: 				socket.bind(localAddress);
0: 				return;
0: 			} catch (BindException e) {
0: 				if ( i+1 == MAX_BIND_ATTEMPTS )
0: 					throw e;
1: 				try {
0: 					Thread.sleep(BIND_ATTEMPT_DELAY);
0: 				} catch (InterruptedException e1) {
0: 					throw e;
1: 				}
1: 			}			
1:     	}
1: 
commit:26bb18b
/////////////////////////////////////////////////////////////////////////
1: 
1:     public InetSocketAddress getLocalSocketAddress() {
0:         if( channel==null ) {
1:             return null;
1:         } else {
1:             return (InetSocketAddress)channel.socket().getLocalSocketAddress();
1:         }
1:     }
commit:ef0c0e1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(UdpTransport.class);
author:Bruce Snyder
-------------------------------------------------------------------------------
commit:8a1f994
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.InetAddressUtil;
/////////////////////////////////////////////////////////////////////////
1:         String localName = InetAddressUtil.getLocalHostName();
author:Gary Tully
-------------------------------------------------------------------------------
commit:05101de
/////////////////////////////////////////////////////////////////////////
1:     private boolean useLocalHost = false;
author:James Strachan
-------------------------------------------------------------------------------
commit:0f1dcce
/////////////////////////////////////////////////////////////////////////
1: 
0: 	public String getRemoteAddress() {
0: 		if(targetAddress != null){
0: 			return "" + targetAddress;
1: 		}
1: 		return null;
1: 	}
commit:cff515e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:f3ef1a9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.reliable.ReplayBuffer;
/////////////////////////////////////////////////////////////////////////
1:     private ReplayBuffer replayBuffer;
/////////////////////////////////////////////////////////////////////////
1:     public Replayer createReplayer() throws IOException {
1:             return getCommandChannel();
/////////////////////////////////////////////////////////////////////////
1:     public CommandChannel getCommandChannel() throws IOException {
1:         if (commandChannel == null) {
1:             commandChannel = createCommandChannel();
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (sequenceGenerator == null) {
1:             sequenceGenerator = new IntSequenceGenerator();
1:         }
/////////////////////////////////////////////////////////////////////////
1:     public ByteBufferPool getBufferPool() {
1:         if (bufferPool == null) {
1:             bufferPool = new DefaultBufferPool();
1:         }
1:         return bufferPool;
1:     }
1: 
1:     public void setBufferPool(ByteBufferPool bufferPool) {
1:         this.bufferPool = bufferPool;
1:     }
1:     
1:     public ReplayBuffer getReplayBuffer() {
1:         return replayBuffer;
1:     }
1: 
1:     public void setReplayBuffer(ReplayBuffer replayBuffer) throws IOException {
1:         this.replayBuffer = replayBuffer;
1:         getCommandChannel().setReplayBuffer(replayBuffer);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         getCommandChannel().start();
/////////////////////////////////////////////////////////////////////////
1:         return createCommandDatagramChannel();
1:     }
1: 
1:     protected CommandChannel createCommandDatagramChannel() {
1:         return new CommandDatagramChannel(this, getWireFormat(), getDatagramSize(), getTargetAddress(), createDatagramHeaderMarshaller(), getChannel(), getBufferPool());
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected DatagramChannel getChannel() {
1:         return channel;
1:     }
1: 
1:     protected void setChannel(DatagramChannel channel) {
1:         this.channel = channel;
1:     }
commit:8d589ec
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.reliable.Replayer;
/////////////////////////////////////////////////////////////////////////
1:     private boolean replayEnabled = true;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Creates a replayer for working with the reliable transport
0:      * @return
1:      */
0:     public Replayer createReplayer() {
0:         if (replayEnabled ) {
1:             return commandChannel;
1:         }
0:         return null;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public boolean isReplayEnabled() {
1:         return replayEnabled;
1:     }
1: 
1:     /**
0:      * Sets whether or not replay should be enabled when using the reliable transport.
0:      * i.e. should we maintain a buffer of messages that can be replayed?
1:      */
1:     public void setReplayEnabled(boolean replayEnabled) {
1:         this.replayEnabled = replayEnabled;
1:     }
1: 
1:     
/////////////////////////////////////////////////////////////////////////
0:         return new CommandDatagramChannel(this, wireFormat, datagramSize, targetAddress, createDatagramHeaderMarshaller(), channel, bufferPool);
commit:364337b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.IntSequenceGenerator;
/////////////////////////////////////////////////////////////////////////
1:     private IntSequenceGenerator sequenceGenerator;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * A one way asynchronous send to a given address
0:     public void oneway(Command command, SocketAddress address) throws IOException {
0:         commandChannel.write(command, address);
/////////////////////////////////////////////////////////////////////////
1: 
1:     public IntSequenceGenerator getSequenceGenerator() {
1:         return sequenceGenerator;
1:     }
1: 
1:     public void setSequenceGenerator(IntSequenceGenerator sequenceGenerator) {
1:         this.sequenceGenerator = sequenceGenerator;
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
commit:72b382d
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
1: 
0: import org.apache.activemq.command.Response;
0: import org.apache.activemq.transport.FutureResponse;
0: import org.apache.activemq.transport.ResponseCorrelator;
0: import org.apache.activemq.transport.TransportFilter;
/////////////////////////////////////////////////////////////////////////
0: import java.io.EOFException;
/////////////////////////////////////////////////////////////////////////
0:     private final ConcurrentHashMap requestMap = new ConcurrentHashMap();
0:     private int lastCommandId = 0;
1: 
0:     private Runnable runnable;
/////////////////////////////////////////////////////////////////////////
0:     public TransportFilter createFilter(Transport transport) {
0:         return new TransportFilter(transport) {
0:             public void onCommand(Command command) {
0:                 boolean debug = log.isDebugEnabled();
0:                 if (command.isResponse()) {
0:                     Response response = (Response) command;
0:                     FutureResponse future = (FutureResponse) requestMap.remove(new Integer(response.getCorrelationId()));
0:                     if (future != null) {
0:                         future.set(response);
1:                     }
0:                     else {
0:                         if (debug)
0:                             log.debug("Received unexpected response for command id: " + response.getCorrelationId());
1:                     }
1:                 }
0:                 else {
0:                     super.onCommand(command);
1:                 }
1:             }
0:         };
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:      * A one way asynchronous send
1:      */
0:     public void oneway(Command command, FutureResponse future) throws IOException {
0:         oneway(command, targetAddress, future);
1:     }
1: 
0:     protected void oneway(Command command, SocketAddress address, FutureResponse future) throws IOException {
0:         if (log.isDebugEnabled()) {
0:             log.debug("Sending oneway from: " + this + " to target: " + targetAddress + " command: " + command);
1:         }
0:         checkStarted(command);
0:         commandChannel.write(command, address, requestMap, future);
1:     }
1: 
1:     /**
0:         oneway(command, address, null);
1: 
0:     public FutureResponse asyncRequest(Command command) throws IOException {
0:         if (command.getCommandId() == 0) {
0:             command.setCommandId(getNextCommandId());
1:         }
0:         command.setResponseRequired(true);
0:         FutureResponse future = new FutureResponse();
0:         oneway(command, future);
0:         return future;
1:     }
1: 
0:     public Response request(Command command) throws IOException {
0:         FutureResponse response = asyncRequest(command);
0:         return response.getResult();
1:     }
1: 
0:     public Response request(Command command, int timeout) throws IOException {
0:         FutureResponse response = asyncRequest(command);
0:         return response.getResult(timeout);
1:     }
1: 
1: 
0:     public void setStartupRunnable(Runnable runnable) {
0:         this.runnable = runnable;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         if (runnable != null) {
0:             runnable.run();
1:         }
/////////////////////////////////////////////////////////////////////////
0:                     log.warn("Caught in: " + this + " while closing: " + e2 + ". Now Closed", e2);
/////////////////////////////////////////////////////////////////////////
0:                     log.warn("Caught in: " + this + " while closing: " + e2 + ". Now Closed", e2);
0:             catch (EOFException e) {
1:                 // DataInputStream closed
0:                 log.debug("Socket closed: " + e, e);
0:                     log.warn("Caught in: " + this + " while closing: " + e2 + ". Now Closed", e2);
1:                 }
1:             }
0:             catch (Exception e) {
1:                 try {
1:                     stop();
1:                 }
0:                 catch (Exception e2) {
0:                     log.warn("Caught in: " + this + " while closing: " + e2 + ". Now Closed", e2);
0:                     log.error("Caught: " + e, e);
1:                     e.printStackTrace();
/////////////////////////////////////////////////////////////////////////
1:                 commandChannel.setTargetAddress(address);
/////////////////////////////////////////////////////////////////////////
0:         return new CommandDatagramChannel(this, channel, wireFormat, bufferPool, datagramSize, targetAddress, createDatagramHeaderMarshaller());
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:     protected synchronized int getNextCommandId() {
0:         return ++lastCommandId;
commit:5739c6c
/////////////////////////////////////////////////////////////////////////
0: import java.net.SocketException;
/////////////////////////////////////////////////////////////////////////
1:                 // DatagramChannel closed
1:                 try {
1:                     stop();
1:                 }
0:                 catch (Exception e2) {
0:                     log.warn("Caught while closing: " + e2 + ". Now Closed", e2);
1:                 }
1:             }
0:             catch (SocketException e) {
1:                 // DatagramSocket closed
0:                 log.debug("Socket closed: " + e, e);
/////////////////////////////////////////////////////////////////////////
0:                 System.out.println("Caught exception of type: " + e.getClass());
/////////////////////////////////////////////////////////////////////////
1:     public int getDatagramSize() {
1:         return datagramSize;
1:     public void setDatagramSize(int datagramSize) {
1:         this.datagramSize = datagramSize;
/////////////////////////////////////////////////////////////////////////
1:     public void setCommandChannel(CommandDatagramChannel commandChannel) {
/////////////////////////////////////////////////////////////////////////
0:         commandChannel = createCommandChannel();
0:         commandChannel.start();
1:         super.doStart();
1:     }
1: 
1:     protected CommandChannel createCommandChannel() throws IOException {
1:         SocketAddress localAddress = createLocalAddress();
1:         channel = DatagramChannel.open();
1: 
1:         channel = connect(channel, targetAddress);
1:         bind(socket, localAddress);
/////////////////////////////////////////////////////////////////////////
0:         return new CommandDatagramChannel(toString(), channel, wireFormat, bufferPool, datagramSize, targetAddress, createDatagramHeaderMarshaller());
1:     }
1:     protected void bind(DatagramSocket socket, SocketAddress localAddress) throws IOException {
1:         channel.configureBlocking(true);
1:         
0:         if (log.isDebugEnabled()) {
0:             log.debug("Binding to address: " + localAddress);
1:         }
0:         socket.bind(localAddress);
1:     }
1: 
1:     protected DatagramChannel connect(DatagramChannel channel, SocketAddress targetAddress2) throws IOException {
1:         // TODO
1:         // connect to default target address to avoid security checks each time
1:         // channel = channel.connect(targetAddress);
1:         
1:         return channel;
1:     }
1: 
1:     protected SocketAddress createLocalAddress() {
1:         return new InetSocketAddress(port);
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected SocketAddress getTargetAddress() {
1:         return targetAddress;
1:     }
1: 
0:     public void setCommandChannel(CommandChannel commandChannel) {
1:         this.commandChannel = commandChannel;
1:     }
commit:e6954f1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.reliable.ExceptionIfDroppedReplayStrategy;
1: import org.apache.activemq.transport.reliable.ReplayStrategy;
commit:f51ac13
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.Endpoint;
0: import org.apache.activemq.transport.replay.ReplayStrategy;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void setTargetEndpoint(Endpoint newTarget) {
1:         if (newTarget instanceof DatagramEndpoint) {
0:             DatagramEndpoint endpoint = (DatagramEndpoint) newTarget;
1:             SocketAddress address = endpoint.getAddress();
1:             if (address != null) {
1:                 if (originalTargetAddress == null) {
1:                     originalTargetAddress = targetAddress;
1:                 }
1:                 targetAddress = address;
1:             }
/////////////////////////////////////////////////////////////////////////
commit:8704338
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transport.replay.ReplayStrategy;
0: import org.apache.activemq.transport.replay.ExceptionIfDroppedReplayStrategy;
/////////////////////////////////////////////////////////////////////////
1:     private ReplayStrategy replayStrategy = new ExceptionIfDroppedReplayStrategy();
/////////////////////////////////////////////////////////////////////////
0:     private DatagramEndpoint wireFormatHeader;
/////////////////////////////////////////////////////////////////////////
0:     public void receivedHeader(DatagramEndpoint endpoint) {
0:         wireFormatHeader = endpoint;
/////////////////////////////////////////////////////////////////////////
1:                 Command command = commandChannel.read();
1:                 doConsume(command);
/////////////////////////////////////////////////////////////////////////
1:     public ReplayStrategy getReplayStrategy() {
1:     public void setReplayStrategy(ReplayStrategy replayStrategy) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         commandChannel = new CommandChannel(toString(), channel, wireFormat, bufferPool, datagramSize, targetAddress, createDatagramHeaderMarshaller());
0:             commandChannel.setWireFormatInfoEndpoint(wireFormatHeader);
commit:df26287
/////////////////////////////////////////////////////////////////////////
1:         this.description = getProtocolName() + "ServerConnection@";
/////////////////////////////////////////////////////////////////////////
1:         this.description = getProtocolName() + "Server@";
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             return getProtocolUriScheme() + targetAddress + "@" + port;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * We have received the WireFormatInfo from the server on the actual channel
1:      * we should use for all future communication with the server, so lets set
1:      * the target to be the actual channel that the server has chosen for us to
1:      * talk on.
1:      */
0:     public void useLastInboundDatagramAsNewTarget() {
0:         if (originalTargetAddress == null) {
0:             originalTargetAddress = targetAddress;
1:         }
0:         SocketAddress lastAddress = commandChannel.getLastReadDatagramAddress();
0:         if (lastAddress != null) {
0:             targetAddress = lastAddress;
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:         commandChannel = new CommandChannel(toString(), channel, wireFormat, bufferPool, datagramSize, replayStrategy, targetAddress, isCheckSequenceNumbers(), createDatagramHeaderMarshaller());
/////////////////////////////////////////////////////////////////////////
1:     protected DatagramHeaderMarshaller createDatagramHeaderMarshaller() {
1:         return new DatagramHeaderMarshaller();
1:     protected String getProtocolName() {
1:         return "Udp";
1:     }
1:     protected String getProtocolUriScheme() {
1:         return "udp://";
1:     }
commit:4446d55
/////////////////////////////////////////////////////////////////////////
0:     private boolean checkSequenceNumbers = true;
/////////////////////////////////////////////////////////////////////////
1: 
0:     public void receivedHeader(DatagramHeader header) {
/////////////////////////////////////////////////////////////////////////
1:     
0:     public boolean isCheckSequenceNumbers() {
0:         return checkSequenceNumbers;
1:     }
1: 
0:     public void setCheckSequenceNumbers(boolean checkSequenceNumbers) {
0:         this.checkSequenceNumbers = checkSequenceNumbers;
1:     }
/////////////////////////////////////////////////////////////////////////
0:         commandChannel = new CommandChannel(toString(), channel, wireFormat, bufferPool, datagramSize, replayStrategy, targetAddress, isCheckSequenceNumbers());
/////////////////////////////////////////////////////////////////////////
1: 
commit:4f446eb
/////////////////////////////////////////////////////////////////////////
1:     private SocketAddress targetAddress;
1:     private SocketAddress originalTargetAddress;
1:     private int minmumWireFormatVersion;
0:     private String description = null;
1: 
0:         public void process(Command command, DatagramHeader header) {
1:         }
0:     };
1: 
0:     private DatagramHeader wireFormatHeader;
/////////////////////////////////////////////////////////////////////////
1:         description = remoteLocation.toString() + "@";
1:     public UdpTransport(OpenWireFormat wireFormat, SocketAddress socketAddress) throws IOException {
0:         this.description = "UdpServerConnection@";
1: 
1:     /**
1:      * Used by the server transport
1:      */
1:     public UdpTransport(OpenWireFormat wireFormat, int port) throws UnknownHostException, IOException {
1:         this(wireFormat);
1:         this.port = port;
1:         this.targetAddress = null;
0:         this.description = "UdpServer@";
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:     public void oneway(Command command, SocketAddress address) throws IOException {
0:             log.debug("Sending oneway from: " + this + " to target: " + targetAddress);
0:     public void doConsume(Command command, DatagramHeader header) throws IOException {
0:         wireFormatHeader = header;
1:     }
1: 
1:         if (description != null) {
1:             return description + port;
1:         }
0:         else {
0:             return "udp://" + targetAddress + "@" + port;
1:         }
/////////////////////////////////////////////////////////////////////////
1:     public int getMinmumWireFormatVersion() {
1:         return minmumWireFormatVersion;
1:     }
1: 
1:     public void setMinmumWireFormatVersion(int minmumWireFormatVersion) {
1:         this.minmumWireFormatVersion = minmumWireFormatVersion;
1:     }
1: 
1:     public OpenWireFormat getWireFormat() {
1:         return wireFormat;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:         if (log.isDebugEnabled()) {
0:             log.debug("Binding to address: " + localAddress);
1:         }
1: 
0:         // lets pass the header & address into the channel so it avoids a
0:         // re-request
0:         if (wireFormatHeader != null) {
0:             commandChannel.onDatagramReceived(wireFormatHeader);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * We have received the WireFormatInfo from the server on the actual channel
0:      * we should use for all future communication with the server, so lets set
0:      * the target to be the actual channel that the server has chosen for us to
0:      * talk on.
1:      */
0:     public void useLastInboundDatagramAsNewTarget() {
0:         if (originalTargetAddress == null) {
0:             originalTargetAddress = targetAddress;
1:         }
0:         SocketAddress lastAddress = commandChannel.getLastReadDatagramAddress();
0:         if (lastAddress != null) {
0:             targetAddress = lastAddress;
1:         }
1:     }
0: 
commit:08f4639
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private CommandProcessor commandProcessor = new CommandProcessor() {
0:         public void process(Command command, SocketAddress address) {
0:             doConsume(command);
0:         }};
/////////////////////////////////////////////////////////////////////////
0:     
1:         oneway(command, targetAddress);
0:     }
0: 
1:     /**
0:      * A one way asynchronous send to a given address
1:      */
0:     public void oneway(Command command, InetSocketAddress address) throws IOException {
0:         commandChannel.write(command, address);
/////////////////////////////////////////////////////////////////////////
1:         while (!isStopped()) {
0:                 commandChannel.read(commandProcessor);
/////////////////////////////////////////////////////////////////////////
0:     protected CommandProcessor getCommandProcessor() {
0:         return commandProcessor;
0:     }
0:     protected void setCommandProcessor(CommandProcessor commandProcessor) {
0:         this.commandProcessor = commandProcessor;
0:     }
0:     
/////////////////////////////////////////////////////////////////////////
0: 
commit:187f884
/////////////////////////////////////////////////////////////////////////
0: import java.net.DatagramSocket;
0: import java.net.SocketAddress;
0: import java.nio.channels.AsynchronousCloseException;
/////////////////////////////////////////////////////////////////////////
0:     private long maxInactivityDuration = 0; // 30000;
0:     private InetSocketAddress targetAddress;
1:     private int port;
1:     protected UdpTransport(OpenWireFormat wireFormat) throws IOException {
1:         this.targetAddress = createAddress(remoteLocation);
0:     public UdpTransport(OpenWireFormat wireFormat, InetSocketAddress socketAddress) throws IOException {
1:         this.targetAddress = socketAddress;
0:         if (log.isDebugEnabled()) {
0:             log.debug("Sending oneway from port: " + port + " to target: " + targetAddress);
0:         }
/////////////////////////////////////////////////////////////////////////
0:         return "udp://" + targetAddress + "?port=" + port;
/////////////////////////////////////////////////////////////////////////
0:             /*
0:              * catch (SocketTimeoutException e) { } catch
0:              * (InterruptedIOException e) { }
1:              */
0:             catch (AsynchronousCloseException e) {
0:             }
0:             catch (Exception e) {
0:                 e.printStackTrace();
1:                 try {
1:                     stop();
0:                 }
0:                 catch (Exception e2) {
0:                     log.warn("Caught while closing: " + e2 + ". Now Closed", e2);
0:                 }
1:                 if (e instanceof IOException) {
0:                     onException((IOException) e);
0:                 }
0:                 else {
0:                     log.error(e);
0:                 }
/////////////////////////////////////////////////////////////////////////
0:     public DatagramChannel getChannel() {
0:         return channel;
0:     }
0: 
0:     public void setChannel(DatagramChannel channel) {
0:         this.channel = channel;
0:     }
0: 
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1:     public int getPort() {
1:         return port;
0:     }
0: 
1:     /**
1:      * Sets the port to connect on
1:      */
1:     public void setPort(int port) {
1:         this.port = port;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         SocketAddress localAddress = new InetSocketAddress(port);
0:         channel = DatagramChannel.open();
0:         channel.configureBlocking(true);
0: 
0:         // TODO
0:         // connect to default target address to avoid security checks each time
0:         // channel = channel.connect(targetAddress);
0:         
1:         DatagramSocket socket = channel.socket();
0:         socket.bind(localAddress);
1:         if (port == 0) {
1:             port = socket.getLocalPort();
0:         
0:         commandChannel = new CommandChannel(channel, wireFormat, bufferPool, datagramSize, replayStrategy, targetAddress);
0: 
commit:1c5ecb3
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transport.udp.replay.DatagramReplayStrategy;
0: import org.apache.activemq.transport.udp.replay.ExceptionIfDroppedPacketStrategy;
/////////////////////////////////////////////////////////////////////////
0:     private DatagramReplayStrategy replayStrategy = new ExceptionIfDroppedPacketStrategy();
/////////////////////////////////////////////////////////////////////////
0:         log.trace("Consumer thread starting for: " + toString());
/////////////////////////////////////////////////////////////////////////
0:     public DatagramReplayStrategy getReplayStrategy() {
1:         return replayStrategy;
0:     }
0: 
1:     /**
1:      * Sets the strategy used to replay missed datagrams
1:      */
0:     public void setReplayStrategy(DatagramReplayStrategy replayStrategy) {
1:         this.replayStrategy = replayStrategy;
0:     }
0: 
0:     
/////////////////////////////////////////////////////////////////////////
0:         if (bufferPool == null) {
0:             bufferPool = new DefaultBufferPool();
0:         }
0:         commandChannel = new CommandChannel(channel, wireFormat, bufferPool, datagramSize, replayStrategy);
commit:eba4c9c
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport.udp;
0: 
1: import org.apache.activemq.Service;
1: import org.apache.activemq.command.Command;
1: import org.apache.activemq.openwire.OpenWireFormat;
1: import org.apache.activemq.transport.Transport;
1: import org.apache.activemq.transport.TransportThreadSupport;
1: import org.apache.activemq.util.ServiceStopper;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: 
0: import java.io.IOException;
0: import java.io.InterruptedIOException;
0: import java.net.InetAddress;
0: import java.net.InetSocketAddress;
0: import java.net.SocketTimeoutException;
0: import java.net.URI;
0: import java.net.UnknownHostException;
0: import java.nio.channels.DatagramChannel;
0: 
1: /**
1:  * An implementation of the {@link Transport} interface using raw UDP
1:  * 
0:  * @version $Revision$
1:  */
1: public class UdpTransport extends TransportThreadSupport implements Transport, Service, Runnable {
0:     private static final Log log = LogFactory.getLog(UdpTransport.class);
0: 
1:     private CommandChannel commandChannel;
1:     private OpenWireFormat wireFormat;
1:     private ByteBufferPool bufferPool;
1:     private int datagramSize = 4 * 1024;
0:     private long maxInactivityDuration = 0; //30000;
0:     private InetSocketAddress socketAddress;
1:     private DatagramChannel channel;
0:     private boolean trace = false;
0:     private boolean useLocalHost = true;
0: 
0:     protected UdpTransport(OpenWireFormat wireFormat) {
1:         this.wireFormat = wireFormat;
0:     }
0: 
1:     public UdpTransport(OpenWireFormat wireFormat, URI remoteLocation) throws UnknownHostException, IOException {
1:         this(wireFormat);
0:         this.socketAddress = createAddress(remoteLocation);
0:     }
0: 
0:     public UdpTransport(OpenWireFormat wireFormat, InetSocketAddress socketAddress) {
1:         this(wireFormat);
0:         this.socketAddress = socketAddress;
0:     }
0: 
1:     /**
0:      * A one way asynchronous send
1:      */
0:     public void oneway(Command command) throws IOException {
0:         checkStarted(command);
0:         commandChannel.write(command);
0:     }
0: 
1:     /**
1:      * @return pretty print of 'this'
1:      */
1:     public String toString() {
0:         return "udp://" + socketAddress;
0:     }
0: 
1:     /**
1:      * reads packets from a Socket
1:      */
1:     public void run() {
0:         log.trace("TCP consumer thread starting");
0:         while (!isClosed()) {
0:             try {
0:                 Command command = commandChannel.read();
0:                 doConsume(command);
0:             }
0:             catch (SocketTimeoutException e) {
0:             }
0:             catch (InterruptedIOException e) {
0:             }
0:             catch (IOException e) {
0:                 try {
1:                     stop();
0:                 }
0:                 catch (Exception e2) {
0:                     log.warn("Caught while closing: " + e2 + ". Now Closed", e2);
0:                 }
0:                 onException(e);
0:             }
0:         }
0:     }
0: 
1:     // Properties
1:     // -------------------------------------------------------------------------
1:     public boolean isTrace() {
1:         return trace;
0:     }
0: 
1:     public void setTrace(boolean trace) {
1:         this.trace = trace;
0:     }
0: 
0:     public long getMaxInactivityDuration() {
0:         return maxInactivityDuration;
0:     }
0: 
1:     /**
0:      * Sets the maximum inactivity duration
1:      */
0:     public void setMaxInactivityDuration(long maxInactivityDuration) {
0:         this.maxInactivityDuration = maxInactivityDuration;
0:     }
1:     public boolean isUseLocalHost() {
1:         return useLocalHost;
0:     }
0: 
1:     /**
1:      * Sets whether 'localhost' or the actual local host name should be used to
1:      * make local connections. On some operating systems such as Macs its not
1:      * possible to connect as the local host name so localhost is better.
1:      */
1:     public void setUseLocalHost(boolean useLocalHost) {
1:         this.useLocalHost = useLocalHost;
0:     }
0: 
0: 
0:     public CommandChannel getCommandChannel() {
0:         return commandChannel;
0:     }
0: 
1:     /**
1:      * Sets the implementation of the command channel to use.
1:      */
0:     public void setCommandChannel(CommandChannel commandChannel) {
0:         this.commandChannel = commandChannel;
0:     }
0:     
1:     // Implementation methods
1:     // -------------------------------------------------------------------------
0: 
0: 
1:     /**
1:      * Creates an address from the given URI
1:      */
1:     protected InetSocketAddress createAddress(URI remoteLocation) throws UnknownHostException, IOException {
1:         String host = resolveHostName(remoteLocation.getHost());
1:         return new InetSocketAddress(host, remoteLocation.getPort());
0:     }
0: 
1:     protected String resolveHostName(String host) throws UnknownHostException {
0:         String localName = InetAddress.getLocalHost().getHostName();
1:         if (localName != null && isUseLocalHost()) {
1:             if (localName.equals(host)) {
1:                 return "localhost";
0:             }
0:         }
1:         return host;
0:     }
0: 
1:     protected void doStart() throws Exception {
0:         if (socketAddress != null) {
0:             channel = DatagramChannel.open();
0:             channel.connect(socketAddress);
0:         }
0:         else if (channel == null) {
0:             throw new IllegalArgumentException("No channel configured");
0:         }
0:         commandChannel = new CommandChannel(channel, wireFormat, bufferPool, datagramSize);
0:         commandChannel.start();
0:         super.doStart();
0:     }
0: 
1:     protected void doStop(ServiceStopper stopper) throws Exception {
1:         if (channel != null) {
1:             channel.close();
0:         }
0:     }
0: }
============================================================================