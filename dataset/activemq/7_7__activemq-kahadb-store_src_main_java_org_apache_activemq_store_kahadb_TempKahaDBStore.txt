1:b7c2b67: /**
1:b7c2b67:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:b7c2b67:  * contributor license agreements.  See the NOTICE file distributed with
1:b7c2b67:  * this work for additional information regarding copyright ownership.
1:b7c2b67:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:b7c2b67:  * (the "License"); you may not use this file except in compliance with
1:b7c2b67:  * the License.  You may obtain a copy of the License at
1:b7c2b67:  *
1:b7c2b67:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b7c2b67:  *
1:b7c2b67:  * Unless required by applicable law or agreed to in writing, software
1:b7c2b67:  * distributed under the License is distributed on an "AS IS" BASIS,
1:b7c2b67:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:b7c2b67:  * See the License for the specific language governing permissions and
1:b7c2b67:  * limitations under the License.
1:b7c2b67:  */
1:b7c2b67: package org.apache.activemq.store.kahadb;
34:b7c2b67: 
1:b7c2b67: import java.io.DataInputStream;
1:b7c2b67: import java.io.IOException;
1:b7c2b67: import java.util.ArrayList;
1:b7c2b67: import java.util.HashSet;
1:b7c2b67: import java.util.Iterator;
1:b7c2b67: import java.util.Map;
1:b7c2b67: import java.util.Map.Entry;
1:74846bb: import java.util.Set;
1:ec9975c: 
1:ec9975c: import org.apache.activemq.broker.BrokerService;
1:ec9975c: import org.apache.activemq.broker.BrokerServiceAware;
1:b7c2b67: import org.apache.activemq.broker.ConnectionContext;
1:74846bb: import org.apache.activemq.broker.scheduler.JobSchedulerStore;
1:b7c2b67: import org.apache.activemq.command.ActiveMQDestination;
1:b7c2b67: import org.apache.activemq.command.ActiveMQQueue;
1:b7c2b67: import org.apache.activemq.command.ActiveMQTempQueue;
1:b7c2b67: import org.apache.activemq.command.ActiveMQTempTopic;
1:b7c2b67: import org.apache.activemq.command.ActiveMQTopic;
1:b7c2b67: import org.apache.activemq.command.Message;
1:b7c2b67: import org.apache.activemq.command.MessageAck;
1:b7c2b67: import org.apache.activemq.command.MessageId;
1:a6a6a70: import org.apache.activemq.command.ProducerId;
1:b7c2b67: import org.apache.activemq.command.SubscriptionInfo;
1:b7c2b67: import org.apache.activemq.command.TransactionId;
1:b7c2b67: import org.apache.activemq.command.XATransactionId;
1:b7c2b67: import org.apache.activemq.openwire.OpenWireFormat;
1:b7c2b67: import org.apache.activemq.protobuf.Buffer;
1:b7c2b67: import org.apache.activemq.store.AbstractMessageStore;
1:b7c2b67: import org.apache.activemq.store.MessageRecoveryListener;
1:b7c2b67: import org.apache.activemq.store.MessageStore;
1:cf3d419: import org.apache.activemq.store.MessageStoreSubscriptionStatistics;
1:b7c2b67: import org.apache.activemq.store.PersistenceAdapter;
1:b7c2b67: import org.apache.activemq.store.TopicMessageStore;
1:b7c2b67: import org.apache.activemq.store.TransactionRecoveryListener;
1:b7c2b67: import org.apache.activemq.store.TransactionStore;
1:b7c2b67: import org.apache.activemq.store.kahadb.data.KahaAddMessageCommand;
1:b7c2b67: import org.apache.activemq.store.kahadb.data.KahaDestination;
1:74846bb: import org.apache.activemq.store.kahadb.data.KahaDestination.DestinationType;
1:b7c2b67: import org.apache.activemq.store.kahadb.data.KahaLocation;
1:b7c2b67: import org.apache.activemq.store.kahadb.data.KahaRemoveDestinationCommand;
1:b7c2b67: import org.apache.activemq.store.kahadb.data.KahaRemoveMessageCommand;
1:b7c2b67: import org.apache.activemq.store.kahadb.data.KahaSubscriptionCommand;
1:74846bb: import org.apache.activemq.store.kahadb.disk.journal.Location;
1:74846bb: import org.apache.activemq.store.kahadb.disk.page.Transaction;
1:b7c2b67: import org.apache.activemq.usage.MemoryUsage;
1:b7c2b67: import org.apache.activemq.usage.SystemUsage;
1:b7c2b67: import org.apache.activemq.util.ByteSequence;
1:b7c2b67: import org.apache.activemq.wireformat.WireFormat;
1:b7c2b67: 
1:ec9975c: public class TempKahaDBStore extends TempMessageDatabase implements PersistenceAdapter, BrokerServiceAware {
1:b7c2b67: 
1:27262c8:     private final WireFormat wireFormat = new OpenWireFormat();
1:ec9975c:     private BrokerService brokerService;
1:b7c2b67: 
1:74846bb:     @Override
1:b7c2b67:     public void setBrokerName(String brokerName) {
4:b7c2b67:     }
1:74846bb:     @Override
1:b7c2b67:     public void setUsageManager(SystemUsage usageManager) {
1:b7c2b67:     }
1:b7c2b67: 
1:74846bb:     @Override
1:b7c2b67:     public TransactionStore createTransactionStore() throws IOException {
1:b7c2b67:         return new TransactionStore(){
1:74846bb: 
1:74846bb:             @Override
1:27262c8:             public void commit(TransactionId txid, boolean wasPrepared, Runnable preCommit,Runnable postCommit) throws IOException {
1:27262c8:                 if (preCommit != null) {
1:27262c8:                     preCommit.run();
1:b7c2b67:                 }
1:b7c2b67:                 processCommit(txid);
1:27262c8:                 if (postCommit != null) {
1:27262c8:                     postCommit.run();
1:b7c2b67:                 }
1:b7c2b67:             }
1:74846bb:             @Override
1:b7c2b67:             public void prepare(TransactionId txid) throws IOException {
1:74846bb:                 processPrepare(txid);
1:b7c2b67:             }
1:74846bb:             @Override
1:b7c2b67:             public void rollback(TransactionId txid) throws IOException {
1:74846bb:                 processRollback(txid);
1:b7c2b67:             }
1:74846bb:             @Override
1:b7c2b67:             public void recover(TransactionRecoveryListener listener) throws IOException {
1:b7c2b67:                 for (Map.Entry<TransactionId, ArrayList<Operation>> entry : preparedTransactions.entrySet()) {
1:b7c2b67:                     XATransactionId xid = (XATransactionId)entry.getKey();
1:b7c2b67:                     ArrayList<Message> messageList = new ArrayList<Message>();
1:b7c2b67:                     ArrayList<MessageAck> ackList = new ArrayList<MessageAck>();
1:74846bb: 
1:b7c2b67:                     for (Operation op : entry.getValue()) {
1:b7c2b67:                         if( op.getClass() == AddOpperation.class ) {
1:b7c2b67:                             AddOpperation addOp = (AddOpperation)op;
1:b7c2b67:                             Message msg = (Message)wireFormat.unmarshal( new DataInputStream(addOp.getCommand().getMessage().newInput()) );
1:b7c2b67:                             messageList.add(msg);
1:b7c2b67:                         } else {
1:b7c2b67:                             RemoveOpperation rmOp = (RemoveOpperation)op;
1:b7c2b67:                             MessageAck ack = (MessageAck)wireFormat.unmarshal( new DataInputStream(rmOp.getCommand().getAck().newInput()) );
1:b7c2b67:                             ackList.add(ack);
1:b7c2b67:                         }
1:b7c2b67:                     }
1:74846bb: 
1:b7c2b67:                     Message[] addedMessages = new Message[messageList.size()];
1:b7c2b67:                     MessageAck[] acks = new MessageAck[ackList.size()];
1:b7c2b67:                     messageList.toArray(addedMessages);
1:b7c2b67:                     ackList.toArray(acks);
1:b7c2b67:                     listener.recover(xid, addedMessages, acks);
1:b7c2b67:                 }
1:b7c2b67:             }
1:74846bb:             @Override
1:b7c2b67:             public void start() throws Exception {
1:b7c2b67:             }
1:74846bb:             @Override
1:b7c2b67:             public void stop() throws Exception {
1:b7c2b67:             }
1:b7c2b67:         };
1:b7c2b67:     }
1:74846bb: 
1:b7c2b67:     public class KahaDBMessageStore extends AbstractMessageStore {
1:b7c2b67:         protected KahaDestination dest;
1:74846bb: 
1:b7c2b67:         public KahaDBMessageStore(ActiveMQDestination destination) {
1:b7c2b67:             super(destination);
1:b7c2b67:             this.dest = convert( destination );
1:b7c2b67:         }
1:b7c2b67: 
1:785b16b:         @Override
1:b7c2b67:         public ActiveMQDestination getDestination() {
1:b7c2b67:             return destination;
1:b7c2b67:         }
1:b7c2b67: 
1:74846bb:         @Override
1:b7c2b67:         public void addMessage(ConnectionContext context, Message message) throws IOException {
1:b7c2b67:             KahaAddMessageCommand command = new KahaAddMessageCommand();
1:b7c2b67:             command.setDestination(dest);
1:b2b4fc8:             command.setMessageId(message.getMessageId().toProducerKey());
1:b7c2b67:             processAdd(command, message.getTransactionId(), wireFormat.marshal(message));
1:b7c2b67:         }
1:74846bb: 
1:74846bb:         @Override
1:b7c2b67:         public void removeMessage(ConnectionContext context, MessageAck ack) throws IOException {
1:b7c2b67:             KahaRemoveMessageCommand command = new KahaRemoveMessageCommand();
1:b7c2b67:             command.setDestination(dest);
1:b2b4fc8:             command.setMessageId(ack.getLastMessageId().toProducerKey());
1:b7c2b67:             processRemove(command, ack.getTransactionId());
1:b7c2b67:         }
1:b7c2b67: 
1:74846bb:         @Override
1:b7c2b67:         public void removeAllMessages(ConnectionContext context) throws IOException {
1:b7c2b67:             KahaRemoveDestinationCommand command = new KahaRemoveDestinationCommand();
1:b7c2b67:             command.setDestination(dest);
1:b7c2b67:             process(command);
1:b7c2b67:         }
1:b7c2b67: 
1:74846bb:         @Override
1:b7c2b67:         public Message getMessage(MessageId identity) throws IOException {
1:b2b4fc8:             final String key = identity.toProducerKey();
1:74846bb: 
1:b7c2b67:             // Hopefully one day the page file supports concurrent read operations... but for now we must
1:b7c2b67:             // externally synchronize...
1:b7c2b67:             ByteSequence data;
2:b7c2b67:             synchronized(indexMutex) {
1:b7c2b67:                 data = pageFile.tx().execute(new Transaction.CallableClosure<ByteSequence, IOException>(){
1:74846bb:                     @Override
1:b7c2b67:                     public ByteSequence execute(Transaction tx) throws IOException {
2:b7c2b67:                         StoredDestination sd = getStoredDestination(dest, tx);
1:b7c2b67:                         Long sequence = sd.messageIdIndex.get(tx, key);
1:b7c2b67:                         if( sequence ==null ) {
1:b7c2b67:                             return null;
1:b7c2b67:                         }
1:b7c2b67:                         return sd.orderIndex.get(tx, sequence).data;
1:b7c2b67:                     }
2:b7c2b67:                 });
1:b7c2b67:             }
1:b7c2b67:             if( data == null ) {
1:b7c2b67:                 return null;
1:b7c2b67:             }
1:74846bb: 
1:b7c2b67:             Message msg = (Message)wireFormat.unmarshal( data );
1:74846bb:             return msg;
1:b7c2b67:         }
1:74846bb: 
1:74846bb:         @Override
1:b7c2b67:         public void recover(final MessageRecoveryListener listener) throws Exception {
1:b7c2b67:             synchronized(indexMutex) {
1:b7c2b67:                 pageFile.tx().execute(new Transaction.Closure<Exception>(){
1:74846bb:                     @Override
1:b7c2b67:                     public void execute(Transaction tx) throws Exception {
1:b7c2b67:                         StoredDestination sd = getStoredDestination(dest, tx);
1:b7c2b67:                         for (Iterator<Entry<Long, MessageRecord>> iterator = sd.orderIndex.iterator(tx); iterator.hasNext();) {
1:b7c2b67:                             Entry<Long, MessageRecord> entry = iterator.next();
1:b7c2b67:                             listener.recoverMessage( (Message) wireFormat.unmarshal(entry.getValue().data) );
1:b7c2b67:                         }
1:b7c2b67:                     }
1:b7c2b67:                 });
1:b7c2b67:             }
1:b7c2b67:         }
1:74846bb: 
1:b7c2b67:         long cursorPos=0;
1:74846bb: 
1:74846bb:         @Override
1:b7c2b67:         public void recoverNextMessages(final int maxReturned, final MessageRecoveryListener listener) throws Exception {
1:b7c2b67:             synchronized(indexMutex) {
1:b7c2b67:                 pageFile.tx().execute(new Transaction.Closure<Exception>(){
1:74846bb:                     @Override
1:b7c2b67:                     public void execute(Transaction tx) throws Exception {
1:b7c2b67:                         StoredDestination sd = getStoredDestination(dest, tx);
1:b7c2b67:                         Entry<Long, MessageRecord> entry=null;
1:b7c2b67:                         int counter = 0;
1:b7c2b67:                         for (Iterator<Entry<Long, MessageRecord>> iterator = sd.orderIndex.iterator(tx, cursorPos); iterator.hasNext();) {
1:b7c2b67:                             entry = iterator.next();
1:b7c2b67:                             listener.recoverMessage( (Message) wireFormat.unmarshal(entry.getValue().data ) );
1:b7c2b67:                             counter++;
1:b7c2b67:                             if( counter >= maxReturned ) {
1:b7c2b67:                                 break;
1:b7c2b67:                             }
1:b7c2b67:                         }
1:b7c2b67:                         if( entry!=null ) {
1:b7c2b67:                             cursorPos = entry.getKey()+1;
1:b7c2b67:                         }
1:b7c2b67:                     }
1:b7c2b67:                 });
1:b7c2b67:             }
1:b7c2b67:         }
1:74846bb: 
1:74846bb:         @Override
1:b7c2b67:         public void resetBatching() {
1:b7c2b67:             cursorPos=0;
1:b7c2b67:         }
1:74846bb: 
1:b7c2b67: 
1:74846bb:         @Override
1:b7c2b67:         public void setBatch(MessageId identity) throws IOException {
1:b2b4fc8:             final String key = identity.toProducerKey();
1:74846bb: 
1:b7c2b67:             // Hopefully one day the page file supports concurrent read operations... but for now we must
1:b7c2b67:             // externally synchronize...
1:b7c2b67:             Long location;
1:b7c2b67:             synchronized(indexMutex) {
1:b7c2b67:                 location = pageFile.tx().execute(new Transaction.CallableClosure<Long, IOException>(){
1:74846bb:                     @Override
1:b7c2b67:                     public Long execute(Transaction tx) throws IOException {
1:b7c2b67:                         StoredDestination sd = getStoredDestination(dest, tx);
1:b7c2b67:                         return sd.messageIdIndex.get(tx, key);
1:b7c2b67:                     }
1:b7c2b67:                 });
1:b7c2b67:             }
1:b7c2b67:             if( location!=null ) {
1:b7c2b67:                 cursorPos=location+1;
1:b7c2b67:             }
1:74846bb: 
1:b7c2b67:         }
1:b7c2b67: 
1:74846bb:         @Override
1:c0090f6:         public void setMemoryUsage(MemoryUsage memoryUsage) {
1:b7c2b67:         }
1:74846bb:         @Override
1:b7c2b67:         public void start() throws Exception {
1:b7c2b67:         }
1:74846bb:         @Override
1:b7c2b67:         public void stop() throws Exception {
1:b7c2b67:         }
1:b7c2b67: 
1:74846bb:         @Override
1:785b16b:         public void recoverMessageStoreStatistics() throws IOException {
1:785b16b:             int count = 0;
1:785b16b:             synchronized(indexMutex) {
1:785b16b:                 count = pageFile.tx().execute(new Transaction.CallableClosure<Integer, IOException>(){
1:785b16b:                     @Override
1:785b16b:                     public Integer execute(Transaction tx) throws IOException {
1:785b16b:                         // Iterate through all index entries to get a count of messages in the destination.
1:785b16b:                         StoredDestination sd = getStoredDestination(dest, tx);
1:785b16b:                         int rc=0;
1:785b16b:                         for (Iterator<Entry<String, Long>> iterator = sd.messageIdIndex.iterator(tx); iterator.hasNext();) {
1:785b16b:                             iterator.next();
1:785b16b:                             rc++;
1:785b16b:                         }
1:785b16b:                         return rc;
1:785b16b:                     }
1:785b16b:                 });
1:785b16b:             }
1:785b16b:             getMessageStoreStatistics().getMessageCount().setCount(count);
1:785b16b:         }
1:785b16b: 
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     class KahaDBTopicMessageStore extends KahaDBMessageStore implements TopicMessageStore {
1:b7c2b67:         public KahaDBTopicMessageStore(ActiveMQTopic destination) {
1:b7c2b67:             super(destination);
1:b7c2b67:         }
1:74846bb: 
1:74846bb:         @Override
1:3432a75:         public void acknowledge(ConnectionContext context, String clientId, String subscriptionName,
1:3432a75:                                 MessageId messageId, MessageAck ack) throws IOException {
1:b7c2b67:             KahaRemoveMessageCommand command = new KahaRemoveMessageCommand();
1:b7c2b67:             command.setDestination(dest);
1:b7c2b67:             command.setSubscriptionKey(subscriptionKey(clientId, subscriptionName));
1:b2b4fc8:             command.setMessageId(messageId.toProducerKey());
1:b7c2b67:             // We are not passed a transaction info.. so we can't participate in a transaction.
1:b7c2b67:             // Looks like a design issue with the TopicMessageStore interface.  Also we can't recover the original ack
1:b7c2b67:             // to pass back to the XA recover method.
1:b7c2b67:             // command.setTransactionInfo();
1:b7c2b67:             processRemove(command, null);
1:b7c2b67:         }
1:b7c2b67: 
1:74846bb:         @Override
1:c0090f6:         public void addSubscription(SubscriptionInfo subscriptionInfo, boolean retroactive) throws IOException {
1:b7c2b67:             String subscriptionKey = subscriptionKey(subscriptionInfo.getClientId(), subscriptionInfo.getSubscriptionName());
1:b7c2b67:             KahaSubscriptionCommand command = new KahaSubscriptionCommand();
1:b7c2b67:             command.setDestination(dest);
1:b7c2b67:             command.setSubscriptionKey(subscriptionKey);
1:b7c2b67:             command.setRetroactive(retroactive);
1:b7c2b67:             org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(subscriptionInfo);
1:b7c2b67:             command.setSubscriptionInfo(new Buffer(packet.getData(), packet.getOffset(), packet.getLength()));
1:b7c2b67:             process(command);
1:b7c2b67:         }
1:b7c2b67: 
1:74846bb:         @Override
1:b7c2b67:         public void deleteSubscription(String clientId, String subscriptionName) throws IOException {
1:b7c2b67:             KahaSubscriptionCommand command = new KahaSubscriptionCommand();
1:b7c2b67:             command.setDestination(dest);
1:b7c2b67:             command.setSubscriptionKey(subscriptionKey(clientId, subscriptionName));
1:b7c2b67:             process(command);
1:b7c2b67:         }
1:b7c2b67: 
1:74846bb:         @Override
1:b7c2b67:         public SubscriptionInfo[] getAllSubscriptions() throws IOException {
1:74846bb: 
1:b7c2b67:             final ArrayList<SubscriptionInfo> subscriptions = new ArrayList<SubscriptionInfo>();
1:b7c2b67:             synchronized(indexMutex) {
1:b7c2b67:                 pageFile.tx().execute(new Transaction.Closure<IOException>(){
1:74846bb:                     @Override
1:b7c2b67:                     public void execute(Transaction tx) throws IOException {
1:b7c2b67:                         StoredDestination sd = getStoredDestination(dest, tx);
1:b7c2b67:                         for (Iterator<Entry<String, KahaSubscriptionCommand>> iterator = sd.subscriptions.iterator(tx); iterator.hasNext();) {
1:b7c2b67:                             Entry<String, KahaSubscriptionCommand> entry = iterator.next();
1:b7c2b67:                             SubscriptionInfo info = (SubscriptionInfo)wireFormat.unmarshal( new DataInputStream(entry.getValue().getSubscriptionInfo().newInput()) );
1:b7c2b67:                             subscriptions.add(info);
1:b7c2b67: 
1:b7c2b67:                         }
1:b7c2b67:                     }
1:b7c2b67:                 });
1:b7c2b67:             }
1:b7c2b67: 
1:b7c2b67:             SubscriptionInfo[]rc=new SubscriptionInfo[subscriptions.size()];
1:b7c2b67:             subscriptions.toArray(rc);
2:b7c2b67:             return rc;
1:b7c2b67:         }
1:b7c2b67: 
1:74846bb:         @Override
1:b7c2b67:         public SubscriptionInfo lookupSubscription(String clientId, String subscriptionName) throws IOException {
1:b7c2b67:             final String subscriptionKey = subscriptionKey(clientId, subscriptionName);
1:b7c2b67:             synchronized(indexMutex) {
1:b7c2b67:                 return pageFile.tx().execute(new Transaction.CallableClosure<SubscriptionInfo, IOException>(){
1:74846bb:                     @Override
1:b7c2b67:                     public SubscriptionInfo execute(Transaction tx) throws IOException {
1:b7c2b67:                         StoredDestination sd = getStoredDestination(dest, tx);
1:b7c2b67:                         KahaSubscriptionCommand command = sd.subscriptions.get(tx, subscriptionKey);
1:b7c2b67:                         if( command ==null ) {
1:b7c2b67:                             return null;
1:b7c2b67:                         }
1:b7c2b67:                         return (SubscriptionInfo)wireFormat.unmarshal( new DataInputStream(command.getSubscriptionInfo().newInput()) );
1:b7c2b67:                     }
1:b7c2b67:                 });
1:b7c2b67:             }
1:b7c2b67:         }
1:b7c2b67: 
1:74846bb:         @Override
1:b7c2b67:         public int getMessageCount(String clientId, String subscriptionName) throws IOException {
1:b7c2b67:             final String subscriptionKey = subscriptionKey(clientId, subscriptionName);
1:b7c2b67:             synchronized(indexMutex) {
2:b7c2b67:                 return pageFile.tx().execute(new Transaction.CallableClosure<Integer, IOException>(){
1:74846bb:                     @Override
2:b7c2b67:                     public Integer execute(Transaction tx) throws IOException {
1:b7c2b67:                         StoredDestination sd = getStoredDestination(dest, tx);
1:b7c2b67:                         Long cursorPos = sd.subscriptionAcks.get(tx, subscriptionKey);
1:b7c2b67:                         if ( cursorPos==null ) {
1:b7c2b67:                             // The subscription might not exist.
1:b7c2b67:                             return 0;
1:b7c2b67:                         }
1:b7c2b67:                         cursorPos += 1;
1:74846bb: 
1:b7c2b67:                         int counter = 0;
1:b7c2b67:                         for (Iterator<Entry<Long, MessageRecord>> iterator = sd.orderIndex.iterator(tx, cursorPos); iterator.hasNext();) {
2:b7c2b67:                             iterator.next();
1:b7c2b67:                             counter++;
1:b7c2b67:                         }
1:b7c2b67:                         return counter;
1:74846bb:                     }
1:b7c2b67:                 });
1:b7c2b67:             }
1:b7c2b67:         }
1:b7c2b67: 
1:74846bb:         @Override
1:734fb7d:         public long getMessageSize(String clientId, String subscriptionName) throws IOException {
1:734fb7d:             return 0;
1:734fb7d:         }
1:734fb7d: 
1:cf3d419:         private final MessageStoreSubscriptionStatistics stats = new MessageStoreSubscriptionStatistics(false);
1:cf3d419: 
1:cf3d419:         @Override
1:cf3d419:         public MessageStoreSubscriptionStatistics getMessageStoreSubStatistics() {
1:cf3d419:             return stats;
1:cf3d419:         }
1:cf3d419: 
1:734fb7d:         @Override
1:b7c2b67:         public void recoverSubscription(String clientId, String subscriptionName, final MessageRecoveryListener listener) throws Exception {
1:b7c2b67:             final String subscriptionKey = subscriptionKey(clientId, subscriptionName);
1:b7c2b67:             synchronized(indexMutex) {
1:b7c2b67:                 pageFile.tx().execute(new Transaction.Closure<Exception>(){
1:74846bb:                     @Override
1:b7c2b67:                     public void execute(Transaction tx) throws Exception {
1:b7c2b67:                         StoredDestination sd = getStoredDestination(dest, tx);
1:b7c2b67:                         Long cursorPos = sd.subscriptionAcks.get(tx, subscriptionKey);
1:b7c2b67:                         cursorPos += 1;
1:74846bb: 
1:b7c2b67:                         for (Iterator<Entry<Long, MessageRecord>> iterator = sd.orderIndex.iterator(tx, cursorPos); iterator.hasNext();) {
1:b7c2b67:                             Entry<Long, MessageRecord> entry = iterator.next();
1:b7c2b67:                             listener.recoverMessage( (Message) wireFormat.unmarshal(entry.getValue().data ) );
1:b7c2b67:                         }
1:b7c2b67:                     }
1:b7c2b67:                 });
1:b7c2b67:             }
1:b7c2b67:         }
1:b7c2b67: 
1:b7c2b67:         @Override
1:b7c2b67:         public void recoverNextMessages(String clientId, String subscriptionName, final int maxReturned, final MessageRecoveryListener listener) throws Exception {
1:b7c2b67:             final String subscriptionKey = subscriptionKey(clientId, subscriptionName);
1:b7c2b67:             synchronized(indexMutex) {
1:b7c2b67:                 pageFile.tx().execute(new Transaction.Closure<Exception>(){
1:74846bb:                     @Override
1:b7c2b67:                     public void execute(Transaction tx) throws Exception {
1:b7c2b67:                         StoredDestination sd = getStoredDestination(dest, tx);
1:b7c2b67:                         Long cursorPos = sd.subscriptionCursors.get(subscriptionKey);
1:b7c2b67:                         if( cursorPos == null ) {
1:b7c2b67:                             cursorPos = sd.subscriptionAcks.get(tx, subscriptionKey);
1:b7c2b67:                             cursorPos += 1;
1:b7c2b67:                         }
1:74846bb: 
1:b7c2b67:                         Entry<Long, MessageRecord> entry=null;
1:b7c2b67:                         int counter = 0;
1:b7c2b67:                         for (Iterator<Entry<Long, MessageRecord>> iterator = sd.orderIndex.iterator(tx, cursorPos); iterator.hasNext();) {
1:b7c2b67:                             entry = iterator.next();
1:b7c2b67:                             listener.recoverMessage( (Message) wireFormat.unmarshal(entry.getValue().data ) );
1:b7c2b67:                             counter++;
1:b7c2b67:                             if( counter >= maxReturned ) {
1:b7c2b67:                                 break;
1:b7c2b67:                             }
1:b7c2b67:                         }
1:b7c2b67:                         if( entry!=null ) {
1:19bfd9d:                             sd.subscriptionCursors.put(subscriptionKey, entry.getKey() + 1);
1:b7c2b67:                         }
1:b7c2b67:                     }
1:b7c2b67:                 });
1:b7c2b67:             }
1:b7c2b67:         }
1:b7c2b67: 
1:27262c8:         @Override
1:b7c2b67:         public void resetBatching(String clientId, String subscriptionName) {
1:b7c2b67:             try {
1:b7c2b67:                 final String subscriptionKey = subscriptionKey(clientId, subscriptionName);
1:b7c2b67:                 synchronized(indexMutex) {
1:b7c2b67:                     pageFile.tx().execute(new Transaction.Closure<IOException>(){
1:74846bb:                         @Override
1:b7c2b67:                         public void execute(Transaction tx) throws IOException {
1:b7c2b67:                             StoredDestination sd = getStoredDestination(dest, tx);
1:b7c2b67:                             sd.subscriptionCursors.remove(subscriptionKey);
1:b7c2b67:                         }
1:b7c2b67:                     });
1:b7c2b67:                 }
1:b7c2b67:             } catch (IOException e) {
1:b7c2b67:                 throw new RuntimeException(e);
1:b7c2b67:             }
1:b7c2b67:         }
1:b7c2b67:     }
1:74846bb: 
1:b7c2b67:     String subscriptionKey(String clientId, String subscriptionName){
1:b7c2b67:         return clientId+":"+subscriptionName;
1:b7c2b67:     }
1:74846bb: 
1:74846bb:     @Override
1:b7c2b67:     public MessageStore createQueueMessageStore(ActiveMQQueue destination) throws IOException {
1:b7c2b67:         return new KahaDBMessageStore(destination);
1:b7c2b67:     }
1:b7c2b67: 
1:74846bb:     @Override
1:b7c2b67:     public TopicMessageStore createTopicMessageStore(ActiveMQTopic destination) throws IOException {
1:b7c2b67:         return new KahaDBTopicMessageStore(destination);
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     /**
1:b7c2b67:      * Cleanup method to remove any state associated with the given destination.
1:b7c2b67:      * This method does not stop the message store (it might not be cached).
1:b7c2b67:      *
1:b7c2b67:      * @param destination Destination to forget
1:b7c2b67:      */
1:74846bb:     @Override
1:b7c2b67:     public void removeQueueMessageStore(ActiveMQQueue destination) {
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     /**
1:b7c2b67:      * Cleanup method to remove any state associated with the given destination
1:b7c2b67:      * This method does not stop the message store (it might not be cached).
1:b7c2b67:      *
1:b7c2b67:      * @param destination Destination to forget
1:b7c2b67:      */
1:74846bb:     @Override
1:b7c2b67:     public void removeTopicMessageStore(ActiveMQTopic destination) {
1:b7c2b67:     }
1:b7c2b67: 
1:74846bb:     @Override
1:b7c2b67:     public void deleteAllMessages() throws IOException {
1:b7c2b67:     }
1:74846bb: 
1:74846bb: 
1:74846bb:     @Override
1:b7c2b67:     public Set<ActiveMQDestination> getDestinations() {
1:b7c2b67:         try {
1:b7c2b67:             final HashSet<ActiveMQDestination> rc = new HashSet<ActiveMQDestination>();
1:b7c2b67:             synchronized(indexMutex) {
1:b7c2b67:                 pageFile.tx().execute(new Transaction.Closure<IOException>(){
1:74846bb:                     @Override
1:b7c2b67:                     public void execute(Transaction tx) throws IOException {
1:b7c2b67:                         for (Iterator<Entry<String, StoredDestination>> iterator = destinations.iterator(tx); iterator.hasNext();) {
1:b7c2b67:                             Entry<String, StoredDestination> entry = iterator.next();
1:b7c2b67:                             rc.add(convert(entry.getKey()));
1:b7c2b67:                         }
1:b7c2b67:                     }
1:b7c2b67:                 });
1:b7c2b67:             }
1:b7c2b67:             return rc;
1:b7c2b67:         } catch (IOException e) {
1:b7c2b67:             throw new RuntimeException(e);
1:b7c2b67:         }
1:b7c2b67:     }
1:b7c2b67: 
1:74846bb:     @Override
1:b7c2b67:     public long getLastMessageBrokerSequenceId() throws IOException {
1:b7c2b67:         return 0;
1:b7c2b67:     }
1:74846bb: 
1:74846bb:     @Override
1:b7c2b67:     public long size() {
1:b7c2b67:         if ( !started.get() ) {
1:b7c2b67:             return 0;
1:b7c2b67:         }
1:b7c2b67:         try {
1:b7c2b67:             return pageFile.getDiskSize();
1:b7c2b67:         } catch (IOException e) {
1:b7c2b67:             throw new RuntimeException(e);
1:b7c2b67:         }
1:b7c2b67:     }
1:b7c2b67: 
3:27262c8:     @Override
1:b7c2b67:     public void beginTransaction(ConnectionContext context) throws IOException {
1:b7c2b67:         throw new IOException("Not yet implemented.");
1:b7c2b67:     }
1:74846bb:     @Override
1:b7c2b67:     public void commitTransaction(ConnectionContext context) throws IOException {
1:b7c2b67:         throw new IOException("Not yet implemented.");
1:b7c2b67:     }
1:74846bb:     @Override
1:b7c2b67:     public void rollbackTransaction(ConnectionContext context) throws IOException {
1:b7c2b67:         throw new IOException("Not yet implemented.");
1:b7c2b67:     }
1:74846bb: 
1:74846bb:     @Override
1:b7c2b67:     public void checkpoint(boolean sync) throws IOException {
1:74846bb:     }
1:b7c2b67: 
1:b7c2b67:     ///////////////////////////////////////////////////////////////////
1:b7c2b67:     // Internal conversion methods.
1:b7c2b67:     ///////////////////////////////////////////////////////////////////
1:74846bb: 
1:74846bb: 
1:b7c2b67: 
1:b7c2b67:     KahaLocation convert(Location location) {
1:b7c2b67:         KahaLocation rc = new KahaLocation();
1:b7c2b67:         rc.setLogId(location.getDataFileId());
1:b7c2b67:         rc.setOffset(location.getOffset());
1:b7c2b67:         return rc;
1:b7c2b67:     }
1:74846bb: 
1:b7c2b67:     KahaDestination convert(ActiveMQDestination dest) {
1:b7c2b67:         KahaDestination rc = new KahaDestination();
1:b7c2b67:         rc.setName(dest.getPhysicalName());
1:b7c2b67:         switch( dest.getDestinationType() ) {
1:b7c2b67:         case ActiveMQDestination.QUEUE_TYPE:
1:b7c2b67:             rc.setType(DestinationType.QUEUE);
1:b7c2b67:             return rc;
1:b7c2b67:         case ActiveMQDestination.TOPIC_TYPE:
1:b7c2b67:             rc.setType(DestinationType.TOPIC);
1:b7c2b67:             return rc;
1:b7c2b67:         case ActiveMQDestination.TEMP_QUEUE_TYPE:
1:b7c2b67:             rc.setType(DestinationType.TEMP_QUEUE);
1:b7c2b67:             return rc;
1:b7c2b67:         case ActiveMQDestination.TEMP_TOPIC_TYPE:
1:b7c2b67:             rc.setType(DestinationType.TEMP_TOPIC);
1:b7c2b67:             return rc;
2:b7c2b67:         default:
1:b7c2b67:             return null;
1:b7c2b67:         }
1:b7c2b67:     }
1:b7c2b67: 
1:b7c2b67:     ActiveMQDestination convert(String dest) {
1:b7c2b67:         int p = dest.indexOf(":");
1:b7c2b67:         if( p<0 ) {
1:b7c2b67:             throw new IllegalArgumentException("Not in the valid destination format");
1:b7c2b67:         }
1:b7c2b67:         int type = Integer.parseInt(dest.substring(0, p));
1:b7c2b67:         String name = dest.substring(p+1);
1:74846bb: 
1:b7c2b67:         switch( KahaDestination.DestinationType.valueOf(type) ) {
1:b7c2b67:         case QUEUE:
1:b7c2b67:             return new ActiveMQQueue(name);
1:b7c2b67:         case TOPIC:
1:b7c2b67:             return new ActiveMQTopic(name);
1:b7c2b67:         case TEMP_QUEUE:
1:b7c2b67:             return new ActiveMQTempQueue(name);
1:b7c2b67:         case TEMP_TOPIC:
1:b7c2b67:             return new ActiveMQTempTopic(name);
1:74846bb:         default:
1:b7c2b67:             throw new IllegalArgumentException("Not in the valid destination format");
1:b7c2b67:         }
1:b7c2b67:     }
1:74846bb: 
1:74846bb:     @Override
1:a6a6a70:     public long getLastProducerSequenceId(ProducerId id) {
1:a6a6a70:         return -1;
1:b7c2b67:     }
1:ec9975c: 
1:ec9975c:     @Override
1:b07821a:     public void allowIOResumption() {
1:b07821a:         if (pageFile != null) {
1:b07821a:             pageFile.allowIOResumption();
1:b07821a:         }
1:b07821a:     }
1:b07821a: 
1:b07821a:     @Override
1:ec9975c:     public void setBrokerService(BrokerService brokerService) {
1:ec9975c:         this.brokerService = brokerService;
1:ec9975c:     }
1:ec9975c: 
1:ec9975c:     @Override
1:ec9975c:     public void load() throws IOException {
1:ec9975c:         if( brokerService!=null ) {
1:ec9975c:             wireFormat.setVersion(brokerService.getStoreOpenWireVersion());
1:ec9975c:         }
1:ec9975c:         super.load();
1:ec9975c:     }
1:74846bb:     @Override
1:74846bb:     public JobSchedulerStore createJobSchedulerStore() throws IOException, UnsupportedOperationException {
1:74846bb:         throw new UnsupportedOperationException();
1:74846bb:     }
1:b7c2b67: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:b07821a
/////////////////////////////////////////////////////////////////////////
1:     public void allowIOResumption() {
1:         if (pageFile != null) {
1:             pageFile.allowIOResumption();
1:         }
1:     }
1: 
1:     @Override
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:cf3d419
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.MessageStoreSubscriptionStatistics;
/////////////////////////////////////////////////////////////////////////
1:         private final MessageStoreSubscriptionStatistics stats = new MessageStoreSubscriptionStatistics(false);
1: 
1:         @Override
1:         public MessageStoreSubscriptionStatistics getMessageStoreSubStatistics() {
1:             return stats;
1:         }
1: 
commit:734fb7d
/////////////////////////////////////////////////////////////////////////
1:         public long getMessageSize(String clientId, String subscriptionName) throws IOException {
1:             return 0;
1:         }
1: 
1:         @Override
commit:785b16b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:         public void recoverMessageStoreStatistics() throws IOException {
1:             int count = 0;
1:             synchronized(indexMutex) {
1:                 count = pageFile.tx().execute(new Transaction.CallableClosure<Integer, IOException>(){
1:                     @Override
1:                     public Integer execute(Transaction tx) throws IOException {
1:                         // Iterate through all index entries to get a count of messages in the destination.
1:                         StoredDestination sd = getStoredDestination(dest, tx);
1:                         int rc=0;
1:                         for (Iterator<Entry<String, Long>> iterator = sd.messageIdIndex.iterator(tx); iterator.hasNext();) {
1:                             iterator.next();
1:                             rc++;
1:                         }
1:                         return rc;
1:                     }
1:                 });
1:             }
1:             getMessageStoreStatistics().getMessageCount().setCount(count);
1:         }
1: 
author:Timothy Bish
-------------------------------------------------------------------------------
commit:74846bb
/////////////////////////////////////////////////////////////////////////
1: import java.util.Set;
1: import org.apache.activemq.broker.scheduler.JobSchedulerStore;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.kahadb.data.KahaDestination.DestinationType;
1: import org.apache.activemq.store.kahadb.disk.journal.Location;
1: import org.apache.activemq.store.kahadb.disk.page.Transaction;
1:     @Override
1:     @Override
1:     @Override
1: 
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:                 processPrepare(txid);
1:             @Override
1:                 processRollback(txid);
1:             @Override
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
1: 
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:         @Override
1: 
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1: 
1:             return msg;
1: 
1:         @Override
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1: 
1:         @Override
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
1: 
1: 
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
1: 
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1: 
1:         @Override
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1: 
1:         @Override
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             }
1:         @Override
1:                     @Override
1: 
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:                         @Override
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1: 
1: 
1:     @Override
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1: 
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1: 
1:     @Override
1:     }
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         default:
1: 
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public JobSchedulerStore createJobSchedulerStore() throws IOException, UnsupportedOperationException {
1:         throw new UnsupportedOperationException();
1:     }
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:c0090f6
/////////////////////////////////////////////////////////////////////////
1:         public void setMemoryUsage(MemoryUsage memoryUsage) {
/////////////////////////////////////////////////////////////////////////
1:         public void addSubscription(SubscriptionInfo subscriptionInfo, boolean retroactive) throws IOException {
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:ec9975c
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.BrokerServiceAware;
/////////////////////////////////////////////////////////////////////////
1: public class TempKahaDBStore extends TempMessageDatabase implements PersistenceAdapter, BrokerServiceAware {
1:     private BrokerService brokerService;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     public void setBrokerService(BrokerService brokerService) {
1:         this.brokerService = brokerService;
1:     }
1: 
1:     @Override
1:     public void load() throws IOException {
1:         if( brokerService!=null ) {
1:             wireFormat.setVersion(brokerService.getStoreOpenWireVersion());
1:         }
1:         super.load();
1:     }
commit:b2b4fc8
/////////////////////////////////////////////////////////////////////////
1:             command.setMessageId(message.getMessageId().toProducerKey());
1:             command.setMessageId(ack.getLastMessageId().toProducerKey());
/////////////////////////////////////////////////////////////////////////
1:             final String key = identity.toProducerKey();
/////////////////////////////////////////////////////////////////////////
1:             final String key = identity.toProducerKey();
/////////////////////////////////////////////////////////////////////////
1:             command.setMessageId(messageId.toProducerKey());
commit:c5cf038
commit:1aab71b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.kahadb.disk.journal.Location;
0: import org.apache.activemq.store.kahadb.disk.page.Transaction;
commit:b7c2b67
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.store.kahadb;
1: 
1: import java.io.DataInputStream;
1: import java.io.IOException;
1: import java.util.ArrayList;
1: import java.util.HashSet;
1: import java.util.Iterator;
1: import java.util.Map;
0: import java.util.Set;
1: import java.util.Map.Entry;
1: 
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.command.ActiveMQTempQueue;
1: import org.apache.activemq.command.ActiveMQTempTopic;
1: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.command.SubscriptionInfo;
1: import org.apache.activemq.command.TransactionId;
1: import org.apache.activemq.command.XATransactionId;
1: import org.apache.activemq.openwire.OpenWireFormat;
1: import org.apache.activemq.protobuf.Buffer;
1: import org.apache.activemq.store.AbstractMessageStore;
1: import org.apache.activemq.store.MessageRecoveryListener;
1: import org.apache.activemq.store.MessageStore;
1: import org.apache.activemq.store.PersistenceAdapter;
1: import org.apache.activemq.store.TopicMessageStore;
1: import org.apache.activemq.store.TransactionRecoveryListener;
1: import org.apache.activemq.store.TransactionStore;
1: import org.apache.activemq.store.kahadb.data.KahaAddMessageCommand;
1: import org.apache.activemq.store.kahadb.data.KahaDestination;
1: import org.apache.activemq.store.kahadb.data.KahaLocation;
1: import org.apache.activemq.store.kahadb.data.KahaRemoveDestinationCommand;
1: import org.apache.activemq.store.kahadb.data.KahaRemoveMessageCommand;
1: import org.apache.activemq.store.kahadb.data.KahaSubscriptionCommand;
0: import org.apache.activemq.store.kahadb.data.KahaDestination.DestinationType;
1: import org.apache.activemq.usage.MemoryUsage;
1: import org.apache.activemq.usage.SystemUsage;
1: import org.apache.activemq.util.ByteSequence;
1: import org.apache.activemq.wireformat.WireFormat;
0: import org.apache.kahadb.journal.Location;
0: import org.apache.kahadb.page.Transaction;
1: 
0: public class TempKahaDBStore extends TempMessageDatabase implements PersistenceAdapter {
1: 
0:     private WireFormat wireFormat = new OpenWireFormat();
1: 
1:     public void setBrokerName(String brokerName) {
1:     }
1:     public void setUsageManager(SystemUsage usageManager) {
1:     }
1: 
1:     public TransactionStore createTransactionStore() throws IOException {
1:         return new TransactionStore(){
1:             
0:             public void commit(TransactionId txid, boolean wasPrepared) throws IOException {
1:                 processCommit(txid);
1:             }
1:             public void prepare(TransactionId txid) throws IOException {
0:             	processPrepare(txid);
1:             }
1:             public void rollback(TransactionId txid) throws IOException {
0:             	processRollback(txid);
1:             }
1:             public void recover(TransactionRecoveryListener listener) throws IOException {
1:                 for (Map.Entry<TransactionId, ArrayList<Operation>> entry : preparedTransactions.entrySet()) {
1:                     XATransactionId xid = (XATransactionId)entry.getKey();
1:                     ArrayList<Message> messageList = new ArrayList<Message>();
1:                     ArrayList<MessageAck> ackList = new ArrayList<MessageAck>();
1:                     
1:                     for (Operation op : entry.getValue()) {
1:                         if( op.getClass() == AddOpperation.class ) {
1:                             AddOpperation addOp = (AddOpperation)op;
1:                             Message msg = (Message)wireFormat.unmarshal( new DataInputStream(addOp.getCommand().getMessage().newInput()) );
1:                             messageList.add(msg);
1:                         } else {
1:                             RemoveOpperation rmOp = (RemoveOpperation)op;
1:                             MessageAck ack = (MessageAck)wireFormat.unmarshal( new DataInputStream(rmOp.getCommand().getAck().newInput()) );
1:                             ackList.add(ack);
1:                         }
1:                     }
1:                     
1:                     Message[] addedMessages = new Message[messageList.size()];
1:                     MessageAck[] acks = new MessageAck[ackList.size()];
1:                     messageList.toArray(addedMessages);
1:                     ackList.toArray(acks);
1:                     listener.recover(xid, addedMessages, acks);
1:                 }
1:             }
1:             public void start() throws Exception {
1:             }
1:             public void stop() throws Exception {
1:             }
1:         };
1:     }
1: 
1:     public class KahaDBMessageStore extends AbstractMessageStore {
1:         protected KahaDestination dest;
1: 
1:         public KahaDBMessageStore(ActiveMQDestination destination) {
1:             super(destination);
1:             this.dest = convert( destination );
1:         }
1: 
1:         public ActiveMQDestination getDestination() {
1:             return destination;
1:         }
1: 
1:         public void addMessage(ConnectionContext context, Message message) throws IOException {
1:             KahaAddMessageCommand command = new KahaAddMessageCommand();
1:             command.setDestination(dest);
0:             command.setMessageId(message.getMessageId().toString());
1:             processAdd(command, message.getTransactionId(), wireFormat.marshal(message));
1:         }
1:         
1:         public void removeMessage(ConnectionContext context, MessageAck ack) throws IOException {
1:             KahaRemoveMessageCommand command = new KahaRemoveMessageCommand();
1:             command.setDestination(dest);
0:             command.setMessageId(ack.getLastMessageId().toString());
1:             processRemove(command, ack.getTransactionId());
1:         }
1: 
1:         public void removeAllMessages(ConnectionContext context) throws IOException {
1:             KahaRemoveDestinationCommand command = new KahaRemoveDestinationCommand();
1:             command.setDestination(dest);
1:             process(command);
1:         }
1: 
1:         public Message getMessage(MessageId identity) throws IOException {
0:             final String key = identity.toString();
1:             
1:             // Hopefully one day the page file supports concurrent read operations... but for now we must
1:             // externally synchronize...
1:             ByteSequence data;
1:             synchronized(indexMutex) {
1:                 data = pageFile.tx().execute(new Transaction.CallableClosure<ByteSequence, IOException>(){
1:                     public ByteSequence execute(Transaction tx) throws IOException {
1:                         StoredDestination sd = getStoredDestination(dest, tx);
1:                         Long sequence = sd.messageIdIndex.get(tx, key);
1:                         if( sequence ==null ) {
1:                             return null;
1:                         }
1:                         return sd.orderIndex.get(tx, sequence).data;
1:                     }
1:                 });
1:             }
1:             if( data == null ) {
1:                 return null;
1:             }
1:             
1:             Message msg = (Message)wireFormat.unmarshal( data );
0: 			return msg;
1:         }
1:         
0:         public int getMessageCount() throws IOException {
1:             synchronized(indexMutex) {
1:                 return pageFile.tx().execute(new Transaction.CallableClosure<Integer, IOException>(){
1:                     public Integer execute(Transaction tx) throws IOException {
0:                         // Iterate through all index entries to get a count of messages in the destination.
1:                         StoredDestination sd = getStoredDestination(dest, tx);
0:                         int rc=0;
0:                         for (Iterator<Entry<String, Long>> iterator = sd.messageIdIndex.iterator(tx); iterator.hasNext();) {
1:                             iterator.next();
0:                             rc++;
1:                         }
1:                         return rc;
1:                     }
1:                 });
1:             }
1:         }
1: 
1:         public void recover(final MessageRecoveryListener listener) throws Exception {
1:             synchronized(indexMutex) {
1:                 pageFile.tx().execute(new Transaction.Closure<Exception>(){
1:                     public void execute(Transaction tx) throws Exception {
1:                         StoredDestination sd = getStoredDestination(dest, tx);
1:                         for (Iterator<Entry<Long, MessageRecord>> iterator = sd.orderIndex.iterator(tx); iterator.hasNext();) {
1:                             Entry<Long, MessageRecord> entry = iterator.next();
1:                             listener.recoverMessage( (Message) wireFormat.unmarshal(entry.getValue().data) );
1:                         }
1:                     }
1:                 });
1:             }
1:         }
1: 
1:         long cursorPos=0;
1:         
1:         public void recoverNextMessages(final int maxReturned, final MessageRecoveryListener listener) throws Exception {
1:             synchronized(indexMutex) {
1:                 pageFile.tx().execute(new Transaction.Closure<Exception>(){
1:                     public void execute(Transaction tx) throws Exception {
1:                         StoredDestination sd = getStoredDestination(dest, tx);
1:                         Entry<Long, MessageRecord> entry=null;
1:                         int counter = 0;
1:                         for (Iterator<Entry<Long, MessageRecord>> iterator = sd.orderIndex.iterator(tx, cursorPos); iterator.hasNext();) {
1:                             entry = iterator.next();
1:                             listener.recoverMessage( (Message) wireFormat.unmarshal(entry.getValue().data ) );
1:                             counter++;
1:                             if( counter >= maxReturned ) {
1:                                 break;
1:                             }
1:                         }
1:                         if( entry!=null ) {
1:                             cursorPos = entry.getKey()+1;
1:                         }
1:                     }
1:                 });
1:             }
1:         }
1: 
1:         public void resetBatching() {
1:             cursorPos=0;
1:         }
1: 
1:         
1:         @Override
1:         public void setBatch(MessageId identity) throws IOException {
0:             final String key = identity.toString();
1:             
1:             // Hopefully one day the page file supports concurrent read operations... but for now we must
1:             // externally synchronize...
1:             Long location;
1:             synchronized(indexMutex) {
1:                 location = pageFile.tx().execute(new Transaction.CallableClosure<Long, IOException>(){
1:                     public Long execute(Transaction tx) throws IOException {
1:                         StoredDestination sd = getStoredDestination(dest, tx);
1:                         return sd.messageIdIndex.get(tx, key);
1:                     }
1:                 });
1:             }
1:             if( location!=null ) {
1:                 cursorPos=location+1;
1:             }
1:             
1:         }
1: 
0:         public void setMemoryUsage(MemoryUsage memoeyUSage) {
1:         }
1:         public void start() throws Exception {
1:         }
1:         public void stop() throws Exception {
1:         }
1:         
1:     }
1:         
1:     class KahaDBTopicMessageStore extends KahaDBMessageStore implements TopicMessageStore {
1:         public KahaDBTopicMessageStore(ActiveMQTopic destination) {
1:             super(destination);
1:         }
1:         
0:         public void acknowledge(ConnectionContext context, String clientId, String subscriptionName, MessageId messageId) throws IOException {
1:             KahaRemoveMessageCommand command = new KahaRemoveMessageCommand();
1:             command.setDestination(dest);
1:             command.setSubscriptionKey(subscriptionKey(clientId, subscriptionName));
0:             command.setMessageId(messageId.toString());
1:             // We are not passed a transaction info.. so we can't participate in a transaction.
1:             // Looks like a design issue with the TopicMessageStore interface.  Also we can't recover the original ack
1:             // to pass back to the XA recover method.
1:             // command.setTransactionInfo();
1:             processRemove(command, null);
1:         }
1: 
0:         public void addSubsciption(SubscriptionInfo subscriptionInfo, boolean retroactive) throws IOException {
1:             String subscriptionKey = subscriptionKey(subscriptionInfo.getClientId(), subscriptionInfo.getSubscriptionName());
1:             KahaSubscriptionCommand command = new KahaSubscriptionCommand();
1:             command.setDestination(dest);
1:             command.setSubscriptionKey(subscriptionKey);
1:             command.setRetroactive(retroactive);
1:             org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(subscriptionInfo);
1:             command.setSubscriptionInfo(new Buffer(packet.getData(), packet.getOffset(), packet.getLength()));
1:             process(command);
1:         }
1: 
1:         public void deleteSubscription(String clientId, String subscriptionName) throws IOException {
1:             KahaSubscriptionCommand command = new KahaSubscriptionCommand();
1:             command.setDestination(dest);
1:             command.setSubscriptionKey(subscriptionKey(clientId, subscriptionName));
1:             process(command);
1:         }
1: 
1:         public SubscriptionInfo[] getAllSubscriptions() throws IOException {
1:             
1:             final ArrayList<SubscriptionInfo> subscriptions = new ArrayList<SubscriptionInfo>();
1:             synchronized(indexMutex) {
1:                 pageFile.tx().execute(new Transaction.Closure<IOException>(){
1:                     public void execute(Transaction tx) throws IOException {
1:                         StoredDestination sd = getStoredDestination(dest, tx);
1:                         for (Iterator<Entry<String, KahaSubscriptionCommand>> iterator = sd.subscriptions.iterator(tx); iterator.hasNext();) {
1:                             Entry<String, KahaSubscriptionCommand> entry = iterator.next();
1:                             SubscriptionInfo info = (SubscriptionInfo)wireFormat.unmarshal( new DataInputStream(entry.getValue().getSubscriptionInfo().newInput()) );
1:                             subscriptions.add(info);
1: 
1:                         }
1:                     }
1:                 });
1:             }
1:             
1:             SubscriptionInfo[]rc=new SubscriptionInfo[subscriptions.size()];
1:             subscriptions.toArray(rc);
1:             return rc;
1:         }
1: 
1:         public SubscriptionInfo lookupSubscription(String clientId, String subscriptionName) throws IOException {
1:             final String subscriptionKey = subscriptionKey(clientId, subscriptionName);
1:             synchronized(indexMutex) {
1:                 return pageFile.tx().execute(new Transaction.CallableClosure<SubscriptionInfo, IOException>(){
1:                     public SubscriptionInfo execute(Transaction tx) throws IOException {
1:                         StoredDestination sd = getStoredDestination(dest, tx);
1:                         KahaSubscriptionCommand command = sd.subscriptions.get(tx, subscriptionKey);
1:                         if( command ==null ) {
1:                             return null;
1:                         }
1:                         return (SubscriptionInfo)wireFormat.unmarshal( new DataInputStream(command.getSubscriptionInfo().newInput()) );
1:                     }
1:                 });
1:             }
1:         }
1:        
1:         public int getMessageCount(String clientId, String subscriptionName) throws IOException {
1:             final String subscriptionKey = subscriptionKey(clientId, subscriptionName);
1:             synchronized(indexMutex) {
1:                 return pageFile.tx().execute(new Transaction.CallableClosure<Integer, IOException>(){
1:                     public Integer execute(Transaction tx) throws IOException {
1:                         StoredDestination sd = getStoredDestination(dest, tx);
1:                         Long cursorPos = sd.subscriptionAcks.get(tx, subscriptionKey);
1:                         if ( cursorPos==null ) {
1:                             // The subscription might not exist.
1:                             return 0;
1:                         }
1:                         cursorPos += 1;
1:                         
1:                         int counter = 0;
1:                         for (Iterator<Entry<Long, MessageRecord>> iterator = sd.orderIndex.iterator(tx, cursorPos); iterator.hasNext();) {
1:                             iterator.next();
1:                             counter++;
1:                         }
1:                         return counter;
1:                     }
1:                 });
1:             }        
1:         }
1: 
1:         public void recoverSubscription(String clientId, String subscriptionName, final MessageRecoveryListener listener) throws Exception {
1:             final String subscriptionKey = subscriptionKey(clientId, subscriptionName);
1:             synchronized(indexMutex) {
1:                 pageFile.tx().execute(new Transaction.Closure<Exception>(){
1:                     public void execute(Transaction tx) throws Exception {
1:                         StoredDestination sd = getStoredDestination(dest, tx);
1:                         Long cursorPos = sd.subscriptionAcks.get(tx, subscriptionKey);
1:                         cursorPos += 1;
1:                         
1:                         for (Iterator<Entry<Long, MessageRecord>> iterator = sd.orderIndex.iterator(tx, cursorPos); iterator.hasNext();) {
1:                             Entry<Long, MessageRecord> entry = iterator.next();
1:                             listener.recoverMessage( (Message) wireFormat.unmarshal(entry.getValue().data ) );
1:                         }
1:                     }
1:                 });
1:             }
1:         }
1: 
1:         public void recoverNextMessages(String clientId, String subscriptionName, final int maxReturned, final MessageRecoveryListener listener) throws Exception {
1:             final String subscriptionKey = subscriptionKey(clientId, subscriptionName);
1:             synchronized(indexMutex) {
1:                 pageFile.tx().execute(new Transaction.Closure<Exception>(){
1:                     public void execute(Transaction tx) throws Exception {
1:                         StoredDestination sd = getStoredDestination(dest, tx);
1:                         Long cursorPos = sd.subscriptionCursors.get(subscriptionKey);
1:                         if( cursorPos == null ) {
1:                             cursorPos = sd.subscriptionAcks.get(tx, subscriptionKey);
1:                             cursorPos += 1;
1:                         }
1:                         
1:                         Entry<Long, MessageRecord> entry=null;
1:                         int counter = 0;
1:                         for (Iterator<Entry<Long, MessageRecord>> iterator = sd.orderIndex.iterator(tx, cursorPos); iterator.hasNext();) {
1:                             entry = iterator.next();
1:                             listener.recoverMessage( (Message) wireFormat.unmarshal(entry.getValue().data ) );
1:                             counter++;
1:                             if( counter >= maxReturned ) {
1:                                 break;
1:                             }
1:                         }
1:                         if( entry!=null ) {
0:                             sd.subscriptionCursors.put(subscriptionKey, cursorPos+1);
1:                         }
1:                     }
1:                 });
1:             }
1:         }
1: 
1:         public void resetBatching(String clientId, String subscriptionName) {
1:             try {
1:                 final String subscriptionKey = subscriptionKey(clientId, subscriptionName);
1:                 synchronized(indexMutex) {
1:                     pageFile.tx().execute(new Transaction.Closure<IOException>(){
1:                         public void execute(Transaction tx) throws IOException {
1:                             StoredDestination sd = getStoredDestination(dest, tx);
1:                             sd.subscriptionCursors.remove(subscriptionKey);
1:                         }
1:                     });
1:                 }
1:             } catch (IOException e) {
1:                 throw new RuntimeException(e);
1:             }
1:         }
1:     }
1: 
1:     String subscriptionKey(String clientId, String subscriptionName){
1:         return clientId+":"+subscriptionName;
1:     }
1:     
1:     public MessageStore createQueueMessageStore(ActiveMQQueue destination) throws IOException {
1:         return new KahaDBMessageStore(destination);
1:     }
1: 
1:     public TopicMessageStore createTopicMessageStore(ActiveMQTopic destination) throws IOException {
1:         return new KahaDBTopicMessageStore(destination);
1:     }
1: 
1:     /**
1:      * Cleanup method to remove any state associated with the given destination.
1:      * This method does not stop the message store (it might not be cached).
1:      *
1:      * @param destination Destination to forget
1:      */
1:     public void removeQueueMessageStore(ActiveMQQueue destination) {
1:     }
1: 
1:     /**
1:      * Cleanup method to remove any state associated with the given destination
1:      * This method does not stop the message store (it might not be cached).
1:      *
1:      * @param destination Destination to forget
1:      */
1:     public void removeTopicMessageStore(ActiveMQTopic destination) {
1:     }
1: 
1:     public void deleteAllMessages() throws IOException {
1:     }
1:     
1:     
1:     public Set<ActiveMQDestination> getDestinations() {
1:         try {
1:             final HashSet<ActiveMQDestination> rc = new HashSet<ActiveMQDestination>();
1:             synchronized(indexMutex) {
1:                 pageFile.tx().execute(new Transaction.Closure<IOException>(){
1:                     public void execute(Transaction tx) throws IOException {
1:                         for (Iterator<Entry<String, StoredDestination>> iterator = destinations.iterator(tx); iterator.hasNext();) {
1:                             Entry<String, StoredDestination> entry = iterator.next();
1:                             rc.add(convert(entry.getKey()));
1:                         }
1:                     }
1:                 });
1:             }
1:             return rc;
1:         } catch (IOException e) {
1:             throw new RuntimeException(e);
1:         }
1:     }
1:     
1:     public long getLastMessageBrokerSequenceId() throws IOException {
1:         return 0;
1:     }
1:     
1:     public long size() {
1:         if ( !started.get() ) {
1:             return 0;
1:         }
1:         try {
1:             return pageFile.getDiskSize();
1:         } catch (IOException e) {
1:             throw new RuntimeException(e);
1:         }
1:     }
1: 
1:     public void beginTransaction(ConnectionContext context) throws IOException {
1:         throw new IOException("Not yet implemented.");
1:     }
1:     public void commitTransaction(ConnectionContext context) throws IOException {
1:         throw new IOException("Not yet implemented.");
1:     }
1:     public void rollbackTransaction(ConnectionContext context) throws IOException {
1:         throw new IOException("Not yet implemented.");
1:     }
1:     
1:     public void checkpoint(boolean sync) throws IOException {
1:     }    
1: 
1:     ///////////////////////////////////////////////////////////////////
1:     // Internal conversion methods.
1:     ///////////////////////////////////////////////////////////////////
1:     
1: 
1:     
1:     KahaLocation convert(Location location) {
1:         KahaLocation rc = new KahaLocation();
1:         rc.setLogId(location.getDataFileId());
1:         rc.setOffset(location.getOffset());
1:         return rc;
1:     }
1:     
1:     KahaDestination convert(ActiveMQDestination dest) {
1:         KahaDestination rc = new KahaDestination();
1:         rc.setName(dest.getPhysicalName());
1:         switch( dest.getDestinationType() ) {
1:         case ActiveMQDestination.QUEUE_TYPE:
1:             rc.setType(DestinationType.QUEUE);
1:             return rc;
1:         case ActiveMQDestination.TOPIC_TYPE:
1:             rc.setType(DestinationType.TOPIC);
1:             return rc;
1:         case ActiveMQDestination.TEMP_QUEUE_TYPE:
1:             rc.setType(DestinationType.TEMP_QUEUE);
1:             return rc;
1:         case ActiveMQDestination.TEMP_TOPIC_TYPE:
1:             rc.setType(DestinationType.TEMP_TOPIC);
1:             return rc;
1:         default:
1:             return null;
1:         }
1:     }
1: 
1:     ActiveMQDestination convert(String dest) {
1:         int p = dest.indexOf(":");
1:         if( p<0 ) {
1:             throw new IllegalArgumentException("Not in the valid destination format");
1:         }
1:         int type = Integer.parseInt(dest.substring(0, p));
1:         String name = dest.substring(p+1);
1:         
1:         switch( KahaDestination.DestinationType.valueOf(type) ) {
1:         case QUEUE:
1:             return new ActiveMQQueue(name);
1:         case TOPIC:
1:             return new ActiveMQTopic(name);
1:         case TEMP_QUEUE:
1:             return new ActiveMQTempQueue(name);
1:         case TEMP_TOPIC:
1:             return new ActiveMQTempTopic(name);
1:         default:    
1:             throw new IllegalArgumentException("Not in the valid destination format");
1:         }
1:     }
1:         
1: }
author:Gary Tully
-------------------------------------------------------------------------------
commit:3432a75
/////////////////////////////////////////////////////////////////////////
1:         public void acknowledge(ConnectionContext context, String clientId, String subscriptionName,
1:                                 MessageId messageId, MessageAck ack) throws IOException {
commit:a6a6a70
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ProducerId;
/////////////////////////////////////////////////////////////////////////
0:     
1:     public long getLastProducerSequenceId(ProducerId id) {
1:         return -1;
0:     }
commit:e1389a6
/////////////////////////////////////////////////////////////////////////
0:             public void commit(TransactionId txid, boolean wasPrepared, Runnable done) throws IOException {
0:                 done.run();
commit:19bfd9d
/////////////////////////////////////////////////////////////////////////
1:                             sd.subscriptionCursors.put(subscriptionKey, entry.getKey() + 1);
author:Robert Davies
-------------------------------------------------------------------------------
commit:27262c8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final WireFormat wireFormat = new OpenWireFormat();
/////////////////////////////////////////////////////////////////////////
1:             public void commit(TransactionId txid, boolean wasPrepared, Runnable preCommit,Runnable postCommit) throws IOException {
1:                 if (preCommit != null) {
1:                     preCommit.run();
0:                 }
1:                 if (postCommit != null) {
1:                     postCommit.run();
0:                 }
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:         @Override
1:         @Override
============================================================================