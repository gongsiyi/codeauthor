4:4eef609: /**
1:fc00993:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:fc00993:  * contributor license agreements.  See the NOTICE file distributed with
1:fc00993:  * this work for additional information regarding copyright ownership.
1:fc00993:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:fc00993:  * (the "License"); you may not use this file except in compliance with
1:fc00993:  * the License.  You may obtain a copy of the License at
2:fc00993:  *
1:fc00993:  *      http://www.apache.org/licenses/LICENSE-2.0
1:0bbc0ac:  *
1:fc00993:  * Unless required by applicable law or agreed to in writing, software
1:fc00993:  * distributed under the License is distributed on an "AS IS" BASIS,
1:fc00993:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:fc00993:  * See the License for the specific language governing permissions and
1:fc00993:  * limitations under the License.
4:4eef609:  */
1:4eef609: package org.apache.activemq.broker.region.cursors;
1:230a86c: 
1:a7533ba: import org.apache.activemq.broker.region.MessageReference;
1:53c4e12: import org.apache.activemq.broker.region.Subscription;
1:4eef609: import org.apache.activemq.broker.region.Topic;
1:4eef609: import org.apache.activemq.command.Message;
1:4eef609: import org.apache.activemq.command.MessageId;
1:53c4e12: import org.apache.activemq.filter.MessageEvaluationContext;
1:3b0afd6: import org.apache.activemq.filter.NonCachedMessageEvaluationContext;
1:4eef609: import org.apache.activemq.store.TopicMessageStore;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:230a86c: 
1:9dd11cb: /**
1:9fcf16e:  * persist pendingCount messages pendingCount message (messages awaiting disptach
1:230a86c:  * to a consumer) cursor
1:734fb7d:  *
1:734fb7d:  *
1:9dd11cb:  */
1:071b4b1: class TopicStorePrefetch extends AbstractStoreCursor {
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(TopicStorePrefetch.class);
1:affd91e:     private final TopicMessageStore store;
1:affd91e:     private final String clientId;
1:affd91e:     private final String subscriberName;
1:53c4e12:     private final Subscription subscription;
1:fe31092:     private byte lastRecoveredPriority = 9;
1:13ec994:     private boolean storeHasMessages = false;
1:8b8f630: 
1:4eef609:     /**
1:4eef609:      * @param topic
1:4eef609:      * @param clientId
1:4eef609:      * @param subscriberName
1:4eef609:      */
1:071b4b1:     public TopicStorePrefetch(Subscription subscription,Topic topic, String clientId, String subscriberName) {
1:071b4b1:         super(topic);
1:071b4b1:         this.subscription=subscription;
1:230a86c:         this.store = (TopicMessageStore)topic.getMessageStore();
1:230a86c:         this.clientId = clientId;
1:230a86c:         this.subscriberName = subscriberName;
1:9dd11cb:         this.maxProducersToAudit=32;
1:9dd11cb:         this.maxAuditDepth=10000;
1:eaac0d2:         resetSize();
1:13ec994:         this.storeHasMessages=this.size > 0;
1:a810f43:     }
1:734fb7d: 
1:13ec994:     @Override
1:230a86c:     public boolean recoverMessageReference(MessageId messageReference) throws Exception {
1:4eef609:         // shouldn't get called
1:4eef609:         throw new RuntimeException("Not supported");
1:53c4e12:     }
1:a7533ba: 
1:734fb7d:     @Override
1:a7533ba:     public synchronized void addMessageFirst(MessageReference node) throws Exception {
1:a7533ba:         batchList.addMessageFirst(node);
1:a7533ba:         size++;
1:4318eba:         node.incrementReferenceCount();
1:a7533ba:     }
1:8b8f630: 
1:8b8f630:     @Override
1:13ec994:     public final synchronized boolean addMessageLast(MessageReference node) throws Exception {
1:13ec994:         this.storeHasMessages = super.addMessageLast(node);
1:13ec994:         return this.storeHasMessages;
1:13ec994:     }
1:8b8f630: 
1:734fb7d:     @Override
1:071b4b1:     public synchronized boolean recoverMessage(Message message, boolean cached) throws Exception {
1:f92d45b:         LOG.trace("{} recover: {}, priority: {}", this, message.getMessageId(), message.getPriority());
1:3ddb71c:         boolean recovered = false;
1:3b0afd6:         MessageEvaluationContext messageEvaluationContext = new NonCachedMessageEvaluationContext();
1:53c4e12:         messageEvaluationContext.setMessageReference(message);
1:071b4b1:         if (this.subscription.matches(message, messageEvaluationContext)) {
1:3ddb71c:             recovered = super.recoverMessage(message, cached);
1:fe31092:             if (recovered && !cached) {
1:fe31092:                 lastRecoveredPriority = message.getPriority();
1:8b8f630:             }
1:13ec994:             storeHasMessages = true;
1:53c4e12:         }
1:734fb7d:         return recovered;
1:53c4e12:     }
1:2b6f36d: 
1:affd91e:     @Override
1:511b9b6:     protected boolean duplicateFromStoreExcepted(Message message) {
1:511b9b6:         // setBatch is not implemented - sequence order not reliable with concurrent transactions
1:511b9b6:         // on cache exhaustion - first pageIn starts from last ack location which may replay what
1:511b9b6:         // cursor has dispatched
1:511b9b6:         return true;
1:511b9b6:     }
1:511b9b6: 
1:511b9b6:     @Override
1:230a86c:     protected synchronized int getStoreSize() {
1:53c4e12:         try {
1:d96c1cb:             return store.getMessageCount(clientId, subscriberName);
1:2b6f36d:         } catch (Exception e) {
1:e1bbde7:             LOG.error("{} Failed to get the outstanding message count from the store", this, e);
1:53c4e12:             throw new RuntimeException(e);
1:53c4e12:         }
1:53c4e12:     }
1:734fb7d: 
1:734fb7d: 
1:734fb7d:     @Override
1:734fb7d:     protected synchronized long getStoreMessageSize() {
1:734fb7d:         try {
1:734fb7d:             return store.getMessageSize(clientId, subscriberName);
1:734fb7d:         } catch (Exception e) {
1:734fb7d:             LOG.error("{} Failed to get the outstanding message count from the store", this, e);
1:734fb7d:             throw new RuntimeException(e);
1:734fb7d:         }
1:734fb7d:     }
1:734fb7d: 
1:affd91e:     @Override
1:affd91e:     protected synchronized boolean isStoreEmpty() {
1:230a86c:         try {
1:fe31092:             return this.store.isEmpty();
1:53c4e12:         } catch (Exception e) {
1:fe31092:             LOG.error("Failed to determine if store is empty", e);
1:a810f43:             throw new RuntimeException(e);
1:230a86c:         }
1:230a86c:     }
1:53c4e12: 
1:53c4e12: 
3:affd91e:     @Override
1:071b4b1:     protected void resetBatch() {
1:071b4b1:         this.store.resetBatching(clientId, subscriberName);
1:230a86c:     }
1:230a86c: 
1:3ddb71c:     @Override
1:071b4b1:     protected void doFillBatch() throws Exception {
1:13ec994:         // avoid repeated  trips to the store if there is nothing of interest
1:13ec994:         this.storeHasMessages = false;
1:071b4b1:         this.store.recoverNextMessages(clientId, subscriberName,
1:071b4b1:                 maxBatchSize, this);
1:511b9b6:         dealWithDuplicates();
1:13ec994:         if (!this.storeHasMessages && (!this.batchList.isEmpty() || !hadSpace)) {
1:13ec994:             this.storeHasMessages = true;
1:13ec994:         }
1:8b8f630:     }
1:230a86c: 
1:fe31092:     public byte getLastRecoveredPriority() {
1:fe31092:         return lastRecoveredPriority;
1:230a86c:     }
1:230a86c: 
1:fe31092:     public final boolean isPaging() {
1:fe31092:         return !isCacheEnabled() && !batchList.isEmpty();
1:230a86c:     }
1:230a86c: 
1:affd91e:     @Override
1:f92d45b:     public Subscription getSubscription() {
1:f92d45b:         return subscription;
1:f92d45b:     }
1:f92d45b: 
1:f92d45b:     @Override
1:230a86c:     public String toString() {
1:13ec994:         return "TopicStorePrefetch(" + clientId + "," + subscriberName + ",storeHasMessages=" + this.storeHasMessages +") " + this.subscription.getConsumerInfo().getConsumerId() + " - " + super.toString();
1:230a86c:     }
1:a810f43: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:511b9b6
/////////////////////////////////////////////////////////////////////////
1:     protected boolean duplicateFromStoreExcepted(Message message) {
1:         // setBatch is not implemented - sequence order not reliable with concurrent transactions
1:         // on cache exhaustion - first pageIn starts from last ack location which may replay what
1:         // cursor has dispatched
1:         return true;
1:     }
1: 
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         dealWithDuplicates();
commit:13ec994
/////////////////////////////////////////////////////////////////////////
1:     private boolean storeHasMessages = false;
/////////////////////////////////////////////////////////////////////////
1:         this.storeHasMessages=this.size > 0;
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public final synchronized boolean addMessageLast(MessageReference node) throws Exception {
1:         this.storeHasMessages = super.addMessageLast(node);
1:         return this.storeHasMessages;
1:     }
/////////////////////////////////////////////////////////////////////////
1:             storeHasMessages = true;
/////////////////////////////////////////////////////////////////////////
1:         // avoid repeated  trips to the store if there is nothing of interest
1:         this.storeHasMessages = false;
1:         if (!this.storeHasMessages && (!this.batchList.isEmpty() || !hadSpace)) {
1:             this.storeHasMessages = true;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         return "TopicStorePrefetch(" + clientId + "," + subscriberName + ",storeHasMessages=" + this.storeHasMessages +") " + this.subscription.getConsumerInfo().getConsumerId() + " - " + super.toString();
commit:d8cf54b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         return "TopicStorePrefetch(" + clientId + "," + subscriberName + ") " + this.subscription.getConsumerInfo().getConsumerId() + " - " + super.toString();
commit:4318eba
/////////////////////////////////////////////////////////////////////////
1:         node.incrementReferenceCount();
commit:8b8f630
/////////////////////////////////////////////////////////////////////////
0:     private boolean storeHasMessages = false;
1: 
/////////////////////////////////////////////////////////////////////////
0:         this.storeHasMessages=this.size > 0;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
0:     public final synchronized boolean addMessageLast(MessageReference node) throws Exception {
0:         this.storeHasMessages = super.addMessageLast(node);
0:         return this.storeHasMessages;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:             storeHasMessages = true;
/////////////////////////////////////////////////////////////////////////
0:         // avoid repeated  trips to the store if there is nothing of interest
0:         this.storeHasMessages = false;
0:         if (!this.storeHasMessages && (!this.batchList.isEmpty() || !hadSpace)) {
0:             this.storeHasMessages = true;
1:         }
/////////////////////////////////////////////////////////////////////////
0:         return "TopicStorePrefetch(" + clientId + "," + subscriberName + ",storeHasMessages=" + this.storeHasMessages +") " + this.subscription.getConsumerInfo().getConsumerId() + " - " + super.toString();
commit:f92d45b
/////////////////////////////////////////////////////////////////////////
1:         LOG.trace("{} recover: {}, priority: {}", this, message.getMessageId(), message.getPriority());
/////////////////////////////////////////////////////////////////////////
1:     public Subscription getSubscription() {
1:         return subscription;
1:     }
1: 
1:     @Override
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:cf3d419
/////////////////////////////////////////////////////////////////////////
commit:734fb7d
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
0:         //this.messageSize.addSize(node.getMessage().getSize());
/////////////////////////////////////////////////////////////////////////
1:         return recovered;
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     @Override
1:     protected synchronized long getStoreMessageSize() {
1:         try {
1:             return store.getMessageSize(clientId, subscriberName);
1:         } catch (Exception e) {
1:             LOG.error("{} Failed to get the outstanding message count from the store", this, e);
1:             throw new RuntimeException(e);
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
author:Timothy Bish
-------------------------------------------------------------------------------
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
0:         LOG.trace("recover: {}, priority: {}", message.getMessageId(), message.getPriority());
/////////////////////////////////////////////////////////////////////////
1:             LOG.error("{} Failed to get the outstanding message count from the store", this, e);
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:a7533ba
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.MessageReference;
/////////////////////////////////////////////////////////////////////////
1: 
1:     public synchronized void addMessageFirst(MessageReference node) throws Exception {
1:         batchList.addMessageFirst(node);
1:         size++;
1:     }
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(TopicStorePrefetch.class);
commit:d96c1cb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             return store.getMessageCount(clientId, subscriberName);
commit:2b6f36d
/////////////////////////////////////////////////////////////////////////
1:     
0:             this.store.recoverNextMessages(clientId, subscriberName, maxBatchSize, this);
0:             return size;
1:         } catch (Exception e) {
commit:9fcf16e
/////////////////////////////////////////////////////////////////////////
1:  * persist pendingCount messages pendingCount message (messages awaiting disptach
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
commit:0bbc0ac
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:53c4e12
/////////////////////////////////////////////////////////////////////////
0: import java.util.Iterator;
1: import org.apache.activemq.broker.region.Subscription;
1: import org.apache.activemq.filter.MessageEvaluationContext;
/////////////////////////////////////////////////////////////////////////
0:     private boolean batchResetNeeded = true;
0:     private boolean storeMayHaveMoreMessages = true;
1:     private final Subscription subscription;
0:     public TopicStorePrefetch(Topic topic, String clientId, String subscriberName, Subscription subscription) {
0:         this.subscription = subscription;
/////////////////////////////////////////////////////////////////////////
0:             safeFillBatch();
/////////////////////////////////////////////////////////////////////////
0:         safeFillBatch();
0:         return batchList.isEmpty();
0:         safeFillBatch();
0:         return batchList.size();
/////////////////////////////////////////////////////////////////////////
0:             storeMayHaveMoreMessages=true;
/////////////////////////////////////////////////////////////////////////
0:             storeMayHaveMoreMessages=true;
0:         gc();
/////////////////////////////////////////////////////////////////////////
0:         safeFillBatch();
0:         if (batchList.isEmpty()) {
0:             return null;
0:         } else {
0:             result = batchList.removeFirst();
0:             if (lastMessageId != null) {
0:                 if (result.getMessageId().equals(lastMessageId)) {
0:                     // pendingCount=0;
0:             result.setRegionDestination(regionDestination);
/////////////////////////////////////////////////////////////////////////
0:         MessageEvaluationContext messageEvaluationContext = new MessageEvaluationContext();
1:         messageEvaluationContext.setMessageReference(message);
0:         if( subscription.matches(message, messageEvaluationContext) ) {
0:             message.setRegionDestination(regionDestination);
0:             // only increment if count is zero (could have been cached)
0:             if (message.getReferenceCount() == 0) {
0:                 message.incrementReferenceCount();
1:             }
0:             batchList.addLast(message);
/////////////////////////////////////////////////////////////////////////
0:     protected void safeFillBatch() {
1:         try {
0:             fillBatch();
1:         } catch (Exception e) {
0:             LOG.error("Failed to fill batch", e);
1:             throw new RuntimeException(e);
1:         }
1:     }
1: 
0:         if( batchResetNeeded ) {
0:             store.resetBatching(clientId, subscriberName);
0:             batchResetNeeded=false;
0:             storeMayHaveMoreMessages=true;
1:         }
1:         
0:         while( batchList.isEmpty() && storeMayHaveMoreMessages ) {
0:             if( batchList.isEmpty() ) {
0:                 storeMayHaveMoreMessages = false;
0:             } else {
0:                 if (firstMessageId != null) {
0:                     int pos = 0;
0:                     for (Iterator<Message> iter = batchList.iterator(); iter.hasNext();) {
0:                         Message msg = iter.next();
0:                         if (msg.getMessageId().equals(firstMessageId)) {
0:                             firstMessageId = null;
0:                             break;
0:                         } else {
0:                             iter.remove();
1:                         }
/////////////////////////////////////////////////////////////////////////
0:         batchResetNeeded = true;
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(TopicStorePrefetch.class);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.error("Failed to fill batch", e);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.error("Failed to fill batch", e);
/////////////////////////////////////////////////////////////////////////
0:                         LOG.debug("Refilling batch - haven't got past first message = " + firstMessageId);
/////////////////////////////////////////////////////////////////////////
0:             LOG.error(this + " Failed to get the outstanding message count from the store", e);
commit:230a86c
/////////////////////////////////////////////////////////////////////////
0:  * perist pendingCount messages pendingCount message (messages awaiting disptach
1:  * to a consumer) cursor
0: class TopicStorePrefetch extends AbstractPendingMessageCursor implements MessageRecoveryListener {
0:     static private final Log log = LogFactory.getLog(TopicStorePrefetch.class);
0:     private final LinkedList<Message> batchList = new LinkedList<Message>();
/////////////////////////////////////////////////////////////////////////
0:     public TopicStorePrefetch(Topic topic, String clientId, String subscriberName) {
0:         this.regionDestination = topic;
1:         this.store = (TopicMessageStore)topic.getMessageStore();
1:         this.clientId = clientId;
1:         this.subscriberName = subscriberName;
0:     public synchronized void start() {
0:         if (!started) {
0:             started = true;
0:             pendingCount = getStoreSize();
1:             try {
0:             } catch (Exception e) {
0:                 log.error("Failed to fill batch", e);
0:     public synchronized void stop() {
0:         if (started) {
0:             started = false;
0:             store.resetBatching(clientId, subscriberName);
/////////////////////////////////////////////////////////////////////////
0:     public synchronized boolean isEmpty() {
0:     public synchronized int size() {
0:     public synchronized void addMessageLast(MessageReference node) throws Exception {
0:         if (node != null) {
0:             if (isEmpty() && started) {
0:                 firstMessageId = node.getMessageId();
0:             lastMessageId = node.getMessageId();
0:     public synchronized void addMessageFirst(MessageReference node) throws Exception {
0:         if (node != null) {
0:             if (started) {
0:                 firstMessageId = node.getMessageId();
1:             }
0:             node.decrementReferenceCount();
0:             pendingCount++;
1:         }
1:     }
1: 
0:     public synchronized void remove() {
0:         pendingCount--;
1:     }
1: 
0:     public synchronized void remove(MessageReference node) {
0:         pendingCount--;
1:     }
1: 
0:     public synchronized void clear() {
0:         pendingCount = 0;
1:     }
1: 
0:     public synchronized boolean hasNext() {
0:     public synchronized MessageReference next() {
0:         Message result = null;
0:         if (!isEmpty()) {
0:             if (batchList.isEmpty()) {
0:                 try {
0:                 } catch (final Exception e) {
0:                     log.error("Failed to fill batch", e);
0:                 if (batchList.isEmpty()) {
0:             if (!batchList.isEmpty()) {
0:                 result = batchList.removeFirst();
0:                 if (lastMessageId != null) {
0:                     if (result.getMessageId().equals(lastMessageId)) {
0:                         // pendingCount=0;
/////////////////////////////////////////////////////////////////////////
0:     public void reset() {
0:     public void finished() {
0:     public synchronized boolean recoverMessage(Message message) throws Exception {
0:         if (message.getReferenceCount() == 0) {
1:     public boolean recoverMessageReference(MessageId messageReference) throws Exception {
0:     protected synchronized void fillBatch() throws Exception {
0:         if (!isEmpty()) {
0:             store.recoverNextMessages(clientId, subscriberName, maxBatchSize, this);
0:             if (firstMessageId != null) {
0:                 int pos = 0;
0:                 for (Message msg : batchList) {
0:                     if (msg.getMessageId().equals(firstMessageId)) {
0:                         firstMessageId = null;
0:                 if (pos > 0) {
0:                     for (int i = 0; i < pos && !batchList.isEmpty(); i++) {
0:                     if (batchList.isEmpty()) {
/////////////////////////////////////////////////////////////////////////
1: 
0:     protected synchronized int getPendingCount() {
0:         if (pendingCount <= 0) {
1: 
1:     protected synchronized int getStoreSize() {
0:         try {
0:             return store.getMessageCount(clientId, subscriberName);
0:         } catch (IOException e) {
0:             log.error(this + " Failed to get the outstanding message count from the store", e);
0:     public synchronized void gc() {
0:         for (Message msg : batchList) {
1:     public String toString() {
0:         return "TopicStorePrefetch" + System.identityHashCode(this) + "(" + clientId + "," + subscriberName + ")";
commit:0afb7f9
/////////////////////////////////////////////////////////////////////////
0:     public void recoverMessageReference(MessageId messageReference)
commit:a810f43
/////////////////////////////////////////////////////////////////////////
0:     boolean empty;
/////////////////////////////////////////////////////////////////////////
0:     public void start() throws Exception {
0:         if(batchList.isEmpty()){
0:             try{
0:                 fillBatch();
0:             }catch(Exception e){
0:                 log.error("Failed to fill batch",e);
1:                 throw new RuntimeException(e);
1:             }
0:             empty = batchList.isEmpty();
1:         }    	
commit:7695676
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:     boolean empty=true;
0: 	private MessageId firstMessageId;
0: 	private MessageId lastMessageId;
0: 
/////////////////////////////////////////////////////////////////////////
0:         return empty;
/////////////////////////////////////////////////////////////////////////
0: 		if(node!=null){
0: 			if( empty ) {
0: 				firstMessageId = node.getMessageId();
0: 				empty=false;
0: 			}
0: 	        lastMessageId = node.getMessageId();
0:     public synchronized boolean hasNext() {
0:     	    	
0:         if( empty ) {
0:         	return null;
0:         } else {
0: 
0:         	// We may need to fill in the batch...
0:             if(batchList.isEmpty()){
0:                 try{
0:                     fillBatch();
0:                 }catch(Exception e){
0:                     log.error("Failed to fill batch",e);
0:                     throw new RuntimeException(e);
0:                 }
0:                 if( batchList.isEmpty()) {
0:                 	return null;
0:                 }
0:             }
0: 
0:             Message result = (Message)batchList.removeFirst();
0:         	
0:         	if( firstMessageId != null ) {
0:             	// Skip messages until we get to the first message.
0:         		if( !result.getMessageId().equals(firstMessageId) ) 
0:         			return null;
0:         		firstMessageId = null;
0:         	}
0:         	if( lastMessageId != null ) {
0:         		if( result.getMessageId().equals(lastMessageId) ) {
0:         			empty=true;
0:         		}
0:         	}        	
0:             result.setRegionDestination(regionDestination);
0:             return result;
0:         }
/////////////////////////////////////////////////////////////////////////
0:         store.recoverNextMessages(clientId,subscriberName,maxBatchSize,this);
author:Gary Tully
-------------------------------------------------------------------------------
commit:eaac0d2
/////////////////////////////////////////////////////////////////////////
1:         resetSize();
commit:53b29a2
/////////////////////////////////////////////////////////////////////////
0:         return "TopicStorePrefetch(" + clientId + "," + subscriberName + ") " + this.subscription.getConsumerInfo().getConsumerId() + " - " + super.toString();
commit:fe31092
/////////////////////////////////////////////////////////////////////////
1:     private byte lastRecoveredPriority = 9;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             if (recovered && !cached) {
1:                 lastRecoveredPriority = message.getPriority();
0: 
/////////////////////////////////////////////////////////////////////////
1:             return this.store.isEmpty();
1:             LOG.error("Failed to determine if store is empty", e);
/////////////////////////////////////////////////////////////////////////
1:     public byte getLastRecoveredPriority() {
1:         return lastRecoveredPriority;
0:     }
0: 
1:     public final boolean isPaging() {
1:         return !isCacheEnabled() && !batchList.isEmpty();
0:     }
0: 
commit:cb96783
/////////////////////////////////////////////////////////////////////////
0:         return "TopicStorePrefetch(" + clientId + "," + subscriberName + ")" + super.toString();
commit:3ddb71c
/////////////////////////////////////////////////////////////////////////
0:     private int currentLowestPriority;
/////////////////////////////////////////////////////////////////////////
0:         resetCurrentLowestPriority();
0:     }
0: 
0:     private void resetCurrentLowestPriority() {
0:         currentLowestPriority = 9;
0:     }
0: 
0:     public synchronized int getCurrentLowestPriority() {
0:         return currentLowestPriority;
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isTraceEnabled()) {
0:             LOG.trace("recover: " + message.getMessageId() + ", priority: " + message.getPriority());
0:         }
1:         boolean recovered = false;
1:             recovered = super.recoverMessage(message, cached);
0:             if (recovered) {
0:                 currentLowestPriority = Math.min(currentLowestPriority, message.getPriority());                
0:             }
0:         return recovered;      
/////////////////////////////////////////////////////////////////////////
0:             boolean empty = this.store.isEmpty();
0:             if (empty) {
0:                 resetCurrentLowestPriority();
0:             }
0:             return empty;
/////////////////////////////////////////////////////////////////////////
0: 
1:     @Override
0:     public synchronized void gc() {
0:         super.gc();
0:         resetCurrentLowestPriority();
0:     }
/////////////////////////////////////////////////////////////////////////
commit:6519c3e
/////////////////////////////////////////////////////////////////////////
0:     public int getLastDispatchPriority() {
0:         return last != null? last.getMessage().getPriority() : 9;
0:     }
0: 
commit:d7f34d9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Robert Davies
-------------------------------------------------------------------------------
commit:affd91e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final TopicMessageStore store;
1:     private final String clientId;
1:     private final String subscriberName;
0:     private final Subscription subscription;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:     
1:     @Override
1:     protected synchronized boolean isStoreEmpty() {
0:         try {
0:             return this.store.isEmpty();
0:             
0:         } catch (Exception e) {
0:             LOG.error("Failed to get message count", e);
0:             throw new RuntimeException(e);
0:         }
0:     }
1:     @Override
1:     @Override
1:     @Override
commit:d261412
/////////////////////////////////////////////////////////////////////////
0:         
commit:3b0afd6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.filter.NonCachedMessageEvaluationContext;
/////////////////////////////////////////////////////////////////////////
1:         MessageEvaluationContext messageEvaluationContext = new NonCachedMessageEvaluationContext();
commit:071b4b1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: class TopicStorePrefetch extends AbstractStoreCursor {
0:     private Subscription subscription;
0:     
1:     public TopicStorePrefetch(Subscription subscription,Topic topic, String clientId, String subscriberName) {
1:         super(topic);
1:         this.subscription=subscription;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     
1:     public synchronized boolean recoverMessage(Message message, boolean cached) throws Exception {
0:         MessageEvaluationContext messageEvaluationContext = new MessageEvaluationContext();
0:         messageEvaluationContext.setMessageReference(message);
1:         if (this.subscription.matches(message, messageEvaluationContext)) {
0:             return super.recoverMessage(message, cached);
0:         return false;
0:         
0:    
/////////////////////////////////////////////////////////////////////////
0:             
1:     protected void resetBatch() {
1:         this.store.resetBatching(clientId, subscriberName);
1:     protected void doFillBatch() throws Exception {
1:         this.store.recoverNextMessages(clientId, subscriberName,
1:                 maxBatchSize, this);
commit:55810b3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private boolean storeHasMessages = false;
/////////////////////////////////////////////////////////////////////////
0:             this.storeHasMessages = getStoreSize() > 0;
/////////////////////////////////////////////////////////////////////////
0:         	storeHasMessages=true;
0:         	storeHasMessages=true;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         while (this.batchList.isEmpty() && this.storeHasMessages) {
0:             this.storeHasMessages = false;
0:                 this.storeHasMessages=true;
/////////////////////////////////////////////////////////////////////////
0:         	storeHasMessages = true;
commit:3d10acc
/////////////////////////////////////////////////////////////////////////
0:             rollback(msg.getMessageId());
commit:9dd11cb
/////////////////////////////////////////////////////////////////////////
0: import java.util.LinkedHashMap;
0: import java.util.Map;
0: 
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.usage.SystemUsage;
0: import org.apache.activemq.usage.Usage;
0: import org.apache.activemq.usage.UsageListener;
/////////////////////////////////////////////////////////////////////////
0: class TopicStorePrefetch extends AbstractPendingMessageCursor implements MessageRecoveryListener, UsageListener {
0:     private final LinkedHashMap<MessageId,Message> batchList = new LinkedHashMap<MessageId,Message> ();
0:    
/////////////////////////////////////////////////////////////////////////
1:         this.maxProducersToAudit=32;
1:         this.maxAuditDepth=10000;
0:             getSystemUsage().getMemoryUsage().addUsageListener(this);
/////////////////////////////////////////////////////////////////////////
0:             getSystemUsage().getMemoryUsage().removeUsageListener(this);
/////////////////////////////////////////////////////////////////////////
0:             node.decrementReferenceCount();
0:             node.decrementReferenceCount();
0:             rollback(node.getMessageId());
/////////////////////////////////////////////////////////////////////////
0:         boolean result =  !isEmpty();
0:         return result;
/////////////////////////////////////////////////////////////////////////
0:             Iterator i = batchList.entrySet().iterator();
0:             result = (Message) ((Map.Entry)i.next()).getValue();
0:             i.remove();
0:             result.setMemoryUsage(this.getSystemUsage().getMemoryUsage());
/////////////////////////////////////////////////////////////////////////
0:     public synchronized boolean recoverMessage(Message message)
0:             throws Exception {
0:         if (subscription.matches(message, messageEvaluationContext)) {
0:             if (!isDuplicate(message.getMessageId())) {
0:                 // only increment if count is zero (could have been cached)
0:                 if (message.getReferenceCount() == 0) {
0:                     message.setMemoryUsage(this.getSystemUsage().getMemoryUsage());
0:                     message.incrementReferenceCount();
0:                    
0:                 }
0:                 batchList.put(message.getMessageId(), message);
0:             }else {
0:                 this.storeMayHaveMoreMessages=true;
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
0:      * Mark a message as already dispatched
0:      * @param message
1:      */  
0:     public synchronized void dispatched(MessageReference message) {
0:         if (this.audit != null) {
0:             isDuplicate(message.getMessageId());
0:             Message removed = this.batchList.remove(message.getMessageId());
0:             if (removed != null) {
0:                 removed.decrementReferenceCount();
0:             }
0:         }
0:     }
0:     protected synchronized void safeFillBatch() {
/////////////////////////////////////////////////////////////////////////
0:         if (batchResetNeeded) {
0:             this.store.resetBatching(clientId, subscriberName);
0:             this.batchResetNeeded = false;
0:             this.storeMayHaveMoreMessages = true;
0:         while (this.batchList.isEmpty() && this.storeMayHaveMoreMessages) {
0:             this.storeMayHaveMoreMessages = false;
0:             this.store.recoverNextMessages(clientId, subscriberName,
0:                     maxBatchSize, this);
0:             if (!this.batchList.isEmpty()) {
0:                 this.storeMayHaveMoreMessages=true;
/////////////////////////////////////////////////////////////////////////
0:         for (Message msg : batchList.values()) {
0:     
0:     public void onUsageChanged(Usage usage, int oldPercentUsage,int newPercentUsage) {
0:         if (oldPercentUsage > newPercentUsage && oldPercentUsage >= 90) {
0:             storeMayHaveMoreMessages = true;
0:             try {
0:                 fillBatch();
0:             } catch (Exception e) {
0:                 LOG.error("Failed to fill batch ", e);
0:             }
0:         }
0:     }
commit:1ee0017
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void start() throws Exception {
0:             super.start();
0:     public synchronized void stop() throws Exception {
0:             super.stop();
commit:3a5f48d
/////////////////////////////////////////////////////////////////////////
0:     public synchronized boolean recoverMessage(Message message) throws Exception{
0:         return true;
0:     public boolean recoverMessageReference(MessageId messageReference) throws Exception{
commit:a3e3821
/////////////////////////////////////////////////////////////////////////
0:     public synchronized boolean isEmpty(){
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void addMessageFirst(MessageReference node) throws Exception{
commit:9f15a47
/////////////////////////////////////////////////////////////////////////
0:                         log.debug("Refilling batch - haven't got past first message = " + firstMessageId);
commit:dc02413
/////////////////////////////////////////////////////////////////////////
0:  * perist pendingCount messages pendingCount message (messages awaiting disptach to a consumer) cursor
/////////////////////////////////////////////////////////////////////////
0:     private int pendingCount;
0:     private boolean started;
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void start(){
0:         if(!started){
0:             started=true;
0:             pendingCount=getStoreSize();
0:     public synchronized void stop(){
0:         if(started){
0:             started=false;
0:             store.resetBatching(clientId,subscriberName);
0:             gc();
0:         }
0:      * @return true if there are no pendingCount messages
0:         return pendingCount <= 0;
0:         return getPendingCount();
0:             if(isEmpty() && started){
0:             pendingCount++;
0:     
0:     public void addMessageFirst(MessageReference node) throws Exception{
0:         if(node!=null){
0:             if(started){
0:                 firstMessageId=node.getMessageId();
0:             }
0:             node.decrementReferenceCount();
0:             pendingCount++;
0:         }
0:     }
0:     
0:     public synchronized void remove(){
0:         pendingCount--;
0:     }
0:     
0:     public synchronized void remove(MessageReference node){
0:         pendingCount--;
0:     }
0:     
0:     public synchronized void clear(){
0:         pendingCount=0;
0:     }
/////////////////////////////////////////////////////////////////////////
0:         if(!isEmpty()){
/////////////////////////////////////////////////////////////////////////
0:                 if(lastMessageId!=null){
0:                     if(result.getMessageId().equals(lastMessageId)){
0:                         //pendingCount=0;
0:                 result.setRegionDestination(regionDestination);
/////////////////////////////////////////////////////////////////////////
0:         if(!isEmpty()){
0:             store.recoverNextMessages(clientId,subscriberName,maxBatchSize,this);
0:             if(firstMessageId!=null){
0:                 int pos=0;
0:                 for(Message msg:batchList){
0:                     if(msg.getMessageId().equals(firstMessageId)){
0:                         firstMessageId=null;
0:                         break;
0:                     }
0:                     pos++;
0:                 }
0:                 if(pos>0){
0:                     for(int i=0;i<pos&&!batchList.isEmpty();i++){
0:                         batchList.removeFirst();
0:                     }
0:                     if(batchList.isEmpty()){
0:                         log.warn("Refilling batch - haven't got past first message = " + firstMessageId);
0:                         fillBatch();
0:                     }
0:                 }
0:             }
0:         }
0:     
0:     protected synchronized int getPendingCount(){
0:         if(pendingCount <= 0){
0:             pendingCount = getStoreSize();
0:         }
0:         return pendingCount;
0:     }
0:     
0:     protected synchronized int getStoreSize(){
0:         try{
0:             return store.getMessageCount(clientId,subscriberName);
0:         }catch(IOException e){
0:             log.error(this+" Failed to get the outstanding message count from the store",e);
0:             throw new RuntimeException(e);
0:         }
0:     }
0:     
0:     
commit:b88db24
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void start() throws Exception{
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void stop() throws Exception{
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void recoverMessage(Message message) throws Exception{
/////////////////////////////////////////////////////////////////////////
0:     protected synchronized void fillBatch() throws Exception{
0:     public synchronized void gc(){
commit:c46003f
/////////////////////////////////////////////////////////////////////////
0:  * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE
0:  * file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file
0:  * to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
0:  * License. You may obtain a copy of the License at
0:  * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
0:  * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
0:  * specific language governing permissions and limitations under the License.
/////////////////////////////////////////////////////////////////////////
0:  * perist pending messages pending message (messages awaiting disptach to a consumer) cursor
0: class TopicStorePrefetch extends AbstractPendingMessageCursor implements MessageRecoveryListener{
0:     private final LinkedList<Message> batchList=new LinkedList<Message>();
0:     private MessageId firstMessageId;
0:     private MessageId lastMessageId;
/////////////////////////////////////////////////////////////////////////
0:         this.regionDestination=topic;
0:     public void start() throws Exception{
/////////////////////////////////////////////////////////////////////////
0:             empty=batchList.isEmpty();
0:         }
/////////////////////////////////////////////////////////////////////////
0: 
0:             log.error(this+" Failed to get the outstanding message count from the store",e);
0: 
0:         if(node!=null){
0:             if(empty){
0:                 firstMessageId=node.getMessageId();
0:                 empty=false;
0:             }
0:             lastMessageId=node.getMessageId();
0:     public synchronized boolean hasNext(){
0:         Message result=null;
0:         if(!empty){
0:                 }catch(final Exception e){
0:                 if(batchList.isEmpty()){
0:                     return null;
0:             if(!batchList.isEmpty()){
0:                 result=batchList.removeFirst();
0:                 if(firstMessageId!=null){
0:                     // Skip messages until we get to the first message.
0:                     if(!result.getMessageId().equals(firstMessageId))
0:                         result=null;
0:                     firstMessageId=null;
0:                 }else{
0:                     if(lastMessageId!=null){
0:                         if(result.getMessageId().equals(lastMessageId)){
0:                             empty=true;
0:                         }
0:                     }
0:                     result.setRegionDestination(regionDestination);
0:                 }
0:             }
0:         return result;
/////////////////////////////////////////////////////////////////////////
0:         // only increment if count is zero (could have been cached)
0:         if(message.getReferenceCount()==0){
0:             message.incrementReferenceCount();
0:         }
0:     public void recoverMessageReference(MessageId messageReference) throws Exception{
/////////////////////////////////////////////////////////////////////////
0: 
0:     public void gc(){
0:         for(Message msg:batchList){
0:             msg.decrementReferenceCount();
0:         }
0: 
0:     public String toString(){
0:         return "TopicStorePrefetch"+System.identityHashCode(this)+"("+clientId+","+subscriberName+")";
commit:3bf0245
/////////////////////////////////////////////////////////////////////////
0:         gc();
/////////////////////////////////////////////////////////////////////////
0:     public void gc() {
0:         batchList.clear();
0:     }
0:     
commit:629bc81
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         store.resetBatching(clientId,subscriberName);
/////////////////////////////////////////////////////////////////////////
0:         store.recoverNextMessages(clientId,subscriberName,
0:           
/////////////////////////////////////////////////////////////////////////
commit:7a6b944
/////////////////////////////////////////////////////////////////////////
0:     
0:     public synchronized void addMessageLast(MessageReference node) throws Exception{
0:         if(node!=null){
0:             node.decrementReferenceCount();
0:         }
0:     }
/////////////////////////////////////////////////////////////////////////
0:         message.incrementReferenceCount();
commit:b6ba20b
/////////////////////////////////////////////////////////////////////////
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
0:  * contributor license agreements. See the NOTICE file distributed with this
0:  * work for additional information regarding copyright ownership. The ASF
0:  * licenses this file to You under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
0:  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
0:  * License for the specific language governing permissions and limitations under
0:  * the License.
0: 
0: import javax.jms.JMSException;
0: import org.apache.activemq.broker.region.Destination;
/////////////////////////////////////////////////////////////////////////
0: 
0:  * perist pending messages pending message (messages awaiting disptach to a
0:  * consumer) cursor
0: class TopicStorePrefetch extends AbstractPendingMessageCursor implements
0:         MessageRecoveryListener {
0: 
0:    
0:     private final LinkedList batchList=new LinkedList();
0:     private Destination regionDestination;
0:     public TopicStorePrefetch(Topic topic,String clientId,String subscriberName){
0:         this.regionDestination = topic;
0:         this.store=(TopicMessageStore)topic.getMessageStore();
0:         store.resetBatching(clientId,clientId,null);
0:         return batchList.isEmpty();
0:     
0:     public synchronized int size(){
0:         try{
0:             return store.getMessageCount(clientId,subscriberName);
0:         }catch(IOException e){
0:             log.error(this + " Failed to get the outstanding message count from the store",e);
0:             throw new RuntimeException(e);
0:         }
0:         if(isEmpty()){
0:             try{
0:                 fillBatch();
0:             }catch(Exception e){
0:                 log.error("Failed to fill batch",e);
0:                 throw new RuntimeException(e);
0:             }
0:         }
0:         Message result = (Message)batchList.removeFirst();
0:         result.setRegionDestination(regionDestination);
0:     public void finished(){
0:     }
0:         message.setRegionDestination(regionDestination);
0:     public void recoverMessageReference(String messageReference)
0:             throws Exception{
0:         store.recoverNextMessages(clientId,subscriberName,lastMessageId,
0:                 maxBatchSize,this);
0:         // this will add more messages to the batch list
0:         if(!batchList.isEmpty()){
0:             Message message=(Message)batchList.getLast();
0:             lastMessageId=message.getMessageId();
0:     }
0:     
0:     public String toString() {
0:         return "TopicStorePrefetch" + System.identityHashCode(this) + "("+clientId+","+subscriberName+")";
0:     }
0:     
0:     synchronized void nextToDispatch(MessageId id) throws Exception {
0:         lastMessageId = store.getPreviousMessageIdToDeliver(clientId,clientId,id);
0:         store.resetBatching(clientId,clientId,id);        
commit:4eef609
/////////////////////////////////////////////////////////////////////////
1: /**
0:  * 
0:  * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE
0:  * file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file
0:  * to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
0:  * License. You may obtain a copy of the License at
0:  * 
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  * 
0:  * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
0:  * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
0:  * specific language governing permissions and limitations under the License.
1:  */
1: package org.apache.activemq.broker.region.cursors;
0: 
0: import java.io.IOException;
0: import java.util.LinkedList;
0: import org.apache.activemq.broker.region.MessageReference;
1: import org.apache.activemq.broker.region.Topic;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageId;
0: import org.apache.activemq.store.MessageRecoveryListener;
1: import org.apache.activemq.store.TopicMessageStore;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: /**
0:  * perist pending messages pending message (messages awaiting disptach to a consumer) cursor
0:  * 
0:  * @version $Revision$
1:  */
0: class TopicStorePrefetch extends AbstractPendingMessageCursor implements MessageRecoveryListener{
0:     static private final Log log=LogFactory.getLog(TopicStorePrefetch.class);
0:     private Topic topic;
0:     private TopicMessageStore store;
0:     private LinkedList batchList;
0:     private String clientId;
0:     private String subscriberName;
0:     private int pendingCount=0;
0:     private MessageId lastMessageId;
0:     private int maxBatchSize=10;
0: 
1:     /**
1:      * @param topic
0:      * @param batchList
1:      * @param clientId
1:      * @param subscriberName
0:      * @throws IOException
1:      */
0:     public TopicStorePrefetch(Topic topic,LinkedList batchList,String clientId,String subscriberName){
0:         this.topic=topic;
0:         this.store=(TopicMessageStore) topic.getMessageStore();
0:         this.batchList=batchList;
0:         this.clientId=clientId;
0:         this.subscriberName=subscriberName;
0:     }
0: 
0:     public void start() throws Exception{
0:         pendingCount=store.getMessageCount(clientId,subscriberName);
0:         System.err.println("Pending count = "+pendingCount);
0:     }
0: 
0:     public void stop() throws Exception{
0:         pendingCount=0;
0:         lastMessageId=null;
0:     }
0: 
1:     /**
0:      * @return true if there are no pending messages
1:      */
0:     public boolean isEmpty(){
0:         return pendingCount==0;
0:     }
0: 
1:     /**
0:      * Informs the Broker if the subscription needs to intervention to recover it's state e.g. DurableTopicSubscriber
0:      * may do
0:      * 
0:      * @see org.apache.activemq.region.cursors.PendingMessageCursor
0:      * @return true if recovery required
1:      */
0:     public boolean isRecoveryRequired(){
0:         return false;
0:     }
0: 
0:     public synchronized void addMessageFirst(MessageReference node){
0:         pendingCount++;
0:     }
0: 
0:     public synchronized void addMessageLast(MessageReference node){
0:         pendingCount++;
0:     }
0: 
0:     public void clear(){
0:         pendingCount=0;
0:         lastMessageId=null;
0:     }
0: 
0:     public synchronized boolean hasNext(){
0:         return !isEmpty();
0:     }
0: 
0:     public synchronized MessageReference next(){
0:         MessageReference result=null;
0:         if(!isEmpty()){
0:             if(batchList.isEmpty()){
0:                 try{
0:                     fillBatch();
0:                 }catch(Exception e){
0:                     log.error(topic.getDestination()+" Couldn't fill batch from store ",e);
0:                     throw new RuntimeException(e);
0:                 }
0:             }
0:             result=(MessageReference) batchList.removeFirst();
0:         }
0:         return result;
0:     }
0: 
0:     public synchronized void remove(){
0:         pendingCount--;
0:     }
0: 
0:     public void reset(){
0:         batchList.clear();
0:     }
0: 
0:     public int size(){
0:         return pendingCount;
0:     }
0: 
0:     // MessageRecoveryListener implementation
0:     public void finished(){}
0: 
0:     public void recoverMessage(Message message) throws Exception{
0:         batchList.addLast(message);
0:     }
0: 
0:     public void recoverMessageReference(String messageReference) throws Exception{
1:         // shouldn't get called
1:         throw new RuntimeException("Not supported");
0:     }
0: 
0:     // implementation
0:     protected void fillBatch() throws Exception{
0:         if(pendingCount<=0){
0:             pendingCount=store.getMessageCount(clientId,subscriberName);
0:         }
0:         if(pendingCount>0){
0:             store.recoverNextMessages(clientId,subscriberName,lastMessageId,maxBatchSize,this);
0:             // this will add more messages to the batch list
0:             if(!batchList.isEmpty()){
0:                 Message message=(Message) batchList.getLast();
0:                 lastMessageId=message.getMessageId();
0:             }
0:         }
0:     }
0: }
============================================================================