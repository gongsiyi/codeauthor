2:1f862ba: /**
1:56a7001:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:56a7001:  * contributor license agreements.  See the NOTICE file distributed with
1:56a7001:  * this work for additional information regarding copyright ownership.
1:56a7001:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:56a7001:  * (the "License"); you may not use this file except in compliance with
1:56a7001:  * the License.  You may obtain a copy of the License at
9:1f862ba:  *
1:56a7001:  *      http://www.apache.org/licenses/LICENSE-2.0
1:1f862ba:  *
1:56a7001:  * Unless required by applicable law or agreed to in writing, software
1:56a7001:  * distributed under the License is distributed on an "AS IS" BASIS,
1:56a7001:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:56a7001:  * See the License for the specific language governing permissions and
1:56a7001:  * limitations under the License.
2:1f862ba:  */
1:56a7001: package org.apache.activemq.security;
1:1f862ba: 
1:02a58c2: import java.util.ArrayList;
1:02a58c2: import java.util.HashSet;
1:02a58c2: import java.util.Hashtable;
1:02a58c2: import java.util.Map;
1:02a58c2: import java.util.Set;
1:02a58c2: import java.util.concurrent.ConcurrentHashMap;
1:02a58c2: import java.util.concurrent.LinkedBlockingQueue;
1:02a58c2: import java.util.concurrent.ThreadFactory;
1:02a58c2: import java.util.concurrent.ThreadPoolExecutor;
1:02a58c2: import java.util.concurrent.TimeUnit;
1:02a58c2: import java.util.concurrent.atomic.AtomicReference;
1:1a2e3eb: import java.util.concurrent.locks.ReentrantReadWriteLock;
1:02a58c2: 
1:02a58c2: import javax.naming.Binding;
1:02a58c2: import javax.naming.Context;
1:02a58c2: import javax.naming.InvalidNameException;
1:02a58c2: import javax.naming.NamingEnumeration;
1:02a58c2: import javax.naming.NamingException;
1:02a58c2: import javax.naming.directory.Attribute;
1:02a58c2: import javax.naming.directory.Attributes;
1:02a58c2: import javax.naming.directory.DirContext;
1:02a58c2: import javax.naming.directory.InitialDirContext;
1:02a58c2: import javax.naming.directory.SearchControls;
1:02a58c2: import javax.naming.directory.SearchResult;
1:02a58c2: import javax.naming.event.EventDirContext;
1:02a58c2: import javax.naming.event.NamespaceChangeListener;
1:02a58c2: import javax.naming.event.NamingEvent;
1:02a58c2: import javax.naming.event.NamingExceptionEvent;
1:02a58c2: import javax.naming.event.ObjectChangeListener;
1:02a58c2: import javax.naming.ldap.LdapName;
1:02a58c2: import javax.naming.ldap.Rdn;
1:02a58c2: 
1:56a7001: import org.apache.activemq.command.ActiveMQDestination;
1:56a7001: import org.apache.activemq.command.ActiveMQQueue;
1:56a7001: import org.apache.activemq.command.ActiveMQTopic;
1:3dbc9c9: import org.apache.activemq.filter.DestinationMapEntry;
1:1f862ba: import org.apache.activemq.jaas.UserPrincipal;
1:56a7001: import org.slf4j.Logger;
1:56a7001: import org.slf4j.LoggerFactory;
1:1f862ba: 
1:02a58c2: public class SimpleCachedLDAPAuthorizationMap implements AuthorizationMap {
1:1f862ba: 
1:7c9fec6:     private static final Logger LOG = LoggerFactory.getLogger(SimpleCachedLDAPAuthorizationMap.class);
1:1f862ba: 
1:1f862ba:     // Configuration Options
1:02a58c2:     private final String initialContextFactory = "com.sun.jndi.ldap.LdapCtxFactory";
1:56a7001:     private String connectionURL = "ldap://localhost:1024";
1:56a7001:     private String connectionUsername = "uid=admin,ou=system";
1:56a7001:     private String connectionPassword = "secret";
1:56a7001:     private String connectionProtocol = "s";
1:56a7001:     private String authentication = "simple";
1:1f862ba: 
1:1f862ba:     private int queuePrefixLength = 4;
1:1f862ba:     private int topicPrefixLength = 4;
1:1f862ba:     private int tempPrefixLength = 4;
1:02a58c2: 
1:1f862ba:     private String queueSearchBase = "ou=Queue,ou=Destination,ou=ActiveMQ,ou=system";
1:1f862ba:     private String topicSearchBase = "ou=Topic,ou=Destination,ou=ActiveMQ,ou=system";
1:1f862ba:     private String tempSearchBase = "ou=Temp,ou=Destination,ou=ActiveMQ,ou=system";
1:02a58c2: 
1:1f862ba:     private String permissionGroupMemberAttribute = "member";
1:02a58c2: 
1:1f862ba:     private String adminPermissionGroupSearchFilter = "(cn=Admin)";
1:1f862ba:     private String readPermissionGroupSearchFilter = "(cn=Read)";
1:1f862ba:     private String writePermissionGroupSearchFilter = "(cn=Write)";
1:02a58c2: 
1:1f862ba:     private boolean legacyGroupMapping = true;
1:1f862ba:     private String groupObjectClass = "groupOfNames";
1:1f862ba:     private String userObjectClass = "person";
1:1f862ba:     private String groupNameAttribute = "cn";
1:1f862ba:     private String userNameAttribute = "uid";
1:1f862ba: 
1:56a7001:     private int refreshInterval = -1;
1:1f862ba:     private boolean refreshDisabled = false;
1:02a58c2: 
1:9d65673:     protected String groupClass = DefaultAuthorizationMap.DEFAULT_GROUP_CLASS;
1:9d65673: 
1:1f862ba:     // Internal State
1:1a2e3eb:     private long lastUpdated = -1;
1:1f862ba: 
1:56a7001:     private static String ANY_DESCENDANT = "\\$";
1:1f862ba: 
1:b067a65:     protected DirContext context;
1:56a7001:     private EventDirContext eventContext;
1:02a58c2: 
1:02a58c2:     private final AtomicReference<DefaultAuthorizationMap> map =
1:02a58c2:         new AtomicReference<DefaultAuthorizationMap>(new DefaultAuthorizationMap());
1:02a58c2:     private final ThreadPoolExecutor updaterService;
1:02a58c2: 
1:02a58c2:     protected Map<ActiveMQDestination, AuthorizationEntry> entries =
1:02a58c2:         new ConcurrentHashMap<ActiveMQDestination, AuthorizationEntry>();
1:02a58c2: 
1:02a58c2:     public SimpleCachedLDAPAuthorizationMap() {
1:a3060d0:         // Allow for only a couple outstanding update request, they can be slow so we
1:02a58c2:         // don't want a bunch to pile up for no reason.
1:a3060d0:         updaterService = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS,
1:02a58c2:             new LinkedBlockingQueue<Runnable>(2),
1:02a58c2:             new ThreadFactory() {
1:02a58c2: 
1:02a58c2:                 @Override
1:02a58c2:                 public Thread newThread(Runnable r) {
1:02a58c2:                     return new Thread(r, "SimpleCachedLDAPAuthorizationMap update thread");
1:02a58c2:                 }
1:02a58c2:             });
1:02a58c2:         updaterService.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardPolicy());
1:02a58c2:     }
1:02a58c2: 
1:06949a5:     protected DirContext createContext() throws NamingException {
1:06949a5:         Hashtable<String, String> env = new Hashtable<String, String>();
1:06949a5:         env.put(Context.INITIAL_CONTEXT_FACTORY, initialContextFactory);
1:0b5231a:         if (connectionUsername != null && !"".equals(connectionUsername)) {
1:06949a5:             env.put(Context.SECURITY_PRINCIPAL, connectionUsername);
1:0b5231a:         } else {
1:0b5231a:             throw new NamingException("Empty username is not allowed");
1:06949a5:         }
1:0b5231a:         if (connectionPassword != null && !"".equals(connectionPassword)) {
1:06949a5:             env.put(Context.SECURITY_CREDENTIALS, connectionPassword);
1:0b5231a:         } else {
1:0b5231a:             throw new NamingException("Empty password is not allowed");
1:06949a5:         }
1:06949a5:         env.put(Context.SECURITY_PROTOCOL, connectionProtocol);
1:06949a5:         env.put(Context.PROVIDER_URL, connectionURL);
1:06949a5:         env.put(Context.SECURITY_AUTHENTICATION, authentication);
1:06949a5:         return new InitialDirContext(env);
1:06949a5:     }
1:02a58c2: 
1:b067a65:     protected boolean isContextAlive() {
1:b067a65:         boolean alive = false;
1:b067a65:         if (context != null) {
1:b067a65:             try {
1:b067a65:                 context.getAttributes("");
1:b067a65:                 alive = true;
1:02a58c2:             } catch (Exception e) {
1:02a58c2:             }
1:b067a65:         }
1:b067a65:         return alive;
1:b067a65:     }
1:b067a65: 
1:1f862ba:     /**
1:02a58c2:      * Returns the existing open context or creates a new one and registers listeners for push notifications if such an
1:02a58c2:      * update style is enabled. This implementation should not be invoked concurrently.
1:1f862ba:      *
1:1f862ba:      * @return the current context
1:1f862ba:      *
1:02a58c2:      * @throws NamingException
1:02a58c2:      *             if there is an error setting things up
1:1f862ba:      */
1:56a7001:     protected DirContext open() throws NamingException {
1:b067a65:         if (isContextAlive()) {
1:b067a65:             return context;
1:02a58c2:         }
1:06949a5: 
1:06949a5:         try {
1:06949a5:             context = createContext();
1:1f862ba:             if (refreshInterval == -1 && !refreshDisabled) {
1:02a58c2:                 eventContext = ((EventDirContext) context.lookup(""));
1:02a58c2: 
1:56a7001:                 final SearchControls constraints = new SearchControls();
1:56a7001:                 constraints.setSearchScope(SearchControls.SUBTREE_SCOPE);
1:1f862ba: 
1:1f862ba:                 // Listeners for Queue policy //
1:02a58c2: 
1:1f862ba:                 // Listeners for each type of permission
1:1f862ba:                 for (PermissionType permissionType : PermissionType.values()) {
1:1f862ba:                     eventContext.addNamingListener(queueSearchBase, getFilterForPermissionType(permissionType), constraints,
1:02a58c2:                         this.new CachedLDAPAuthorizationMapNamespaceChangeListener(DestinationType.QUEUE, permissionType));
1:06949a5:                 }
1:1f862ba:                 // Listener for changes to the destination pattern entry itself and not a permission entry.
1:02a58c2:                 eventContext.addNamingListener(queueSearchBase, "cn=*", new SearchControls(), this.new CachedLDAPAuthorizationMapNamespaceChangeListener(
1:02a58c2:                     DestinationType.QUEUE, null));
1:02a58c2: 
1:1f862ba:                 // Listeners for Topic policy //
1:02a58c2: 
1:1f862ba:                 // Listeners for each type of permission
1:1f862ba:                 for (PermissionType permissionType : PermissionType.values()) {
1:1f862ba:                     eventContext.addNamingListener(topicSearchBase, getFilterForPermissionType(permissionType), constraints,
1:02a58c2:                         this.new CachedLDAPAuthorizationMapNamespaceChangeListener(DestinationType.TOPIC, permissionType));
1:06949a5:                 }
1:1f862ba:                 // Listener for changes to the destination pattern entry itself and not a permission entry.
1:02a58c2:                 eventContext.addNamingListener(topicSearchBase, "cn=*", new SearchControls(), this.new CachedLDAPAuthorizationMapNamespaceChangeListener(
1:02a58c2:                     DestinationType.TOPIC, null));
1:02a58c2: 
1:1f862ba:                 // Listeners for Temp policy //
1:02a58c2: 
1:1f862ba:                 // Listeners for each type of permission
1:1f862ba:                 for (PermissionType permissionType : PermissionType.values()) {
1:1f862ba:                     eventContext.addNamingListener(tempSearchBase, getFilterForPermissionType(permissionType), constraints,
1:02a58c2:                         this.new CachedLDAPAuthorizationMapNamespaceChangeListener(DestinationType.TEMP, permissionType));
1:1f862ba:                 }
1:06949a5: 
1:1f862ba:             }
2:56a7001:         } catch (NamingException e) {
1:1f862ba:             context = null;
1:56a7001:             throw e;
1:1f862ba:         }
1:1f862ba: 
1:06949a5:         return context;
1:1f862ba:     }
24:1f862ba: 
1:1f862ba:     /**
1:02a58c2:      * Queries the directory and initializes the policy based on the data in the directory. This implementation should
1:02a58c2:      * not be invoked concurrently.
1:02a58c2:      *
1:02a58c2:      * @throws Exception
1:02a58c2:      *             if there is an unrecoverable error processing the directory contents
1:1f862ba:      */
1:3dbc9c9:     @SuppressWarnings("rawtypes")
1:1a2e3eb:     protected synchronized void query() throws Exception {
1:1f862ba:         DirContext currentContext = open();
1:1a2e3eb:         entries.clear();
1:02a58c2: 
1:56a7001:         final SearchControls constraints = new SearchControls();
1:56a7001:         constraints.setSearchScope(SearchControls.SUBTREE_SCOPE);
1:02a58c2: 
1:02a58c2:         DefaultAuthorizationMap newMap = new DefaultAuthorizationMap();
1:1f862ba:         for (PermissionType permissionType : PermissionType.values()) {
1:06949a5:             try {
1:02a58c2:                 processQueryResults(newMap,
1:02a58c2:                     currentContext.search(queueSearchBase, getFilterForPermissionType(permissionType),
1:02a58c2:                     constraints), DestinationType.QUEUE, permissionType);
1:06949a5:             } catch (Exception e) {
1:e1bbde7:                 LOG.error("Policy not applied!.  Error processing policy under '{}' with filter '{}'", new Object[]{ queueSearchBase, getFilterForPermissionType(permissionType) }, e);
1:1f862ba:             }
1:1f862ba:         }
1:02a58c2: 
1:1f862ba:         for (PermissionType permissionType : PermissionType.values()) {
1:1f862ba:             try {
1:02a58c2:                 processQueryResults(newMap,
1:02a58c2:                     currentContext.search(topicSearchBase, getFilterForPermissionType(permissionType),
1:02a58c2:                     constraints), DestinationType.TOPIC, permissionType);
2:1f862ba:             } catch (Exception e) {
1:e1bbde7:                 LOG.error("Policy not applied!.  Error processing policy under '{}' with filter '{}'", new Object[]{ topicSearchBase, getFilterForPermissionType(permissionType) }, e);
1:1f862ba:             }
1:1f862ba:         }
1:02a58c2: 
1:1f862ba:         for (PermissionType permissionType : PermissionType.values()) {
1:1f862ba:             try {
1:02a58c2:                 processQueryResults(newMap,
1:02a58c2:                     currentContext.search(tempSearchBase, getFilterForPermissionType(permissionType),
1:02a58c2:                     constraints), DestinationType.TEMP, permissionType);
1:1f862ba:             } catch (Exception e) {
1:e1bbde7:                 LOG.error("Policy not applied!.  Error processing policy under '{}' with filter '{}'", new Object[]{ tempSearchBase, getFilterForPermissionType(permissionType) }, e);
1:1f862ba:             }
21:56a7001:         }
1:02a58c2: 
1:02a58c2:         // Create and swap in the new instance with updated LDAP data.
1:02a58c2:         newMap.setAuthorizationEntries(new ArrayList<DestinationMapEntry>(entries.values()));
1:9d65673:         newMap.setGroupClass(groupClass);
1:02a58c2:         this.map.set(newMap);
1:02a58c2: 
1:56a7001:         updated();
1:56a7001:     }
1:02a58c2: 
1:1f862ba:     /**
1:02a58c2:      * Processes results from a directory query in the context of a given destination type and permission type. This
1:02a58c2:      * implementation should not be invoked concurrently.
1:1f862ba:      *
1:02a58c2:      * @param results
1:02a58c2:      *            the results to process
1:02a58c2:      * @param destinationType
1:02a58c2:      *            the type of the destination for which the directory results apply
1:02a58c2:      * @param permissionType
1:02a58c2:      *            the type of the permission for which the directory results apply
1:1f862ba:      *
1:02a58c2:      * @throws Exception
1:02a58c2:      *             if there is an error processing the results
1:1f862ba:      */
1:02a58c2:     protected void processQueryResults(DefaultAuthorizationMap map, NamingEnumeration<SearchResult> results, DestinationType destinationType, PermissionType permissionType)
1:02a58c2:         throws Exception {
1:02a58c2: 
1:1f862ba:         while (results.hasMore()) {
1:1f862ba:             SearchResult result = results.next();
1:1f862ba:             AuthorizationEntry entry = null;
1:02a58c2: 
1:1f862ba:             try {
1:02a58c2:                 entry = getEntry(map, new LdapName(result.getNameInNamespace()), destinationType);
1:1f862ba:             } catch (Exception e) {
1:e1bbde7:                 LOG.error("Policy not applied!  Error parsing authorization policy entry under {}", result.getNameInNamespace(), e);
1:1f862ba:                 continue;
1:1f862ba:             }
1:02a58c2: 
1:1f862ba:             applyACL(entry, result, permissionType);
1:1f862ba:         }
1:1f862ba:     }
1:1f862ba: 
1:1f862ba:     /**
1:02a58c2:      * Marks the time at which the authorization state was last refreshed. Relevant for synchronous
1:02a58c2:      * policy updates. This implementation should not be invoked concurrently.
1:1f862ba:      */
1:56a7001:     protected void updated() {
1:56a7001:         lastUpdated = System.currentTimeMillis();
1:56a7001:     }
1:1f862ba: 
1:1f862ba:     /**
1:02a58c2:      * Retrieves or creates the {@link AuthorizationEntry} that corresponds to the DN in {@code dn}. This implementation
1:02a58c2:      * should not be invoked concurrently.
1:02a58c2:      *
1:02a58c2:      * @param map
1:02a58c2:      *            the DefaultAuthorizationMap to operate on.
1:1f862ba:      * @param dn
1:1f862ba:      *            the DN representing the policy entry in the directory
1:02a58c2:      * @param destinationType
1:02a58c2:      *            the type of the destination to get/create the entry for
1:02a58c2:      *
1:1f862ba:      * @return the corresponding authorization entry for the DN
1:02a58c2:      *
1:1f862ba:      * @throws IllegalArgumentException
1:1f862ba:      *             if destination type is not one of {@link DestinationType#QUEUE}, {@link DestinationType#TOPIC},
1:1f862ba:      *             {@link DestinationType#TEMP} or if the policy entry DN is malformed
1:1f862ba:      */
1:02a58c2:     protected AuthorizationEntry getEntry(DefaultAuthorizationMap map, LdapName dn, DestinationType destinationType) {
1:1f862ba:         AuthorizationEntry entry = null;
1:1f862ba:         switch (destinationType) {
1:1f862ba:             case TEMP:
1:1f862ba:                 // handle temp entry
1:1f862ba:                 if (dn.size() != getPrefixLengthForDestinationType(destinationType) + 1) {
1:1f862ba:                     // handle unknown entry
1:1f862ba:                     throw new IllegalArgumentException("Malformed policy structure for a temporary destination "
1:02a58c2:                         + "policy entry.  The permission group entries should be immediately below the " + "temporary policy base DN.");
1:56a7001:                 }
1:02a58c2:                 entry = map.getTempDestinationAuthorizationEntry();
1:56a7001:                 if (entry == null) {
1:1f862ba:                     entry = new TempDestinationAuthorizationEntry();
1:02a58c2:                     map.setTempDestinationAuthorizationEntry((TempDestinationAuthorizationEntry) entry);
1:56a7001:                 }
1:02a58c2: 
1:1f862ba:                 break;
1:02a58c2: 
1:1f862ba:             case QUEUE:
1:1f862ba:             case TOPIC:
1:1f862ba:                 // handle regular destinations
1:1f862ba:                 if (dn.size() != getPrefixLengthForDestinationType(destinationType) + 2) {
1:1f862ba:                     throw new IllegalArgumentException("Malformed policy structure for a queue or topic destination "
1:02a58c2:                         + "policy entry.  The destination pattern and permission group entries should be " + "nested below the queue or topic policy base DN.");
1:1f862ba:                 }
1:02a58c2: 
1:1f862ba:                 ActiveMQDestination dest = formatDestination(dn, destinationType);
1:1f862ba: 
1:1f862ba:                 if (dest != null) {
1:1f862ba:                     entry = entries.get(dest);
1:1f862ba:                     if (entry == null) {
1:1f862ba:                         entry = new AuthorizationEntry();
1:1f862ba:                         entry.setDestination(dest);
1:1f862ba:                         entries.put(dest, entry);
1:1f862ba:                     }
1:1f862ba:                 }
1:02a58c2: 
1:1f862ba:                 break;
1:1f862ba:             default:
1:1f862ba:                 // handle unknown entry
1:1f862ba:                 throw new IllegalArgumentException("Unknown destination type " + destinationType);
1:1f862ba:         }
1:02a58c2: 
1:1f862ba:         return entry;
1:56a7001:     }
1:1f862ba: 
1:1f862ba:     /**
1:02a58c2:      * Applies the policy from the directory to the given entry within the context of the provided permission type.
1:1f862ba:      *
1:02a58c2:      * @param entry
1:02a58c2:      *            the policy entry to apply the policy to
1:02a58c2:      * @param result
1:02a58c2:      *            the results from the directory to apply to the policy entry
1:02a58c2:      * @param permissionType
1:02a58c2:      *            the permission type of the data in the directory
1:1f862ba:      *
1:02a58c2:      * @throws NamingException
1:02a58c2:      *             if there is an error applying the ACL
1:1f862ba:      */
1:02a58c2:     protected void applyACL(AuthorizationEntry entry, SearchResult result, PermissionType permissionType) throws NamingException {
1:02a58c2: 
1:1f862ba:         // Find members
1:1f862ba:         Attribute memberAttribute = result.getAttributes().get(permissionGroupMemberAttribute);
1:1f862ba:         NamingEnumeration<?> memberAttributeEnum = memberAttribute.getAll();
1:02a58c2: 
1:3dbc9c9:         HashSet<Object> members = new HashSet<Object>();
1:02a58c2: 
1:1f862ba:         while (memberAttributeEnum.hasMoreElements()) {
1:1f862ba:             String memberDn = (String) memberAttributeEnum.nextElement();
1:1f862ba:             boolean group = false;
1:1f862ba:             boolean user = false;
1:1f862ba:             String principalName = null;
1:02a58c2: 
1:1f862ba:             if (!legacyGroupMapping) {
1:1f862ba:                 // Lookup of member to determine principal type (group or user) and name.
1:1f862ba:                 Attributes memberAttributes;
1:1f862ba:                 try {
1:02a58c2:                     memberAttributes = context.getAttributes(memberDn, new String[] { "objectClass", groupNameAttribute, userNameAttribute });
1:1f862ba:                 } catch (NamingException e) {
1:e1bbde7:                     LOG.error("Policy not applied! Unknown member {} in policy entry {}", new Object[]{ memberDn, result.getNameInNamespace() }, e);
1:1f862ba:                     continue;
1:1f862ba:                 }
1:02a58c2: 
1:1f862ba:                 Attribute memberEntryObjectClassAttribute = memberAttributes.get("objectClass");
1:1f862ba:                 NamingEnumeration<?> memberEntryObjectClassAttributeEnum = memberEntryObjectClassAttribute.getAll();
1:02a58c2: 
1:1f862ba:                 while (memberEntryObjectClassAttributeEnum.hasMoreElements()) {
1:1f862ba:                     String objectClass = (String) memberEntryObjectClassAttributeEnum.nextElement();
1:02a58c2: 
1:1f862ba:                     if (objectClass.equalsIgnoreCase(groupObjectClass)) {
1:1f862ba:                         group = true;
1:1f862ba:                         Attribute name = memberAttributes.get(groupNameAttribute);
1:1f862ba:                         if (name == null) {
1:e1bbde7:                             LOG.error("Policy not applied! Group {} does not have name attribute {} under entry {}", new Object[]{ memberDn, groupNameAttribute, result.getNameInNamespace() });
1:1f862ba:                             break;
1:1f862ba:                         }
1:02a58c2: 
1:1f862ba:                         principalName = (String) name.get();
1:1f862ba:                     }
1:02a58c2: 
1:1f862ba:                     if (objectClass.equalsIgnoreCase(userObjectClass)) {
1:1f862ba:                         user = true;
1:1f862ba:                         Attribute name = memberAttributes.get(userNameAttribute);
1:1f862ba:                         if (name == null) {
1:e1bbde7:                             LOG.error("Policy not applied! User {} does not have name attribute {} under entry {}", new Object[]{ memberDn, userNameAttribute, result.getNameInNamespace() });
1:1f862ba:                             break;
1:1f862ba:                         }
1:02a58c2: 
1:1f862ba:                         principalName = (String) name.get();
1:1f862ba:                     }
1:1f862ba:                 }
1:02a58c2: 
1:1f862ba:             } else {
1:1f862ba:                 group = true;
1:1f862ba:                 principalName = memberDn.replaceAll("(cn|CN)=", "");
1:1f862ba:             }
1:02a58c2: 
1:1f862ba:             if ((!group && !user) || (group && user)) {
1:e1bbde7:                 LOG.error("Policy not applied! Can't determine type of member {} under entry {}", memberDn, result.getNameInNamespace());
1:02a58c2:             } else if (principalName != null) {
1:02a58c2:                 DefaultAuthorizationMap map = this.map.get();
1:1f862ba:                 if (group && !user) {
1:9027d49:                     try {
1:02a58c2:                         members.add(DefaultAuthorizationMap.createGroupPrincipal(principalName, map.getGroupClass()));
1:9027d49:                     } catch (Exception e) {
1:02a58c2:                         NamingException ne = new NamingException(
1:02a58c2:                             "Can't create a group " + principalName + " of class " + map.getGroupClass());
1:9027d49:                         ne.initCause(e);
1:9027d49:                         throw ne;
1:9027d49:                     }
1:1f862ba:                 } else if (!group && user) {
1:1f862ba:                     members.add(new UserPrincipal(principalName));
1:1f862ba:                 }
1:1f862ba:             }
1:1f862ba:         }
1:1f862ba: 
1:1f862ba:         try {
1:1f862ba:             applyAcl(entry, permissionType, members);
1:1f862ba:         } catch (Exception e) {
1:e1bbde7:             LOG.error("Policy not applied! Error adding principals to ACL under {}", result.getNameInNamespace(), e);
1:1f862ba:         }
1:1f862ba:     }
1:02a58c2: 
1:1f862ba:     /**
1:1f862ba:      * Applies policy to the entry given the actual principals that will be applied to the policy entry.
1:1f862ba:      *
1:02a58c2:      * @param entry
1:02a58c2:      *            the policy entry to which the policy should be applied
1:02a58c2:      * @param permissionType
1:02a58c2:      *            the type of the permission that the policy will be applied to
1:02a58c2:      * @param acls
1:02a58c2:      *            the principals that represent the actual policy
1:1f862ba:      *
1:1f862ba:      * @throw IllegalArgumentException if {@code permissionType} is unsupported
1:1f862ba:      */
1:1f862ba:     protected void applyAcl(AuthorizationEntry entry, PermissionType permissionType, Set<Object> acls) {
1:02a58c2: 
1:1f862ba:         switch (permissionType) {
1:1f862ba:             case READ:
1:1f862ba:                 entry.setReadACLs(acls);
1:1f862ba:                 break;
1:1f862ba:             case WRITE:
1:1f862ba:                 entry.setWriteACLs(acls);
1:1f862ba:                 break;
1:1f862ba:             case ADMIN:
1:1f862ba:                 entry.setAdminACLs(acls);
1:1f862ba:                 break;
1:1f862ba:             default:
1:1f862ba:                 throw new IllegalArgumentException("Unknown permission " + permissionType + ".");
1:1f862ba:         }
1:1f862ba:     }
1:02a58c2: 
1:1f862ba:     /**
1:02a58c2:      * Parses a DN into the equivalent {@link ActiveMQDestination}. The default implementation expects a format of
1:02a58c2:      * cn=<PERMISSION_NAME>,ou=<DESTINATION_PATTERN>,.... or ou=<DESTINATION_PATTERN>,.... for permission and
1:02a58c2:      * destination entries, respectively. For example {@code cn=admin,ou=$,ou=...} or {@code ou=$,ou=...}.
1:1f862ba:      *
1:02a58c2:      * @param dn
1:02a58c2:      *            the DN to parse
1:02a58c2:      * @param destinationType
1:02a58c2:      *            the type of the destination that we are parsing
1:1f862ba:      *
1:1f862ba:      * @return the destination that the DN represents
1:1f862ba:      *
1:02a58c2:      * @throws IllegalArgumentException
1:02a58c2:      *             if {@code destinationType} is {@link DestinationType#TEMP} or if the format of {@code dn} is
1:02a58c2:      *             incorrect for for a topic or queue
1:1f862ba:      *
1:1f862ba:      * @see #formatDestination(Rdn, DestinationType)
1:1f862ba:      */
1:1f862ba:     protected ActiveMQDestination formatDestination(LdapName dn, DestinationType destinationType) {
1:1f862ba:         ActiveMQDestination destination = null;
1:02a58c2: 
1:1f862ba:         switch (destinationType) {
1:1f862ba:             case QUEUE:
1:1f862ba:             case TOPIC:
1:1f862ba:                 // There exists a need to deal with both names representing a permission or simply a
1:02a58c2:                 // destination. As such, we need to determine the proper RDN to work with based
1:1f862ba:                 // on the destination type and the DN size.
1:1f862ba:                 if (dn.size() == (getPrefixLengthForDestinationType(destinationType) + 2)) {
1:1f862ba:                     destination = formatDestination(dn.getRdn(dn.size() - 2), destinationType);
1:02a58c2:                 } else if (dn.size() == (getPrefixLengthForDestinationType(destinationType) + 1)) {
1:1f862ba:                     destination = formatDestination(dn.getRdn(dn.size() - 1), destinationType);
1:1f862ba:                 } else {
1:02a58c2:                     throw new IllegalArgumentException("Malformed DN for representing a permission or destination entry.");
1:1f862ba:                 }
1:1f862ba:                 break;
1:1f862ba:             default:
1:02a58c2:                 throw new IllegalArgumentException("Cannot format destination for destination type " + destinationType);
1:1f862ba:         }
1:02a58c2: 
1:1f862ba:         return destination;
1:1f862ba:     }
1:02a58c2: 
1:1f862ba:     /**
1:02a58c2:      * Parses RDN values representing the destination name/pattern and destination type into the equivalent
1:02a58c2:      * {@link ActiveMQDestination}.
1:02a58c2:      *
1:1f862ba:      * @param destinationName
1:1f862ba:      *            the RDN representing the name or pattern for the destination
1:1f862ba:      * @param destinationType
1:1f862ba:      *            the type of the destination
1:02a58c2:      *
1:1f862ba:      * @return the destination that the RDN represent
1:02a58c2:      *
1:1f862ba:      * @throws IllegalArgumentException
1:1f862ba:      *             if {@code destinationType} is not one of {@link DestinationType#TOPIC} or
1:1f862ba:      *             {@link DestinationType#QUEUE}.
1:02a58c2:      *
1:1f862ba:      * @see #formatDestinationName(Rdn)
1:1f862ba:      * @see #formatDestination(LdapName, DestinationType)
1:1f862ba:      */
1:1f862ba:     protected ActiveMQDestination formatDestination(Rdn destinationName, DestinationType destinationType) {
1:1f862ba:         ActiveMQDestination dest = null;
1:02a58c2: 
1:1f862ba:         switch (destinationType) {
1:1f862ba:             case QUEUE:
1:1f862ba:                 dest = new ActiveMQQueue(formatDestinationName(destinationName));
1:1f862ba:                 break;
1:1f862ba:             case TOPIC:
1:1f862ba:                 dest = new ActiveMQTopic(formatDestinationName(destinationName));
1:1f862ba:                 break;
1:1f862ba:             default:
1:02a58c2:                 throw new IllegalArgumentException("Unknown destination type: " + destinationType);
1:56a7001:         }
1:1f862ba: 
1:1f862ba:         return dest;
1:1f862ba:     }
1:1f862ba: 
1:1f862ba:     /**
1:02a58c2:      * Parses the RDN representing a destination name/pattern into the standard string representation of the
1:02a58c2:      * name/pattern. This implementation does not care about the type of the RDN such that the RDN could be a CN or OU.
1:1f862ba:      *
1:02a58c2:      * @param destinationName
1:02a58c2:      *            the RDN representing the name or pattern for the destination
1:1f862ba:      *
1:1f862ba:      * @see #formatDestination(Rdn, Rdn)
1:1f862ba:      */
1:1f862ba:     protected String formatDestinationName(Rdn destinationName) {
1:1f862ba:         return destinationName.getValue().toString().replaceAll(ANY_DESCENDANT, ">");
1:1f862ba:     }
1:02a58c2: 
1:1f862ba:     /**
1:02a58c2:      * Transcribes an existing set into a new set. Used to make defensive copies for concurrent access.
1:02a58c2:      *
1:1f862ba:      * @param source
1:1f862ba:      *            the source set or {@code null}
1:02a58c2:      *
1:02a58c2:      * @return a new set containing the same elements as {@code source} or {@code null} if {@code source} is
1:02a58c2:      *         {@code null}
1:1f862ba:      */
1:1f862ba:     protected <T> Set<T> transcribeSet(Set<T> source) {
1:1f862ba:         if (source != null) {
1:1f862ba:             return new HashSet<T>(source);
5:56a7001:         } else {
1:1f862ba:             return null;
1:56a7001:         }
1:56a7001:     }
1:02a58c2: 
1:1f862ba:     /**
1:1f862ba:      * Returns the filter string for the given permission type.
1:02a58c2:      *
1:02a58c2:      * @throws IllegalArgumentException
1:02a58c2:      *             if {@code permissionType} is not supported
1:1f862ba:      *
1:1f862ba:      * @see #setAdminPermissionGroupSearchFilter(String)
1:1f862ba:      * @see #setReadPermissionGroupSearchFilter(String)
1:1f862ba:      * @see #setWritePermissionGroupSearchFilter(String)
1:1f862ba:      */
1:1f862ba:     protected String getFilterForPermissionType(PermissionType permissionType) {
1:1f862ba:         String filter = null;
1:02a58c2: 
1:1f862ba:         switch (permissionType) {
1:1f862ba:             case ADMIN:
1:1f862ba:                 filter = adminPermissionGroupSearchFilter;
1:1f862ba:                 break;
1:1f862ba:             case READ:
1:1f862ba:                 filter = readPermissionGroupSearchFilter;
1:1f862ba:                 break;
1:1f862ba:             case WRITE:
1:1f862ba:                 filter = writePermissionGroupSearchFilter;
1:1f862ba:                 break;
1:1f862ba:             default:
1:1f862ba:                 throw new IllegalArgumentException("Unknown permission type " + permissionType);
1:56a7001:         }
1:02a58c2: 
1:1f862ba:         return filter;
1:56a7001:     }
1:02a58c2: 
1:1f862ba:     /**
1:1f862ba:      * Returns the DN prefix size based on the given destination type.
1:1f862ba:      *
1:02a58c2:      * @throws IllegalArgumentException
1:02a58c2:      *             if {@code destinationType} is not supported
1:1f862ba:      *
1:1f862ba:      * @see #setQueueSearchBase(String)
1:1f862ba:      * @see #setTopicSearchBase(String)
1:1f862ba:      * @see #setTempSearchBase(String)
1:1f862ba:      */
1:1f862ba:     protected int getPrefixLengthForDestinationType(DestinationType destinationType) {
1:1f862ba:         int filter = 0;
1:02a58c2: 
1:1f862ba:         switch (destinationType) {
1:1f862ba:             case QUEUE:
1:1f862ba:                 filter = queuePrefixLength;
1:1f862ba:                 break;
1:1f862ba:             case TOPIC:
1:1f862ba:                 filter = topicPrefixLength;
1:1f862ba:                 break;
1:1f862ba:             case TEMP:
1:1f862ba:                 filter = tempPrefixLength;
1:1f862ba:                 break;
1:1f862ba:             default:
1:1f862ba:                 throw new IllegalArgumentException("Unknown permission type " + destinationType);
1:1f862ba:         }
1:02a58c2: 
1:1f862ba:         return filter;
1:1f862ba:     }
1:02a58c2: 
1:1f862ba:     /**
1:02a58c2:      * Performs a check for updates from the server in the event that synchronous updates are enabled and are the
1:02a58c2:      * refresh interval has elapsed.
1:1f862ba:      */
1:1f862ba:     protected void checkForUpdates() {
1:1a2e3eb:         if (lastUpdated == -1) {
1:1a2e3eb:             //ACL's have never been queried, but we need them NOW as we're being asked for them. 
1:1a2e3eb:             try {
1:1a2e3eb:                 query();
1:1a2e3eb:                 return;
1:1a2e3eb:             } catch (Exception e) {
1:1a2e3eb:                 LOG.error("Error updating authorization map.  Partial policy may be applied until the next successful update.", e);
1:1a2e3eb:             }
1:1a2e3eb:         }
1:02a58c2: 
1:02a58c2:         if (context != null && refreshDisabled) {
1:02a58c2:             return;
1:02a58c2:         }
1:1a2e3eb:         
1:02a58c2:         if (context == null || (!refreshDisabled && (refreshInterval != -1 && System.currentTimeMillis() >= lastUpdated + refreshInterval))) {
1:02a58c2:             this.updaterService.execute(new Runnable() {
1:02a58c2:                 @Override
1:02a58c2:                 public void run() {
1:02a58c2: 
1:02a58c2:                     // Check again in case of stacked update request.
1:02a58c2:                     if (context == null || (!refreshDisabled &&
1:02a58c2:                         (refreshInterval != -1 && System.currentTimeMillis() >= lastUpdated + refreshInterval))) {
1:02a58c2: 
1:02a58c2:                         if (!isContextAlive()) {
1:02a58c2:                             try {
1:02a58c2:                                 context = createContext();
1:02a58c2:                             } catch (NamingException ne) {
1:02a58c2:                                 // LDAP is down, use already cached values
1:02a58c2:                                 return;
1:02a58c2:                             }
1:02a58c2:                         }
1:02a58c2: 
1:02a58c2:                         LOG.debug("Updating authorization map!");
1:02a58c2:                         try {
1:02a58c2:                             query();
1:02a58c2:                         } catch (Exception e) {
1:e1bbde7:                             LOG.error("Error updating authorization map.  Partial policy may be applied until the next successful update.", e);
1:02a58c2:                         }
1:02a58c2:                     }
1:02a58c2:                 }
1:02a58c2:             });
1:06949a5:         }
1:06949a5:     }
1:02a58c2: 
1:1f862ba:     // Authorization Map
1:02a58c2: 
1:1f862ba:     /**
1:02a58c2:      * Provides synchronized and defensive access to the admin ACLs for temp destinations as the super implementation
1:02a58c2:      * returns live copies of the ACLs and {@link AuthorizationEntry} is not setup for concurrent access.
1:1f862ba:      */
1:1f862ba:     @Override
1:02a58c2:     public Set<Object> getTempDestinationAdminACLs() {
1:06949a5:         checkForUpdates();
1:02a58c2:         DefaultAuthorizationMap map = this.map.get();
1:02a58c2:         return transcribeSet(map.getTempDestinationAdminACLs());
1:1f862ba:     }
1:02a58c2: 
1:1f862ba:     /**
1:02a58c2:      * Provides synchronized and defensive access to the read ACLs for temp destinations as the super implementation
1:02a58c2:      * returns live copies of the ACLs and {@link AuthorizationEntry} is not setup for concurrent access.
1:1f862ba:      */
1:1f862ba:     @Override
1:02a58c2:     public Set<Object> getTempDestinationReadACLs() {
1:06949a5:         checkForUpdates();
1:02a58c2:         DefaultAuthorizationMap map = this.map.get();
1:02a58c2:         return transcribeSet(map.getTempDestinationReadACLs());
1:1f862ba:     }
1:1f862ba: 
1:1f862ba:     /**
1:02a58c2:      * Provides synchronized and defensive access to the write ACLs for temp destinations as the super implementation
1:02a58c2:      * returns live copies of the ACLs and {@link AuthorizationEntry} is not setup for concurrent access.
1:1f862ba:      */
1:02a58c2:     @Override
1:02a58c2:     public Set<Object> getTempDestinationWriteACLs() {
2:1f862ba:         checkForUpdates();
1:02a58c2:         DefaultAuthorizationMap map = this.map.get();
1:02a58c2:         return transcribeSet(map.getTempDestinationWriteACLs());
1:1f862ba:     }
1:1f862ba: 
1:1f862ba:     /**
1:02a58c2:      * Provides synchronized access to the admin ACLs for the destinations as {@link AuthorizationEntry}
1:02a58c2:      * is not setup for concurrent access.
1:1f862ba:      */
1:02a58c2:     @Override
1:02a58c2:     public Set<Object> getAdminACLs(ActiveMQDestination destination) {
1:1f862ba:         checkForUpdates();
1:02a58c2:         DefaultAuthorizationMap map = this.map.get();
1:02a58c2:         return map.getAdminACLs(destination);
1:1f862ba:     }
1:1f862ba: 
1:1f862ba:     /**
1:02a58c2:      * Provides synchronized access to the read ACLs for the destinations as {@link AuthorizationEntry} is not setup for
1:02a58c2:      * concurrent access.
1:1f862ba:      */
1:02a58c2:     @Override
1:02a58c2:     public Set<Object> getReadACLs(ActiveMQDestination destination) {
1:1f862ba:         checkForUpdates();
1:02a58c2:         DefaultAuthorizationMap map = this.map.get();
1:02a58c2:         return map.getReadACLs(destination);
1:02a58c2:     }
1:02a58c2: 
1:02a58c2:     /**
1:02a58c2:      * Provides synchronized access to the write ACLs for the destinations as {@link AuthorizationEntry} is not setup
1:02a58c2:      * for concurrent access.
1:02a58c2:      */
1:02a58c2:     @Override
1:02a58c2:     public Set<Object> getWriteACLs(ActiveMQDestination destination) {
1:02a58c2:         checkForUpdates();
1:02a58c2:         DefaultAuthorizationMap map = this.map.get();
1:02a58c2:         return map.getWriteACLs(destination);
1:1f862ba:     }
1:1f862ba: 
1:1f862ba:     /**
1:1f862ba:      * Handler for new policy entries in the directory.
1:1f862ba:      *
1:02a58c2:      * @param namingEvent
1:02a58c2:      *            the new entry event that occurred
1:02a58c2:      * @param destinationType
1:02a58c2:      *            the type of the destination to which the event applies
1:02a58c2:      * @param permissionType
1:02a58c2:      *            the permission type to which the event applies
1:1f862ba:      */
1:02a58c2:     public void objectAdded(NamingEvent namingEvent, DestinationType destinationType, PermissionType permissionType) {
1:e1bbde7:         LOG.debug("Adding object: {}", namingEvent.getNewBinding());
1:1f862ba:         SearchResult result = (SearchResult) namingEvent.getNewBinding();
1:02a58c2: 
1:1f862ba:         try {
1:02a58c2:             DefaultAuthorizationMap map = this.map.get();
2:1f862ba:             LdapName name = new LdapName(result.getName());
1:02a58c2:             AuthorizationEntry entry = getEntry(map, name, destinationType);
1:02a58c2: 
1:1f862ba:             applyACL(entry, result, permissionType);
1:1f862ba:             if (!(entry instanceof TempDestinationAuthorizationEntry)) {
1:02a58c2:                 map.put(entry.getDestination(), entry);
1:1f862ba:             }
1:1f862ba:         } catch (InvalidNameException e) {
1:e1bbde7:             LOG.error("Policy not applied!  Error parsing DN for addition of {}", result.getName(), e);
1:1f862ba:         } catch (Exception e) {
1:e1bbde7:             LOG.error("Policy not applied!  Error processing object addition for addition of {}", result.getName(), e);
1:1f862ba:         }
1:56a7001:     }
1:1f862ba: 
1:1f862ba:     /**
1:1f862ba:      * Handler for removed policy entries in the directory.
1:1f862ba:      *
1:02a58c2:      * @param namingEvent
1:02a58c2:      *            the removed entry event that occurred
1:02a58c2:      * @param destinationType
1:02a58c2:      *            the type of the destination to which the event applies
1:02a58c2:      * @param permissionType
1:02a58c2:      *            the permission type to which the event applies
1:1f862ba:      */
1:02a58c2:     public void objectRemoved(NamingEvent namingEvent, DestinationType destinationType, PermissionType permissionType) {
1:e1bbde7:         LOG.debug("Removing object: {}", namingEvent.getOldBinding());
1:56a7001:         Binding result = namingEvent.getOldBinding();
1:1f862ba: 
1:02a58c2:         try {
1:02a58c2:             DefaultAuthorizationMap map = this.map.get();
1:02a58c2:             LdapName name = new LdapName(result.getName());
1:02a58c2:             AuthorizationEntry entry = getEntry(map, name, destinationType);
1:1f862ba:             applyAcl(entry, permissionType, new HashSet<Object>());
1:1f862ba:         } catch (InvalidNameException e) {
1:e1bbde7:             LOG.error("Policy not applied!  Error parsing DN for object removal for removal of {}", result.getName(), e);
1:1f862ba:         } catch (Exception e) {
1:e1bbde7:             LOG.error("Policy not applied!  Error processing object removal for removal of {}", result.getName(), e);
1:56a7001:         }
1:56a7001:     }
1:1f862ba: 
1:1f862ba:     /**
1:02a58c2:      * Handler for renamed policy entries in the directory. This handler deals with the renaming of destination entries
1:02a58c2:      * as well as permission entries. If the permission type is not null, it is assumed that we are dealing with the
1:02a58c2:      * renaming of a permission entry. Otherwise, it is assumed that we are dealing with the renaming of a destination
1:02a58c2:      * entry.
1:1f862ba:      *
1:02a58c2:      * @param namingEvent
1:02a58c2:      *            the renaming entry event that occurred
1:02a58c2:      * @param destinationType
1:02a58c2:      *            the type of the destination to which the event applies
1:02a58c2:      * @param permissionType
1:02a58c2:      *            the permission type to which the event applies
1:1f862ba:      */
1:02a58c2:     public void objectRenamed(NamingEvent namingEvent, DestinationType destinationType, PermissionType permissionType) {
1:56a7001:         Binding oldBinding = namingEvent.getOldBinding();
1:56a7001:         Binding newBinding = namingEvent.getNewBinding();
1:e1bbde7:         LOG.debug("Renaming object: {} to {}", oldBinding, newBinding);
1:1f862ba: 
1:1f862ba:         try {
1:1f862ba:             LdapName oldName = new LdapName(oldBinding.getName());
1:1f862ba:             ActiveMQDestination oldDest = formatDestination(oldName, destinationType);
1:02a58c2: 
1:1f862ba:             LdapName newName = new LdapName(newBinding.getName());
1:1f862ba:             ActiveMQDestination newDest = formatDestination(newName, destinationType);
1:02a58c2: 
1:1f862ba:             if (permissionType != null) {
1:1f862ba:                 // Handle the case where a permission entry is being renamed.
1:1f862ba:                 objectRemoved(namingEvent, destinationType, permissionType);
1:02a58c2: 
1:1f862ba:                 SearchControls controls = new SearchControls();
1:1f862ba:                 controls.setSearchScope(SearchControls.OBJECT_SCOPE);
1:02a58c2: 
1:1f862ba:                 boolean matchedToType = false;
1:02a58c2: 
1:1f862ba:                 for (PermissionType newPermissionType : PermissionType.values()) {
1:02a58c2:                     NamingEnumeration<SearchResult> results = context.search(newName, getFilterForPermissionType(newPermissionType), controls);
1:02a58c2: 
1:1f862ba:                     if (results.hasMore()) {
1:1f862ba:                         objectAdded(namingEvent, destinationType, newPermissionType);
1:1f862ba:                         matchedToType = true;
1:1f862ba:                         break;
1:1f862ba:                     }
1:1f862ba:                 }
1:02a58c2: 
1:1f862ba:                 if (!matchedToType) {
1:e1bbde7:                     LOG.error("Policy not applied!  Error processing object rename for rename of {} to {}. Could not determine permission type of new object.", oldBinding.getName(), newBinding.getName());
1:1f862ba:                 }
1:56a7001:             } else {
1:1f862ba:                 // Handle the case where a destination entry is being renamed.
1:1f862ba:                 if (oldDest != null && newDest != null) {
1:1f862ba:                     AuthorizationEntry entry = entries.remove(oldDest);
1:1f862ba:                     if (entry != null) {
1:1f862ba:                         entry.setDestination(newDest);
1:02a58c2:                         DefaultAuthorizationMap map = this.map.get();
1:02a58c2:                         map.put(newDest, entry);
1:02a58c2:                         map.remove(oldDest, entry);
1:1f862ba:                         entries.put(newDest, entry);
1:1f862ba:                     } else {
1:e1bbde7:                         LOG.warn("No authorization entry for {}", oldDest);
1:1f862ba:                     }
1:1f862ba:                 }
1:56a7001:             }
1:1f862ba:         } catch (InvalidNameException e) {
1:e1bbde7:             LOG.error("Policy not applied!  Error parsing DN for object rename for rename of {} to {}", new Object[]{ oldBinding.getName(), newBinding.getName() }, e);
1:1f862ba:         } catch (Exception e) {
1:e1bbde7:             LOG.error("Policy not applied!  Error processing object rename for rename of {} to {}", new Object[]{ oldBinding.getName(), newBinding.getName() }, e);
1:56a7001:         }
1:56a7001:     }
1:1f862ba: 
1:1f862ba:     /**
1:1f862ba:      * Handler for changed policy entries in the directory.
1:1f862ba:      *
1:02a58c2:      * @param namingEvent
1:02a58c2:      *            the changed entry event that occurred
1:02a58c2:      * @param destinationType
1:02a58c2:      *            the type of the destination to which the event applies
1:02a58c2:      * @param permissionType
1:02a58c2:      *            the permission type to which the event applies
1:1f862ba:      */
1:02a58c2:     public void objectChanged(NamingEvent namingEvent, DestinationType destinationType, PermissionType permissionType) {
1:e1bbde7:         LOG.debug("Changing object {} to {}", namingEvent.getOldBinding(), namingEvent.getNewBinding());
1:1f862ba:         objectRemoved(namingEvent, destinationType, permissionType);
1:1f862ba:         objectAdded(namingEvent, destinationType, permissionType);
1:56a7001:     }
1:1f862ba: 
1:1f862ba:     /**
1:1f862ba:      * Handler for exception events from the registry.
1:1f862ba:      *
1:02a58c2:      * @param namingExceptionEvent
1:02a58c2:      *            the exception event
1:1f862ba:      */
1:56a7001:     public void namingExceptionThrown(NamingExceptionEvent namingExceptionEvent) {
1:06949a5:         context = null;
1:1f862ba:         LOG.error("Caught unexpected exception.", namingExceptionEvent.getException());
1:56a7001:     }
1:1f862ba: 
1:1f862ba:     // Init / Destroy
1:56a7001:     public void afterPropertiesSet() throws Exception {
2:56a7001:         query();
1:56a7001:     }
1:1f862ba: 
1:1f862ba:     public void destroy() throws Exception {
1:1f862ba:         if (eventContext != null) {
1:1f862ba:             eventContext.close();
1:1f862ba:             eventContext = null;
1:1f862ba:         }
1:1f862ba: 
1:1f862ba:         if (context != null) {
1:1f862ba:             context.close();
1:1f862ba:             context = null;
1:1f862ba:         }
1:1f862ba:     }
1:1f862ba: 
1:1f862ba:     // Getters and Setters
1:1f862ba: 
1:56a7001:     public String getConnectionURL() {
1:56a7001:         return connectionURL;
1:56a7001:     }
1:1f862ba: 
1:56a7001:     public void setConnectionURL(String connectionURL) {
1:56a7001:         this.connectionURL = connectionURL;
1:56a7001:     }
1:1f862ba: 
1:56a7001:     public String getConnectionUsername() {
1:56a7001:         return connectionUsername;
1:56a7001:     }
1:1f862ba: 
1:56a7001:     public void setConnectionUsername(String connectionUsername) {
1:56a7001:         this.connectionUsername = connectionUsername;
1:56a7001:     }
1:1f862ba: 
1:56a7001:     public String getConnectionPassword() {
1:56a7001:         return connectionPassword;
1:56a7001:     }
1:1f862ba: 
1:56a7001:     public void setConnectionPassword(String connectionPassword) {
1:56a7001:         this.connectionPassword = connectionPassword;
1:56a7001:     }
1:1f862ba: 
1:56a7001:     public String getConnectionProtocol() {
1:56a7001:         return connectionProtocol;
1:56a7001:     }
1:1f862ba: 
1:56a7001:     public void setConnectionProtocol(String connectionProtocol) {
1:56a7001:         this.connectionProtocol = connectionProtocol;
1:56a7001:     }
1:1f862ba: 
1:56a7001:     public String getAuthentication() {
1:56a7001:         return authentication;
1:56a7001:     }
1:1f862ba: 
1:56a7001:     public void setAuthentication(String authentication) {
1:56a7001:         this.authentication = authentication;
1:56a7001:     }
1:02a58c2: 
1:1f862ba:     public String getQueueSearchBase() {
1:1f862ba:         return queueSearchBase;
1:56a7001:     }
1:1f862ba: 
1:1f862ba:     public void setQueueSearchBase(String queueSearchBase) {
1:1f862ba:         try {
1:1f862ba:             LdapName baseName = new LdapName(queueSearchBase);
1:1f862ba:             queuePrefixLength = baseName.size();
1:1f862ba:             this.queueSearchBase = queueSearchBase;
1:1f862ba:         } catch (InvalidNameException e) {
1:1f862ba:             throw new IllegalArgumentException("Invalid base DN value " + queueSearchBase, e);
1:1f862ba:         }
1:56a7001:     }
1:1f862ba: 
1:1f862ba:     public String getTopicSearchBase() {
1:1f862ba:         return topicSearchBase;
1:1f862ba:     }
1:1f862ba: 
1:1f862ba:     public void setTopicSearchBase(String topicSearchBase) {
1:1f862ba:         try {
1:1f862ba:             LdapName baseName = new LdapName(topicSearchBase);
1:1f862ba:             topicPrefixLength = baseName.size();
1:1f862ba:             this.topicSearchBase = topicSearchBase;
1:1f862ba:         } catch (InvalidNameException e) {
1:1f862ba:             throw new IllegalArgumentException("Invalid base DN value " + topicSearchBase, e);
1:1f862ba:         }
1:1f862ba:     }
1:1f862ba: 
1:1f862ba:     public String getTempSearchBase() {
1:1f862ba:         return tempSearchBase;
1:1f862ba:     }
1:1f862ba: 
1:1f862ba:     public void setTempSearchBase(String tempSearchBase) {
3:1f862ba:         try {
1:1f862ba:             LdapName baseName = new LdapName(tempSearchBase);
1:1f862ba:             tempPrefixLength = baseName.size();
1:1f862ba:             this.tempSearchBase = tempSearchBase;
1:1f862ba:         } catch (InvalidNameException e) {
1:1f862ba:             throw new IllegalArgumentException("Invalid base DN value " + tempSearchBase, e);
1:1f862ba:         }
1:1f862ba:     }
1:1f862ba: 
1:1f862ba:     public String getPermissionGroupMemberAttribute() {
1:1f862ba:         return permissionGroupMemberAttribute;
1:1f862ba:     }
1:1f862ba: 
1:02a58c2:     public void setPermissionGroupMemberAttribute(String permissionGroupMemberAttribute) {
1:1f862ba:         this.permissionGroupMemberAttribute = permissionGroupMemberAttribute;
1:1f862ba:     }
1:02a58c2: 
1:1f862ba:     public String getAdminPermissionGroupSearchFilter() {
1:1f862ba:         return adminPermissionGroupSearchFilter;
1:1f862ba:     }
1:1f862ba: 
1:02a58c2:     public void setAdminPermissionGroupSearchFilter(String adminPermissionGroupSearchFilter) {
1:1f862ba:         this.adminPermissionGroupSearchFilter = adminPermissionGroupSearchFilter;
1:1f862ba:     }
1:1f862ba: 
1:1f862ba:     public String getReadPermissionGroupSearchFilter() {
1:1f862ba:         return readPermissionGroupSearchFilter;
1:1f862ba:     }
1:1f862ba: 
1:02a58c2:     public void setReadPermissionGroupSearchFilter(String readPermissionGroupSearchFilter) {
1:1f862ba:         this.readPermissionGroupSearchFilter = readPermissionGroupSearchFilter;
1:1f862ba:     }
1:1f862ba: 
1:1f862ba:     public String getWritePermissionGroupSearchFilter() {
1:1f862ba:         return writePermissionGroupSearchFilter;
1:1f862ba:     }
1:1f862ba: 
1:02a58c2:     public void setWritePermissionGroupSearchFilter(String writePermissionGroupSearchFilter) {
1:1f862ba:         this.writePermissionGroupSearchFilter = writePermissionGroupSearchFilter;
1:1f862ba:     }
1:02a58c2: 
1:1f862ba:     public boolean isLegacyGroupMapping() {
1:1f862ba:         return legacyGroupMapping;
1:1f862ba:     }
1:1f862ba: 
1:1f862ba:     public void setLegacyGroupMapping(boolean legacyGroupMapping) {
1:1f862ba:         this.legacyGroupMapping = legacyGroupMapping;
1:1f862ba:     }
1:1f862ba: 
1:1f862ba:     public String getGroupObjectClass() {
1:1f862ba:         return groupObjectClass;
1:1f862ba:     }
1:1f862ba: 
1:1f862ba:     public void setGroupObjectClass(String groupObjectClass) {
1:1f862ba:         this.groupObjectClass = groupObjectClass;
1:1f862ba:     }
1:1f862ba: 
1:1f862ba:     public String getUserObjectClass() {
1:1f862ba:         return userObjectClass;
1:1f862ba:     }
1:1f862ba: 
1:1f862ba:     public void setUserObjectClass(String userObjectClass) {
1:1f862ba:         this.userObjectClass = userObjectClass;
1:1f862ba:     }
1:02a58c2: 
1:1f862ba:     public String getGroupNameAttribute() {
1:1f862ba:         return groupNameAttribute;
1:1f862ba:     }
1:1f862ba: 
1:1f862ba:     public void setGroupNameAttribute(String groupNameAttribute) {
1:1f862ba:         this.groupNameAttribute = groupNameAttribute;
1:1f862ba:     }
1:1f862ba: 
1:1f862ba:     public String getUserNameAttribute() {
1:1f862ba:         return userNameAttribute;
1:1f862ba:     }
1:1f862ba: 
1:1f862ba:     public void setUserNameAttribute(String userNameAttribute) {
1:1f862ba:         this.userNameAttribute = userNameAttribute;
1:1f862ba:     }
1:1f862ba: 
1:1f862ba:     public boolean isRefreshDisabled() {
1:1f862ba:         return refreshDisabled;
1:1f862ba:     }
1:1f862ba: 
1:1f862ba:     public void setRefreshDisabled(boolean refreshDisabled) {
1:1f862ba:         this.refreshDisabled = refreshDisabled;
1:1f862ba:     }
1:02a58c2: 
1:56a7001:     public int getRefreshInterval() {
1:56a7001:         return refreshInterval;
1:56a7001:     }
1:1f862ba: 
1:56a7001:     public void setRefreshInterval(int refreshInterval) {
1:56a7001:         this.refreshInterval = refreshInterval;
1:56a7001:     }
1:02a58c2: 
1:9d65673:     public String getGroupClass() {
1:9d65673:         return groupClass;
1:9d65673:     }
1:9d65673: 
1:9d65673:     public void setGroupClass(String groupClass) {
1:9d65673:         this.groupClass = groupClass;
1:9d65673:         map.get().setGroupClass(groupClass);
1:9d65673:     }
1:9d65673: 
1:1f862ba:     protected static enum DestinationType {
1:02a58c2:         QUEUE, TOPIC, TEMP;
1:1f862ba:     }
1:02a58c2: 
1:1f862ba:     protected static enum PermissionType {
1:02a58c2:         READ, WRITE, ADMIN;
1:1f862ba:     }
1:02a58c2: 
1:1f862ba:     /**
1:02a58c2:      * Listener implementation for directory changes that maps change events to destination types.
1:1f862ba:      */
1:02a58c2:     protected class CachedLDAPAuthorizationMapNamespaceChangeListener implements NamespaceChangeListener, ObjectChangeListener {
1:02a58c2: 
1:1f862ba:         private final DestinationType destinationType;
1:1f862ba:         private final PermissionType permissionType;
1:02a58c2: 
1:1f862ba:         /**
1:02a58c2:          * Creates a new listener. If {@code permissionType} is {@code null}, add and remove events are ignored as they
1:02a58c2:          * do not directly affect policy state. This configuration is used when listening for changes on entries that
1:02a58c2:          * represent destination patterns and not for entries that represent permissions.
1:1f862ba:          *
1:02a58c2:          * @param destinationType
1:02a58c2:          *            the type of the destination being listened for
1:02a58c2:          * @param permissionType
1:02a58c2:          *            the optional permission type being listened for
1:1f862ba:          */
1:02a58c2:         public CachedLDAPAuthorizationMapNamespaceChangeListener(DestinationType destinationType, PermissionType permissionType) {
1:1f862ba:             this.destinationType = destinationType;
1:1f862ba:             this.permissionType = permissionType;
1:1f862ba:         }
1:1f862ba: 
1:1f862ba:         @Override
1:1f862ba:         public void namingExceptionThrown(NamingExceptionEvent evt) {
1:7c9fec6:             SimpleCachedLDAPAuthorizationMap.this.namingExceptionThrown(evt);
1:1f862ba:         }
1:1f862ba: 
1:1f862ba:         @Override
1:1f862ba:         public void objectAdded(NamingEvent evt) {
1:1f862ba:             // This test is a hack to work around the fact that Apache DS 2.0 seems to trigger notifications
1:1f862ba:             // for the entire sub-tree even when one-level is the selected search scope.
1:1f862ba:             if (permissionType != null) {
1:7c9fec6:                 SimpleCachedLDAPAuthorizationMap.this.objectAdded(evt, destinationType, permissionType);
1:1f862ba:             }
1:1f862ba:         }
1:1f862ba: 
1:1f862ba:         @Override
1:1f862ba:         public void objectRemoved(NamingEvent evt) {
1:1f862ba:             // This test is a hack to work around the fact that Apache DS 2.0 seems to trigger notifications
1:1f862ba:             // for the entire sub-tree even when one-level is the selected search scope.
1:1f862ba:             if (permissionType != null) {
1:7c9fec6:                 SimpleCachedLDAPAuthorizationMap.this.objectRemoved(evt, destinationType, permissionType);
1:1f862ba:             }
1:1f862ba:         }
1:1f862ba: 
1:1f862ba:         @Override
1:1f862ba:         public void objectRenamed(NamingEvent evt) {
1:7c9fec6:             SimpleCachedLDAPAuthorizationMap.this.objectRenamed(evt, destinationType, permissionType);
1:1f862ba:         }
1:1f862ba: 
1:1f862ba:         @Override
1:1f862ba:         public void objectChanged(NamingEvent evt) {
1:1f862ba:             // This test is a hack to work around the fact that Apache DS 2.0 seems to trigger notifications
1:1f862ba:             // for the entire sub-tree even when one-level is the selected search scope.
1:1f862ba:             if (permissionType != null) {
1:7c9fec6:                 SimpleCachedLDAPAuthorizationMap.this.objectChanged(evt, destinationType, permissionType);
1:1f862ba:             }
1:1f862ba:         }
1:1f862ba:     }
1:1f862ba: }
============================================================================
author:Daniel Kulp
-------------------------------------------------------------------------------
commit:1a2e3eb
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.locks.ReentrantReadWriteLock;
/////////////////////////////////////////////////////////////////////////
1:     private long lastUpdated = -1;
/////////////////////////////////////////////////////////////////////////
1:     protected synchronized void query() throws Exception {
1:         entries.clear();
/////////////////////////////////////////////////////////////////////////
1:         if (lastUpdated == -1) {
1:             //ACL's have never been queried, but we need them NOW as we're being asked for them. 
1:             try {
1:                 query();
1:                 return;
1:             } catch (Exception e) {
1:                 LOG.error("Error updating authorization map.  Partial policy may be applied until the next successful update.", e);
1:             }
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:0b5231a
/////////////////////////////////////////////////////////////////////////
1:         if (connectionUsername != null && !"".equals(connectionUsername)) {
1:         } else {
1:             throw new NamingException("Empty username is not allowed");
1:         if (connectionPassword != null && !"".equals(connectionPassword)) {
1:         } else {
1:             throw new NamingException("Empty password is not allowed");
commit:9d65673
/////////////////////////////////////////////////////////////////////////
1:     protected String groupClass = DefaultAuthorizationMap.DEFAULT_GROUP_CLASS;
1: 
/////////////////////////////////////////////////////////////////////////
1:         newMap.setGroupClass(groupClass);
/////////////////////////////////////////////////////////////////////////
1:     public String getGroupClass() {
1:         return groupClass;
1:     }
1: 
1:     public void setGroupClass(String groupClass) {
1:         this.groupClass = groupClass;
1:         map.get().setGroupClass(groupClass);
1:     }
1: 
author:Timothy Bish
-------------------------------------------------------------------------------
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
1:                 LOG.error("Policy not applied!.  Error processing policy under '{}' with filter '{}'", new Object[]{ queueSearchBase, getFilterForPermissionType(permissionType) }, e);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.error("Policy not applied!.  Error processing policy under '{}' with filter '{}'", new Object[]{ topicSearchBase, getFilterForPermissionType(permissionType) }, e);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.error("Policy not applied!.  Error processing policy under '{}' with filter '{}'", new Object[]{ tempSearchBase, getFilterForPermissionType(permissionType) }, e);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.error("Policy not applied!  Error parsing authorization policy entry under {}", result.getNameInNamespace(), e);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.error("Policy not applied! Unknown member {} in policy entry {}", new Object[]{ memberDn, result.getNameInNamespace() }, e);
/////////////////////////////////////////////////////////////////////////
1:                             LOG.error("Policy not applied! Group {} does not have name attribute {} under entry {}", new Object[]{ memberDn, groupNameAttribute, result.getNameInNamespace() });
/////////////////////////////////////////////////////////////////////////
1:                             LOG.error("Policy not applied! User {} does not have name attribute {} under entry {}", new Object[]{ memberDn, userNameAttribute, result.getNameInNamespace() });
/////////////////////////////////////////////////////////////////////////
1:                 LOG.error("Policy not applied! Can't determine type of member {} under entry {}", memberDn, result.getNameInNamespace());
/////////////////////////////////////////////////////////////////////////
1:             LOG.error("Policy not applied! Error adding principals to ACL under {}", result.getNameInNamespace(), e);
/////////////////////////////////////////////////////////////////////////
1:                             LOG.error("Error updating authorization map.  Partial policy may be applied until the next successful update.", e);
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("Adding object: {}", namingEvent.getNewBinding());
/////////////////////////////////////////////////////////////////////////
1:             LOG.error("Policy not applied!  Error parsing DN for addition of {}", result.getName(), e);
1:             LOG.error("Policy not applied!  Error processing object addition for addition of {}", result.getName(), e);
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("Removing object: {}", namingEvent.getOldBinding());
/////////////////////////////////////////////////////////////////////////
1:             LOG.error("Policy not applied!  Error parsing DN for object removal for removal of {}", result.getName(), e);
1:             LOG.error("Policy not applied!  Error processing object removal for removal of {}", result.getName(), e);
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("Renaming object: {} to {}", oldBinding, newBinding);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.error("Policy not applied!  Error processing object rename for rename of {} to {}. Could not determine permission type of new object.", oldBinding.getName(), newBinding.getName());
/////////////////////////////////////////////////////////////////////////
1:                         LOG.warn("No authorization entry for {}", oldDest);
1:             LOG.error("Policy not applied!  Error parsing DN for object rename for rename of {} to {}", new Object[]{ oldBinding.getName(), newBinding.getName() }, e);
1:             LOG.error("Policy not applied!  Error processing object rename for rename of {} to {}", new Object[]{ oldBinding.getName(), newBinding.getName() }, e);
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("Changing object {} to {}", namingEvent.getOldBinding(), namingEvent.getNewBinding());
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:a3060d0
/////////////////////////////////////////////////////////////////////////
1:         // Allow for only a couple outstanding update request, they can be slow so we
1:         updaterService = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS,
commit:02a58c2
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.HashSet;
1: import java.util.Hashtable;
1: import java.util.Map;
1: import java.util.Set;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.LinkedBlockingQueue;
1: import java.util.concurrent.ThreadFactory;
1: import java.util.concurrent.ThreadPoolExecutor;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicReference;
1: 
1: import javax.naming.Binding;
1: import javax.naming.Context;
1: import javax.naming.InvalidNameException;
1: import javax.naming.NamingEnumeration;
1: import javax.naming.NamingException;
1: import javax.naming.directory.Attribute;
1: import javax.naming.directory.Attributes;
1: import javax.naming.directory.DirContext;
1: import javax.naming.directory.InitialDirContext;
1: import javax.naming.directory.SearchControls;
1: import javax.naming.directory.SearchResult;
1: import javax.naming.event.EventDirContext;
1: import javax.naming.event.NamespaceChangeListener;
1: import javax.naming.event.NamingEvent;
1: import javax.naming.event.NamingExceptionEvent;
1: import javax.naming.event.ObjectChangeListener;
1: import javax.naming.ldap.LdapName;
1: import javax.naming.ldap.Rdn;
1: 
1: public class SimpleCachedLDAPAuthorizationMap implements AuthorizationMap {
1:     private final String initialContextFactory = "com.sun.jndi.ldap.LdapCtxFactory";
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     private final AtomicReference<DefaultAuthorizationMap> map =
1:         new AtomicReference<DefaultAuthorizationMap>(new DefaultAuthorizationMap());
1:     private final ThreadPoolExecutor updaterService;
1: 
1:     protected Map<ActiveMQDestination, AuthorizationEntry> entries =
1:         new ConcurrentHashMap<ActiveMQDestination, AuthorizationEntry>();
1: 
1:     public SimpleCachedLDAPAuthorizationMap() {
0:         // Allow for only a couple outstanding update requests, they can be slow so we
1:         // don't want a bunch to pile up for no reason.
0:         updaterService = new ThreadPoolExecutor(1, 1, 0, TimeUnit.SECONDS,
1:             new LinkedBlockingQueue<Runnable>(2),
1:             new ThreadFactory() {
1: 
1:                 @Override
1:                 public Thread newThread(Runnable r) {
1:                     return new Thread(r, "SimpleCachedLDAPAuthorizationMap update thread");
1:                 }
1:             });
1:         updaterService.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardPolicy());
1:     }
/////////////////////////////////////////////////////////////////////////
1:             } catch (Exception e) {
1:             }
1:      * Returns the existing open context or creates a new one and registers listeners for push notifications if such an
1:      * update style is enabled. This implementation should not be invoked concurrently.
1:      * @throws NamingException
1:      *             if there is an error setting things up
/////////////////////////////////////////////////////////////////////////
1:                 eventContext = ((EventDirContext) context.lookup(""));
1: 
1: 
1:                         this.new CachedLDAPAuthorizationMapNamespaceChangeListener(DestinationType.QUEUE, permissionType));
1:                 eventContext.addNamingListener(queueSearchBase, "cn=*", new SearchControls(), this.new CachedLDAPAuthorizationMapNamespaceChangeListener(
1:                     DestinationType.QUEUE, null));
1: 
1: 
1:                         this.new CachedLDAPAuthorizationMapNamespaceChangeListener(DestinationType.TOPIC, permissionType));
1:                 eventContext.addNamingListener(topicSearchBase, "cn=*", new SearchControls(), this.new CachedLDAPAuthorizationMapNamespaceChangeListener(
1:                     DestinationType.TOPIC, null));
1: 
1: 
1:                         this.new CachedLDAPAuthorizationMapNamespaceChangeListener(DestinationType.TEMP, permissionType));
/////////////////////////////////////////////////////////////////////////
1:     }
1:      * Queries the directory and initializes the policy based on the data in the directory. This implementation should
1:      * not be invoked concurrently.
1:      *
1:      * @throws Exception
1:      *             if there is an unrecoverable error processing the directory contents
1: 
1: 
1:         DefaultAuthorizationMap newMap = new DefaultAuthorizationMap();
1:                 processQueryResults(newMap,
1:                     currentContext.search(queueSearchBase, getFilterForPermissionType(permissionType),
1:                     constraints), DestinationType.QUEUE, permissionType);
0:                 LOG.error("Policy not applied!.  Error processing policy under '" + queueSearchBase +
0:                           "' with filter '" + getFilterForPermissionType(permissionType) + "'", e);
1: 
1:                 processQueryResults(newMap,
1:                     currentContext.search(topicSearchBase, getFilterForPermissionType(permissionType),
1:                     constraints), DestinationType.TOPIC, permissionType);
0:                 LOG.error("Policy not applied!.  Error processing policy under '" + topicSearchBase +
0:                           "' with filter '" + getFilterForPermissionType(permissionType) + "'", e);
1: 
1:                 processQueryResults(newMap,
1:                     currentContext.search(tempSearchBase, getFilterForPermissionType(permissionType),
1:                     constraints), DestinationType.TEMP, permissionType);
0:                 LOG.error("Policy not applied!.  Error processing policy under '" + tempSearchBase +
0:                           "' with filter '" + getFilterForPermissionType(permissionType) + "'", e);
1: 
1:         // Create and swap in the new instance with updated LDAP data.
1:         newMap.setAuthorizationEntries(new ArrayList<DestinationMapEntry>(entries.values()));
1:         this.map.set(newMap);
1: 
1: 
1:      * Processes results from a directory query in the context of a given destination type and permission type. This
1:      * implementation should not be invoked concurrently.
1:      * @param results
1:      *            the results to process
1:      * @param destinationType
1:      *            the type of the destination for which the directory results apply
1:      * @param permissionType
1:      *            the type of the permission for which the directory results apply
1:      * @throws Exception
1:      *             if there is an error processing the results
1:     protected void processQueryResults(DefaultAuthorizationMap map, NamingEnumeration<SearchResult> results, DestinationType destinationType, PermissionType permissionType)
1:         throws Exception {
1: 
1: 
1:                 entry = getEntry(map, new LdapName(result.getNameInNamespace()), destinationType);
0:                 LOG.error("Policy not applied!  Error parsing authorization policy entry under " + result.getNameInNamespace(), e);
1: 
1:      * Marks the time at which the authorization state was last refreshed. Relevant for synchronous
1:      * policy updates. This implementation should not be invoked concurrently.
1:      * Retrieves or creates the {@link AuthorizationEntry} that corresponds to the DN in {@code dn}. This implementation
1:      * should not be invoked concurrently.
1:      *
1:      * @param map
1:      *            the DefaultAuthorizationMap to operate on.
1:      * @param destinationType
1:      *            the type of the destination to get/create the entry for
1:      *
1:      *
1:     protected AuthorizationEntry getEntry(DefaultAuthorizationMap map, LdapName dn, DestinationType destinationType) {
/////////////////////////////////////////////////////////////////////////
1:                         + "policy entry.  The permission group entries should be immediately below the " + "temporary policy base DN.");
1:                 entry = map.getTempDestinationAuthorizationEntry();
1:                     map.setTempDestinationAuthorizationEntry((TempDestinationAuthorizationEntry) entry);
1: 
1: 
1:                         + "policy entry.  The destination pattern and permission group entries should be " + "nested below the queue or topic policy base DN.");
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:      * Applies the policy from the directory to the given entry within the context of the provided permission type.
1:      * @param entry
1:      *            the policy entry to apply the policy to
1:      * @param result
1:      *            the results from the directory to apply to the policy entry
1:      * @param permissionType
1:      *            the permission type of the data in the directory
1:      * @throws NamingException
1:      *             if there is an error applying the ACL
1:     protected void applyACL(AuthorizationEntry entry, SearchResult result, PermissionType permissionType) throws NamingException {
1: 
1: 
1: 
1: 
1:                     memberAttributes = context.getAttributes(memberDn, new String[] { "objectClass", groupNameAttribute, userNameAttribute });
0:                     LOG.error("Policy not applied! Unknown member " + memberDn + " in policy entry " + result.getNameInNamespace(), e);
1: 
1: 
1: 
0:                             LOG.error("Policy not applied! Group " + memberDn + "does not have name attribute " + groupNameAttribute + " under entry "
0:                                 + result.getNameInNamespace());
1: 
1: 
0:                             LOG.error("Policy not applied! User " + memberDn + " does not have name attribute " + userNameAttribute + " under entry "
0:                                 + result.getNameInNamespace());
1: 
1: 
1: 
0:                 LOG.error("Policy not applied! Can't determine type of member " + memberDn + " under entry " + result.getNameInNamespace());
1:             } else if (principalName != null) {
1:                 DefaultAuthorizationMap map = this.map.get();
1:                         members.add(DefaultAuthorizationMap.createGroupPrincipal(principalName, map.getGroupClass()));
1:                         NamingException ne = new NamingException(
1:                             "Can't create a group " + principalName + " of class " + map.getGroupClass());
/////////////////////////////////////////////////////////////////////////
1: 
0:             LOG.error("Policy not applied! Error adding principals to ACL under " + result.getNameInNamespace(), e);
1: 
1:      * @param entry
1:      *            the policy entry to which the policy should be applied
1:      * @param permissionType
1:      *            the type of the permission that the policy will be applied to
1:      * @param acls
1:      *            the principals that represent the actual policy
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:      * Parses a DN into the equivalent {@link ActiveMQDestination}. The default implementation expects a format of
1:      * cn=<PERMISSION_NAME>,ou=<DESTINATION_PATTERN>,.... or ou=<DESTINATION_PATTERN>,.... for permission and
1:      * destination entries, respectively. For example {@code cn=admin,ou=$,ou=...} or {@code ou=$,ou=...}.
1:      * @param dn
1:      *            the DN to parse
1:      * @param destinationType
1:      *            the type of the destination that we are parsing
1:      * @throws IllegalArgumentException
1:      *             if {@code destinationType} is {@link DestinationType#TEMP} or if the format of {@code dn} is
1:      *             incorrect for for a topic or queue
1: 
1:                 // destination. As such, we need to determine the proper RDN to work with based
1:                 } else if (dn.size() == (getPrefixLengthForDestinationType(destinationType) + 1)) {
1:                     throw new IllegalArgumentException("Malformed DN for representing a permission or destination entry.");
1:                 throw new IllegalArgumentException("Cannot format destination for destination type " + destinationType);
1: 
1: 
1:      * Parses RDN values representing the destination name/pattern and destination type into the equivalent
1:      * {@link ActiveMQDestination}.
1:      *
1:      *
1:      *
1:      *
1: 
/////////////////////////////////////////////////////////////////////////
1:                 throw new IllegalArgumentException("Unknown destination type: " + destinationType);
1:      * Parses the RDN representing a destination name/pattern into the standard string representation of the
1:      * name/pattern. This implementation does not care about the type of the RDN such that the RDN could be a CN or OU.
1:      * @param destinationName
1:      *            the RDN representing the name or pattern for the destination
1: 
1:      * Transcribes an existing set into a new set. Used to make defensive copies for concurrent access.
1:      *
1:      *
1:      * @return a new set containing the same elements as {@code source} or {@code null} if {@code source} is
1:      *         {@code null}
/////////////////////////////////////////////////////////////////////////
1: 
1:      *
1:      * @throws IllegalArgumentException
1:      *             if {@code permissionType} is not supported
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:      * @throws IllegalArgumentException
1:      *             if {@code destinationType} is not supported
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:      * Performs a check for updates from the server in the event that synchronous updates are enabled and are the
1:      * refresh interval has elapsed.
1:         if (context != null && refreshDisabled) {
1:             return;
1:         }
1: 
1:         if (context == null || (!refreshDisabled && (refreshInterval != -1 && System.currentTimeMillis() >= lastUpdated + refreshInterval))) {
1:             this.updaterService.execute(new Runnable() {
1:                 @Override
1:                 public void run() {
1: 
1:                     // Check again in case of stacked update request.
1:                     if (context == null || (!refreshDisabled &&
1:                         (refreshInterval != -1 && System.currentTimeMillis() >= lastUpdated + refreshInterval))) {
1: 
1:                         if (!isContextAlive()) {
1:                             try {
1:                                 context = createContext();
1:                             } catch (NamingException ne) {
1:                                 // LDAP is down, use already cached values
1:                                 return;
1:                             }
1:                         }
1: 
0:                         entries.clear();
1: 
1:                         LOG.debug("Updating authorization map!");
1:                         try {
1:                             query();
1:                         } catch (Exception e) {
0:                             LOG.error("Error updating authorization map.  Partial policy " +
0:                                       "may be applied until the next successful update.", e);
1:                         }
1:                     }
1:                 }
1:             });
1: 
1: 
1:      * Provides synchronized and defensive access to the admin ACLs for temp destinations as the super implementation
1:      * returns live copies of the ACLs and {@link AuthorizationEntry} is not setup for concurrent access.
1:     public Set<Object> getTempDestinationAdminACLs() {
1:         DefaultAuthorizationMap map = this.map.get();
1:         return transcribeSet(map.getTempDestinationAdminACLs());
1: 
1:      * Provides synchronized and defensive access to the read ACLs for temp destinations as the super implementation
1:      * returns live copies of the ACLs and {@link AuthorizationEntry} is not setup for concurrent access.
1:     public Set<Object> getTempDestinationReadACLs() {
1:         DefaultAuthorizationMap map = this.map.get();
1:         return transcribeSet(map.getTempDestinationReadACLs());
1:      * Provides synchronized and defensive access to the write ACLs for temp destinations as the super implementation
1:      * returns live copies of the ACLs and {@link AuthorizationEntry} is not setup for concurrent access.
1:     @Override
1:     public Set<Object> getTempDestinationWriteACLs() {
1:         DefaultAuthorizationMap map = this.map.get();
1:         return transcribeSet(map.getTempDestinationWriteACLs());
1:      * Provides synchronized access to the admin ACLs for the destinations as {@link AuthorizationEntry}
1:      * is not setup for concurrent access.
1:     @Override
1:     public Set<Object> getAdminACLs(ActiveMQDestination destination) {
1:         DefaultAuthorizationMap map = this.map.get();
1:         return map.getAdminACLs(destination);
1:      * Provides synchronized access to the read ACLs for the destinations as {@link AuthorizationEntry} is not setup for
1:      * concurrent access.
1:     @Override
1:     public Set<Object> getReadACLs(ActiveMQDestination destination) {
1:         DefaultAuthorizationMap map = this.map.get();
1:         return map.getReadACLs(destination);
1:     }
1: 
1:     /**
1:      * Provides synchronized access to the write ACLs for the destinations as {@link AuthorizationEntry} is not setup
1:      * for concurrent access.
1:      */
1:     @Override
1:     public Set<Object> getWriteACLs(ActiveMQDestination destination) {
1:         checkForUpdates();
1:         DefaultAuthorizationMap map = this.map.get();
1:         return map.getWriteACLs(destination);
1:      * @param namingEvent
1:      *            the new entry event that occurred
1:      * @param destinationType
1:      *            the type of the destination to which the event applies
1:      * @param permissionType
1:      *            the permission type to which the event applies
1:     public void objectAdded(NamingEvent namingEvent, DestinationType destinationType, PermissionType permissionType) {
1: 
1:             DefaultAuthorizationMap map = this.map.get();
1:             AuthorizationEntry entry = getEntry(map, name, destinationType);
1: 
1:                 map.put(entry.getDestination(), entry);
0:             LOG.error("Policy not applied!  Error parsing DN for addition of " + result.getName(), e);
0:             LOG.error("Policy not applied!  Error processing object addition for addition of " + result.getName(), e);
1:      * @param namingEvent
1:      *            the removed entry event that occurred
1:      * @param destinationType
1:      *            the type of the destination to which the event applies
1:      * @param permissionType
1:      *            the permission type to which the event applies
1:     public void objectRemoved(NamingEvent namingEvent, DestinationType destinationType, PermissionType permissionType) {
1:         try {
1:             DefaultAuthorizationMap map = this.map.get();
1:             LdapName name = new LdapName(result.getName());
1:             AuthorizationEntry entry = getEntry(map, name, destinationType);
0:             LOG.error("Policy not applied!  Error parsing DN for object removal for removal of " + result.getName(), e);
0:             LOG.error("Policy not applied!  Error processing object removal for removal of " + result.getName(), e);
1:      * Handler for renamed policy entries in the directory. This handler deals with the renaming of destination entries
1:      * as well as permission entries. If the permission type is not null, it is assumed that we are dealing with the
1:      * renaming of a permission entry. Otherwise, it is assumed that we are dealing with the renaming of a destination
1:      * entry.
1:      * @param namingEvent
1:      *            the renaming entry event that occurred
1:      * @param destinationType
1:      *            the type of the destination to which the event applies
1:      * @param permissionType
1:      *            the permission type to which the event applies
1:     public void objectRenamed(NamingEvent namingEvent, DestinationType destinationType, PermissionType permissionType) {
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1:                     NamingEnumeration<SearchResult> results = context.search(newName, getFilterForPermissionType(newPermissionType), controls);
1: 
1: 
0:                     LOG.error("Policy not applied!  Error processing object rename for rename of " + oldBinding.getName() + " to " + newBinding.getName()
0:                         + ".  Could not determine permission type of new object.");
1:                         DefaultAuthorizationMap map = this.map.get();
1:                         map.put(newDest, entry);
1:                         map.remove(oldDest, entry);
/////////////////////////////////////////////////////////////////////////
0:             LOG.error("Policy not applied!  Error parsing DN for object rename for rename of " + oldBinding.getName() + " to " + newBinding.getName(), e);
0:             LOG.error("Policy not applied!  Error processing object rename for rename of " + oldBinding.getName() + " to " + newBinding.getName(), e);
1:      * @param namingEvent
1:      *            the changed entry event that occurred
1:      * @param destinationType
1:      *            the type of the destination to which the event applies
1:      * @param permissionType
1:      *            the permission type to which the event applies
1:     public void objectChanged(NamingEvent namingEvent, DestinationType destinationType, PermissionType permissionType) {
/////////////////////////////////////////////////////////////////////////
1:      * @param namingExceptionEvent
1:      *            the exception event
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void setPermissionGroupMemberAttribute(String permissionGroupMemberAttribute) {
1: 
1:     public void setAdminPermissionGroupSearchFilter(String adminPermissionGroupSearchFilter) {
/////////////////////////////////////////////////////////////////////////
1:     public void setReadPermissionGroupSearchFilter(String readPermissionGroupSearchFilter) {
/////////////////////////////////////////////////////////////////////////
1:     public void setWritePermissionGroupSearchFilter(String writePermissionGroupSearchFilter) {
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         QUEUE, TOPIC, TEMP;
1: 
1:         READ, WRITE, ADMIN;
1: 
1:      * Listener implementation for directory changes that maps change events to destination types.
1:     protected class CachedLDAPAuthorizationMapNamespaceChangeListener implements NamespaceChangeListener, ObjectChangeListener {
1: 
1: 
1:          * Creates a new listener. If {@code permissionType} is {@code null}, add and remove events are ignored as they
1:          * do not directly affect policy state. This configuration is used when listening for changes on entries that
1:          * represent destination patterns and not for entries that represent permissions.
1:          * @param destinationType
1:          *            the type of the destination being listened for
1:          * @param permissionType
1:          *            the optional permission type being listened for
1:         public CachedLDAPAuthorizationMapNamespaceChangeListener(DestinationType destinationType, PermissionType permissionType) {
commit:3dbc9c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.filter.DestinationMapEntry;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("rawtypes")
/////////////////////////////////////////////////////////////////////////
0:         NamingEnumeration<?> results = context.search("ou=Destination,ou=ActiveMQ," + baseDn, "(|(cn=admin)(cn=write)(cn=read))", constraints);
0:         setEntries(new ArrayList<DestinationMapEntry>(entries.values()));
/////////////////////////////////////////////////////////////////////////
0:         NamingEnumeration<?> memberEnum = member.getAll();
1:         HashSet<Object> members = new HashSet<Object>();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             entry.setAdminACLs(new HashSet<Object>());
0:             entry.setWriteACLs(new HashSet<Object>());
0:             entry.setReadACLs(new HashSet<Object>());
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:9027d49
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     try {
0:                         members.add(createGroupPrincipal(principalName, getGroupClass()));
1:                     } catch (Exception e) {
0:                         NamingException ne = new NamingException("Can't create a group " + principalName + " of class " + getGroupClass());
1:                         ne.initCause(e);
1:                         throw ne;
1:                     }
commit:9bf65b4
/////////////////////////////////////////////////////////////////////////
commit:b067a65
/////////////////////////////////////////////////////////////////////////
1:     protected DirContext context;
/////////////////////////////////////////////////////////////////////////
1:     protected boolean isContextAlive() {
1:         boolean alive = false;
1:         if (context != null) {
1:             try {
1:                 context.getAttributes("");
1:                 alive = true;
0:             } catch (Exception e) {}
1:         }
1:         return alive;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isContextAlive()) {
1:             return context;
/////////////////////////////////////////////////////////////////////////
0:             if (!isContextAlive()) {
commit:06949a5
/////////////////////////////////////////////////////////////////////////
1:     protected DirContext createContext() throws NamingException {
1:         Hashtable<String, String> env = new Hashtable<String, String>();
1:         env.put(Context.INITIAL_CONTEXT_FACTORY, initialContextFactory);
0:         if (connectionUsername != null || !"".equals(connectionUsername)) {
1:             env.put(Context.SECURITY_PRINCIPAL, connectionUsername);
1:         }
0:         if (connectionPassword != null || !"".equals(connectionPassword)) {
1:             env.put(Context.SECURITY_CREDENTIALS, connectionPassword);
1:         }
1:         env.put(Context.SECURITY_PROTOCOL, connectionProtocol);
1:         env.put(Context.PROVIDER_URL, connectionURL);
1:         env.put(Context.SECURITY_AUTHENTICATION, authentication);
0:         //env.put("com.sun.jndi.ldap.connect.pool", "true");
1:         return new InitialDirContext(env);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:             boolean alive = true;
1:             try {
0:                 context.getAttributes("");
1:             } catch (Exception e) {
0:                LOG.info("LDAP connection failed", e);
0:                alive = false;
1:             }
0:             if (alive) {
1:                 return context;
1:             }
1:             context = createContext();
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:         if (context == null || (!refreshDisabled && (refreshInterval != -1 && System.currentTimeMillis() >= lastUpdated + refreshInterval))) {
0:             if (context == null) {
1:                 try {
0:                     context = createContext();
0:                 } catch (NamingException ne) {
0:                     // LDAP is down, use already cached values
0:                     return;
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
1:         checkForUpdates();
/////////////////////////////////////////////////////////////////////////
1:         checkForUpdates();
/////////////////////////////////////////////////////////////////////////
1:         context = null;
commit:1f862ba
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.jaas.UserPrincipal;
0: import org.springframework.beans.factory.DisposableBean;
0: import javax.naming.InvalidNameException;
0: import javax.naming.ldap.LdapName;
0: import javax.naming.ldap.Rdn;
1: 
0:  * A {@link DefaultAuthorizationMap} implementation which uses LDAP to initialize and update authorization
0:  * policy.
0: public class CachedLDAPAuthorizationMap extends DefaultAuthorizationMap implements InitializingBean, DisposableBean {
1:     // Configuration Options
/////////////////////////////////////////////////////////////////////////
1:     
1:     private int queuePrefixLength = 4;
1:     private int topicPrefixLength = 4;
1:     private int tempPrefixLength = 4;
1:     
1:     private String queueSearchBase = "ou=Queue,ou=Destination,ou=ActiveMQ,ou=system";
1:     private String topicSearchBase = "ou=Topic,ou=Destination,ou=ActiveMQ,ou=system";
1:     private String tempSearchBase = "ou=Temp,ou=Destination,ou=ActiveMQ,ou=system";
1:     
1:     
1:     private String permissionGroupMemberAttribute = "member";
1:     
1:     private String adminPermissionGroupSearchFilter = "(cn=Admin)";
1:     private String readPermissionGroupSearchFilter = "(cn=Read)";
1:     private String writePermissionGroupSearchFilter = "(cn=Write)";
1:     
1:     private boolean legacyGroupMapping = true;
1:     private String groupObjectClass = "groupOfNames";
1:     private String userObjectClass = "person";
1:     private String groupNameAttribute = "cn";
1:     private String userNameAttribute = "uid";
1:     
1:     private boolean refreshDisabled = false;
1:     
1:     // Internal State
1:     
0:     protected HashMap<ActiveMQDestination, AuthorizationEntry> entries = 
0:             new HashMap<ActiveMQDestination, AuthorizationEntry>();
1:     /**
0:      * Returns the existing open context or creates a new one and registers listeners for
0:      * push notifications if such an update style is enabled.  This implementation should not
0:      * be invoked concurrently.
1:      *
1:      * @return the current context
1:      *
0:      * @throws NamingException if there is an error setting things up
1:      */
/////////////////////////////////////////////////////////////////////////
1:             if (refreshInterval == -1 && !refreshDisabled) {
1:                 
1: 
1:                 // Listeners for Queue policy //
1:                 
1:                 // Listeners for each type of permission
1:                 for (PermissionType permissionType : PermissionType.values()) {
1:                     eventContext.addNamingListener(queueSearchBase, getFilterForPermissionType(permissionType), constraints,
0:                             this.new CachedLDAPAuthorizationMapNamespaceChangeListener(DestinationType.QUEUE, permissionType));
1:                 }
1:                 // Listener for changes to the destination pattern entry itself and not a permission entry.
0:                 eventContext.addNamingListener(queueSearchBase, "cn=*", new SearchControls(),
0:                         this.new CachedLDAPAuthorizationMapNamespaceChangeListener(DestinationType.QUEUE, null));
1:                 
1:                 // Listeners for Topic policy //
1:                 
1:                 // Listeners for each type of permission
1:                 for (PermissionType permissionType : PermissionType.values()) {
1:                     eventContext.addNamingListener(topicSearchBase, getFilterForPermissionType(permissionType), constraints,
0:                             this.new CachedLDAPAuthorizationMapNamespaceChangeListener(DestinationType.TOPIC, permissionType));
1:                 }
1:                 // Listener for changes to the destination pattern entry itself and not a permission entry.
0:                 eventContext.addNamingListener(topicSearchBase, "cn=*", new SearchControls(),
0:                         this.new CachedLDAPAuthorizationMapNamespaceChangeListener(DestinationType.TOPIC, null));
1:                 
1:                 // Listeners for Temp policy //
1:                 
1:                 // Listeners for each type of permission
1:                 for (PermissionType permissionType : PermissionType.values()) {
1:                     eventContext.addNamingListener(tempSearchBase, getFilterForPermissionType(permissionType), constraints,
0:                             this.new CachedLDAPAuthorizationMapNamespaceChangeListener(DestinationType.TEMP, permissionType));
1:                 }
1:             context = null;
1: 
1:     } 
1:     /**
0:      * Queries the directory and initializes the policy based on the data in the directory.
0:      * This implementation should not be invoked concurrently.
1:      * 
0:      * @throws Exception if there is an unrecoverable error processing the directory contents
1:      */
0:     protected void query() throws Exception {
1:         DirContext currentContext = open();
1:     
1:        
1:         for (PermissionType permissionType : PermissionType.values()) {
1:             try {
0:                 processQueryResults(
0:                         currentContext.search(queueSearchBase, getFilterForPermissionType(permissionType), constraints),
0:                         DestinationType.QUEUE, permissionType);
1:             } catch (Exception e) {
0:                 LOG.error("Policy not applied!.  Error processing policy under '" + queueSearchBase + "' with filter '" 
0:                         + getFilterForPermissionType(permissionType) + "'", e);
1:             }
1:         
1:         for (PermissionType permissionType : PermissionType.values()) {
1:             try {
0:                 processQueryResults(
0:                         currentContext.search(topicSearchBase, getFilterForPermissionType(permissionType), constraints),
0:                         DestinationType.TOPIC, permissionType);
1:             } catch (Exception e) {
0:                 LOG.error("Policy not applied!.  Error processing policy under '" + topicSearchBase + "' with filter '" 
0:                         + getFilterForPermissionType(permissionType) + "'", e);
1:             }
1:         }
1:         
1:         for (PermissionType permissionType : PermissionType.values()) {
1:             try {
0:                 processQueryResults(
0:                         currentContext.search(tempSearchBase, getFilterForPermissionType(permissionType), constraints),
0:                         DestinationType.TEMP, permissionType);
1:             } catch (Exception e) {
0:                 LOG.error("Policy not applied!.  Error processing policy under '" + tempSearchBase + "' with filter '" 
0:                         + getFilterForPermissionType(permissionType) + "'", e);
1:             }
1:         }
1:         
1:     
1:     /**
0:      * Processes results from a directory query in the context of a given destination type and permission type.
0:      * This implementation should not be invoked concurrently.
1:      *
0:      * @param results the results to process
0:      * @param destinationType the type of the destination for which the directory results apply
0:      * @param permissionType the type of the permission for which the directory results apply
1:      *
0:      * @throws Exception if there is an error processing the results
1:      */
0:     protected void processQueryResults(NamingEnumeration<SearchResult> results,
0:             DestinationType destinationType, PermissionType permissionType) throws Exception {
1:         
1:         while (results.hasMore()) {
1:             SearchResult result = results.next();
1:             AuthorizationEntry entry = null;
1:             
1:             try {
0:                 entry = getEntry(new LdapName(result.getNameInNamespace()), destinationType);
1:             } catch (Exception e) {
0:                 LOG.error("Policy not applied!  Error parsing authorization policy entry under "
0:                         + result.getNameInNamespace(), e);
1:                 continue;
1:             }
1:                 
1:             applyACL(entry, result, permissionType);
1:         }
1:     }
1:     /**
0:      * Marks the time at which the authorization state was last refreshed.  Relevant for synchronous policy updates.
0:      * This implementation should not be invoked concurrently.
1:      */
1:     /**
0:      * Retrieves or creates the {@link AuthorizationEntry} that corresponds to
0:      * the DN in {@code dn}.  This implementation should not be invoked concurrently.
1:      * 
1:      * @param dn
1:      *            the DN representing the policy entry in the directory
0:      * @param destinationType the type of the destination to get/create the entry for
1:      * 
1:      * @return the corresponding authorization entry for the DN
1:      * 
1:      * @throws IllegalArgumentException
1:      *             if destination type is not one of {@link DestinationType#QUEUE}, {@link DestinationType#TOPIC},
1:      *             {@link DestinationType#TEMP} or if the policy entry DN is malformed
1:      */
0:     protected AuthorizationEntry getEntry(LdapName dn, DestinationType destinationType) {
1:         
1:         AuthorizationEntry entry = null;
1:         
1:         
1:         switch (destinationType) {
1:             case TEMP:
1:                 // handle temp entry
1:                 if (dn.size() != getPrefixLengthForDestinationType(destinationType) + 1) {
1:                     // handle unknown entry
1:                     throw new IllegalArgumentException("Malformed policy structure for a temporary destination "
0:                             + "policy entry.  The permission group entries should be immediately below the "
0:                             + "temporary policy base DN.");
0:                 entry = getTempDestinationAuthorizationEntry();
1:                     entry = new TempDestinationAuthorizationEntry();
0:                     setTempDestinationAuthorizationEntry((TempDestinationAuthorizationEntry) entry);
1:                 
1:                 break;
1:                 
1:             case QUEUE:
1:             case TOPIC:
1:                 // handle regular destinations
1:                 if (dn.size() != getPrefixLengthForDestinationType(destinationType) + 2) {
1:                     throw new IllegalArgumentException("Malformed policy structure for a queue or topic destination "
0:                             + "policy entry.  The destination pattern and permission group entries should be "
0:                             + "nested below the queue or topic policy base DN.");
1:                 }
1:                 
1:                 ActiveMQDestination dest = formatDestination(dn, destinationType);
1: 
1:                 if (dest != null) {
1:                     entry = entries.get(dest);
1:                     if (entry == null) {
1:                         entry = new AuthorizationEntry();
1:                         entry.setDestination(dest);
1:                         entries.put(dest, entry);
1:                     }
1:                 }
1:                 
1:                 break;
1:             default:
1:                 // handle unknown entry
1:                 throw new IllegalArgumentException("Unknown destination type " + destinationType);
1:         }
1:         
1:         return entry;
1:     /**
0:      * Applies the policy from the directory to the given entry within the context of the provided
0:      * permission type.
1:      *
0:      * @param entry the policy entry to apply the policy to
0:      * @param result the results from the directory to apply to the policy entry
0:      * @param permissionType the permission type of the data in the directory
1:      *
0:      * @throws NamingException if there is an error applying the ACL
1:      */
0:     protected void applyACL(AuthorizationEntry entry, SearchResult result,
0:             PermissionType permissionType) throws NamingException {
1:         
1:         // Find members
1:         Attribute memberAttribute = result.getAttributes().get(permissionGroupMemberAttribute);
1:         NamingEnumeration<?> memberAttributeEnum = memberAttribute.getAll();
1:         
1:         
1:         while (memberAttributeEnum.hasMoreElements()) {
1:             String memberDn = (String) memberAttributeEnum.nextElement();
1:             boolean group = false;
1:             boolean user = false;
1:             String principalName = null;
1:             
1:             if (!legacyGroupMapping) {
1:                 // Lookup of member to determine principal type (group or user) and name.
1:                 Attributes memberAttributes;
1:                 try {
0:                     memberAttributes = context.getAttributes(memberDn, 
0:                             new String[] {"objectClass", groupNameAttribute, userNameAttribute});
1:                 } catch (NamingException e) {
0:                     LOG.error(
0:                             "Policy not applied! Unknown member " + memberDn
0:                                     + " in policy entry "
0:                                     + result.getNameInNamespace(), e);
1:                     continue;
1:                 }
1:                 
1:                 Attribute memberEntryObjectClassAttribute = memberAttributes.get("objectClass");
1:                 NamingEnumeration<?> memberEntryObjectClassAttributeEnum = memberEntryObjectClassAttribute.getAll();
1:                 
1:                 while (memberEntryObjectClassAttributeEnum.hasMoreElements()) {
1:                     String objectClass = (String) memberEntryObjectClassAttributeEnum.nextElement();
1:                     
1:                     if (objectClass.equalsIgnoreCase(groupObjectClass)) {
1:                         group = true;
1:                         Attribute name = memberAttributes.get(groupNameAttribute);
1:                         if (name == null) {
0:                             LOG.error("Policy not applied! Group "
0:                                     + memberDn
0:                                     + "does not have name attribute "
0:                                     + groupNameAttribute + " under entry " + result.getNameInNamespace());
1:                             break;
1:                         }
1:                         
1:                         principalName = (String) name.get();
1:                     }
1:                     
1:                     if (objectClass.equalsIgnoreCase(userObjectClass)) {
1:                         user = true;
1:                         Attribute name = memberAttributes.get(userNameAttribute);
1:                         if (name == null) {
0:                             LOG.error("Policy not applied! User "
0:                                     + memberDn + " does not have name attribute "
0:                                     + userNameAttribute + " under entry " + result.getNameInNamespace());
1:                             break;
1:                         }
1:                         
1:                         principalName = (String) name.get();
1:                     }
1:                 }
1:                 
1:             } else {
1:                 group = true;
1:                 principalName = memberDn.replaceAll("(cn|CN)=", "");
1:             }
1:             
1:             if ((!group && !user) || (group && user)) {
0:                 LOG.error("Policy not applied! Can't determine type of member "
0:                         + memberDn + " under entry " + result.getNameInNamespace());
0:             } else if (principalName != null){
1:                 if (group && !user) {
0:                     members.add(new GroupPrincipal(principalName));
1:                 } else if (!group && user) {
1:                     members.add(new UserPrincipal(principalName));
1:                 }
1:             }
1:         }
1:         
1:         try {
1:             applyAcl(entry, permissionType, members);
1:         } catch (Exception e) {
0:             LOG.error(
0:                     "Policy not applied! Error adding principals to ACL under "
0:                             + result.getNameInNamespace(), e);
1:         }
1:     }
1:     
1:     /**
1:      * Applies policy to the entry given the actual principals that will be applied to the policy entry.
1:      *
0:      * @param entry the policy entry to which the policy should be applied
0:      * @param permissionType the type of the permission that the policy will be applied to
0:      * @param acls the principals that represent the actual policy
1:      *
1:      * @throw IllegalArgumentException if {@code permissionType} is unsupported
1:      */
1:     protected void applyAcl(AuthorizationEntry entry, PermissionType permissionType, Set<Object> acls) {
1:         
1:         switch (permissionType) {
1:             case READ:
1:                 entry.setReadACLs(acls);
1:                 break;
1:             case WRITE:
1:                 entry.setWriteACLs(acls);
1:                 break;
1:             case ADMIN:
1:                 entry.setAdminACLs(acls);
1:                 break;
1:             default:
1:                 throw new IllegalArgumentException("Unknown permission " + permissionType + ".");
1:         }
1:     }
1:     
1:     /**
0:      * Parses a DN into the equivalent {@link ActiveMQDestination}.  The default implementation
0:      * expects a format of cn=<PERMISSION_NAME>,ou=<DESTINATION_PATTERN>,.... or 
0:      * ou=<DESTINATION_PATTERN>,.... for permission and destination entries, respectively.
0:      * For example {@code cn=admin,ou=$,ou=...} or {@code ou=$,ou=...}. 
1:      *
0:      * @param dn the DN to parse
0:      * @param destinationType the type of the destination that we are parsing
1:      *
1:      * @return the destination that the DN represents
1:      *
0:      * @throws IllegalArgumentException if {@code destinationType} is {@link DestinationType#TEMP} or
0:      * if the format of {@code dn} is incorrect for for a topic or queue
1:      *
1:      * @see #formatDestination(Rdn, DestinationType)
1:      */
1:     protected ActiveMQDestination formatDestination(LdapName dn, DestinationType destinationType) {
1:         ActiveMQDestination destination = null;
1:         
1:         switch (destinationType) {
1:             case QUEUE:
1:             case TOPIC:
1:                 // There exists a need to deal with both names representing a permission or simply a
0:                 // destination.  As such, we need to determine the proper RDN to work with based
1:                 // on the destination type and the DN size.
1:                 if (dn.size() == (getPrefixLengthForDestinationType(destinationType) + 2)) {
1:                     destination = formatDestination(dn.getRdn(dn.size() - 2), destinationType);
0:                 } else if (dn.size() == (getPrefixLengthForDestinationType(destinationType) + 1)){
1:                     destination = formatDestination(dn.getRdn(dn.size() - 1), destinationType);
1:                 } else {
0:                     throw new IllegalArgumentException(
0:                             "Malformed DN for representing a permission or destination entry.");
1:                 }
1:                 break;
1:             default:
0:                 throw new IllegalArgumentException(
0:                         "Cannot format destination for destination type " + destinationType);
1:         }
1:         
1:         return destination;
1:     }
1:     
1:     /**
0:      * Parses RDN values representing the destination name/pattern and
0:      * destination type into the equivalent {@link ActiveMQDestination}.
1:      * 
1:      * @param destinationName
1:      *            the RDN representing the name or pattern for the destination
1:      * @param destinationType
1:      *            the type of the destination
1:      * 
1:      * @return the destination that the RDN represent
1:      * 
1:      * @throws IllegalArgumentException
1:      *             if {@code destinationType} is not one of {@link DestinationType#TOPIC} or
1:      *             {@link DestinationType#QUEUE}.
1:      * 
1:      * @see #formatDestinationName(Rdn)
1:      * @see #formatDestination(LdapName, DestinationType)
1:      */
1:     protected ActiveMQDestination formatDestination(Rdn destinationName, DestinationType destinationType) {
1:         ActiveMQDestination dest = null;
1:         
1:         switch (destinationType) {
1:             case QUEUE:
1:                 dest = new ActiveMQQueue(formatDestinationName(destinationName));
1:                 break;
1:             case TOPIC:
1:                 dest = new ActiveMQTopic(formatDestinationName(destinationName));
1:                 break;
1:             default:
0:                 throw new IllegalArgumentException("Unknown destination type: "
0:                         + destinationType);
1:         return dest;
1:     }
1: 
1:     /**
0:      * Parses the RDN representing a destination name/pattern into the standard string representation
0:      * of the name/pattern.  This implementation does not care about the type of the RDN such that the RDN could
0:      * be a CN or OU.
1:      *
0:      * @param destinationName the RDN representing the name or pattern for the destination
1:      *
1:      * @see #formatDestination(Rdn, Rdn)
1:      */
1:     protected String formatDestinationName(Rdn destinationName) {
1:         return destinationName.getValue().toString().replaceAll(ANY_DESCENDANT, ">");
1:     }
1:     
1:     /**
0:      * Transcribes an existing set into a new set. Used to make defensive copies
0:      * for concurrent access.
1:      * 
1:      * @param source
1:      *            the source set or {@code null}
1:      * 
0:      * @return a new set containing the same elements as {@code source} or
0:      *         {@code null} if {@code source} is {@code null}
1:      */
1:     protected <T> Set<T> transcribeSet(Set<T> source) {
1:         if (source != null) {
1:             return new HashSet<T>(source);
1:             return null;
1:     
1:     /**
1:      * Returns the filter string for the given permission type.
1:      * 
0:      * @throws IllegalArgumentException if {@code permissionType} is not supported
1:      *
1:      * @see #setAdminPermissionGroupSearchFilter(String)
1:      * @see #setReadPermissionGroupSearchFilter(String)
1:      * @see #setWritePermissionGroupSearchFilter(String)
1:      */
1:     protected String getFilterForPermissionType(PermissionType permissionType) {
1:         String filter = null;
1:         
1:         switch (permissionType) {
1:             case ADMIN:
1:                 filter = adminPermissionGroupSearchFilter;
1:                 break;
1:             case READ:
1:                 filter = readPermissionGroupSearchFilter;
1:                 break;
1:             case WRITE:
1:                 filter = writePermissionGroupSearchFilter;
1:                 break;
1:             default:
1:                 throw new IllegalArgumentException("Unknown permission type " + permissionType);
1:         
1:         return filter;
1:     
1:     /**
1:      * Returns the DN prefix size based on the given destination type.
1:      *
0:      * @throws IllegalArgumentException if {@code destinationType} is not supported
1:      *
1:      * @see #setQueueSearchBase(String)
1:      * @see #setTopicSearchBase(String)
1:      * @see #setTempSearchBase(String)
1:      */
1:     protected int getPrefixLengthForDestinationType(DestinationType destinationType) {
1:         int filter = 0;
1:         
1:         switch (destinationType) {
1:             case QUEUE:
1:                 filter = queuePrefixLength;
1:                 break;
1:             case TOPIC:
1:                 filter = topicPrefixLength;
1:                 break;
1:             case TEMP:
1:                 filter = tempPrefixLength;
1:                 break;
1:             default:
1:                 throw new IllegalArgumentException("Unknown permission type " + destinationType);
1:         }
1:         
1:         return filter;
1:     }
1:     
1:     /**
0:      * Performs a check for updates from the server in the event that synchronous updates are enabled 
0:      * and are the refresh interval has elapsed.
1:      */
1:     protected void checkForUpdates() {
0:         if (!refreshDisabled && (refreshInterval != -1 && System.currentTimeMillis() >= lastUpdated + refreshInterval)) {
0:             setTempDestinationAuthorizationEntry(null);
0:                 LOG.error("Error updating authorization map.  Partial policy "
0:                         + "may be applied until the next successful update.", e);
1:     }
1:     
1:     // Authorization Map
1:     
1:     /**
0:      * Provides synchronous refresh capabilities if so configured before delegating to the super implementation,
0:      * and otherwise simply delegates to the super implementation.
1:      */
1:     @Override
0:     protected synchronized Set<AuthorizationEntry> getAllEntries(ActiveMQDestination destination) {
1:         checkForUpdates();
1:     
1:     /**
0:      * Provides synchronized and defensive access to the admin ACLs for temp destinations as the super
0:      * implementation returns live copies of the ACLs and {@link AuthorizationEntry} is not
0:      * setup for concurrent access.
1:      */
0:     public synchronized Set<Object> getTempDestinationAdminACLs() {
1:         checkForUpdates();
0:         return transcribeSet(super.getTempDestinationAdminACLs());
1:     }
1:     
1:     /**
0:      * Provides synchronized and defensive access to the read ACLs for temp destinations as the super
0:      * implementation returns live copies of the ACLs and {@link AuthorizationEntry} is not
0:      * setup for concurrent access.
1:      */
0:     public synchronized Set<Object> getTempDestinationReadACLs() {
1:         checkForUpdates();
0:         return transcribeSet(super.getTempDestinationReadACLs());
1:     }
1: 
1:     /**
0:      * Provides synchronized and defensive access to the write ACLs for temp destinations as the super
0:      * implementation returns live copies of the ACLs and {@link AuthorizationEntry} is not
0:      * setup for concurrent access.
1:      */
0:     public synchronized Set<Object> getTempDestinationWriteACLs() {
1:         checkForUpdates();
0:         return transcribeSet(super.getTempDestinationWriteACLs());
1:     }
1:     
1:     /**
0:      * Provides synchronized access to the admin ACLs for the destinations as 
0:      * {@link AuthorizationEntry} is not setup for concurrent access.
1:      */
0:     public synchronized Set<Object> getAdminACLs(ActiveMQDestination destination) {
0:         return super.getAdminACLs(destination);
1:     }
1: 
1:     /**
0:      * Provides synchronized access to the read ACLs for the destinations as 
0:      * {@link AuthorizationEntry} is not setup for concurrent access.
1:      */
0:     public synchronized Set<Object> getReadACLs(ActiveMQDestination destination) {
0:         return super.getReadACLs(destination);
1:     }
1: 
1:     /**
0:      * Provides synchronized access to the write ACLs for the destinations as 
0:      * {@link AuthorizationEntry} is not setup for concurrent access.
1:      */
0:     public synchronized Set<Object> getWriteACLs(ActiveMQDestination destination) {
0:         return super.getWriteACLs(destination);
1:     }
1: 
1:     /**
1:      * Handler for new policy entries in the directory.
1:      *
0:      * @param namingEvent the new entry event that occurred 
0:      * @param destinationType the type of the destination to which the event applies
0:      * @param permissionType the permission type to which the event applies
1:      */
0:     public synchronized void objectAdded(NamingEvent namingEvent, DestinationType destinationType,
0:             PermissionType permissionType) {
1:         SearchResult result = (SearchResult) namingEvent.getNewBinding();
1:         
1:         try {
1:             LdapName name = new LdapName(result.getName());
1:             
0:             AuthorizationEntry entry = getEntry(name, destinationType);
1:                
1:             applyACL(entry, result, permissionType);
1:             if (!(entry instanceof TempDestinationAuthorizationEntry)) {
0:                 put(entry.getDestination(), entry);
1:             
1:         } catch (InvalidNameException e) {
0:             LOG.error("Policy not applied!  Error parsing DN for addition of "
0:                     + result.getName(), e);
1:         } catch (Exception e) {
0:             LOG.error("Policy not applied!  Error processing object addition for addition of "
0:                     + result.getName(), e);
1:     /**
1:      * Handler for removed policy entries in the directory.
1:      *
0:      * @param namingEvent the removed entry event that occurred 
0:      * @param destinationType the type of the destination to which the event applies
0:      * @param permissionType the permission type to which the event applies
1:      */
0:     public synchronized void objectRemoved(NamingEvent namingEvent, DestinationType destinationType,
0:             PermissionType permissionType) {
1:         
1:         try {
1:             LdapName name = new LdapName(result.getName());
1:             
0:             AuthorizationEntry entry = getEntry(name, destinationType);
1: 
1:             applyAcl(entry, permissionType, new HashSet<Object>());
1:         } catch (InvalidNameException e) {
0:             LOG.error("Policy not applied!  Error parsing DN for object removal for removal of "
0:                     + result.getName(), e);
1:         } catch (Exception e) {
0:             LOG.error("Policy not applied!  Error processing object removal for removal of "
0:                     + result.getName(), e);
1:     /**
0:      * Handler for renamed policy entries in the directory.  This handler deals with the renaming
0:      * of destination entries as well as permission entries.  If the permission type is not null, it is
0:      * assumed that we are dealing with the renaming of a permission entry.  Otherwise, it is assumed
0:      * that we are dealing with the renaming of a destination entry.
1:      *
0:      * @param namingEvent the renaming entry event that occurred 
0:      * @param destinationType the type of the destination to which the event applies
0:      * @param permissionType the permission type to which the event applies
1:      */
0:     public synchronized void objectRenamed(NamingEvent namingEvent, DestinationType destinationType,
0:             PermissionType permissionType) {
1:         try {
1:             LdapName oldName = new LdapName(oldBinding.getName());
1:             ActiveMQDestination oldDest = formatDestination(oldName, destinationType);
1:     
1:             LdapName newName = new LdapName(newBinding.getName());
1:             ActiveMQDestination newDest = formatDestination(newName, destinationType);
1:             
1:             if (permissionType != null) {
1:                 // Handle the case where a permission entry is being renamed.
1:                 objectRemoved(namingEvent, destinationType, permissionType);
1:                 
1:                 SearchControls controls = new SearchControls();
1:                 controls.setSearchScope(SearchControls.OBJECT_SCOPE);
1:                 
1:                 boolean matchedToType = false;
1:                 
1:                 for (PermissionType newPermissionType : PermissionType.values()) {
0:                     NamingEnumeration<SearchResult> results = context.search(
0:                             newName,
0:                             getFilterForPermissionType(newPermissionType), controls);
1:                     
1:                     if (results.hasMore()) {
1:                         objectAdded(namingEvent, destinationType, newPermissionType);
1:                         matchedToType = true;
1:                         break;
1:                     }
1:                 }
1:                 
1:                 if (!matchedToType) {
0:                     LOG.error("Policy not applied!  Error processing object rename for rename of "
0:                             + oldBinding.getName() + " to " + newBinding.getName()
0:                             + ".  Could not determine permission type of new object.");
1:                 }
1:                 
1:                 // Handle the case where a destination entry is being renamed.
1:                 if (oldDest != null && newDest != null) {
1:                     AuthorizationEntry entry = entries.remove(oldDest);
1:                     if (entry != null) {
1:                         entry.setDestination(newDest);
0:                         put(newDest, entry);
0:                         remove(oldDest, entry);
1:                         entries.put(newDest, entry);
1:                     } else {
0:                         LOG.warn("No authorization entry for " + oldDest);
1:                     }
1:                 }
1:         } catch (InvalidNameException e) {
0:             LOG.error("Policy not applied!  Error parsing DN for object rename for rename of "
0:                     + oldBinding.getName() + " to " + newBinding.getName(), e);
1:         } catch (Exception e) {
0:             LOG.error("Policy not applied!  Error processing object rename for rename of "
0:                     + oldBinding.getName() + " to " + newBinding.getName(), e);
1:     /**
1:      * Handler for changed policy entries in the directory.
1:      *
0:      * @param namingEvent the changed entry event that occurred 
0:      * @param destinationType the type of the destination to which the event applies
0:      * @param permissionType the permission type to which the event applies
1:      */
0:     public synchronized void objectChanged(NamingEvent namingEvent,
0:             DestinationType destinationType, PermissionType permissionType) {
1:         objectRemoved(namingEvent, destinationType, permissionType);
1:         objectAdded(namingEvent, destinationType, permissionType);
1:     /**
1:      * Handler for exception events from the registry.
1:      *
0:      * @param namingExceptionEvent the exception event
1:      */
1:         LOG.error("Caught unexpected exception.", namingExceptionEvent.getException());
1:     
1:     // Init / Destroy
1:     
1:     
1:     @Override
1:     public void destroy() throws Exception {
1:         if (eventContext != null) {
1:             eventContext.close();
1:             eventContext = null;
1:         }
1:         
1:         if (context != null) {
1:             context.close();
1:             context = null;
1:         }
1:     }
1:     // Getters and Setters
/////////////////////////////////////////////////////////////////////////
0:     
1:     public String getQueueSearchBase() {
1:         return queueSearchBase;
1:     public void setQueueSearchBase(String queueSearchBase) {
1:         try {
1:             LdapName baseName = new LdapName(queueSearchBase);
1:             queuePrefixLength = baseName.size();
1:             this.queueSearchBase = queueSearchBase;
1:         } catch (InvalidNameException e) {
1:             throw new IllegalArgumentException("Invalid base DN value " + queueSearchBase, e);
1:         }
1:     public String getTopicSearchBase() {
1:         return topicSearchBase;
1:     }
0: 
1:     public void setTopicSearchBase(String topicSearchBase) {
1:         try {
1:             LdapName baseName = new LdapName(topicSearchBase);
1:             topicPrefixLength = baseName.size();
1:             this.topicSearchBase = topicSearchBase;
1:         } catch (InvalidNameException e) {
1:             throw new IllegalArgumentException("Invalid base DN value " + topicSearchBase, e);
1:         }
1:     }
0: 
1:     public String getTempSearchBase() {
1:         return tempSearchBase;
1:     }
0: 
1:     public void setTempSearchBase(String tempSearchBase) {
1:         try {
1:             LdapName baseName = new LdapName(tempSearchBase);
1:             tempPrefixLength = baseName.size();
1:             this.tempSearchBase = tempSearchBase;
1:         } catch (InvalidNameException e) {
1:             throw new IllegalArgumentException("Invalid base DN value " + tempSearchBase, e);
1:         }
1:     }
0: 
1:     public String getPermissionGroupMemberAttribute() {
1:         return permissionGroupMemberAttribute;
1:     }
0: 
0:     public void setPermissionGroupMemberAttribute(
0:             String permissionGroupMemberAttribute) {
1:         this.permissionGroupMemberAttribute = permissionGroupMemberAttribute;
1:     }
0:     
1:     public String getAdminPermissionGroupSearchFilter() {
1:         return adminPermissionGroupSearchFilter;
1:     }
0: 
0:     public void setAdminPermissionGroupSearchFilter(
0:             String adminPermissionGroupSearchFilter) {
1:         this.adminPermissionGroupSearchFilter = adminPermissionGroupSearchFilter;
1:     }
0: 
1:     public String getReadPermissionGroupSearchFilter() {
1:         return readPermissionGroupSearchFilter;
1:     }
0: 
0:     public void setReadPermissionGroupSearchFilter(
0:             String readPermissionGroupSearchFilter) {
1:         this.readPermissionGroupSearchFilter = readPermissionGroupSearchFilter;
1:     }
0: 
1:     public String getWritePermissionGroupSearchFilter() {
1:         return writePermissionGroupSearchFilter;
1:     }
0: 
0:     public void setWritePermissionGroupSearchFilter(
0:             String writePermissionGroupSearchFilter) {
1:         this.writePermissionGroupSearchFilter = writePermissionGroupSearchFilter;
1:     }
0:     
1:     public boolean isLegacyGroupMapping() {
1:         return legacyGroupMapping;
1:     }
0: 
1:     public void setLegacyGroupMapping(boolean legacyGroupMapping) {
1:         this.legacyGroupMapping = legacyGroupMapping;
1:     }
0: 
1:     public String getGroupObjectClass() {
1:         return groupObjectClass;
1:     }
0: 
1:     public void setGroupObjectClass(String groupObjectClass) {
1:         this.groupObjectClass = groupObjectClass;
1:     }
0: 
1:     public String getUserObjectClass() {
1:         return userObjectClass;
1:     }
0: 
1:     public void setUserObjectClass(String userObjectClass) {
1:         this.userObjectClass = userObjectClass;
1:     }
0:     
1:     public String getGroupNameAttribute() {
1:         return groupNameAttribute;
1:     }
0: 
1:     public void setGroupNameAttribute(String groupNameAttribute) {
1:         this.groupNameAttribute = groupNameAttribute;
1:     }
0: 
1:     public String getUserNameAttribute() {
1:         return userNameAttribute;
1:     }
0: 
1:     public void setUserNameAttribute(String userNameAttribute) {
1:         this.userNameAttribute = userNameAttribute;
1:     }
0: 
1:     public boolean isRefreshDisabled() {
1:         return refreshDisabled;
1:     }
0: 
1:     public void setRefreshDisabled(boolean refreshDisabled) {
1:         this.refreshDisabled = refreshDisabled;
1:     }
0:     
/////////////////////////////////////////////////////////////////////////
0:     
1:     protected static enum DestinationType {
0:         QUEUE,
0:         TOPIC,
0:         TEMP;
1:     }
0:     
1:     protected static enum PermissionType {
0:         READ,
0:         WRITE,
0:         ADMIN;
1:     }
0:     
1:     /**
0:      * Listener implementation for directory changes that maps change events to
0:      * destination types.
1:      */
0:     protected class CachedLDAPAuthorizationMapNamespaceChangeListener implements
0:             NamespaceChangeListener, ObjectChangeListener {
0:         
1:         private final DestinationType destinationType;
1:         private final PermissionType permissionType;
0:         
1:         /**
0:          * Creates a new listener.  If {@code permissionType} is {@code null}, add
0:          * and remove events are ignored as they do not directly affect policy state.
0:          * This configuration is used when listening for changes on entries that represent
0:          * destination patterns and not for entries that represent permissions.
0:          *
0:          * @param destinationType the type of the destination being listened for
0:          * @param permissionType the optional permission type being listened for
1:          */
0:         public CachedLDAPAuthorizationMapNamespaceChangeListener(
0:                 DestinationType destinationType, PermissionType permissionType) {
1:             this.destinationType = destinationType;
1:             this.permissionType = permissionType;
1:         }
1:         @Override
1:         public void namingExceptionThrown(NamingExceptionEvent evt) {
0:             CachedLDAPAuthorizationMap.this.namingExceptionThrown(evt);
1:         }
0: 
1:         @Override
1:         public void objectAdded(NamingEvent evt) {
1:             // This test is a hack to work around the fact that Apache DS 2.0 seems to trigger notifications
1:             // for the entire sub-tree even when one-level is the selected search scope.
1:             if (permissionType != null) {
0:                 CachedLDAPAuthorizationMap.this.objectAdded(evt, destinationType, permissionType);
1:             }
1:         }
0: 
1:         @Override
1:         public void objectRemoved(NamingEvent evt) {
1:             // This test is a hack to work around the fact that Apache DS 2.0 seems to trigger notifications
1:             // for the entire sub-tree even when one-level is the selected search scope.
1:             if (permissionType != null) {
0:                 CachedLDAPAuthorizationMap.this.objectRemoved(evt, destinationType, permissionType);
1:             }
1:         }
0: 
1:         @Override
1:         public void objectRenamed(NamingEvent evt) {
0:             CachedLDAPAuthorizationMap.this.objectRenamed(evt, destinationType, permissionType);
1:         }
0: 
1:         @Override
1:         public void objectChanged(NamingEvent evt) {
1:             // This test is a hack to work around the fact that Apache DS 2.0 seems to trigger notifications
1:             // for the entire sub-tree even when one-level is the selected search scope.
1:             if (permissionType != null) {
0:                 CachedLDAPAuthorizationMap.this.objectChanged(evt, destinationType, permissionType);
1:             }
1:         }
1:     }
1: }
commit:01bc7fa
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
0: /**
0:  * A {@link DefaultAuthorizationMap} implementation which uses LDAP to initialize and update
0:  *
0:  * @org.apache.xbean.XBean
0:  *
0:  */
commit:56a7001
/////////////////////////////////////////////////////////////////////////
0: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
0:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
1: package org.apache.activemq.security;
0: 
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.command.ActiveMQTopic;
0: import org.apache.activemq.filter.DestinationMapNode;
0: import org.apache.activemq.filter.DestinationNode;
0: import org.apache.activemq.jaas.GroupPrincipal;
0: import org.apache.activemq.security.AuthorizationEntry;
0: import org.apache.activemq.security.DefaultAuthorizationMap;
0: import org.apache.activemq.security.TempDestinationAuthorizationEntry;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
0: import org.springframework.beans.factory.InitializingBean;
0: 
0: import javax.naming.Binding;
0: import javax.naming.Context;
0: import javax.naming.NamingEnumeration;
0: import javax.naming.NamingException;
0: import javax.naming.directory.*;
0: import javax.naming.event.*;
0: import java.util.*;
0: 
0: public class CachedLDAPAuthorizationMap extends DefaultAuthorizationMap implements NamespaceChangeListener,
0:         ObjectChangeListener, InitializingBean {
0: 
0:     private static final Logger LOG = LoggerFactory.getLogger(CachedLDAPAuthorizationMap.class);
0: 
0: 
0:     private String initialContextFactory = "com.sun.jndi.ldap.LdapCtxFactory";
1:     private String connectionURL = "ldap://localhost:1024";
1:     private String connectionUsername = "uid=admin,ou=system";
1:     private String connectionPassword = "secret";
1:     private String connectionProtocol = "s";
1:     private String authentication = "simple";
0: 
0:     private String baseDn = "ou=system";
0:     private int cnsLength = 5;
0: 
1:     private int refreshInterval = -1;
0:     private long lastUpdated;
0: 
1:     private static String ANY_DESCENDANT = "\\$";
0: 
0:     private DirContext context;
1:     private EventDirContext eventContext;
0: 
1:     protected DirContext open() throws NamingException {
0:         if (context != null) {
0:             return context;
1:         }
0: 
0:         try {
0:             Hashtable<String, String> env = new Hashtable<String, String>();
0:             env.put(Context.INITIAL_CONTEXT_FACTORY, initialContextFactory);
0:             if (connectionUsername != null || !"".equals(connectionUsername)) {
0:                 env.put(Context.SECURITY_PRINCIPAL, connectionUsername);
1:             }
0:             if (connectionPassword != null || !"".equals(connectionPassword)) {
0:                 env.put(Context.SECURITY_CREDENTIALS, connectionPassword);
1:             }
0:             env.put(Context.SECURITY_PROTOCOL, connectionProtocol);
0:             env.put(Context.PROVIDER_URL, connectionURL);
0:             env.put(Context.SECURITY_AUTHENTICATION, authentication);
0:             context = new InitialDirContext(env);
0: 
0: 
0:             if (refreshInterval == -1) {
0:                 eventContext = ((EventDirContext)context.lookup(""));
1:                 final SearchControls constraints = new SearchControls();
1:                 constraints.setSearchScope(SearchControls.SUBTREE_SCOPE);
0:                 LOG.debug("Listening for: " + "'ou=Destination,ou=ActiveMQ," + baseDn + "'");
0:                 eventContext.addNamingListener("ou=Destination,ou=ActiveMQ," + baseDn, "cn=*", constraints, this);
1:             }
1:         } catch (NamingException e) {
0:             LOG.error(e.toString());
1:             throw e;
1:         }
0:         return context;
1:     }
0: 
0: 
0:     HashMap<ActiveMQDestination, AuthorizationEntry> entries = new HashMap<ActiveMQDestination, AuthorizationEntry>();
0: 
0: 
0:     public void query() throws Exception {
0:         try {
0:             context = open();
1:         } catch (NamingException e) {
0:             LOG.error(e.toString());
1:         }
0: 
1:         final SearchControls constraints = new SearchControls();
1:         constraints.setSearchScope(SearchControls.SUBTREE_SCOPE);
0: 
0:         NamingEnumeration results = context.search("ou=Destination,ou=ActiveMQ," + baseDn, "(|(cn=admin)(cn=write)(cn=read))", constraints);
0:         while (results.hasMore()) {
0:             SearchResult result = (SearchResult) results.next();
0:             AuthorizationEntry entry = getEntry(result.getNameInNamespace());
0:             applyACL(entry, result);
1:         }
0: 
0:         setEntries(new ArrayList(entries.values()));
1:         updated();
1:     }
0: 
1:     protected void updated() {
1:         lastUpdated = System.currentTimeMillis();
1:     }
0: 
0:     protected AuthorizationEntry getEntry(String name) {;
0:             String[] cns = name.split(",");
0: 
0:             // handle temp entry
0:             if (cns.length == cnsLength && cns[1].equals("ou=Temp")) {
0:                 TempDestinationAuthorizationEntry tempEntry = getTempDestinationAuthorizationEntry();
0:                 if (tempEntry == null) {
0:                     tempEntry = new TempDestinationAuthorizationEntry();
0:                     setTempDestinationAuthorizationEntry(tempEntry);
1:                 }
0:                 return tempEntry;
1:             }
0: 
0:             // handle regular destinations
0:             if (cns.length != (cnsLength + 1)) {
0:                 LOG.warn("Policy not applied! Wrong cn for authorization entry " + name);
1:             }
0: 
0:             ActiveMQDestination dest = formatDestination(cns[1], cns[2]);
0: 
0:             if (dest != null) {
0:                 AuthorizationEntry entry = entries.get(dest);
1:                 if (entry == null) {
0:                     entry = new AuthorizationEntry();
0:                     entry.setDestination(dest);
0:                     entries.put(dest, entry);
1:                 }
0:                 return entry;
1:             } else {
0:                 return null;
1:             }
1:     }
0: 
0:     protected ActiveMQDestination formatDestination(String destinationName, String destinationType) {
0:             ActiveMQDestination dest = null;
0:             if (destinationType.equalsIgnoreCase("ou=queue")) {
0:                dest = new ActiveMQQueue(formatDestinationName(destinationName));
0:             } else if (destinationType.equalsIgnoreCase("ou=topic")) {
0:                dest = new ActiveMQTopic(formatDestinationName(destinationName));
1:             } else {
0:                 LOG.warn("Policy not applied! Unknown destination type " + destinationType);
1:             }
0:             return dest;
1:     }
0: 
0:     protected void applyACL(AuthorizationEntry entry, SearchResult result) throws NamingException {
0:         // find members
0:         Attribute cn = result.getAttributes().get("cn");
0:         Attribute member = result.getAttributes().get("member");
0:         NamingEnumeration memberEnum = member.getAll();
0:         HashSet members = new HashSet();
0:         while (memberEnum.hasMoreElements()) {
0:             String elem = (String) memberEnum.nextElement();
0:             members.add(new GroupPrincipal(elem.replaceAll("cn=", "")));
1:         }
0: 
0:         // apply privilege
0:         if (cn.get().equals("admin")) {
0:             entry.setAdminACLs(members);
0:         } else if (cn.get().equals("write")) {
0:             entry.setWriteACLs(members);
0:         } else if (cn.get().equals("read")) {
0:             entry.setReadACLs(members);
1:         } else {
0:             LOG.warn("Policy not applied! Unknown privilege " + result.getName());
1:         }
1:     }
0: 
0:     protected String formatDestinationName(String cn) {
0:         return cn.replaceFirst("cn=", "").replaceAll(ANY_DESCENDANT, ">");
1:     }
0: 
0:     protected boolean isPriviledge(Binding binding) {
0:         String name = binding.getName();
0:         if (name.startsWith("cn=admin") || name.startsWith("cn=write") || name.startsWith("cn=read")) {
0:             return true;
1:         } else {
0:             return false;
1:         }
1:     }
0: 
0:     @Override
0:     protected Set<AuthorizationEntry> getAllEntries(ActiveMQDestination destination) {
0:         if (refreshInterval != -1 && System.currentTimeMillis() >= lastUpdated + refreshInterval) {
0: 
0:             reset();
0:             entries.clear();
0: 
0:             LOG.debug("Updating authorization map!");
0:             try {
1:                 query();
0:             } catch (Exception e) {
0:                 LOG.error("Error updating authorization map", e);
1:             }
1:         }
0: 
0:         return super.getAllEntries(destination);
1:     }
0: 
0:     @Override
0:     public void objectAdded(NamingEvent namingEvent) {
0:         LOG.debug("Adding object: " + namingEvent.getNewBinding());
0:         SearchResult result = (SearchResult)namingEvent.getNewBinding();
0:         String cn = null;
0:         if (!isPriviledge(result)) return;
0:         AuthorizationEntry entry = getEntry(result.getName());
0:         if (entry != null) {
0:             try {
0:                 applyACL(entry, result);
0:                 if (!(entry instanceof TempDestinationAuthorizationEntry)) {
0:                     put(entry.getDestination(), entry);
1:                 }
0:             } catch (NamingException ne) {
0:                 LOG.warn("Unable to add entry", ne);
1:             }
1:         }
1:     }
0: 
0:     @Override
0:     public void objectRemoved(NamingEvent namingEvent) {
0:         LOG.debug("Removing object: " + namingEvent.getOldBinding());
1:         Binding result = namingEvent.getOldBinding();
0:         if (!isPriviledge(result)) return;
0:         AuthorizationEntry entry = getEntry(result.getName());
0:         String[] cns = result.getName().split(",");
0:         if (!isPriviledge(result)) return;
0:         if (cns[0].equalsIgnoreCase("cn=admin")) {
0:             entry.setAdminACLs(new HashSet());
0:         } else if (cns[0].equalsIgnoreCase("cn=write")) {
0:             entry.setWriteACLs(new HashSet());
0:         } else if (cns[0].equalsIgnoreCase("cn=read")) {
0:             entry.setReadACLs(new HashSet());
1:         } else {
0:             LOG.warn("Policy not removed! Unknown privilege " + result.getName());
1:         }
1:     }
0: 
0:     @Override
0:     public void objectRenamed(NamingEvent namingEvent) {
1:         Binding oldBinding = namingEvent.getOldBinding();
1:         Binding newBinding = namingEvent.getNewBinding();
0:         LOG.debug("Renaming object: " + oldBinding + " to " + newBinding);
0: 
0:         String[] oldCns = oldBinding.getName().split(",");
0:         ActiveMQDestination oldDest = formatDestination(oldCns[0], oldCns[1]);
0: 
0:         String[] newCns = newBinding.getName().split(",");
0:         ActiveMQDestination newDest = formatDestination(newCns[0], newCns[1]);
0: 
0:         if (oldDest != null && newDest != null) {
0:             AuthorizationEntry entry = entries.remove(oldDest);
0:             if (entry != null) {
0:                 entry.setDestination(newDest);
0:                 put(newDest, entry);
0:                 remove(oldDest, entry);
1:             } else {
0:                 LOG.warn("No authorization entry for " + oldDest);
1:             }
1:         }
1:     }
0: 
0:     @Override
0:     public void objectChanged(NamingEvent namingEvent) {
0:         LOG.debug("Changing object " + namingEvent.getOldBinding() + " to " + namingEvent.getNewBinding());
0:         objectRemoved(namingEvent);
0:         objectAdded(namingEvent);
1:     }
0: 
0:     @Override
1:     public void namingExceptionThrown(NamingExceptionEvent namingExceptionEvent) {
0:         LOG.error("Caught Unexpected Exception", namingExceptionEvent.getException());
1:     }
0: 
0:     // init
0: 
0:     @Override
1:     public void afterPropertiesSet() throws Exception {
1:         query();
1:     }
0: 
0:     // getters and setters
0: 
1:     public String getConnectionURL() {
1:         return connectionURL;
1:     }
0: 
1:     public void setConnectionURL(String connectionURL) {
1:         this.connectionURL = connectionURL;
1:     }
0: 
1:     public String getConnectionUsername() {
1:         return connectionUsername;
1:     }
0: 
1:     public void setConnectionUsername(String connectionUsername) {
1:         this.connectionUsername = connectionUsername;
1:     }
0: 
1:     public String getConnectionPassword() {
1:         return connectionPassword;
1:     }
0: 
1:     public void setConnectionPassword(String connectionPassword) {
1:         this.connectionPassword = connectionPassword;
1:     }
0: 
1:     public String getConnectionProtocol() {
1:         return connectionProtocol;
1:     }
0: 
1:     public void setConnectionProtocol(String connectionProtocol) {
1:         this.connectionProtocol = connectionProtocol;
1:     }
0: 
1:     public String getAuthentication() {
1:         return authentication;
1:     }
0: 
1:     public void setAuthentication(String authentication) {
1:         this.authentication = authentication;
1:     }
0: 
0:     public String getBaseDn() {
0:         return baseDn;
1:     }
0: 
0:     public void setBaseDn(String baseDn) {
0:         this.baseDn = baseDn;
0:         cnsLength = baseDn.split(",").length + 4;
1:     }
0: 
1:     public int getRefreshInterval() {
1:         return refreshInterval;
1:     }
0: 
1:     public void setRefreshInterval(int refreshInterval) {
1:         this.refreshInterval = refreshInterval;
1:     }
1: }
0: 
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:7c9fec6
/////////////////////////////////////////////////////////////////////////
0: import javax.naming.*;
0: public class SimpleCachedLDAPAuthorizationMap extends DefaultAuthorizationMap {
1:     private static final Logger LOG = LoggerFactory.getLogger(SimpleCachedLDAPAuthorizationMap.class);
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
1:             SimpleCachedLDAPAuthorizationMap.this.namingExceptionThrown(evt);
/////////////////////////////////////////////////////////////////////////
1:                 SimpleCachedLDAPAuthorizationMap.this.objectAdded(evt, destinationType, permissionType);
/////////////////////////////////////////////////////////////////////////
1:                 SimpleCachedLDAPAuthorizationMap.this.objectRemoved(evt, destinationType, permissionType);
1:             SimpleCachedLDAPAuthorizationMap.this.objectRenamed(evt, destinationType, permissionType);
/////////////////////////////////////////////////////////////////////////
1:                 SimpleCachedLDAPAuthorizationMap.this.objectChanged(evt, destinationType, permissionType);
commit:58aca86
============================================================================