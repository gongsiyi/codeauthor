1:72839b7: /**
1:72839b7:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:72839b7:  * contributor license agreements.  See the NOTICE file distributed with
1:72839b7:  * this work for additional information regarding copyright ownership.
1:72839b7:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:72839b7:  * (the "License"); you may not use this file except in compliance with
1:72839b7:  * the License.  You may obtain a copy of the License at
1:72839b7:  *
1:72839b7:  *      http://www.apache.org/licenses/LICENSE-2.0
1:72839b7:  *
1:72839b7:  * Unless required by applicable law or agreed to in writing, software
1:72839b7:  * distributed under the License is distributed on an "AS IS" BASIS,
1:72839b7:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:72839b7:  * See the License for the specific language governing permissions and
1:72839b7:  * limitations under the License.
1:72839b7:  */
1:72839b7: package org.apache.activemq.transport.amqp.client;
2:72839b7: 
1:4c838c5: import java.io.IOException;
1:4a1c05b: import java.util.Map;
1:72839b7: import java.util.concurrent.ScheduledExecutorService;
1:4c838c5: import java.util.concurrent.atomic.AtomicBoolean;
1:72839b7: import java.util.concurrent.atomic.AtomicLong;
1:72839b7: 
1:8448cf1: import org.apache.activemq.transport.amqp.client.util.AsyncResult;
1:72839b7: import org.apache.activemq.transport.amqp.client.util.ClientFuture;
1:fddbac2: import org.apache.activemq.transport.amqp.client.util.UnmodifiableProxy;
1:4a1c05b: import org.apache.qpid.proton.amqp.Symbol;
1:ca456c4: import org.apache.qpid.proton.amqp.messaging.Source;
1:8e6a404: import org.apache.qpid.proton.amqp.messaging.Target;
1:381a1ae: import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;
1:381a1ae: import org.apache.qpid.proton.amqp.transport.SenderSettleMode;
1:72839b7: import org.apache.qpid.proton.engine.Connection;
1:72839b7: import org.apache.qpid.proton.engine.Session;
1:72839b7: 
1:72839b7: /**
1:72839b7:  * Session class that manages a Proton session endpoint.
1:72839b7:  */
1:72839b7: public class AmqpSession extends AmqpAbstractResource<Session> {
1:72839b7: 
1:72839b7:     private final AtomicLong receiverIdGenerator = new AtomicLong();
1:72839b7:     private final AtomicLong senderIdGenerator = new AtomicLong();
1:72839b7: 
1:72839b7:     private final AmqpConnection connection;
1:72839b7:     private final String sessionId;
1:272fb2b:     private final AmqpTransactionContext txContext;
1:4c838c5:     private final AtomicBoolean closed = new AtomicBoolean();
1:72839b7: 
1:72839b7:     /**
1:72839b7:      * Create a new session instance.
1:72839b7:      *
1:72839b7:      * @param connection
1:72839b7:      * 		  The parent connection that created the session.
1:72839b7:      * @param sessionId
1:72839b7:      *        The unique ID value assigned to this session.
1:72839b7:      */
1:72839b7:     public AmqpSession(AmqpConnection connection, String sessionId) {
1:72839b7:         this.connection = connection;
1:72839b7:         this.sessionId = sessionId;
1:272fb2b:         this.txContext = new AmqpTransactionContext(this);
2:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:4c838c5:      * Close the receiver, a closed receiver will throw exceptions if any further send
1:4c838c5:      * calls are made.
1:4c838c5:      *
1:4c838c5:      * @throws IOException if an error occurs while closing the receiver.
1:4c838c5:      */
1:4c838c5:     public void close() throws IOException {
1:4c838c5:         if (closed.compareAndSet(false, true)) {
1:4c838c5:             final ClientFuture request = new ClientFuture();
1:4c838c5:             getScheduler().execute(new Runnable() {
1:4c838c5: 
1:4c838c5:                 @Override
1:4c838c5:                 public void run() {
1:4c838c5:                     checkClosed();
1:4c838c5:                     close(request);
1:4c838c5:                     pumpToProtonTransport(request);
1:4c838c5:                 }
1:4c838c5:             });
1:4c838c5: 
1:4c838c5:             request.sync();
1:4c838c5:         }
1:4c838c5:     }
1:4c838c5: 
1:4c838c5:     /**
1:0050f22:      * Create an anonymous sender.
1:0050f22:      *
1:0050f22:      * @return a newly created sender that is ready for use.
1:0050f22:      *
1:0050f22:      * @throws Exception if an error occurs while creating the sender.
1:0050f22:      */
1:0050f22:     public AmqpSender createSender() throws Exception {
1:4a1c05b:         return createSender(null, false, null, null, null);
1:0050f22:     }
1:0050f22: 
1:0050f22:     /**
1:72839b7:      * Create a sender instance using the given address
1:8e6a404:      *
2:72839b7:      * @param address
1:381a1ae:      *        the address to which the sender will produce its messages.
1:b3bf8e7:      *
1:72839b7:      * @return a newly created sender that is ready for use.
1:934ad44:      *
1:72839b7:      * @throws Exception if an error occurs while creating the sender.
1:72839b7:      */
1:72839b7:     public AmqpSender createSender(final String address) throws Exception {
1:4a1c05b:         return createSender(address, false, null, null, null);
1:4a1c05b:     }
1:4a1c05b: 
1:4a1c05b:     /**
1:4a1c05b:      * Create a sender instance using the given address
1:4a1c05b:      *
1:4a1c05b:      * @param address
1:4a1c05b:      *        the address to which the sender will produce its messages.
1:4a1c05b:      * @param desiredCapabilities
1:4a1c05b:      *        the capabilities that the caller wants the remote to support.
1:4a1c05b:      *
1:4a1c05b:      * @return a newly created sender that is ready for use.
1:4a1c05b:      *
1:4a1c05b:      * @throws Exception if an error occurs while creating the sender.
1:4a1c05b:      */
1:4a1c05b:     public AmqpSender createSender(final String address, Symbol[] desiredCapabilities) throws Exception {
1:4a1c05b:         return createSender(address, false, desiredCapabilities, null, null);
1:4a1c05b:     }
1:4a1c05b: 
1:4a1c05b:     /**
1:4a1c05b:      * Create a sender instance using the given address
1:4a1c05b:      *
1:4a1c05b:      * @param address
1:4a1c05b:      *        the address to which the sender will produce its messages.
1:4a1c05b:      * @param presettle
1:4a1c05b:      *        controls if the created sender produces message that have already been marked settled.
1:4a1c05b:      *
1:4a1c05b:      * @return a newly created sender that is ready for use.
1:4a1c05b:      *
1:4a1c05b:      * @throws Exception if an error occurs while creating the sender.
1:4a1c05b:      */
1:4a1c05b:     public AmqpSender createSender(final String address, boolean presettle) throws Exception {
1:4a1c05b:         return createSender(address, presettle, null, null, null);
1:b3bf8e7:     }
1:b3bf8e7: 
1:b3bf8e7:     /**
1:b3bf8e7:      * Create a sender instance using the given address
1:72839b7:      *
1:b3bf8e7:      * @param address
1:b3bf8e7:      *        the address to which the sender will produce its messages.
1:381a1ae:      * @param senderSettlementMode
1:381a1ae:      *        controls the settlement mode used by the created Sender
1:381a1ae:      * @param receiverSettlementMode
1:381a1ae:      *        controls the desired settlement mode used by the remote Receiver
1:381a1ae:      *
1:381a1ae:      * @return a newly created sender that is ready for use.
1:381a1ae:      *
1:381a1ae:      * @throws Exception if an error occurs while creating the sender.
1:381a1ae:      */
1:381a1ae:     public AmqpSender createSender(final String address, final SenderSettleMode senderMode, ReceiverSettleMode receiverMode) throws Exception {
1:381a1ae:         checkClosed();
1:381a1ae: 
1:381a1ae:         final AmqpSender sender = new AmqpSender(AmqpSession.this, address, getNextSenderId(), senderMode, receiverMode);
1:381a1ae:         final ClientFuture request = new ClientFuture();
1:381a1ae: 
1:381a1ae:         connection.getScheduler().execute(new Runnable() {
1:381a1ae: 
1:381a1ae:             @Override
1:381a1ae:             public void run() {
1:381a1ae:                 checkClosed();
1:381a1ae:                 sender.setStateInspector(getStateInspector());
1:381a1ae:                 sender.open(request);
1:381a1ae:                 pumpToProtonTransport(request);
1:381a1ae:             }
1:381a1ae:         });
1:381a1ae: 
1:381a1ae:         request.sync();
1:381a1ae: 
1:381a1ae:         return sender;
1:381a1ae:     }
1:381a1ae: 
1:381a1ae:     /**
1:381a1ae:      * Create a sender instance using the given address
1:381a1ae:      *
1:381a1ae:      * @param address
1:b3bf8e7:      * 	      the address to which the sender will produce its messages.
1:b3bf8e7:      * @param presettle
1:b3bf8e7:      *        controls if the created sender produces message that have already been marked settled.
1:4a1c05b:      * @param desiredCapabilities
1:4a1c05b:      *        the capabilities that the caller wants the remote to support.
1:4a1c05b:      * @param offeredCapabilities
1:4a1c05b:      *        the capabilities that the caller wants the advertise support for.
1:4a1c05b:      * @param properties
1:4a1c05b:      *        the properties to send as part of the sender open.
1:b3bf8e7:      *
1:b3bf8e7:      * @return a newly created sender that is ready for use.
1:b3bf8e7:      *
1:b3bf8e7:      * @throws Exception if an error occurs while creating the sender.
1:b3bf8e7:      */
1:4a1c05b:     public AmqpSender createSender(final String address, boolean presettle, Symbol[] desiredCapabilities, Symbol[] offeredCapabilities, Map<Symbol, Object> properties) throws Exception {
1:72839b7:         checkClosed();
1:72839b7: 
1:72839b7:         final AmqpSender sender = new AmqpSender(AmqpSession.this, address, getNextSenderId());
1:b3bf8e7:         sender.setPresettle(presettle);
1:4a1c05b:         sender.setDesiredCapabilities(desiredCapabilities);
1:4a1c05b:         sender.setOfferedCapabilities(offeredCapabilities);
1:4a1c05b:         sender.setProperties(properties);
1:4a1c05b: 
2:72839b7:         final ClientFuture request = new ClientFuture();
1:72839b7: 
1:72839b7:         connection.getScheduler().execute(new Runnable() {
1:72839b7: 
2:72839b7:             @Override
1:72839b7:             public void run() {
1:72839b7:                 checkClosed();
1:1a0f73e:                 sender.setStateInspector(getStateInspector());
1:72839b7:                 sender.open(request);
1:8448cf1:                 pumpToProtonTransport(request);
1:72839b7:             }
1:72839b7:         });
1:72839b7: 
1:72839b7:         request.sync();
1:72839b7: 
1:72839b7:         return sender;
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:8e6a404:      * Create a sender instance using the given Target
1:8e6a404:      *
1:8e6a404:      * @param target
1:24a7941:      *        the caller created and configured Target used to create the sender link.
1:24a7941:      *
1:8e6a404:      * @return a newly created sender that is ready for use.
1:8e6a404:      *
1:8e6a404:      * @throws Exception if an error occurs while creating the receiver.
1:8e6a404:      */
1:8e6a404:     public AmqpSender createSender(Target target) throws Exception {
1:24a7941:         return createSender(target, getNextSenderId());
1:24a7941:     }
1:24a7941: 
1:24a7941:     /**
1:24a7941:      * Create a sender instance using the given Target
1:4a1c05b:      *
1:24a7941:      * @param target
1:24a7941:      *        the caller created and configured Target used to create the sender link.
1:24a7941:      * @param sender
1:24a7941:      *        the sender ID to assign to the newly created Sender.
1:24a7941:      *
1:24a7941:      * @return a newly created sender that is ready for use.
1:24a7941:      *
1:24a7941:      * @throws Exception if an error occurs while creating the receiver.
1:24a7941:      */
1:24a7941:     public AmqpSender createSender(Target target, String senderId) throws Exception {
1:4a1c05b:         return createSender(target, senderId, null, null, null);
1:4a1c05b:     }
1:4a1c05b: 
1:4a1c05b:     /**
1:4a1c05b:      * Create a sender instance using the given Target
1:4a1c05b:      *
1:4a1c05b:      * @param target
1:4a1c05b:      *        the caller created and configured Target used to create the sender link.
1:4a1c05b:      * @param sender
1:4a1c05b:      *        the sender ID to assign to the newly created Sender.
1:4a1c05b:      * @param desiredCapabilities
1:4a1c05b:      *        the capabilities that the caller wants the remote to support.
1:4a1c05b:      * @param offeredCapabilities
1:4a1c05b:      *        the capabilities that the caller wants the advertise support for.
1:4a1c05b:      * @param properties
1:4a1c05b:      *        the properties to send as part of the sender open.
1:4a1c05b:      *
1:4a1c05b:      * @return a newly created sender that is ready for use.
1:72839b7:      *
1:4a1c05b:      * @throws Exception if an error occurs while creating the receiver.
1:4a1c05b:      */
1:4a1c05b:     public AmqpSender createSender(Target target, String senderId, Symbol[] desiredCapabilities, Symbol[] offeredCapabilities, Map<Symbol, Object> properties) throws Exception {
1:8e6a404:         checkClosed();
1:8e6a404: 
1:24a7941:         final AmqpSender sender = new AmqpSender(AmqpSession.this, target, senderId);
1:4a1c05b:         sender.setDesiredCapabilities(desiredCapabilities);
1:4a1c05b:         sender.setOfferedCapabilities(offeredCapabilities);
1:4a1c05b:         sender.setProperties(properties);
1:4a1c05b: 
1:8e6a404:         final ClientFuture request = new ClientFuture();
1:8e6a404: 
1:8e6a404:         connection.getScheduler().execute(new Runnable() {
1:8e6a404: 
1:8e6a404:             @Override
1:8e6a404:             public void run() {
1:8e6a404:                 checkClosed();
1:8e6a404:                 sender.setStateInspector(getStateInspector());
1:8e6a404:                 sender.open(request);
1:8448cf1:                 pumpToProtonTransport(request);
1:8e6a404:             }
1:8e6a404:         });
1:8e6a404: 
1:8e6a404:         request.sync();
1:8e6a404: 
1:8e6a404:         return sender;
1:8e6a404:     }
1:8e6a404: 
1:8e6a404:     /**
1:381a1ae:      * Create a receiver instance using the given address
1:381a1ae:      *
1:381a1ae:      * @param address
1:381a1ae:      *        the address to which the receiver will subscribe for its messages.
1:ca456c4:      *
1:72839b7:      * @return a newly created receiver that is ready for use.
1:72839b7:      *
1:72839b7:      * @throws Exception if an error occurs while creating the receiver.
1:72839b7:      */
1:72839b7:     public AmqpReceiver createReceiver(String address) throws Exception {
1:1a0f73e:         return createReceiver(address, null, false);
1:1a0f73e:     }
1:1a0f73e: 
1:1a0f73e:     /**
1:ca456c4:      * Create a receiver instance using the given address
1:1a0f73e:      *
1:ca456c4:      * @param address
1:ca456c4:      *        the address to which the receiver will subscribe for its messages.
1:1a0f73e:      * @param selector
1:1a0f73e:      *        the JMS selector to use for the subscription
1:1a0f73e:      *
1:1a0f73e:      * @return a newly created receiver that is ready for use.
1:1a0f73e:      *
1:1a0f73e:      * @throws Exception if an error occurs while creating the receiver.
1:1a0f73e:      */
1:1a0f73e:     public AmqpReceiver createReceiver(String address, String selector) throws Exception {
1:1a0f73e:         return createReceiver(address, selector, false);
1:1a0f73e:     }
1:1a0f73e: 
1:1a0f73e:     /**
1:1a0f73e:      * Create a receiver instance using the given address
1:1a0f73e:      *
1:1a0f73e:      * @param address
1:1a0f73e:      * 	      the address to which the receiver will subscribe for its messages.
1:1a0f73e:      * @param selector
1:1a0f73e:      *        the JMS selector to use for the subscription
1:1a0f73e:      * @param noLocal
1:1a0f73e:      *        should the subscription have messages from its connection filtered.
1:1a0f73e:      *
1:1a0f73e:      * @return a newly created receiver that is ready for use.
1:1a0f73e:      *
1:1a0f73e:      * @throws Exception if an error occurs while creating the receiver.
1:1a0f73e:      */
1:1a0f73e:     public AmqpReceiver createReceiver(String address, String selector, boolean noLocal) throws Exception {
1:db71b43:         return createReceiver(address, selector, noLocal, false);
1:db71b43:     }
1:db71b43: 
1:db71b43:     /**
1:db71b43:      * Create a receiver instance using the given address
1:db71b43:      *
1:db71b43:      * @param address
1:db71b43:      *        the address to which the receiver will subscribe for its messages.
1:db71b43:      * @param selector
1:db71b43:      *        the JMS selector to use for the subscription
1:db71b43:      * @param noLocal
1:db71b43:      *        should the subscription have messages from its connection filtered.
1:db71b43:      * @param presettle
1:db71b43:      *        should the receiver be created with a settled sender mode.
1:db71b43:      *
1:db71b43:      * @return a newly created receiver that is ready for use.
1:db71b43:      *
1:db71b43:      * @throws Exception if an error occurs while creating the receiver.
1:db71b43:      */
1:db71b43:     public AmqpReceiver createReceiver(String address, String selector, boolean noLocal, boolean presettle) throws Exception {
1:72839b7:         checkClosed();
1:72839b7: 
1:934ad44:         final ClientFuture request = new ClientFuture();
1:1a0f73e:         final AmqpReceiver receiver = new AmqpReceiver(AmqpSession.this, address, getNextReceiverId());
1:1a0f73e: 
1:1a0f73e:         receiver.setNoLocal(noLocal);
1:db71b43:         receiver.setPresettle(presettle);
1:1a0f73e:         if (selector != null && !selector.isEmpty()) {
1:1a0f73e:             receiver.setSelector(selector);
1:1a0f73e:         }
1:934ad44: 
1:72839b7:         connection.getScheduler().execute(new Runnable() {
1:72839b7: 
1:72839b7:             @Override
1:72839b7:             public void run() {
1:72839b7:                 checkClosed();
1:1a0f73e:                 receiver.setStateInspector(getStateInspector());
1:72839b7:                 receiver.open(request);
1:8448cf1:                 pumpToProtonTransport(request);
1:72839b7:             }
1:72839b7:         });
1:72839b7: 
1:72839b7:         request.sync();
1:72839b7: 
1:72839b7:         return receiver;
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:1a0f73e:      * Create a receiver instance using the given address
1:72839b7:      *
1:1a0f73e:      * @param address
1:1a0f73e:      *        the address to which the receiver will subscribe for its messages.
1:381a1ae:      * @param senderSettlementMode
1:381a1ae:      *        controls the desired settlement mode used by the remote Sender
1:381a1ae:      * @param receiverSettlementMode
1:381a1ae:      *        controls the settlement mode used by the created Receiver
1:381a1ae:      *
1:381a1ae:      * @return a newly created receiver that is ready for use.
1:381a1ae:      *
1:381a1ae:      * @throws Exception if an error occurs while creating the receiver.
1:381a1ae:      */
1:381a1ae:     public AmqpReceiver createReceiver(String address, SenderSettleMode senderMode, ReceiverSettleMode receiverMode) throws Exception {
1:381a1ae:         checkClosed();
1:381a1ae: 
1:381a1ae:         final ClientFuture request = new ClientFuture();
1:381a1ae:         final AmqpReceiver receiver = new AmqpReceiver(AmqpSession.this, address, getNextReceiverId(), senderMode, receiverMode);
1:381a1ae: 
1:381a1ae:         connection.getScheduler().execute(new Runnable() {
1:381a1ae: 
1:381a1ae:             @Override
1:381a1ae:             public void run() {
1:381a1ae:                 checkClosed();
1:381a1ae:                 receiver.setStateInspector(getStateInspector());
1:381a1ae:                 receiver.open(request);
1:381a1ae:                 pumpToProtonTransport(request);
1:381a1ae:             }
1:381a1ae:         });
1:381a1ae: 
1:381a1ae:         request.sync();
1:381a1ae: 
1:381a1ae:         return receiver;
1:381a1ae:     }
1:381a1ae: 
1:381a1ae:     /**
1:8e6a404:      * Create a receiver instance using the given Source
1:72839b7:      *
1:ca456c4:      * @param source
1:ca456c4:      *        the caller created and configured Source used to create the receiver link.
1:ca456c4:      *
1:ca456c4:      * @return a newly created receiver that is ready for use.
1:ca456c4:      *
1:ca456c4:      * @throws Exception if an error occurs while creating the receiver.
1:ca456c4:      */
1:ca456c4:     public AmqpReceiver createReceiver(Source source) throws Exception {
1:24a7941:         return createReceiver(source, getNextReceiverId());
1:24a7941:     }
1:24a7941: 
1:24a7941:     /**
1:24a7941:      * Create a receiver instance using the given Source
1:24a7941:      *
1:24a7941:      * @param source
1:24a7941:      *        the caller created and configured Source used to create the receiver link.
1:24a7941:      * @param receivedId
1:24a7941:      *        the ID value to assign to the newly created receiver
1:24a7941:      *
1:24a7941:      * @return a newly created receiver that is ready for use.
1:24a7941:      *
1:24a7941:      * @throws Exception if an error occurs while creating the receiver.
1:24a7941:      */
1:24a7941:     public AmqpReceiver createReceiver(Source source, String receiverId) throws Exception {
1:ca456c4:         checkClosed();
1:ca456c4: 
1:ca456c4:         final ClientFuture request = new ClientFuture();
1:ca456c4:         final AmqpReceiver receiver = new AmqpReceiver(AmqpSession.this, source, getNextReceiverId());
1:ca456c4: 
1:ca456c4:         connection.getScheduler().execute(new Runnable() {
1:ca456c4: 
1:ca456c4:             @Override
1:ca456c4:             public void run() {
1:ca456c4:                 checkClosed();
1:ca456c4:                 receiver.setStateInspector(getStateInspector());
1:ca456c4:                 receiver.open(request);
1:8448cf1:                 pumpToProtonTransport(request);
1:ca456c4:             }
1:ca456c4:         });
1:ca456c4: 
1:ca456c4:         request.sync();
1:ca456c4: 
1:ca456c4:         return receiver;
1:ca456c4:     }
1:ca456c4: 
1:ca456c4:     /**
1:4228e3d:      * Create a receiver instance using the given address that creates a durable subscription.
1:4228e3d:      *
1:934ad44:      * @param address
1:1a0f73e:      *        the address to which the receiver will subscribe for its messages.
1:4228e3d:      * @param subscriptionName
1:934ad44:      *        the name of the subscription that is being created.
1:1a0f73e:      *
1:934ad44:      * @return a newly created receiver that is ready for use.
1:934ad44:      *
1:934ad44:      * @throws Exception if an error occurs while creating the receiver.
1:934ad44:      */
1:934ad44:     public AmqpReceiver createDurableReceiver(String address, String subscriptionName) throws Exception {
1:1a0f73e:         return createDurableReceiver(address, subscriptionName, null, false);
1:1a0f73e:     }
1:1a0f73e: 
1:1a0f73e:     /**
1:1a0f73e:      * Create a receiver instance using the given address that creates a durable subscription.
1:1a0f73e:      *
1:1a0f73e:      * @param address
1:1a0f73e:      *        the address to which the receiver will subscribe for its messages.
1:1a0f73e:      * @param subscriptionName
1:1a0f73e:      *        the name of the subscription that is being created.
1:1a0f73e:      * @param selector
1:1a0f73e:      *        the JMS selector to use for the subscription
1:1a0f73e:      *
1:1a0f73e:      * @return a newly created receiver that is ready for use.
1:1a0f73e:      *
1:1a0f73e:      * @throws Exception if an error occurs while creating the receiver.
1:1a0f73e:      */
1:1a0f73e:     public AmqpReceiver createDurableReceiver(String address, String subscriptionName, String selector) throws Exception {
1:1a0f73e:         return createDurableReceiver(address, subscriptionName, selector, false);
1:1a0f73e:     }
1:1a0f73e: 
1:1a0f73e:     /**
1:1a0f73e:      * Create a receiver instance using the given address that creates a durable subscription.
1:1a0f73e:      *
1:1a0f73e:      * @param address
1:1a0f73e:      *        the address to which the receiver will subscribe for its messages.
1:1a0f73e:      * @param subscriptionName
1:1a0f73e:      *        the name of the subscription that is being created.
1:1a0f73e:      * @param selector
1:1a0f73e:      *        the JMS selector to use for the subscription
1:1a0f73e:      * @param noLocal
1:1a0f73e:      *        should the subscription have messages from its connection filtered.
1:1a0f73e:      *
1:1a0f73e:      * @return a newly created receiver that is ready for use.
1:934ad44:      *
1:1a0f73e:      * @throws Exception if an error occurs while creating the receiver.
1:1a0f73e:      */
1:1a0f73e:     public AmqpReceiver createDurableReceiver(String address, String subscriptionName, String selector, boolean noLocal) throws Exception {
1:934ad44:         checkClosed();
1:934ad44: 
1:1a0f73e:         if (subscriptionName == null || subscriptionName.isEmpty()) {
1:1a0f73e:             throw new IllegalArgumentException("subscription name must not be null or empty.");
1:1a0f73e:         }
1:1a0f73e: 
1:1a0f73e:         final ClientFuture request = new ClientFuture();
1:934ad44:         final AmqpReceiver receiver = new AmqpReceiver(AmqpSession.this, address, getNextReceiverId());
1:934ad44:         receiver.setSubscriptionName(subscriptionName);
1:1a0f73e:         receiver.setNoLocal(noLocal);
1:1a0f73e:         if (selector != null && !selector.isEmpty()) {
1:1a0f73e:             receiver.setSelector(selector);
1:1a0f73e:         }
1:4228e3d: 
1:934ad44:         connection.getScheduler().execute(new Runnable() {
1:934ad44: 
1:934ad44:             @Override
1:934ad44:             public void run() {
1:934ad44:                 checkClosed();
1:1a0f73e:                 receiver.setStateInspector(getStateInspector());
1:934ad44:                 receiver.open(request);
1:8448cf1:                 pumpToProtonTransport(request);
1:934ad44:             }
1:934ad44:         });
1:934ad44: 
1:934ad44:         request.sync();
1:934ad44: 
1:934ad44:         return receiver;
1:934ad44:     }
1:934ad44: 
1:934ad44:     /**
1:934ad44:      * Create a receiver instance using the given address that creates a durable subscription.
1:72839b7:      *
1:934ad44:      * @param subscriptionName
1:4228e3d:      *        the name of the subscription that should be queried for on the remote..
1:4228e3d:      *
1:4228e3d:      * @return a newly created receiver that is ready for use if the subscription exists.
1:4228e3d:      *
1:4228e3d:      * @throws Exception if an error occurs while creating the receiver.
1:4228e3d:      */
1:4228e3d:     public AmqpReceiver lookupSubscription(String subscriptionName) throws Exception {
1:4228e3d:         checkClosed();
1:4228e3d: 
1:4228e3d:         if (subscriptionName == null || subscriptionName.isEmpty()) {
1:4228e3d:             throw new IllegalArgumentException("subscription name must not be null or empty.");
1:4228e3d:         }
1:4228e3d: 
1:4228e3d:         final ClientFuture request = new ClientFuture();
1:4228e3d:         final AmqpReceiver receiver = new AmqpReceiver(AmqpSession.this, (String) null, getNextReceiverId());
1:4228e3d:         receiver.setSubscriptionName(subscriptionName);
1:4228e3d: 
1:4228e3d:         connection.getScheduler().execute(new Runnable() {
1:4228e3d: 
1:4228e3d:             @Override
1:4228e3d:             public void run() {
1:4228e3d:                 checkClosed();
1:4228e3d:                 receiver.setStateInspector(getStateInspector());
1:4228e3d:                 receiver.open(request);
1:8448cf1:                 pumpToProtonTransport(request);
1:4228e3d:             }
1:4228e3d:         });
1:4228e3d: 
1:4228e3d:         request.sync();
1:4228e3d: 
1:4228e3d:         return receiver;
1:4228e3d:     }
1:72839b7: 
1:4228e3d:     /**
1:72839b7:      * @return this session's parent AmqpConnection.
1:72839b7:      */
1:72839b7:     public AmqpConnection getConnection() {
1:72839b7:         return connection;
1:72839b7:     }
1:72839b7: 
1:72839b7:     public Session getSession() {
1:fddbac2:         return UnmodifiableProxy.sessionProxy(getEndpoint());
1:72839b7:     }
1:72839b7: 
1:272fb2b:     public boolean isInTransaction() {
1:272fb2b:         return txContext.isInTransaction();
1:272fb2b:     }
1:272fb2b: 
1:272fb2b:     @Override
1:272fb2b:     public String toString() {
1:272fb2b:         return "AmqpSession { " + sessionId + " }";
1:272fb2b:     }
1:272fb2b: 
1:272fb2b:     //----- Session Transaction Methods --------------------------------------//
1:272fb2b: 
1:272fb2b:     /**
1:272fb2b:      * Starts a new transaction associated with this session.
1:272fb2b:      *
1:272fb2b:      * @throws Exception if an error occurs starting a new Transaction.
1:272fb2b:      */
1:272fb2b:     public void begin() throws Exception {
1:272fb2b:         if (txContext.isInTransaction()) {
1:272fb2b:             throw new javax.jms.IllegalStateException("Session already has an active transaction");
1:272fb2b:         }
1:272fb2b: 
1:272fb2b:         txContext.begin();
1:272fb2b:     }
1:272fb2b: 
1:272fb2b:     /**
1:272fb2b:      * Commit the current transaction associated with this session.
1:272fb2b:      *
1:272fb2b:      * @throws Exception if an error occurs committing the Transaction.
1:272fb2b:      */
1:272fb2b:     public void commit() throws Exception {
1:272fb2b:         if (!txContext.isInTransaction()) {
1:272fb2b:             throw new javax.jms.IllegalStateException(
1:272fb2b:                 "Commit called on Session that does not have an active transaction");
1:272fb2b:         }
1:272fb2b: 
1:272fb2b:         txContext.commit();
1:272fb2b:     }
1:272fb2b: 
1:272fb2b:     /**
1:272fb2b:      * Roll back the current transaction associated with this session.
1:272fb2b:      *
1:272fb2b:      * @throws Exception if an error occurs rolling back the Transaction.
1:272fb2b:      */
1:272fb2b:     public void rollback() throws Exception {
1:272fb2b:         if (!txContext.isInTransaction()) {
1:272fb2b:             throw new javax.jms.IllegalStateException(
1:272fb2b:                 "Rollback called on Session that does not have an active transaction");
1:272fb2b:         }
1:272fb2b: 
1:272fb2b:         txContext.rollback();
1:272fb2b:     }
1:272fb2b: 
1:272fb2b:     //----- Internal access used to manage resources -------------------------//
1:72839b7: 
1:72839b7:     ScheduledExecutorService getScheduler() {
1:72839b7:         return connection.getScheduler();
1:72839b7:     }
1:72839b7: 
1:72839b7:     Connection getProtonConnection() {
1:72839b7:         return connection.getProtonConnection();
1:72839b7:     }
1:72839b7: 
1:8448cf1:     void pumpToProtonTransport(AsyncResult request) {
1:8448cf1:         connection.pumpToProtonTransport(request);
1:72839b7:     }
1:72839b7: 
1:b4ab0e1:     public AmqpTransactionId getTransactionId() {
1:b4ab0e1:         if (txContext != null && txContext.isInTransaction()) {
1:b4ab0e1:             return txContext.getTransactionId();
1:b4ab0e1:         }
1:b4ab0e1: 
1:b4ab0e1:         return null;
1:272fb2b:     }
1:272fb2b: 
1:272fb2b:     AmqpTransactionContext getTransactionContext() {
1:272fb2b:         return txContext;
1:272fb2b:     }
1:272fb2b: 
1:72839b7:     //----- Private implementation details -----------------------------------//
1:72839b7: 
1:72839b7:     @Override
1:2e2d5dd:     protected void doOpen() {
1:2e2d5dd:         getEndpoint().setIncomingCapacity(Integer.MAX_VALUE);
1:2e2d5dd:         super.doOpen();
1:2e2d5dd:     }
1:2e2d5dd: 
1:2e2d5dd:     @Override
1:72839b7:     protected void doOpenInspection() {
1:7c06d8d:         try {
1:7c06d8d:             getStateInspector().inspectOpenedResource(getSession());
1:7c06d8d:         } catch (Throwable error) {
1:7c06d8d:             getStateInspector().markAsInvalid(error.getMessage());
1:7c06d8d:         }
1:72839b7:     }
1:72839b7: 
1:72839b7:     @Override
1:72839b7:     protected void doClosedInspection() {
1:7c06d8d:         try {
1:7c06d8d:             getStateInspector().inspectClosedResource(getSession());
1:7c06d8d:         } catch (Throwable error) {
1:7c06d8d:             getStateInspector().markAsInvalid(error.getMessage());
1:7c06d8d:         }
1:72839b7:     }
1:72839b7: 
1:72839b7:     private String getNextSenderId() {
1:72839b7:         return sessionId + ":" + senderIdGenerator.incrementAndGet();
1:72839b7:     }
1:72839b7: 
1:72839b7:     private String getNextReceiverId() {
1:72839b7:         return sessionId + ":" + receiverIdGenerator.incrementAndGet();
1:72839b7:     }
1:72839b7: 
1:72839b7:     private void checkClosed() {
1:13b915a:         if (isClosed() || connection.isClosed()) {
1:72839b7:             throw new IllegalStateException("Session is already closed");
1:72839b7:         }
1:72839b7:     }
1:72839b7: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:fddbac2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.amqp.client.util.UnmodifiableProxy;
/////////////////////////////////////////////////////////////////////////
1:         return UnmodifiableProxy.sessionProxy(getEndpoint());
commit:2e2d5dd
/////////////////////////////////////////////////////////////////////////
1:     protected void doOpen() {
1:         getEndpoint().setIncomingCapacity(Integer.MAX_VALUE);
1:         super.doOpen();
1:     }
1: 
1:     @Override
commit:381a1ae
/////////////////////////////////////////////////////////////////////////
1: import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;
1: import org.apache.qpid.proton.amqp.transport.SenderSettleMode;
/////////////////////////////////////////////////////////////////////////
1:      *        the address to which the sender will produce its messages.
1:      * @param senderSettlementMode
1:      *        controls the settlement mode used by the created Sender
1:      * @param receiverSettlementMode
1:      *        controls the desired settlement mode used by the remote Receiver
1:      *
1:      * @return a newly created sender that is ready for use.
1:      *
1:      * @throws Exception if an error occurs while creating the sender.
1:      */
1:     public AmqpSender createSender(final String address, final SenderSettleMode senderMode, ReceiverSettleMode receiverMode) throws Exception {
1:         checkClosed();
1: 
1:         final AmqpSender sender = new AmqpSender(AmqpSession.this, address, getNextSenderId(), senderMode, receiverMode);
1:         final ClientFuture request = new ClientFuture();
1: 
1:         connection.getScheduler().execute(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 checkClosed();
1:                 sender.setStateInspector(getStateInspector());
1:                 sender.open(request);
1:                 pumpToProtonTransport(request);
1:             }
1:         });
1: 
1:         request.sync();
1: 
1:         return sender;
1:     }
1: 
1:     /**
1:      * Create a sender instance using the given address
1:      *
1:      * @param address
/////////////////////////////////////////////////////////////////////////
1:      * Create a receiver instance using the given address
1:      *
1:      * @param address
1:      *        the address to which the receiver will subscribe for its messages.
1:      * @param senderSettlementMode
1:      *        controls the desired settlement mode used by the remote Sender
1:      * @param receiverSettlementMode
1:      *        controls the settlement mode used by the created Receiver
1:      *
1:      * @return a newly created receiver that is ready for use.
1:      *
1:      * @throws Exception if an error occurs while creating the receiver.
1:      */
1:     public AmqpReceiver createReceiver(String address, SenderSettleMode senderMode, ReceiverSettleMode receiverMode) throws Exception {
1:         checkClosed();
1: 
1:         final ClientFuture request = new ClientFuture();
1:         final AmqpReceiver receiver = new AmqpReceiver(AmqpSession.this, address, getNextReceiverId(), senderMode, receiverMode);
1: 
1:         connection.getScheduler().execute(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 checkClosed();
1:                 receiver.setStateInspector(getStateInspector());
1:                 receiver.open(request);
1:                 pumpToProtonTransport(request);
1:             }
1:         });
1: 
1:         request.sync();
1: 
1:         return receiver;
1:     }
1: 
1:     /**
commit:4a1c05b
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.qpid.proton.amqp.Symbol;
/////////////////////////////////////////////////////////////////////////
1:         return createSender(null, false, null, null, null);
/////////////////////////////////////////////////////////////////////////
1:         return createSender(address, false, null, null, null);
1:     }
1: 
1:     /**
1:      * Create a sender instance using the given address
1:      *
1:      * @param address
1:      *        the address to which the sender will produce its messages.
1:      * @param desiredCapabilities
1:      *        the capabilities that the caller wants the remote to support.
1:      *
1:      * @return a newly created sender that is ready for use.
1:      *
1:      * @throws Exception if an error occurs while creating the sender.
1:      */
1:     public AmqpSender createSender(final String address, Symbol[] desiredCapabilities) throws Exception {
1:         return createSender(address, false, desiredCapabilities, null, null);
1:     }
1: 
1:     /**
1:      * Create a sender instance using the given address
1:      *
1:      * @param address
1:      *        the address to which the sender will produce its messages.
1:      * @param presettle
1:      *        controls if the created sender produces message that have already been marked settled.
1:      *
1:      * @return a newly created sender that is ready for use.
1:      *
1:      * @throws Exception if an error occurs while creating the sender.
1:      */
1:     public AmqpSender createSender(final String address, boolean presettle) throws Exception {
1:         return createSender(address, presettle, null, null, null);
/////////////////////////////////////////////////////////////////////////
1:      * @param desiredCapabilities
1:      *        the capabilities that the caller wants the remote to support.
1:      * @param offeredCapabilities
1:      *        the capabilities that the caller wants the advertise support for.
1:      * @param properties
1:      *        the properties to send as part of the sender open.
1:     public AmqpSender createSender(final String address, boolean presettle, Symbol[] desiredCapabilities, Symbol[] offeredCapabilities, Map<Symbol, Object> properties) throws Exception {
1:         sender.setDesiredCapabilities(desiredCapabilities);
1:         sender.setOfferedCapabilities(offeredCapabilities);
1:         sender.setProperties(properties);
1: 
/////////////////////////////////////////////////////////////////////////
1:         return createSender(target, senderId, null, null, null);
1:     }
1: 
1:     /**
1:      * Create a sender instance using the given Target
1:      *
1:      * @param target
1:      *        the caller created and configured Target used to create the sender link.
1:      * @param sender
1:      *        the sender ID to assign to the newly created Sender.
1:      * @param desiredCapabilities
1:      *        the capabilities that the caller wants the remote to support.
1:      * @param offeredCapabilities
1:      *        the capabilities that the caller wants the advertise support for.
1:      * @param properties
1:      *        the properties to send as part of the sender open.
1:      *
1:      * @return a newly created sender that is ready for use.
1:      *
1:      * @throws Exception if an error occurs while creating the receiver.
1:      */
1:     public AmqpSender createSender(Target target, String senderId, Symbol[] desiredCapabilities, Symbol[] offeredCapabilities, Map<Symbol, Object> properties) throws Exception {
1:         sender.setDesiredCapabilities(desiredCapabilities);
1:         sender.setOfferedCapabilities(offeredCapabilities);
1:         sender.setProperties(properties);
1: 
commit:24a7941
/////////////////////////////////////////////////////////////////////////
1:      *        the caller created and configured Target used to create the sender link.
1:         return createSender(target, getNextSenderId());
1:     }
1: 
1:     /**
1:      * Create a sender instance using the given Target
1:      *
1:      * @param target
1:      *        the caller created and configured Target used to create the sender link.
1:      * @param sender
1:      *        the sender ID to assign to the newly created Sender.
1:      *
1:      * @return a newly created sender that is ready for use.
1:      *
1:      * @throws Exception if an error occurs while creating the receiver.
1:      */
1:     public AmqpSender createSender(Target target, String senderId) throws Exception {
1:         final AmqpSender sender = new AmqpSender(AmqpSession.this, target, senderId);
/////////////////////////////////////////////////////////////////////////
1:         return createReceiver(source, getNextReceiverId());
1:     }
1: 
1:     /**
1:      * Create a receiver instance using the given Source
1:      *
1:      * @param source
1:      *        the caller created and configured Source used to create the receiver link.
1:      * @param receivedId
1:      *        the ID value to assign to the newly created receiver
1:      *
1:      * @return a newly created receiver that is ready for use.
1:      *
1:      * @throws Exception if an error occurs while creating the receiver.
1:      */
1:     public AmqpReceiver createReceiver(Source source, String receiverId) throws Exception {
commit:4c838c5
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicBoolean closed = new AtomicBoolean();
/////////////////////////////////////////////////////////////////////////
1:      * Close the receiver, a closed receiver will throw exceptions if any further send
1:      * calls are made.
1:      *
1:      * @throws IOException if an error occurs while closing the receiver.
1:      */
1:     public void close() throws IOException {
1:         if (closed.compareAndSet(false, true)) {
1:             final ClientFuture request = new ClientFuture();
1:             getScheduler().execute(new Runnable() {
1: 
1:                 @Override
1:                 public void run() {
1:                     checkClosed();
1:                     close(request);
1:                     pumpToProtonTransport(request);
1:                 }
1:             });
1: 
1:             request.sync();
1:         }
1:     }
1: 
1:     /**
commit:b4ab0e1
/////////////////////////////////////////////////////////////////////////
1:     public AmqpTransactionId getTransactionId() {
1:         if (txContext != null && txContext.isInTransaction()) {
1:             return txContext.getTransactionId();
1:         }
1: 
1:         return null;
commit:0050f22
/////////////////////////////////////////////////////////////////////////
1:      * Create an anonymous sender.
1:      *
1:      * @return a newly created sender that is ready for use.
1:      *
1:      * @throws Exception if an error occurs while creating the sender.
1:      */
1:     public AmqpSender createSender() throws Exception {
0:         return createSender(null, false);
1:     }
1: 
1:     /**
commit:db71b43
/////////////////////////////////////////////////////////////////////////
1:         return createReceiver(address, selector, noLocal, false);
1:     }
1: 
1:     /**
1:      * Create a receiver instance using the given address
1:      *
1:      * @param address
1:      *        the address to which the receiver will subscribe for its messages.
1:      * @param selector
1:      *        the JMS selector to use for the subscription
1:      * @param noLocal
1:      *        should the subscription have messages from its connection filtered.
1:      * @param presettle
1:      *        should the receiver be created with a settled sender mode.
1:      *
1:      * @return a newly created receiver that is ready for use.
1:      *
1:      * @throws Exception if an error occurs while creating the receiver.
1:      */
1:     public AmqpReceiver createReceiver(String address, String selector, boolean noLocal, boolean presettle) throws Exception {
1:         receiver.setPresettle(presettle);
commit:8448cf1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.amqp.client.util.AsyncResult;
/////////////////////////////////////////////////////////////////////////
1:                 pumpToProtonTransport(request);
/////////////////////////////////////////////////////////////////////////
1:                 pumpToProtonTransport(request);
/////////////////////////////////////////////////////////////////////////
1:                 pumpToProtonTransport(request);
/////////////////////////////////////////////////////////////////////////
1:                 pumpToProtonTransport(request);
/////////////////////////////////////////////////////////////////////////
1:                 pumpToProtonTransport(request);
/////////////////////////////////////////////////////////////////////////
1:                 pumpToProtonTransport(request);
/////////////////////////////////////////////////////////////////////////
1:     void pumpToProtonTransport(AsyncResult request) {
1:         connection.pumpToProtonTransport(request);
commit:272fb2b
/////////////////////////////////////////////////////////////////////////
1:     private final AmqpTransactionContext txContext;
/////////////////////////////////////////////////////////////////////////
1:         this.txContext = new AmqpTransactionContext(this);
/////////////////////////////////////////////////////////////////////////
1:     public boolean isInTransaction() {
1:         return txContext.isInTransaction();
1:     }
1: 
1:     @Override
1:     public String toString() {
1:         return "AmqpSession { " + sessionId + " }";
1:     }
1: 
1:     //----- Session Transaction Methods --------------------------------------//
1: 
1:     /**
1:      * Starts a new transaction associated with this session.
1:      *
1:      * @throws Exception if an error occurs starting a new Transaction.
1:      */
1:     public void begin() throws Exception {
1:         if (txContext.isInTransaction()) {
1:             throw new javax.jms.IllegalStateException("Session already has an active transaction");
1:         }
1: 
1:         txContext.begin();
1:     }
1: 
1:     /**
1:      * Commit the current transaction associated with this session.
1:      *
1:      * @throws Exception if an error occurs committing the Transaction.
1:      */
1:     public void commit() throws Exception {
1:         if (!txContext.isInTransaction()) {
1:             throw new javax.jms.IllegalStateException(
1:                 "Commit called on Session that does not have an active transaction");
1:         }
1: 
1:         txContext.commit();
1:     }
1: 
1:     /**
1:      * Roll back the current transaction associated with this session.
1:      *
1:      * @throws Exception if an error occurs rolling back the Transaction.
1:      */
1:     public void rollback() throws Exception {
1:         if (!txContext.isInTransaction()) {
1:             throw new javax.jms.IllegalStateException(
1:                 "Rollback called on Session that does not have an active transaction");
1:         }
1: 
1:         txContext.rollback();
1:     }
1: 
1:     //----- Internal access used to manage resources -------------------------//
/////////////////////////////////////////////////////////////////////////
0:     AmqpTransactionId getTransactionId() {
0:         return txContext.getTransactionId();
1:     }
1: 
1:     AmqpTransactionContext getTransactionContext() {
1:         return txContext;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
commit:7c06d8d
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             getStateInspector().inspectOpenedResource(getSession());
1:         } catch (Throwable error) {
1:             getStateInspector().markAsInvalid(error.getMessage());
1:         }
1:         try {
1:             getStateInspector().inspectClosedResource(getSession());
1:         } catch (Throwable error) {
1:             getStateInspector().markAsInvalid(error.getMessage());
1:         }
commit:13b915a
/////////////////////////////////////////////////////////////////////////
1:         if (isClosed() || connection.isClosed()) {
commit:b3bf8e7
/////////////////////////////////////////////////////////////////////////
1:      *        the address to which the sender will produce its messages.
0:         return createSender(address, false);
1:     }
1: 
1:     /**
1:      * Create a sender instance using the given address
1:      *
1:      * @param address
1:      * 	      the address to which the sender will produce its messages.
1:      * @param presettle
1:      *        controls if the created sender produces message that have already been marked settled.
1:      *
1:      * @return a newly created sender that is ready for use.
1:      *
1:      * @throws Exception if an error occurs while creating the sender.
1:      */
0:     public AmqpSender createSender(final String address, boolean presettle) throws Exception {
1:         sender.setPresettle(presettle);
commit:8e6a404
/////////////////////////////////////////////////////////////////////////
1: import org.apache.qpid.proton.amqp.messaging.Target;
/////////////////////////////////////////////////////////////////////////
1:      * Create a sender instance using the given Target
1:      *
1:      * @param target
0:      *        the caller created and configured Traget used to create the sender link.
1:      *
1:      * @return a newly created sender that is ready for use.
1:      *
1:      * @throws Exception if an error occurs while creating the receiver.
1:      */
1:     public AmqpSender createSender(Target target) throws Exception {
1:         checkClosed();
1: 
0:         final AmqpSender sender = new AmqpSender(AmqpSession.this, target, getNextSenderId());
1:         final ClientFuture request = new ClientFuture();
1: 
1:         connection.getScheduler().execute(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 checkClosed();
1:                 sender.setStateInspector(getStateInspector());
1:                 sender.open(request);
0:                 pumpToProtonTransport();
1:             }
1:         });
1: 
1:         request.sync();
1: 
1:         return sender;
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:      * Create a receiver instance using the given Source
commit:4228e3d
/////////////////////////////////////////////////////////////////////////
1:      * Create a receiver instance using the given address that creates a durable subscription.
1:      *
1:      * @param subscriptionName
1:      *        the name of the subscription that should be queried for on the remote..
1:      *
1:      * @return a newly created receiver that is ready for use if the subscription exists.
1:      *
1:      * @throws Exception if an error occurs while creating the receiver.
1:      */
1:     public AmqpReceiver lookupSubscription(String subscriptionName) throws Exception {
1:         checkClosed();
1: 
1:         if (subscriptionName == null || subscriptionName.isEmpty()) {
1:             throw new IllegalArgumentException("subscription name must not be null or empty.");
1:         }
1: 
1:         final ClientFuture request = new ClientFuture();
1:         final AmqpReceiver receiver = new AmqpReceiver(AmqpSession.this, (String) null, getNextReceiverId());
1:         receiver.setSubscriptionName(subscriptionName);
1: 
1:         connection.getScheduler().execute(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 checkClosed();
1:                 receiver.setStateInspector(getStateInspector());
1:                 receiver.open(request);
0:                 pumpToProtonTransport();
1:             }
1:         });
1: 
1:         request.sync();
1: 
1:         return receiver;
1:     }
1: 
1:     /**
commit:ca456c4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.qpid.proton.amqp.messaging.Source;
/////////////////////////////////////////////////////////////////////////
1:      * Create a receiver instance using the given address
1:      *
1:      * @param address
1:      *        the address to which the receiver will subscribe for its messages.
1:      * @param source
1:      *        the caller created and configured Source used to create the receiver link.
1:      *
1:      * @return a newly created receiver that is ready for use.
1:      *
1:      * @throws Exception if an error occurs while creating the receiver.
1:      */
1:     public AmqpReceiver createReceiver(Source source) throws Exception {
1:         checkClosed();
1: 
1:         final ClientFuture request = new ClientFuture();
1:         final AmqpReceiver receiver = new AmqpReceiver(AmqpSession.this, source, getNextReceiverId());
1: 
1:         connection.getScheduler().execute(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 checkClosed();
1:                 receiver.setStateInspector(getStateInspector());
1:                 receiver.open(request);
0:                 pumpToProtonTransport();
1:             }
1:         });
1: 
1:         request.sync();
1: 
1:         return receiver;
1:     }
1: 
1:     /**
commit:1a0f73e
/////////////////////////////////////////////////////////////////////////
1:                 sender.setStateInspector(getStateInspector());
/////////////////////////////////////////////////////////////////////////
1:      *        the address to which the receiver will subscribe for its messages.
1:         return createReceiver(address, null, false);
1:     }
1: 
1:     /**
1:      * Create a receiver instance using the given address
1:      *
1:      * @param address
1:      *        the address to which the receiver will subscribe for its messages.
1:      * @param selector
1:      *        the JMS selector to use for the subscription
1:      *
1:      * @return a newly created receiver that is ready for use.
1:      *
1:      * @throws Exception if an error occurs while creating the receiver.
1:      */
1:     public AmqpReceiver createReceiver(String address, String selector) throws Exception {
1:         return createReceiver(address, selector, false);
1:     }
1: 
1:     /**
1:      * Create a receiver instance using the given address
1:      *
1:      * @param address
1:      * 	      the address to which the receiver will subscribe for its messages.
1:      * @param selector
1:      *        the JMS selector to use for the subscription
1:      * @param noLocal
1:      *        should the subscription have messages from its connection filtered.
1:      *
1:      * @return a newly created receiver that is ready for use.
1:      *
1:      * @throws Exception if an error occurs while creating the receiver.
1:      */
1:     public AmqpReceiver createReceiver(String address, String selector, boolean noLocal) throws Exception {
1:         final AmqpReceiver receiver = new AmqpReceiver(AmqpSession.this, address, getNextReceiverId());
1: 
1:         receiver.setNoLocal(noLocal);
1:         if (selector != null && !selector.isEmpty()) {
1:             receiver.setSelector(selector);
1:         }
1:                 receiver.setStateInspector(getStateInspector());
/////////////////////////////////////////////////////////////////////////
1:         return createDurableReceiver(address, subscriptionName, null, false);
1:     }
1: 
1:     /**
1:      * Create a receiver instance using the given address that creates a durable subscription.
1:      *
1:      * @param address
1:      *        the address to which the receiver will subscribe for its messages.
1:      * @param subscriptionName
1:      *        the name of the subscription that is being created.
1:      * @param selector
1:      *        the JMS selector to use for the subscription
1:      *
1:      * @return a newly created receiver that is ready for use.
1:      *
1:      * @throws Exception if an error occurs while creating the receiver.
1:      */
1:     public AmqpReceiver createDurableReceiver(String address, String subscriptionName, String selector) throws Exception {
1:         return createDurableReceiver(address, subscriptionName, selector, false);
1:     }
1: 
1:     /**
1:      * Create a receiver instance using the given address that creates a durable subscription.
1:      *
1:      * @param address
1:      *        the address to which the receiver will subscribe for its messages.
1:      * @param subscriptionName
1:      *        the name of the subscription that is being created.
1:      * @param selector
1:      *        the JMS selector to use for the subscription
1:      * @param noLocal
1:      *        should the subscription have messages from its connection filtered.
1:      *
1:      * @return a newly created receiver that is ready for use.
1:      *
1:      * @throws Exception if an error occurs while creating the receiver.
1:      */
1:     public AmqpReceiver createDurableReceiver(String address, String subscriptionName, String selector, boolean noLocal) throws Exception {
1:         if (subscriptionName == null || subscriptionName.isEmpty()) {
1:             throw new IllegalArgumentException("subscription name must not be null or empty.");
1:         }
1: 
1:         final ClientFuture request = new ClientFuture();
1:         receiver.setNoLocal(noLocal);
1:         if (selector != null && !selector.isEmpty()) {
1:             receiver.setSelector(selector);
1:         }
1:                 receiver.setStateInspector(getStateInspector());
commit:934ad44
/////////////////////////////////////////////////////////////////////////
1:      * Create a receiver instance using the given address that creates a durable subscription.
1:      *
1:      * @param address
0:      *        the address to which the receiver will subscribe for its messages.
1:      * @param subscriptionName
1:      *        the name of the subscription that is being created.
1:      *
1:      * @return a newly created receiver that is ready for use.
1:      *
1:      * @throws Exception if an error occurs while creating the receiver.
1:      */
1:     public AmqpReceiver createDurableReceiver(String address, String subscriptionName) throws Exception {
1:         checkClosed();
1: 
1:         final AmqpReceiver receiver = new AmqpReceiver(AmqpSession.this, address, getNextReceiverId());
1:         receiver.setSubscriptionName(subscriptionName);
1:         final ClientFuture request = new ClientFuture();
1: 
1:         connection.getScheduler().execute(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 checkClosed();
1:                 receiver.open(request);
0:                 pumpToProtonTransport();
1:             }
1:         });
1: 
1:         request.sync();
1: 
1:         return receiver;
1:     }
1: 
1:     /**
commit:72839b7
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport.amqp.client;
1: 
1: import java.util.concurrent.ScheduledExecutorService;
1: import java.util.concurrent.atomic.AtomicLong;
1: 
1: import org.apache.activemq.transport.amqp.client.util.ClientFuture;
0: import org.apache.activemq.transport.amqp.client.util.UnmodifiableSession;
1: import org.apache.qpid.proton.engine.Connection;
1: import org.apache.qpid.proton.engine.Session;
1: 
1: /**
1:  * Session class that manages a Proton session endpoint.
1:  */
1: public class AmqpSession extends AmqpAbstractResource<Session> {
1: 
1:     private final AtomicLong receiverIdGenerator = new AtomicLong();
1:     private final AtomicLong senderIdGenerator = new AtomicLong();
1: 
1:     private final AmqpConnection connection;
1:     private final String sessionId;
1: 
1:     /**
1:      * Create a new session instance.
1:      *
1:      * @param connection
1:      * 		  The parent connection that created the session.
1:      * @param sessionId
1:      *        The unique ID value assigned to this session.
1:      */
1:     public AmqpSession(AmqpConnection connection, String sessionId) {
1:         this.connection = connection;
1:         this.sessionId = sessionId;
1:     }
1: 
1:     /**
1:      * Create a sender instance using the given address
1:      *
1:      * @param address
0:      * 	      the address to which the sender will produce its messages.
1:      *
1:      * @return a newly created sender that is ready for use.
1:      *
1:      * @throws Exception if an error occurs while creating the sender.
1:      */
1:     public AmqpSender createSender(final String address) throws Exception {
1:         checkClosed();
1: 
1:         final AmqpSender sender = new AmqpSender(AmqpSession.this, address, getNextSenderId());
1:         final ClientFuture request = new ClientFuture();
1: 
1:         connection.getScheduler().execute(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 checkClosed();
1:                 sender.open(request);
0:                 pumpToProtonTransport();
1:             }
1:         });
1: 
1:         request.sync();
1: 
1:         return sender;
1:     }
1: 
1:     /**
0:      * Create a receiver instance using the given address
1:      *
1:      * @param address
0:      * 	      the address to which the receiver will subscribe for its messages.
1:      *
1:      * @return a newly created receiver that is ready for use.
1:      *
1:      * @throws Exception if an error occurs while creating the receiver.
1:      */
1:     public AmqpReceiver createReceiver(String address) throws Exception {
1:         checkClosed();
1: 
0:         final AmqpReceiver receiver = new AmqpReceiver(AmqpSession.this, address, getNextReceiverId());
1:         final ClientFuture request = new ClientFuture();
1: 
1:         connection.getScheduler().execute(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 checkClosed();
1:                 receiver.open(request);
0:                 pumpToProtonTransport();
1:             }
1:         });
1: 
1:         request.sync();
1: 
1:         return receiver;
1:     }
1: 
1:     /**
1:      * @return this session's parent AmqpConnection.
1:      */
1:     public AmqpConnection getConnection() {
1:         return connection;
1:     }
1: 
1:     public Session getSession() {
0:         return new UnmodifiableSession(getEndpoint());
1:     }
1: 
0:     //----- Internal getters used from the child AmqpResource classes --------//
1: 
1:     ScheduledExecutorService getScheduler() {
1:         return connection.getScheduler();
1:     }
1: 
1:     Connection getProtonConnection() {
1:         return connection.getProtonConnection();
1:     }
1: 
0:     void pumpToProtonTransport() {
0:         connection.pumpToProtonTransport();
1:     }
1: 
1:     //----- Private implementation details -----------------------------------//
1: 
1:     @Override
1:     protected void doOpenInspection() {
0:         getStateInspector().inspectOpenedResource(getSession());
1:     }
1: 
1:     @Override
1:     protected void doClosedInspection() {
0:         getStateInspector().inspectClosedResource(getSession());
1:     }
1: 
1:     private String getNextSenderId() {
1:         return sessionId + ":" + senderIdGenerator.incrementAndGet();
1:     }
1: 
1:     private String getNextReceiverId() {
1:         return sessionId + ":" + receiverIdGenerator.incrementAndGet();
1:     }
1: 
1:     private void checkClosed() {
0:         if (isClosed()) {
1:             throw new IllegalStateException("Session is already closed");
1:         }
1:     }
1: 
1:     @Override
0:     public String toString() {
0:         return "AmqpSession { " + sessionId + " }";
1:     }
1: }
============================================================================