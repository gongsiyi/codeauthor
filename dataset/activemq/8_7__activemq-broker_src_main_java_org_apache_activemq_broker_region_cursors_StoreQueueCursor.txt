1:629bc81: /**
1:fc00993:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:fc00993:  * contributor license agreements.  See the NOTICE file distributed with
1:fc00993:  * this work for additional information regarding copyright ownership.
1:fc00993:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:fc00993:  * (the "License"); you may not use this file except in compliance with
1:fc00993:  * the License.  You may obtain a copy of the License at
1:fc00993:  *
1:fc00993:  *      http://www.apache.org/licenses/LICENSE-2.0
1:0bbc0ac:  *
1:fc00993:  * Unless required by applicable law or agreed to in writing, software
1:fc00993:  * distributed under the License is distributed on an "AS IS" BASIS,
1:fc00993:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:fc00993:  * See the License for the specific language governing permissions and
1:fc00993:  * limitations under the License.
1:629bc81:  */
1:629bc81: package org.apache.activemq.broker.region.cursors;
1:e5efc58: 
1:23cda2d: import org.apache.activemq.broker.Broker;
1:629bc81: import org.apache.activemq.broker.region.MessageReference;
1:629bc81: import org.apache.activemq.broker.region.Queue;
1:629bc81: import org.apache.activemq.command.Message;
1:2eff835: import org.apache.activemq.command.MessageId;
1:6d8e2c5: import org.apache.activemq.usage.SystemUsage;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:415d46c: 
1:629bc81: /**
1:629bc81:  * Store based Cursor for Queues
1:629bc81:  */
1:230a86c: public class StoreQueueCursor extends AbstractPendingMessageCursor {
18:629bc81: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(StoreQueueCursor.class);
1:00879cf:     private final Broker broker;
1:933eb2f:     private int pendingCount;
1:00879cf:     private final Queue queue;
1:629bc81:     private PendingMessageCursor nonPersistent;
1:00879cf:     private final QueueStorePrefetch persistent;
1:629bc81:     private PendingMessageCursor currentCursor;
1:230a86c: 
1:629bc81:     /**
1:629bc81:      * Construct
1:926fdd7:      * @param broker
1:629bc81:      * @param queue
1:629bc81:      */
1:23cda2d:     public StoreQueueCursor(Broker broker,Queue queue) {
1:00879cf:         super((queue != null ? queue.isPrioritizedMessages():false));
1:23cda2d:         this.broker=broker;
1:230a86c:         this.queue = queue;
1:13ec994:         this.persistent = new QueueStorePrefetch(queue, broker);
1:e5efc58:         currentCursor = persistent;
5:629bc81:     }
1:926fdd7: 
1:734fb7d:     @Override
1:230a86c:     public synchronized void start() throws Exception {
1:230a86c:         started = true;
1:1ee0017:         super.start();
1:230a86c:         if (nonPersistent == null) {
1:512b0c7:             if (broker.getBrokerService().isPersistent()) {
1:00879cf:                 nonPersistent = new FilePendingMessageCursor(broker,queue.getName(),this.prioritizedMessages);
1:512b0c7:             }else {
1:00879cf:                 nonPersistent = new VMPendingMessageCursor(this.prioritizedMessages);
1:512b0c7:             }
1:629bc81:             nonPersistent.setMaxBatchSize(getMaxBatchSize());
1:6d8e2c5:             nonPersistent.setSystemUsage(systemUsage);
1:1ee0017:             nonPersistent.setEnableAudit(isEnableAudit());
1:1ee0017:             nonPersistent.setMaxAuditDepth(getMaxAuditDepth());
1:1ee0017:             nonPersistent.setMaxProducersToAudit(getMaxProducersToAudit());
1:629bc81:         }
1:55810b3:         nonPersistent.setMessageAudit(getMessageAudit());
1:629bc81:         nonPersistent.start();
1:55810b3:         persistent.setMessageAudit(getMessageAudit());
1:e006780:         persistent.start();
1:230a86c:         pendingCount = persistent.size() + nonPersistent.size();
1:629bc81:     }
1:926fdd7: 
1:734fb7d:     @Override
1:230a86c:     public synchronized void stop() throws Exception {
1:230a86c:         started = false;
1:230a86c:         if (nonPersistent != null) {
1:d112ad5:           nonPersistent.destroy();
1:230a86c:         }
1:e006780:         persistent.stop();
1:3bf0245:         persistent.gc();
1:5d93518:         super.stop();
1:230a86c:         pendingCount = 0;
1:629bc81:     }
1:00879cf: 
1:734fb7d:     @Override
1:cc6213e:     public synchronized boolean tryAddMessageLast(MessageReference node, long maxWait) throws Exception {
1:54e2e3b:         boolean result = true;
1:230a86c:         if (node != null) {
1:230a86c:             Message msg = node.getMessage();
1:230a86c:             if (started) {
1:415d46c:                 pendingCount++;
1:230a86c:                 if (!msg.isPersistent()) {
1:cc6213e:                     result = nonPersistent.tryAddMessageLast(node, maxWait);
1:629bc81:                 }
1:629bc81:             }
1:230a86c:             if (msg.isPersistent()) {
1:54e2e3b:                 result = persistent.addMessageLast(node);
1:629bc81:             }
1:629bc81:         }
1:54e2e3b:         return result;
1:629bc81:     }
1:230a86c: 
1:734fb7d:     @Override
1:230a86c:     public synchronized void addMessageFirst(MessageReference node) throws Exception {
1:230a86c:         if (node != null) {
1:230a86c:             Message msg = node.getMessage();
1:230a86c:             if (started) {
1:629bc81:                 pendingCount++;
1:230a86c:                 if (!msg.isPersistent()) {
1:415d46c:                     nonPersistent.addMessageFirst(node);
1:415d46c:                 }
1:415d46c:             }
1:230a86c:             if (msg.isPersistent()) {
1:415d46c:                 persistent.addMessageFirst(node);
1:415d46c:             }
1:415d46c:         }
1:415d46c:     }
1:785454a: 
1:734fb7d:     @Override
1:230a86c:     public synchronized void clear() {
1:230a86c:         pendingCount = 0;
1:629bc81:     }
1:230a86c: 
1:734fb7d:     @Override
1:230a86c:     public synchronized boolean hasNext() {
1:230a86c:         try {
1:81f0cc0:             getNextCursor();
1:230a86c:         } catch (Exception e) {
1:230a86c:             LOG.error("Failed to get current cursor ", e);
1:81f0cc0:             throw new RuntimeException(e);
1:81f0cc0:        }
1:81f0cc0:        return currentCursor != null ? currentCursor.hasNext() : false;
1:629bc81:     }
1:47cfa55: 
1:734fb7d:     @Override
1:230a86c:     public synchronized MessageReference next() {
1:230a86c:         MessageReference result = currentCursor != null ? currentCursor.next() : null;
1:415d46c:         return result;
1:8ab5f45:     }
1:8ab5f45: 
1:734fb7d:     @Override
1:230a86c:     public synchronized void remove() {
1:230a86c:         if (currentCursor != null) {
1:629bc81:             currentCursor.remove();
1:629bc81:         }
1:629bc81:         pendingCount--;
1:629bc81:     }
1:071b4b1: 
1:734fb7d:     @Override
1:230a86c:     public synchronized void remove(MessageReference node) {
1:415d46c:         if (!node.isPersistent()) {
1:415d46c:             nonPersistent.remove(node);
1:230a86c:         } else {
1:415d46c:             persistent.remove(node);
1:415d46c:         }
1:629bc81:         pendingCount--;
1:629bc81:     }
1:1ee0017: 
1:734fb7d:     @Override
1:230a86c:     public synchronized void reset() {
1:629bc81:         nonPersistent.reset();
1:e5efc58:         persistent.reset();
1:926fdd7:         pendingCount = persistent.size() + nonPersistent.size();
1:629bc81:     }
1:926fdd7: 
1:734fb7d:     @Override
1:47cfa55:     public void release() {
1:47cfa55:         nonPersistent.release();
1:47cfa55:         persistent.release();
1:47cfa55:     }
1:47cfa55: 
1:1ee0017: 
1:734fb7d:     @Override
1:230a86c:     public synchronized int size() {
1:81f0cc0:         if (pendingCount < 0) {
1:81f0cc0:             pendingCount = persistent.size() + nonPersistent.size();
1:81f0cc0:         }
1:629bc81:         return pendingCount;
1:629bc81:     }
1:415d46c: 
1:734fb7d:     @Override
1:734fb7d:     public synchronized long messageSize() {
1:734fb7d:         return persistent.messageSize() + nonPersistent.messageSize();
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     @Override
1:230a86c:     public synchronized boolean isEmpty() {
1:81f0cc0:         // if negative, more messages arrived in store since last reset so non empty
1:81f0cc0:         return pendingCount == 0;
1:629bc81:     }
1:3bf0245: 
1:629bc81:     /**
1:230a86c:      * Informs the Broker if the subscription needs to intervention to recover
1:230a86c:      * it's state e.g. DurableTopicSubscriber may do
1:fc00993:      *
1:aad7e73:      * @see org.apache.activemq.broker.region.cursors.PendingMessageCursor
1:629bc81:      * @return true if recovery required
1:629bc81:      */
1:734fb7d:     @Override
1:0326ab7:     public boolean isRecoveryRequired() {
1:629bc81:         return false;
1:629bc81:     }
1:629bc81: 
1:629bc81:     /**
1:629bc81:      * @return the nonPersistent Cursor
1:629bc81:      */
1:0326ab7:     public PendingMessageCursor getNonPersistent() {
1:629bc81:         return this.nonPersistent;
1:629bc81:     }
1:629bc81: 
1:629bc81:     /**
1:629bc81:      * @param nonPersistent cursor to set
1:629bc81:      */
1:0326ab7:     public void setNonPersistent(PendingMessageCursor nonPersistent) {
1:230a86c:         this.nonPersistent = nonPersistent;
1:629bc81:     }
1:629bc81: 
1:83514ef:     /**
1:83514ef:      * @return the persistent Cursor
1:83514ef:      */
1:83514ef:     public PendingMessageCursor getPersistent() { return  this.persistent; }
1:83514ef: 
1:734fb7d:     @Override
1:0326ab7:     public void setMaxBatchSize(int maxBatchSize) {
1:629bc81:         persistent.setMaxBatchSize(maxBatchSize);
1:230a86c:         if (nonPersistent != null) {
1:629bc81:             nonPersistent.setMaxBatchSize(maxBatchSize);
1:629bc81:         }
1:629bc81:         super.setMaxBatchSize(maxBatchSize);
1:629bc81:     }
1:230a86c: 
1:926fdd7: 
1:734fb7d:     @Override
1:0326ab7:     public void setMaxProducersToAudit(int maxProducersToAudit) {
1:1ee0017:         super.setMaxProducersToAudit(maxProducersToAudit);
1:1ee0017:         if (persistent != null) {
1:1ee0017:             persistent.setMaxProducersToAudit(maxProducersToAudit);
1:1ee0017:         }
1:1ee0017:         if (nonPersistent != null) {
1:1ee0017:             nonPersistent.setMaxProducersToAudit(maxProducersToAudit);
1:1ee0017:         }
1:1ee0017:     }
1:1ee0017: 
1:734fb7d:     @Override
1:0326ab7:     public void setMaxAuditDepth(int maxAuditDepth) {
1:1ee0017:         super.setMaxAuditDepth(maxAuditDepth);
1:1ee0017:         if (persistent != null) {
1:1ee0017:             persistent.setMaxAuditDepth(maxAuditDepth);
1:1ee0017:         }
1:1ee0017:         if (nonPersistent != null) {
1:1ee0017:             nonPersistent.setMaxAuditDepth(maxAuditDepth);
1:1ee0017:         }
1:1ee0017:     }
1:926fdd7: 
1:734fb7d:     @Override
1:0326ab7:     public void setEnableAudit(boolean enableAudit) {
1:1ee0017:         super.setEnableAudit(enableAudit);
1:1ee0017:         if (persistent != null) {
1:1ee0017:             persistent.setEnableAudit(enableAudit);
1:1ee0017:         }
1:1ee0017:         if (nonPersistent != null) {
1:1ee0017:             nonPersistent.setEnableAudit(enableAudit);
1:1ee0017:         }
1:1ee0017:     }
1:926fdd7: 
1:734fb7d:     @Override
1:2eff835:     public void rollback(MessageId id) {
1:2eff835:         nonPersistent.rollback(id);
1:2eff835:         persistent.rollback(id);
1:2eff835:     }
1:2eff835: 
1:2eff835:     @Override
1:0326ab7:     public void setUseCache(boolean useCache) {
1:071b4b1:         super.setUseCache(useCache);
1:071b4b1:         if (persistent != null) {
1:071b4b1:             persistent.setUseCache(useCache);
1:071b4b1:         }
1:071b4b1:         if (nonPersistent != null) {
1:071b4b1:             nonPersistent.setUseCache(useCache);
1:071b4b1:         }
1:071b4b1:     }
1:926fdd7: 
1:734fb7d:     @Override
1:785454a:     public void setMemoryUsageHighWaterMark(int memoryUsageHighWaterMark) {
1:785454a:         super.setMemoryUsageHighWaterMark(memoryUsageHighWaterMark);
1:785454a:         if (persistent != null) {
1:785454a:             persistent.setMemoryUsageHighWaterMark(memoryUsageHighWaterMark);
1:785454a:         }
1:785454a:         if (nonPersistent != null) {
1:785454a:             nonPersistent.setMemoryUsageHighWaterMark(memoryUsageHighWaterMark);
1:785454a:         }
1:785454a:     }
1:1ee0017: 
1:1ee0017: 
1:1ee0017: 
1:00879cf:     @Override
1:a3e3821:     public synchronized void gc() {
1:3bf0245:         if (persistent != null) {
1:3bf0245:             persistent.gc();
1:3bf0245:         }
1:3bf0245:         if (nonPersistent != null) {
1:3bf0245:             nonPersistent.gc();
1:3bf0245:         }
1:81f0cc0:         pendingCount = persistent.size() + nonPersistent.size();
1:3bf0245:     }
1:230a86c: 
1:00879cf:     @Override
1:0326ab7:     public void setSystemUsage(SystemUsage usageManager) {
1:6d8e2c5:         super.setSystemUsage(usageManager);
1:3bf0245:         if (persistent != null) {
1:6d8e2c5:             persistent.setSystemUsage(usageManager);
1:3bf0245:         }
1:3bf0245:         if (nonPersistent != null) {
1:6d8e2c5:             nonPersistent.setSystemUsage(usageManager);
1:3bf0245:         }
1:3bf0245:     }
1:3bf0245: 
1:230a86c:     protected synchronized PendingMessageCursor getNextCursor() throws Exception {
1:230a86c:         if (currentCursor == null || !currentCursor.hasMessagesBufferedToDeliver()) {
1:230a86c:             currentCursor = currentCursor == persistent ? nonPersistent : persistent;
1:230a86c:             // sanity check
1:e5efc58:             if (currentCursor.isEmpty()) {
1:230a86c:                 currentCursor = currentCursor == persistent ? nonPersistent : persistent;
1:e5efc58:             }
1:629bc81:         }
1:629bc81:         return currentCursor;
1:629bc81:     }
1:aad7e73: 
1:aad7e73:     @Override
1:aad7e73:     public boolean isCacheEnabled() {
1:cb96783:         boolean cacheEnabled = isUseCache();
1:aad7e73:         if (cacheEnabled) {
1:aad7e73:             if (persistent != null) {
1:aad7e73:                 cacheEnabled &= persistent.isCacheEnabled();
1:aad7e73:             }
1:aad7e73:             if (nonPersistent != null) {
1:aad7e73:                 cacheEnabled &= nonPersistent.isCacheEnabled();
1:aad7e73:             }
1:cb96783:             setCacheEnabled(cacheEnabled);
1:aad7e73:         }
1:aad7e73:         return cacheEnabled;
1:aad7e73:     }
1:cfe099d: 
1:cfe099d:     @Override
1:cfe099d:     public void rebase() {
1:cfe099d:         persistent.rebase();
1:cfe099d:         reset();
1:cfe099d:     }
1:cfe099d: 
1:629bc81: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:83514ef
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @return the persistent Cursor
1:      */
1:     public PendingMessageCursor getPersistent() { return  this.persistent; }
1: 
commit:2eff835
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.MessageId;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void rollback(MessageId id) {
1:         nonPersistent.rollback(id);
1:         persistent.rollback(id);
1:     }
1: 
1:     @Override
commit:8d3674b
/////////////////////////////////////////////////////////////////////////
commit:13ec994
/////////////////////////////////////////////////////////////////////////
1:         this.persistent = new QueueStorePrefetch(queue, broker);
commit:d8cf54b
/////////////////////////////////////////////////////////////////////////
0:         this.persistent = new QueueStorePrefetch(queue);
commit:54e2e3b
/////////////////////////////////////////////////////////////////////////
0:     public synchronized boolean addMessageLast(MessageReference node) throws Exception {
1:         boolean result = true;
/////////////////////////////////////////////////////////////////////////
1:                 result = persistent.addMessageLast(node);
1:         return result;
commit:cfe099d
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     public void rebase() {
1:         persistent.rebase();
1:         reset();
1:     }
1: 
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:cc6213e
/////////////////////////////////////////////////////////////////////////
1:     public synchronized boolean tryAddMessageLast(MessageReference node, long maxWait) throws Exception {
1:                     result = nonPersistent.tryAddMessageLast(node, maxWait);
commit:734fb7d
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public synchronized long messageSize() {
1:         return persistent.messageSize() + nonPersistent.messageSize();
1:     }
1: 
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:7450a32
/////////////////////////////////////////////////////////////////////////
0:         this.persistent = new QueueStorePrefetch(queue, broker);
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(StoreQueueCursor.class);
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
commit:0bbc0ac
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
1:     private int pendingCount;
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(StoreQueueCursor.class);
commit:230a86c
/////////////////////////////////////////////////////////////////////////
1: public class StoreQueueCursor extends AbstractPendingMessageCursor {
0:     static private final Log LOG = LogFactory.getLog(StoreQueueCursor.class);
0:     private int pendingCount = 0;
1: 
0:     public StoreQueueCursor(Queue queue, Store tmpStore) {
1:         this.queue = queue;
0:         this.tmpStore = tmpStore;
0:         this.persistent = new QueueStorePrefetch(queue);
1:     public synchronized void start() throws Exception {
1:         started = true;
1:         if (nonPersistent == null) {
0:             nonPersistent = new FilePendingMessageCursor(queue.getDestination(), tmpStore);
1:         pendingCount = persistent.size() + nonPersistent.size();
1:     public synchronized void stop() throws Exception {
1:         started = false;
1:         if (nonPersistent != null) {
1:         pendingCount = 0;
0:     public synchronized void addMessageLast(MessageReference node) throws Exception {
1:         if (node != null) {
1:             Message msg = node.getMessage();
1:             if (started) {
1:                 if (!msg.isPersistent()) {
1:             if (msg.isPersistent()) {
1: 
1:     public synchronized void addMessageFirst(MessageReference node) throws Exception {
1:         if (node != null) {
1:             Message msg = node.getMessage();
1:             if (started) {
1:                 if (!msg.isPersistent()) {
1:             if (msg.isPersistent()) {
1:     public synchronized void clear() {
1:         pendingCount = 0;
1:     public synchronized boolean hasNext() {
1: 
0:         boolean result = pendingCount > 0;
0:         if (result) {
1:             try {
0:                 currentCursor = getNextCursor();
1:             } catch (Exception e) {
1:                 LOG.error("Failed to get current cursor ", e);
0:             result = currentCursor != null ? currentCursor.hasNext() : false;
1:     public synchronized MessageReference next() {
1:         MessageReference result = currentCursor != null ? currentCursor.next() : null;
1:     public synchronized void remove() {
1:         if (currentCursor != null) {
1:     public synchronized void remove(MessageReference node) {
1:         } else {
1:     public synchronized void reset() {
1:     public synchronized int size() {
1:     public synchronized boolean isEmpty() {
0:         return pendingCount <= 0;
1:      * Informs the Broker if the subscription needs to intervention to recover
1:      * it's state e.g. DurableTopicSubscriber may do
0:     public synchronized boolean isRecoveryRequired() {
0:     public synchronized PendingMessageCursor getNonPersistent() {
0:     public synchronized void setNonPersistent(PendingMessageCursor nonPersistent) {
1:         this.nonPersistent = nonPersistent;
0:     public synchronized void setMaxBatchSize(int maxBatchSize) {
1:         if (nonPersistent != null) {
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:     public synchronized void setUsageManager(UsageManager usageManager) {
/////////////////////////////////////////////////////////////////////////
1:     }
1:     protected synchronized PendingMessageCursor getNextCursor() throws Exception {
1:         if (currentCursor == null || !currentCursor.hasMessagesBufferedToDeliver()) {
1:             currentCursor = currentCursor == persistent ? nonPersistent : persistent;
1:             // sanity check
1:                 currentCursor = currentCursor == persistent ? nonPersistent : persistent;
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:d112ad5
/////////////////////////////////////////////////////////////////////////
0: //            nonPersistent.clear();
0: //            nonPersistent.stop();
0: //            nonPersistent.gc();
1:           nonPersistent.destroy();
commit:926fdd7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @param broker
/////////////////////////////////////////////////////////////////////////
0:             nonPersistent.clear();
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         pendingCount = persistent.size() + nonPersistent.size();
1: 
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
author:Gary Tully
-------------------------------------------------------------------------------
commit:cb96783
/////////////////////////////////////////////////////////////////////////
1:         boolean cacheEnabled = isUseCache();
/////////////////////////////////////////////////////////////////////////
1:             setCacheEnabled(cacheEnabled);
commit:aad7e73
/////////////////////////////////////////////////////////////////////////
1:      * @see org.apache.activemq.broker.region.cursors.PendingMessageCursor
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     public boolean isCacheEnabled() {
0:         cacheEnabled = isUseCache();
1:         if (cacheEnabled) {
1:             if (persistent != null) {
1:                 cacheEnabled &= persistent.isCacheEnabled();
1:             }
1:             if (nonPersistent != null) {
1:                 cacheEnabled &= nonPersistent.isCacheEnabled();
1:             }
1:         }
1:         return cacheEnabled;
1:     }
commit:81f0cc0
/////////////////////////////////////////////////////////////////////////
0:         try {
1:             getNextCursor();
0:         } catch (Exception e) {
0:             LOG.error("Failed to get current cursor ", e);
1:             throw new RuntimeException(e);
1:        }
1:        return currentCursor != null ? currentCursor.hasNext() : false;
/////////////////////////////////////////////////////////////////////////
1:         pendingCount = persistent.size() + nonPersistent.size();        
/////////////////////////////////////////////////////////////////////////
1:         if (pendingCount < 0) {
1:             pendingCount = persistent.size() + nonPersistent.size();
1:         }
1:         // if negative, more messages arrived in store since last reset so non empty
1:         return pendingCount == 0;
/////////////////////////////////////////////////////////////////////////
0:         pendingCount = persistent.size() + nonPersistent.size();
commit:5d93518
/////////////////////////////////////////////////////////////////////////
1:         super.stop();
author:Robert Davies
-------------------------------------------------------------------------------
commit:00879cf
/////////////////////////////////////////////////////////////////////////
1:     private final Broker broker;
1:     private final Queue queue;
1:     private final QueueStorePrefetch persistent;
0:      * @param broker 
1:         super((queue != null ? queue.isPrioritizedMessages():false));
/////////////////////////////////////////////////////////////////////////
1:                 nonPersistent = new FilePendingMessageCursor(broker,queue.getName(),this.prioritizedMessages);
1:                 nonPersistent = new VMPendingMessageCursor(this.prioritizedMessages);
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:785454a
/////////////////////////////////////////////////////////////////////////
1:     
1:     public void setMemoryUsageHighWaterMark(int memoryUsageHighWaterMark) {
1:         super.setMemoryUsageHighWaterMark(memoryUsageHighWaterMark);
1:         if (persistent != null) {
1:             persistent.setMemoryUsageHighWaterMark(memoryUsageHighWaterMark);
1:         }
1:         if (nonPersistent != null) {
1:             nonPersistent.setMemoryUsageHighWaterMark(memoryUsageHighWaterMark);
1:         }
1:     }
commit:47cfa55
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     
1:     public void release() {
1:         nonPersistent.release();
1:         persistent.release();
1:     }
1: 
commit:0f1ef01
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.ActiveMQMessageAudit;
0: import org.apache.activemq.kaha.Store;
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void addMessageLast(MessageReference node) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void addMessageFirst(MessageReference node) throws Exception {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void reset() {
commit:8ab5f45
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public void addMessageLast(MessageReference node) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void addMessageFirst(MessageReference node) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     
0:     public synchronized void release() {
0:     	nonPersistent.release();
0:     	persistent.release();
1:     }
/////////////////////////////////////////////////////////////////////////
0:     public void reset() {
commit:0326ab7
/////////////////////////////////////////////////////////////////////////
1:     public boolean isRecoveryRequired() {
1:     public PendingMessageCursor getNonPersistent() {
1:     public void setNonPersistent(PendingMessageCursor nonPersistent) {
1:     public void setMaxBatchSize(int maxBatchSize) {
/////////////////////////////////////////////////////////////////////////
1:     public void setMaxProducersToAudit(int maxProducersToAudit) {
/////////////////////////////////////////////////////////////////////////
1:     public void setMaxAuditDepth(int maxAuditDepth) {
/////////////////////////////////////////////////////////////////////////
1:     public void setEnableAudit(boolean enableAudit) {
/////////////////////////////////////////////////////////////////////////
1:     public void setUseCache(boolean useCache) {
/////////////////////////////////////////////////////////////////////////
1:     public void setSystemUsage(SystemUsage usageManager) {
commit:512b0c7
/////////////////////////////////////////////////////////////////////////
1:             if (broker.getBrokerService().isPersistent()) {
0:                 nonPersistent = new FilePendingMessageCursor(broker,queue.getName());
1:             }else {
0:                 nonPersistent = new VMPendingMessageCursor();
1:             }
commit:2a153b0
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void setUseCache(boolean useCache) {
commit:6d0c552
/////////////////////////////////////////////////////////////////////////
0:         boolean result = true;//pendingCount > 0;
commit:071b4b1
/////////////////////////////////////////////////////////////////////////
1:     
0:     public void setUseCache(boolean useCache) {
1:         super.setUseCache(useCache);
1:         if (persistent != null) {
1:             persistent.setUseCache(useCache);
1:         }
1:         if (nonPersistent != null) {
1:             nonPersistent.setUseCache(useCache);
1:         }
1:     }
commit:55810b3
/////////////////////////////////////////////////////////////////////////
1:         nonPersistent.setMessageAudit(getMessageAudit());
1:         persistent.setMessageAudit(getMessageAudit());
commit:23cda2d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.Broker;
/////////////////////////////////////////////////////////////////////////
0:     private Broker broker;
/////////////////////////////////////////////////////////////////////////
1:     public StoreQueueCursor(Broker broker,Queue queue) {
1:         this.broker=broker;
/////////////////////////////////////////////////////////////////////////
0:             nonPersistent = new FilePendingMessageCursor(broker,queue.getName());
commit:1ee0017
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.ActiveMQMessageAudit;
/////////////////////////////////////////////////////////////////////////
1:         super.start();
1:             nonPersistent.setEnableAudit(isEnableAudit());
1:             nonPersistent.setMaxAuditDepth(getMaxAuditDepth());
1:             nonPersistent.setMaxProducersToAudit(getMaxProducersToAudit());
/////////////////////////////////////////////////////////////////////////
0:         super.stop();
/////////////////////////////////////////////////////////////////////////
1:     
1:     
0:     public synchronized void setMaxProducersToAudit(int maxProducersToAudit) {
1:         super.setMaxProducersToAudit(maxProducersToAudit);
1:         if (persistent != null) {
1:             persistent.setMaxProducersToAudit(maxProducersToAudit);
1:         }
1:         if (nonPersistent != null) {
1:             nonPersistent.setMaxProducersToAudit(maxProducersToAudit);
1:         }
1:     }
1: 
0:     public synchronized void setMaxAuditDepth(int maxAuditDepth) {
1:         super.setMaxAuditDepth(maxAuditDepth);
1:         if (persistent != null) {
1:             persistent.setMaxAuditDepth(maxAuditDepth);
1:         }
1:         if (nonPersistent != null) {
1:             nonPersistent.setMaxAuditDepth(maxAuditDepth);
1:         }
1:     }
1:     
0:     public synchronized void setEnableAudit(boolean enableAudit) {
1:         super.setEnableAudit(enableAudit);
1:         if (persistent != null) {
1:             persistent.setEnableAudit(enableAudit);
1:         }
1:         if (nonPersistent != null) {
1:             nonPersistent.setEnableAudit(enableAudit);
1:         }
1:     }
1: 
1: 
commit:6d8e2c5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.SystemUsage;
/////////////////////////////////////////////////////////////////////////
1:             nonPersistent.setSystemUsage(systemUsage);
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void setSystemUsage(SystemUsage usageManager) {
1:         super.setSystemUsage(usageManager);
1:             persistent.setSystemUsage(usageManager);
1:             nonPersistent.setSystemUsage(usageManager);
commit:a3e3821
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void addMessageFirst(MessageReference node) throws Exception{
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void clear(){
/////////////////////////////////////////////////////////////////////////
0:     public synchronized int size(){
/////////////////////////////////////////////////////////////////////////
0:     public synchronized boolean isRecoveryRequired(){
0:     public synchronized PendingMessageCursor getNonPersistent(){
0:     public synchronized void setNonPersistent(PendingMessageCursor nonPersistent){
0:     public synchronized void setMaxBatchSize(int maxBatchSize){
/////////////////////////////////////////////////////////////////////////
1:     public synchronized void gc() {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void setUsageManager(UsageManager usageManager){
commit:e5efc58
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:         currentCursor = persistent;
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void remove(MessageReference node){
/////////////////////////////////////////////////////////////////////////
1:         persistent.reset();
/////////////////////////////////////////////////////////////////////////
0:         if(currentCursor == null || !currentCursor.hasMessagesBufferedToDeliver()){
0:             //sanity check
1:             if (currentCursor.isEmpty()) {
0:                 currentCursor=currentCursor==persistent?nonPersistent:persistent;
1:             }
commit:415d46c
/////////////////////////////////////////////////////////////////////////
0:         pendingCount=persistent.size() + nonPersistent.size();
/////////////////////////////////////////////////////////////////////////
1:     
0:     public void addMessageFirst(MessageReference node) throws Exception{
0:         if(node!=null){
0:             Message msg=node.getMessage();
0:             if(started){
1:                 pendingCount++;
0:                 if(!msg.isPersistent()){
1:                     nonPersistent.addMessageFirst(node);
1:                 }
1:             }
0:             if(msg.isPersistent()){
1:                 persistent.addMessageFirst(node);
1:             }
1:         }
1:     }
1:         
/////////////////////////////////////////////////////////////////////////
0:         MessageReference result = currentCursor!=null?currentCursor.next():null;
1:         return result;
/////////////////////////////////////////////////////////////////////////
1:         if (!node.isPersistent()) {
1:             nonPersistent.remove(node);
0:         }else {
1:             persistent.remove(node);
1:         }
commit:3bf0245
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.memory.UsageManager;
/////////////////////////////////////////////////////////////////////////
0:             nonPersistent.setUsageManager(usageManager);
/////////////////////////////////////////////////////////////////////////
1:             nonPersistent.gc();
1:         persistent.gc();
/////////////////////////////////////////////////////////////////////////
1:     
0:     public void gc() {
1:         if (persistent != null) {
1:             persistent.gc();
1:         }
1:         if (nonPersistent != null) {
0:             nonPersistent.gc();
1:         }
1:     }
1:     
0:     public void setUsageManager(UsageManager usageManager){
0:         super.setUsageManager(usageManager);
1:         if (persistent != null) {
0:             persistent.setUsageManager(usageManager);
1:         }
1:         if (nonPersistent != null) {
0:             nonPersistent.setUsageManager(usageManager);
1:         }
1:      }
0:             currentCursor=currentCursor==persistent?nonPersistent:persistent;
commit:e006780
/////////////////////////////////////////////////////////////////////////
1:         persistent.start();
/////////////////////////////////////////////////////////////////////////
1:         persistent.stop();
commit:629bc81
/////////////////////////////////////////////////////////////////////////
1: /**
0:  * 
0:  * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE
0:  * file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file
0:  * to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
0:  * License. You may obtain a copy of the License at
0:  * 
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  * 
0:  * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
0:  * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
0:  * specific language governing permissions and limitations under the License.
1:  */
1: 
1: package org.apache.activemq.broker.region.cursors;
1: 
0: import java.util.Iterator;
1: import org.apache.activemq.broker.region.MessageReference;
1: import org.apache.activemq.broker.region.Queue;
1: import org.apache.activemq.command.Message;
0: import org.apache.activemq.kaha.Store;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
1: /**
1:  * Store based Cursor for Queues
0:  * 
0:  * @version $Revision: 474985 $
1:  */
0: public class StoreQueueCursor extends AbstractPendingMessageCursor{
1: 
0:     static private final Log log=LogFactory.getLog(StoreQueueCursor.class);
0:     private int pendingCount=0;
0:     private Queue queue;
0:     private Store tmpStore;
1:     private PendingMessageCursor nonPersistent;
0:     private QueueStorePrefetch persistent;
0:     private boolean started;
1:     private PendingMessageCursor currentCursor;
1:    
1:     /**
1:      * Construct
0:      * 
1:      * @param queue
0:      * @param tmpStore
1:      */
0:     public StoreQueueCursor(Queue queue,Store tmpStore){
0:         this.queue=queue;
0:         this.tmpStore=tmpStore;
0:         this.persistent=new QueueStorePrefetch(queue);
1:     }
1: 
0:     public synchronized void start() throws Exception{
0:         started=true;
0:         if(nonPersistent==null){
0:             nonPersistent=new FilePendingMessageCursor(queue.getDestination(),tmpStore);
1:             nonPersistent.setMaxBatchSize(getMaxBatchSize());
1:         }
1:         nonPersistent.start();
0:         pendingCount=persistent.size();
1:     }
1: 
0:     public synchronized void stop() throws Exception{
0:         started=false;
0:         if(nonPersistent!=null){
0:             nonPersistent.stop();
1:         }
0:         pendingCount=0;
1:     }
1: 
0:     public synchronized void addMessageLast(MessageReference node) throws Exception{
0:         if(node!=null){
0:             Message msg=node.getMessage();
0:             if(started){
1:                 pendingCount++;
0:                 if(!msg.isPersistent()){
0:                     nonPersistent.addMessageLast(node);
1:                 }
1:             }
0:             if(msg.isPersistent()){
0:                 persistent.addMessageLast(node);
1:             }
1:         }
1:     }
1: 
0:     public void clear(){
0:         pendingCount=0;
1:     }
1: 
0:     public synchronized boolean hasNext(){
0:         boolean result=pendingCount>0;
0:         if(result){
0:             try{
0:                 currentCursor=getNextCursor();
0:             }catch(Exception e){
0:                 log.error("Failed to get current cursor ",e);
0:                 throw new RuntimeException(e);
1:             }
0:             result=currentCursor!=null?currentCursor.hasNext():false;
1:         }
0:         return result;
1:     }
1: 
0:     public synchronized MessageReference next(){
0:         return currentCursor!=null?currentCursor.next():null;
1:     }
1: 
0:     public synchronized void remove(){
0:         if(currentCursor!=null){
1:             currentCursor.remove();
1:         }
1:         pendingCount--;
1:     }
1: 
0:     public void remove(MessageReference node){
1:         pendingCount--;
1:     }
1: 
0:     public synchronized void reset(){
1:         nonPersistent.reset();
1:     }
1: 
0:     public int size(){
1:         return pendingCount;
1:     }
1: 
0:     public synchronized boolean isEmpty(){
0:         return pendingCount<=0;
1:     }
1: 
1:     /**
0:      * Informs the Broker if the subscription needs to intervention to recover it's state e.g. DurableTopicSubscriber
0:      * may do
0:      * 
0:      * @see org.apache.activemq.region.cursors.PendingMessageCursor
1:      * @return true if recovery required
1:      */
0:     public boolean isRecoveryRequired(){
1:         return false;
1:     }
1: 
1:     /**
1:      * @return the nonPersistent Cursor
1:      */
0:     public PendingMessageCursor getNonPersistent(){
1:         return this.nonPersistent;
1:     }
1: 
1:     /**
1:      * @param nonPersistent cursor to set
1:      */
0:     public void setNonPersistent(PendingMessageCursor nonPersistent){
0:         this.nonPersistent=nonPersistent;
1:     }
1: 
0:     public void setMaxBatchSize(int maxBatchSize){
1:         persistent.setMaxBatchSize(maxBatchSize);
0:         if(nonPersistent!=null){
1:             nonPersistent.setMaxBatchSize(maxBatchSize);
1:         }
1:         super.setMaxBatchSize(maxBatchSize);
1:     }
1: 
0:     protected synchronized PendingMessageCursor getNextCursor() throws Exception{
0:         if(currentCursor==null||currentCursor.isEmpty()){
0:             currentCursor = currentCursor == persistent ? nonPersistent : persistent;
1:         }
1:         return currentCursor;
1:     }
1: }
============================================================================