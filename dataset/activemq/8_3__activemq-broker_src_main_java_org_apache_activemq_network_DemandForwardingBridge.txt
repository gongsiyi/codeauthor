1:d29ca2a: /**
1:7f883f6:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:7f883f6:  * contributor license agreements.  See the NOTICE file distributed with
1:7f883f6:  * this work for additional information regarding copyright ownership.
1:7f883f6:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:7f883f6:  * (the "License"); you may not use this file except in compliance with
1:7f883f6:  * the License.  You may obtain a copy of the License at
1:7f883f6:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:7f883f6:  *
1:7f883f6:  * Unless required by applicable law or agreed to in writing, software
1:7f883f6:  * distributed under the License is distributed on an "AS IS" BASIS,
1:7f883f6:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7f883f6:  * See the License for the specific language governing permissions and
1:7f883f6:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.network;
1:f812e34: 
1:d29ca2a: import org.apache.activemq.transport.Transport;
1:74a7a8b: 
1:d29ca2a: /**
1:5a429d9:  * Forwards messages from the local broker to the remote broker based on demand.
1:7f883f6:  *
1:68d245f:  * @org.apache.xbean.XBean
1:b0c2a40:  *
1:d29ca2a:  */
1:687a45a: public class DemandForwardingBridge extends DemandForwardingBridgeSupport {
1:f812e34: 
1:f812e34:     public DemandForwardingBridge(NetworkBridgeConfiguration configuration, Transport localBroker,
1:f812e34:                                   Transport remoteBroker) {
1:f812e34:         super(configuration, localBroker, remoteBroker);
1:8963244:     }
2:8963244: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(DemandForwardingBridge.class);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.info("Disconnecting loop back connection.");
/////////////////////////////////////////////////////////////////////////
0:                     LOG.info("Disconnecting loop back connection.");
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
1: 
/////////////////////////////////////////////////////////////////////////
commit:f812e34
/////////////////////////////////////////////////////////////////////////
0:     protected final BrokerId remoteBrokerPath[] = new BrokerId[] {null};
1:     public DemandForwardingBridge(NetworkBridgeConfiguration configuration, Transport localBroker,
1:                                   Transport remoteBroker) {
1:         super(configuration, localBroker, remoteBroker);
0:         synchronized (brokerInfoMutex) {
0:             BrokerInfo remoteBrokerInfo = (BrokerInfo)command;
0:             remoteBrokerId = remoteBrokerInfo.getBrokerId();
0:             remoteBrokerPath[0] = remoteBrokerId;
0:             remoteBrokerName = remoteBrokerInfo.getBrokerName();
0:             if (localBrokerId != null) {
0:                 if (localBrokerId.equals(remoteBrokerId)) {
0:                     // waitStarted();
0:             remoteBrokerNameKnownLatch.countDown();
0:         info.setBrokerPath(appendToBrokerPath(info.getBrokerPath(), getRemoteBrokerPath()));
0:         synchronized (brokerInfoMutex) {
0:             localBrokerId = ((BrokerInfo)command).getBrokerId();
0:             localBrokerPath[0] = localBrokerId;
0:             if (remoteBrokerId != null) {
0:                 if (remoteBrokerId.equals(localBrokerId)) {
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0:     protected BrokerId[] getRemoteBrokerPath() {
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:58d4605
/////////////////////////////////////////////////////////////////////////
0:         	remoteBrokerNameKnownLatch.countDown();
commit:7f883f6
/////////////////////////////////////////////////////////////////////////
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
commit:ad2546f
/////////////////////////////////////////////////////////////////////////
commit:446629b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.NetworkBridgeFilter;
/////////////////////////////////////////////////////////////////////////
0:     static final Log log=LogFactory.getLog(DemandForwardingBridge.class);
/////////////////////////////////////////////////////////////////////////
0:     public static boolean contains(BrokerId[] brokerPath,BrokerId brokerId){
/////////////////////////////////////////////////////////////////////////
0:         sub.getLocalInfo().setAdditionalPredicate(new NetworkBridgeFilter(remoteBrokerPath[0], networkTTL));
/////////////////////////////////////////////////////////////////////////
commit:8963244
/////////////////////////////////////////////////////////////////////////
0:     
/////////////////////////////////////////////////////////////////////////
0:     
0:     private boolean decreaseNetowrkConsumerPriority;
/////////////////////////////////////////////////////////////////////////
0:             
0:             if( decreaseNetowrkConsumerPriority ) {
0:                 byte priority=ConsumerInfo.NETWORK_CONSUMER_PRIORITY;
0:                 if(priority>Byte.MIN_VALUE&&info.getBrokerPath()!=null&&info.getBrokerPath().length>1){
0:                     // The longer the path to the consumer, the less it's consumer priority.
0:                     priority-=info.getBrokerPath().length+1;
1:                 }
0:                 sub.localInfo.setPriority(priority);
0:             
/////////////////////////////////////////////////////////////////////////
0: 
0:     public boolean isDecreaseNetowrkConsumerPriority() {
0:         return decreaseNetowrkConsumerPriority;
1:     }
0: 
0:     public void setDecreaseNetowrkConsumerPriority(boolean decreaseNetowrkConsumerPriority) {
0:         this.decreaseNetowrkConsumerPriority = decreaseNetowrkConsumerPriority;
1:     }
commit:68d245f
/////////////////////////////////////////////////////////////////////////
1:  * @org.apache.xbean.XBean
commit:27329ab
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.WireFormatInfo;
/////////////////////////////////////////////////////////////////////////
0:                 switch ( command.getDataStructureType() ) {
0:                     case WireFormatInfo.DATA_STRUCTURE_TYPE:
0:                     break;
0:                     default:
0:                         log.warn("Unexpected remote command: "+command);
0:                 }
/////////////////////////////////////////////////////////////////////////
0:                 switch ( command.getDataStructureType() ) {
0:                 case WireFormatInfo.DATA_STRUCTURE_TYPE:
0:                 break;
0:                 default:
0:                     log.warn("Unexpected local command: "+command);
0:                 }
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
1:  */
1: package org.apache.activemq.network;
0: 
0: import java.io.IOException;
0: 
0: import javax.jms.JMSException;
0: 
0: import org.apache.activemq.advisory.AdvisorySupport;
0: import org.apache.activemq.command.ActiveMQTopic;
0: import org.apache.activemq.command.BrokerId;
0: import org.apache.activemq.command.BrokerInfo;
0: import org.apache.activemq.command.Command;
0: import org.apache.activemq.command.CommandTypes;
0: import org.apache.activemq.command.ConnectionId;
0: import org.apache.activemq.command.ConnectionInfo;
0: import org.apache.activemq.command.ConsumerId;
0: import org.apache.activemq.command.ConsumerInfo;
0: import org.apache.activemq.command.DataStructure;
0: import org.apache.activemq.command.Message;
0: import org.apache.activemq.command.MessageAck;
0: import org.apache.activemq.command.MessageDispatch;
0: import org.apache.activemq.command.ProducerInfo;
0: import org.apache.activemq.command.RemoveInfo;
0: import org.apache.activemq.command.SessionInfo;
0: import org.apache.activemq.command.ShutdownInfo;
0: import org.apache.activemq.filter.BooleanExpression;
0: import org.apache.activemq.filter.MessageEvaluationContext;
1: import org.apache.activemq.transport.Transport;
0: import org.apache.activemq.transport.TransportListener;
0: import org.apache.activemq.util.IdGenerator;
0: import org.apache.activemq.util.JMSExceptionSupport;
0: import org.apache.activemq.util.LongSequenceGenerator;
0: import org.apache.activemq.util.ServiceStopper;
0: import org.apache.activemq.util.ServiceSupport;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
0: 
1: /**
0:  * Forwards messages from the local broker to the remote broker based on 
0:  * demand.
0:  * 
0:  * @org.xbean.XBean
0:  * 
0:  * @version $Revision$
1:  */
0: public class DemandForwardingBridge implements Bridge {
0: 
0:     static final private Log log = LogFactory.getLog(DemandForwardingBridge.class);
0:     
0:     private final Transport localBroker;
0:     private final Transport remoteBroker;
0:     
0:     IdGenerator idGenerator = new IdGenerator();
0:     LongSequenceGenerator consumerIdGenerator = new LongSequenceGenerator();
0:     
0:     ConnectionInfo connectionInfo;
0:     SessionInfo sessionInfo;
0:     ProducerInfo producerInfo;
0:     
0:     private String clientId;
0:     private int prefetchSize=1000;
0:     private boolean dispatchAsync;
0:     private String destinationFilter = ">";
0:     
0:     private ConsumerInfo demandConsumerInfo;
0:     private int demandConsumerDispatched;
0:     
0:     BrokerId localBrokerId;
0:     BrokerId remoteBrokerId;
0:     
0:     private static class DemandSubscription {
0:         ConsumerInfo remoteInfo;
0:         ConsumerInfo localInfo;
0:         int dispatched;
0:         
0:         public DemandSubscription(ConsumerInfo info) {
0:             remoteInfo = info;
0:             localInfo = info.copy();
0:         }
0:     }
0:     
0:     ConcurrentHashMap subscriptionMapByLocalId = new ConcurrentHashMap();
0:     ConcurrentHashMap subscriptionMapByRemoteId = new ConcurrentHashMap();
0:     
0:     protected final BrokerId localBrokerPath[] = new BrokerId[] {null};
0:     protected final BrokerId remoteBrokerPath[] = new BrokerId[] {null};
0:     
0:     public DemandForwardingBridge(Transport localBroker, Transport remoteBroker) {
0:         this.localBroker = localBroker;
0:         this.remoteBroker = remoteBroker;
0:     }
0: 
0:     public void start() throws Exception {
0:         log.info("Starting a network connection between " + localBroker + " and " + remoteBroker + " has been established.");
0: 
0:         localBroker.setTransportListener(new TransportListener(){
0:             public void onCommand(Command command) {
0:                 serviceLocalCommand(command);
0:             }
0:             public void onException(IOException error) {
0:                 serviceLocalException(error);
0:             }
0:         });
0:         
0:         remoteBroker.setTransportListener(new TransportListener(){
0:             public void onCommand(Command command) {
0:                 serviceRemoteCommand(command);
0:             }
0:             public void onException(IOException error) {
0:                 serviceRemoteException(error);
0:             }
0:         });
0:         
0:         localBroker.start();
0:         remoteBroker.start();
0:         
0:     }
0: 
0:     protected void triggerStartBridge() throws IOException {
0:         Thread thead = new Thread() {
0:             public void run() {
0:                 try {
0:                     startBridge();
0:                 }
0:                 catch (IOException e) {
0:                     log.error("Failed to start network bridge: " + e, e);
0:                 }
0:             }
0:         };
0:         thead.start();
0:     }
0:     
0:     protected void startBridge() throws IOException {
0:         BrokerInfo brokerInfo = new BrokerInfo();
0:         remoteBroker.oneway(brokerInfo);
0:         connectionInfo = new ConnectionInfo();
0:         connectionInfo.setConnectionId(new ConnectionId(idGenerator.generateId()));
0:         connectionInfo.setClientId(clientId);
0:         localBroker.oneway(connectionInfo);
0:         remoteBroker.oneway(connectionInfo);
0: 
0:         sessionInfo=new SessionInfo(connectionInfo, 1);
0:         localBroker.oneway(sessionInfo);
0:         remoteBroker.oneway(sessionInfo);
0:         
0:         producerInfo = new ProducerInfo(sessionInfo, 1);
0:         producerInfo.setResponseRequired(false);
0:         remoteBroker.oneway(producerInfo);
0: 
0:         // Listen to consumer advisory messages on the remote broker to determine demand.
0:         demandConsumerInfo = new ConsumerInfo(sessionInfo, 1);
0:         demandConsumerInfo.setDispatchAsync(dispatchAsync);
0:         demandConsumerInfo.setDestination(new ActiveMQTopic(AdvisorySupport.CONSUMER_ADVISORY_TOPIC_PREFIX+destinationFilter));
0:         demandConsumerInfo.setPrefetchSize(prefetchSize);
0:         remoteBroker.oneway(demandConsumerInfo);
0:         
0:         log.info("Network connection between " + localBroker + " and " + remoteBroker + " has been established.");
0:     }
0:     
0:     public void stop() throws Exception{        
0:         try {
0:             if( connectionInfo!=null ) {
0:                 localBroker.request(connectionInfo.createRemoveCommand());
0:                 remoteBroker.request(connectionInfo.createRemoveCommand());
0:             }
0:             localBroker.setTransportListener(null);
0:             remoteBroker.setTransportListener(null);
0:             remoteBroker.oneway(new ShutdownInfo());
0:             localBroker.oneway(new ShutdownInfo());
0:         }catch(IOException e){
0:           log.debug("Caught exception stopping",e);
0:         } finally {
0:             ServiceStopper ss = new ServiceStopper();
0:             ss.stop(localBroker);
0:             ss.stop(remoteBroker);
0:             ss.throwFirstException();
0:         }
0:     }
0:     
0:     protected void serviceRemoteException(IOException error) {
0:         log.info("Network connection between " + localBroker + " and " + remoteBroker + " shutdown: "+error.getMessage(), error);
0:         ServiceSupport.dispose(this);
0:     }
0:     
0:     protected void serviceRemoteCommand(Command command) {
0:         try {
0:             if( command.isMessageDispatch() ) {
0:                 MessageDispatch md = (MessageDispatch) command;
0:                 serviceRemoteConsumerAdvisory(md.getMessage().getDataStructure());
0:                 demandConsumerDispatched++;
0:                 if( demandConsumerDispatched > (demandConsumerInfo.getPrefetchSize()*.75) ) {
0:                     remoteBroker.oneway(new MessageAck(md, MessageAck.STANDARD_ACK_TYPE, demandConsumerDispatched));
0:                     demandConsumerDispatched=0;
0:                 }
0:             } else if ( command.isBrokerInfo() ) {
0:                 synchronized( this ) {
0:                     remoteBrokerId = ((BrokerInfo)command).getBrokerId();
0:                     remoteBrokerPath[0] = remoteBrokerId;
0:                     if( localBrokerId !=null) {
0:                         if( localBrokerId.equals(remoteBrokerId) ) {
0:                             log.info("Disconnecting loop back connection.");
0:                             ServiceSupport.dispose(this);
0:                         } else {
0:                             triggerStartBridge();                            
0:                         }
0:                     }
0:                 }
0:             } else {
0:                log.warn("Unexpected remote command: "+command);
0:             }
0:         } catch (IOException e) {
0:             serviceRemoteException(e);
0:         }
0:     }
0: 
0:     private void serviceRemoteConsumerAdvisory(DataStructure data) throws IOException {
0:         if( data.getClass() == ConsumerInfo.class ) {
0:                        
0:             // Create a new local subscription
0:             ConsumerInfo info = (ConsumerInfo) data;
0:             BrokerId[] path = info.getBrokerPath();
0: 
0:             if( (path!=null && path.length>0) || info.isNetworkSubscription() ) {
0:                 // Ignore:  We only support directly connected brokers for now.
0:                 return;
0:             }
0:             if( contains(info.getBrokerPath(), localBrokerPath[0]) ) {
0:                 // Ignore this consumer as it's a consumer we locally sent to the broker.
0:                 return;
0:             }
0:             
0:             if( log.isTraceEnabled() )
0:                 log.trace("Forwarding sub on " + localBroker + " from " + remoteBroker + " on  "+info);
0: 
0:             
0:             // Update the packet to show where it came from.
0:             info = info.copy();
0:             info.setBrokerPath( appendToBrokerPath(info.getBrokerPath(), remoteBrokerPath) );
0:                 
0:             DemandSubscription sub  = new DemandSubscription(info);
0:             sub.localInfo.setConsumerId( new ConsumerId(sessionInfo.getSessionId(), consumerIdGenerator.getNextSequenceId()) );
0:             sub.localInfo.setDispatchAsync(dispatchAsync);
0:             sub.localInfo.setPrefetchSize(prefetchSize);
0:             byte priority = ConsumerInfo.NETWORK_CONSUMER_PRIORITY;
0:             if( priority > Byte.MIN_VALUE && info.getBrokerPath()!=null && info.getBrokerPath().length>1 ) {
0:                 // The longer the path to the consumer, the less it's consumer priority.
0:                 priority -= info.getBrokerPath().length+1;
0:             }
0:             sub.localInfo.setPriority(priority);
0:             subscriptionMapByLocalId.put(sub.localInfo.getConsumerId(), sub);
0:             subscriptionMapByRemoteId.put(sub.remoteInfo.getConsumerId(), sub);
0:             sub.localInfo.setBrokerPath(info.getBrokerPath());
0:             sub.localInfo.setNetworkSubscription(true);
0:             // This works for now since we use a VM connection to the local broker.
0:             // may need to change if we ever subscribe to a remote broker.
0:             sub.localInfo.setAdditionalPredicate(new BooleanExpression(){
0:                 public boolean matches(MessageEvaluationContext message) throws JMSException {
0:                     try {
0:                         return matchesForwardingFilter(message.getMessage());
0:                     } catch (IOException e) {
0:                         throw JMSExceptionSupport.create(e);
0:                     }
0:                 }
0:                 public Object evaluate(MessageEvaluationContext message) throws JMSException {
0:                     return matches(message) ? Boolean.TRUE : Boolean.FALSE;
0:                 }
0:             });
0:                         
0:             localBroker.oneway(sub.localInfo);            
0:         }
0:         if( data.getClass() == RemoveInfo.class ) {
0:             ConsumerId id = (ConsumerId) ((RemoveInfo)data).getObjectId();
0:             DemandSubscription sub = (DemandSubscription)subscriptionMapByRemoteId.remove(id);
0:             if( sub !=null ) {
0:                 subscriptionMapByLocalId.remove(sub.localInfo.getConsumerId());
0:                 localBroker.oneway(sub.localInfo.createRemoveCommand());
0:             }
0:         }
0:     }
0: 
0:     protected void serviceLocalException(IOException error) {
0:         log.info("Network connection between " + localBroker + " and " + remoteBroker + " shutdown: "+error.getMessage(), error);
0:         ServiceSupport.dispose(this);
0:     }
0: 
0:     boolean matchesForwardingFilter(Message message) {
0:         if( message.isRecievedByDFBridge() || contains(message.getBrokerPath(), remoteBrokerPath[0]) )
0:             return false;
0: 
0:         // Don't propagate advisory messages about network subscriptions
0:         if( message.isAdvisory() 
0:                 && message.getDataStructure()!=null
0:                 && message.getDataStructure().getDataStructureType()==CommandTypes.CONSUMER_INFO) {
0:             
0:             ConsumerInfo info=(ConsumerInfo) message.getDataStructure();
0:             if(info.isNetworkSubscription()) {
0:                 return false;
0:             }
0:         }
0:         return true;
0:     }
0:     
0:     protected void serviceLocalCommand(Command command) {
0:         boolean trace = log.isTraceEnabled();
0:         try {
0:             if( command.isMessageDispatch() ) {
0:                 MessageDispatch md = (MessageDispatch) command;
0:                 Message message = md.getMessage();
0:                 DemandSubscription sub = (DemandSubscription)subscriptionMapByLocalId.get(md.getConsumerId());
0:                 if( sub!=null ) {
0:                    
0:                     message = message.copy();
0:                     
0:                     // Update the packet to show where it came from.
0:                     message.setBrokerPath( appendToBrokerPath(message.getBrokerPath(), localBrokerPath) );
0: 
0:                     message.setProducerId(producerInfo.getProducerId());
0:                     message.setDestination( md.getDestination() );
0:                     
0:                     if( message.getOriginalTransactionId()==null )
0:                         message.setOriginalTransactionId(message.getTransactionId());
0:                     message.setTransactionId(null);
0:                     message.setRecievedByDFBridge(true);
0:                     message.evictMarshlledForm();
0: 
0:                     if( trace )
0:                         log.trace("bridging " + localBroker + " -> " + remoteBroker + ": "+message);
0:                     
0:                     remoteBroker.oneway( message );
0: 
0:                     sub.dispatched++;
0:                     if( sub.dispatched > (sub.localInfo.getPrefetchSize()*.75) ) {
0:                         localBroker.oneway(new MessageAck(md, MessageAck.STANDARD_ACK_TYPE, demandConsumerDispatched));
0:                         sub.dispatched=0;
0:                     }                    
0:                 }
0:             } else if ( command.isBrokerInfo() ) {
0:                 synchronized( this ) {
0:                     localBrokerId = ((BrokerInfo)command).getBrokerId();
0:                     localBrokerPath[0] = localBrokerId;
0:                     if( remoteBrokerId !=null  ) {
0:                         if( remoteBrokerId.equals(localBrokerId) ) {
0:                             log.info("Disconnecting loop back connection.");
0:                             ServiceSupport.dispose(this);
0:                         } else {
0:                             triggerStartBridge();                            
0:                         }
0:                     }
0:                 }
0:             } else {
0:                 log.warn("Unexpected local command: "+command);
0:             }
0:         } catch (IOException e) {
0:             serviceLocalException(e);
0:         }
0:     }
0: 
0:     public String getClientId() {
0:         return clientId;
0:     }
0: 
0:     public void setClientId(String clientId) {
0:         this.clientId = clientId;
0:     }
0: 
0:     public int getPrefetchSize() {
0:         return prefetchSize;
0:     }
0: 
0:     public void setPrefetchSize(int prefetchSize) {
0:         this.prefetchSize = prefetchSize;
0:     }
0: 
0:     public boolean isDispatchAsync() {
0:         return dispatchAsync;
0:     }
0: 
0:     public void setDispatchAsync(boolean dispatchAsync) {
0:         this.dispatchAsync = dispatchAsync;
0:     }
0: 
0:     public String getDestinationFilter() {
0:         return destinationFilter;
0:     }
0:     public void setDestinationFilter(String destinationFilter) {
0:         this.destinationFilter = destinationFilter;
0:     }
0:     
0:     private boolean contains(BrokerId[] brokerPath, BrokerId brokerId) {
0:         if( brokerPath!=null ) {
0:             for (int i = 0; i < brokerPath.length; i++) {
0:                 if( brokerId.equals(brokerPath[i]) )
0:                     return true;
0:             }
0:         }
0:         return false;
0:     }
0:     private BrokerId[] appendToBrokerPath(BrokerId[] brokerPath, BrokerId pathsToAppend[]) {
0:         if( brokerPath == null || brokerPath.length==0 )
0:             return pathsToAppend;
0:         
0:         BrokerId rc[] = new BrokerId[brokerPath.length+pathsToAppend.length];
0:         System.arraycopy(brokerPath,0,rc,0,brokerPath.length);
0:         System.arraycopy(pathsToAppend,0,rc,brokerPath.length,pathsToAppend.length);
0:         return rc;
0:     }
0: 
0: }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:a80acbb
/////////////////////////////////////////////////////////////////////////
0:  *
0:  *
author:Gary Tully
-------------------------------------------------------------------------------
commit:174c405
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:af1b232
/////////////////////////////////////////////////////////////////////////
commit:966658f
/////////////////////////////////////////////////////////////////////////
0:             localBrokerIdKnownLatch.countDown();
commit:5b8a886
/////////////////////////////////////////////////////////////////////////
0:                     if (LOG.isTraceEnabled()) {
0:                         LOG.trace(configuration.getBrokerName() + " disconnecting remote loop back connection: " + remoteBrokerName);
0:                     }
0:             if (LOG.isTraceEnabled()) {
0:                 LOG.trace("counting down remoteBrokerNameKnownLatch with: " + command);
0:             }
/////////////////////////////////////////////////////////////////////////
0:                     if (LOG.isTraceEnabled()) {
0:                         LOG.trace(configuration.getBrokerName() + " disconnecting local loop back connection.");
0:                     }
commit:21cd3e6
/////////////////////////////////////////////////////////////////////////
0:                     LOG.info(configuration.getBrokerName() + " disconnecting remote loop back connection: " + remoteBrokerName);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.info(configuration.getBrokerName() + " disconnecting local loop back connection.");
commit:543bc84
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("counting down remoteBrokerNameKnownLatch with: " + command);
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
0:     private static final Logger LOG = LoggerFactory.getLogger(DemandForwardingBridge.class);
author:Robert Davies
-------------------------------------------------------------------------------
commit:ae73f86
/////////////////////////////////////////////////////////////////////////
0:     public DemandForwardingBridge(NetworkBridgeConfiguration configuration,Transport localBroker,Transport remoteBroker){
0:         super(configuration,localBroker, remoteBroker);
/////////////////////////////////////////////////////////////////////////
0:         return new NetworkBridgeFilter(remoteBrokerPath[0], configuration.getNetworkTTL());
commit:a9c49a7
/////////////////////////////////////////////////////////////////////////
0:         info.setBrokerPath(appendToBrokerPath(info.getBrokerPath(),getRemoteBrokerPath()));
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected BrokerId[] getRemoteBrokerPath(){
0:         return remoteBrokerPath;
0:     }
commit:695a766
/////////////////////////////////////////////////////////////////////////
0:             return false;
commit:6c1d45e
/////////////////////////////////////////////////////////////////////////
0:     protected String name = "bridge";
/////////////////////////////////////////////////////////////////////////
0:             localClientId="NC_"+remoteBrokerName+"_inbound"+name;
/////////////////////////////////////////////////////////////////////////
0:             remoteConnectionInfo.setClientId("NC_"+localBrokerName+"_outbound"+name);
/////////////////////////////////////////////////////////////////////////
0:      * @return Returns the name.
0:     public String getName(){
0:         return name;
0:      * @param name The name to set.
0:     public void setName(String name){
0:         this.name=name;
/////////////////////////////////////////////////////////////////////////
0:    
0: 
commit:97fff42
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transport.TransportListener;
/////////////////////////////////////////////////////////////////////////
0:     protected boolean shutDown;
/////////////////////////////////////////////////////////////////////////
0:         remoteBroker.setTransportListener(new TransportListener(){
/////////////////////////////////////////////////////////////////////////
0: 
0:             public void transportInterupted(){
0:                 //clear any subscriptions - to try and prevent the bridge from stalling the broker
0:                 log.warn("Outbound transport to " + remoteBrokerName +  " interrupted ...");
0:                 clearDownSubscriptions();
0:                 
0:             }
0: 
0:             public void transportResumed(){
0:                 //restart and static subscriptions - the consumer advisories will be replayed
0:                 log.info("Outbound transport to " + remoteBrokerName + " resumed");
0:                 setupStaticDestinations();
0:                 
0:             }
/////////////////////////////////////////////////////////////////////////
0:     public void stop() throws Exception{
0:         shutDown = true;
0:         doStop();
0:     }
0:     protected void doStop() throws Exception{
0:         log.debug(" stopping "+localBrokerName+ " bridge to " + remoteBrokerName + " is disposed already ? "+disposed);
0:                 if(!shutDown){
0:                    remoteBroker.oneway(new ShutdownInfo());
0:                     if(localConnectionInfo!=null){
0:                         localBroker.oneway(localConnectionInfo.createRemoveCommand());
0:                         remoteBroker.oneway(remoteConnectionInfo.createRemoveCommand());
0:                     }
0:                     localBroker.oneway(new ShutdownInfo());
/////////////////////////////////////////////////////////////////////////
0:         log.debug(localBrokerName+ " bridge to " + remoteBrokerName + " stopped");
/////////////////////////////////////////////////////////////////////////
0:                                 //waitStarted();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     shutDown = true;
0:                     doStop();
0:                    
0:                     
/////////////////////////////////////////////////////////////////////////
0:     
0:     /**
0:      * @return Returns the shutDown.
0:      */
0:     public boolean isShutDown(){
0:         return shutDown;
0:     }
0: 
0:     /**
0:      * @param shutDown The shutDown to set.
0:      */
0:     public void setShutDown(boolean shutDown){
0:         this.shutDown=shutDown;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     protected void setupStaticDestinations(){
0:                 try{
0:                     addSubscription(sub);
0:                 }catch(IOException e){
0:                    log.error("Failed to add static destination " + dest,e);
0:                 }
/////////////////////////////////////////////////////////////////////////
0:      return doCreateDemandSubscription(info);
0:     }
0:     
0:     protected DemandSubscription doCreateDemandSubscription(ConsumerInfo info){
/////////////////////////////////////////////////////////////////////////
0:             hops = info.getBrokerPath() == null ? 0 : message.getBrokerPath().length;
0:             if(hops >= networkTTL){
0:                 if (log.isTraceEnabled()){
0:                     log.trace("ConsumerInfo advisory restricted to " + networkTTL + " network hops ignoring: " + message);
0:                 }
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected void clearDownSubscriptions(){
0:         
0:     }
0:   
commit:068c646
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ActiveMQDestination;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.filter.DestinationFilter;
0: import org.apache.activemq.transport.DefaultTransportListener;
/////////////////////////////////////////////////////////////////////////
0:     protected final Transport localBroker;
0:     protected final Transport remoteBroker;
0:     protected IdGenerator idGenerator=new IdGenerator();
0:     protected LongSequenceGenerator consumerIdGenerator=new LongSequenceGenerator();
0:     protected ConnectionInfo localConnectionInfo;
0:     protected ConnectionInfo remoteConnectionInfo;
0:     protected SessionInfo localSessionInfo;
0:     protected ProducerInfo producerInfo;
0:     protected String localBrokerName;
0:     protected String remoteBrokerName;
0:     protected String localClientId;
0:     protected int prefetchSize=1000;
0:     protected boolean dispatchAsync;
0:     protected String destinationFilter=">";
0:     protected ConsumerInfo demandConsumerInfo;
0:     protected int demandConsumerDispatched;
0:     protected AtomicBoolean localBridgeStarted=new AtomicBoolean(false);
0:     protected AtomicBoolean remoteBridgeStarted=new AtomicBoolean(false);
0:     protected boolean disposed=false;
0:     protected BrokerId localBrokerId;
0:     protected BrokerId remoteBrokerId;
0:     protected ActiveMQDestination[] excludedDestinations;
0:     protected ActiveMQDestination[] dynamicallyIncludedDestinations;
0:     protected ActiveMQDestination[] staticallyIncludedDestinations;
0:     protected ActiveMQDestination[] durableDestinations;   
0:     protected ConcurrentHashMap subscriptionMapByLocalId=new ConcurrentHashMap();
0:     protected ConcurrentHashMap subscriptionMapByRemoteId=new ConcurrentHashMap();
0:     protected CountDownLatch startedLatch = new CountDownLatch(2);
0:     protected Object brokerInfoMutex = new Object();
0:     protected boolean decreaseNetworkConsumerPriority;
0:     protected int networkTTL = 1;
0:     
0:     
/////////////////////////////////////////////////////////////////////////
0:         localBroker.setTransportListener(new DefaultTransportListener(){
/////////////////////////////////////////////////////////////////////////
0:         remoteBroker.setTransportListener(new DefaultTransportListener(){
/////////////////////////////////////////////////////////////////////////
0:             setupStaticDestinations();
/////////////////////////////////////////////////////////////////////////
0:     
0:    
0:     /**
0:      * stop the bridge
0:      * @throws Exception 
0:      */
/////////////////////////////////////////////////////////////////////////
0:             if((path!=null&&path.length>= networkTTL)){
0:                 if(log.isTraceEnabled())
0:                     log.trace("Ignoring Subscription " + info + " restricted to " + networkTTL + " network hops only");
0:                 if(log.isTraceEnabled())
0:                     log.trace("Ignoring sub " + info + " already routed through this broker once");
0:             if (!isPermissableDestination(info.getDestination())){
0:                 //ignore if not in the permited or in the excluded list
0:                 if(log.isTraceEnabled())
0:                     log.trace("Ignoring sub " + info + " destination " + info.getDestination() + " is not permiited");
0:                 return;
0:             }
0:             DemandSubscription sub=createDemandSubscription(info);
0:             if (sub != null){
0:                 addSubscription(sub);
0:                 if(log.isTraceEnabled())
0:                     log.trace("Forwarding sub on "+localBroker+" from "+remoteBrokerName+" :  "+info);
0:             }else {
0:                 if(log.isTraceEnabled())
0:                     log.trace("Ignoring sub " + info + " already subscribed to matching destination");
0:             removeDemandSubscription(id);
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected void addSubscription(DemandSubscription sub) throws IOException{
0:         if (sub != null){
0:             localBroker.oneway(sub.getLocalInfo());
0:     
0:     protected void removeSubscription(DemandSubscription sub) throws IOException{
0:         if(sub!=null){
0:             subscriptionMapByLocalId.remove(sub.getLocalInfo().getConsumerId());
0:             localBroker.oneway(sub.getLocalInfo().createRemoveCommand());
0:         }
0:     }
0:     
0:     protected DemandSubscription getDemandSubscription(MessageDispatch md){
0:         return (DemandSubscription) subscriptionMapByLocalId.get(md.getConsumerId());
0:     }
0:     
0:     protected Message configureMessage(MessageDispatch md){
0:         Message message=md.getMessage().copy();
0:         // Update the packet to show where it came from.
0:         message.setBrokerPath(appendToBrokerPath(message.getBrokerPath(),localBrokerPath));
0:         message.setProducerId(producerInfo.getProducerId());
0:         message.setDestination(md.getDestination());
0:         if(message.getOriginalTransactionId()==null)
0:             message.setOriginalTransactionId(message.getTransactionId());
0:         message.setTransactionId(null);
0:         message.setRecievedByDFBridge(true);
0:         message.evictMarshlledForm();
0:         return message;
0:     }
0: 
0:     
/////////////////////////////////////////////////////////////////////////
0:                         Message message= configureMessage(md);
0:                         if(!message.isPersistent()||!sub.getRemoteInfo().isDurable()){
/////////////////////////////////////////////////////////////////////////
0:                         int dispatched = sub.incrementDispatched();
0:                         if(dispatched>(sub.getLocalInfo().getPrefetchSize()*.75)){
0:                             localBroker.oneway(new MessageAck(md,MessageAck.STANDARD_ACK_TYPE,dispatched));
0:                             sub.setDispatched(0);
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * @return prefetch size
0:      */
0:     
0:     /**
0:      * @param prefetchSize
0:      */
0:     
0:     /**
0:      * @return true if dispatch async
0:      */
0:     /**
0:      * @param dispatchAsync
0:      */
0:     
0:     /**
0:      * @return Returns the dynamicallyIncludedDestinations.
0:      */
0:     public ActiveMQDestination[] getDynamicallyIncludedDestinations(){
0:         return dynamicallyIncludedDestinations;
0:     /**
0:      * @param dynamicallyIncludedDestinations The dynamicallyIncludedDestinations to set.
0:      */
0:     public void setDynamicallyIncludedDestinations(ActiveMQDestination[] dynamicallyIncludedDestinations){
0:         this.dynamicallyIncludedDestinations=dynamicallyIncludedDestinations;
0:     }
0: 
0:     /**
0:      * @return Returns the excludedDestinations.
0:      */
0:     public ActiveMQDestination[] getExcludedDestinations(){
0:         return excludedDestinations;
0:     }
0: 
0:     /**
0:      * @param excludedDestinations The excludedDestinations to set.
0:      */
0:     public void setExcludedDestinations(ActiveMQDestination[] excludedDestinations){
0:         this.excludedDestinations=excludedDestinations;
0:     }
0: 
0:     /**
0:      * @return Returns the staticallyIncludedDestinations.
0:      */
0:     public ActiveMQDestination[] getStaticallyIncludedDestinations(){
0:         return staticallyIncludedDestinations;
0:     }
0: 
0:     /**
0:      * @param staticallyIncludedDestinations The staticallyIncludedDestinations to set.
0:      */
0:     public void setStaticallyIncludedDestinations(ActiveMQDestination[] staticallyIncludedDestinations){
0:         this.staticallyIncludedDestinations=staticallyIncludedDestinations;
0:     }
0:     
0: 
0:     /**
0:      * @return Returns the durableDestinations.
0:      */
0:     public ActiveMQDestination[] getDurableDestinations(){
0:         return durableDestinations;
0:     }
0: 
0:     /**
0:      * @param durableDestinations The durableDestinations to set.
0:      */
0:     public void setDurableDestinations(ActiveMQDestination[] durableDestinations){
0:         this.durableDestinations=durableDestinations;
/////////////////////////////////////////////////////////////////////////
0:     
0:     /**
0:      * @return Returns the localBroker.
0:      */
0:     public Transport getLocalBroker(){
0:         return localBroker;
0:     }
0: 
0:     /**
0:      * @return Returns the remoteBroker.
0:      */
0:     public Transport getRemoteBroker(){
0:         return remoteBroker;
0:     }
0: 
0: 
0:     /**
0:      * @return Returns the remoteBrokerName.
0:      */
0:     public String getRemoteBrokerName(){
0:         return remoteBrokerName;
0:     }
0: 
0:     /**
0:      * @param remoteBrokerName The remoteBrokerName to set.
0:      */
0:     public void setRemoteBrokerName(String remoteBrokerName){
0:         this.remoteBrokerName=remoteBrokerName;
0:     }
0:     
0:     /**
0:      * @return Returns the decreaseNetworkConsumerPriority.
0:      */
0:     public boolean isDecreaseNetworkConsumerPriority(){
0:         return decreaseNetworkConsumerPriority;
0:     }
0: 
0:     /**
0:      * @param decreaseNetworkConsumerPriority The decreaseNetworkConsumerPriority to set.
0:      */
0:     public void setDecreaseNetworkConsumerPriority(boolean decreaseNetworkConsumerPriority){
0:         this.decreaseNetworkConsumerPriority=decreaseNetworkConsumerPriority;
0:     }
0:     
0:     /**
0:      * @return Returns the networkTTL.
0:      */
0:     public int getNetworkTTL(){
0:         return networkTTL;
0:     }
0: 
0:     /**
0:      * @param networkTTL The networkTTL to set.
0:      */
0:     public void setNetworkTTL(int networkTTL){
0:         this.networkTTL=networkTTL;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected boolean isPermissableDestination(ActiveMQDestination destination){
0:         DestinationFilter filter=DestinationFilter.parseFilter(destination);
0:         ActiveMQDestination[] dests = excludedDestinations;
0:         if(dests!=null&&dests.length>0){
0:             for(int i=0;i<dests.length;i++){
0:                 ActiveMQDestination match=dests[i];
0:                 if(match!=null&&filter.matches(match)){
0:                     return false;
0:                 }
0:             }
0:         }
0:         dests = dynamicallyIncludedDestinations;
0:         if(dests!=null&&dests.length>0){
0:             for(int i=0;i<dests.length;i++){
0:                 ActiveMQDestination match=dests[i];
0:                 if(match!=null&&filter.matches(match)){
0:                     return true;
0:                 }
0:             }
0:             return false;
0:         }
0:        
0:         return true;
0:     }
0:     
0:     /**
0:      * Subscriptions for these desitnations are always created
0:      * @throws IOException 
0:      *
0:      */
0:     protected void setupStaticDestinations() throws IOException{
0:         ActiveMQDestination[] dests = staticallyIncludedDestinations;
0:         if (dests != null){
0:             for(int i=0;i<dests.length;i++){
0:                 ActiveMQDestination dest=dests[i];
0:                 DemandSubscription sub = createDemandSubscription(dest);
0:                 addSubscription(sub);
0:                 if(log.isTraceEnabled())
0:                     log.trace("Forwarding messages for static destination: " + dest);
0:             } 
0:         }
0:     }
0:     
0:     protected DemandSubscription createDemandSubscription(ConsumerInfo info){
0:         DemandSubscription result=new DemandSubscription(info);
0:         result.getLocalInfo().setConsumerId(new ConsumerId(localSessionInfo.getSessionId(),consumerIdGenerator
0:                         .getNextSequenceId()));
0:         
0:         if( decreaseNetworkConsumerPriority ) {
0:             byte priority=ConsumerInfo.NETWORK_CONSUMER_PRIORITY;
0:             if(priority>Byte.MIN_VALUE&&info.getBrokerPath()!=null&&info.getBrokerPath().length>1){
0:                 // The longer the path to the consumer, the less it's consumer priority.
0:                 priority-=info.getBrokerPath().length+1;
0:             }
0:             result.getLocalInfo().setPriority(priority);
0:         }
0:         configureDemandSubscription(result);
0:         return result;
0:     }
0:     
0:     protected DemandSubscription createDemandSubscription(ActiveMQDestination destination){
0:         ConsumerInfo info = new ConsumerInfo();
0:         info.setDestination(destination);
0:         //the remote info held by the DemandSubscription holds the original consumerId,
0:         //the local info get's overwritten
0:         info.setConsumerId(new ConsumerId(localSessionInfo.getSessionId(),consumerIdGenerator
0:                         .getNextSequenceId()));
0:         DemandSubscription result=new DemandSubscription(info);
0:         result.getLocalInfo().setPriority(ConsumerInfo.NETWORK_CONSUMER_PRIORITY);
0:         
0:         return result;
0:     }
0:     
0:     protected void configureDemandSubscription(DemandSubscription sub){
0:         sub.getLocalInfo().setDispatchAsync(dispatchAsync);
0:         sub.getLocalInfo().setPrefetchSize(prefetchSize);
0:         subscriptionMapByLocalId.put(sub.getLocalInfo().getConsumerId(),sub);
0:         subscriptionMapByRemoteId.put(sub.getRemoteInfo().getConsumerId(),sub);
0:        
0:         // This works for now since we use a VM connection to the local broker.
0:         // may need to change if we ever subscribe to a remote broker.
0:         sub.getLocalInfo().setAdditionalPredicate(new BooleanExpression(){
0:             public boolean matches(MessageEvaluationContext message) throws JMSException{
0:                 try{
0:                     return matchesForwardingFilter(message.getMessage());
0:                 }catch(IOException e){
0:                     throw JMSExceptionSupport.create(e);
0:                 }
0:             }
0: 
0:             public Object evaluate(MessageEvaluationContext message) throws JMSException{
0:                 return matches(message)?Boolean.TRUE:Boolean.FALSE;
0:             }
0:         });
0:     }
0:     
0:     protected void  removeDemandSubscription(ConsumerId id) throws IOException{
0:         DemandSubscription sub=(DemandSubscription) subscriptionMapByRemoteId.remove(id);
0:         if (sub != null){
0:             removeSubscription(sub);
0:             if(log.isTraceEnabled())
0:                 log.trace("removing sub on "+localBroker+" from "+remoteBrokerName+" :  "+sub.getRemoteInfo());
0:         }
0:     }
0:     
0:     protected boolean matchesForwardingFilter(Message message){
0:         if (contains(message.getBrokerPath(),remoteBrokerPath[0])){
0:             if (log.isTraceEnabled()){
0:                 log.trace("Message all ready routed once through this broker - ignoring: " + message);
0:             }
0:         }
0:         int hops = message.getBrokerPath() == null ? 0 : message.getBrokerPath().length;
0:         if(hops >= networkTTL){
0:             if (log.isTraceEnabled()){
0:                 log.trace("Message restricted to " + networkTTL + " network hops ignoring: " + message);
0:             }
0:             return false;
0:         }
0:         // Don't propagate advisory messages about network subscriptions
0:         if(message.isAdvisory()&&message.getDataStructure()!=null
0:                         &&message.getDataStructure().getDataStructureType()==CommandTypes.CONSUMER_INFO){
0:             ConsumerInfo info=(ConsumerInfo) message.getDataStructure();
0:             if(info.isNetworkSubscription()){
0:                 return false;
0:             }
0:         }
0:         return true;
0:     }
0:     
0:     protected void waitStarted() throws InterruptedException {
0:     
0:     
0: 
0:     
commit:db747b4
/////////////////////////////////////////////////////////////////////////
0:     private Object brokerInfoMutex = new Object();
/////////////////////////////////////////////////////////////////////////
0:                     synchronized(brokerInfoMutex){
/////////////////////////////////////////////////////////////////////////
0:                         if (!disposed){
0:                             triggerLocalStartBridge();
0:                         }
/////////////////////////////////////////////////////////////////////////
0:                     synchronized(brokerInfoMutex){
commit:5a429d9
/////////////////////////////////////////////////////////////////////////
0:  * 
0:  * 
0:  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
0:  * the License. You may obtain a copy of the License at
0:  * 
0:  * 
0:  * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
0:  * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
0:  * specific language governing permissions and limitations under the License.
0: import org.apache.activemq.broker.BrokerService;
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean;
1:  * Forwards messages from the local broker to the remote broker based on demand.
0: public class DemandForwardingBridge implements Bridge{
0:     static final private Log log=LogFactory.getLog(DemandForwardingBridge.class);
0:     private IdGenerator idGenerator=new IdGenerator();
0:     private LongSequenceGenerator consumerIdGenerator=new LongSequenceGenerator();
0:     private ConnectionInfo localConnectionInfo;
0:     private ConnectionInfo remoteConnectionInfo;
0:     private SessionInfo localSessionInfo;
0:     private ProducerInfo producerInfo;
0:     private String localBrokerName;
0:     private String remoteBrokerName;
0:     private String localClientId;
0:     private String destinationFilter=">";
0:     private AtomicBoolean localBridgeStarted=new AtomicBoolean(false);
0:     private AtomicBoolean remoteBridgeStarted=new AtomicBoolean(false);
0:     private boolean disposed=false;
0:     private static class DemandSubscription{
0: 
0:         public DemandSubscription(ConsumerInfo info){
0:             remoteInfo=info;
0:             localInfo=info.copy();
0:     ConcurrentHashMap subscriptionMapByLocalId=new ConcurrentHashMap();
0:     ConcurrentHashMap subscriptionMapByRemoteId=new ConcurrentHashMap();
0:     protected final BrokerId localBrokerPath[]=new BrokerId[] { null };
0:     protected final BrokerId remoteBrokerPath[]=new BrokerId[] { null };
0: 
0:     public DemandForwardingBridge(Transport localBroker,Transport remoteBroker){
0:         this.localBroker=localBroker;
0:         this.remoteBroker=remoteBroker;
0:     public void start() throws Exception{
0:         log.info("Starting a network connection between "+localBroker+" and "+remoteBroker+" has been established.");
0:             public void onCommand(Command command){
0: 
0:             public void onException(IOException error){
0:             public void onCommand(Command command){
0: 
0:             public void onException(IOException error){
0:         triggerRemoteStartBridge();
0:     protected void triggerLocalStartBridge() throws IOException{
0:         Thread thead=new Thread(){
0:             public void run(){
0:                 try{
0:                     startLocalBridge();
0:                 }catch(IOException e){
0:                     log.error("Failed to start network bridge: "+e,e);
0:     protected void triggerRemoteStartBridge() throws IOException{
0:         Thread thead=new Thread(){
0:             public void run(){
0:                 try{
0:                     startRemoteBridge();
0:                 }catch(IOException e){
0:                     log.error("Failed to start network bridge: "+e,e);
0:                 }
0:         };
0:         thead.start();
0:     }
0: 
0:     protected void startLocalBridge() throws IOException{
0:         if(localBridgeStarted.compareAndSet(false,true)){
0:             localConnectionInfo=new ConnectionInfo();
0:             localConnectionInfo.setConnectionId(new ConnectionId(idGenerator.generateId()));
0:             localClientId="NC_"+remoteBrokerName+"_inbound";
0:             localConnectionInfo.setClientId(localClientId);
0:             localBroker.oneway(localConnectionInfo);
0:             localSessionInfo=new SessionInfo(localConnectionInfo,1);
0:             localBroker.oneway(localSessionInfo);
0:             log.info("Network connection between "+localBroker+" and "+remoteBroker+"("+remoteBrokerName
0:                             +") has been established.");
0: 
0:     protected void startRemoteBridge() throws IOException{
0:         if(remoteBridgeStarted.compareAndSet(false,true)){
0:             BrokerInfo brokerInfo=new BrokerInfo();
0:             brokerInfo.setBrokerName(localBrokerName);
0:             remoteBroker.oneway(brokerInfo);
0:             remoteConnectionInfo=new ConnectionInfo();
0:             remoteConnectionInfo.setConnectionId(new ConnectionId(idGenerator.generateId()));
0:             remoteConnectionInfo.setClientId("NC_"+localBrokerName+"_outbound");
0:             remoteBroker.oneway(remoteConnectionInfo);
0:             SessionInfo remoteSessionInfo=new SessionInfo(remoteConnectionInfo,1);
0:             remoteBroker.oneway(remoteSessionInfo);
0:             producerInfo=new ProducerInfo(remoteSessionInfo,1);
0:             producerInfo.setResponseRequired(false);
0:             remoteBroker.oneway(producerInfo);
0:             // Listen to consumer advisory messages on the remote broker to determine demand.
0:             demandConsumerInfo=new ConsumerInfo(remoteSessionInfo,1);
0:             demandConsumerInfo.setDispatchAsync(dispatchAsync);
0:             demandConsumerInfo.setDestination(new ActiveMQTopic(AdvisorySupport.CONSUMER_ADVISORY_TOPIC_PREFIX
0:                             +destinationFilter));
0:             demandConsumerInfo.setPrefetchSize(prefetchSize);
0:             remoteBroker.oneway(demandConsumerInfo);
0:         }
0:     }
0: 
0:     public void stop() throws Exception{
0:         if(!disposed){
0:             try{
0:                 disposed=true;
0:                 localBridgeStarted.set(false);
0:                 remoteBridgeStarted.set(false);
0:                 if(localConnectionInfo!=null){
0:                     localBroker.request(localConnectionInfo.createRemoveCommand());
0:                     remoteBroker.request(remoteConnectionInfo.createRemoveCommand());
0:                 }
0:                 localBroker.setTransportListener(null);
0:                 remoteBroker.setTransportListener(null);
0:                 remoteBroker.oneway(new ShutdownInfo());
0:                 localBroker.oneway(new ShutdownInfo());
0:             }catch(IOException e){
0:                 log.debug("Caught exception stopping",e);
0:             }finally{
0:                 ServiceStopper ss=new ServiceStopper();
0:                 ss.stop(localBroker);
0:                 ss.stop(remoteBroker);
0:                 ss.throwFirstException();
0:             }
0:         }
0:     }
0: 
0:     protected void serviceRemoteException(IOException error){
0:         log.info("Network connection between "+localBroker+" and "+remoteBroker+" shutdown: "+error.getMessage(),error);
0: 
0:     protected void serviceRemoteCommand(Command command){
0:         if(!disposed){
0:             try{
0:                 if(command.isMessageDispatch()){
0:                     MessageDispatch md=(MessageDispatch) command;
0:                     serviceRemoteConsumerAdvisory(md.getMessage().getDataStructure());
0:                     demandConsumerDispatched++;
0:                     if(demandConsumerDispatched>(demandConsumerInfo.getPrefetchSize()*.75)){
0:                         remoteBroker.oneway(new MessageAck(md,MessageAck.STANDARD_ACK_TYPE,demandConsumerDispatched));
0:                         demandConsumerDispatched=0;
0:                     }
0:                 }else if(command.isBrokerInfo()){
0:                     synchronized(this){
0:                         BrokerInfo remoteBrokerInfo=(BrokerInfo) command;
0:                         remoteBrokerId=remoteBrokerInfo.getBrokerId();
0:                         remoteBrokerPath[0]=remoteBrokerId;
0:                         remoteBrokerName=remoteBrokerInfo.getBrokerName();
0:                         if(localBrokerId!=null){
0:                             if(localBrokerId.equals(remoteBrokerId)){
0:                                 log.info("Disconnecting loop back connection.");
0:                                 ServiceSupport.dispose(this);
0:                             }else{
0:                                 triggerLocalStartBridge();
0:                             }
0:                 }else{
0:                     switch(command.getDataStructureType()){
0:                         break;
0:                     }
0:             }catch(IOException e){
0:                 serviceRemoteException(e);
0:     private void serviceRemoteConsumerAdvisory(DataStructure data) throws IOException{
0:         if(data.getClass()==ConsumerInfo.class){
0:             ConsumerInfo info=(ConsumerInfo) data;
0:             BrokerId[] path=info.getBrokerPath();
0:             if((path!=null&&path.length>0)||info.isNetworkSubscription()){
0:                 // Ignore: We only support directly connected brokers for now.
0:             if(contains(info.getBrokerPath(),localBrokerPath[0])){
0:             if(log.isTraceEnabled())
0:                 log.trace("Forwarding sub on "+localBroker+" from "+remoteBrokerName+" :  "+info);
0:             info=info.copy();
0:             info.setBrokerPath(appendToBrokerPath(info.getBrokerPath(),remoteBrokerPath));
0:             DemandSubscription sub=new DemandSubscription(info);
0:             sub.localInfo.setConsumerId(new ConsumerId(localSessionInfo.getSessionId(),consumerIdGenerator
0:                             .getNextSequenceId()));
0:             byte priority=ConsumerInfo.NETWORK_CONSUMER_PRIORITY;
0:             if(priority>Byte.MIN_VALUE&&info.getBrokerPath()!=null&&info.getBrokerPath().length>1){
0:                 priority-=info.getBrokerPath().length+1;
0:             subscriptionMapByLocalId.put(sub.localInfo.getConsumerId(),sub);
0:             subscriptionMapByRemoteId.put(sub.remoteInfo.getConsumerId(),sub);
0:                 public boolean matches(MessageEvaluationContext message) throws JMSException{
0:                     try{
0:                     }catch(IOException e){
0: 
0:                 public Object evaluate(MessageEvaluationContext message) throws JMSException{
0:                     return matches(message)?Boolean.TRUE:Boolean.FALSE;
0:             localBroker.oneway(sub.localInfo);
0:         if(data.getClass()==RemoveInfo.class){
0:             ConsumerId id=(ConsumerId) ((RemoveInfo) data).getObjectId();
0:             DemandSubscription sub=(DemandSubscription) subscriptionMapByRemoteId.remove(id);
0:             if(sub!=null){
0:     protected void serviceLocalException(Throwable error){
0:         log.info("Network connection between "+localBroker+" and "+remoteBroker+" shutdown: "+error.getMessage(),error);
0:     boolean matchesForwardingFilter(Message message){
0:         if(message.isRecievedByDFBridge()||contains(message.getBrokerPath(),remoteBrokerPath[0]))
0:         if(message.isAdvisory()&&message.getDataStructure()!=null
0:                         &&message.getDataStructure().getDataStructureType()==CommandTypes.CONSUMER_INFO){
0:             if(info.isNetworkSubscription()){
0:     protected void serviceLocalCommand(Command command){
0:         if(!disposed){
0:             final boolean trace=log.isTraceEnabled();
0:             try{
0:                 if(command.isMessageDispatch()){
0:                     MessageDispatch md=(MessageDispatch) command;
0:                     Message message=md.getMessage();
0:                     DemandSubscription sub=(DemandSubscription) subscriptionMapByLocalId.get(md.getConsumerId());
0:                     if(sub!=null){
0:                         message=message.copy();
0:                         // Update the packet to show where it came from.
0:                         message.setBrokerPath(appendToBrokerPath(message.getBrokerPath(),localBrokerPath));
0:                         message.setProducerId(producerInfo.getProducerId());
0:                         message.setDestination(md.getDestination());
0:                         if(message.getOriginalTransactionId()==null)
0:                             message.setOriginalTransactionId(message.getTransactionId());
0:                         message.setTransactionId(null);
0:                         message.setRecievedByDFBridge(true);
0:                         message.evictMarshlledForm();
0:                         if(trace)
0:                             log.trace("bridging "+localBrokerName+" -> "+remoteBrokerName+": "+message);
0:                         if(!message.isPersistent()||!sub.remoteInfo.isDurable()){
0:                             remoteBroker.oneway(message);
0:                         }else{
0:                             Response response=remoteBroker.request(message);
0:                             if(response.isException()){
0:                                 ExceptionResponse er=(ExceptionResponse) response;
0:                                 serviceLocalException(er.getException());
0:                             }
0:                         }
0:                         sub.dispatched++;
0:                         if(sub.dispatched>(sub.localInfo.getPrefetchSize()*.75)){
0:                             localBroker.oneway(new MessageAck(md,MessageAck.STANDARD_ACK_TYPE,sub.dispatched));
0:                             sub.dispatched=0;
0:                 }else if(command.isBrokerInfo()){
0:                     synchronized(this){
0:                         localBrokerId=((BrokerInfo) command).getBrokerId();
0:                         localBrokerPath[0]=localBrokerId;
0:                         if(remoteBrokerId!=null){
0:                             if(remoteBrokerId.equals(localBrokerId)){
0:                                 log.info("Disconnecting loop back connection.");
0:                                 ServiceSupport.dispose(this);
0:                             }
0:                 }else if(command.isShutdownInfo()){
0:                     log.info(localBrokerName+" Shutting down");
0:                     disposed = true;
0:                     stop();
0:                 }else{
0:                     switch(command.getDataStructureType()){
0:                     case WireFormatInfo.DATA_STRUCTURE_TYPE:
0:                         break;
0:                     default:
0:                         log.warn("Unexpected local command: "+command);
0:                     }
0:             }catch(Exception e){
0:                 serviceLocalException(e);
0:     public int getPrefetchSize(){
0:     public void setPrefetchSize(int prefetchSize){
0:         this.prefetchSize=prefetchSize;
0:     public boolean isDispatchAsync(){
0:     public void setDispatchAsync(boolean dispatchAsync){
0:         this.dispatchAsync=dispatchAsync;
0:     public String getDestinationFilter(){
0: 
0:     public void setDestinationFilter(String destinationFilter){
0:         this.destinationFilter=destinationFilter;
0: 
0:     /**
0:      * @return Returns the localBrokerName.
0:      */
0:     public String getLocalBrokerName(){
0:         return localBrokerName;
0:     }
0: 
0:     /**
0:      * @param localBrokerName
0:      *            The localBrokerName to set.
0:      */
0:     public void setLocalBrokerName(String localBrokerName){
0:         this.localBrokerName=localBrokerName;
0:     }
0: 
0:     private boolean contains(BrokerId[] brokerPath,BrokerId brokerId){
0:         if(brokerPath!=null){
0:             for(int i=0;i<brokerPath.length;i++){
0:                 if(brokerId.equals(brokerPath[i]))
0: 
0:     private BrokerId[] appendToBrokerPath(BrokerId[] brokerPath,BrokerId pathsToAppend[]){
0:         if(brokerPath==null||brokerPath.length==0)
0:         BrokerId rc[]=new BrokerId[brokerPath.length+pathsToAppend.length];
commit:fb53ad9
/////////////////////////////////////////////////////////////////////////
0:                     sub.dispatched++;
0:                     if( sub.dispatched > (sub.localInfo.getPrefetchSize()*.75) ) {
0:                         localBroker.oneway(new MessageAck(md, MessageAck.STANDARD_ACK_TYPE, sub.dispatched));
0:                         sub.dispatched=0;
0:                     } 
0:                                                      
commit:ef3b50e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ExceptionResponse;
0: import org.apache.activemq.command.Response;
/////////////////////////////////////////////////////////////////////////
0:     protected void serviceLocalException(Throwable error) {
/////////////////////////////////////////////////////////////////////////
0:                     if (!message.isPersistent() || !sub.remoteInfo.isDurable()){
0:                     }else{
0:                         Response response = remoteBroker.request(message);
0:                         if (response.isException()) {
0:                             ExceptionResponse er = (ExceptionResponse) response;
0:                             serviceLocalException(er.getException());
0:                             
0:                         }
0:                     }
/////////////////////////////////////////////////////////////////////////
0:         } catch (Exception e) {
commit:c68a146
/////////////////////////////////////////////////////////////////////////
0:         final boolean trace = log.isTraceEnabled();
/////////////////////////////////////////////////////////////////////////
0:                     localBroker.oneway(new MessageAck(md, MessageAck.STANDARD_ACK_TYPE, demandConsumerDispatched));
0:                                    
author:James Strachan
-------------------------------------------------------------------------------
commit:400b1fc
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: 
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected NetworkBridgeFilter createNetworkBridgeFilter(ConsumerInfo info) throws IOException {
commit:687a45a
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
1: public class DemandForwardingBridge extends DemandForwardingBridgeSupport {
0: 
0:     protected final BrokerId remoteBrokerPath[] = new BrokerId[] { null };
0:     protected BrokerId remoteBrokerId;
0:         super(localBroker, remoteBroker);
0:     protected void serviceRemoteBrokerInfo(Command command) throws IOException {
0:         synchronized(brokerInfoMutex){
0:             BrokerInfo remoteBrokerInfo=(BrokerInfo) command;
0:             remoteBrokerId=remoteBrokerInfo.getBrokerId();
0:             remoteBrokerPath[0]=remoteBrokerId;
0:             remoteBrokerName=remoteBrokerInfo.getBrokerName();
0:             if(localBrokerId!=null){
0:                 if(localBrokerId.equals(remoteBrokerId)){
0:                     log.info("Disconnecting loop back connection.");
0:                     //waitStarted();
0:                     ServiceSupport.dispose(this);
0:             if (!disposed){
0:                 triggerLocalStartBridge();
0:     protected void addRemoteBrokerToBrokerPath(ConsumerInfo info) {
0:         info.setBrokerPath(appendToBrokerPath(info.getBrokerPath(),remoteBrokerPath));
0:     protected void serviceLocalBrokerInfo(Command command) throws InterruptedException {
0:         synchronized(brokerInfoMutex){
0:             localBrokerId=((BrokerInfo) command).getBrokerId();
0:             localBrokerPath[0]=localBrokerId;
0:             if(remoteBrokerId!=null){
0:                 if(remoteBrokerId.equals(localBrokerId)){
0:                     log.info("Disconnecting loop back connection.");
0:                     ServiceSupport.dispose(this);
0:     protected NetworkBridgeFilter createNetworkBridgeFilter() {
0:         return new NetworkBridgeFilter(remoteBrokerPath[0], networkTTL);
0:     }
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:3a0358e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.CountDownLatch;
/////////////////////////////////////////////////////////////////////////
0:     private CountDownLatch startedLatch = new CountDownLatch(2);
/////////////////////////////////////////////////////////////////////////
0:             startedLatch.countDown();
/////////////////////////////////////////////////////////////////////////
0:             startedLatch.countDown();
/////////////////////////////////////////////////////////////////////////
0:     protected void serviceRemoteException(Exception error){
/////////////////////////////////////////////////////////////////////////
0:                     waitStarted();
/////////////////////////////////////////////////////////////////////////
0:                                 waitStarted();
/////////////////////////////////////////////////////////////////////////
0:             }catch(Exception e){
/////////////////////////////////////////////////////////////////////////
0:                     waitStarted();
/////////////////////////////////////////////////////////////////////////
0:                                 waitStarted();
/////////////////////////////////////////////////////////////////////////
0:     
0:     private void waitStarted() throws InterruptedException {
0:         startedLatch.await();
0:     }
============================================================================