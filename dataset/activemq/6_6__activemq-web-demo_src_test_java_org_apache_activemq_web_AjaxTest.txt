1:de66445: /**
1:de66445:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:de66445:  * contributor license agreements.  See the NOTICE file distributed with
1:de66445:  * this work for additional information regarding copyright ownership.
1:de66445:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:de66445:  * (the "License"); you may not use this file except in compliance with
1:de66445:  * the License.  You may obtain a copy of the License at
1:de66445:  *
1:de66445:  *      http://www.apache.org/licenses/LICENSE-2.0
1:de66445:  *
1:de66445:  * Unless required by applicable law or agreed to in writing, software
1:de66445:  * distributed under the License is distributed on an "AS IS" BASIS,
1:de66445:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:de66445:  * See the License for the specific language governing permissions and
1:de66445:  * limitations under the License.
1:de66445:  */
1:bef96a9: package org.apache.activemq.web;
1:9308db8: 
1:f44c3d2: import static org.junit.Assert.assertEquals;
1:f44c3d2: import static org.junit.Assert.assertTrue;
1:f44c3d2: 
1:f44c3d2: import java.io.ByteArrayInputStream;
1:a259c12: import java.net.SocketTimeoutException;
1:a259c12: import java.util.HashMap;
1:f44c3d2: import java.util.concurrent.CountDownLatch;
1:a259c12: import java.util.concurrent.TimeUnit;
1:f44c3d2: import java.util.concurrent.atomic.AtomicInteger;
1:a259c12: 
1:a259c12: import javax.jms.Message;
1:a259c12: import javax.jms.MessageProducer;
1:a259c12: 
1:a259c12: import org.apache.activemq.transport.stomp.Stomp;
1:88fc7fe: import org.apache.activemq.transport.stomp.StompConnection;
1:88fc7fe: import org.apache.activemq.transport.stomp.StompFrame;
1:88fc7fe: import org.apache.commons.lang.StringUtils;
1:88fc7fe: import org.eclipse.jetty.client.HttpClient;
1:f44c3d2: import org.eclipse.jetty.client.api.Request;
1:f44c3d2: import org.eclipse.jetty.client.api.Result;
1:f44c3d2: import org.eclipse.jetty.client.util.BufferingResponseListener;
1:f44c3d2: import org.eclipse.jetty.client.util.InputStreamContentProvider;
1:f44c3d2: import org.eclipse.jetty.http.HttpHeader;
1:f44c3d2: import org.eclipse.jetty.http.HttpMethod;
1:bdf7aa4: import org.junit.Test;
1:a259c12: import org.slf4j.Logger;
1:a259c12: import org.slf4j.LoggerFactory;
1:bdf7aa4: 
1:bef96a9: public class AjaxTest extends JettyTestSupport {
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(AjaxTest.class);
1:9308db8: 
1:9308db8: 
1:88fc7fe:     public void assertContains( String expected, String actual ) {
1:88fc7fe:         assertTrue( "'"+actual+"' does not contain expected fragment '"+expected+"'", actual.indexOf( expected ) != -1 );
6:88fc7fe:     }
1:88fc7fe:     public void assertResponseCount( int expected, String actual ) {
1:88fc7fe:         int occurrences = StringUtils.countMatches( actual, "<response" );
1:88fc7fe:         assertEquals( "Expected number of <response> elements is not correct.", expected, occurrences );
1:88fc7fe:     }
1:9308db8: 
1:df0c195:     @Test(timeout = 15 * 1000)
1:88fc7fe:     public void testAjaxClientReceivesMessagesWhichAreSentToQueueWhileClientIsPolling() throws Exception {
1:88fc7fe:         LOG.debug( "*** testAjaxClientReceivesMessagesWhichAreSentToQueueWhileClientIsPolling ***" );
1:c5cebd5:         int port = getPort();
1:9308db8: 
1:88fc7fe:         HttpClient httpClient = new HttpClient();
1:df0c195:         httpClient.start();
1:9308db8: 
1:88fc7fe:         // client 1 subscribes to a queue
1:88fc7fe:         LOG.debug( "SENDING LISTEN" );
1:f44c3d2:         String sessionId = subscribe(httpClient, port, "destination=queue://test&type=listen&message=handler");
1:9308db8: 
1:88fc7fe:         // client 1 polls for messages
1:c6ede16:         LOG.debug( "SENDING POLL" );
1:f44c3d2:         final StringBuffer buf = new StringBuffer();
1:f44c3d2:         final CountDownLatch latch =
1:f44c3d2:                 asyncRequest(httpClient, "http://localhost:" + port + "/amq?timeout=5000", buf, sessionId);
1:9308db8: 
1:88fc7fe:         // while client 1 is polling, client 2 sends messages to the queue
1:88fc7fe:         LOG.debug( "SENDING MESSAGES" );
1:f44c3d2:         sendMessages(httpClient, port, ("destination=queue://test&type=send&message=msg1&"+
1:f44c3d2:                          "d1=queue://test&t1=send&m1=msg2&"+
1:f44c3d2:                          "d2=queue://test&t2=send&m2=msg3").getBytes());
1:f44c3d2: 
2:88fc7fe:         LOG.debug( "DONE POSTING MESSAGES" );
1:9308db8: 
1:88fc7fe:         // wait for poll to finish
1:f44c3d2:        latch.await();
1:f44c3d2:        String response = buf.toString();
1:9308db8: 
1:88fc7fe:         // messages might not all be delivered during the 1st poll.  We need to check again.
1:f44c3d2:        final StringBuffer buf2 = new StringBuffer();
1:f44c3d2:        final CountDownLatch latch2 =
1:f44c3d2:                asyncRequest(httpClient, "http://localhost:" + port + "/amq?timeout=5000", buf2, sessionId);
1:f44c3d2:        latch2.await();
1:9308db8: 
1:f44c3d2:         String fullResponse = response + buf2.toString();
1:88fc7fe:         LOG.debug( "full response : " + fullResponse );
1:b41b7cc:         assertContains( "<response id='handler' destination='queue://test' >msg1</response>", fullResponse );
1:b41b7cc:         assertContains( "<response id='handler' destination='queue://test' >msg2</response>", fullResponse );
1:b41b7cc:         assertContains( "<response id='handler' destination='queue://test' >msg3</response>", fullResponse );
1:88fc7fe:         assertResponseCount( 3, fullResponse );
1:df0c195: 
1:df0c195:         httpClient.stop();
1:df0c195: }
1:f44c3d2: 
1:df0c195:     @Test(timeout = 15 * 1000)
1:88fc7fe:     public void testAjaxClientReceivesMessagesWhichAreSentToTopicWhileClientIsPolling() throws Exception {
1:88fc7fe:         LOG.debug( "*** testAjaxClientReceivesMessagesWhichAreSentToTopicWhileClientIsPolling ***" );
1:c5cebd5:         int port = getPort();
1:9308db8: 
1:88fc7fe:         HttpClient httpClient = new HttpClient();
1:df0c195:         httpClient.start();
1:9308db8: 
1:88fc7fe:         // client 1 subscribes to a queue
1:88fc7fe:         LOG.debug( "SENDING LISTEN" );
1:f44c3d2:         String sessionId = subscribe(httpClient, port, "destination=topic://test&type=listen&message=handler");
1:9308db8: 
1:88fc7fe:         // client 1 polls for messages
2:88fc7fe:         LOG.debug( "SENDING POLL" );
1:f44c3d2:         final StringBuffer buf = new StringBuffer();
1:f44c3d2:         final CountDownLatch latch =
1:f44c3d2:                 asyncRequest(httpClient, "http://localhost:" + port + "/amq?timeout=5000", buf, sessionId);
1:9308db8: 
1:88fc7fe:         // while client 1 is polling, client 2 sends messages to the queue
1:88fc7fe:         LOG.debug( "SENDING MESSAGES" );
1:f44c3d2:         sendMessages(httpClient, port, ("destination=topic://test&type=send&message=msg1&"+
1:f44c3d2:                 "d1=topic://test&t1=send&m1=msg2&"+
1:f44c3d2:                 "d2=topic://test&t2=send&m2=msg3").getBytes());
1:9308db8: 
1:88fc7fe:         // wait for poll to finish
1:f44c3d2:         latch.await();
1:f44c3d2:         String response = buf.toString();
1:9308db8: 
1:f44c3d2:         // messages might not all be delivered during the 1st poll. We need to
1:f44c3d2:         // check again.
1:f44c3d2:         final StringBuffer buf2 = new StringBuffer();
1:f44c3d2:         final CountDownLatch latch2 = asyncRequest(httpClient,
1:f44c3d2:                 "http://localhost:" + port + "/amq?timeout=5000", buf2, sessionId);
1:f44c3d2:         latch2.await();
1:f44c3d2: 
1:f44c3d2:         String fullResponse = response + buf2.toString();
1:9308db8: 
1:88fc7fe:         LOG.debug( "full response : " + fullResponse );
1:9308db8: 
1:b41b7cc:         assertContains( "<response id='handler' destination='topic://test' >msg1</response>", fullResponse );
1:b41b7cc:         assertContains( "<response id='handler' destination='topic://test' >msg2</response>", fullResponse );
1:b41b7cc:         assertContains( "<response id='handler' destination='topic://test' >msg3</response>", fullResponse );
1:88fc7fe:         assertResponseCount( 3, fullResponse );
1:df0c195: 
1:df0c195:         httpClient.stop();
1:88fc7fe:     }
1:9308db8: 
1:df0c195:     @Test(timeout = 15 * 1000)
1:88fc7fe:     public void testAjaxClientReceivesMessagesWhichAreQueuedBeforeClientSubscribes() throws Exception {
1:88fc7fe:         LOG.debug( "*** testAjaxClientReceivesMessagesWhichAreQueuedBeforeClientSubscribes ***" );
1:c5cebd5:         int port = getPort();
1:c5cebd5: 
1:88fc7fe:         // send messages to queue://test
1:88fc7fe:         producer.send( session.createTextMessage("test one") );
1:88fc7fe:         producer.send( session.createTextMessage("test two") );
1:88fc7fe:         producer.send( session.createTextMessage("test three") );
1:9308db8: 
1:88fc7fe:         HttpClient httpClient = new HttpClient();
1:df0c195:         httpClient.start();
1:9308db8: 
1:88fc7fe:         // client 1 subscribes to queue
1:88fc7fe:         LOG.debug( "SENDING LISTEN" );
1:f44c3d2:         String sessionId = subscribe(httpClient, port, "destination=queue://test&type=listen&message=handler");
1:9308db8: 
1:88fc7fe:         // client 1 polls for messages
1:88fc7fe:         LOG.debug( "SENDING POLL" );
1:f44c3d2:         final StringBuffer buf = new StringBuffer();
1:f44c3d2:         final CountDownLatch latch =
1:f44c3d2:                 asyncRequest(httpClient, "http://localhost:" + port + "/amq?timeout=5000", buf, sessionId);
1:9308db8: 
1:88fc7fe:         // wait for poll to finish
1:f44c3d2:         latch.await();
1:f44c3d2:         String response = buf.toString();
1:9308db8: 
1:b41b7cc:         assertContains( "<response id='handler' destination='queue://test' >test one</response>", response );
1:b41b7cc:         assertContains( "<response id='handler' destination='queue://test' >test two</response>", response );
1:b41b7cc:         assertContains( "<response id='handler' destination='queue://test' >test three</response>", response );
1:88fc7fe:         assertResponseCount( 3, response );
1:df0c195: 
1:df0c195:         httpClient.stop();
1:88fc7fe:     }
1:9308db8: 
1:df0c195:     @Test(timeout = 15 * 1000)
1:88fc7fe:     public void testStompMessagesAreReceivedByAjaxClient() throws Exception {
1:88fc7fe:         LOG.debug( "*** testStompMessagesAreRecievedByAjaxClient ***" );
1:c5cebd5:         int port = getPort();
1:9308db8: 
1:88fc7fe:         HttpClient httpClient = new HttpClient();
1:df0c195:         httpClient.start();
1:9308db8: 
1:88fc7fe:         // client 1 subscribes to a queue
1:88fc7fe:         LOG.debug( "SENDING LISTEN" );
1:f44c3d2:         String sessionId = subscribe(httpClient, port, "destination=queue://test&type=listen&message=handler");
1:9308db8: 
1:88fc7fe:         // client 1 polls for messages
1:88fc7fe:         LOG.debug( "SENDING POLL" );
1:f44c3d2:         final StringBuffer buf = new StringBuffer();
1:f44c3d2:         final CountDownLatch latch =
1:f44c3d2:                 asyncRequest(httpClient, "http://localhost:" + port + "/amq?timeout=5000", buf, sessionId);
1:9308db8: 
1:88fc7fe:         // stomp client queues some messages
1:88fc7fe:         StompConnection connection = new StompConnection();
1:9308db8:         connection.open(stompUri.getHost(), stompUri.getPort());
1:88fc7fe:         connection.connect("user", "password");
1:88fc7fe:         HashMap<String, String> headers = new HashMap<String, String>();
1:88fc7fe:         headers.put( "amq-msg-type", "text" );
1:88fc7fe:         connection.send( "/queue/test", "message1", (String)null, headers );
1:88fc7fe:         connection.send( "/queue/test", "message2", (String)null, headers );
1:88fc7fe:         connection.send( "/queue/test", "message3", (String)null, headers );
1:88fc7fe:         connection.send( "/queue/test", "message4", (String)null, headers );
1:88fc7fe:         connection.send( "/queue/test", "message5", (String)null, headers );
1:a259c12:         String frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
1:a259c12:         connection.sendFrame(frame);
1:a259c12: 
1:a259c12:         // Need to let the transport have enough time to dispatch the incoming messages from
1:a259c12:         // the socket before we break the connection.
1:a259c12:         TimeUnit.SECONDS.sleep(5);
1:a259c12: 
1:88fc7fe:         connection.disconnect();
1:9308db8: 
1:88fc7fe:         // wait for poll to finish
1:f44c3d2:         latch.await();
1:f44c3d2:         String response = buf.toString();
1:9308db8: 
2:88fc7fe:         // not all messages might be delivered during the 1st poll.  We need to check again.
1:f44c3d2:         final StringBuffer buf2 = new StringBuffer();
1:f44c3d2:         final CountDownLatch latch2 =
1:f44c3d2:                 asyncRequest(httpClient, "http://localhost:" + port + "/amq?timeout=5000", buf2, sessionId);
1:f44c3d2:         latch2.await();
1:9308db8: 
1:f44c3d2:         String fullResponse = response + buf2.toString();
1:9308db8: 
1:b41b7cc:         assertContains( "<response id='handler' destination='queue://test' >message1</response>", fullResponse );
1:b41b7cc:         assertContains( "<response id='handler' destination='queue://test' >message2</response>", fullResponse );
1:b41b7cc:         assertContains( "<response id='handler' destination='queue://test' >message3</response>", fullResponse );
1:b41b7cc:         assertContains( "<response id='handler' destination='queue://test' >message4</response>", fullResponse );
1:b41b7cc:         assertContains( "<response id='handler' destination='queue://test' >message5</response>", fullResponse );
1:88fc7fe:         assertResponseCount( 5, fullResponse );
1:df0c195: 
1:df0c195:         httpClient.stop();
1:88fc7fe:     }
1:9308db8: 
1:df0c195:     @Test(timeout = 15 * 1000)
1:88fc7fe:     public void testAjaxMessagesAreReceivedByStompClient() throws Exception {
1:88fc7fe:         LOG.debug( "*** testAjaxMessagesAreReceivedByStompClient ***" );
1:c5cebd5:         int port = getPort();
1:9308db8: 
1:88fc7fe:         HttpClient httpClient = new HttpClient();
1:df0c195:         httpClient.start();
1:9308db8: 
1:f44c3d2:         sendMessages(httpClient, port, ("destination=queue://test&type=send&message=msg1&"+
1:f44c3d2:                 "d1=queue://test&t1=send&m1=msg2&"+
1:f44c3d2:                 "d2=queue://test&t2=send&m2=msg3&"+
1:f44c3d2:                 "d3=queue://test&t3=send&m3=msg4").getBytes());
1:9308db8: 
1:88fc7fe:         StompConnection connection = new StompConnection();
1:9308db8:         connection.open(stompUri.getHost(), stompUri.getPort());
1:88fc7fe:         connection.connect("user", "password");
1:88fc7fe:         connection.subscribe( "/queue/test" );
1:9308db8: 
1:88fc7fe:         StompFrame message;
1:88fc7fe:         String allMessageBodies = "";
1:88fc7fe:         try {
1:88fc7fe:             while( true ) {
1:88fc7fe:                 message = connection.receive(5000);
1:88fc7fe:                 allMessageBodies = allMessageBodies +"\n"+ message.getBody();
1:88fc7fe:             }
1:88fc7fe:         } catch (SocketTimeoutException e) {}
1:9308db8: 
1:88fc7fe:         LOG.debug( "All message bodies : " + allMessageBodies );
1:9308db8: 
1:88fc7fe:         assertContains( "msg1", allMessageBodies );
1:88fc7fe:         assertContains( "msg2", allMessageBodies );
1:88fc7fe:         assertContains( "msg3", allMessageBodies );
1:88fc7fe:         assertContains( "msg4", allMessageBodies );
1:df0c195: 
1:df0c195:         httpClient.stop();
1:88fc7fe:     }
1:9308db8: 
1:df0c195:     @Test(timeout = 15 * 1000)
1:88fc7fe:     public void testAjaxClientMayUseSelectors() throws Exception {
1:88fc7fe:         LOG.debug( "*** testAjaxClientMayUseSelectors ***" );
1:c5cebd5:         int port = getPort();
1:f44c3d2: 
1:9308db8: 
1:88fc7fe:         // send 2 messages to the same queue w/ different 'filter' values.
1:88fc7fe:         Message msg = session.createTextMessage("test one");
1:88fc7fe:         msg.setStringProperty( "filter", "one" );
1:88fc7fe:         producer.send( msg );
1:88fc7fe:         msg = session.createTextMessage("test two");
1:88fc7fe:         msg.setStringProperty( "filter", "two" );
1:88fc7fe:         producer.send( msg );
1:9308db8: 
1:88fc7fe:         HttpClient httpClient = new HttpClient();
1:df0c195:         httpClient.start();
1:9308db8: 
1:df0c195:         // client subscribes to queue
1:88fc7fe:         LOG.debug( "SENDING LISTEN" );
1:f44c3d2:         String sessionId = subscribe(httpClient, port, "destination=queue://test&type=listen&message=handler", "filter='two'", null);
1:9308db8: 
1:88fc7fe:         // client 1 polls for messages
1:88fc7fe:         LOG.debug( "SENDING POLL" );
1:f44c3d2:         final StringBuffer buf = new StringBuffer();
1:f44c3d2:         final CountDownLatch latch =
1:f44c3d2:                 asyncRequest(httpClient, "http://localhost:" + port + "/amq?timeout=5000", buf, sessionId);
1:f44c3d2:         latch.await();
1:9308db8: 
1:f44c3d2:         LOG.debug( buf.toString() );
1:9308db8: 
1:b41b7cc:         String expected = "<response id='handler' destination='queue://test' >test two</response>";
1:f44c3d2:         assertContains( expected, buf.toString() );
1:b41b7cc: 
1:df0c195:         httpClient.stop();
1:88fc7fe:     }
1:9308db8: 
1:df0c195:     @Test(timeout = 15 * 1000)
1:88fc7fe:     public void testMultipleAjaxClientsMayExistInTheSameSession() throws Exception {
1:88fc7fe:         LOG.debug( "*** testMultipleAjaxClientsMayExistInTheSameSession ***" );
1:c5cebd5:         int port = getPort();
1:9308db8: 
1:88fc7fe:         // send messages to queues testA and testB.
1:88fc7fe:         MessageProducer producerA = session.createProducer(session.createQueue("testA"));
1:88fc7fe:         MessageProducer producerB = session.createProducer(session.createQueue("testB"));
1:88fc7fe:         producerA.send( session.createTextMessage("A1") );
1:88fc7fe:         producerA.send( session.createTextMessage("A2") );
1:88fc7fe:         producerB.send( session.createTextMessage("B1") );
1:88fc7fe:         producerB.send( session.createTextMessage("B2") );
1:9308db8: 
1:88fc7fe:         HttpClient httpClient = new HttpClient();
1:df0c195:         httpClient.start();
1:9308db8: 
1:88fc7fe:         // clientA subscribes to /queue/testA
1:88fc7fe:         LOG.debug( "SENDING LISTEN" );
1:f44c3d2:         String sessionId = subscribe(httpClient, port, "destination=queue://testA&type=listen&message=handlerA&clientId=clientA");
1:9308db8: 
1:88fc7fe:         // clientB subscribes to /queue/testB using the same JSESSIONID.
1:f44c3d2:         subscribe(httpClient, port, "destination=queue://testB&type=listen&message=handlerB&clientId=clientB", null, sessionId);
1:9308db8: 
1:88fc7fe:         // clientA polls for messages
1:f44c3d2:         final StringBuffer buf = new StringBuffer();
1:f44c3d2:         final CountDownLatch latch =
1:f44c3d2:                 asyncRequest(httpClient, "http://localhost:" + port + "/amq?timeout=5000&clientId=clientA", buf, sessionId);
1:f44c3d2:         latch.await();
1:9308db8: 
1:f44c3d2:         LOG.debug( "clientA response : " + buf.toString() );
1:b41b7cc:         String expected1 = "<response id='handlerA' destination='queue://testA' >A1</response>";
1:b41b7cc:         String expected2 = "<response id='handlerA' destination='queue://testA' >A2</response>";
1:b41b7cc: 
1:f44c3d2:         assertContains( expected1, buf.toString() );
1:f44c3d2:         assertContains( expected2, buf.toString() );
1:9308db8: 
1:88fc7fe:         // clientB polls for messages
1:f44c3d2:         final StringBuffer buf2 = new StringBuffer();
1:f44c3d2:         final CountDownLatch latch2 =
1:f44c3d2:                 asyncRequest(httpClient, "http://localhost:" + port + "/amq?timeout=5000&clientId=clientB", buf2, sessionId);
1:f44c3d2:         latch2.await();
1:9308db8: 
1:f44c3d2:         LOG.debug( "clientB response : " + buf2.toString() );
1:b41b7cc:         expected1 =  "<response id='handlerB' destination='queue://testB' >B1</response>";
1:b41b7cc:         expected2 = "<response id='handlerB' destination='queue://testB' >B2</response>";
1:f44c3d2:         assertContains( expected1, buf2.toString() );
1:f44c3d2:         assertContains( expected2, buf2.toString() );
1:df0c195: 
1:df0c195:         httpClient.stop();
1:88fc7fe:     }
1:b41b7cc: 
1:df0c195:     @Test(timeout = 15 * 1000)
1:c6ede16:     public void testAjaxClientReceivesMessagesForMultipleTopics() throws Exception {
1:c6ede16:         LOG.debug( "*** testAjaxClientReceivesMessagesForMultipleTopics ***" );
1:c5cebd5:         int port = getPort();
1:c5cebd5: 
1:c6ede16:         HttpClient httpClient = new HttpClient();
1:df0c195:         httpClient.start();
1:9308db8: 
1:c6ede16:         LOG.debug( "SENDING LISTEN FOR /topic/topicA" );
1:f44c3d2:         String sessionId = subscribe(httpClient, port, "destination=topic://topicA&type=listen&message=handlerA");
1:f44c3d2: 
1:9308db8: 
1:c6ede16:         LOG.debug( "SENDING LISTEN FOR /topic/topicB" );
1:f44c3d2:         subscribe(httpClient, port, "destination=topic://topicB&type=listen&message=handlerB", null, sessionId);
1:9308db8: 
1:c6ede16:         // client 1 polls for messages
1:f44c3d2:         final StringBuffer buf = new StringBuffer();
1:f44c3d2:         final CountDownLatch latch =
1:f44c3d2:                 asyncRequest(httpClient, "http://localhost:" + port + "/amq?timeout=5000", buf, sessionId);
1:9308db8: 
1:c6ede16:         // while client 1 is polling, client 2 sends messages to the topics
1:c6ede16:         LOG.debug( "SENDING MESSAGES" );
1:f44c3d2:         sendMessages(httpClient, port, ("destination=topic://topicA&type=send&message=A1&"+
1:f44c3d2:                 "d1=topic://topicB&t1=send&m1=B1&"+
1:f44c3d2:                 "d2=topic://topicA&t2=send&m2=A2&"+
1:f44c3d2:                 "d3=topic://topicB&t3=send&m3=B2").getBytes());
1:c6ede16:         LOG.debug( "DONE POSTING MESSAGES" );
1:9308db8: 
1:c6ede16:         // wait for poll to finish
1:f44c3d2:         latch.await();
1:f44c3d2:         String response = buf.toString();
1:9308db8: 
1:c6ede16:         // not all messages might be delivered during the 1st poll.  We need to check again.
1:f44c3d2:         final StringBuffer buf2 = new StringBuffer();
1:f44c3d2:         final CountDownLatch latch2 =
1:f44c3d2:                 asyncRequest(httpClient, "http://localhost:" + port + "/amq?timeout=5000", buf2, sessionId);
1:f44c3d2:         latch2.await();
1:9308db8: 
1:f44c3d2:         String fullResponse = response + buf2.toString();
1:c6ede16:         LOG.debug( "full response " + fullResponse );
1:b41b7cc:         assertContains( "<response id='handlerA' destination='topic://topicA' >A1</response>", fullResponse );
1:b41b7cc:         assertContains( "<response id='handlerB' destination='topic://topicB' >B1</response>", fullResponse );
1:b41b7cc:         assertContains( "<response id='handlerA' destination='topic://topicA' >A2</response>", fullResponse );
1:b41b7cc:         assertContains( "<response id='handlerB' destination='topic://topicB' >B2</response>", fullResponse );
1:c6ede16:         assertResponseCount( 4, fullResponse );
1:df0c195: 
1:df0c195:         httpClient.stop();
1:c6ede16:      }
1:9308db8: 
1:f44c3d2:     protected void sendMessages(HttpClient httpClient, int port, byte[] content) throws InterruptedException {
1:f44c3d2:         final CountDownLatch latch = new CountDownLatch(1);
1:f44c3d2:         final StringBuffer buf = new StringBuffer();
1:f44c3d2:         httpClient
1:f44c3d2:                 .newRequest("http://localhost:" + port + "/amq")
1:f44c3d2:                 .header("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8")
1:f44c3d2:                 .content(
1:f44c3d2:                         new InputStreamContentProvider(new ByteArrayInputStream(content)))
1:f44c3d2:                 .method(HttpMethod.POST).send(new BufferingResponseListener() {
1:f44c3d2:                     @Override
1:f44c3d2:                     public void onComplete(Result result) {
1:f44c3d2:                         buf.append(getContentAsString());
1:f44c3d2:                         latch.countDown();
1:f44c3d2:                     }
1:f44c3d2:                 });
1:f44c3d2:         latch.await();
1:f44c3d2:     }
1:f44c3d2: 
1:f44c3d2:     protected String subscribe(HttpClient httpClient, int port, String content) throws InterruptedException {
1:f44c3d2:         return this.subscribe(httpClient, port, content, null, null);
1:f44c3d2:     }
1:f44c3d2: 
1:f44c3d2:     protected String subscribe(HttpClient httpClient, int port, String content, String selector, String session) throws InterruptedException {
1:f44c3d2:         final CountDownLatch latch = new CountDownLatch(1);
1:f44c3d2:         final StringBuffer buf = new StringBuffer();
1:f44c3d2:         final StringBuffer sessionId = new StringBuffer();
1:f44c3d2:         Request request = httpClient.newRequest("http://localhost:" + port + "/amq");
1:f44c3d2:         if (selector != null) {
1:f44c3d2:             request.header("selector", selector);
1:f44c3d2:         }
1:f44c3d2:         if (session != null) {
1:f44c3d2:             request.header(HttpHeader.COOKIE, session);
1:f44c3d2:         }
1:f44c3d2:         request.header("Content-Type","application/x-www-form-urlencoded; charset=UTF-8")
1:f44c3d2:            .content(new InputStreamContentProvider(new ByteArrayInputStream(content.getBytes())))
1:f44c3d2:            .method(HttpMethod.POST).send(new BufferingResponseListener() {
1:f44c3d2:             @Override
1:f44c3d2:             public void onComplete(Result result) {
1:f44c3d2:                 buf.append(getContentAsString());
1:f44c3d2:                 String cookie = result.getResponse().getHeaders().get(HttpHeader.SET_COOKIE);
1:f44c3d2:                 if (cookie != null) {
1:f44c3d2:                     String[] cookieParts = cookie.split(";");
1:f44c3d2:                     sessionId.append(cookieParts[0]);
1:f44c3d2:                 }
1:f44c3d2:                 latch.countDown();
1:f44c3d2:             }
1:f44c3d2:         });
1:f44c3d2:         latch.await();
1:f44c3d2: 
1:f44c3d2:         return sessionId.toString();
1:f44c3d2:     }
1:f44c3d2: 
1:f44c3d2:     protected CountDownLatch asyncRequest(final HttpClient httpClient, final String url, final StringBuffer buffer,
1:f44c3d2:             final String sessionId) {
1:f44c3d2:         final CountDownLatch latch = new CountDownLatch(1);
1:f44c3d2:         Request request = httpClient.newRequest(url);
1:f44c3d2:         if (sessionId != null) {
1:f44c3d2:             request.header(HttpHeader.COOKIE, sessionId);
1:f44c3d2:         }
1:f44c3d2:         request.send(new BufferingResponseListener() {
1:f44c3d2:             @Override
1:f44c3d2:             public void onComplete(Result result) {
1:f44c3d2:                 buffer.append(getContentAsString());
1:f44c3d2:                 latch.countDown();
1:f44c3d2:             }
1:f44c3d2:         });
1:f44c3d2:         return latch;
1:f44c3d2:     }
1:f44c3d2: 
1:f44c3d2:     protected CountDownLatch asyncRequest(final HttpClient httpClient, final String url, final StringBuffer buffer,
1:f44c3d2:             final AtomicInteger status) {
1:f44c3d2:         final CountDownLatch latch = new CountDownLatch(1);
1:f44c3d2:         httpClient.newRequest(url).send(new BufferingResponseListener() {
1:f44c3d2:             @Override
1:f44c3d2:             public void onComplete(Result result) {
1:f44c3d2:                 status.getAndSet(result.getResponse().getStatus());
1:f44c3d2:                 buffer.append(getContentAsString());
1:f44c3d2:                 latch.countDown();
1:f44c3d2:             }
1:f44c3d2:         });
1:f44c3d2:         return latch;
1:f44c3d2:     }
1:88fc7fe: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:f44c3d2
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertTrue;
1: 
1: import java.io.ByteArrayInputStream;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.atomic.AtomicInteger;
/////////////////////////////////////////////////////////////////////////
1: import org.eclipse.jetty.client.api.Request;
1: import org.eclipse.jetty.client.api.Result;
1: import org.eclipse.jetty.client.util.BufferingResponseListener;
1: import org.eclipse.jetty.client.util.InputStreamContentProvider;
1: import org.eclipse.jetty.http.HttpHeader;
1: import org.eclipse.jetty.http.HttpMethod;
/////////////////////////////////////////////////////////////////////////
1:         String sessionId = subscribe(httpClient, port, "destination=queue://test&type=listen&message=handler");
1:         final StringBuffer buf = new StringBuffer();
1:         final CountDownLatch latch =
1:                 asyncRequest(httpClient, "http://localhost:" + port + "/amq?timeout=5000", buf, sessionId);
1:         sendMessages(httpClient, port, ("destination=queue://test&type=send&message=msg1&"+
1:                          "d1=queue://test&t1=send&m1=msg2&"+
1:                          "d2=queue://test&t2=send&m2=msg3").getBytes());
1: 
1:        latch.await();
1:        String response = buf.toString();
1:        final StringBuffer buf2 = new StringBuffer();
1:        final CountDownLatch latch2 =
1:                asyncRequest(httpClient, "http://localhost:" + port + "/amq?timeout=5000", buf2, sessionId);
1:        latch2.await();
1:         String fullResponse = response + buf2.toString();
/////////////////////////////////////////////////////////////////////////
1:         String sessionId = subscribe(httpClient, port, "destination=topic://test&type=listen&message=handler");
1:         final StringBuffer buf = new StringBuffer();
1:         final CountDownLatch latch =
1:                 asyncRequest(httpClient, "http://localhost:" + port + "/amq?timeout=5000", buf, sessionId);
1:         sendMessages(httpClient, port, ("destination=topic://test&type=send&message=msg1&"+
1:                 "d1=topic://test&t1=send&m1=msg2&"+
1:                 "d2=topic://test&t2=send&m2=msg3").getBytes());
1:         latch.await();
1:         String response = buf.toString();
1:         // messages might not all be delivered during the 1st poll. We need to
1:         // check again.
1:         final StringBuffer buf2 = new StringBuffer();
1:         final CountDownLatch latch2 = asyncRequest(httpClient,
1:                 "http://localhost:" + port + "/amq?timeout=5000", buf2, sessionId);
1:         latch2.await();
1:         String fullResponse = response + buf2.toString();
1: 
/////////////////////////////////////////////////////////////////////////
1:         String sessionId = subscribe(httpClient, port, "destination=queue://test&type=listen&message=handler");
1:         final StringBuffer buf = new StringBuffer();
1:         final CountDownLatch latch =
1:                 asyncRequest(httpClient, "http://localhost:" + port + "/amq?timeout=5000", buf, sessionId);
1:         latch.await();
1:         String response = buf.toString();
/////////////////////////////////////////////////////////////////////////
1:         String sessionId = subscribe(httpClient, port, "destination=queue://test&type=listen&message=handler");
1:         final StringBuffer buf = new StringBuffer();
1:         final CountDownLatch latch =
1:                 asyncRequest(httpClient, "http://localhost:" + port + "/amq?timeout=5000", buf, sessionId);
/////////////////////////////////////////////////////////////////////////
1:         latch.await();
1:         String response = buf.toString();
1:         final StringBuffer buf2 = new StringBuffer();
1:         final CountDownLatch latch2 =
1:                 asyncRequest(httpClient, "http://localhost:" + port + "/amq?timeout=5000", buf2, sessionId);
1:         latch2.await();
1:         String fullResponse = response + buf2.toString();
/////////////////////////////////////////////////////////////////////////
1:         sendMessages(httpClient, port, ("destination=queue://test&type=send&message=msg1&"+
1:                 "d1=queue://test&t1=send&m1=msg2&"+
1:                 "d2=queue://test&t2=send&m2=msg3&"+
1:                 "d3=queue://test&t3=send&m3=msg4").getBytes());
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         String sessionId = subscribe(httpClient, port, "destination=queue://test&type=listen&message=handler", "filter='two'", null);
1:         final StringBuffer buf = new StringBuffer();
1:         final CountDownLatch latch =
1:                 asyncRequest(httpClient, "http://localhost:" + port + "/amq?timeout=5000", buf, sessionId);
1:         latch.await();
1:         LOG.debug( buf.toString() );
1:         assertContains( expected, buf.toString() );
/////////////////////////////////////////////////////////////////////////
1:         String sessionId = subscribe(httpClient, port, "destination=queue://testA&type=listen&message=handlerA&clientId=clientA");
1:         subscribe(httpClient, port, "destination=queue://testB&type=listen&message=handlerB&clientId=clientB", null, sessionId);
1:         final StringBuffer buf = new StringBuffer();
1:         final CountDownLatch latch =
1:                 asyncRequest(httpClient, "http://localhost:" + port + "/amq?timeout=5000&clientId=clientA", buf, sessionId);
1:         latch.await();
1:         LOG.debug( "clientA response : " + buf.toString() );
1:         assertContains( expected1, buf.toString() );
1:         assertContains( expected2, buf.toString() );
1:         final StringBuffer buf2 = new StringBuffer();
1:         final CountDownLatch latch2 =
1:                 asyncRequest(httpClient, "http://localhost:" + port + "/amq?timeout=5000&clientId=clientB", buf2, sessionId);
1:         latch2.await();
1:         LOG.debug( "clientB response : " + buf2.toString() );
1:         assertContains( expected1, buf2.toString() );
1:         assertContains( expected2, buf2.toString() );
/////////////////////////////////////////////////////////////////////////
1:         String sessionId = subscribe(httpClient, port, "destination=topic://topicA&type=listen&message=handlerA");
1: 
1:         subscribe(httpClient, port, "destination=topic://topicB&type=listen&message=handlerB", null, sessionId);
1:         final StringBuffer buf = new StringBuffer();
1:         final CountDownLatch latch =
1:                 asyncRequest(httpClient, "http://localhost:" + port + "/amq?timeout=5000", buf, sessionId);
1:         sendMessages(httpClient, port, ("destination=topic://topicA&type=send&message=A1&"+
1:                 "d1=topic://topicB&t1=send&m1=B1&"+
1:                 "d2=topic://topicA&t2=send&m2=A2&"+
1:                 "d3=topic://topicB&t3=send&m3=B2").getBytes());
1:         latch.await();
1:         String response = buf.toString();
1:         final StringBuffer buf2 = new StringBuffer();
1:         final CountDownLatch latch2 =
1:                 asyncRequest(httpClient, "http://localhost:" + port + "/amq?timeout=5000", buf2, sessionId);
1:         latch2.await();
1:         String fullResponse = response + buf2.toString();
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected void sendMessages(HttpClient httpClient, int port, byte[] content) throws InterruptedException {
1:         final CountDownLatch latch = new CountDownLatch(1);
1:         final StringBuffer buf = new StringBuffer();
1:         httpClient
1:                 .newRequest("http://localhost:" + port + "/amq")
1:                 .header("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8")
1:                 .content(
1:                         new InputStreamContentProvider(new ByteArrayInputStream(content)))
1:                 .method(HttpMethod.POST).send(new BufferingResponseListener() {
1:                     @Override
1:                     public void onComplete(Result result) {
1:                         buf.append(getContentAsString());
1:                         latch.countDown();
1:                     }
1:                 });
1:         latch.await();
1:     }
1: 
1:     protected String subscribe(HttpClient httpClient, int port, String content) throws InterruptedException {
1:         return this.subscribe(httpClient, port, content, null, null);
1:     }
1: 
1:     protected String subscribe(HttpClient httpClient, int port, String content, String selector, String session) throws InterruptedException {
1:         final CountDownLatch latch = new CountDownLatch(1);
1:         final StringBuffer buf = new StringBuffer();
1:         final StringBuffer sessionId = new StringBuffer();
1:         Request request = httpClient.newRequest("http://localhost:" + port + "/amq");
1:         if (selector != null) {
1:             request.header("selector", selector);
1:         }
1:         if (session != null) {
1:             request.header(HttpHeader.COOKIE, session);
1:         }
1:         request.header("Content-Type","application/x-www-form-urlencoded; charset=UTF-8")
1:            .content(new InputStreamContentProvider(new ByteArrayInputStream(content.getBytes())))
1:            .method(HttpMethod.POST).send(new BufferingResponseListener() {
1:             @Override
1:             public void onComplete(Result result) {
1:                 buf.append(getContentAsString());
1:                 String cookie = result.getResponse().getHeaders().get(HttpHeader.SET_COOKIE);
1:                 if (cookie != null) {
1:                     String[] cookieParts = cookie.split(";");
1:                     sessionId.append(cookieParts[0]);
1:                 }
1:                 latch.countDown();
1:             }
1:         });
1:         latch.await();
1: 
1:         return sessionId.toString();
1:     }
1: 
1:     protected CountDownLatch asyncRequest(final HttpClient httpClient, final String url, final StringBuffer buffer,
1:             final String sessionId) {
1:         final CountDownLatch latch = new CountDownLatch(1);
1:         Request request = httpClient.newRequest(url);
1:         if (sessionId != null) {
1:             request.header(HttpHeader.COOKIE, sessionId);
1:         }
1:         request.send(new BufferingResponseListener() {
1:             @Override
1:             public void onComplete(Result result) {
1:                 buffer.append(getContentAsString());
1:                 latch.countDown();
1:             }
1:         });
1:         return latch;
1:     }
1: 
1:     protected CountDownLatch asyncRequest(final HttpClient httpClient, final String url, final StringBuffer buffer,
1:             final AtomicInteger status) {
1:         final CountDownLatch latch = new CountDownLatch(1);
1:         httpClient.newRequest(url).send(new BufferingResponseListener() {
1:             @Override
1:             public void onComplete(Result result) {
1:                 status.getAndSet(result.getResponse().getStatus());
1:                 buffer.append(getContentAsString());
1:                 latch.countDown();
1:             }
1:         });
1:         return latch;
1:     }
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:c5cebd5
/////////////////////////////////////////////////////////////////////////
1:         int port = getPort();
/////////////////////////////////////////////////////////////////////////
0:         contentExchange.setURL("http://localhost:" + port + "/amq");
/////////////////////////////////////////////////////////////////////////
0:         poll.setURL("http://localhost:" + port + "/amq?timeout=5000");
/////////////////////////////////////////////////////////////////////////
0:         contentExchange.setURL("http://localhost:" + port + "/amq");
/////////////////////////////////////////////////////////////////////////
0:         poll.setURL("http://localhost:" + port + "/amq?timeout=5000");
/////////////////////////////////////////////////////////////////////////
1:         int port = getPort();
/////////////////////////////////////////////////////////////////////////
0:         contentExchange.setURL("http://localhost:" + port + "/amq");
/////////////////////////////////////////////////////////////////////////
0:         poll.setURL("http://localhost:" + port + "/amq?timeout=5000");
/////////////////////////////////////////////////////////////////////////
0:         contentExchange.setURL("http://localhost:" + port + "/amq");
/////////////////////////////////////////////////////////////////////////
0:         poll.setURL("http://localhost:" + port + "/amq?timeout=5000");
/////////////////////////////////////////////////////////////////////////
1:         int port = getPort();
1: 
/////////////////////////////////////////////////////////////////////////
0:         contentExchange.setURL("http://localhost:" + port + "/amq");
/////////////////////////////////////////////////////////////////////////
0:         poll.setURL("http://localhost:" + port + "/amq?timeout=5000");
/////////////////////////////////////////////////////////////////////////
1:         int port = getPort();
/////////////////////////////////////////////////////////////////////////
0:         contentExchange.setURL("http://localhost:" + port + "/amq");
/////////////////////////////////////////////////////////////////////////
0:         poll.setURL("http://localhost:" + port + "/amq?timeout=5000");
/////////////////////////////////////////////////////////////////////////
0:         poll.setURL("http://localhost:" + port + "/amq?timeout=5000");
/////////////////////////////////////////////////////////////////////////
1:         int port = getPort();
/////////////////////////////////////////////////////////////////////////
0:         contentExchange.setURL("http://localhost:" + port + "/amq");
/////////////////////////////////////////////////////////////////////////
1:         int port = getPort();
/////////////////////////////////////////////////////////////////////////
0:         contentExchange.setURL("http://localhost:" + port + "/amq");
/////////////////////////////////////////////////////////////////////////
0:         poll.setURL("http://localhost:" + port + "/amq?timeout=5000");
/////////////////////////////////////////////////////////////////////////
1:         int port = getPort();
/////////////////////////////////////////////////////////////////////////
0:         contentExchange.setURL("http://localhost:" + port + "/amq");
/////////////////////////////////////////////////////////////////////////
0:         contentExchange.setURL("http://localhost:" + port + "/amq");
/////////////////////////////////////////////////////////////////////////
0:         poll.setURL("http://localhost:" + port + "/amq?timeout=5000&clientId=clientA");
/////////////////////////////////////////////////////////////////////////
0:         poll.setURL("http://localhost:" + port + "/amq?timeout=5000&clientId=clientB");
/////////////////////////////////////////////////////////////////////////
1:         int port = getPort();
1: 
/////////////////////////////////////////////////////////////////////////
0:         contentExchange.setURL("http://localhost:" + port + "/amq");
/////////////////////////////////////////////////////////////////////////
0:         contentExchange.setURL("http://localhost:" + port + "/amq");
/////////////////////////////////////////////////////////////////////////
0:         poll.setURL("http://localhost:" + port + "/amq?timeout=5000");
/////////////////////////////////////////////////////////////////////////
0:         contentExchange.setURL("http://localhost:" + port + "/amq");
/////////////////////////////////////////////////////////////////////////
0:         poll.setURL("http://localhost:" + port + "/amq?timeout=5000");
commit:df0c195
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 15 * 1000)
1:         httpClient.start();
/////////////////////////////////////////////////////////////////////////
1:         httpClient.stop();
1: }
1: 
1:     @Test(timeout = 15 * 1000)
1:         httpClient.start();
/////////////////////////////////////////////////////////////////////////
1: 
1:         httpClient.stop();
1:     @Test(timeout = 15 * 1000)
/////////////////////////////////////////////////////////////////////////
1:         httpClient.start();
/////////////////////////////////////////////////////////////////////////
1: 
1:         httpClient.stop();
1:     @Test(timeout = 15 * 1000)
1:         httpClient.start();
/////////////////////////////////////////////////////////////////////////
1: 
1:         httpClient.stop();
1:     @Test(timeout = 15 * 1000)
1:         httpClient.start();
/////////////////////////////////////////////////////////////////////////
1: 
1:         httpClient.stop();
1:     @Test(timeout = 15 * 1000)
/////////////////////////////////////////////////////////////////////////
1:         httpClient.start();
1:         // client subscribes to queue
/////////////////////////////////////////////////////////////////////////
1:         httpClient.stop();
1:     @Test(timeout = 15 * 1000)
/////////////////////////////////////////////////////////////////////////
1:         httpClient.start();
/////////////////////////////////////////////////////////////////////////
1: 
1:         httpClient.stop();
1:     @Test(timeout = 15 * 1000)
1:         httpClient.start();
/////////////////////////////////////////////////////////////////////////
1: 
1:         httpClient.stop();
author:Kevin Earls
-------------------------------------------------------------------------------
commit:bdf7aa4
/////////////////////////////////////////////////////////////////////////
1: import org.junit.Test;
0: import static org.junit.Assert.*;
1: 
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout = 60 * 1000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout = 60 * 1000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout = 60 * 1000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout = 60 * 1000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout = 60 * 1000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout = 60 * 1000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout = 60 * 1000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout = 60 * 1000)
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:b41b7cc
/////////////////////////////////////////////////////////////////////////
1:         assertContains( "<response id='handler' destination='queue://test' >msg1</response>", fullResponse );
1:         assertContains( "<response id='handler' destination='queue://test' >msg2</response>", fullResponse );
1:         assertContains( "<response id='handler' destination='queue://test' >msg3</response>", fullResponse );
/////////////////////////////////////////////////////////////////////////
1:         assertContains( "<response id='handler' destination='topic://test' >msg1</response>", fullResponse );
1:         assertContains( "<response id='handler' destination='topic://test' >msg2</response>", fullResponse );
1:         assertContains( "<response id='handler' destination='topic://test' >msg3</response>", fullResponse );
/////////////////////////////////////////////////////////////////////////
1:         assertContains( "<response id='handler' destination='queue://test' >test one</response>", response );
1:         assertContains( "<response id='handler' destination='queue://test' >test two</response>", response );
1:         assertContains( "<response id='handler' destination='queue://test' >test three</response>", response );
/////////////////////////////////////////////////////////////////////////
1:         assertContains( "<response id='handler' destination='queue://test' >message1</response>", fullResponse );
1:         assertContains( "<response id='handler' destination='queue://test' >message2</response>", fullResponse );
1:         assertContains( "<response id='handler' destination='queue://test' >message3</response>", fullResponse );
1:         assertContains( "<response id='handler' destination='queue://test' >message4</response>", fullResponse );
1:         assertContains( "<response id='handler' destination='queue://test' >message5</response>", fullResponse );
/////////////////////////////////////////////////////////////////////////
1:         String expected = "<response id='handler' destination='queue://test' >test two</response>";
1: 
0:         assertContains( expected, poll.getResponseContent() );
/////////////////////////////////////////////////////////////////////////
1:         String expected1 = "<response id='handlerA' destination='queue://testA' >A1</response>";
1:         String expected2 = "<response id='handlerA' destination='queue://testA' >A2</response>";
1: 
0:         assertContains( expected1, poll.getResponseContent() );
0:         assertContains( expected2, poll.getResponseContent() );
/////////////////////////////////////////////////////////////////////////
1:         expected1 =  "<response id='handlerB' destination='queue://testB' >B1</response>";
1:         expected2 = "<response id='handlerB' destination='queue://testB' >B2</response>";
1: 
0:         assertContains( expected1, poll.getResponseContent() );
0:         assertContains( expected2, poll.getResponseContent() );
/////////////////////////////////////////////////////////////////////////
1:         assertContains( "<response id='handlerA' destination='topic://topicA' >A1</response>", fullResponse );
1:         assertContains( "<response id='handlerB' destination='topic://topicB' >B1</response>", fullResponse );
1:         assertContains( "<response id='handlerA' destination='topic://topicA' >A2</response>", fullResponse );
1:         assertContains( "<response id='handlerB' destination='topic://topicB' >B2</response>", fullResponse );
commit:a259c12
/////////////////////////////////////////////////////////////////////////
1: import java.net.SocketTimeoutException;
1: import java.util.HashMap;
1: import java.util.concurrent.TimeUnit;
1: 
1: import javax.jms.Message;
1: import javax.jms.MessageProducer;
1: 
1: import org.apache.activemq.transport.stomp.Stomp;
0: import org.eclipse.jetty.io.Buffer;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:         String frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
1:         connection.sendFrame(frame);
1: 
1:         // Need to let the transport have enough time to dispatch the incoming messages from
1:         // the socket before we break the connection.
1:         TimeUnit.SECONDS.sleep(5);
1: 
commit:f3e9ec0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:9308db8
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         connection.open(stompUri.getHost(), stompUri.getPort());
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         connection.open(stompUri.getHost(), stompUri.getPort());
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
author:Alex Dean
-------------------------------------------------------------------------------
commit:c6ede16
/////////////////////////////////////////////////////////////////////////
1:     public void testAjaxClientReceivesMessagesForMultipleTopics() throws Exception {
1:         LOG.debug( "*** testAjaxClientReceivesMessagesForMultipleTopics ***" );
1:         HttpClient httpClient = new HttpClient();
0:         httpClient.start();
0:         httpClient.setConnectorType(HttpClient.CONNECTOR_SELECT_CHANNEL);
0:         
1:         LOG.debug( "SENDING LISTEN FOR /topic/topicA" );
0:         AjaxTestContentExchange contentExchange = new AjaxTestContentExchange();
0:         contentExchange.setMethod( "POST" );
0:         contentExchange.setURL("http://localhost:8080/amq");
0:         contentExchange.setRequestContent( new ByteArrayBuffer("destination=topic://topicA&type=listen&message=handlerA") );
0:         contentExchange.setRequestContentType( "application/x-www-form-urlencoded; charset=UTF-8" );
0:         httpClient.send(contentExchange);
0:         contentExchange.waitForDone();
0:         String jsessionid = contentExchange.getJsessionId();
0:         
1:         LOG.debug( "SENDING LISTEN FOR /topic/topicB" );
0:         contentExchange = new AjaxTestContentExchange();
0:         contentExchange.setMethod( "POST" );
0:         contentExchange.setURL("http://localhost:8080/amq");
0:         contentExchange.setRequestContent( new ByteArrayBuffer("destination=topic://topicB&type=listen&message=handlerB") );
0:         contentExchange.setRequestContentType( "application/x-www-form-urlencoded; charset=UTF-8" );
0:         contentExchange.setRequestHeader( "Cookie", jsessionid );
0:         httpClient.send(contentExchange);
0:         contentExchange.waitForDone();
0:         
1:         // client 1 polls for messages
1:         LOG.debug( "SENDING POLL" );
0:         AjaxTestContentExchange poll = new AjaxTestContentExchange();
0:         poll.setMethod( "GET" );
0:         poll.setURL("http://localhost:8080/amq?timeout=5000");
0:         poll.setRequestHeader( "Cookie", jsessionid );
0:         httpClient.send( poll );
0:         
1:         // while client 1 is polling, client 2 sends messages to the topics
1:         LOG.debug( "SENDING MESSAGES" );
0:         contentExchange = new AjaxTestContentExchange();
0:         contentExchange.setMethod( "POST" );
0:         contentExchange.setURL("http://localhost:8080/amq");
0:         contentExchange.setRequestContent( new ByteArrayBuffer(
0:             "destination=topic://topicA&type=send&message=A1&"+
0:             "d1=topic://topicB&t1=send&m1=B1&"+
0:             "d2=topic://topicA&t2=send&m2=A2&"+
0:             "d3=topic://topicB&t3=send&m3=B2"
0:         ) );
0:         contentExchange.setRequestContentType( "application/x-www-form-urlencoded; charset=UTF-8" );
0:         httpClient.send(contentExchange);
0:         contentExchange.waitForDone();
1:         LOG.debug( "DONE POSTING MESSAGES" );
0:         
1:         // wait for poll to finish
0:         poll.waitForDone();
0:         String response = poll.getResponseContent();
0:         
1:         // not all messages might be delivered during the 1st poll.  We need to check again.
0:         poll = new AjaxTestContentExchange();
0:         poll.setMethod( "GET" );
0:         poll.setURL("http://localhost:8080/amq?timeout=5000");
0:         poll.setRequestHeader( "Cookie", jsessionid );
0:         httpClient.send( poll );
0:         poll.waitForDone();
0: 
0:         String fullResponse = response + poll.getResponseContent();
1:         LOG.debug( "full response " + fullResponse );
0:         assertContains( "<response id='handlerA' destination='topic://topicA' >A1</response>\n", fullResponse );
0:         assertContains( "<response id='handlerB' destination='topic://topicB' >B1</response>\n", fullResponse );
0:         assertContains( "<response id='handlerA' destination='topic://topicA' >A2</response>\n", fullResponse );
0:         assertContains( "<response id='handlerB' destination='topic://topicB' >B2</response>\n", fullResponse );
1:         assertResponseCount( 4, fullResponse );
1:      }
0:     
commit:88fc7fe
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.stomp.StompConnection;
1: import org.apache.activemq.transport.stomp.StompFrame;
0: import org.apache.activemq.transport.stomp.Stomp;
0: import java.lang.Thread;
0: import java.net.SocketTimeoutException;
0: 
1: import org.apache.commons.lang.StringUtils;
0: 
0: import java.util.*;
0: import org.eclipse.jetty.io.Buffer;
0: import org.eclipse.jetty.client.ContentExchange;
1: import org.eclipse.jetty.client.HttpClient;
0: import org.eclipse.jetty.http.HttpFields;
0: import org.eclipse.jetty.io.ByteArrayBuffer;
0: import javax.jms.Message;
0:     
0:     private class AjaxTestContentExchange extends ContentExchange  {
0:         private HashMap<String,String> headers;
0:         private String responseContent;
0:         
0:         AjaxTestContentExchange() {
0:             super(true);
0:             this.headers = new HashMap<String,String>();
0:             this.responseContent = "";
1:         }
0:         protected void onResponseContent( Buffer content ) {
0:             this.responseContent += content.toString();
1:         }
0:         protected void onResponseHeader( Buffer name, Buffer value ) {
0:           headers.put( name.toString(), value.toString() );
1:         }
0:         public String getJsessionId() {
0:             String cookie = headers.get( "Set-Cookie" );
0:             String[] cookie_parts = cookie.split( ";" );
0:             return cookie_parts[0];
1:         }
0:         public String getResponseContent() {
0:             return responseContent;
1:         }
0:     
1:     public void assertContains( String expected, String actual ) {
1:         assertTrue( "'"+actual+"' does not contain expected fragment '"+expected+"'", actual.indexOf( expected ) != -1 );
1:     }
1:     public void assertResponseCount( int expected, String actual ) {
1:         int occurrences = StringUtils.countMatches( actual, "<response" );
1:         assertEquals( "Expected number of <response> elements is not correct.", expected, occurrences );
1:     }
0:     
1:     public void testAjaxClientReceivesMessagesWhichAreSentToQueueWhileClientIsPolling() throws Exception {
1:         LOG.debug( "*** testAjaxClientReceivesMessagesWhichAreSentToQueueWhileClientIsPolling ***" );
0:         
1:         HttpClient httpClient = new HttpClient();
0:         httpClient.start();
0:         httpClient.setConnectorType(HttpClient.CONNECTOR_SELECT_CHANNEL);
0:         
1:         // client 1 subscribes to a queue
1:         LOG.debug( "SENDING LISTEN" );
0:         AjaxTestContentExchange contentExchange = new AjaxTestContentExchange();
0:         contentExchange.setMethod( "POST" );
0:         contentExchange.setURL("http://localhost:8080/amq");
0:         contentExchange.setRequestContent( new ByteArrayBuffer("destination=queue://test&type=listen&message=handler") );
0:         contentExchange.setRequestContentType( "application/x-www-form-urlencoded; charset=UTF-8" );
0:         httpClient.send(contentExchange);
0:         contentExchange.waitForDone();
0:         String jsessionid = contentExchange.getJsessionId();
0:         
1:         // client 1 polls for messages
1:         LOG.debug( "SENDING POLL" );
0:         AjaxTestContentExchange poll = new AjaxTestContentExchange();
0:         poll.setMethod( "GET" );
0:         poll.setURL("http://localhost:8080/amq?timeout=5000");
0:         poll.setRequestHeader( "Cookie", jsessionid );
0:         httpClient.send( poll );
0:         
1:         // while client 1 is polling, client 2 sends messages to the queue
1:         LOG.debug( "SENDING MESSAGES" );
0:         contentExchange = new AjaxTestContentExchange();
0:         contentExchange.setMethod( "POST" );
0:         contentExchange.setURL("http://localhost:8080/amq");
0:         contentExchange.setRequestContent( new ByteArrayBuffer(
0:             "destination=queue://test&type=send&message=msg1&"+
0:             "d1=queue://test&t1=send&m1=msg2&"+
0:             "d2=queue://test&t2=send&m2=msg3"
0:         ) );
0:         contentExchange.setRequestContentType( "application/x-www-form-urlencoded; charset=UTF-8" );
0:         httpClient.send(contentExchange);
0:         contentExchange.waitForDone();
1:         LOG.debug( "DONE POSTING MESSAGES" );
0:         
1:         // wait for poll to finish
0:         poll.waitForDone();
0:         String response = poll.getResponseContent();
0:         
1:         // messages might not all be delivered during the 1st poll.  We need to check again.
0:         poll = new AjaxTestContentExchange();
0:         poll.setMethod( "GET" );
0:         poll.setURL("http://localhost:8080/amq?timeout=5000");
0:         poll.setRequestHeader( "Cookie", jsessionid );
0:         httpClient.send( poll );
0:         poll.waitForDone();
0:         
0:         String fullResponse = response + poll.getResponseContent();
1:         LOG.debug( "full response : " + fullResponse );
0:         
0:         assertContains( "<response id='handler' destination='queue://test' >msg1</response>\n", fullResponse );
0:         assertContains( "<response id='handler' destination='queue://test' >msg2</response>\n", fullResponse );
0:         assertContains( "<response id='handler' destination='queue://test' >msg3</response>\n", fullResponse );
1:         assertResponseCount( 3, fullResponse );
1:     }
0:     
1:     public void testAjaxClientReceivesMessagesWhichAreSentToTopicWhileClientIsPolling() throws Exception {
1:         LOG.debug( "*** testAjaxClientReceivesMessagesWhichAreSentToTopicWhileClientIsPolling ***" );
0:         
1:         HttpClient httpClient = new HttpClient();
0:         httpClient.start();
0:         httpClient.setConnectorType(HttpClient.CONNECTOR_SELECT_CHANNEL);
0:         
1:         // client 1 subscribes to a queue
1:         LOG.debug( "SENDING LISTEN" );
0:         AjaxTestContentExchange contentExchange = new AjaxTestContentExchange();
0:         contentExchange.setMethod( "POST" );
0:         contentExchange.setURL("http://localhost:8080/amq");
0:         contentExchange.setRequestContent( new ByteArrayBuffer("destination=topic://test&type=listen&message=handler") );
0:         contentExchange.setRequestContentType( "application/x-www-form-urlencoded; charset=UTF-8" );
0:         httpClient.send(contentExchange);
0:         contentExchange.waitForDone();
0:         String jsessionid = contentExchange.getJsessionId();
0:         
1:         // client 1 polls for messages
1:         LOG.debug( "SENDING POLL" );
0:         AjaxTestContentExchange poll = new AjaxTestContentExchange();
0:         poll.setMethod( "GET" );
0:         poll.setURL("http://localhost:8080/amq?timeout=5000");
0:         poll.setRequestHeader( "Cookie", jsessionid );
0:         httpClient.send( poll );
0:         
1:         // while client 1 is polling, client 2 sends messages to the queue
1:         LOG.debug( "SENDING MESSAGES" );
0:         contentExchange = new AjaxTestContentExchange();
0:         contentExchange.setMethod( "POST" );
0:         contentExchange.setURL("http://localhost:8080/amq");
0:         contentExchange.setRequestContent( new ByteArrayBuffer(
0:             "destination=topic://test&type=send&message=msg1&"+
0:             "d1=topic://test&t1=send&m1=msg2&"+
0:             "d2=topic://test&t2=send&m2=msg3"
0:         ) );
0:         contentExchange.setRequestContentType( "application/x-www-form-urlencoded; charset=UTF-8" );
0:         httpClient.send(contentExchange);
0:         contentExchange.waitForDone();
1:         LOG.debug( "DONE POSTING MESSAGES" );
0:         
1:         // wait for poll to finish
0:         poll.waitForDone();
0:         String response = poll.getResponseContent();
0:         
1:         // not all messages might be delivered during the 1st poll.  We need to check again.
0:         poll = new AjaxTestContentExchange();
0:         poll.setMethod( "GET" );
0:         poll.setURL("http://localhost:8080/amq?timeout=5000");
0:         poll.setRequestHeader( "Cookie", jsessionid );
0:         httpClient.send( poll );
0:         poll.waitForDone();
0:         
0:         String fullResponse = response + poll.getResponseContent();
1:         LOG.debug( "full response : " + fullResponse );
0:         
0:         assertContains( "<response id='handler' destination='topic://test' >msg1</response>\n", fullResponse );
0:         assertContains( "<response id='handler' destination='topic://test' >msg2</response>\n", fullResponse );
0:         assertContains( "<response id='handler' destination='topic://test' >msg3</response>\n", fullResponse );
1:         assertResponseCount( 3, fullResponse );
1:     }
0:     
1:     public void testAjaxClientReceivesMessagesWhichAreQueuedBeforeClientSubscribes() throws Exception {
1:         LOG.debug( "*** testAjaxClientReceivesMessagesWhichAreQueuedBeforeClientSubscribes ***" );
1:         // send messages to queue://test
1:         producer.send( session.createTextMessage("test one") );
1:         producer.send( session.createTextMessage("test two") );
1:         producer.send( session.createTextMessage("test three") );
0:         
1:         HttpClient httpClient = new HttpClient();
0:         httpClient.start();
0:         httpClient.setConnectorType(HttpClient.CONNECTOR_SELECT_CHANNEL);
0:         
1:         // client 1 subscribes to queue
1:         LOG.debug( "SENDING LISTEN" );
0:         AjaxTestContentExchange contentExchange = new AjaxTestContentExchange();
0:         contentExchange.setMethod( "POST" );
0:         contentExchange.setURL("http://localhost:8080/amq");
0:         contentExchange.setRequestContent( new ByteArrayBuffer("destination=queue://test&type=listen&message=handler") );
0:         contentExchange.setRequestContentType( "application/x-www-form-urlencoded; charset=UTF-8" );
0:         httpClient.send(contentExchange);
0:         contentExchange.waitForDone();
0:         String jsessionid = contentExchange.getJsessionId();
0:         
1:         // client 1 polls for messages
1:         LOG.debug( "SENDING POLL" );
0:         AjaxTestContentExchange poll = new AjaxTestContentExchange();
0:         poll.setMethod( "GET" );
0:         poll.setURL("http://localhost:8080/amq?timeout=5000");
0:         poll.setRequestHeader( "Cookie", jsessionid );
0:         httpClient.send( poll );
0:         
1:         // wait for poll to finish
0:         poll.waitForDone();
0:         String response = poll.getResponseContent();
0:         
0:         assertContains( "<response id='handler' destination='queue://test' >test one</response>\n", response );
0:         assertContains( "<response id='handler' destination='queue://test' >test two</response>\n", response );
0:         assertContains( "<response id='handler' destination='queue://test' >test three</response>\n", response );
1:         assertResponseCount( 3, response );
1:     }
0:     
1:     public void testStompMessagesAreReceivedByAjaxClient() throws Exception {
1:         LOG.debug( "*** testStompMessagesAreRecievedByAjaxClient ***" );
0:         
1:         HttpClient httpClient = new HttpClient();
0:         httpClient.start();
0:         httpClient.setConnectorType(HttpClient.CONNECTOR_SELECT_CHANNEL);
0:         
1:         // client 1 subscribes to a queue
1:         LOG.debug( "SENDING LISTEN" );
0:         AjaxTestContentExchange contentExchange = new AjaxTestContentExchange();
0:         contentExchange.setMethod( "POST" );
0:         contentExchange.setURL("http://localhost:8080/amq");
0:         contentExchange.setRequestContent( new ByteArrayBuffer("destination=queue://test&type=listen&message=handler") );
0:         contentExchange.setRequestContentType( "application/x-www-form-urlencoded; charset=UTF-8" );
0:         httpClient.send(contentExchange);
0:         contentExchange.waitForDone();
0:         String jsessionid = contentExchange.getJsessionId();
0:         
1:         // client 1 polls for messages
1:         LOG.debug( "SENDING POLL" );
0:         AjaxTestContentExchange poll = new AjaxTestContentExchange();
0:         poll.setMethod( "GET" );
0:         poll.setURL("http://localhost:8080/amq?timeout=5000");
0:         poll.setRequestHeader( "Cookie", jsessionid );
0:         httpClient.send( poll );
0:         
1:         // stomp client queues some messages
1:         StompConnection connection = new StompConnection();
0:         connection.open("localhost", 61613);
1:         connection.connect("user", "password");
1:         HashMap<String, String> headers = new HashMap<String, String>();
1:         headers.put( "amq-msg-type", "text" );
1:         connection.send( "/queue/test", "message1", (String)null, headers );
1:         connection.send( "/queue/test", "message2", (String)null, headers );
1:         connection.send( "/queue/test", "message3", (String)null, headers );
1:         connection.send( "/queue/test", "message4", (String)null, headers );
1:         connection.send( "/queue/test", "message5", (String)null, headers );
1:         connection.disconnect();
0:         
1:         // wait for poll to finish
0:         poll.waitForDone();
0:         String response = poll.getResponseContent();
0:         
1:         // not all messages might be delivered during the 1st poll.  We need to check again.
0:         poll = new AjaxTestContentExchange();
0:         poll.setMethod( "GET" );
0:         poll.setURL("http://localhost:8080/amq?timeout=5000");
0:         poll.setRequestHeader( "Cookie", jsessionid );
0:         httpClient.send( poll );
0:         poll.waitForDone();
0:         
0:         String fullResponse = response + poll.getResponseContent();
0:         
0:         assertContains( "<response id='handler' destination='queue://test' >message1</response>\n", fullResponse );
0:         assertContains( "<response id='handler' destination='queue://test' >message2</response>\n", fullResponse );
0:         assertContains( "<response id='handler' destination='queue://test' >message3</response>\n", fullResponse );
0:         assertContains( "<response id='handler' destination='queue://test' >message4</response>\n", fullResponse );
0:         assertContains( "<response id='handler' destination='queue://test' >message5</response>\n", fullResponse );
1:         assertResponseCount( 5, fullResponse );
1:     }
0:     
1:     public void testAjaxMessagesAreReceivedByStompClient() throws Exception {
1:         LOG.debug( "*** testAjaxMessagesAreReceivedByStompClient ***" );
0:         
1:         HttpClient httpClient = new HttpClient();
0:         httpClient.start();
0:         httpClient.setConnectorType(HttpClient.CONNECTOR_SELECT_CHANNEL);
0:         
0:         AjaxTestContentExchange contentExchange = new AjaxTestContentExchange();
0:         contentExchange.setMethod( "POST" );
0:         contentExchange.setURL("http://localhost:8080/amq");
0:         contentExchange.setRequestContent( new ByteArrayBuffer(
0:             "destination=queue://test&type=send&message=msg1&"+
0:             "d1=queue://test&t1=send&m1=msg2&"+
0:             "d2=queue://test&t2=send&m2=msg3&"+
0:             "d3=queue://test&t3=send&m3=msg4") );
0:         contentExchange.setRequestContentType( "application/x-www-form-urlencoded; charset=UTF-8" );
0:         httpClient.send(contentExchange);
0:         contentExchange.waitForDone();
0:         
1:         StompConnection connection = new StompConnection();
0:         connection.open("localhost", 61613);
1:         connection.connect("user", "password");
1:         connection.subscribe( "/queue/test" );
0:         
1:         StompFrame message;
1:         String allMessageBodies = "";
1:         try {
1:             while( true ) {
1:                 message = connection.receive(5000);
1:                 allMessageBodies = allMessageBodies +"\n"+ message.getBody();
1:             }
1:         } catch (SocketTimeoutException e) {}
0:         
1:         LOG.debug( "All message bodies : " + allMessageBodies );
0:         
1:         assertContains( "msg1", allMessageBodies );
1:         assertContains( "msg2", allMessageBodies );
1:         assertContains( "msg3", allMessageBodies );
1:         assertContains( "msg4", allMessageBodies );
1:     }
0:     
1:     public void testAjaxClientMayUseSelectors() throws Exception {
1:         LOG.debug( "*** testAjaxClientMayUseSelectors ***" );
0:         
1:         // send 2 messages to the same queue w/ different 'filter' values.
1:         Message msg = session.createTextMessage("test one");
1:         msg.setStringProperty( "filter", "one" );
1:         producer.send( msg );
1:         msg = session.createTextMessage("test two");
1:         msg.setStringProperty( "filter", "two" );
1:         producer.send( msg );
0:         
1:         HttpClient httpClient = new HttpClient();
0:         httpClient.start();
0:         httpClient.setConnectorType(HttpClient.CONNECTOR_SELECT_CHANNEL);
0:         
0:         // client ubscribes to queue
1:         LOG.debug( "SENDING LISTEN" );
0:         AjaxTestContentExchange contentExchange = new AjaxTestContentExchange();
0:         contentExchange.setMethod( "POST" );
0:         contentExchange.setURL("http://localhost:8080/amq");
0:         contentExchange.setRequestContent( new ByteArrayBuffer("destination=queue://test&type=listen&message=handler") );
0:         contentExchange.setRequestContentType( "application/x-www-form-urlencoded; charset=UTF-8" );
0:         // SELECTOR
0:         contentExchange.setRequestHeader( "selector", "filter='two'" );
0:         httpClient.send(contentExchange);
0:         contentExchange.waitForDone();
0:         String jsessionid = contentExchange.getJsessionId();
0:         
1:         // client 1 polls for messages
1:         LOG.debug( "SENDING POLL" );
0:         AjaxTestContentExchange poll = new AjaxTestContentExchange();
0:         poll.setMethod( "GET" );
0:         poll.setURL("http://localhost:8080/amq?timeout=5000");
0:         poll.setRequestHeader( "Cookie", jsessionid );
0:         httpClient.send( poll );
0:         poll.waitForDone();
0:         
0:         LOG.debug( poll.getResponseContent() );
0:         
0:         String expected = "<ajax-response>\n" +
0:             "<response id='handler' destination='queue://test' >test two</response>\n" +
0:             "</ajax-response>\n";
0:         assertEquals( "Poll response is not correct.", expected, poll.getResponseContent() );
0:         
1:     }
0:     
1:     public void testMultipleAjaxClientsMayExistInTheSameSession() throws Exception {
1:         LOG.debug( "*** testMultipleAjaxClientsMayExistInTheSameSession ***" );
0:         
1:         // send messages to queues testA and testB.
1:         MessageProducer producerA = session.createProducer(session.createQueue("testA"));
1:         MessageProducer producerB = session.createProducer(session.createQueue("testB"));
1:         producerA.send( session.createTextMessage("A1") );
1:         producerA.send( session.createTextMessage("A2") );
1:         producerB.send( session.createTextMessage("B1") );
1:         producerB.send( session.createTextMessage("B2") );
0:         
1:         HttpClient httpClient = new HttpClient();
0:         httpClient.start();
0:         httpClient.setConnectorType(HttpClient.CONNECTOR_SELECT_CHANNEL);
0:         
1:         // clientA subscribes to /queue/testA
1:         LOG.debug( "SENDING LISTEN" );
0:         AjaxTestContentExchange contentExchange = new AjaxTestContentExchange();
0:         contentExchange.setMethod( "POST" );
0:         contentExchange.setURL("http://localhost:8080/amq");
0:         contentExchange.setRequestContent( new ByteArrayBuffer(
0:             "destination=queue://testA&"+
0:             "type=listen&"+
0:             "message=handlerA&"+
0:             "clientId=clientA"
0:         ) );
0:         contentExchange.setRequestContentType( "application/x-www-form-urlencoded; charset=UTF-8" );
0:         httpClient.send(contentExchange);
0:         contentExchange.waitForDone();
0:         String jsessionid = contentExchange.getJsessionId();
0:         
1:         // clientB subscribes to /queue/testB using the same JSESSIONID.
0:         contentExchange = new AjaxTestContentExchange();
0:         contentExchange.setMethod( "POST" );
0:         contentExchange.setURL("http://localhost:8080/amq");
0:         contentExchange.setRequestHeader( "Cookie", jsessionid );
0:         contentExchange.setRequestContent( new ByteArrayBuffer(
0:             "destination=queue://testB&"+
0:             "type=listen&"+
0:             "message=handlerB&"+
0:             "clientId=clientB"
0:         ) );
0:         contentExchange.setRequestContentType( "application/x-www-form-urlencoded; charset=UTF-8" );
0:         httpClient.send(contentExchange);
0:         contentExchange.waitForDone();
0:         
1:         // clientA polls for messages
0:         AjaxTestContentExchange poll = new AjaxTestContentExchange();
0:         poll.setMethod( "GET" );
0:         poll.setURL("http://localhost:8080/amq?timeout=5000&clientId=clientA");
0:         poll.setRequestHeader( "Cookie", jsessionid );
0:         httpClient.send( poll );
0:         poll.waitForDone();
0:         
0:         LOG.debug( "clientA response : " + poll.getResponseContent() );
0:         String expected = "<ajax-response>\n" +
0:             "<response id='handlerA' destination='queue://testA' >A1</response>\n" +
0:             "<response id='handlerA' destination='queue://testA' >A2</response>\n" +
0:             "</ajax-response>\n";
0:         assertEquals( "Poll response is not correct.", expected, poll.getResponseContent() );
0:         
1:         // clientB polls for messages
0:         poll = new AjaxTestContentExchange();
0:         poll.setMethod( "GET" );
0:         poll.setURL("http://localhost:8080/amq?timeout=5000&clientId=clientB");
0:         poll.setRequestHeader( "Cookie", jsessionid );
0:         httpClient.send( poll );
0:         poll.waitForDone();
0:         
0:         LOG.debug( "clientB response : " + poll.getResponseContent() );
0:         expected = "<ajax-response>\n" +
0:             "<response id='handlerB' destination='queue://testB' >B1</response>\n" +
0:             "<response id='handlerB' destination='queue://testB' >B2</response>\n" +
0:             "</ajax-response>\n";
0:         assertEquals( "Poll response is not correct.", expected, poll.getResponseContent() );
1:     }
0:     
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(AjaxTest.class);
commit:de66445
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: import org.apache.commons.httpclient.HttpClient;
0: import org.apache.commons.httpclient.HttpMethod;
0: import org.apache.commons.httpclient.methods.GetMethod;
0: import org.apache.commons.httpclient.methods.PostMethod;
0: 
0: import javax.jms.MessageProducer;
0: import javax.jms.TextMessage;
commit:bef96a9
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.web;
0: 
0: 
0: import java.util.Enumeration;
0: import javax.jms.TextMessage;
0: import javax.jms.MessageProducer;
0: import javax.management.ObjectName;
0: 
0: import org.apache.activemq.broker.jmx.DestinationViewMBean;
0: import org.apache.activemq.broker.jmx.SubscriptionViewMBean;
0: import org.apache.commons.lang.RandomStringUtils;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: import org.apache.commons.httpclient.*;
0: import org.apache.commons.httpclient.methods.*;
0: import java.util.Set;
0: 
1: public class AjaxTest extends JettyTestSupport {
0:     private static final Log LOG = LogFactory.getLog(AjaxTest.class);
0: 
0:     private String expectedResponse = "<ajax-response>\n" +
0:             "<response id='handler' destination='queue://test' >test one</response>\n" +
0:             "<response id='handler' destination='queue://test' >test two</response>\n" +
0:             "<response id='handler' destination='queue://test' >test three</response>\n" +
0:             "</ajax-response>";
0: 
0:     public void testReceiveMultipleMessagesFromQueue() throws Exception {
0: 
0:         MessageProducer local_producer = session.createProducer(session.createQueue("test"));
0: 
0:         HttpClient httpClient = new HttpClient();
0:         PostMethod post = new PostMethod( "http://localhost:8080/amq" );
0:         post.addParameter( "destination", "queue://test" );
0:         post.addParameter( "type", "listen" );
0:         post.addParameter( "message", "handler" );
0:         httpClient.executeMethod( post );
0: 
0:         // send message
0:         TextMessage msg1 = session.createTextMessage("test one");
0:         producer.send(msg1);
0:         TextMessage msg2 = session.createTextMessage("test two");
0:         producer.send(msg2);
0:         TextMessage msg3 = session.createTextMessage("test three");
0:         producer.send(msg3);
0: 
0:         HttpMethod get = new GetMethod( "http://localhost:8080/amq?timeout=5000" );
0:         httpClient.executeMethod( get );
0:         byte[] responseBody = get.getResponseBody();
0:         String response = new String( responseBody );
0: 
0:         LOG.info("Poll response: " + response);
0:         assertEquals("Poll response not right", expectedResponse.trim(), response.trim());
0:     }
0: 
0: }
============================================================================