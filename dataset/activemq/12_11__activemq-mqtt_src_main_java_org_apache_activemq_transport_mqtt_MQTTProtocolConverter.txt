1:cfc6917: /**
1:cfc6917:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:cfc6917:  * contributor license agreements.  See the NOTICE file distributed with
1:cfc6917:  * this work for additional information regarding copyright ownership.
1:cfc6917:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:cfc6917:  * (the "License"); you may not use this file except in compliance with
1:cfc6917:  * the License.  You may obtain a copy of the License at
1:d212d3c:  *
1:cfc6917:  *      http://www.apache.org/licenses/LICENSE-2.0
2:cfc6917:  *
1:cfc6917:  * Unless required by applicable law or agreed to in writing, software
1:cfc6917:  * distributed under the License is distributed on an "AS IS" BASIS,
1:cfc6917:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:cfc6917:  * See the License for the specific language governing permissions and
1:cfc6917:  * limitations under the License.
2:cfc6917:  */
1:cfc6917: package org.apache.activemq.transport.mqtt;
1:6c85967: 
1:cfc6917: import java.io.IOException;
1:cfc6917: import java.util.Map;
1:cfc6917: import java.util.concurrent.ConcurrentHashMap;
1:9ef4259: import java.util.concurrent.ConcurrentMap;
1:cfc6917: import java.util.concurrent.atomic.AtomicBoolean;
1:0f5b406: import java.util.zip.DataFormatException;
1:0f5b406: import java.util.zip.Inflater;
1:3653f81: 
1:cfc6917: import javax.jms.Destination;
1:619864d: import javax.jms.InvalidClientIDException;
1:cfc6917: import javax.jms.JMSException;
1:0f5b406: import javax.jms.Message;
1:619864d: import javax.security.auth.login.CredentialException;
1:0db7e69: 
1:bc4f4e9: import org.apache.activemq.broker.BrokerService;
1:413e484: import org.apache.activemq.broker.BrokerServiceAware;
1:bcb60a4: import org.apache.activemq.broker.region.policy.RetainedMessageSubscriptionRecoveryPolicy;
1:3653f81: import org.apache.activemq.command.ActiveMQBytesMessage;
1:3653f81: import org.apache.activemq.command.ActiveMQDestination;
1:3653f81: import org.apache.activemq.command.ActiveMQMapMessage;
1:3653f81: import org.apache.activemq.command.ActiveMQMessage;
1:3653f81: import org.apache.activemq.command.ActiveMQTextMessage;
1:3653f81: import org.apache.activemq.command.Command;
1:3653f81: import org.apache.activemq.command.ConnectionError;
1:3653f81: import org.apache.activemq.command.ConnectionId;
1:3653f81: import org.apache.activemq.command.ConnectionInfo;
1:3653f81: import org.apache.activemq.command.ExceptionResponse;
1:3653f81: import org.apache.activemq.command.MessageAck;
1:3653f81: import org.apache.activemq.command.MessageDispatch;
1:3653f81: import org.apache.activemq.command.MessageId;
1:3653f81: import org.apache.activemq.command.ProducerId;
1:3653f81: import org.apache.activemq.command.ProducerInfo;
1:3653f81: import org.apache.activemq.command.Response;
1:3653f81: import org.apache.activemq.command.SessionId;
1:3653f81: import org.apache.activemq.command.SessionInfo;
1:3653f81: import org.apache.activemq.command.ShutdownInfo;
1:413e484: import org.apache.activemq.transport.mqtt.strategy.MQTTSubscriptionStrategy;
1:0f5b406: import org.apache.activemq.util.ByteArrayOutputStream;
1:cfc6917: import org.apache.activemq.util.ByteSequence;
1:413e484: import org.apache.activemq.util.FactoryFinder;
1:cfc6917: import org.apache.activemq.util.IOExceptionSupport;
1:cfc6917: import org.apache.activemq.util.IdGenerator;
1:413e484: import org.apache.activemq.util.JMSExceptionSupport;
1:cfc6917: import org.apache.activemq.util.LRUCache;
1:cfc6917: import org.apache.activemq.util.LongSequenceGenerator;
1:cfc6917: import org.fusesource.hawtbuf.Buffer;
1:cfc6917: import org.fusesource.hawtbuf.UTF8Buffer;
1:0f5b406: import org.fusesource.mqtt.client.QoS;
1:0f5b406: import org.fusesource.mqtt.client.Topic;
1:3653f81: import org.fusesource.mqtt.codec.CONNACK;
1:3653f81: import org.fusesource.mqtt.codec.CONNECT;
1:3653f81: import org.fusesource.mqtt.codec.DISCONNECT;
1:3653f81: import org.fusesource.mqtt.codec.MQTTFrame;
1:3653f81: import org.fusesource.mqtt.codec.PINGREQ;
1:3653f81: import org.fusesource.mqtt.codec.PINGRESP;
1:3653f81: import org.fusesource.mqtt.codec.PUBACK;
1:3653f81: import org.fusesource.mqtt.codec.PUBCOMP;
1:3653f81: import org.fusesource.mqtt.codec.PUBLISH;
1:3653f81: import org.fusesource.mqtt.codec.PUBREC;
1:3653f81: import org.fusesource.mqtt.codec.PUBREL;
1:3653f81: import org.fusesource.mqtt.codec.SUBACK;
1:3653f81: import org.fusesource.mqtt.codec.SUBSCRIBE;
1:3653f81: import org.fusesource.mqtt.codec.UNSUBACK;
1:3653f81: import org.fusesource.mqtt.codec.UNSUBSCRIBE;
1:cfc6917: import org.slf4j.Logger;
1:cfc6917: import org.slf4j.LoggerFactory;
1:6c85967: 
1:33ec1cf: public class MQTTProtocolConverter {
1:a581d01: 
1:cfc6917:     private static final Logger LOG = LoggerFactory.getLogger(MQTTProtocolConverter.class);
1:7068302: 
1:eaed019:     public static final String QOS_PROPERTY_NAME = "ActiveMQ.MQTT.QoS";
1:a4fbe70:     public static final int V3_1 = 3;
1:a4fbe70:     public static final int V3_1_1 = 4;
1:eaed019: 
1:1b38b27:     public static final String SINGLE_LEVEL_WILDCARD = "+";
1:1b38b27:     public static final String MULTI_LEVEL_WILDCARD = "#";
1:1b38b27: 
1:cfc6917:     private static final IdGenerator CONNECTION_ID_GENERATOR = new IdGenerator();
1:cfc6917:     private static final MQTTFrame PING_RESP_FRAME = new PINGRESP().encode();
1:59f8cfc:     private static final double MQTT_KEEP_ALIVE_GRACE_PERIOD = 0.5;
1:afddc1a:     static final int DEFAULT_CACHE_SIZE = 5000;
1:4c38438: 
1:cfc6917:     private final ConnectionId connectionId = new ConnectionId(CONNECTION_ID_GENERATOR.generateId());
1:cfc6917:     private final SessionId sessionId = new SessionId(connectionId, -1);
1:cfc6917:     private final ProducerId producerId = new ProducerId(sessionId, 1);
1:67f151f:     private final LongSequenceGenerator publisherIdGenerator = new LongSequenceGenerator();
1:4c38438: 
1:9ef4259:     private final ConcurrentMap<Integer, ResponseHandler> resposeHandlers = new ConcurrentHashMap<Integer, ResponseHandler>();
1:413e484:     private final Map<String, ActiveMQDestination> activeMQDestinationMap = new LRUCache<String, ActiveMQDestination>(DEFAULT_CACHE_SIZE);
1:a0a23b9:     private final Map<ActiveMQDestination, String> mqttTopicMap = new LRUCache<ActiveMQDestination, String>(DEFAULT_CACHE_SIZE);
1:4c38438: 
1:667237f:     private final Map<Short, MessageAck> consumerAcks = new LRUCache<Short, MessageAck>(DEFAULT_CACHE_SIZE);
1:667237f:     private final Map<Short, PUBREC> publisherRecs = new LRUCache<Short, PUBREC>(DEFAULT_CACHE_SIZE);
1:67f151f: 
1:cfc6917:     private final MQTTTransport mqttTransport;
1:bc4f4e9:     private final BrokerService brokerService;
1:0f5b406: 
1:cfc6917:     private final Object commnadIdMutex = new Object();
1:cfc6917:     private int lastCommandId;
1:cfc6917:     private final AtomicBoolean connected = new AtomicBoolean(false);
1:7b5f956:     private final ConnectionInfo connectionInfo = new ConnectionInfo();
1:cfc6917:     private CONNECT connect;
1:cfc6917:     private String clientId;
1:d212d3c:     private long defaultKeepAlive;
1:d547025:     private int activeMQSubscriptionPrefetch = -1;
1:afddc1a:     private final MQTTPacketIdGenerator packetIdGenerator;
1:73908d6:     private boolean publishDollarTopics;
12:0f5b406: 
1:a4fbe70:     public int version;
1:a4fbe70: 
1:413e484:     private final FactoryFinder STRATAGY_FINDER = new FactoryFinder("META-INF/services/org/apache/activemq/transport/strategies/");
1:59f8cfc: 
1:413e484:     /*
1:413e484:      * Subscription strategy configuration element.
1:413e484:      *   > mqtt-default-subscriptions
1:413e484:      *   > mqtt-virtual-topic-subscriptions
1:413e484:      */
1:413e484:     private String subscriptionStrategyName = "mqtt-default-subscriptions";
1:413e484:     private MQTTSubscriptionStrategy subsciptionStrategy;
1:413e484: 
1:bc4f4e9:     public MQTTProtocolConverter(MQTTTransport mqttTransport, BrokerService brokerService) {
1:cfc6917:         this.mqttTransport = mqttTransport;
1:bc4f4e9:         this.brokerService = brokerService;
1:afddc1a:         this.packetIdGenerator = MQTTPacketIdGenerator.getMQTTPacketIdGenerator(brokerService);
1:d212d3c:         this.defaultKeepAlive = 0;
1:bc4f4e9:     }
1:d8f9686: 
1:0f5b406:     int generateCommandId() {
1:cfc6917:         synchronized (commnadIdMutex) {
1:cfc6917:             return lastCommandId++;
1:413e484:         }
1:413e484:     }
1:d8f9686: 
1:413e484:     public void sendToActiveMQ(Command command, ResponseHandler handler) {
1:73908d6: 
1:7068302:         // Lets intercept message send requests..
1:efa5527:         if (command instanceof ActiveMQMessage) {
1:7068302:             ActiveMQMessage msg = (ActiveMQMessage) command;
1:413e484:             try {
1:59f8cfc:                 if (!getPublishDollarTopics() && findSubscriptionStrategy().isControlTopic(msg.getDestination())) {
1:413e484:                     // We don't allow users to send to $ prefixed topics to avoid failing MQTT 3.1.1
1:413e484:                     // specification requirements for system assigned destinations.
1:413e484:                     if (handler != null) {
1:413e484:                         try {
1:413e484:                             handler.onResponse(this, new Response());
1:413e484:                         } catch (IOException e) {
1:457dbd8:                             LOG.warn("Failed to send command " + command, e);
1:413e484:                         }
1:413e484:                     }
1:413e484:                     return;
1:413e484:                 }
1:413e484:             } catch (IOException e) {
1:457dbd8:                 LOG.warn("Failed to send command " + command, e);
1:d8f9686:             }
1:5de0c8e:         }
1:73908d6: 
1:cfc6917:         command.setCommandId(generateCommandId());
1:efa5527:         if (handler != null) {
1:cfc6917:             command.setResponseRequired(true);
1:667237f:             resposeHandlers.put(command.getCommandId(), handler);
1:73908d6:         }
1:4ba4aa2:         getMQTTTransport().sendToActiveMQ(command);
1:6c85967:     }
1:6c85967: 
1:0f5b406:     void sendToMQTT(MQTTFrame frame) {
1:413e484:         try {
1:0f5b406:             mqttTransport.sendToMQTT(frame);
1:413e484:         } catch (IOException e) {
1:0f5b406:             LOG.warn("Failed to send frame " + frame, e);
1:6c85967:         }
1:88c6ee9:     }
1:8644090: 
1:cfc6917:     /**
1:cfc6917:      * Convert a MQTT command
1:cfc6917:      */
1:cfc6917:     public void onMQTTCommand(MQTTFrame frame) throws IOException, JMSException {
1:cfc6917:         switch (frame.messageType()) {
1:413e484:             case PINGREQ.TYPE:
1:d212d3c:                 LOG.debug("Received a ping from client: " + getClientId());
1:6dacef1:                 checkConnected();
1:4ba4aa2:                 sendToMQTT(PING_RESP_FRAME);
1:cfc6917:                 LOG.debug("Sent Ping Response to " + getClientId());
1:8644090:                 break;
1:413e484:             case CONNECT.TYPE:
1:ad30410:                 CONNECT connect = new CONNECT().decode(frame);
1:ad30410:                 onMQTTConnect(connect);
1:ad30410:                 LOG.debug("MQTT Client {} connected. (version: {})", getClientId(), connect.version());
1:9735806:                 break;
1:413e484:             case DISCONNECT.TYPE:
1:ad30410:                 LOG.debug("MQTT Client {} disconnecting", getClientId());
1:7b5f956:                 onMQTTDisconnect();
1:9735806:                 break;
1:413e484:             case SUBSCRIBE.TYPE:
1:0f5b406:                 onSubscribe(new SUBSCRIBE().decode(frame));
1:9735806:                 break;
1:413e484:             case UNSUBSCRIBE.TYPE:
1:0f5b406:                 onUnSubscribe(new UNSUBSCRIBE().decode(frame));
1:9735806:                 break;
1:413e484:             case PUBLISH.TYPE:
1:0f5b406:                 onMQTTPublish(new PUBLISH().decode(frame));
1:9735806:                 break;
1:413e484:             case PUBACK.TYPE:
1:0f5b406:                 onMQTTPubAck(new PUBACK().decode(frame));
1:9735806:                 break;
1:413e484:             case PUBREC.TYPE:
1:4c38438:                 onMQTTPubRec(new PUBREC().decode(frame));
1:4c38438:                 break;
1:413e484:             case PUBREL.TYPE:
1:4c38438:                 onMQTTPubRel(new PUBREL().decode(frame));
1:4c38438:                 break;
1:413e484:             case PUBCOMP.TYPE:
1:4c38438:                 onMQTTPubComp(new PUBCOMP().decode(frame));
1:4c38438:                 break;
1:413e484:             default:
1:cfc6917:                 handleException(new MQTTProtocolException("Unknown MQTTFrame type: " + frame.messageType(), true), frame);
1:a581d01:         }
1:a581d01:     }
1:88c6ee9: 
1:4c38438:     void onMQTTConnect(final CONNECT connect) throws MQTTProtocolException {
1:cfc6917:         if (connected.get()) {
1:b679787:             throw new MQTTProtocolException("Already connected.");
1:a581d01:         }
1:cfc6917:         this.connect = connect;
1:88c6ee9: 
1:f3544f2:         // The Server MUST respond to the CONNECT Packet with a CONNACK return code 0x01
1:f3544f2:         // (unacceptable protocol level) and then disconnect the Client if the Protocol Level
1:f3544f2:         // is not supported by the Server [MQTT-3.1.2-2].
1:f3544f2:         if (connect.version() < 3 || connect.version() > 4) {
1:f3544f2:             CONNACK ack = new CONNACK();
1:f3544f2:             ack.code(CONNACK.Code.CONNECTION_REFUSED_UNACCEPTED_PROTOCOL_VERSION);
1:f3544f2:             try {
1:f3544f2:                 getMQTTTransport().sendToMQTT(ack.encode());
1:f3544f2:                 getMQTTTransport().onException(IOExceptionSupport.create("Unsupported or invalid protocol version", null));
1:f3544f2:             } catch (IOException e) {
1:f3544f2:                 getMQTTTransport().onException(IOExceptionSupport.create(e));
1:f3544f2:             }
1:f3544f2:             return;
1:f3544f2:         }
1:f3544f2: 
1:cfc6917:         String clientId = "";
1:cfc6917:         if (connect.clientId() != null) {
2:cfc6917:             clientId = connect.clientId().toString();
1:a581d01:         }
1:88c6ee9: 
1:a63a832:         String userName = null;
1:cfc6917:         if (connect.userName() != null) {
1:cfc6917:             userName = connect.userName().toString();
1:a581d01:         }
1:a63a832:         String passswd = null;
1:cfc6917:         if (connect.password() != null) {
1:c530b69: 
1:c530b69:             if (userName == null && connect.version() != V3_1) {
1:c530b69:                 // [MQTT-3.1.2-22]: If the user name is not present then the
1:c530b69:                 // password must also be absent.
1:c530b69:                 // [MQTT-3.1.4-1]: would seem to imply we don't send a CONNACK here.
1:c530b69:                 getMQTTTransport().onException(IOExceptionSupport.create("Password given without a user name", null));
1:c530b69:                 return;
1:c530b69:             }
1:c530b69: 
1:cfc6917:             passswd = connect.password().toString();
1:7068302:         }
1:a581d01: 
1:a4fbe70:         version = connect.version();
1:a4fbe70: 
1:cfc6917:         configureInactivityMonitor(connect.keepAlive());
1:a581d01: 
1:cfc6917:         connectionInfo.setConnectionId(connectionId);
1:0f5b406:         if (clientId != null && !clientId.isEmpty()) {
1:cfc6917:             connectionInfo.setClientId(clientId);
1:d8f9686:         } else {
1:b679787:             // Clean Session MUST be set for 0 length Client Id
1:b679787:             if (!connect.cleanSession()) {
1:b679787:                 CONNACK ack = new CONNACK();
1:b679787:                 ack.code(CONNACK.Code.CONNECTION_REFUSED_IDENTIFIER_REJECTED);
1:413e484:                 try {
1:b679787:                     getMQTTTransport().sendToMQTT(ack.encode());
1:b679787:                     getMQTTTransport().onException(IOExceptionSupport.create("Invalid Client ID", null));
1:413e484:                 } catch (IOException e) {
1:b679787:                     getMQTTTransport().onException(IOExceptionSupport.create(e));
1:7e56f34:                 }
1:b679787:                 return;
1:b679787:             }
1:cfc6917:             connectionInfo.setClientId("" + connectionInfo.getConnectionId().toString());
1:b679787:         }
1:d8f9686: 
1:cfc6917:         connectionInfo.setResponseRequired(true);
1:cfc6917:         connectionInfo.setUserName(userName);
1:cfc6917:         connectionInfo.setPassword(passswd);
1:cfc6917:         connectionInfo.setTransportContext(mqttTransport.getPeerCertificates());
1:7e56f34: 
1:cfc6917:         sendToActiveMQ(connectionInfo, new ResponseHandler() {
1:ac23b01:             @Override
1:ac23b01:             public void onResponse(MQTTProtocolConverter converter, Response response) throws IOException {
1:7e56f34: 
1:ac23b01:                 if (response.isException()) {
1:cfc6917:                     // If the connection attempt fails we close the socket.
1:cfc6917:                     Throwable exception = ((ExceptionResponse) response).getException();
1:cfc6917:                     //let the client know
1:cfc6917:                     CONNACK ack = new CONNACK();
1:619864d:                     if (exception instanceof InvalidClientIDException) {
1:619864d:                         ack.code(CONNACK.Code.CONNECTION_REFUSED_IDENTIFIER_REJECTED);
1:619864d:                     } else if (exception instanceof SecurityException) {
1:619864d:                         ack.code(CONNACK.Code.CONNECTION_REFUSED_NOT_AUTHORIZED);
1:619864d:                     } else if (exception instanceof CredentialException) {
1:3653f81:                         ack.code(CONNACK.Code.CONNECTION_REFUSED_BAD_USERNAME_OR_PASSWORD);
1:ac23b01:                     } else {
1:3653f81:                         ack.code(CONNACK.Code.CONNECTION_REFUSED_SERVER_UNAVAILABLE);
1:ac23b01:                     }
1:cfc6917:                     getMQTTTransport().sendToMQTT(ack.encode());
1:cfc6917:                     getMQTTTransport().onException(IOExceptionSupport.create(exception));
1:b679787:                     return;
1:ac23b01:                 }
1:7e56f34: 
1:cfc6917:                 final SessionInfo sessionInfo = new SessionInfo(sessionId);
1:cfc6917:                 sendToActiveMQ(sessionInfo, null);
1:7e56f34: 
1:cfc6917:                 final ProducerInfo producerInfo = new ProducerInfo(producerId);
1:cfc6917:                 sendToActiveMQ(producerInfo, new ResponseHandler() {
1:413e484:                     @Override
1:413e484:                     public void onResponse(MQTTProtocolConverter converter, Response response) throws IOException {
1:a581d01: 
2:0f5b406:                         if (response.isException()) {
1:cfc6917:                             // If the connection attempt fails we close the socket.
1:cfc6917:                             Throwable exception = ((ExceptionResponse) response).getException();
1:cfc6917:                             CONNACK ack = new CONNACK();
1:cfc6917:                             ack.code(CONNACK.Code.CONNECTION_REFUSED_BAD_USERNAME_OR_PASSWORD);
1:cfc6917:                             getMQTTTransport().sendToMQTT(ack.encode());
1:cfc6917:                             getMQTTTransport().onException(IOExceptionSupport.create(exception));
1:6c85967:                             return;
1:413e484:                         }
1:a581d01: 
1:cfc6917:                         CONNACK ack = new CONNACK();
1:cfc6917:                         ack.code(CONNACK.Code.CONNECTION_ACCEPTED);
1:0f5b406:                         connected.set(true);
1:cfc6917:                         getMQTTTransport().sendToMQTT(ack.encode());
1:7068302: 
1:efa5527:                         if (connect.cleanSession()) {
1:afddc1a:                             packetIdGenerator.stopClientSession(getClientId());
1:3653f81:                         } else {
1:afddc1a:                             packetIdGenerator.startClientSession(getClientId());
1:3653f81:                         }
1:413e484: 
1:59f8cfc:                         findSubscriptionStrategy().onConnect(connect);
1:7068302:                     }
1:ac23b01:                 });
1:ac23b01:             }
1:413e484:         });
1:7068302:     }
1:ac23b01: 
1:7b5f956:     void onMQTTDisconnect() throws MQTTProtocolException {
1:bd442a3:         if (connected.compareAndSet(true, false)) {
1:7b5f956:             sendToActiveMQ(connectionInfo.createRemoveCommand(), null);
1:7b5f956:             sendToActiveMQ(new ShutdownInfo(), null);
1:7068302:         }
1:cfc6917:         stopTransport();
1:e2a7d6a:     }
1:413e484: 
1:0f5b406:     void onSubscribe(SUBSCRIBE command) throws MQTTProtocolException {
1:b97fa15:         checkConnected();
1:7ebc6ce:         LOG.trace("MQTT SUBSCRIBE message:{} client:{} connection:{}",
1:7ebc6ce:                   command.messageId(), clientId, connectionInfo.getConnectionId());
1:0f5b406:         Topic[] topics = command.topics();
1:0f5b406:         if (topics != null) {
1:0f5b406:             byte[] qos = new byte[topics.length];
1:0db7e69:             for (int i = 0; i < topics.length; i++) {
1:5d6d42c:                 MQTTProtocolSupport.validate(topics[i].name().toString());
1:ec049a0:                 try {
1:59f8cfc:                     qos[i] = findSubscriptionStrategy().onSubscribe(topics[i]);
1:ec049a0:                 } catch (IOException e) {
1:ec049a0:                     throw new MQTTProtocolException("Failed to process subscription request", true, e);
1:ac23b01:                 }
1:ec049a0:             }
1:0f5b406:             SUBACK ack = new SUBACK();
2:0f5b406:             ack.messageId(command.messageId());
1:0f5b406:             ack.grantedQos(qos);
1:413e484:             try {
1:0f5b406:                 getMQTTTransport().sendToMQTT(ack.encode());
1:413e484:             } catch (IOException e) {
1:0f5b406:                 LOG.warn("Couldn't send SUBACK for " + command, e);
1:9735806:             }
1:7e56f34:         } else {
1:0db7e69:             LOG.warn("No topics defined for Subscription " + command);
1:5d6d42c:             throw new MQTTProtocolException("SUBSCRIBE command received with no topic filter");
1:413e484:         }
1:413e484:     }
1:413e484: 
1:413e484:     public void onUnSubscribe(UNSUBSCRIBE command) throws MQTTProtocolException {
1:0f5b406:         checkConnected();
1:b83c38b:         if (command.qos() != QoS.AT_LEAST_ONCE && (version != V3_1 || publishDollarTopics != true)) {
1:b83c38b:             throw new MQTTProtocolException("Failed to process unsubscribe request", true, new Exception("UNSUBSCRIBE frame not properly formatted, QoS"));
1:b83c38b:         }
1:0f5b406:         UTF8Buffer[] topics = command.topics();
1:0f5b406:         if (topics != null) {
1:667237f:             for (UTF8Buffer topic : topics) {
1:5d6d42c:                 MQTTProtocolSupport.validate(topic.toString());
1:ec049a0:                 try {
1:59f8cfc:                     findSubscriptionStrategy().onUnSubscribe(topic.toString());
1:ec049a0:                 } catch (IOException e) {
1:ec049a0:                     throw new MQTTProtocolException("Failed to process unsubscribe request", true, e);
1:ec049a0:                 }
1:9735806:             }
1:5d6d42c:             UNSUBACK ack = new UNSUBACK();
1:5d6d42c:             ack.messageId(command.messageId());
1:5d6d42c:             sendToMQTT(ack.encode());
1:5d6d42c:         } else {
1:5d6d42c:             LOG.warn("No topics defined for Subscription " + command);
1:5d6d42c:             throw new MQTTProtocolException("UNSUBSCRIBE command received with no topic filter");
1:413e484:         }
1:9735806:     }
1:413e484: 
1:cfc6917:     /**
1:8644090:      * Dispatch an ActiveMQ command
1:0f5b406:      */
1:0f5b406:     public void onActiveMQCommand(Command command) throws Exception {
1:cfc6917:         if (command.isResponse()) {
1:cfc6917:             Response response = (Response) command;
1:cfc6917:             ResponseHandler rh = resposeHandlers.remove(Integer.valueOf(response.getCorrelationId()));
1:cfc6917:             if (rh != null) {
1:cfc6917:                 rh.onResponse(this, response);
1:0db7e69:             } else {
1:cfc6917:                 // Pass down any unexpected errors. Should this close the connection?
1:0f5b406:                 if (response.isException()) {
1:cfc6917:                     Throwable exception = ((ExceptionResponse) response).getException();
1:cfc6917:                     handleException(exception, null);
1:bc4f4e9:                 }
1:bc4f4e9:             }
1:cfc6917:         } else if (command.isMessageDispatch()) {
1:cfc6917:             MessageDispatch md = (MessageDispatch) command;
1:59f8cfc:             MQTTSubscription sub = findSubscriptionStrategy().getSubscription(md.getConsumerId());
1:cfc6917:             if (sub != null) {
1:0f5b406:                 MessageAck ack = sub.createMessageAck(md);
1:4c38438:                 PUBLISH publish = sub.createPublish((ActiveMQMessage) md.getMessage());
1:67f151f:                 switch (publish.qos()) {
1:67f151f:                     case AT_LEAST_ONCE:
1:67f151f:                     case EXACTLY_ONCE:
1:67f151f:                         publish.dup(publish.dup() ? true : md.getMessage().isRedelivered());
1:67f151f:                     case AT_MOST_ONCE:
1:67f151f:                 }
1:09c4500:                 if (ack != null && sub.expectAck(publish)) {
1:0f5b406:                     synchronized (consumerAcks) {
1:0f5b406:                         consumerAcks.put(publish.messageId(), ack);
1:67f151f:                     }
1:bc4f4e9:                 }
1:7ebc6ce:                 LOG.trace("MQTT Snd PUBLISH message:{} client:{} connection:{}",
1:7ebc6ce:                           publish.messageId(), clientId, connectionInfo.getConnectionId());
1:0f5b406:                 getMQTTTransport().sendToMQTT(publish.encode());
1:09c4500:                 if (ack != null && !sub.expectAck(publish)) {
1:4c38438:                     getMQTTTransport().sendToActiveMQ(ack);
1:bc4f4e9:                 }
1:bc4f4e9:             }
1:cfc6917:         } else if (command.getDataStructureType() == ConnectionError.DATA_STRUCTURE_TYPE) {
1:cfc6917:             // Pass down any unexpected async errors. Should this close the connection?
1:cfc6917:             Throwable exception = ((ConnectionError) command).getException();
1:cfc6917:             handleException(exception, null);
1:0f5b406:         } else if (command.isBrokerInfo()) {
1:0f5b406:             //ignore
1:bc4f4e9:         } else {
1:413e484:             LOG.debug("Do not know how to process ActiveMQ Command {}", command);
1:bc4f4e9:         }
1:bc4f4e9:     }
1:9735806: 
1:0f5b406:     void onMQTTPublish(PUBLISH command) throws IOException, JMSException {
1:0f5b406:         checkConnected();
1:7ebc6ce:         LOG.trace("MQTT Rcv PUBLISH message:{} client:{} connection:{}",
1:7ebc6ce:                   command.messageId(), clientId, connectionInfo.getConnectionId());
1:1b38b27:         //Both version 3.1 and 3.1.1 do not allow the topic name to contain a wildcard in the publish packet
1:1b38b27:         if (containsMqttWildcard(command.topicName().toString())) {
1:1b38b27:             // [MQTT-3.3.2-2]: The Topic Name in the PUBLISH Packet MUST NOT contain wildcard characters
1:1b38b27:             getMQTTTransport().onException(IOExceptionSupport.create("The topic name must not contain wildcard characters.", null));
1:1b38b27:             return;
1:1b38b27:         }
1:0f5b406:         ActiveMQMessage message = convertMessage(command);
1:4c38438:         message.setProducerId(producerId);
1:4c38438:         message.onSend();
1:0f5b406:         sendToActiveMQ(message, createResponseHandler(command));
1:9735806:     }
1:9735806: 
1:0f5b406:     void onMQTTPubAck(PUBACK command) {
1:0f5b406:         short messageId = command.messageId();
1:7ebc6ce:         LOG.trace("MQTT Rcv PUBACK message:{} client:{} connection:{}",
1:7ebc6ce:                   messageId, clientId, connectionInfo.getConnectionId());
1:afddc1a:         packetIdGenerator.ackPacketId(getClientId(), messageId);
1:4c38438:         MessageAck ack;
1:4c38438:         synchronized (consumerAcks) {
1:4c38438:             ack = consumerAcks.remove(messageId);
1:6683eb6:         }
1:4c38438:         if (ack != null) {
1:4c38438:             getMQTTTransport().sendToActiveMQ(ack);
1:6683eb6:         }
1:6683eb6:     }
1:9735806: 
1:4c38438:     void onMQTTPubRec(PUBREC commnand) {
1:4c38438:         //from a subscriber - send a PUBREL in response
1:4c38438:         PUBREL pubrel = new PUBREL();
1:4c38438:         pubrel.messageId(commnand.messageId());
1:4c38438:         sendToMQTT(pubrel.encode());
1:6683eb6:     }
1:9735806: 
1:4c38438:     void onMQTTPubRel(PUBREL command) {
1:4c38438:         PUBREC ack;
1:4c38438:         synchronized (publisherRecs) {
1:4c38438:             ack = publisherRecs.remove(command.messageId());
1:6683eb6:         }
1:4c38438:         if (ack == null) {
1:413e484:             LOG.warn("Unknown PUBREL: {} received", command.messageId());
1:d212d3c:         }
1:4c38438:         PUBCOMP pubcomp = new PUBCOMP();
1:4c38438:         pubcomp.messageId(command.messageId());
1:4c38438:         sendToMQTT(pubcomp.encode());
1:667237f:     }
1:bc4f4e9: 
1:4c38438:     void onMQTTPubComp(PUBCOMP command) {
1:4c38438:         short messageId = command.messageId();
1:afddc1a:         packetIdGenerator.ackPacketId(getClientId(), messageId);
1:4c38438:         MessageAck ack;
1:0f5b406:         synchronized (consumerAcks) {
1:0f5b406:             ack = consumerAcks.remove(messageId);
1:667237f:         }
2:0f5b406:         if (ack != null) {
1:0f5b406:             getMQTTTransport().sendToActiveMQ(ack);
1:4c38438:         }
1:4c38438:     }
1:bc4f4e9: 
1:0f5b406:     ActiveMQMessage convertMessage(PUBLISH command) throws JMSException {
1:cfc6917:         ActiveMQBytesMessage msg = new ActiveMQBytesMessage();
1:bc4f4e9: 
1:0f5b406:         msg.setProducerId(producerId);
1:67f151f:         MessageId id = new MessageId(producerId, publisherIdGenerator.getNextSequenceId());
1:0f5b406:         msg.setMessageId(id);
1:7ebc6ce:         LOG.trace("MQTT-->ActiveMQ: MQTT_MSGID:{} client:{} connection:{} ActiveMQ_MSGID:{}",
1:7ebc6ce:                 command.messageId(), clientId, connectionInfo.getConnectionId(), msg.getMessageId());
1:0f5b406:         msg.setTimestamp(System.currentTimeMillis());
1:0f5b406:         msg.setPriority((byte) Message.DEFAULT_PRIORITY);
1:919ca96:         msg.setPersistent(command.qos() != QoS.AT_MOST_ONCE);
1:0f5b406:         msg.setIntProperty(QOS_PROPERTY_NAME, command.qos().ordinal());
1:bcb60a4:         if (command.retain()) {
1:bcb60a4:             msg.setBooleanProperty(RetainedMessageSubscriptionRecoveryPolicy.RETAIN_PROPERTY, true);
1:bcb60a4:         }
1:bc4f4e9: 
1:413e484:         ActiveMQDestination destination;
1:413e484:         synchronized (activeMQDestinationMap) {
1:413e484:             destination = activeMQDestinationMap.get(command.topicName());
1:413e484:             if (destination == null) {
1:d8f9686:                 String topicName = MQTTProtocolSupport.convertMQTTToActiveMQ(command.topicName().toString());
1:413e484:                 try {
1:59f8cfc:                     destination = findSubscriptionStrategy().onSend(topicName);
1:413e484:                 } catch (IOException e) {
1:413e484:                     throw JMSExceptionSupport.create(e);
1:413e484:                 }
1:413e484: 
1:413e484:                 activeMQDestinationMap.put(command.topicName().toString(), destination);
1:4c38438:             }
1:4c38438:         }
1:413e484: 
1:413e484:         msg.setJMSDestination(destination);
1:cfc6917:         msg.writeBytes(command.payload().data, command.payload().offset, command.payload().length);
1:cfc6917:         return msg;
1:4c38438:     }
1:413e484: 
1:0f5b406:     public PUBLISH convertMessage(ActiveMQMessage message) throws IOException, JMSException, DataFormatException {
1:cfc6917:         PUBLISH result = new PUBLISH();
1:67f151f:         // packet id is set in MQTTSubscription
1:0f5b406:         QoS qoS;
1:0f5b406:         if (message.propertyExists(QOS_PROPERTY_NAME)) {
1:0f5b406:             int ordinal = message.getIntProperty(QOS_PROPERTY_NAME);
1:0f5b406:             qoS = QoS.values()[ordinal];
1:6683eb6: 
1:0f5b406:         } else {
1:0f5b406:             qoS = message.isPersistent() ? QoS.AT_MOST_ONCE : QoS.AT_LEAST_ONCE;
1:4c38438:         }
1:0f5b406:         result.qos(qoS);
1:bcb60a4:         if (message.getBooleanProperty(RetainedMessageSubscriptionRecoveryPolicy.RETAINED_PROPERTY)) {
1:bcb60a4:             result.retain(true);
1:bcb60a4:         }
1:d212d3c: 
1:2cd5424:         String topicName;
1:cfc6917:         synchronized (mqttTopicMap) {
1:a0a23b9:             ActiveMQDestination destination = message.getDestination();
1:a0a23b9:             if (destination.isPattern() && message.getOriginalDestination() != null) {
1:a0a23b9:                 destination = message.getOriginalDestination();
1:a0a23b9:             }
1:a0a23b9:             topicName = mqttTopicMap.get(destination);
1:cfc6917:             if (topicName == null) {
1:a0a23b9:                 String amqTopicName = findSubscriptionStrategy().onSend(destination);
1:413e484:                 topicName = MQTTProtocolSupport.convertActiveMQToMQTT(amqTopicName);
1:a0a23b9:                 mqttTopicMap.put(destination, topicName);
1:4c38438:             }
1:4c38438:         }
1:2cd5424:         result.topicName(new UTF8Buffer(topicName));
1:667237f: 
1:0f5b406:         if (message.getDataStructureType() == ActiveMQTextMessage.DATA_STRUCTURE_TYPE) {
1:cfc6917:             ActiveMQTextMessage msg = (ActiveMQTextMessage) message.copy();
1:1e3ea5c:             msg.setReadOnlyBody(true);
1:cfc6917:             String messageText = msg.getText();
1:cfc6917:             if (messageText != null) {
1:1e3ea5c:                 result.payload(new Buffer(messageText.getBytes("UTF-8")));
1:1e3ea5c:             }
1:cfc6917:         } else if (message.getDataStructureType() == ActiveMQBytesMessage.DATA_STRUCTURE_TYPE) {
1:cfc6917:             ActiveMQBytesMessage msg = (ActiveMQBytesMessage) message.copy();
1:cfc6917:             msg.setReadOnlyBody(true);
1:cfc6917:             byte[] data = new byte[(int) msg.getBodyLength()];
1:cfc6917:             msg.readBytes(data);
1:cfc6917:             result.payload(new Buffer(data));
1:2ad13d6:         } else if (message.getDataStructureType() == ActiveMQMapMessage.DATA_STRUCTURE_TYPE) {
1:1e3ea5c:             ActiveMQMapMessage msg = (ActiveMQMapMessage) message.copy();
1:1e3ea5c:             msg.setReadOnlyBody(true);
1:2ad13d6:             Map<String, Object> map = msg.getContentMap();
1:2ad13d6:             if (map != null) {
1:1e3ea5c:                 result.payload(new Buffer(map.toString().getBytes("UTF-8")));
1:1e3ea5c:             }
1:0f5b406:         } else {
1:1e3ea5c:             ByteSequence byteSequence = message.getContent();
1:0f5b406:             if (byteSequence != null && byteSequence.getLength() > 0) {
1:0f5b406:                 if (message.isCompressed()) {
1:1e3ea5c:                     Inflater inflater = new Inflater();
1:0f5b406:                     inflater.setInput(byteSequence.data, byteSequence.offset, byteSequence.length);
1:0f5b406:                     byte[] data = new byte[4096];
1:1e3ea5c:                     int read;
1:1e3ea5c:                     ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
1:2ad13d6:                     while ((read = inflater.inflate(data)) != 0) {
1:0f5b406:                         bytesOut.write(data, 0, read);
1:1e3ea5c:                     }
1:1e3ea5c:                     byteSequence = bytesOut.toByteSequence();
1:7b5f956:                     bytesOut.close();
1:1e3ea5c:                 }
1:0f5b406:                 result.payload(new Buffer(byteSequence.data, byteSequence.offset, byteSequence.length));
1:4c38438:             }
1:4c38438:         }
1:7ebc6ce:         LOG.trace("ActiveMQ-->MQTT:MQTT_MSGID:{} client:{} connection:{} ActiveMQ_MSGID:{}",
1:7ebc6ce:                 result.messageId(), clientId, connectionInfo.getConnectionId(), message.getMessageId());
1:0f5b406:         return result;
1:a581d01:     }
1:a581d01: 
1:cfc6917:     public MQTTTransport getMQTTTransport() {
1:cfc6917:         return mqttTransport;
1:4c38438:     }
1:d212d3c: 
1:9735806:     boolean willSent = false;
1:4c38438:     public void onTransportError() {
1:4c38438:         if (connect != null) {
1:bf8eb0e:             if (connected.get()) {
1:bf8eb0e:                 if (connect.willTopic() != null && connect.willMessage() != null && !willSent) {
1:bf8eb0e:                     willSent = true;
1:bf8eb0e:                     try {
1:bf8eb0e:                         PUBLISH publish = new PUBLISH();
1:bf8eb0e:                         publish.topicName(connect.willTopic());
1:bf8eb0e:                         publish.qos(connect.willQos());
1:afddc1a:                         publish.messageId(packetIdGenerator.getNextSequenceId(getClientId()));
1:bf8eb0e:                         publish.payload(connect.willMessage());
1:9bc2821:                         publish.retain(connect.willRetain());
1:bf8eb0e:                         ActiveMQMessage message = convertMessage(publish);
1:bf8eb0e:                         message.setProducerId(producerId);
1:bf8eb0e:                         message.onSend();
1:9735806: 
1:bf8eb0e:                         sendToActiveMQ(message, null);
1:bf8eb0e:                     } catch (Exception e) {
1:bf8eb0e:                         LOG.warn("Failed to publish Will Message " + connect.willMessage());
1:bf8eb0e:                     }
1:88c6ee9:                 }
1:bf8eb0e:                 // remove connection info
1:bf8eb0e:                 sendToActiveMQ(connectionInfo.createRemoveCommand(), null);
1:4c38438:             }
1:4c38438:         }
1:0f5b406:     }
1:1e3ea5c: 
1:d212d3c:     void configureInactivityMonitor(short keepAliveSeconds) {
1:d212d3c:         MQTTInactivityMonitor monitor = getMQTTTransport().getInactivityMonitor();
1:d212d3c: 
1:d212d3c:         // If the user specifically shuts off the InactivityMonitor with transport.useInactivityMonitor=false,
1:d212d3c:         // then ignore configuring it because it won't exist
1:d212d3c:         if (monitor == null) {
1:7068302:             return;
1:d212d3c:         }
1:d212d3c: 
1:4b7131f:         // Client has sent a valid CONNECT frame, we can stop the connect checker.
1:4b7131f:         monitor.stopConnectChecker();
1:4b7131f: 
1:d212d3c:         long keepAliveMS = keepAliveSeconds * 1000;
1:d212d3c: 
1:413e484:         LOG.debug("MQTT Client {} requests heart beat of {} ms", getClientId(), keepAliveMS);
1:d212d3c: 
1:b679787:         try {
1:d212d3c:             // if we have a default keep-alive value, and the client is trying to turn off keep-alive,
1:6e68a37: 
1:d212d3c:             // we'll observe the server-side configured default value (note, no grace period)
1:6e68a37:             if (keepAliveMS == 0 && defaultKeepAlive > 0) {
1:6e68a37:                 keepAliveMS = defaultKeepAlive;
1:d212d3c:             }
1:d212d3c: 
1:6e68a37:             long readGracePeriod = (long) (keepAliveMS * MQTT_KEEP_ALIVE_GRACE_PERIOD);
1:6e68a37: 
1:4c38438:             monitor.setProtocolConverter(this);
1:6e68a37:             monitor.setReadKeepAliveTime(keepAliveMS);
1:6e68a37:             monitor.setReadGraceTime(readGracePeriod);
1:4b7131f:             monitor.startReadChecker();
1:d212d3c: 
1:413e484:             LOG.debug("MQTT Client {} established heart beat of  {} ms ({} ms + {} ms grace period)",
1:413e484:                       new Object[] { getClientId(), keepAliveMS, keepAliveMS, readGracePeriod });
1:cfc6917:         } catch (Exception ex) {
1:0f5b406:             LOG.warn("Failed to start MQTT InactivityMonitor ", ex);
1:d212d3c:         }
1:d212d3c:     }
1:d212d3c: 
1:0f5b406:     void handleException(Throwable exception, MQTTFrame command) {
1:cfc6917:         LOG.warn("Exception occurred processing: \n" + command + ": " + exception.toString());
1:413e484:         LOG.debug("Exception detail", exception);
1:d212d3c: 
1:bf8eb0e:         if (connected.get() && connectionInfo != null) {
1:bf8eb0e:             connected.set(false);
1:bf8eb0e:             sendToActiveMQ(connectionInfo.createRemoveCommand(), null);
1:0f5b406:         }
1:bf8eb0e:         stopTransport();
1:0f5b406:     }
1:d212d3c: 
1:0f5b406:     void checkConnected() throws MQTTProtocolException {
1:0f5b406:         if (!connected.get()) {
1:0f5b406:             throw new MQTTProtocolException("Not connected.");
1:0f5b406:         }
1:0f5b406:     }
1:d212d3c: 
1:cfc6917:     private void stopTransport() {
1:88c6ee9:         try {
2:cfc6917:             getMQTTTransport().stop();
1:e2a7d6a:         } catch (Throwable e) {
1:cfc6917:             LOG.debug("Failed to stop MQTT transport ", e);
1:0f5b406:         }
10:0f5b406:     }
1:1e3ea5c: 
1:0f5b406:     ResponseHandler createResponseHandler(final PUBLISH command) {
1:0f5b406:         if (command != null) {
1:789eb9a:             return new ResponseHandler() {
1:789eb9a:                 @Override
1:789eb9a:                 public void onResponse(MQTTProtocolConverter converter, Response response) throws IOException {
1:789eb9a:                     if (response.isException()) {
1:789eb9a:                         Throwable error = ((ExceptionResponse) response).getException();
1:789eb9a:                         LOG.warn("Failed to send MQTT Publish: ", command, error.getMessage());
1:789eb9a:                         LOG.trace("Error trace: {}", error);
1:789eb9a:                     }
1:789eb9a: 
1:789eb9a:                     switch (command.qos()) {
1:67f151f:                         case AT_LEAST_ONCE:
1:789eb9a:                             PUBACK ack = new PUBACK();
1:789eb9a:                             ack.messageId(command.messageId());
1:789eb9a:                             LOG.trace("MQTT Snd PUBACK message:{} client:{} connection:{}",
1:789eb9a:                                       command.messageId(), clientId, connectionInfo.getConnectionId());
1:789eb9a:                             converter.getMQTTTransport().sendToMQTT(ack.encode());
1:789eb9a:                             break;
1:67f151f:                         case EXACTLY_ONCE:
1:789eb9a:                             PUBREC req = new PUBREC();
1:789eb9a:                             req.messageId(command.messageId());
1:789eb9a:                             synchronized (publisherRecs) {
1:789eb9a:                                 publisherRecs.put(command.messageId(), req);
1:0f5b406:                             }
1:789eb9a:                             LOG.trace("MQTT Snd PUBREC message:{} client:{} connection:{}",
1:789eb9a:                                       command.messageId(), clientId, connectionInfo.getConnectionId());
1:789eb9a:                             converter.getMQTTTransport().sendToMQTT(req.encode());
1:789eb9a:                             break;
1:789eb9a:                         default:
1:789eb9a:                             break;
1:789eb9a:                     }
1:789eb9a:                 }
1:789eb9a:             };
1:0f5b406:         }
1:0f5b406:         return null;
1:0f5b406:     }
1:4c38438: 
1:d212d3c:     public long getDefaultKeepAlive() {
1:d212d3c:         return defaultKeepAlive;
1:d212d3c:     }
1:d212d3c: 
1:d212d3c:     /**
1:d212d3c:      * Set the default keep alive time (in milliseconds) that would be used if configured on server side
1:d212d3c:      * and the client sends a keep-alive value of 0 (zero) on a CONNECT frame
1:09c4500:      * @param keepAlive the keepAlive in milliseconds
1:d212d3c:      */
1:09c4500:     public void setDefaultKeepAlive(long keepAlive) {
1:09c4500:         this.defaultKeepAlive = keepAlive;
1:d212d3c:     }
1:667237f: 
1:667237f:     public int getActiveMQSubscriptionPrefetch() {
1:667237f:         return activeMQSubscriptionPrefetch;
1:667237f:     }
1:667237f: 
1:667237f:     /**
1:667237f:      * set the default prefetch size when mapping the MQTT subscription to an ActiveMQ one
1:667237f:      * The default = 1
1:2cd5424:      *
1:2cd5424:      * @param activeMQSubscriptionPrefetch
1:2cd5424:      *        set the prefetch for the corresponding ActiveMQ subscription
1:667237f:      */
1:667237f:     public void setActiveMQSubscriptionPrefetch(int activeMQSubscriptionPrefetch) {
1:667237f:         this.activeMQSubscriptionPrefetch = activeMQSubscriptionPrefetch;
1:67f151f:     }
1:67f151f: 
1:afddc1a:     public MQTTPacketIdGenerator getPacketIdGenerator() {
1:afddc1a:         return packetIdGenerator;
1:67f151f:     }
1:67f151f: 
1:73908d6:     public void setPublishDollarTopics(boolean publishDollarTopics) {
1:73908d6:         this.publishDollarTopics = publishDollarTopics;
1:67f151f:     }
1:67f151f: 
1:73908d6:     public boolean getPublishDollarTopics() {
1:73908d6:         return publishDollarTopics;
1:67f151f:     }
1:d8f9686: 
1:d8f9686:     public ConnectionId getConnectionId() {
1:d8f9686:         return connectionId;
1:67f151f:     }
1:413e484: 
1:ec049a0:     public SessionId getSessionId() {
1:ec049a0:         return sessionId;
1:67f151f:     }
1:d8f9686: 
1:413e484:     public boolean isCleanSession() {
1:413e484:         return this.connect.cleanSession();
1:67f151f:     }
1:413e484: 
1:59f8cfc:     public String getSubscriptionStrategy() {
1:413e484:         return subscriptionStrategyName;
1:413e484:     }
1:413e484: 
1:59f8cfc:     public void setSubscriptionStrategy(String name) {
1:413e484:         this.subscriptionStrategyName = name;
1:413e484:     }
1:413e484: 
1:d8f9686:     public String getClientId() {
1:d8f9686:         if (clientId == null) {
1:d8f9686:             if (connect != null && connect.clientId() != null) {
1:d8f9686:                 clientId = connect.clientId().toString();
1:67f151f:             } else {
1:d8f9686:                 clientId = "";
1:d8f9686:             }
1:d8f9686:         }
1:d8f9686:         return clientId;
1:d8f9686:     }
1:413e484: 
1:1b38b27:     protected boolean containsMqttWildcard(String value) {
1:1b38b27:         return value != null && (value.contains(SINGLE_LEVEL_WILDCARD) ||
1:1b38b27:                 value.contains(MULTI_LEVEL_WILDCARD));
1:1b38b27:     }
1:1b38b27: 
1:59f8cfc:     protected MQTTSubscriptionStrategy findSubscriptionStrategy() throws IOException {
1:413e484:         if (subsciptionStrategy == null) {
1:413e484:             synchronized (STRATAGY_FINDER) {
1:413e484:                 if (subsciptionStrategy != null) {
1:413e484:                     return subsciptionStrategy;
1:413e484:                 }
1:413e484: 
1:413e484:                 MQTTSubscriptionStrategy strategy = null;
1:413e484:                 if (subscriptionStrategyName != null && !subscriptionStrategyName.isEmpty()) {
1:413e484:                     try {
1:413e484:                         strategy = (MQTTSubscriptionStrategy) STRATAGY_FINDER.newInstance(subscriptionStrategyName);
1:413e484:                         LOG.debug("MQTT Using subscription strategy: {}", subscriptionStrategyName);
1:413e484:                         if (strategy instanceof BrokerServiceAware) {
1:413e484:                             ((BrokerServiceAware)strategy).setBrokerService(brokerService);
1:413e484:                         }
1:413e484:                         strategy.initialize(this);
1:413e484:                     } catch (Exception e) {
1:413e484:                         throw IOExceptionSupport.create(e);
1:413e484:                     }
1:413e484:                 } else {
1:413e484:                     throw new IOException("Invalid subscription strategy name given: " + subscriptionStrategyName);
1:413e484:                 }
1:413e484: 
1:413e484:                 this.subsciptionStrategy = strategy;
1:413e484:             }
1:413e484:         }
1:413e484:         return subsciptionStrategy;
1:413e484:     }
1:73908d6: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:919ca96
/////////////////////////////////////////////////////////////////////////
1:         msg.setPersistent(command.qos() != QoS.AT_MOST_ONCE);
commit:bf8eb0e
/////////////////////////////////////////////////////////////////////////
0:         // create durable subscriptions only when cleansession is false
0:         if ( !connect.cleanSession() && connect.clientId() != null && topic.qos().ordinal() >= QoS.AT_LEAST_ONCE.ordinal() ) {
/////////////////////////////////////////////////////////////////////////
0:                     LOG.warn("Error subscribing to " + topic.name(), throwable);
/////////////////////////////////////////////////////////////////////////
1:             if (connected.get()) {
1:                 if (connect.willTopic() != null && connect.willMessage() != null && !willSent) {
1:                     willSent = true;
1:                     try {
1:                         PUBLISH publish = new PUBLISH();
1:                         publish.topicName(connect.willTopic());
1:                         publish.qos(connect.willQos());
0:                         publish.messageId(getNextSequenceId());
1:                         publish.payload(connect.willMessage());
1:                         ActiveMQMessage message = convertMessage(publish);
1:                         message.setProducerId(producerId);
1:                         message.onSend();
1:                         sendToActiveMQ(message, null);
1:                     } catch (Exception e) {
1:                         LOG.warn("Failed to publish Will Message " + connect.willMessage());
1:                     }
1:                 // remove connection info
1:                 sendToActiveMQ(connectionInfo.createRemoveCommand(), null);
/////////////////////////////////////////////////////////////////////////
1:         if (connected.get() && connectionInfo != null) {
1:             connected.set(false);
1:             sendToActiveMQ(connectionInfo.createRemoveCommand(), null);
1:         stopTransport();
commit:67f151f
/////////////////////////////////////////////////////////////////////////
1:     private final LongSequenceGenerator publisherIdGenerator = new LongSequenceGenerator();
/////////////////////////////////////////////////////////////////////////
0:     private final Map<String, Short> activemqToPacketIds = new LRUCache<String, Short>(DEFAULT_CACHE_SIZE);
0:     private final Map<Short, String> packetIdsToActivemq = new LRUCache<Short, String>(DEFAULT_CACHE_SIZE);
1: 
/////////////////////////////////////////////////////////////////////////
0:                             switch (retainedCopy.qos()) {
1:                                 case AT_LEAST_ONCE:
1:                                 case EXACTLY_ONCE:
0:                                     retainedCopy.messageId(getNextSequenceId());
1:                                 case AT_MOST_ONCE:
1:                             }
/////////////////////////////////////////////////////////////////////////
1:                 switch (publish.qos()) {
1:                     case AT_LEAST_ONCE:
1:                     case EXACTLY_ONCE:
1:                         publish.dup(publish.dup() ? true : md.getMessage().isRedelivered());
0:                     case AT_MOST_ONCE:
1:                 }
/////////////////////////////////////////////////////////////////////////
0:         ackPacketId(messageId);
/////////////////////////////////////////////////////////////////////////
0:         ackPacketId(messageId);
/////////////////////////////////////////////////////////////////////////
1:         MessageId id = new MessageId(producerId, publisherIdGenerator.getNextSequenceId());
/////////////////////////////////////////////////////////////////////////
1:         // packet id is set in MQTTSubscription
/////////////////////////////////////////////////////////////////////////
0:                     publish.messageId(getNextSequenceId());
/////////////////////////////////////////////////////////////////////////
1: 
0:     short setPacketId(MQTTSubscription subscription, ActiveMQMessage message, PUBLISH publish) {
0:         // subscription key
0:         final StringBuilder subscriptionKey = new StringBuilder();
0:         subscriptionKey.append(subscription.getConsumerInfo().getDestination().getPhysicalName())
0:             .append(':').append(message.getJMSMessageID());
0:         final String keyStr = subscriptionKey.toString();
0:         Short packetId;
0:         synchronized (activemqToPacketIds) {
0:             packetId = activemqToPacketIds.get(keyStr);
0:             if (packetId == null) {
0:                 packetId = getNextSequenceId();
0:                 activemqToPacketIds.put(keyStr, packetId);
0:                 packetIdsToActivemq.put(packetId, keyStr);
1:             } else {
0:                 // mark publish as duplicate!
0:                 publish.dup(true);
1:             }
1:         }
0:         publish.messageId(packetId);
0:         return packetId;
1:     }
1: 
0:     void ackPacketId(short packetId) {
0:         synchronized (activemqToPacketIds) {
0:             final String subscriptionKey = packetIdsToActivemq.remove(packetId);
0:             if (subscriptionKey != null) {
0:                 activemqToPacketIds.remove(subscriptionKey);
1:             }
1:         }
1:     }
1: 
0:     short getNextSequenceId() {
0:         return (short) messageIdGenerator.getNextSequenceId();
1:     }
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:a0a23b9
/////////////////////////////////////////////////////////////////////////
1:     private final Map<ActiveMQDestination, String> mqttTopicMap = new LRUCache<ActiveMQDestination, String>(DEFAULT_CACHE_SIZE);
/////////////////////////////////////////////////////////////////////////
1:             ActiveMQDestination destination = message.getDestination();
1:             if (destination.isPattern() && message.getOriginalDestination() != null) {
1:                 destination = message.getOriginalDestination();
1:             }
1:             topicName = mqttTopicMap.get(destination);
1:                 String amqTopicName = findSubscriptionStrategy().onSend(destination);
1:                 mqttTopicMap.put(destination, topicName);
commit:9bc2821
/////////////////////////////////////////////////////////////////////////
1:                         publish.retain(connect.willRetain());
commit:b83c38b
/////////////////////////////////////////////////////////////////////////
1:         if (command.qos() != QoS.AT_LEAST_ONCE && (version != V3_1 || publishDollarTopics != true)) {
1:             throw new MQTTProtocolException("Failed to process unsubscribe request", true, new Exception("UNSUBSCRIBE frame not properly formatted, QoS"));
1:         }
commit:a4fbe70
/////////////////////////////////////////////////////////////////////////
1:     public static final int V3_1 = 3;
1:     public static final int V3_1_1 = 4;
/////////////////////////////////////////////////////////////////////////
1:     public int version;
1: 
/////////////////////////////////////////////////////////////////////////
1:         version = connect.version();
1: 
commit:d547025
/////////////////////////////////////////////////////////////////////////
1:     private int activeMQSubscriptionPrefetch = -1;
commit:fc3d90e
/////////////////////////////////////////////////////////////////////////
commit:4ba4aa2
/////////////////////////////////////////////////////////////////////////
1:         getMQTTTransport().sendToActiveMQ(command);
/////////////////////////////////////////////////////////////////////////
1:                 sendToMQTT(PING_RESP_FRAME);
commit:ac23b01
/////////////////////////////////////////////////////////////////////////
0:     private static final byte SUBSCRIBE_ERROR = (byte) 0x80;
/////////////////////////////////////////////////////////////////////////
0:                 qos[i] = onSubscribe(topics[i]);
/////////////////////////////////////////////////////////////////////////
0:                 if (qos[i] == SUBSCRIBE_ERROR) {
0:                     // skip this topic if subscribe failed
0:                     continue;
1:                 }
/////////////////////////////////////////////////////////////////////////
0:     byte onSubscribe(final Topic topic) throws MQTTProtocolException {
/////////////////////////////////////////////////////////////////////////
0:                 return (byte) topic.qos().ordinal();
/////////////////////////////////////////////////////////////////////////
0:         final byte[] qos = {-1};
0:         sendToActiveMQ(consumerInfo, new ResponseHandler() {
1:             @Override
1:             public void onResponse(MQTTProtocolConverter converter, Response response) throws IOException {
0:                 // validate subscription request
1:                 if (response.isException()) {
0:                     final Throwable throwable = ((ExceptionResponse) response).getException();
0:                     LOG.debug("Error subscribing to " + topic.name(), throwable);
0:                     qos[0] = SUBSCRIBE_ERROR;
1:                 } else {
0:                     qos[0] = (byte) topic.qos().ordinal();
1:                 }
1:             }
1:         });
0:         if (qos[0] != SUBSCRIBE_ERROR) {
0:             subscriptionsByConsumerId.put(id, mqttSubscription);
0:             mqttSubscriptionByTopic.put(topic.name(), mqttSubscription);
1:         }
1: 
0:         return qos[0];
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:6dacef1
/////////////////////////////////////////////////////////////////////////
1:                 checkConnected();
commit:bd442a3
/////////////////////////////////////////////////////////////////////////
1:         if (connected.compareAndSet(true, false)) {
commit:1b38b27
/////////////////////////////////////////////////////////////////////////
1:     public static final String SINGLE_LEVEL_WILDCARD = "+";
1:     public static final String MULTI_LEVEL_WILDCARD = "#";
1: 
/////////////////////////////////////////////////////////////////////////
1:         //Both version 3.1 and 3.1.1 do not allow the topic name to contain a wildcard in the publish packet
1:         if (containsMqttWildcard(command.topicName().toString())) {
1:             // [MQTT-3.3.2-2]: The Topic Name in the PUBLISH Packet MUST NOT contain wildcard characters
1:             getMQTTTransport().onException(IOExceptionSupport.create("The topic name must not contain wildcard characters.", null));
1:             return;
1:         }
/////////////////////////////////////////////////////////////////////////
1:     protected boolean containsMqttWildcard(String value) {
1:         return value != null && (value.contains(SINGLE_LEVEL_WILDCARD) ||
1:                 value.contains(MULTI_LEVEL_WILDCARD));
1:     }
1: 
commit:457dbd8
/////////////////////////////////////////////////////////////////////////
1:                             LOG.warn("Failed to send command " + command, e);
1:                 LOG.warn("Failed to send command " + command, e);
author:Timothy Bish
-------------------------------------------------------------------------------
commit:f3544f2
/////////////////////////////////////////////////////////////////////////
1:         // The Server MUST respond to the CONNECT Packet with a CONNACK return code 0x01
1:         // (unacceptable protocol level) and then disconnect the Client if the Protocol Level
1:         // is not supported by the Server [MQTT-3.1.2-2].
1:         if (connect.version() < 3 || connect.version() > 4) {
1:             CONNACK ack = new CONNACK();
1:             ack.code(CONNACK.Code.CONNECTION_REFUSED_UNACCEPTED_PROTOCOL_VERSION);
1:             try {
1:                 getMQTTTransport().sendToMQTT(ack.encode());
1:                 getMQTTTransport().onException(IOExceptionSupport.create("Unsupported or invalid protocol version", null));
1:             } catch (IOException e) {
1:                 getMQTTTransport().onException(IOExceptionSupport.create(e));
1:             }
1:             return;
1:         }
1: 
commit:5d6d42c
/////////////////////////////////////////////////////////////////////////
1:                 MQTTProtocolSupport.validate(topics[i].name().toString());
/////////////////////////////////////////////////////////////////////////
1:             throw new MQTTProtocolException("SUBSCRIBE command received with no topic filter");
/////////////////////////////////////////////////////////////////////////
1:                 MQTTProtocolSupport.validate(topic.toString());
1:             UNSUBACK ack = new UNSUBACK();
1:             ack.messageId(command.messageId());
1:             sendToMQTT(ack.encode());
1:         } else {
1:             LOG.warn("No topics defined for Subscription " + command);
1:             throw new MQTTProtocolException("UNSUBSCRIBE command received with no topic filter");
commit:c530b69
/////////////////////////////////////////////////////////////////////////
1: 
1:             if (userName == null && connect.version() != V3_1) {
1:                 // [MQTT-3.1.2-22]: If the user name is not present then the
1:                 // password must also be absent.
1:                 // [MQTT-3.1.4-1]: would seem to imply we don't send a CONNACK here.
1:                 getMQTTTransport().onException(IOExceptionSupport.create("Password given without a user name", null));
1:                 return;
1:             }
1: 
commit:789eb9a
/////////////////////////////////////////////////////////////////////////
1:             return new ResponseHandler() {
1:                 @Override
1:                 public void onResponse(MQTTProtocolConverter converter, Response response) throws IOException {
1:                     if (response.isException()) {
1:                         Throwable error = ((ExceptionResponse) response).getException();
1:                         LOG.warn("Failed to send MQTT Publish: ", command, error.getMessage());
1:                         LOG.trace("Error trace: {}", error);
1:                     }
1: 
1:                     switch (command.qos()) {
0:                         case AT_LEAST_ONCE:
1:                             PUBACK ack = new PUBACK();
1:                             ack.messageId(command.messageId());
1:                             LOG.trace("MQTT Snd PUBACK message:{} client:{} connection:{}",
1:                                       command.messageId(), clientId, connectionInfo.getConnectionId());
1:                             converter.getMQTTTransport().sendToMQTT(ack.encode());
1:                             break;
0:                         case EXACTLY_ONCE:
1:                             PUBREC req = new PUBREC();
1:                             req.messageId(command.messageId());
1:                             synchronized (publisherRecs) {
1:                                 publisherRecs.put(command.messageId(), req);
1:                             LOG.trace("MQTT Snd PUBREC message:{} client:{} connection:{}",
1:                                       command.messageId(), clientId, connectionInfo.getConnectionId());
1:                             converter.getMQTTTransport().sendToMQTT(req.encode());
1:                             break;
1:                         default:
1:                             break;
1:                     }
1:                 }
1:             };
commit:9ef4259
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentMap;
/////////////////////////////////////////////////////////////////////////
1:     private final ConcurrentMap<Integer, ResponseHandler> resposeHandlers = new ConcurrentHashMap<Integer, ResponseHandler>();
commit:7ebc6ce
/////////////////////////////////////////////////////////////////////////
1:         LOG.trace("MQTT SUBSCRIBE message:{} client:{} connection:{}",
1:                   command.messageId(), clientId, connectionInfo.getConnectionId());
/////////////////////////////////////////////////////////////////////////
1:                 LOG.trace("MQTT Snd PUBLISH message:{} client:{} connection:{}",
1:                           publish.messageId(), clientId, connectionInfo.getConnectionId());
/////////////////////////////////////////////////////////////////////////
1:         LOG.trace("MQTT Rcv PUBLISH message:{} client:{} connection:{}",
1:                   command.messageId(), clientId, connectionInfo.getConnectionId());
/////////////////////////////////////////////////////////////////////////
1:         LOG.trace("MQTT Rcv PUBACK message:{} client:{} connection:{}",
1:                   messageId, clientId, connectionInfo.getConnectionId());
/////////////////////////////////////////////////////////////////////////
1:         LOG.trace("MQTT-->ActiveMQ: MQTT_MSGID:{} client:{} connection:{} ActiveMQ_MSGID:{}",
1:                 command.messageId(), clientId, connectionInfo.getConnectionId(), msg.getMessageId());
/////////////////////////////////////////////////////////////////////////
1:         LOG.trace("ActiveMQ-->MQTT:MQTT_MSGID:{} client:{} connection:{} ActiveMQ_MSGID:{}",
1:                 result.messageId(), clientId, connectionInfo.getConnectionId(), message.getMessageId());
/////////////////////////////////////////////////////////////////////////
0:                                 LOG.trace("MQTT Snd PUBACK message:{} client:{} connection:{}",
0:                                           command.messageId(), clientId, connectionInfo.getConnectionId());
/////////////////////////////////////////////////////////////////////////
0:                                 LOG.trace("MQTT Snd PUBACK message:{} client:{} connection:{}",
0:                                           command.messageId(), clientId, connectionInfo.getConnectionId());
commit:4b7131f
/////////////////////////////////////////////////////////////////////////
1:         // Client has sent a valid CONNECT frame, we can stop the connect checker.
1:         monitor.stopConnectChecker();
1: 
/////////////////////////////////////////////////////////////////////////
1:             monitor.startReadChecker();
commit:eaed019
/////////////////////////////////////////////////////////////////////////
1:     public static final String QOS_PROPERTY_NAME = "ActiveMQ.MQTT.QoS";
1: 
/////////////////////////////////////////////////////////////////////////
commit:59f8cfc
/////////////////////////////////////////////////////////////////////////
1:     private static final double MQTT_KEEP_ALIVE_GRACE_PERIOD = 0.5;
/////////////////////////////////////////////////////////////////////////
0:     private static final String QOS_PROPERTY_NAME = "ActiveMQ.MQTT.QoS";
1: 
/////////////////////////////////////////////////////////////////////////
1:                 if (!getPublishDollarTopics() && findSubscriptionStrategy().isControlTopic(msg.getDestination())) {
/////////////////////////////////////////////////////////////////////////
1:                         findSubscriptionStrategy().onConnect(connect);
/////////////////////////////////////////////////////////////////////////
1:                     qos[i] = findSubscriptionStrategy().onSubscribe(topics[i]);
/////////////////////////////////////////////////////////////////////////
1:                     findSubscriptionStrategy().onUnSubscribe(topic.toString());
/////////////////////////////////////////////////////////////////////////
1:             MQTTSubscription sub = findSubscriptionStrategy().getSubscription(md.getConsumerId());
/////////////////////////////////////////////////////////////////////////
1:                     destination = findSubscriptionStrategy().onSend(topicName);
/////////////////////////////////////////////////////////////////////////
0:                 String amqTopicName = findSubscriptionStrategy().onSend(message.getDestination());
/////////////////////////////////////////////////////////////////////////
1:     public String getSubscriptionStrategy() {
1:     public void setSubscriptionStrategy(String name) {
/////////////////////////////////////////////////////////////////////////
1:     protected MQTTSubscriptionStrategy findSubscriptionStrategy() throws IOException {
commit:ec049a0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private int activeMQSubscriptionPrefetch = 1;
/////////////////////////////////////////////////////////////////////////
1:                 try {
0:                     qos[i] = getSubscriptionStrategy().onSubscribe(topics[i]);
1:                 } catch (IOException e) {
1:                     throw new MQTTProtocolException("Failed to process subscription request", true, e);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                 try {
0:                     getSubscriptionStrategy().onUnSubscribe(topic.toString());
1:                 } catch (IOException e) {
1:                     throw new MQTTProtocolException("Failed to process unsubscribe request", true, e);
1:                 }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             MQTTSubscription sub = getSubscriptionStrategy().getSubscription(md.getConsumerId());
/////////////////////////////////////////////////////////////////////////
1:     public SessionId getSessionId() {
1:         return sessionId;
commit:413e484
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.BrokerServiceAware;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.mqtt.strategy.MQTTSubscriptionStrategy;
1: import org.apache.activemq.util.FactoryFinder;
1: import org.apache.activemq.util.JMSExceptionSupport;
/////////////////////////////////////////////////////////////////////////
1:     private final Map<String, ActiveMQDestination> activeMQDestinationMap = new LRUCache<String, ActiveMQDestination>(DEFAULT_CACHE_SIZE);
/////////////////////////////////////////////////////////////////////////
1:     private final FactoryFinder STRATAGY_FINDER = new FactoryFinder("META-INF/services/org/apache/activemq/transport/strategies/");
1:     /*
1:      * Subscription strategy configuration element.
1:      *   > mqtt-default-subscriptions
1:      *   > mqtt-virtual-topic-subscriptions
1:      */
1:     private String subscriptionStrategyName = "mqtt-default-subscriptions";
1:     private MQTTSubscriptionStrategy subsciptionStrategy;
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void sendToActiveMQ(Command command, ResponseHandler handler) {
1:             try {
0:                 if (!getPublishDollarTopics() && getSubscriptionStrategy().isControlTopic(msg.getDestination())) {
1:                     // We don't allow users to send to $ prefixed topics to avoid failing MQTT 3.1.1
1:                     // specification requirements for system assigned destinations.
1:                     if (handler != null) {
1:                         try {
1:                             handler.onResponse(this, new Response());
1:                         } catch (IOException e) {
0:                             e.printStackTrace();
1:                         }
1:                     return;
1:             } catch (IOException e) {
0:                 e.printStackTrace();
/////////////////////////////////////////////////////////////////////////
1:             case PINGREQ.TYPE:
1:             case CONNECT.TYPE:
1:             case DISCONNECT.TYPE:
1:             case SUBSCRIBE.TYPE:
1:             case UNSUBSCRIBE.TYPE:
1:             case PUBLISH.TYPE:
1:             case PUBACK.TYPE:
1:             case PUBREC.TYPE:
1:             case PUBREL.TYPE:
1:             case PUBCOMP.TYPE:
1:             default:
/////////////////////////////////////////////////////////////////////////
1: 
0:                         getSubscriptionStrategy().onConnect(connect);
/////////////////////////////////////////////////////////////////////////
0:     public byte onSubscribe(final Topic topic) throws MQTTProtocolException {
0:         final String destinationName = topic.name().toString();
0:         final QoS requestedQoS = topic.qos();
0:         if (mqttSubscriptionByTopic.containsKey(destinationName)) {
0:             final MQTTSubscription mqttSubscription = mqttSubscriptionByTopic.get(destinationName);
0:             if (requestedQoS != mqttSubscription.getQoS()) {
0:                 onUnSubscribe(destinationName);
1:                 try {
0:                     getSubscriptionStrategy().onReSubscribe(mqttSubscription);
1:                 } catch (IOException e) {
0:                     throw new MQTTProtocolException("Failed to find subscription strategy", true, e);
1:                 }
0:                 return (byte) requestedQoS.ordinal();
1:         try {
0:             return getSubscriptionStrategy().onSubscribe(destinationName, requestedQoS);
1:         } catch (IOException e) {
0:             throw new MQTTProtocolException("Failed while intercepting subscribe", true, e);
1:     }
1: 
0:     public byte doSubscribe(ConsumerInfo consumerInfo, final String topicName, final QoS qoS) throws MQTTProtocolException {
1: 
0:         MQTTSubscription mqttSubscription = new MQTTSubscription(this, topicName, qoS, consumerInfo);
0:         subscriptionsByConsumerId.put(consumerInfo.getConsumerId(), mqttSubscription);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.warn("Error subscribing to {}", topicName, throwable);
0:                     qos[0] = (byte) qoS.ordinal();
0:             subscriptionsByConsumerId.remove(consumerInfo.getConsumerId());
1:     public void onUnSubscribe(UNSUBSCRIBE command) throws MQTTProtocolException {
/////////////////////////////////////////////////////////////////////////
0:     public void onUnSubscribe(String topicName) {
0:         MQTTSubscription subscription = mqttSubscriptionByTopic.remove(topicName);
0:         if (subscription != null) {
0:             doUnSubscribe(subscription);
0:             // check if the broker side of the subscription needs to be removed
1:             try {
0:                 getSubscriptionStrategy().onUnSubscribe(subscription);
1:             } catch (IOException e) {
0:                 // Ignore
0:     public void doUnSubscribe(MQTTSubscription subscription) {
0:         mqttSubscriptionByTopic.remove(subscription.getTopicName());
0:         ConsumerInfo info = subscription.getConsumerInfo();
0:         if (info != null) {
0:             subscriptionsByConsumerId.remove(info.getConsumerId());
1:         }
0:         RemoveInfo removeInfo = null;
0:         if (info != null) {
0:             removeInfo = info.createRemoveCommand();
1:         }
0:         sendToActiveMQ(removeInfo, new ResponseHandler() {
1:             @Override
1:             public void onResponse(MQTTProtocolConverter converter, Response response) throws IOException {
0:                 // ignore failures..
1:             }
1:         });
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug("Do not know how to process ActiveMQ Command {}", command);
/////////////////////////////////////////////////////////////////////////
1:             LOG.warn("Unknown PUBREL: {} received", command.messageId());
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQDestination destination;
1:         synchronized (activeMQDestinationMap) {
1:             destination = activeMQDestinationMap.get(command.topicName());
1:             if (destination == null) {
1: 
1:                 try {
0:                     destination = getSubscriptionStrategy().onSend(topicName);
1:                 } catch (IOException e) {
1:                     throw JMSExceptionSupport.create(e);
1:                 }
1: 
1:                 activeMQDestinationMap.put(command.topicName().toString(), destination);
1: 
1:         msg.setJMSDestination(destination);
/////////////////////////////////////////////////////////////////////////
0:                 String amqTopicName = getSubscriptionStrategy().onSend(message.getDestination());
1:                 topicName = MQTTProtocolSupport.convertActiveMQToMQTT(amqTopicName);
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("MQTT Client {} requests heart beat of {} ms", getClientId(), keepAliveMS);
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug("MQTT Client {} established heart beat of  {} ms ({} ms + {} ms grace period)",
1:                       new Object[] { getClientId(), keepAliveMS, keepAliveMS, readGracePeriod });
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("Exception detail", exception);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public ConsumerId getNextConsumerId() {
0:         return new ConsumerId(sessionId, consumerIdGenerator.getNextSequenceId());
1:     }
1: 
1:     public boolean isCleanSession() {
1:         return this.connect.cleanSession();
1:     }
1: 
0:     public String getSubscriptionStrategyName() {
1:         return subscriptionStrategyName;
1:     }
1: 
0:     public void setSubscriptionStrategyName(String name) {
1:         this.subscriptionStrategyName = name;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:     protected MQTTSubscriptionStrategy getSubscriptionStrategy() throws IOException {
1:         if (subsciptionStrategy == null) {
1:             synchronized (STRATAGY_FINDER) {
1:                 if (subsciptionStrategy != null) {
1:                     return subsciptionStrategy;
1:                 }
1: 
1:                 MQTTSubscriptionStrategy strategy = null;
1:                 if (subscriptionStrategyName != null && !subscriptionStrategyName.isEmpty()) {
1:                     try {
1:                         strategy = (MQTTSubscriptionStrategy) STRATAGY_FINDER.newInstance(subscriptionStrategyName);
1:                         LOG.debug("MQTT Using subscription strategy: {}", subscriptionStrategyName);
1:                         if (strategy instanceof BrokerServiceAware) {
1:                             ((BrokerServiceAware)strategy).setBrokerService(brokerService);
1:                         }
1:                         strategy.initialize(this);
1:                     } catch (Exception e) {
1:                         throw IOExceptionSupport.create(e);
1:                     }
1:                 } else {
1:                     throw new IOException("Invalid subscription strategy name given: " + subscriptionStrategyName);
1:                 }
1: 
1:                 this.subsciptionStrategy = strategy;
1:             }
1:         }
1:         return subsciptionStrategy;
1:     }
commit:d8f9686
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 resendRetainedMessages(mqttSubscription);
0:         ActiveMQDestination destination = new ActiveMQTopic(MQTTProtocolSupport.convertMQTTToActiveMQ(topicName));
1: 
/////////////////////////////////////////////////////////////////////////
0:         MQTTSubscription mqttSubscription = new MQTTSubscription(this, topicName, topicQoS, consumerInfo);
/////////////////////////////////////////////////////////////////////////
0:     private void resendRetainedMessages(MQTTSubscription mqttSubscription) throws MQTTProtocolException {
1: 
0:         ActiveMQDestination destination = mqttSubscription.getDestination();
1: 
0:         String topicName = mqttSubscription.getTopicName();
/////////////////////////////////////////////////////////////////////////
0:                 restoredSubs.remove(MQTTProtocolSupport.convertMQTTToActiveMQ(topicName));
/////////////////////////////////////////////////////////////////////////
1:                 String topicName = MQTTProtocolSupport.convertMQTTToActiveMQ(command.topicName().toString());
/////////////////////////////////////////////////////////////////////////
0:                 topicName = MQTTProtocolSupport.convertActiveMQToMQTT(message.getDestination().getPhysicalName());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     public ConnectionId getConnectionId() {
1:         return connectionId;
1:     }
1: 
1:     public String getClientId() {
1:         if (clientId == null) {
1:             if (connect != null && connect.clientId() != null) {
1:                 clientId = connect.clientId().toString();
1:             } else {
1:                 clientId = "";
1:             }
1:         }
1:         return clientId;
1:     }
commit:5de0c8e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.virtual.VirtualTopicInterceptor;
/////////////////////////////////////////////////////////////////////////
0:                         if (dest instanceof org.apache.activemq.broker.region.Topic) {
0:                             ((org.apache.activemq.broker.region.Topic)dest).recoverRetroactiveMessages(connectionContext, subscription);
0:                         } else if (dest instanceof VirtualTopicInterceptor) {
0:                             ((VirtualTopicInterceptor)dest).getTopic().recoverRetroactiveMessages(connectionContext, subscription);
1:                         }
/////////////////////////////////////////////////////////////////////////
commit:efa5527
/////////////////////////////////////////////////////////////////////////
1:         if (command instanceof ActiveMQMessage) {
0:             if (!getPublishDollarTopics() && msg.getDestination().getPhysicalName().startsWith("$")) {
0:                 // We don't allow users to send to $ prefixed topics to avoid failing MQTT 3.1.1
0:                 // specification requirements
1:                 if (handler != null) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                         if (connect.cleanSession()) {
/////////////////////////////////////////////////////////////////////////
0:         if (mqttSubscriptionByTopic.containsKey(topicName)) {
0:                 // duplicate SUBSCRIBE packet, find all matching topics and re-send retained messages
/////////////////////////////////////////////////////////////////////////
0:         if (!connect.cleanSession() && connect.clientId() != null && topicQoS.ordinal() >= QoS.AT_LEAST_ONCE.ordinal()) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:2cd5424
/////////////////////////////////////////////////////////////////////////
0:     private final ConcurrentHashMap<String, MQTTSubscription> mqttSubscriptionByTopic = new ConcurrentHashMap<String, MQTTSubscription>();
0:     private final Map<String, ActiveMQTopic> activeMQTopicMap = new LRUCache<String, ActiveMQTopic>(DEFAULT_CACHE_SIZE);
0:     private final Map<Destination, String> mqttTopicMap = new LRUCache<Destination, String>(DEFAULT_CACHE_SIZE);
/////////////////////////////////////////////////////////////////////////
0:         final String topicName = topic.name().toString();
0:         ActiveMQDestination destination = new ActiveMQTopic(convertMQTTToActiveMQ(topicName));
/////////////////////////////////////////////////////////////////////////
0:             consumerInfo.setSubscriptionName(topicQoS + ":" + topicName);
/////////////////////////////////////////////////////////////////////////
0:     private void resendRetainedMessages(String topicName, ActiveMQDestination destination,
/////////////////////////////////////////////////////////////////////////
0:                 onUnSubscribe(topic.toString());
/////////////////////////////////////////////////////////////////////////
0:     void onUnSubscribe(String topicName) {
/////////////////////////////////////////////////////////////////////////
0:                 restoredSubs.remove(convertMQTTToActiveMQ(topicName));
/////////////////////////////////////////////////////////////////////////
0:                 activeMQTopicMap.put(command.topicName().toString(), topic);
/////////////////////////////////////////////////////////////////////////
1:         String topicName;
0:                 topicName = convertActiveMQToMQTT(message.getDestination().getPhysicalName());
1:         result.topicName(new UTF8Buffer(topicName));
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @param activeMQSubscriptionPrefetch
1:      *        set the prefetch for the corresponding ActiveMQ subscription
commit:619864d
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.InvalidClientIDException;
1: import javax.security.auth.login.CredentialException;
/////////////////////////////////////////////////////////////////////////
1:                     if (exception instanceof InvalidClientIDException) {
1:                         ack.code(CONNACK.Code.CONNECTION_REFUSED_IDENTIFIER_REJECTED);
1:                     } else if (exception instanceof SecurityException) {
1:                         ack.code(CONNACK.Code.CONNECTION_REFUSED_NOT_AUTHORIZED);
1:                     } else if (exception instanceof CredentialException) {
commit:3653f81
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQBytesMessage;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQMapMessage;
1: import org.apache.activemq.command.ActiveMQMessage;
1: import org.apache.activemq.command.ActiveMQTextMessage;
0: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.command.Command;
1: import org.apache.activemq.command.ConnectionError;
1: import org.apache.activemq.command.ConnectionId;
1: import org.apache.activemq.command.ConnectionInfo;
0: import org.apache.activemq.command.ConsumerId;
0: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.command.ExceptionResponse;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.MessageDispatch;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.command.ProducerId;
1: import org.apache.activemq.command.ProducerInfo;
0: import org.apache.activemq.command.RemoveInfo;
0: import org.apache.activemq.command.RemoveSubscriptionInfo;
1: import org.apache.activemq.command.Response;
1: import org.apache.activemq.command.SessionId;
1: import org.apache.activemq.command.SessionInfo;
1: import org.apache.activemq.command.ShutdownInfo;
0: import org.apache.activemq.command.SubscriptionInfo;
/////////////////////////////////////////////////////////////////////////
1: import org.fusesource.mqtt.codec.CONNACK;
1: import org.fusesource.mqtt.codec.CONNECT;
1: import org.fusesource.mqtt.codec.DISCONNECT;
1: import org.fusesource.mqtt.codec.MQTTFrame;
1: import org.fusesource.mqtt.codec.PINGREQ;
1: import org.fusesource.mqtt.codec.PINGRESP;
1: import org.fusesource.mqtt.codec.PUBACK;
1: import org.fusesource.mqtt.codec.PUBCOMP;
1: import org.fusesource.mqtt.codec.PUBLISH;
1: import org.fusesource.mqtt.codec.PUBREC;
1: import org.fusesource.mqtt.codec.PUBREL;
1: import org.fusesource.mqtt.codec.SUBACK;
1: import org.fusesource.mqtt.codec.SUBSCRIBE;
1: import org.fusesource.mqtt.codec.UNSUBACK;
1: import org.fusesource.mqtt.codec.UNSUBSCRIBE;
/////////////////////////////////////////////////////////////////////////
0:                     if (exception instanceof SecurityException) {
1:                         ack.code(CONNACK.Code.CONNECTION_REFUSED_BAD_USERNAME_OR_PASSWORD);
1:                     } else {
1:                         ack.code(CONNACK.Code.CONNECTION_REFUSED_SERVER_UNAVAILABLE);
1:                     }
commit:afddc1a
/////////////////////////////////////////////////////////////////////////
1:     static final int DEFAULT_CACHE_SIZE = 5000;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final MQTTPacketIdGenerator packetIdGenerator;
1:         this.packetIdGenerator = MQTTPacketIdGenerator.getMQTTPacketIdGenerator(brokerService);
/////////////////////////////////////////////////////////////////////////
1:                             packetIdGenerator.stopClientSession(getClientId());
1:                             packetIdGenerator.startClientSession(getClientId());
/////////////////////////////////////////////////////////////////////////
0:                                     retainedCopy.messageId(packetIdGenerator.getNextSequenceId(getClientId()));
/////////////////////////////////////////////////////////////////////////
1:         packetIdGenerator.ackPacketId(getClientId(), messageId);
/////////////////////////////////////////////////////////////////////////
1:         packetIdGenerator.ackPacketId(getClientId(), messageId);
/////////////////////////////////////////////////////////////////////////
1:                         publish.messageId(packetIdGenerator.getNextSequenceId(getClientId()));
/////////////////////////////////////////////////////////////////////////
0:     String getClientId() {
/////////////////////////////////////////////////////////////////////////
1:     public MQTTPacketIdGenerator getPacketIdGenerator() {
1:         return packetIdGenerator;
commit:7e56f34
/////////////////////////////////////////////////////////////////////////
0:         if( mqttSubscriptionByTopic.containsKey(topic.name())) {
0:             if (topic.qos() != mqttSubscriptionByTopic.get(topic.name()).qos()) {
0:                 // remove old subscription as the QoS has changed
0:                 onUnSubscribe(topic.name());
1:             } else {
0:                 // duplicate SUBSCRIBE packet, nothing to do
0:                 return topic.qos();
1: 
0:         ActiveMQDestination destination = new ActiveMQTopic(convertMQTTToActiveMQ(topic.name().toString()));
1: 
0:         ConsumerId id = new ConsumerId(sessionId, consumerIdGenerator.getNextSequenceId());
0:         ConsumerInfo consumerInfo = new ConsumerInfo(id);
0:         consumerInfo.setDestination(destination);
0:         consumerInfo.setPrefetchSize(getActiveMQSubscriptionPrefetch());
0:         consumerInfo.setDispatchAsync(true);
0:         if ( connect.clientId() != null && topic.qos().ordinal() >= QoS.AT_LEAST_ONCE.ordinal() ) {
0:             consumerInfo.setSubscriptionName(topic.qos()+":"+topic.name().toString());
1:         }
0:         MQTTSubscription mqttSubscription = new MQTTSubscription(this, topic.qos(), consumerInfo);
1: 
0:         subscriptionsByConsumerId.put(id, mqttSubscription);
0:         mqttSubscriptionByTopic.put(topic.name(), mqttSubscription);
1: 
0:         sendToActiveMQ(consumerInfo, null);
commit:0db7e69
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:             // check retained messages
1:             for (int i = 0; i < topics.length; i++) {
0:                 final Topic topic = topics[i];
0:                             PUBLISH retainedCopy = new PUBLISH();
0:                             retainedCopy.topicName(msg.topicName());
0:                             retainedCopy.retain(msg.retain());
0:                             retainedCopy.messageId(msg.messageId());
0:                             retainedCopy.payload(msg.payload());
0:                             // set QoS of retained message to maximum of subscription QoS
0:                             retainedCopy.qos(msg.qos().ordinal() > qos[i] ? QoS.values()[qos[i]] : msg.qos());
0:                             getMQTTTransport().sendToMQTT(retainedCopy.encode());
1:         } else {
1:             LOG.warn("No topics defined for Subscription " + command);
commit:b97fa15
/////////////////////////////////////////////////////////////////////////
0:     void onUnSubscribe(UNSUBSCRIBE command) throws MQTTProtocolException {
1:         checkConnected();
commit:b679787
/////////////////////////////////////////////////////////////////////////
1:             throw new MQTTProtocolException("Already connected.");
/////////////////////////////////////////////////////////////////////////
1:             // Clean Session MUST be set for 0 length Client Id
1:             if (!connect.cleanSession()) {
1:                 CONNACK ack = new CONNACK();
1:                 ack.code(CONNACK.Code.CONNECTION_REFUSED_IDENTIFIER_REJECTED);
1:                 try {
1:                     getMQTTTransport().sendToMQTT(ack.encode());
1:                     getMQTTTransport().onException(IOExceptionSupport.create("Invalid Client ID", null));
0:                 } catch (IOException e) {
1:                     getMQTTTransport().onException(IOExceptionSupport.create(e));
1:                 }
1:                 return;
1:             }
/////////////////////////////////////////////////////////////////////////
1:                             return;
/////////////////////////////////////////////////////////////////////////
author:Dhiraj Bokde
-------------------------------------------------------------------------------
commit:73908d6
/////////////////////////////////////////////////////////////////////////
1:     private boolean publishDollarTopics;
/////////////////////////////////////////////////////////////////////////
0:             if( !getPublishDollarTopics() && msg.getDestination().getPhysicalName().startsWith("$") ) {
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void setPublishDollarTopics(boolean publishDollarTopics) {
1:         this.publishDollarTopics = publishDollarTopics;
1:     }
1: 
1:     public boolean getPublishDollarTopics() {
1:         return publishDollarTopics;
1:     }
commit:6c85967
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collections;
0: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.PrefetchSubscription;
/////////////////////////////////////////////////////////////////////////
0:     private final Set<String> restoredSubs = Collections.synchronizedSet(new HashSet<String>());
1: 
/////////////////////////////////////////////////////////////////////////
0:                 // mark this durable subscription as restored by Broker
0:                 restoredSubs.add(split[1]);
/////////////////////////////////////////////////////////////////////////
0:         // check whether the Topic has been recovered in restoreDurableSubs
0:         // mark subscription available for recovery for duplicate subscription
0:         if (restoredSubs.remove(destination.getPhysicalName())) {
1:             return;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:                         if (subscription instanceof PrefetchSubscription) {
0:                             // request dispatch for prefetch subs
0:                             PrefetchSubscription prefetchSubscription = (PrefetchSubscription) subscription;
0:                             prefetchSubscription.dispatchPending();
1:                         }
/////////////////////////////////////////////////////////////////////////
0:                 // also remove it from restored durable subscriptions set
0:                 restoredSubs.remove(convertMQTTToActiveMQ(topicName.toString()));
1: 
commit:8644090
/////////////////////////////////////////////////////////////////////////
0:         // optimistic add to local maps first to be able to handle commands in onActiveMQCommand
0:         subscriptionsByConsumerId.put(id, mqttSubscription);
0:         mqttSubscriptionByTopic.put(topicName, mqttSubscription);
1: 
/////////////////////////////////////////////////////////////////////////
0:         if (qos[0] == SUBSCRIBE_ERROR) {
0:             // remove from local maps if subscribe failed
0:             subscriptionsByConsumerId.remove(id);
0:             mqttSubscriptionByTopic.remove(topicName);
/////////////////////////////////////////////////////////////////////////
0:             // recover retroactive messages for matching subscription
/////////////////////////////////////////////////////////////////////////
1:                     break;
/////////////////////////////////////////////////////////////////////////
1:      * Dispatch an ActiveMQ command
commit:88c6ee9
/////////////////////////////////////////////////////////////////////////
0:             final MQTTSubscription mqttSubscription = mqttSubscriptionByTopic.get(topicName);
0:             if (topicQoS != mqttSubscription.qos()) {
0:                 resendRetainedMessages(topicName, destination, mqttSubscription);
/////////////////////////////////////////////////////////////////////////
0:     private void resendRetainedMessages(UTF8Buffer topicName, ActiveMQDestination destination,
0:                                         MQTTSubscription mqttSubscription) throws MQTTProtocolException {
/////////////////////////////////////////////////////////////////////////
0:         final ConsumerInfo consumerInfo = mqttSubscription.getConsumerInfo();
0:         final ConsumerId consumerId = consumerInfo.getConsumerId();
1: 
0:         // use actual client id used to create connection to lookup connection context
0:         final String connectionInfoClientId = connectionInfo.getClientId();
0:         final ConnectionContext connectionContext = regionBroker.getConnectionContext(connectionInfoClientId);
1: 
0:             // recover retroactive messages for matching subscriptions
0:             for (Subscription subscription : dest.getConsumers()) {
0:                 if (subscription.getConsumerInfo().getConsumerId().equals(consumerId)) {
1:                     try {
0:                         ((org.apache.activemq.broker.region.Topic)dest).recoverRetroactiveMessages(connectionContext, subscription);
0:                     } catch (Exception e) {
0:                         throw new MQTTProtocolException("Error recovering retained messages for " +
0:                             dest.getName() + ": " + e.getMessage(), false, e);
1:                     }
/////////////////////////////////////////////////////////////////////////
1: 
0:             // check if the durable sub also needs to be removed
0:             if (subs.getConsumerInfo().getSubscriptionName() != null) {
0:                 RemoveSubscriptionInfo rsi = new RemoveSubscriptionInfo();
0:                 rsi.setConnectionId(connectionId);
0:                 rsi.setSubscriptionName(subs.getConsumerInfo().getSubscriptionName());
0:                 rsi.setClientId(connectionInfo.getClientId());
0:                 sendToActiveMQ(rsi, null);
1:             }
commit:a581d01
/////////////////////////////////////////////////////////////////////////
0: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.ConnectionContext;
0: import org.apache.activemq.broker.region.RegionBroker;
0: import org.apache.activemq.broker.region.Subscription;
0: import org.apache.activemq.broker.region.TopicRegion;
/////////////////////////////////////////////////////////////////////////
0:     protected static final String QOS_PROPERTY_NAME = "ActiveMQ.MQTT.QoS";
/////////////////////////////////////////////////////////////////////////
0:         ActiveMQDestination destination = new ActiveMQTopic(convertMQTTToActiveMQ(topicName.toString()));
1: 
0:                 // duplicate SUBSCRIBE packet, find all matching topics and resend retained messages
0:                 resendRetainedMessages(topicName, destination);
1: 
/////////////////////////////////////////////////////////////////////////
0:     private void resendRetainedMessages(UTF8Buffer topicName, ActiveMQDestination destination) throws MQTTProtocolException {
0:         // get TopicRegion
0:         RegionBroker regionBroker;
0:         try {
0:             regionBroker = (RegionBroker) brokerService.getBroker().getAdaptor(RegionBroker.class);
0:         } catch (Exception e) {
0:             throw new MQTTProtocolException("Error subscribing to " + topicName + ": " + e.getMessage(), false, e);
1:         }
0:         final TopicRegion topicRegion = (TopicRegion) regionBroker.getTopicRegion();
1: 
0:         // get all matching Topics
0:         final Set<org.apache.activemq.broker.region.Destination> matchingDestinations = topicRegion.getDestinations(destination);
0:         for (org.apache.activemq.broker.region.Destination dest : matchingDestinations) {
0:             // find matching MQTT subscription for this client
0:             final String mqttTopicName = convertActiveMQToMQTT(dest.getName());
0:             final MQTTSubscription mqttSubscription = mqttSubscriptionByTopic.get(new UTF8Buffer(mqttTopicName));
0:             if (mqttSubscription != null) {
0:                 // recover retroactive messages for matching subscription
0:                 final ConsumerInfo consumerInfo = mqttSubscription.getConsumerInfo();
0:                 final ConsumerId consumerId = consumerInfo.getConsumerId();
0:                 final Subscription subscription = topicRegion.getSubscriptions().get(consumerId);
1: 
0:                 // use actual client id used to create connection to lookup connection context
0:                 final ConnectionContext connectionContext = regionBroker.getConnectionContext(connectionInfo.getClientId());
0:                 try {
0:                     ((org.apache.activemq.broker.region.Topic)dest).recoverRetroactiveMessages(connectionContext, subscription);
0:                 } catch (Exception e) {
0:                     throw new MQTTProtocolException("Error recovering retained messages for " +
0:                         mqttTopicName + ": " + e.getMessage(), false, e);
1:                 }
1:             }
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:                 topicName = new UTF8Buffer(convertActiveMQToMQTT(message.getDestination().getPhysicalName()));
/////////////////////////////////////////////////////////////////////////
0:     private String convertActiveMQToMQTT(String physicalName) {
0:         return physicalName.replace('.', '/');
1:     }
1: 
commit:bcb60a4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.policy.RetainedMessageSubscriptionRecoveryPolicy;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         final UTF8Buffer topicName = topic.name();
0:         final QoS topicQoS = topic.qos();
0:         if( mqttSubscriptionByTopic.containsKey(topicName)) {
0:             if (topicQoS != mqttSubscriptionByTopic.get(topicName).qos()) {
0:                 onUnSubscribe(topicName);
0:                 // duplicate SUBSCRIBE packet
0:                 // TODO find all matching topics and resend retained messages
0:                 return (byte) topicQoS.ordinal();
0:             onUnSubscribe(topicName);
0:         ActiveMQDestination destination = new ActiveMQTopic(convertMQTTToActiveMQ(topicName.toString()));
0:         consumerInfo.setRetroactive(true);
0:         if ( !connect.cleanSession() && connect.clientId() != null && topicQoS.ordinal() >= QoS.AT_LEAST_ONCE.ordinal() ) {
0:             consumerInfo.setSubscriptionName(topicQoS + ":" + topicName.toString());
0:         MQTTSubscription mqttSubscription = new MQTTSubscription(this, topicQoS, consumerInfo);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.warn("Error subscribing to " + topicName, throwable);
0:                     qos[0] = (byte) topicQoS.ordinal();
0:             mqttSubscriptionByTopic.put(topicName, mqttSubscription);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (command.retain()) {
1:             msg.setBooleanProperty(RetainedMessageSubscriptionRecoveryPolicy.RETAIN_PROPERTY, true);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (message.getBooleanProperty(RetainedMessageSubscriptionRecoveryPolicy.RETAINED_PROPERTY)) {
1:             result.retain(true);
1:         }
author:Hiram Chirino
-------------------------------------------------------------------------------
commit:7068302
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Lets intercept message send requests..
0:         if( command instanceof ActiveMQMessage) {
1:             ActiveMQMessage msg = (ActiveMQMessage) command;
0:             if( msg.getDestination().getPhysicalName().startsWith("$") ) {
0:                 // We don't allow users to send to $ prefixed topics to avoid failing MQTT 3.1.1 spec requirements
0:                 if( handler!=null ) {
0:                     try {
0:                         handler.onResponse(this, new Response());
0:                     } catch (IOException e) {
0:                         e.printStackTrace();
1:                     }
1:                 }
1:                 return;
1:             }
1:         }
1: 
commit:6e68a37
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private static final double MQTT_KEEP_ALIVE_GRACE_PERIOD= 0.5;
/////////////////////////////////////////////////////////////////////////
1: 
1:             if (keepAliveMS == 0 && defaultKeepAlive > 0) {
1:                 keepAliveMS = defaultKeepAlive;
1:             long readGracePeriod = (long) (keepAliveMS * MQTT_KEEP_ALIVE_GRACE_PERIOD);
1: 
1:             monitor.setReadKeepAliveTime(keepAliveMS);
1:             monitor.setReadGraceTime(readGracePeriod);
0:                         " established heart beat of  " + keepAliveMS +
0:                         " ms (" + keepAliveMS + "ms + " + readGracePeriod +
commit:e2a7d6a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 RemoveSubscriptionInfo rsi = new RemoveSubscriptionInfo();
0:                 rsi.setConnectionId(connectionId);
0:                 rsi.setSubscriptionName(sub.getSubcriptionName());
0:                 rsi.setClientId(sub.getClientId());
0:                 sendToActiveMQ(rsi, new ResponseHandler() {
0:                     @Override
0:                     public void onResponse(MQTTProtocolConverter converter, Response response) throws IOException {
0:                         // ignore failures..
1:                     }
0:                 });
1:         } catch (Throwable e) {
/////////////////////////////////////////////////////////////////////////
0:         msg.setPersistent(command.qos() != QoS.AT_MOST_ONCE && !command.retain());
commit:9735806
/////////////////////////////////////////////////////////////////////////
0:         System.out.println(mqttTransport.getInactivityMonitor()+" ==> "+command);
/////////////////////////////////////////////////////////////////////////
0:                 ActiveMQTopic destination = new ActiveMQTopic(convertMQTTToActiveMQ(topic.name().toString()));
0:                 for (PUBLISH msg : retainedMessages.getMessages(destination)) {
0:                     if( msg.payload().length > 0 ) {
0:                         try {
0:                             getMQTTTransport().sendToMQTT(msg.encode());
0:                         } catch (IOException e) {
0:                             LOG.warn("Couldn't send retained message " + msg, e);
1:                         }
/////////////////////////////////////////////////////////////////////////
0:             if ( connect.clientId() != null && topic.qos().ordinal() >= QoS.AT_LEAST_ONCE.ordinal() ) {
/////////////////////////////////////////////////////////////////////////
0:         if (command.retain()){
0:             retainedMessages.addMessage((ActiveMQTopic) message.getDestination(), command);
1:         }
/////////////////////////////////////////////////////////////////////////
0:                 String topicName = convertMQTTToActiveMQ(command.topicName().toString());
/////////////////////////////////////////////////////////////////////////
1:     boolean willSent = false;
0:             if (connected.get() && connect.willTopic() != null && connect.willMessage() != null && !willSent) {
0:                 willSent = true;
0:                     publish.messageId((short) messageIdGenerator.getNextSequenceId());
1: 
/////////////////////////////////////////////////////////////////////////
0:         char[] chars = name.toCharArray();
0:         for (int i = 0; i < chars.length; i++) {
0:             switch(chars[i]) {
1: 
0:                 case '#':
0:                     chars[i] = '>';
1:                     break;
0:                 case '>':
0:                     chars[i] = '#';
1:                     break;
1: 
0:                 case '+':
0:                     chars[i] = '*';
1:                     break;
0:                 case '*':
0:                     chars[i] = '+';
1:                     break;
1: 
0:                 case '/':
0:                     chars[i] = '.';
1:                     break;
0:                 case '.':
0:                     chars[i] = '/';
1:                     break;
1: 
1:             }
1:         }
0:         String rc = new String(chars);
0:         return rc;
commit:ad30410
/////////////////////////////////////////////////////////////////////////
1:                 CONNECT connect = new CONNECT().decode(frame);
1:                 onMQTTConnect(connect);
1:                 LOG.debug("MQTT Client {} connected. (version: {})", getClientId(), connect.version());
1:                 LOG.debug("MQTT Client {} disconnecting", getClientId());
commit:bc4f4e9
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashSet;
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.BrokerService;
0: import org.apache.activemq.command.*;
0: import org.apache.activemq.store.PersistenceAdapterSupport;
0: import org.apache.activemq.store.TopicMessageStore;
/////////////////////////////////////////////////////////////////////////
1:     private final BrokerService brokerService;
/////////////////////////////////////////////////////////////////////////
1:     public MQTTProtocolConverter(MQTTTransport mqttTransport, BrokerService brokerService) {
1:         this.brokerService = brokerService;
/////////////////////////////////////////////////////////////////////////
0:                         List<SubscriptionInfo> subs = PersistenceAdapterSupport.listSubscriptions(brokerService.getPersistenceAdapter(), connectionInfo.getClientId());
0:                         if( connect.cleanSession() ) {
0:                             deleteDurableSubs(subs);
1:                         } else {
0:                             restoreDurableSubs(subs);
1:                         }
0:     public void deleteDurableSubs(List<SubscriptionInfo> subs) {
0:         try {
0:             for (SubscriptionInfo sub : subs) {
0:                 TopicMessageStore store = brokerService.getPersistenceAdapter().createTopicMessageStore((ActiveMQTopic) sub.getDestination());
0:                 store.deleteSubscription(connectionInfo.getClientId(), sub.getSubscriptionName());
1:             }
0:         } catch (IOException e) {
0:             LOG.warn("Could not delete the MQTT durable subs.", e);
1:         }
1:     }
1: 
0:     public void restoreDurableSubs(List<SubscriptionInfo> subs) {
0:         try {
0:             SUBSCRIBE command = new SUBSCRIBE();
0:             for (SubscriptionInfo sub : subs) {
0:                 String name = sub.getSubcriptionName();
0:                 String[] split = name.split(":", 2);
0:                 QoS qoS = QoS.valueOf(split[0]);
0:                 onSubscribe(new Topic(split[1], qoS));
1:             }
0:         } catch (IOException e) {
0:             LOG.warn("Could not restore the MQTT durable subs.", e);
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:                 qos[i] = (byte) onSubscribe(topics[i]).ordinal();
/////////////////////////////////////////////////////////////////////////
0:     QoS onSubscribe(Topic topic) throws MQTTProtocolException {
0:         if( !mqttSubscriptionByTopic.containsKey(topic.name()) ) {
0:             ActiveMQDestination destination = new ActiveMQTopic(convertMQTTToActiveMQ(topic.name().toString()));
0:             ConsumerId id = new ConsumerId(sessionId, consumerIdGenerator.getNextSequenceId());
0:             ConsumerInfo consumerInfo = new ConsumerInfo(id);
0:             consumerInfo.setDestination(destination);
0:             consumerInfo.setPrefetchSize(getActiveMQSubscriptionPrefetch());
0:             consumerInfo.setDispatchAsync(true);
0:             if (!connect.cleanSession() && (connect.clientId() != null)) {
0:                 consumerInfo.setSubscriptionName(topic.qos()+":"+topic.name().toString());
1:             }
0:             MQTTSubscription mqttSubscription = new MQTTSubscription(this, topic.qos(), consumerInfo);
1: 
0:             subscriptionsByConsumerId.put(id, mqttSubscription);
0:             mqttSubscriptionByTopic.put(topic.name(), mqttSubscription);
1: 
0:             sendToActiveMQ(consumerInfo, null);
author:rajdavies
-------------------------------------------------------------------------------
commit:6683eb6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.fusesource.mqtt.codec.*;
/////////////////////////////////////////////////////////////////////////
0:     private final MQTTRetainedMessages retainedMessages;
0:         this.retainedMessages = MQTTRetainedMessages.getMQTTRetainedMessages(brokerService);
/////////////////////////////////////////////////////////////////////////
0:         //check retained messages
0:         if (topics != null){
0:             for (Topic topic:topics){
0:                 Buffer buffer = retainedMessages.getMessage(topic.name().toString());
0:                 if (buffer != null){
0:                     PUBLISH msg = new PUBLISH();
0:                     msg.payload(buffer);
0:                     msg.topicName(topic.name());
0:                     try {
0:                         getMQTTTransport().sendToMQTT(msg.encode());
0:                     } catch (IOException e) {
0:                         LOG.warn("Couldn't send retained message " + msg, e);
1:                     }
1:                 }
1:             }
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:         if (command.retain()){
0:             retainedMessages.addMessage(command.topicName().toString(),command.payload());
1:         }
author:Christian Posta
-------------------------------------------------------------------------------
commit:a63a832
/////////////////////////////////////////////////////////////////////////
1:         String userName = null;
1:         String passswd = null;
commit:d212d3c
/////////////////////////////////////////////////////////////////////////
0:     private static final double MQTT_KEEP_ALIVE_GRACE_PERIOD= 1.5;
/////////////////////////////////////////////////////////////////////////
1:     private long defaultKeepAlive;
1:         this.defaultKeepAlive = 0;
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Received a ping from client: " + getClientId());
/////////////////////////////////////////////////////////////////////////
1:     void configureInactivityMonitor(short keepAliveSeconds) {
1:         MQTTInactivityMonitor monitor = getMQTTTransport().getInactivityMonitor();
1: 
1:         // If the user specifically shuts off the InactivityMonitor with transport.useInactivityMonitor=false,
1:         // then ignore configuring it because it won't exist
1:         if (monitor == null) {
0:             return;
1:         }
1: 
1: 
1:         long keepAliveMS = keepAliveSeconds * 1000;
1: 
0:         if (LOG.isDebugEnabled()) {
0:             LOG.debug("MQTT Client " + getClientId() + " requests heart beat of  " + keepAliveMS + " ms");
1:         }
1: 
1: 
0:             long keepAliveMSWithGracePeriod = (long) (keepAliveMS * MQTT_KEEP_ALIVE_GRACE_PERIOD);
1: 
1:             // if we have a default keep-alive value, and the client is trying to turn off keep-alive,
1:             // we'll observe the server-side configured default value (note, no grace period)
0:             if (keepAliveMSWithGracePeriod == 0 && defaultKeepAlive > 0) {
0:                 keepAliveMSWithGracePeriod = defaultKeepAlive;
1:             }
1: 
0:             monitor.setReadCheckTime(keepAliveMSWithGracePeriod);
0:             monitor.setInitialDelayTime(keepAliveMS);
1: 
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("MQTT Client " + getClientId() +
0:                         " established heart beat of  " + keepAliveMSWithGracePeriod +
0:                         " ms (" + keepAliveMS + "ms + " + (keepAliveMSWithGracePeriod - keepAliveMS) +
0:                         "ms grace period)");
1:             }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:             else {
0:                 clientId = "";
1:             }
/////////////////////////////////////////////////////////////////////////
1: 
1:     public long getDefaultKeepAlive() {
1:         return defaultKeepAlive;
1:     }
1: 
1:     /**
1:      * Set the default keep alive time (in milliseconds) that would be used if configured on server side
1:      * and the client sends a keep-alive value of 0 (zero) on a CONNECT frame
1:      *
0:      * @param defaultKeepAlive
1:      */
0:     public void setDefaultKeepAlive(long defaultKeepAlive) {
0:         this.defaultKeepAlive = defaultKeepAlive;
1:     }
author:Robert Davies
-------------------------------------------------------------------------------
commit:8335dfc
/////////////////////////////////////////////////////////////////////////
0:             connected.set(false);
/////////////////////////////////////////////////////////////////////////
0:             if (connected.get() && connect.willTopic() != null && connect.willMessage() != null) {
commit:09c4500
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 if (ack != null && sub.expectAck(publish)) {
1:                 if (ack != null && !sub.expectAck(publish)) {
/////////////////////////////////////////////////////////////////////////
1:      * @param keepAlive the keepAlive in milliseconds
1:     public void setDefaultKeepAlive(long keepAlive) {
1:         this.defaultKeepAlive = keepAlive;
commit:667237f
/////////////////////////////////////////////////////////////////////////
0:     private static final int DEFAULT_CACHE_SIZE = 5000;
/////////////////////////////////////////////////////////////////////////
0:     private final Map<UTF8Buffer, ActiveMQTopic> activeMQTopicMap = new LRUCache<UTF8Buffer, ActiveMQTopic>(DEFAULT_CACHE_SIZE);
0:     private final Map<Destination, UTF8Buffer> mqttTopicMap = new LRUCache<Destination, UTF8Buffer>(DEFAULT_CACHE_SIZE);
1:     private final Map<Short, MessageAck> consumerAcks = new LRUCache<Short, MessageAck>(DEFAULT_CACHE_SIZE);
1:     private final Map<Short, PUBREC> publisherRecs = new LRUCache<Short, PUBREC>(DEFAULT_CACHE_SIZE);
/////////////////////////////////////////////////////////////////////////
0:     private int activeMQSubscriptionPrefetch=1;
/////////////////////////////////////////////////////////////////////////
1:             resposeHandlers.put(command.getCommandId(), handler);
/////////////////////////////////////////////////////////////////////////
0:         consumerInfo.setPrefetchSize(getActiveMQSubscriptionPrefetch());
/////////////////////////////////////////////////////////////////////////
1:             for (UTF8Buffer topic : topics) {
0:                 onUnSubscribe(topic);
/////////////////////////////////////////////////////////////////////////
0:             RemoveInfo removeInfo = null;
0:             if (info != null) {
0:                 removeInfo = info.createRemoveCommand();
1:             }
/////////////////////////////////////////////////////////////////////////
0:         ActiveMQTopic topic;
/////////////////////////////////////////////////////////////////////////
0:      * @param defaultKeepAlive the keepAlive in milliseconds
1: 
1:     public int getActiveMQSubscriptionPrefetch() {
1:         return activeMQSubscriptionPrefetch;
1:     }
1: 
1:     /**
1:      * set the default prefetch size when mapping the MQTT subscription to an ActiveMQ one
1:      * The default = 1
0:      * @param activeMQSubscriptionPrefetch set the prefetch for the corresponding ActiveMQ subscription
1:      */
1: 
1:     public void setActiveMQSubscriptionPrefetch(int activeMQSubscriptionPrefetch) {
1:         this.activeMQSubscriptionPrefetch = activeMQSubscriptionPrefetch;
1:     }
commit:1e3ea5c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 msg.setReadOnlyBody(true);
1:                     result.payload(new Buffer(messageText.getBytes("UTF-8")));
1: 
/////////////////////////////////////////////////////////////////////////
0:         } else if (message.getDataStructureType() == ActiveMQMapMessage.DATA_STRUCTURE_TYPE){
1:             ActiveMQMapMessage msg = (ActiveMQMapMessage) message.copy();
1:             msg.setReadOnlyBody(true);
0:             Map map = msg.getContentMap();
0:             if (map != null){
1:                 result.payload(new Buffer(map.toString().getBytes("UTF-8")));
1:             }
1:         }
1: 
0:         else {
1:             ByteSequence byteSequence = message.getContent();
0:                 if (message.isCompressed()){
1:                     Inflater inflater = new Inflater();
0:                     inflater.setInput(byteSequence.data,byteSequence.offset,byteSequence.length);
0:                     byte[]  data = new byte[4096];
1:                     int read;
1:                     ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
0:                     while((read = inflater.inflate(data)) != 0){
0:                        bytesOut.write(data,0,read);
1:                     }
1:                     byteSequence = bytesOut.toByteSequence();
1:                 }
/////////////////////////////////////////////////////////////////////////
0:         String result = name.replace('#', '>');
0:         result = result.replace('+', '*');
0:         result = result.replace('/', '.');
commit:4c38438
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private final Map<Short, PUBREC> publisherRecs = new LRUCache<Short, PUBREC>();
/////////////////////////////////////////////////////////////////////////
0:             case PUBREC.TYPE: {
1:                 onMQTTPubRec(new PUBREC().decode(frame));
1:                 break;
1:             }
0:             case PUBREL.TYPE: {
1:                 onMQTTPubRel(new PUBREL().decode(frame));
1:                 break;
1:             }
0:             case PUBCOMP.TYPE: {
1:                 onMQTTPubComp(new PUBCOMP().decode(frame));
1:                 break;
1:             }
/////////////////////////////////////////////////////////////////////////
1:     void onMQTTConnect(final CONNECT connect) throws MQTTProtocolException {
0:             throw new MQTTProtocolException("All ready connected.");
/////////////////////////////////////////////////////////////////////////
0:         MQTTSubscription mqttSubscription = new MQTTSubscription(this, topic.qos(), consumerInfo);
/////////////////////////////////////////////////////////////////////////
1:                 PUBLISH publish = sub.createPublish((ActiveMQMessage) md.getMessage());
0:                 if (ack != null && sub.expectAck()) {
0:                 if (ack != null && !sub.expectAck()) {
1:                     getMQTTTransport().sendToActiveMQ(ack);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:         MessageAck ack;
1:         synchronized (consumerAcks) {
1:             ack = consumerAcks.remove(messageId);
1:         }
1:         if (ack != null) {
1:             getMQTTTransport().sendToActiveMQ(ack);
1:         }
1:     }
1: 
1:     void onMQTTPubRec(PUBREC commnand) {
1:         //from a subscriber - send a PUBREL in response
1:         PUBREL pubrel = new PUBREL();
1:         pubrel.messageId(commnand.messageId());
1:         sendToMQTT(pubrel.encode());
1:     }
1: 
1:     void onMQTTPubRel(PUBREL command) {
1:         PUBREC ack;
1:         synchronized (publisherRecs) {
1:             ack = publisherRecs.remove(command.messageId());
1:         }
1:         if (ack == null) {
0:             LOG.warn("Unknown PUBREL: " + command.messageId() + " received");
1:         }
1:         PUBCOMP pubcomp = new PUBCOMP();
1:         pubcomp.messageId(command.messageId());
1:         sendToMQTT(pubcomp.encode());
1:     }
1: 
1:     void onMQTTPubComp(PUBCOMP command) {
1:         short messageId = command.messageId();
1:         MessageAck ack;
/////////////////////////////////////////////////////////////////////////
1:     public void onTransportError() {
1:         if (connect != null) {
0:             if (connect.willTopic() != null && connect.willMessage() != null) {
0:                 try {
0:                     PUBLISH publish = new PUBLISH();
0:                     publish.topicName(connect.willTopic());
0:                     publish.qos(connect.willQos());
0:                     publish.payload(connect.willMessage());
0:                     ActiveMQMessage message = convertMessage(publish);
1:                     message.setProducerId(producerId);
1:                     message.onSend();
0:                     sendToActiveMQ(message, null);
0:                 } catch (Exception e) {
0:                     LOG.warn("Failed to publish Will Message " + connect.willMessage());
1:                 }
1: 
/////////////////////////////////////////////////////////////////////////
1:             monitor.setProtocolConverter(this);
/////////////////////////////////////////////////////////////////////////
0:                                 PUBREC ack = new PUBREC();
0:                                 synchronized (publisherRecs) {
0:                                     publisherRecs.put(command.messageId(), ack);
1:                                 }
/////////////////////////////////////////////////////////////////////////
commit:0f5b406
/////////////////////////////////////////////////////////////////////////
1: import java.util.zip.DataFormatException;
1: import java.util.zip.Inflater;
1: import javax.jms.Message;
1: import org.apache.activemq.util.ByteArrayOutputStream;
1: import org.fusesource.mqtt.client.QoS;
1: import org.fusesource.mqtt.client.Topic;
0: import org.fusesource.mqtt.codec.*;
/////////////////////////////////////////////////////////////////////////
0:     private final LongSequenceGenerator consumerIdGenerator = new LongSequenceGenerator();
0:     private final ConcurrentHashMap<ConsumerId, MQTTSubscription> subscriptionsByConsumerId = new ConcurrentHashMap<ConsumerId, MQTTSubscription>();
0:     private final ConcurrentHashMap<UTF8Buffer, MQTTSubscription> mqttSubscriptionByTopic = new ConcurrentHashMap<UTF8Buffer, MQTTSubscription>();
0:     private final Map<Short, MessageAck> consumerAcks = new LRUCache<Short, MessageAck>();
0:     private ConnectionInfo connectionInfo = new ConnectionInfo();
0:     private final String QOS_PROPERTY_NAME = "QoSPropertyName";
1:     int generateCommandId() {
0:     void sendToActiveMQ(Command command, ResponseHandler handler) {
/////////////////////////////////////////////////////////////////////////
1:     void sendToMQTT(MQTTFrame frame) {
0:         try {
1:             mqttTransport.sendToMQTT(frame);
0:         } catch (IOException e) {
1:             LOG.warn("Failed to send frame " + frame, e);
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:                 LOG.debug("MQTT Client " + getClientId() + " connected.");
/////////////////////////////////////////////////////////////////////////
0:             case SUBSCRIBE.TYPE: {
1:                 onSubscribe(new SUBSCRIBE().decode(frame));
0:                 break;
1:             }
0:             case UNSUBSCRIBE.TYPE: {
1:                 onUnSubscribe(new UNSUBSCRIBE().decode(frame));
0:                 break;
1:             }
0:             case PUBLISH.TYPE: {
1:                 onMQTTPublish(new PUBLISH().decode(frame));
0:                 break;
1:             }
0:             case PUBACK.TYPE: {
1:                 onMQTTPubAck(new PUBACK().decode(frame));
0:                 break;
1:             }
/////////////////////////////////////////////////////////////////////////
0:     void onMQTTConnect(final CONNECT connect) throws ProtocolException {
/////////////////////////////////////////////////////////////////////////
1:         if (clientId != null && !clientId.isEmpty()) {
/////////////////////////////////////////////////////////////////////////
1:                         connected.set(true);
/////////////////////////////////////////////////////////////////////////
1:     void onSubscribe(SUBSCRIBE command) throws MQTTProtocolException {
1:         checkConnected();
0:         SUBACK result = new SUBACK();
1:         Topic[] topics = command.topics();
1:         if (topics != null) {
1:             byte[] qos = new byte[topics.length];
0:             for (int i = 0; i < topics.length; i++) {
0:                 qos[i] = (byte) onSubscribe(command, topics[i]).ordinal();
1:             }
1:             SUBACK ack = new SUBACK();
1:             ack.messageId(command.messageId());
1:             ack.grantedQos(qos);
0:             try {
1:                 getMQTTTransport().sendToMQTT(ack.encode());
0:             } catch (IOException e) {
1:                 LOG.warn("Couldn't send SUBACK for " + command, e);
1:             }
1:         } else {
0:             LOG.warn("No topics defined for Subscription " + command);
1:         }
1:     }
1: 
0:     QoS onSubscribe(SUBSCRIBE command, Topic topic) throws MQTTProtocolException {
0:         ActiveMQDestination destination = new ActiveMQTopic(convertMQTTToActiveMQ(topic.name().toString()));
1: 
1: 
0:         if (destination == null) {
0:             throw new MQTTProtocolException("Invalid Destination.");
1:         }
1: 
0:         ConsumerId id = new ConsumerId(sessionId, consumerIdGenerator.getNextSequenceId());
0:         ConsumerInfo consumerInfo = new ConsumerInfo(id);
0:         consumerInfo.setDestination(destination);
0:         consumerInfo.setPrefetchSize(1000);
0:         consumerInfo.setDispatchAsync(true);
0:         if (!connect.cleanSession() && (connect.clientId() != null)) {
0:             //by default subscribers are persistent
0:             consumerInfo.setSubscriptionName(connect.clientId().toString());
1:         }
1: 
0:         MQTTSubscription mqttSubscription = new MQTTSubscription(this, command.qos(), consumerInfo);
1: 
1: 
0:         subscriptionsByConsumerId.put(id, mqttSubscription);
0:         mqttSubscriptionByTopic.put(topic.name(), mqttSubscription);
1: 
0:         sendToActiveMQ(consumerInfo, null);
0:         return topic.qos();
1:     }
1: 
0:     void onUnSubscribe(UNSUBSCRIBE command) {
1:         UTF8Buffer[] topics = command.topics();
1:         if (topics != null) {
0:             for (int i = 0; i < topics.length; i++) {
0:                 onUnSubscribe(topics[i]);
1:             }
1:         }
0:         UNSUBACK ack = new UNSUBACK();
1:         ack.messageId(command.messageId());
0:         sendToMQTT(ack.encode());
1: 
1:     }
1: 
0:     void onUnSubscribe(UTF8Buffer topicName) {
0:         MQTTSubscription subs = mqttSubscriptionByTopic.remove(topicName);
0:         if (subs != null) {
0:             ConsumerInfo info = subs.getConsumerInfo();
0:             if (info != null) {
0:                 subscriptionsByConsumerId.remove(info.getConsumerId());
1:             }
0:             RemoveInfo removeInfo = info.createRemoveCommand();
0:             sendToActiveMQ(removeInfo, null);
1:         }
1:     }
1: 
1:     public void onActiveMQCommand(Command command) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:             MQTTSubscription sub = subscriptionsByConsumerId.get(md.getConsumerId());
1:                 MessageAck ack = sub.createMessageAck(md);
0:                 PUBLISH publish = convertMessage((ActiveMQMessage) md.getMessage());
1:                 if (ack != null) {
1:                     synchronized (consumerAcks) {
1:                         consumerAcks.put(publish.messageId(), ack);
0:                     }
0:                 }
1:                 getMQTTTransport().sendToMQTT(publish.encode());
1:         } else if (command.isBrokerInfo()) {
1:             //ignore
1:     void onMQTTPublish(PUBLISH command) throws IOException, JMSException {
1:         checkConnected();
1:         ActiveMQMessage message = convertMessage(command);
0:         message.setProducerId(producerId);
0:         message.onSend();
1:         sendToActiveMQ(message, createResponseHandler(command));
0:     }
1:     void onMQTTPubAck(PUBACK command) {
1:         short messageId = command.messageId();
0:         MessageAck ack = null;
1:         synchronized (consumerAcks) {
1:             ack = consumerAcks.remove(messageId);
0:         }
1:         if (ack != null) {
1:             getMQTTTransport().sendToActiveMQ(ack);
0:         }
0:     }
0: 
0: 
1:     ActiveMQMessage convertMessage(PUBLISH command) throws JMSException {
1:         msg.setProducerId(producerId);
0:         MessageId id = new MessageId(producerId, messageIdGenerator.getNextSequenceId());
1:         msg.setMessageId(id);
1:         msg.setTimestamp(System.currentTimeMillis());
1:         msg.setPriority((byte) Message.DEFAULT_PRIORITY);
0:         msg.setPersistent(command.qos() != QoS.AT_MOST_ONCE);
1:         msg.setIntProperty(QOS_PROPERTY_NAME, command.qos().ordinal());
0: 
/////////////////////////////////////////////////////////////////////////
1:     public PUBLISH convertMessage(ActiveMQMessage message) throws IOException, JMSException, DataFormatException {
0:         short id = (short) message.getMessageId().getProducerSequenceId();
1:         QoS qoS;
1:         if (message.propertyExists(QOS_PROPERTY_NAME)) {
1:             int ordinal = message.getIntProperty(QOS_PROPERTY_NAME);
1:             qoS = QoS.values()[ordinal];
1:         } else {
1:             qoS = message.isPersistent() ? QoS.AT_MOST_ONCE : QoS.AT_LEAST_ONCE;
0:         }
1:         result.qos(qoS);
0: 
0:         UTF8Buffer topicName;
0:                 topicName = new UTF8Buffer(message.getDestination().getPhysicalName().replace('.', '/'));
0:         ByteSequence byteSequence = message.getContent();
1:         if (message.isCompressed()) {
0:             Inflater inflater = new Inflater();
1:             inflater.setInput(byteSequence.data, byteSequence.offset, byteSequence.length);
1:             byte[] data = new byte[4096];
0:             int read;
0:             ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
0:             while ((read = inflater.inflate(data, 0, data.length)) != 0) {
1:                 bytesOut.write(data, 0, read);
0:             }
0:             byteSequence = bytesOut.toByteSequence();
0:         }
1:         if (message.getDataStructureType() == ActiveMQTextMessage.DATA_STRUCTURE_TYPE) {
0:             if (byteSequence.getLength() > 4) {
0:                 byte[] content = new byte[byteSequence.getLength() - 4];
0:                 System.arraycopy(byteSequence.data, 4, content, 0, content.length);
0:                 result.payload(new Buffer(content));
/////////////////////////////////////////////////////////////////////////
1:             if (byteSequence != null && byteSequence.getLength() > 0) {
1:                 result.payload(new Buffer(byteSequence.data, byteSequence.offset, byteSequence.length));
0:             }
1:         return result;
/////////////////////////////////////////////////////////////////////////
0:     void configureInactivityMonitor(short heartBeat) {
/////////////////////////////////////////////////////////////////////////
1:             LOG.warn("Failed to start MQTT InactivityMonitor ", ex);
1:     void handleException(Throwable exception, MQTTFrame command) {
/////////////////////////////////////////////////////////////////////////
1:     void checkConnected() throws MQTTProtocolException {
1:         if (!connected.get()) {
1:             throw new MQTTProtocolException("Not connected.");
0:         }
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:     ResponseHandler createResponseHandler(final PUBLISH command) {
0: 
1:         if (command != null) {
0:             switch (command.qos()) {
0:                 case AT_LEAST_ONCE:
0:                     return new ResponseHandler() {
0:                         public void onResponse(MQTTProtocolConverter converter, Response response) throws IOException {
1:                             if (response.isException()) {
0:                                 LOG.warn("Failed to send MQTT Publish: ", command, ((ExceptionResponse) response).getException());
0:                             } else {
0:                                 PUBACK ack = new PUBACK();
0:                                 ack.messageId(command.messageId());
0:                                 converter.getMQTTTransport().sendToMQTT(ack.encode());
0:                             }
0:                         }
0:                     };
0:                 case EXACTLY_ONCE:
0:                     return new ResponseHandler() {
0:                         public void onResponse(MQTTProtocolConverter converter, Response response) throws IOException {
1:                             if (response.isException()) {
0:                                 LOG.warn("Failed to send MQTT Publish: ", command, ((ExceptionResponse) response).getException());
0:                             } else {
0:                                 PUBACK ack = new PUBACK();
0:                                 ack.messageId(command.messageId());
0:                                 converter.getMQTTTransport().sendToMQTT(ack.encode());
0:                             }
0:                         }
0:                     };
0:                 case AT_MOST_ONCE:
0:                     break;
0:             }
0:         }
0:         /*
0:         final String receiptId = command.getHeaders().get(Stomp.Headers.RECEIPT_REQUESTED);
0:         if (receiptId != null) {
0:             return new ResponseHandler() {
0:                 public void onResponse(ProtocolConverter converter, Response response) throws IOException {
1:                     if (response.isException()) {
0:                         // Generally a command can fail.. but that does not invalidate the connection.
0:                         // We report back the failure but we don't close the connection.
0:                         Throwable exception = ((ExceptionResponse)response).getException();
0:                         handleException(exception, command);
0:                     } else {
0:                         StompFrame sc = new StompFrame();
0:                         sc.setAction(Stomp.Responses.RECEIPT);
0:                         sc.setHeaders(new HashMap<String, String>(1));
0:                         sc.getHeaders().put(Stomp.Headers.Response.RECEIPT_ID, receiptId);
0:                         stompTransport.sendToStomp(sc);
0:                     }
0:                 }
0:             };
0:         }
1:         */
1:         return null;
0:     }
0: 
0:     private String convertMQTTToActiveMQ(String name) {
0:         String result = name.replace('>', '#');
0:         result = result.replace('*', '+');
0:         result = result.replace('.', '/');
0:         return result;
0:     }
commit:cfc6917
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport.mqtt;
0: 
0: import java.io.BufferedReader;
1: import java.io.IOException;
0: import java.io.InputStream;
0: import java.io.InputStreamReader;
1: import java.util.Map;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.atomic.AtomicBoolean;
0: 
1: import javax.jms.Destination;
1: import javax.jms.JMSException;
0: import org.apache.activemq.broker.BrokerContext;
0: import org.apache.activemq.command.*;
0: import org.apache.activemq.transport.stomp.FrameTranslator;
0: import org.apache.activemq.transport.stomp.LegacyFrameTranslator;
0: import org.apache.activemq.transport.stomp.ProtocolException;
0: import org.apache.activemq.transport.stomp.StompSubscription;
1: import org.apache.activemq.util.ByteSequence;
0: import org.apache.activemq.util.FactoryFinder;
1: import org.apache.activemq.util.IOExceptionSupport;
1: import org.apache.activemq.util.IdGenerator;
1: import org.apache.activemq.util.LRUCache;
1: import org.apache.activemq.util.LongSequenceGenerator;
1: import org.fusesource.hawtbuf.Buffer;
1: import org.fusesource.hawtbuf.UTF8Buffer;
0: import org.fusesource.mqtt.codec.CONNACK;
0: import org.fusesource.mqtt.codec.CONNECT;
0: import org.fusesource.mqtt.codec.DISCONNECT;
0: import org.fusesource.mqtt.codec.MQTTFrame;
0: import org.fusesource.mqtt.codec.PINGREQ;
0: import org.fusesource.mqtt.codec.PINGRESP;
0: import org.fusesource.mqtt.codec.PUBLISH;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
0: 
0: class MQTTProtocolConverter {
0: 
1:     private static final Logger LOG = LoggerFactory.getLogger(MQTTProtocolConverter.class);
0: 
1:     private static final IdGenerator CONNECTION_ID_GENERATOR = new IdGenerator();
0: 
0:     private static final String BROKER_VERSION;
1:     private static final MQTTFrame PING_RESP_FRAME = new PINGRESP().encode();
0: 
0:     static {
0:         InputStream in = null;
0:         String version = "5.6.0";
0:         if ((in = MQTTProtocolConverter.class.getResourceAsStream("/org/apache/activemq/version.txt")) != null) {
0:             BufferedReader reader = new BufferedReader(new InputStreamReader(in));
0:             try {
0:                 version = reader.readLine();
0:             } catch (Exception e) {
0:             }
0:         }
0:         BROKER_VERSION = version;
0:     }
0: 
1:     private final ConnectionId connectionId = new ConnectionId(CONNECTION_ID_GENERATOR.generateId());
1:     private final SessionId sessionId = new SessionId(connectionId, -1);
1:     private final ProducerId producerId = new ProducerId(sessionId, 1);
0: 
0:     private final LongSequenceGenerator consumerIdGenerator = new LongSequenceGenerator();
0:     private final LongSequenceGenerator messageIdGenerator = new LongSequenceGenerator();
0:     private final LongSequenceGenerator transactionIdGenerator = new LongSequenceGenerator();
0:     private final LongSequenceGenerator tempDestinationGenerator = new LongSequenceGenerator();
0: 
0:     private final ConcurrentHashMap<Integer, ResponseHandler> resposeHandlers = new ConcurrentHashMap<Integer, ResponseHandler>();
0:     private final ConcurrentHashMap<ConsumerId, StompSubscription> subscriptionsByConsumerId = new ConcurrentHashMap<ConsumerId, StompSubscription>();
0:     private final ConcurrentHashMap<String, StompSubscription> subscriptions = new ConcurrentHashMap<String, StompSubscription>();
0:     private final ConcurrentHashMap<String, ActiveMQDestination> tempDestinations = new ConcurrentHashMap<String, ActiveMQDestination>();
0:     private final ConcurrentHashMap<String, String> tempDestinationAmqToStompMap = new ConcurrentHashMap<String, String>();
0:     private final Map<String, LocalTransactionId> transactions = new ConcurrentHashMap<String, LocalTransactionId>();
0:     private final Map<UTF8Buffer, ActiveMQTopic> activeMQTopicMap = new LRUCache<UTF8Buffer, ActiveMQTopic>();
0:     private final Map<Destination, UTF8Buffer> mqttTopicMap = new LRUCache<Destination, UTF8Buffer>();
1:     private final MQTTTransport mqttTransport;
0: 
1:     private final Object commnadIdMutex = new Object();
1:     private int lastCommandId;
1:     private final AtomicBoolean connected = new AtomicBoolean(false);
0:     private final FrameTranslator frameTranslator = new LegacyFrameTranslator();
0:     private final FactoryFinder FRAME_TRANSLATOR_FINDER = new FactoryFinder("META-INF/services/org/apache/activemq/transport/frametranslator/");
0:     private final BrokerContext brokerContext;
0:     private String version = "1.0";
0:     ConnectionInfo connectionInfo = new ConnectionInfo();
1:     private CONNECT connect;
1:     private String clientId;
0: 
0:     public MQTTProtocolConverter(MQTTTransport mqttTransport, BrokerContext brokerContext) {
1:         this.mqttTransport = mqttTransport;
0:         this.brokerContext = brokerContext;
0:     }
0: 
0:     protected int generateCommandId() {
1:         synchronized (commnadIdMutex) {
1:             return lastCommandId++;
0:         }
0:     }
0: 
0: 
0:     protected void sendToActiveMQ(Command command, ResponseHandler handler) {
1:         command.setCommandId(generateCommandId());
0:         if (handler != null) {
1:             command.setResponseRequired(true);
0:             resposeHandlers.put(Integer.valueOf(command.getCommandId()), handler);
0:         }
0:         mqttTransport.sendToActiveMQ(command);
0:     }
0: 
0: 
1:     /**
1:      * Convert a MQTT command
1:      */
1:     public void onMQTTCommand(MQTTFrame frame) throws IOException, JMSException {
0: 
0: 
1:         switch (frame.messageType()) {
0:             case PINGREQ.TYPE: {
0:                 mqttTransport.sendToMQTT(PING_RESP_FRAME);
1:                 LOG.debug("Sent Ping Response to " + getClientId());
0:                 break;
0:             }
0:             case CONNECT.TYPE: {
0:                 onMQTTConnect(new CONNECT().decode(frame));
0:                 break;
0:             }
0:             case DISCONNECT.TYPE: {
0:                 LOG.debug("MQTT Client " + getClientId() + " disconnecting");
1:                 stopTransport();
0:                 break;
0:             }
0:             default:
1:                 handleException(new MQTTProtocolException("Unknown MQTTFrame type: " + frame.messageType(), true), frame);
0:         }
0: 
0:     }
0: 
0: 
0:     protected void onMQTTConnect(final CONNECT connect) throws ProtocolException {
0: 
1:         if (connected.get()) {
0:             throw new ProtocolException("All ready connected.");
0:         }
1:         this.connect = connect;
0: 
1:         String clientId = "";
1:         if (connect.clientId() != null) {
1:             clientId = connect.clientId().toString();
0:         }
0: 
0:         String userName = "";
1:         if (connect.userName() != null) {
1:             userName = connect.userName().toString();
0:         }
0:         String passswd = "";
1:         if (connect.password() != null) {
1:             passswd = connect.password().toString();
0: 
0:         }
0: 
0: 
1:         configureInactivityMonitor(connect.keepAlive());
0: 
0: 
1:         connectionInfo.setConnectionId(connectionId);
0:         if (clientId != null && clientId.isEmpty() == false) {
1:             connectionInfo.setClientId(clientId);
0:         } else {
1:             connectionInfo.setClientId("" + connectionInfo.getConnectionId().toString());
0:         }
0: 
1:         connectionInfo.setResponseRequired(true);
1:         connectionInfo.setUserName(userName);
1:         connectionInfo.setPassword(passswd);
1:         connectionInfo.setTransportContext(mqttTransport.getPeerCertificates());
0: 
1:         sendToActiveMQ(connectionInfo, new ResponseHandler() {
0:             public void onResponse(MQTTProtocolConverter converter, Response response) throws IOException {
0: 
0:                 if (response.isException()) {
1:                     // If the connection attempt fails we close the socket.
1:                     Throwable exception = ((ExceptionResponse) response).getException();
1:                     //let the client know
1:                     CONNACK ack = new CONNACK();
0:                     ack.code(CONNACK.Code.CONNECTION_REFUSED_SERVER_UNAVAILABLE);
1:                     getMQTTTransport().sendToMQTT(ack.encode());
1:                     getMQTTTransport().onException(IOExceptionSupport.create(exception));
0:                     return;
0:                 }
0: 
1:                 final SessionInfo sessionInfo = new SessionInfo(sessionId);
1:                 sendToActiveMQ(sessionInfo, null);
0: 
1:                 final ProducerInfo producerInfo = new ProducerInfo(producerId);
1:                 sendToActiveMQ(producerInfo, new ResponseHandler() {
0:                     public void onResponse(MQTTProtocolConverter converter, Response response) throws IOException {
0: 
0:                         if (response.isException()) {
1:                             // If the connection attempt fails we close the socket.
1:                             Throwable exception = ((ExceptionResponse) response).getException();
1:                             CONNACK ack = new CONNACK();
1:                             ack.code(CONNACK.Code.CONNECTION_REFUSED_BAD_USERNAME_OR_PASSWORD);
1:                             getMQTTTransport().sendToMQTT(ack.encode());
1:                             getMQTTTransport().onException(IOExceptionSupport.create(exception));
0:                         }
0: 
1:                         CONNACK ack = new CONNACK();
1:                         ack.code(CONNACK.Code.CONNECTION_ACCEPTED);
1:                         getMQTTTransport().sendToMQTT(ack.encode());
0: 
0:                     }
0:                 });
0: 
0:             }
0:         });
0:     }
0: 
0: 
1:     /**
0:      * Dispatch a ActiveMQ command
1:      */
0: 
0: 
0:     public void onActiveMQCommand(Command command) throws IOException, JMSException {
1:         if (command.isResponse()) {
1:             Response response = (Response) command;
1:             ResponseHandler rh = resposeHandlers.remove(Integer.valueOf(response.getCorrelationId()));
1:             if (rh != null) {
1:                 rh.onResponse(this, response);
0:             } else {
1:                 // Pass down any unexpected errors. Should this close the connection?
0:                 if (response.isException()) {
1:                     Throwable exception = ((ExceptionResponse) response).getException();
1:                     handleException(exception, null);
0:                 }
0:             }
1:         } else if (command.isMessageDispatch()) {
1:             MessageDispatch md = (MessageDispatch) command;
0:             StompSubscription sub = subscriptionsByConsumerId.get(md.getConsumerId());
1:             if (sub != null) {
0:                 //sub.onMessageDispatch(md);
0:             }
1:         } else if (command.getDataStructureType() == ConnectionError.DATA_STRUCTURE_TYPE) {
1:             // Pass down any unexpected async errors. Should this close the connection?
1:             Throwable exception = ((ConnectionError) command).getException();
1:             handleException(exception, null);
0:         } else {
0:             LOG.debug("Do not know how to process ActiveMQ Command " + command);
0:         }
0:     }
0: 
0: 
0:     public ActiveMQMessage convertMessage(PUBLISH command) throws IOException, JMSException {
1:         ActiveMQBytesMessage msg = new ActiveMQBytesMessage();
0:         StringBuilder msgId = new StringBuilder();
0:         msgId.append("ID:").append(getClientId()).append(":").append(command.messageId());
0:         msg.setJMSMessageID(msgId.toString());
0:         msg.setJMSPriority(4);
0: 
0:         //ActiveMQTopic topic = new ActiveMQTopic(topicName);
0:         ActiveMQTopic topic = null;
0:         synchronized (activeMQTopicMap) {
0:             topic = activeMQTopicMap.get(command.topicName());
0:             if (topic == null) {
0:                 String topicName = command.topicName().toString().replaceAll("/", ".");
0:                 topic = new ActiveMQTopic(topicName);
0:                 activeMQTopicMap.put(command.topicName(), topic);
0:             }
0:         }
0:         msg.setJMSDestination(topic);
1:         msg.writeBytes(command.payload().data, command.payload().offset, command.payload().length);
1:         return msg;
0:     }
0: 
0:     public MQTTFrame convertMessage(ActiveMQMessage message) throws IOException, JMSException {
1:         PUBLISH result = new PUBLISH();
0:         String msgId = message.getJMSMessageID();
0:         int offset = msgId.lastIndexOf(':');
0: 
0:         short id = 0;
0:         if (offset > 0) {
0:             Short.parseShort(msgId.substring(offset, msgId.length() - 1));
0:         }
0:         result.messageId(id);
0: 
0:         UTF8Buffer topicName = null;
1:         synchronized (mqttTopicMap) {
0:             topicName = mqttTopicMap.get(message.getJMSDestination());
1:             if (topicName == null) {
0:                 topicName = new UTF8Buffer(message.getDestination().getPhysicalName().replaceAll(".", "/"));
0:                 mqttTopicMap.put(message.getJMSDestination(), topicName);
0:             }
0:         }
0:         result.topicName(topicName);
0: 
0:         if (message.getDataStructureType() == ActiveMQTextMessage.DATA_STRUCTURE_TYPE) {
0: 
0:             if (!message.isCompressed() && message.getContent() != null) {
0:                 ByteSequence msgContent = message.getContent();
0:                 if (msgContent.getLength() > 4) {
0:                     byte[] content = new byte[msgContent.getLength() - 4];
0:                     System.arraycopy(msgContent.data, 4, content, 0, content.length);
0:                     result.payload(new Buffer(content));
0:                 }
0:             } else {
1:                 ActiveMQTextMessage msg = (ActiveMQTextMessage) message.copy();
1:                 String messageText = msg.getText();
1:                 if (messageText != null) {
0:                     result.payload(new Buffer(msg.getText().getBytes("UTF-8")));
0:                 }
0:             }
0: 
1:         } else if (message.getDataStructureType() == ActiveMQBytesMessage.DATA_STRUCTURE_TYPE) {
0: 
1:             ActiveMQBytesMessage msg = (ActiveMQBytesMessage) message.copy();
1:             msg.setReadOnlyBody(true);
1:             byte[] data = new byte[(int) msg.getBodyLength()];
1:             msg.readBytes(data);
1:             result.payload(new Buffer(data));
0:         } else {
0:             LOG.debug("Cannot convert " + message + " to a MQTT PUBLISH");
0:         }
0:         return result.encode();
0:     }
0: 
0: 
1:     public MQTTTransport getMQTTTransport() {
1:         return mqttTransport;
0:     }
0: 
0:     public ActiveMQDestination createTempDestination(String name, boolean topic) {
0:         ActiveMQDestination rc = tempDestinations.get(name);
0:         if (rc == null) {
0:             if (topic) {
0:                 rc = new ActiveMQTempTopic(connectionId, tempDestinationGenerator.getNextSequenceId());
0:             } else {
0:                 rc = new ActiveMQTempQueue(connectionId, tempDestinationGenerator.getNextSequenceId());
0:             }
0:             sendToActiveMQ(new DestinationInfo(connectionId, DestinationInfo.ADD_OPERATION_TYPE, rc), null);
0:             tempDestinations.put(name, rc);
0:             tempDestinationAmqToStompMap.put(rc.getQualifiedName(), name);
0:         }
0:         return rc;
0:     }
0: 
0:     public String getCreatedTempDestinationName(ActiveMQDestination destination) {
0:         return tempDestinationAmqToStompMap.get(destination.getQualifiedName());
0:     }
0: 
0: 
0:     protected void configureInactivityMonitor(short heartBeat) throws ProtocolException {
0:         try {
0: 
0:             int heartBeatMS = heartBeat * 1000;
0:             MQTTInactivityMonitor monitor = getMQTTTransport().getInactivityMonitor();
0: 
0:             monitor.setReadCheckTime(heartBeatMS);
0:             monitor.setInitialDelayTime(heartBeatMS);
0: 
0:             monitor.startMonitorThread();
0: 
1:         } catch (Exception ex) {
0: 
0:         }
0: 
0:         LOG.debug(getClientId() + " MQTT Connection using heart beat of  " + heartBeat + " secs");
0:     }
0: 
0: 
0:     protected void handleException(Throwable exception, MQTTFrame command) throws IOException {
1:         LOG.warn("Exception occurred processing: \n" + command + ": " + exception.toString());
0:         if (LOG.isDebugEnabled()) {
0:             LOG.debug("Exception detail", exception);
0:         }
0: 
0:         try {
1:             getMQTTTransport().stop();
0:         } catch (Throwable e) {
0:             LOG.error("Failed to stop MQTTT Transport ", e);
0:         }
0:     }
0: 
0:     private String getClientId() {
0:         if (clientId == null) {
0:             if (connect != null && connect.clientId() != null) {
1:                 clientId = connect.clientId().toString();
0:             }
0:         } else {
0:             clientId = "";
0:         }
0:         return clientId;
0:     }
0: 
1:     private void stopTransport() {
0:         try {
1:             getMQTTTransport().stop();
0:         } catch (Throwable e) {
1:             LOG.debug("Failed to stop MQTT transport ", e);
0:         }
0:     }
0: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:33ec1cf
/////////////////////////////////////////////////////////////////////////
1: public class MQTTProtocolConverter {
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:3845c7c
/////////////////////////////////////////////////////////////////////////
0:             consumerInfo.setSubscriptionName(
0:                 connect.clientId().toString() + topic.name().toString());
commit:7b5f956
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ShutdownInfo;
/////////////////////////////////////////////////////////////////////////
1:     private final ConnectionInfo connectionInfo = new ConnectionInfo();
/////////////////////////////////////////////////////////////////////////
1:                 onMQTTDisconnect();
/////////////////////////////////////////////////////////////////////////
0:             @Override
/////////////////////////////////////////////////////////////////////////
0:                     @Override
/////////////////////////////////////////////////////////////////////////
1:     void onMQTTDisconnect() throws MQTTProtocolException {
0:         if (connected.get()) {
1:             sendToActiveMQ(connectionInfo.createRemoveCommand(), null);
1:             sendToActiveMQ(new ShutdownInfo(), null);
0:         }
0:         stopTransport();
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:                     bytesOut.close();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                         @Override
/////////////////////////////////////////////////////////////////////////
0:                         @Override
commit:2ad13d6
/////////////////////////////////////////////////////////////////////////
0: 
0: import org.apache.activemq.command.ActiveMQBytesMessage;
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQMapMessage;
0: import org.apache.activemq.command.ActiveMQMessage;
0: import org.apache.activemq.command.ActiveMQTextMessage;
0: import org.apache.activemq.command.ActiveMQTopic;
0: import org.apache.activemq.command.Command;
0: import org.apache.activemq.command.ConnectionError;
0: import org.apache.activemq.command.ConnectionId;
0: import org.apache.activemq.command.ConnectionInfo;
0: import org.apache.activemq.command.ConsumerId;
0: import org.apache.activemq.command.ConsumerInfo;
0: import org.apache.activemq.command.ExceptionResponse;
0: import org.apache.activemq.command.MessageAck;
0: import org.apache.activemq.command.MessageDispatch;
0: import org.apache.activemq.command.MessageId;
0: import org.apache.activemq.command.ProducerId;
0: import org.apache.activemq.command.ProducerInfo;
0: import org.apache.activemq.command.RemoveInfo;
0: import org.apache.activemq.command.Response;
0: import org.apache.activemq.command.SessionId;
0: import org.apache.activemq.command.SessionInfo;
/////////////////////////////////////////////////////////////////////////
0: import org.fusesource.mqtt.codec.CONNACK;
0: import org.fusesource.mqtt.codec.CONNECT;
0: import org.fusesource.mqtt.codec.DISCONNECT;
0: import org.fusesource.mqtt.codec.MQTTFrame;
0: import org.fusesource.mqtt.codec.PINGREQ;
0: import org.fusesource.mqtt.codec.PINGRESP;
0: import org.fusesource.mqtt.codec.PUBACK;
0: import org.fusesource.mqtt.codec.PUBCOMP;
0: import org.fusesource.mqtt.codec.PUBLISH;
0: import org.fusesource.mqtt.codec.PUBREC;
0: import org.fusesource.mqtt.codec.PUBREL;
0: import org.fusesource.mqtt.codec.SUBACK;
0: import org.fusesource.mqtt.codec.SUBSCRIBE;
0: import org.fusesource.mqtt.codec.UNSUBACK;
0: import org.fusesource.mqtt.codec.UNSUBSCRIBE;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             default: {
0:             }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             ActiveMQTextMessage msg = (ActiveMQTextMessage) message.copy();
0:             msg.setReadOnlyBody(true);
0:             String messageText = msg.getText();
0:             if (messageText != null) {
0:                 result.payload(new Buffer(messageText.getBytes("UTF-8")));
0:             }
1:         } else if (message.getDataStructureType() == ActiveMQMapMessage.DATA_STRUCTURE_TYPE) {
1:             Map<String, Object> map = msg.getContentMap();
1:             if (map != null) {
0:         } else {
0:                 if (message.isCompressed()) {
0:                     inflater.setInput(byteSequence.data, byteSequence.offset, byteSequence.length);
0:                     byte[] data = new byte[4096];
1:                     while ((read = inflater.inflate(data)) != 0) {
0:                         bytesOut.write(data, 0, read);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:c5cf038
============================================================================