1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:cfcd4f7:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:cfcd4f7:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.broker;
1:1f521da: 
1:2280719: import java.io.IOException;
1:2280719: import java.net.URI;
1:2280719: import java.net.URISyntaxException;
1:2280719: import java.util.LinkedList;
1:2280719: import java.util.StringTokenizer;
1:2280719: import java.util.concurrent.CopyOnWriteArrayList;
1:2280719: import java.util.regex.Pattern;
1:a3060e7: 
1:2280719: import javax.management.ObjectName;
1:6f2ac63: 
1:d29ca2a: import org.apache.activemq.broker.jmx.ManagedTransportConnector;
1:1ec71bd: import org.apache.activemq.broker.jmx.ManagementContext;
1:d29ca2a: import org.apache.activemq.broker.region.ConnectorStatistics;
1:d29ca2a: import org.apache.activemq.command.BrokerInfo;
1:f392884: import org.apache.activemq.command.ConnectionControl;
1:a640ff5: import org.apache.activemq.security.MessageAuthorizationPolicy;
1:d29ca2a: import org.apache.activemq.thread.TaskRunnerFactory;
1:a4be10c: import org.apache.activemq.transport.Transport;
1:a4be10c: import org.apache.activemq.transport.TransportAcceptListener;
1:a4be10c: import org.apache.activemq.transport.TransportFactorySupport;
1:a4be10c: import org.apache.activemq.transport.TransportServer;
1:d29ca2a: import org.apache.activemq.transport.discovery.DiscoveryAgent;
1:d29ca2a: import org.apache.activemq.transport.discovery.DiscoveryAgentFactory;
1:d29ca2a: import org.apache.activemq.util.ServiceStopper;
1:7e672d4: import org.apache.activemq.util.ServiceSupport;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:2280719: 
1:d29ca2a: /**
1:68d245f:  * @org.apache.xbean.XBean
1:d29ca2a:  */
1:3910056: public class TransportConnector implements Connector, BrokerServiceAware {
1:4d3af76: 
1:8bf987b:     final Logger LOG = LoggerFactory.getLogger(TransportConnector.class);
1:a3060e7: 
1:6f2ac63:     protected final CopyOnWriteArrayList<TransportConnection> connections = new CopyOnWriteArrayList<TransportConnection>();
1:ecf89a6:     protected TransportStatusDetector statusDector;
1:3910056:     private BrokerService brokerService;
1:d29ca2a:     private TransportServer server;
1:d29ca2a:     private URI uri;
1:d29ca2a:     private BrokerInfo brokerInfo = new BrokerInfo();
1:230a86c:     private TaskRunnerFactory taskRunnerFactory;
1:a640ff5:     private MessageAuthorizationPolicy messageAuthorizationPolicy;
1:d29ca2a:     private DiscoveryAgent discoveryAgent;
1:f392884:     private final ConnectorStatistics statistics = new ConnectorStatistics();
1:d29ca2a:     private URI discoveryUri;
1:b2ad8fa:     private String name;
1:230a86c:     private boolean disableAsyncDispatch;
1:e58dfee:     private boolean enableStatusMonitor = false;
1:5d99c99:     private Broker broker;
1:efd6bda:     private boolean updateClusterClients = false;
1:f392884:     private boolean rebalanceClusterClients;
1:be55d0a:     private boolean updateClusterClientsOnRemove = false;
1:dc0f5b3:     private String updateClusterFilter;
1:49718ed:     private boolean auditNetworkProducers = false;
1:74bed6b:     private int maximumProducersAllowedPerConnection = Integer.MAX_VALUE;
1:74bed6b:     private int maximumConsumersAllowedPerConnection  = Integer.MAX_VALUE;
1:a4be10c:     private PublishedAddressPolicy publishedAddressPolicy = new PublishedAddressPolicy();
1:16c1627:     private boolean allowLinkStealing;
1:beda82a: 
1:2280719:     LinkedList<String> peerBrokers = new LinkedList<String>();
1:1f521da: 
1:230a86c:     public TransportConnector() {
1:a3060e7:     }
1:4d3af76: 
1:5d99c99:     public TransportConnector(TransportServer server) {
1:d29ca2a:         this();
1:d29ca2a:         setServer(server);
1:230a86c:         if (server != null && server.getConnectURI() != null) {
1:a7b9e8c:             URI uri = server.getConnectURI();
1:230a86c:             if (uri != null && uri.getScheme().equals("vm")) {
1:a7b9e8c:                 setEnableStatusMonitor(false);
1:47d1985:             }
1:230a86c:         }
1:230a86c:     }
1:6f2ac63: 
1:ecf89a6:     /**
1:ecf89a6:      * @return Returns the connections.
1:ecf89a6:      */
1:ecf89a6:     public CopyOnWriteArrayList<TransportConnection> getConnections() {
1:ecf89a6:         return connections;
1:ecf89a6:     }
1:6f2ac63: 
1:d29ca2a:     /**
1:230a86c:      * Factory method to create a JMX managed version of this transport
1:230a86c:      * connector
1:d29ca2a:      */
1:6f2ac63:     public ManagedTransportConnector asManagedConnector(ManagementContext context, ObjectName connectorName) throws IOException, URISyntaxException {
1:1ec71bd:         ManagedTransportConnector rc = new ManagedTransportConnector(context, connectorName, getServer());
1:a28ccae:         rc.setBrokerInfo(getBrokerInfo());
1:a28ccae:         rc.setDisableAsyncDispatch(isDisableAsyncDispatch());
1:a28ccae:         rc.setDiscoveryAgent(getDiscoveryAgent());
1:a28ccae:         rc.setDiscoveryUri(getDiscoveryUri());
1:a28ccae:         rc.setEnableStatusMonitor(isEnableStatusMonitor());
1:a28ccae:         rc.setMessageAuthorizationPolicy(getMessageAuthorizationPolicy());
1:a28ccae:         rc.setName(getName());
1:523ea5f:         rc.setTaskRunnerFactory(getTaskRunnerFactory());
1:a28ccae:         rc.setUri(getUri());
1:5d99c99:         rc.setBrokerService(brokerService);
1:f392884:         rc.setUpdateClusterClients(isUpdateClusterClients());
1:f392884:         rc.setRebalanceClusterClients(isRebalanceClusterClients());
1:55c3ef9:         rc.setUpdateClusterFilter(getUpdateClusterFilter());
1:55c3ef9:         rc.setUpdateClusterClientsOnRemove(isUpdateClusterClientsOnRemove());
1:49718ed:         rc.setAuditNetworkProducers(isAuditNetworkProducers());
1:74bed6b:         rc.setMaximumConsumersAllowedPerConnection(getMaximumConsumersAllowedPerConnection());
1:74bed6b:         rc.setMaximumProducersAllowedPerConnection(getMaximumProducersAllowedPerConnection());
1:a4be10c:         rc.setPublishedAddressPolicy(getPublishedAddressPolicy());
1:47d1985:         rc.setAllowLinkStealing(isAllowLinkStealing());
1:523ea5f:         return rc;
1:d29ca2a:     }
1:6f2ac63: 
1:a4be10c:     @Override
1:d29ca2a:     public BrokerInfo getBrokerInfo() {
1:d29ca2a:         return brokerInfo;
1:d29ca2a:     }
1:a3060e7: 
1:d29ca2a:     public void setBrokerInfo(BrokerInfo brokerInfo) {
1:d29ca2a:         this.brokerInfo = brokerInfo;
1:d29ca2a:     }
1:a3060e7: 
1:d29ca2a:     public TransportServer getServer() throws IOException, URISyntaxException {
1:d29ca2a:         if (server == null) {
1:d29ca2a:             setServer(createTransportServer());
1:d29ca2a:         }
1:d29ca2a:         return server;
1:d29ca2a:     }
1:5d99c99: 
1:d29ca2a:     public void setServer(TransportServer server) {
1:d29ca2a:         this.server = server;
1:d29ca2a:     }
1:5d99c99: 
1:d29ca2a:     public URI getUri() {
1:d29ca2a:         if (uri == null) {
1:3a7c673:             try {
1:064880b:                 uri = getConnectUri();
1:064880b:             } catch (Throwable e) {
1:064880b:             }
1:064880b:         }
1:d29ca2a:         return uri;
1:d29ca2a:     }
1:5d99c99: 
1:7fed5d8:     /**
1:d29ca2a:      * Sets the server transport URI to use if there is not a
1:d29ca2a:      * {@link TransportServer} configured via the
1:d29ca2a:      * {@link #setServer(TransportServer)} method. This value is used to lazy
1:d29ca2a:      * create a {@link TransportServer} instance
1:cfcd4f7:      *
1:d29ca2a:      * @param uri
1:7fed5d8:      */
1:d29ca2a:     public void setUri(URI uri) {
1:d29ca2a:         this.uri = uri;
1:d29ca2a:     }
1:ecf89a6: 
1:d29ca2a:     public TaskRunnerFactory getTaskRunnerFactory() {
1:d29ca2a:         return taskRunnerFactory;
1:d29ca2a:     }
1:ecf89a6: 
1:d29ca2a:     public void setTaskRunnerFactory(TaskRunnerFactory taskRunnerFactory) {
1:d29ca2a:         this.taskRunnerFactory = taskRunnerFactory;
1:d29ca2a:     }
1:ecf89a6: 
1:d29ca2a:     /**
1:d29ca2a:      * @return the statistics for this connector
1:d29ca2a:      */
1:a4be10c:     @Override
1:d29ca2a:     public ConnectorStatistics getStatistics() {
1:d29ca2a:         return statistics;
1:d29ca2a:     }
1:230a86c: 
1:a640ff5:     public MessageAuthorizationPolicy getMessageAuthorizationPolicy() {
1:a640ff5:         return messageAuthorizationPolicy;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     /**
1:230a86c:      * Sets the policy used to decide if the current connection is authorized to
1:230a86c:      * consume a given message
1:d29ca2a:      */
1:a640ff5:     public void setMessageAuthorizationPolicy(MessageAuthorizationPolicy messageAuthorizationPolicy) {
1:a640ff5:         this.messageAuthorizationPolicy = messageAuthorizationPolicy;
1:d29ca2a:     }
1:230a86c: 
1:a4be10c:     @Override
1:d29ca2a:     public void start() throws Exception {
1:5d99c99:         broker = brokerService.getBroker();
1:5d99c99:         brokerInfo.setBrokerName(broker.getBrokerName());
1:5d99c99:         brokerInfo.setBrokerId(broker.getBrokerId());
1:5d99c99:         brokerInfo.setPeerBrokerInfos(broker.getPeerBrokerInfos());
1:5d99c99:         brokerInfo.setFaultTolerantConfiguration(broker.isFaultTolerantConfiguration());
1:91059de:         brokerInfo.setBrokerURL(broker.getBrokerService().getDefaultSocketURIString());
1:475eedc:         getServer().setAcceptListener(new TransportAcceptListener() {
1:a4be10c:             @Override
1:5d99c99:             public void onAccept(final Transport transport) {
1:5d99c99:                 try {
1:8a01c5d:                     brokerService.getTaskRunnerFactory().execute(new Runnable() {
1:a4be10c:                         @Override
1:5d99c99:                         public void run() {
1:5d99c99:                             try {
1:c6fe94e:                                 if (!brokerService.isStopping()) {
1:c6fe94e:                                     Connection connection = createConnection(transport);
1:c6fe94e:                                     connection.start();
1:c6fe94e:                                 } else {
1:c6fe94e:                                     throw new BrokerStoppedException("Broker " + brokerService + " is being stopped");
1:c6fe94e:                                 }
1:5d99c99:                             } catch (Exception e) {
1:cfcd4f7:                                 String remoteHost = transport.getRemoteAddress();
1:5d99c99:                                 ServiceSupport.dispose(transport);
1:cfcd4f7:                                 onAcceptError(e, remoteHost);
1:5d99c99:                             }
1:5d99c99:                         }
1:1f521da:                     });
1:5d99c99:                 } catch (Exception e) {
1:5d99c99:                     String remoteHost = transport.getRemoteAddress();
1:5d99c99:                     ServiceSupport.dispose(transport);
1:5d99c99:                     onAcceptError(e, remoteHost);
1:5d99c99:                 }
1:5d99c99:             }
1:5d99c99: 
1:a4be10c:             @Override
1:5d99c99:             public void onAcceptError(Exception error) {
1:5d99c99:                 onAcceptError(error, null);
1:5d99c99:             }
1:5d99c99: 
1:5d99c99:             private void onAcceptError(Exception error, String remoteHost) {
1:f9682b8:                 if (brokerService != null && brokerService.isStopping()) {
1:f9682b8:                     LOG.info("Could not accept connection during shutdown {} : {}", (remoteHost == null ? "" : "from " + remoteHost), error);
1:f9682b8:                 } else {
1:f9682b8:                     LOG.error("Could not accept connection {} : {}", (remoteHost == null ? "" : "from " + remoteHost), error);
1:f9682b8:                     LOG.debug("Reason: " + error, error);
1:f9682b8:                 }
1:5d99c99:             }
1:5d99c99:         });
1:475eedc:         getServer().setBrokerInfo(brokerInfo);
1:d29ca2a:         getServer().start();
1:5d99c99: 
1:d29ca2a:         DiscoveryAgent da = getDiscoveryAgent();
1:230a86c:         if (da != null) {
1:bd1b10c:             da.registerService(getPublishableConnectString());
1:d29ca2a:             da.start();
1:3910056:         }
1:230a86c:         if (enableStatusMonitor) {
1:d29ca2a:             this.statusDector = new TransportStatusDetector(this);
1:d29ca2a:             this.statusDector.start();
1:3a7c673:         }
1:5d99c99: 
1:59af747:         LOG.info("Connector {} started", getName());
1:3a7c673:     }
1:230a86c: 
1:0ed0ba5:     public String getPublishableConnectString() throws Exception {
1:a4be10c:         String publishableConnectString = publishedAddressPolicy.getPublishableConnectString(this);
1:e1bbde7:         LOG.debug("Publishing: {} for broker transport URI: {}", publishableConnectString, getConnectUri());
1:bd1b10c:         return publishableConnectString;
1:4d3af76:     }
1:4d3af76: 
1:a3a22ef:     public URI getPublishableConnectURI() throws Exception {
1:a3a22ef:         return publishedAddressPolicy.getPublishableConnectURI(this);
1:a3a22ef:     }
1:a3a22ef: 
1:a4be10c:     @Override
1:d29ca2a:     public void stop() throws Exception {
1:d29ca2a:         ServiceStopper ss = new ServiceStopper();
1:230a86c:         if (discoveryAgent != null) {
1:d29ca2a:             ss.stop(discoveryAgent);
1:6bae959:         }
1:230a86c:         if (server != null) {
1:d29ca2a:             ss.stop(server);
1:d29ca2a:         }
1:230a86c:         if (this.statusDector != null) {
1:d29ca2a:             this.statusDector.stop();
1:d29ca2a:         }
1:230a86c: 
1:6f2ac63:         for (TransportConnection connection : connections) {
1:6f2ac63:             ss.stop(connection);
1:d29ca2a:         }
1:290f51a:         server = null;
1:d29ca2a:         ss.throwFirstException();
1:59af747:         LOG.info("Connector {} stopped", getName());
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     // Implementation methods
1:d29ca2a:     // -------------------------------------------------------------------------
1:d29ca2a:     protected Connection createConnection(Transport transport) throws IOException {
1:8a01c5d:         // prefer to use task runner from broker service as stop task runner, as we can then
1:8a01c5d:         // tie it to the lifecycle of the broker service
1:dc0f5b3:         TransportConnection answer = new TransportConnection(this, transport, broker, disableAsyncDispatch ? null
1:8a01c5d:                 : taskRunnerFactory, brokerService.getTaskRunnerFactory());
1:ccf3f3c:         boolean statEnabled = this.getStatistics().isEnabled();
1:ccf3f3c:         answer.getStatistics().setEnabled(statEnabled);
1:a640ff5:         answer.setMessageAuthorizationPolicy(messageAuthorizationPolicy);
1:a640ff5:         return answer;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     protected TransportServer createTransportServer() throws IOException, URISyntaxException {
1:230a86c:         if (uri == null) {
1:d29ca2a:             throw new IllegalArgumentException("You must specify either a server or uri property");
1:d29ca2a:         }
1:5d99c99:         if (brokerService == null) {
1:dc0f5b3:             throw new IllegalArgumentException(
1:dc0f5b3:                     "You must specify the brokerService property. Maybe this connector should be added to a broker?");
1:d29ca2a:         }
1:9a8f6e4:         return TransportFactorySupport.bind(brokerService, uri);
1:d29ca2a:     }
1:6bae959: 
1:d29ca2a:     public DiscoveryAgent getDiscoveryAgent() throws IOException {
1:230a86c:         if (discoveryAgent == null) {
1:d29ca2a:             discoveryAgent = createDiscoveryAgent();
1:d29ca2a:         }
1:d29ca2a:         return discoveryAgent;
1:d29ca2a:     }
17:d29ca2a: 
1:d29ca2a:     protected DiscoveryAgent createDiscoveryAgent() throws IOException {
1:230a86c:         if (discoveryUri != null) {
1:1b97cdd:             DiscoveryAgent agent = DiscoveryAgentFactory.createDiscoveryAgent(discoveryUri);
1:1b97cdd: 
1:6f2ac63:             if (agent != null && agent instanceof BrokerServiceAware) {
1:6f2ac63:                 ((BrokerServiceAware) agent).setBrokerService(brokerService);
1:1b97cdd:             }
1:1b97cdd: 
1:1b97cdd:             return agent;
1:d29ca2a:         }
1:d29ca2a:         return null;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public void setDiscoveryAgent(DiscoveryAgent discoveryAgent) {
1:d29ca2a:         this.discoveryAgent = discoveryAgent;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public URI getDiscoveryUri() {
1:d29ca2a:         return discoveryUri;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public void setDiscoveryUri(URI discoveryUri) {
1:d29ca2a:         this.discoveryUri = discoveryUri;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public URI getConnectUri() throws IOException, URISyntaxException {
1:fa29678:         if (server != null) {
1:fa29678:             return server.getConnectURI();
1:fa29678:         } else {
1:fa29678:             return uri;
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d2d1c6d:     public void onStarted(TransportConnection connection) {
1:d2d1c6d:         connections.add(connection);
1:d2d1c6d:     }
1:d2d1c6d: 
1:d2d1c6d:     public void onStopped(TransportConnection connection) {
1:d2d1c6d:         connections.remove(connection);
1:b2ad8fa:     }
1:d2d1c6d: 
1:230a86c:     public String getName() {
1:230a86c:         if (name == null) {
1:230a86c:             uri = getUri();
1:230a86c:             if (uri != null) {
1:230a86c:                 name = uri.toString();
1:230a86c:             }
1:e16114f:         }
1:b2ad8fa:         return name;
1:b2ad8fa:     }
1:230a86c: 
1:b2ad8fa:     public void setName(String name) {
1:b2ad8fa:         this.name = name;
1:b2ad8fa:     }
1:b2ad8fa: 
1:a4be10c:     @Override
1:e2aad41:     public String toString() {
1:e16114f:         String rc = getName();
1:ecf89a6:         if (rc == null) {
1:230a86c:             rc = super.toString();
1:ecf89a6:         }
1:e16114f:         return rc;
1:24d8986:     }
1:24d8986: 
1:f392884:     protected ConnectionControl getConnectionControl() {
1:f392884:         boolean rebalance = isRebalanceClusterClients();
1:dc0f5b3:         String connectedBrokers = "";
1:91059de:         String separator = "";
1:d29ca2a: 
1:0ed0ba5:         if (isUpdateClusterClients()) {
1:2280719:             synchronized (peerBrokers) {
1:2280719:                 for (String uri : getPeerBrokers()) {
1:2280719:                     connectedBrokers += separator + uri;
1:2280719:                     separator = ",";
1:2280719:                 }
1:2280719: 
1:2280719:                 if (rebalance) {
1:15affd0:                     String shuffle = peerBrokers.removeFirst();
1:15affd0:                     peerBrokers.addLast(shuffle);
1:beda82a:                 }
1:e2aad41:             }
1:d2d1c6d:         }
1:dc0f5b3:         ConnectionControl control = new ConnectionControl();
1:dc0f5b3:         control.setConnectedBrokers(connectedBrokers);
1:dc0f5b3:         control.setRebalanceConnection(rebalance);
1:dc0f5b3:         return control;
1:d29ca2a:     }
1:2280719: 
1:2280719:     public void addPeerBroker(BrokerInfo info) {
1:2280719:         if (isMatchesClusterFilter(info.getBrokerName())) {
1:2280719:             synchronized (peerBrokers) {
1:2280719:                 getPeerBrokers().addLast(info.getBrokerURL());
1:2280719:             }
1:2280719:         }
1:2280719:     }
1:2280719: 
1:2280719:     public void removePeerBroker(BrokerInfo info) {
1:2280719:         synchronized (peerBrokers) {
1:2280719:             getPeerBrokers().remove(info.getBrokerURL());
1:2280719:         }
1:2280719:     }
1:2280719: 
1:2280719:     public LinkedList<String> getPeerBrokers() {
1:2280719:         synchronized (peerBrokers) {
1:2280719:             if (peerBrokers.isEmpty()) {
1:2280719:                 peerBrokers.add(brokerService.getDefaultSocketURIString());
1:2280719:             }
1:2280719:             return peerBrokers;
1:2280719:         }
1:2280719:     }
1:2280719: 
1:f392884:     @Override
1:f392884:     public void updateClientClusterInfo() {
1:f392884:         if (isRebalanceClusterClients() || isUpdateClusterClients()) {
1:f392884:             ConnectionControl control = getConnectionControl();
1:dc0f5b3:             for (Connection c : this.connections) {
1:f392884:                 c.updateClient(control);
1:beda82a:                 if (isRebalanceClusterClients()) {
1:beda82a:                     control = getConnectionControl();
1:beda82a:                 }
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:beda82a: 
1:dc0f5b3:     private boolean isMatchesClusterFilter(String brokerName) {
2:dc0f5b3:         boolean result = true;
1:dc0f5b3:         String filter = getUpdateClusterFilter();
1:dc0f5b3:         if (filter != null) {
1:dc0f5b3:             filter = filter.trim();
1:dc0f5b3:             if (filter.length() > 0) {
1:8c77e95:                 result = false;
1:dc0f5b3:                 StringTokenizer tokenizer = new StringTokenizer(filter, ",");
1:8c77e95:                 while (!result && tokenizer.hasMoreTokens()) {
1:dc0f5b3:                     String token = tokenizer.nextToken();
1:dc0f5b3:                     result = isMatchesClusterFilter(brokerName, token);
1:d29ca2a:                 }
1:74bed6b:             }
1:74bed6b:         }
1:d29ca2a: 
1:dc0f5b3:         return result;
1:74bed6b:     }
1:d29ca2a: 
1:dc0f5b3:     private boolean isMatchesClusterFilter(String brokerName, String match) {
1:8c77e95:         boolean result = false;
1:dc0f5b3:         if (brokerName != null && match != null && brokerName.length() > 0 && match.length() > 0) {
1:dc0f5b3:             result = Pattern.matches(match, brokerName);
1:74bed6b:         }
1:dc0f5b3:         return result;
1:be55d0a:     }
1:d29ca2a: 
1:230a86c:     public boolean isDisableAsyncDispatch() {
1:230a86c:         return disableAsyncDispatch;
1:230a86c:     }
1:24d8986: 
1:230a86c:     public void setDisableAsyncDispatch(boolean disableAsyncDispatch) {
1:230a86c:         this.disableAsyncDispatch = disableAsyncDispatch;
1:230a86c:     }
1:d29ca2a: 
1:f392884:     /**
1:a7b9e8c:      * @return the enableStatusMonitor
1:d29ca2a:      */
1:230a86c:     public boolean isEnableStatusMonitor() {
1:a7b9e8c:         return enableStatusMonitor;
1:24d8986:     }
1:d29ca2a: 
1:a7b9e8c:     /**
1:dc0f5b3:      * @param enableStatusMonitor
1:dc0f5b3:      *            the enableStatusMonitor to set
1:a7b9e8c:      */
1:230a86c:     public void setEnableStatusMonitor(boolean enableStatusMonitor) {
1:230a86c:         this.enableStatusMonitor = enableStatusMonitor;
1:be55d0a:     }
1:3910056: 
1:7fed5d8:     /**
1:7fed5d8:      * This is called by the BrokerService right before it starts the transport.
1:7fed5d8:      */
1:a4be10c:     @Override
1:5d99c99:     public void setBrokerService(BrokerService brokerService) {
1:5d99c99:         this.brokerService = brokerService;
1:5d99c99:     }
1:5d99c99: 
1:5d99c99:     public Broker getBroker() {
1:5d99c99:         return broker;
1:5d99c99:     }
1:d29ca2a: 
1:dc0f5b3:     public BrokerService getBrokerService() {
1:dc0f5b3:         return brokerService;
1:3910056:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:f392884:      * @return the updateClusterClients
1:f392884:      */
1:a4be10c:     @Override
1:f392884:     public boolean isUpdateClusterClients() {
1:f392884:         return this.updateClusterClients;
1:d29ca2a:     }
1:d29ca2a: 
1:f392884:     /**
1:dc0f5b3:      * @param updateClusterClients
1:dc0f5b3:      *            the updateClusterClients to set
1:f392884:      */
1:f392884:     public void setUpdateClusterClients(boolean updateClusterClients) {
1:f392884:         this.updateClusterClients = updateClusterClients;
1:d29ca2a:     }
1:d29ca2a: 
1:f392884:     /**
1:f392884:      * @return the rebalanceClusterClients
1:f392884:      */
1:a4be10c:     @Override
1:f392884:     public boolean isRebalanceClusterClients() {
1:f392884:         return this.rebalanceClusterClients;
1:d29ca2a:     }
1:d29ca2a: 
1:f392884:     /**
1:dc0f5b3:      * @param rebalanceClusterClients
1:dc0f5b3:      *            the rebalanceClusterClients to set
1:f392884:      */
1:f392884:     public void setRebalanceClusterClients(boolean rebalanceClusterClients) {
1:f392884:         this.rebalanceClusterClients = rebalanceClusterClients;
1:d29ca2a:     }
1:cfcd4f7: 
1:be55d0a:     /**
1:be55d0a:      * @return the updateClusterClientsOnRemove
1:be55d0a:      */
1:a4be10c:     @Override
1:be55d0a:     public boolean isUpdateClusterClientsOnRemove() {
1:be55d0a:         return this.updateClusterClientsOnRemove;
1:d29ca2a:     }
1:d29ca2a: 
1:dc0f5b3:     /**
1:be55d0a:      * @param updateClusterClientsOnRemove the updateClusterClientsOnRemove to set
1:be55d0a:      */
1:be55d0a:     public void setUpdateClusterClientsOnRemove(boolean updateClusterClientsOnRemove) {
1:be55d0a:         this.updateClusterClientsOnRemove = updateClusterClientsOnRemove;
1:d29ca2a:     }
1:cfcd4f7: 
1:be55d0a:     /**
1:dc0f5b3:      * @return the updateClusterFilter
1:dc0f5b3:      */
1:f9682b8:     @Override
1:dc0f5b3:     public String getUpdateClusterFilter() {
1:dc0f5b3:         return this.updateClusterFilter;
1:d29ca2a:     }
1:d29ca2a: 
1:dc0f5b3:     /**
1:dc0f5b3:      * @param updateClusterFilter
1:dc0f5b3:      *            the updateClusterFilter to set
1:dc0f5b3:      */
1:dc0f5b3:     public void setUpdateClusterFilter(String updateClusterFilter) {
1:dc0f5b3:         this.updateClusterFilter = updateClusterFilter;
1:d29ca2a:     }
1:d29ca2a: 
1:a4be10c:     @Override
1:4cf6dae:     public int connectionCount() {
1:4cf6dae:         return connections.size();
1:1b97cdd:     }
1:d29ca2a: 
1:16c1627:     @Override
1:16c1627:     public boolean isAllowLinkStealing() {
1:c99e2d8:         return server.isAllowLinkStealing();
1:16c1627:     }
1:16c1627: 
1:16c1627:     public void setAllowLinkStealing (boolean allowLinkStealing) {
1:16c1627:         this.allowLinkStealing=allowLinkStealing;
1:16c1627:     }
1:16c1627: 
1:0018f4a:     public boolean isAuditNetworkProducers() {
1:0018f4a:         return auditNetworkProducers;
1:d29ca2a:     }
1:d29ca2a: 
1:a7b9e8c:     /**
1:49718ed:      * Enable a producer audit on network connections, Traps the case of a missing send reply and resend.
1:49718ed:      * Note: does not work with conduit=false, networked composite destinations or networked virtual topics
1:49718ed:      * @param auditNetworkProducers
1:a7b9e8c:      */
1:0018f4a:     public void setAuditNetworkProducers(boolean auditNetworkProducers) {
1:0018f4a:         this.auditNetworkProducers = auditNetworkProducers;
1:cfcd4f7:     }
1:d29ca2a: 
1:74bed6b:     public int getMaximumProducersAllowedPerConnection() {
1:74bed6b:         return maximumProducersAllowedPerConnection;
1:d29ca2a:     }
1:d29ca2a: 
1:74bed6b:     public void setMaximumProducersAllowedPerConnection(int maximumProducersAllowedPerConnection) {
1:74bed6b:         this.maximumProducersAllowedPerConnection = maximumProducersAllowedPerConnection;
1:d29ca2a:     }
1:d29ca2a: 
1:74bed6b:     public int getMaximumConsumersAllowedPerConnection() {
1:74bed6b:         return maximumConsumersAllowedPerConnection;
1:d29ca2a:     }
1:d29ca2a: 
1:74bed6b:     public void setMaximumConsumersAllowedPerConnection(int maximumConsumersAllowedPerConnection) {
1:74bed6b:         this.maximumConsumersAllowedPerConnection = maximumConsumersAllowedPerConnection;
1:d29ca2a:     }
1:a4be10c: 
1:a4be10c:     /**
1:a4be10c:      * Gets the currently configured policy for creating the published connection address of this
1:a4be10c:      * TransportConnector.
1:a4be10c:      *
1:a4be10c:      * @return the publishedAddressPolicy
1:a4be10c:      */
1:a4be10c:     public PublishedAddressPolicy getPublishedAddressPolicy() {
1:a4be10c:         return publishedAddressPolicy;
1:a4be10c:     }
1:a4be10c: 
1:a4be10c:     /**
1:a4be10c:      * Sets the configured policy for creating the published connection address of this
1:a4be10c:      * TransportConnector.
1:a4be10c:      *
1:a4be10c:      * @return the publishedAddressPolicy
1:a4be10c:      */
1:a4be10c:     public void setPublishedAddressPolicy(PublishedAddressPolicy publishedAddressPolicy) {
1:a4be10c:         this.publishedAddressPolicy = publishedAddressPolicy;
1:a4be10c:     }
1:d29ca2a: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:8c77e95
/////////////////////////////////////////////////////////////////////////
1:                 result = false;
1:                 while (!result && tokenizer.hasMoreTokens()) {
/////////////////////////////////////////////////////////////////////////
1:         boolean result = false;
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Timothy Bish
-------------------------------------------------------------------------------
commit:f9682b8
/////////////////////////////////////////////////////////////////////////
1:                 if (brokerService != null && brokerService.isStopping()) {
1:                     LOG.info("Could not accept connection during shutdown {} : {}", (remoteHost == null ? "" : "from " + remoteHost), error);
1:                 } else {
1:                     LOG.error("Could not accept connection {} : {}", (remoteHost == null ? "" : "from " + remoteHost), error);
1:                     LOG.debug("Reason: " + error, error);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
0:         LOG.info("Connector {} Started", getName());
1:         LOG.debug("Publishing: {} for broker transport URI: {}", publishableConnectString, getConnectUri());
/////////////////////////////////////////////////////////////////////////
0:         LOG.info("Connector {} Stopped", getName());
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:c99e2d8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return server.isAllowLinkStealing();
commit:c6fe94e
/////////////////////////////////////////////////////////////////////////
1:                                 if (!brokerService.isStopping()) {
1:                                     Connection connection = createConnection(transport);
1:                                     connection.start();
1:                                 } else {
1:                                     throw new BrokerStoppedException("Broker " + brokerService + " is being stopped");
1:                                 }
commit:a3a22ef
/////////////////////////////////////////////////////////////////////////
1:     public URI getPublishableConnectURI() throws Exception {
1:         return publishedAddressPolicy.getPublishableConnectURI(this);
1:     }
1: 
author:Rob Davies
-------------------------------------------------------------------------------
commit:47d1985
/////////////////////////////////////////////////////////////////////////
0:         if (server != null){
0:             setAllowLinkStealing(server.isAllowLinkStealing());
1:         }
/////////////////////////////////////////////////////////////////////////
1:         rc.setAllowLinkStealing(isAllowLinkStealing());
commit:16c1627
/////////////////////////////////////////////////////////////////////////
1:     private boolean allowLinkStealing;
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public boolean isAllowLinkStealing() {
0:         return allowLinkStealing;
1:     }
1: 
1:     public void setAllowLinkStealing (boolean allowLinkStealing) {
1:         this.allowLinkStealing=allowLinkStealing;
1:     }
1: 
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:59af747
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("Connector {} started", getName());
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("Connector {} stopped", getName());
commit:8a01c5d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     brokerService.getTaskRunnerFactory().execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
1:         // prefer to use task runner from broker service as stop task runner, as we can then
1:         // tie it to the lifecycle of the broker service
1:                 : taskRunnerFactory, brokerService.getTaskRunnerFactory());
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:15affd0
/////////////////////////////////////////////////////////////////////////
1:                     String shuffle = peerBrokers.removeFirst();
1:                     peerBrokers.addLast(shuffle);
commit:fa29678
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (server != null) {
1:             return server.getConnectURI();
1:         } else {
1:             return uri;
commit:2280719
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import javax.management.ObjectName;
1: import java.io.IOException;
1: import java.net.URI;
1: import java.net.URISyntaxException;
0: import java.util.Iterator;
1: import java.util.LinkedList;
1: import java.util.StringTokenizer;
1: import java.util.concurrent.CopyOnWriteArrayList;
1: import java.util.regex.Pattern;
1: 
/////////////////////////////////////////////////////////////////////////
1:     LinkedList<String> peerBrokers = new LinkedList<String>();
/////////////////////////////////////////////////////////////////////////
1:             synchronized (peerBrokers) {
1:                 for (String uri : getPeerBrokers()) {
1:                     connectedBrokers += separator + uri;
1:                     separator = ",";
1:                 }
1: 
1:                 if (rebalance) {
0:                     String shuffle = getPeerBrokers().removeFirst();
0:                     getPeerBrokers().addLast(shuffle);
/////////////////////////////////////////////////////////////////////////
1:     
1:     public void addPeerBroker(BrokerInfo info) {
1:         if (isMatchesClusterFilter(info.getBrokerName())) {
1:             synchronized (peerBrokers) {
1:                 getPeerBrokers().addLast(info.getBrokerURL());
1:             }
1:         }
1:     }
1:     
1:     public void removePeerBroker(BrokerInfo info) {
1:         synchronized (peerBrokers) {
1:             getPeerBrokers().remove(info.getBrokerURL());
1:         }
1:     }
1: 
1:     public LinkedList<String> getPeerBrokers() {
1:         synchronized (peerBrokers) {
1:             if (peerBrokers.isEmpty()) {
1:                 peerBrokers.add(brokerService.getDefaultSocketURIString());
1:             }
1:             return peerBrokers;
1:         }
1:     }
1: 
commit:beda82a
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
0: import java.util.Collections;
0: import java.util.Random;
/////////////////////////////////////////////////////////////////////////
0:     Random rnd = new Random(System.currentTimeMillis());
1: 
/////////////////////////////////////////////////////////////////////////
0:             ArrayList<String> uris = new ArrayList<String>();
0:             uris.add(brokerService.getDefaultSocketURIString());
0:             for (BrokerInfo info: broker.getPeerBrokerInfos()) {
0:                 if (isMatchesClusterFilter(info.getBrokerName())) {
0:                     uris.add(info.getBrokerURL());
0:                 Collections.shuffle(uris, rnd);
0:             for (String uri: uris) {
0:                 connectedBrokers += separator + uri;
0:                 separator = ",";
1:             }
1:             
/////////////////////////////////////////////////////////////////////////
1:                 if (isRebalanceClusterClients()) {
1:                     control = getConnectionControl();
1:                 }
commit:91059de
/////////////////////////////////////////////////////////////////////////
1:         brokerInfo.setBrokerURL(broker.getBrokerService().getDefaultSocketURIString());
/////////////////////////////////////////////////////////////////////////
1:         String separator = "";
0:                 separator = ",";
0:                         connectedBrokers += separator;
0:                         separator = ",";
0:                 connectedBrokers += separator + self;
commit:4d3af76
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import javax.management.ObjectName;
0: import java.io.IOException;
0: import java.net.URI;
0: import java.net.URISyntaxException;
0: import java.util.Iterator;
0: import java.util.StringTokenizer;
0: import java.util.concurrent.CopyOnWriteArrayList;
0: import java.util.regex.Pattern;
1: 
/////////////////////////////////////////////////////////////////////////
0:         brokerInfo.setBrokerURL(getPublishableConnectString(getServer().getConnectURI()));
/////////////////////////////////////////////////////////////////////////
1:     
0:         return getPublishableConnectString(getConnectUri());
1:     }
1: 
0:     public String getPublishableConnectString(URI theConnectURI) throws Exception {
commit:1b97cdd
/////////////////////////////////////////////////////////////////////////
1:             DiscoveryAgent agent = DiscoveryAgentFactory.createDiscoveryAgent(discoveryUri);
1: 
0:             if( agent!=null && agent instanceof BrokerServiceAware ) {
0:                 ((BrokerServiceAware)agent).setBrokerService(brokerService);
1:             }
1: 
1:             return agent;
/////////////////////////////////////////////////////////////////////////
1: }
commit:f0429be
/////////////////////////////////////////////////////////////////////////
0: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.MDCHelper;
/////////////////////////////////////////////////////////////////////////
0:         final Map context = MDCHelper.getCopyOfContextMap();
0:                             MDCHelper.setContextMap(context);
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     final Logger LOG = LoggerFactory.getLogger(TransportConnector.class);
commit:09bae42
/////////////////////////////////////////////////////////////////////////
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:a4be10c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.Transport;
1: import org.apache.activemq.transport.TransportAcceptListener;
1: import org.apache.activemq.transport.TransportFactorySupport;
1: import org.apache.activemq.transport.TransportServer;
/////////////////////////////////////////////////////////////////////////
1:     private PublishedAddressPolicy publishedAddressPolicy = new PublishedAddressPolicy();
/////////////////////////////////////////////////////////////////////////
1:         rc.setPublishedAddressPolicy(getPublishedAddressPolicy());
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:                         @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:         String publishableConnectString = publishedAddressPolicy.getPublishableConnectString(this);
0:             LOG.debug("Publishing: " + publishableConnectString + " for broker transport URI: " + getConnectUri());
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Gets the currently configured policy for creating the published connection address of this
1:      * TransportConnector.
1:      *
1:      * @return the publishedAddressPolicy
1:      */
1:     public PublishedAddressPolicy getPublishedAddressPolicy() {
1:         return publishedAddressPolicy;
1:     }
1: 
1:     /**
1:      * Sets the configured policy for creating the published connection address of this
1:      * TransportConnector.
1:      *
1:      * @return the publishedAddressPolicy
1:      */
1:     public void setPublishedAddressPolicy(PublishedAddressPolicy publishedAddressPolicy) {
1:         this.publishedAddressPolicy = publishedAddressPolicy;
1:     }
commit:6f2ac63
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     protected final CopyOnWriteArrayList<TransportConnection> connections = new CopyOnWriteArrayList<TransportConnection>();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public ManagedTransportConnector asManagedConnector(ManagementContext context, ObjectName connectorName) throws IOException, URISyntaxException {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             // strip off server side query parameters which may not be compatible to clients
/////////////////////////////////////////////////////////////////////////
1:         for (TransportConnection connection : connections) {
1:             ss.stop(connection);
/////////////////////////////////////////////////////////////////////////
1:             if (agent != null && agent instanceof BrokerServiceAware) {
1:                 ((BrokerServiceAware) agent).setBrokerService(brokerService);
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
commit:a3060e7
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.net.URI;
0: import java.net.URISyntaxException;
0: import java.util.ArrayList;
0: import java.util.Collections;
0: import java.util.Iterator;
0: import java.util.Random;
0: import java.util.StringTokenizer;
0: import java.util.concurrent.CopyOnWriteArrayList;
0: import java.util.regex.Pattern;
1: 
0: import javax.management.ObjectName;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:                     if (info.getBrokerURL() != null) {
0:                         uris.add(info.getBrokerURL());
1:                     }
/////////////////////////////////////////////////////////////////////////
1: 
commit:cfcd4f7
/////////////////////////////////////////////////////////////////////////
1:  *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:                                 String remoteHost = transport.getRemoteAddress();
1:                                 onAcceptError(e, remoteHost);
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
commit:9a8f6e4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transport.*;
/////////////////////////////////////////////////////////////////////////
1:         return TransportFactorySupport.bind(brokerService, uri);
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
0:  * 
commit:1f521da
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.thread.DefaultThreadPools;
/////////////////////////////////////////////////////////////////////////
1: 
0: import static org.apache.activemq.thread.DefaultThreadPools.*;
1: 
/////////////////////////////////////////////////////////////////////////
0:                     getDefaultTaskRunnerFactory().execute(new Runnable(){
/////////////////////////////////////////////////////////////////////////
1:                     });
commit:7fed5d8
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * 
0:      * @deprecated use the {@link #setBrokerService(BrokerService)} method instead.
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * This is called by the BrokerService right before it starts the transport.
1:      */
commit:5d99c99
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private Broker broker;
1:     public TransportConnector(TransportServer server) {
/////////////////////////////////////////////////////////////////////////
0:         ManagedTransportConnector rc = new ManagedTransportConnector(mbeanServer, connectorName, getServer());
/////////////////////////////////////////////////////////////////////////
1:         rc.setBrokerService(brokerService);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         
0:         TransportServer server = getServer();
1:         
1:         broker = brokerService.getBroker();
1:         brokerInfo.setBrokerName(broker.getBrokerName());
1:         brokerInfo.setBrokerId(broker.getBrokerId());
1:         brokerInfo.setPeerBrokerInfos(broker.getPeerBrokerInfos());
1:         brokerInfo.setFaultTolerantConfiguration(broker.isFaultTolerantConfiguration());
0:         brokerInfo.setBrokerURL(server.getConnectURI().toString());
1:         
0:         server.setAcceptListener(new TransportAcceptListener() {
1:             public void onAccept(final Transport transport) {
1:                 try {
0:                     // Starting the connection could block due to
0:                     // wireformat negotiation, so start it in an async thread.
0:                     Thread startThread = new Thread("ActiveMQ Transport Initiator: " + transport.getRemoteAddress()) {
1:                         public void run() {
1:                             try {
0:                                 Connection connection = createConnection(transport);
0:                                 connection.start();
1:                             } catch (Exception e) {
1:                                 ServiceSupport.dispose(transport);
0:                                 onAcceptError(e);
1:                             }
1:                         }
0:                     };
0:                     startThread.setPriority(4);
0:                     startThread.start();
1:                 } catch (Exception e) {
1:                     String remoteHost = transport.getRemoteAddress();
1:                     ServiceSupport.dispose(transport);
1:                     onAcceptError(e, remoteHost);
1:                 }
1:             }
1: 
1:             public void onAcceptError(Exception error) {
1:                 onAcceptError(error, null);
1:             }
1: 
1:             private void onAcceptError(Exception error, String remoteHost) {
0:                 LOG.error("Could not accept connection " + (remoteHost == null ? "" : "from " + remoteHost) + ": " + error.getMessage());
0:                 LOG.debug("Reason: " + error.getMessage(), error);
1:             }
1:         });
1:         
0:         server.setBrokerInfo(brokerInfo);
0:         server.start();
1:         
/////////////////////////////////////////////////////////////////////////
1:         if (brokerService == null) {
0:             throw new IllegalArgumentException("You must specify the brokerService property. Maybe this connector should be added to a broker?");
0:       	return TransportFactory.bind(brokerService, uri);
/////////////////////////////////////////////////////////////////////////
1:     public void setBrokerService(BrokerService brokerService) {
1:         this.brokerService = brokerService;
1:     }
1: 
1:     public Broker getBroker() {
1:         return broker;
1:     }
commit:3910056
/////////////////////////////////////////////////////////////////////////
1: public class TransportConnector implements Connector, BrokerServiceAware {
/////////////////////////////////////////////////////////////////////////
1:     private BrokerService brokerService;
/////////////////////////////////////////////////////////////////////////
0:         if (brokerService != null) {
0:         	return TransportFactory.bind(brokerService, uri);
0:         } else {
0:         	return TransportFactory.bind(broker.getBrokerId().getValue(), uri);
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
0: 	public void setBrokerService(BrokerService brokerService) {
0: 		this.brokerService = brokerService;
1: 	}
commit:62890b3
/////////////////////////////////////////////////////////////////////////
0:                 LOG.error("Could not accept connection " + (remoteHost == null ? "" : "from " + remoteHost) + ": " + error.getMessage());
0:                 LOG.debug("Reason: " + error.getMessage(), error);
commit:43b808d
/////////////////////////////////////////////////////////////////////////
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
0:     protected CopyOnWriteArrayList<TransportConnection> connections = new CopyOnWriteArrayList<TransportConnection>();
1:     protected TransportStatusDetector statusDector;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * @return Returns the connections.
1:      */
1:     public CopyOnWriteArrayList<TransportConnection> getConnections() {
1:         return connections;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator<TransportConnection> iter = connections.iterator(); iter.hasNext();) {
0:             TransportConnection c = iter.next();
/////////////////////////////////////////////////////////////////////////
1:         if (rc == null) {
1:         }
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.CopyOnWriteArrayList;
/////////////////////////////////////////////////////////////////////////
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(TransportConnector.class);
1:     private TaskRunnerFactory taskRunnerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private boolean disableAsyncDispatch;
0:     public CopyOnWriteArrayList getConnections() {
1:     public TransportConnector() {
0:     public TransportConnector(Broker broker, TransportServer server) {
1:         if (server != null && server.getConnectURI() != null) {
1:             if (uri != null && uri.getScheme().equals("vm")) {
1: 
1:      * Factory method to create a JMX managed version of this transport
1:      * connector
0:         ManagedTransportConnector rc = new ManagedTransportConnector(mbeanServer, connectorName, getBroker(), getServer());
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:                     // Starting the connection could block due to
0:                     // wireformat negotiation, so start it in an async thread.
0:                     Thread startThread = new Thread("ActiveMQ Transport Initiator: " + transport.getRemoteAddress()) {
0:                         public void run() {
0:                                 Connection connection = createConnection(transport);
0:                                 connection.start();
0:                             } catch (Exception e) {
0:                                 ServiceSupport.dispose(transport);
0:                                 onAcceptError(e);
1:                             }
1:                         }
0:                     };
0:                     startThread.setPriority(4);
0:                     startThread.start();
0:                 } catch (Exception e) {
0:                     ServiceSupport.dispose(transport);
0:                 onAcceptError(error, null);
0:                 LOG.error("Could not accept connection " + (remoteHost == null ? "" : "from " + remoteHost) + ": " + error, error);
1:         if (uri == null) {
/////////////////////////////////////////////////////////////////////////
1: 
1:      * Sets the policy used to decide if the current connection is authorized to
1:      * consume a given message
/////////////////////////////////////////////////////////////////////////
1:         if (da != null) {
0:             da.setBrokerName(getBrokerInfo().getBrokerName());
1:         if (enableStatusMonitor) {
1: 
0:         LOG.info("Connector " + getName() + " Started");
1:         if (discoveryAgent != null) {
1:         if (this.statusDector != null) {
1: 
0:             TransportConnection c = (TransportConnection)iter.next();
0:         LOG.info("Connector " + getName() + " Stopped");
/////////////////////////////////////////////////////////////////////////
0:         return TransportFactory.bind(broker.getBrokerId().getValue(), uri);
1: 
1:         if (discoveryAgent == null) {
1:         if (discoveryUri != null) {
/////////////////////////////////////////////////////////////////////////
0:         if (connectUri == null) {
1:             if (server != null) {
/////////////////////////////////////////////////////////////////////////
1:     public String getName() {
1:         if (name == null) {
1:             uri = getUri();
1:             if (uri != null) {
1:                 name = uri.toString();
1:             }
1: 
0:         if (rc == null)
1:             rc = super.toString();
1:     public boolean isDisableAsyncDispatch() {
1:         return disableAsyncDispatch;
1:     }
1:     public void setDisableAsyncDispatch(boolean disableAsyncDispatch) {
1:         this.disableAsyncDispatch = disableAsyncDispatch;
1:     }
1:     public boolean isEnableStatusMonitor() {
1:     public void setEnableStatusMonitor(boolean enableStatusMonitor) {
1:         this.enableStatusMonitor = enableStatusMonitor;
commit:5a3a45f
/////////////////////////////////////////////////////////////////////////
0:                 	// wireformat negotiation, so start it in an async thread.
commit:3a7c673
/////////////////////////////////////////////////////////////////////////
0:             public void onAccept(final Transport transport) {
0:                 	// Starting the connection could block due to 
0:                 	// wireformat negociation, so start it in an async thread.
0:                 	Thread startThread = new Thread("ActiveMQ Transport Initiator: "+transport.getRemoteAddress()) {
0:                 		public void run() {
1:                             try {
0: 								Connection connection = createConnection(transport);
0: 								connection.start();
0: 							} catch (Exception e) {
0: 			                	ServiceSupport.dispose(transport);
0: 			                    onAcceptError(e);
1: 							}
1:                 		}
0:                 	};
0:                 	startThread.setPriority(4);
0:                 	startThread.start();
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.CopyOnWriteArrayList;
commit:6bae959
/////////////////////////////////////////////////////////////////////////
0:                     String remoteHost = transport.getRemoteAddress();
0:                     onAcceptError(e, remoteHost);
0:                 onAcceptError(error,null);
1:             }
1: 
0:             private void onAcceptError(Exception error, String remoteHost) {
0:                 log.error("Could not accept connection "  +
0:                     (remoteHost == null ? "" : "from " + remoteHost)
0:                     + ": " + error, error);
commit:5159e2b
/////////////////////////////////////////////////////////////////////////
0:         rc.setBrokerInfo(brokerInfo);
/////////////////////////////////////////////////////////////////////////
0:         	da.setBrokerName(getBrokerInfo().getBrokerName());
commit:e16114f
/////////////////////////////////////////////////////////////////////////
0:         	uri = getUri();
0:         	if( uri != null ) {
0:         		name = uri.toString();
1:         	}
/////////////////////////////////////////////////////////////////////////
1:         String rc = getName();
0:         if( rc == null )
0:         	rc = super.toString();
1:         return rc;
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:24d8986
/////////////////////////////////////////////////////////////////////////
0:     private boolean disableAsyncDispatch=false;
/////////////////////////////////////////////////////////////////////////
0:         rc.setDisableAsyncDispatch(disableAsyncDispatch);
/////////////////////////////////////////////////////////////////////////
0:         TransportConnection answer = new TransportConnection(this, transport, broker, disableAsyncDispatch ? null : taskRunnerFactory);
/////////////////////////////////////////////////////////////////////////
1: 
0: 	public boolean isDisableAsyncDispatch() {
0: 		return disableAsyncDispatch;
1: 	}
1: 
0: 	public void setDisableAsyncDispatch(boolean disableAsyncDispatch) {
0: 		this.disableAsyncDispatch = disableAsyncDispatch;
1: 	}
commit:e2aad41
/////////////////////////////////////////////////////////////////////////
1:     public String toString() {
0:         return getName();
1:     }
commit:064880b
/////////////////////////////////////////////////////////////////////////
0:         if( uri == null ) {
0:             try {
1:                 uri = getConnectUri();
1:             } catch (Throwable e) {
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
0:             if( server !=null ) {
0:                 connectUri = server.getConnectURI();
/////////////////////////////////////////////////////////////////////////
0:         if( name==null ){
0:             name = getUri().toString();
commit:b2ad8fa
/////////////////////////////////////////////////////////////////////////
1:     private String name;
/////////////////////////////////////////////////////////////////////////
0:         ManagedTransportConnector rc = new ManagedTransportConnector(mbeanServer, connectorName,  getBroker(), getServer());
0:         rc.setName(name);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         log.info("Connector "+getName()+" Started");
/////////////////////////////////////////////////////////////////////////
0:         log.info("Connector "+getName()+" Stopped");
/////////////////////////////////////////////////////////////////////////
0:     public String getName() {
0:         if( name == null ) {
0:             name = server.getConnectURI().toString();
1:         }
1:         return name;
1:     }
1:     public void setName(String name) {
1:         this.name = name;
1:     }
1: 
commit:523ea5f
/////////////////////////////////////////////////////////////////////////
0:         ManagedTransportConnector rc = new ManagedTransportConnector(mbeanServer,connectorName,  getBroker(), getServer());
1:         rc.setTaskRunnerFactory(getTaskRunnerFactory());
0:         rc.setUri(uri);
0:         rc.setConnectUri(connectUri);
0:         rc.setDiscoveryAgent(discoveryAgent);
0:         rc.setDiscoveryUri(discoveryUri);
1:         return rc;
commit:68d245f
/////////////////////////////////////////////////////////////////////////
1:  * @org.apache.xbean.XBean
commit:7e672d4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.ServiceSupport;
/////////////////////////////////////////////////////////////////////////
0:                 	ServiceSupport.dispose(transport);
commit:d2d1c6d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             TransportConnection c = (TransportConnection) iter.next();
0:             ss.stop(c);
/////////////////////////////////////////////////////////////////////////
0:         return new TransportConnection(this, transport, broker, taskRunnerFactory);
/////////////////////////////////////////////////////////////////////////
1:     public void onStarted(TransportConnection connection) {
1:         connections.add(connection);
1:     }
1: 
1:     public void onStopped(TransportConnection connection) {
1:         connections.remove(connection);
1:     }
1: 
commit:c59246d
/////////////////////////////////////////////////////////////////////////
0:         return TransportFactory.bind(broker.getBrokerId().getValue(),uri);
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker;
1: 
0: import java.io.IOException;
0: import java.net.URI;
0: import java.net.URISyntaxException;
0: import java.util.Iterator;
1: 
0: import javax.management.MBeanServer;
0: import javax.management.ObjectName;
1: 
1: import org.apache.activemq.broker.jmx.ManagedTransportConnector;
1: import org.apache.activemq.broker.region.ConnectorStatistics;
1: import org.apache.activemq.command.BrokerInfo;
0: import org.apache.activemq.command.ConnectionInfo;
1: import org.apache.activemq.thread.TaskRunnerFactory;
0: import org.apache.activemq.transport.Transport;
0: import org.apache.activemq.transport.TransportAcceptListener;
0: import org.apache.activemq.transport.TransportFactory;
0: import org.apache.activemq.transport.TransportServer;
1: import org.apache.activemq.transport.discovery.DiscoveryAgent;
1: import org.apache.activemq.transport.discovery.DiscoveryAgentFactory;
1: import org.apache.activemq.util.ServiceStopper;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArrayList;
1: 
1: /**
0:  * @org.xbean.XBean
0:  * 
0:  * @version $Revision: 1.6 $
1:  */
0: public class TransportConnector implements Connector {
1: 
0:     private static final Log log = LogFactory.getLog(TransportConnector.class);
1: 
0:     private Broker broker;
0:     private BrokerFilter brokerFilter;
1:     private TransportServer server;
1:     private URI uri;
1:     private BrokerInfo brokerInfo = new BrokerInfo();
0:     private TaskRunnerFactory taskRunnerFactory = null;
0:     protected CopyOnWriteArrayList connections = new CopyOnWriteArrayList();
0:     protected TransportStatusDetector statusDector;
1:     private DiscoveryAgent discoveryAgent;
0:     private ConnectorStatistics statistics = new ConnectorStatistics();
1:     private URI discoveryUri;
0:     private URI connectUri;
1: 
1:     /**
0:      * @return Returns the connections.
1:      */
0:     public CopyOnWriteArrayList getConnections(){
0:         return connections;
1:     }
1: 
0:     public TransportConnector() {
1:         this.statusDector = new TransportStatusDetector(this);
1:     }
1: 
0:     public TransportConnector(Broker broker, TransportServer server) {
1:         this();
0:         setBroker(broker);
1:         setServer(server);
1:     }
1: 
1:     /**
0:      * Factory method to create a JMX managed version of this transport connector
1:      */
0:     public ManagedTransportConnector asManagedConnector(MBeanServer mbeanServer, ObjectName connectorName) throws IOException, URISyntaxException {
0:         return new ManagedTransportConnector(mbeanServer,connectorName,  getBroker(), getServer());    
1:     }
1:     
1:     public BrokerInfo getBrokerInfo() {
1:         return brokerInfo;
1:     }
1: 
1:     public void setBrokerInfo(BrokerInfo brokerInfo) {
1:         this.brokerInfo = brokerInfo;
1:     }
1: 
1:     public TransportServer getServer() throws IOException, URISyntaxException {
1:         if (server == null) {
1:             setServer(createTransportServer());
1:         }
1:         return server;
1:     }
1: 
0:     public String getName() throws IOException, URISyntaxException {
0:         return getServer().getConnectURI().toString();
1:     }
1: 
0:     public Broker getBroker() {
0:         return broker;
1:     }
1: 
0:     public void setBroker(Broker broker) {
0:         this.broker = broker;
0:         brokerInfo.setBrokerId(broker.getBrokerId());
1:     }
1: 	
0:     public void setBrokerName(String brokerName) {
0:         brokerInfo.setBrokerName(brokerName);
1:     }
1: 
1:     public void setServer(TransportServer server) {
1:         this.server = server;
0:         this.server.setAcceptListener(new TransportAcceptListener() {
0:             public void onAccept(Transport transport) {
0:                 try {
0:                     Connection connection = createConnection(transport);
0:                     connection.start();
1:                 }
0:                 catch (Exception e) {
0:                     onAcceptError(e);
1:                 }
1:             }
1: 
0:             public void onAcceptError(Exception error) {
0:                 log.error("Could not accept connection: " + error, error);
1:             }
0:         });
0:         this.server.setBrokerInfo(brokerInfo);
1:     }
1: 
1:     public URI getUri() {
1:         return uri;
1:     }
1: 
1:     /**
1:      * Sets the server transport URI to use if there is not a
1:      * {@link TransportServer} configured via the
1:      * {@link #setServer(TransportServer)} method. This value is used to lazy
1:      * create a {@link TransportServer} instance
0:      * 
1:      * @param uri
1:      */
1:     public void setUri(URI uri) {
1:         this.uri = uri;
1:     }
1: 
1:     public TaskRunnerFactory getTaskRunnerFactory() {
1:         return taskRunnerFactory;
1:     }
1: 
1:     public void setTaskRunnerFactory(TaskRunnerFactory taskRunnerFactory) {
1:         this.taskRunnerFactory = taskRunnerFactory;
1:     }
1: 
1:     /**
1:      * @return the statistics for this connector
1:      */
1:     public ConnectorStatistics getStatistics() {
1:         return statistics;
1:     }
1: 
1:     public void start() throws Exception {
1:         getServer().start();
0:         log.info("Accepting connection on: "+getServer().getConnectURI());
1: 
1:         DiscoveryAgent da = getDiscoveryAgent();
0:         if( da!=null ) {
0:             da.registerService(getConnectUri().toString());
1:             da.start();
1:         }
1: 
1:         this.statusDector.start();
1:     }
1: 
1:     public void stop() throws Exception {
1:         ServiceStopper ss = new ServiceStopper();
0:         if( discoveryAgent!=null ) {
1:             ss.stop(discoveryAgent);
1:         }
0:         if (server != null) {
1:             ss.stop(server);
1:         }
1:         this.statusDector.stop();
0:         for (Iterator iter = connections.iterator(); iter.hasNext();) {
0:             ConnectionContext context = (ConnectionContext) iter.next();
0:             ss.stop(context.getConnection());
1:         }
1:         ss.throwFirstException();
1:     }
1: 
1:     // Implementation methods
1:     // -------------------------------------------------------------------------
1:     protected Connection createConnection(Transport transport) throws IOException {
0:         return new TransportConnection(this, transport, getBrokerFilter(), taskRunnerFactory);
1:     }
1: 
0:     protected BrokerFilter getBrokerFilter() {
0:         if (brokerFilter == null) {
0:             if (broker == null) {
0:                 throw new IllegalArgumentException("You must specify the broker property. Maybe this connector should be added to a broker?");
1:             }
0:             this.brokerFilter = new BrokerFilter(broker) {
0:                 public void addConnection(ConnectionContext context, ConnectionInfo info) throws Throwable {
0:                     connections.add(context);
0:                     super.addConnection(context, info);
1:                 }
1: 
0:                 public void removeConnection(ConnectionContext context, ConnectionInfo info, Throwable error) throws Throwable {
0:                     connections.remove(context);
0:                     super.removeConnection(context, info, error);
1:                 }
0:             };
1: 
1:         }
0:         return brokerFilter;
1:     }
1: 
1:     protected TransportServer createTransportServer() throws IOException, URISyntaxException {
1:         if (uri == null) {
1:             throw new IllegalArgumentException("You must specify either a server or uri property");
1:         }
0:         if (broker == null) {
0:             throw new IllegalArgumentException("You must specify the broker property. Maybe this connector should be added to a broker?");
1:         }
0:         return TransportFactory.bind(broker.getBrokerId().getBrokerId(),uri);
1:     }
1:     
1:     public DiscoveryAgent getDiscoveryAgent() throws IOException {
0:         if( discoveryAgent==null ) {
1:             discoveryAgent = createDiscoveryAgent();
1:         }
1:         return discoveryAgent;
1:     }
1: 
1:     protected DiscoveryAgent createDiscoveryAgent() throws IOException {
0:         if( discoveryUri!=null ) {
0:             return DiscoveryAgentFactory.createDiscoveryAgent(discoveryUri);
1:         }
1:         return null;
1:     }
1: 
1:     public void setDiscoveryAgent(DiscoveryAgent discoveryAgent) {
1:         this.discoveryAgent = discoveryAgent;
1:     }
1: 
1:     public URI getDiscoveryUri() {
1:         return discoveryUri;
1:     }
1: 
1:     public void setDiscoveryUri(URI discoveryUri) {
1:         this.discoveryUri = discoveryUri;
1:     }
1: 
1:     public URI getConnectUri() throws IOException, URISyntaxException {
0:         if( connectUri==null ) {
0:             if( getServer().getConnectURI()==null ) {
0:                 throw new IllegalStateException("The transportConnector has not been started.");
1:             }
0:             connectUri = getServer().getConnectURI();
1:         }
0:         return connectUri;
1:     }
1: 
0:     public void setConnectUri(URI transportUri) {
0:         this.connectUri = transportUri;
1:     }
1: 
1: }
author:Robert Davies
-------------------------------------------------------------------------------
commit:74bed6b
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.net.URI;
0: import java.net.URISyntaxException;
0: import java.util.Iterator;
0: import java.util.LinkedList;
0: import java.util.StringTokenizer;
0: import java.util.concurrent.CopyOnWriteArrayList;
0: import java.util.regex.Pattern;
0: 
0: import javax.management.ObjectName;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private int maximumProducersAllowedPerConnection = Integer.MAX_VALUE;
1:     private int maximumConsumersAllowedPerConnection  = Integer.MAX_VALUE;
/////////////////////////////////////////////////////////////////////////
1:         rc.setMaximumConsumersAllowedPerConnection(getMaximumConsumersAllowedPerConnection());
1:         rc.setMaximumProducersAllowedPerConnection(getMaximumProducersAllowedPerConnection());
/////////////////////////////////////////////////////////////////////////
0: 
1:     public int getMaximumProducersAllowedPerConnection() {
1:         return maximumProducersAllowedPerConnection;
1:     }
0: 
1:     public void setMaximumProducersAllowedPerConnection(int maximumProducersAllowedPerConnection) {
1:         this.maximumProducersAllowedPerConnection = maximumProducersAllowedPerConnection;
1:     }
0: 
1:     public int getMaximumConsumersAllowedPerConnection() {
1:         return maximumConsumersAllowedPerConnection;
1:     }
0: 
1:     public void setMaximumConsumersAllowedPerConnection(int maximumConsumersAllowedPerConnection) {
1:         this.maximumConsumersAllowedPerConnection = maximumConsumersAllowedPerConnection;
1:     }
0: 
commit:475eedc
/////////////////////////////////////////////////////////////////////////
0:         brokerInfo.setBrokerURL(getServer().getConnectURI().toString());
1:         getServer().setAcceptListener(new TransportAcceptListener() {
/////////////////////////////////////////////////////////////////////////
1:         getServer().setBrokerInfo(brokerInfo);
0:         getServer().start();
commit:efd6bda
/////////////////////////////////////////////////////////////////////////
1:     private boolean updateClusterClients = false;
commit:be55d0a
/////////////////////////////////////////////////////////////////////////
0:     private boolean updateClusterClients = true;
1:     private boolean updateClusterClientsOnRemove = false;
/////////////////////////////////////////////////////////////////////////
0:  
1:     /**
1:      * @return the updateClusterClientsOnRemove
1:      */
1:     public boolean isUpdateClusterClientsOnRemove() {
1:         return this.updateClusterClientsOnRemove;
1:     }
1:      * @param updateClusterClientsOnRemove the updateClusterClientsOnRemove to set
1:      */
1:     public void setUpdateClusterClientsOnRemove(boolean updateClusterClientsOnRemove) {
1:         this.updateClusterClientsOnRemove = updateClusterClientsOnRemove;
1:     }
0:     
1:     /**
/////////////////////////////////////////////////////////////////////////
0: 
commit:dc0f5b3
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.activemq.thread.DefaultThreadPools.getDefaultTaskRunnerFactory;
0: import java.util.StringTokenizer;
0: import java.util.regex.Pattern;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     final Log LOG = LogFactory.getLog(TransportConnector.class);
/////////////////////////////////////////////////////////////////////////
0:     private boolean updateClusterClients = false;
1:     private String updateClusterFilter;
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public ManagedTransportConnector asManagedConnector(ManagementContext context, ObjectName connectorName)
0:             throws IOException, URISyntaxException {
/////////////////////////////////////////////////////////////////////////
0: 
0:      * @deprecated use the {@link #setBrokerService(BrokerService)} method
0:      *             instead.
0:         if (this.brokerInfo == null) {
0:             this.brokerInfo = new BrokerInfo();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     getDefaultTaskRunnerFactory().execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
0:                 LOG.error("Could not accept connection " + (remoteHost == null ? "" : "from " + remoteHost) + ": "
0:                         + error);
0: 
/////////////////////////////////////////////////////////////////////////
0:         URI theConnectURI = getConnectUri();
0:         String publishableConnectString = theConnectURI.toString();
0:         // strip off server side query parameters which may not be compatible to
0:         // clients
0:         if (theConnectURI.getRawQuery() != null) {
0:             publishableConnectString = publishableConnectString.substring(0, publishableConnectString
0:                     .indexOf(theConnectURI.getRawQuery()) - 1);
0:             LOG.debug("Publishing: " + publishableConnectString + " for broker transport URI: " + theConnectURI);
/////////////////////////////////////////////////////////////////////////
1:         TransportConnection answer = new TransportConnection(this, transport, broker, disableAsyncDispatch ? null
0:                 : taskRunnerFactory);
/////////////////////////////////////////////////////////////////////////
1:             throw new IllegalArgumentException(
1:                     "You must specify the brokerService property. Maybe this connector should be added to a broker?");
0:         return TransportFactory.bind(brokerService, uri);
/////////////////////////////////////////////////////////////////////////
0: 
1:         String connectedBrokers = "";
0:         String self = "";
0:         if (brokerService.getDefaultSocketURI() != null) {
0:             self += brokerService.getDefaultSocketURI().toString();
0:             self += ",";
0:         }
0:         if (rebalance == false) {
0:             connectedBrokers += self;
0:         }
0:         if (this.broker.getPeerBrokerInfos() != null) {
0:                 if (isMatchesClusterFilter(info.getBrokerName())) {
0:                     connectedBrokers += info.getBrokerURL();
0:                     connectedBrokers += ",";
0:                 }
0:         }
0:         if (rebalance) {
0:             connectedBrokers += self;
0:         }
1:         ConnectionControl control = new ConnectionControl();
1:         control.setConnectedBrokers(connectedBrokers);
1:         control.setRebalanceConnection(rebalance);
1:         return control;
0: 
0: 
1:             for (Connection c : this.connections) {
1:     private boolean isMatchesClusterFilter(String brokerName) {
1:         boolean result = true;
1:         String filter = getUpdateClusterFilter();
1:         if (filter != null) {
1:             filter = filter.trim();
1:             if (filter.length() > 0) {
1:                 StringTokenizer tokenizer = new StringTokenizer(filter, ",");
0:                 while (result && tokenizer.hasMoreTokens()) {
1:                     String token = tokenizer.nextToken();
1:                     result = isMatchesClusterFilter(brokerName, token);
0:                 }
0:             }
0:         }
1:         return result;
0:     }
0: 
1:     private boolean isMatchesClusterFilter(String brokerName, String match) {
1:         boolean result = true;
1:         if (brokerName != null && match != null && brokerName.length() > 0 && match.length() > 0) {
1:             result = Pattern.matches(match, brokerName);
0:         }
1:         return result;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:      * @param enableStatusMonitor
1:      *            the enableStatusMonitor to set
/////////////////////////////////////////////////////////////////////////
1:     public BrokerService getBrokerService() {
1:         return brokerService;
0:     }
/////////////////////////////////////////////////////////////////////////
1:      * @param updateClusterClients
1:      *            the updateClusterClients to set
/////////////////////////////////////////////////////////////////////////
1:      * @param rebalanceClusterClients
1:      *            the rebalanceClusterClients to set
0: 
1:     /**
1:      * @return the updateClusterFilter
1:      */
1:     public String getUpdateClusterFilter() {
1:         return this.updateClusterFilter;
0:     }
0: 
1:     /**
1:      * @param updateClusterFilter
1:      *            the updateClusterFilter to set
1:      */
1:     public void setUpdateClusterFilter(String updateClusterFilter) {
1:         this.updateClusterFilter = updateClusterFilter;
0:     }
commit:f392884
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.net.URI;
0: import java.net.URISyntaxException;
0: import java.util.Iterator;
0: import java.util.concurrent.CopyOnWriteArrayList;
0: import javax.management.ObjectName;
1: import org.apache.activemq.command.ConnectionControl;
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final ConnectorStatistics statistics = new ConnectorStatistics();
0:     private boolean updateClusterClients=false;
1:     private boolean rebalanceClusterClients;
0:     
/////////////////////////////////////////////////////////////////////////
1:         rc.setUpdateClusterClients(isUpdateClusterClients());
1:         rc.setRebalanceClusterClients(isRebalanceClusterClients());
/////////////////////////////////////////////////////////////////////////
0:         TransportServer server = getServer();  
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:     
1:     protected ConnectionControl getConnectionControl() {
1:         boolean rebalance = isRebalanceClusterClients();
0:             String connectedBrokers = "";
0:             String self = "";
0:             if (brokerService.getDefaultSocketURI() != null) {
0:                 self += brokerService.getDefaultSocketURI().toString();
0:                 self += ",";
0:             }
0:             if (rebalance == false) {
0:                 connectedBrokers += self;
0:             }
0:             if (this.broker.getPeerBrokerInfos() != null) {
0:             for (BrokerInfo info : this.broker.getPeerBrokerInfos()) {
0:                 connectedBrokers += info.getBrokerURL();
0:                 connectedBrokers += ",";
0:             }
0:             }
0:             if (rebalance) {
0:                 connectedBrokers += self;
0:             }
0: 
0:             ConnectionControl control = new ConnectionControl();
0:             control.setConnectedBrokers(connectedBrokers);
0:             control.setRebalanceConnection(rebalance);
0:             return control;
0:         
0:     }
0:     
1:     public void updateClientClusterInfo() {
1:         if (isRebalanceClusterClients() || isUpdateClusterClients()) {
1:             ConnectionControl control = getConnectionControl();
0:             for (Connection c: this.connections) {
1:                 c.updateClient(control);
0:             }
0:         }
0:     }
/////////////////////////////////////////////////////////////////////////
0: 
1:     /**
1:      * @return the updateClusterClients
1:      */
1:     public boolean isUpdateClusterClients() {
1:         return this.updateClusterClients;
0:     }
0: 
1:     /**
0:      * @param updateClusterClients the updateClusterClients to set
1:      */
1:     public void setUpdateClusterClients(boolean updateClusterClients) {
1:         this.updateClusterClients = updateClusterClients;
0:     }
0: 
1:     /**
1:      * @return the rebalanceClusterClients
1:      */
1:     public boolean isRebalanceClusterClients() {
1:         return this.rebalanceClusterClients;
0:     }
0: 
1:     /**
0:      * @param rebalanceClusterClients the rebalanceClusterClients to set
1:      */
1:     public void setRebalanceClusterClients(boolean rebalanceClusterClients) {
1:         this.rebalanceClusterClients = rebalanceClusterClients;
0:     }
commit:1ec71bd
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.jmx.ManagementContext;
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.net.URI;
0: import java.net.URISyntaxException;
0: import java.util.Iterator;
0: import java.util.concurrent.CopyOnWriteArrayList;
0: import javax.management.ObjectName;
/////////////////////////////////////////////////////////////////////////
0:     public ManagedTransportConnector asManagedConnector(ManagementContext context, ObjectName connectorName) throws IOException, URISyntaxException {
1:         ManagedTransportConnector rc = new ManagedTransportConnector(context, connectorName, getServer());
commit:d14e4ae
/////////////////////////////////////////////////////////////////////////
0: 
0: 	public BrokerService getBrokerService() {
0: 		return brokerService;
0: 	}
commit:290f51a
/////////////////////////////////////////////////////////////////////////
1:             server = null;
commit:b544fc0
/////////////////////////////////////////////////////////////////////////
0:     
0:     @Deprecated
0:     public void setBrokerName(String name) {
0:         if (this.brokerInfo==null) {
0:             this.brokerInfo=new BrokerInfo();
0:         }
0:         this.brokerInfo.setBrokerName(name);
0:     }
commit:e58dfee
/////////////////////////////////////////////////////////////////////////
1:     private boolean enableStatusMonitor = false;
commit:25a252f
/////////////////////////////////////////////////////////////////////////
0:         brokerInfo.setFaultTolerantConfiguration(broker.isFaultTolerantConfiguration());
commit:a7b9e8c
/////////////////////////////////////////////////////////////////////////
0:     private boolean enableStatusMonitor = true;
/////////////////////////////////////////////////////////////////////////
0:     public TransportConnector(){
0:     
0:     public TransportConnector(Broker broker,TransportServer server){
0:         if (server!=null&&server.getConnectURI()!=null){
1:             URI uri = server.getConnectURI();
0:             if (uri != null && uri.getScheme().equals("vm")){
1:                 setEnableStatusMonitor(false);
0:             }
0:         }
0:         
/////////////////////////////////////////////////////////////////////////
0:         if (enableStatusMonitor){
0:             this.statusDector = new TransportStatusDetector(this);
0:             this.statusDector.start();
0:         }
0:         
/////////////////////////////////////////////////////////////////////////
0:         if (this.statusDector != null){
0:             this.statusDector.stop();
0:         }
0:         
/////////////////////////////////////////////////////////////////////////
0: 
1:     /**
1:      * @return the enableStatusMonitor
1:      */
0:     public boolean isEnableStatusMonitor(){
1:         return enableStatusMonitor;
0:     }
0: 
1:     /**
0:      * @param enableStatusMonitor the enableStatusMonitor to set
1:      */
0:     public void setEnableStatusMonitor(boolean enableStatusMonitor){
0:         this.enableStatusMonitor=enableStatusMonitor;
0:     }
commit:8f02ba6
/////////////////////////////////////////////////////////////////////////
0:     public String getName(){
0:         if(name==null){
0:             if(server!=null){
0:                 if(server.getConnectURI()!=null){
0:                     name=server.getConnectURI().toString();
0:                 }else{
0:                     name = server.getClass() + ":Not started";
0:                 }
0:             }else{
0:                 name = "NOT_SET";
0:             }
commit:4098942
/////////////////////////////////////////////////////////////////////////
0:         brokerInfo.setPeerBrokerInfos(broker.getPeerBrokerInfos());
/////////////////////////////////////////////////////////////////////////
0:         this.brokerInfo.setBrokerURL(server.getConnectURI().toString());
author:Gary Tully
-------------------------------------------------------------------------------
commit:49718ed
/////////////////////////////////////////////////////////////////////////
1:     private boolean auditNetworkProducers = false;
/////////////////////////////////////////////////////////////////////////
1:         rc.setAuditNetworkProducers(isAuditNetworkProducers());
/////////////////////////////////////////////////////////////////////////
0:     /**
1:      * Enable a producer audit on network connections, Traps the case of a missing send reply and resend.
1:      * Note: does not work with conduit=false, networked composite destinations or networked virtual topics
1:      * @param auditNetworkProducers
0:      */
commit:49e7044
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         server = null;
commit:0018f4a
/////////////////////////////////////////////////////////////////////////
0:     private boolean auditNetworkProducers = true;
/////////////////////////////////////////////////////////////////////////
0: 
1:     public boolean isAuditNetworkProducers() {
1:         return auditNetworkProducers;
0:     }
0: 
1:     public void setAuditNetworkProducers(boolean auditNetworkProducers) {
1:         this.auditNetworkProducers = auditNetworkProducers;
0:     }
commit:4cf6dae
/////////////////////////////////////////////////////////////////////////
1:     public int connectionCount() {
1:         return connections.size();
0:     }
commit:8a2892b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e10f75c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.thread.DefaultThreadPools;
/////////////////////////////////////////////////////////////////////////
0:                     DefaultThreadPools.getDefaultTaskRunnerFactory().execute(new Runnable() {
commit:5ca9763
/////////////////////////////////////////////////////////////////////////
0:         String publishableConnectString = null;
0:         if (theConnectURI != null) {
0:             publishableConnectString = theConnectURI.toString();
0:             // strip off server side query parameters which may not be compatible to
0:             // clients
0:             if (theConnectURI.getRawQuery() != null) {
0:                 publishableConnectString = publishableConnectString.substring(0, publishableConnectString
0:                         .indexOf(theConnectURI.getRawQuery()) - 1);
0:             }
commit:0ed0ba5
/////////////////////////////////////////////////////////////////////////
1:     public String getPublishableConnectString() throws Exception {
/////////////////////////////////////////////////////////////////////////
0: 
1:         if (isUpdateClusterClients()) {
0:             if (brokerService.getDefaultSocketURIString() != null) {
0:                 self += brokerService.getDefaultSocketURIString();
0:                 self += ",";
0:             }
0:             if (rebalance == false) {
0:                 connectedBrokers += self;
0:             }
0:             if (this.broker.getPeerBrokerInfos() != null) {
0:                 for (BrokerInfo info : this.broker.getPeerBrokerInfos()) {
0:                     if (isMatchesClusterFilter(info.getBrokerName())) {
0:                         connectedBrokers += info.getBrokerURL();
0:                         connectedBrokers += ",";
0:                     }
0:             if (rebalance) {
0:                 connectedBrokers += self;
0:             }
commit:55c3ef9
/////////////////////////////////////////////////////////////////////////
1:         rc.setUpdateClusterFilter(getUpdateClusterFilter());
1:         rc.setUpdateClusterClientsOnRemove(isUpdateClusterClientsOnRemove());
commit:bd1b10c
/////////////////////////////////////////////////////////////////////////
1:             da.registerService(getPublishableConnectString());
/////////////////////////////////////////////////////////////////////////
0:     private String getPublishableConnectString() throws Exception {
0:         URI connectUri = getConnectUri();
0:         String publishableConnectString = connectUri.toString();
0:         // strip off server side query parameters which may not be compatible to clients
0:         if (connectUri.getRawQuery() != null) {
0:             publishableConnectString = 
0:                 publishableConnectString.substring(0, publishableConnectString.indexOf(connectUri.getRawQuery()) -1); 
0:         }
0:         if (LOG.isDebugEnabled()) {
0:             LOG.debug("Publishing: " + publishableConnectString + " for broker transport URI: " + connectUri);
0:         }
1:         return publishableConnectString;
0:     }
0: 
commit:7b78c36
/////////////////////////////////////////////////////////////////////////
0:                 LOG.error("Could not accept connection " + (remoteHost == null ? "" : "from " + remoteHost) + ": " + error);
0:                 LOG.debug("Reason: " + error, error);
author:James Strachan
-------------------------------------------------------------------------------
commit:a28ccae
/////////////////////////////////////////////////////////////////////////
0:         //rc.setBroker(getBroker());
1:         rc.setBrokerInfo(getBrokerInfo());
0:         rc.setConnectUri(getConnectUri());
1:         rc.setDisableAsyncDispatch(isDisableAsyncDispatch());
1:         rc.setDiscoveryAgent(getDiscoveryAgent());
1:         rc.setDiscoveryUri(getDiscoveryUri());
1:         rc.setEnableStatusMonitor(isEnableStatusMonitor());
1:         rc.setMessageAuthorizationPolicy(getMessageAuthorizationPolicy());
1:         rc.setName(getName());
0:         //rc.setServer(getServer());
1:         rc.setUri(getUri());
commit:a640ff5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.security.MessageAuthorizationPolicy;
/////////////////////////////////////////////////////////////////////////
1:     private MessageAuthorizationPolicy messageAuthorizationPolicy;
0:     private DiscoveryAgent discoveryAgent;
0: 
/////////////////////////////////////////////////////////////////////////
0:     
1:     public MessageAuthorizationPolicy getMessageAuthorizationPolicy() {
1:         return messageAuthorizationPolicy;
0:     }
0: 
0:     /**
0:      * Sets the policy used to decide if the current connection is authorized to consume
0:      * a given message
0:      */
1:     public void setMessageAuthorizationPolicy(MessageAuthorizationPolicy messageAuthorizationPolicy) {
1:         this.messageAuthorizationPolicy = messageAuthorizationPolicy;
0:     }
/////////////////////////////////////////////////////////////////////////
0:         TransportConnection answer = new TransportConnection(this, transport, broker, taskRunnerFactory);
1:         answer.setMessageAuthorizationPolicy(messageAuthorizationPolicy);
1:         return answer;
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:ccf3f3c
/////////////////////////////////////////////////////////////////////////
1:         boolean statEnabled = this.getStatistics().isEnabled();
1:         answer.getStatistics().setEnabled(statEnabled);
============================================================================