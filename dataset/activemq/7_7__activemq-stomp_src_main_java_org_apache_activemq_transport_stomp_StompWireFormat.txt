1:2490c85: /*
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
3:dc98d96:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:dc98d96:  *
1:dc98d96:  * Unless required by applicable law or agreed to in writing, software
1:dc98d96:  * distributed under the License is distributed on an "AS IS" BASIS,
1:dc98d96:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:dc98d96:  * See the License for the specific language governing permissions and
1:dc98d96:  * limitations under the License.
1:dc98d96:  */
1:98b61e4: package org.apache.activemq.transport.stomp;
30:dc98d96: 
1:956724e: import java.io.DataInput;
1:dc98d96: import java.io.DataInputStream;
1:956724e: import java.io.DataOutput;
1:dc98d96: import java.io.DataOutputStream;
1:dc98d96: import java.io.IOException;
1:956724e: import java.io.InputStream;
1:956724e: import java.io.PushbackInputStream;
1:dc98d96: import java.util.HashMap;
1:dc98d96: import java.util.Map;
1:a7a3c78: import java.util.concurrent.atomic.AtomicLong;
1:3125cae: 
1:88acb0e: import org.apache.activemq.util.ByteArrayInputStream;
1:88acb0e: import org.apache.activemq.util.ByteArrayOutputStream;
1:88acb0e: import org.apache.activemq.util.ByteSequence;
1:88acb0e: import org.apache.activemq.wireformat.WireFormat;
1:a7a3c78: 
2:dc98d96: /**
1:f812e34:  * Implements marshalling and unmarsalling the <a
1:f812e34:  * href="http://stomp.codehaus.org/">Stomp</a> protocol.
1:dc98d96:  */
1:dc98d96: public class StompWireFormat implements WireFormat {
1:530884a: 
1:f812e34:     private static final byte[] NO_DATA = new byte[] {};
1:f812e34:     private static final byte[] END_OF_FRAME = new byte[] {0, '\n'};
1:f812e34: 
1:f812e34:     private static final int MAX_COMMAND_LENGTH = 1024;
1:f812e34:     private static final int MAX_HEADER_LENGTH = 1024 * 10;
1:f812e34:     private static final int MAX_HEADERS = 1000;
1:3125cae: 
1:f37b005:     public static final int MAX_DATA_LENGTH = 1024 * 1024 * 100;
1:a7a3c78:     public static final long DEFAULT_MAX_FRAME_SIZE = Long.MAX_VALUE;
1:3125cae:     public static final long DEFAULT_CONNECTION_TIMEOUT = 30000;
1:f812e34: 
1:f812e34:     private int version = 1;
1:8d42343:     private int maxDataLength = MAX_DATA_LENGTH;
1:a7a3c78:     private long maxFrameSize = DEFAULT_MAX_FRAME_SIZE;
1:a54fa4b:     private String stompVersion = Stomp.DEFAULT_VERSION;
1:3125cae:     private long connectionAttemptTimeout = DEFAULT_CONNECTION_TIMEOUT;
1:3125cae: 
1:a7a3c78:     //The current frame size as it is unmarshalled from the stream
1:3125cae:     private final AtomicLong frameSize = new AtomicLong();
1:a7a3c78: 
1:8d42343:     @Override
1:f812e34:     public ByteSequence marshal(Object command) throws IOException {
1:dc98d96:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:dc98d96:         DataOutputStream dos = new DataOutputStream(baos);
1:dc98d96:         marshal(command, dos);
1:dc98d96:         dos.close();
1:88acb0e:         return baos.toByteSequence();
1:f812e34:     }
1:a7a3c78: 
1:8d42343:     @Override
1:88acb0e:     public Object unmarshal(ByteSequence packet) throws IOException {
1:88acb0e:         ByteArrayInputStream stream = new ByteArrayInputStream(packet);
1:dc98d96:         DataInputStream dis = new DataInputStream(stream);
1:dc98d96:         return unmarshal(dis);
1:fc00993:     }
1:a7a3c78: 
1:2490c85:     private StringBuilder marshalHeaders(StompFrame stomp, StringBuilder buffer) throws IOException {
1:f812e34:         buffer.append(stomp.getAction());
1:f812e34:         buffer.append(Stomp.NEWLINE);
1:530884a: 
1:f812e34:         // Output the headers.
1:0885c60:         for (Map.Entry<String, String> entry : stomp.getHeaders().entrySet()) {
1:f812e34:             buffer.append(entry.getKey());
1:f812e34:             buffer.append(Stomp.Headers.SEPERATOR);
1:0885c60:             buffer.append(encodeHeader(entry.getValue()));
1:f812e34:             buffer.append(Stomp.NEWLINE);
1:f812e34:         }
1:530884a: 
1:2490c85:         // Add a newline to separate the headers from the content.
1:f812e34:         buffer.append(Stomp.NEWLINE);
1:530884a: 
1:2490c85:         return buffer;
1:2490c85:     }
1:2490c85: 
1:2490c85:     @Override
1:2490c85:     public void marshal(Object command, DataOutput os) throws IOException {
1:2490c85:         StompFrame stomp = (org.apache.activemq.transport.stomp.StompFrame)command;
1:2490c85: 
1:2490c85:         if (stomp.getAction().equals(Stomp.Commands.KEEPALIVE)) {
1:2490c85:             os.write(Stomp.BREAK);
1:2490c85:             return;
1:2490c85:         }
1:2490c85: 
1:2490c85:         StringBuilder builder = new StringBuilder();
1:2490c85: 
1:2490c85:         os.write(marshalHeaders(stomp, builder).toString().getBytes("UTF-8"));
1:f812e34:         os.write(stomp.getContent());
1:f812e34:         os.write(END_OF_FRAME);
1:f812e34:     }
1:f812e34: 
1:2490c85:     public String marshalToString(StompFrame stomp) throws IOException {
1:2490c85:         if (stomp.getAction().equals(Stomp.Commands.KEEPALIVE)) {
1:2490c85:             return String.valueOf((char)Stomp.BREAK);
1:2490c85:         }
1:2490c85: 
1:2490c85:         StringBuilder buffer = new StringBuilder();
1:2490c85:         marshalHeaders(stomp, buffer);
1:2490c85: 
1:2490c85:         if (stomp.getContent() != null) {
1:2490c85:             String contentString = new String(stomp.getContent(), "UTF-8");
1:2490c85:             buffer.append(contentString);
1:2490c85:         }
1:2490c85: 
1:2490c85:         buffer.append('\u0000');
1:2490c85:         return buffer.toString();
1:2490c85:     }
1:2490c85: 
1:8d42343:     @Override
1:4821b9d:     public Object unmarshal(DataInput in) throws IOException {
1:f812e34:         try {
1:584d52c:             // parse action
1:a7a3c78:             String action = parseAction(in, frameSize);
1:f812e34: 
1:f812e34:             // Parse the headers
1:a7a3c78:             HashMap<String, String> headers = parseHeaders(in, frameSize);
1:f812e34: 
1:f812e34:             // Read in the data part.
1:f812e34:             byte[] data = NO_DATA;
1:933eb2f:             String contentLength = headers.get(Stomp.Headers.CONTENT_LENGTH);
1:a35fdd1:             if ((action.equals(Stomp.Commands.SEND) || action.equals(Stomp.Responses.MESSAGE)) && contentLength != null) {
1:f812e34: 
1:f812e34:                 // Bless the client, he's telling us how much data to read in.
1:a7a3c78:                 int length = parseContentLength(contentLength, frameSize);
1:f812e34: 
1:f812e34:                 data = new byte[length];
1:f812e34:                 in.readFully(data);
1:f812e34: 
1:f812e34:                 if (in.readByte() != 0) {
1:f812e34:                     throw new ProtocolException(Stomp.Headers.CONTENT_LENGTH + " bytes were read and " + "there was no trailing null byte", true);
1:f812e34:                 }
1:f812e34: 
1:f812e34:             } else {
1:f812e34: 
1:f812e34:                 // We don't know how much to read.. data ends when we hit a 0
1:f812e34:                 byte b;
1:f812e34:                 ByteArrayOutputStream baos = null;
1:3125cae:                 while ((b = in.readByte()) != 0) {
1:f812e34:                     if (baos == null) {
1:f812e34:                         baos = new ByteArrayOutputStream();
1:8d42343:                     } else if (baos.size() > getMaxDataLength()) {
1:f812e34:                         throw new ProtocolException("The maximum data length was exceeded", true);
1:a7a3c78:                     } else {
1:a7a3c78:                         if (frameSize.incrementAndGet() > getMaxFrameSize()) {
1:a7a3c78:                             throw new ProtocolException("The maximum frame size was exceeded", true);
1:a7a3c78:                         }
1:f812e34:                     }
1:3125cae: 
1:f812e34:                     baos.write(b);
1:f812e34:                 }
1:a7a3c78: 
1:f812e34:                 if (baos != null) {
1:f812e34:                     baos.close();
1:f812e34:                     data = baos.toByteArray();
1:f812e34:                 }
1:f812e34:             }
1:a7a3c78: 
1:f812e34:             return new StompFrame(action, headers, data);
1:dc98d96: 
1:f812e34:         } catch (ProtocolException e) {
1:f812e34:             return new StompFrameError(e);
1:a7a3c78:         } finally {
1:a7a3c78:             frameSize.set(0);
10:dc98d96:         }
1:dc98d96:     }
1:dc98d96: 
1:4821b9d:     private String readLine(DataInput in, int maxLength, String errorMessage) throws IOException {
1:0885c60:         ByteSequence sequence = readHeaderLine(in, maxLength, errorMessage);
1:0885c60:         return new String(sequence.getData(), sequence.getOffset(), sequence.getLength(), "UTF-8").trim();
1:dc98d96:     }
1:dc98d96: 
1:0885c60:     private ByteSequence readHeaderLine(DataInput in, int maxLength, String errorMessage) throws IOException {
1:530884a:         byte b;
1:f812e34:         ByteArrayOutputStream baos = new ByteArrayOutputStream(maxLength);
1:dc98d96:         while ((b = in.readByte()) != '\n') {
1:fc00993:             if (baos.size() > maxLength) {
1:530884a:                 baos.close();
1:f812e34:                 throw new ProtocolException(errorMessage, true);
1:fc00993:             }
1:530884a:             baos.write(b);
1:dc98d96:         }
1:dc98d96: 
1:dc98d96:         baos.close();
1:6d08aca:         ByteSequence line = baos.toByteSequence();
1:dc98d96: 
1:6d08aca:         if (stompVersion.equals(Stomp.V1_0) || stompVersion.equals(Stomp.V1_2)) {
1:6d08aca:             int lineLength = line.getLength();
1:6d08aca:             if (lineLength > 0 && line.data[lineLength-1] == '\r') {
1:6d08aca:                 line.setLength(lineLength-1);
1:dc98d96:             }
1:dc98d96:         }
1:dc98d96: 
1:6d08aca:         return line;
1:dc98d96:     }
1:a7a3c78: 
1:a7a3c78:     protected String parseAction(DataInput in, AtomicLong frameSize) throws IOException {
1:f812e34:         String action = null;
1:3125cae: 
1:f812e34:         // skip white space to next real action line
1:f812e34:         while (true) {
1:f812e34:             action = readLine(in, MAX_COMMAND_LENGTH, "The maximum command length was exceeded");
1:f812e34:             if (action == null) {
1:f812e34:                 throw new IOException("connection was closed");
1:f812e34:             } else {
1:f812e34:                 action = action.trim();
1:f812e34:                 if (action.length() > 0) {
1:f812e34:                     break;
1:530884a:                 }
1:dc98d96:             }
1:dc98d96:         }
1:a7a3c78:         frameSize.addAndGet(action.length());
1:584d52c:         return action;
1:dc98d96:     }
1:a7a3c78: 
1:a7a3c78:     protected HashMap<String, String> parseHeaders(DataInput in, AtomicLong frameSize) throws IOException {
1:2490c85:         HashMap<String, String> headers = new HashMap<>(25);
1:f812e34:         while (true) {
1:0885c60:             ByteSequence line = readHeaderLine(in, MAX_HEADER_LENGTH, "The maximum header length was exceeded");
1:e32ff5c:             if (line != null && line.length > 1) {
1:3125cae: 
1:fc00993:                 if (headers.size() > MAX_HEADERS) {
1:f812e34:                     throw new ProtocolException("The maximum number of headers was exceeded", true);
1:fc00993:                 }
1:a7a3c78:                 frameSize.addAndGet(line.length);
1:530884a: 
1:f812e34:                 try {
1:530884a: 
1:0885c60:                     ByteArrayInputStream headerLine = new ByteArrayInputStream(line);
1:0885c60:                     ByteArrayOutputStream stream = new ByteArrayOutputStream(line.length);
1:530884a: 
1:0885c60:                     // First complete the name
1:0885c60:                     int result = -1;
1:0885c60:                     while ((result = headerLine.read()) != -1) {
1:0885c60:                         if (result != ':') {
1:0885c60:                             stream.write(result);
1:530884a:                         } else {
1:530884a:                             break;
1:dc98d96:                         }
1:dc98d96:                     }
1:530884a: 
1:0885c60:                     ByteSequence nameSeq = stream.toByteSequence();
1:530884a: 
1:9601f67:                     String name = new String(nameSeq.getData(), nameSeq.getOffset(), nameSeq.getLength(), "UTF-8");
1:956724e:                     String value = decodeHeader(headerLine);
1:a54fa4b:                     if (stompVersion.equals(Stomp.V1_0)) {
1:a54fa4b:                         value = value.trim();
1:dc98d96:                     }
1:dc98d96: 
1:8aadc4b:                     if (!headers.containsKey(name)) {
1:f812e34:                         headers.put(name, value);
1:530884a:                     }
1:530884a: 
1:6d08aca:                     stream.close();
1:530884a: 
1:f812e34:                 } catch (Exception e) {
1:f812e34:                     throw new ProtocolException("Unable to parser header line [" + line + "]", true);
1:530884a:                 }
2:dc98d96:             } else {
1:f812e34:                 break;
1:530884a:             }
1:530884a:         }
1:584d52c:         return headers;
1:530884a:     }
1:3125cae: 
1:a7a3c78:     protected int parseContentLength(String contentLength, AtomicLong frameSize) throws ProtocolException {
1:f812e34:         int length;
3:530884a:         try {
1:f812e34:             length = Integer.parseInt(contentLength.trim());
1:f812e34:         } catch (NumberFormatException e) {
1:f812e34:             throw new ProtocolException("Specified content-length is not a valid integer", true);
1:f812e34:         }
1:f812e34: 
1:8d42343:         if (length > getMaxDataLength()) {
1:f812e34:             throw new ProtocolException("The maximum data length was exceeded", true);
1:f812e34:         }
1:3125cae: 
1:a7a3c78:         if (frameSize.addAndGet(length) > getMaxFrameSize()) {
1:a7a3c78:             throw new ProtocolException("The maximum frame size was exceeded", true);
1:a7a3c78:         }
1:f812e34: 
1:584d52c:         return length;
1:f812e34:     }
1:f812e34: 
1:0885c60:     private String encodeHeader(String header) throws IOException {
1:0885c60:         String result = header;
1:a54fa4b:         if (!stompVersion.equals(Stomp.V1_0)) {
1:0885c60:             byte[] utf8buf = header.getBytes("UTF-8");
1:0885c60:             ByteArrayOutputStream stream = new ByteArrayOutputStream(utf8buf.length);
1:0885c60:             for(byte val : utf8buf) {
1:0885c60:                 switch(val) {
1:0885c60:                 case Stomp.ESCAPE:
1:0885c60:                     stream.write(Stomp.ESCAPE_ESCAPE_SEQ);
1:530884a:                     break;
1:0885c60:                 case Stomp.BREAK:
1:0885c60:                     stream.write(Stomp.NEWLINE_ESCAPE_SEQ);
1:dc98d96:                     break;
1:0885c60:                 case Stomp.COLON:
1:0885c60:                     stream.write(Stomp.COLON_ESCAPE_SEQ);
1:dc98d96:                     break;
1:0885c60:                 default:
1:0885c60:                     stream.write(val);
1:f812e34:                 }
1:f812e34:             }
1:a36e618:             result =  new String(stream.toByteArray(), "UTF-8");
1:8d42343:             stream.close();
1:f812e34:         }
1:f812e34: 
1:0885c60:         return result;
1:f812e34:     }
1:f812e34: 
1:0885c60:     private String decodeHeader(InputStream header) throws IOException {
1:0885c60:         ByteArrayOutputStream decoded = new ByteArrayOutputStream();
1:0885c60:         PushbackInputStream stream = new PushbackInputStream(header);
1:f812e34: 
1:0885c60:         int value = -1;
1:0885c60:         while( (value = stream.read()) != -1) {
1:0885c60:             if (value == 92) {
1:f812e34: 
1:0885c60:                 int next = stream.read();
1:0885c60:                 if (next != -1) {
1:0885c60:                     switch(next) {
1:0885c60:                     case 110:
1:0885c60:                         decoded.write(Stomp.BREAK);
1:0885c60:                         break;
1:0885c60:                     case 99:
1:0885c60:                         decoded.write(Stomp.COLON);
5:0885c60:                         break;
1:0885c60:                     case 92:
1:0885c60:                         decoded.write(Stomp.ESCAPE);
1:0885c60:                         break;
1:0885c60:                     default:
1:0885c60:                         stream.unread(next);
1:0885c60:                         decoded.write(value);
1:f812e34:                     }
1:f812e34:                 } else {
1:0885c60:                     decoded.write(value);
1:530884a:                 }
1:f812e34: 
1:530884a:             } else {
1:0885c60:                 decoded.write(value);
1:530884a:             }
1:530884a:         }
1:530884a: 
1:8d42343:         decoded.close();
1:8d42343: 
1:0885c60:         return new String(decoded.toByteArray(), "UTF-8");
1:530884a:     }
1:3125cae: 
1:8d42343:     @Override
1:f812e34:     public int getVersion() {
1:dc98d96:         return version;
1:530884a:     }
1:530884a: 
2:8d42343:     @Override
1:dc98d96:     public void setVersion(int version) {
1:dc98d96:         this.version = version;
1:530884a:     }
1:530884a: 
1:a54fa4b:     public String getStompVersion() {
1:a54fa4b:         return stompVersion;
1:530884a:     }
1:530884a: 
1:a54fa4b:     public void setStompVersion(String stompVersion) {
1:a54fa4b:         this.stompVersion = stompVersion;
1:dc98d96:     }
1:8d42343: 
1:8d42343:     public void setMaxDataLength(int maxDataLength) {
1:8d42343:         this.maxDataLength = maxDataLength;
1:8d42343:     }
1:8d42343: 
1:8d42343:     public int getMaxDataLength() {
1:8d42343:         return maxDataLength;
1:8d42343:     }
1:a7a3c78: 
1:a7a3c78:     public long getMaxFrameSize() {
1:a7a3c78:         return maxFrameSize;
1:a7a3c78:     }
1:a7a3c78: 
1:a7a3c78:     public void setMaxFrameSize(long maxFrameSize) {
1:a7a3c78:         this.maxFrameSize = maxFrameSize;
1:a7a3c78:     }
1:3125cae: 
1:3125cae:     public long getConnectionAttemptTimeout() {
1:3125cae:         return connectionAttemptTimeout;
1:3125cae:     }
1:3125cae: 
1:3125cae:     public void setConnectionAttemptTimeout(long connectionAttemptTimeout) {
1:3125cae:         this.connectionAttemptTimeout = connectionAttemptTimeout;
1:3125cae:     }
1:dc98d96: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:2490c85
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
1:     private StringBuilder marshalHeaders(StompFrame stomp, StringBuilder buffer) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:         // Add a newline to separate the headers from the content.
1:         return buffer;
1:     }
1: 
1:     @Override
1:     public void marshal(Object command, DataOutput os) throws IOException {
1:         StompFrame stomp = (org.apache.activemq.transport.stomp.StompFrame)command;
1: 
1:         if (stomp.getAction().equals(Stomp.Commands.KEEPALIVE)) {
1:             os.write(Stomp.BREAK);
1:             return;
1:         }
1: 
1:         StringBuilder builder = new StringBuilder();
1: 
1:         os.write(marshalHeaders(stomp, builder).toString().getBytes("UTF-8"));
1:     public String marshalToString(StompFrame stomp) throws IOException {
1:         if (stomp.getAction().equals(Stomp.Commands.KEEPALIVE)) {
1:             return String.valueOf((char)Stomp.BREAK);
1:         }
1: 
1:         StringBuilder buffer = new StringBuilder();
1:         marshalHeaders(stomp, buffer);
1: 
1:         if (stomp.getContent() != null) {
1:             String contentString = new String(stomp.getContent(), "UTF-8");
1:             buffer.append(contentString);
1:         }
1: 
1:         buffer.append('\u0000');
1:         return buffer.toString();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         HashMap<String, String> headers = new HashMap<>(25);
commit:f37b005
/////////////////////////////////////////////////////////////////////////
1:     public static final int MAX_DATA_LENGTH = 1024 * 1024 * 100;
commit:3125cae
/////////////////////////////////////////////////////////////////////////
1: 
1:     public static final long DEFAULT_CONNECTION_TIMEOUT = 30000;
1:     private long connectionAttemptTimeout = DEFAULT_CONNECTION_TIMEOUT;
1: 
1:     private final AtomicLong frameSize = new AtomicLong();
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:                 while ((b = in.readByte()) != 0) {
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:         HashMap<String, String> headers = new HashMap<String, String>(25);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public long getConnectionAttemptTimeout() {
1:         return connectionAttemptTimeout;
1:     }
1: 
1:     public void setConnectionAttemptTimeout(long connectionAttemptTimeout) {
1:         this.connectionAttemptTimeout = connectionAttemptTimeout;
1:     }
commit:8d42343
/////////////////////////////////////////////////////////////////////////
1:     private int maxDataLength = MAX_DATA_LENGTH;
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                     } else if (baos.size() > getMaxDataLength()) {
/////////////////////////////////////////////////////////////////////////
1:         if (length > getMaxDataLength()) {
/////////////////////////////////////////////////////////////////////////
1:             stream.close();
/////////////////////////////////////////////////////////////////////////
1:         decoded.close();
1: 
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void setMaxDataLength(int maxDataLength) {
1:         this.maxDataLength = maxDataLength;
1:     }
1: 
1:     public int getMaxDataLength() {
1:         return maxDataLength;
1:     }
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:a7a3c78
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicLong;
/////////////////////////////////////////////////////////////////////////
1:     public static final long DEFAULT_MAX_FRAME_SIZE = Long.MAX_VALUE;
1:     private long maxFrameSize = DEFAULT_MAX_FRAME_SIZE;
1:     
1:     //The current frame size as it is unmarshalled from the stream
0:     private AtomicLong frameSize = new AtomicLong();
/////////////////////////////////////////////////////////////////////////
1:             
1:             String action = parseAction(in, frameSize);
1:             HashMap<String, String> headers = parseHeaders(in, frameSize);
/////////////////////////////////////////////////////////////////////////
1:                 int length = parseContentLength(contentLength, frameSize);
/////////////////////////////////////////////////////////////////////////
0:                 while ((b = in.readByte()) != 0) {                    
1:                     } else {
1:                         if (frameSize.incrementAndGet() > getMaxFrameSize()) {
1:                             throw new ProtocolException("The maximum frame size was exceeded", true);
1:                         }
1:                     
/////////////////////////////////////////////////////////////////////////
1:         } finally {
1:             frameSize.set(0);
/////////////////////////////////////////////////////////////////////////
1:     protected String parseAction(DataInput in, AtomicLong frameSize) throws IOException {
1:         
/////////////////////////////////////////////////////////////////////////
1:         frameSize.addAndGet(action.length());
1:     protected HashMap<String, String> parseHeaders(DataInput in, AtomicLong frameSize) throws IOException {
0:         HashMap<String, String> headers = new HashMap<String, String>(25); 
1:                 
1:                 frameSize.addAndGet(line.length);
/////////////////////////////////////////////////////////////////////////
1:     
1:     protected int parseContentLength(String contentLength, AtomicLong frameSize) throws ProtocolException {
/////////////////////////////////////////////////////////////////////////
1:         
1:         if (frameSize.addAndGet(length) > getMaxFrameSize()) {
1:             throw new ProtocolException("The maximum frame size was exceeded", true);
1:         }
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1: 
1:     public long getMaxFrameSize() {
1:         return maxFrameSize;
1:     }
1: 
1:     public void setMaxFrameSize(long maxFrameSize) {
1:         this.maxFrameSize = maxFrameSize;
1:     }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:c5cf038
commit:8978ac0
/////////////////////////////////////////////////////////////////////////
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
0:             HashMap<String, String> headers = new HashMap<String, String>(25);
/////////////////////////////////////////////////////////////////////////
1:             String contentLength = headers.get(Stomp.Headers.CONTENT_LENGTH);
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:                     if (headers.size() > MAX_HEADERS) {
1:                     }
0:                         int seperatorIndex = line.indexOf(Stomp.Headers.SEPERATOR);
0:                         String name = line.substring(0, seperatorIndex).trim();
0:                         String value = line.substring(seperatorIndex + 1, line.length()).trim();
/////////////////////////////////////////////////////////////////////////
0:                 if (length > MAX_DATA_LENGTH) {
1:                 }
/////////////////////////////////////////////////////////////////////////
1:             if (baos.size() > maxLength) {
1:             }
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1:  * Implements marshalling and unmarsalling the <a
1:  * href="http://stomp.codehaus.org/">Stomp</a> protocol.
1:     private static final byte[] NO_DATA = new byte[] {};
1:     private static final byte[] END_OF_FRAME = new byte[] {0, '\n'};
1:     private static final int MAX_COMMAND_LENGTH = 1024;
1:     private static final int MAX_HEADER_LENGTH = 1024 * 10;
1:     private static final int MAX_HEADERS = 1000;
0:     private static final int MAX_DATA_LENGTH = 1024 * 1024 * 100;
1: 
1:     private int version = 1;
1: 
1:     public ByteSequence marshal(Object command) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:         StompFrame stomp = (org.apache.activemq.transport.stomp.StompFrame)command;
0:         StringBuffer buffer = new StringBuffer();
1:         buffer.append(stomp.getAction());
1:         buffer.append(Stomp.NEWLINE);
1:         // Output the headers.
0:         for (Iterator iter = stomp.getHeaders().entrySet().iterator(); iter.hasNext();) {
0:             Map.Entry entry = (Map.Entry)iter.next();
1:             buffer.append(entry.getKey());
1:             buffer.append(Stomp.Headers.SEPERATOR);
0:             buffer.append(entry.getValue());
1:             buffer.append(Stomp.NEWLINE);
1:         }
0:         // Add a newline to seperate the headers from the content.
1:         buffer.append(Stomp.NEWLINE);
0:         os.write(buffer.toString().getBytes("UTF-8"));
1:         os.write(stomp.getContent());
1:         os.write(END_OF_FRAME);
1:     }
1: 
1:             String action = null;
1:             // skip white space to next real action line
1:             while (true) {
1:                 action = readLine(in, MAX_COMMAND_LENGTH, "The maximum command length was exceeded");
1:                 if (action == null) {
1:                     throw new IOException("connection was closed");
1:                 } else {
1:                     action = action.trim();
1:                     if (action.length() > 0) {
1:                         break;
1:                     }
1:                 }
1:             }
1:             // Parse the headers
0:             HashMap headers = new HashMap(25);
1:             while (true) {
0:                 String line = readLine(in, MAX_HEADER_LENGTH, "The maximum header length was exceeded");
0:                 if (line != null && line.trim().length() > 0) {
1: 
0:                     if (headers.size() > MAX_HEADERS)
1:                         throw new ProtocolException("The maximum number of headers was exceeded", true);
1: 
1:                     try {
0:                         int seperator_index = line.indexOf(Stomp.Headers.SEPERATOR);
0:                         String name = line.substring(0, seperator_index).trim();
0:                         String value = line.substring(seperator_index + 1, line.length()).trim();
1:                         headers.put(name, value);
1:                     } catch (Exception e) {
1:                         throw new ProtocolException("Unable to parser header line [" + line + "]", true);
1:                     }
1:                 } else {
1:                     break;
1:                 }
1:             }
1: 
1:             // Read in the data part.
1:             byte[] data = NO_DATA;
0:             String contentLength = (String)headers.get(Stomp.Headers.CONTENT_LENGTH);
0:             if (contentLength != null) {
1: 
1:                 // Bless the client, he's telling us how much data to read in.
1:                 int length;
1:                 try {
1:                     length = Integer.parseInt(contentLength.trim());
1:                 } catch (NumberFormatException e) {
1:                     throw new ProtocolException("Specified content-length is not a valid integer", true);
1:                 }
1: 
0:                 if (length > MAX_DATA_LENGTH)
1:                     throw new ProtocolException("The maximum data length was exceeded", true);
1: 
1:                 data = new byte[length];
1:                 in.readFully(data);
1: 
1:                 if (in.readByte() != 0) {
1:                     throw new ProtocolException(Stomp.Headers.CONTENT_LENGTH + " bytes were read and " + "there was no trailing null byte", true);
1:                 }
1: 
1:             } else {
1: 
1:                 // We don't know how much to read.. data ends when we hit a 0
1:                 byte b;
1:                 ByteArrayOutputStream baos = null;
0:                 while ((b = in.readByte()) != 0) {
1: 
1:                     if (baos == null) {
1:                         baos = new ByteArrayOutputStream();
0:                     } else if (baos.size() > MAX_DATA_LENGTH) {
1:                         throw new ProtocolException("The maximum data length was exceeded", true);
1:                     }
1: 
1:                     baos.write(b);
1:                 }
1: 
1:                 if (baos != null) {
1:                     baos.close();
1:                     data = baos.toByteArray();
1:                 }
1: 
1:             }
1: 
1:             return new StompFrame(action, headers, data);
1: 
1:         } catch (ProtocolException e) {
1:             return new StompFrameError(e);
1:         }
1:         ByteArrayOutputStream baos = new ByteArrayOutputStream(maxLength);
0:             if (baos.size() > maxLength)
1:                 throw new ProtocolException(errorMessage, true);
0:         return new String(sequence.getData(), sequence.getOffset(), sequence.getLength(), "UTF-8");
1:     }
1:     public int getVersion() {
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:88acb0e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.ByteArrayInputStream;
1: import org.apache.activemq.util.ByteArrayOutputStream;
1: import org.apache.activemq.util.ByteSequence;
1: import org.apache.activemq.wireformat.WireFormat;
/////////////////////////////////////////////////////////////////////////
0: 	public ByteSequence marshal(Object command) throws IOException {
1:         return baos.toByteSequence();
1:     public Object unmarshal(ByteSequence packet) throws IOException {
1:         ByteArrayInputStream stream = new ByteArrayInputStream(packet);
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:98b61e4
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.transport.stomp;
/////////////////////////////////////////////////////////////////////////
0: 		StompFrame stomp = (org.apache.activemq.transport.stomp.StompFrame) command;
commit:1f6aa57
/////////////////////////////////////////////////////////////////////////
commit:530884a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		StompFrame stomp = (org.apache.activemq.transport.stomp2.StompFrame) command;
/////////////////////////////////////////////////////////////////////////
1:         try {
0: 			String action = null;
1: 			
0: 			// skip white space to next real action line
0: 			while (true) {
0: 				action = readLine(in, MAX_COMMAND_LENGTH, "The maximum command length was exceeded");
0: 				if (action == null) {
0: 					throw new IOException("connection was closed");
1: 				} else {
0: 					action = action.trim();
0: 					if (action.length() > 0) {
1: 						break;
1: 					}
0: 			// Parse the headers
0: 			HashMap headers = new HashMap(25);
0: 			while (true) {
0: 			    String line = readLine(in, MAX_HEADER_LENGTH, "The maximum header length was exceeded");
0: 			    if (line != null && line.trim().length() > 0) {
1: 			    	
0: 			    	if( headers.size() > MAX_HEADERS )
0: 			    		throw new ProtocolException("The maximum number of headers was exceeded", true);
1: 			    	
1: 			        try {
0: 			            int seperator_index = line.indexOf(Stomp.Headers.SEPERATOR);
0: 			            String name = line.substring(0, seperator_index).trim();
0: 			            String value = line.substring(seperator_index + 1, line.length()).trim();
0: 			            headers.put(name, value);
1: 			        }
0: 			        catch (Exception e) {
0: 			            throw new ProtocolException("Unable to parser header line [" + line + "]", true);
1: 			        }
1: 			    }
0: 			    else {
1: 			        break;
1: 			    }
1: 			}
1: 			
0: 			// Read in the data part.
0: 			byte[] data = NO_DATA;
0: 			String contentLength = (String)headers.get(Stomp.Headers.CONTENT_LENGTH);
0: 			if (contentLength!=null) {
1: 			    
0: 				// Bless the client, he's telling us how much data to read in.        	
0: 				int length;
1: 				try {
0: 					length = Integer.parseInt(contentLength.trim());
0: 				} catch (NumberFormatException e) {
0: 					throw new ProtocolException("Specified content-length is not a valid integer", true);
1: 				}
0: 				if( length > MAX_DATA_LENGTH )
0: 					throw new ProtocolException("The maximum data length was exceeded", true);
1: 				
0: 			    data = new byte[length];
0: 			    in.readFully(data);
1: 			    
0: 			    if (in.readByte() != 0) {
0: 			        throw new ProtocolException(Stomp.Headers.CONTENT_LENGTH+" bytes were read and " + "there was no trailing null byte", true);
1: 			    }
1: 			
1: 			} else {
1: 
0: 				// We don't know how much to read.. data ends when we hit a 0
1: 			    byte b;
0: 			    ByteArrayOutputStream baos=null;
0: 			    while ((b = in.readByte()) != 0) {
1: 					
0: 					if( baos == null ) {
0: 			    		baos = new ByteArrayOutputStream();
0: 			    	} else if( baos.size() > MAX_DATA_LENGTH ) {
0: 			    		throw new ProtocolException("The maximum data length was exceeded", true);
1: 			    	}
1: 			    
1: 			        baos.write(b);
1: 			    }
1: 			    
0: 			    if( baos!=null ) {
1: 			        baos.close();
0: 			        data = baos.toByteArray();
1: 			    }
1: 			    
1: 			}
1: 			
0: 			return new StompFrame(action, headers, data);
1: 			
0: 		} catch (ProtocolException e) {
0: 			return new StompFrameError(e);
1: 		} 
/////////////////////////////////////////////////////////////////////////
0:         		throw new ProtocolException(errorMessage, true);
commit:dc98d96
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: package org.apache.activemq.transport.stomp2;
1: 
1: import java.io.DataInputStream;
1: import java.io.DataOutputStream;
1: import java.io.IOException;
0: import java.net.ProtocolException;
1: import java.util.HashMap;
0: import java.util.Iterator;
1: import java.util.Map;
1: 
0: import org.apache.activeio.adapter.PacketInputStream;
0: import org.apache.activeio.command.WireFormat;
0: import org.apache.activeio.packet.ByteArrayPacket;
0: import org.apache.activeio.packet.ByteSequence;
0: import org.apache.activeio.packet.Packet;
0: import org.apache.activeio.util.ByteArrayOutputStream;
0: import org.apache.activemq.transport.stomp.Stomp;
1: 
1: /**
0:  * Implements marshalling and unmarsalling the <a href="http://stomp.codehaus.org/">Stomp</a> protocol.
1:  */
1: public class StompWireFormat implements WireFormat {
1: 
0:     private static final byte[] NO_DATA = new byte[]{};
0: 	private static final byte[] END_OF_FRAME = new byte[]{0,'\n'};
1: 	
0: 	private static final int MAX_COMMAND_LENGTH = 1024;
0: 	private static final int MAX_HEADER_LENGTH = 1024*10;
0: 	private static final int MAX_HEADERS = 1000;
0: 	private static final int MAX_DATA_LENGTH = 1024*1024*100;
1:     
0: 	private int version=1;
1: 
0: 	public Packet marshal(Object command) throws IOException {
1:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:         DataOutputStream dos = new DataOutputStream(baos);
1:         marshal(command, dos);
1:         dos.close();
0:         return new ByteArrayPacket(baos.toByteSequence());
1:     }
1: 
0:     public Object unmarshal(Packet packet) throws IOException {
0:         PacketInputStream stream = new PacketInputStream(packet);
1:         DataInputStream dis = new DataInputStream(stream);
1:         return unmarshal(dis);
1:     }
1: 
0:     public void marshal(Object command, DataOutputStream os) throws IOException {
0: 		StompCommand stomp = (org.apache.activemq.transport.stomp2.StompCommand) command;
1: 
0: 		StringBuffer buffer = new StringBuffer();
0: 		buffer.append(stomp.getAction());
0: 		buffer.append(Stomp.NEWLINE);
1: 
0: 		// Output the headers.
0: 		for (Iterator iter = stomp.getHeaders().entrySet().iterator(); iter.hasNext();) {
0: 			Map.Entry entry = (Map.Entry) iter.next();
0: 			buffer.append(entry.getKey());
0: 			buffer.append(Stomp.Headers.SEPERATOR);
0: 			buffer.append(entry.getValue());
0: 			buffer.append(Stomp.NEWLINE);
1: 		}
1: 
0: 		// Add a newline to seperate the headers from the content.
0: 		buffer.append(Stomp.NEWLINE);
1: 
0: 		os.write(buffer.toString().getBytes("UTF-8"));
0: 		os.write(stomp.getContent());
0: 		os.write(END_OF_FRAME);
1: 	}
1:     
1: 
0:     public Object unmarshal(DataInputStream in) throws IOException {
1:         	
0:         String action = null;
1:         
0:         // skip white space to next real action line
0: 		while (true) {
0: 			action = readLine(in, MAX_COMMAND_LENGTH, "The maximum command length was exceeded");
0: 			if (action == null) {
0: 				throw new IOException("connection was closed");
1: 			} else {
0: 				action = action.trim();
0: 				if (action.length() > 0) {
1: 					break;
1: 				}
1: 			}
1: 		}
1: 		
0: 		// Parse the headers
0:     	HashMap headers = new HashMap(25);
0:         while (true) {
0:             String line = readLine(in, MAX_HEADER_LENGTH, "The maximum header length was exceeded");
0:             if (line != null && line.trim().length() > 0) {
1:             	
0:             	if( headers.size() > MAX_HEADERS )
0:             		throw new ProtocolException("The maximum number of headers was exceeded");
1:             	
0:                 try {
0:                     int seperator_index = line.indexOf(Stomp.Headers.SEPERATOR);
0:                     String name = line.substring(0, seperator_index).trim();
0:                     String value = line.substring(seperator_index + 1, line.length()).trim();
0:                     headers.put(name, value);
1:                 }
0:                 catch (Exception e) {
0:                     throw new ProtocolException("Unable to parser header line [" + line + "]");
1:                 }
1:             }
0:             else {
1:                 break;
1:             }
1:         }
1:         
0:         // Read in the data part.
0:         byte[] data = NO_DATA;
0:         String contentLength = (String)headers.get(Stomp.Headers.CONTENT_LENGTH);
0:         if (contentLength!=null) {
1:             
0:         	// Bless the client, he's telling us how much data to read in.        	
0:         	int length;
0: 			try {
0: 				length = Integer.parseInt(contentLength.trim());
0: 			} catch (NumberFormatException e) {
0: 				throw new ProtocolException("Specified content-length is not a valid integer");
1: 			}
1: 
0: 			if( length > MAX_DATA_LENGTH )
0:         		throw new ProtocolException("The maximum data length was exceeded");
1: 			
0:             data = new byte[length];
0:             in.readFully(data);
1:             
0:             if (in.readByte() != 0) {
0:                 throw new ProtocolException(Stomp.Headers.CONTENT_LENGTH+" bytes were read and " + "there was no trailing null byte");
1:             }
1:         
1:         } else {
1: 
0:         	// We don't know how much to read.. data ends when we hit a 0
0:             byte b;
0:             ByteArrayOutputStream baos=null;
0:             while ((b = in.readByte()) != 0) {
1:     			
0:     			if( baos == null ) {
0:             		baos = new ByteArrayOutputStream();
0:             	} else if( baos.size() > MAX_DATA_LENGTH ) {
0:             		throw new ProtocolException("The maximum data length was exceeded");
1:             	}
1:             
0:                 baos.write(b);
1:             }
1:             
0:             if( baos!=null ) {
1: 	            baos.close();
0: 	            data = baos.toByteArray();
1:             }
1:             
1:         }
1:         
0:         return new StompCommand(action, headers, data); 
1: 
1:     }
1: 
0:     private String readLine(DataInputStream in, int maxLength, String errorMessage) throws IOException {
0:         byte b;
0:         ByteArrayOutputStream baos=new ByteArrayOutputStream(maxLength);
1:         while ((b = in.readByte()) != '\n') {
0:         	if( baos.size() > maxLength )
0:         		throw new ProtocolException(errorMessage);
0:             baos.write(b);
1:         }
0:         ByteSequence sequence = baos.toByteSequence();
0: 		return new String(sequence.getData(),sequence.getOffset(),sequence.getLength(),"UTF-8");
1: 	}
1: 
0: 	public int getVersion() {
1:         return version;
1:     }
1: 
1:     public void setVersion(int version) {
1:         this.version = version;
1:     }
1: 
1: }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:6d08aca
/////////////////////////////////////////////////////////////////////////
0:                 baos.close();
0: 
1:         ByteSequence line = baos.toByteSequence();
0: 
1:         if (stompVersion.equals(Stomp.V1_0) || stompVersion.equals(Stomp.V1_2)) {
1:             int lineLength = line.getLength();
1:             if (lineLength > 0 && line.data[lineLength-1] == '\r') {
1:                 line.setLength(lineLength-1);
0:             }
0:         }
0: 
1:         return line;
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:                         headers.put(name, value);
0: 
1:                     stream.close();
0: 
commit:8aadc4b
/////////////////////////////////////////////////////////////////////////
0: 
1:                     if (!headers.containsKey(name)) {
0:                     	headers.put(name, value);
0:                     }
commit:9601f67
/////////////////////////////////////////////////////////////////////////
1:                     String name = new String(nameSeq.getData(), nameSeq.getOffset(), nameSeq.getLength(), "UTF-8");
commit:956724e
/////////////////////////////////////////////////////////////////////////
1: import java.io.DataInput;
0: import java.io.DataInputStream;
1: import java.io.DataOutput;
0: import java.io.DataOutputStream;
0: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.PushbackInputStream;
0: import java.util.HashMap;
0: import java.util.Map;
0: 
/////////////////////////////////////////////////////////////////////////
1:                     String value = decodeHeader(headerLine);
commit:0885c60
/////////////////////////////////////////////////////////////////////////
0: import java.io.InputStream;
0: import java.io.PushbackInputStream;
/////////////////////////////////////////////////////////////////////////
0:     private boolean encodingEnabled = false;
/////////////////////////////////////////////////////////////////////////
0:         if (stomp.getAction().equals(Stomp.Commands.KEEPALIVE)) {
0:             os.write(Stomp.BREAK);
0:             return;
0:         }
0: 
0:         StringBuilder buffer = new StringBuilder();
1:         for (Map.Entry<String, String> entry : stomp.getHeaders().entrySet()) {
1:             buffer.append(encodeHeader(entry.getValue()));
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         ByteSequence sequence = readHeaderLine(in, maxLength, errorMessage);
1:         return new String(sequence.getData(), sequence.getOffset(), sequence.getLength(), "UTF-8").trim();
0:     }
0: 
1:     private ByteSequence readHeaderLine(DataInput in, int maxLength, String errorMessage) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:         return baos.toByteSequence();
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:             ByteSequence line = readHeaderLine(in, MAX_HEADER_LENGTH, "The maximum header length was exceeded");
0:             if (line != null && line.length > 0) {
0: 
1:                     ByteArrayInputStream headerLine = new ByteArrayInputStream(line);
1:                     ByteArrayOutputStream stream = new ByteArrayOutputStream(line.length);
0: 
1:                     // First complete the name
1:                     int result = -1;
1:                     while ((result = headerLine.read()) != -1) {
1:                         if (result != ':') {
1:                             stream.write(result);
0:                         } else {
1:                             break;
0:                         }
0:                     }
0: 
1:                     ByteSequence nameSeq = stream.toByteSequence();
0:                     String name = new String(nameSeq.getData(), nameSeq.getOffset(), nameSeq.getLength(), "UTF-8").trim();
0:                     String value = decodeHeader(headerLine).trim();
/////////////////////////////////////////////////////////////////////////
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:     private String encodeHeader(String header) throws IOException {
1:         String result = header;
0:         if (this.encodingEnabled) {
1:             byte[] utf8buf = header.getBytes("UTF-8");
1:             ByteArrayOutputStream stream = new ByteArrayOutputStream(utf8buf.length);
1:             for(byte val : utf8buf) {
1:                 switch(val) {
1:                 case Stomp.ESCAPE:
1:                     stream.write(Stomp.ESCAPE_ESCAPE_SEQ);
1:                     break;
1:                 case Stomp.BREAK:
1:                     stream.write(Stomp.NEWLINE_ESCAPE_SEQ);
1:                     break;
1:                 case Stomp.COLON:
1:                     stream.write(Stomp.COLON_ESCAPE_SEQ);
1:                     break;
1:                 default:
1:                     stream.write(val);
0:                 }
0:             }
0:         }
0: 
1:         return result;
0:     }
0: 
1:     private String decodeHeader(InputStream header) throws IOException {
1:         ByteArrayOutputStream decoded = new ByteArrayOutputStream();
1:         PushbackInputStream stream = new PushbackInputStream(header);
0: 
1:         int value = -1;
1:         while( (value = stream.read()) != -1) {
1:             if (value == 92) {
0: 
1:                 int next = stream.read();
1:                 if (next != -1) {
1:                     switch(next) {
1:                     case 110:
1:                         decoded.write(Stomp.BREAK);
1:                         break;
1:                     case 99:
1:                         decoded.write(Stomp.COLON);
1:                         break;
1:                     case 92:
1:                         decoded.write(Stomp.ESCAPE);
1:                         break;
1:                     default:
1:                         stream.unread(next);
1:                         decoded.write(value);
0:                     }
0:                 } else {
1:                     decoded.write(value);
0:                 }
0: 
0:             } else {
1:                 decoded.write(value);
0:             }
0:         }
0: 
1:         return new String(decoded.toByteArray(), "UTF-8");
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     public boolean isEncodingEnabled() {
0:         return this.encodingEnabled;
0:     }
0: 
0:     public void setEncodingEnabled(boolean value) {
0:         this.encodingEnabled = value;
0:     }
0: 
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:a54fa4b
/////////////////////////////////////////////////////////////////////////
1:     private String stompVersion = Stomp.DEFAULT_VERSION;
/////////////////////////////////////////////////////////////////////////
1:                     if (stompVersion.equals(Stomp.V1_0)) {
1:                         value = value.trim();
0:                     }
/////////////////////////////////////////////////////////////////////////
1:         if (!stompVersion.equals(Stomp.V1_0)) {
/////////////////////////////////////////////////////////////////////////
1:     public String getStompVersion() {
1:         return stompVersion;
1:     public void setStompVersion(String stompVersion) {
1:         this.stompVersion = stompVersion;
commit:a35fdd1
/////////////////////////////////////////////////////////////////////////
0: import java.io.*;
0: import java.util.HashMap;
0: import java.util.Map;
0: 
/////////////////////////////////////////////////////////////////////////
1:             if ((action.equals(Stomp.Commands.SEND) || action.equals(Stomp.Responses.MESSAGE)) && contentLength != null) {
commit:584d52c
/////////////////////////////////////////////////////////////////////////
0:             
1:             // parse action
0:             String action = parseAction(in);
0:             HashMap<String, String> headers = parseHeaders(in);
/////////////////////////////////////////////////////////////////////////
0:                 int length = parseContentLength(contentLength);
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected String parseAction(DataInput in) throws IOException {
0:         String action = null;
0: 
0:         // skip white space to next real action line
0:         while (true) {
0:             action = readLine(in, MAX_COMMAND_LENGTH, "The maximum command length was exceeded");
0:             if (action == null) {
0:                 throw new IOException("connection was closed");
0:             } else {
0:                 action = action.trim();
0:                 if (action.length() > 0) {
0:                     break;
0:                 }
0:             }
0:         }
1:         return action;
0:     }
0:     
0:     protected HashMap<String, String> parseHeaders(DataInput in) throws IOException {
0:         HashMap<String, String> headers = new HashMap<String, String>(25);
0:         while (true) {
0:             String line = readLine(in, MAX_HEADER_LENGTH, "The maximum header length was exceeded");
0:             if (line != null && line.trim().length() > 0) {
0: 
0:                 if (headers.size() > MAX_HEADERS) {
0:                     throw new ProtocolException("The maximum number of headers was exceeded", true);
0:                 }
0: 
0:                 try {
0:                     int seperatorIndex = line.indexOf(Stomp.Headers.SEPERATOR);
0:                     String name = line.substring(0, seperatorIndex).trim();
0:                     String value = line.substring(seperatorIndex + 1, line.length()).trim();
0:                     headers.put(name, value);
0:                 } catch (Exception e) {
0:                     throw new ProtocolException("Unable to parser header line [" + line + "]", true);
0:                 }
0:             } else {
0:                 break;
0:             }
0:         }     
1:         return headers;
0:     }
0:     
0:     protected int parseContentLength(String contentLength) throws ProtocolException {
0:         int length;
0:         try {
0:             length = Integer.parseInt(contentLength.trim());
0:         } catch (NumberFormatException e) {
0:             throw new ProtocolException("Specified content-length is not a valid integer", true);
0:         }
0: 
0:         if (length > MAX_DATA_LENGTH) {
0:             throw new ProtocolException("The maximum data length was exceeded", true);
0:         }
0:         
1:         return length;
0:     }
commit:15065b7
/////////////////////////////////////////////////////////////////////////
0: 	public boolean inReceive() {
0: 		//TODO implement the inactivity monitor
0: 		return false;
0: 	}
0:     
0:     
0: 
author:Gary Tully
-------------------------------------------------------------------------------
commit:e32ff5c
/////////////////////////////////////////////////////////////////////////
1:             if (line != null && line.length > 1) {
commit:a36e618
/////////////////////////////////////////////////////////////////////////
1:             result =  new String(stream.toByteArray(), "UTF-8");
author:Robert Davies
-------------------------------------------------------------------------------
commit:d36c0d4
/////////////////////////////////////////////////////////////////////////
0:         baos.close();
commit:4821b9d
/////////////////////////////////////////////////////////////////////////
0: import java.io.DataInput;
0: import java.io.DataOutput;
/////////////////////////////////////////////////////////////////////////
0:     public void marshal(Object command, DataOutput os) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     public Object unmarshal(DataInput in) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     private String readLine(DataInput in, int maxLength, String errorMessage) throws IOException {
============================================================================