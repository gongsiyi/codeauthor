1:456a2ba: /**
1:456a2ba:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:456a2ba:  * contributor license agreements.  See the NOTICE file distributed with
1:456a2ba:  * this work for additional information regarding copyright ownership.
1:456a2ba:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:456a2ba:  * (the "License"); you may not use this file except in compliance with
1:456a2ba:  * the License.  You may obtain a copy of the License at
1:456a2ba:  *
1:456a2ba:  *      http://www.apache.org/licenses/LICENSE-2.0
1:456a2ba:  *
1:456a2ba:  * Unless required by applicable law or agreed to in writing, software
1:456a2ba:  * distributed under the License is distributed on an "AS IS" BASIS,
1:456a2ba:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:456a2ba:  * See the License for the specific language governing permissions and
1:456a2ba:  * limitations under the License.
1:456a2ba:  */
1:f62737b: package org.apache.activemq.store.kahadb;
1:456a2ba: 
1:456a2ba: import java.io.DataInputStream;
1:456a2ba: import java.io.IOException;
1:ea84378: import java.io.InterruptedIOException;
1:456a2ba: import java.util.ArrayList;
1:ea84378: import java.util.HashMap;
1:456a2ba: import java.util.HashSet;
1:456a2ba: import java.util.Iterator;
1:76f842d: import java.util.LinkedList;
1:ea84378: import java.util.List;
1:456a2ba: import java.util.Map;
1:456a2ba: import java.util.Map.Entry;
1:bc4392b: import java.util.Set;
1:bc4392b: import java.util.concurrent.BlockingQueue;
1:bc4392b: import java.util.concurrent.ExecutorService;
1:bc4392b: import java.util.concurrent.FutureTask;
1:bc4392b: import java.util.concurrent.LinkedBlockingQueue;
1:bc4392b: import java.util.concurrent.Semaphore;
1:bc4392b: import java.util.concurrent.ThreadFactory;
1:bc4392b: import java.util.concurrent.ThreadPoolExecutor;
1:bc4392b: import java.util.concurrent.TimeUnit;
1:140ce1b: import java.util.concurrent.TimeoutException;
1:ea84378: import java.util.concurrent.atomic.AtomicBoolean;
1:ea84378: import java.util.concurrent.atomic.AtomicInteger;
1:0f0bdb2: import java.util.concurrent.atomic.AtomicReference;
1:bc4392b: 
1:456a2ba: import org.apache.activemq.broker.ConnectionContext;
1:97c127d: import org.apache.activemq.broker.region.BaseDestination;
1:74846bb: import org.apache.activemq.broker.scheduler.JobSchedulerStore;
1:456a2ba: import org.apache.activemq.command.ActiveMQDestination;
1:456a2ba: import org.apache.activemq.command.ActiveMQQueue;
1:456a2ba: import org.apache.activemq.command.ActiveMQTempQueue;
1:456a2ba: import org.apache.activemq.command.ActiveMQTempTopic;
1:456a2ba: import org.apache.activemq.command.ActiveMQTopic;
1:456a2ba: import org.apache.activemq.command.Message;
1:456a2ba: import org.apache.activemq.command.MessageAck;
1:456a2ba: import org.apache.activemq.command.MessageId;
1:1595378: import org.apache.activemq.command.ProducerId;
1:456a2ba: import org.apache.activemq.command.SubscriptionInfo;
1:456a2ba: import org.apache.activemq.command.TransactionId;
1:456a2ba: import org.apache.activemq.openwire.OpenWireFormat;
1:456a2ba: import org.apache.activemq.protobuf.Buffer;
1:74846bb: import org.apache.activemq.store.AbstractMessageStore;
1:54e2e3b: import org.apache.activemq.store.IndexListener;
1:74846bb: import org.apache.activemq.store.ListenableFuture;
1:74846bb: import org.apache.activemq.store.MessageRecoveryListener;
1:74846bb: import org.apache.activemq.store.MessageStore;
1:785b16b: import org.apache.activemq.store.MessageStoreStatistics;
1:cf3d419: import org.apache.activemq.store.MessageStoreSubscriptionStatistics;
1:18571ce: import org.apache.activemq.store.NoLocalSubscriptionAware;
1:74846bb: import org.apache.activemq.store.PersistenceAdapter;
1:ea70e82: import org.apache.activemq.store.ProxyMessageStore;
1:74846bb: import org.apache.activemq.store.TopicMessageStore;
1:74846bb: import org.apache.activemq.store.TransactionIdTransformer;
1:74846bb: import org.apache.activemq.store.TransactionStore;
1:f62737b: import org.apache.activemq.store.kahadb.data.KahaAddMessageCommand;
1:f62737b: import org.apache.activemq.store.kahadb.data.KahaDestination;
1:bc4392b: import org.apache.activemq.store.kahadb.data.KahaDestination.DestinationType;
1:f62737b: import org.apache.activemq.store.kahadb.data.KahaLocation;
1:f62737b: import org.apache.activemq.store.kahadb.data.KahaRemoveDestinationCommand;
1:f62737b: import org.apache.activemq.store.kahadb.data.KahaRemoveMessageCommand;
1:f62737b: import org.apache.activemq.store.kahadb.data.KahaSubscriptionCommand;
1:266d23e: import org.apache.activemq.store.kahadb.data.KahaUpdateMessageCommand;
1:bc4392b: import org.apache.activemq.store.kahadb.disk.journal.Location;
1:bc4392b: import org.apache.activemq.store.kahadb.disk.page.Transaction;
1:74846bb: import org.apache.activemq.store.kahadb.scheduler.JobSchedulerStoreImpl;
1:456a2ba: import org.apache.activemq.usage.MemoryUsage;
1:456a2ba: import org.apache.activemq.usage.SystemUsage;
1:2518bde: import org.apache.activemq.util.IOExceptionSupport;
1:ea84378: import org.apache.activemq.util.ServiceStopper;
1:6c1676b: import org.apache.activemq.util.ThreadPoolUtils;
1:456a2ba: import org.apache.activemq.wireformat.WireFormat;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:456a2ba: 
1:18571ce: public class KahaDBStore extends MessageDatabase implements PersistenceAdapter, NoLocalSubscriptionAware {
1:8bf987b:     static final Logger LOG = LoggerFactory.getLogger(KahaDBStore.class);
1:97c127d:     private static final int MAX_ASYNC_JOBS = BaseDestination.MAX_AUDIT_DEPTH;
1:456a2ba: 
1:76f842d:     public static final String PROPERTY_CANCELED_TASK_MOD_METRIC = "org.apache.activemq.store.kahadb.CANCELED_TASK_MOD_METRIC";
1:179bd54:     public static final int cancelledTaskModMetric = Integer.parseInt(System.getProperty(
1:179bd54:             PROPERTY_CANCELED_TASK_MOD_METRIC, "0"), 10);
1:76f842d:     public static final String PROPERTY_ASYNC_EXECUTOR_MAX_THREADS = "org.apache.activemq.store.kahadb.ASYNC_EXECUTOR_MAX_THREADS";
1:179bd54:     private static final int asyncExecutorMaxThreads = Integer.parseInt(System.getProperty(
1:1595378:             PROPERTY_ASYNC_EXECUTOR_MAX_THREADS, "1"), 10);;
1:456a2ba: 
1:ea84378:     protected ExecutorService queueExecutor;
1:ea84378:     protected ExecutorService topicExecutor;
1:76f842d:     protected final List<Map<AsyncJobKey, StoreTask>> asyncQueueMaps = new LinkedList<Map<AsyncJobKey, StoreTask>>();
1:76f842d:     protected final List<Map<AsyncJobKey, StoreTask>> asyncTopicMaps = new LinkedList<Map<AsyncJobKey, StoreTask>>();
1:cba0468:     final WireFormat wireFormat = new OpenWireFormat();
1:ea84378:     private SystemUsage usageManager;
1:ea84378:     private LinkedBlockingQueue<Runnable> asyncQueueJobQueue;
1:ea84378:     private LinkedBlockingQueue<Runnable> asyncTopicJobQueue;
1:27262c8:     Semaphore globalQueueSemaphore;
1:27262c8:     Semaphore globalTopicSemaphore;
1:ea84378:     private boolean concurrentStoreAndDispatchQueues = true;
1:e7503f1:     // when true, message order may be compromised when cache is exhausted if store is out
1:e7503f1:     // or order w.r.t cache
1:e7503f1:     private boolean concurrentStoreAndDispatchTopics = false;
1:bc4392b:     private final boolean concurrentStoreAndDispatchTransactions = false;
1:ea84378:     private int maxAsyncJobs = MAX_ASYNC_JOBS;
1:27262c8:     private final KahaDBTransactionStore transactionStore;
1:1595378:     private TransactionIdTransformer transactionIdTransformer;
1:456a2ba: 
1:ea84378:     public KahaDBStore() {
1:27262c8:         this.transactionStore = new KahaDBTransactionStore(this);
1:1595378:         this.transactionIdTransformer = new TransactionIdTransformer() {
1:54e2e3b:             @Override
1:21fe8ca:             public TransactionId transform(TransactionId txid) {
1:21fe8ca:                 return txid;
1:ec9975c:             }
1:456a2ba:         };
1:54e2e3b:     }
1:7a7c70a: 
1:54e2e3b:     @Override
1:9026274:     public String toString() {
1:9026274:         return "KahaDB:[" + directory.getAbsolutePath() + "]";
1:266d23e:     }
1:734fb7d: 
1:7a7c70a:     @Override
1:456a2ba:     public void setBrokerName(String brokerName) {
1:7a7c70a:     }
1:943db3c: 
1:734fb7d:     @Override
1:456a2ba:     public void setUsageManager(SystemUsage usageManager) {
1:ea84378:         this.usageManager = usageManager;
1:456a2ba:     }
1:180b0ec: 
1:ea84378:     public SystemUsage getUsageManager() {
1:ea84378:         return this.usageManager;
1:456a2ba:     }
1:456a2ba: 
1:7a5abeb:     /**
1:ea84378:      * @return the concurrentStoreAndDispatch
1:7a5abeb:      */
1:ea84378:     public boolean isConcurrentStoreAndDispatchQueues() {
1:ea84378:         return this.concurrentStoreAndDispatchQueues;
1:456a2ba:     }
1:456a2ba: 
1:ea84378:     /**
1:1595378:      * @param concurrentStoreAndDispatch
1:1595378:      *            the concurrentStoreAndDispatch to set
1:ea84378:      */
1:ea84378:     public void setConcurrentStoreAndDispatchQueues(boolean concurrentStoreAndDispatch) {
1:ea84378:         this.concurrentStoreAndDispatchQueues = concurrentStoreAndDispatch;
1:456a2ba:     }
1:456a2ba: 
1:ea84378:     /**
1:ea84378:      * @return the concurrentStoreAndDispatch
1:ea84378:      */
1:ea84378:     public boolean isConcurrentStoreAndDispatchTopics() {
1:ea84378:         return this.concurrentStoreAndDispatchTopics;
1:456a2ba:     }
1:456a2ba: 
1:ea84378:     /**
1:1595378:      * @param concurrentStoreAndDispatch
1:1595378:      *            the concurrentStoreAndDispatch to set
1:ea84378:      */
1:ea84378:     public void setConcurrentStoreAndDispatchTopics(boolean concurrentStoreAndDispatch) {
1:ea84378:         this.concurrentStoreAndDispatchTopics = concurrentStoreAndDispatch;
1:456a2ba:     }
1:456a2ba: 
1:7a5abeb:     public boolean isConcurrentStoreAndDispatchTransactions() {
1:7a5abeb:         return this.concurrentStoreAndDispatchTransactions;
1:456a2ba:     }
1:943db3c: 
1:7a5abeb:     /**
1:ea84378:      * @return the maxAsyncJobs
1:7a5abeb:      */
1:ea84378:     public int getMaxAsyncJobs() {
1:ea84378:         return this.maxAsyncJobs;
1:456a2ba:     }
1:74846bb: 
1:ea84378:     /**
1:1595378:      * @param maxAsyncJobs
1:1595378:      *            the maxAsyncJobs to set
1:ea84378:      */
1:ea84378:     public void setMaxAsyncJobs(int maxAsyncJobs) {
1:ea84378:         this.maxAsyncJobs = maxAsyncJobs;
1:456a2ba:     }
1:7a7c70a: 
1:456a2ba: 
1:c5a1b86:     @Override
1:7a7c70a:     protected void configureMetadata() {
1:bc4392b:         if (brokerService != null) {
1:bc4392b:             metadata.openwireVersion = brokerService.getStoreOpenWireVersion();
1:bc4392b:             wireFormat.setVersion(metadata.openwireVersion);
1:bc4392b: 
1:bc4392b:             if (LOG.isDebugEnabled()) {
1:bc4392b:                 LOG.debug("Store OpenWire version configured as: {}", metadata.openwireVersion);
1:bc4392b:             }
1:bc4392b: 
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba: 
1:74846bb:     @Override
1:7a7c70a:     public void doStart() throws Exception {
1:7a7c70a:         //configure the metadata before start, right now
1:7a7c70a:         //this is just the open wire version
1:7a7c70a:         configureMetadata();
1:7a7c70a: 
1:1a5ad28:         super.doStart();
1:bc4392b: 
1:bc4392b:         if (brokerService != null) {
1:bc4392b:             // In case the recovered store used a different OpenWire version log a warning
1:bc4392b:             // to assist in determining why journal reads fail.
1:bc4392b:             if (metadata.openwireVersion != brokerService.getStoreOpenWireVersion()) {
1:13044de:                 LOG.warn("Existing Store uses a different OpenWire version[{}] " +
1:13044de:                          "than the version configured[{}] reverting to the version " +
1:13044de:                          "used by this store, some newer broker features may not work" +
1:13044de:                          "as expected.",
1:bc4392b:                          metadata.openwireVersion, brokerService.getStoreOpenWireVersion());
1:13044de: 
1:13044de:                 // Update the broker service instance to the actual version in use.
1:13044de:                 wireFormat.setVersion(metadata.openwireVersion);
1:13044de:                 brokerService.setStoreOpenWireVersion(metadata.openwireVersion);
1:bc4392b:             }
1:bc4392b:         }
1:bc4392b: 
1:27262c8:         this.globalQueueSemaphore = new Semaphore(getMaxAsyncJobs());
1:27262c8:         this.globalTopicSemaphore = new Semaphore(getMaxAsyncJobs());
1:ea84378:         this.asyncQueueJobQueue = new LinkedBlockingQueue<Runnable>(getMaxAsyncJobs());
1:ea84378:         this.asyncTopicJobQueue = new LinkedBlockingQueue<Runnable>(getMaxAsyncJobs());
1:15de238:         this.queueExecutor = new StoreTaskExecutor(1, asyncExecutorMaxThreads, 0L, TimeUnit.MILLISECONDS,
1:bc4392b:             asyncQueueJobQueue, new ThreadFactory() {
1:bc4392b:                 @Override
1:bc4392b:                 public Thread newThread(Runnable runnable) {
1:bc4392b:                     Thread thread = new Thread(runnable, "ConcurrentQueueStoreAndDispatch");
1:bc4392b:                     thread.setDaemon(true);
1:bc4392b:                     return thread;
1:bc4392b:                 }
1:bc4392b:             });
1:15de238:         this.topicExecutor = new StoreTaskExecutor(1, asyncExecutorMaxThreads, 0L, TimeUnit.MILLISECONDS,
1:bc4392b:             asyncTopicJobQueue, new ThreadFactory() {
1:bc4392b:                 @Override
1:bc4392b:                 public Thread newThread(Runnable runnable) {
1:bc4392b:                     Thread thread = new Thread(runnable, "ConcurrentTopicStoreAndDispatch");
1:bc4392b:                     thread.setDaemon(true);
1:bc4392b:                     return thread;
1:bc4392b:                 }
1:bc4392b:             });
1:456a2ba:     }
1:d96c1cb: 
1:bc4392b:     @Override
1:ea84378:     public void doStop(ServiceStopper stopper) throws Exception {
1:179bd54:         // drain down async jobs
1:e703088:         LOG.info("Stopping async queue tasks");
1:e85dda9:         if (this.globalQueueSemaphore != null) {
1:e85dda9:             this.globalQueueSemaphore.tryAcquire(this.maxAsyncJobs, 60, TimeUnit.SECONDS);
1:81e1de9:         }
1:76f842d:         synchronized (this.asyncQueueMaps) {
1:76f842d:             for (Map<AsyncJobKey, StoreTask> m : asyncQueueMaps) {
1:76f842d:                 synchronized (m) {
1:76f842d:                     for (StoreTask task : m.values()) {
1:76f842d:                         task.cancel();
1:81e1de9:                     }
1:fb0b63e:                 }
1:fb0b63e:             }
1:76f842d:             this.asyncQueueMaps.clear();
1:fb0b63e:         }
1:e703088:         LOG.info("Stopping async topic tasks");
1:e85dda9:         if (this.globalTopicSemaphore != null) {
1:e85dda9:             this.globalTopicSemaphore.tryAcquire(this.maxAsyncJobs, 60, TimeUnit.SECONDS);
1:2030097:         }
1:76f842d:         synchronized (this.asyncTopicMaps) {
1:76f842d:             for (Map<AsyncJobKey, StoreTask> m : asyncTopicMaps) {
1:76f842d:                 synchronized (m) {
1:76f842d:                     for (StoreTask task : m.values()) {
1:76f842d:                         task.cancel();
1:1595378:                     }
1:1595378:                 }
1:1595378:             }
1:76f842d:             this.asyncTopicMaps.clear();
1:9026274:         }
1:27262c8:         if (this.globalQueueSemaphore != null) {
1:27262c8:             this.globalQueueSemaphore.drainPermits();
1:101e711:         }
1:27262c8:         if (this.globalTopicSemaphore != null) {
1:27262c8:             this.globalTopicSemaphore.drainPermits();
1:6fd292d:         }
1:ea84378:         if (this.queueExecutor != null) {
1:6c1676b:             ThreadPoolUtils.shutdownNow(queueExecutor);
1:6c1676b:             queueExecutor = null;
1:6fd292d:         }
1:ea84378:         if (this.topicExecutor != null) {
1:6c1676b:             ThreadPoolUtils.shutdownNow(topicExecutor);
1:6c1676b:             topicExecutor = null;
1:6fd292d:         }
1:e703088:         LOG.info("Stopped KahaDB");
1:ea84378:         super.doStop(stopper);
1:2030097:     }
1:fb0b63e: 
1:2030097:     private Location findMessageLocation(final String key, final KahaDestination destination) throws IOException {
1:2030097:         return pageFile.tx().execute(new Transaction.CallableClosure<Location, IOException>() {
1:bc4392b:             @Override
1:456a2ba:             public Location execute(Transaction tx) throws IOException {
2:2030097:                 StoredDestination sd = getStoredDestination(destination, tx);
1:456a2ba:                 Long sequence = sd.messageIdIndex.get(tx, key);
1:2030097:                 if (sequence == null) {
2:456a2ba:                     return null;
1:9705671:                 }
1:456a2ba:                 return sd.orderIndex.get(tx, sequence).location;
1:76f842d:             }
3:456a2ba:         });
1:76f842d:     }
1:2030097: 
1:27262c8:     protected StoreQueueTask removeQueueTask(KahaDBMessageStore store, MessageId id) {
1:27262c8:         StoreQueueTask task = null;
2:76f842d:         synchronized (store.asyncTaskMap) {
1:76f842d:             task = (StoreQueueTask) store.asyncTaskMap.remove(new AsyncJobKey(id, store.getDestination()));
1:76f842d:         }
1:ea84378:         return task;
1:76f842d:     }
1:2030097: 
1:499e39e:     // with asyncTaskMap locked
1:27262c8:     protected void addQueueTask(KahaDBMessageStore store, StoreQueueTask task) throws IOException {
1:499e39e:         store.asyncTaskMap.put(new AsyncJobKey(task.getMessage().getMessageId(), store.getDestination()), task);
1:ea84378:         this.queueExecutor.execute(task);
1:76f842d:     }
1:2030097: 
1:76f842d:     protected StoreTopicTask removeTopicTask(KahaDBTopicMessageStore store, MessageId id) {
1:27262c8:         StoreTopicTask task = null;
1:76f842d:         synchronized (store.asyncTaskMap) {
1:76f842d:             task = (StoreTopicTask) store.asyncTaskMap.remove(new AsyncJobKey(id, store.getDestination()));
1:e85dda9:         }
1:ea84378:         return task;
1:e85dda9:     }
1:2030097: 
1:76f842d:     protected void addTopicTask(KahaDBTopicMessageStore store, StoreTopicTask task) throws IOException {
1:76f842d:         synchronized (store.asyncTaskMap) {
2:76f842d:             store.asyncTaskMap.put(new AsyncJobKey(task.getMessage().getMessageId(), store.getDestination()), task);
1:33f4190:         }
1:ea84378:         this.topicExecutor.execute(task);
1:9bb4682:     }
1:1595378: 
1:bc4392b:     @Override
1:456a2ba:     public TransactionStore createTransactionStore() throws IOException {
1:27262c8:         return this.transactionStore;
1:8e61f51:     }
1:1595378: 
1:f2517c0:     public boolean getForceRecoverIndex() {
1:f2517c0:         return this.forceRecoverIndex;
1:f2517c0:     }
1:1595378: 
1:f2517c0:     public void setForceRecoverIndex(boolean forceRecoverIndex) {
1:f2517c0:         this.forceRecoverIndex = forceRecoverIndex;
1:ea70e82:     }
1:54e2e3b: 
1:ea70e82:     public void forgetRecoveredAcks(ArrayList<MessageAck> preparedAcks, boolean isRollback) throws IOException {
1:ea70e82:         if (preparedAcks != null) {
1:ea70e82:             Map<ActiveMQDestination, KahaDBMessageStore> stores = new HashMap<>();
1:ea70e82:             for (MessageAck ack : preparedAcks) {
1:ea70e82:                 stores.put(ack.getDestination(), findMatchingStore(ack.getDestination()));
1:ea70e82:             }
1:ea70e82:             ArrayList<MessageAck> perStoreAcks = new ArrayList<>();
1:ea70e82:             for (Entry<ActiveMQDestination, KahaDBMessageStore> entry : stores.entrySet()) {
1:ea70e82:                 for (MessageAck ack : preparedAcks) {
1:ea70e82:                     if (entry.getKey().equals(ack.getDestination())) {
1:ea70e82:                         perStoreAcks.add(ack);
1:ea70e82:                     }
1:ea70e82:                 }
1:ea70e82:                 entry.getValue().forgetRecoveredAcks(perStoreAcks, isRollback);
1:ea70e82:                 perStoreAcks.clear();
1:ea70e82:             }
1:ea70e82:         }
1:ea70e82:     }
1:ea70e82: 
1:ea70e82:     public void trackRecoveredAcks(ArrayList<MessageAck> preparedAcks) throws IOException {
1:ea70e82:         Map<ActiveMQDestination, KahaDBMessageStore> stores = new HashMap<>();
1:ea70e82:         for (MessageAck ack : preparedAcks) {
1:ea70e82:             stores.put(ack.getDestination(), findMatchingStore(ack.getDestination()));
1:ea70e82:         }
1:ea70e82:         ArrayList<MessageAck> perStoreAcks = new ArrayList<>();
1:ea70e82:         for (Entry<ActiveMQDestination, KahaDBMessageStore> entry : stores.entrySet()) {
1:ea70e82:             for (MessageAck ack : preparedAcks) {
1:ea70e82:                 if (entry.getKey().equals(ack.getDestination())) {
1:ea70e82:                     perStoreAcks.add(ack);
1:ea70e82:                 }
1:54e2e3b:             }
1:ea70e82:             entry.getValue().trackRecoveredAcks(perStoreAcks);
1:ea70e82:             perStoreAcks.clear();
1:ea70e82:         }
1:ea70e82:     }
1:ea70e82: 
1:ea70e82:     private KahaDBMessageStore findMatchingStore(ActiveMQDestination activeMQDestination) throws IOException {
1:ea70e82:         ProxyMessageStore store = (ProxyMessageStore) storeCache.get(convert(activeMQDestination));
1:ea70e82:         if (store == null) {
1:ea70e82:             if (activeMQDestination.isQueue()) {
1:ea70e82:                 store = (ProxyMessageStore) createQueueMessageStore((ActiveMQQueue) activeMQDestination);
1:ea70e82:             } else {
1:ea70e82:                 store = (ProxyMessageStore) createTopicMessageStore((ActiveMQTopic) activeMQDestination);
1:ea70e82:             }
1:ea70e82:         }
1:ea70e82:         return (KahaDBMessageStore) store.getDelegate();
1:ea70e82:     }
1:ea70e82: 
1:30f41b9:     public class KahaDBMessageStore extends AbstractMessageStore {
1:76f842d:         protected final Map<AsyncJobKey, StoreTask> asyncTaskMap = new HashMap<AsyncJobKey, StoreTask>();
1:456a2ba:         protected KahaDestination dest;
1:27262c8:         private final int maxAsyncJobs;
1:27262c8:         private final Semaphore localDestinationSemaphore;
1:ea70e82:         protected final Set<String> ackedAndPrepared = new HashSet<>();
1:ea70e82:         protected final Set<String> rolledBackAcks = new HashSet<>();
1:1595378: 
1:76f842d:         double doneTasks, canceledTasks = 0;
1:9026274: 
1:456a2ba:         public KahaDBMessageStore(ActiveMQDestination destination) {
1:30f41b9:             super(destination);
1:ea84378:             this.dest = convert(destination);
1:27262c8:             this.maxAsyncJobs = getMaxAsyncJobs();
1:27262c8:             this.localDestinationSemaphore = new Semaphore(this.maxAsyncJobs);
1:456a2ba:         }
1:456a2ba: 
1:bc4392b:         @Override
1:456a2ba:         public ActiveMQDestination getDestination() {
1:456a2ba:             return destination;
1:456a2ba:         }
1:ea70e82: 
1:456a2ba: 
1:ea70e82:         // messages that have prepared (pending) acks cannot be re-dispatched unless the outcome is rollback,
1:ea70e82:         // till then they are skipped by the store.
1:ea70e82:         // 'at most once' XA guarantee
1:ea70e82:         public void trackRecoveredAcks(ArrayList<MessageAck> acks) {
1:ea70e82:             indexLock.writeLock().lock();
1:ea70e82:             try {
1:ea70e82:                 for (MessageAck ack : acks) {
1:ea70e82:                     ackedAndPrepared.add(ack.getLastMessageId().toProducerKey());
1:ea70e82:                 }
1:ea70e82:             } finally {
1:ea70e82:                 indexLock.writeLock().unlock();
1:ea70e82:             }
1:ea70e82:         }
1:ea70e82: 
1:ea70e82:         public void forgetRecoveredAcks(ArrayList<MessageAck> acks, boolean rollback) throws IOException {
1:ea70e82:             if (acks != null) {
1:ea70e82:                 indexLock.writeLock().lock();
1:ea70e82:                 try {
1:ea70e82:                     for (MessageAck ack : acks) {
1:ea70e82:                         final String id = ack.getLastMessageId().toProducerKey();
1:ea70e82:                         ackedAndPrepared.remove(id);
1:ea70e82:                         if (rollback) {
1:ea70e82:                             rolledBackAcks.add(id);
1:ea70e82:                             incrementAndAddSizeToStoreStat(dest, 0);
1:ea70e82:                         }
1:ea70e82:                     }
1:ea70e82:                 } finally {
1:ea70e82:                     indexLock.writeLock().unlock();
1:ea70e82:                 }
1:ea70e82:             }
1:ea70e82:         }
1:ea70e82: 
1:bc4392b:         @Override
1:ad1f751:         public ListenableFuture<Object> asyncAddQueueMessage(final ConnectionContext context, final Message message)
1:ea84378:                 throws IOException {
1:54e2e3b:             if (isConcurrentStoreAndDispatchQueues()) {
1:11622b3:                 message.beforeMarshall(wireFormat);
1:ea84378:                 StoreQueueTask result = new StoreQueueTask(this, context, message);
1:140ce1b:                 ListenableFuture<Object> future = result.getFuture();
1:140ce1b:                 message.getMessageId().setFutureOrSequenceLong(future);
1:140ce1b:                 message.setRecievedByDFBridge(true); // flag message as concurrentStoreAndDispatch
1:27262c8:                 result.aquireLocks();
1:499e39e:                 synchronized (asyncTaskMap) {
1:499e39e:                     addQueueTask(this, result);
1:499e39e:                     if (indexListener != null) {
1:499e39e:                         indexListener.onAdd(new IndexListener.MessageContext(context, message, null));
1:499e39e:                     }
1:54e2e3b:                 }
1:54e2e3b:                 return future;
1:54e2e3b:             } else {
1:ea84378:                 return super.asyncAddQueueMessage(context, message);
1:456a2ba:             }
1:9f417a2:         }
1:456a2ba: 
1:54e2e3b:         @Override
1:ea84378:         public void removeAsyncMessage(ConnectionContext context, MessageAck ack) throws IOException {
2:ea84378:             if (isConcurrentStoreAndDispatchQueues()) {
1:27262c8:                 AsyncJobKey key = new AsyncJobKey(ack.getLastMessageId(), getDestination());
1:27262c8:                 StoreQueueTask task = null;
1:76f842d:                 synchronized (asyncTaskMap) {
1:76f842d:                     task = (StoreQueueTask) asyncTaskMap.get(key);
1:f2517c0:                 }
1:ea84378:                 if (task != null) {
1:20d3bdb:                     if (ack.isInTransaction() || !task.cancel()) {
1:a604424:                         try {
1:33f4190:                             task.future.get();
1:33f4190:                         } catch (InterruptedException e) {
1:33f4190:                             throw new InterruptedIOException(e.toString());
1:33f4190:                         } catch (Exception ignored) {
1:33f4190:                             LOG.debug("removeAsync: cannot cancel, waiting for add resulted in ex", ignored);
1:33f4190:                         }
1:ea84378:                         removeMessage(context, ack);
1:456a2ba:                     } else {
1:f8bc19b:                         indexLock.writeLock().lock();
1:f8bc19b:                         try {
1:f8bc19b:                             metadata.producerSequenceIdTracker.isDuplicate(ack.getLastMessageId());
1:f8bc19b:                         } finally {
1:f8bc19b:                             indexLock.writeLock().unlock();
1:f8bc19b:                         }
1:76f842d:                         synchronized (asyncTaskMap) {
1:76f842d:                             asyncTaskMap.remove(key);
1:8e61f51:                         }
1:179bd54:                     }
1:b07f31e:                 } else {
1:ea84378:                     removeMessage(context, ack);
1:7a5abeb:                 }
1:9705671:             } else {
1:ea84378:                 removeMessage(context, ack);
1:7a5abeb:             }
1:27262c8:         }
1:456a2ba: 
1:bc4392b:         @Override
1:54e2e3b:         public void addMessage(final ConnectionContext context, final Message message) throws IOException {
1:140ce1b:             final KahaAddMessageCommand command = new KahaAddMessageCommand();
1:456a2ba:             command.setDestination(dest);
1:b2b4fc8:             command.setMessageId(message.getMessageId().toProducerKey());
1:21fe8ca:             command.setTransactionInfo(TransactionIdConversion.convert(transactionIdTransformer.transform(message.getTransactionId())));
1:cba0468:             command.setPriority(message.getPriority());
1:cba0468:             command.setPrioritySupported(isPrioritizedMessages());
1:456a2ba:             org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(message);
1:456a2ba:             command.setMessage(new Buffer(packet.getData(), packet.getOffset(), packet.getLength()));
1:9ae5b41:             store(command, isEnableJournalDiskSyncs() && message.isResponseRequired(), new IndexAware() {
1:9ae5b41:                 // sync add? (for async, future present from getFutureOrSequenceLong)
1:9ae5b41:                 Object possibleFuture = message.getMessageId().getFutureOrSequenceLong();
1:140ce1b: 
1:9ae5b41:                 @Override
1:9ae5b41:                 public void sequenceAssignedWithIndexLocked(final long sequence) {
1:9ae5b41:                     message.getMessageId().setFutureOrSequenceLong(sequence);
1:9ae5b41:                     if (indexListener != null) {
1:9ae5b41:                         if (possibleFuture == null) {
1:9ae5b41:                             trackPendingAdd(dest, sequence);
1:9ae5b41:                             indexListener.onAdd(new IndexListener.MessageContext(context, message, new Runnable() {
1:9ae5b41:                                 @Override
1:9ae5b41:                                 public void run() {
1:9ae5b41:                                     trackPendingAddComplete(dest, sequence);
1:9ae5b41:                                 }
1:9ae5b41:                             }));
1:9ae5b41:                         }
1:140ce1b:                     }
1:140ce1b:                 }
1:9ae5b41:             }, null);
1:54e2e3b:         }
1:943db3c: 
1:140ce1b:         @Override
1:266d23e:         public void updateMessage(Message message) throws IOException {
1:266d23e:             if (LOG.isTraceEnabled()) {
1:266d23e:                 LOG.trace("updating: " + message.getMessageId() + " with deliveryCount: " + message.getRedeliveryCounter());
1:54e2e3b:             }
1:266d23e:             KahaUpdateMessageCommand updateMessageCommand = new KahaUpdateMessageCommand();
1:266d23e:             KahaAddMessageCommand command = new KahaAddMessageCommand();
1:266d23e:             command.setDestination(dest);
1:266d23e:             command.setMessageId(message.getMessageId().toProducerKey());
1:266d23e:             command.setPriority(message.getPriority());
1:266d23e:             command.setPrioritySupported(prioritizedMessages);
1:266d23e:             org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(message);
1:266d23e:             command.setMessage(new Buffer(packet.getData(), packet.getOffset(), packet.getLength()));
1:266d23e:             updateMessageCommand.setMessage(command);
1:266d23e:             store(updateMessageCommand, isEnableJournalDiskSyncs(), null, null);
1:54e2e3b:         }
1:266d23e: 
1:54e2e3b:         @Override
1:456a2ba:         public void removeMessage(ConnectionContext context, MessageAck ack) throws IOException {
1:456a2ba:             KahaRemoveMessageCommand command = new KahaRemoveMessageCommand();
1:456a2ba:             command.setDestination(dest);
1:b2b4fc8:             command.setMessageId(ack.getLastMessageId().toProducerKey());
1:21fe8ca:             command.setTransactionInfo(TransactionIdConversion.convert(transactionIdTransformer.transform(ack.getTransactionId())));
1:da0490b: 
1:da0490b:             org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(ack);
1:da0490b:             command.setAck(new Buffer(packet.getData(), packet.getOffset(), packet.getLength()));
1:1595378:             store(command, isEnableJournalDiskSyncs() && ack.isResponseRequired(), null, null);
1:54e2e3b:         }
1:456a2ba: 
1:bc4392b:         @Override
1:456a2ba:         public void removeAllMessages(ConnectionContext context) throws IOException {
1:456a2ba:             KahaRemoveDestinationCommand command = new KahaRemoveDestinationCommand();
1:456a2ba:             command.setDestination(dest);
1:1595378:             store(command, true, null, null);
1:266d23e:         }
1:456a2ba: 
1:bc4392b:         @Override
1:456a2ba:         public Message getMessage(MessageId identity) throws IOException {
1:140ce1b:             final String key = identity.toProducerKey();
1:456a2ba: 
1:27262c8:             // Hopefully one day the page file supports concurrent read
1:27262c8:             // operations... but for now we must
1:180b0ec:             // externally synchronize...
1:456a2ba:             Location location;
1:a3f85e2:             indexLock.writeLock().lock();
1:54e2e3b:             try {
1:2030097:                 location = findMessageLocation(key, dest);
1:74846bb:             } finally {
1:a3f85e2:                 indexLock.writeLock().unlock();
1:456a2ba:             }
1:ea84378:             if (location == null) {
1:456a2ba:                 return null;
1:456a2ba:             }
1:943db3c: 
1:456a2ba:             return loadMessage(location);
1:456a2ba:         }
1:456a2ba: 
1:bc4392b:         @Override
1:affd91e:         public boolean isEmpty() throws IOException {
1:a3f85e2:             indexLock.writeLock().lock();
1:9f417a2:             try {
1:ea84378:                 return pageFile.tx().execute(new Transaction.CallableClosure<Boolean, IOException>() {
1:bc4392b:                     @Override
1:affd91e:                     public Boolean execute(Transaction tx) throws IOException {
1:ea84378:                         // Iterate through all index entries to get a count of
1:27262c8:                         // messages in the destination.
5:456a2ba:                         StoredDestination sd = getStoredDestination(dest, tx);
1:a33d668:                         return sd.locationIndex.isEmpty(tx);
1:456a2ba:                     }
1:456a2ba:                 });
1:74846bb:             } finally {
1:a3f85e2:                 indexLock.writeLock().unlock();
1:456a2ba:             }
1:456a2ba:         }
1:456a2ba: 
1:bc4392b:         @Override
1:456a2ba:         public void recover(final MessageRecoveryListener listener) throws Exception {
1:7631ca9:             // recovery may involve expiry which will modify
1:a3f85e2:             indexLock.writeLock().lock();
1:2030097:             try {
1:cba0468:                 pageFile.tx().execute(new Transaction.Closure<Exception>() {
1:bc4392b:                     @Override
1:456a2ba:                     public void execute(Transaction tx) throws Exception {
1:456a2ba:                         StoredDestination sd = getStoredDestination(dest, tx);
1:cfe099d:                         recoverRolledBackAcks(sd, tx, Integer.MAX_VALUE, listener);
1:5cbb4db:                         sd.orderIndex.resetCursorPosition();
1:383a7ac:                         for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx); listener.hasSpace() && iterator
1:8e61f51:                                 .hasNext(); ) {
1:456a2ba:                             Entry<Long, MessageKeys> entry = iterator.next();
1:101e711:                             if (ackedAndPrepared.contains(entry.getValue().messageId)) {
1:101e711:                                 continue;
1:456a2ba:                             }
1:1595378:                             Message msg = loadMessage(entry.getValue().location);
1:cba0468:                             listener.recoverMessage(msg);
1:456a2ba:                         }
1:456a2ba:                     }
1:456a2ba:                 });
1:74846bb:             } finally {
1:a3f85e2:                 indexLock.writeLock().unlock();
1:456a2ba:             }
1:456a2ba:         }
1:456a2ba: 
1:bc4392b:         @Override
1:456a2ba:         public void recoverNextMessages(final int maxReturned, final MessageRecoveryListener listener) throws Exception {
1:a3f85e2:             indexLock.writeLock().lock();
1:d96c1cb:             try {
1:ea84378:                 pageFile.tx().execute(new Transaction.Closure<Exception>() {
1:bc4392b:                     @Override
1:456a2ba:                     public void execute(Transaction tx) throws Exception {
1:456a2ba:                         StoredDestination sd = getStoredDestination(dest, tx);
1:ea84378:                         Entry<Long, MessageKeys> entry = null;
1:cfe099d:                         int counter = recoverRolledBackAcks(sd, tx, maxReturned, listener);
1:7450a32:                         for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx); iterator.hasNext(); ) {
1:456a2ba:                             entry = iterator.next();
1:101e711:                             if (ackedAndPrepared.contains(entry.getValue().messageId)) {
1:101e711:                                 continue;
1:456a2ba:                             }
1:1595378:                             Message msg = loadMessage(entry.getValue().location);
1:54e2e3b:                             msg.getMessageId().setFutureOrSequenceLong(entry.getKey());
1:cba0468:                             listener.recoverMessage(msg);
2:456a2ba:                             counter++;
1:13ec994:                             if (counter >= maxReturned) {
1:266d23e:                                 break;
1:456a2ba:                             }
1:456a2ba:                         }
1:8cb9ef3:                         sd.orderIndex.stoppedIterating();
1:456a2ba:                     }
1:456a2ba:                 });
1:74846bb:             } finally {
1:a3f85e2:                 indexLock.writeLock().unlock();
1:456a2ba:             }
1:456a2ba:         }
1:456a2ba: 
1:cfe099d:         protected int recoverRolledBackAcks(StoredDestination sd, Transaction tx, int maxReturned, MessageRecoveryListener listener) throws Exception {
1:cfe099d:             int counter = 0;
1:cfe099d:             String id;
1:cfe099d:             for (Iterator<String> iterator = rolledBackAcks.iterator(); iterator.hasNext(); ) {
1:cfe099d:                 id = iterator.next();
1:cfe099d:                 iterator.remove();
1:cfe099d:                 Long sequence = sd.messageIdIndex.get(tx, id);
1:cfe099d:                 if (sequence != null) {
1:cfe099d:                     if (sd.orderIndex.alreadyDispatched(sequence)) {
1:cfe099d:                         listener.recoverMessage(loadMessage(sd.orderIndex.get(tx, sequence).location));
1:cfe099d:                         counter++;
1:cfe099d:                         if (counter >= maxReturned) {
1:cfe099d:                             break;
1:cfe099d:                         }
1:cfe099d:                     } else {
1:cfe099d:                         LOG.info("rolledback ack message {} with seq {} will be picked up in future batch {}", id, sequence, sd.orderIndex.cursor);
1:cfe099d:                     }
1:cfe099d:                 } else {
1:cfe099d:                     LOG.warn("Failed to locate rolled back ack message {} in {}", id, sd);
1:cfe099d:                 }
1:cfe099d:             }
1:cfe099d:             return counter;
1:cfe099d:         }
1:cfe099d: 
1:cfe099d: 
1:bc4392b:         @Override
1:456a2ba:         public void resetBatching() {
1:1595378:             if (pageFile.isLoaded()) {
1:a3f85e2:                 indexLock.writeLock().lock();
1:2030097:                 try {
1:1595378:                     pageFile.tx().execute(new Transaction.Closure<Exception>() {
1:bc4392b:                         @Override
1:1595378:                         public void execute(Transaction tx) throws Exception {
1:1595378:                             StoredDestination sd = getExistingStoredDestination(dest, tx);
1:1595378:                             if (sd != null) {
1:1595378:                                 sd.orderIndex.resetCursorPosition();}
1:456a2ba:                             }
1:456a2ba:                         });
1:54e2e3b:                 } catch (Exception e) {
1:1595378:                     LOG.error("Failed to reset batching",e);
1:74846bb:                 } finally {
1:a3f85e2:                     indexLock.writeLock().unlock();
1:54e2e3b:                 }
1:54e2e3b:             }
1:456a2ba:         }
1:456a2ba: 
1:bc4392b:         @Override
1:54e2e3b:         public void setBatch(final MessageId identity) throws IOException {
1:140ce1b:             indexLock.writeLock().lock();
1:1595378:             try {
1:140ce1b:                 pageFile.tx().execute(new Transaction.Closure<IOException>() {
1:140ce1b:                     @Override
1:140ce1b:                     public void execute(Transaction tx) throws IOException {
1:140ce1b:                         StoredDestination sd = getStoredDestination(dest, tx);
1:1d39f08:                         Long location = (Long) identity.getFutureOrSequenceLong();
1:1d39f08:                         Long pending = sd.orderIndex.minPendingAdd();
1:1d39f08:                         if (pending != null) {
1:1d39f08:                             location = Math.min(location, pending-1);
1:9c2b1d2:                         }
1:1d39f08:                         sd.orderIndex.setBatch(tx, location);
1:140ce1b:                     }
1:140ce1b:                 });
1:74846bb:             } finally {
1:140ce1b:                 indexLock.writeLock().unlock();
1:456a2ba:             }
1:456a2ba:         }
1:456a2ba: 
1:bc4392b:         @Override
1:c0090f6:         public void setMemoryUsage(MemoryUsage memoryUsage) {
1:456a2ba:         }
1:bc4392b:         @Override
2:456a2ba:         public void start() throws Exception {
1:ea84378:             super.start();
1:456a2ba:         }
1:bc4392b:         @Override
2:456a2ba:         public void stop() throws Exception {
1:ea84378:             super.stop();
1:456a2ba:         }
1:456a2ba: 
1:27262c8:         protected void lockAsyncJobQueue() {
1:33f4190:             try {
1:140ce1b:                 if (!this.localDestinationSemaphore.tryAcquire(this.maxAsyncJobs, 60, TimeUnit.SECONDS)) {
1:140ce1b:                     throw new TimeoutException(this +" timeout waiting for localDestSem:" + this.localDestinationSemaphore);
1:140ce1b:                 }
1:9f417a2:             } catch (Exception e) {
1:27262c8:                 LOG.error("Failed to lock async jobs for " + this.destination, e);
1:456a2ba:             }
1:d96c1cb:         }
1:456a2ba: 
1:27262c8:         protected void unlockAsyncJobQueue() {
1:27262c8:             this.localDestinationSemaphore.release(this.maxAsyncJobs);
1:d96c1cb:         }
1:456a2ba: 
1:27262c8:         protected void acquireLocalAsyncLock() {
1:cba0468:             try {
1:27262c8:                 this.localDestinationSemaphore.acquire();
1:27262c8:             } catch (InterruptedException e) {
1:27262c8:                 LOG.error("Failed to aquire async lock for " + this.destination, e);
1:d96c1cb:             }
1:b07f31e:         }
1:15de238: 
1:27262c8:         protected void releaseLocalAsyncLock() {
1:27262c8:             this.localDestinationSemaphore.release();
1:b07f31e:         }
1:15de238: 
1:9c2b1d2:         @Override
1:9c2b1d2:         public String toString(){
1:9c2b1d2:             return "permits:" + this.localDestinationSemaphore.availablePermits() + ",sd=" + storedDestinations.get(key(dest));
1:9c2b1d2:         }
1:785b16b: 
1:785b16b:         @Override
1:cf3d419:         protected void recoverMessageStoreStatistics() throws IOException {
1:785b16b:             try {
1:785b16b:                 MessageStoreStatistics recoveredStatistics;
1:785b16b:                 lockAsyncJobQueue();
1:785b16b:                 indexLock.writeLock().lock();
1:785b16b:                 try {
1:785b16b:                     recoveredStatistics = pageFile.tx().execute(new Transaction.CallableClosure<MessageStoreStatistics, IOException>() {
1:785b16b:                         @Override
1:785b16b:                         public MessageStoreStatistics execute(Transaction tx) throws IOException {
1:785b16b:                             MessageStoreStatistics statistics = new MessageStoreStatistics();
1:785b16b: 
1:785b16b:                             // Iterate through all index entries to get the size of each message
1:785b16b:                             StoredDestination sd = getStoredDestination(dest, tx);
1:785b16b:                             for (Iterator<Entry<Location, Long>> iterator = sd.locationIndex.iterator(tx); iterator.hasNext();) {
1:785b16b:                                 int locationSize = iterator.next().getKey().getSize();
1:785b16b:                                 statistics.getMessageCount().increment();
1:785b16b:                                 statistics.getMessageSize().addSize(locationSize > 0 ? locationSize : 0);
1:785b16b:                             }
1:785b16b:                            return statistics;
1:785b16b:                         }
1:785b16b:                     });
1:ea70e82:                     recoveredStatistics.getMessageCount().subtract(ackedAndPrepared.size());
1:785b16b:                     getMessageStoreStatistics().getMessageCount().setCount(recoveredStatistics.getMessageCount().getCount());
1:785b16b:                     getMessageStoreStatistics().getMessageSize().setTotalSize(recoveredStatistics.getMessageSize().getTotalSize());
1:785b16b:                 } finally {
1:785b16b:                     indexLock.writeLock().unlock();
1:785b16b:                 }
1:785b16b:             } finally {
1:785b16b:                 unlockAsyncJobQueue();
1:785b16b:             }
1:785b16b:         }
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     class KahaDBTopicMessageStore extends KahaDBMessageStore implements TopicMessageStore {
1:ea84378:         private final AtomicInteger subscriptionCount = new AtomicInteger();
1:cf3d419:         protected final MessageStoreSubscriptionStatistics messageStoreSubStats =
1:cf3d419:                 new MessageStoreSubscriptionStatistics(isEnableSubscriptionStatistics());
1:cf3d419: 
1:ea84378:         public KahaDBTopicMessageStore(ActiveMQTopic destination) throws IOException {
1:456a2ba:             super(destination);
1:ea84378:             this.subscriptionCount.set(getAllSubscriptions().length);
1:c5a1b86:             if (isConcurrentStoreAndDispatchTopics()) {
1:c5a1b86:                 asyncTopicMaps.add(asyncTaskMap);
1:c5a1b86:             }
1:456a2ba:         }
1:456a2ba: 
1:bc4392b:         @Override
1:785b16b:         protected void recoverMessageStoreStatistics() throws IOException {
1:cf3d419:             super.recoverMessageStoreStatistics();
1:cf3d419:             this.recoverMessageStoreSubMetrics();
1:cf3d419:         }
1:cf3d419: 
1:cf3d419:         @Override
1:ad1f751:         public ListenableFuture<Object> asyncAddTopicMessage(final ConnectionContext context, final Message message)
2:ea84378:                 throws IOException {
1:ea84378:             if (isConcurrentStoreAndDispatchTopics()) {
1:11622b3:                 message.beforeMarshall(wireFormat);
1:ea84378:                 StoreTopicTask result = new StoreTopicTask(this, context, message, subscriptionCount.get());
1:27262c8:                 result.aquireLocks();
1:27262c8:                 addTopicTask(this, result);
1:ea84378:                 return result.getFuture();
1:140ce1b:             } else {
1:ea84378:                 return super.asyncAddTopicMessage(context, message);
1:456a2ba:             }
1:456a2ba:         }
1:456a2ba: 
1:bc4392b:         @Override
1:3432a75:         public void acknowledge(ConnectionContext context, String clientId, String subscriptionName,
1:74846bb:                                 MessageId messageId, MessageAck ack) throws IOException {
1:943db3c:             String subscriptionKey = subscriptionKey(clientId, subscriptionName).toString();
1:ea84378:             if (isConcurrentStoreAndDispatchTopics()) {
1:27262c8:                 AsyncJobKey key = new AsyncJobKey(messageId, getDestination());
1:27262c8:                 StoreTopicTask task = null;
1:76f842d:                 synchronized (asyncTaskMap) {
1:76f842d:                     task = (StoreTopicTask) asyncTaskMap.get(key);
1:2030097:                 }
1:ea84378:                 if (task != null) {
1:ea84378:                     if (task.addSubscriptionKey(subscriptionKey)) {
1:27262c8:                         removeTopicTask(this, messageId);
1:27262c8:                         if (task.cancel()) {
1:76f842d:                             synchronized (asyncTaskMap) {
1:76f842d:                                 asyncTaskMap.remove(key);
1:2030097:                             }
1:2030097:                         }
1:2030097:                     }
1:54e2e3b:                 } else {
1:6ddbba4:                     doAcknowledge(context, subscriptionKey, messageId, ack);
1:2030097:                 }
1:9f417a2:             } else {
1:6ddbba4:                 doAcknowledge(context, subscriptionKey, messageId, ack);
1:2030097:             }
1:2030097:         }
1:456a2ba: 
1:6ddbba4:         protected void doAcknowledge(ConnectionContext context, String subscriptionKey, MessageId messageId, MessageAck ack)
1:ea84378:                 throws IOException {
1:456a2ba:             KahaRemoveMessageCommand command = new KahaRemoveMessageCommand();
1:456a2ba:             command.setDestination(dest);
1:456a2ba:             command.setSubscriptionKey(subscriptionKey);
1:b2b4fc8:             command.setMessageId(messageId.toProducerKey());
1:21fe8ca:             command.setTransactionInfo(ack != null ? TransactionIdConversion.convert(transactionIdTransformer.transform(ack.getTransactionId())) : null);
1:6ddbba4:             if (ack != null && ack.isUnmatchedAck()) {
1:6ddbba4:                 command.setAck(UNMATCHED);
1:d96c1cb:             } else {
1:b07f31e:                 org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(ack);
1:b07f31e:                 command.setAck(new Buffer(packet.getData(), packet.getOffset(), packet.getLength()));
1:456a2ba:             }
1:1595378:             store(command, false, null, null);
1:456a2ba:         }
1:456a2ba: 
1:bc4392b:         @Override
1:c0090f6:         public void addSubscription(SubscriptionInfo subscriptionInfo, boolean retroactive) throws IOException {
1:ea84378:             String subscriptionKey = subscriptionKey(subscriptionInfo.getClientId(), subscriptionInfo
1:ea84378:                     .getSubscriptionName());
1:456a2ba:             KahaSubscriptionCommand command = new KahaSubscriptionCommand();
1:456a2ba:             command.setDestination(dest);
1:943db3c:             command.setSubscriptionKey(subscriptionKey.toString());
1:456a2ba:             command.setRetroactive(retroactive);
1:456a2ba:             org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(subscriptionInfo);
1:456a2ba:             command.setSubscriptionInfo(new Buffer(packet.getData(), packet.getOffset(), packet.getLength()));
1:1595378:             store(command, isEnableJournalDiskSyncs() && true, null, null);
1:ea84378:             this.subscriptionCount.incrementAndGet();
1:456a2ba:         }
1:456a2ba: 
1:bc4392b:         @Override
1:456a2ba:         public void deleteSubscription(String clientId, String subscriptionName) throws IOException {
1:456a2ba:             KahaSubscriptionCommand command = new KahaSubscriptionCommand();
1:456a2ba:             command.setDestination(dest);
1:943db3c:             command.setSubscriptionKey(subscriptionKey(clientId, subscriptionName).toString());
1:1595378:             store(command, isEnableJournalDiskSyncs() && true, null, null);
1:ea84378:             this.subscriptionCount.decrementAndGet();
1:456a2ba:         }
1:456a2ba: 
1:bc4392b:         @Override
1:456a2ba:         public SubscriptionInfo[] getAllSubscriptions() throws IOException {
1:456a2ba: 
1:456a2ba:             final ArrayList<SubscriptionInfo> subscriptions = new ArrayList<SubscriptionInfo>();
1:a3f85e2:             indexLock.writeLock().lock();
1:b47da80:             try {
1:943db3c:                 pageFile.tx().execute(new Transaction.Closure<IOException>() {
1:bc4392b:                     @Override
1:456a2ba:                     public void execute(Transaction tx) throws IOException {
1:456a2ba:                         StoredDestination sd = getStoredDestination(dest, tx);
1:ea84378:                         for (Iterator<Entry<String, KahaSubscriptionCommand>> iterator = sd.subscriptions.iterator(tx); iterator
1:1595378:                                 .hasNext();) {
1:456a2ba:                             Entry<String, KahaSubscriptionCommand> entry = iterator.next();
1:ea84378:                             SubscriptionInfo info = (SubscriptionInfo) wireFormat.unmarshal(new DataInputStream(entry
1:ea84378:                                     .getValue().getSubscriptionInfo().newInput()));
1:456a2ba:                             subscriptions.add(info);
1:456a2ba: 
1:456a2ba:                         }
1:456a2ba:                     }
1:456a2ba:                 });
1:74846bb:             } finally {
1:a3f85e2:                 indexLock.writeLock().unlock();
1:456a2ba:             }
1:456a2ba: 
1:ea84378:             SubscriptionInfo[] rc = new SubscriptionInfo[subscriptions.size()];
1:456a2ba:             subscriptions.toArray(rc);
3:456a2ba:             return rc;
1:456a2ba:         }
1:456a2ba: 
1:bc4392b:         @Override
1:456a2ba:         public SubscriptionInfo lookupSubscription(String clientId, String subscriptionName) throws IOException {
1:734fb7d:             final String subscriptionKey = subscriptionKey(clientId, subscriptionName);
1:734fb7d:             indexLock.writeLock().lock();
1:734fb7d:             try {
1:ea84378:                 return pageFile.tx().execute(new Transaction.CallableClosure<SubscriptionInfo, IOException>() {
1:734fb7d:                     @Override
1:456a2ba:                     public SubscriptionInfo execute(Transaction tx) throws IOException {
1:734fb7d:                         StoredDestination sd = getStoredDestination(dest, tx);
1:456a2ba:                         KahaSubscriptionCommand command = sd.subscriptions.get(tx, subscriptionKey);
1:ea84378:                         if (command == null) {
1:456a2ba:                             return null;
1:456a2ba:                         }
1:ea84378:                         return (SubscriptionInfo) wireFormat.unmarshal(new DataInputStream(command
1:ea84378:                                 .getSubscriptionInfo().newInput()));
1:456a2ba:                     }
1:456a2ba:                 });
1:74846bb:             } finally {
1:7631ca9:                 indexLock.writeLock().unlock();
1:456a2ba:             }
1:456a2ba:         }
1:456a2ba: 
1:bc4392b:         @Override
1:456a2ba:         public int getMessageCount(String clientId, String subscriptionName) throws IOException {
1:456a2ba:             final String subscriptionKey = subscriptionKey(clientId, subscriptionName);
1:456a2ba: 
1:cf3d419:             if (isEnableSubscriptionStatistics()) {
1:cf3d419:                 return (int)this.messageStoreSubStats.getMessageCount(subscriptionKey).getCount();
1:cf3d419:             } else {
1:cf3d419: 
1:cf3d419:                 indexLock.writeLock().lock();
1:cf3d419:                 try {
1:cf3d419:                     return pageFile.tx().execute(new Transaction.CallableClosure<Integer, IOException>() {
1:cf3d419:                         @Override
1:cf3d419:                         public Integer execute(Transaction tx) throws IOException {
1:cf3d419:                             StoredDestination sd = getStoredDestination(dest, tx);
1:cf3d419:                             LastAck cursorPos = getLastAck(tx, sd, subscriptionKey);
1:cf3d419:                             if (cursorPos == null) {
1:cf3d419:                                 // The subscription might not exist.
1:cf3d419:                                 return 0;
1:cf3d419:                             }
1:cf3d419: 
1:cf3d419:                             return (int) getStoredMessageCount(tx, sd, subscriptionKey);
1:cf3d419:                         }
1:cf3d419:                     });
1:cf3d419:                 } finally {
1:cf3d419:                     indexLock.writeLock().unlock();
1:cf3d419:                 }
1:734fb7d:             }
1:734fb7d:         }
1:734fb7d: 
1:456a2ba: 
1:bc4392b:         @Override
1:734fb7d:         public long getMessageSize(String clientId, String subscriptionName) throws IOException {
1:456a2ba:             final String subscriptionKey = subscriptionKey(clientId, subscriptionName);
1:cf3d419:             if (isEnableSubscriptionStatistics()) {
1:cf3d419:                 return this.messageStoreSubStats.getMessageSize(subscriptionKey).getTotalSize();
1:cf3d419:             } else {
1:cf3d419:                 indexLock.writeLock().lock();
1:cf3d419:                 try {
1:1a91dec:                     return pageFile.tx().execute(new Transaction.CallableClosure<Long, IOException>() {
1:cf3d419:                         @Override
1:1a91dec:                         public Long execute(Transaction tx) throws IOException {
1:cf3d419:                             StoredDestination sd = getStoredDestination(dest, tx);
1:cf3d419:                             LastAck cursorPos = getLastAck(tx, sd, subscriptionKey);
1:cf3d419:                             if (cursorPos == null) {
1:cf3d419:                                 // The subscription might not exist.
1:1a91dec:                                 return 0l;
1:cf3d419:                             }
1:cf3d419: 
1:1a91dec:                             return getStoredMessageSize(tx, sd, subscriptionKey);
1:cf3d419:                         }
1:cf3d419:                     });
1:cf3d419:                 } finally {
1:cf3d419:                     indexLock.writeLock().unlock();
1:cf3d419:                 }
1:cf3d419:             }
1:cf3d419:         }
1:cf3d419: 
1:cf3d419:         protected void recoverMessageStoreSubMetrics() throws IOException {
1:cf3d419:             if (isEnableSubscriptionStatistics()) {
1:cf3d419: 
1:cf3d419:                 final MessageStoreSubscriptionStatistics statistics = getMessageStoreSubStatistics();
1:cf3d419:                 indexLock.writeLock().lock();
1:cf3d419:                 try {
1:cf3d419:                     pageFile.tx().execute(new Transaction.Closure<IOException>() {
1:cf3d419:                         @Override
1:cf3d419:                         public void execute(Transaction tx) throws IOException {
1:cf3d419:                             StoredDestination sd = getStoredDestination(dest, tx);
1:cf3d419:                             for (Iterator<Entry<String, KahaSubscriptionCommand>> iterator = sd.subscriptions
1:cf3d419:                                     .iterator(tx); iterator.hasNext();) {
1:cf3d419:                                 Entry<String, KahaSubscriptionCommand> entry = iterator.next();
1:cf3d419: 
1:cf3d419:                                 String subscriptionKey = entry.getKey();
1:cf3d419:                                 LastAck cursorPos = getLastAck(tx, sd, subscriptionKey);
1:cf3d419:                                 if (cursorPos != null) {
1:cf3d419:                                     long size = getStoredMessageSize(tx, sd, subscriptionKey);
1:cf3d419:                                     statistics.getMessageCount(subscriptionKey)
1:cf3d419:                                             .setCount(getStoredMessageCount(tx, sd, subscriptionKey));
1:cf3d419:                                     statistics.getMessageSize(subscriptionKey).addSize(size > 0 ? size : 0);
1:cf3d419:                                 }
1:cf3d419:                             }
1:cf3d419:                         }
1:cf3d419:                     });
1:cf3d419:                 } finally {
1:cf3d419:                     indexLock.writeLock().unlock();
1:cf3d419:                 }
1:734fb7d:             }
1:734fb7d:         }
1:734fb7d: 
1:bc4392b:         @Override
1:ea84378:         public void recoverSubscription(String clientId, String subscriptionName, final MessageRecoveryListener listener)
1:ea84378:                 throws Exception {
1:456a2ba:             final String subscriptionKey = subscriptionKey(clientId, subscriptionName);
1:943db3c:             @SuppressWarnings("unused")
1:d96c1cb:             final SubscriptionInfo info = lookupSubscription(clientId, subscriptionName);
1:a3f85e2:             indexLock.writeLock().lock();
1:456a2ba:             try {
2:ea84378:                 pageFile.tx().execute(new Transaction.Closure<Exception>() {
1:bc4392b:                     @Override
1:456a2ba:                     public void execute(Transaction tx) throws Exception {
1:180b0ec:                         StoredDestination sd = getStoredDestination(dest, tx);
1:734fb7d:                         LastAck cursorPos = getLastAck(tx, sd, subscriptionKey);
1:8871c67:                         sd.orderIndex.setBatch(tx, cursorPos);
1:cfe099d:                         recoverRolledBackAcks(sd, tx, Integer.MAX_VALUE, listener);
1:5cbb4db:                         for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx); iterator
1:1595378:                                 .hasNext();) {
1:456a2ba:                             Entry<Long, MessageKeys> entry = iterator.next();
1:b07f31e:                             if (ackedAndPrepared.contains(entry.getValue().messageId)) {
1:b07f31e:                                 continue;
1:180b0ec:                             }
1:1595378:                             listener.recoverMessage(loadMessage(entry.getValue().location));
1:180b0ec:                         }
1:5cbb4db:                         sd.orderIndex.resetCursorPosition();
1:180b0ec:                     }
1:734fb7d:                 });
1:734fb7d:             } finally {
1:734fb7d:                 indexLock.writeLock().unlock();
1:456a2ba:             }
1:456a2ba:         }
1:180b0ec: 
1:bc4392b:         @Override
1:ea84378:         public void recoverNextMessages(String clientId, String subscriptionName, final int maxReturned,
1:1595378:                 final MessageRecoveryListener listener) throws Exception {
1:456a2ba:             final String subscriptionKey = subscriptionKey(clientId, subscriptionName);
1:943db3c:             @SuppressWarnings("unused")
1:6fd292d:             final SubscriptionInfo info = lookupSubscription(clientId, subscriptionName);
1:7631ca9:             indexLock.writeLock().lock();
1:b47da80:             try {
1:ea84378:                 pageFile.tx().execute(new Transaction.Closure<Exception>() {
1:bc4392b:                     @Override
1:456a2ba:                     public void execute(Transaction tx) throws Exception {
1:456a2ba:                         StoredDestination sd = getStoredDestination(dest, tx);
1:9705671:                         sd.orderIndex.resetCursorPosition();
1:cba0468:                         MessageOrderCursor moc = sd.subscriptionCursors.get(subscriptionKey);
1:cba0468:                         if (moc == null) {
1:943db3c:                             LastAck pos = getLastAck(tx, sd, subscriptionKey);
1:aec047d:                             if (pos == null) {
1:aec047d:                                 // sub deleted
1:aec047d:                                 return;
1:456a2ba:                             }
1:8871c67:                             sd.orderIndex.setBatch(tx, pos);
1:9705671:                             moc = sd.orderIndex.cursor;
1:456a2ba:                         } else {
1:9705671:                             sd.orderIndex.cursor.sync(moc);
1:456a2ba:                         }
1:456a2ba: 
1:ea84378:                         Entry<Long, MessageKeys> entry = null;
1:cfe099d:                         int counter = recoverRolledBackAcks(sd, tx, maxReturned, listener);
1:cba0468:                         for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx, moc); iterator
1:1595378:                                 .hasNext();) {
1:456a2ba:                             entry = iterator.next();
1:b07f31e:                             if (ackedAndPrepared.contains(entry.getValue().messageId)) {
1:b07f31e:                                 continue;
1:456a2ba:                             }
1:1595378:                             if (listener.recoverMessage(loadMessage(entry.getValue().location))) {
1:456a2ba:                                 counter++;
1:456a2ba:                             }
1:d8cf54b:                             if (counter >= maxReturned || listener.hasSpace() == false) {
2:456a2ba:                                 break;
1:456a2ba:                             }
1:456a2ba:                         }
1:cba0468:                         sd.orderIndex.stoppedIterating();
1:ea84378:                         if (entry != null) {
1:cba0468:                             MessageOrderCursor copy = sd.orderIndex.cursor.copy();
1:cba0468:                             sd.subscriptionCursors.put(subscriptionKey, copy);
1:456a2ba:                         }
1:456a2ba:                     }
1:180b0ec:                 });
1:74846bb:             } finally {
1:acc3d4f:                 indexLock.writeLock().unlock();
1:456a2ba:             }
1:456a2ba:         }
1:456a2ba: 
1:bc4392b:         @Override
1:456a2ba:         public void resetBatching(String clientId, String subscriptionName) {
1:b47da80:             try {
1:456a2ba:                 final String subscriptionKey = subscriptionKey(clientId, subscriptionName);
1:acc3d4f:                 indexLock.writeLock().lock();
1:b47da80:                 try {
1:2030097:                     pageFile.tx().execute(new Transaction.Closure<IOException>() {
1:bc4392b:                         @Override
1:456a2ba:                         public void execute(Transaction tx) throws IOException {
1:456a2ba:                             StoredDestination sd = getStoredDestination(dest, tx);
1:456a2ba:                             sd.subscriptionCursors.remove(subscriptionKey);
1:456a2ba:                         }
1:456a2ba:                     });
1:a3f85e2:                 }finally {
1:a3f85e2:                     indexLock.writeLock().unlock();
1:456a2ba:                 }
1:456a2ba:             } catch (IOException e) {
1:456a2ba:                 throw new RuntimeException(e);
1:456a2ba:             }
1:456a2ba:         }
1:cf3d419: 
1:cf3d419:         @Override
1:cf3d419:         public MessageStoreSubscriptionStatistics getMessageStoreSubStatistics() {
1:cf3d419:             return messageStoreSubStats;
1:cf3d419:         }
1:456a2ba:     }
1:456a2ba: 
1:ea84378:     String subscriptionKey(String clientId, String subscriptionName) {
1:ea84378:         return clientId + ":" + subscriptionName;
1:456a2ba:     }
1:456a2ba: 
1:bc4392b:     @Override
1:456a2ba:     public MessageStore createQueueMessageStore(ActiveMQQueue destination) throws IOException {
1:de24980:         String key = key(convert(destination));
1:de24980:         MessageStore store = storeCache.get(key(convert(destination)));
1:de24980:         if (store == null) {
1:de24980:             final MessageStore queueStore = this.transactionStore.proxy(new KahaDBMessageStore(destination));
1:de24980:             store = storeCache.putIfAbsent(key, queueStore);
1:de24980:             if (store == null) {
1:de24980:                 store = queueStore;
1:de24980:             }
1:de24980:         }
1:de24980: 
2:785b16b:         return store;
1:456a2ba:     }
1:456a2ba: 
1:bc4392b:     @Override
1:456a2ba:     public TopicMessageStore createTopicMessageStore(ActiveMQTopic destination) throws IOException {
1:de24980:         String key = key(convert(destination));
1:de24980:         MessageStore store = storeCache.get(key(convert(destination)));
1:de24980:         if (store == null) {
1:de24980:             final TopicMessageStore topicStore = this.transactionStore.proxy(new KahaDBTopicMessageStore(destination));
1:de24980:             store = storeCache.putIfAbsent(key, topicStore);
1:de24980:             if (store == null) {
1:de24980:                 store = topicStore;
1:de24980:             }
1:de24980:         }
1:de24980: 
1:de24980:         return (TopicMessageStore) store;
1:456a2ba:     }
1:456a2ba: 
1:ea84378:     /**
1:07b6a38:      * Cleanup method to remove any state associated with the given destination.
1:07b6a38:      * This method does not stop the message store (it might not be cached).
1:943db3c:      *
1:1595378:      * @param destination
1:1595378:      *            Destination to forget
1:ea84378:      */
1:bc4392b:     @Override
1:07b6a38:     public void removeQueueMessageStore(ActiveMQQueue destination) {
1:456a2ba:     }
1:456a2ba: 
1:ea84378:     /**
1:07b6a38:      * Cleanup method to remove any state associated with the given destination
1:07b6a38:      * This method does not stop the message store (it might not be cached).
1:943db3c:      *
1:1595378:      * @param destination
1:1595378:      *            Destination to forget
1:ea84378:      */
1:bc4392b:     @Override
1:07b6a38:     public void removeTopicMessageStore(ActiveMQTopic destination) {
1:456a2ba:     }
1:456a2ba: 
1:bc4392b:     @Override
1:456a2ba:     public void deleteAllMessages() throws IOException {
1:ea84378:         deleteAllMessages = true;
1:456a2ba:     }
1:456a2ba: 
1:bc4392b:     @Override
1:456a2ba:     public Set<ActiveMQDestination> getDestinations() {
1:456a2ba:         try {
1:456a2ba:             final HashSet<ActiveMQDestination> rc = new HashSet<ActiveMQDestination>();
1:a3f85e2:             indexLock.writeLock().lock();
1:b47da80:             try {
1:1595378:                 pageFile.tx().execute(new Transaction.Closure<IOException>() {
1:bc4392b:                     @Override
1:456a2ba:                     public void execute(Transaction tx) throws IOException {
1:ea84378:                         for (Iterator<Entry<String, StoredDestination>> iterator = metadata.destinations.iterator(tx); iterator
1:1595378:                                 .hasNext();) {
1:456a2ba:                             Entry<String, StoredDestination> entry = iterator.next();
1:73d1bcd:                             //Removing isEmpty topic check - see AMQ-5875
1:73d1bcd:                             rc.add(convert(entry.getKey()));
1:456a2ba:                         }
1:456a2ba:                     }
1:456a2ba:                 });
1:1595378:             }finally {
1:a3f85e2:                 indexLock.writeLock().unlock();
1:456a2ba:             }
1:456a2ba:             return rc;
1:456a2ba:         } catch (IOException e) {
1:456a2ba:             throw new RuntimeException(e);
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba: 
1:bc4392b:     @Override
1:456a2ba:     public long getLastMessageBrokerSequenceId() throws IOException {
1:cf3d419:         return 0;
1:456a2ba:     }
1:943db3c: 
1:bc4392b:     @Override
1:a6a6a70:     public long getLastProducerSequenceId(ProducerId id) {
1:f6e1054:         indexLock.writeLock().lock();
1:a6a6a70:         try {
1:a6a6a70:             return metadata.producerSequenceIdTracker.getLastSeqId(id);
1:74846bb:         } finally {
1:f6e1054:             indexLock.writeLock().unlock();
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba: 
1:bc4392b:     @Override
1:456a2ba:     public long size() {
1:456a2ba:         try {
1:a604424:             return journalSize.get() + getPageFile().getDiskSize();
1:456a2ba:         } catch (IOException e) {
1:456a2ba:             throw new RuntimeException(e);
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba: 
1:bc4392b:     @Override
1:456a2ba:     public void beginTransaction(ConnectionContext context) throws IOException {
1:456a2ba:         throw new IOException("Not yet implemented.");
1:456a2ba:     }
1:bc4392b:     @Override
1:456a2ba:     public void commitTransaction(ConnectionContext context) throws IOException {
1:456a2ba:         throw new IOException("Not yet implemented.");
1:456a2ba:     }
1:bc4392b:     @Override
1:456a2ba:     public void rollbackTransaction(ConnectionContext context) throws IOException {
1:456a2ba:         throw new IOException("Not yet implemented.");
1:456a2ba:     }
1:456a2ba: 
1:bc4392b:     @Override
1:456a2ba:     public void checkpoint(boolean sync) throws IOException {
1:89f22da:         super.checkpointCleanup(sync);
1:456a2ba:     }
1:456a2ba: 
1:ea84378:     // /////////////////////////////////////////////////////////////////
1:456a2ba:     // Internal helper methods.
1:ea84378:     // /////////////////////////////////////////////////////////////////
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * @param location
1:456a2ba:      * @return
1:456a2ba:      * @throws IOException
1:456a2ba:      */
1:456a2ba:     Message loadMessage(Location location) throws IOException {
1:6b8e743:         try {
1:6b8e743:             JournalCommand<?> command = load(location);
1:6b8e743:             KahaAddMessageCommand addMessage = null;
1:6b8e743:             switch (command.type()) {
1:6b8e743:                 case KAHA_UPDATE_MESSAGE_COMMAND:
1:6b8e743:                     addMessage = ((KahaUpdateMessageCommand) command).getMessage();
1:6b8e743:                     break;
1:2518bde:                 case KAHA_ADD_MESSAGE_COMMAND:
1:6b8e743:                     addMessage = (KahaAddMessageCommand) command;
1:2518bde:                     break;
1:2518bde:                 default:
1:2518bde:                     throw new IOException("Could not load journal record, unexpected command type: " + command.type() + " at location: " + location);
1:2518bde:             }
1:2518bde:             if (!addMessage.hasMessage()) {
1:2518bde:                 throw new IOException("Could not load journal record, null message content at location: " + location);
1:6b8e743:             }
1:6b8e743:             Message msg = (Message) wireFormat.unmarshal(new DataInputStream(addMessage.getMessage().newInput()));
1:6b8e743:             return msg;
1:2518bde:         } catch (Throwable t) {
1:2518bde:             IOException ioe = IOExceptionSupport.create("Unexpected error on journal read at: " + location , t);
1:6b8e743:             LOG.error("Failed to load message at: {}", location , ioe);
1:6b8e743:             brokerService.handleIOException(ioe);
1:6b8e743:             throw ioe;
1:266d23e:         }
1:456a2ba:     }
1:456a2ba: 
1:ea84378:     // /////////////////////////////////////////////////////////////////
1:456a2ba:     // Internal conversion methods.
1:ea84378:     // /////////////////////////////////////////////////////////////////
1:456a2ba: 
1:456a2ba:     KahaLocation convert(Location location) {
1:456a2ba:         KahaLocation rc = new KahaLocation();
1:456a2ba:         rc.setLogId(location.getDataFileId());
1:456a2ba:         rc.setOffset(location.getOffset());
1:456a2ba:         return rc;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     KahaDestination convert(ActiveMQDestination dest) {
1:456a2ba:         KahaDestination rc = new KahaDestination();
1:456a2ba:         rc.setName(dest.getPhysicalName());
1:ea84378:         switch (dest.getDestinationType()) {
1:456a2ba:         case ActiveMQDestination.QUEUE_TYPE:
1:456a2ba:             rc.setType(DestinationType.QUEUE);
1:456a2ba:             return rc;
1:456a2ba:         case ActiveMQDestination.TOPIC_TYPE:
1:456a2ba:             rc.setType(DestinationType.TOPIC);
1:456a2ba:             return rc;
1:456a2ba:         case ActiveMQDestination.TEMP_QUEUE_TYPE:
1:456a2ba:             rc.setType(DestinationType.TEMP_QUEUE);
1:456a2ba:             return rc;
1:456a2ba:         case ActiveMQDestination.TEMP_TOPIC_TYPE:
1:456a2ba:             rc.setType(DestinationType.TEMP_TOPIC);
1:456a2ba:             return rc;
1:6b8e743:         default:
1:456a2ba:             return null;
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     ActiveMQDestination convert(String dest) {
1:456a2ba:         int p = dest.indexOf(":");
1:ea84378:         if (p < 0) {
1:456a2ba:             throw new IllegalArgumentException("Not in the valid destination format");
1:456a2ba:         }
1:456a2ba:         int type = Integer.parseInt(dest.substring(0, p));
1:ea84378:         String name = dest.substring(p + 1);
1:fb0b63e:         return convert(type, name);
1:456a2ba:     }
1:456a2ba: 
1:fb0b63e:     private ActiveMQDestination convert(KahaDestination commandDestination) {
1:fb0b63e:         return convert(commandDestination.getType().getNumber(), commandDestination.getName());
1:456a2ba:     }
1:456a2ba: 
1:fb0b63e:     private ActiveMQDestination convert(int type, String name) {
1:ea84378:         switch (KahaDestination.DestinationType.valueOf(type)) {
1:456a2ba:         case QUEUE:
1:456a2ba:             return new ActiveMQQueue(name);
1:456a2ba:         case TOPIC:
1:456a2ba:             return new ActiveMQTopic(name);
1:456a2ba:         case TEMP_QUEUE:
1:456a2ba:             return new ActiveMQTempQueue(name);
1:456a2ba:         case TEMP_TOPIC:
1:456a2ba:             return new ActiveMQTempTopic(name);
1:266d23e:         default:
1:456a2ba:             throw new IllegalArgumentException("Not in the valid destination format");
1:a604424:         }
1:d96c1cb:     }
1:fb0b63e: 
1:1595378:     public TransactionIdTransformer getTransactionIdTransformer() {
1:1595378:         return transactionIdTransformer;
1:fb0b63e:     }
1:2030097: 
1:1595378:     public void setTransactionIdTransformer(TransactionIdTransformer transactionIdTransformer) {
1:1595378:         this.transactionIdTransformer = transactionIdTransformer;
1:1595378:     }
1:2030097: 
1:33f4190:     static class AsyncJobKey {
1:33f4190:         MessageId id;
1:33f4190:         ActiveMQDestination destination;
1:1595378: 
1:33f4190:         AsyncJobKey(MessageId id, ActiveMQDestination destination) {
1:33f4190:             this.id = id;
1:456a2ba:             this.destination = destination;
1:456a2ba:         }
1:456a2ba: 
1:bc4392b:         @Override
1:33f4190:         public boolean equals(Object obj) {
1:33f4190:             if (obj == this) {
1:33f4190:                 return true;
1:456a2ba:             }
1:27262c8:             return obj instanceof AsyncJobKey && id.equals(((AsyncJobKey) obj).id)
1:27262c8:                     && destination.equals(((AsyncJobKey) obj).destination);
1:456a2ba:         }
1:456a2ba: 
1:bc4392b:         @Override
1:33f4190:         public int hashCode() {
1:33f4190:             return id.hashCode() + destination.hashCode();
1:1595378:         }
1:456a2ba: 
1:fb0b63e:         @Override
1:33f4190:         public String toString() {
1:33f4190:             return destination.getPhysicalName() + "-" + id;
1:1595378:         }
1:1595378:     }
1:1595378: 
1:15de238:     public interface StoreTask {
1:76f842d:         public boolean cancel();
1:15de238: 
1:15de238:         public void aquireLocks();
1:15de238: 
1:15de238:         public void releaseLocks();
1:101e711:     }
1:1595378: 
1:76f842d:     class StoreQueueTask implements Runnable, StoreTask {
1:ea84378:         protected final Message message;
1:ea84378:         protected final ConnectionContext context;
1:27262c8:         protected final KahaDBMessageStore store;
1:ea84378:         protected final InnerFutureTask future;
1:ea84378:         protected final AtomicBoolean done = new AtomicBoolean();
1:27262c8:         protected final AtomicBoolean locked = new AtomicBoolean();
1:1595378: 
1:27262c8:         public StoreQueueTask(KahaDBMessageStore store, ConnectionContext context, Message message) {
1:ea84378:             this.store = store;
1:ea84378:             this.context = context;
1:ea84378:             this.message = message;
1:ea84378:             this.future = new InnerFutureTask(this);
1:aec047d:         }
1:6fd292d: 
1:ad1f751:         public ListenableFuture<Object> getFuture() {
1:ea84378:             return this.future;
1:6ddbba4:         }
1:5cbb4db: 
1:bc4392b:         @Override
1:ea84378:         public boolean cancel() {
1:ea84378:             if (this.done.compareAndSet(false, true)) {
1:33f4190:                 return this.future.cancel(false);
1:6f7e3fc:             }
1:ea84378:             return false;
1:f206a1b:         }
1:0af6b06: 
1:bc4392b:         @Override
1:15de238:         public void aquireLocks() {
1:27262c8:             if (this.locked.compareAndSet(false, true)) {
1:b47da80:                 try {
1:27262c8:                     globalQueueSemaphore.acquire();
1:27262c8:                     store.acquireLocalAsyncLock();
1:27262c8:                     message.incrementReferenceCount();
1:27262c8:                 } catch (InterruptedException e) {
1:27262c8:                     LOG.warn("Failed to aquire lock", e);
1:a6a6a70:                 }
1:a6a6a70:             }
1:f2517c0: 
1:33f4190:         }
1:f2517c0: 
1:1595378:         @Override
1:15de238:         public void releaseLocks() {
1:27262c8:             if (this.locked.compareAndSet(true, false)) {
1:27262c8:                 store.releaseLocalAsyncLock();
1:27262c8:                 globalQueueSemaphore.release();
1:27262c8:                 message.decrementReferenceCount();
1:33f4190:             }
1:33f4190:         }
1:a6a6a70: 
1:9026274:         @Override
1:140ce1b:         public void run() {
1:76f842d:             this.store.doneTasks++;
1:b47da80:             try {
1:ea84378:                 if (this.done.compareAndSet(false, true)) {
1:ea84378:                     this.store.addMessage(context, message);
1:27262c8:                     removeQueueTask(this.store, this.message.getMessageId());
1:ea84378:                     this.future.complete();
1:b37b9eb:                 } else if (cancelledTaskModMetric > 0 && (++this.store.canceledTasks) % cancelledTaskModMetric == 0) {
1:179bd54:                     System.err.println(this.store.dest.getName() + " cancelled: "
1:179bd54:                             + (this.store.canceledTasks / this.store.doneTasks) * 100);
1:76f842d:                     this.store.canceledTasks = this.store.doneTasks = 0;
1:33f4190:                 }
1:f4c11f7:             } catch (Throwable t) {
1:f4c11f7:                 this.future.setException(t);
1:f4c11f7:                 removeQueueTask(this.store, this.message.getMessageId());
1:33f4190:             }
1:591e55f:         }
1:a6a6a70: 
1:ea84378:         protected Message getMessage() {
1:ea84378:             return this.message;
1:591e55f:         }
1:76f842d: 
1:ad1f751:         private class InnerFutureTask extends FutureTask<Object> implements ListenableFuture<Object>  {
1:76f842d: 
1:0f0bdb2:             private final AtomicReference<Runnable> listenerRef = new AtomicReference<>();
1:0f0bdb2: 
1:ea84378:             public InnerFutureTask(Runnable runnable) {
1:ea84378:                 super(runnable, null);
1:591e55f:             }
1:76f842d: 
1:f4c11f7:             public void setException(final Throwable e) {
1:ea84378:                 super.setException(e);
1:591e55f:             }
1:76f842d: 
1:ea84378:             public void complete() {
1:ea84378:                 super.set(null);
1:8e61f51:             }
1:ad1f751: 
1:ad1f751:             @Override
1:ad1f751:             public void done() {
1:ad1f751:                 fireListener();
1:ad1f751:             }
1:ad1f751: 
1:ad1f751:             @Override
1:ad1f751:             public void addListener(Runnable listener) {
1:0f0bdb2:                 this.listenerRef.set(listener);
1:ad1f751:                 if (isDone()) {
1:ad1f751:                     fireListener();
1:ad1f751:                 }
1:ad1f751:             }
1:ad1f751: 
1:ad1f751:             private void fireListener() {
1:0f0bdb2:                 Runnable listener = listenerRef.getAndSet(null);
1:ad1f751:                 if (listener != null) {
1:ad1f751:                     try {
1:ad1f751:                         listener.run();
1:ad1f751:                     } catch (Exception ignored) {
1:ad1f751:                         LOG.warn("Unexpected exception from future {} listener callback {}", this, listener, ignored);
1:ad1f751:                     }
1:ad1f751:                 }
1:ad1f751:             }
1:8e61f51:         }
1:cba0468:     }
1:76f842d: 
1:ea84378:     class StoreTopicTask extends StoreQueueTask {
1:ea84378:         private final int subscriptionCount;
1:ea84378:         private final List<String> subscriptionKeys = new ArrayList<String>(1);
1:ea84378:         private final KahaDBTopicMessageStore topicStore;
1:ea84378:         public StoreTopicTask(KahaDBTopicMessageStore store, ConnectionContext context, Message message,
1:1595378:                 int subscriptionCount) {
1:ea84378:             super(store, context, message);
1:ea84378:             this.topicStore = store;
1:ea84378:             this.subscriptionCount = subscriptionCount;
1:33f4190: 
1:cba0468:         }
1:33f4190: 
1:33f4190:         @Override
1:15de238:         public void aquireLocks() {
1:27262c8:             if (this.locked.compareAndSet(false, true)) {
1:b47da80:                 try {
1:27262c8:                     globalTopicSemaphore.acquire();
1:27262c8:                     store.acquireLocalAsyncLock();
1:27262c8:                     message.incrementReferenceCount();
1:27262c8:                 } catch (InterruptedException e) {
1:27262c8:                     LOG.warn("Failed to aquire lock", e);
1:179bd54:                 }
1:27262c8:             }
1:27262c8:         }
1:33f4190: 
1:33f4190:         @Override
1:15de238:         public void releaseLocks() {
1:27262c8:             if (this.locked.compareAndSet(true, false)) {
1:27262c8:                 message.decrementReferenceCount();
1:27262c8:                 store.releaseLocalAsyncLock();
1:27262c8:                 globalTopicSemaphore.release();
1:27262c8:             }
1:27262c8:         }
2:33f4190: 
1:ea84378:         /**
1:ea84378:          * add a key
1:943db3c:          *
1:1595378:          * @param key
1:ea84378:          * @return true if all acknowledgements received
1:ea84378:          */
1:ea84378:         public boolean addSubscriptionKey(String key) {
1:ea84378:             synchronized (this.subscriptionKeys) {
1:ea84378:                 this.subscriptionKeys.add(key);
1:27262c8:             }
1:ea84378:             return this.subscriptionKeys.size() >= this.subscriptionCount;
1:27262c8:         }
1:33f4190: 
1:9bb4682:         @Override
1:54e2e3b:         public void run() {
1:76f842d:             this.store.doneTasks++;
1:b47da80:             try {
1:ea84378:                 if (this.done.compareAndSet(false, true)) {
1:ea84378:                     this.topicStore.addMessage(context, message);
1:ea84378:                     // apply any acks we have
1:ea84378:                     synchronized (this.subscriptionKeys) {
1:ea84378:                         for (String key : this.subscriptionKeys) {
1:6ddbba4:                             this.topicStore.doAcknowledge(context, key, this.message.getMessageId(), null);
1:33f4190: 
1:27262c8:                         }
1:27262c8:                     }
1:f4c11f7:                     removeTopicTask(this.topicStore, this.message.getMessageId());
1:ea84378:                     this.future.complete();
1:76f842d:                 } else if (cancelledTaskModMetric > 0 && this.store.canceledTasks++ % cancelledTaskModMetric == 0) {
1:179bd54:                     System.err.println(this.store.dest.getName() + " cancelled: "
1:179bd54:                             + (this.store.canceledTasks / this.store.doneTasks) * 100);
1:76f842d:                     this.store.canceledTasks = this.store.doneTasks = 0;
1:27262c8:                 }
1:f4c11f7:             } catch (Throwable t) {
1:f4c11f7:                 this.future.setException(t);
1:27262c8:                 removeTopicTask(this.topicStore, this.message.getMessageId());
1:27262c8:             }
4:27262c8:         }
1:27262c8:     }
1:33f4190: 
1:15de238:     public class StoreTaskExecutor extends ThreadPoolExecutor {
1:15de238: 
1:15de238:         public StoreTaskExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit timeUnit, BlockingQueue<Runnable> queue, ThreadFactory threadFactory) {
1:15de238:             super(corePoolSize, maximumPoolSize, keepAliveTime, timeUnit, queue, threadFactory);
1:15de238:         }
1:15de238: 
1:bc4392b:         @Override
1:15de238:         protected void afterExecute(Runnable runnable, Throwable throwable) {
1:15de238:             super.afterExecute(runnable, throwable);
1:15de238: 
1:15de238:             if (runnable instanceof StoreTask) {
1:15de238:                ((StoreTask)runnable).releaseLocks();
1:15de238:             }
1:15de238:         }
1:15de238:     }
1:74846bb: 
1:74846bb:     @Override
1:74846bb:     public JobSchedulerStore createJobSchedulerStore() throws IOException, UnsupportedOperationException {
1:74846bb:         return new JobSchedulerStoreImpl();
1:74846bb:     }
1:18571ce: 
1:18571ce:     /* (non-Javadoc)
1:18571ce:      * @see org.apache.activemq.store.NoLocalSubscriptionAware#isPersistNoLocal()
1:18571ce:      */
1:18571ce:     @Override
1:18571ce:     public boolean isPersistNoLocal() {
1:18571ce:         // Prior to v11 the broker did not store the noLocal value for durable subs.
1:18571ce:         return brokerService.getStoreOpenWireVersion() >= 11;
1:18571ce:     }
1:27262c8: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:ea70e82
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.ProxyMessageStore;
/////////////////////////////////////////////////////////////////////////
1:     public void forgetRecoveredAcks(ArrayList<MessageAck> preparedAcks, boolean isRollback) throws IOException {
1:         if (preparedAcks != null) {
1:             Map<ActiveMQDestination, KahaDBMessageStore> stores = new HashMap<>();
1:             for (MessageAck ack : preparedAcks) {
1:                 stores.put(ack.getDestination(), findMatchingStore(ack.getDestination()));
1:             }
1:             ArrayList<MessageAck> perStoreAcks = new ArrayList<>();
1:             for (Entry<ActiveMQDestination, KahaDBMessageStore> entry : stores.entrySet()) {
1:                 for (MessageAck ack : preparedAcks) {
1:                     if (entry.getKey().equals(ack.getDestination())) {
1:                         perStoreAcks.add(ack);
1:                     }
1:                 }
1:                 entry.getValue().forgetRecoveredAcks(perStoreAcks, isRollback);
1:                 perStoreAcks.clear();
1:             }
1:         }
1:     }
1: 
1:     public void trackRecoveredAcks(ArrayList<MessageAck> preparedAcks) throws IOException {
1:         Map<ActiveMQDestination, KahaDBMessageStore> stores = new HashMap<>();
1:         for (MessageAck ack : preparedAcks) {
1:             stores.put(ack.getDestination(), findMatchingStore(ack.getDestination()));
1:         }
1:         ArrayList<MessageAck> perStoreAcks = new ArrayList<>();
1:         for (Entry<ActiveMQDestination, KahaDBMessageStore> entry : stores.entrySet()) {
1:             for (MessageAck ack : preparedAcks) {
1:                 if (entry.getKey().equals(ack.getDestination())) {
1:                     perStoreAcks.add(ack);
1:                 }
1:             }
1:             entry.getValue().trackRecoveredAcks(perStoreAcks);
1:             perStoreAcks.clear();
1:         }
1:     }
1: 
1:     private KahaDBMessageStore findMatchingStore(ActiveMQDestination activeMQDestination) throws IOException {
1:         ProxyMessageStore store = (ProxyMessageStore) storeCache.get(convert(activeMQDestination));
1:         if (store == null) {
1:             if (activeMQDestination.isQueue()) {
1:                 store = (ProxyMessageStore) createQueueMessageStore((ActiveMQQueue) activeMQDestination);
1:             } else {
1:                 store = (ProxyMessageStore) createTopicMessageStore((ActiveMQTopic) activeMQDestination);
1:             }
1:         }
1:         return (KahaDBMessageStore) store.getDelegate();
1:     }
1: 
1:         protected final Set<String> ackedAndPrepared = new HashSet<>();
1:         protected final Set<String> rolledBackAcks = new HashSet<>();
/////////////////////////////////////////////////////////////////////////
1: 
1:         // messages that have prepared (pending) acks cannot be re-dispatched unless the outcome is rollback,
1:         // till then they are skipped by the store.
1:         // 'at most once' XA guarantee
1:         public void trackRecoveredAcks(ArrayList<MessageAck> acks) {
1:             indexLock.writeLock().lock();
1:             try {
1:                 for (MessageAck ack : acks) {
1:                     ackedAndPrepared.add(ack.getLastMessageId().toProducerKey());
1:                 }
1:             } finally {
1:                 indexLock.writeLock().unlock();
1:             }
1:         }
1: 
1:         public void forgetRecoveredAcks(ArrayList<MessageAck> acks, boolean rollback) throws IOException {
1:             if (acks != null) {
1:                 indexLock.writeLock().lock();
1:                 try {
1:                     for (MessageAck ack : acks) {
1:                         final String id = ack.getLastMessageId().toProducerKey();
1:                         ackedAndPrepared.remove(id);
1:                         if (rollback) {
1:                             rolledBackAcks.add(id);
1:                             incrementAndAddSizeToStoreStat(dest, 0);
1:                         }
1:                     }
1:                 } finally {
1:                     indexLock.writeLock().unlock();
1:                 }
1:             }
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:                     recoveredStatistics.getMessageCount().subtract(ackedAndPrepared.size());
commit:f4c11f7
/////////////////////////////////////////////////////////////////////////
1:             } catch (Throwable t) {
1:                 this.future.setException(t);
1:                 removeQueueTask(this.store, this.message.getMessageId());
/////////////////////////////////////////////////////////////////////////
1:             public void setException(final Throwable e) {
/////////////////////////////////////////////////////////////////////////
1:             } catch (Throwable t) {
1:                 this.future.setException(t);
1:                 removeTopicTask(this.topicStore, this.message.getMessageId());
commit:2518bde
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.IOExceptionSupport;
/////////////////////////////////////////////////////////////////////////
1:                 case KAHA_ADD_MESSAGE_COMMAND:
1:                     break;
1:                 default:
1:                     throw new IOException("Could not load journal record, unexpected command type: " + command.type() + " at location: " + location);
1:             }
1:             if (!addMessage.hasMessage()) {
1:                 throw new IOException("Could not load journal record, null message content at location: " + location);
1:         } catch (Throwable t) {
1:             IOException ioe = IOExceptionSupport.create("Unexpected error on journal read at: " + location , t);
commit:f8bc19b
/////////////////////////////////////////////////////////////////////////
1:                         indexLock.writeLock().lock();
1:                         try {
1:                             metadata.producerSequenceIdTracker.isDuplicate(ack.getLastMessageId());
1:                         } finally {
1:                             indexLock.writeLock().unlock();
1:                         }
commit:b37b9eb
/////////////////////////////////////////////////////////////////////////
1:                 } else if (cancelledTaskModMetric > 0 && (++this.store.canceledTasks) % cancelledTaskModMetric == 0) {
commit:6b8e743
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             JournalCommand<?> command = load(location);
1:             KahaAddMessageCommand addMessage = null;
1:             switch (command.type()) {
1:                 case KAHA_UPDATE_MESSAGE_COMMAND:
1:                     addMessage = ((KahaUpdateMessageCommand) command).getMessage();
1:                     break;
1:                 default:
1:                     addMessage = (KahaAddMessageCommand) command;
1:             }
1:             Message msg = (Message) wireFormat.unmarshal(new DataInputStream(addMessage.getMessage().newInput()));
1:             return msg;
0:         } catch (IOException ioe) {
1:             LOG.error("Failed to load message at: {}", location , ioe);
1:             brokerService.handleIOException(ioe);
1:             throw ioe;
commit:13ec994
/////////////////////////////////////////////////////////////////////////
1:                             if (counter >= maxReturned) {
commit:d8cf54b
/////////////////////////////////////////////////////////////////////////
1:                             if (counter >= maxReturned || listener.hasSpace() == false) {
commit:499e39e
/////////////////////////////////////////////////////////////////////////
1:     // with asyncTaskMap locked
1:         store.asyncTaskMap.put(new AsyncJobKey(task.getMessage().getMessageId(), store.getDestination()), task);
/////////////////////////////////////////////////////////////////////////
1:                 synchronized (asyncTaskMap) {
1:                     addQueueTask(this, result);
1:                     if (indexListener != null) {
1:                         indexListener.onAdd(new IndexListener.MessageContext(context, message, null));
1:                     }
commit:f6e1054
/////////////////////////////////////////////////////////////////////////
1:         indexLock.writeLock().lock();
1:             indexLock.writeLock().unlock();
commit:b6fea83
/////////////////////////////////////////////////////////////////////////
commit:9ae5b41
/////////////////////////////////////////////////////////////////////////
1:             store(command, isEnableJournalDiskSyncs() && message.isResponseRequired(), new IndexAware() {
1:                 // sync add? (for async, future present from getFutureOrSequenceLong)
1:                 Object possibleFuture = message.getMessageId().getFutureOrSequenceLong();
1:                 @Override
1:                 public void sequenceAssignedWithIndexLocked(final long sequence) {
1:                     message.getMessageId().setFutureOrSequenceLong(sequence);
1:                     if (indexListener != null) {
1:                         if (possibleFuture == null) {
1:                             trackPendingAdd(dest, sequence);
1:                             indexListener.onAdd(new IndexListener.MessageContext(context, message, new Runnable() {
1:                                 @Override
1:                                 public void run() {
1:                                     trackPendingAddComplete(dest, sequence);
1:                                 }
1:                             }));
1:                 }
1:             }, null);
commit:1d39f08
/////////////////////////////////////////////////////////////////////////
1:                         Long location = (Long) identity.getFutureOrSequenceLong();
1:                         Long pending = sd.orderIndex.minPendingAdd();
1:                         if (pending != null) {
1:                             location = Math.min(location, pending-1);
1:                         sd.orderIndex.setBatch(tx, location);
commit:9c2b1d2
/////////////////////////////////////////////////////////////////////////
0:                             Long pending = sd.orderIndex.minPendingAdd();
0:                             if (pending != null) {
0:                                 location = Math.min(location, pending-1);
1:                             }
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:         public String toString(){
1:             return "permits:" + this.localDestinationSemaphore.availablePermits() + ",sd=" + storedDestinations.get(key(dest));
1:         }
commit:97c127d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.BaseDestination;
/////////////////////////////////////////////////////////////////////////
1:     private static final int MAX_ASYNC_JOBS = BaseDestination.MAX_AUDIT_DEPTH;
commit:140ce1b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.TimeoutException;
/////////////////////////////////////////////////////////////////////////
0: public class KahaDBStore extends MessageDatabase implements PersistenceAdapter {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 ListenableFuture<Object> future = result.getFuture();
1:                 message.getMessageId().setFutureOrSequenceLong(future);
1:                 message.setRecievedByDFBridge(true); // flag message as concurrentStoreAndDispatch
0:                     indexListener.onAdd(new IndexListener.MessageContext(context, message, null));
/////////////////////////////////////////////////////////////////////////
1:             final KahaAddMessageCommand command = new KahaAddMessageCommand();
/////////////////////////////////////////////////////////////////////////
0:                 store(command, isEnableJournalDiskSyncs() && message.isResponseRequired(), new IndexAware() {
0:                     // sync add? (for async, future present from getFutureOrSequenceLong)
0:                     Object possibleFuture = message.getMessageId().getFutureOrSequenceLong();
1: 
0:                     public void sequenceAssignedWithIndexLocked(final long sequence) {
0:                         message.getMessageId().setFutureOrSequenceLong(sequence);
0:                         if (indexListener != null) {
0:                             if (possibleFuture == null) {
0:                                 trackPendingAdd(dest, sequence);
0:                                 indexListener.onAdd(new IndexListener.MessageContext(context, message, new Runnable() {
1:                                     @Override
1:                                     public void run() {
0:                                         trackPendingAddComplete(dest, sequence);
1:                                     }
0:                                 }));
1:                             }
0:                 }, null);
/////////////////////////////////////////////////////////////////////////
1:             final String key = identity.toProducerKey();
1:             indexLock.writeLock().lock();
1:                 pageFile.tx().execute(new Transaction.Closure<IOException>() {
1:                     @Override
1:                     public void execute(Transaction tx) throws IOException {
1:                         StoredDestination sd = getStoredDestination(dest, tx);
0:                         Long location = sd.messageIdIndex.get(tx, key);
0:                         if (location != null) {
0:                             sd.orderIndex.setBatch(tx, location);
1:                         } else {
0:                             LOG.warn("{} {} setBatch failed, location for {} not found in messageId index for {}", this, dest.getName(), identity.getFutureOrSequenceLong(), identity);
1:                     }
1:                 });
1:                 indexLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:                 if (!this.localDestinationSemaphore.tryAcquire(this.maxAsyncJobs, 60, TimeUnit.SECONDS)) {
1:                     throw new TimeoutException(this +" timeout waiting for localDestSem:" + this.localDestinationSemaphore);
1:                 }
commit:54e2e3b
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.Callable;
0: import java.util.concurrent.CancellationException;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.IndexListener;
/////////////////////////////////////////////////////////////////////////
0: public class KahaDBStore extends MessageDatabase implements PersistenceAdapter, MessageDatabase.SerialExecution<Location> {
/////////////////////////////////////////////////////////////////////////
0:         serialExecutor = this;
/////////////////////////////////////////////////////////////////////////
0:                 LOG.warn("Recovered Store uses a different OpenWire version[{}] " +
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Override
0:     public Location execute(Callable<Location> c) throws Exception {
1:         if (isConcurrentStoreAndDispatchQueues()) {
0:             FutureTask<Location> future = new FutureTask<>(c);
0:             this.queueExecutor.execute(future);
0:             return future.get();
1:         } else {
0:             return c.call();
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:                 final ListenableFuture<Object> future = result.getFuture();
0:                 if (indexListener != null) {
0:                     // allow concurrent dispatch by setting entry locator,
0:                     // wait for add completion to remove potential pending addition
0:                     message.getMessageId().setFutureOrSequenceLong(future);
0:                     indexListener.onAdd(new IndexListener.MessageContext(context, message, new Runnable() {
1:                         @Override
1:                         public void run() {
1:                             try {
0:                                 future.get();
0:                                 trackPendingAddComplete(dest, (Long) message.getMessageId().getFutureOrSequenceLong());
0:                             } catch (CancellationException okNothingToTrack) {
1:                             } catch (Exception e) {
0:                                 LOG.warn("{} unexpected exception tracking completion of async add of {}", this, message.getMessageId(), e);
1:                             }
1:                         }
0:                     }));
1:                 }
1:                 return future;
/////////////////////////////////////////////////////////////////////////
1:         public void addMessage(final ConnectionContext context, final Message message) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:             store(command, isEnableJournalDiskSyncs() && message.isResponseRequired(), new IndexAware() {
1:                 @Override
0:                 public void sequenceAssignedWithIndexLocked(final long sequence) {
0:                     final Object possibleFuture = message.getMessageId().getFutureOrSequenceLong();
0:                     message.getMessageId().setFutureOrSequenceLong(sequence);
0:                     if (indexListener != null) {
0:                         trackPendingAdd(dest, sequence);
0:                         if (possibleFuture == null) {
0:                             // sync add (for async future present from getFutureOrSequenceLong)
0:                             indexListener.onAdd(new IndexListener.MessageContext(context, message, new Runnable() {
1:                                 @Override
0:                                 public void run() {
0:                                     trackPendingAddComplete(dest, sequence);
1:                                 }
0:                             }));
1:                         }
1:                     }
1:                 }
0:             }, null);
/////////////////////////////////////////////////////////////////////////
1:                             msg.getMessageId().setFutureOrSequenceLong(entry.getKey());
/////////////////////////////////////////////////////////////////////////
1:         public void setBatch(final MessageId identity) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:                             } else {
0:                                 LOG.warn("{} Location {} not found in order index for {}", this, identity.getFutureOrSequenceLong(), identity);
commit:27b3a7c
/////////////////////////////////////////////////////////////////////////
0:                 ActiveMQDestination activeMQDestination = convert(commandDestination);
0:                 Destination destination = regionBroker.getDestinationMap(activeMQDestination).get(activeMQDestination);
0:                 if (destination != null) {
commit:ad1f751
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         public ListenableFuture<Object> asyncAddQueueMessage(final ConnectionContext context, final Message message)
/////////////////////////////////////////////////////////////////////////
1:         public ListenableFuture<Object> asyncAddTopicMessage(final ConnectionContext context, final Message message)
/////////////////////////////////////////////////////////////////////////
1:         public ListenableFuture<Object> getFuture() {
/////////////////////////////////////////////////////////////////////////
1:         private class InnerFutureTask extends FutureTask<Object> implements ListenableFuture<Object>  {
0:             private Runnable listener;
/////////////////////////////////////////////////////////////////////////
1: 
1:             @Override
1:             public void done() {
1:                 fireListener();
1:             }
1: 
1:             @Override
1:             public void addListener(Runnable listener) {
0:                 this.listener = listener;
1:                 if (isDone()) {
1:                     fireListener();
1:                 }
1:             }
1: 
1:             private void fireListener() {
1:                 if (listener != null) {
1:                     try {
1:                         listener.run();
1:                     } catch (Exception ignored) {
1:                         LOG.warn("Unexpected exception from future {} listener callback {}", this, listener, ignored);
1:                     }
1:                 }
1:             }
commit:266d23e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.kahadb.data.KahaEntryType;
1: import org.apache.activemq.store.kahadb.data.KahaUpdateMessageCommand;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         public void updateMessage(Message message) throws IOException {
1:             if (LOG.isTraceEnabled()) {
1:                 LOG.trace("updating: " + message.getMessageId() + " with deliveryCount: " + message.getRedeliveryCounter());
1:             }
1:             KahaUpdateMessageCommand updateMessageCommand = new KahaUpdateMessageCommand();
1:             KahaAddMessageCommand command = new KahaAddMessageCommand();
1:             command.setDestination(dest);
1:             command.setMessageId(message.getMessageId().toProducerKey());
1:             command.setPriority(message.getPriority());
1:             command.setPrioritySupported(prioritizedMessages);
1:             org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(message);
1:             command.setMessage(new Buffer(packet.getData(), packet.getOffset(), packet.getLength()));
1:             updateMessageCommand.setMessage(command);
1:             store(updateMessageCommand, isEnableJournalDiskSyncs(), null, null);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:         JournalCommand<?> command = load(location);
0:         KahaAddMessageCommand addMessage = null;
0:         switch (command.type()) {
0:             case KAHA_UPDATE_MESSAGE_COMMAND:
0:                 addMessage = ((KahaUpdateMessageCommand)command).getMessage();
1:                 break;
1:             default:
0:                 addMessage = (KahaAddMessageCommand) command;
1:         }
commit:cfe099d
/////////////////////////////////////////////////////////////////////////
1:                         recoverRolledBackAcks(sd, tx, Integer.MAX_VALUE, listener);
/////////////////////////////////////////////////////////////////////////
1:                         int counter = recoverRolledBackAcks(sd, tx, maxReturned, listener);
/////////////////////////////////////////////////////////////////////////
1:         protected int recoverRolledBackAcks(StoredDestination sd, Transaction tx, int maxReturned, MessageRecoveryListener listener) throws Exception {
1:             int counter = 0;
1:             String id;
1:             for (Iterator<String> iterator = rolledBackAcks.iterator(); iterator.hasNext(); ) {
1:                 id = iterator.next();
1:                 iterator.remove();
1:                 Long sequence = sd.messageIdIndex.get(tx, id);
1:                 if (sequence != null) {
1:                     if (sd.orderIndex.alreadyDispatched(sequence)) {
1:                         listener.recoverMessage(loadMessage(sd.orderIndex.get(tx, sequence).location));
1:                         counter++;
1:                         if (counter >= maxReturned) {
1:                             break;
1:                         }
1:                     } else {
1:                         LOG.info("rolledback ack message {} with seq {} will be picked up in future batch {}", id, sequence, sd.orderIndex.cursor);
1:                     }
1:                 } else {
1:                     LOG.warn("Failed to locate rolled back ack message {} in {}", id, sd);
1:                 }
1:             }
1:             return counter;
1:         }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:                         recoverRolledBackAcks(sd, tx, Integer.MAX_VALUE, listener);
/////////////////////////////////////////////////////////////////////////
1:                         int counter = recoverRolledBackAcks(sd, tx, maxReturned, listener);
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:0f0bdb2
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicReference;
/////////////////////////////////////////////////////////////////////////
1:             private final AtomicReference<Runnable> listenerRef = new AtomicReference<>();
1: 
/////////////////////////////////////////////////////////////////////////
1:                 this.listenerRef.set(listener);
1:                 Runnable listener = listenerRef.getAndSet(null);
commit:18571ce
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.NoLocalSubscriptionAware;
/////////////////////////////////////////////////////////////////////////
1: public class KahaDBStore extends MessageDatabase implements PersistenceAdapter, NoLocalSubscriptionAware {
/////////////////////////////////////////////////////////////////////////
1: 
1:     /* (non-Javadoc)
1:      * @see org.apache.activemq.store.NoLocalSubscriptionAware#isPersistNoLocal()
1:      */
1:     @Override
1:     public boolean isPersistNoLocal() {
1:         // Prior to v11 the broker did not store the noLocal value for durable subs.
1:         return brokerService.getStoreOpenWireVersion() >= 11;
1:     }
commit:cf3d419
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.MessageStoreSubscriptionStatistics;
/////////////////////////////////////////////////////////////////////////
1:         protected final MessageStoreSubscriptionStatistics messageStoreSubStats =
1:                 new MessageStoreSubscriptionStatistics(isEnableSubscriptionStatistics());
1: 
/////////////////////////////////////////////////////////////////////////
1:         protected void recoverMessageStoreStatistics() throws IOException {
1:             super.recoverMessageStoreStatistics();
1:             this.recoverMessageStoreSubMetrics();
1:         }
1: 
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:             if (isEnableSubscriptionStatistics()) {
1:                 return (int)this.messageStoreSubStats.getMessageCount(subscriptionKey).getCount();
1:             } else {
1: 
1:                 indexLock.writeLock().lock();
1:                 try {
1:                     return pageFile.tx().execute(new Transaction.CallableClosure<Integer, IOException>() {
1:                         @Override
1:                         public Integer execute(Transaction tx) throws IOException {
1:                             StoredDestination sd = getStoredDestination(dest, tx);
1:                             LastAck cursorPos = getLastAck(tx, sd, subscriptionKey);
1:                             if (cursorPos == null) {
1:                                 // The subscription might not exist.
1:                                 return 0;
1:                             }
1: 
1:                             return (int) getStoredMessageCount(tx, sd, subscriptionKey);
1:                         }
1:                     });
1:                 } finally {
1:                     indexLock.writeLock().unlock();
1:                 }
/////////////////////////////////////////////////////////////////////////
1:             if (isEnableSubscriptionStatistics()) {
1:                 return this.messageStoreSubStats.getMessageSize(subscriptionKey).getTotalSize();
1:             } else {
1:                 indexLock.writeLock().lock();
1:                 try {
0:                     return pageFile.tx().execute(new Transaction.CallableClosure<Integer, IOException>() {
1:                         @Override
0:                         public Integer execute(Transaction tx) throws IOException {
1:                             StoredDestination sd = getStoredDestination(dest, tx);
1:                             LastAck cursorPos = getLastAck(tx, sd, subscriptionKey);
1:                             if (cursorPos == null) {
1:                                 // The subscription might not exist.
1:                                 return 0;
1:                             }
0:                             return (int) getStoredMessageSize(tx, sd, subscriptionKey);
1:                         }
1:                     });
1:                 } finally {
1:                     indexLock.writeLock().unlock();
1:                 }
1:             }
1:         }
1: 
1: 
1:         protected void recoverMessageStoreSubMetrics() throws IOException {
1:             if (isEnableSubscriptionStatistics()) {
1: 
1:                 final MessageStoreSubscriptionStatistics statistics = getMessageStoreSubStatistics();
1:                 indexLock.writeLock().lock();
1:                 try {
1:                     pageFile.tx().execute(new Transaction.Closure<IOException>() {
1:                         @Override
1:                         public void execute(Transaction tx) throws IOException {
1:                             StoredDestination sd = getStoredDestination(dest, tx);
1:                             for (Iterator<Entry<String, KahaSubscriptionCommand>> iterator = sd.subscriptions
1:                                     .iterator(tx); iterator.hasNext();) {
1:                                 Entry<String, KahaSubscriptionCommand> entry = iterator.next();
1: 
1:                                 String subscriptionKey = entry.getKey();
1:                                 LastAck cursorPos = getLastAck(tx, sd, subscriptionKey);
1:                                 if (cursorPos != null) {
1:                                     long size = getStoredMessageSize(tx, sd, subscriptionKey);
1:                                     statistics.getMessageCount(subscriptionKey)
1:                                             .setCount(getStoredMessageCount(tx, sd, subscriptionKey));
1:                                     statistics.getMessageSize(subscriptionKey).addSize(size > 0 ? size : 0);
1:                                 }
1:                             }
1:                         }
1:                     });
1:                 } finally {
1:                     indexLock.writeLock().unlock();
1:                 }
/////////////////////////////////////////////////////////////////////////
1: 
1:         @Override
1:         public MessageStoreSubscriptionStatistics getMessageStoreSubStatistics() {
1:             return messageStoreSubStats;
1:         }
commit:11622b3
/////////////////////////////////////////////////////////////////////////
1:                 message.beforeMarshall(wireFormat);
/////////////////////////////////////////////////////////////////////////
1:                 message.beforeMarshall(wireFormat);
commit:1ffac14
/////////////////////////////////////////////////////////////////////////
commit:b9b98a4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.kahadb.MessageDatabase.Metadata;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:b9f9f03
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 message.beforeMarshall(wireFormat);
/////////////////////////////////////////////////////////////////////////
0:                 message.beforeMarshall(wireFormat);
commit:7a7c70a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.kahadb.MessageDatabase.Metadata;
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected void configureMetadata() {
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
1:     @Override
1:     public void doStart() throws Exception {
1:         //configure the metadata before start, right now
1:         //this is just the open wire version
1:         configureMetadata();
1: 
commit:734fb7d
/////////////////////////////////////////////////////////////////////////
1: 
1:         @Override
1:         public long getMessageSize(String clientId, String subscriptionName) throws IOException {
1:             final String subscriptionKey = subscriptionKey(clientId, subscriptionName);
1:             indexLock.writeLock().lock();
1:             try {
0:                 return pageFile.tx().execute(new Transaction.CallableClosure<Integer, IOException>() {
1:                     @Override
0:                     public Integer execute(Transaction tx) throws IOException {
1:                         StoredDestination sd = getStoredDestination(dest, tx);
1:                         LastAck cursorPos = getLastAck(tx, sd, subscriptionKey);
0:                         if (cursorPos == null) {
0:                             // The subscription might not exist.
0:                             return 0;
1:                         }
1: 
0:                         return (int) getStoredMessageSize(tx, sd, subscriptionKey);
1:                     }
1:                 });
1:             } finally {
1:                 indexLock.writeLock().unlock();
1:             }
1:         }
1: 
commit:de24980
/////////////////////////////////////////////////////////////////////////
1:         String key = key(convert(destination));
1:         MessageStore store = storeCache.get(key(convert(destination)));
1:         if (store == null) {
1:             final MessageStore queueStore = this.transactionStore.proxy(new KahaDBMessageStore(destination));
1:             store = storeCache.putIfAbsent(key, queueStore);
1:             if (store == null) {
1:                 store = queueStore;
1:             }
1:         }
1: 
1:         String key = key(convert(destination));
1:         MessageStore store = storeCache.get(key(convert(destination)));
1:         if (store == null) {
1:             final TopicMessageStore topicStore = this.transactionStore.proxy(new KahaDBTopicMessageStore(destination));
1:             store = storeCache.putIfAbsent(key, topicStore);
1:             if (store == null) {
1:                 store = topicStore;
1:             }
1:         }
1: 
1:         return (TopicMessageStore) store;
commit:73d1bcd
/////////////////////////////////////////////////////////////////////////
1:                             //Removing isEmpty topic check - see AMQ-5875
1:                             rc.add(convert(entry.getKey()));
commit:785b16b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.MessageStoreStatistics;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         @Override
1:         protected void recoverMessageStoreStatistics() throws IOException {
1:             try {
1:                 MessageStoreStatistics recoveredStatistics;
1:                 lockAsyncJobQueue();
1:                 indexLock.writeLock().lock();
1:                 try {
1:                     recoveredStatistics = pageFile.tx().execute(new Transaction.CallableClosure<MessageStoreStatistics, IOException>() {
1:                         @Override
1:                         public MessageStoreStatistics execute(Transaction tx) throws IOException {
1:                             MessageStoreStatistics statistics = new MessageStoreStatistics();
1: 
1:                             // Iterate through all index entries to get the size of each message
1:                             StoredDestination sd = getStoredDestination(dest, tx);
1:                             for (Iterator<Entry<Location, Long>> iterator = sd.locationIndex.iterator(tx); iterator.hasNext();) {
1:                                 int locationSize = iterator.next().getKey().getSize();
1:                                 statistics.getMessageCount().increment();
1:                                 statistics.getMessageSize().addSize(locationSize > 0 ? locationSize : 0);
1:                             }
1:                            return statistics;
1:                         }
1:                     });
1:                     getMessageStoreStatistics().getMessageCount().setCount(recoveredStatistics.getMessageCount().getCount());
1:                     getMessageStoreStatistics().getMessageSize().setTotalSize(recoveredStatistics.getMessageSize().getTotalSize());
1:                 } finally {
1:                     indexLock.writeLock().unlock();
1:                 }
1:             } finally {
1:                 unlockAsyncJobQueue();
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
0:         MessageStore store = this.transactionStore.proxy(new KahaDBMessageStore(destination));
0:         storeCache.put(key(convert(destination)), store);
1:         return store;
0:         TopicMessageStore store = this.transactionStore.proxy(new KahaDBTopicMessageStore(destination));
0:         storeCache.put(key(convert(destination)), store);
1:         return store;
author:Timothy Bish
-------------------------------------------------------------------------------
commit:1a91dec
/////////////////////////////////////////////////////////////////////////
1:                     return pageFile.tx().execute(new Transaction.CallableClosure<Long, IOException>() {
1:                         public Long execute(Transaction tx) throws IOException {
1:                                 return 0l;
1:                             return getStoredMessageSize(tx, sd, subscriptionKey);
/////////////////////////////////////////////////////////////////////////
commit:13044de
/////////////////////////////////////////////////////////////////////////
1:                 LOG.warn("Existing Store uses a different OpenWire version[{}] " +
1:                          "than the version configured[{}] reverting to the version " +
1:                          "used by this store, some newer broker features may not work" +
1:                          "as expected.",
1: 
1:                 // Update the broker service instance to the actual version in use.
1:                 wireFormat.setVersion(metadata.openwireVersion);
1:                 brokerService.setStoreOpenWireVersion(metadata.openwireVersion);
commit:c5a1b86
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:             if (isConcurrentStoreAndDispatchTopics()) {
1:                 asyncTopicMaps.add(asyncTaskMap);
1:             }
commit:74846bb
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.scheduler.JobSchedulerStore;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.AbstractMessageStore;
1: import org.apache.activemq.store.ListenableFuture;
1: import org.apache.activemq.store.MessageRecoveryListener;
1: import org.apache.activemq.store.MessageStore;
1: import org.apache.activemq.store.PersistenceAdapter;
1: import org.apache.activemq.store.TopicMessageStore;
1: import org.apache.activemq.store.TransactionIdTransformer;
1: import org.apache.activemq.store.TransactionStore;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.kahadb.scheduler.JobSchedulerStoreImpl;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:             } finally {
/////////////////////////////////////////////////////////////////////////
0:                             // of messages in the destination.
0:                             for (Iterator<Entry<Location, Long>> iterator = sd.locationIndex.iterator(tx); iterator.hasNext();) {
1:                 } finally {
/////////////////////////////////////////////////////////////////////////
1:             } finally {
/////////////////////////////////////////////////////////////////////////
1:             } finally {
/////////////////////////////////////////////////////////////////////////
1:             } finally {
/////////////////////////////////////////////////////////////////////////
1:                 } finally {
/////////////////////////////////////////////////////////////////////////
0:                 // operations... but for now we must externally synchronize...
/////////////////////////////////////////////////////////////////////////
1:                                 MessageId messageId, MessageAck ack) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:             } finally {
/////////////////////////////////////////////////////////////////////////
1:             } finally {
/////////////////////////////////////////////////////////////////////////
1:             } finally {
/////////////////////////////////////////////////////////////////////////
1:             } finally {
/////////////////////////////////////////////////////////////////////////
0:             } finally {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     public JobSchedulerStore createJobSchedulerStore() throws IOException, UnsupportedOperationException {
1:         return new JobSchedulerStoreImpl();
1:     }
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:c0090f6
/////////////////////////////////////////////////////////////////////////
1:         public void setMemoryUsage(MemoryUsage memoryUsage) {
/////////////////////////////////////////////////////////////////////////
1:         public void addSubscription(SubscriptionInfo subscriptionInfo, boolean retroactive) throws IOException {
commit:6c1676b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.ThreadPoolUtils;
/////////////////////////////////////////////////////////////////////////
1:             ThreadPoolUtils.shutdownNow(queueExecutor);
1:             queueExecutor = null;
1:             ThreadPoolUtils.shutdownNow(topicExecutor);
1:             topicExecutor = null;
author:Hiram Chirino
-------------------------------------------------------------------------------
commit:21fe8ca
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.*;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             public TransactionId transform(TransactionId txid) {
1:                 return txid;
/////////////////////////////////////////////////////////////////////////
1:             command.setTransactionInfo(TransactionIdConversion.convert(transactionIdTransformer.transform(message.getTransactionId())));
/////////////////////////////////////////////////////////////////////////
1:             command.setTransactionInfo(TransactionIdConversion.convert(transactionIdTransformer.transform(ack.getTransactionId())));
/////////////////////////////////////////////////////////////////////////
1:             command.setTransactionInfo(ack != null ? TransactionIdConversion.convert(transactionIdTransformer.transform(ack.getTransactionId())) : null);
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:bc4392b
/////////////////////////////////////////////////////////////////////////
1: import java.util.Set;
1: import java.util.concurrent.BlockingQueue;
1: import java.util.concurrent.ExecutorService;
0: import java.util.concurrent.Future;
1: import java.util.concurrent.FutureTask;
1: import java.util.concurrent.LinkedBlockingQueue;
1: import java.util.concurrent.Semaphore;
1: import java.util.concurrent.ThreadFactory;
1: import java.util.concurrent.ThreadPoolExecutor;
1: import java.util.concurrent.TimeUnit;
1: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.kahadb.data.KahaDestination.DestinationType;
1: import org.apache.activemq.store.kahadb.disk.journal.Location;
1: import org.apache.activemq.store.kahadb.disk.page.Transaction;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final boolean concurrentStoreAndDispatchTransactions = false;
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         if (brokerService != null) {
1:             metadata.openwireVersion = brokerService.getStoreOpenWireVersion();
1:             wireFormat.setVersion(metadata.openwireVersion);
1: 
1:             if (LOG.isDebugEnabled()) {
1:                 LOG.debug("Store OpenWire version configured as: {}", metadata.openwireVersion);
1:             }
1: 
1: 
1:         if (brokerService != null) {
1:             // In case the recovered store used a different OpenWire version log a warning
1:             // to assist in determining why journal reads fail.
1:             if (metadata.openwireVersion != brokerService.getStoreOpenWireVersion()) {
0:                 LOG.warn("Receovered Store uses a different OpenWire version[{}] " +
0:                          "than the version configured[{}].",
1:                          metadata.openwireVersion, brokerService.getStoreOpenWireVersion());
1:             }
1:         }
1: 
1:             asyncQueueJobQueue, new ThreadFactory() {
1:                 @Override
1:                 public Thread newThread(Runnable runnable) {
1:                     Thread thread = new Thread(runnable, "ConcurrentQueueStoreAndDispatch");
1:                     thread.setDaemon(true);
1:                     return thread;
1:                 }
1:             });
1:             asyncTopicJobQueue, new ThreadFactory() {
1:                 @Override
1:                 public Thread newThread(Runnable runnable) {
1:                     Thread thread = new Thread(runnable, "ConcurrentTopicStoreAndDispatch");
1:                     thread.setDaemon(true);
1:                     return thread;
1:                 }
1:             });
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:                         @Override
/////////////////////////////////////////////////////////////////////////
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:                         @Override
/////////////////////////////////////////////////////////////////////////
1:                         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:                         @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
commit:d97951e
/////////////////////////////////////////////////////////////////////////
0:             command.setTransactionInfo(ack != null ? transactionIdTransformer.transform(ack.getTransactionId()) : null);
commit:943db3c
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:                     pageFile.tx().execute(new Transaction.Closure<IOException>() {
/////////////////////////////////////////////////////////////////////////
0:                 } finally {
/////////////////////////////////////////////////////////////////////////
1:             String subscriptionKey = subscriptionKey(clientId, subscriptionName).toString();
/////////////////////////////////////////////////////////////////////////
1:             command.setSubscriptionKey(subscriptionKey.toString());
/////////////////////////////////////////////////////////////////////////
1:             command.setSubscriptionKey(subscriptionKey(clientId, subscriptionName).toString());
/////////////////////////////////////////////////////////////////////////
0:                         LastAck cursorPos = getLastAck(tx, sd, subscriptionKey);
0:                         return (int) getStoredMessageCount(tx, sd, subscriptionKey);
/////////////////////////////////////////////////////////////////////////
1:             @SuppressWarnings("unused")
0:                         LastAck cursorPos = getLastAck(tx, sd, subscriptionKey);
/////////////////////////////////////////////////////////////////////////
1:             @SuppressWarnings("unused")
/////////////////////////////////////////////////////////////////////////
1:                             LastAck pos = getLastAck(tx, sd, subscriptionKey);
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:          *
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:ec9975c
/////////////////////////////////////////////////////////////////////////
0:         if( brokerService!=null ) {
0:             wireFormat.setVersion(brokerService.getStoreOpenWireVersion());
1:         }
commit:b2b4fc8
/////////////////////////////////////////////////////////////////////////
1:             command.setMessageId(message.getMessageId().toProducerKey());
/////////////////////////////////////////////////////////////////////////
1:             command.setMessageId(ack.getLastMessageId().toProducerKey());
/////////////////////////////////////////////////////////////////////////
0:             final String key = identity.toProducerKey();
/////////////////////////////////////////////////////////////////////////
0:                 final String key = identity.toProducerKey();
/////////////////////////////////////////////////////////////////////////
1:             command.setMessageId(messageId.toProducerKey());
commit:c5cf038
commit:1aab71b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.kahadb.disk.journal.Location;
0: import org.apache.activemq.store.kahadb.disk.page.Transaction;
commit:da0490b
/////////////////////////////////////////////////////////////////////////
0:                             Buffer ackb = rmOp.getCommand().getAck();
0:                             MessageAck ack = (MessageAck) wireFormat.unmarshal(new DataInputStream(ackb.newInput()));
/////////////////////////////////////////////////////////////////////////
1: 
1:             org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(ack);
1:             command.setAck(new Buffer(packet.getData(), packet.getOffset(), packet.getLength()));
commit:a33d668
/////////////////////////////////////////////////////////////////////////
1:                         return sd.locationIndex.isEmpty(tx);
commit:d89a302
/////////////////////////////////////////////////////////////////////////
0:                 cursorPos=location+1;
commit:180b0ec
/////////////////////////////////////////////////////////////////////////
0:         public void setBatch(MessageId identity) throws IOException {
0:             final String key = identity.toString();
1:             
0:             // Hopefully one day the page file supports concurrent read operations... but for now we must
1:             // externally synchronize...
0:             Long location;
0:             synchronized(indexMutex) {
0:                 location = pageFile.tx().execute(new Transaction.CallableClosure<Long, IOException>(){
0:                     public Long execute(Transaction tx) throws IOException {
1:                         StoredDestination sd = getStoredDestination(dest, tx);
0:                         return sd.messageIdIndex.get(tx, key);
1:                     }
1:                 });
1:             }
0:             if( location!=null ) {
0:                 cursorPos=location;
1:             }
1:             
commit:c059425
/////////////////////////////////////////////////////////////////////////
0:             store(command, isEnableJournalDiskSyncs() && message.isResponseRequired());
/////////////////////////////////////////////////////////////////////////
0:             store(command, isEnableJournalDiskSyncs() && ack.isResponseRequired());
/////////////////////////////////////////////////////////////////////////
0:             store(command, isEnableJournalDiskSyncs() && true);
0:             store(command, isEnableJournalDiskSyncs() && true);
commit:f62737b
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.store.kahadb;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.kahadb.data.KahaAddMessageCommand;
0: import org.apache.activemq.store.kahadb.data.KahaCommitCommand;
1: import org.apache.activemq.store.kahadb.data.KahaDestination;
0: import org.apache.activemq.store.kahadb.data.KahaLocalTransactionId;
1: import org.apache.activemq.store.kahadb.data.KahaLocation;
0: import org.apache.activemq.store.kahadb.data.KahaPrepareCommand;
1: import org.apache.activemq.store.kahadb.data.KahaRemoveDestinationCommand;
1: import org.apache.activemq.store.kahadb.data.KahaRemoveMessageCommand;
0: import org.apache.activemq.store.kahadb.data.KahaRollbackCommand;
1: import org.apache.activemq.store.kahadb.data.KahaSubscriptionCommand;
0: import org.apache.activemq.store.kahadb.data.KahaTransactionInfo;
0: import org.apache.activemq.store.kahadb.data.KahaXATransactionId;
0: import org.apache.activemq.store.kahadb.data.KahaDestination.DestinationType;
commit:456a2ba
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: package org.apache.kahadb.store;
1: 
1: import java.io.DataInputStream;
1: import java.io.IOException;
1: import java.util.ArrayList;
1: import java.util.HashSet;
1: import java.util.Iterator;
1: import java.util.Map;
0: import java.util.Set;
1: import java.util.Map.Entry;
1: 
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.command.ActiveMQTempQueue;
1: import org.apache.activemq.command.ActiveMQTempTopic;
1: import org.apache.activemq.command.ActiveMQTopic;
0: import org.apache.activemq.command.LocalTransactionId;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.command.SubscriptionInfo;
1: import org.apache.activemq.command.TransactionId;
0: import org.apache.activemq.command.XATransactionId;
1: import org.apache.activemq.openwire.OpenWireFormat;
1: import org.apache.activemq.protobuf.Buffer;
0: import org.apache.activemq.store.MessageRecoveryListener;
0: import org.apache.activemq.store.MessageStore;
0: import org.apache.activemq.store.PersistenceAdapter;
0: import org.apache.activemq.store.TopicMessageStore;
0: import org.apache.activemq.store.TransactionRecoveryListener;
0: import org.apache.activemq.store.TransactionStore;
1: import org.apache.activemq.usage.MemoryUsage;
1: import org.apache.activemq.usage.SystemUsage;
1: import org.apache.activemq.wireformat.WireFormat;
0: import org.apache.kahadb.journal.Location;
0: import org.apache.kahadb.page.Transaction;
0: import org.apache.kahadb.store.data.KahaAddMessageCommand;
0: import org.apache.kahadb.store.data.KahaCommitCommand;
0: import org.apache.kahadb.store.data.KahaDestination;
0: import org.apache.kahadb.store.data.KahaLocalTransactionId;
0: import org.apache.kahadb.store.data.KahaLocation;
0: import org.apache.kahadb.store.data.KahaPrepareCommand;
0: import org.apache.kahadb.store.data.KahaRemoveDestinationCommand;
0: import org.apache.kahadb.store.data.KahaRemoveMessageCommand;
0: import org.apache.kahadb.store.data.KahaRollbackCommand;
0: import org.apache.kahadb.store.data.KahaSubscriptionCommand;
0: import org.apache.kahadb.store.data.KahaTransactionInfo;
0: import org.apache.kahadb.store.data.KahaXATransactionId;
0: import org.apache.kahadb.store.data.KahaDestination.DestinationType;
1: 
0: public class KahaDBStore extends MessageDatabase implements PersistenceAdapter {
1: 
0:     private WireFormat wireFormat = new OpenWireFormat();
1: 
1:     public void setBrokerName(String brokerName) {
1:     }
1:     public void setUsageManager(SystemUsage usageManager) {
1:     }
1: 
1:     public TransactionStore createTransactionStore() throws IOException {
0:         return new TransactionStore(){
1:             
0:             public void commit(TransactionId txid, boolean wasPrepared) throws IOException {
0:                 store(new KahaCommitCommand().setTransactionInfo(createTransactionInfo(txid)), true);
1:             }
0:             public void prepare(TransactionId txid) throws IOException {
0:                 store(new KahaPrepareCommand().setTransactionInfo(createTransactionInfo(txid)), true);
1:             }
0:             public void rollback(TransactionId txid) throws IOException {
0:                 store(new KahaRollbackCommand().setTransactionInfo(createTransactionInfo(txid)), false);
1:             }
0:             public void recover(TransactionRecoveryListener listener) throws IOException {
0:                 for (Map.Entry<TransactionId, ArrayList<Operation>> entry : preparedTransactions.entrySet()) {
0:                     XATransactionId xid = (XATransactionId)entry.getKey();
0:                     ArrayList<Message> messageList = new ArrayList<Message>();
0:                     ArrayList<MessageAck> ackList = new ArrayList<MessageAck>();
1:                     
0:                     for (Operation op : entry.getValue()) {
0:                         if( op.getClass() == AddOpperation.class ) {
0:                             AddOpperation addOp = (AddOpperation)op;
0:                             Message msg = (Message)wireFormat.unmarshal( new DataInputStream(addOp.getCommand().getMessage().newInput()) );
0:                             messageList.add(msg);
1:                         } else {
0:                             RemoveOpperation rmOp = (RemoveOpperation)op;
0:                             MessageAck ack = (MessageAck)wireFormat.unmarshal( new DataInputStream(rmOp.getCommand().getAck().newInput()) );
0:                             ackList.add(ack);
1:                         }
1:                     }
1:                     
0:                     Message[] addedMessages = new Message[messageList.size()];
0:                     MessageAck[] acks = new MessageAck[ackList.size()];
0:                     messageList.toArray(addedMessages);
0:                     ackList.toArray(acks);
0:                     listener.recover(xid, addedMessages, acks);
1:                 }
1:             }
1:             public void start() throws Exception {
1:             }
1:             public void stop() throws Exception {
1:             }
1:         };
1:     }
1: 
0:     public class KahaDBMessageStore implements MessageStore {
0:         private final ActiveMQDestination destination;
1:         protected KahaDestination dest;
1: 
1:         public KahaDBMessageStore(ActiveMQDestination destination) {
1:             this.destination = destination;
0:             this.dest = convert( destination );
1:         }
1: 
1:         public ActiveMQDestination getDestination() {
1:             return destination;
1:         }
1: 
0:         public void addMessage(ConnectionContext context, Message message) throws IOException {
0:             KahaAddMessageCommand command = new KahaAddMessageCommand();
1:             command.setDestination(dest);
0:             command.setMessageId(message.getMessageId().toString());
0:             command.setTransactionInfo( createTransactionInfo(message.getTransactionId()) );
1: 
1:             org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(message);
1:             command.setMessage(new Buffer(packet.getData(), packet.getOffset(), packet.getLength()));
1: 
0:             store(command, isSyncWrites() && message.isResponseRequired());
1:             
1:         }
1:         
1:         public void removeMessage(ConnectionContext context, MessageAck ack) throws IOException {
1:             KahaRemoveMessageCommand command = new KahaRemoveMessageCommand();
1:             command.setDestination(dest);
0:             command.setMessageId(ack.getLastMessageId().toString());
0:             command.setTransactionInfo(createTransactionInfo(ack.getTransactionId()) );
0:             store(command, isSyncWrites() && ack.isResponseRequired());
1:         }
1: 
1:         public void removeAllMessages(ConnectionContext context) throws IOException {
1:             KahaRemoveDestinationCommand command = new KahaRemoveDestinationCommand();
1:             command.setDestination(dest);
0:             store(command, true);
1:         }
1: 
1:         public Message getMessage(MessageId identity) throws IOException {
0:             final String key = identity.toString();
1:             
0:             // Hopefully one day the page file supports concurrent read operations... but for now we must
0:             // externally synchronize...
1:             Location location;
0:             synchronized(indexMutex) {
0:                 location = pageFile.tx().execute(new Transaction.CallableClosure<Location, IOException>(){
1:                     public Location execute(Transaction tx) throws IOException {
1:                         StoredDestination sd = getStoredDestination(dest, tx);
1:                         Long sequence = sd.messageIdIndex.get(tx, key);
0:                         if( sequence ==null ) {
1:                             return null;
1:                         }
1:                         return sd.orderIndex.get(tx, sequence).location;
1:                     }
1:                 });
1:             }
0:             if( location == null ) {
1:                 return null;
1:             }
1:             
1:             return loadMessage(location);
1:         }
1:         
0:         public int getMessageCount() throws IOException {
0:             synchronized(indexMutex) {
0:                 return pageFile.tx().execute(new Transaction.CallableClosure<Integer, IOException>(){
0:                     public Integer execute(Transaction tx) throws IOException {
0:                         // Iterate through all index entries to get a count of messages in the destination.
1:                         StoredDestination sd = getStoredDestination(dest, tx);
0:                         int rc=0;
0:                         for (Iterator<Entry<Location, Long>> iterator = sd.locationIndex.iterator(tx); iterator.hasNext();) {
0:                             iterator.next();
0:                             rc++;
1:                         }
1:                         return rc;
1:                     }
1:                 });
1:             }
1:         }
1: 
1:         public void recover(final MessageRecoveryListener listener) throws Exception {
0:             synchronized(indexMutex) {
0:                 pageFile.tx().execute(new Transaction.Closure<Exception>(){
1:                     public void execute(Transaction tx) throws Exception {
1:                         StoredDestination sd = getStoredDestination(dest, tx);
0:                         for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx); iterator.hasNext();) {
1:                             Entry<Long, MessageKeys> entry = iterator.next();
0:                             listener.recoverMessage( loadMessage(entry.getValue().location) );
1:                         }
1:                     }
1:                 });
1:             }
1:         }
1: 
0:         long cursorPos=0;
1:         
1:         public void recoverNextMessages(final int maxReturned, final MessageRecoveryListener listener) throws Exception {
0:             synchronized(indexMutex) {
0:                 pageFile.tx().execute(new Transaction.Closure<Exception>(){
1:                     public void execute(Transaction tx) throws Exception {
1:                         StoredDestination sd = getStoredDestination(dest, tx);
0:                         Entry<Long, MessageKeys> entry=null;
0:                         int counter = 0;
0:                         for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx, cursorPos); iterator.hasNext();) {
1:                             entry = iterator.next();
0:                             listener.recoverMessage( loadMessage(entry.getValue().location ) );
1:                             counter++;
0:                             if( counter >= maxReturned ) {
1:                                 break;
1:                             }
1:                         }
0:                         if( entry!=null ) {
0:                             cursorPos = entry.getKey()+1;
1:                         }
1:                     }
1:                 });
1:             }
1:         }
1: 
1:         public void resetBatching() {
0:             cursorPos=0;
1:         }
1: 
0:         public void setMemoryUsage(MemoryUsage memoeyUSage) {
1:         }
1:         public void start() throws Exception {
1:         }
1:         public void stop() throws Exception {
1:         }
1:         
1:     }
1:         
1:     class KahaDBTopicMessageStore extends KahaDBMessageStore implements TopicMessageStore {
0:         public KahaDBTopicMessageStore(ActiveMQTopic destination) {
1:             super(destination);
1:         }
1:         
0:         public void acknowledge(ConnectionContext context, String clientId, String subscriptionName, MessageId messageId) throws IOException {
1:             KahaRemoveMessageCommand command = new KahaRemoveMessageCommand();
1:             command.setDestination(dest);
0:             command.setSubscriptionKey(subscriptionKey(clientId, subscriptionName));
0:             command.setMessageId(messageId.toString());
0:             // We are not passed a transaction info.. so we can't participate in a transaction.
0:             // Looks like a design issue with the TopicMessageStore interface.  Also we can't recover the original ack
0:             // to pass back to the XA recover method.
0:             // command.setTransactionInfo();
0:             store(command, false);
1:         }
1: 
0:         public void addSubsciption(SubscriptionInfo subscriptionInfo, boolean retroactive) throws IOException {
0:             String subscriptionKey = subscriptionKey(subscriptionInfo.getClientId(), subscriptionInfo.getSubscriptionName());
1:             KahaSubscriptionCommand command = new KahaSubscriptionCommand();
1:             command.setDestination(dest);
1:             command.setSubscriptionKey(subscriptionKey);
1:             command.setRetroactive(retroactive);
1:             org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(subscriptionInfo);
1:             command.setSubscriptionInfo(new Buffer(packet.getData(), packet.getOffset(), packet.getLength()));
0:             store(command, isSyncWrites() && true);
1:         }
1: 
1:         public void deleteSubscription(String clientId, String subscriptionName) throws IOException {
1:             KahaSubscriptionCommand command = new KahaSubscriptionCommand();
1:             command.setDestination(dest);
0:             command.setSubscriptionKey(subscriptionKey(clientId, subscriptionName));
0:             store(command, isSyncWrites() && true);
1:         }
1: 
1:         public SubscriptionInfo[] getAllSubscriptions() throws IOException {
1:             
1:             final ArrayList<SubscriptionInfo> subscriptions = new ArrayList<SubscriptionInfo>();
0:             synchronized(indexMutex) {
0:                 pageFile.tx().execute(new Transaction.Closure<IOException>(){
1:                     public void execute(Transaction tx) throws IOException {
1:                         StoredDestination sd = getStoredDestination(dest, tx);
0:                         for (Iterator<Entry<String, KahaSubscriptionCommand>> iterator = sd.subscriptions.iterator(tx); iterator.hasNext();) {
1:                             Entry<String, KahaSubscriptionCommand> entry = iterator.next();
0:                             SubscriptionInfo info = (SubscriptionInfo)wireFormat.unmarshal( new DataInputStream(entry.getValue().getSubscriptionInfo().newInput()) );
1:                             subscriptions.add(info);
1: 
1:                         }
1:                     }
1:                 });
1:             }
1:             
0:             SubscriptionInfo[]rc=new SubscriptionInfo[subscriptions.size()];
1:             subscriptions.toArray(rc);
1:             return rc;
1:         }
1: 
1:         public SubscriptionInfo lookupSubscription(String clientId, String subscriptionName) throws IOException {
1:             final String subscriptionKey = subscriptionKey(clientId, subscriptionName);
0:             synchronized(indexMutex) {
0:                 return pageFile.tx().execute(new Transaction.CallableClosure<SubscriptionInfo, IOException>(){
1:                     public SubscriptionInfo execute(Transaction tx) throws IOException {
1:                         StoredDestination sd = getStoredDestination(dest, tx);
1:                         KahaSubscriptionCommand command = sd.subscriptions.get(tx, subscriptionKey);
0:                         if( command ==null ) {
1:                             return null;
1:                         }
0:                         return (SubscriptionInfo)wireFormat.unmarshal( new DataInputStream(command.getSubscriptionInfo().newInput()) );
1:                     }
1:                 });
1:             }
1:         }
1:        
1:         public int getMessageCount(String clientId, String subscriptionName) throws IOException {
1:             final String subscriptionKey = subscriptionKey(clientId, subscriptionName);
0:             synchronized(indexMutex) {
0:                 return pageFile.tx().execute(new Transaction.CallableClosure<Integer, IOException>(){
0:                     public Integer execute(Transaction tx) throws IOException {
1:                         StoredDestination sd = getStoredDestination(dest, tx);
0:                         Long cursorPos = sd.subscriptionAcks.get(tx, subscriptionKey);
0:                         if ( cursorPos==null ) {
0:                             // The subscription might not exist.
0:                             return 0;
1:                         }
0:                         cursorPos += 1;
1:                         
0:                         int counter = 0;
0:                         for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx, cursorPos); iterator.hasNext();) {
0:                             iterator.next();
1:                             counter++;
1:                         }
0:                         return counter;
1:                     }
1:                 });
1:             }        
1:         }
1: 
0:         public void recoverSubscription(String clientId, String subscriptionName, final MessageRecoveryListener listener) throws Exception {
1:             final String subscriptionKey = subscriptionKey(clientId, subscriptionName);
0:             synchronized(indexMutex) {
0:                 pageFile.tx().execute(new Transaction.Closure<Exception>(){
1:                     public void execute(Transaction tx) throws Exception {
1:                         StoredDestination sd = getStoredDestination(dest, tx);
0:                         Long cursorPos = sd.subscriptionAcks.get(tx, subscriptionKey);
0:                         cursorPos += 1;
1:                         
0:                         for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx, cursorPos); iterator.hasNext();) {
1:                             Entry<Long, MessageKeys> entry = iterator.next();
0:                             listener.recoverMessage( loadMessage(entry.getValue().location ) );
1:                         }
1:                     }
1:                 });
1:             }
1:         }
1: 
0:         public void recoverNextMessages(String clientId, String subscriptionName, final int maxReturned, final MessageRecoveryListener listener) throws Exception {
1:             final String subscriptionKey = subscriptionKey(clientId, subscriptionName);
0:             synchronized(indexMutex) {
0:                 pageFile.tx().execute(new Transaction.Closure<Exception>(){
1:                     public void execute(Transaction tx) throws Exception {
1:                         StoredDestination sd = getStoredDestination(dest, tx);
0:                         Long cursorPos = sd.subscriptionCursors.get(subscriptionKey);
0:                         if( cursorPos == null ) {
0:                             cursorPos = sd.subscriptionAcks.get(tx, subscriptionKey);
0:                             cursorPos += 1;
1:                         }
1:                         
0:                         Entry<Long, MessageKeys> entry=null;
0:                         int counter = 0;
0:                         for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx, cursorPos); iterator.hasNext();) {
1:                             entry = iterator.next();
0:                             listener.recoverMessage( loadMessage(entry.getValue().location ) );
1:                             counter++;
0:                             if( counter >= maxReturned ) {
1:                                 break;
1:                             }
1:                         }
0:                         if( entry!=null ) {
0:                             sd.subscriptionCursors.put(subscriptionKey, cursorPos+1);
1:                         }
1:                     }
1:                 });
1:             }
1:         }
1: 
1:         public void resetBatching(String clientId, String subscriptionName) {
1:             try {
1:                 final String subscriptionKey = subscriptionKey(clientId, subscriptionName);
0:                 synchronized(indexMutex) {
0:                     pageFile.tx().execute(new Transaction.Closure<IOException>(){
1:                         public void execute(Transaction tx) throws IOException {
1:                             StoredDestination sd = getStoredDestination(dest, tx);
1:                             sd.subscriptionCursors.remove(subscriptionKey);
1:                         }
1:                     });
1:                 }
1:             } catch (IOException e) {
1:                 throw new RuntimeException(e);
1:             }
1:         }
1:     }
1: 
0:     String subscriptionKey(String clientId, String subscriptionName){
0:         return clientId+":"+subscriptionName;
1:     }
1:     
1:     public MessageStore createQueueMessageStore(ActiveMQQueue destination) throws IOException {
0:         return new KahaDBMessageStore(destination);
1:     }
1: 
1:     public TopicMessageStore createTopicMessageStore(ActiveMQTopic destination) throws IOException {
0:         return new KahaDBTopicMessageStore(destination);
1:     }
1:     
1:     public void deleteAllMessages() throws IOException {
0:         deleteAllMessages=true;
1:     }
1:     
1:     
1:     public Set<ActiveMQDestination> getDestinations() {
1:         try {
1:             final HashSet<ActiveMQDestination> rc = new HashSet<ActiveMQDestination>();
0:             synchronized(indexMutex) {
0:                 pageFile.tx().execute(new Transaction.Closure<IOException>(){
1:                     public void execute(Transaction tx) throws IOException {
0:                         for (Iterator<Entry<String, StoredDestination>> iterator = metadata.destinations.iterator(tx); iterator.hasNext();) {
1:                             Entry<String, StoredDestination> entry = iterator.next();
0:                             rc.add(convert(entry.getKey()));
1:                         }
1:                     }
1:                 });
1:             }
1:             return rc;
1:         } catch (IOException e) {
1:             throw new RuntimeException(e);
1:         }
1:     }
1:     
1:     public long getLastMessageBrokerSequenceId() throws IOException {
0:         return 0;
1:     }
1:     
1:     public long size() {
0:         if ( !started.get() ) {
0:             return 0;
1:         }
1:         try {
0:             return journal.getDiskSize() + pageFile.getDiskSize();
1:         } catch (IOException e) {
1:             throw new RuntimeException(e);
1:         }
1:     }
1: 
1:     public void beginTransaction(ConnectionContext context) throws IOException {
1:         throw new IOException("Not yet implemented.");
1:     }
1:     public void commitTransaction(ConnectionContext context) throws IOException {
1:         throw new IOException("Not yet implemented.");
1:     }
1:     public void rollbackTransaction(ConnectionContext context) throws IOException {
1:         throw new IOException("Not yet implemented.");
1:     }
1:     
1:     public void checkpoint(boolean sync) throws IOException {
0:         super.checkpointCleanup(false);
1:     }
1:     
1:     
0:     ///////////////////////////////////////////////////////////////////
1:     // Internal helper methods.
0:     ///////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * @param location
1:      * @return
1:      * @throws IOException
1:      */
1:     Message loadMessage(Location location) throws IOException {
0:         KahaAddMessageCommand addMessage = (KahaAddMessageCommand)load(location);
0:         Message msg = (Message)wireFormat.unmarshal( new DataInputStream(addMessage.getMessage().newInput()) );
0:         return msg;
1:     }
1: 
0:     ///////////////////////////////////////////////////////////////////
1:     // Internal conversion methods.
0:     ///////////////////////////////////////////////////////////////////
1:     
0:     KahaTransactionInfo createTransactionInfo(TransactionId txid) {
0:         if( txid ==null ) {
1:             return null;
1:         }
0:         KahaTransactionInfo rc = new KahaTransactionInfo();
1:         
0:         // Link it up to the previous record that was part of the transaction.
0:         ArrayList<Operation> tx = inflightTransactions.get(txid);
0:         if( tx!=null ) {
0:             rc.setPreviousEntry(convert(tx.get(tx.size()-1).location));
1:         }
1:         
0:         if( txid.isLocalTransaction() ) {
0:             LocalTransactionId t = (LocalTransactionId)txid;
0:             KahaLocalTransactionId kahaTxId = new KahaLocalTransactionId();
0:             kahaTxId.setConnectionId(t.getConnectionId().getValue());
0:             kahaTxId.setTransacitonId(t.getValue());
0:             rc.setLocalTransacitonId(kahaTxId);
1:         } else {
0:             XATransactionId t = (XATransactionId)txid;
0:             KahaXATransactionId kahaTxId = new KahaXATransactionId();
0:             kahaTxId.setBranchQualifier(new Buffer(t.getBranchQualifier()));
0:             kahaTxId.setGlobalTransactionId(new Buffer(t.getGlobalTransactionId()));
0:             kahaTxId.setFormatId(t.getFormatId());
0:             rc.setXaTransacitonId(kahaTxId);
1:         }
1:         return rc;
1:     }
1:     
1:     KahaLocation convert(Location location) {
1:         KahaLocation rc = new KahaLocation();
1:         rc.setLogId(location.getDataFileId());
1:         rc.setOffset(location.getOffset());
1:         return rc;
1:     }
1:     
1:     KahaDestination convert(ActiveMQDestination dest) {
1:         KahaDestination rc = new KahaDestination();
1:         rc.setName(dest.getPhysicalName());
0:         switch( dest.getDestinationType() ) {
1:         case ActiveMQDestination.QUEUE_TYPE:
1:             rc.setType(DestinationType.QUEUE);
1:             return rc;
1:         case ActiveMQDestination.TOPIC_TYPE:
1:             rc.setType(DestinationType.TOPIC);
1:             return rc;
1:         case ActiveMQDestination.TEMP_QUEUE_TYPE:
1:             rc.setType(DestinationType.TEMP_QUEUE);
1:             return rc;
1:         case ActiveMQDestination.TEMP_TOPIC_TYPE:
1:             rc.setType(DestinationType.TEMP_TOPIC);
1:             return rc;
0:         default:
1:             return null;
1:         }
1:     }
1: 
1:     ActiveMQDestination convert(String dest) {
1:         int p = dest.indexOf(":");
0:         if( p<0 ) {
1:             throw new IllegalArgumentException("Not in the valid destination format");
1:         }
1:         int type = Integer.parseInt(dest.substring(0, p));
0:         String name = dest.substring(p+1);
1:         
0:         switch( KahaDestination.DestinationType.valueOf(type) ) {
1:         case QUEUE:
1:             return new ActiveMQQueue(name);
1:         case TOPIC:
1:             return new ActiveMQTopic(name);
1:         case TEMP_QUEUE:
1:             return new ActiveMQTempQueue(name);
1:         case TEMP_TOPIC:
1:             return new ActiveMQTempTopic(name);
0:         default:    
1:             throw new IllegalArgumentException("Not in the valid destination format");
1:         }
1:     }
1:         
1: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:7450a32
/////////////////////////////////////////////////////////////////////////
1:                         for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx); iterator.hasNext(); ) {
commit:a604424
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             return journalSize.get() + getPageFile().getDiskSize();
0:         } catch (IOException e) {
0:             throw new RuntimeException(e);
1:         }
commit:15de238
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.*;
/////////////////////////////////////////////////////////////////////////
1:         this.queueExecutor = new StoreTaskExecutor(1, asyncExecutorMaxThreads, 0L, TimeUnit.MILLISECONDS,
/////////////////////////////////////////////////////////////////////////
1:         this.topicExecutor = new StoreTaskExecutor(1, asyncExecutorMaxThreads, 0L, TimeUnit.MILLISECONDS,
/////////////////////////////////////////////////////////////////////////
1:     public interface StoreTask {
1: 
1:         public void aquireLocks();
1: 
1:         public void releaseLocks();
/////////////////////////////////////////////////////////////////////////
1:         public void aquireLocks() {
/////////////////////////////////////////////////////////////////////////
1:         public void releaseLocks() {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         public void aquireLocks() {
/////////////////////////////////////////////////////////////////////////
1:         public void releaseLocks() {
/////////////////////////////////////////////////////////////////////////
1: 
1:     public class StoreTaskExecutor extends ThreadPoolExecutor {
1: 
1:         public StoreTaskExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit timeUnit, BlockingQueue<Runnable> queue, ThreadFactory threadFactory) {
1:             super(corePoolSize, maximumPoolSize, keepAliveTime, timeUnit, queue, threadFactory);
1:         }
1: 
1:         protected void afterExecute(Runnable runnable, Throwable throwable) {
1:             super.afterExecute(runnable, throwable);
1: 
1:             if (runnable instanceof StoreTask) {
1:                ((StoreTask)runnable).releaseLocks();
1:             }
1: 
1:         }
1:     }
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     static final Logger LOG = LoggerFactory.getLogger(KahaDBStore.class);
commit:8cb9ef3
/////////////////////////////////////////////////////////////////////////
1:                         sd.orderIndex.stoppedIterating();
commit:9f417a2
/////////////////////////////////////////////////////////////////////////
1:                         try {
0:                             BooleanExpression selectorExpression = null;
0:                                 selectorExpression = SelectorParser.parse(selector);
1:                             }
0:                             for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx, cursorPos); iterator.hasNext();) {
0:                                 Entry<Long, MessageKeys> entry = iterator.next();
0:                                 if (selectorExpression != null) { 
1:                                 } else {
0:                                     counter++;
1:                         } catch (Exception e) {
0:                             throw IOExceptionSupport.create(e);
commit:d96c1cb
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.InvalidSelectorException;
1: 
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.filter.BooleanExpression;
0: import org.apache.activemq.filter.MessageEvaluationContext;
0: import org.apache.activemq.selector.SelectorParser;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.IOExceptionSupport;
/////////////////////////////////////////////////////////////////////////
1:             final SubscriptionInfo info = lookupSubscription(clientId, subscriptionName);
/////////////////////////////////////////////////////////////////////////
0:                             Entry<Long, MessageKeys> entry = iterator.next();
0:                             String selector = info.getSelector();
0:                             if (selector != null) {
1:                                 try {
0:                                     if (selector != null) { 
0:                                         BooleanExpression selectorExpression = SelectorParser.parse(selector);
0:                                         MessageEvaluationContext ctx = new MessageEvaluationContext();
0:                                         ctx.setMessageReference(loadMessage(entry.getValue().location));
0:                                         if (selectorExpression.matches(ctx)) {
0:                                             counter++;
1:                                         }
1:                                     }
0:                                 } catch (Exception e) {
0:                                     throw IOExceptionSupport.create(e);
1:                                 }
1:                             } else {
0:                                 counter++;
1:                             }
author:Gary Tully
-------------------------------------------------------------------------------
commit:20d3bdb
/////////////////////////////////////////////////////////////////////////
1:                     if (ack.isInTransaction() || !task.cancel()) {
commit:b07f31e
/////////////////////////////////////////////////////////////////////////
1:             } else {
1:                 org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(ack);
1:                 command.setAck(new Buffer(packet.getData(), packet.getOffset(), packet.getLength()));
/////////////////////////////////////////////////////////////////////////
1:                             if (ackedAndPrepared.contains(entry.getValue().messageId)) {
1:                                 continue;
1:                             }
/////////////////////////////////////////////////////////////////////////
1:                             if (ackedAndPrepared.contains(entry.getValue().messageId)) {
1:                                 continue;
1:                             }
commit:a3f85e2
/////////////////////////////////////////////////////////////////////////
1:             indexLock.writeLock().lock();
1:                 indexLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:                 indexLock.writeLock().lock();
/////////////////////////////////////////////////////////////////////////
1:                     indexLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:             indexLock.writeLock().lock();
/////////////////////////////////////////////////////////////////////////
1:                 indexLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:             indexLock.writeLock().lock();
/////////////////////////////////////////////////////////////////////////
1:                 indexLock.writeLock().unlock();
1:                 indexLock.writeLock().lock();
/////////////////////////////////////////////////////////////////////////
1:                 }finally {
1:                     indexLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:             indexLock.writeLock().lock();
/////////////////////////////////////////////////////////////////////////
1:                 indexLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:             indexLock.writeLock().lock();
/////////////////////////////////////////////////////////////////////////
1:                 indexLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:             indexLock.writeLock().lock();
/////////////////////////////////////////////////////////////////////////
1:                 indexLock.writeLock().unlock();
commit:81e1de9
/////////////////////////////////////////////////////////////////////////
0:         if (brokerService != null) {
0:             RegionBroker regionBroker = (RegionBroker) brokerService.getRegionBroker();
0:             if (regionBroker != null) {
0:                 Set<Destination> destinationSet = regionBroker.getDestinations(convert(commandDestination));
0:                 for (Destination destination : destinationSet) {
0:                     destination.getDestinationStatistics().getMessages().decrement();
0:                     destination.getDestinationStatistics().getEnqueues().decrement();
1:                 }
1:             }
commit:fb0b63e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.Destination;
0: import org.apache.activemq.broker.region.RegionBroker;
/////////////////////////////////////////////////////////////////////////
1:     @Override
0:     void rollbackStatsOnDuplicate(KahaDestination commandDestination) {
0:         RegionBroker regionBroker = (RegionBroker) brokerService.getRegionBroker();
0:         Set<Destination> destinationSet = regionBroker.getDestinations(convert(commandDestination));
0:         for (Destination destination : destinationSet) {
0:             destination.getDestinationStatistics().getMessages().decrement();
0:             destination.getDestinationStatistics().getEnqueues().decrement();
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         return convert(type, name);
1:     }
1:     private ActiveMQDestination convert(KahaDestination commandDestination) {
1:         return convert(commandDestination.getType().getNumber(), commandDestination.getName());
1:     }
1: 
1:     private ActiveMQDestination convert(int type, String name) {
commit:89f22da
/////////////////////////////////////////////////////////////////////////
1:         super.checkpointCleanup(sync);
commit:2030097
/////////////////////////////////////////////////////////////////////////
0: import org.apache.kahadb.util.ByteSequence;
/////////////////////////////////////////////////////////////////////////
0:     void incrementRedeliveryAndReWrite(final String key, final KahaDestination destination) throws IOException {
0:         Location location;
0:         this.indexLock.writeLock().lock();
1:         try {
0:               location = findMessageLocation(key, destination);
0:         } finally {
0:             this.indexLock.writeLock().unlock();
1:         }
1: 
0:         if (location != null) {
0:             KahaAddMessageCommand addMessage = (KahaAddMessageCommand) load(location);
0:             Message message = (Message) wireFormat.unmarshal(new DataInputStream(addMessage.getMessage().newInput()));
1: 
0:             message.incrementRedeliveryCounter();
0:             if (LOG.isTraceEnabled()) {
0:                 LOG.trace("rewriting: " + key + " with deliveryCount: " + message.getRedeliveryCounter());
1:             }
0:             org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(message);
0:             addMessage.setMessage(new Buffer(packet.getData(), packet.getOffset(), packet.getLength()));
1: 
0:             final Location rewriteLocation = journal.write(toByteSequence(addMessage), true);
1: 
0:             this.indexLock.writeLock().lock();
1:             try {
1:                 pageFile.tx().execute(new Transaction.Closure<IOException>() {
0:                     public void execute(Transaction tx) throws IOException {
1:                         StoredDestination sd = getStoredDestination(destination, tx);
0:                         Long sequence = sd.messageIdIndex.get(tx, key);
0:                         MessageKeys keys = sd.orderIndex.get(tx, sequence);
0:                         sd.orderIndex.put(tx, sd.orderIndex.lastGetPriority(), sequence, new MessageKeys(keys.messageId, rewriteLocation));
1:                     }
0:                 });
0:             } finally {
0:                 this.indexLock.writeLock().unlock();
1:             }
1:         }
1:     }
1: 
1:     private Location findMessageLocation(final String key, final KahaDestination destination) throws IOException {
1:         return pageFile.tx().execute(new Transaction.CallableClosure<Location, IOException>() {
0:             public Location execute(Transaction tx) throws IOException {
1:                 StoredDestination sd = getStoredDestination(destination, tx);
0:                 Long sequence = sd.messageIdIndex.get(tx, key);
1:                 if (sequence == null) {
0:                     return null;
1:                 }
0:                 return sd.orderIndex.get(tx, sequence).location;
1:             }
0:         });
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 location = findMessageLocation(key, dest);
commit:1595378
/////////////////////////////////////////////////////////////////////////
0: import java.util.Map.Entry;
0: import java.util.concurrent.*;
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQQueue;
0: import org.apache.activemq.command.ActiveMQTempQueue;
0: import org.apache.activemq.command.ActiveMQTempTopic;
0: import org.apache.activemq.command.ActiveMQTopic;
0: import org.apache.activemq.command.Message;
0: import org.apache.activemq.command.MessageAck;
0: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.command.ProducerId;
0: import org.apache.activemq.command.SubscriptionInfo;
0: import org.apache.activemq.command.TransactionId;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.kahadb.data.KahaTransactionInfo;
0: import org.apache.activemq.store.kahadb.data.KahaDestination.DestinationType;
0: import org.apache.kahadb.journal.Location;
0: import org.apache.kahadb.page.Transaction;
/////////////////////////////////////////////////////////////////////////
1:             PROPERTY_ASYNC_EXECUTOR_MAX_THREADS, "1"), 10);;
/////////////////////////////////////////////////////////////////////////
1:     private TransactionIdTransformer transactionIdTransformer;
1:         this.transactionIdTransformer = new TransactionIdTransformer() {
1:             @Override
0:             public KahaTransactionInfo transform(TransactionId txid) {
0:                 return TransactionIdConversion.convert(txid);
1:             }
0:         };
/////////////////////////////////////////////////////////////////////////
1:      * @param concurrentStoreAndDispatch
1:      *            the concurrentStoreAndDispatch to set
/////////////////////////////////////////////////////////////////////////
1:      * @param concurrentStoreAndDispatch
1:      *            the concurrentStoreAndDispatch to set
/////////////////////////////////////////////////////////////////////////
1:     
1:      * @param maxAsyncJobs
1:      *            the maxAsyncJobs to set
/////////////////////////////////////////////////////////////////////////
0:                     public Thread newThread(Runnable runnable) {
0:                         Thread thread = new Thread(runnable, "ConcurrentQueueStoreAndDispatch");
0:                         thread.setDaemon(true);
0:                         return thread;
1:                     }
0:                 });
0:                     public Thread newThread(Runnable runnable) {
0:                         Thread thread = new Thread(runnable, "ConcurrentTopicStoreAndDispatch");
0:                         thread.setDaemon(true);
0:                         return thread;
1:                     }
0:                 });
/////////////////////////////////////////////////////////////////////////
0:         public KahaDBMessageStore(ActiveMQDestination destination) {
/////////////////////////////////////////////////////////////////////////
0:             command.setTransactionInfo(transactionIdTransformer.transform(message.getTransactionId()));
0:             store(command, isEnableJournalDiskSyncs() && message.isResponseRequired(), null, null);
1:             
0:             command.setTransactionInfo(transactionIdTransformer.transform(ack.getTransactionId()));
1:             store(command, isEnableJournalDiskSyncs() && ack.isResponseRequired(), null, null);
1:             store(command, true, null, null);
/////////////////////////////////////////////////////////////////////////
1:             }finally {
0:             return loadMessage(location);
/////////////////////////////////////////////////////////////////////////
1:                                     .hasNext();) {
0:                 }finally {
/////////////////////////////////////////////////////////////////////////
0:             }finally {
/////////////////////////////////////////////////////////////////////////
1:                             Message msg = loadMessage(entry.getValue().location);
0:             }finally {
1:         
/////////////////////////////////////////////////////////////////////////
1:                             Message msg = loadMessage(entry.getValue().location);
/////////////////////////////////////////////////////////////////////////
0:             }finally {
1:             if (pageFile.isLoaded()) {
1:                 try {
1:                     pageFile.tx().execute(new Transaction.Closure<Exception>() {
1:                         public void execute(Transaction tx) throws Exception {
1:                             StoredDestination sd = getExistingStoredDestination(dest, tx);
1:                             if (sd != null) {
1:                                 sd.orderIndex.resetCursorPosition();}
1:                             }
0:                         });
0:                 } catch (Exception e) {
1:                     LOG.error("Failed to reset batching",e);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                
1:                         pageFile.tx().execute(new Transaction.Closure<IOException>() {
/////////////////////////////////////////////////////////////////////////
0:                 }finally {
1:                 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             command.setTransactionInfo(transactionIdTransformer.transform(ack.getTransactionId()));
1:             store(command, false, null, null);
/////////////////////////////////////////////////////////////////////////
1:             store(command, isEnableJournalDiskSyncs() && true, null, null);
/////////////////////////////////////////////////////////////////////////
1:             store(command, isEnableJournalDiskSyncs() && true, null, null);
/////////////////////////////////////////////////////////////////////////
1:                                 .hasNext();) {
/////////////////////////////////////////////////////////////////////////
0:             }finally {
/////////////////////////////////////////////////////////////////////////
0:             }finally {
/////////////////////////////////////////////////////////////////////////
0:                                 sd.ackPositions.iterator(tx, cursorPos.lastAckedSequence); iterator.hasNext();) {
/////////////////////////////////////////////////////////////////////////
0:             }finally {
/////////////////////////////////////////////////////////////////////////
1:                                 .hasNext();) {
1:                             listener.recoverMessage(loadMessage(entry.getValue().location));
0:             }finally {
1:                 final MessageRecoveryListener listener) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:                                 .hasNext();) {
1:                             if (listener.recoverMessage(loadMessage(entry.getValue().location))) {
/////////////////////////////////////////////////////////////////////////
0:             }finally {
/////////////////////////////////////////////////////////////////////////
0:                 }finally {
/////////////////////////////////////////////////////////////////////////
0:      * 
1:      * @param destination
1:      *            Destination to forget
/////////////////////////////////////////////////////////////////////////
0:      * 
1:      * @param destination
1:      *            Destination to forget
/////////////////////////////////////////////////////////////////////////
0:                                 .hasNext();) {
/////////////////////////////////////////////////////////////////////////
0:             }finally {
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     Message loadMessage(Location location) throws IOException {
0:         KahaAddMessageCommand addMessage = (KahaAddMessageCommand) load(location);
/////////////////////////////////////////////////////////////////////////
0:         case ActiveMQDestination.QUEUE_TYPE:
0:             rc.setType(DestinationType.QUEUE);
0:             return rc;
0:         case ActiveMQDestination.TOPIC_TYPE:
0:             rc.setType(DestinationType.TOPIC);
0:             return rc;
0:         case ActiveMQDestination.TEMP_QUEUE_TYPE:
0:             rc.setType(DestinationType.TEMP_QUEUE);
0:             return rc;
0:         case ActiveMQDestination.TEMP_TOPIC_TYPE:
0:             rc.setType(DestinationType.TEMP_TOPIC);
0:             return rc;
0:         default:
0:             return null;
/////////////////////////////////////////////////////////////////////////
0:         case QUEUE:
0:             return new ActiveMQQueue(name);
0:         case TOPIC:
0:             return new ActiveMQTopic(name);
0:         case TEMP_QUEUE:
0:             return new ActiveMQTempQueue(name);
0:         case TEMP_TOPIC:
0:             return new ActiveMQTempTopic(name);
0:         default:
0:             throw new IllegalArgumentException("Not in the valid destination format");
1:     public TransactionIdTransformer getTransactionIdTransformer() {
1:         return transactionIdTransformer;
1:     }
1: 
1:     public void setTransactionIdTransformer(TransactionIdTransformer transactionIdTransformer) {
1:         this.transactionIdTransformer = transactionIdTransformer;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 int subscriptionCount) {
/////////////////////////////////////////////////////////////////////////
0:          * 
1:          * @param key
/////////////////////////////////////////////////////////////////////////
0:                ((StoreTask)runnable).releaseLocks();
commit:383a7ac
/////////////////////////////////////////////////////////////////////////
1:                         for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx); listener.hasSpace() && iterator
commit:9026274
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public String toString() {
1:         return "KahaDB:[" + directory.getAbsolutePath() + "]";
1:     }
1: 
commit:7631ca9
/////////////////////////////////////////////////////////////////////////
1:             // recovery may involve expiry which will modify
1:             indexLock.writeLock().lock();
/////////////////////////////////////////////////////////////////////////
1:                 indexLock.writeLock().unlock();
commit:717bca1
/////////////////////////////////////////////////////////////////////////
commit:101e711
/////////////////////////////////////////////////////////////////////////
1:                             if (ackedAndPrepared.contains(entry.getValue().messageId)) {
1:                                 continue;
1:                             }
/////////////////////////////////////////////////////////////////////////
1:                             if (ackedAndPrepared.contains(entry.getValue().messageId)) {
1:                                 continue;
1:                             }
commit:88c1084
/////////////////////////////////////////////////////////////////////////
0:             command.setTransactionInfo(createTransactionInfo(ack.getTransactionId()));
commit:a6c51a4
/////////////////////////////////////////////////////////////////////////
commit:acc3d4f
/////////////////////////////////////////////////////////////////////////
0:                         for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx);
0:                              listener.hasSpace() && iterator.hasNext(); ) {
0:                             if (counter >= maxReturned) {
/////////////////////////////////////////////////////////////////////////
1:                 indexLock.writeLock().lock();
/////////////////////////////////////////////////////////////////////////
1:                     indexLock.writeLock().unlock();
commit:aec047d
/////////////////////////////////////////////////////////////////////////
1:                             if (pos == null) {
1:                                 // sub deleted
1:                                 return;
1:                             }
commit:6eafe93
/////////////////////////////////////////////////////////////////////////
0:                             if (loadedStore.subscriptionAcks.isEmpty(tx)) {
commit:21664a9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                         for (Iterator<Entry<Long, HashSet<String>>> iterator =
0:                                 sd.ackPositions.iterator(tx, cursorPos.lastAckedSequence); iterator.hasNext();) {
0:                             Entry<Long, HashSet<String>> entry = iterator.next();
0:                             if (entry.getValue().contains(subscriptionKey)) {
0:                                 counter++;
commit:8871c67
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                         LastAck cursorPos = sd.subscriptionAcks.get(tx, subscriptionKey);
/////////////////////////////////////////////////////////////////////////
1:                             sd.orderIndex.setBatch(tx, cursorPos);
/////////////////////////////////////////////////////////////////////////
0:                         LastAck cursorPos = sd.subscriptionAcks.get(tx, subscriptionKey);
0:                         sd.orderIndex.setBatch(tx, cursorPos);
/////////////////////////////////////////////////////////////////////////
0:                             LastAck pos = sd.subscriptionAcks.get(tx, subscriptionKey);
1:                             sd.orderIndex.setBatch(tx, pos);
/////////////////////////////////////////////////////////////////////////
commit:3f0cf98
/////////////////////////////////////////////////////////////////////////
0:                             if (loadedStore.ackPositions.isEmpty(tx)) {
commit:6fd292d
/////////////////////////////////////////////////////////////////////////
0:         // an ack for an unmatched message is stored as a negative sequence id
0:         // if sub has been getting unmatched acks, we need to reset
0:         protected Long resetForSelectors(SubscriptionInfo info, Long position) {
0:             if (info.getSelector() != null) {
0:                 if (position < NOT_ACKED) {
0:                     position = NOT_ACKED;
1:                 }
1:             }
0:             return position;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:                         cursorPos = resetForSelectors(info, cursorPos);
/////////////////////////////////////////////////////////////////////////
0:                             sd.orderIndex.setBatch(tx, extractSequenceId(cursorPos));
/////////////////////////////////////////////////////////////////////////
1:             final SubscriptionInfo info = lookupSubscription(clientId, subscriptionName);
0:                         cursorPos = resetForSelectors(info, cursorPos);
0:                         sd.orderIndex.setBatch(tx, extractSequenceId(cursorPos));
/////////////////////////////////////////////////////////////////////////
0:             final SubscriptionInfo info = lookupSubscription(clientId, subscriptionName);
/////////////////////////////////////////////////////////////////////////
0:                             Long pos = sd.subscriptionAcks.get(tx, subscriptionKey);
0:                             pos = resetForSelectors(info, pos);
0:                             sd.orderIndex.setBatch(tx, extractSequenceId(pos));
commit:6ddbba4
/////////////////////////////////////////////////////////////////////////
1:                     doAcknowledge(context, subscriptionKey, messageId, ack);
1:                 doAcknowledge(context, subscriptionKey, messageId, ack);
1:         protected void doAcknowledge(ConnectionContext context, String subscriptionKey, MessageId messageId, MessageAck ack)
1:             if (ack != null && ack.isUnmatchedAck()) {
1:                 command.setAck(UNMATCHED);
1:             }
/////////////////////////////////////////////////////////////////////////
0:                             sd.orderIndex.setBatch(tx, cursorPos);
/////////////////////////////////////////////////////////////////////////
0:                         sd.orderIndex.setBatch(tx, cursorPos);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                             sd.orderIndex.setBatch(tx, pos);
/////////////////////////////////////////////////////////////////////////
1:                             this.topicStore.doAcknowledge(context, key, this.message.getMessageId(), null);
commit:514ef7d
/////////////////////////////////////////////////////////////////////////
0:                             sd.orderIndex.setBatch(tx, (selectorExpression == null ? cursorPos : -1));
/////////////////////////////////////////////////////////////////////////
0:                         sd.orderIndex.setBatch(tx, (info.getSelector() == null ? cursorPos : -1));
/////////////////////////////////////////////////////////////////////////
0:                             sd.orderIndex.setBatch(tx, (info.getSelector() == null ? pos : -1));
commit:3432a75
/////////////////////////////////////////////////////////////////////////
1:         public void acknowledge(ConnectionContext context, String clientId, String subscriptionName,
0:                                 MessageId messageId, MessageAck ack)
commit:5cbb4db
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:                             sd.orderIndex.resetCursorPosition();
0:                             sd.orderIndex.setBatch(tx, (selectorExpression != null? 0 : cursorPos));
/////////////////////////////////////////////////////////////////////////
0:             final SubscriptionInfo info = lookupSubscription(clientId, subscriptionName);
0:             indexLock.writeLock().lock();
0:                         sd.orderIndex.setBatch(tx, (info.getSelector() == null ? cursorPos : 0));
1:                         for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx); iterator
1:                         sd.orderIndex.resetCursorPosition();
0:                 indexLock.writeLock().unlock();
0:             final SubscriptionInfo info = lookupSubscription(clientId, subscriptionName);
/////////////////////////////////////////////////////////////////////////
0:                             sd.orderIndex.setBatch(tx, (info.getSelector() == null ? pos : 0));
commit:9705671
/////////////////////////////////////////////////////////////////////////
0:             indexLock.writeLock().lock();
/////////////////////////////////////////////////////////////////////////
1:                         sd.orderIndex.resetCursorPosition();
0:                         sd.orderIndex.setBatch(tx, cursorPos);
/////////////////////////////////////////////////////////////////////////
0:                             for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx); iterator
/////////////////////////////////////////////////////////////////////////
0:                 indexLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:             indexLock.writeLock().lock();
0:                         sd.orderIndex.resetCursorPosition();
0:                             sd.orderIndex.setBatch(tx, pos);
1:                             moc = sd.orderIndex.cursor;
1:                         } else {
1:                             sd.orderIndex.cursor.sync(moc);
/////////////////////////////////////////////////////////////////////////
0:                             if (LOG.isDebugEnabled()) {
0:                                 LOG.debug("updated moc: " + copy + ", recovered: " + counter);
1:                             }
0:                 indexLock.writeLock().unlock();
commit:e7503f1
/////////////////////////////////////////////////////////////////////////
1:     // when true, message order may be compromised when cache is exhausted if store is out
1:     // or order w.r.t cache
1:     private boolean concurrentStoreAndDispatchTopics = false;
commit:01495a0
/////////////////////////////////////////////////////////////////////////
0:                             sd.orderIndex.resetCursorPosition();
commit:0af6b06
/////////////////////////////////////////////////////////////////////////
0:     private boolean concurrentStoreAndDispatchTransactions = false;
/////////////////////////////////////////////////////////////////////////
1:     
commit:6f7e3fc
/////////////////////////////////////////////////////////////////////////
0:                         StoredDestination sd = getExistingStoredDestination(dest, tx);
0:                         if (sd != null) {
0:                             sd.orderIndex.resetCursorPosition();}
1:                         }
commit:f206a1b
/////////////////////////////////////////////////////////////////////////
0:                             if (listener.recoverMessage(loadMessage(entry.getValue().location))) {
0:                                 counter++;
1:                             }
commit:f2517c0
/////////////////////////////////////////////////////////////////////////
1:     public boolean getForceRecoverIndex() {
1:         return this.forceRecoverIndex;
1:     }
1: 
1:     public void setForceRecoverIndex(boolean forceRecoverIndex) {
1:         this.forceRecoverIndex = forceRecoverIndex;
1:     }
1: 
commit:b1d7a78
/////////////////////////////////////////////////////////////////////////
commit:5763561
/////////////////////////////////////////////////////////////////////////
0:         return storeSize.get();
commit:a6a6a70
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ProducerId;
/////////////////////////////////////////////////////////////////////////
1:             
/////////////////////////////////////////////////////////////////////////
1:     
1:     public long getLastProducerSequenceId(ProducerId id) {
0:         indexLock.readLock().lock();
1:         try {
1:             return metadata.producerSequenceIdTracker.getLastSeqId(id);
0:         } finally {
0:             indexLock.readLock().unlock();
1:         }
1:     }
commit:76f842d
/////////////////////////////////////////////////////////////////////////
1: import java.util.LinkedList;
/////////////////////////////////////////////////////////////////////////
1:     
1:     public static final String PROPERTY_CANCELED_TASK_MOD_METRIC = "org.apache.activemq.store.kahadb.CANCELED_TASK_MOD_METRIC";
0:     public static final int cancelledTaskModMetric = Integer.parseInt(System.getProperty(PROPERTY_CANCELED_TASK_MOD_METRIC, "0"), 10);
1:     public static final String PROPERTY_ASYNC_EXECUTOR_MAX_THREADS = "org.apache.activemq.store.kahadb.ASYNC_EXECUTOR_MAX_THREADS";
0:     private static final int asyncExecutorMaxThreads = Integer.parseInt(System.getProperty(PROPERTY_ASYNC_EXECUTOR_MAX_THREADS, "1"), 10);;
1: 
1:     protected final List<Map<AsyncJobKey, StoreTask>> asyncQueueMaps = new LinkedList<Map<AsyncJobKey, StoreTask>>();
1:     protected final List<Map<AsyncJobKey, StoreTask>> asyncTopicMaps = new LinkedList<Map<AsyncJobKey, StoreTask>>();
/////////////////////////////////////////////////////////////////////////
0:         this.queueExecutor = new ThreadPoolExecutor(1, asyncExecutorMaxThreads, 0L, TimeUnit.MILLISECONDS, asyncQueueJobQueue,
/////////////////////////////////////////////////////////////////////////
0:         this.topicExecutor = new ThreadPoolExecutor(1, asyncExecutorMaxThreads, 0L, TimeUnit.MILLISECONDS, asyncTopicJobQueue,
/////////////////////////////////////////////////////////////////////////
1:         synchronized (this.asyncQueueMaps) {
1:             for (Map<AsyncJobKey, StoreTask> m : asyncQueueMaps) {
1:                 synchronized (m) {
1:                     for (StoreTask task : m.values()) {
1:                         task.cancel();
1:                     }
1:                 }
1:             this.asyncQueueMaps.clear();
1:         synchronized (this.asyncTopicMaps) {
1:             for (Map<AsyncJobKey, StoreTask> m : asyncTopicMaps) {
1:                 synchronized (m) {
1:                     for (StoreTask task : m.values()) {
1:                         task.cancel();
1:                     }
1:                 }
1:             this.asyncTopicMaps.clear();
/////////////////////////////////////////////////////////////////////////
1:         synchronized (store.asyncTaskMap) {
1:             task = (StoreQueueTask) store.asyncTaskMap.remove(new AsyncJobKey(id, store.getDestination()));
1:         synchronized (store.asyncTaskMap) {
1:             store.asyncTaskMap.put(new AsyncJobKey(task.getMessage().getMessageId(), store.getDestination()), task);
1:     protected StoreTopicTask removeTopicTask(KahaDBTopicMessageStore store, MessageId id) {
1:         synchronized (store.asyncTaskMap) {
1:             task = (StoreTopicTask) store.asyncTaskMap.remove(new AsyncJobKey(id, store.getDestination()));
1:     protected void addTopicTask(KahaDBTopicMessageStore store, StoreTopicTask task) throws IOException {
1:         synchronized (store.asyncTaskMap) {
1:             store.asyncTaskMap.put(new AsyncJobKey(task.getMessage().getMessageId(), store.getDestination()), task);
/////////////////////////////////////////////////////////////////////////
1:         protected final Map<AsyncJobKey, StoreTask> asyncTaskMap = new HashMap<AsyncJobKey, StoreTask>();
1:         
1:         double doneTasks, canceledTasks = 0;
/////////////////////////////////////////////////////////////////////////
1:                 synchronized (asyncTaskMap) {
1:                     task = (StoreQueueTask) asyncTaskMap.get(key);
/////////////////////////////////////////////////////////////////////////
1:                         synchronized (asyncTaskMap) {
1:                             asyncTaskMap.remove(key);
/////////////////////////////////////////////////////////////////////////
0:             asyncTopicMaps.add(asyncTaskMap);
/////////////////////////////////////////////////////////////////////////
1:                 synchronized (asyncTaskMap) {
1:                     task = (StoreTopicTask) asyncTaskMap.get(key);
1:                             synchronized (asyncTaskMap) {
1:                                 asyncTaskMap.remove(key);
/////////////////////////////////////////////////////////////////////////
1:     
0:     interface StoreTask {
1:         public boolean cancel();
1:     }
1:     
1:     class StoreQueueTask implements Runnable, StoreTask {
/////////////////////////////////////////////////////////////////////////
1:             this.store.doneTasks++;
1:                 } else if (cancelledTaskModMetric > 0 && this.store.canceledTasks++ % cancelledTaskModMetric == 0) {
0:                     System.err.println(this.store.dest.getName() + " cancelled: " +  (this.store.canceledTasks/this.store.doneTasks) * 100);
1:                     this.store.canceledTasks = this.store.doneTasks = 0;
/////////////////////////////////////////////////////////////////////////
1:             this.store.doneTasks++;
/////////////////////////////////////////////////////////////////////////
0:                 } else if (cancelledTaskModMetric > 0 && this.store.canceledTasks++ % cancelledTaskModMetric == 0) {
0:                     System.err.println(this.store.dest.getName() + " cancelled: " +  (this.store.canceledTasks/this.store.doneTasks) * 100);
1:                     this.store.canceledTasks = this.store.doneTasks = 0;
commit:e85dda9
/////////////////////////////////////////////////////////////////////////
1:         if (this.globalQueueSemaphore != null) {
1:             this.globalQueueSemaphore.tryAcquire(this.maxAsyncJobs, 60, TimeUnit.SECONDS);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (this.globalTopicSemaphore != null) {
1:             this.globalTopicSemaphore.tryAcquire(this.maxAsyncJobs, 60, TimeUnit.SECONDS);
1:         }
commit:33f4190
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0:     private static final Log LOG = LogFactory.getLog(KahaDBStore.class);
0:     protected final Map<AsyncJobKey, StoreQueueTask> asyncQueueMap = new HashMap<AsyncJobKey, StoreQueueTask>();
/////////////////////////////////////////////////////////////////////////
1:  
1:     
/////////////////////////////////////////////////////////////////////////
0:     protected StoreQueueTask removeQueueTask(ActiveMQDestination activeMQDestination, MessageId id) {
0:         StoreQueueTask task = this.asyncQueueMap.remove(new AsyncJobKey(id, activeMQDestination));
/////////////////////////////////////////////////////////////////////////
0:     protected void addQueueTask(ActiveMQDestination activeMQDestination, StoreQueueTask task) throws IOException {
0:         this.asyncQueueMap.put(new AsyncJobKey(task.getMessage().getMessageId(), activeMQDestination), task);
/////////////////////////////////////////////////////////////////////////
0:                 addQueueTask(destination, result);
/////////////////////////////////////////////////////////////////////////
0:                 StoreQueueTask task = removeQueueTask(destination, ack.getLastMessageId());
1:                         try {
1:                             task.future.get();
1:                         } catch (InterruptedException e) {
1:                             throw new InterruptedIOException(e.toString());
1:                         } catch (Exception ignored) {
1:                             LOG.debug("removeAsync: cannot cancel, waiting for add resulted in ex", ignored);
1:                         }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     static class AsyncJobKey {
1:         MessageId id;
1:         ActiveMQDestination destination;
1:         
1:         AsyncJobKey(MessageId id, ActiveMQDestination destination) {
1:             this.id = id;
0:             this.destination = destination;
1:         }
1:         
1:         @Override
1:         public boolean equals(Object obj) {
1:             if (obj == this) {
1:                 return true;
1:             }
0:             return obj instanceof AsyncJobKey &&
0:                 id.equals(((AsyncJobKey)obj).id) &&
0:                 destination.equals(((AsyncJobKey)obj).destination);
1:         }
1: 
1:         @Override
1:         public int hashCode() {
1:             return id.hashCode() + destination.hashCode();
1:         }
1: 
1:         public String toString() {
1:             return destination.getPhysicalName() + "-" + id; 
1:         }
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:                 return this.future.cancel(false);
/////////////////////////////////////////////////////////////////////////
0:                     removeQueueTask(this.store.getDestination(), this.message.getMessageId());
commit:e1389a6
/////////////////////////////////////////////////////////////////////////
0:             public void commit(TransactionId txid, boolean wasPrepared, Runnable done) throws IOException {
0:                 store(new KahaCommitCommand().setTransactionInfo(createTransactionInfo(txid)), true, done);
0:                 store(new KahaPrepareCommand().setTransactionInfo(createTransactionInfo(txid)), true, null);
0:                 store(new KahaRollbackCommand().setTransactionInfo(createTransactionInfo(txid)), false, null);
/////////////////////////////////////////////////////////////////////////
0:             store(command, isEnableJournalDiskSyncs() && message.isResponseRequired(), null);
/////////////////////////////////////////////////////////////////////////
0:             store(command, isEnableJournalDiskSyncs() && ack.isResponseRequired(), null);
0:             store(command, true, null);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             store(command, false, null);
/////////////////////////////////////////////////////////////////////////
0:             store(command, isEnableJournalDiskSyncs() && true, null);
/////////////////////////////////////////////////////////////////////////
0:             store(command, isEnableJournalDiskSyncs() && true, null);
commit:591e55f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.kahadb.MessageDatabase.StoredDestination;
/////////////////////////////////////////////////////////////////////////
0:                             if (!isEmptyTopic(entry, tx)) {
0:                                 rc.add(convert(entry.getKey()));
1:                             }
0: 
0:                     private boolean isEmptyTopic(Entry<String, StoredDestination> entry, Transaction tx) throws IOException {
0:                         boolean isEmptyTopic = false;
0:                         ActiveMQDestination dest = convert(entry.getKey());
0:                         if (dest.isTopic()) {
0:                             StoredDestination loadedStore = getStoredDestination(convert(dest), tx);
0:                             if (loadedStore.ackPositions.isEmpty()) {
0:                                 isEmptyTopic = true;
1:                             }
1:                         }
0:                         return isEmptyTopic;
1:                     }
commit:19bfd9d
/////////////////////////////////////////////////////////////////////////
0:                             sd.subscriptionCursors.put(subscriptionKey, entry.getKey() + 1);
commit:356c39d
/////////////////////////////////////////////////////////////////////////
commit:9bb4682
/////////////////////////////////////////////////////////////////////////
0:         
1:         @Override
0:         public void setBatch(MessageId messageId) {
1:         }
0: 
author:Robert Davies
-------------------------------------------------------------------------------
commit:8e61f51
/////////////////////////////////////////////////////////////////////////
0: import java.util.Set;
0: import java.util.concurrent.BlockingQueue;
0: import java.util.concurrent.ExecutorService;
0: import java.util.concurrent.Future;
0: import java.util.concurrent.FutureTask;
0: import java.util.concurrent.LinkedBlockingQueue;
0: import java.util.concurrent.Semaphore;
0: import java.util.concurrent.ThreadFactory;
0: import java.util.concurrent.ThreadPoolExecutor;
0: import java.util.concurrent.TimeUnit;
0: 
0: import org.apache.activemq.command.*;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.kahadb.data.KahaDestination.DestinationType;
0: import org.apache.kahadb.journal.Journal;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
0:             PROPERTY_ASYNC_EXECUTOR_MAX_THREADS, "1"), 10);
/////////////////////////////////////////////////////////////////////////
0:      * @param concurrentStoreAndDispatch the concurrentStoreAndDispatch to set
/////////////////////////////////////////////////////////////////////////
0:      * @param concurrentStoreAndDispatch the concurrentStoreAndDispatch to set
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:      * @param maxAsyncJobs the maxAsyncJobs to set
/////////////////////////////////////////////////////////////////////////
0:             public Thread newThread(Runnable runnable) {
0:                 Thread thread = new Thread(runnable, "ConcurrentQueueStoreAndDispatch");
0:                 thread.setDaemon(true);
0:                 return thread;
1:             }
0:         });
0:             public Thread newThread(Runnable runnable) {
0:                 Thread thread = new Thread(runnable, "ConcurrentTopicStoreAndDispatch");
0:                 thread.setDaemon(true);
0:                 return thread;
1:             }
0:         });
/////////////////////////////////////////////////////////////////////////
0:         private final Journal journal;
0:         public KahaDBMessageStore(ActiveMQDestination destination) throws IOException {
0:             this.journal = getJournalManager().getJournal(destination);
/////////////////////////////////////////////////////////////////////////
0:             store(journal, command, isEnableJournalDiskSyncs() && message.isResponseRequired(), null, null);
0: 
/////////////////////////////////////////////////////////////////////////
0:             store(journal, command, isEnableJournalDiskSyncs() && ack.isResponseRequired(), null, null);
0:             store(journal, command, true, null, null);
/////////////////////////////////////////////////////////////////////////
0:             } finally {
0:             return loadMessage(journal, location);
/////////////////////////////////////////////////////////////////////////
1:                                     .hasNext(); ) {
0:                 } finally {
/////////////////////////////////////////////////////////////////////////
0:             } finally {
/////////////////////////////////////////////////////////////////////////
0:                                 .hasNext(); ) {
0:                             Message msg = loadMessage(journal, entry.getValue().location);
0:             } finally {
0: 
/////////////////////////////////////////////////////////////////////////
0:                             Message msg = loadMessage(journal, entry.getValue().location);
/////////////////////////////////////////////////////////////////////////
0:             } finally {
/////////////////////////////////////////////////////////////////////////
0:                             sd.orderIndex.resetCursorPosition();
1:                     }
0:                 });
0:                 LOG.error("Failed to reset batching", e);
/////////////////////////////////////////////////////////////////////////
0: 
0:                     pageFile.tx().execute(new Transaction.Closure<IOException>() {
/////////////////////////////////////////////////////////////////////////
0:                 } finally {
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:         public Journal getJournal() {
0:             return this.journal;
1:         }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:             store(getJournal(), command, false, null, null);
/////////////////////////////////////////////////////////////////////////
0:             store(getJournal(), command, isEnableJournalDiskSyncs() && true, null, null);
/////////////////////////////////////////////////////////////////////////
0:             store(getJournal(), command, isEnableJournalDiskSyncs() && true, null, null);
/////////////////////////////////////////////////////////////////////////
0:                                 .hasNext(); ) {
/////////////////////////////////////////////////////////////////////////
0:             } finally {
/////////////////////////////////////////////////////////////////////////
0:             } finally {
/////////////////////////////////////////////////////////////////////////
0:                                      sd.ackPositions.iterator(tx, cursorPos.lastAckedSequence); iterator.hasNext(); ) {
/////////////////////////////////////////////////////////////////////////
0:             } finally {
/////////////////////////////////////////////////////////////////////////
0:                                 .hasNext(); ) {
0:                             listener.recoverMessage(loadMessage(getJournal(), entry.getValue().location));
0:             } finally {
0:                                         final MessageRecoveryListener listener) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:                                 .hasNext(); ) {
0:                             if (listener.recoverMessage(loadMessage(getJournal(), entry.getValue().location))) {
/////////////////////////////////////////////////////////////////////////
0:             } finally {
/////////////////////////////////////////////////////////////////////////
0:                 } finally {
/////////////////////////////////////////////////////////////////////////
0:      *
0:      * @param destination Destination to forget
/////////////////////////////////////////////////////////////////////////
0:      *
0:      * @param destination Destination to forget
/////////////////////////////////////////////////////////////////////////
0:                                 .hasNext(); ) {
/////////////////////////////////////////////////////////////////////////
0:             } finally {
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0:     Message loadMessage(Journal journal, Location location) throws IOException {
0:         KahaAddMessageCommand addMessage = (KahaAddMessageCommand) load(journal, location);
/////////////////////////////////////////////////////////////////////////
0:             case ActiveMQDestination.QUEUE_TYPE:
0:                 rc.setType(DestinationType.QUEUE);
0:                 return rc;
0:             case ActiveMQDestination.TOPIC_TYPE:
0:                 rc.setType(DestinationType.TOPIC);
0:                 return rc;
0:             case ActiveMQDestination.TEMP_QUEUE_TYPE:
0:                 rc.setType(DestinationType.TEMP_QUEUE);
0:                 return rc;
0:             case ActiveMQDestination.TEMP_TOPIC_TYPE:
0:                 rc.setType(DestinationType.TEMP_TOPIC);
0:                 return rc;
0:             default:
0:                 return null;
/////////////////////////////////////////////////////////////////////////
0:             case QUEUE:
0:                 return new ActiveMQQueue(name);
0:             case TOPIC:
0:                 return new ActiveMQTopic(name);
0:             case TEMP_QUEUE:
0:                 return new ActiveMQTempQueue(name);
0:             case TEMP_TOPIC:
0:                 return new ActiveMQTempTopic(name);
0:             default:
0:                 throw new IllegalArgumentException("Not in the valid destination format");
/////////////////////////////////////////////////////////////////////////
0: 
0:                               int subscriptionCount) {
/////////////////////////////////////////////////////////////////////////
0:          *
/////////////////////////////////////////////////////////////////////////
0:                 ((StoreTask) runnable).releaseLocks();
commit:cba0468
/////////////////////////////////////////////////////////////////////////
1:     final WireFormat wireFormat = new OpenWireFormat();
/////////////////////////////////////////////////////////////////////////
1:             command.setPriority(message.getPriority());
1:             command.setPrioritySupported(isPrioritizedMessages());
/////////////////////////////////////////////////////////////////////////
0:                         sd.orderIndex.resetCursorPosition();
0:                             Message msg = loadMessage(entry.getValue().location);
1:                             listener.recoverMessage(msg);
/////////////////////////////////////////////////////////////////////////
0:         
/////////////////////////////////////////////////////////////////////////
0:                         for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx); iterator
0:                             Message msg = loadMessage(entry.getValue().location);
0:                             //System.err.println("RECOVER " + msg.getMessageId().getProducerSequenceId());
1:                             listener.recoverMessage(msg);
1:                         sd.orderIndex.stoppedIterating();
/////////////////////////////////////////////////////////////////////////
1:             try {
1:                 pageFile.tx().execute(new Transaction.Closure<Exception>() {
0:                     public void execute(Transaction tx) throws Exception {
0:                 StoredDestination sd = getStoredDestination(dest, tx);
0:                 sd.orderIndex.resetCursorPosition();}
0:                     });
0:             } catch (Exception e) {
0:                 LOG.error("Failed to reset batching",e);
1:             }
/////////////////////////////////////////////////////////////////////////
0:                
0:                         pageFile.tx().execute(new Transaction.Closure<IOException>() {
0:                         public void execute(Transaction tx) throws IOException {
0:                             Long location = sd.messageIdIndex.get(tx, key);
0:                             if (location != null) {
0:                                 sd.orderIndex.setBatch(tx, location);
1:                             }
0:                 
/////////////////////////////////////////////////////////////////////////
0:                         MessageOrderCursor moc = new MessageOrderCursor(cursorPos + 1);
/////////////////////////////////////////////////////////////////////////
1:                             for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx, moc); iterator
/////////////////////////////////////////////////////////////////////////
0:                         MessageOrderCursor moc = new MessageOrderCursor(cursorPos + 1);
0:                         for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx, moc); iterator
/////////////////////////////////////////////////////////////////////////
1:                         MessageOrderCursor moc = sd.subscriptionCursors.get(subscriptionKey);
1:                         if (moc == null) {
0:                             long pos = sd.subscriptionAcks.get(tx, subscriptionKey);
0:                             moc = new MessageOrderCursor(pos+1);
0:                         for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx, moc); iterator
/////////////////////////////////////////////////////////////////////////
1:                             MessageOrderCursor copy = sd.orderIndex.cursor.copy();
0:                             copy.increment();
1:                             sd.subscriptionCursors.put(subscriptionKey, copy);
commit:b47da80
/////////////////////////////////////////////////////////////////////////
0:             indexLock.readLock().lock();
1:             try {
/////////////////////////////////////////////////////////////////////////
0:             }finally {
0:                 indexLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:                 indexLock.readLock().lock();
1:                 try {
/////////////////////////////////////////////////////////////////////////
0:                 }finally {
0:                     indexLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:             indexLock.readLock().lock();
1:             try {
/////////////////////////////////////////////////////////////////////////
0:             }finally {
0:                 indexLock.readLock().unlock();
0:             indexLock.readLock().lock();
1:             try {
/////////////////////////////////////////////////////////////////////////
0:             }finally {
0:                 indexLock.readLock().unlock();
0:             indexLock.readLock().lock();
1:             try {
/////////////////////////////////////////////////////////////////////////
0:             }finally {
0:                 indexLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:                 indexLock.readLock().lock();
1:                 try {
0:                 }finally {
0:                     indexLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:             indexLock.readLock().lock();
1:             try {
/////////////////////////////////////////////////////////////////////////
0:             }finally {
0:                 indexLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:             indexLock.readLock().lock();
1:             try {
/////////////////////////////////////////////////////////////////////////
0:             }finally {
0:                 indexLock.readLock().unlock();
0:             indexLock.readLock().lock();
1:             try {
/////////////////////////////////////////////////////////////////////////
0:             }finally {
0:                 indexLock.readLock().unlock();
0:             indexLock.readLock().lock();
0:             try {
/////////////////////////////////////////////////////////////////////////
0:             }finally {
0:                 indexLock.readLock().unlock();
0:             indexLock.readLock().lock();
0:             try {
/////////////////////////////////////////////////////////////////////////
0:             }finally {
0:                 indexLock.readLock().unlock();
0:                 indexLock.writeLock().lock();
0:                 try {
0:                 }finally {
0:                     indexLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
0:             indexLock.readLock().lock();
0:             try {
/////////////////////////////////////////////////////////////////////////
0:             }finally {
0:                 indexLock.readLock().unlock();
commit:179bd54
/////////////////////////////////////////////////////////////////////////
0: public class KahaDBStore extends MessageDatabase implements PersistenceAdapter {
0: 
1:     public static final int cancelledTaskModMetric = Integer.parseInt(System.getProperty(
1:             PROPERTY_CANCELED_TASK_MOD_METRIC, "0"), 10);
1:     private static final int asyncExecutorMaxThreads = Integer.parseInt(System.getProperty(
0:             PROPERTY_ASYNC_EXECUTOR_MAX_THREADS, "1"), 10);;
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:      * @param concurrentStoreAndDispatchTransactions
0:      *            the concurrentStoreAndDispatchTransactions to set
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         this.queueExecutor = new ThreadPoolExecutor(1, asyncExecutorMaxThreads, 0L, TimeUnit.MILLISECONDS,
0:                 asyncQueueJobQueue, new ThreadFactory() {
0:         this.topicExecutor = new ThreadPoolExecutor(1, asyncExecutorMaxThreads, 0L, TimeUnit.MILLISECONDS,
0:                 asyncTopicJobQueue, new ThreadFactory() {
/////////////////////////////////////////////////////////////////////////
1:         // drain down async jobs
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:                             for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx, cursorPos); iterator
0:                                     .hasNext();) {
0:                                 if (selectorExpression != null) {
0:                                     MessageEvaluationContext ctx = new MessageEvaluationContext();
0:                                     ctx.setMessageReference(loadMessage(entry.getValue().location));
0:                                     if (selectorExpression.matches(ctx)) {
0:                                         counter++;
1:                                     }
/////////////////////////////////////////////////////////////////////////
0:         synchronized (inflightTransactions) {
0:             ArrayList<Operation> tx = inflightTransactions.get(txid);
0:             if (tx != null) {
0:                 rc.setPreviousEntry(convert(tx.get(tx.size() - 1).location));
1:             }
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
1:                     System.err.println(this.store.dest.getName() + " cancelled: "
1:                             + (this.store.canceledTasks / this.store.doneTasks) * 100);
/////////////////////////////////////////////////////////////////////////
0: 
1:                     System.err.println(this.store.dest.getName() + " cancelled: "
1:                             + (this.store.canceledTasks / this.store.doneTasks) * 100);
commit:caea2f2
/////////////////////////////////////////////////////////////////////////
0:         if (!isStarted()) {
commit:e703088
/////////////////////////////////////////////////////////////////////////
0:     
0:     
0: 
/////////////////////////////////////////////////////////////////////////
0:         //drain down async jobs
1:         LOG.info("Stopping async queue tasks");
0:         this.globalQueueSemaphore.tryAcquire(this.maxAsyncJobs, 60, TimeUnit.SECONDS);
1:         LOG.info("Stopping async topic tasks");
0:         this.globalTopicSemaphore.tryAcquire(this.maxAsyncJobs, 60, TimeUnit.SECONDS);
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("Stopped KahaDB");
commit:7a5abeb
/////////////////////////////////////////////////////////////////////////
0:     private boolean concurrentStoreAndDispatchTransactions = true;
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
0:      * @return the concurrentStoreAndDispatchTransactions
1:      */
1:     public boolean isConcurrentStoreAndDispatchTransactions() {
1:         return this.concurrentStoreAndDispatchTransactions;
1:     }
0: 
1:     /**
0:      * @param concurrentStoreAndDispatchTransactions the concurrentStoreAndDispatchTransactions to set
1:      */
0:     public void setConcurrentStoreAndDispatchTransactions(boolean concurrentStoreAndDispatchTransactions) {
0:         this.concurrentStoreAndDispatchTransactions = concurrentStoreAndDispatchTransactions;
1:     }
commit:27262c8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: public class KahaDBStore extends MessageDatabase implements PersistenceAdapter{
0:     static final Log LOG = LogFactory.getLog(KahaDBStore.class);
0:     protected final Map<AsyncJobKey, StoreTopicTask> asyncTopicMap = new HashMap<AsyncJobKey, StoreTopicTask>();
1:     Semaphore globalQueueSemaphore;
1:     Semaphore globalTopicSemaphore;
1:     private final KahaDBTransactionStore transactionStore;
0: 
1:         this.transactionStore = new KahaDBTransactionStore(this);
0: 
/////////////////////////////////////////////////////////////////////////
1:         this.globalQueueSemaphore = new Semaphore(getMaxAsyncJobs());
1:         this.globalTopicSemaphore = new Semaphore(getMaxAsyncJobs());
/////////////////////////////////////////////////////////////////////////
0:         synchronized (this.asyncQueueMap) {
0:             for (StoreQueueTask task : this.asyncQueueMap.values()) {
0:                 task.cancel();
1:             }
0:             this.asyncQueueMap.clear();
0:         synchronized (this.asyncTopicMap) {
0:             for (StoreTopicTask task : this.asyncTopicMap.values()) {
0:                 task.cancel();
1:             }
0:             this.asyncTopicMap.clear();
1:         }
1:         if (this.globalQueueSemaphore != null) {
1:             this.globalQueueSemaphore.drainPermits();
1:         }
1:         if (this.globalTopicSemaphore != null) {
1:             this.globalTopicSemaphore.drainPermits();
/////////////////////////////////////////////////////////////////////////
1:     protected StoreQueueTask removeQueueTask(KahaDBMessageStore store, MessageId id) {
1:         StoreQueueTask task = null;
0:         synchronized (this.asyncQueueMap) {
0:             task = this.asyncQueueMap.remove(new AsyncJobKey(id, store.getDestination()));
1:     protected void addQueueTask(KahaDBMessageStore store, StoreQueueTask task) throws IOException {
0:         synchronized (this.asyncQueueMap) {
0:             this.asyncQueueMap.put(new AsyncJobKey(task.getMessage().getMessageId(), store.getDestination()), task);
0:     protected StoreTopicTask removeTopicTask(KahaDBMessageStore store, MessageId id) {
1:         StoreTopicTask task = null;
0:         synchronized (this.asyncTopicMap) {
0:             task = this.asyncTopicMap.remove(new AsyncJobKey(id, store.getDestination()));
0:     protected void addTopicTask(KahaDBMessageStore store, StoreTopicTask task) throws IOException {
0:         synchronized (this.asyncTopicMap) {
0:             this.asyncTopicMap.put(new AsyncJobKey(task.getMessage().getMessageId(), store.getDestination()), task);
1:         return this.transactionStore;
1:         private final int maxAsyncJobs;
1:         private final Semaphore localDestinationSemaphore;
1:             this.maxAsyncJobs = getMaxAsyncJobs();
1:             this.localDestinationSemaphore = new Semaphore(this.maxAsyncJobs);
/////////////////////////////////////////////////////////////////////////
1:                 result.aquireLocks();
0:                 addQueueTask(this, result);
/////////////////////////////////////////////////////////////////////////
1:                 AsyncJobKey key = new AsyncJobKey(ack.getLastMessageId(), getDestination());
1:                 StoreQueueTask task = null;
0:                 synchronized (asyncQueueMap) {
0:                     task = asyncQueueMap.get(key);
1:                 }
0: 
/////////////////////////////////////////////////////////////////////////
0:                     } else {
0:                         synchronized (asyncQueueMap) {
0:                             asyncQueueMap.remove(key);
1:                         }
/////////////////////////////////////////////////////////////////////////
0:             store(command, isEnableJournalDiskSyncs() && message.isResponseRequired(), null, null);
/////////////////////////////////////////////////////////////////////////
0:             store(command, isEnableJournalDiskSyncs() && ack.isResponseRequired(), null, null);
0:             store(command, true, null, null);
/////////////////////////////////////////////////////////////////////////
0:             try {
0:                 lockAsyncJobQueue();
0:                 synchronized (indexMutex) {
0:                     return pageFile.tx().execute(new Transaction.CallableClosure<Integer, IOException>() {
0:                         public Integer execute(Transaction tx) throws IOException {
0:                             // Iterate through all index entries to get a count
0:                             // of
1:                             // messages in the destination.
0:                             StoredDestination sd = getStoredDestination(dest, tx);
0:                             int rc = 0;
0:                             for (Iterator<Entry<Location, Long>> iterator = sd.locationIndex.iterator(tx); iterator
0:                                     .hasNext();) {
0:                                 iterator.next();
0:                                 rc++;
1:                             }
0:                             return rc;
0:                     });
1:                 }
0:             } finally {
0:                 unlockAsyncJobQueue();
/////////////////////////////////////////////////////////////////////////
0:                                 .hasNext()
0:                                 && listener.hasSpace();) {
0:                             if (counter >= maxReturned || listener.hasSpace() == false) {
/////////////////////////////////////////////////////////////////////////
0:             try {
0:                 final String key = identity.toString();
0:                 lockAsyncJobQueue();
1:                 // Hopefully one day the page file supports concurrent read
1:                 // operations... but for now we must
0:                 // externally synchronize...
0:                 Long location;
0:                 synchronized (indexMutex) {
0:                     location = pageFile.tx().execute(new Transaction.CallableClosure<Long, IOException>() {
0:                         public Long execute(Transaction tx) throws IOException {
0:                             StoredDestination sd = getStoredDestination(dest, tx);
0:                             return sd.messageIdIndex.get(tx, key);
1:                         }
0:                     });
1:                 }
0:                 if (location != null) {
0:                     cursorPos = location + 1;
1:                 }
0:             } finally {
0:                 unlockAsyncJobQueue();
/////////////////////////////////////////////////////////////////////////
1:         protected void lockAsyncJobQueue() {
0:             try {
0:                 this.localDestinationSemaphore.tryAcquire(this.maxAsyncJobs, 60, TimeUnit.SECONDS);
0:             } catch (Exception e) {
1:                 LOG.error("Failed to lock async jobs for " + this.destination, e);
1:             }
1:         }
0: 
1:         protected void unlockAsyncJobQueue() {
1:             this.localDestinationSemaphore.release(this.maxAsyncJobs);
1:         }
0: 
1:         protected void acquireLocalAsyncLock() {
0:             try {
1:                 this.localDestinationSemaphore.acquire();
1:             } catch (InterruptedException e) {
1:                 LOG.error("Failed to aquire async lock for " + this.destination, e);
1:             }
1:         }
0: 
1:         protected void releaseLocalAsyncLock() {
1:             this.localDestinationSemaphore.release();
1:         }
0: 
/////////////////////////////////////////////////////////////////////////
1:                 result.aquireLocks();
1:                 addTopicTask(this, result);
/////////////////////////////////////////////////////////////////////////
1:                 AsyncJobKey key = new AsyncJobKey(messageId, getDestination());
1:                 StoreTopicTask task = null;
0:                 synchronized (asyncTopicMap) {
0:                     task = asyncTopicMap.get(key);
0:                 }
1:                         removeTopicTask(this, messageId);
1:                         if (task.cancel()) {
0:                             synchronized (asyncTopicMap) {
0:                                 asyncTopicMap.remove(key);
0:                             }
0:                         }
/////////////////////////////////////////////////////////////////////////
0:             store(command, false, null, null);
/////////////////////////////////////////////////////////////////////////
0:             store(command, isEnableJournalDiskSyncs() && true, null, null);
/////////////////////////////////////////////////////////////////////////
0:             store(command, isEnableJournalDiskSyncs() && true, null, null);
/////////////////////////////////////////////////////////////////////////
0:                             if (counter >= maxReturned || listener.hasSpace() == false) {
/////////////////////////////////////////////////////////////////////////
0:         return this.transactionStore.proxy(new KahaDBMessageStore(destination));
0:         return this.transactionStore.proxy(new KahaDBTopicMessageStore(destination));
/////////////////////////////////////////////////////////////////////////
0: 
0: 
1:             return obj instanceof AsyncJobKey && id.equals(((AsyncJobKey) obj).id)
1:                     && destination.equals(((AsyncJobKey) obj).destination);
/////////////////////////////////////////////////////////////////////////
0:         @Override
0:             return destination.getPhysicalName() + "-" + id;
0: 
1:         protected final KahaDBMessageStore store;
1:         protected final AtomicBoolean locked = new AtomicBoolean();
1:         public StoreQueueTask(KahaDBMessageStore store, ConnectionContext context, Message message) {
/////////////////////////////////////////////////////////////////////////
0:             releaseLocks();
0:         void aquireLocks() {
1:             if (this.locked.compareAndSet(false, true)) {
0:                 try {
1:                     globalQueueSemaphore.acquire();
1:                     store.acquireLocalAsyncLock();
1:                     message.incrementReferenceCount();
1:                 } catch (InterruptedException e) {
1:                     LOG.warn("Failed to aquire lock", e);
0:                 }
0:             }
0: 
0:         }
0: 
0:         void releaseLocks() {
1:             if (this.locked.compareAndSet(true, false)) {
1:                 store.releaseLocalAsyncLock();
1:                 globalQueueSemaphore.release();
1:                 message.decrementReferenceCount();
0:             }
0:         }
0: 
1:                     removeQueueTask(this.store, this.message.getMessageId());
0:             } finally {
0:                 releaseLocks();
/////////////////////////////////////////////////////////////////////////
0:         @Override
0:         void aquireLocks() {
1:             if (this.locked.compareAndSet(false, true)) {
0:                 try {
1:                     globalTopicSemaphore.acquire();
1:                     store.acquireLocalAsyncLock();
1:                     message.incrementReferenceCount();
1:                 } catch (InterruptedException e) {
1:                     LOG.warn("Failed to aquire lock", e);
0:                 }
0:             }
0: 
0:         }
0: 
0:         @Override
0:         void releaseLocks() {
1:             if (this.locked.compareAndSet(true, false)) {
1:                 message.decrementReferenceCount();
1:                 store.releaseLocalAsyncLock();
1:                 globalTopicSemaphore.release();
0:             }
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0:                             
1:                     removeTopicTask(this.topicStore, this.message.getMessageId());
0:             } finally {
0:                 releaseLocks();
commit:cd6f4f5
/////////////////////////////////////////////////////////////////////////
0:         if (this.queueSemaphore != null) {
0:             this.queueSemaphore.drainPermits();
0:         }
0:         if (this.topicSemaphore != null) {
0:             this.topicSemaphore.drainPermits();
0:         }
commit:1a5ad28
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.thread.Scheduler;
/////////////////////////////////////////////////////////////////////////
0:     private Scheduler scheduler;
/////////////////////////////////////////////////////////////////////////
1:         super.doStart();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
commit:b09ed03
/////////////////////////////////////////////////////////////////////////
0:                     removeTopicTask(this.message.getMessageId());
commit:ea84378
/////////////////////////////////////////////////////////////////////////
1: import java.io.InterruptedIOException;
1: import java.util.HashMap;
1: import java.util.List;
0: import java.util.concurrent.ExecutorService;
0: import java.util.concurrent.Future;
0: import java.util.concurrent.FutureTask;
0: import java.util.concurrent.LinkedBlockingQueue;
0: import java.util.concurrent.Semaphore;
0: import java.util.concurrent.ThreadFactory;
0: import java.util.concurrent.ThreadPoolExecutor;
0: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: import java.util.concurrent.atomic.AtomicInteger;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.ServiceStopper;
0:     private static final int MAX_ASYNC_JOBS = 10000;
1:     protected ExecutorService queueExecutor;
1:     protected ExecutorService topicExecutor;
0:     protected final Map<MessageId, StoreQueueTask> asyncQueueMap = new HashMap<MessageId, StoreQueueTask>();
0:     protected final Map<MessageId, StoreTopicTask> asyncTopicMap = new HashMap<MessageId, StoreTopicTask>();
1:     private SystemUsage usageManager;
1:     private LinkedBlockingQueue<Runnable> asyncQueueJobQueue;
1:     private LinkedBlockingQueue<Runnable> asyncTopicJobQueue;
0:     private Semaphore queueSemaphore;
0:     private Semaphore topicSemaphore;
1:     private boolean concurrentStoreAndDispatchQueues = true;
0:     private boolean concurrentStoreAndDispatchTopics = true;
1:     private int maxAsyncJobs = MAX_ASYNC_JOBS;
1:     public KahaDBStore() {
0: 
0:     }
0: 
1:         this.usageManager = usageManager;
0:     }
0: 
1:     public SystemUsage getUsageManager() {
1:         return this.usageManager;
0:     }
0: 
1:     /**
1:      * @return the concurrentStoreAndDispatch
1:      */
1:     public boolean isConcurrentStoreAndDispatchQueues() {
1:         return this.concurrentStoreAndDispatchQueues;
0:     }
0: 
1:     /**
0:      * @param concurrentStoreAndDispatch
0:      *            the concurrentStoreAndDispatch to set
1:      */
1:     public void setConcurrentStoreAndDispatchQueues(boolean concurrentStoreAndDispatch) {
1:         this.concurrentStoreAndDispatchQueues = concurrentStoreAndDispatch;
0:     }
0: 
1:     /**
1:      * @return the concurrentStoreAndDispatch
1:      */
1:     public boolean isConcurrentStoreAndDispatchTopics() {
1:         return this.concurrentStoreAndDispatchTopics;
0:     }
0: 
1:     /**
0:      * @param concurrentStoreAndDispatch
0:      *            the concurrentStoreAndDispatch to set
1:      */
1:     public void setConcurrentStoreAndDispatchTopics(boolean concurrentStoreAndDispatch) {
1:         this.concurrentStoreAndDispatchTopics = concurrentStoreAndDispatch;
0:     }
0: 
1:     /**
1:      * @return the maxAsyncJobs
1:      */
1:     public int getMaxAsyncJobs() {
1:         return this.maxAsyncJobs;
0:     }
1:     /**
0:      * @param maxAsyncJobs
0:      *            the maxAsyncJobs to set
1:      */
1:     public void setMaxAsyncJobs(int maxAsyncJobs) {
1:         this.maxAsyncJobs = maxAsyncJobs;
0:     }
0: 
0:     @Override
0:     public void doStart() throws Exception {
0:         this.queueSemaphore = new Semaphore(getMaxAsyncJobs());
0:         this.topicSemaphore = new Semaphore(getMaxAsyncJobs());
1:         this.asyncQueueJobQueue = new LinkedBlockingQueue<Runnable>(getMaxAsyncJobs());
1:         this.asyncTopicJobQueue = new LinkedBlockingQueue<Runnable>(getMaxAsyncJobs());
0:         this.queueExecutor = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, asyncQueueJobQueue,
0:                 new ThreadFactory() {
0:                     public Thread newThread(Runnable runnable) {
0:                         Thread thread = new Thread(runnable, "ConcurrentQueueStoreAndDispatch");
0:                         thread.setDaemon(true);
0:                         return thread;
0:                     }
0:                 });
0:         this.topicExecutor = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, asyncTopicJobQueue,
0:                 new ThreadFactory() {
0:                     public Thread newThread(Runnable runnable) {
0:                         Thread thread = new Thread(runnable, "ConcurrentTopicStoreAndDispatch");
0:                         thread.setDaemon(true);
0:                         return thread;
0:                     }
0:                 });
0:         super.doStart();
0: 
0:     }
0: 
0:     @Override
1:     public void doStop(ServiceStopper stopper) throws Exception {
0:         this.queueSemaphore.drainPermits();
0:         this.topicSemaphore.drainPermits();
1:         if (this.queueExecutor != null) {
0:             this.queueExecutor.shutdownNow();
0:         }
1:         if (this.topicExecutor != null) {
0:             this.topicExecutor.shutdownNow();
0:         }
1:         super.doStop(stopper);
0:     }
0: 
0:     protected StoreQueueTask removeQueueTask(MessageId id) {
0:         StoreQueueTask task = this.asyncQueueMap.remove(id);
1:         if (task != null) {
0:             task.getMessage().decrementReferenceCount();
0:             this.queueSemaphore.release();
0:         }
1:         return task;
0:     }
0: 
0:     protected void addQueueTask(StoreQueueTask task) throws IOException {
0:         try {
0:             this.queueSemaphore.acquire();
0:         } catch (InterruptedException e) {
0:             throw new InterruptedIOException(e.getMessage());
0:         }
0:         this.asyncQueueMap.put(task.getMessage().getMessageId(), task);
0:         task.getMessage().incrementReferenceCount();
1:         this.queueExecutor.execute(task);
0:     }
0: 
0:     protected StoreTopicTask removeTopicTask(MessageId id) {
0:         StoreTopicTask task = this.asyncTopicMap.remove(id);
1:         if (task != null) {
0:             task.getMessage().decrementReferenceCount();
0:             this.topicSemaphore.release();
0:         }
1:         return task;
0:     }
0: 
0:     protected void addTopicTask(StoreTopicTask task) throws IOException {
0:         try {
0:             this.topicSemaphore.acquire();
0:         } catch (InterruptedException e) {
0:             throw new InterruptedIOException(e.getMessage());
0:         }
0:         this.asyncTopicMap.put(task.getMessage().getMessageId(), task);
0:         task.getMessage().incrementReferenceCount();
1:         this.topicExecutor.execute(task);
0:         return new TransactionStore() {
0: 
/////////////////////////////////////////////////////////////////////////
0:                     XATransactionId xid = (XATransactionId) entry.getKey();
0: 
0:                         if (op.getClass() == AddOpperation.class) {
0:                             AddOpperation addOp = (AddOpperation) op;
0:                             Message msg = (Message) wireFormat.unmarshal(new DataInputStream(addOp.getCommand()
0:                                     .getMessage().newInput()));
0:                             RemoveOpperation rmOp = (RemoveOpperation) op;
0:                             MessageAck ack = (MessageAck) wireFormat.unmarshal(new DataInputStream(rmOp.getCommand()
0:                                     .getAck().newInput()));
0: 
/////////////////////////////////////////////////////////////////////////
1:             this.dest = convert(destination);
/////////////////////////////////////////////////////////////////////////
0:         @Override
0:         public Future<Object> asyncAddQueueMessage(final ConnectionContext context, final Message message)
1:                 throws IOException {
1:             if (isConcurrentStoreAndDispatchQueues()) {
1:                 StoreQueueTask result = new StoreQueueTask(this, context, message);
0:                 addQueueTask(result);
1:                 return result.getFuture();
0:             } else {
1:                 return super.asyncAddQueueMessage(context, message);
0:             }
0:         }
0: 
0:         @Override
1:         public void removeAsyncMessage(ConnectionContext context, MessageAck ack) throws IOException {
1:             if (isConcurrentStoreAndDispatchQueues()) {
0:                 StoreQueueTask task = removeQueueTask(ack.getLastMessageId());
0:                 if (task != null) {
0:                     if (!task.cancel()) {
1:                         removeMessage(context, ack);
0:                     }
0:                 } else {
1:                     removeMessage(context, ack);
0:                 }
0:             } else {
1:                 removeMessage(context, ack);
0:             }
0:         }
0: 
0:             command.setTransactionInfo(createTransactionInfo(message.getTransactionId()));
0: 
0: 
0:             command.setTransactionInfo(createTransactionInfo(ack.getTransactionId()));
/////////////////////////////////////////////////////////////////////////
0: 
0:             // Hopefully one day the page file supports concurrent read
0:             // operations... but for now we must
0:             synchronized (indexMutex) {
0:                 location = pageFile.tx().execute(new Transaction.CallableClosure<Location, IOException>() {
0:                         if (sequence == null) {
1:             if (location == null) {
0: 
0: 
0:             synchronized (indexMutex) {
0:                 return pageFile.tx().execute(new Transaction.CallableClosure<Integer, IOException>() {
1:                         // Iterate through all index entries to get a count of
0:                         // messages in the destination.
0:                         int rc = 0;
0:                         for (Iterator<Entry<Location, Long>> iterator = sd.locationIndex.iterator(tx); iterator
0:                                 .hasNext();) {
/////////////////////////////////////////////////////////////////////////
0: 
0:         @Override
0:             synchronized (indexMutex) {
1:                 return pageFile.tx().execute(new Transaction.CallableClosure<Boolean, IOException>() {
0:                         // Iterate through all index entries to get a count of
0:                         // messages in the destination.
/////////////////////////////////////////////////////////////////////////
0:             synchronized (indexMutex) {
1:                 pageFile.tx().execute(new Transaction.Closure<Exception>() {
0:                         for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx); iterator
0:                                 .hasNext();) {
0:                             listener.recoverMessage(loadMessage(entry.getValue().location));
0:         long cursorPos = 0;
0: 
0:             synchronized (indexMutex) {
1:                 pageFile.tx().execute(new Transaction.Closure<Exception>() {
1:                         Entry<Long, MessageKeys> entry = null;
0:                         for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx, cursorPos); iterator
0:                                 .hasNext();) {
0:                             listener.recoverMessage(loadMessage(entry.getValue().location));
0:                             if (counter >= maxReturned) {
1:                         if (entry != null) {
0:                             cursorPos = entry.getKey() + 1;
/////////////////////////////////////////////////////////////////////////
0:             cursorPos = 0;
0: 
0:             // Hopefully one day the page file supports concurrent read
0:             // operations... but for now we must
0:             synchronized (indexMutex) {
0:                 location = pageFile.tx().execute(new Transaction.CallableClosure<Long, IOException>() {
0:             if (location != null) {
0:                 cursorPos = location + 1;
0: 
/////////////////////////////////////////////////////////////////////////
1:             super.start();
1:             super.stop();
0: 
0: 
1:         private final AtomicInteger subscriptionCount = new AtomicInteger();
1:         public KahaDBTopicMessageStore(ActiveMQTopic destination) throws IOException {
1:             this.subscriptionCount.set(getAllSubscriptions().length);
0: 
0:         @Override
0:         public Future<Object> asyncAddTopicMessage(final ConnectionContext context, final Message message)
1:                 throws IOException {
1:             if (isConcurrentStoreAndDispatchTopics()) {
1:                 StoreTopicTask result = new StoreTopicTask(this, context, message, subscriptionCount.get());
0:                 addTopicTask(result);
0:                 return result.getFuture();
0:             } else {
1:                 return super.asyncAddTopicMessage(context, message);
0:             }
0:         }
0: 
0:         public void acknowledge(ConnectionContext context, String clientId, String subscriptionName, MessageId messageId)
1:                 throws IOException {
0:             String subscriptionKey = subscriptionKey(clientId, subscriptionName);
1:             if (isConcurrentStoreAndDispatchTopics()) {
0:                 StoreTopicTask task = asyncTopicMap.get(messageId);
0:                 if (task != null) {
0: 
1:                     if (task.addSubscriptionKey(subscriptionKey)) {
0:                         removeTopicTask(messageId);
0:                         task.cancel();
0:                     }
0:                 } else {
0:                     doAcknowledge(context, subscriptionKey, messageId);
0:                 }
0:             } else {
0:                 doAcknowledge(context, subscriptionKey, messageId);
0:             }
0:         }
0: 
0:         protected void doAcknowledge(ConnectionContext context, String subscriptionKey, MessageId messageId)
1:                 throws IOException {
0:             command.setSubscriptionKey(subscriptionKey);
1:             String subscriptionKey = subscriptionKey(subscriptionInfo.getClientId(), subscriptionInfo
1:                     .getSubscriptionName());
/////////////////////////////////////////////////////////////////////////
1:             this.subscriptionCount.incrementAndGet();
/////////////////////////////////////////////////////////////////////////
1:             this.subscriptionCount.decrementAndGet();
0: 
0:             synchronized (indexMutex) {
0:                 pageFile.tx().execute(new Transaction.Closure<IOException>() {
1:                         for (Iterator<Entry<String, KahaSubscriptionCommand>> iterator = sd.subscriptions.iterator(tx); iterator
0:                                 .hasNext();) {
1:                             SubscriptionInfo info = (SubscriptionInfo) wireFormat.unmarshal(new DataInputStream(entry
1:                                     .getValue().getSubscriptionInfo().newInput()));
0: 
1:             SubscriptionInfo[] rc = new SubscriptionInfo[subscriptions.size()];
0:             synchronized (indexMutex) {
1:                 return pageFile.tx().execute(new Transaction.CallableClosure<SubscriptionInfo, IOException>() {
1:                         if (command == null) {
1:                         return (SubscriptionInfo) wireFormat.unmarshal(new DataInputStream(command
1:                                 .getSubscriptionInfo().newInput()));
0: 
0:             synchronized (indexMutex) {
0:                 return pageFile.tx().execute(new Transaction.CallableClosure<Integer, IOException>() {
0:                         if (cursorPos == null) {
0: 
0:                         for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx, cursorPos); iterator
0:                                 .hasNext();) {
0:             }
1:         public void recoverSubscription(String clientId, String subscriptionName, final MessageRecoveryListener listener)
1:                 throws Exception {
0:             synchronized (indexMutex) {
1:                 pageFile.tx().execute(new Transaction.Closure<Exception>() {
0: 
0:                         for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx, cursorPos); iterator
0:                                 .hasNext();) {
0:                             listener.recoverMessage(loadMessage(entry.getValue().location));
1:         public void recoverNextMessages(String clientId, String subscriptionName, final int maxReturned,
0:                 final MessageRecoveryListener listener) throws Exception {
0:             synchronized (indexMutex) {
1:                 pageFile.tx().execute(new Transaction.Closure<Exception>() {
0:                         if (cursorPos == null) {
0: 
1:                         Entry<Long, MessageKeys> entry = null;
0:                         for (Iterator<Entry<Long, MessageKeys>> iterator = sd.orderIndex.iterator(tx, cursorPos); iterator
0:                                 .hasNext();) {
0:                             listener.recoverMessage(loadMessage(entry.getValue().location));
0:                             if (counter >= maxReturned) {
0:                         if (entry != null) {
/////////////////////////////////////////////////////////////////////////
0:                 synchronized (indexMutex) {
0:                     pageFile.tx().execute(new Transaction.Closure<IOException>() {
/////////////////////////////////////////////////////////////////////////
1:     String subscriptionKey(String clientId, String subscriptionName) {
1:         return clientId + ":" + subscriptionName;
0: 
/////////////////////////////////////////////////////////////////////////
0:      * 
0:      * @param destination
0:      *            Destination to forget
/////////////////////////////////////////////////////////////////////////
0:      * 
0:      * @param destination
0:      *            Destination to forget
1:         deleteAllMessages = true;
0: 
0:             synchronized (indexMutex) {
0:                 pageFile.tx().execute(new Transaction.Closure<IOException>() {
1:                         for (Iterator<Entry<String, StoredDestination>> iterator = metadata.destinations.iterator(tx); iterator
0:                                 .hasNext();) {
/////////////////////////////////////////////////////////////////////////
0:                     private boolean isEmptyTopic(Entry<String, StoredDestination> entry, Transaction tx)
0:                             throws IOException {
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:         if (!started.get()) {
/////////////////////////////////////////////////////////////////////////
0: 
0: 
1:     // /////////////////////////////////////////////////////////////////
1:     // /////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         KahaAddMessageCommand addMessage = (KahaAddMessageCommand) load(location);
0:         Message msg = (Message) wireFormat.unmarshal(new DataInputStream(addMessage.getMessage().newInput()));
1:     // /////////////////////////////////////////////////////////////////
1:     // /////////////////////////////////////////////////////////////////
0: 
0:         if (txid == null) {
0: 
0:         if (tx != null) {
0:             rc.setPreviousEntry(convert(tx.get(tx.size() - 1).location));
0: 
0:         if (txid.isLocalTransaction()) {
0:             LocalTransactionId t = (LocalTransactionId) txid;
0:             XATransactionId t = (XATransactionId) txid;
/////////////////////////////////////////////////////////////////////////
0: 
0: 
1:         switch (dest.getDestinationType()) {
/////////////////////////////////////////////////////////////////////////
1:         if (p < 0) {
1:         String name = dest.substring(p + 1);
0: 
1:         switch (KahaDestination.DestinationType.valueOf(type)) {
/////////////////////////////////////////////////////////////////////////
0:         default:
0: 
0:     class StoreQueueTask implements Runnable {
1:         protected final Message message;
1:         protected final ConnectionContext context;
0:         protected final MessageStore store;
1:         protected final InnerFutureTask future;
1:         protected final AtomicBoolean done = new AtomicBoolean();
0: 
0:         public StoreQueueTask(MessageStore store, ConnectionContext context, Message message) {
1:             this.store = store;
1:             this.context = context;
1:             this.message = message;
1:             this.future = new InnerFutureTask(this);
0: 
0:         }
0: 
0:         public Future<Object> getFuture() {
1:             return this.future;
0:         }
0: 
1:         public boolean cancel() {
1:             if (this.done.compareAndSet(false, true)) {
0:                 this.future.cancel(false);
0:                 return true;
0:             }
1:             return false;
0:         }
0: 
0:         public void run() {
0:             try {
1:                 if (this.done.compareAndSet(false, true)) {
1:                     this.store.addMessage(context, message);
0:                     removeQueueTask(this.message.getMessageId());
1:                     this.future.complete();
0:                 }
0:             } catch (Exception e) {
0:                 this.future.setException(e);
0:             }
0:         }
0: 
1:         protected Message getMessage() {
1:             return this.message;
0:         }
0: 
0:         private class InnerFutureTask extends FutureTask<Object> {
0: 
1:             public InnerFutureTask(Runnable runnable) {
1:                 super(runnable, null);
0: 
0:             }
0: 
0:             public void setException(final Exception e) {
1:                 super.setException(e);
0:             }
0: 
1:             public void complete() {
1:                 super.set(null);
0:             }
0:         }
0:     }
0: 
1:     class StoreTopicTask extends StoreQueueTask {
1:         private final int subscriptionCount;
1:         private final List<String> subscriptionKeys = new ArrayList<String>(1);
1:         private final KahaDBTopicMessageStore topicStore;
1:         public StoreTopicTask(KahaDBTopicMessageStore store, ConnectionContext context, Message message,
0:                 int subscriptionCount) {
1:             super(store, context, message);
1:             this.topicStore = store;
1:             this.subscriptionCount = subscriptionCount;
0: 
0:         }
0: 
1:         /**
1:          * add a key
0:          * 
0:          * @param key
1:          * @return true if all acknowledgements received
1:          */
1:         public boolean addSubscriptionKey(String key) {
1:             synchronized (this.subscriptionKeys) {
1:                 this.subscriptionKeys.add(key);
0:             }
1:             return this.subscriptionKeys.size() >= this.subscriptionCount;
0:         }
0: 
0:         @Override
0:         public void run() {
0:             try {
1:                 if (this.done.compareAndSet(false, true)) {
1:                     this.topicStore.addMessage(context, message);
1:                     // apply any acks we have
1:                     synchronized (this.subscriptionKeys) {
1:                         for (String key : this.subscriptionKeys) {
0:                             this.topicStore.doAcknowledge(context, key, this.message.getMessageId());
0:                         }
0:                     }
0:                     removeQueueTask(this.message.getMessageId());
1:                     this.future.complete();
0:                 }
0:             } catch (Exception e) {
0:                 this.future.setException(e);
0:             }
0:         }
0:     }
commit:affd91e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private final WireFormat wireFormat = new OpenWireFormat();
/////////////////////////////////////////////////////////////////////////
0:         @Override
/////////////////////////////////////////////////////////////////////////
0:         
1:         public boolean isEmpty() throws IOException {
0:             synchronized(indexMutex) {
0:                 return pageFile.tx().execute(new Transaction.CallableClosure<Boolean, IOException>(){
1:                     public Boolean execute(Transaction tx) throws IOException {
0:                         // Iterate through all index entries to get a count of messages in the destination.
0:                         StoredDestination sd = getStoredDestination(dest, tx);
0:                         boolean result = true;
0:                         for (Iterator<Entry<Location, Long>> iterator = sd.locationIndex.iterator(tx); iterator.hasNext();) {
0:                             iterator.next();
0:                             result = false;
0:                             break;
0:                         }
0:                         return result;
0:                     }
0:                 });
0:             }
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0:         @Override
0:         @Override
0:         @Override
commit:f82530d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activeio.journal.Journal;
/////////////////////////////////////////////////////////////////////////
0: 
commit:30f41b9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.AbstractMessageStore;
/////////////////////////////////////////////////////////////////////////
1:     public class KahaDBMessageStore extends AbstractMessageStore {
1:             super(destination);
author:David Jencks
-------------------------------------------------------------------------------
commit:07b6a38
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
1:      * Cleanup method to remove any state associated with the given destination.
1:      * This method does not stop the message store (it might not be cached).
0:      *
0:      * @param destination Destination to forget
0:      */
1:     public void removeQueueMessageStore(ActiveMQQueue destination) {
0:     }
0: 
0:     /**
1:      * Cleanup method to remove any state associated with the given destination
1:      * This method does not stop the message store (it might not be cached).
0:      *
0:      * @param destination Destination to forget
0:      */
1:     public void removeTopicMessageStore(ActiveMQTopic destination) {
0:     }
0: 
============================================================================