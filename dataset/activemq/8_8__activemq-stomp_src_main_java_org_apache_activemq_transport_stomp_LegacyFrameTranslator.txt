1:fc00993: /**
1:fc00993:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:fc00993:  * contributor license agreements.  See the NOTICE file distributed with
1:fc00993:  * this work for additional information regarding copyright ownership.
1:fc00993:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:fc00993:  * (the "License"); you may not use this file except in compliance with
1:fc00993:  * the License.  You may obtain a copy of the License at
1:fc00993:  *
1:fc00993:  *      http://www.apache.org/licenses/LICENSE-2.0
1:fc00993:  *
1:fc00993:  * Unless required by applicable law or agreed to in writing, software
1:fc00993:  * distributed under the License is distributed on an "AS IS" BASIS,
1:fc00993:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:fc00993:  * See the License for the specific language governing permissions and
1:fc00993:  * limitations under the License.
1:fc00993:  */
1:f8485e3: package org.apache.activemq.transport.stomp;
1:1c26408: 
1:c360c3e: import java.io.DataOutputStream;
1:c360c3e: import java.io.IOException;
1:c360c3e: import java.util.HashMap;
1:c360c3e: import java.util.Map;
1:c360c3e: 
1:c360c3e: import javax.jms.Destination;
1:c360c3e: import javax.jms.JMSException;
1:c360c3e: 
1:74a7a8b: import org.apache.activemq.command.ActiveMQBytesMessage;
1:74a7a8b: import org.apache.activemq.command.ActiveMQDestination;
1:74a7a8b: import org.apache.activemq.command.ActiveMQMessage;
1:74a7a8b: import org.apache.activemq.command.ActiveMQTextMessage;
1:1c26408: import org.apache.activemq.util.ByteArrayOutputStream;
1:1c26408: import org.apache.activemq.util.ByteSequence;
1:c360c3e: import org.slf4j.Logger;
1:c360c3e: import org.slf4j.LoggerFactory;
1:04a6379: 
1:9807ee3: /**
1:f8485e3:  * Implements ActiveMQ 4.0 translations
1:9807ee3:  */
1:f812e34: public class LegacyFrameTranslator implements FrameTranslator {
1:04a6379: 
1:c360c3e:     private static final Logger LOG = LoggerFactory.getLogger(LegacyFrameTranslator.class);
1:c360c3e: 
1:c360c3e:     @Override
1:04a6379:     public ActiveMQMessage convertFrame(ProtocolConverter converter, StompFrame command) throws JMSException, ProtocolException {
1:0885c60:         final Map<?, ?> headers = command.getHeaders();
1:f8485e3:         final ActiveMQMessage msg;
1:c6af867:         /*
1:c6af867:          * To reduce the complexity of this method perhaps a Chain of Responsibility
1:c6af867:          * would be a better implementation
1:c6af867:          */
1:c6af867:         if (headers.containsKey(Stomp.Headers.AMQ_MESSAGE_TYPE)) {
1:c6af867:             String intendedType = (String)headers.get(Stomp.Headers.AMQ_MESSAGE_TYPE);
1:c6af867:             if(intendedType.equalsIgnoreCase("text")){
1:c6af867:                 ActiveMQTextMessage text = new ActiveMQTextMessage();
1:68a8b6d:                 try {
1:0885c60:                     ByteArrayOutputStream bytes = new ByteArrayOutputStream(command.getContent().length + 4);
1:0885c60:                     DataOutputStream data = new DataOutputStream(bytes);
1:0885c60:                     data.writeInt(command.getContent().length);
1:0885c60:                     data.write(command.getContent());
1:0885c60:                     text.setContent(bytes.toByteSequence());
1:6d08aca:                     data.close();
1:f812e34:                 } catch (Throwable e) {
1:c6af867:                     throw new ProtocolException("Text could not bet set: " + e, false, e);
1:c6af867:                 }
1:c6af867:                 msg = text;
1:c6af867:             } else if(intendedType.equalsIgnoreCase("bytes")) {
1:c6af867:                 ActiveMQBytesMessage byteMessage = new ActiveMQBytesMessage();
1:c6af867:                 byteMessage.writeBytes(command.getContent());
1:c6af867:                 msg = byteMessage;
1:f812e34:             } else {
1:c6af867:                 throw new ProtocolException("Unsupported message type '"+intendedType+"'",false);
1:1c26408:             }
1:c6af867:         }else if (headers.containsKey(Stomp.Headers.CONTENT_LENGTH)) {
1:f8485e3:             headers.remove(Stomp.Headers.CONTENT_LENGTH);
1:f8485e3:             ActiveMQBytesMessage bm = new ActiveMQBytesMessage();
1:f8485e3:             bm.writeBytes(command.getContent());
1:f8485e3:             msg = bm;
1:c6af867:         } else {
1:f8485e3:             ActiveMQTextMessage text = new ActiveMQTextMessage();
1:1c26408:             try {
1:0885c60:                 ByteArrayOutputStream bytes = new ByteArrayOutputStream(command.getContent().length + 4);
1:0885c60:                 DataOutputStream data = new DataOutputStream(bytes);
1:0885c60:                 data.writeInt(command.getContent().length);
1:0885c60:                 data.write(command.getContent());
1:0885c60:                 text.setContent(bytes.toByteSequence());
1:6d08aca:                 data.close();
1:c6af867:             } catch (Throwable e) {
1:f8485e3:                 throw new ProtocolException("Text could not bet set: " + e, false, e);
1:9807ee3:             }
1:f8485e3:             msg = text;
1:68a8b6d:         }
1:04a6379:         FrameTranslator.Helper.copyStandardHeadersFromFrameToMessage(converter, command, msg, this);
1:f8485e3:         return msg;
1:c6af867:     }
1:1fdcf59: 
1:c360c3e:     @Override
1:04a6379:     public StompFrame convertMessage(ProtocolConverter converter, ActiveMQMessage message) throws IOException, JMSException {
1:f8485e3:         StompFrame command = new StompFrame();
1:f812e34:         command.setAction(Stomp.Responses.MESSAGE);
1:933eb2f:         Map<String, String> headers = new HashMap<String, String>(25);
1:f8485e3:         command.setHeaders(headers);
1:74a7a8b: 
1:04a6379:         FrameTranslator.Helper.copyStandardHeadersFromMessageToFrame(converter, message, command, this);
1:74a7a8b: 
1:f812e34:         if (message.getDataStructureType() == ActiveMQTextMessage.DATA_STRUCTURE_TYPE) {
1:e426de8: 
1:0885c60:             if (!message.isCompressed() && message.getContent() != null) {
1:0885c60:                 ByteSequence msgContent = message.getContent();
1:0885c60:                 if (msgContent.getLength() > 4) {
1:0885c60:                     byte[] content = new byte[msgContent.getLength() - 4];
1:0885c60:                     System.arraycopy(msgContent.data, 4, content, 0, content.length);
1:0885c60:                     command.setContent(content);
1:0885c60:                 }
1:0885c60:             } else {
1:0885c60:                 ActiveMQTextMessage msg = (ActiveMQTextMessage)message.copy();
1:e426de8:                 String messageText = msg.getText();
1:e426de8:                 if (messageText != null) {
1:e426de8:                     command.setContent(msg.getText().getBytes("UTF-8"));
1:e426de8:                 }
1:0885c60:             }
1:e426de8: 
1:f812e34:         } else if (message.getDataStructureType() == ActiveMQBytesMessage.DATA_STRUCTURE_TYPE) {
1:e426de8: 
1:f812e34:             ActiveMQBytesMessage msg = (ActiveMQBytesMessage)message.copy();
1:f812e34:             msg.setReadOnlyBody(true);
1:f8485e3:             byte[] data = new byte[(int)msg.getBodyLength()];
1:f8485e3:             msg.readBytes(data);
1:0885c60: 
1:0885c60:             headers.put(Stomp.Headers.CONTENT_LENGTH, Integer.toString(data.length));
1:f8485e3:             command.setContent(data);
1:1a33eb6:         }
1:1fdcf59: 
1:f8485e3:         return command;
1:1a33eb6:     }
1:9807ee3: 
1:c360c3e:     @Override
1:04a6379:     public String convertDestination(ProtocolConverter converter, Destination d) {
1:f8485e3:         if (d == null) {
1:f8485e3:             return null;
1:1a33eb6:         }
1:fc00993:         ActiveMQDestination activeMQDestination = (ActiveMQDestination)d;
1:fc00993:         String physicalName = activeMQDestination.getPhysicalName();
1:eb887f1: 
1:04a6379:         String rc = converter.getCreatedTempDestinationName(activeMQDestination);
1:04a6379:         if( rc!=null ) {
1:04a6379:             return rc;
1:04a6379:         }
1:04a6379: 
1:0885c60:         StringBuilder buffer = new StringBuilder();
1:fc00993:         if (activeMQDestination.isQueue()) {
1:fc00993:             if (activeMQDestination.isTemporary()) {
1:04a6379:                 buffer.append("/remote-temp-queue/");
1:f812e34:             } else {
1:1a33eb6:                 buffer.append("/queue/");
1:1a33eb6:             }
1:f812e34:         } else {
1:fc00993:             if (activeMQDestination.isTemporary()) {
1:04a6379:                 buffer.append("/remote-temp-topic/");
1:f812e34:             } else {
1:1a33eb6:                 buffer.append("/topic/");
1:1a33eb6:             }
1:1a33eb6:         }
1:fc00993:         buffer.append(physicalName);
1:f8485e3:         return buffer.toString();
14:f8485e3:     }
1:9807ee3: 
1:c360c3e:     @Override
1:1c26408:     public ActiveMQDestination convertDestination(ProtocolConverter converter, String name, boolean forceFallback) throws ProtocolException {
1:f8485e3:         if (name == null) {
1:f8485e3:             return null;
1:eb887f1:         }
1:eb887f1: 
1:eb887f1:         // in case of space padding by a client we trim for the initial detection, on fallback use
1:eb887f1:         // the un-trimmed value.
1:eb887f1:         String originalName = name;
1:eb887f1:         name = name.trim();
1:c360c3e: 
1:c360c3e:         String[] destinations = name.split(",");
1:c360c3e:         if (destinations == null || destinations.length == 0) {
1:c360c3e:             destinations = new String[] { name };
1:f8485e3:         }
1:c360c3e: 
1:c360c3e:         StringBuilder destinationBuilder = new StringBuilder();
1:c360c3e:         for (int i = 0; i < destinations.length; ++i) {
1:c360c3e:             String destinationName = destinations[i];
1:c360c3e: 
1:c360c3e:             if (destinationName.startsWith("/queue/")) {
1:c360c3e:                 destinationName = destinationName.substring("/queue/".length(), destinationName.length());
1:c360c3e:                 destinationBuilder.append(ActiveMQDestination.QUEUE_QUALIFIED_PREFIX + destinationName);
1:c360c3e:             } else if (destinationName.startsWith("/topic/")) {
1:c360c3e:                 destinationName = destinationName.substring("/topic/".length(), destinationName.length());
1:c360c3e:                 destinationBuilder.append(ActiveMQDestination.TOPIC_QUALIFIED_PREFIX + destinationName);
1:c360c3e:             } else if (destinationName.startsWith("/remote-temp-queue/")) {
1:c360c3e:                 destinationName = destinationName.substring("/remote-temp-queue/".length(), destinationName.length());
1:c360c3e:                 destinationBuilder.append(ActiveMQDestination.TEMP_QUEUE_QUALIFED_PREFIX + destinationName);
1:c360c3e:             } else if (destinationName.startsWith("/remote-temp-topic/")) {
1:c360c3e:                 destinationName = destinationName.substring("/remote-temp-topic/".length(), destinationName.length());
1:c360c3e:                 destinationBuilder.append(ActiveMQDestination.TEMP_TOPIC_QUALIFED_PREFIX + destinationName);
1:c360c3e:             } else if (destinationName.startsWith("/temp-queue/")) {
1:c360c3e:                 ActiveMQDestination converted = converter.createTempDestination(destinationName, false);
1:c360c3e:                 destinationBuilder.append(converted.getQualifiedName());
1:c360c3e:             } else if (destinationName.startsWith("/temp-topic/")) {
1:c360c3e:                 ActiveMQDestination converted = converter.createTempDestination(destinationName, true);
1:c360c3e:                 destinationBuilder.append(converted.getQualifiedName());
1:c360c3e:             } else {
1:c360c3e:                 if (forceFallback) {
1:c360c3e:                     String fallbackName = destinationName;
1:c360c3e:                     if (destinationName.length() == 1) {
1:c360c3e:                         // Use the original non-trimmed name instead
1:c360c3e:                         fallbackName = originalName;
1:c360c3e:                     }
1:c360c3e: 
1:c360c3e:                     try {
1:c360c3e:                         ActiveMQDestination fallback = ActiveMQDestination.getUnresolvableDestinationTransformer().transform(fallbackName);
1:c360c3e:                         if (fallback != null) {
1:c360c3e:                             destinationBuilder.append(fallback.getQualifiedName());
1:c360c3e:                         }
1:c360c3e:                     } catch (JMSException e) {
1:c360c3e:                         throw new ProtocolException("Illegal destination name: [" + fallbackName + "] -- ActiveMQ STOMP destinations "
1:c360c3e:                                 + "must begin with one of: /queue/ /topic/ /temp-queue/ /temp-topic/", false, e);
1:c360c3e:                     }
1:15dc6cc:                 } else {
1:15dc6cc:                     throw new ProtocolException("Illegal destination name: [" + originalName + "] -- ActiveMQ STOMP destinations "
1:15dc6cc:                                                 + "must begin with one of: /queue/ /topic/ /temp-queue/ /temp-topic/");
1:c360c3e:                 }
1:c360c3e:             }
1:c360c3e: 
1:c360c3e:             if (i < destinations.length - 1) {
1:c360c3e:                 destinationBuilder.append(",");
1:c360c3e:             }
1:c360c3e:         }
1:c360c3e: 
1:c360c3e:         LOG.trace("New Composite Destination name: {}", destinationBuilder);
1:c360c3e: 
1:c360c3e:         return ActiveMQDestination.createDestination(destinationBuilder.toString(), ActiveMQDestination.QUEUE_TYPE);
1:68a8b6d:     }
1:f8485e3: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:15dc6cc
/////////////////////////////////////////////////////////////////////////
1:                 } else {
1:                     throw new ProtocolException("Illegal destination name: [" + originalName + "] -- ActiveMQ STOMP destinations "
1:                                                 + "must begin with one of: /queue/ /topic/ /temp-queue/ /temp-topic/");
commit:c360c3e
/////////////////////////////////////////////////////////////////////////
1: import java.io.DataOutputStream;
1: import java.io.IOException;
1: import java.util.HashMap;
1: import java.util.Map;
1: 
1: import javax.jms.Destination;
1: import javax.jms.JMSException;
1: 
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(LegacyFrameTranslator.class);
1: 
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         String[] destinations = name.split(",");
1:         if (destinations == null || destinations.length == 0) {
1:             destinations = new String[] { name };
1: 
1:         StringBuilder destinationBuilder = new StringBuilder();
1:         for (int i = 0; i < destinations.length; ++i) {
1:             String destinationName = destinations[i];
1: 
1:             if (destinationName.startsWith("/queue/")) {
1:                 destinationName = destinationName.substring("/queue/".length(), destinationName.length());
1:                 destinationBuilder.append(ActiveMQDestination.QUEUE_QUALIFIED_PREFIX + destinationName);
1:             } else if (destinationName.startsWith("/topic/")) {
1:                 destinationName = destinationName.substring("/topic/".length(), destinationName.length());
1:                 destinationBuilder.append(ActiveMQDestination.TOPIC_QUALIFIED_PREFIX + destinationName);
1:             } else if (destinationName.startsWith("/remote-temp-queue/")) {
1:                 destinationName = destinationName.substring("/remote-temp-queue/".length(), destinationName.length());
1:                 destinationBuilder.append(ActiveMQDestination.TEMP_QUEUE_QUALIFED_PREFIX + destinationName);
1:             } else if (destinationName.startsWith("/remote-temp-topic/")) {
1:                 destinationName = destinationName.substring("/remote-temp-topic/".length(), destinationName.length());
1:                 destinationBuilder.append(ActiveMQDestination.TEMP_TOPIC_QUALIFED_PREFIX + destinationName);
1:             } else if (destinationName.startsWith("/temp-queue/")) {
1:                 ActiveMQDestination converted = converter.createTempDestination(destinationName, false);
1:                 destinationBuilder.append(converted.getQualifiedName());
1:             } else if (destinationName.startsWith("/temp-topic/")) {
1:                 ActiveMQDestination converted = converter.createTempDestination(destinationName, true);
1:                 destinationBuilder.append(converted.getQualifiedName());
1:             } else {
1:                 if (forceFallback) {
1:                     String fallbackName = destinationName;
1:                     if (destinationName.length() == 1) {
1:                         // Use the original non-trimmed name instead
1:                         fallbackName = originalName;
1:                     }
1: 
1:                     try {
1:                         ActiveMQDestination fallback = ActiveMQDestination.getUnresolvableDestinationTransformer().transform(fallbackName);
1:                         if (fallback != null) {
1:                             destinationBuilder.append(fallback.getQualifiedName());
0:                             continue;
1:                         }
1:                     } catch (JMSException e) {
1:                         throw new ProtocolException("Illegal destination name: [" + fallbackName + "] -- ActiveMQ STOMP destinations "
1:                                 + "must begin with one of: /queue/ /topic/ /temp-queue/ /temp-topic/", false, e);
1:                     }
1:                 }
1: 
0:                 throw new ProtocolException("Illegal destination name: [" + originalName + "] -- ActiveMQ STOMP destinations "
0:                                             + "must begin with one of: /queue/ /topic/ /temp-queue/ /temp-topic/");
1:             }
1: 
1:             if (i < destinations.length - 1) {
1:                 destinationBuilder.append(",");
1:             }
1:         }
1: 
1:         LOG.trace("New Composite Destination name: {}", destinationBuilder);
1: 
1:         return ActiveMQDestination.createDestination(destinationBuilder.toString(), ActiveMQDestination.QUEUE_TYPE);
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:1fdcf59
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.Destination;
0: import javax.jms.JMSException;
0: import java.io.DataOutputStream;
0: import java.io.IOException;
0: import java.util.HashMap;
0: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
commit:1c26408
/////////////////////////////////////////////////////////////////////////
0: import com.thoughtworks.xstream.XStream;
0: import com.thoughtworks.xstream.io.json.JsonHierarchicalStreamDriver;
0: import org.apache.activemq.advisory.AdvisorySupport;
0: import org.apache.activemq.command.*;
1: import org.apache.activemq.util.ByteArrayOutputStream;
1: import org.apache.activemq.util.ByteSequence;
1: 
0: import javax.jms.Destination;
0: import javax.jms.JMSException;
/////////////////////////////////////////////////////////////////////////
1:     public ActiveMQDestination convertDestination(ProtocolConverter converter, String name, boolean forceFallback) throws ProtocolException {
/////////////////////////////////////////////////////////////////////////
0:             if (forceFallback) {
1:                 try {
0:                     ActiveMQDestination fallback = ActiveMQDestination.getUnresolvableDestinationTransformer().transform(name);
0:                     if (fallback != null) {
0:                         return fallback;
1:                     }
0:                 } catch (JMSException e) {
0:                     throw new ProtocolException("Illegal destination name: [" + name + "] -- ActiveMQ STOMP destinations "
0:                             + "must begin with one of: /queue/ /topic/ /temp-queue/ /temp-topic/", false, e);
commit:8ed8dd4
/////////////////////////////////////////////////////////////////////////
0:                                         + "must begin with one of: /queue/ /topic/ /temp-queue/ /temp-topic/");
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:c5cf038
commit:04a6379
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	
1:     public ActiveMQMessage convertFrame(ProtocolConverter converter, StompFrame command) throws JMSException, ProtocolException {
/////////////////////////////////////////////////////////////////////////
1:         FrameTranslator.Helper.copyStandardHeadersFromFrameToMessage(converter, command, msg, this);
1:     public StompFrame convertMessage(ProtocolConverter converter, ActiveMQMessage message) throws IOException, JMSException {
1:         FrameTranslator.Helper.copyStandardHeadersFromMessageToFrame(converter, message, command, this);
/////////////////////////////////////////////////////////////////////////
1:     public String convertDestination(ProtocolConverter converter, Destination d) {
1:         String rc = converter.getCreatedTempDestinationName(activeMQDestination);
1:         if( rc!=null ) {
1:         	return rc;
1:         }
1:         
1:                 buffer.append("/remote-temp-queue/");
1:                 buffer.append("/remote-temp-topic/");
/////////////////////////////////////////////////////////////////////////
0:     public ActiveMQDestination convertDestination(ProtocolConverter converter, String name) throws ProtocolException {
/////////////////////////////////////////////////////////////////////////
0:         } else if (name.startsWith("/remote-temp-queue/")) {
0:             String tName = name.substring("/remote-temp-queue/".length(), name.length());
0:         } else if (name.startsWith("/remote-temp-topic/")) {
0:             String tName = name.substring("/remote-temp-topic/".length(), name.length());
0:         } else if (name.startsWith("/temp-queue/")) {
0:             return converter.createTempQueue(name);
0:         } else if (name.startsWith("/temp-topic/")) {
0:             return converter.createTempTopic(name);
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
1:         Map<String, String> headers = new HashMap<String, String>(25);
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQDestination activeMQDestination = (ActiveMQDestination)d;
1:         String physicalName = activeMQDestination.getPhysicalName();
1:         if (activeMQDestination.isQueue()) {
1:             if (activeMQDestination.isTemporary()) {
1:             if (activeMQDestination.isTemporary()) {
1:         buffer.append(physicalName);
/////////////////////////////////////////////////////////////////////////
0:             String qName = name.substring("/queue/".length(), name.length());
0:             return ActiveMQDestination.createDestination(qName, ActiveMQDestination.QUEUE_TYPE);
0:             String tName = name.substring("/topic/".length(), name.length());
0:             return ActiveMQDestination.createDestination(tName, ActiveMQDestination.TOPIC_TYPE);
0:             String tName = name.substring("/temp-queue/".length(), name.length());
0:             return ActiveMQDestination.createDestination(tName, ActiveMQDestination.TEMP_QUEUE_TYPE);
0:             String tName = name.substring("/temp-topic/".length(), name.length());
0:             return ActiveMQDestination.createDestination(tName, ActiveMQDestination.TEMP_TOPIC_TYPE);
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
0: import java.util.Map;
1: 
0: import javax.jms.Destination;
0: import javax.jms.JMSException;
1: 
1: import org.apache.activemq.command.ActiveMQBytesMessage;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQMessage;
1: import org.apache.activemq.command.ActiveMQTextMessage;
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1: public class LegacyFrameTranslator implements FrameTranslator {
/////////////////////////////////////////////////////////////////////////
1:             } catch (Throwable e) {
/////////////////////////////////////////////////////////////////////////
1:         command.setAction(Stomp.Responses.MESSAGE);
1:         if (message.getDataStructureType() == ActiveMQTextMessage.DATA_STRUCTURE_TYPE) {
1:         } else if (message.getDataStructureType() == ActiveMQBytesMessage.DATA_STRUCTURE_TYPE) {
1:             ActiveMQBytesMessage msg = (ActiveMQBytesMessage)message.copy();
1:             msg.setReadOnlyBody(true);
0:             headers.put(Stomp.Headers.CONTENT_LENGTH, "" + data.length);
/////////////////////////////////////////////////////////////////////////
0:         ActiveMQDestination amq_d = (ActiveMQDestination)d;
1:             } else {
1:         } else {
1:             } else {
/////////////////////////////////////////////////////////////////////////
0:         } else if (name.startsWith("/queue/")) {
0:         } else if (name.startsWith("/topic/")) {
0:         } else if (name.startsWith("/temp-queue/")) {
0:         } else if (name.startsWith("/temp-topic/")) {
1:         } else {
0:             throw new ProtocolException("Illegal destination name: [" + name + "] -- ActiveMQ STOMP destinations "
0:                                         + "must begine with one of: /queue/ /topic/ /temp-queue/ /temp-topic/");
commit:76efc33
/////////////////////////////////////////////////////////////////////////
0:         	msg.setReadOnlyBody(true);
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:6d08aca
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     data.close();
/////////////////////////////////////////////////////////////////////////
1:                 data.close();
commit:eb887f1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         }
1: 
1:         // in case of space padding by a client we trim for the initial detection, on fallback use
1:         // the un-trimmed value.
1:         String originalName = name;
1:         name = name.trim();
1: 
0:         if (name.startsWith("/queue/")) {
/////////////////////////////////////////////////////////////////////////
0:                     ActiveMQDestination fallback = ActiveMQDestination.getUnresolvableDestinationTransformer().transform(originalName);
0:                     throw new ProtocolException("Illegal destination name: [" + originalName + "] -- ActiveMQ STOMP destinations "
0:             throw new ProtocolException("Illegal destination name: [" + originalName + "] -- ActiveMQ STOMP destinations "
commit:e426de8
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.Destination;
0: import javax.jms.JMSException;
1: 
0: import org.apache.activemq.advisory.AdvisorySupport;
0: import org.apache.activemq.command.ActiveMQBytesMessage;
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQMessage;
0: import org.apache.activemq.command.ActiveMQTextMessage;
0: import org.apache.activemq.command.DataStructure;
0: import org.apache.activemq.util.ByteArrayOutputStream;
0: import org.apache.activemq.util.ByteSequence;
1: 
0: import com.thoughtworks.xstream.XStream;
0: import com.thoughtworks.xstream.io.json.JsonHierarchicalStreamDriver;
1: 
/////////////////////////////////////////////////////////////////////////
1:                 String messageText = msg.getText();
1:                 if (messageText != null) {
1:                     command.setContent(msg.getText().getBytes("UTF-8"));
1:                 }
commit:9ff3500
/////////////////////////////////////////////////////////////////////////
0:             return converter.createTempDestination(name, false);
0:             return converter.createTempDestination(name, true);
commit:0885c60
/////////////////////////////////////////////////////////////////////////
0: import java.io.DataOutputStream;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.advisory.AdvisorySupport;
0: import org.apache.activemq.command.ActiveMQBytesMessage;
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQMessage;
0: import org.apache.activemq.command.ActiveMQTextMessage;
0: import org.apache.activemq.command.DataStructure;
0: import org.apache.activemq.util.ByteArrayOutputStream;
0: import org.apache.activemq.util.ByteSequence;
1: 
/////////////////////////////////////////////////////////////////////////
1:         final Map<?, ?> headers = command.getHeaders();
/////////////////////////////////////////////////////////////////////////
0:                     //text.setText(new String(command.getContent(), "UTF-8"));
1:                     ByteArrayOutputStream bytes = new ByteArrayOutputStream(command.getContent().length + 4);
1:                     DataOutputStream data = new DataOutputStream(bytes);
1:                     data.writeInt(command.getContent().length);
1:                     data.write(command.getContent());
1:                     text.setContent(bytes.toByteSequence());
/////////////////////////////////////////////////////////////////////////
0:                 //text.setText(new String(command.getContent(), "UTF-8"));
1:                 ByteArrayOutputStream bytes = new ByteArrayOutputStream(command.getContent().length + 4);
1:                 DataOutputStream data = new DataOutputStream(bytes);
1:                 data.writeInt(command.getContent().length);
1:                 data.write(command.getContent());
1:                 text.setContent(bytes.toByteSequence());
/////////////////////////////////////////////////////////////////////////
1:             if (!message.isCompressed() && message.getContent() != null) {
1:                 ByteSequence msgContent = message.getContent();
1:                 if (msgContent.getLength() > 4) {
1:                     byte[] content = new byte[msgContent.getLength() - 4];
1:                     System.arraycopy(msgContent.data, 4, content, 0, content.length);
1:                     command.setContent(content);
1:                 }
1:             } else {
1:                 ActiveMQTextMessage msg = (ActiveMQTextMessage)message.copy();
0:                 command.setContent(msg.getText().getBytes("UTF-8"));
1:             }
/////////////////////////////////////////////////////////////////////////
1:             headers.put(Stomp.Headers.CONTENT_LENGTH, Integer.toString(data.length));
0:                     converter, message, command, this);
/////////////////////////////////////////////////////////////////////////
0:             return rc;
1:         StringBuilder buffer = new StringBuilder();
commit:9807ee3
/////////////////////////////////////////////////////////////////////////
0: import com.thoughtworks.xstream.XStream;
0: import com.thoughtworks.xstream.io.json.JsonHierarchicalStreamDriver;
0: import org.apache.activemq.advisory.AdvisorySupport;
0: import org.apache.activemq.command.*;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:         } else if (message.getDataStructureType() == ActiveMQMessage.DATA_STRUCTURE_TYPE &&
0:                 AdvisorySupport.ADIVSORY_MESSAGE_TYPE.equals(message.getType())) {
0: 
0:             FrameTranslator.Helper.copyStandardHeadersFromMessageToFrame(
0: 					converter, message, command, this);
0: 
0:             String body = marshallAdvisory(message.getDataStructure());
0:             command.setContent(body.getBytes("UTF-8"));
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:     /**
0:      * Return an Advisory message as a JSON formatted string
0:      * @param ds
0:      * @return
1:      */
0:     protected String marshallAdvisory(final DataStructure ds) {
0:         XStream xstream = new XStream(new JsonHierarchicalStreamDriver());
0:         xstream.setMode(XStream.NO_REFERENCES);
0:         xstream.aliasPackage("", "org.apache.activemq.command");
0:         return xstream.toXML(ds);
1:     }
author:Gary Tully
-------------------------------------------------------------------------------
commit:68a8b6d
/////////////////////////////////////////////////////////////////////////
1:             try {
0:                 ActiveMQDestination fallback = ActiveMQDestination.getUnresolvableDestinationTransformer().transform(name);
0:                 if (fallback != null) {
0:                     return fallback;
1:                 }
0:             } catch (JMSException e) {
0:                  throw new ProtocolException("Illegal destination name: [" + name + "] -- ActiveMQ STOMP destinations "
0:                                         + "must begin with one of: /queue/ /topic/ /temp-queue/ /temp-topic/", false, e);
1:             }
author:Robert Davies
-------------------------------------------------------------------------------
commit:c6af867
/////////////////////////////////////////////////////////////////////////
1:         /*
1:          * To reduce the complexity of this method perhaps a Chain of Responsibility
1:          * would be a better implementation
1:          */
1:         if (headers.containsKey(Stomp.Headers.AMQ_MESSAGE_TYPE)) {
1:             String intendedType = (String)headers.get(Stomp.Headers.AMQ_MESSAGE_TYPE);
1:             if(intendedType.equalsIgnoreCase("text")){
1:                 ActiveMQTextMessage text = new ActiveMQTextMessage();
0:                 try {
0:                     text.setText(new String(command.getContent(), "UTF-8"));
1:                 } catch (Throwable e) {
1:                     throw new ProtocolException("Text could not bet set: " + e, false, e);
1:                 }
1:                 msg = text;
1:             } else if(intendedType.equalsIgnoreCase("bytes")) {
1:                 ActiveMQBytesMessage byteMessage = new ActiveMQBytesMessage();
1:                 byteMessage.writeBytes(command.getContent());
1:                 msg = byteMessage;
1:             } else {
1:                 throw new ProtocolException("Unsupported message type '"+intendedType+"'",false);
1:             }
1:         }else if (headers.containsKey(Stomp.Headers.CONTENT_LENGTH)) {
author:James Strachan
-------------------------------------------------------------------------------
commit:1a33eb6
/////////////////////////////////////////////////////////////////////////
0:             if (amq_d.isTemporary()) {
0:                 buffer.append("/temp-queue/");
1:             }
0:             else {
1:                 buffer.append("/queue/");
1:             }
0:         else {
0:             if (amq_d.isTemporary()) {
0:                 buffer.append("/temp-topic/");
1:             }
0:             else {
1:                 buffer.append("/topic/");
1:             }
/////////////////////////////////////////////////////////////////////////
0:         else if (name.startsWith("/temp-queue/")) {
0:             String t_name = name.substring("/temp-queue/".length(), name.length());
0:             return ActiveMQDestination.createDestination(t_name, ActiveMQDestination.TEMP_QUEUE_TYPE);
1:         }
0:         else if (name.startsWith("/temp-topic/")) {
0:             String t_name = name.substring("/temp-topic/".length(), name.length());
0:             return ActiveMQDestination.createDestination(t_name, ActiveMQDestination.TEMP_TOPIC_TYPE);
1:         }
0:                                         "must begine with one of: /queue/ /topic/ /temp-queue/ /temp-topic/");
author:Brian McCallister
-------------------------------------------------------------------------------
commit:f8485e3
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.transport.stomp;
0: 
0: import org.apache.activemq.command.ActiveMQMessage;
0: import org.apache.activemq.command.ActiveMQBytesMessage;
0: import org.apache.activemq.command.ActiveMQTextMessage;
0: import org.apache.activemq.command.ActiveMQDestination;
0: 
0: import javax.jms.JMSException;
0: import javax.jms.Destination;
0: import java.util.Map;
0: import java.util.HashMap;
0: import java.io.IOException;
0: 
0: /**
1:  * Implements ActiveMQ 4.0 translations
0:  */
0: public class LegacyFrameTranslator implements FrameTranslator
0: {
0:     public ActiveMQMessage convertFrame(StompFrame command) throws JMSException, ProtocolException {
0:         final Map headers = command.getHeaders();
1:         final ActiveMQMessage msg;
0:         if (headers.containsKey(Stomp.Headers.CONTENT_LENGTH)) {
1:             headers.remove(Stomp.Headers.CONTENT_LENGTH);
1:             ActiveMQBytesMessage bm = new ActiveMQBytesMessage();
1:             bm.writeBytes(command.getContent());
1:             msg = bm;
0:         } else {
1:             ActiveMQTextMessage text = new ActiveMQTextMessage();
0:             try {
0:                 text.setText(new String(command.getContent(), "UTF-8"));
1:             }
0:             catch (Throwable e) {
1:                 throw new ProtocolException("Text could not bet set: " + e, false, e);
1:             }
1:             msg = text;
1:         }
0:         FrameTranslator.Helper.copyStandardHeadersFromFrameToMessage(command, msg, this);
1:         return msg;
1:     }
0: 
0:     public StompFrame convertMessage(ActiveMQMessage message) throws IOException, JMSException {
1:         StompFrame command = new StompFrame();
0: 		command.setAction(Stomp.Responses.MESSAGE);
0:         Map headers = new HashMap(25);
1:         command.setHeaders(headers);
0: 
0:         FrameTranslator.Helper.copyStandardHeadersFromMessageToFrame(message, command, this);
0: 
0:         if( message.getDataStructureType() == ActiveMQTextMessage.DATA_STRUCTURE_TYPE ) {
0: 
0:             ActiveMQTextMessage msg = (ActiveMQTextMessage)message.copy();
0:             command.setContent(msg.getText().getBytes("UTF-8"));
0: 
0:         } else if( message.getDataStructureType() == ActiveMQBytesMessage.DATA_STRUCTURE_TYPE ) {
0: 
0:         	ActiveMQBytesMessage msg = (ActiveMQBytesMessage)message.copy();
1:             byte[] data = new byte[(int)msg.getBodyLength()];
1:             msg.readBytes(data);
0: 
0:             headers.put(Stomp.Headers.CONTENT_LENGTH, ""+data.length);
1:             command.setContent(data);
1:         }
1:         return command;
1:     }
0: 
0:     public String convertDestination(Destination d) {
1:         if (d == null) {
1:             return null;
1:         }
0:         ActiveMQDestination amq_d = (ActiveMQDestination) d;
0:         String p_name = amq_d.getPhysicalName();
0: 
0:         StringBuffer buffer = new StringBuffer();
0:         if (amq_d.isQueue()) {
0:             buffer.append("/queue/");
1:         }
0:         if (amq_d.isTopic()) {
0:             buffer.append("/topic/");
1:         }
0:         buffer.append(p_name);
1:         return buffer.toString();
1:     }
0: 
0:     public ActiveMQDestination convertDestination(String name) throws ProtocolException {
1:         if (name == null) {
1:             return null;
1:         }
0:         else if (name.startsWith("/queue/")) {
0:             String q_name = name.substring("/queue/".length(), name.length());
0:             return ActiveMQDestination.createDestination(q_name, ActiveMQDestination.QUEUE_TYPE);
1:         }
0:         else if (name.startsWith("/topic/")) {
0:             String t_name = name.substring("/topic/".length(), name.length());
0:             return ActiveMQDestination.createDestination(t_name, ActiveMQDestination.TOPIC_TYPE);
1:         }
0:         else {
0:             throw new ProtocolException("Illegal destination name: [" + name + "] -- ActiveMQ STOMP destinations " +
0:                                         "must begine with /queue/ or /topic/");
1:         }
1:     }
1: }
============================================================================