1:784ead5: /**
1:784ead5:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:784ead5:  * contributor license agreements.  See the NOTICE file distributed with
1:784ead5:  * this work for additional information regarding copyright ownership.
1:784ead5:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:784ead5:  * (the "License"); you may not use this file except in compliance with
1:784ead5:  * the License.  You may obtain a copy of the License at
1:784ead5:  *
1:784ead5:  *      http://www.apache.org/licenses/LICENSE-2.0
1:784ead5:  *
1:784ead5:  * Unless required by applicable law or agreed to in writing, software
1:784ead5:  * distributed under the License is distributed on an "AS IS" BASIS,
1:784ead5:  * WITHOUT WARRANTIES OR ONDITIONS OF ANY KIND, either express or implied.
1:784ead5:  * See the License for the specific language governing permissions and
1:784ead5:  * limitations under the License.
1:784ead5:  */
1:784ead5: package org.apache.activemq.usecases;
8:784ead5: 
1:4743a20: import static org.junit.Assert.assertTrue;
1:4743a20: import static org.junit.Assert.fail;
1:4743a20: 
1:784ead5: import java.io.File;
1:784ead5: import java.text.SimpleDateFormat;
1:784ead5: import java.util.ArrayList;
1:784ead5: import java.util.Arrays;
1:784ead5: import java.util.Date;
1:784ead5: import java.util.HashSet;
1:2d121f4: import java.util.Vector;
1:784ead5: import java.util.concurrent.ConcurrentLinkedQueue;
1:784ead5: import java.util.concurrent.CopyOnWriteArrayList;
1:784ead5: import java.util.concurrent.locks.ReentrantReadWriteLock;
1:4743a20: 
1:784ead5: import javax.jms.Connection;
1:784ead5: import javax.jms.ConnectionFactory;
1:784ead5: import javax.jms.JMSException;
1:784ead5: import javax.jms.Message;
1:784ead5: import javax.jms.MessageConsumer;
1:784ead5: import javax.jms.MessageProducer;
1:784ead5: import javax.jms.Session;
1:4743a20: 
1:2d121f4: import org.apache.activemq.ActiveMQConnectionFactory;
1:2d121f4: import org.apache.activemq.broker.BrokerFactory;
1:2d121f4: import org.apache.activemq.broker.BrokerService;
1:2d121f4: import org.apache.activemq.command.ActiveMQTopic;
1:b2fca26: import org.apache.activemq.leveldb.LevelDBStore;
1:2d121f4: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1:2d121f4: import org.junit.After;
1:2d121f4: import org.junit.Before;
1:2d121f4: import org.junit.Ignore;
1:2d121f4: import org.junit.Test;
1:2d121f4: import org.slf4j.Logger;
1:2d121f4: import org.slf4j.LoggerFactory;
1:2d121f4: 
1:784ead5: public class DurableSubProcessWithRestartTest {
1:2d121f4:     private static final Logger LOG = LoggerFactory.getLogger(DurableSubProcessWithRestartTest.class);
1:784ead5:     public static final long RUNTIME = 5 * 60 * 1000;
1:2d121f4: 
1:784ead5:     public static final int SERVER_SLEEP = 2 * 1000; // max
1:784ead5:     public static final int CARGO_SIZE = 400; // max
1:784ead5: 
1:784ead5:     public static final int MAX_CLIENTS = 5;
1:2d121f4:     public static final Random CLIENT_LIFETIME = new Random(5 * 1000,
1:2d121f4:             2 * 5 * 1000);
1:2d121f4:     public static final Random CLIENT_ONLINE = new Random(2 * 1000, 2 * 1000);
1:2d121f4:     public static final Random CLIENT_OFFLINE = new Random(10 * 1000, 10 * 1000);
1:784ead5: 
1:784ead5:     public static final Persistence PERSISTENT_ADAPTER = Persistence.KAHADB;
1:2d121f4:     public static final long BROKER_RESTART = 1 * 10 * 1000;
1:784ead5: 
1:784ead5:     public static final boolean ALLOW_SUBSCRIPTION_ABANDONMENT = true;
1:2d121f4:     public static final boolean CHECK_REDELIVERY = true;
1:784ead5: 
1:784ead5:     private BrokerService broker;
1:784ead5:     private ActiveMQTopic topic;
1:784ead5: 
1:784ead5:     private ClientManager clientManager;
1:784ead5:     private Server server;
1:784ead5:     private HouseKeeper houseKeeper;
1:784ead5: 
1:784ead5:     private final ReentrantReadWriteLock processLock = new ReentrantReadWriteLock(
1:784ead5:             true);
1:784ead5:     private int restartCount = 0;
1:2d121f4:     static final Vector<Throwable> exceptions = new Vector<Throwable>();
1:784ead5: 
1:2d121f4:     // this is a nice test but it takes 5mins, may be handy in the future
1:2d121f4:     // resulting bug https://issues.apache.org/jira/browse/AMQ-3190
1:2d121f4:     @Ignore("covered by org.apache.activemq.usecases.DurableSubscriptionOfflineTest.testNoMissOnMatchingSubAfterRestart()") @Test
1:784ead5:     public void testProcess() {
1:784ead5:         try {
1:784ead5:             server.start();
1:784ead5:             clientManager.start();
1:784ead5: 
1:784ead5:             if (ALLOW_SUBSCRIPTION_ABANDONMENT)
1:784ead5:                 houseKeeper.start();
1:784ead5: 
1:4743a20:             long end = System.currentTimeMillis() + RUNTIME;
1:784ead5: 
1:4743a20:             while (true) {
1:4743a20:                 long now = System.currentTimeMillis();
1:4743a20:                 if (now > end)
1:4743a20:                     break;
1:784ead5: 
1:4743a20:                 now = end - now;
1:4743a20:                 now = now < BROKER_RESTART ? now : BROKER_RESTART;
1:4743a20:                 Thread.sleep(now);
1:784ead5: 
1:4743a20:                 restartBroker();
2:784ead5:             }
1:784ead5:         } catch (Throwable e) {
1:784ead5:             exit("ProcessTest.testProcess failed.", e);
1:784ead5:         }
1:784ead5: 
1:784ead5:         processLock.writeLock().lock();
1:2d121f4:         assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
1:2d121f4:         LOG.info("DONE.");
1:784ead5:     }
1:784ead5: 
1:784ead5:     private void restartBroker() throws Exception {
1:2d121f4:         LOG.info("Broker restart: waiting for components.");
1:784ead5: 
1:784ead5:         processLock.writeLock().lock();
1:784ead5:         try {
1:784ead5:             destroyBroker();
1:784ead5:             startBroker(false);
1:784ead5: 
1:784ead5:             restartCount++;
1:2d121f4:             LOG.info("Broker restarted. count: " + restartCount);
1:784ead5:         } finally {
1:784ead5:             processLock.writeLock().unlock();
1:784ead5:         }
1:784ead5:     }
1:784ead5: 
1:784ead5:     /**
1:784ead5:      * Creates batch of messages in a transaction periodically. The last message
1:784ead5:      * in the transaction is always a special message what contains info about
1:784ead5:      * the whole transaction.
1:784ead5:      * <p>
1:784ead5:      * Notifies the clients about the created messages also.
1:784ead5:      */
1:784ead5:     final class Server extends Thread {
1:784ead5: 
1:784ead5:         final String url = "vm://"
1:2d121f4:                 + DurableSubProcessWithRestartTest.getName()
1:784ead5:                 + "?"
1:784ead5:                 + "jms.redeliveryPolicy.maximumRedeliveries=2&jms.redeliveryPolicy.initialRedeliveryDelay=500&"
1:784ead5:                 + "jms.producerWindowSize=20971520&jms.prefetchPolicy.all=100&"
1:784ead5:                 + "jms.copyMessageOnSend=false&jms.disableTimeStampsByDefault=false&"
1:784ead5:                 + "jms.alwaysSyncSend=true&jms.dispatchAsync=false&"
1:784ead5:                 + "jms.watchTopicAdvisories=false&"
1:784ead5:                 + "waitForStart=200&create=false";
1:784ead5:         final ConnectionFactory cf = new ActiveMQConnectionFactory(url);
1:784ead5: 
1:784ead5:         final Object sendMutex = new Object();
1:784ead5:         final String[] cargos = new String[500];
1:784ead5: 
1:784ead5:         int transRover = 0;
1:784ead5:         int messageRover = 0;
1:784ead5: 
1:784ead5:         public Server() {
1:784ead5:             super("Server");
1:784ead5:             setDaemon(true);
1:784ead5:         }
1:784ead5: 
1:784ead5:         @Override
1:784ead5:         public void run() {
1:784ead5:             try {
2:784ead5:                 while (true) {
1:784ead5:                     DurableSubProcessWithRestartTest.sleepRandom(SERVER_SLEEP);
1:784ead5: 
1:784ead5:                     processLock.readLock().lock();
1:784ead5:                     try {
1:784ead5:                         send();
1:784ead5:                     } finally {
1:784ead5:                         processLock.readLock().unlock();
1:784ead5:                     }
1:784ead5:                 }
1:784ead5:             } catch (Throwable e) {
1:784ead5:                 exit("Server.run failed", e);
1:784ead5:             }
1:784ead5:         }
1:784ead5: 
1:784ead5:         public void send() throws JMSException {
1:784ead5:             // do not create new clients now
1:784ead5:             // ToDo: Test this case later.
1:784ead5:             synchronized (sendMutex) {
1:784ead5:                 int trans = ++transRover;
1:784ead5:                 boolean relevantTrans = random(2) > 1;
1:784ead5:                 ClientType clientType = relevantTrans ? ClientType
1:784ead5:                         .randomClientType() : null; // sends this types
1:784ead5:                 int count = random(200);
1:784ead5: 
1:2d121f4:                 LOG.info("Sending Trans[id=" + trans + ", count="
1:784ead5:                         + count + ", clientType=" + clientType + "]");
1:784ead5: 
1:784ead5:                 Connection con = cf.createConnection();
1:784ead5:                 Session sess = con
1:2d121f4:                         .createSession(true, Session.SESSION_TRANSACTED);
1:784ead5:                 MessageProducer prod = sess.createProducer(null);
1:784ead5: 
1:784ead5:                 for (int i = 0; i < count; i++) {
1:784ead5:                     Message message = sess.createMessage();
1:784ead5:                     message.setIntProperty("ID", ++messageRover);
1:784ead5:                     message.setIntProperty("TRANS", trans);
1:784ead5:                     String type = clientType != null ? clientType
1:784ead5:                             .randomMessageType() : ClientType
1:784ead5:                             .randomNonRelevantMessageType();
1:784ead5:                     message.setStringProperty("TYPE", type);
1:784ead5: 
1:784ead5:                     if (CARGO_SIZE > 0)
1:784ead5:                         message.setStringProperty("CARGO",
1:784ead5:                                 getCargo(random(CARGO_SIZE)));
1:784ead5: 
1:784ead5:                     prod.send(topic, message);
1:784ead5:                     clientManager.onServerMessage(message);
1:784ead5:                 }
1:784ead5: 
1:784ead5:                 Message message = sess.createMessage();
1:784ead5:                 message.setIntProperty("ID", ++messageRover);
1:784ead5:                 message.setIntProperty("TRANS", trans);
1:784ead5:                 message.setBooleanProperty("COMMIT", true);
1:784ead5:                 message.setBooleanProperty("RELEVANT", relevantTrans);
1:784ead5:                 prod.send(topic, message);
1:784ead5:                 clientManager.onServerMessage(message);
1:784ead5: 
1:784ead5:                 sess.commit();
1:2d121f4:                 LOG.info("Committed Trans[id=" + trans + ", count="
1:784ead5:                         + count + ", clientType=" + clientType + "], ID=" + messageRover);
1:784ead5: 
1:784ead5:                 sess.close();
1:784ead5:                 con.close();
1:784ead5:             }
1:784ead5:         }
1:784ead5: 
1:784ead5:         private String getCargo(int length) {
1:784ead5:             if (length == 0)
1:784ead5:                 return null;
1:784ead5: 
1:784ead5:             if (length < cargos.length) {
1:784ead5:                 String result = cargos[length];
1:784ead5:                 if (result == null) {
1:784ead5:                     result = getCargoImpl(length);
1:784ead5:                     cargos[length] = result;
1:784ead5:                 }
1:784ead5:                 return result;
1:784ead5:             }
1:784ead5:             return getCargoImpl(length);
1:784ead5:         }
1:784ead5: 
1:784ead5:         private String getCargoImpl(int length) {
1:784ead5:             StringBuilder sb = new StringBuilder(length);
1:784ead5:             for (int i = length; --i >= 0;) {
1:784ead5:                 sb.append('a');
1:784ead5:             }
1:784ead5:             return sb.toString();
1:784ead5:         }
1:784ead5:     }
1:784ead5: 
1:784ead5:     /**
1:784ead5:      * Clients listen on different messages in the topic. The 'TYPE' property
1:784ead5:      * helps the client to select the proper messages.
1:784ead5:      */
1:784ead5:     private enum ClientType {
1:784ead5:         A("a", "b", "c"), B("c", "d", "e"), C("d", "e", "f"), D("g", "h");
1:784ead5: 
1:784ead5:         public final String[] messageTypes;
1:784ead5:         public final HashSet<String> messageTypeSet;
1:784ead5:         public final String selector;
1:784ead5: 
1:784ead5:         ClientType(String... messageTypes) {
1:784ead5:             this.messageTypes = messageTypes;
1:784ead5:             messageTypeSet = new HashSet<String>(Arrays.asList(messageTypes));
1:784ead5: 
1:784ead5:             StringBuilder sb = new StringBuilder("TYPE in (");
1:784ead5:             for (int i = 0; i < messageTypes.length; i++) {
1:784ead5:                 if (i > 0)
1:784ead5:                     sb.append(", ");
1:784ead5:                 sb.append('\'').append(messageTypes[i]).append('\'');
1:784ead5:             }
1:784ead5:             sb.append(')');
1:784ead5:             selector = sb.toString();
1:784ead5:         }
1:784ead5: 
1:784ead5:         public static ClientType randomClientType() {
1:784ead5:             return values()[DurableSubProcessWithRestartTest
1:784ead5:                     .random(values().length - 1)];
1:784ead5:         }
1:784ead5: 
1:784ead5:         public final String randomMessageType() {
1:784ead5:             return messageTypes[DurableSubProcessWithRestartTest
1:784ead5:                     .random(messageTypes.length - 1)];
1:784ead5:         }
1:784ead5: 
1:784ead5:         public static String randomNonRelevantMessageType() {
1:784ead5:             return Integer
1:784ead5:                     .toString(DurableSubProcessWithRestartTest.random(20));
1:784ead5:         }
1:784ead5: 
1:784ead5:         public final boolean isRelevant(String messageType) {
1:784ead5:             return messageTypeSet.contains(messageType);
1:784ead5:         }
1:784ead5: 
1:784ead5:         @Override
1:784ead5:         public final String toString() {
1:784ead5:             return this.name() /* + '[' + selector + ']' */;
1:784ead5:         }
1:784ead5:     }
1:784ead5: 
1:784ead5:     /**
1:784ead5:      * Creates new cliens.
1:784ead5:      */
1:784ead5:     private final class ClientManager extends Thread {
1:784ead5: 
1:784ead5:         private int clientRover = 0;
1:784ead5: 
1:784ead5:         private final CopyOnWriteArrayList<Client> clients = new CopyOnWriteArrayList<Client>();
1:784ead5: 
1:784ead5:         public ClientManager() {
1:784ead5:             super("ClientManager");
1:784ead5:             setDaemon(true);
1:784ead5:         }
1:784ead5: 
1:784ead5:         @Override
1:784ead5:         public void run() {
1:784ead5:             try {
1:784ead5:                 while (true) {
1:784ead5:                     if (clients.size() < MAX_CLIENTS) {
1:784ead5:                         processLock.readLock().lock();
1:784ead5:                         try {
1:784ead5:                             createNewClient();
1:784ead5:                         } finally {
1:784ead5:                             processLock.readLock().unlock();
1:784ead5:                         }
1:784ead5:                     }
1:784ead5: 
1:784ead5:                     int size = clients.size();
1:784ead5:                     sleepRandom(size * 3 * 1000, size * 6 * 1000);
1:784ead5:                 }
1:784ead5:             } catch (Throwable e) {
1:784ead5:                 exit("ClientManager.run failed.", e);
1:784ead5:             }
1:784ead5:         }
1:784ead5: 
1:784ead5:         private void createNewClient() throws JMSException {
1:784ead5:             ClientType type = ClientType.randomClientType();
1:784ead5: 
1:784ead5:             Client client;
1:784ead5:             synchronized (server.sendMutex) {
1:784ead5:                 client = new Client(++clientRover, type, CLIENT_LIFETIME,
1:784ead5:                         CLIENT_ONLINE, CLIENT_OFFLINE);
1:784ead5:                 clients.add(client);
1:784ead5:             }
1:784ead5:             client.start();
1:784ead5: 
1:2d121f4:             LOG.info(client.toString() + " created. " + this);
1:784ead5:         }
1:784ead5: 
1:784ead5:         public void removeClient(Client client) {
1:784ead5:             clients.remove(client);
1:784ead5:         }
1:784ead5: 
1:784ead5:         public void onServerMessage(Message message) throws JMSException {
1:784ead5:             for (Client client : clients) {
1:784ead5:                 client.onServerMessage(message);
1:784ead5:             }
1:784ead5:         }
1:784ead5: 
1:784ead5:         @Override
1:784ead5:         public String toString() {
1:784ead5:             StringBuilder sb = new StringBuilder("ClientManager[count=");
1:784ead5:             sb.append(clients.size());
1:784ead5:             sb.append(", clients=");
1:784ead5:             boolean sep = false;
1:784ead5:             for (Client client : clients) {
1:784ead5:                 if (sep)
1:784ead5:                     sb.append(", ");
1:784ead5:                 else
1:784ead5:                     sep = true;
1:784ead5:                 sb.append(client.toString());
1:784ead5:             }
1:784ead5:             sb.append(']');
1:784ead5:             return sb.toString();
1:784ead5:         }
1:784ead5:     }
1:784ead5: 
1:784ead5:     /**
1:784ead5:      * Consumes massages from a durable subscription. Goes online/offline
1:784ead5:      * periodically. Checks the incoming messages against the sent messages of
1:784ead5:      * the server.
1:784ead5:      */
1:784ead5:     private final class Client extends Thread {
1:784ead5: 
1:784ead5:         String url = "failover:(tcp://localhost:61656?wireFormat.maxInactivityDuration=0)?"
1:784ead5:                 + "jms.watchTopicAdvisories=false&"
1:784ead5:                 + "jms.alwaysSyncSend=true&jms.dispatchAsync=true&"
1:784ead5:                 + "jms.producerWindowSize=20971520&"
1:784ead5:                 + "jms.copyMessageOnSend=false&"
1:4acd132:                 + "initialReconnectDelay=100&maxReconnectDelay=30000&"
1:784ead5:                 + "useExponentialBackOff=true";
1:784ead5:         final ConnectionFactory cf = new ActiveMQConnectionFactory(url);
1:784ead5: 
1:784ead5:         public static final String SUBSCRIPTION_NAME = "subscription";
1:784ead5: 
1:784ead5:         private final int id;
1:784ead5:         private final String conClientId;
1:784ead5: 
1:784ead5:         private final Random lifetime;
1:784ead5:         private final Random online;
1:784ead5:         private final Random offline;
1:784ead5: 
1:784ead5:         private final ClientType clientType;
1:784ead5:         private final String selector;
1:784ead5: 
1:784ead5:         private final ConcurrentLinkedQueue<Message> waitingList = new ConcurrentLinkedQueue<Message>();
1:784ead5:         private final HashSet<Integer> processed = CHECK_REDELIVERY ? new HashSet<Integer>(
1:784ead5:                 10000) : null;
1:784ead5: 
1:784ead5:         public Client(int id, ClientType clientType, Random lifetime,
1:784ead5:                 Random online, Random offline) throws JMSException {
1:784ead5:             super("Client" + id);
1:784ead5:             setDaemon(true);
1:784ead5: 
1:784ead5:             this.id = id;
1:784ead5:             conClientId = "cli" + id;
1:784ead5:             this.clientType = clientType;
1:784ead5:             selector = "(COMMIT = true and RELEVANT = true) or "
1:784ead5:                     + clientType.selector;
1:784ead5: 
1:784ead5:             this.lifetime = lifetime;
1:784ead5:             this.online = online;
1:784ead5:             this.offline = offline;
1:784ead5: 
1:784ead5:             subscribe();
1:784ead5:         }
1:784ead5: 
1:784ead5:         @Override
1:784ead5:         public void run() {
1:784ead5:             long end = System.currentTimeMillis() + lifetime.next();
1:784ead5:             try {
1:784ead5:                 boolean sleep = false;
1:784ead5:                 while (true) {
1:784ead5:                     long max = end - System.currentTimeMillis();
1:784ead5:                     if (max <= 0)
3:784ead5:                         break;
1:784ead5: 
1:784ead5:                     if (sleep)
1:784ead5:                         offline.sleepRandom();
1:784ead5:                     else
1:784ead5:                         sleep = true;
1:784ead5: 
1:784ead5:                     processLock.readLock().lock();
1:784ead5:                     try {
1:784ead5:                         process(online.next());
1:784ead5:                     } finally {
1:784ead5:                         processLock.readLock().unlock();
1:784ead5:                     }
1:784ead5:                 }
1:784ead5: 
1:784ead5:                 if (!ALLOW_SUBSCRIPTION_ABANDONMENT || random(1) > 0)
1:784ead5:                     unsubscribe();
2:784ead5:                 else {
1:2d121f4:                     LOG.info("Client abandon the subscription. "
1:784ead5:                             + this);
1:784ead5: 
1:784ead5:                     // housekeeper should sweep these abandoned subscriptions
1:784ead5:                     houseKeeper.abandonedSubscriptions.add(conClientId);
1:784ead5:                 }
1:784ead5:             } catch (Throwable e) {
1:784ead5:                 exit(toString() + " failed.", e);
1:784ead5:             }
1:784ead5: 
1:784ead5:             clientManager.removeClient(this);
1:2d121f4:             LOG.info(toString() + " DONE.");
1:784ead5:         }
1:784ead5: 
1:784ead5:         private void process(long millis) throws JMSException {
1:784ead5:             long end = System.currentTimeMillis() + millis;
1:784ead5:             long hardEnd = end + 20000; // wait to finish the transaction.
1:784ead5:             boolean inTransaction = false;
1:784ead5:             int transCount = 0;
1:784ead5: 
1:2d121f4:             LOG.info(toString() + " ONLINE.");
1:784ead5:             Connection con = openConnection();
1:784ead5:             Session sess = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:784ead5:             MessageConsumer consumer = sess.createDurableSubscriber(topic,
1:784ead5:                     SUBSCRIPTION_NAME, selector, false);
1:784ead5:             try {
1:784ead5:                 do {
1:784ead5:                     long max = end - System.currentTimeMillis();
1:784ead5:                     if (max <= 0) {
1:784ead5:                         if (!inTransaction)
1:784ead5:                             break;
1:784ead5: 
1:784ead5:                         max = hardEnd - System.currentTimeMillis();
1:784ead5:                         if (max <= 0)
1:784ead5:                             exit("" + this
1:784ead5:                                     + " failed: Transaction is not finished.");
1:784ead5:                     }
1:784ead5: 
1:784ead5:                     Message message = consumer.receive(max);
1:784ead5:                     if (message == null)
1:784ead5:                         continue;
1:784ead5: 
1:784ead5:                     onClientMessage(message);
1:784ead5: 
1:784ead5:                     if (message.propertyExists("COMMIT")) {
1:784ead5:                         message.acknowledge(); // CLIENT_ACKNOWLEDGE
1:784ead5: 
1:2d121f4:                         LOG.info("Received Trans[id="
1:784ead5:                                 + message.getIntProperty("TRANS") + ", count="
1:784ead5:                                 + transCount + "] in " + this + ".");
1:784ead5: 
1:784ead5:                         inTransaction = false;
1:784ead5:                         transCount = 0;
1:784ead5:                     } else {
1:784ead5:                         inTransaction = true;
1:784ead5:                         transCount++;
1:784ead5:                     }
1:784ead5:                 } while (true);
1:784ead5:             } finally {
1:784ead5:                 sess.close();
1:784ead5:                 con.close();
1:784ead5: 
1:2d121f4:                 LOG.info(toString() + " OFFLINE.");
1:784ead5: 
1:784ead5:                 // Check if the messages are in the waiting
1:784ead5:                 // list for long time.
1:784ead5:                 Message topMessage = waitingList.peek();
1:784ead5:                 if (topMessage != null)
1:784ead5:                     checkDeliveryTime(topMessage);
1:784ead5:             }
1:784ead5:         }
1:784ead5: 
1:784ead5:         public void onServerMessage(Message message) throws JMSException {
1:784ead5:             if (Boolean.TRUE.equals(message.getObjectProperty("COMMIT"))) {
1:784ead5:                 if (Boolean.TRUE.equals(message.getObjectProperty("RELEVANT")))
1:784ead5:                     waitingList.add(message);
1:784ead5:             } else {
1:784ead5:                 String messageType = message.getStringProperty("TYPE");
1:784ead5:                 if (clientType.isRelevant(messageType))
1:784ead5:                     waitingList.add(message);
1:784ead5:             }
1:784ead5:         }
1:784ead5: 
1:784ead5:         public void onClientMessage(Message message) {
1:784ead5:             Message serverMessage = waitingList.poll();
1:784ead5:             try {
1:784ead5:                 Integer receivedId = (Integer) message.getObjectProperty("ID");
1:784ead5:                 if (processed != null && processed.contains(receivedId))
1:2d121f4:                     LOG.info("! Message has been processed before. "
1:784ead5:                             + this + " message = " + message);
1:784ead5: 
1:784ead5:                 if (serverMessage == null)
1:784ead5:                     exit(""
1:784ead5:                             + this
1:784ead5:                             + " failed: There is no next server message, but received: "
1:784ead5:                             + message);
1:784ead5: 
1:784ead5:                 Integer serverId = (Integer) serverMessage
1:784ead5:                         .getObjectProperty("ID");
1:784ead5:                 if (receivedId == null || serverId == null)
1:784ead5:                     exit("" + this + " failed: message ID not found.\r\n"
1:784ead5:                             + " received: " + message + "\r\n" + "   server: "
1:784ead5:                             + serverMessage);
1:784ead5: 
1:2d121f4:                 if (!serverId.equals(receivedId)) {
1:2d121f4:                     String detail = processed != null ?
1:2d121f4:                         Arrays.toString(processed.toArray()) + "\n"
1:2d121f4:                         : "";
1:2d121f4:                     exit(detail + this + " failed: Received wrong message.\r\n"
1:784ead5:                             + " received: " + message + "\r\n" + "   server: "
1:784ead5:                             + serverMessage);
1:2d121f4:                 }
1:784ead5: 
1:784ead5:                 checkDeliveryTime(message);
1:784ead5: 
1:784ead5:                 if (processed != null)
1:784ead5:                     processed.add(receivedId);
1:784ead5:             } catch (Throwable e) {
1:784ead5:                 exit("" + this + ".onClientMessage failed.\r\n" + " received: "
1:784ead5:                         + message + "\r\n" + "   server: " + serverMessage, e);
1:784ead5:             }
1:784ead5:         }
1:784ead5: 
1:784ead5:         /**
1:784ead5:          * Checks if the message was not delivered fast enough.
1:784ead5:          */
1:4743a20:         @SuppressWarnings("unused")
1:784ead5:         public void checkDeliveryTime(Message message) throws JMSException {
1:784ead5:             long creation = message.getJMSTimestamp();
1:784ead5:             long min = System.currentTimeMillis() - (offline.max + online.min)
1:784ead5:                     * (BROKER_RESTART > 0 ? 4 : 1);
1:784ead5: 
1:784ead5:             if (false && min > creation) {
1:784ead5:                 SimpleDateFormat df = new SimpleDateFormat("HH:mm:ss.SSS");
1:784ead5:                 exit("" + this + ".checkDeliveryTime failed. Message time: "
1:784ead5:                         + df.format(new Date(creation)) + ", min: "
1:784ead5:                         + df.format(new Date(min)) + "\r\n" + message);
1:784ead5:             }
1:784ead5:         }
1:784ead5: 
1:784ead5:         private Connection openConnection() throws JMSException {
1:784ead5:             Connection con = cf.createConnection();
1:784ead5:             con.setClientID(conClientId);
1:784ead5:             con.start();
1:784ead5:             return con;
1:784ead5:         }
1:784ead5: 
1:784ead5:         private void subscribe() throws JMSException {
1:784ead5:             Connection con = openConnection();
1:784ead5:             Session session = con
1:784ead5:                     .createSession(false, Session.AUTO_ACKNOWLEDGE);
1:784ead5:             session.createDurableSubscriber(topic, SUBSCRIPTION_NAME, selector,
1:784ead5:                     true);
1:784ead5:             session.close();
1:784ead5:             con.close();
1:784ead5:         }
1:784ead5: 
1:784ead5:         private void unsubscribe() throws JMSException {
1:784ead5:             Connection con = openConnection();
1:784ead5:             Session session = con
1:784ead5:                     .createSession(false, Session.AUTO_ACKNOWLEDGE);
1:784ead5:             session.unsubscribe(SUBSCRIPTION_NAME);
1:784ead5:             session.close();
1:784ead5:             con.close();
1:784ead5:         }
1:784ead5: 
1:784ead5:         @Override
1:784ead5:         public String toString() {
1:784ead5:             return "Client[id=" + id + ", type=" + clientType + "]";
1:784ead5:         }
1:784ead5:     }
1:784ead5: 
1:784ead5:     /**
1:784ead5:      * Sweeps out not-used durable subscriptions.
1:784ead5:      */
1:784ead5:     private final class HouseKeeper extends Thread {
1:784ead5: 
1:784ead5:         private HouseKeeper() {
1:784ead5:             super("HouseKeeper");
1:784ead5:             setDaemon(true);
1:784ead5:         }
1:784ead5: 
1:784ead5:         public final CopyOnWriteArrayList<String> abandonedSubscriptions = new CopyOnWriteArrayList<String>();
1:784ead5: 
1:784ead5:         @Override
1:784ead5:         public void run() {
1:784ead5:             while (true) {
1:784ead5:                 try {
1:784ead5:                     Thread.sleep(3 * 60 * 1000);
1:784ead5: 
1:784ead5:                     processLock.readLock().lock();
1:784ead5:                     try {
1:784ead5:                         sweep();
1:784ead5:                     } finally {
1:784ead5:                         processLock.readLock().unlock();
1:784ead5:                     }
1:784ead5:                 } catch (InterruptedException ex) {
1:784ead5:                     break;
1:784ead5:                 } catch (Throwable e) {
1:784ead5:                     Exception log = new Exception("HouseKeeper failed.", e);
2:784ead5:                     log.printStackTrace();
1:784ead5:                 }
1:784ead5:             }
1:784ead5:         }
1:784ead5: 
1:784ead5:         private void sweep() throws Exception {
1:2d121f4:             LOG.info("Housekeeper sweeping.");
1:784ead5: 
1:784ead5:             int closed = 0;
1:784ead5:             ArrayList<String> sweeped = new ArrayList<String>();
1:784ead5:             try {
1:784ead5:                 for (String clientId : abandonedSubscriptions) {
1:2d121f4:                     LOG.info("Sweeping out subscription of "
1:784ead5:                             + clientId + ".");
1:784ead5:                     broker.getAdminView().destroyDurableSubscriber(clientId,
1:784ead5:                             Client.SUBSCRIPTION_NAME);
1:784ead5:                     sweeped.add(clientId);
1:784ead5:                     closed++;
1:784ead5:                 }
1:784ead5:             } catch (Exception ignored) {
1:2d121f4:                 LOG.info("Ex on destroy sub " + ignored);
1:784ead5:             } finally {
1:784ead5:                 abandonedSubscriptions.removeAll(sweeped);
1:784ead5:             }
1:784ead5: 
1:2d121f4:             LOG.info("Housekeeper sweeped out " + closed
1:784ead5:                     + " subscriptions.");
1:784ead5:         }
1:784ead5:     }
1:784ead5: 
1:784ead5:     public static int random(int max) {
1:784ead5:         return (int) (Math.random() * (max + 1));
1:784ead5:     }
1:784ead5: 
1:784ead5:     public static int random(int min, int max) {
1:784ead5:         return random(max - min) + min;
1:784ead5:     }
1:784ead5: 
1:784ead5:     public static void sleepRandom(int maxMillis) throws InterruptedException {
1:784ead5:         Thread.sleep(random(maxMillis));
1:784ead5:     }
1:784ead5: 
1:784ead5:     public static void sleepRandom(int minMillis, int maxMillis)
1:784ead5:             throws InterruptedException {
1:784ead5:         Thread.sleep(random(minMillis, maxMillis));
1:784ead5:     }
1:784ead5: 
1:784ead5:     public static final class Random {
1:784ead5: 
1:784ead5:         final int min;
1:784ead5:         final int max;
1:784ead5: 
1:784ead5:         Random(int min, int max) {
1:784ead5:             this.min = min;
1:784ead5:             this.max = max;
1:784ead5:         }
1:784ead5: 
1:784ead5:         public int next() {
1:784ead5:             return random(min, max);
1:784ead5:         }
1:784ead5: 
1:784ead5:         public void sleepRandom() throws InterruptedException {
1:784ead5:             DurableSubProcessWithRestartTest.sleepRandom(min, max);
1:784ead5:         }
1:784ead5:     }
1:784ead5: 
1:784ead5:     public static void exit(String message) {
1:784ead5:         exit(message, null);
1:784ead5:     }
1:784ead5: 
1:784ead5:     public static void exit(String message, Throwable e) {
1:2d121f4:         Throwable cause = new RuntimeException(message, e);
1:2d121f4:         LOG.error(message, cause);
1:2d121f4:         exceptions.add(cause);
1:2d121f4:         fail(cause.toString());
1:784ead5:     }
1:784ead5: 
1:2d121f4:     @Before
1:2d121f4:     public void setUp() throws Exception {
1:784ead5:         topic = new ActiveMQTopic("TopicT");
1:784ead5:         startBroker();
1:784ead5: 
1:784ead5:         clientManager = new ClientManager();
1:784ead5:         server = new Server();
1:784ead5:         houseKeeper = new HouseKeeper();
1:784ead5: 
1:784ead5:     }
1:784ead5: 
1:2d121f4:     @After
1:2d121f4:     public void tearDown() throws Exception {
1:784ead5:         destroyBroker();
1:784ead5:     }
1:784ead5: 
1:784ead5:     private enum Persistence {
1:b2fca26:         MEMORY, LEVELDB, KAHADB
1:784ead5:     }
1:784ead5: 
1:784ead5:     private void startBroker() throws Exception {
1:784ead5:         startBroker(true);
1:784ead5:     }
1:784ead5: 
1:784ead5:     private void startBroker(boolean deleteAllMessages) throws Exception {
1:784ead5:         if (broker != null)
1:784ead5:             return;
1:784ead5: 
1:784ead5:         broker = BrokerFactory.createBroker("broker:(vm://" + getName() + ")");
1:784ead5:         broker.setBrokerName(getName());
1:2d121f4:         broker.setAdvisorySupport(false);
1:784ead5:         broker.setDeleteAllMessagesOnStartup(deleteAllMessages);
1:784ead5: 
1:784ead5:         switch (PERSISTENT_ADAPTER) {
1:784ead5:         case MEMORY:
1:784ead5:             broker.setPersistent(false);
1:784ead5:             break;
1:784ead5: 
1:b2fca26:         case LEVELDB:
1:b2fca26:             File datadir = new File("activemq-data/" + getName() + "-leveldb");
2:784ead5:             if (deleteAllMessages)
1:b2fca26:                 delete(datadir);
1:784ead5: 
2:784ead5:             broker.setPersistent(true);
1:b2fca26:             LevelDBStore amq = new LevelDBStore();
1:b2fca26:             amq.setDirectory(datadir);
1:784ead5:             broker.setPersistenceAdapter(amq);
1:784ead5:             break;
1:784ead5: 
1:784ead5:         case KAHADB:
1:784ead5:             File kahadbData = new File("activemq-data/" + getName() + "-kahadb");
1:784ead5:             if (deleteAllMessages)
1:784ead5:                 delete(kahadbData);
1:784ead5: 
1:784ead5:             broker.setPersistent(true);
1:784ead5:             KahaDBPersistenceAdapter kahadb = new KahaDBPersistenceAdapter();
1:784ead5:             kahadb.setDirectory(kahadbData);
1:784ead5:             kahadb.setJournalMaxFileLength(5 * 1024 * 1024);
1:784ead5:             broker.setPersistenceAdapter(kahadb);
1:784ead5:             break;
1:784ead5:         }
1:784ead5: 
1:784ead5:         broker.addConnector("tcp://localhost:61656");
1:784ead5: 
1:784ead5:         broker.getSystemUsage().getMemoryUsage().setLimit(256 * 1024 * 1024);
1:784ead5:         broker.getSystemUsage().getTempUsage().setLimit(256 * 1024 * 1024);
1:784ead5:         broker.getSystemUsage().getStoreUsage().setLimit(256 * 1024 * 1024);
1:784ead5: 
1:784ead5:         broker.start();
1:784ead5:     }
1:784ead5: 
1:2d121f4:     protected static String getName() {
1:2d121f4:         return "DurableSubProcessWithRestartTest";
1:784ead5:     }
1:784ead5: 
1:784ead5:     private static boolean delete(File path) {
1:784ead5:         if (path == null)
1:784ead5:             return true;
1:784ead5: 
1:784ead5:         if (path.isDirectory()) {
1:784ead5:             for (File file : path.listFiles()) {
1:784ead5:                 delete(file);
1:784ead5:             }
1:784ead5:         }
1:784ead5:         return path.delete();
1:784ead5:     }
1:784ead5: 
1:784ead5:     private void destroyBroker() throws Exception {
1:784ead5:         if (broker == null)
1:784ead5:             return;
1:784ead5: 
1:784ead5:         broker.stop();
1:784ead5:         broker = null;
1:784ead5:     }
1:784ead5: }
============================================================================
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:b2fca26
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.leveldb.LevelDBStore;
/////////////////////////////////////////////////////////////////////////
1:         MEMORY, LEVELDB, KAHADB
/////////////////////////////////////////////////////////////////////////
1:         case LEVELDB:
1:             File datadir = new File("activemq-data/" + getName() + "-leveldb");
1:                 delete(datadir);
1:             LevelDBStore amq = new LevelDBStore();
1:             amq.setDirectory(datadir);
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:4743a20
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertTrue;
1: import static org.junit.Assert.fail;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             long end = System.currentTimeMillis() + RUNTIME;
1:             while (true) {
1:                 long now = System.currentTimeMillis();
1:                 if (now > end)
1:                     break;
1:                 now = end - now;
1:                 now = now < BROKER_RESTART ? now : BROKER_RESTART;
1:                 Thread.sleep(now);
1:                 restartBroker();
/////////////////////////////////////////////////////////////////////////
1:         @SuppressWarnings("unused")
commit:ef24cc9
author:Gary Tully
-------------------------------------------------------------------------------
commit:4acd132
/////////////////////////////////////////////////////////////////////////
1:                 + "initialReconnectDelay=100&maxReconnectDelay=30000&"
commit:2d121f4
/////////////////////////////////////////////////////////////////////////
1: import java.util.Vector;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.broker.BrokerFactory;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.command.ActiveMQTopic;
0: import org.apache.activemq.store.amq.AMQPersistenceAdapter;
0: import org.apache.activemq.store.kahadaptor.KahaPersistenceAdapter;
1: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Ignore;
1: import org.junit.Test;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: 
0: import static org.junit.Assert.assertTrue;
0: import static org.junit.Assert.fail;
1:     private static final Logger LOG = LoggerFactory.getLogger(DurableSubProcessWithRestartTest.class);
1:     public static final Random CLIENT_LIFETIME = new Random(5 * 1000,
1:             2 * 5 * 1000);
1:     public static final Random CLIENT_ONLINE = new Random(2 * 1000, 2 * 1000);
1:     public static final Random CLIENT_OFFLINE = new Random(10 * 1000, 10 * 1000);
1:     public static final long BROKER_RESTART = 1 * 10 * 1000;
1:     public static final boolean CHECK_REDELIVERY = true;
/////////////////////////////////////////////////////////////////////////
1:     static final Vector<Throwable> exceptions = new Vector<Throwable>();
1:     // this is a nice test but it takes 5mins, may be handy in the future
1:     // resulting bug https://issues.apache.org/jira/browse/AMQ-3190
1:     @Ignore("covered by org.apache.activemq.usecases.DurableSubscriptionOfflineTest.testNoMissOnMatchingSubAfterRestart()") @Test
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
1:         LOG.info("DONE.");
1:         LOG.info("Broker restart: waiting for components.");
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("Broker restarted. count: " + restartCount);
/////////////////////////////////////////////////////////////////////////
1:                 + DurableSubProcessWithRestartTest.getName()
/////////////////////////////////////////////////////////////////////////
1:                 LOG.info("Sending Trans[id=" + trans + ", count="
1:                         .createSession(true, Session.SESSION_TRANSACTED);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.info("Committed Trans[id=" + trans + ", count="
/////////////////////////////////////////////////////////////////////////
1:             LOG.info(client.toString() + " created. " + this);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.info("Client abandon the subscription. "
/////////////////////////////////////////////////////////////////////////
1:             LOG.info(toString() + " DONE.");
/////////////////////////////////////////////////////////////////////////
1:             LOG.info(toString() + " ONLINE.");
/////////////////////////////////////////////////////////////////////////
1:                         LOG.info("Received Trans[id="
/////////////////////////////////////////////////////////////////////////
1:                 LOG.info(toString() + " OFFLINE.");
/////////////////////////////////////////////////////////////////////////
1:                     LOG.info("! Message has been processed before. "
/////////////////////////////////////////////////////////////////////////
1:                 if (!serverId.equals(receivedId)) {
1:                     String detail = processed != null ?
1:                         Arrays.toString(processed.toArray()) + "\n"
1:                         : "";
1:                     exit(detail + this + " failed: Received wrong message.\r\n"
1:                 }
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("Housekeeper sweeping.");
1:                     LOG.info("Sweeping out subscription of "
/////////////////////////////////////////////////////////////////////////
1:                 LOG.info("Ex on destroy sub " + ignored);
1:             LOG.info("Housekeeper sweeped out " + closed
/////////////////////////////////////////////////////////////////////////
1:         Throwable cause = new RuntimeException(message, e);
1:         LOG.error(message, cause);
1:         exceptions.add(cause);
1:         fail(cause.toString());
1:     @Before
1:     public void setUp() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     @After
1:     public void tearDown() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         broker.setAdvisorySupport(false);
/////////////////////////////////////////////////////////////////////////
1:     protected static String getName() {
1:         return "DurableSubProcessWithRestartTest";
commit:784ead5
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR ONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.usecases;
1: 
0: import org.apache.activemq.ActiveMQConnectionFactory;
0: import org.apache.activemq.broker.BrokerFactory;
0: import org.apache.activemq.broker.BrokerService;
0: import org.apache.activemq.command.ActiveMQTopic;
0: import org.apache.activemq.store.amq.AMQPersistenceAdapter;
0: import org.apache.activemq.store.kahadaptor.KahaPersistenceAdapter;
0: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
0: import org.junit.Ignore;
0: import org.junit.Test;
1: 
1: import java.io.File;
1: import java.text.SimpleDateFormat;
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Date;
1: import java.util.HashSet;
1: import java.util.concurrent.ConcurrentLinkedQueue;
1: import java.util.concurrent.CopyOnWriteArrayList;
1: import java.util.concurrent.locks.ReentrantReadWriteLock;
1: 
1: import javax.jms.Connection;
1: import javax.jms.ConnectionFactory;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: 
1: public class DurableSubProcessWithRestartTest {
1: 
1:     public static final long RUNTIME = 5 * 60 * 1000;
1: 
1:     public static final int SERVER_SLEEP = 2 * 1000; // max
1:     public static final int CARGO_SIZE = 400; // max
1: 
1:     public static final int MAX_CLIENTS = 5;
0:     public static final Random CLIENT_LIFETIME = new Random(30 * 1000,
0:             2 * 60 * 1000);
0:     public static final Random CLIENT_ONLINE = new Random(2 * 1000, 15 * 1000);
0:     public static final Random CLIENT_OFFLINE = new Random(1 * 1000, 20 * 1000);
1: 
1:     public static final Persistence PERSISTENT_ADAPTER = Persistence.KAHADB;
0:     public static final long BROKER_RESTART = 1 * 60 * 1000;
1: 
1:     public static final boolean ALLOW_SUBSCRIPTION_ABANDONMENT = true;
0:     public static final boolean CHECK_REDELIVERY = false;
1: 
1:     private BrokerService broker;
1:     private ActiveMQTopic topic;
1: 
1:     private ClientManager clientManager;
1:     private Server server;
1:     private HouseKeeper houseKeeper;
1: 
1:     private final ReentrantReadWriteLock processLock = new ReentrantReadWriteLock(
1:             true);
1:     private int restartCount = 0;
1: 
0:     @Ignore("Needs some more investigation") @Test
1:     public void testProcess() {
1:         try {
1:             server.start();
1:             clientManager.start();
1: 
1:             if (ALLOW_SUBSCRIPTION_ABANDONMENT)
1:                 houseKeeper.start();
1: 
0:             if (BROKER_RESTART <= 0)
0:                 Thread.sleep(RUNTIME);
1:             else {
0:                 long end = System.currentTimeMillis() + RUNTIME;
1: 
1:                 while (true) {
0:                     long now = System.currentTimeMillis();
0:                     if (now > end)
1:                         break;
1: 
0:                     now = end - now;
0:                     now = now < BROKER_RESTART ? now : BROKER_RESTART;
0:                     Thread.sleep(now);
1: 
0:                     restartBroker();
1:                 }
1:             }
1:         } catch (Throwable e) {
1:             exit("ProcessTest.testProcess failed.", e);
1:         }
1: 
1:         processLock.writeLock().lock();
0:         System.out.println("DONE.");
1:     }
1: 
1:     private void restartBroker() throws Exception {
0:         System.out.println("Broker restart: waiting for components.");
1: 
1:         processLock.writeLock().lock();
1:         try {
1:             destroyBroker();
1:             startBroker(false);
1: 
1:             restartCount++;
0:             System.out.println("Broker restarted. count: " + restartCount);
1:         } finally {
1:             processLock.writeLock().unlock();
1:         }
1:     }
1: 
1:     /**
1:      * Creates batch of messages in a transaction periodically. The last message
1:      * in the transaction is always a special message what contains info about
1:      * the whole transaction.
1:      * <p>
1:      * Notifies the clients about the created messages also.
1:      */
1:     final class Server extends Thread {
1: 
1:         final String url = "vm://"
0:                 + getName()
1:                 + "?"
1:                 + "jms.redeliveryPolicy.maximumRedeliveries=2&jms.redeliveryPolicy.initialRedeliveryDelay=500&"
1:                 + "jms.producerWindowSize=20971520&jms.prefetchPolicy.all=100&"
1:                 + "jms.copyMessageOnSend=false&jms.disableTimeStampsByDefault=false&"
1:                 + "jms.alwaysSyncSend=true&jms.dispatchAsync=false&"
1:                 + "jms.watchTopicAdvisories=false&"
1:                 + "waitForStart=200&create=false";
1:         final ConnectionFactory cf = new ActiveMQConnectionFactory(url);
1: 
1:         final Object sendMutex = new Object();
1:         final String[] cargos = new String[500];
1: 
1:         int transRover = 0;
1:         int messageRover = 0;
1: 
1:         public Server() {
1:             super("Server");
1:             setDaemon(true);
1:         }
1: 
1:         @Override
1:         public void run() {
1:             try {
1:                 while (true) {
1:                     DurableSubProcessWithRestartTest.sleepRandom(SERVER_SLEEP);
1: 
1:                     processLock.readLock().lock();
1:                     try {
1:                         send();
1:                     } finally {
1:                         processLock.readLock().unlock();
1:                     }
1:                 }
1:             } catch (Throwable e) {
1:                 exit("Server.run failed", e);
1:             }
1:         }
1: 
1:         public void send() throws JMSException {
1:             // do not create new clients now
1:             // ToDo: Test this case later.
1:             synchronized (sendMutex) {
1:                 int trans = ++transRover;
1:                 boolean relevantTrans = random(2) > 1;
1:                 ClientType clientType = relevantTrans ? ClientType
1:                         .randomClientType() : null; // sends this types
1:                 int count = random(200);
1: 
0:                 System.out.println("Sending Trans[id=" + trans + ", count="
1:                         + count + ", clientType=" + clientType + "]");
1: 
1:                 Connection con = cf.createConnection();
1:                 Session sess = con
0:                         .createSession(true, Session.AUTO_ACKNOWLEDGE);
1:                 MessageProducer prod = sess.createProducer(null);
1: 
1:                 for (int i = 0; i < count; i++) {
1:                     Message message = sess.createMessage();
1:                     message.setIntProperty("ID", ++messageRover);
1:                     message.setIntProperty("TRANS", trans);
1:                     String type = clientType != null ? clientType
1:                             .randomMessageType() : ClientType
1:                             .randomNonRelevantMessageType();
1:                     message.setStringProperty("TYPE", type);
1: 
1:                     if (CARGO_SIZE > 0)
1:                         message.setStringProperty("CARGO",
1:                                 getCargo(random(CARGO_SIZE)));
1: 
1:                     prod.send(topic, message);
1:                     clientManager.onServerMessage(message);
1:                 }
1: 
1:                 Message message = sess.createMessage();
1:                 message.setIntProperty("ID", ++messageRover);
1:                 message.setIntProperty("TRANS", trans);
1:                 message.setBooleanProperty("COMMIT", true);
1:                 message.setBooleanProperty("RELEVANT", relevantTrans);
1:                 prod.send(topic, message);
1:                 clientManager.onServerMessage(message);
1: 
1:                 sess.commit();
0:                 System.out.println("Committed Trans[id=" + trans + ", count="
1:                         + count + ", clientType=" + clientType + "], ID=" + messageRover);
1: 
1:                 sess.close();
1:                 con.close();
1:             }
1:         }
1: 
1:         private String getCargo(int length) {
1:             if (length == 0)
1:                 return null;
1: 
1:             if (length < cargos.length) {
1:                 String result = cargos[length];
1:                 if (result == null) {
1:                     result = getCargoImpl(length);
1:                     cargos[length] = result;
1:                 }
1:                 return result;
1:             }
1:             return getCargoImpl(length);
1:         }
1: 
1:         private String getCargoImpl(int length) {
1:             StringBuilder sb = new StringBuilder(length);
1:             for (int i = length; --i >= 0;) {
1:                 sb.append('a');
1:             }
1:             return sb.toString();
1:         }
1:     }
1: 
1:     /**
1:      * Clients listen on different messages in the topic. The 'TYPE' property
1:      * helps the client to select the proper messages.
1:      */
1:     private enum ClientType {
1:         A("a", "b", "c"), B("c", "d", "e"), C("d", "e", "f"), D("g", "h");
1: 
1:         public final String[] messageTypes;
1:         public final HashSet<String> messageTypeSet;
1:         public final String selector;
1: 
1:         ClientType(String... messageTypes) {
1:             this.messageTypes = messageTypes;
1:             messageTypeSet = new HashSet<String>(Arrays.asList(messageTypes));
1: 
1:             StringBuilder sb = new StringBuilder("TYPE in (");
1:             for (int i = 0; i < messageTypes.length; i++) {
1:                 if (i > 0)
1:                     sb.append(", ");
1:                 sb.append('\'').append(messageTypes[i]).append('\'');
1:             }
1:             sb.append(')');
1:             selector = sb.toString();
1:         }
1: 
1:         public static ClientType randomClientType() {
1:             return values()[DurableSubProcessWithRestartTest
1:                     .random(values().length - 1)];
1:         }
1: 
1:         public final String randomMessageType() {
1:             return messageTypes[DurableSubProcessWithRestartTest
1:                     .random(messageTypes.length - 1)];
1:         }
1: 
1:         public static String randomNonRelevantMessageType() {
1:             return Integer
1:                     .toString(DurableSubProcessWithRestartTest.random(20));
1:         }
1: 
1:         public final boolean isRelevant(String messageType) {
1:             return messageTypeSet.contains(messageType);
1:         }
1: 
1:         @Override
1:         public final String toString() {
1:             return this.name() /* + '[' + selector + ']' */;
1:         }
1:     }
1: 
1:     /**
1:      * Creates new cliens.
1:      */
1:     private final class ClientManager extends Thread {
1: 
1:         private int clientRover = 0;
1: 
1:         private final CopyOnWriteArrayList<Client> clients = new CopyOnWriteArrayList<Client>();
1: 
1:         public ClientManager() {
1:             super("ClientManager");
1:             setDaemon(true);
1:         }
1: 
1:         @Override
1:         public void run() {
1:             try {
1:                 while (true) {
1:                     if (clients.size() < MAX_CLIENTS) {
1:                         processLock.readLock().lock();
1:                         try {
1:                             createNewClient();
1:                         } finally {
1:                             processLock.readLock().unlock();
1:                         }
1:                     }
1: 
1:                     int size = clients.size();
1:                     sleepRandom(size * 3 * 1000, size * 6 * 1000);
1:                 }
1:             } catch (Throwable e) {
1:                 exit("ClientManager.run failed.", e);
1:             }
1:         }
1: 
1:         private void createNewClient() throws JMSException {
1:             ClientType type = ClientType.randomClientType();
1: 
1:             Client client;
1:             synchronized (server.sendMutex) {
1:                 client = new Client(++clientRover, type, CLIENT_LIFETIME,
1:                         CLIENT_ONLINE, CLIENT_OFFLINE);
1:                 clients.add(client);
1:             }
1:             client.start();
1: 
0:             System.out.println(client.toString() + " created. " + this);
1:         }
1: 
1:         public void removeClient(Client client) {
1:             clients.remove(client);
1:         }
1: 
1:         public void onServerMessage(Message message) throws JMSException {
1:             for (Client client : clients) {
1:                 client.onServerMessage(message);
1:             }
1:         }
1: 
1:         @Override
1:         public String toString() {
1:             StringBuilder sb = new StringBuilder("ClientManager[count=");
1:             sb.append(clients.size());
1:             sb.append(", clients=");
1:             boolean sep = false;
1:             for (Client client : clients) {
1:                 if (sep)
1:                     sb.append(", ");
1:                 else
1:                     sep = true;
1:                 sb.append(client.toString());
1:             }
1:             sb.append(']');
1:             return sb.toString();
1:         }
1:     }
1: 
1:     /**
1:      * Consumes massages from a durable subscription. Goes online/offline
1:      * periodically. Checks the incoming messages against the sent messages of
1:      * the server.
1:      */
1:     private final class Client extends Thread {
1: 
1:         String url = "failover:(tcp://localhost:61656?wireFormat.maxInactivityDuration=0)?"
1:                 + "jms.watchTopicAdvisories=false&"
1:                 + "jms.alwaysSyncSend=true&jms.dispatchAsync=true&"
1:                 + "jms.producerWindowSize=20971520&"
1:                 + "jms.copyMessageOnSend=false&"
0:                 + "initialReconnectDelay=100&maxReconnectDelay=30000&maxReconnectAttempts=0&"
1:                 + "useExponentialBackOff=true";
1:         final ConnectionFactory cf = new ActiveMQConnectionFactory(url);
1: 
1:         public static final String SUBSCRIPTION_NAME = "subscription";
1: 
1:         private final int id;
1:         private final String conClientId;
1: 
1:         private final Random lifetime;
1:         private final Random online;
1:         private final Random offline;
1: 
1:         private final ClientType clientType;
1:         private final String selector;
1: 
1:         private final ConcurrentLinkedQueue<Message> waitingList = new ConcurrentLinkedQueue<Message>();
1:         private final HashSet<Integer> processed = CHECK_REDELIVERY ? new HashSet<Integer>(
1:                 10000) : null;
1: 
1:         public Client(int id, ClientType clientType, Random lifetime,
1:                 Random online, Random offline) throws JMSException {
1:             super("Client" + id);
1:             setDaemon(true);
1: 
1:             this.id = id;
1:             conClientId = "cli" + id;
1:             this.clientType = clientType;
1:             selector = "(COMMIT = true and RELEVANT = true) or "
1:                     + clientType.selector;
1: 
1:             this.lifetime = lifetime;
1:             this.online = online;
1:             this.offline = offline;
1: 
1:             subscribe();
1:         }
1: 
1:         @Override
1:         public void run() {
1:             long end = System.currentTimeMillis() + lifetime.next();
1:             try {
1:                 boolean sleep = false;
1:                 while (true) {
1:                     long max = end - System.currentTimeMillis();
1:                     if (max <= 0)
1:                         break;
1: 
1:                     if (sleep)
1:                         offline.sleepRandom();
1:                     else
1:                         sleep = true;
1: 
1:                     processLock.readLock().lock();
1:                     try {
1:                         process(online.next());
1:                     } finally {
1:                         processLock.readLock().unlock();
1:                     }
1:                 }
1: 
1:                 if (!ALLOW_SUBSCRIPTION_ABANDONMENT || random(1) > 0)
1:                     unsubscribe();
1:                 else {
0:                     System.out.println("Client abandon the subscription. "
1:                             + this);
1: 
1:                     // housekeeper should sweep these abandoned subscriptions
1:                     houseKeeper.abandonedSubscriptions.add(conClientId);
1:                 }
1:             } catch (Throwable e) {
1:                 exit(toString() + " failed.", e);
1:             }
1: 
1:             clientManager.removeClient(this);
0:             System.out.println(toString() + " DONE.");
1:         }
1: 
1:         private void process(long millis) throws JMSException {
1:             long end = System.currentTimeMillis() + millis;
1:             long hardEnd = end + 20000; // wait to finish the transaction.
1:             boolean inTransaction = false;
1:             int transCount = 0;
1: 
0:             System.out.println(toString() + " ONLINE.");
1:             Connection con = openConnection();
1:             Session sess = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:             MessageConsumer consumer = sess.createDurableSubscriber(topic,
1:                     SUBSCRIPTION_NAME, selector, false);
1:             try {
1:                 do {
1:                     long max = end - System.currentTimeMillis();
1:                     if (max <= 0) {
1:                         if (!inTransaction)
1:                             break;
1: 
1:                         max = hardEnd - System.currentTimeMillis();
1:                         if (max <= 0)
1:                             exit("" + this
1:                                     + " failed: Transaction is not finished.");
1:                     }
1: 
1:                     Message message = consumer.receive(max);
1:                     if (message == null)
1:                         continue;
1: 
1:                     onClientMessage(message);
1: 
1:                     if (message.propertyExists("COMMIT")) {
1:                         message.acknowledge(); // CLIENT_ACKNOWLEDGE
1: 
0:                         System.out.println("Received Trans[id="
1:                                 + message.getIntProperty("TRANS") + ", count="
1:                                 + transCount + "] in " + this + ".");
1: 
1:                         inTransaction = false;
1:                         transCount = 0;
1:                     } else {
1:                         inTransaction = true;
1:                         transCount++;
1:                     }
1:                 } while (true);
1:             } finally {
1:                 sess.close();
1:                 con.close();
1: 
0:                 System.out.println(toString() + " OFFLINE.");
1: 
1:                 // Check if the messages are in the waiting
1:                 // list for long time.
1:                 Message topMessage = waitingList.peek();
1:                 if (topMessage != null)
1:                     checkDeliveryTime(topMessage);
1:             }
1:         }
1: 
1:         public void onServerMessage(Message message) throws JMSException {
1:             if (Boolean.TRUE.equals(message.getObjectProperty("COMMIT"))) {
1:                 if (Boolean.TRUE.equals(message.getObjectProperty("RELEVANT")))
1:                     waitingList.add(message);
1:             } else {
1:                 String messageType = message.getStringProperty("TYPE");
1:                 if (clientType.isRelevant(messageType))
1:                     waitingList.add(message);
1:             }
1:         }
1: 
1:         public void onClientMessage(Message message) {
1:             Message serverMessage = waitingList.poll();
1:             try {
1:                 Integer receivedId = (Integer) message.getObjectProperty("ID");
1:                 if (processed != null && processed.contains(receivedId))
0:                     System.out.println("! Message has been processed before. "
1:                             + this + " message = " + message);
1: 
1:                 if (serverMessage == null)
1:                     exit(""
1:                             + this
1:                             + " failed: There is no next server message, but received: "
1:                             + message);
1: 
1:                 Integer serverId = (Integer) serverMessage
1:                         .getObjectProperty("ID");
1:                 if (receivedId == null || serverId == null)
1:                     exit("" + this + " failed: message ID not found.\r\n"
1:                             + " received: " + message + "\r\n" + "   server: "
1:                             + serverMessage);
1: 
0:                 if (!serverId.equals(receivedId))
0:                     exit("" + this + " failed: Received wrong message.\r\n"
1:                             + " received: " + message + "\r\n" + "   server: "
1:                             + serverMessage);
1: 
1:                 checkDeliveryTime(message);
1: 
1:                 if (processed != null)
1:                     processed.add(receivedId);
1:             } catch (Throwable e) {
1:                 exit("" + this + ".onClientMessage failed.\r\n" + " received: "
1:                         + message + "\r\n" + "   server: " + serverMessage, e);
1:             }
1:         }
1: 
1:         /**
1:          * Checks if the message was not delivered fast enough.
1:          */
1:         public void checkDeliveryTime(Message message) throws JMSException {
1:             long creation = message.getJMSTimestamp();
1:             long min = System.currentTimeMillis() - (offline.max + online.min)
1:                     * (BROKER_RESTART > 0 ? 4 : 1);
1: 
1:             if (false && min > creation) {
1:                 SimpleDateFormat df = new SimpleDateFormat("HH:mm:ss.SSS");
1:                 exit("" + this + ".checkDeliveryTime failed. Message time: "
1:                         + df.format(new Date(creation)) + ", min: "
1:                         + df.format(new Date(min)) + "\r\n" + message);
1:             }
1:         }
1: 
1:         private Connection openConnection() throws JMSException {
1:             Connection con = cf.createConnection();
1:             con.setClientID(conClientId);
1:             con.start();
1:             return con;
1:         }
1: 
1:         private void subscribe() throws JMSException {
1:             Connection con = openConnection();
1:             Session session = con
1:                     .createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             session.createDurableSubscriber(topic, SUBSCRIPTION_NAME, selector,
1:                     true);
1:             session.close();
1:             con.close();
1:         }
1: 
1:         private void unsubscribe() throws JMSException {
1:             Connection con = openConnection();
1:             Session session = con
1:                     .createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             session.unsubscribe(SUBSCRIPTION_NAME);
1:             session.close();
1:             con.close();
1:         }
1: 
1:         @Override
1:         public String toString() {
1:             return "Client[id=" + id + ", type=" + clientType + "]";
1:         }
1:     }
1: 
1:     /**
1:      * Sweeps out not-used durable subscriptions.
1:      */
1:     private final class HouseKeeper extends Thread {
1: 
1:         private HouseKeeper() {
1:             super("HouseKeeper");
1:             setDaemon(true);
1:         }
1: 
1:         public final CopyOnWriteArrayList<String> abandonedSubscriptions = new CopyOnWriteArrayList<String>();
1: 
1:         @Override
1:         public void run() {
1:             while (true) {
1:                 try {
1:                     Thread.sleep(3 * 60 * 1000);
1: 
1:                     processLock.readLock().lock();
1:                     try {
1:                         sweep();
1:                     } finally {
1:                         processLock.readLock().unlock();
1:                     }
1:                 } catch (InterruptedException ex) {
1:                     break;
1:                 } catch (Throwable e) {
1:                     Exception log = new Exception("HouseKeeper failed.", e);
1:                     log.printStackTrace();
1:                 }
1:             }
1:         }
1: 
1:         private void sweep() throws Exception {
0:             System.out.println("Housekeeper sweeping.");
1: 
1:             int closed = 0;
1:             ArrayList<String> sweeped = new ArrayList<String>();
1:             try {
1:                 for (String clientId : abandonedSubscriptions) {
0:                     System.out.println("Sweeping out subscription of "
1:                             + clientId + ".");
1:                     broker.getAdminView().destroyDurableSubscriber(clientId,
1:                             Client.SUBSCRIPTION_NAME);
1:                     sweeped.add(clientId);
1:                     closed++;
1:                 }
1:             } catch (Exception ignored) {
0:                 System.out.println("Ex on destroy sub "  + ignored);
1:             } finally {
1:                 abandonedSubscriptions.removeAll(sweeped);
1:             }
1: 
0:             System.out.println("Housekeeper sweeped out " + closed
1:                     + " subscriptions.");
1:         }
1:     }
1: 
1:     public static int random(int max) {
1:         return (int) (Math.random() * (max + 1));
1:     }
1: 
1:     public static int random(int min, int max) {
1:         return random(max - min) + min;
1:     }
1: 
1:     public static void sleepRandom(int maxMillis) throws InterruptedException {
1:         Thread.sleep(random(maxMillis));
1:     }
1: 
1:     public static void sleepRandom(int minMillis, int maxMillis)
1:             throws InterruptedException {
1:         Thread.sleep(random(minMillis, maxMillis));
1:     }
1: 
1:     public static final class Random {
1: 
1:         final int min;
1:         final int max;
1: 
1:         Random(int min, int max) {
1:             this.min = min;
1:             this.max = max;
1:         }
1: 
1:         public int next() {
1:             return random(min, max);
1:         }
1: 
1:         public void sleepRandom() throws InterruptedException {
1:             DurableSubProcessWithRestartTest.sleepRandom(min, max);
1:         }
1:     }
1: 
1:     public static void exit(String message) {
1:         exit(message, null);
1:     }
1: 
1:     public static void exit(String message, Throwable e) {
0:         Throwable log = new RuntimeException(message, e);
1:         log.printStackTrace();
0:         System.exit(0);
1:     }
1: 
0:     protected void setUp() throws Exception {
1:         topic = new ActiveMQTopic("TopicT");
1:         startBroker();
1: 
1:         clientManager = new ClientManager();
1:         server = new Server();
1:         houseKeeper = new HouseKeeper();
1: 
1:     }
1: 
0:     protected void tearDown() throws Exception {
1:         destroyBroker();
1:     }
1: 
1:     private enum Persistence {
0:         MEMORY, AMQ, KAHA, KAHADB
1:     }
1: 
1:     private void startBroker() throws Exception {
1:         startBroker(true);
1:     }
1: 
1:     private void startBroker(boolean deleteAllMessages) throws Exception {
1:         if (broker != null)
1:             return;
1: 
1:         broker = BrokerFactory.createBroker("broker:(vm://" + getName() + ")");
1:         broker.setBrokerName(getName());
1:         broker.setDeleteAllMessagesOnStartup(deleteAllMessages);
1: 
1:         switch (PERSISTENT_ADAPTER) {
1:         case MEMORY:
1:             broker.setPersistent(false);
1:             break;
1: 
0:         case AMQ:
0:             File amqData = new File("activemq-data/" + getName() + "-amq");
1:             if (deleteAllMessages)
0:                 delete(amqData);
1: 
1:             broker.setPersistent(true);
0:             AMQPersistenceAdapter amq = new AMQPersistenceAdapter();
0:             amq.setDirectory(amqData);
1:             broker.setPersistenceAdapter(amq);
1:             break;
1: 
0:         case KAHA:
0:             File kahaData = new File("activemq-data/" + getName() + "-kaha");
1:             if (deleteAllMessages)
0:                 delete(kahaData);
1: 
1:             broker.setPersistent(true);
0:             KahaPersistenceAdapter kaha = new KahaPersistenceAdapter();
0:             kaha.setDirectory(kahaData);
0:             broker.setPersistenceAdapter(kaha);
1:             break;
1: 
1:         case KAHADB:
1:             File kahadbData = new File("activemq-data/" + getName() + "-kahadb");
1:             if (deleteAllMessages)
1:                 delete(kahadbData);
1: 
1:             broker.setPersistent(true);
1:             KahaDBPersistenceAdapter kahadb = new KahaDBPersistenceAdapter();
1:             kahadb.setDirectory(kahadbData);
1:             kahadb.setJournalMaxFileLength(5 * 1024 * 1024);
1:             broker.setPersistenceAdapter(kahadb);
1:             break;
1:         }
1: 
1:         broker.addConnector("tcp://localhost:61656");
1: 
1:         broker.getSystemUsage().getMemoryUsage().setLimit(256 * 1024 * 1024);
1:         broker.getSystemUsage().getTempUsage().setLimit(256 * 1024 * 1024);
1:         broker.getSystemUsage().getStoreUsage().setLimit(256 * 1024 * 1024);
1: 
1:         broker.start();
1:     }
1: 
0:     private String getName() {
0:         return DurableSubProcessWithRestartTest.class.getName();
1:     }
1: 
1:     private static boolean delete(File path) {
1:         if (path == null)
1:             return true;
1: 
1:         if (path.isDirectory()) {
1:             for (File file : path.listFiles()) {
1:                 delete(file);
1:             }
1:         }
1:         return path.delete();
1:     }
1: 
1:     private void destroyBroker() throws Exception {
1:         if (broker == null)
1:             return;
1: 
1:         broker.stop();
1:         broker = null;
1:     }
1: }
============================================================================