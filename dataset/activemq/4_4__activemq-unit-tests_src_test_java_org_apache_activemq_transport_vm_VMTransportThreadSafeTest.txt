1:ad585dc: /**
1:ad585dc:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:ad585dc:  * contributor license agreements.  See the NOTICE file distributed with
1:ad585dc:  * this work for additional information regarding copyright ownership.
1:ad585dc:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:ad585dc:  * (the "License"); you may not use this file except in compliance with
1:ad585dc:  * the License.  You may obtain a copy of the License at
1:ad585dc:  *
1:ad585dc:  *      http://www.apache.org/licenses/LICENSE-2.0
1:ad585dc:  *
1:ad585dc:  * Unless required by applicable law or agreed to in writing, software
1:ad585dc:  * distributed under the License is distributed on an "AS IS" BASIS,
1:ad585dc:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:ad585dc:  * See the License for the specific language governing permissions and
1:ad585dc:  * limitations under the License.
1:ad585dc:  */
1:ad585dc: package org.apache.activemq.transport.vm;
8:ad585dc: 
1:ad585dc: import static org.junit.Assert.assertEquals;
1:ad585dc: import static org.junit.Assert.assertTrue;
1:ad585dc: import static org.junit.Assert.fail;
1:ad585dc: 
1:ad585dc: import java.io.IOException;
1:ad585dc: import java.net.URI;
1:ad585dc: import java.util.Queue;
1:ad585dc: import java.util.concurrent.ConcurrentLinkedQueue;
1:ad585dc: import java.util.concurrent.CountDownLatch;
1:ad585dc: import java.util.concurrent.TimeUnit;
1:ad585dc: import java.util.concurrent.atomic.AtomicInteger;
1:ad585dc: 
1:ad585dc: import org.apache.activemq.command.BaseCommand;
1:58b9a83: import org.apache.activemq.command.ExceptionResponse;
1:ad585dc: import org.apache.activemq.command.Response;
1:ad585dc: import org.apache.activemq.command.ShutdownInfo;
1:ad585dc: import org.apache.activemq.state.CommandVisitor;
1:58b9a83: import org.apache.activemq.transport.FutureResponse;
1:e0bb36b: import org.apache.activemq.transport.MutexTransport;
1:58b9a83: import org.apache.activemq.transport.ResponseCallback;
1:58b9a83: import org.apache.activemq.transport.ResponseCorrelator;
1:e0bb36b: import org.apache.activemq.transport.Transport;
1:ad585dc: import org.apache.activemq.transport.TransportDisposedIOException;
1:ad585dc: import org.apache.activemq.transport.TransportListener;
1:ad585dc: import org.apache.activemq.util.Wait;
1:ad585dc: import org.junit.After;
1:ad585dc: import org.junit.Before;
1:ad585dc: import org.junit.Test;
1:ad585dc: import org.slf4j.Logger;
1:ad585dc: import org.slf4j.LoggerFactory;
1:ad585dc: 
1:ad585dc: public class VMTransportThreadSafeTest {
1:ad585dc: 
1:ad585dc:     private static final Logger LOG = LoggerFactory.getLogger(VMTransportThreadSafeTest.class);
1:ad585dc: 
1:ad585dc:     private final static String location1 = "vm://transport1";
1:ad585dc:     private final static String location2 = "vm://transport2";
1:ad585dc: 
1:ad585dc:     private final ConcurrentLinkedQueue<DummyCommand> localReceived = new ConcurrentLinkedQueue<DummyCommand>();
1:ad585dc:     private final ConcurrentLinkedQueue<DummyCommand> remoteReceived = new ConcurrentLinkedQueue<DummyCommand>();
1:ad585dc: 
1:ad585dc:     private class DummyCommand extends BaseCommand {
1:ad585dc: 
1:ad585dc:         public final int sequenceId;
1:ad585dc: 
1:ad585dc:         public DummyCommand() {
1:ad585dc:             this.sequenceId = 0;
3:ad585dc:         }
1:ad585dc: 
1:ad585dc:         public DummyCommand(int id) {
1:ad585dc:             this.sequenceId = id;
1:ad585dc:         }
1:ad585dc: 
2:ad585dc:         @Override
1:ad585dc:         public Response visit(CommandVisitor visitor) throws Exception {
1:ad585dc:             return null;
1:ad585dc:         }
1:ad585dc: 
1:ad585dc:         @Override
1:ad585dc:         public byte getDataStructureType() {
1:ad585dc:             return 42;
1:ad585dc:         }
1:ad585dc:     }
1:ad585dc: 
1:ad585dc:     private class VMTestTransportListener implements TransportListener {
1:ad585dc: 
1:ad585dc:         protected final Queue<DummyCommand> received;
1:ad585dc: 
1:ad585dc:         public boolean shutdownReceived = false;
1:ad585dc: 
1:ad585dc:         public VMTestTransportListener(Queue<DummyCommand> receiveQueue) {
1:ad585dc:             this.received = receiveQueue;
1:ad585dc:         }
1:ad585dc: 
1:ad585dc:         @Override
1:ad585dc:         public void onCommand(Object command) {
1:ad585dc: 
1:ad585dc:             if (command instanceof ShutdownInfo) {
1:ad585dc:                 shutdownReceived = true;
1:ad585dc:             } else {
1:ad585dc:                 received.add((DummyCommand) command);
1:ad585dc:             }
1:ad585dc:         }
1:ad585dc: 
1:ad585dc:         @Override
1:ad585dc:         public void onException(IOException error) {
1:ad585dc:         }
1:ad585dc: 
1:ad585dc:         @Override
1:ad585dc:         public void transportInterupted() {
1:ad585dc:         }
1:ad585dc: 
1:ad585dc:         @Override
1:ad585dc:         public void transportResumed() {
1:ad585dc:         }
1:ad585dc:     }
1:ad585dc: 
1:e0bb36b:     private class VMResponderTransportListener implements TransportListener {
1:e0bb36b: 
1:e0bb36b:         protected final Queue<DummyCommand> received;
1:e0bb36b: 
1:e0bb36b:         private final Transport peer;
1:e0bb36b: 
1:e0bb36b:         public VMResponderTransportListener(Queue<DummyCommand> receiveQueue, Transport peer) {
1:e0bb36b:             this.received = receiveQueue;
1:e0bb36b:             this.peer = peer;
1:e0bb36b:         }
1:e0bb36b: 
1:e0bb36b:         @Override
1:e0bb36b:         public void onCommand(Object command) {
1:e0bb36b: 
1:e0bb36b:             if (command instanceof ShutdownInfo) {
1:e0bb36b:                 return;
1:e0bb36b:             } else {
1:e0bb36b:                 received.add((DummyCommand) command);
1:e0bb36b: 
1:e0bb36b:                 if (peer != null) {
1:e0bb36b:                     try {
1:e0bb36b:                         peer.oneway(command);
1:e0bb36b:                     } catch (IOException e) {
1:e0bb36b:                     }
1:e0bb36b:                 }
1:e0bb36b:             }
1:e0bb36b:         }
1:e0bb36b: 
1:e0bb36b:         @Override
1:e0bb36b:         public void onException(IOException error) {
1:e0bb36b:         }
1:e0bb36b: 
1:e0bb36b:         @Override
1:e0bb36b:         public void transportInterupted() {
1:e0bb36b:         }
1:e0bb36b: 
1:e0bb36b:         @Override
1:e0bb36b:         public void transportResumed() {
1:e0bb36b:         }
1:e0bb36b:     }
1:e0bb36b: 
1:ad585dc:     private class SlowVMTestTransportListener extends VMTestTransportListener {
1:ad585dc: 
1:ad585dc:         private final TimeUnit delayUnit;
1:ad585dc:         private final long delay;
1:ad585dc: 
1:ad585dc:         public SlowVMTestTransportListener(Queue<DummyCommand> receiveQueue) {
1:ad585dc:             this(receiveQueue, 10, TimeUnit.MILLISECONDS);
1:ad585dc:         }
1:ad585dc: 
1:ad585dc:         public SlowVMTestTransportListener(Queue<DummyCommand> receiveQueue, long delay, TimeUnit delayUnit) {
1:ad585dc:             super(receiveQueue);
1:ad585dc: 
1:ad585dc:             this.delay = delay;
1:ad585dc:             this.delayUnit = delayUnit;
1:ad585dc:         }
1:ad585dc: 
1:ad585dc:         @Override
1:ad585dc:         public void onCommand(Object command) {
1:ad585dc:             super.onCommand(command);
1:ad585dc:             try {
1:ad585dc:                 delayUnit.sleep(delay);
1:ad585dc:             } catch (InterruptedException e) {
1:ad585dc:             }
1:ad585dc:         }
1:ad585dc:     }
1:ad585dc: 
1:ad585dc:     private class GatedVMTestTransportListener extends VMTestTransportListener {
1:ad585dc: 
1:ad585dc:         private final CountDownLatch gate;
1:ad585dc: 
1:ad585dc:         public GatedVMTestTransportListener(Queue<DummyCommand> receiveQueue) {
1:ad585dc:             this(receiveQueue, new CountDownLatch(1));
1:ad585dc:         }
1:ad585dc: 
1:ad585dc:         public GatedVMTestTransportListener(Queue<DummyCommand> receiveQueue, CountDownLatch gate) {
1:ad585dc:             super(receiveQueue);
1:ad585dc: 
1:ad585dc:             this.gate = gate;
1:ad585dc:         }
1:ad585dc: 
1:ad585dc:         @Override
1:ad585dc:         public void onCommand(Object command) {
1:ad585dc:             super.onCommand(command);
1:ad585dc:             try {
1:ad585dc:                 gate.await();
1:ad585dc:             } catch (InterruptedException e) {
1:ad585dc:             }
1:ad585dc:         }
1:ad585dc:     }
1:ad585dc: 
1:ad585dc:     private void assertMessageAreOrdered(ConcurrentLinkedQueue<DummyCommand> queue) {
1:ad585dc:         int lastSequenceId = 0;
1:ad585dc:         for(DummyCommand command : queue) {
1:ad585dc:             int id = command.sequenceId;
1:ad585dc:             assertTrue("Last id: " + lastSequenceId + " should be less than current id: " + id,  id > lastSequenceId);
1:ad585dc:         }
1:ad585dc:     }
1:ad585dc: 
1:ad585dc:     @Before
1:ad585dc:     public void setUp() throws Exception {
1:ad585dc:         localReceived.clear();
1:ad585dc:         remoteReceived.clear();
1:ad585dc:     }
1:ad585dc: 
1:ad585dc:     @After
1:ad585dc:     public void tearDown() throws Exception {
1:ad585dc:     }
1:ad585dc: 
2:ad585dc:     @Test(timeout=60000)
1:ad585dc:     public void testStartWthoutListenerIOE() throws Exception {
1:ad585dc: 
2:ad585dc:         final VMTransport local = new VMTransport(new URI(location1));
2:ad585dc:         final VMTransport remote = new VMTransport(new URI(location2));
1:ad585dc: 
2:ad585dc:         local.setPeer(remote);
2:ad585dc:         remote.setPeer(local);
1:58b9a83: 
1:ad585dc:         remote.setTransportListener(new VMTestTransportListener(localReceived));
1:ad585dc: 
1:ad585dc:         try {
2:ad585dc:             local.start();
1:ad585dc:             fail("Should have thrown an IOExcoption");
1:ad585dc:         } catch (IOException e) {
1:ad585dc:         }
1:ad585dc:     }
1:ad585dc: 
1:ad585dc:     @Test(timeout=60000)
1:ad585dc:     public void testOnewayOnStoppedTransportTDE() throws Exception {
1:ad585dc: 
1:ad585dc:         final VMTransport local = new VMTransport(new URI(location1));
1:ad585dc:         final VMTransport remote = new VMTransport(new URI(location2));
1:ad585dc: 
1:ad585dc:         local.setPeer(remote);
1:ad585dc:         remote.setPeer(local);
1:ad585dc: 
2:ad585dc:         local.setTransportListener(new VMTestTransportListener(localReceived));
1:ad585dc:         remote.setTransportListener(new VMTestTransportListener(remoteReceived));
1:ad585dc: 
1:ad585dc:         local.start();
2:ad585dc:         local.stop();
1:ad585dc: 
1:ad585dc:         try {
1:ad585dc:             local.oneway(new DummyCommand());
1:ad585dc:             fail("Should have thrown a TransportDisposedException");
1:ad585dc:         } catch(TransportDisposedIOException e) {
1:ad585dc:         }
1:ad585dc:     }
1:ad585dc: 
1:ad585dc:     @Test(timeout=60000)
1:b60bfbb:     public void testStopSendsShutdownToPeer() throws Exception {
1:b60bfbb: 
1:b60bfbb:         final VMTransport local = new VMTransport(new URI(location1));
1:b60bfbb:         final VMTransport remote = new VMTransport(new URI(location2));
1:b60bfbb: 
1:b60bfbb:         local.setPeer(remote);
1:b60bfbb:         remote.setPeer(local);
1:b60bfbb: 
1:b60bfbb:         final VMTestTransportListener remoteListener = new VMTestTransportListener(remoteReceived);
1:b60bfbb: 
1:b60bfbb:         local.setTransportListener(new VMTestTransportListener(localReceived));
1:b60bfbb:         remote.setTransportListener(remoteListener);
1:b60bfbb: 
1:b60bfbb:         local.start();
1:b60bfbb:         local.stop();
1:b60bfbb: 
1:b60bfbb:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:b60bfbb:             @Override
1:b60bfbb:             public boolean isSatisified() throws Exception {
1:b60bfbb:                 return remoteListener.shutdownReceived;
1:b60bfbb:             }
1:b60bfbb:         }));
1:b60bfbb:     }
1:b60bfbb: 
1:b60bfbb:     @Test(timeout=60000)
1:58b9a83:     public void testRemoteStopSendsExceptionToPendingRequests() throws Exception {
1:58b9a83: 
1:58b9a83:         final VMTransport local = new VMTransport(new URI(location1));
1:58b9a83:         final VMTransport remote = new VMTransport(new URI(location2));
1:58b9a83: 
1:58b9a83:         local.setPeer(remote);
1:58b9a83:         remote.setPeer(local);
1:58b9a83: 
1:58b9a83:         final VMTestTransportListener remoteListener = new VMTestTransportListener(remoteReceived);
1:58b9a83:         remote.setTransportListener(remoteListener);
1:2050498:         remote.start();
1:ad585dc: 
1:58b9a83:         final Response[] answer = new Response[1];
1:58b9a83:         ResponseCorrelator responseCorrelator = new ResponseCorrelator(local);
1:58b9a83:         responseCorrelator.setTransportListener(new VMTestTransportListener(localReceived));
1:58b9a83:         responseCorrelator.start();
1:58b9a83:         responseCorrelator.asyncRequest(new DummyCommand(), new ResponseCallback() {
1:58b9a83:             @Override
1:58b9a83:             public void onCompletion(FutureResponse resp) {
1:58b9a83:                 try {
1:58b9a83:                     answer[0] = resp.getResult();
1:58b9a83:                 } catch (IOException e) {
1:58b9a83:                     e.printStackTrace();
1:58b9a83:                 }
1:58b9a83:             }
1:58b9a83:         });
1:58b9a83: 
1:58b9a83:         // simulate broker stop
1:58b9a83:         remote.stop();
1:58b9a83: 
1:0a12bcb:         assertTrue("got expected exception response", Wait.waitFor(new Wait.Condition() {
1:58b9a83:             @Override
1:58b9a83:             public boolean isSatisified() throws Exception {
1:58b9a83:                 LOG.info("answer: " + answer[0]);
1:58b9a83:                 return answer[0] instanceof ExceptionResponse && ((ExceptionResponse)answer[0]).getException() instanceof TransportDisposedIOException;
1:58b9a83:             }
1:58b9a83:         }));
1:58b9a83: 
1:58b9a83:         local.stop();
1:58b9a83:     }
1:58b9a83: 
1:58b9a83:     @Test(timeout=60000)
1:ad585dc:     public void testMultipleStartsAndStops() throws Exception {
1:ad585dc: 
1:ad585dc:         final VMTransport local = new VMTransport(new URI(location1));
1:ad585dc:         final VMTransport remote = new VMTransport(new URI(location2));
1:ad585dc: 
1:ad585dc:         local.setPeer(remote);
1:ad585dc:         remote.setPeer(local);
1:ad585dc: 
1:ad585dc:         local.setTransportListener(new VMTestTransportListener(localReceived));
1:ad585dc:         remote.setTransportListener(new VMTestTransportListener(remoteReceived));
1:ad585dc: 
1:ad585dc:         local.start();
1:ad585dc:         remote.start();
1:ad585dc: 
1:ad585dc:         local.start();
1:ad585dc:         remote.start();
1:ad585dc: 
1:ad585dc:         for(int i = 0; i < 100; ++i) {
1:ad585dc:             local.oneway(new DummyCommand());
1:ad585dc:         }
1:ad585dc: 
1:ad585dc:         for(int i = 0; i < 100; ++i) {
1:ad585dc:             remote.oneway(new DummyCommand());
1:ad585dc:         }
1:ad585dc: 
1:ad585dc:         local.start();
1:ad585dc:         remote.start();
1:ad585dc: 
1:58b9a83:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:ad585dc:             @Override
2:ad585dc:             public boolean isSatisified() throws Exception {
1:ad585dc:                 return remoteReceived.size() == 100;
1:ad585dc:             }
2:ad585dc:         }));
1:ad585dc: 
4:ad585dc:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:ad585dc:             @Override
1:ad585dc:             public boolean isSatisified() throws Exception {
1:ad585dc:                 return localReceived.size() == 100;
1:ad585dc:             }
1:ad585dc:         }));
1:ad585dc: 
1:ad585dc:         local.stop();
1:ad585dc:         local.stop();
1:ad585dc:         remote.stop();
1:ad585dc:         remote.stop();
1:ad585dc:     }
1:ad585dc: 
1:ad585dc:     @Test(timeout=60000)
1:ad585dc:     public void testStartWithPeerNotStartedEnqueusCommandsNonAsync() throws Exception {
1:ad585dc:         doTestStartWithPeerNotStartedEnqueusCommands(false);
1:ad585dc:     }
1:ad585dc: 
1:ad585dc:     private void doTestStartWithPeerNotStartedEnqueusCommands(boolean async) throws Exception {
1:ad585dc: 
1:ad585dc:         final VMTransport local = new VMTransport(new URI(location1));
1:ad585dc:         final VMTransport remote = new VMTransport(new URI(location2));
1:ad585dc: 
1:ad585dc:         remote.setAsync(async);
1:ad585dc: 
1:ad585dc:         local.setPeer(remote);
1:ad585dc:         remote.setPeer(local);
1:ad585dc: 
1:ad585dc:         local.setTransportListener(new VMTestTransportListener(localReceived));
1:ad585dc:         remote.setTransportListener(new VMTestTransportListener(remoteReceived));
1:ad585dc: 
1:ad585dc:         local.start();
1:ad585dc: 
1:ad585dc:         for(int i = 0; i < 100; ++i) {
1:ad585dc:             local.oneway(new DummyCommand());
1:ad585dc:         }
1:ad585dc: 
1:ad585dc:         assertEquals(100, remote.getMessageQueue().size());
1:ad585dc: 
1:ad585dc:         remote.start();
1:ad585dc: 
1:ad585dc:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:ad585dc:             @Override
1:ad585dc:             public boolean isSatisified() throws Exception {
1:ad585dc:                 return remoteReceived.size() == 100;
1:ad585dc:             }
1:ad585dc:         }));
1:ad585dc: 
1:ad585dc:         local.stop();
1:ad585dc:         remote.stop();
1:ad585dc:     }
1:ad585dc: 
1:ad585dc:     @Test(timeout=60000)
1:ad585dc:     public void testBlockedOnewayEnqeueAandStopTransportAsync() throws Exception {
1:ad585dc:         doTestBlockedOnewayEnqeueAandStopTransport(true);
1:ad585dc:     }
1:ad585dc: 
1:ad585dc:     @Test(timeout=60000)
1:ad585dc:     public void testBlockedOnewayEnqeueAandStopTransportNonAsync() throws Exception {
1:ad585dc:         doTestBlockedOnewayEnqeueAandStopTransport(false);
1:ad585dc:     }
1:ad585dc: 
1:ad585dc:     private void doTestBlockedOnewayEnqeueAandStopTransport(boolean async) throws Exception {
1:ad585dc: 
1:ad585dc:         final VMTransport local = new VMTransport(new URI(location1));
1:ad585dc:         final VMTransport remote = new VMTransport(new URI(location2));
1:ad585dc: 
1:ad585dc:         final AtomicInteger sequenceId = new AtomicInteger();
1:ad585dc: 
1:ad585dc:         remote.setAsync(async);
1:ad585dc:         remote.setAsyncQueueDepth(99);
1:ad585dc: 
1:ad585dc:         local.setPeer(remote);
1:ad585dc:         remote.setPeer(local);
1:ad585dc: 
1:ad585dc:         local.setTransportListener(new VMTestTransportListener(localReceived));
1:ad585dc:         remote.setTransportListener(new VMTestTransportListener(remoteReceived));
1:ad585dc: 
1:ad585dc:         local.start();
1:ad585dc: 
1:ad585dc:         Thread t = new Thread(new Runnable() {
1:ad585dc: 
1:ad585dc:             @Override
1:ad585dc:             public void run() {
1:ad585dc:                 for(int i = 0; i < 100; ++i) {
1:ad585dc:                     try {
1:ad585dc:                         local.oneway(new DummyCommand(sequenceId.incrementAndGet()));
1:ad585dc:                     } catch (Exception e) {
1:ad585dc:                     }
1:ad585dc:                 }
1:ad585dc: 
1:ad585dc:             }
1:ad585dc:         });
1:ad585dc:         t.start();
1:ad585dc: 
1:ad585dc:         LOG.debug("Started async delivery, wait for remote's queue to fill up");
1:ad585dc: 
1:ad585dc:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:ad585dc:             @Override
1:ad585dc:             public boolean isSatisified() throws Exception {
1:ad585dc:                 return remote.getMessageQueue().remainingCapacity() == 0;
1:ad585dc:             }
1:ad585dc:         }));
1:ad585dc: 
1:ad585dc:         LOG.debug("Remote messageQ is full, start it and stop all");
1:ad585dc: 
1:ad585dc:         remote.start();
1:ad585dc:         local.stop();
1:ad585dc:         remote.stop();
1:ad585dc:     }
1:ad585dc: 
1:ad585dc:     @Test(timeout=60000)
1:ad585dc:     public void testBlockedOnewayEnqeueWhileStartedDetectsStop() throws Exception {
1:ad585dc:         final VMTransport local = new VMTransport(new URI(location1));
1:ad585dc:         final VMTransport remote = new VMTransport(new URI(location2));
1:ad585dc: 
1:ad585dc:         final AtomicInteger sequenceId = new AtomicInteger();
1:ad585dc: 
1:ad585dc:         remote.setAsync(true);
1:ad585dc:         remote.setAsyncQueueDepth(2);
1:ad585dc: 
1:ad585dc:         local.setPeer(remote);
1:ad585dc:         remote.setPeer(local);
1:ad585dc: 
1:ad585dc:         local.setTransportListener(new VMTestTransportListener(localReceived));
1:ad585dc:         remote.setTransportListener(new GatedVMTestTransportListener(remoteReceived));
1:ad585dc: 
1:ad585dc:         local.start();
1:ad585dc:         remote.start();
1:ad585dc: 
1:ad585dc:         Thread t = new Thread(new Runnable() {
1:ad585dc: 
1:ad585dc:             @Override
1:ad585dc:             public void run() {
1:ad585dc:                 for(int i = 0; i < 3; ++i) {
1:ad585dc:                     try {
1:ad585dc:                         local.oneway(new DummyCommand(sequenceId.incrementAndGet()));
1:ad585dc:                     } catch (Exception e) {
1:ad585dc:                     }
1:ad585dc:                 }
1:ad585dc: 
1:ad585dc:             }
1:ad585dc:         });
1:ad585dc:         t.start();
1:ad585dc: 
1:ad585dc:         LOG.debug("Started async delivery, wait for remote's queue to fill up");
1:ad585dc:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:ad585dc:             @Override
1:ad585dc:             public boolean isSatisified() throws Exception {
1:ad585dc:                 return remote.getMessageQueue().remainingCapacity() == 0;
1:ad585dc:             }
1:ad585dc:         }));
1:ad585dc: 
1:ad585dc:         LOG.debug("Starting async gate open.");
1:ad585dc:         Thread gateman = new Thread(new Runnable() {
1:ad585dc:             @Override
1:ad585dc:             public void run() {
1:ad585dc:                 try {
1:eaf5c12:                     Thread.sleep(200);
1:ad585dc:                 } catch (InterruptedException e) {
1:ad585dc:                 }
1:ad585dc:                 ((GatedVMTestTransportListener) remote.getTransportListener()).gate.countDown();
1:ad585dc:             }
1:ad585dc:         });
1:eaf5c12: 
1:eaf5c12:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:eaf5c12:             @Override
1:eaf5c12:             public boolean isSatisified() throws Exception {
1:eaf5c12:                 return remoteReceived.size() == 1;
1:eaf5c12:             }
1:eaf5c12:         }));
1:eaf5c12: 
1:ad585dc:         gateman.start();
1:eaf5c12: 
1:ad585dc:         remote.stop();
1:ad585dc:         local.stop();
1:ad585dc: 
1:eaf5c12:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:eaf5c12:             @Override
1:eaf5c12:             public boolean isSatisified() throws Exception {
1:eaf5c12:                 return remoteReceived.size() == 1;
1:eaf5c12:             }
1:eaf5c12:         }));
1:ad585dc: 
1:ad585dc:         assertMessageAreOrdered(remoteReceived);
1:ad585dc:     }
1:ad585dc: 
1:ad585dc:     @Test(timeout=60000)
1:ad585dc:     public void testStopWhileStartingAsyncWithNoAsyncLimit() throws Exception {
1:ad585dc:         // In the async case the iterate method should see that we are stopping and
1:ad585dc:         // drop out before we dispatch all the messages but it should get at least 49 since
1:ad585dc:         // the stop thread waits 500 mills and the listener is waiting 10 mills on each receive.
1:ad585dc:         doTestStopWhileStartingWithNoAsyncLimit(true, 49);
1:ad585dc:     }
1:ad585dc: 
1:ad585dc:     @Test(timeout=60000)
1:ad585dc:     public void testStopWhileStartingNonAsyncWithNoAsyncLimit() throws Exception {
1:ad585dc:         // In the non-async case the start dispatches all messages up front and then continues on
1:ad585dc:         doTestStopWhileStartingWithNoAsyncLimit(false, 100);
1:ad585dc:     }
1:ad585dc: 
1:ad585dc:     private void doTestStopWhileStartingWithNoAsyncLimit(boolean async, final int expect) throws Exception {
1:ad585dc: 
1:ad585dc:         final VMTransport local = new VMTransport(new URI(location1));
1:ad585dc:         final VMTransport remote = new VMTransport(new URI(location2));
1:ad585dc: 
1:ad585dc:         remote.setAsync(async);
1:ad585dc: 
1:ad585dc:         local.setPeer(remote);
1:ad585dc:         remote.setPeer(local);
1:ad585dc: 
1:ad585dc:         local.setTransportListener(new VMTestTransportListener(localReceived));
1:ad585dc:         remote.setTransportListener(new SlowVMTestTransportListener(remoteReceived));
1:ad585dc: 
1:ad585dc:         local.start();
1:ad585dc: 
1:ad585dc:         for(int i = 0; i < 100; ++i) {
1:ad585dc:             local.oneway(new DummyCommand(i));
1:ad585dc:         }
1:ad585dc: 
1:ad585dc:         Thread t = new Thread(new Runnable() {
1:ad585dc: 
1:ad585dc:             @Override
1:ad585dc:             public void run() {
1:ad585dc:                 try {
1:4a7f870:                     Thread.sleep(1000);
1:ad585dc:                     remote.stop();
1:ad585dc:                 } catch (Exception e) {
1:ad585dc:                 }
1:ad585dc:             }
1:ad585dc:         });
1:ad585dc: 
1:ad585dc:         remote.start();
1:ad585dc: 
1:ad585dc:         t.start();
1:ad585dc: 
1:4a7f870:         assertTrue("Remote should receive: " + expect + ", commands but got: " + remoteReceived.size(), Wait.waitFor(new Wait.Condition() {
1:ad585dc:             @Override
1:ad585dc:             public boolean isSatisified() throws Exception {
1:ad585dc:                 return remoteReceived.size() >= expect;
1:ad585dc:             }
1:ad585dc:         }));
1:ad585dc: 
1:ad585dc:         LOG.debug("Remote listener received " + remoteReceived.size() + " messages");
1:ad585dc: 
1:ad585dc:         local.stop();
1:ad585dc: 
1:ad585dc:         assertTrue("Remote transport never was disposed.", Wait.waitFor(new Wait.Condition() {
1:ad585dc:             @Override
1:ad585dc:             public boolean isSatisified() throws Exception {
1:ad585dc:                 return remote.isDisposed();
1:ad585dc:             }
1:ad585dc:         }));
1:ad585dc:     }
1:ad585dc: 
1:ad585dc:     @Test(timeout=120000)
1:ad585dc:     public void TestTwoWayMessageThroughPutSync() throws Exception {
1:ad585dc: 
1:ad585dc:         long totalTimes = 0;
1:ad585dc:         final long executions = 20;
1:ad585dc: 
1:ad585dc:         for (int i = 0; i < 20; ++i) {
1:ad585dc:             totalTimes += doTestTwoWayMessageThroughPut(false);
1:ad585dc:         }
1:ad585dc: 
1:ad585dc:         LOG.info("Total time of one way sync send throughput test: " + (totalTimes/executions) + "ms");
1:ad585dc:     }
1:ad585dc: 
1:ad585dc:     @Test(timeout=120000)
1:ad585dc:     public void TestTwoWayMessageThroughPutAsnyc() throws Exception {
1:ad585dc: 
1:ad585dc:         long totalTimes = 0;
1:ad585dc:         final long executions = 50;
1:ad585dc: 
1:ad585dc:         for (int i = 0; i < executions; ++i) {
1:ad585dc:             totalTimes += doTestTwoWayMessageThroughPut(false);
1:ad585dc:         }
1:ad585dc: 
1:ad585dc:         LOG.info("Total time of one way async send throughput test: " + (totalTimes/executions) + "ms");
1:ad585dc:     }
1:ad585dc: 
1:ad585dc:     private long doTestTwoWayMessageThroughPut(boolean async) throws Exception {
1:ad585dc: 
1:ad585dc:         final VMTransport local = new VMTransport(new URI(location1));
1:ad585dc:         final VMTransport remote = new VMTransport(new URI(location2));
1:ad585dc: 
1:ad585dc:         final AtomicInteger sequenceId = new AtomicInteger();
1:ad585dc: 
1:ad585dc:         remote.setAsync(async);
1:ad585dc: 
1:ad585dc:         local.setPeer(remote);
1:ad585dc:         remote.setPeer(local);
1:ad585dc: 
1:ad585dc:         local.setTransportListener(new VMTestTransportListener(localReceived));
1:ad585dc:         remote.setTransportListener(new VMTestTransportListener(remoteReceived));
1:ad585dc: 
1:ad585dc:         final int messageCount = 200000;
1:ad585dc: 
1:ad585dc:         local.start();
1:ad585dc:         remote.start();
1:ad585dc: 
1:ad585dc:         long startTime = System.currentTimeMillis();
1:ad585dc: 
1:ad585dc:         Thread localSend = new Thread(new Runnable() {
1:ad585dc: 
1:ad585dc:             @Override
1:ad585dc:             public void run() {
1:ad585dc:                 for(int i = 0; i < messageCount; ++i) {
1:ad585dc:                     try {
1:ad585dc:                         local.oneway(new DummyCommand(sequenceId.incrementAndGet()));
1:ad585dc:                     } catch (Exception e) {
1:ad585dc:                     }
1:ad585dc:                 }
1:ad585dc: 
1:ad585dc:             }
1:ad585dc:         });
1:ad585dc: 
1:ad585dc:         Thread remoteSend = new Thread(new Runnable() {
1:ad585dc: 
1:ad585dc:             @Override
1:ad585dc:             public void run() {
1:ad585dc:                 for(int i = 0; i < messageCount; ++i) {
1:ad585dc:                     try {
1:ad585dc:                         remote.oneway(new DummyCommand(sequenceId.incrementAndGet()));
1:ad585dc:                     } catch (Exception e) {
1:ad585dc:                     }
1:ad585dc:                 }
1:ad585dc: 
1:ad585dc:             }
1:ad585dc:         });
1:ad585dc: 
1:ad585dc:         localSend.start();
1:ad585dc:         remoteSend.start();
1:ad585dc: 
1:ad585dc:         // Wait for both to finish and then check that each side go the correct amount
1:ad585dc:         localSend.join();
1:ad585dc:         remoteSend.join();
1:ad585dc: 
1:ad585dc:         long endTime = System.currentTimeMillis();
1:ad585dc: 
1:ad585dc:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:ad585dc:             @Override
1:ad585dc:             public boolean isSatisified() throws Exception {
1:ad585dc:                 return remoteReceived.size() == messageCount;
1:ad585dc:             }
1:ad585dc:         }));
1:ad585dc: 
1:ad585dc:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:ad585dc:             @Override
1:ad585dc:             public boolean isSatisified() throws Exception {
1:ad585dc:                 return localReceived.size() == messageCount;
1:ad585dc:             }
1:ad585dc:         }));
1:ad585dc: 
1:ad585dc:         LOG.debug("All messages sent,stop all");
1:ad585dc: 
1:ad585dc:         local.stop();
1:ad585dc:         remote.stop();
1:ad585dc: 
1:ad585dc:         localReceived.clear();
1:ad585dc:         remoteReceived.clear();
1:ad585dc: 
1:ad585dc:         return endTime - startTime;
1:ad585dc:     }
1:e0bb36b: 
1:e0bb36b:     @Test(timeout=120000)
1:ad585dc:     public void TestOneWayMessageThroughPutSync() throws Exception {
1:e0bb36b: 
1:ad585dc:         long totalTimes = 0;
1:ad585dc:         final long executions = 30;
1:ad585dc: 
1:ad585dc:         for (int i = 0; i < executions; ++i) {
1:ad585dc:             totalTimes += doTestOneWayMessageThroughPut(false);
1:ad585dc:         }
1:ad585dc: 
1:ad585dc:         LOG.info("Total time of one way sync send throughput test: " + (totalTimes/executions) + "ms");
1:ad585dc:     }
1:ad585dc: 
1:ad585dc:     @Test(timeout=120000)
1:ad585dc:     public void TestOneWayMessageThroughPutAsnyc() throws Exception {
1:ad585dc: 
1:ad585dc:         long totalTimes = 0;
1:ad585dc:         final long executions = 20;
1:ad585dc: 
1:ad585dc:         for (int i = 0; i < 20; ++i) {
1:ad585dc:             totalTimes += doTestOneWayMessageThroughPut(true);
1:ad585dc:         }
1:ad585dc: 
1:ad585dc:         LOG.info("Total time of one way async send throughput test: " + (totalTimes/executions) + "ms");
1:ad585dc:     }
1:ad585dc: 
1:ad585dc:     private long doTestOneWayMessageThroughPut(boolean async) throws Exception {
1:ad585dc: 
1:ad585dc:         final VMTransport local = new VMTransport(new URI(location1));
1:ad585dc:         final VMTransport remote = new VMTransport(new URI(location2));
1:ad585dc: 
1:ad585dc:         final AtomicInteger sequenceId = new AtomicInteger();
1:ad585dc: 
1:ad585dc:         remote.setAsync(async);
1:ad585dc: 
1:ad585dc:         local.setPeer(remote);
1:ad585dc:         remote.setPeer(local);
1:ad585dc: 
1:ad585dc:         local.setTransportListener(new VMTestTransportListener(localReceived));
1:ad585dc:         remote.setTransportListener(new VMTestTransportListener(remoteReceived));
1:ad585dc: 
1:ad585dc:         final int messageCount = 100000;
1:ad585dc: 
1:ad585dc:         local.start();
1:ad585dc:         remote.start();
1:ad585dc: 
1:ad585dc:         long startTime = System.currentTimeMillis();
1:ad585dc: 
1:ad585dc:         Thread localSend = new Thread(new Runnable() {
1:ad585dc: 
1:ad585dc:             @Override
1:ad585dc:             public void run() {
1:ad585dc:                 for(int i = 0; i < messageCount; ++i) {
1:ad585dc:                     try {
1:ad585dc:                         local.oneway(new DummyCommand(sequenceId.incrementAndGet()));
1:ad585dc:                     } catch (Exception e) {
1:ad585dc:                     }
1:ad585dc:                 }
1:ad585dc: 
1:ad585dc:             }
1:ad585dc:         });
1:ad585dc: 
1:ad585dc:         localSend.start();
1:ad585dc: 
1:ad585dc:         // Wait for both to finish and then check that each side go the correct amount
1:ad585dc:         localSend.join();
1:ad585dc: 
1:ad585dc:         long endTime = System.currentTimeMillis();
1:ad585dc: 
1:ad585dc:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:ad585dc:             @Override
1:ad585dc:             public boolean isSatisified() throws Exception {
1:ad585dc:                 return remoteReceived.size() == messageCount;
1:ad585dc:             }
1:ad585dc:         }));
1:ad585dc: 
1:ad585dc:         LOG.debug("All messages sent,stop all");
1:ad585dc: 
1:ad585dc:         local.stop();
1:ad585dc:         remote.stop();
1:ad585dc: 
1:ad585dc:         localReceived.clear();
1:ad585dc:         remoteReceived.clear();
1:ad585dc: 
1:ad585dc:         return endTime - startTime;
1:ad585dc:     }
1:ad585dc: 
1:ad585dc:     @Test(timeout=120000)
1:e0bb36b:     public void testTwoWayTrafficWithMutexTransportSync1() throws Exception {
1:e0bb36b: 
1:e0bb36b:         for (int i = 0; i < 20; ++i) {
1:e0bb36b:             doTestTwoWayTrafficWithMutexTransport(false, false);
1:e0bb36b:         }
1:e0bb36b:     }
1:e0bb36b: 
1:e0bb36b:     @Test(timeout=120000)
1:e0bb36b:     public void testTwoWayTrafficWithMutexTransportSync2() throws Exception {
1:e0bb36b: 
1:e0bb36b:         for (int i = 0; i < 20; ++i) {
1:e0bb36b:             doTestTwoWayTrafficWithMutexTransport(true, false);
1:e0bb36b:         }
1:e0bb36b:     }
1:e0bb36b: 
1:e0bb36b:     @Test(timeout=120000)
1:e0bb36b:     public void testTwoWayTrafficWithMutexTransportSync3() throws Exception {
1:e0bb36b: 
1:e0bb36b:         for (int i = 0; i < 20; ++i) {
1:e0bb36b:             doTestTwoWayTrafficWithMutexTransport(false, true);
1:e0bb36b:         }
1:e0bb36b:     }
1:e0bb36b: 
1:e0bb36b:     @Test(timeout=120000)
1:e0bb36b:     public void testTwoWayTrafficWithMutexTransportSync4() throws Exception {
1:e0bb36b: 
1:e0bb36b:         for (int i = 0; i < 20; ++i) {
1:e0bb36b:             doTestTwoWayTrafficWithMutexTransport(false, false);
1:e0bb36b:         }
1:e0bb36b:     }
1:e0bb36b: 
1:e0bb36b:     public void doTestTwoWayTrafficWithMutexTransport(boolean localAsync, boolean remoteAsync) throws Exception {
1:e0bb36b: 
1:e0bb36b:         final VMTransport vmlocal = new VMTransport(new URI(location1));
1:e0bb36b:         final VMTransport vmremote = new VMTransport(new URI(location2));
1:e0bb36b: 
1:e0bb36b:         final MutexTransport local = new MutexTransport(vmlocal);
1:e0bb36b:         final MutexTransport remote = new MutexTransport(vmremote);
1:e0bb36b: 
1:e0bb36b:         final AtomicInteger sequenceId = new AtomicInteger();
1:e0bb36b: 
1:e0bb36b:         vmlocal.setAsync(localAsync);
1:e0bb36b:         vmremote.setAsync(remoteAsync);
1:e0bb36b: 
1:e0bb36b:         vmlocal.setPeer(vmremote);
1:e0bb36b:         vmremote.setPeer(vmlocal);
1:e0bb36b: 
1:e0bb36b:         local.setTransportListener(new VMTestTransportListener(localReceived));
1:e0bb36b:         remote.setTransportListener(new VMResponderTransportListener(remoteReceived, remote));
1:e0bb36b: 
1:e0bb36b:         final int messageCount = 200000;
1:e0bb36b: 
1:e0bb36b:         Thread localSend = new Thread(new Runnable() {
1:e0bb36b: 
1:e0bb36b:             @Override
1:e0bb36b:             public void run() {
1:e0bb36b:                 for(int i = 0; i < messageCount; ++i) {
1:e0bb36b:                     try {
1:e0bb36b:                         local.oneway(new DummyCommand(sequenceId.incrementAndGet()));
1:e0bb36b:                     } catch (Exception e) {
1:e0bb36b:                     }
1:e0bb36b:                 }
1:e0bb36b:             }
1:e0bb36b:         });
1:e0bb36b: 
1:e0bb36b:         Thread remoteSend = new Thread(new Runnable() {
1:e0bb36b: 
1:e0bb36b:             @Override
1:e0bb36b:             public void run() {
1:e0bb36b:                 for(int i = 0; i < messageCount; ++i) {
1:e0bb36b:                     try {
1:e0bb36b:                         remote.oneway(new DummyCommand(sequenceId.incrementAndGet()));
1:e0bb36b:                     } catch (Exception e) {
1:e0bb36b:                     }
1:e0bb36b:                 }
1:e0bb36b:             }
1:e0bb36b:         });
1:e0bb36b: 
1:e0bb36b:         localSend.start();
1:e0bb36b:         remoteSend.start();
1:ad585dc: 
1:e0bb36b:         Thread.sleep(10);
1:e0bb36b: 
1:e0bb36b:         local.start();
1:e0bb36b:         remote.start();
1:e0bb36b: 
1:e0bb36b:         // Wait for both to finish and then check that each side go the correct amount
1:e0bb36b:         localSend.join();
1:e0bb36b:         remoteSend.join();
1:e0bb36b: 
1:e0bb36b:         assertTrue("Remote should have received ("+messageCount+") but got ()" + remoteReceived.size(), Wait.waitFor(new Wait.Condition() {
1:e0bb36b:             @Override
1:e0bb36b:             public boolean isSatisified() throws Exception {
1:e0bb36b:                 return remoteReceived.size() == messageCount;
1:e0bb36b:             }
1:e0bb36b:         }));
1:e0bb36b: 
1:e0bb36b:         assertTrue("Local should have received ("+messageCount*2+") but got ()" + localReceived.size(), Wait.waitFor(new Wait.Condition() {
1:e0bb36b:             @Override
1:e0bb36b:             public boolean isSatisified() throws Exception {
1:e0bb36b:                 return localReceived.size() == messageCount*2;
1:e0bb36b:             }
1:e0bb36b:         }));
1:e0bb36b: 
1:e0bb36b:         LOG.debug("All messages sent,stop all");
1:e0bb36b: 
1:e0bb36b:         local.stop();
1:e0bb36b:         remote.stop();
1:e0bb36b: 
1:e0bb36b:         localReceived.clear();
1:e0bb36b:         remoteReceived.clear();
1:e0bb36b:     }
1:ad585dc: 
1:ad585dc: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:0a12bcb
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("got expected exception response", Wait.waitFor(new Wait.Condition() {
commit:b60bfbb
/////////////////////////////////////////////////////////////////////////
1:     public void testStopSendsShutdownToPeer() throws Exception {
1: 
1:         final VMTransport local = new VMTransport(new URI(location1));
1:         final VMTransport remote = new VMTransport(new URI(location2));
1: 
1:         local.setPeer(remote);
1:         remote.setPeer(local);
1: 
1:         final VMTestTransportListener remoteListener = new VMTestTransportListener(remoteReceived);
1: 
1:         local.setTransportListener(new VMTestTransportListener(localReceived));
1:         remote.setTransportListener(remoteListener);
1: 
1:         local.start();
1:         local.stop();
1: 
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return remoteListener.shutdownReceived;
1:             }
1:         }));
1:     }
1: 
1:     @Test(timeout=60000)
commit:8cf98a0
/////////////////////////////////////////////////////////////////////////
commit:2050498
/////////////////////////////////////////////////////////////////////////
1:         remote.start();
author:Timothy Bish
-------------------------------------------------------------------------------
commit:eaf5c12
/////////////////////////////////////////////////////////////////////////
1:                     Thread.sleep(200);
1: 
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return remoteReceived.size() == 1;
1:             }
1:         }));
1: 
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return remoteReceived.size() == 1;
1:             }
1:         }));
1: 
author:Gary Tully
-------------------------------------------------------------------------------
commit:58b9a83
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ExceptionResponse;
1: import org.apache.activemq.transport.FutureResponse;
1: import org.apache.activemq.transport.ResponseCallback;
1: import org.apache.activemq.transport.ResponseCorrelator;
/////////////////////////////////////////////////////////////////////////
1:     public void testRemoteStopSendsExceptionToPendingRequests() throws Exception {
1: 
1:         final VMTransport local = new VMTransport(new URI(location1));
1:         final VMTransport remote = new VMTransport(new URI(location2));
1: 
1:         local.setPeer(remote);
1:         remote.setPeer(local);
1: 
1:         final VMTestTransportListener remoteListener = new VMTestTransportListener(remoteReceived);
1:         remote.setTransportListener(remoteListener);
1: 
1:         final Response[] answer = new Response[1];
1:         ResponseCorrelator responseCorrelator = new ResponseCorrelator(local);
1:         responseCorrelator.setTransportListener(new VMTestTransportListener(localReceived));
1:         responseCorrelator.start();
1:         responseCorrelator.asyncRequest(new DummyCommand(), new ResponseCallback() {
1:             @Override
1:             public void onCompletion(FutureResponse resp) {
1:                 try {
1:                     answer[0] = resp.getResult();
1:                 } catch (IOException e) {
1:                     e.printStackTrace();
1:                 }
1:             }
1:         });
1: 
1:         // simulate broker stop
1:         remote.stop();
1: 
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 LOG.info("answer: " + answer[0]);
1:                 return answer[0] instanceof ExceptionResponse && ((ExceptionResponse)answer[0]).getException() instanceof TransportDisposedIOException;
1:             }
1:         }));
1: 
1:         local.stop();
1:     }
1: 
1:     @Test(timeout=60000)
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
commit:e0bb36b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.MutexTransport;
1: import org.apache.activemq.transport.Transport;
/////////////////////////////////////////////////////////////////////////
1:     private class VMResponderTransportListener implements TransportListener {
1: 
1:         protected final Queue<DummyCommand> received;
1: 
1:         private final Transport peer;
1: 
1:         public VMResponderTransportListener(Queue<DummyCommand> receiveQueue, Transport peer) {
1:             this.received = receiveQueue;
1:             this.peer = peer;
1:         }
1: 
1:         @Override
1:         public void onCommand(Object command) {
1: 
1:             if (command instanceof ShutdownInfo) {
1:                 return;
1:             } else {
1:                 received.add((DummyCommand) command);
1: 
1:                 if (peer != null) {
1:                     try {
1:                         peer.oneway(command);
1:                     } catch (IOException e) {
1:                     }
1:                 }
1:             }
1:         }
1: 
1:         @Override
1:         public void onException(IOException error) {
1:         }
1: 
1:         @Override
1:         public void transportInterupted() {
1:         }
1: 
1:         @Override
1:         public void transportResumed() {
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=120000)
1:     public void testTwoWayTrafficWithMutexTransportSync1() throws Exception {
1: 
1:         for (int i = 0; i < 20; ++i) {
1:             doTestTwoWayTrafficWithMutexTransport(false, false);
1:         }
1:     }
1: 
1:     @Test(timeout=120000)
1:     public void testTwoWayTrafficWithMutexTransportSync2() throws Exception {
1: 
1:         for (int i = 0; i < 20; ++i) {
1:             doTestTwoWayTrafficWithMutexTransport(true, false);
1:         }
1:     }
1: 
1:     @Test(timeout=120000)
1:     public void testTwoWayTrafficWithMutexTransportSync3() throws Exception {
1: 
1:         for (int i = 0; i < 20; ++i) {
1:             doTestTwoWayTrafficWithMutexTransport(false, true);
1:         }
1:     }
1: 
1:     @Test(timeout=120000)
1:     public void testTwoWayTrafficWithMutexTransportSync4() throws Exception {
1: 
1:         for (int i = 0; i < 20; ++i) {
1:             doTestTwoWayTrafficWithMutexTransport(false, false);
1:         }
1:     }
1: 
1:     public void doTestTwoWayTrafficWithMutexTransport(boolean localAsync, boolean remoteAsync) throws Exception {
1: 
1:         final VMTransport vmlocal = new VMTransport(new URI(location1));
1:         final VMTransport vmremote = new VMTransport(new URI(location2));
1: 
1:         final MutexTransport local = new MutexTransport(vmlocal);
1:         final MutexTransport remote = new MutexTransport(vmremote);
1: 
1:         final AtomicInteger sequenceId = new AtomicInteger();
1: 
1:         vmlocal.setAsync(localAsync);
1:         vmremote.setAsync(remoteAsync);
1: 
1:         vmlocal.setPeer(vmremote);
1:         vmremote.setPeer(vmlocal);
1: 
1:         local.setTransportListener(new VMTestTransportListener(localReceived));
1:         remote.setTransportListener(new VMResponderTransportListener(remoteReceived, remote));
1: 
1:         final int messageCount = 200000;
1: 
1:         Thread localSend = new Thread(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 for(int i = 0; i < messageCount; ++i) {
1:                     try {
1:                         local.oneway(new DummyCommand(sequenceId.incrementAndGet()));
1:                     } catch (Exception e) {
1:                     }
1:                 }
1:             }
1:         });
1: 
1:         Thread remoteSend = new Thread(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 for(int i = 0; i < messageCount; ++i) {
1:                     try {
1:                         remote.oneway(new DummyCommand(sequenceId.incrementAndGet()));
1:                     } catch (Exception e) {
1:                     }
1:                 }
1:             }
1:         });
1: 
1:         localSend.start();
1:         remoteSend.start();
1: 
1:         Thread.sleep(10);
1: 
1:         local.start();
1:         remote.start();
1: 
1:         // Wait for both to finish and then check that each side go the correct amount
1:         localSend.join();
1:         remoteSend.join();
1: 
1:         assertTrue("Remote should have received ("+messageCount+") but got ()" + remoteReceived.size(), Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return remoteReceived.size() == messageCount;
1:             }
1:         }));
1: 
1:         assertTrue("Local should have received ("+messageCount*2+") but got ()" + localReceived.size(), Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return localReceived.size() == messageCount*2;
1:             }
1:         }));
1: 
1:         LOG.debug("All messages sent,stop all");
1: 
1:         local.stop();
1:         remote.stop();
1: 
1:         localReceived.clear();
1:         remoteReceived.clear();
1:     }
1: 
commit:4a7f870
/////////////////////////////////////////////////////////////////////////
1:                     Thread.sleep(1000);
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("Remote should receive: " + expect + ", commands but got: " + remoteReceived.size(), Wait.waitFor(new Wait.Condition() {
commit:ad585dc
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport.vm;
1: 
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertTrue;
1: import static org.junit.Assert.fail;
1: 
1: import java.io.IOException;
1: import java.net.URI;
1: import java.util.Queue;
1: import java.util.concurrent.ConcurrentLinkedQueue;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicInteger;
1: 
1: import org.apache.activemq.command.BaseCommand;
1: import org.apache.activemq.command.Response;
1: import org.apache.activemq.command.ShutdownInfo;
1: import org.apache.activemq.state.CommandVisitor;
1: import org.apache.activemq.transport.TransportDisposedIOException;
1: import org.apache.activemq.transport.TransportListener;
1: import org.apache.activemq.util.Wait;
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Test;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: public class VMTransportThreadSafeTest {
1: 
1:     private static final Logger LOG = LoggerFactory.getLogger(VMTransportThreadSafeTest.class);
1: 
1:     private final static String location1 = "vm://transport1";
1:     private final static String location2 = "vm://transport2";
1: 
1:     private final ConcurrentLinkedQueue<DummyCommand> localReceived = new ConcurrentLinkedQueue<DummyCommand>();
1:     private final ConcurrentLinkedQueue<DummyCommand> remoteReceived = new ConcurrentLinkedQueue<DummyCommand>();
1: 
1:     private class DummyCommand extends BaseCommand {
1: 
1:         public final int sequenceId;
1: 
1:         public DummyCommand() {
1:             this.sequenceId = 0;
1:         }
1: 
1:         public DummyCommand(int id) {
1:             this.sequenceId = id;
1:         }
1: 
1:         @Override
1:         public Response visit(CommandVisitor visitor) throws Exception {
1:             return null;
1:         }
1: 
1:         @Override
1:         public byte getDataStructureType() {
1:             return 42;
1:         }
1:     }
1: 
1:     private class VMTestTransportListener implements TransportListener {
1: 
1:         protected final Queue<DummyCommand> received;
1: 
1:         public boolean shutdownReceived = false;
1: 
1:         public VMTestTransportListener(Queue<DummyCommand> receiveQueue) {
1:             this.received = receiveQueue;
1:         }
1: 
1:         @Override
1:         public void onCommand(Object command) {
1: 
1:             if (command instanceof ShutdownInfo) {
1:                 shutdownReceived = true;
1:             } else {
1:                 received.add((DummyCommand) command);
1:             }
1:         }
1: 
1:         @Override
1:         public void onException(IOException error) {
1:         }
1: 
1:         @Override
1:         public void transportInterupted() {
1:         }
1: 
1:         @Override
1:         public void transportResumed() {
1:         }
1:     }
1: 
1:     private class SlowVMTestTransportListener extends VMTestTransportListener {
1: 
1:         private final TimeUnit delayUnit;
1:         private final long delay;
1: 
1:         public SlowVMTestTransportListener(Queue<DummyCommand> receiveQueue) {
1:             this(receiveQueue, 10, TimeUnit.MILLISECONDS);
1:         }
1: 
1:         public SlowVMTestTransportListener(Queue<DummyCommand> receiveQueue, long delay, TimeUnit delayUnit) {
1:             super(receiveQueue);
1: 
1:             this.delay = delay;
1:             this.delayUnit = delayUnit;
1:         }
1: 
1:         @Override
1:         public void onCommand(Object command) {
1:             super.onCommand(command);
1:             try {
1:                 delayUnit.sleep(delay);
1:             } catch (InterruptedException e) {
1:             }
1:         }
1:     }
1: 
1:     private class GatedVMTestTransportListener extends VMTestTransportListener {
1: 
1:         private final CountDownLatch gate;
1: 
1:         public GatedVMTestTransportListener(Queue<DummyCommand> receiveQueue) {
1:             this(receiveQueue, new CountDownLatch(1));
1:         }
1: 
1:         public GatedVMTestTransportListener(Queue<DummyCommand> receiveQueue, CountDownLatch gate) {
1:             super(receiveQueue);
1: 
1:             this.gate = gate;
1:         }
1: 
1:         @Override
1:         public void onCommand(Object command) {
1:             super.onCommand(command);
1:             try {
1:                 gate.await();
1:             } catch (InterruptedException e) {
1:             }
1:         }
1:     }
1: 
1:     private void assertMessageAreOrdered(ConcurrentLinkedQueue<DummyCommand> queue) {
1:         int lastSequenceId = 0;
1:         for(DummyCommand command : queue) {
1:             int id = command.sequenceId;
1:             assertTrue("Last id: " + lastSequenceId + " should be less than current id: " + id,  id > lastSequenceId);
1:         }
1:     }
1: 
1:     @Before
1:     public void setUp() throws Exception {
1:         localReceived.clear();
1:         remoteReceived.clear();
1:     }
1: 
1:     @After
1:     public void tearDown() throws Exception {
1:     }
1: 
1:     @Test(timeout=60000)
1:     public void testStartWthoutListenerIOE() throws Exception {
1: 
1:         final VMTransport local = new VMTransport(new URI(location1));
1:         final VMTransport remote = new VMTransport(new URI(location2));
1: 
1:         local.setPeer(remote);
1:         remote.setPeer(local);
1: 
1:         remote.setTransportListener(new VMTestTransportListener(localReceived));
1: 
1:         try {
1:             local.start();
1:             fail("Should have thrown an IOExcoption");
1:         } catch (IOException e) {
1:         }
1:     }
1: 
1:     @Test(timeout=60000)
1:     public void testOnewayOnStoppedTransportTDE() throws Exception {
1: 
1:         final VMTransport local = new VMTransport(new URI(location1));
1:         final VMTransport remote = new VMTransport(new URI(location2));
1: 
1:         local.setPeer(remote);
1:         remote.setPeer(local);
1: 
1:         local.setTransportListener(new VMTestTransportListener(localReceived));
1:         remote.setTransportListener(new VMTestTransportListener(remoteReceived));
1: 
1:         local.start();
1:         local.stop();
1: 
1:         try {
1:             local.oneway(new DummyCommand());
1:             fail("Should have thrown a TransportDisposedException");
1:         } catch(TransportDisposedIOException e) {
1:         }
1:     }
1: 
1:     @Test(timeout=60000)
0:     public void testStopSendsShutdownToPeer() throws Exception {
1: 
1:         final VMTransport local = new VMTransport(new URI(location1));
1:         final VMTransport remote = new VMTransport(new URI(location2));
1: 
1:         local.setPeer(remote);
1:         remote.setPeer(local);
1: 
0:         final VMTestTransportListener remoteListener = new VMTestTransportListener(remoteReceived);
1: 
1:         local.setTransportListener(new VMTestTransportListener(localReceived));
0:         remote.setTransportListener(remoteListener);
1: 
1:         local.start();
1:         local.stop();
1: 
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
0:                 return remoteListener.shutdownReceived;
1:             }
1:         }));
1:     }
1: 
1:     @Test(timeout=60000)
1:     public void testMultipleStartsAndStops() throws Exception {
1: 
1:         final VMTransport local = new VMTransport(new URI(location1));
1:         final VMTransport remote = new VMTransport(new URI(location2));
1: 
1:         local.setPeer(remote);
1:         remote.setPeer(local);
1: 
1:         local.setTransportListener(new VMTestTransportListener(localReceived));
1:         remote.setTransportListener(new VMTestTransportListener(remoteReceived));
1: 
1:         local.start();
1:         remote.start();
1: 
1:         local.start();
1:         remote.start();
1: 
1:         for(int i = 0; i < 100; ++i) {
1:             local.oneway(new DummyCommand());
1:         }
1: 
1:         for(int i = 0; i < 100; ++i) {
1:             remote.oneway(new DummyCommand());
1:         }
1: 
1:         local.start();
1:         remote.start();
1: 
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return remoteReceived.size() == 100;
1:             }
1:         }));
1: 
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return localReceived.size() == 100;
1:             }
1:         }));
1: 
1:         local.stop();
1:         local.stop();
1:         remote.stop();
1:         remote.stop();
1:     }
1: 
1:     @Test(timeout=60000)
1:     public void testStartWithPeerNotStartedEnqueusCommandsNonAsync() throws Exception {
1:         doTestStartWithPeerNotStartedEnqueusCommands(false);
1:     }
1: 
1:     private void doTestStartWithPeerNotStartedEnqueusCommands(boolean async) throws Exception {
1: 
1:         final VMTransport local = new VMTransport(new URI(location1));
1:         final VMTransport remote = new VMTransport(new URI(location2));
1: 
1:         remote.setAsync(async);
1: 
1:         local.setPeer(remote);
1:         remote.setPeer(local);
1: 
1:         local.setTransportListener(new VMTestTransportListener(localReceived));
1:         remote.setTransportListener(new VMTestTransportListener(remoteReceived));
1: 
1:         local.start();
1: 
1:         for(int i = 0; i < 100; ++i) {
1:             local.oneway(new DummyCommand());
1:         }
1: 
1:         assertEquals(100, remote.getMessageQueue().size());
1: 
1:         remote.start();
1: 
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return remoteReceived.size() == 100;
1:             }
1:         }));
1: 
1:         local.stop();
1:         remote.stop();
1:     }
1: 
1:     @Test(timeout=60000)
1:     public void testBlockedOnewayEnqeueAandStopTransportAsync() throws Exception {
1:         doTestBlockedOnewayEnqeueAandStopTransport(true);
1:     }
1: 
1:     @Test(timeout=60000)
1:     public void testBlockedOnewayEnqeueAandStopTransportNonAsync() throws Exception {
1:         doTestBlockedOnewayEnqeueAandStopTransport(false);
1:     }
1: 
1:     private void doTestBlockedOnewayEnqeueAandStopTransport(boolean async) throws Exception {
1: 
1:         final VMTransport local = new VMTransport(new URI(location1));
1:         final VMTransport remote = new VMTransport(new URI(location2));
1: 
1:         final AtomicInteger sequenceId = new AtomicInteger();
1: 
1:         remote.setAsync(async);
1:         remote.setAsyncQueueDepth(99);
1: 
1:         local.setPeer(remote);
1:         remote.setPeer(local);
1: 
1:         local.setTransportListener(new VMTestTransportListener(localReceived));
1:         remote.setTransportListener(new VMTestTransportListener(remoteReceived));
1: 
1:         local.start();
1: 
1:         Thread t = new Thread(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 for(int i = 0; i < 100; ++i) {
1:                     try {
1:                         local.oneway(new DummyCommand(sequenceId.incrementAndGet()));
1:                     } catch (Exception e) {
1:                     }
1:                 }
1: 
1:             }
1:         });
1:         t.start();
1: 
1:         LOG.debug("Started async delivery, wait for remote's queue to fill up");
1: 
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return remote.getMessageQueue().remainingCapacity() == 0;
1:             }
1:         }));
1: 
1:         LOG.debug("Remote messageQ is full, start it and stop all");
1: 
1:         remote.start();
1:         local.stop();
1:         remote.stop();
1:     }
1: 
1:     @Test(timeout=60000)
1:     public void testBlockedOnewayEnqeueWhileStartedDetectsStop() throws Exception {
1:         final VMTransport local = new VMTransport(new URI(location1));
1:         final VMTransport remote = new VMTransport(new URI(location2));
1: 
1:         final AtomicInteger sequenceId = new AtomicInteger();
1: 
1:         remote.setAsync(true);
1:         remote.setAsyncQueueDepth(2);
1: 
1:         local.setPeer(remote);
1:         remote.setPeer(local);
1: 
1:         local.setTransportListener(new VMTestTransportListener(localReceived));
1:         remote.setTransportListener(new GatedVMTestTransportListener(remoteReceived));
1: 
1:         local.start();
1:         remote.start();
1: 
1:         Thread t = new Thread(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 for(int i = 0; i < 3; ++i) {
1:                     try {
1:                         local.oneway(new DummyCommand(sequenceId.incrementAndGet()));
1:                     } catch (Exception e) {
1:                     }
1:                 }
1: 
1:             }
1:         });
1:         t.start();
1: 
1:         LOG.debug("Started async delivery, wait for remote's queue to fill up");
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return remote.getMessageQueue().remainingCapacity() == 0;
1:             }
1:         }));
1: 
1:         LOG.debug("Starting async gate open.");
1:         Thread gateman = new Thread(new Runnable() {
1:             @Override
1:             public void run() {
1:                 try {
0:                     Thread.sleep(100);
1:                 } catch (InterruptedException e) {
1:                 }
1:                 ((GatedVMTestTransportListener) remote.getTransportListener()).gate.countDown();
1:             }
1:         });
1:         gateman.start();
1: 
1:         remote.stop();
1:         local.stop();
1: 
0:         assertEquals(1, remoteReceived.size());
1:         assertMessageAreOrdered(remoteReceived);
1:     }
1: 
1:     @Test(timeout=60000)
1:     public void testStopWhileStartingAsyncWithNoAsyncLimit() throws Exception {
1:         // In the async case the iterate method should see that we are stopping and
1:         // drop out before we dispatch all the messages but it should get at least 49 since
1:         // the stop thread waits 500 mills and the listener is waiting 10 mills on each receive.
1:         doTestStopWhileStartingWithNoAsyncLimit(true, 49);
1:     }
1: 
1:     @Test(timeout=60000)
1:     public void testStopWhileStartingNonAsyncWithNoAsyncLimit() throws Exception {
1:         // In the non-async case the start dispatches all messages up front and then continues on
1:         doTestStopWhileStartingWithNoAsyncLimit(false, 100);
1:     }
1: 
1:     private void doTestStopWhileStartingWithNoAsyncLimit(boolean async, final int expect) throws Exception {
1: 
1:         final VMTransport local = new VMTransport(new URI(location1));
1:         final VMTransport remote = new VMTransport(new URI(location2));
1: 
1:         remote.setAsync(async);
1: 
1:         local.setPeer(remote);
1:         remote.setPeer(local);
1: 
1:         local.setTransportListener(new VMTestTransportListener(localReceived));
1:         remote.setTransportListener(new SlowVMTestTransportListener(remoteReceived));
1: 
1:         local.start();
1: 
1:         for(int i = 0; i < 100; ++i) {
1:             local.oneway(new DummyCommand(i));
1:         }
1: 
1:         Thread t = new Thread(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 try {
0:                     Thread.sleep(500);
1:                     remote.stop();
1:                 } catch (Exception e) {
1:                 }
1:             }
1:         });
1: 
1:         remote.start();
1: 
1:         t.start();
1: 
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return remoteReceived.size() >= expect;
1:             }
1:         }));
1: 
1:         LOG.debug("Remote listener received " + remoteReceived.size() + " messages");
1: 
1:         local.stop();
1: 
1:         assertTrue("Remote transport never was disposed.", Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return remote.isDisposed();
1:             }
1:         }));
1:     }
1: 
1:     @Test(timeout=120000)
1:     public void TestTwoWayMessageThroughPutSync() throws Exception {
1: 
1:         long totalTimes = 0;
1:         final long executions = 20;
1: 
1:         for (int i = 0; i < 20; ++i) {
1:             totalTimes += doTestTwoWayMessageThroughPut(false);
1:         }
1: 
1:         LOG.info("Total time of one way sync send throughput test: " + (totalTimes/executions) + "ms");
1:     }
1: 
1:     @Test(timeout=120000)
1:     public void TestTwoWayMessageThroughPutAsnyc() throws Exception {
1: 
1:         long totalTimes = 0;
1:         final long executions = 50;
1: 
1:         for (int i = 0; i < executions; ++i) {
1:             totalTimes += doTestTwoWayMessageThroughPut(false);
1:         }
1: 
1:         LOG.info("Total time of one way async send throughput test: " + (totalTimes/executions) + "ms");
1:     }
1: 
1:     private long doTestTwoWayMessageThroughPut(boolean async) throws Exception {
1: 
1:         final VMTransport local = new VMTransport(new URI(location1));
1:         final VMTransport remote = new VMTransport(new URI(location2));
1: 
1:         final AtomicInteger sequenceId = new AtomicInteger();
1: 
1:         remote.setAsync(async);
1: 
1:         local.setPeer(remote);
1:         remote.setPeer(local);
1: 
1:         local.setTransportListener(new VMTestTransportListener(localReceived));
1:         remote.setTransportListener(new VMTestTransportListener(remoteReceived));
1: 
1:         final int messageCount = 200000;
1: 
1:         local.start();
1:         remote.start();
1: 
1:         long startTime = System.currentTimeMillis();
1: 
1:         Thread localSend = new Thread(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 for(int i = 0; i < messageCount; ++i) {
1:                     try {
1:                         local.oneway(new DummyCommand(sequenceId.incrementAndGet()));
1:                     } catch (Exception e) {
1:                     }
1:                 }
1: 
1:             }
1:         });
1: 
1:         Thread remoteSend = new Thread(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 for(int i = 0; i < messageCount; ++i) {
1:                     try {
1:                         remote.oneway(new DummyCommand(sequenceId.incrementAndGet()));
1:                     } catch (Exception e) {
1:                     }
1:                 }
1: 
1:             }
1:         });
1: 
1:         localSend.start();
1:         remoteSend.start();
1: 
1:         // Wait for both to finish and then check that each side go the correct amount
1:         localSend.join();
1:         remoteSend.join();
1: 
1:         long endTime = System.currentTimeMillis();
1: 
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return remoteReceived.size() == messageCount;
1:             }
1:         }));
1: 
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return localReceived.size() == messageCount;
1:             }
1:         }));
1: 
1:         LOG.debug("All messages sent,stop all");
1: 
1:         local.stop();
1:         remote.stop();
1: 
1:         localReceived.clear();
1:         remoteReceived.clear();
1: 
1:         return endTime - startTime;
1:     }
1: 
1:     @Test(timeout=120000)
1:     public void TestOneWayMessageThroughPutSync() throws Exception {
1: 
1:         long totalTimes = 0;
1:         final long executions = 30;
1: 
1:         for (int i = 0; i < executions; ++i) {
1:             totalTimes += doTestOneWayMessageThroughPut(false);
1:         }
1: 
1:         LOG.info("Total time of one way sync send throughput test: " + (totalTimes/executions) + "ms");
1:     }
1: 
1:     @Test(timeout=120000)
1:     public void TestOneWayMessageThroughPutAsnyc() throws Exception {
1: 
1:         long totalTimes = 0;
1:         final long executions = 20;
1: 
1:         for (int i = 0; i < 20; ++i) {
1:             totalTimes += doTestOneWayMessageThroughPut(true);
1:         }
1: 
1:         LOG.info("Total time of one way async send throughput test: " + (totalTimes/executions) + "ms");
1:     }
1: 
1:     private long doTestOneWayMessageThroughPut(boolean async) throws Exception {
1: 
1:         final VMTransport local = new VMTransport(new URI(location1));
1:         final VMTransport remote = new VMTransport(new URI(location2));
1: 
1:         final AtomicInteger sequenceId = new AtomicInteger();
1: 
1:         remote.setAsync(async);
1: 
1:         local.setPeer(remote);
1:         remote.setPeer(local);
1: 
1:         local.setTransportListener(new VMTestTransportListener(localReceived));
1:         remote.setTransportListener(new VMTestTransportListener(remoteReceived));
1: 
1:         final int messageCount = 100000;
1: 
1:         local.start();
1:         remote.start();
1: 
1:         long startTime = System.currentTimeMillis();
1: 
1:         Thread localSend = new Thread(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 for(int i = 0; i < messageCount; ++i) {
1:                     try {
1:                         local.oneway(new DummyCommand(sequenceId.incrementAndGet()));
1:                     } catch (Exception e) {
1:                     }
1:                 }
1: 
1:             }
1:         });
1: 
1:         localSend.start();
1: 
1:         // Wait for both to finish and then check that each side go the correct amount
1:         localSend.join();
1: 
1:         long endTime = System.currentTimeMillis();
1: 
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return remoteReceived.size() == messageCount;
1:             }
1:         }));
1: 
1:         LOG.debug("All messages sent,stop all");
1: 
1:         local.stop();
1:         remote.stop();
1: 
1:         localReceived.clear();
1:         remoteReceived.clear();
1: 
1:         return endTime - startTime;
1:     }
1: 
1: }
============================================================================