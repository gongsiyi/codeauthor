1:1b9f5f6: /**
1:1b9f5f6:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:1b9f5f6:  * contributor license agreements.  See the NOTICE file distributed with
1:1b9f5f6:  * this work for additional information regarding copyright ownership.
1:1b9f5f6:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:1b9f5f6:  * (the "License"); you may not use this file except in compliance with
1:1b9f5f6:  * the License.  You may obtain a copy of the License at
1:1b9f5f6:  *
1:1b9f5f6:  *      http://www.apache.org/licenses/LICENSE-2.0
1:1b9f5f6:  *
1:1b9f5f6:  * Unless required by applicable law or agreed to in writing, software
1:1b9f5f6:  * distributed under the License is distributed on an "AS IS" BASIS,
1:1b9f5f6:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:1b9f5f6:  * See the License for the specific language governing permissions and
1:1b9f5f6:  * limitations under the License.
1:1b9f5f6:  */
1:1b9f5f6: package org.apache.activemq.plugin;
1:61da1fa: 
1:9ef4259: import java.io.File;
1:9ef4259: import java.io.FileInputStream;
1:9ef4259: import java.io.FileOutputStream;
1:9ef4259: import java.io.IOException;
1:9ef4259: import java.io.ObjectInputStream;
1:9ef4259: import java.io.ObjectOutputStream;
1:9ef4259: import java.util.Collections;
1:9ef4259: import java.util.HashSet;
1:9ef4259: import java.util.Set;
1:9ef4259: import java.util.concurrent.ConcurrentHashMap;
1:9ef4259: import java.util.concurrent.ConcurrentMap;
1:278d29d: import java.util.regex.Matcher;
1:278d29d: import java.util.regex.Pattern;
1:9ef4259: 
1:9ef4259: import javax.management.JMException;
1:9ef4259: import javax.management.ObjectName;
1:9ef4259: 
1:61da1fa: import org.apache.activemq.advisory.AdvisorySupport;
1:1b9f5f6: import org.apache.activemq.broker.Broker;
1:1b9f5f6: import org.apache.activemq.broker.BrokerFilter;
1:61da1fa: import org.apache.activemq.broker.BrokerService;
1:1b9f5f6: import org.apache.activemq.broker.ConnectionContext;
1:61da1fa: import org.apache.activemq.broker.jmx.AnnotatedMBean;
1:61da1fa: import org.apache.activemq.broker.jmx.BrokerMBeanSupport;
1:61da1fa: import org.apache.activemq.broker.jmx.VirtualDestinationSelectorCacheView;
1:1b9f5f6: import org.apache.activemq.broker.region.Subscription;
1:1b9f5f6: import org.apache.activemq.command.ConsumerInfo;
1:1b9f5f6: import org.slf4j.Logger;
1:1b9f5f6: import org.slf4j.LoggerFactory;
1:61da1fa: 
1:1b9f5f6: /**
1:1b9f5f6:  * A plugin which allows the caching of the selector from a subscription queue.
1:1b9f5f6:  * <p/>
1:1b9f5f6:  * This stops the build-up of unwanted messages, especially when consumers may
1:1b9f5f6:  * disconnect from time to time when using virtual destinations.
1:1b9f5f6:  * <p/>
1:1b9f5f6:  * This is influenced by code snippets developed by Maciej Rakowicz
1:1b9f5f6:  *
1:5e05df1:  * Refer to:
1:5e05df1:  * https://issues.apache.org/activemq/browse/AMQ-3004
1:5e05df1:  * http://mail-archives.apache.org/mod_mbox/activemq-users/201011.mbox/%3C8A013711-2613-450A-A487-379E784AF1D6@homeaway.co.uk%3E
1:1b9f5f6:  */
1:1b9f5f6: public class SubQueueSelectorCacheBroker extends BrokerFilter implements Runnable {
1:1b9f5f6:     private static final Logger LOG = LoggerFactory.getLogger(SubQueueSelectorCacheBroker.class);
1:61da1fa:     public static final String MATCH_EVERYTHING = "TRUE";
1:afded92: 
1:1b9f5f6:     /**
1:1b9f5f6:      * The subscription's selector cache. We cache compiled expressions keyed
1:1b9f5f6:      * by the target destination.
1:1b9f5f6:      */
1:9ef4259:     private ConcurrentMap<String, Set<String>> subSelectorCache = new ConcurrentHashMap<String, Set<String>>();
13:1b9f5f6: 
1:1b9f5f6:     private final File persistFile;
1:61da1fa:     private boolean singleSelectorPerDestination = false;
1:61da1fa:     private boolean ignoreWildcardSelectors = false;
1:61da1fa:     private ObjectName objectName;
1:1b9f5f6: 
1:1b9f5f6:     private boolean running = true;
1:9ef4259:     private final Thread persistThread;
1:61da1fa:     private long persistInterval = MAX_PERSIST_INTERVAL;
1:61da1fa:     public static final long MAX_PERSIST_INTERVAL = 600000;
1:1b9f5f6:     private static final String SELECTOR_CACHE_PERSIST_THREAD_NAME = "SelectorCachePersistThread";
1:1b9f5f6: 
1:1b9f5f6:     /**
1:1b9f5f6:      * Constructor
1:1b9f5f6:      */
1:1b9f5f6:     public SubQueueSelectorCacheBroker(Broker next, final File persistFile) {
1:1b9f5f6:         super(next);
1:1b9f5f6:         this.persistFile = persistFile;
1:e1bbde7:         LOG.info("Using persisted selector cache from[{}]", persistFile);
1:1b9f5f6: 
1:1b9f5f6:         readCache();
1:1b9f5f6: 
1:1b9f5f6:         persistThread = new Thread(this, SELECTOR_CACHE_PERSIST_THREAD_NAME);
1:1b9f5f6:         persistThread.start();
1:61da1fa:         enableJmx();
1:61da1fa:     }
1:278d29d: 
1:61da1fa:     private void enableJmx() {
1:61da1fa:         BrokerService broker = getBrokerService();
1:61da1fa:         if (broker.isUseJmx()) {
1:61da1fa:             VirtualDestinationSelectorCacheView view = new VirtualDestinationSelectorCacheView(this);
1:61da1fa:             try {
1:61da1fa:                 objectName = BrokerMBeanSupport.createVirtualDestinationSelectorCacheName(broker.getBrokerObjectName(), "plugin", "virtualDestinationCache");
1:61da1fa:                 LOG.trace("virtualDestinationCacheSelector mbean name; " + objectName.toString());
1:61da1fa:                 AnnotatedMBean.registerMBean(broker.getManagementContext(), view, objectName);
1:61da1fa:             } catch (Exception e) {
1:61da1fa:                 LOG.warn("JMX is enabled, but when installing the VirtualDestinationSelectorCache, couldn't install the JMX mbeans. Continuing without installing the mbeans.");
1:61da1fa:             }
1:61da1fa:         }
4:1b9f5f6:     }
1:278d29d: 
1:1b9f5f6:     @Override
1:1b9f5f6:     public void stop() throws Exception {
1:1b9f5f6:         running = false;
1:1b9f5f6:         if (persistThread != null) {
1:1b9f5f6:             persistThread.interrupt();
1:1b9f5f6:             persistThread.join();
1:f3ecc29:         }
1:61da1fa:         unregisterMBeans();
1:61da1fa:     }
1:61da1fa: 
1:61da1fa:     private void unregisterMBeans() {
1:61da1fa:         BrokerService broker = getBrokerService();
1:61da1fa:         if (broker.isUseJmx() && this.objectName != null) {
1:61da1fa:             try {
1:61da1fa:                 broker.getManagementContext().unregisterMBean(objectName);
1:61da1fa:             } catch (JMException e) {
1:61da1fa:                 LOG.warn("Trying uninstall VirtualDestinationSelectorCache; couldn't uninstall mbeans, continuting...");
1:61da1fa:             }
1:61da1fa:         }
1:61cbe46:     }
1:61cbe46: 
1:1b9f5f6:     @Override
1:1b9f5f6:     public Subscription addConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
1:f3ecc29:         // don't track selectors for advisory topics or temp destinations
1:f3ecc29:         if (!AdvisorySupport.isAdvisoryTopic(info.getDestination()) && !info.getDestination().isTemporary()) {
1:61da1fa:             String destinationName = info.getDestination().getQualifiedName();
1:61da1fa:             LOG.debug("Caching consumer selector [{}] on  '{}'", info.getSelector(), destinationName);
1:61cbe46: 
1:61da1fa:             String selector = info.getSelector() == null ? MATCH_EVERYTHING : info.getSelector();
1:61da1fa: 
1:61da1fa:             if (!(ignoreWildcardSelectors && hasWildcards(selector))) {
1:61da1fa: 
1:61da1fa:                 Set<String> selectors = subSelectorCache.get(destinationName);
1:61da1fa:                 if (selectors == null) {
1:61da1fa:                     selectors = Collections.synchronizedSet(new HashSet<String>());
1:61da1fa:                 } else if (singleSelectorPerDestination && !MATCH_EVERYTHING.equals(selector)) {
1:61da1fa:                     // in this case, we allow only ONE selector. But we don't count the catch-all "null/TRUE" selector
1:61da1fa:                     // here, we always allow that one. But only one true selector.
1:61da1fa:                     boolean containsMatchEverything = selectors.contains(MATCH_EVERYTHING);
1:61da1fa:                     selectors.clear();
1:61da1fa: 
1:61da1fa:                     // put back the MATCH_EVERYTHING selector
1:61da1fa:                     if (containsMatchEverything) {
1:61da1fa:                         selectors.add(MATCH_EVERYTHING);
1:61da1fa:                     }
1:61da1fa:                 }
1:61da1fa: 
1:61da1fa:                 LOG.debug("adding new selector: into cache " + selector);
1:61da1fa:                 selectors.add(selector);
1:61da1fa:                 LOG.debug("current selectors in cache: " + selectors);
1:61da1fa:                 subSelectorCache.put(destinationName, selectors);
1:61da1fa:             }
1:afded92:         }
1:f3ecc29: 
1:1b9f5f6:         return super.addConsumer(context, info);
1:61da1fa:     }
1:278d29d: 
1:278d29d:     static boolean hasWildcards(String selector) {
1:33dded1:         return WildcardFinder.hasWildcards(selector);
1:1b9f5f6:     }
1:61da1fa: 
1:61da1fa:     @Override
1:61da1fa:     public void removeConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
1:48ba714:         if (!AdvisorySupport.isAdvisoryTopic(info.getDestination()) && !info.getDestination().isTemporary()) {
1:61da1fa:             if (singleSelectorPerDestination) {
1:61da1fa:                 String destinationName = info.getDestination().getQualifiedName();
1:61da1fa:                 Set<String> selectors = subSelectorCache.get(destinationName);
1:61da1fa:                 if (info.getSelector() == null && selectors.size() > 1) {
1:61da1fa:                     boolean removed = selectors.remove(MATCH_EVERYTHING);
1:61da1fa:                     LOG.debug("A non-selector consumer has dropped. Removing the catchall matching pattern 'TRUE'. Successful? " + removed);
1:61da1fa:                 }
1:61da1fa:             }
1:61da1fa: 
1:61da1fa:         }
1:61da1fa:         super.removeConsumer(context, info);
1:61da1fa:     }
1:61da1fa: 
1:f3ecc29:     @SuppressWarnings("unchecked")
1:1b9f5f6:     private void readCache() {
1:1b9f5f6:         if (persistFile != null && persistFile.exists()) {
2:1b9f5f6:             try {
1:48ba714:                 try (FileInputStream fis = new FileInputStream(persistFile);) {
1:1b9f5f6:                     ObjectInputStream in = new ObjectInputStream(fis);
1:1b9f5f6:                     try {
1:afded92:                         subSelectorCache = (ConcurrentHashMap<String, Set<String>>) in.readObject();
1:1b9f5f6:                     } catch (ClassNotFoundException ex) {
1:1b9f5f6:                         LOG.error("Invalid selector cache data found. Please remove file.", ex);
2:1b9f5f6:                     } finally {
1:1b9f5f6:                         in.close();
1:f3ecc29:                     }
1:f3ecc29:                 }
1:1b9f5f6:             } catch (IOException ex) {
1:1b9f5f6:                 LOG.error("Unable to read persisted selector cache...it will be ignored!", ex);
1:f3ecc29:             }
1:f3ecc29:         }
1:1b9f5f6:     }
1:61da1fa: 
1:1b9f5f6:     /**
1:1b9f5f6:      * Persist the selector cache.
1:1b9f5f6:      */
1:1b9f5f6:     private void persistCache() {
1:1b9f5f6:         LOG.debug("Persisting selector cache....");
1:1b9f5f6:         try {
1:1b9f5f6:             FileOutputStream fos = new FileOutputStream(persistFile);
1:1b9f5f6:             try {
1:1b9f5f6:                 ObjectOutputStream out = new ObjectOutputStream(fos);
1:1b9f5f6:                 try {
1:1b9f5f6:                     out.writeObject(subSelectorCache);
1:1b9f5f6:                 } finally {
1:1b9f5f6:                     out.flush();
1:1b9f5f6:                     out.close();
1:f3ecc29:                 }
1:1b9f5f6:             } catch (IOException ex) {
1:1b9f5f6:                 LOG.error("Unable to persist selector cache", ex);
1:1b9f5f6:             } finally {
1:1b9f5f6:                 fos.close();
1:f3ecc29:             }
1:1b9f5f6:         } catch (IOException ex) {
1:e1bbde7:             LOG.error("Unable to access file[{}]", persistFile, ex);
1:f3ecc29:         }
1:1b9f5f6:     }
1:61da1fa: 
1:1b9f5f6:     /**
1:1b9f5f6:      * @return The JMS selector for the specified {@code destination}
1:1b9f5f6:      */
1:afded92:     public Set<String> getSelector(final String destination) {
1:1b9f5f6:         return subSelectorCache.get(destination);
1:1b9f5f6:     }
1:61da1fa: 
1:1b9f5f6:     /**
1:1b9f5f6:      * Persist the selector cache every {@code MAX_PERSIST_INTERVAL}ms.
1:1b9f5f6:      *
1:1b9f5f6:      * @see java.lang.Runnable#run()
1:1b9f5f6:      */
1:9ef4259:     @Override
1:1b9f5f6:     public void run() {
1:1b9f5f6:         while (running) {
1:1b9f5f6:             try {
1:61da1fa:                 Thread.sleep(persistInterval);
1:1b9f5f6:             } catch (InterruptedException ex) {
1:f3ecc29:             }
1:61cbe46: 
1:1b9f5f6:             persistCache();
1:61da1fa:         }
1:1b9f5f6:     }
1:61da1fa: 
1:61da1fa:     public boolean isSingleSelectorPerDestination() {
1:61da1fa:         return singleSelectorPerDestination;
1:61da1fa:     }
1:61da1fa: 
1:61da1fa:     public void setSingleSelectorPerDestination(boolean singleSelectorPerDestination) {
1:61da1fa:         this.singleSelectorPerDestination = singleSelectorPerDestination;
1:61da1fa:     }
1:61da1fa: 
1:f3ecc29:     @SuppressWarnings("unchecked")
1:61da1fa:     public Set<String> getSelectorsForDestination(String destinationName) {
1:61da1fa:         if (subSelectorCache.containsKey(destinationName)) {
1:61da1fa:             return new HashSet<String>(subSelectorCache.get(destinationName));
1:61da1fa:         }
1:61da1fa: 
1:61da1fa:         return Collections.EMPTY_SET;
1:61da1fa:     }
1:61da1fa: 
1:61da1fa:     public long getPersistInterval() {
1:61da1fa:         return persistInterval;
1:61da1fa:     }
1:61da1fa: 
1:61da1fa:     public void setPersistInterval(long persistInterval) {
1:61da1fa:         this.persistInterval = persistInterval;
1:61da1fa:     }
1:61da1fa: 
1:61da1fa:     public boolean deleteSelectorForDestination(String destinationName, String selector) {
1:61da1fa:         if (subSelectorCache.containsKey(destinationName)) {
1:61da1fa:             Set<String> cachedSelectors = subSelectorCache.get(destinationName);
1:61da1fa:             return cachedSelectors.remove(selector);
1:61da1fa:         }
1:61da1fa: 
1:61da1fa:         return false;
1:61da1fa:     }
1:61da1fa: 
1:61da1fa:     public boolean deleteAllSelectorsForDestination(String destinationName) {
1:61da1fa:         if (subSelectorCache.containsKey(destinationName)) {
1:61da1fa:             Set<String> cachedSelectors = subSelectorCache.get(destinationName);
1:61da1fa:             cachedSelectors.clear();
1:61da1fa:         }
1:61da1fa:         return true;
1:61da1fa:     }
1:61da1fa: 
1:61da1fa:     public boolean isIgnoreWildcardSelectors() {
1:61da1fa:         return ignoreWildcardSelectors;
1:61da1fa:     }
1:61da1fa: 
1:61da1fa:     public void setIgnoreWildcardSelectors(boolean ignoreWildcardSelectors) {
1:61da1fa:         this.ignoreWildcardSelectors = ignoreWildcardSelectors;
1:278d29d:     }
1:278d29d: 
1:278d29d:     // find wildcards inside like operator arguments
1:278d29d:     static class WildcardFinder {
1:278d29d: 
1:278d29d:         private static final Pattern LIKE_PATTERN=Pattern.compile(
1:278d29d:                 "\\bLIKE\\s+'(?<like>([^']|'')+)'(\\s+ESCAPE\\s+'(?<escape>.)')?",
1:278d29d:                 Pattern.CASE_INSENSITIVE);
1:278d29d: 
1:278d29d:         private static final String REGEX_SPECIAL = ".+?*(){}[]\\-";
1:278d29d: 
1:33dded1:         private static String getLike(final Matcher matcher) {
1:278d29d:             return matcher.group("like");
1:278d29d:         }
1:278d29d: 
1:33dded1:         private static boolean hasLikeOperator(final Matcher matcher) {
1:33dded1:             return matcher.find();
1:33dded1:         }
1:33dded1: 
1:33dded1:         private static String getEscape(final Matcher matcher) {
1:278d29d:             String escapeChar = matcher.group("escape");
1:278d29d:             if (escapeChar == null) {
1:278d29d:                 return null;
1:278d29d:             } else if (REGEX_SPECIAL.contains(escapeChar)) {
1:278d29d:                 escapeChar = "\\"+escapeChar;
1:278d29d:             }
1:278d29d:             return escapeChar;
1:278d29d:         }
1:278d29d: 
1:33dded1:         private static boolean hasWildcardInCurrentMatch(final Matcher matcher) {
1:278d29d:             String wildcards = "[_%]";
1:33dded1:             if (getEscape(matcher) != null) {
1:33dded1:                 wildcards = "(^|[^" + getEscape(matcher) + "])" + wildcards;
1:278d29d:             }
1:33dded1:             return Pattern.compile(wildcards).matcher(getLike(matcher)).find();
1:278d29d:         }
1:278d29d: 
1:33dded1:         public static boolean hasWildcards(String selector) {
1:33dded1:             Matcher matcher = LIKE_PATTERN.matcher(selector);
1:33dded1: 
1:33dded1:             while(hasLikeOperator(matcher)) {
1:48ba714:                 if (hasWildcardInCurrentMatch(matcher)) {
1:278d29d:                     return true;
1:48ba714:                 }
1:278d29d:             }
1:278d29d:             return false;
1:278d29d:         }
1:278d29d:     }
1:278d29d: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:48ba714
/////////////////////////////////////////////////////////////////////////
1:         if (!AdvisorySupport.isAdvisoryTopic(info.getDestination()) && !info.getDestination().isTemporary()) {
/////////////////////////////////////////////////////////////////////////
1:                 try (FileInputStream fis = new FileInputStream(persistFile);) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 if (hasWildcardInCurrentMatch(matcher)) {
1:                 }
commit:f3ecc29
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         }
/////////////////////////////////////////////////////////////////////////
1:         // don't track selectors for advisory topics or temp destinations
1:         if (!AdvisorySupport.isAdvisoryTopic(info.getDestination()) && !info.getDestination().isTemporary()) {
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("unchecked")
/////////////////////////////////////////////////////////////////////////
1:                     }
1:                 }
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:                 }
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:             }
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("unchecked")
/////////////////////////////////////////////////////////////////////////
commit:5e05df1
/////////////////////////////////////////////////////////////////////////
1:  * Refer to:
1:  * https://issues.apache.org/activemq/browse/AMQ-3004
1:  * http://mail-archives.apache.org/mod_mbox/activemq-users/201011.mbox/%3C8A013711-2613-450A-A487-379E784AF1D6@homeaway.co.uk%3E
commit:9ef4259
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
1: import java.io.FileInputStream;
1: import java.io.FileOutputStream;
1: import java.io.IOException;
1: import java.io.ObjectInputStream;
1: import java.io.ObjectOutputStream;
1: import java.util.Collections;
1: import java.util.HashSet;
1: import java.util.Set;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.ConcurrentMap;
1: 
1: import javax.management.JMException;
1: import javax.management.ObjectName;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private ConcurrentMap<String, Set<String>> subSelectorCache = new ConcurrentHashMap<String, Set<String>>();
/////////////////////////////////////////////////////////////////////////
1:     private final Thread persistThread;
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("Using persisted selector cache from[{}]", persistFile);
/////////////////////////////////////////////////////////////////////////
0:         LOG.debug("Caching consumer selector [{}] on a {}", info.getSelector(), info.getDestination().getQualifiedName());
/////////////////////////////////////////////////////////////////////////
1:             LOG.error("Unable to access file[{}]", persistFile, ex);
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:33dded1
/////////////////////////////////////////////////////////////////////////
1:         return WildcardFinder.hasWildcards(selector);
/////////////////////////////////////////////////////////////////////////
1:         private static String getLike(final Matcher matcher) {
1:         private static boolean hasLikeOperator(final Matcher matcher) {
1:             return matcher.find();
1:         }
1: 
1:         private static String getEscape(final Matcher matcher) {
/////////////////////////////////////////////////////////////////////////
1:         private static boolean hasWildcardInCurrentMatch(final Matcher matcher) {
1:             if (getEscape(matcher) != null) {
1:                 wildcards = "(^|[^" + getEscape(matcher) + "])" + wildcards;
1:             return Pattern.compile(wildcards).matcher(getLike(matcher)).find();
1:         public static boolean hasWildcards(String selector) {
1:             Matcher matcher = LIKE_PATTERN.matcher(selector);
1: 
1:             while(hasLikeOperator(matcher)) {
0:                 if (hasWildcardInCurrentMatch(matcher))
author:Patrik Dudits
-------------------------------------------------------------------------------
commit:278d29d
/////////////////////////////////////////////////////////////////////////
1: import java.util.regex.Matcher;
1: import java.util.regex.Pattern;
/////////////////////////////////////////////////////////////////////////
1: 
1:     static boolean hasWildcards(String selector) {
0:         return new WildcardFinder(selector).hasWildcards();
/////////////////////////////////////////////////////////////////////////
1: 
1:     // find wildcards inside like operator arguments
1:     static class WildcardFinder {
1: 
1:         private static final Pattern LIKE_PATTERN=Pattern.compile(
1:                 "\\bLIKE\\s+'(?<like>([^']|'')+)'(\\s+ESCAPE\\s+'(?<escape>.)')?",
1:                 Pattern.CASE_INSENSITIVE);
1: 
1:         private static final String REGEX_SPECIAL = ".+?*(){}[]\\-";
0:         private final Matcher matcher;
1: 
0:         WildcardFinder(String selector) {
0:             this.matcher = LIKE_PATTERN.matcher(selector);
1:         }
1: 
0:         private String getLike() {
1:             return matcher.group("like");
1:         }
1: 
0:         private String getEscape() {
1:             String escapeChar = matcher.group("escape");
1:             if (escapeChar == null) {
1:                 return null;
1:             } else if (REGEX_SPECIAL.contains(escapeChar)) {
1:                 escapeChar = "\\"+escapeChar;
1:             }
1:             return escapeChar;
1:         }
1: 
0:         private boolean hasLikeOperator() {
0:             return matcher.find();
1:         }
1: 
0:         boolean hasWildcardInCurrentMatch() {
1:             String wildcards = "[_%]";
0:             if (getEscape() != null) {
0:                 wildcards = "(^|[^" + getEscape() + "])" + wildcards;
1:             }
0:             return Pattern.compile(wildcards).matcher(getLike()).find();
1:         }
1: 
0:         public boolean hasWildcards() {
0:             while(hasLikeOperator()) {
0:                 if (hasWildcardInCurrentMatch())
1:                     return true;
1:             }
1:             return false;
1:         }
1:     }
author:Christian Posta
-------------------------------------------------------------------------------
commit:61da1fa
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.advisory.AdvisorySupport;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.jmx.AnnotatedMBean;
1: import org.apache.activemq.broker.jmx.BrokerMBeanSupport;
1: import org.apache.activemq.broker.jmx.VirtualDestinationSelectorCacheView;
0: import javax.management.JMException;
0: import javax.management.ObjectName;
/////////////////////////////////////////////////////////////////////////
1:     public static final String MATCH_EVERYTHING = "TRUE";
/////////////////////////////////////////////////////////////////////////
1:     private boolean singleSelectorPerDestination = false;
1:     private boolean ignoreWildcardSelectors = false;
1:     private ObjectName objectName;
1:     private long persistInterval = MAX_PERSIST_INTERVAL;
1:     public static final long MAX_PERSIST_INTERVAL = 600000;
/////////////////////////////////////////////////////////////////////////
1:         enableJmx();
1:     }
1: 
1:     private void enableJmx() {
1:         BrokerService broker = getBrokerService();
1:         if (broker.isUseJmx()) {
1:             VirtualDestinationSelectorCacheView view = new VirtualDestinationSelectorCacheView(this);
1:             try {
1:                 objectName = BrokerMBeanSupport.createVirtualDestinationSelectorCacheName(broker.getBrokerObjectName(), "plugin", "virtualDestinationCache");
1:                 LOG.trace("virtualDestinationCacheSelector mbean name; " + objectName.toString());
1:                 AnnotatedMBean.registerMBean(broker.getManagementContext(), view, objectName);
1:             } catch (Exception e) {
1:                 LOG.warn("JMX is enabled, but when installing the VirtualDestinationSelectorCache, couldn't install the JMX mbeans. Continuing without installing the mbeans.");
1:             }
1: 
1:         }
/////////////////////////////////////////////////////////////////////////
1:         unregisterMBeans();
1:     }
1: 
1:     private void unregisterMBeans() {
1:         BrokerService broker = getBrokerService();
1:         if (broker.isUseJmx() && this.objectName != null) {
1:             try {
1:                 broker.getManagementContext().unregisterMBean(objectName);
1:             } catch (JMException e) {
1:                 LOG.warn("Trying uninstall VirtualDestinationSelectorCache; couldn't uninstall mbeans, continuting...");
1:             }
1:         }
0:         // don't track selectors for advisory topics
0:         if (!AdvisorySupport.isAdvisoryTopic(info.getDestination())) {
1:             String destinationName = info.getDestination().getQualifiedName();
1:             LOG.debug("Caching consumer selector [{}] on  '{}'", info.getSelector(), destinationName);
1:             String selector = info.getSelector() == null ? MATCH_EVERYTHING : info.getSelector();
1: 
1:             if (!(ignoreWildcardSelectors && hasWildcards(selector))) {
1: 
1:                 Set<String> selectors = subSelectorCache.get(destinationName);
1:                 if (selectors == null) {
1:                     selectors = Collections.synchronizedSet(new HashSet<String>());
1:                 } else if (singleSelectorPerDestination && !MATCH_EVERYTHING.equals(selector)) {
1:                     // in this case, we allow only ONE selector. But we don't count the catch-all "null/TRUE" selector
1:                     // here, we always allow that one. But only one true selector.
1:                     boolean containsMatchEverything = selectors.contains(MATCH_EVERYTHING);
1:                     selectors.clear();
1: 
1:                     // put back the MATCH_EVERYTHING selector
1:                     if (containsMatchEverything) {
1:                         selectors.add(MATCH_EVERYTHING);
1:                     }
1:                 }
1: 
1:                 LOG.debug("adding new selector: into cache " + selector);
1:                 selectors.add(selector);
1:                 LOG.debug("current selectors in cache: " + selectors);
1:                 subSelectorCache.put(destinationName, selectors);
1:             }
1: 
1: 
0:     // trivial check for SQL92/selector wildcards
0:     private boolean hasWildcards(String selector) {
0:         return selector.contains("%") || selector.contains("_");
1:     }
1: 
1:     @Override
1:     public void removeConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
0:         if (!AdvisorySupport.isAdvisoryTopic(info.getDestination())) {
1: 
1:             if (singleSelectorPerDestination) {
1:                 String destinationName = info.getDestination().getQualifiedName();
1:                 Set<String> selectors = subSelectorCache.get(destinationName);
1:                 if (info.getSelector() == null && selectors.size() > 1) {
1:                     boolean removed = selectors.remove(MATCH_EVERYTHING);
1:                     LOG.debug("A non-selector consumer has dropped. Removing the catchall matching pattern 'TRUE'. Successful? " + removed);
1:                 }
1:             }
1: 
1:         }
1:         super.removeConsumer(context, info);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 Thread.sleep(persistInterval);
1: 
1:     public boolean isSingleSelectorPerDestination() {
1:         return singleSelectorPerDestination;
1:     }
1: 
1:     public void setSingleSelectorPerDestination(boolean singleSelectorPerDestination) {
1:         this.singleSelectorPerDestination = singleSelectorPerDestination;
1:     }
1: 
1:     public Set<String> getSelectorsForDestination(String destinationName) {
1:         if (subSelectorCache.containsKey(destinationName)) {
1:             return new HashSet<String>(subSelectorCache.get(destinationName));
1:         }
1: 
1:         return Collections.EMPTY_SET;
1:     }
1: 
1:     public long getPersistInterval() {
1:         return persistInterval;
1:     }
1: 
1:     public void setPersistInterval(long persistInterval) {
1:         this.persistInterval = persistInterval;
1:     }
1: 
1:     public boolean deleteSelectorForDestination(String destinationName, String selector) {
1:         if (subSelectorCache.containsKey(destinationName)) {
1:             Set<String> cachedSelectors = subSelectorCache.get(destinationName);
1:             return cachedSelectors.remove(selector);
1:         }
1: 
1:         return false;
1:     }
1: 
1:     public boolean deleteAllSelectorsForDestination(String destinationName) {
1:         if (subSelectorCache.containsKey(destinationName)) {
1:             Set<String> cachedSelectors = subSelectorCache.get(destinationName);
1:             cachedSelectors.clear();
1:         }
1:         return true;
1:     }
1: 
1:     public boolean isIgnoreWildcardSelectors() {
1:         return ignoreWildcardSelectors;
1:     }
1: 
1:     public void setIgnoreWildcardSelectors(boolean ignoreWildcardSelectors) {
1:         this.ignoreWildcardSelectors = ignoreWildcardSelectors;
1:     }
author:Kevin Earls
-------------------------------------------------------------------------------
commit:afded92
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import java.io.File;
0: import java.io.FileInputStream;
0: import java.io.FileOutputStream;
0: import java.io.IOException;
0: import java.io.ObjectInputStream;
0: import java.io.ObjectOutputStream;
0: import java.util.Collections;
0: import java.util.HashSet;
0: import java.util.Set;
0: import java.util.concurrent.ConcurrentHashMap;
1: 
/////////////////////////////////////////////////////////////////////////
0:     private ConcurrentHashMap<String, Set<String>> subSelectorCache = new ConcurrentHashMap<String, Set<String>>();
/////////////////////////////////////////////////////////////////////////
0:         String destinationName = info.getDestination().getQualifiedName();
0:         LOG.debug("Caching consumer selector [{}] on a {}", info.getSelector(), destinationName);
/////////////////////////////////////////////////////////////////////////
0:         Set<String> selectors = subSelectorCache.get(destinationName);
0:         if (selectors == null) {
0:             selectors = Collections.synchronizedSet(new HashSet<String>());
1:         }
0:         selectors.add(selector);
0:         subSelectorCache.put(destinationName, selectors);
/////////////////////////////////////////////////////////////////////////
1:                         subSelectorCache = (ConcurrentHashMap<String, Set<String>>) in.readObject();
/////////////////////////////////////////////////////////////////////////
1:     public Set<String> getSelector(final String destination) {
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:61cbe46
/////////////////////////////////////////////////////////////////////////
0:         String selector = info.getSelector();
1: 
0:         // As ConcurrentHashMap doesn't support null values, use always true expression
0:         if (selector == null) {
0:             selector = "TRUE";
1:         }
1: 
0:         subSelectorCache.put(info.getDestination().getQualifiedName(), selector);
1: 
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
author:Robert Davies
-------------------------------------------------------------------------------
commit:1b9f5f6
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.plugin;
1: 
0: import java.io.File;
0: import java.io.FileInputStream;
0: import java.io.FileOutputStream;
0: import java.io.IOException;
0: import java.io.ObjectInputStream;
0: import java.io.ObjectOutputStream;
0: import java.util.concurrent.ConcurrentHashMap;
1: 
1: import org.apache.activemq.broker.Broker;
1: import org.apache.activemq.broker.BrokerFilter;
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.broker.region.Subscription;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * A plugin which allows the caching of the selector from a subscription queue.
1:  * <p/>
1:  * This stops the build-up of unwanted messages, especially when consumers may
1:  * disconnect from time to time when using virtual destinations.
1:  * <p/>
1:  * This is influenced by code snippets developed by Maciej Rakowicz
1:  *
0:  * @author Roelof Naude roelof(dot)naude(at)gmail.com
0:  * @see https://issues.apache.org/activemq/browse/AMQ-3004
0:  * @see http://mail-archives.apache.org/mod_mbox/activemq-users/201011.mbox/%3C8A013711-2613-450A-A487-379E784AF1D6@homeaway.co.uk%3E
1:  */
1: public class SubQueueSelectorCacheBroker extends BrokerFilter implements Runnable {
1:     private static final Logger LOG = LoggerFactory.getLogger(SubQueueSelectorCacheBroker.class);
1: 
1:     /**
1:      * The subscription's selector cache. We cache compiled expressions keyed
1:      * by the target destination.
1:      */
0:     private ConcurrentHashMap<String, String> subSelectorCache = new ConcurrentHashMap<String, String>();
1: 
1:     private final File persistFile;
1: 
1:     private boolean running = true;
0:     private Thread persistThread;
0:     private static final long MAX_PERSIST_INTERVAL = 600000;
1:     private static final String SELECTOR_CACHE_PERSIST_THREAD_NAME = "SelectorCachePersistThread";
1: 
1:     /**
1:      * Constructor
1:      */
1:     public SubQueueSelectorCacheBroker(Broker next, final File persistFile) {
1:         super(next);
1:         this.persistFile = persistFile;
0:         LOG.info("Using persisted selector cache from[" + persistFile + "]");
1: 
1:         readCache();
1: 
1:         persistThread = new Thread(this, SELECTOR_CACHE_PERSIST_THREAD_NAME);
1:         persistThread.start();
1:     }
1: 
1:     @Override
1:     public void stop() throws Exception {
1:         running = false;
1:         if (persistThread != null) {
1:             persistThread.interrupt();
1:             persistThread.join();
0:         } //if
1:     }
1: 
1:     @Override
1:     public Subscription addConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
0:         LOG.debug("Caching consumer selector [" + info.getSelector() + "] on a " + info.getDestination().getQualifiedName());
0:         if (info.getSelector() != null) {
0:             subSelectorCache.put(info.getDestination().getQualifiedName(), info.getSelector());
0:         } //if
1:         return super.addConsumer(context, info);
1:     }
1: 
1:     private void readCache() {
1:         if (persistFile != null && persistFile.exists()) {
1:             try {
0:                 FileInputStream fis = new FileInputStream(persistFile);
1:                 try {
1:                     ObjectInputStream in = new ObjectInputStream(fis);
1:                     try {
0:                         subSelectorCache = (ConcurrentHashMap<String, String>) in.readObject();
1:                     } catch (ClassNotFoundException ex) {
1:                         LOG.error("Invalid selector cache data found. Please remove file.", ex);
1:                     } finally {
1:                         in.close();
0:                     } //try
1:                 } finally {
0:                     fis.close();
0:                 } //try
1:             } catch (IOException ex) {
1:                 LOG.error("Unable to read persisted selector cache...it will be ignored!", ex);
0:             } //try
0:         } //if
1:     }
1: 
1:     /**
1:      * Persist the selector cache.
1:      */
1:     private void persistCache() {
1:         LOG.debug("Persisting selector cache....");
1:         try {
1:             FileOutputStream fos = new FileOutputStream(persistFile);
1:             try {
1:                 ObjectOutputStream out = new ObjectOutputStream(fos);
1:                 try {
1:                     out.writeObject(subSelectorCache);
1:                 } finally {
1:                     out.flush();
1:                     out.close();
0:                 } //try
1:             } catch (IOException ex) {
1:                 LOG.error("Unable to persist selector cache", ex);
1:             } finally {
1:                 fos.close();
0:             } //try
1:         } catch (IOException ex) {
0:             LOG.error("Unable to access file[" + persistFile + "]", ex);
0:         } //try
1:     }
1: 
1:     /**
1:      * @return The JMS selector for the specified {@code destination}
1:      */
0:     public String getSelector(final String destination) {
1:         return subSelectorCache.get(destination);
1:     }
1: 
1:     /**
1:      * Persist the selector cache every {@code MAX_PERSIST_INTERVAL}ms.
1:      *
1:      * @see java.lang.Runnable#run()
1:      */
1:     public void run() {
1:         while (running) {
1:             try {
0:                 Thread.sleep(MAX_PERSIST_INTERVAL);
1:             } catch (InterruptedException ex) {
0:             } //try
1: 
1:             persistCache();
1:         }
1:     }
1: }
1: 
============================================================================