1:e11ece1: /**
1:e11ece1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:e11ece1:  * contributor license agreements.  See the NOTICE file distributed with
1:e11ece1:  * this work for additional information regarding copyright ownership.
1:e11ece1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:e11ece1:  * (the "License"); you may not use this file except in compliance with
1:e11ece1:  * the License.  You may obtain a copy of the License at
1:e11ece1:  *
1:e11ece1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:e11ece1:  *
1:e11ece1:  * Unless required by applicable law or agreed to in writing, software
1:e11ece1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:e11ece1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:e11ece1:  * See the License for the specific language governing permissions and
1:e11ece1:  * limitations under the License.
1:e11ece1:  */
1:1aab71b: package org.apache.activemq.store.kahadb.disk.index;
1:e11ece1: 
1:e11ece1: import java.io.IOException;
1:0bbb735: import java.lang.ref.WeakReference;
1:e11ece1: import java.util.Iterator;
1:e11ece1: import java.util.Map;
1:734fb7d: import java.util.Map.Entry;
1:e11ece1: import java.util.concurrent.atomic.AtomicBoolean;
1:2b10259: import java.util.concurrent.atomic.AtomicLong;
1:e11ece1: 
1:1aab71b: import org.apache.activemq.store.kahadb.disk.index.ListNode.ListIterator;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.page.Page;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.page.PageFile;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.page.Transaction;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.util.Marshaller;
1:e11ece1: import org.slf4j.Logger;
1:e11ece1: import org.slf4j.LoggerFactory;
1:e11ece1: 
1:e11ece1: public class ListIndex<Key,Value> implements Index<Key,Value> {
1:e11ece1: 
1:e11ece1:     private static final Logger LOG = LoggerFactory.getLogger(ListIndex.class);
1:bf59b7d:     public  final static long NOT_SET = -1;
1:e11ece1:     protected PageFile pageFile;
1:e11ece1:     protected long headPageId;
1:e11ece1:     protected long tailPageId;
1:2b10259:     private AtomicLong size = new AtomicLong(0);
1:e11ece1: 
1:e11ece1:     protected AtomicBoolean loaded = new AtomicBoolean();
1:e11ece1: 
1:bf59b7d:     private ListNode.NodeMarshaller<Key, Value> marshaller;
1:e11ece1:     private Marshaller<Key> keyMarshaller;
1:e11ece1:     private Marshaller<Value> valueMarshaller;
1:e11ece1: 
1:2b10259:     public ListIndex() {
1:2b10259:     }
1:2b10259: 
1:2b10259:     public ListIndex(PageFile pageFile, long headPageId) {
1:e11ece1:         this.pageFile = pageFile;
1:bf59b7d:         setHeadPageId(headPageId);
1:e11ece1:     }
1:e11ece1: 
1:82e3be3:     @SuppressWarnings("rawtypes")
1:82e3be3:     public ListIndex(PageFile pageFile, Page page) {
1:82e3be3:         this(pageFile, page.getPageId());
1:0bbb735:     }
1:e11ece1: 
1:734fb7d:     @Override
1:e11ece1:     synchronized public void load(Transaction tx) throws IOException {
1:e11ece1:         if (loaded.compareAndSet(false, true)) {
1:e11ece1:             LOG.debug("loading");
1:e11ece1:             if( keyMarshaller == null ) {
1:e11ece1:                 throw new IllegalArgumentException("The key marshaller must be set before loading the ListIndex");
1:e11ece1:             }
1:e11ece1:             if( valueMarshaller == null ) {
1:e11ece1:                 throw new IllegalArgumentException("The value marshaller must be set before loading the ListIndex");
1:e11ece1:             }
1:bf59b7d: 
1:bf59b7d:             marshaller = new ListNode.NodeMarshaller<Key, Value>(keyMarshaller, valueMarshaller);
1:bf59b7d:             final Page<ListNode<Key,Value>> p = tx.load(getHeadPageId(), null);
1:e11ece1:             if( p.getType() == Page.PAGE_FREE_TYPE ) {
1:e11ece1:                  // Need to initialize it..
1:2b10259:                 ListNode<Key, Value> root = createNode(p);
1:e11ece1:                 storeNode(tx, root, true);
1:bf59b7d:                 setHeadPageId(p.getPageId());
1:bf59b7d:                 setTailPageId(getHeadPageId());
1:e11ece1:             } else {
1:bf59b7d:                 ListNode<Key, Value> node = loadNode(tx, getHeadPageId());
1:bf59b7d:                 setTailPageId(getHeadPageId());
1:2b10259:                 size.addAndGet(node.size(tx));
1:734fb7d:                 onLoad(node, tx);
1:bf59b7d:                 while (node.getNext() != NOT_SET ) {
1:2b10259:                     node = loadNode(tx, node.getNext());
1:2b10259:                     size.addAndGet(node.size(tx));
1:734fb7d:                     onLoad(node, tx);
1:bf59b7d:                     setTailPageId(node.getPageId());
1:e11ece1:                 }
1:e11ece1:             }
1:e11ece1:         }
1:e11ece1:     }
1:e11ece1: 
1:734fb7d:     protected void onLoad(ListNode<Key, Value> node, Transaction tx) {
1:734fb7d: 
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     @Override
1:e11ece1:     synchronized public void unload(Transaction tx) {
1:e11ece1:         if (loaded.compareAndSet(true, false)) {
1:e11ece1:         }
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     protected ListNode<Key,Value> getHead(Transaction tx) throws IOException {
1:bf59b7d:         return loadNode(tx, getHeadPageId());
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     protected ListNode<Key,Value> getTail(Transaction tx) throws IOException {
1:bf59b7d:         return loadNode(tx, getTailPageId());
1:e11ece1:     }
1:e11ece1: 
1:734fb7d:     @Override
1:e11ece1:     synchronized public boolean containsKey(Transaction tx, Key key) throws IOException {
1:e11ece1:         assertLoaded();
1:e11ece1: 
1:334ade2:         if (size.get() == 0) {
1:334ade2:             return false;
1:e11ece1:         }
1:334ade2: 
2:e11ece1:         for (Iterator<Map.Entry<Key,Value>> iterator = iterator(tx); iterator.hasNext(); ) {
2:e11ece1:             Map.Entry<Key,Value> candidate = iterator.next();
2:e11ece1:             if (key.equals(candidate.getKey())) {
1:e11ece1:                 return true;
1:e11ece1:             }
1:e11ece1:         }
1:e11ece1:         return false;
1:e11ece1:     }
1:e11ece1: 
1:334ade2:     private ListNode<Key, Value> lastGetNodeCache = null;
1:334ade2:     private Map.Entry<Key, Value> lastGetEntryCache = null;
1:0bbb735:     private WeakReference<Transaction> lastCacheTxSrc = new WeakReference<Transaction>(null);
1:e11ece1: 
1:734fb7d:     @Override
1:334ade2:     @SuppressWarnings({ "rawtypes", "unchecked" })
1:e11ece1:     synchronized public Value get(Transaction tx, Key key) throws IOException {
1:e11ece1:         assertLoaded();
1:e11ece1:         for (Iterator<Map.Entry<Key,Value>> iterator = iterator(tx); iterator.hasNext(); ) {
1:e11ece1:             Map.Entry<Key,Value> candidate = iterator.next();
1:e11ece1:             if (key.equals(candidate.getKey())) {
1:334ade2:                 this.lastGetNodeCache = ((ListIterator) iterator).getCurrent();
1:334ade2:                 this.lastGetEntryCache = candidate;
1:0bbb735:                 this.lastCacheTxSrc = new WeakReference<Transaction>(tx);
2:e11ece1:                 return candidate.getValue();
1:e11ece1:             }
1:e11ece1:         }
1:e11ece1:         return null;
1:334ade2:     }
1:334ade2: 
1:e11ece1:     /**
1:334ade2:      * Update the value of the item with the given key in the list if ot exists, otherwise
1:334ade2:      * it appends the value to the end of the list.
1:334ade2:      *
1:334ade2:      * @return the old value contained in the list if one exists or null.
1:e11ece1:      */
1:734fb7d:     @Override
1:334ade2:     @SuppressWarnings({ "rawtypes" })
1:e11ece1:     synchronized public Value put(Transaction tx, Key key, Value value) throws IOException {
1:334ade2: 
1:334ade2:         Value oldValue = null;
1:334ade2: 
1:0bbb735:         if (lastGetNodeCache != null && tx.equals(lastCacheTxSrc.get())) {
1:334ade2: 
1:334ade2:             if(lastGetEntryCache.getKey().equals(key)) {
1:334ade2:                 oldValue = lastGetEntryCache.setValue(value);
1:334ade2:                 lastGetEntryCache.setValue(value);
1:334ade2:                 lastGetNodeCache.storeUpdate(tx);
1:eab8758:                 flushCache();
1:334ade2:                 return oldValue;
1:334ade2:             }
1:334ade2: 
1:334ade2:             // This searches from the last location of a call to get for the element to replace
1:334ade2:             // all the way to the end of the ListIndex.
1:334ade2:             Iterator<Map.Entry<Key, Value>> iterator = lastGetNodeCache.iterator(tx);
1:334ade2:             while (iterator.hasNext()) {
1:334ade2:                 Map.Entry<Key, Value> entry = iterator.next();
1:334ade2:                 if (entry.getKey().equals(key)) {
1:334ade2:                     oldValue = entry.setValue(value);
1:334ade2:                     ((ListIterator) iterator).getCurrent().storeUpdate(tx);
1:eab8758:                     flushCache();
1:334ade2:                     return oldValue;
1:334ade2:                 }
1:334ade2:             }
1:0bbb735:         } else {
1:eab8758:             flushCache();
1:334ade2:         }
1:334ade2: 
1:334ade2:         // Not found because the cache wasn't set or its not at the end of the list so we
1:334ade2:         // start from the beginning and go to the cached location or the end, then we do
1:334ade2:         // an add if its not found.
1:334ade2:         Iterator<Map.Entry<Key, Value>> iterator = iterator(tx);
1:334ade2:         while (iterator.hasNext() && ((ListIterator) iterator).getCurrent() != lastGetNodeCache) {
1:334ade2:             Map.Entry<Key, Value> entry = iterator.next();
1:334ade2:             if (entry.getKey().equals(key)) {
1:334ade2:                 oldValue = entry.setValue(value);
1:334ade2:                 ((ListIterator) iterator).getCurrent().storeUpdate(tx);
1:0bbb735:                 flushCache();
1:334ade2:                 return oldValue;
1:334ade2:             }
1:334ade2:         }
1:334ade2: 
1:334ade2:         // Not found so add it last.
1:eab8758:         flushCache();
1:eab8758: 
1:e11ece1:         return add(tx, key, value);
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     synchronized public Value add(Transaction tx, Key key, Value value) throws IOException {
1:e11ece1:         assertLoaded();
1:e11ece1:         getTail(tx).put(tx, key, value);
1:2b10259:         size.incrementAndGet();
1:eab8758:         flushCache();
1:e11ece1:         return null;
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     synchronized public Value addFirst(Transaction tx, Key key, Value value) throws IOException {
1:e11ece1:         assertLoaded();
1:e11ece1:         getHead(tx).addFirst(tx, key, value);
1:2b10259:         size.incrementAndGet();
1:eab8758:         flushCache();
1:e11ece1:         return null;
1:e11ece1:     }
1:e11ece1: 
1:734fb7d:     @Override
1:334ade2:     @SuppressWarnings("rawtypes")
1:e11ece1:     synchronized public Value remove(Transaction tx, Key key) throws IOException {
1:e11ece1:         assertLoaded();
1:334ade2: 
1:334ade2:         if (size.get() == 0) {
1:334ade2:             return null;
1:334ade2:         }
2:334ade2: 
1:0bbb735:         if (lastGetNodeCache != null && tx.equals(lastCacheTxSrc.get())) {
1:334ade2: 
1:334ade2:             // This searches from the last location of a call to get for the element to remove
1:334ade2:             // all the way to the end of the ListIndex.
1:334ade2:             Iterator<Map.Entry<Key, Value>> iterator = lastGetNodeCache.iterator(tx);
1:334ade2:             while (iterator.hasNext()) {
1:334ade2:                 Map.Entry<Key, Value> entry = iterator.next();
1:334ade2:                 if (entry.getKey().equals(key)) {
1:e11ece1:                     iterator.remove();
1:0bbb735:                     flushCache();
1:334ade2:                     return entry.getValue();
1:e11ece1:                 }
1:e11ece1:             }
1:0bbb735:         } else {
1:0bbb735:             flushCache();
1:e11ece1:         }
1:e11ece1: 
1:334ade2:         // Not found because the cache wasn't set or its not at the end of the list so we
1:334ade2:         // start from the beginning and go to the cached location or the end to find the
1:334ade2:         // element to remove.
1:334ade2:         Iterator<Map.Entry<Key, Value>> iterator = iterator(tx);
1:334ade2:         while (iterator.hasNext() && ((ListIterator) iterator).getCurrent() != lastGetNodeCache) {
1:334ade2:             Map.Entry<Key, Value> entry = iterator.next();
1:334ade2:             if (entry.getKey().equals(key)) {
2:334ade2:                 iterator.remove();
1:0bbb735:                 flushCache();
1:334ade2:                 return entry.getValue();
1:e11ece1:             }
1:334ade2:         }
1:e11ece1: 
1:e11ece1:         return null;
1:334ade2:     }
1:e11ece1: 
1:734fb7d:     public void onRemove(Entry<Key, Value> removed) {
1:2b10259:         size.decrementAndGet();
1:0bbb735:         flushCache();
1:334ade2:     }
1:334ade2: 
1:734fb7d:     @Override
1:e11ece1:     public boolean isTransient() {
1:e11ece1:         return false;
1:e11ece1:     }
1:e11ece1: 
1:734fb7d:     @Override
1:e11ece1:     synchronized public void clear(Transaction tx) throws IOException {
1:e11ece1:         for (Iterator<ListNode<Key,Value>> iterator = listNodeIterator(tx); iterator.hasNext(); ) {
1:e11ece1:             ListNode<Key,Value>candidate = iterator.next();
1:e11ece1:             candidate.clear(tx);
1:2b10259:             // break up the transaction
1:2b10259:             tx.commit();
1:e11ece1:         }
1:0bbb735:         flushCache();
1:2b10259:         size.set(0);
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     synchronized public Iterator<ListNode<Key, Value>> listNodeIterator(Transaction tx) throws IOException {
1:e11ece1:         return getHead(tx).listNodeIterator(tx);
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     synchronized public boolean isEmpty(final Transaction tx) throws IOException {
1:e11ece1:         return getHead(tx).isEmpty(tx);
1:e11ece1:     }
1:e11ece1: 
1:734fb7d:     @Override
1:e11ece1:     synchronized public Iterator<Map.Entry<Key,Value>> iterator(final Transaction tx) throws IOException {
1:e11ece1:         return getHead(tx).iterator(tx);
1:e11ece1:     }
1:e11ece1: 
1:2b10259:     synchronized public Iterator<Map.Entry<Key,Value>> iterator(final Transaction tx, long initialPosition) throws IOException {
1:e11ece1:         return getHead(tx).iterator(tx, initialPosition);
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     synchronized public Map.Entry<Key,Value> getFirst(Transaction tx) throws IOException {
1:e11ece1:         return getHead(tx).getFirst(tx);
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     synchronized public Map.Entry<Key,Value> getLast(Transaction tx) throws IOException {
1:e11ece1:         return getTail(tx).getLast(tx);
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     private void assertLoaded() throws IllegalStateException {
1:e11ece1:         if( !loaded.get() ) {
1:e11ece1:             throw new IllegalStateException("TheListIndex is not loaded");
1:e11ece1:         }
1:e11ece1:     }
1:e11ece1: 
1:2b10259:     ListNode<Key,Value> loadNode(Transaction tx, long pageId) throws IOException {
1:e11ece1:         Page<ListNode<Key,Value>> page = tx.load(pageId, marshaller);
1:1463bec:         ListNode<Key, Value> node = page.get();
1:1463bec:         node.setPage(page);
1:1463bec:         node.setContainingList(this);
1:1463bec:         return node;
1:2b10259:     }
1:2b10259: 
1:2b10259:     ListNode<Key,Value> createNode(Page<ListNode<Key,Value>> page) throws IOException {
1:bf59b7d:         ListNode<Key,Value> node = new ListNode<Key,Value>();
1:2b10259:         node.setPage(page);
1:2b10259:         page.set(node);
2:bf59b7d:         node.setContainingList(this);
1:2b10259:         return node;
1:e11ece1:     }
1:e11ece1: 
1:bf59b7d:     public ListNode<Key,Value> createNode(Transaction tx) throws IOException {
1:bf59b7d:         return createNode(tx.<ListNode<Key,Value>>load(tx.<ListNode<Key,Value>>allocate().getPageId(), null));
1:e11ece1:     }
1:e11ece1: 
1:bf59b7d:     public void storeNode(Transaction tx, ListNode<Key,Value> node, boolean overflow) throws IOException {
1:e11ece1:         tx.store(node.getPage(), marshaller, overflow);
1:334ade2:         flushCache();
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     public PageFile getPageFile() {
1:e11ece1:         return pageFile;
1:e11ece1:     }
1:2b10259: 
1:2b10259:     public void setPageFile(PageFile pageFile) {
1:2b10259:         this.pageFile = pageFile;
1:2b10259:     }
1:2b10259: 
1:e11ece1:     public long getHeadPageId() {
1:e11ece1:         return headPageId;
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     public void setHeadPageId(long headPageId) {
1:2b10259:         this.headPageId = headPageId;
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     public Marshaller<Key> getKeyMarshaller() {
1:e11ece1:         return keyMarshaller;
1:e11ece1:     }
1:734fb7d:     @Override
1:e11ece1:     public void setKeyMarshaller(Marshaller<Key> keyMarshaller) {
1:e11ece1:         this.keyMarshaller = keyMarshaller;
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     public Marshaller<Value> getValueMarshaller() {
1:e11ece1:         return valueMarshaller;
1:e11ece1:     }
1:734fb7d:     @Override
1:e11ece1:     public void setValueMarshaller(Marshaller<Value> valueMarshaller) {
1:e11ece1:         this.valueMarshaller = valueMarshaller;
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     public void setTailPageId(long tailPageId) {
1:e11ece1:         this.tailPageId = tailPageId;
1:e11ece1:     }
1:e11ece1: 
1:bf59b7d:     public long getTailPageId() {
1:bf59b7d:        return tailPageId;
1:bf59b7d:     }
1:bf59b7d: 
1:e11ece1:     public long size() {
1:2b10259:         return size.get();
1:e11ece1:     }
1:334ade2: 
1:334ade2:     private void flushCache() {
1:334ade2:         this.lastGetEntryCache = null;
1:334ade2:         this.lastGetNodeCache = null;
1:0bbb735:         this.lastCacheTxSrc.clear();
1:e11ece1:     }
1:e11ece1: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:734fb7d
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map.Entry;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                 onLoad(node, tx);
1:                     onLoad(node, tx);
1:     protected void onLoad(ListNode<Key, Value> node, Transaction tx) {
1: 
1:     }
1: 
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     public void onRemove(Entry<Key, Value> removed) {
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:c5cf038
commit:1aab71b
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.store.kahadb.disk.index;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.kahadb.disk.index.ListNode.ListIterator;
1: import org.apache.activemq.store.kahadb.disk.page.Page;
1: import org.apache.activemq.store.kahadb.disk.page.PageFile;
1: import org.apache.activemq.store.kahadb.disk.page.Transaction;
1: import org.apache.activemq.store.kahadb.disk.util.Marshaller;
commit:715010a
author:Gary Tully
-------------------------------------------------------------------------------
commit:1463bec
/////////////////////////////////////////////////////////////////////////
1:         ListNode<Key, Value> node = page.get();
1:         node.setPage(page);
1:         node.setContainingList(this);
1:         return node;
commit:bf59b7d
/////////////////////////////////////////////////////////////////////////
1:     public  final static long NOT_SET = -1;
/////////////////////////////////////////////////////////////////////////
1:     private ListNode.NodeMarshaller<Key, Value> marshaller;
/////////////////////////////////////////////////////////////////////////
1:         setHeadPageId(headPageId);
/////////////////////////////////////////////////////////////////////////
1: 
1:             marshaller = new ListNode.NodeMarshaller<Key, Value>(keyMarshaller, valueMarshaller);
1:             final Page<ListNode<Key,Value>> p = tx.load(getHeadPageId(), null);
1:                 setHeadPageId(p.getPageId());
1:                 setTailPageId(getHeadPageId());
1:                 ListNode<Key, Value> node = loadNode(tx, getHeadPageId());
1:                 setTailPageId(getHeadPageId());
1:                 while (node.getNext() != NOT_SET ) {
1:                     setTailPageId(node.getPageId());
/////////////////////////////////////////////////////////////////////////
1:         return loadNode(tx, getHeadPageId());
1:         return loadNode(tx, getTailPageId());
/////////////////////////////////////////////////////////////////////////
1:         node.setContainingList(this);
1:         ListNode<Key,Value> node = new ListNode<Key,Value>();
1:         node.setContainingList(this);
1:     public ListNode<Key,Value> createNode(Transaction tx) throws IOException {
1:         return createNode(tx.<ListNode<Key,Value>>load(tx.<ListNode<Key,Value>>allocate().getPageId(), null));
1:     public void storeNode(Transaction tx, ListNode<Key,Value> node, boolean overflow) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     public long getTailPageId() {
1:        return tailPageId;
1:     }
1: 
commit:2b10259
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicLong;
/////////////////////////////////////////////////////////////////////////
1:     private AtomicLong size = new AtomicLong(0);
/////////////////////////////////////////////////////////////////////////
1:     public ListIndex() {
1:     }
1: 
1:     public ListIndex(PageFile pageFile, long headPageId) {
1:         this.headPageId = headPageId;
/////////////////////////////////////////////////////////////////////////
1:                 ListNode<Key, Value> root = createNode(p);
0:                 tailPageId = headPageId = p.getPageId();
0:                 ListNode<Key, Value> node = loadNode(tx, headPageId);
1:                 size.addAndGet(node.size(tx));
1:                     node = loadNode(tx, node.getNext());
1:                     size.addAndGet(node.size(tx));
/////////////////////////////////////////////////////////////////////////
0:         return loadNode(tx, headPageId);
0:         return loadNode(tx, tailPageId);
/////////////////////////////////////////////////////////////////////////
1:         size.incrementAndGet();
1:         size.incrementAndGet();
/////////////////////////////////////////////////////////////////////////
1:         size.decrementAndGet();
/////////////////////////////////////////////////////////////////////////
1:             // break up the transaction
1:             tx.commit();
1:         size.set(0);
/////////////////////////////////////////////////////////////////////////
1:     synchronized public Iterator<Map.Entry<Key,Value>> iterator(final Transaction tx, long initialPosition) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     ListNode<Key,Value> loadNode(Transaction tx, long pageId) throws IOException {
1:     ListNode<Key,Value> createNode(Page<ListNode<Key,Value>> page) throws IOException {
1:         page.set(node);
1:         return node;
1:     }
1: 
0:     ListNode<Key,Value> createNode(Transaction tx) throws IOException {
0:         Page<ListNode<Key,Value>> page = tx.load(tx.<Object>allocate(1).getPageId(), null);
0:         ListNode<Key,Value> node = new ListNode<Key,Value>(this);
1:         node.setPage(page);
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void setPageFile(PageFile pageFile) {
1:         this.pageFile = pageFile;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         return size.get();
commit:e11ece1
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: package org.apache.kahadb.index;
1: 
1: import java.io.IOException;
1: import java.util.Iterator;
1: import java.util.Map;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: 
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
0: import org.apache.kahadb.page.Page;
0: import org.apache.kahadb.page.PageFile;
0: import org.apache.kahadb.page.Transaction;
0: import org.apache.kahadb.util.Marshaller;
1: 
1: public class ListIndex<Key,Value> implements Index<Key,Value> {
1: 
1:     private static final Logger LOG = LoggerFactory.getLogger(ListIndex.class);
1: 
1:     protected PageFile pageFile;
1:     protected long headPageId;
1:     protected long tailPageId;
0:     private long size;
1: 
1:     protected AtomicBoolean loaded = new AtomicBoolean();
1: 
0:     private final ListNode.Marshaller<Key, Value> marshaller = new ListNode.Marshaller<Key, Value>(this);
1:     private Marshaller<Key> keyMarshaller;
1:     private Marshaller<Value> valueMarshaller;
1: 
0:     public ListIndex(PageFile pageFile, long rootPageId) {
1:         this.pageFile = pageFile;
0:         this.headPageId = rootPageId;
1:     }
1: 
1:     synchronized public void load(Transaction tx) throws IOException {
1:         if (loaded.compareAndSet(false, true)) {
1:             LOG.debug("loading");
1:             if( keyMarshaller == null ) {
1:                 throw new IllegalArgumentException("The key marshaller must be set before loading the ListIndex");
1:             }
1:             if( valueMarshaller == null ) {
1:                 throw new IllegalArgumentException("The value marshaller must be set before loading the ListIndex");
1:             }
1:             
0:             final Page<ListNode<Key,Value>> p = tx.load(headPageId, null);
1:             if( p.getType() == Page.PAGE_FREE_TYPE ) {
1:                  // Need to initialize it..
0:                 ListNode<Key, Value> root = createNode(p, null);
1:                 storeNode(tx, root, true);
0:                 tailPageId = headPageId;
1:             } else {
0:                 ListNode<Key, Value> node = loadNode(tx, headPageId, null);
0:                 size += node.size(tx);
0:                 while (node.getNext() != -1) {
0:                     node = loadNode(tx, node.getNext(), node);
0:                     size += node.size(tx);
0:                     tailPageId = node.getPageId();
1:                 }
1:             }
1:         }
1:     }
1:     
1:     synchronized public void unload(Transaction tx) {
1:         if (loaded.compareAndSet(true, false)) {
1:         }    
1:     }
1:     
1:     protected ListNode<Key,Value> getHead(Transaction tx) throws IOException {
0:         return loadNode(tx, headPageId, null);
1:     }
1: 
1:     protected ListNode<Key,Value> getTail(Transaction tx) throws IOException {
0:         return loadNode(tx, tailPageId, null);
1:     }
1: 
1:     synchronized public boolean containsKey(Transaction tx, Key key) throws IOException {
1:         assertLoaded();
1:         for (Iterator<Map.Entry<Key,Value>> iterator = iterator(tx); iterator.hasNext(); ) {
1:             Map.Entry<Key,Value> candidate = iterator.next();
1:             if (key.equals(candidate.getKey())) {
1:                 return true;
1:             }
1:         }
1:         return false;
1:     }
1: 
1:     synchronized public Value get(Transaction tx, Key key) throws IOException {
1:         assertLoaded();
1:         for (Iterator<Map.Entry<Key,Value>> iterator = iterator(tx); iterator.hasNext(); ) {
1:             Map.Entry<Key,Value> candidate = iterator.next();
1:             if (key.equals(candidate.getKey())) {
1:                 return candidate.getValue();
1:             }
1:         }
1:         return null;
1:     }
1: 
1:     /**
0:       * appends to the list
0:      * @return null
1:      */
1:     synchronized public Value put(Transaction tx, Key key, Value value) throws IOException {
1:         return add(tx, key, value);
1:     }
1: 
1:     synchronized public Value add(Transaction tx, Key key, Value value) throws IOException {
1:         assertLoaded();
1:         getTail(tx).put(tx, key, value);
0:         size ++;
1:         return null;
1:     }
1: 
1:     synchronized public Value addFirst(Transaction tx, Key key, Value value) throws IOException {
1:         assertLoaded();
1:         getHead(tx).addFirst(tx, key, value);
0:         size++;
1:         return null;
1:     }
1: 
1:     synchronized public Value remove(Transaction tx, Key key) throws IOException {
1:         assertLoaded();
1:         for (Iterator<Map.Entry<Key,Value>> iterator = iterator(tx); iterator.hasNext(); ) {
1:             Map.Entry<Key,Value> candidate = iterator.next();
1:             if (key.equals(candidate.getKey())) {
1:                 iterator.remove();
1:                 return candidate.getValue();
1:             }
1:         }
1:         return null;
1:     }
1: 
0:     public void onRemove() {
0:         size--;
1:     }
1: 
1:     public boolean isTransient() {
1:         return false;
1:     }
1: 
1:     synchronized public void clear(Transaction tx) throws IOException {
1:         for (Iterator<ListNode<Key,Value>> iterator = listNodeIterator(tx); iterator.hasNext(); ) {
1:             ListNode<Key,Value>candidate = iterator.next();
1:             candidate.clear(tx);
1:         }
0:         size = 0;
1:     }
1: 
1:     synchronized public Iterator<ListNode<Key, Value>> listNodeIterator(Transaction tx) throws IOException {
1:         return getHead(tx).listNodeIterator(tx);
1:     }
1: 
1:     synchronized public boolean isEmpty(final Transaction tx) throws IOException {
1:         return getHead(tx).isEmpty(tx);
1:     }
1: 
1:     synchronized public Iterator<Map.Entry<Key,Value>> iterator(final Transaction tx) throws IOException {
1:         return getHead(tx).iterator(tx);
1:     }
1:     
0:     synchronized public Iterator<Map.Entry<Key,Value>> iterator(final Transaction tx, int initialPosition) throws IOException {
1:         return getHead(tx).iterator(tx, initialPosition);
1:     }
1: 
1:     synchronized public Map.Entry<Key,Value> getFirst(Transaction tx) throws IOException {
1:         return getHead(tx).getFirst(tx);
1:     }
1: 
1:     synchronized public Map.Entry<Key,Value> getLast(Transaction tx) throws IOException {
1:         return getTail(tx).getLast(tx);
1:     }
1: 
1:     private void assertLoaded() throws IllegalStateException {
1:         if( !loaded.get() ) {
1:             throw new IllegalStateException("TheListIndex is not loaded");
1:         }
1:     }
1: 
0:     ListNode<Key,Value> loadNode(Transaction tx, long pageId, ListNode<Key,Value> parent) throws IOException {
1:         Page<ListNode<Key,Value>> page = tx.load(pageId, marshaller);
0:         ListNode<Key, Value> node = page.get();
0:         node.setPage(page);
0:         node.setParent(parent);
0:         return node;
1:     }
1: 
0:     ListNode<Key,Value> createNode(Page<ListNode<Key,Value>> p, ListNode<Key,Value> parent) throws IOException {
0:         ListNode<Key,Value> node = new ListNode<Key,Value>(this);
0:         node.setPage(p);
0:         node.setParent(parent);
0:         node.setEmpty();
0:         p.set(node);
0:         return node;
1:     }
1: 
0:     ListNode<Key,Value> createNode(Transaction tx, ListNode<Key,Value> parent) throws IOException {
0:         Page<ListNode<Key,Value>> page = tx.load(tx.<Object>allocate(1).getPageId(), marshaller);
0:         ListNode<Key,Value> node = new ListNode<Key,Value>(this);
0:         node.setPage(page);
0:         node.setParent(parent);
0:         node.setEmpty();
0:         page.set(node);
0:         return node;
1:     }
1: 
0:     void storeNode(Transaction tx, ListNode<Key,Value> node, boolean overflow) throws IOException {
1:         tx.store(node.getPage(), marshaller, overflow);
1:     }
1:         
1:     public PageFile getPageFile() {
1:         return pageFile;
1:     }
1:     public long getHeadPageId() {
1:         return headPageId;
1:     }
1: 
1:     public void setHeadPageId(long headPageId) {
0:         this.headPageId = headPageId;
1:     }
1: 
1:     public Marshaller<Key> getKeyMarshaller() {
1:         return keyMarshaller;
1:     }
1:     public void setKeyMarshaller(Marshaller<Key> keyMarshaller) {
1:         this.keyMarshaller = keyMarshaller;
1:     }
1: 
1:     public Marshaller<Value> getValueMarshaller() {
1:         return valueMarshaller;
1:     }
1:     public void setValueMarshaller(Marshaller<Value> valueMarshaller) {
1:         this.valueMarshaller = valueMarshaller;
1:     }
1: 
1:     public void setTailPageId(long tailPageId) {
1:         this.tailPageId = tailPageId;
1:     }
1: 
1:     public long size() {
0:         return size;
1:     }
1: }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:eab8758
/////////////////////////////////////////////////////////////////////////
1:                 flushCache();
/////////////////////////////////////////////////////////////////////////
1:                     flushCache();
/////////////////////////////////////////////////////////////////////////
1:                 flushCache();
1:         flushCache();
1: 
/////////////////////////////////////////////////////////////////////////
1:         flushCache();
/////////////////////////////////////////////////////////////////////////
1:         flushCache();
commit:0bbb735
/////////////////////////////////////////////////////////////////////////
1: import java.lang.ref.WeakReference;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private WeakReference<Transaction> lastCacheTxSrc = new WeakReference<Transaction>(null);
/////////////////////////////////////////////////////////////////////////
1:                 this.lastCacheTxSrc = new WeakReference<Transaction>(tx);
/////////////////////////////////////////////////////////////////////////
1:         if (lastGetNodeCache != null && tx.equals(lastCacheTxSrc.get())) {
/////////////////////////////////////////////////////////////////////////
1:         } else {
1:             flushCache();
/////////////////////////////////////////////////////////////////////////
1:         if (lastGetNodeCache != null && tx.equals(lastCacheTxSrc.get())) {
/////////////////////////////////////////////////////////////////////////
1:                     flushCache();
1:         } else {
1:             flushCache();
/////////////////////////////////////////////////////////////////////////
1:                 flushCache();
/////////////////////////////////////////////////////////////////////////
1:         flushCache();
/////////////////////////////////////////////////////////////////////////
1:         flushCache();
/////////////////////////////////////////////////////////////////////////
0:         try {
0:             ListNode<Key, Value> node = page.get();
0:             node.setPage(page);
0:             node.setContainingList(this);
0:             return node;
0:         } catch (ClassCastException e) {
0:             throw e;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         this.lastCacheTxSrc.clear();
commit:334ade2
/////////////////////////////////////////////////////////////////////////
0: import org.apache.kahadb.index.ListNode.ListIterator;
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (size.get() == 0) {
1:             return false;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:     private ListNode<Key, Value> lastGetNodeCache = null;
1:     private Map.Entry<Key, Value> lastGetEntryCache = null;
1: 
1:     @SuppressWarnings({ "rawtypes", "unchecked" })
1:                 this.lastGetNodeCache = ((ListIterator) iterator).getCurrent();
1:                 this.lastGetEntryCache = candidate;
/////////////////////////////////////////////////////////////////////////
1:      * Update the value of the item with the given key in the list if ot exists, otherwise
1:      * it appends the value to the end of the list.
1:      *
1:      * @return the old value contained in the list if one exists or null.
1:     @SuppressWarnings({ "rawtypes" })
1: 
1:         Value oldValue = null;
1: 
0:         if (lastGetNodeCache != null) {
1: 
1:             if(lastGetEntryCache.getKey().equals(key)) {
1:                 oldValue = lastGetEntryCache.setValue(value);
1:                 lastGetEntryCache.setValue(value);
1:                 lastGetNodeCache.storeUpdate(tx);
1:                 return oldValue;
1:             }
1: 
1:             // This searches from the last location of a call to get for the element to replace
1:             // all the way to the end of the ListIndex.
1:             Iterator<Map.Entry<Key, Value>> iterator = lastGetNodeCache.iterator(tx);
1:             while (iterator.hasNext()) {
1:                 Map.Entry<Key, Value> entry = iterator.next();
1:                 if (entry.getKey().equals(key)) {
1:                     oldValue = entry.setValue(value);
1:                     ((ListIterator) iterator).getCurrent().storeUpdate(tx);
1:                     return oldValue;
1:                 }
1:             }
1:         }
1: 
1:         // Not found because the cache wasn't set or its not at the end of the list so we
1:         // start from the beginning and go to the cached location or the end, then we do
1:         // an add if its not found.
1:         Iterator<Map.Entry<Key, Value>> iterator = iterator(tx);
1:         while (iterator.hasNext() && ((ListIterator) iterator).getCurrent() != lastGetNodeCache) {
1:             Map.Entry<Key, Value> entry = iterator.next();
1:             if (entry.getKey().equals(key)) {
1:                 oldValue = entry.setValue(value);
1:                 ((ListIterator) iterator).getCurrent().storeUpdate(tx);
1:                 return oldValue;
1:             }
1:         }
1: 
1:         // Not found so add it last.
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("rawtypes")
1: 
1:         if (size.get() == 0) {
1:             return null;
1:         }
1: 
0:         if (lastGetNodeCache != null) {
1: 
1:             // This searches from the last location of a call to get for the element to remove
1:             // all the way to the end of the ListIndex.
1:             Iterator<Map.Entry<Key, Value>> iterator = lastGetNodeCache.iterator(tx);
1:             while (iterator.hasNext()) {
1:                 Map.Entry<Key, Value> entry = iterator.next();
1:                 if (entry.getKey().equals(key)) {
1:                     iterator.remove();
1:                     return entry.getValue();
1:                 }
1: 
1:         // Not found because the cache wasn't set or its not at the end of the list so we
1:         // start from the beginning and go to the cached location or the end to find the
1:         // element to remove.
1:         Iterator<Map.Entry<Key, Value>> iterator = iterator(tx);
1:         while (iterator.hasNext() && ((ListIterator) iterator).getCurrent() != lastGetNodeCache) {
1:             Map.Entry<Key, Value> entry = iterator.next();
1:             if (entry.getKey().equals(key)) {
1:                 iterator.remove();
1:                 return entry.getValue();
1:             }
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         flushCache();
/////////////////////////////////////////////////////////////////////////
0: 
1:     private void flushCache() {
1:         this.lastGetEntryCache = null;
1:         this.lastGetNodeCache = null;
0:     }
commit:82e3be3
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("rawtypes")
1:     public ListIndex(PageFile pageFile, Page page) {
1:         this(pageFile, page.getPageId());
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
============================================================================