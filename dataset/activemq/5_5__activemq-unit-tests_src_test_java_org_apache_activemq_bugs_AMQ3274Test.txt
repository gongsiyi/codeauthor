1:974f689: /**
1:974f689:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:974f689:  * contributor license agreements.  See the NOTICE file distributed with
1:974f689:  * this work for additional information regarding copyright ownership.
1:974f689:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:974f689:  * (the "License"); you may not use this file except in compliance with
1:974f689:  * the License.  You may obtain a copy of the License at
1:974f689:  *
1:974f689:  *      http://www.apache.org/licenses/LICENSE-2.0
1:974f689:  *
1:974f689:  * Unless required by applicable law or agreed to in writing, software
1:974f689:  * distributed under the License is distributed on an "AS IS" BASIS,
1:974f689:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:974f689:  * See the License for the specific language governing permissions and
1:974f689:  * limitations under the License.
13:7dc2c4e:  */
58:7dc2c4e: 
1:7dc2c4e: package org.apache.activemq.bugs;
1:974f689: 
1:e2e71eb: import static org.junit.Assert.assertTrue;
1:e2e71eb: 
1:e2e71eb: import java.net.URI;
1:e2e71eb: import java.net.URISyntaxException;
1:e2e71eb: import java.util.ArrayList;
1:e2e71eb: import java.util.Enumeration;
1:e2e71eb: import java.util.concurrent.CountDownLatch;
1:e2e71eb: import java.util.concurrent.TimeUnit;
1:7dc2c4e: 
1:974f689: import javax.jms.Connection;
1:974f689: import javax.jms.Destination;
1:974f689: import javax.jms.JMSException;
1:974f689: import javax.jms.Message;
1:974f689: import javax.jms.MessageConsumer;
1:974f689: import javax.jms.MessageProducer;
1:974f689: import javax.jms.Session;
1:974f689: import javax.jms.TextMessage;
1:7dc2c4e: 
1:e2e71eb: import org.apache.activemq.ActiveMQConnection;
1:e2e71eb: import org.apache.activemq.broker.BrokerService;
1:e2e71eb: import org.apache.activemq.command.ActiveMQDestination;
1:e2e71eb: import org.apache.activemq.network.DiscoveryNetworkConnector;
1:e2e71eb: import org.apache.activemq.network.NetworkConnector;
1:e2e71eb: import org.junit.Test;
1:e2e71eb: import org.slf4j.Logger;
1:e2e71eb: import org.slf4j.LoggerFactory;
1:974f689: 
1:e2e71eb: public class AMQ3274Test {
1:e2e71eb:     private static final transient Logger LOG = LoggerFactory.getLogger(AMQ3274Test.class);
1:7dc2c4e: 
1:e2e71eb:     protected static int Next_broker_num = 0;
1:e2e71eb:     protected EmbeddedTcpBroker broker1;
1:e2e71eb:     protected EmbeddedTcpBroker broker2;
1:7dc2c4e: 
1:e2e71eb:     protected int nextEchoId = 0;
1:e2e71eb:     protected boolean testError = false;
1:7dc2c4e: 
1:e2e71eb:     protected int echoResponseFill = 0; // Number of "filler" response messages per request
1:7dc2c4e: 
1:e2e71eb:     public AMQ3274Test() throws Exception {
1:e2e71eb:         broker1 = new EmbeddedTcpBroker();
1:e2e71eb:         broker2 = new EmbeddedTcpBroker();
1:7dc2c4e: 
1:e2e71eb:         broker1.coreConnectTo(broker2, true);
1:e2e71eb:         broker2.coreConnectTo(broker1, true);
1:e2e71eb:     }
1:7dc2c4e: 
1:e2e71eb:     public void logMessage(String msg) {
1:e2e71eb:         System.out.println(msg);
1:e2e71eb:         System.out.flush();
1:e2e71eb:     }
1:7dc2c4e: 
1:e2e71eb:     public void testMessages(Session sess, MessageProducer req_prod, Destination resp_dest, int num_msg) throws Exception {
1:e2e71eb:         MessageConsumer resp_cons;
1:e2e71eb:         TextMessage msg;
1:e2e71eb:         MessageClient cons_client;
1:e2e71eb:         int cur;
1:e2e71eb:         int tot_expected;
1:7dc2c4e: 
1:e2e71eb:         resp_cons = sess.createConsumer(resp_dest);
1:7dc2c4e: 
1:e2e71eb:         cons_client = new MessageClient(resp_cons, num_msg);
1:e2e71eb:         cons_client.start();
1:7dc2c4e: 
1:e2e71eb:         cur = 0;
1:e2e71eb:         while ((cur < num_msg) && (!testError)) {
1:e2e71eb:             msg = sess.createTextMessage("MSG AAAA " + cur);
1:e2e71eb:             msg.setIntProperty("SEQ", 100 + cur);
1:e2e71eb:             msg.setStringProperty("TEST", "TOPO");
1:e2e71eb:             msg.setJMSReplyTo(resp_dest);
1:7dc2c4e: 
1:e2e71eb:             if (cur == (num_msg - 1))
1:e2e71eb:                 msg.setBooleanProperty("end-of-response", true);
1:7dc2c4e: 
1:e2e71eb:             req_prod.send(msg);
1:7dc2c4e: 
1:e2e71eb:             cur++;
1:e2e71eb:         }
1:7dc2c4e: 
1:e2e71eb:         cons_client.waitShutdown(5000);
1:7dc2c4e: 
1:e2e71eb:         if (cons_client.shutdown()) {
1:e2e71eb:             LOG.debug("Consumer client shutdown complete");
1:e2e71eb:         } else {
1:e2e71eb:             LOG.debug("Consumer client shutdown incomplete!!!");
1:e2e71eb:         }
1:7dc2c4e: 
1:e2e71eb:         tot_expected = num_msg * (echoResponseFill + 1);
1:7dc2c4e: 
1:e2e71eb:         if (cons_client.getNumMsgReceived() == tot_expected) {
1:e2e71eb:             LOG.info("Have " + tot_expected + " messages, as-expected");
1:e2e71eb:         } else {
1:f4bed15:             LOG.error("Have " + cons_client.getNumMsgReceived() + " messages; expected " + tot_expected);
1:e2e71eb:             testError = true;
1:e2e71eb:         }
1:7dc2c4e: 
1:e2e71eb:         resp_cons.close();
1:e2e71eb:     }
1:7dc2c4e: 
1:e2e71eb:     /**
1:e2e71eb:      * Test one destination between the given "producer broker" and
1:e2e71eb:      * "consumer broker" specified.
1:e2e71eb:      */
1:e2e71eb:     public void testOneDest(Connection conn, Session sess, Destination cons_dest, String prod_broker_url, String cons_broker_url, int num_msg) throws Exception {
1:e2e71eb:         int echo_id;
1:7dc2c4e: 
1:e2e71eb:         EchoService echo_svc;
1:e2e71eb:         String echo_queue_name;
1:e2e71eb:         Destination prod_dest;
1:e2e71eb:         MessageProducer msg_prod;
1:7dc2c4e: 
1:e2e71eb:         synchronized (this) {
1:e2e71eb:             echo_id = this.nextEchoId;
1:e2e71eb:             this.nextEchoId++;
1:e2e71eb:         }
1:7dc2c4e: 
1:e2e71eb:         echo_queue_name = "echo.queue." + echo_id;
1:7dc2c4e: 
1:e2e71eb:         LOG.trace("destroying the echo queue in case an old one exists");
1:e2e71eb:         removeQueue(conn, echo_queue_name);
1:7dc2c4e: 
1:e2e71eb:         echo_svc = new EchoService(echo_queue_name, prod_broker_url);
1:e2e71eb:         echo_svc.start();
1:7dc2c4e: 
1:e2e71eb:         LOG.trace("Creating echo queue and producer");
1:e2e71eb:         prod_dest = sess.createQueue(echo_queue_name);
1:e2e71eb:         msg_prod = sess.createProducer(prod_dest);
1:7dc2c4e: 
1:e2e71eb:         testMessages(sess, msg_prod, cons_dest, num_msg);
1:7dc2c4e: 
1:e2e71eb:         echo_svc.shutdown();
1:e2e71eb:         msg_prod.close();
1:e2e71eb:     }
1:7dc2c4e: 
1:e2e71eb:     /**
1:e2e71eb:      * TEST TEMPORARY TOPICS
1:e2e71eb:      */
1:e2e71eb:     public void testTempTopic(String prod_broker_url, String cons_broker_url) throws Exception {
1:e2e71eb:         Connection conn;
1:e2e71eb:         Session sess;
1:e2e71eb:         Destination cons_dest;
1:e2e71eb:         int num_msg;
1:7dc2c4e: 
1:e2e71eb:         num_msg = 5;
1:7dc2c4e: 
1:e2e71eb:         LOG.info("TESTING TEMP TOPICS " + prod_broker_url + " -> " + cons_broker_url + " (" + num_msg + " messages)");
1:7dc2c4e: 
1:e2e71eb:         conn = createConnection(cons_broker_url);
1:e2e71eb:         conn.start();
1:e2e71eb:         sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:7dc2c4e: 
1:e2e71eb:         LOG.trace("Creating destination");
1:e2e71eb:         cons_dest = sess.createTemporaryTopic();
1:7dc2c4e: 
1:e2e71eb:         testOneDest(conn, sess, cons_dest, prod_broker_url, cons_broker_url, num_msg);
1:7dc2c4e: 
1:e2e71eb:         sess.close();
1:e2e71eb:         conn.close();
1:e2e71eb:     }
1:7dc2c4e: 
1:e2e71eb:     /**
1:e2e71eb:      * TEST TOPICS
1:e2e71eb:      */
1:e2e71eb:     public void testTopic(String prod_broker_url, String cons_broker_url) throws Exception {
1:e2e71eb:         int num_msg;
1:7dc2c4e: 
1:e2e71eb:         Connection conn;
1:e2e71eb:         Session sess;
1:e2e71eb:         String topic_name;
1:7dc2c4e: 
1:e2e71eb:         Destination cons_dest;
1:7dc2c4e: 
1:e2e71eb:         num_msg = 5;
1:7dc2c4e: 
1:e2e71eb:         LOG.info("TESTING TOPICS " + prod_broker_url + " -> " + cons_broker_url + " (" + num_msg + " messages)");
1:7dc2c4e: 
1:e2e71eb:         conn = createConnection(cons_broker_url);
1:e2e71eb:         conn.start();
1:e2e71eb:         sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:7dc2c4e: 
1:e2e71eb:         topic_name = "topotest2.perm.topic";
1:e2e71eb:         LOG.trace("Removing existing Topic");
1:e2e71eb:         removeTopic(conn, topic_name);
1:e2e71eb:         LOG.trace("Creating Topic, " + topic_name);
1:e2e71eb:         cons_dest = sess.createTopic(topic_name);
1:7dc2c4e: 
1:e2e71eb:         testOneDest(conn, sess, cons_dest, prod_broker_url, cons_broker_url, num_msg);
1:7dc2c4e: 
1:e2e71eb:         removeTopic(conn, topic_name);
1:e2e71eb:         sess.close();
1:e2e71eb:         conn.close();
1:e2e71eb:     }
1:7dc2c4e: 
1:e2e71eb:     /**
1:e2e71eb:      * TEST TEMPORARY QUEUES
1:e2e71eb:      */
1:e2e71eb:     public void testTempQueue(String prod_broker_url, String cons_broker_url) throws Exception {
1:e2e71eb:         int num_msg;
1:7dc2c4e: 
1:e2e71eb:         Connection conn;
1:e2e71eb:         Session sess;
1:7dc2c4e: 
1:e2e71eb:         Destination cons_dest;
1:7dc2c4e: 
1:e2e71eb:         num_msg = 5;
1:7dc2c4e: 
1:e2e71eb:         LOG.info("TESTING TEMP QUEUES " + prod_broker_url + " -> " + cons_broker_url + " (" + num_msg + " messages)");
1:7dc2c4e: 
1:e2e71eb:         conn = createConnection(cons_broker_url);
1:e2e71eb:         conn.start();
1:e2e71eb:         sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:7dc2c4e: 
1:e2e71eb:         LOG.trace("Creating destination");
1:e2e71eb:         cons_dest = sess.createTemporaryQueue();
1:7dc2c4e: 
1:e2e71eb:         testOneDest(conn, sess, cons_dest, prod_broker_url, cons_broker_url, num_msg);
1:7dc2c4e: 
1:e2e71eb:         sess.close();
1:e2e71eb:         conn.close();
1:e2e71eb:     }
1:7dc2c4e: 
1:e2e71eb:     /**
1:e2e71eb:      * TEST QUEUES
1:e2e71eb:      */
1:e2e71eb:     public void testQueue(String prod_broker_url, String cons_broker_url) throws Exception {
1:e2e71eb:         int num_msg;
1:7dc2c4e: 
1:e2e71eb:         Connection conn;
1:e2e71eb:         Session sess;
1:e2e71eb:         String queue_name;
1:7dc2c4e: 
1:e2e71eb:         Destination cons_dest;
1:7dc2c4e: 
1:e2e71eb:         num_msg = 5;
1:7dc2c4e: 
1:e2e71eb:         LOG.info("TESTING QUEUES " + prod_broker_url + " -> " + cons_broker_url + " (" + num_msg + " messages)");
1:7dc2c4e: 
1:e2e71eb:         conn = createConnection(cons_broker_url);
1:e2e71eb:         conn.start();
1:e2e71eb:         sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:7dc2c4e: 
1:e2e71eb:         queue_name = "topotest2.perm.queue";
1:e2e71eb:         LOG.trace("Removing existing Queue");
1:e2e71eb:         removeQueue(conn, queue_name);
1:e2e71eb:         LOG.trace("Creating Queue, " + queue_name);
1:e2e71eb:         cons_dest = sess.createQueue(queue_name);
1:7dc2c4e: 
1:e2e71eb:         testOneDest(conn, sess, cons_dest, prod_broker_url, cons_broker_url, num_msg);
1:7dc2c4e: 
1:e2e71eb:         removeQueue(conn, queue_name);
1:e2e71eb:         sess.close();
1:e2e71eb:         conn.close();
1:e2e71eb:     }
1:7dc2c4e: 
1:e2e71eb:     @Test
1:e2e71eb:     public void run() throws Exception {
1:e2e71eb:         Thread start1;
1:e2e71eb:         Thread start2;
1:7dc2c4e: 
1:e2e71eb:         testError = false;
1:7dc2c4e: 
1:e2e71eb:         // Use threads to avoid startup deadlock since the first broker started waits until
1:e2e71eb:         // it knows the name of the remote broker before finishing its startup, which means
1:e2e71eb:         // the remote must already be running.
1:7dc2c4e: 
1:e2e71eb:         start1 = new Thread() {
1:e2e71eb:             public void run() {
1:e2e71eb:                 try {
1:e2e71eb:                     broker1.start();
1:e2e71eb:                 } catch (Exception ex) {
1:e2e71eb:                     LOG.error(null, ex);
1:e2e71eb:                 }
1:e2e71eb:             }
1:e2e71eb:         };
1:7dc2c4e: 
1:e2e71eb:         start2 = new Thread() {
1:e2e71eb:             public void run() {
1:e2e71eb:                 try {
1:e2e71eb:                     broker2.start();
1:e2e71eb:                 } catch (Exception ex) {
1:e2e71eb:                     LOG.error(null, ex);
1:e2e71eb:                 }
1:e2e71eb:             }
1:e2e71eb:         };
1:7dc2c4e: 
1:e2e71eb:         start1.start();
1:e2e71eb:         start2.start();
1:7dc2c4e: 
1:e2e71eb:         start1.join();
1:e2e71eb:         start2.join();
1:7dc2c4e: 
1:e2e71eb:         if (!testError) {
1:e2e71eb:             this.testTempTopic(broker1.getConnectionUrl(), broker2.getConnectionUrl());
1:e2e71eb:         }
1:e2e71eb:         if (!testError) {
1:e2e71eb:             this.testTempQueue(broker1.getConnectionUrl(), broker2.getConnectionUrl());
1:e2e71eb:         }
1:e2e71eb:         if (!testError) {
1:e2e71eb:             this.testTopic(broker1.getConnectionUrl(), broker2.getConnectionUrl());
1:e2e71eb:         }
1:e2e71eb:         if (!testError) {
1:e2e71eb:             this.testQueue(broker1.getConnectionUrl(), broker2.getConnectionUrl());
1:e2e71eb:         }
1:e2e71eb:         Thread.sleep(100);
1:7dc2c4e: 
1:e2e71eb:         shutdown();
1:7dc2c4e: 
1:e2e71eb:         assertTrue(!testError);
1:e2e71eb:     }
1:7dc2c4e: 
1:e2e71eb:     public void shutdown() throws Exception {
1:e2e71eb:         broker1.stop();
1:e2e71eb:         broker2.stop();
1:e2e71eb:     }
1:7dc2c4e: 
1:e2e71eb:     /**
1:e2e71eb:      * @param args
1:e2e71eb:      *            the command line arguments
1:e2e71eb:      */
1:e2e71eb:     public static void main(String[] args) {
1:e2e71eb:         AMQ3274Test main_obj;
1:7dc2c4e: 
1:e2e71eb:         try {
1:e2e71eb:             main_obj = new AMQ3274Test();
1:e2e71eb:             main_obj.run();
1:e2e71eb:         } catch (Exception ex) {
1:e2e71eb:             ex.printStackTrace();
1:e2e71eb:             LOG.error(null, ex);
1:e2e71eb:             System.exit(0);
1:e2e71eb:         }
1:e2e71eb:     }
1:7dc2c4e: 
1:e2e71eb:     protected Connection createConnection(String url) throws Exception {
1:e2e71eb:         return org.apache.activemq.ActiveMQConnection.makeConnection(url);
1:e2e71eb:     }
1:7dc2c4e: 
1:e2e71eb:     protected static void removeQueue(Connection conn, String dest_name) throws java.lang.Exception {
1:e2e71eb:         org.apache.activemq.command.ActiveMQDestination dest;
1:7dc2c4e: 
1:e2e71eb:         if (conn instanceof org.apache.activemq.ActiveMQConnection) {
1:e2e71eb:             dest = org.apache.activemq.command.ActiveMQDestination.createDestination(dest_name,
1:e2e71eb:                     (byte) org.apache.activemq.command.ActiveMQDestination.QUEUE_TYPE);
1:e2e71eb:             ((org.apache.activemq.ActiveMQConnection) conn).destroyDestination(dest);
1:e2e71eb:         }
1:e2e71eb:     }
1:7dc2c4e: 
1:e2e71eb:     protected static void removeTopic(Connection conn, String dest_name) throws java.lang.Exception {
1:e2e71eb:         org.apache.activemq.command.ActiveMQDestination dest;
1:7dc2c4e: 
1:e2e71eb:         if (conn instanceof org.apache.activemq.ActiveMQConnection) {
1:e2e71eb:             dest = org.apache.activemq.command.ActiveMQDestination.createDestination(dest_name,
1:e2e71eb:                     (byte) org.apache.activemq.command.ActiveMQDestination.TOPIC_TYPE);
1:e2e71eb:             ((org.apache.activemq.ActiveMQConnection) conn).destroyDestination(dest);
1:e2e71eb:         }
1:e2e71eb:     }
1:7dc2c4e: 
1:e2e71eb:     @SuppressWarnings("rawtypes")
1:e2e71eb:     public static String fmtMsgInfo(Message msg) throws Exception {
1:e2e71eb:         StringBuilder msg_desc;
1:e2e71eb:         String prop;
1:e2e71eb:         Enumeration prop_enum;
1:7dc2c4e: 
1:e2e71eb:         msg_desc = new StringBuilder();
1:e2e71eb:         msg_desc = new StringBuilder();
1:7dc2c4e: 
1:e2e71eb:         if (msg instanceof TextMessage) {
1:e2e71eb:             msg_desc.append(((TextMessage) msg).getText());
1:e2e71eb:         } else {
1:e2e71eb:             msg_desc.append("[");
1:e2e71eb:             msg_desc.append(msg.getClass().getName());
1:e2e71eb:             msg_desc.append("]");
1:e2e71eb:         }
1:7dc2c4e: 
1:e2e71eb:         prop_enum = msg.getPropertyNames();
1:e2e71eb:         while (prop_enum.hasMoreElements()) {
1:e2e71eb:             prop = (String) prop_enum.nextElement();
1:e2e71eb:             msg_desc.append("; ");
1:e2e71eb:             msg_desc.append(prop);
1:e2e71eb:             msg_desc.append("=");
1:e2e71eb:             msg_desc.append(msg.getStringProperty(prop));
1:e2e71eb:         }
1:7dc2c4e: 
1:e2e71eb:         return msg_desc.toString();
1:e2e71eb:     }
1:7dc2c4e: 
1:e2e71eb:     // ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
1:e2e71eb:     // /////////////////////////////////////////////// INTERNAL CLASSES
1:e2e71eb:     // /////////////////////////////////////////////////
1:e2e71eb:     // ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
1:7dc2c4e: 
1:e2e71eb:     protected class EmbeddedTcpBroker {
1:e2e71eb:         protected BrokerService brokerSvc;
1:e2e71eb:         protected int brokerNum;
1:e2e71eb:         protected String brokerName;
1:e2e71eb:         protected String brokerId;
1:e2e71eb:         protected int port;
1:e2e71eb:         protected String tcpUrl;
1:7dc2c4e: 
1:e2e71eb:         public EmbeddedTcpBroker() throws Exception {
1:e2e71eb:             brokerSvc = new BrokerService();
1:7dc2c4e: 
1:e2e71eb:             synchronized (this.getClass()) {
1:e2e71eb:                 brokerNum = Next_broker_num;
1:e2e71eb:                 Next_broker_num++;
1:e2e71eb:             }
1:7dc2c4e: 
1:e2e71eb:             brokerName = "broker" + brokerNum;
1:e2e71eb:             brokerId = "b" + brokerNum;
1:7dc2c4e: 
1:e2e71eb:             brokerSvc.setBrokerName(brokerName);
1:e2e71eb:             brokerSvc.setBrokerId(brokerId);
1:e2e71eb:             brokerSvc.setPersistent(false);
1:e2e71eb:             brokerSvc.setUseJmx(false);
1:e2e71eb:             tcpUrl = brokerSvc.addConnector("tcp://localhost:0").getPublishableConnectString();
1:e2e71eb:         }
1:7dc2c4e: 
1:e2e71eb:         public Connection createConnection() throws URISyntaxException, JMSException {
1:e2e71eb:             Connection result;
1:7dc2c4e: 
1:e2e71eb:             result = org.apache.activemq.ActiveMQConnection.makeConnection(this.tcpUrl);
1:7dc2c4e: 
1:e2e71eb:             return result;
1:e2e71eb:         }
1:7dc2c4e: 
1:e2e71eb:         public String getConnectionUrl() {
1:e2e71eb:             return this.tcpUrl;
1:e2e71eb:         }
1:7dc2c4e: 
1:e2e71eb:         /**
1:e2e71eb:          * Create network connections to the given broker using the
1:e2e71eb:          * network-connector configuration of CORE brokers (e.g.
1:e2e71eb:          * core1.bus.dev1.coresys.tmcs)
1:e2e71eb:          *
1:e2e71eb:          * @param other
1:e2e71eb:          * @param duplex_f
1:e2e71eb:          */
1:e2e71eb:         public void coreConnectTo(EmbeddedTcpBroker other, boolean duplex_f) throws Exception {
1:e2e71eb:             this.makeConnectionTo(other, duplex_f, true);
1:e2e71eb:             this.makeConnectionTo(other, duplex_f, false);
1:e2e71eb:         }
1:7dc2c4e: 
1:e2e71eb:         public void start() throws Exception {
1:e2e71eb:             brokerSvc.start();
1:e2e71eb:         }
1:7dc2c4e: 
1:e2e71eb:         public void stop() throws Exception {
1:e2e71eb:             brokerSvc.stop();
1:e2e71eb:         }
1:7dc2c4e: 
1:e2e71eb:         /**
1:e2e71eb:          * Make one connection to the other embedded broker, of the specified
1:e2e71eb:          * type (queue or topic) using the standard CORE broker networking.
1:e2e71eb:          *
1:e2e71eb:          * @param other
1:e2e71eb:          * @param duplex_f
1:e2e71eb:          * @param queue_f
1:e2e71eb:          * @throws Exception
1:e2e71eb:          */
1:e2e71eb:         protected void makeConnectionTo(EmbeddedTcpBroker other, boolean duplex_f, boolean queue_f) throws Exception {
1:e2e71eb:             NetworkConnector nw_conn;
1:e2e71eb:             String prefix;
1:e2e71eb:             ActiveMQDestination excl_dest;
1:e2e71eb:             ArrayList<ActiveMQDestination> excludes;
1:7dc2c4e: 
1:e2e71eb:             nw_conn = new DiscoveryNetworkConnector(new URI("static:(" + other.tcpUrl + ")"));
1:e2e71eb:             nw_conn.setDuplex(duplex_f);
1:7dc2c4e: 
1:e2e71eb:             if (queue_f)
1:e2e71eb:                 nw_conn.setConduitSubscriptions(false);
1:e2e71eb:             else
1:e2e71eb:                 nw_conn.setConduitSubscriptions(true);
1:7dc2c4e: 
1:e2e71eb:             nw_conn.setNetworkTTL(5);
1:e2e71eb:             nw_conn.setSuppressDuplicateQueueSubscriptions(true);
1:e2e71eb:             nw_conn.setDecreaseNetworkConsumerPriority(true);
1:e2e71eb:             nw_conn.setBridgeTempDestinations(true);
1:7dc2c4e: 
1:e2e71eb:             if (queue_f) {
1:e2e71eb:                 prefix = "queue";
1:8e00c6c:                 excl_dest = ActiveMQDestination.createDestination(">", ActiveMQDestination.TOPIC_TYPE);
1:e2e71eb:             } else {
1:e2e71eb:                 prefix = "topic";
1:8e00c6c:                 excl_dest = ActiveMQDestination.createDestination(">", ActiveMQDestination.QUEUE_TYPE);
1:e2e71eb:             }
1:7dc2c4e: 
1:e2e71eb:             excludes = new ArrayList<ActiveMQDestination>();
1:e2e71eb:             excludes.add(excl_dest);
1:e2e71eb:             nw_conn.setExcludedDestinations(excludes);
1:7dc2c4e: 
1:e2e71eb:             if (duplex_f)
1:e2e71eb:                 nw_conn.setName(this.brokerId + "<-" + prefix + "->" + other.brokerId);
1:e2e71eb:             else
1:e2e71eb:                 nw_conn.setName(this.brokerId + "-" + prefix + "->" + other.brokerId);
1:7dc2c4e: 
1:e2e71eb:             brokerSvc.addNetworkConnector(nw_conn);
1:e2e71eb:         }
1:e2e71eb:     }
1:7dc2c4e: 
1:e2e71eb:     protected class MessageClient extends java.lang.Thread {
1:e2e71eb:         protected MessageConsumer msgCons;
1:e2e71eb:         protected boolean shutdownInd;
1:e2e71eb:         protected int expectedCount;
1:e2e71eb:         protected int lastSeq = 0;
1:e2e71eb:         protected int msgCount = 0;
1:e2e71eb:         protected boolean haveFirstSeq;
1:e2e71eb:         protected CountDownLatch shutdownLatch;
1:7dc2c4e: 
1:e2e71eb:         public MessageClient(MessageConsumer cons, int num_to_expect) {
1:e2e71eb:             msgCons = cons;
1:e2e71eb:             expectedCount = (num_to_expect * (echoResponseFill + 1));
1:e2e71eb:             shutdownLatch = new CountDownLatch(1);
1:e2e71eb:         }
1:7dc2c4e: 
1:e2e71eb:         public void run() {
1:e2e71eb:             CountDownLatch latch;
1:7dc2c4e: 
1:e2e71eb:             try {
1:e2e71eb:                 synchronized (this) {
1:e2e71eb:                     latch = shutdownLatch;
1:e2e71eb:                 }
1:7dc2c4e: 
1:e2e71eb:                 shutdownInd = false;
1:e2e71eb:                 processMessages();
1:7dc2c4e: 
1:e2e71eb:                 latch.countDown();
1:e2e71eb:             } catch (Exception exc) {
1:e2e71eb:                 LOG.error("message client error", exc);
1:e2e71eb:             }
1:e2e71eb:         }
1:7dc2c4e: 
1:e2e71eb:         public void waitShutdown(long timeout) {
1:e2e71eb:             CountDownLatch latch;
1:7dc2c4e: 
1:e2e71eb:             try {
1:e2e71eb:                 synchronized (this) {
1:e2e71eb:                     latch = shutdownLatch;
1:e2e71eb:                 }
1:7dc2c4e: 
1:e2e71eb:                 if (latch != null)
1:e2e71eb:                     latch.await(timeout, TimeUnit.MILLISECONDS);
1:e2e71eb:                 else
1:e2e71eb:                     LOG.info("echo client shutdown: client does not appear to be active");
1:e2e71eb:             } catch (InterruptedException int_exc) {
1:e2e71eb:                 LOG.warn("wait for message client shutdown interrupted", int_exc);
1:e2e71eb:             }
1:e2e71eb:         }
1:7dc2c4e: 
1:e2e71eb:         public boolean shutdown() {
1:e2e71eb:             boolean down_ind;
1:7dc2c4e: 
1:e2e71eb:             if (!shutdownInd) {
1:e2e71eb:                 shutdownInd = true;
1:e2e71eb:             }
1:7dc2c4e: 
1:e2e71eb:             waitShutdown(200);
1:7dc2c4e: 
1:e2e71eb:             synchronized (this) {
1:e2e71eb:                 if ((shutdownLatch == null) || (shutdownLatch.getCount() == 0))
1:e2e71eb:                     down_ind = true;
1:e2e71eb:                 else
1:e2e71eb:                     down_ind = false;
1:e2e71eb:             }
1:7dc2c4e: 
1:e2e71eb:             return down_ind;
1:e2e71eb:         }
1:7dc2c4e: 
1:e2e71eb:         public int getNumMsgReceived() {
1:e2e71eb:             return msgCount;
1:e2e71eb:         }
1:7dc2c4e: 
1:e2e71eb:         protected void processMessages() throws Exception {
1:e2e71eb:             Message in_msg;
1:7dc2c4e: 
1:e2e71eb:             haveFirstSeq = false;
1:e2e71eb:             while ((!shutdownInd) && (!testError)) {
1:e2e71eb:                 in_msg = msgCons.receive(100);
1:7dc2c4e: 
1:e2e71eb:                 if (in_msg != null) {
1:e2e71eb:                     msgCount++;
1:e2e71eb:                     checkMessage(in_msg);
1:e2e71eb:                 }
1:e2e71eb:             }
1:e2e71eb:         }
1:7dc2c4e: 
1:e2e71eb:         protected void checkMessage(Message in_msg) throws Exception {
1:e2e71eb:             int seq;
1:7dc2c4e: 
1:e2e71eb:             LOG.debug("received message " + fmtMsgInfo(in_msg));
1:7dc2c4e: 
1:e2e71eb:             if (in_msg.propertyExists("SEQ")) {
1:e2e71eb:                 seq = in_msg.getIntProperty("SEQ");
1:7dc2c4e: 
1:e2e71eb:                 if ((haveFirstSeq) && (seq != (lastSeq + 1))) {
1:e2e71eb:                     LOG.error("***ERROR*** incorrect sequence number; expected " + Integer.toString(lastSeq + 1) + " but have " + Integer.toString(seq));
1:7dc2c4e: 
1:e2e71eb:                     testError = true;
1:e2e71eb:                 }
1:7dc2c4e: 
1:e2e71eb:                 lastSeq = seq;
1:7dc2c4e: 
1:e2e71eb:                 if (msgCount > expectedCount) {
1:e2e71eb:                     LOG.warn("*** have more messages than expected; have " + msgCount + "; expect " + expectedCount);
1:7dc2c4e: 
1:e2e71eb:                     testError = true;
1:e2e71eb:                 }
1:e2e71eb:             }
1:7dc2c4e: 
1:e2e71eb:             if (in_msg.propertyExists("end-of-response")) {
1:e2e71eb:                 LOG.trace("received end-of-response message");
1:e2e71eb:                 shutdownInd = true;
1:e2e71eb:             }
1:e2e71eb:         }
1:e2e71eb:     }
1:7dc2c4e: 
1:e2e71eb:     protected class EchoService extends java.lang.Thread {
1:e2e71eb:         protected String destName;
1:e2e71eb:         protected Connection jmsConn;
1:e2e71eb:         protected Session sess;
1:e2e71eb:         protected MessageConsumer msg_cons;
1:e2e71eb:         protected boolean Shutdown_ind;
1:7dc2c4e: 
1:e2e71eb:         protected Destination req_dest;
1:e2e71eb:         protected Destination resp_dest;
1:e2e71eb:         protected MessageProducer msg_prod;
1:7dc2c4e: 
1:e2e71eb:         protected CountDownLatch waitShutdown;
1:7dc2c4e: 
1:e2e71eb:         public EchoService(String dest, Connection broker_conn) throws Exception {
1:e2e71eb:             destName = dest;
1:e2e71eb:             jmsConn = broker_conn;
1:7dc2c4e: 
1:e2e71eb:             Shutdown_ind = false;
1:7dc2c4e: 
1:e2e71eb:             sess = jmsConn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:e2e71eb:             req_dest = sess.createQueue(destName);
1:e2e71eb:             msg_cons = sess.createConsumer(req_dest);
1:7dc2c4e: 
1:e2e71eb:             jmsConn.start();
1:7dc2c4e: 
1:e2e71eb:             waitShutdown = new CountDownLatch(1);
1:e2e71eb:         }
1:7dc2c4e: 
1:e2e71eb:         public EchoService(String dest, String broker_url) throws Exception {
1:e2e71eb:             this(dest, ActiveMQConnection.makeConnection(broker_url));
1:e2e71eb:         }
1:7dc2c4e: 
1:e2e71eb:         public void run() {
1:e2e71eb:             Message req;
1:7dc2c4e: 
1:e2e71eb:             try {
1:e2e71eb:                 LOG.info("STARTING ECHO SERVICE");
1:7dc2c4e: 
1:e2e71eb:                 while (!Shutdown_ind) {
1:e2e71eb:                     req = msg_cons.receive(100);
1:e2e71eb:                     if (req != null) {
1:e2e71eb:                         if (LOG.isDebugEnabled())
1:e2e71eb:                             LOG.debug("ECHO request message " + req.toString());
1:7dc2c4e: 
1:e2e71eb:                         resp_dest = req.getJMSReplyTo();
1:e2e71eb:                         if (resp_dest != null) {
1:e2e71eb:                             msg_prod = sess.createProducer(resp_dest);
1:e2e71eb:                             msg_prod.send(req);
1:e2e71eb:                             msg_prod.close();
1:e2e71eb:                             msg_prod = null;
1:e2e71eb:                         } else {
1:e2e71eb:                             LOG.warn("invalid request: no reply-to destination given");
1:e2e71eb:                         }
1:e2e71eb:                     }
1:e2e71eb:                 }
1:e2e71eb:             } catch (Exception ex) {
1:e2e71eb:                 LOG.error(null, ex);
1:e2e71eb:             } finally {
1:e2e71eb:                 LOG.info("shutting down test echo service");
1:7dc2c4e: 
1:e2e71eb:                 try {
1:e2e71eb:                     jmsConn.stop();
1:e2e71eb:                 } catch (javax.jms.JMSException jms_exc) {
1:e2e71eb:                     LOG.warn("error on shutting down JMS connection", jms_exc);
1:e2e71eb:                 }
1:7dc2c4e: 
1:e2e71eb:                 synchronized (this) {
1:e2e71eb:                     waitShutdown.countDown();
1:e2e71eb:                 }
1:e2e71eb:             }
1:e2e71eb:         }
1:7dc2c4e: 
1:e2e71eb:         /**
1:e2e71eb:          * Shut down the service, waiting up to 3 seconds for the service to
1:e2e71eb:          * terminate.
1:e2e71eb:          */
1:e2e71eb:         public void shutdown() {
1:e2e71eb:             CountDownLatch wait_l;
1:7dc2c4e: 
1:e2e71eb:             synchronized (this) {
1:e2e71eb:                 wait_l = waitShutdown;
1:e2e71eb:             }
1:7dc2c4e: 
1:e2e71eb:             Shutdown_ind = true;
1:7dc2c4e: 
1:e2e71eb:             try {
1:e2e71eb:                 if (wait_l != null) {
1:e2e71eb:                     if (wait_l.await(3000, TimeUnit.MILLISECONDS)) {
1:e2e71eb:                         LOG.info("echo service shutdown complete");
1:e2e71eb:                     } else {
1:e2e71eb:                         LOG.warn("timeout waiting for echo service shutdown");
1:e2e71eb:                     }
1:e2e71eb:                 } else {
1:e2e71eb:                     LOG.info("echo service shutdown: service does not appear to be active");
1:e2e71eb:                 }
1:e2e71eb:             } catch (InterruptedException int_exc) {
1:e2e71eb:                 LOG.warn("interrupted while waiting for echo service shutdown");
1:e2e71eb:             }
1:e2e71eb:         }
1:e2e71eb:     }
85:7dc2c4e: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:8e00c6c
/////////////////////////////////////////////////////////////////////////
1:                 excl_dest = ActiveMQDestination.createDestination(">", ActiveMQDestination.TOPIC_TYPE);
1:                 excl_dest = ActiveMQDestination.createDestination(">", ActiveMQDestination.QUEUE_TYPE);
author:Gary Tully
-------------------------------------------------------------------------------
commit:f4bed15
/////////////////////////////////////////////////////////////////////////
1:             LOG.error("Have " + cons_client.getNumMsgReceived() + " messages; expected " + tot_expected);
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
commit:e2e71eb
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertTrue;
1: 
1: import java.net.URI;
1: import java.net.URISyntaxException;
1: import java.util.ArrayList;
1: import java.util.Enumeration;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.network.DiscoveryNetworkConnector;
1: import org.apache.activemq.network.NetworkConnector;
1: import org.junit.Test;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: public class AMQ3274Test {
1:     private static final transient Logger LOG = LoggerFactory.getLogger(AMQ3274Test.class);
1:     protected static int Next_broker_num = 0;
1:     protected EmbeddedTcpBroker broker1;
1:     protected EmbeddedTcpBroker broker2;
1:     protected int nextEchoId = 0;
1:     protected boolean testError = false;
1:     protected int echoResponseFill = 0; // Number of "filler" response messages per request
1:     public AMQ3274Test() throws Exception {
1:         broker1 = new EmbeddedTcpBroker();
1:         broker2 = new EmbeddedTcpBroker();
1:         broker1.coreConnectTo(broker2, true);
1:         broker2.coreConnectTo(broker1, true);
1:     }
1:     public void logMessage(String msg) {
1:         System.out.println(msg);
1:         System.out.flush();
1:     }
1:     public void testMessages(Session sess, MessageProducer req_prod, Destination resp_dest, int num_msg) throws Exception {
1:         MessageConsumer resp_cons;
1:         TextMessage msg;
1:         MessageClient cons_client;
1:         int cur;
1:         int tot_expected;
1:         resp_cons = sess.createConsumer(resp_dest);
1:         cons_client = new MessageClient(resp_cons, num_msg);
1:         cons_client.start();
1:         cur = 0;
1:         while ((cur < num_msg) && (!testError)) {
1:             msg = sess.createTextMessage("MSG AAAA " + cur);
1:             msg.setIntProperty("SEQ", 100 + cur);
1:             msg.setStringProperty("TEST", "TOPO");
1:             msg.setJMSReplyTo(resp_dest);
1:             if (cur == (num_msg - 1))
1:                 msg.setBooleanProperty("end-of-response", true);
1:             req_prod.send(msg);
1:             cur++;
1:         }
1:         cons_client.waitShutdown(5000);
1:         if (cons_client.shutdown()) {
1:             LOG.debug("Consumer client shutdown complete");
1:         } else {
1:             LOG.debug("Consumer client shutdown incomplete!!!");
1:         }
1:         tot_expected = num_msg * (echoResponseFill + 1);
1:         if (cons_client.getNumMsgReceived() == tot_expected) {
1:             LOG.info("Have " + tot_expected + " messages, as-expected");
1:         } else {
1:             testError = true;
0:             LOG.info("Have " + cons_client.getNumMsgReceived() + " messages; expected " + tot_expected);
1:         }
1:         resp_cons.close();
1:     }
1:     /**
1:      * Test one destination between the given "producer broker" and
1:      * "consumer broker" specified.
1:      */
1:     public void testOneDest(Connection conn, Session sess, Destination cons_dest, String prod_broker_url, String cons_broker_url, int num_msg) throws Exception {
1:         int echo_id;
1:         EchoService echo_svc;
1:         String echo_queue_name;
1:         Destination prod_dest;
1:         MessageProducer msg_prod;
1:         synchronized (this) {
1:             echo_id = this.nextEchoId;
1:             this.nextEchoId++;
1:         }
1:         echo_queue_name = "echo.queue." + echo_id;
1:         LOG.trace("destroying the echo queue in case an old one exists");
1:         removeQueue(conn, echo_queue_name);
1:         echo_svc = new EchoService(echo_queue_name, prod_broker_url);
1:         echo_svc.start();
1:         LOG.trace("Creating echo queue and producer");
1:         prod_dest = sess.createQueue(echo_queue_name);
1:         msg_prod = sess.createProducer(prod_dest);
1:         testMessages(sess, msg_prod, cons_dest, num_msg);
1:         echo_svc.shutdown();
1:         msg_prod.close();
1:     }
1:     /**
1:      * TEST TEMPORARY TOPICS
1:      */
1:     public void testTempTopic(String prod_broker_url, String cons_broker_url) throws Exception {
1:         Connection conn;
1:         Session sess;
1:         Destination cons_dest;
1:         int num_msg;
1:         num_msg = 5;
1:         LOG.info("TESTING TEMP TOPICS " + prod_broker_url + " -> " + cons_broker_url + " (" + num_msg + " messages)");
1:         conn = createConnection(cons_broker_url);
1:         conn.start();
1:         sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         LOG.trace("Creating destination");
1:         cons_dest = sess.createTemporaryTopic();
1:         testOneDest(conn, sess, cons_dest, prod_broker_url, cons_broker_url, num_msg);
1:         sess.close();
1:         conn.close();
1:     }
1:     /**
1:      * TEST TOPICS
1:      */
1:     public void testTopic(String prod_broker_url, String cons_broker_url) throws Exception {
1:         int num_msg;
1:         Connection conn;
1:         Session sess;
1:         String topic_name;
1:         Destination cons_dest;
1:         num_msg = 5;
1:         LOG.info("TESTING TOPICS " + prod_broker_url + " -> " + cons_broker_url + " (" + num_msg + " messages)");
1:         conn = createConnection(cons_broker_url);
1:         conn.start();
1:         sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         topic_name = "topotest2.perm.topic";
1:         LOG.trace("Removing existing Topic");
1:         removeTopic(conn, topic_name);
1:         LOG.trace("Creating Topic, " + topic_name);
1:         cons_dest = sess.createTopic(topic_name);
1:         testOneDest(conn, sess, cons_dest, prod_broker_url, cons_broker_url, num_msg);
1:         removeTopic(conn, topic_name);
1:         sess.close();
1:         conn.close();
1:     }
1:     /**
1:      * TEST TEMPORARY QUEUES
1:      */
1:     public void testTempQueue(String prod_broker_url, String cons_broker_url) throws Exception {
1:         int num_msg;
1:         Connection conn;
1:         Session sess;
1:         Destination cons_dest;
1:         num_msg = 5;
1:         LOG.info("TESTING TEMP QUEUES " + prod_broker_url + " -> " + cons_broker_url + " (" + num_msg + " messages)");
1:         conn = createConnection(cons_broker_url);
1:         conn.start();
1:         sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         LOG.trace("Creating destination");
1:         cons_dest = sess.createTemporaryQueue();
1:         testOneDest(conn, sess, cons_dest, prod_broker_url, cons_broker_url, num_msg);
1:         sess.close();
1:         conn.close();
1:     }
1:     /**
1:      * TEST QUEUES
1:      */
1:     public void testQueue(String prod_broker_url, String cons_broker_url) throws Exception {
1:         int num_msg;
1:         Connection conn;
1:         Session sess;
1:         String queue_name;
1:         Destination cons_dest;
1:         num_msg = 5;
1:         LOG.info("TESTING QUEUES " + prod_broker_url + " -> " + cons_broker_url + " (" + num_msg + " messages)");
1:         conn = createConnection(cons_broker_url);
1:         conn.start();
1:         sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         queue_name = "topotest2.perm.queue";
1:         LOG.trace("Removing existing Queue");
1:         removeQueue(conn, queue_name);
1:         LOG.trace("Creating Queue, " + queue_name);
1:         cons_dest = sess.createQueue(queue_name);
1:         testOneDest(conn, sess, cons_dest, prod_broker_url, cons_broker_url, num_msg);
1:         removeQueue(conn, queue_name);
1:         sess.close();
1:         conn.close();
1:     }
1:     @Test
1:     public void run() throws Exception {
1:         Thread start1;
1:         Thread start2;
1:         testError = false;
1:         // Use threads to avoid startup deadlock since the first broker started waits until
1:         // it knows the name of the remote broker before finishing its startup, which means
1:         // the remote must already be running.
1:         start1 = new Thread() {
1:             public void run() {
1:                 try {
1:                     broker1.start();
1:                 } catch (Exception ex) {
1:                     LOG.error(null, ex);
1:                 }
1:             }
1:         };
1:         start2 = new Thread() {
1:             public void run() {
1:                 try {
1:                     broker2.start();
1:                 } catch (Exception ex) {
1:                     LOG.error(null, ex);
1:                 }
1:             }
1:         };
1:         start1.start();
1:         start2.start();
1:         start1.join();
1:         start2.join();
1:         if (!testError) {
1:             this.testTempTopic(broker1.getConnectionUrl(), broker2.getConnectionUrl());
1:         }
1:         if (!testError) {
1:             this.testTempQueue(broker1.getConnectionUrl(), broker2.getConnectionUrl());
1:         }
1:         if (!testError) {
1:             this.testTopic(broker1.getConnectionUrl(), broker2.getConnectionUrl());
1:         }
1:         if (!testError) {
1:             this.testQueue(broker1.getConnectionUrl(), broker2.getConnectionUrl());
1:         }
1:         Thread.sleep(100);
1:         shutdown();
1:         assertTrue(!testError);
1:     }
1:     public void shutdown() throws Exception {
1:         broker1.stop();
1:         broker2.stop();
1:     }
1:     /**
1:      * @param args
1:      *            the command line arguments
1:      */
1:     public static void main(String[] args) {
1:         AMQ3274Test main_obj;
1:         try {
1:             main_obj = new AMQ3274Test();
1:             main_obj.run();
1:         } catch (Exception ex) {
1:             ex.printStackTrace();
1:             LOG.error(null, ex);
1:             System.exit(0);
1:         }
1:     }
1:     protected Connection createConnection(String url) throws Exception {
1:         return org.apache.activemq.ActiveMQConnection.makeConnection(url);
1:     }
1:     protected static void removeQueue(Connection conn, String dest_name) throws java.lang.Exception {
1:         org.apache.activemq.command.ActiveMQDestination dest;
1:         if (conn instanceof org.apache.activemq.ActiveMQConnection) {
1:             dest = org.apache.activemq.command.ActiveMQDestination.createDestination(dest_name,
1:                     (byte) org.apache.activemq.command.ActiveMQDestination.QUEUE_TYPE);
1:             ((org.apache.activemq.ActiveMQConnection) conn).destroyDestination(dest);
1:         }
1:     }
1:     protected static void removeTopic(Connection conn, String dest_name) throws java.lang.Exception {
1:         org.apache.activemq.command.ActiveMQDestination dest;
1:         if (conn instanceof org.apache.activemq.ActiveMQConnection) {
1:             dest = org.apache.activemq.command.ActiveMQDestination.createDestination(dest_name,
1:                     (byte) org.apache.activemq.command.ActiveMQDestination.TOPIC_TYPE);
1:             ((org.apache.activemq.ActiveMQConnection) conn).destroyDestination(dest);
1:         }
1:     }
1:     @SuppressWarnings("rawtypes")
1:     public static String fmtMsgInfo(Message msg) throws Exception {
1:         StringBuilder msg_desc;
1:         String prop;
1:         Enumeration prop_enum;
1:         msg_desc = new StringBuilder();
1:         msg_desc = new StringBuilder();
1:         if (msg instanceof TextMessage) {
1:             msg_desc.append(((TextMessage) msg).getText());
1:         } else {
1:             msg_desc.append("[");
1:             msg_desc.append(msg.getClass().getName());
1:             msg_desc.append("]");
1:         }
1:         prop_enum = msg.getPropertyNames();
1:         while (prop_enum.hasMoreElements()) {
1:             prop = (String) prop_enum.nextElement();
1:             msg_desc.append("; ");
1:             msg_desc.append(prop);
1:             msg_desc.append("=");
1:             msg_desc.append(msg.getStringProperty(prop));
1:         }
1:         return msg_desc.toString();
1:     }
1:     // ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
1:     // /////////////////////////////////////////////// INTERNAL CLASSES
1:     // /////////////////////////////////////////////////
1:     // ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
1:     protected class EmbeddedTcpBroker {
1:         protected BrokerService brokerSvc;
1:         protected int brokerNum;
1:         protected String brokerName;
1:         protected String brokerId;
1:         protected int port;
1:         protected String tcpUrl;
1:         public EmbeddedTcpBroker() throws Exception {
1:             brokerSvc = new BrokerService();
1:             synchronized (this.getClass()) {
1:                 brokerNum = Next_broker_num;
1:                 Next_broker_num++;
1:             }
1:             brokerName = "broker" + brokerNum;
1:             brokerId = "b" + brokerNum;
1:             brokerSvc.setBrokerName(brokerName);
1:             brokerSvc.setBrokerId(brokerId);
1:             brokerSvc.setPersistent(false);
1:             brokerSvc.setUseJmx(false);
1:             tcpUrl = brokerSvc.addConnector("tcp://localhost:0").getPublishableConnectString();
1:         }
1:         public Connection createConnection() throws URISyntaxException, JMSException {
1:             Connection result;
1:             result = org.apache.activemq.ActiveMQConnection.makeConnection(this.tcpUrl);
1:             return result;
1:         }
1:         public String getConnectionUrl() {
1:             return this.tcpUrl;
1:         }
1:         /**
1:          * Create network connections to the given broker using the
1:          * network-connector configuration of CORE brokers (e.g.
1:          * core1.bus.dev1.coresys.tmcs)
1:          *
1:          * @param other
1:          * @param duplex_f
1:          */
1:         public void coreConnectTo(EmbeddedTcpBroker other, boolean duplex_f) throws Exception {
1:             this.makeConnectionTo(other, duplex_f, true);
1:             this.makeConnectionTo(other, duplex_f, false);
1:         }
1:         public void start() throws Exception {
1:             brokerSvc.start();
1:         }
1:         public void stop() throws Exception {
1:             brokerSvc.stop();
1:         }
1:         /**
1:          * Make one connection to the other embedded broker, of the specified
1:          * type (queue or topic) using the standard CORE broker networking.
1:          *
1:          * @param other
1:          * @param duplex_f
1:          * @param queue_f
1:          * @throws Exception
1:          */
1:         protected void makeConnectionTo(EmbeddedTcpBroker other, boolean duplex_f, boolean queue_f) throws Exception {
1:             NetworkConnector nw_conn;
1:             String prefix;
1:             ActiveMQDestination excl_dest;
1:             ArrayList<ActiveMQDestination> excludes;
1:             nw_conn = new DiscoveryNetworkConnector(new URI("static:(" + other.tcpUrl + ")"));
1:             nw_conn.setDuplex(duplex_f);
1:             if (queue_f)
1:                 nw_conn.setConduitSubscriptions(false);
1:             else
1:                 nw_conn.setConduitSubscriptions(true);
1:             nw_conn.setNetworkTTL(5);
1:             nw_conn.setSuppressDuplicateQueueSubscriptions(true);
1:             nw_conn.setDecreaseNetworkConsumerPriority(true);
1:             nw_conn.setBridgeTempDestinations(true);
1:             if (queue_f) {
1:                 prefix = "queue";
0:                 excl_dest = ActiveMQDestination.createDestination(">", ActiveMQDestination.QUEUE_TYPE);
1:             } else {
1:                 prefix = "topic";
0:                 excl_dest = ActiveMQDestination.createDestination(">", ActiveMQDestination.TOPIC_TYPE);
1:             }
1:             excludes = new ArrayList<ActiveMQDestination>();
1:             excludes.add(excl_dest);
1:             nw_conn.setExcludedDestinations(excludes);
1:             if (duplex_f)
1:                 nw_conn.setName(this.brokerId + "<-" + prefix + "->" + other.brokerId);
1:             else
1:                 nw_conn.setName(this.brokerId + "-" + prefix + "->" + other.brokerId);
1:             brokerSvc.addNetworkConnector(nw_conn);
1:         }
1:     }
1:     protected class MessageClient extends java.lang.Thread {
1:         protected MessageConsumer msgCons;
1:         protected boolean shutdownInd;
1:         protected int expectedCount;
1:         protected int lastSeq = 0;
1:         protected int msgCount = 0;
1:         protected boolean haveFirstSeq;
1:         protected CountDownLatch shutdownLatch;
1:         public MessageClient(MessageConsumer cons, int num_to_expect) {
1:             msgCons = cons;
1:             expectedCount = (num_to_expect * (echoResponseFill + 1));
1:             shutdownLatch = new CountDownLatch(1);
1:         }
1:         public void run() {
1:             CountDownLatch latch;
1:             try {
1:                 synchronized (this) {
1:                     latch = shutdownLatch;
1:                 }
1:                 shutdownInd = false;
1:                 processMessages();
1:                 latch.countDown();
1:             } catch (Exception exc) {
1:                 LOG.error("message client error", exc);
1:             }
1:         }
1:         public void waitShutdown(long timeout) {
1:             CountDownLatch latch;
1:             try {
1:                 synchronized (this) {
1:                     latch = shutdownLatch;
1:                 }
1:                 if (latch != null)
1:                     latch.await(timeout, TimeUnit.MILLISECONDS);
1:                 else
1:                     LOG.info("echo client shutdown: client does not appear to be active");
1:             } catch (InterruptedException int_exc) {
1:                 LOG.warn("wait for message client shutdown interrupted", int_exc);
1:             }
1:         }
1:         public boolean shutdown() {
1:             boolean down_ind;
1:             if (!shutdownInd) {
1:                 shutdownInd = true;
1:             }
1:             waitShutdown(200);
1:             synchronized (this) {
1:                 if ((shutdownLatch == null) || (shutdownLatch.getCount() == 0))
1:                     down_ind = true;
1:                 else
1:                     down_ind = false;
1:             }
1:             return down_ind;
1:         }
1:         public int getNumMsgReceived() {
1:             return msgCount;
1:         }
1:         protected void processMessages() throws Exception {
1:             Message in_msg;
1:             haveFirstSeq = false;
1:             while ((!shutdownInd) && (!testError)) {
1:                 in_msg = msgCons.receive(100);
1:                 if (in_msg != null) {
1:                     msgCount++;
1:                     checkMessage(in_msg);
1:                 }
1:             }
1:         }
1:         protected void checkMessage(Message in_msg) throws Exception {
1:             int seq;
1:             LOG.debug("received message " + fmtMsgInfo(in_msg));
1:             if (in_msg.propertyExists("SEQ")) {
1:                 seq = in_msg.getIntProperty("SEQ");
1:                 if ((haveFirstSeq) && (seq != (lastSeq + 1))) {
1:                     LOG.error("***ERROR*** incorrect sequence number; expected " + Integer.toString(lastSeq + 1) + " but have " + Integer.toString(seq));
1:                     testError = true;
1:                 }
1:                 lastSeq = seq;
1:                 if (msgCount > expectedCount) {
1:                     LOG.warn("*** have more messages than expected; have " + msgCount + "; expect " + expectedCount);
1:                     testError = true;
1:                 }
1:             }
1:             if (in_msg.propertyExists("end-of-response")) {
1:                 LOG.trace("received end-of-response message");
1:                 shutdownInd = true;
1:             }
1:         }
1:     }
1:     protected class EchoService extends java.lang.Thread {
1:         protected String destName;
1:         protected Connection jmsConn;
1:         protected Session sess;
1:         protected MessageConsumer msg_cons;
1:         protected boolean Shutdown_ind;
1:         protected Destination req_dest;
1:         protected Destination resp_dest;
1:         protected MessageProducer msg_prod;
1:         protected CountDownLatch waitShutdown;
1:         public EchoService(String dest, Connection broker_conn) throws Exception {
1:             destName = dest;
1:             jmsConn = broker_conn;
1:             Shutdown_ind = false;
1:             sess = jmsConn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             req_dest = sess.createQueue(destName);
1:             msg_cons = sess.createConsumer(req_dest);
1:             jmsConn.start();
1:             waitShutdown = new CountDownLatch(1);
1:         }
1:         public EchoService(String dest, String broker_url) throws Exception {
1:             this(dest, ActiveMQConnection.makeConnection(broker_url));
1:         }
1:         public void run() {
1:             Message req;
1:             try {
1:                 LOG.info("STARTING ECHO SERVICE");
1:                 while (!Shutdown_ind) {
1:                     req = msg_cons.receive(100);
1:                     if (req != null) {
1:                         if (LOG.isDebugEnabled())
1:                             LOG.debug("ECHO request message " + req.toString());
1:                         resp_dest = req.getJMSReplyTo();
1:                         if (resp_dest != null) {
1:                             msg_prod = sess.createProducer(resp_dest);
1:                             msg_prod.send(req);
1:                             msg_prod.close();
1:                             msg_prod = null;
1:                         } else {
1:                             LOG.warn("invalid request: no reply-to destination given");
1:                         }
1:                     }
1:                 }
1:             } catch (Exception ex) {
1:                 LOG.error(null, ex);
1:             } finally {
1:                 LOG.info("shutting down test echo service");
1:                 try {
1:                     jmsConn.stop();
1:                 } catch (javax.jms.JMSException jms_exc) {
1:                     LOG.warn("error on shutting down JMS connection", jms_exc);
1:                 }
1:                 synchronized (this) {
1:                     waitShutdown.countDown();
1:                 }
1:             }
1:         }
1:         /**
1:          * Shut down the service, waiting up to 3 seconds for the service to
1:          * terminate.
1:          */
1:         public void shutdown() {
1:             CountDownLatch wait_l;
1:             synchronized (this) {
1:                 wait_l = waitShutdown;
1:             }
1:             Shutdown_ind = true;
1:             try {
1:                 if (wait_l != null) {
1:                     if (wait_l.await(3000, TimeUnit.MILLISECONDS)) {
1:                         LOG.info("echo service shutdown complete");
1:                     } else {
1:                         LOG.warn("timeout waiting for echo service shutdown");
1:                     }
1:                 } else {
1:                     LOG.info("echo service shutdown: service does not appear to be active");
1:                 }
1:             } catch (InterruptedException int_exc) {
1:                 LOG.warn("interrupted while waiting for echo service shutdown");
1:             }
1:         }
1:     }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:974f689
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0: import org.junit.Test;
1: 
1: import javax.jms.Connection;
1: import javax.jms.Destination;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
0: import java.net.URI;
0: import java.net.URISyntaxException;
0: import java.util.ArrayList;
0: import java.util.Enumeration;
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.TimeUnit;
1: 
0: import static org.junit.Assert.assertTrue;
author:Robert Davies
-------------------------------------------------------------------------------
commit:7dc2c4e
/////////////////////////////////////////////////////////////////////////
0: /*
1:  */
1: 
1: package org.apache.activemq.bugs;
1: 
0: import java.net.URI;
0: import java.net.URISyntaxException;
0: import java.util.ArrayList;
0: import java.util.Enumeration;
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.TimeUnit;
0: import java.util.logging.Level;
0: import java.util.logging.Logger;
0: import javax.jms.Connection;
0: import javax.jms.Destination;
0: import javax.jms.JMSException;
0: import javax.jms.Message;
0: import javax.jms.TextMessage;
0: import javax.jms.Topic;
0: import javax.jms.MessageProducer;
0: import javax.jms.MessageConsumer;
0: import javax.jms.Session;
1: 
0: import org.junit.*;
0: import static org.junit.Assert.*;
1: 
0: import org.apache.activemq.ActiveMQConnection;
0: import org.apache.activemq.broker.BrokerService;
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.network.DiscoveryNetworkConnector;
0: import org.apache.activemq.network.NetworkConnector;
1: 
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
1: 
0: /**
0:  *
1:  */
0: public class AMQ3274Test
0: {
0: 	protected static int		Next_broker_num = 0;
0: 	protected EmbeddedTcpBroker	broker1;
0: 	protected EmbeddedTcpBroker	broker2;
1: 
0: 	protected int			nextEchoId = 0;
0: 	protected boolean		testError = false;
1: 
0: 	protected int			echoResponseFill = 0;   // Number of "filler" response messages per request
1: 
0: 	protected static Log		LOG;
1: 
0: 	static
0: 	{
0: 		LOG = LogFactory.getLog(AMQ3274Test.class);
1: 	}
1: 
0: 	public AMQ3274Test ()
0: 	throws Exception
0: 	{
0: 		broker1 = new EmbeddedTcpBroker();
0: 		broker2 = new EmbeddedTcpBroker();
1: 
0: 		broker1.coreConnectTo(broker2, true);
0: 		broker2.coreConnectTo(broker1, true);
1: 	}
1: 
0: 	public void logMessage (String msg)
0: 	{
0: 		System.out.println(msg);
0: 		System.out.flush();
1: 	}
1: 
1: 
0: 	/**
0: 	 *
1: 	 */
1: 
0: 	public void testMessages (Session sess, MessageProducer req_prod, Destination resp_dest, int num_msg)
0: 	throws Exception
0: 	{
0: 		MessageConsumer resp_cons;
0: 		TextMessage		msg;
0: 		MessageClient	cons_client;
0: 		int				cur;
0: 		int				tot_expected;
1: 
0: 		resp_cons = sess.createConsumer(resp_dest);
1: 
0: 		cons_client = new MessageClient(resp_cons, num_msg);
0: 		cons_client.start();
1: 
0: 		cur = 0;
0: 		while ( ( cur < num_msg ) && ( ! testError ) )
0: 		{
0: 			msg = sess.createTextMessage("MSG AAAA " + cur);
0: 			msg.setIntProperty("SEQ", 100 + cur);
0: 			msg.setStringProperty("TEST", "TOPO");
0: 			msg.setJMSReplyTo(resp_dest);
1: 
0: 			if ( cur == ( num_msg - 1 ) )
0: 				msg.setBooleanProperty("end-of-response", true);
1: 
0: 			req_prod.send(msg);
1: 
0: 			cur++;
1: 		}
1: 
0: 			//
0: 			// Give the consumer some time to receive the response.
0: 			//
0: 		cons_client.waitShutdown(5000);
1: 
0: 			//
0: 			// Now shutdown the consumer if it's still running.
0: 			//
0: 		if ( cons_client.shutdown() )
0: 			LOG.debug("Consumer client shutdown complete");
0: 		else
0: 			LOG.debug("Consumer client shutdown incomplete!!!");
1: 
1: 
0: 			//
0: 			// Check that the correct number of messages was received.
0: 			//
0: 		tot_expected = num_msg * ( echoResponseFill + 1 );
1: 
0: 		if ( cons_client.getNumMsgReceived() == tot_expected )
0: 		{
0: 			LOG.info("Have " + tot_expected + " messages, as-expected");
1: 		}
0: 		else
0: 		{
0: 			testError = true;
0: 			LOG.info("Have " + cons_client.getNumMsgReceived() + " messages; expected " + tot_expected);
1: 		}
1: 
0: 		resp_cons.close();
1: 	}
1: 
1: 
0: 	/**
0: 	 * Test one destination between the given "producer broker" and "consumer broker" specified.
1: 	 */
0: 	public void testOneDest (Connection conn, Session sess, Destination cons_dest, String prod_broker_url,
0: 	                         String cons_broker_url, int num_msg)
0: 	throws Exception
0: 	{
0: 		int			echo_id;
1: 
0: 		EchoService		echo_svc;
0: 		String			echo_queue_name;
0: 		Destination		prod_dest;
0: 		MessageProducer		msg_prod;
1: 
0: 		synchronized ( this )
0: 		{
0: 			echo_id = this.nextEchoId;
0: 			this.nextEchoId++;
1: 		}
1: 
0: 		echo_queue_name = "echo.queue." + echo_id;
1: 
0: 			//
0: 			// Remove any previously-created echo queue with the same name.
0: 			//
0: 		LOG.trace("destroying the echo queue in case an old one exists");
0: 		removeQueue(conn, echo_queue_name);
1: 
1: 
0: 			//
0: 			// Now start the echo service with that queue.
0: 			//
0: 		echo_svc = new EchoService(echo_queue_name, prod_broker_url);
0: 		echo_svc.start();
1: 
1: 
0: 			//
0: 			// Create the Producer to the echo request Queue
0: 			//
0: 		LOG.trace("Creating echo queue and producer");
0: 		prod_dest = sess.createQueue(echo_queue_name);
0: 		msg_prod = sess.createProducer(prod_dest);
1: 
1: 
0: 			//
0: 			// Pass messages around.
0: 			//
0: 		testMessages(sess, msg_prod, cons_dest, num_msg);
1: 
1: 
0: 		//
0: 		//
0: 		//
1: 
0: 		echo_svc.shutdown();
0: 		msg_prod.close();
1: 	}
1: 
1: 
0: 	/**
0: 	 * TEST TEMPORARY TOPICS
1: 	 */
0: 	public void testTempTopic (String prod_broker_url, String cons_broker_url)
0: 	throws Exception
0: 	{
0: 		Connection		conn;
0: 		Session			sess;
0: 		Destination		cons_dest;
0: 		int			echo_id;
0: 		int			num_msg;
1: 
0: 		num_msg = 5;
1: 
0: 		LOG.info("TESTING TEMP TOPICS " + prod_broker_url + " -> " + cons_broker_url + " (" + num_msg +
0: 		         " messages)");
1: 
1: 
0: 			//
0: 			// Connect to the bus.
0: 			//
1: 
0: 		conn = createConnection(cons_broker_url);
0: 		conn.start();
0: 		sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1: 
0: 			//
0: 			// Create the destination on which messages are being tested.
0: 			//
1: 
0: 		LOG.trace("Creating destination");
0: 		cons_dest = sess.createTemporaryTopic();
1: 
0: 		testOneDest(conn, sess, cons_dest, prod_broker_url, cons_broker_url, num_msg);
1: 
1: 
0: 			//
0: 			// Cleanup
0: 			//
1: 
0: 		sess.close();
0: 		conn.close();
1: 	}
1: 
1: 
0: 	/**
0: 	 * TEST TOPICS
1: 	 */
0: 	public void testTopic (String prod_broker_url, String cons_broker_url)
0: 	throws Exception
0: 	{
0: 		int				num_msg;
1: 
0: 		Connection		conn;
0: 		Session			sess;
0: 		String			topic_name;
1: 
0: 		Destination		cons_dest;
1: 
0: 		num_msg = 5;
1: 
0: 		LOG.info("TESTING TOPICS " + prod_broker_url + " -> " + cons_broker_url + " (" + num_msg +
0: 		         " messages)");
1: 
1: 
0: 			//
0: 			// Connect to the bus.
0: 			//
1: 
0: 		conn = createConnection(cons_broker_url);
0: 		conn.start();
0: 		sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1: 
0: 			//
0: 			// Create the destination on which messages are being tested.
0: 			//
1: 
0: 		topic_name = "topotest2.perm.topic";
0: 		LOG.trace("Removing existing Topic");
0: 		removeTopic(conn, topic_name);
0: 		LOG.trace("Creating Topic, " + topic_name);
0: 		cons_dest = sess.createTopic(topic_name);
1: 
0: 		testOneDest(conn, sess, cons_dest, prod_broker_url, cons_broker_url, num_msg);
1: 
1: 
0: 			//
0: 			// Cleanup
0: 			//
1: 
0: 		removeTopic(conn, topic_name);
0: 		sess.close();
0: 		conn.close();
1: 	}
1: 
1: 
0: 	/**
0: 	 * TEST TEMPORARY QUEUES
1: 	 */
0: 	public void testTempQueue (String prod_broker_url, String cons_broker_url)
0: 	throws Exception
0: 	{
0: 		int		echo_id;
0: 		int		num_msg;
1: 
0: 		Connection	conn;
0: 		Session		sess;
1: 
0: 		Destination	cons_dest;
1: 
0: 		num_msg = 5;
1: 
0: 		LOG.info("TESTING TEMP QUEUES " + prod_broker_url + " -> " + cons_broker_url + " (" + num_msg +
0: 		         " messages)");
1: 
1: 
0: 			//
0: 			// Connect to the bus.
0: 			//
1: 
0: 		conn = createConnection(cons_broker_url);
0: 		conn.start();
0: 		sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1: 
0: 			//
0: 			// Create the destination on which messages are being tested.
0: 			//
1: 
0: 		LOG.trace("Creating destination");
0: 		cons_dest = sess.createTemporaryQueue();
1: 
0: 		testOneDest(conn, sess, cons_dest, prod_broker_url, cons_broker_url, num_msg);
1: 
1: 
0: 			//
0: 			// Cleanup
0: 			//
1: 
0: 		sess.close();
0: 		conn.close();
1: 	}
1: 
1: 
0: 	/**
0: 	 * TEST QUEUES
1: 	 */
0: 	public void testQueue (String prod_broker_url, String cons_broker_url)
0: 	throws Exception
0: 	{
0: 		int				num_msg;
1: 
0: 		Connection		conn;
0: 		Session			sess;
0: 		String			queue_name;
1: 
0: 		Destination		cons_dest;
1: 
0: 		num_msg = 5;
1: 
0: 		LOG.info("TESTING QUEUES " + prod_broker_url + " -> " + cons_broker_url + " (" + num_msg +
0: 		         " messages)");
1: 
1: 
0: 			//
0: 			// Connect to the bus.
0: 			//
1: 
0: 		conn = createConnection(cons_broker_url);
0: 		conn.start();
0: 		sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1: 
0: 			//
0: 			// Create the destination on which messages are being tested.
0: 			//
1: 
0: 		queue_name = "topotest2.perm.queue";
0: 		LOG.trace("Removing existing Queue");
0: 		removeQueue(conn, queue_name);
0: 		LOG.trace("Creating Queue, " + queue_name);
0: 		cons_dest = sess.createQueue(queue_name);
1: 
0: 		testOneDest(conn, sess, cons_dest, prod_broker_url, cons_broker_url, num_msg);
1: 
1: 
0: 			//
0: 			// Cleanup
0: 			//
1: 
0: 		removeQueue(conn, queue_name);
0: 		sess.close();
0: 		conn.close();
1: 	}
1: 
0: 	@Test
0: 	public void run ()
0: 	throws Exception
0: 	{
0: 		Thread	start1;
0: 		Thread	start2;
1: 
0: 		testError = false;
1: 
0: 			// Use threads to avoid startup deadlock since the first broker started waits until
0: 			//	it knows the name of the remote broker before finishing its startup, which means
0: 			//	the remote must already be running.
1: 
0: 		start1 = new Thread() {
0: 			public void run()
0: 			{
0: 				try {
0: 					broker1.start();
0: 				} catch (Exception ex) {
0: 					LOG.error(null, ex);
1: 				}
1: 			}
0: 		};
1: 
0: 		start2 = new Thread() {
0: 			public void run()
0: 			{
0: 				try {
0: 					broker2.start();
0: 				} catch (Exception ex) {
0: 					LOG.error(null, ex);
1: 				}
1: 			}
0: 		};
1: 
0: 		start1.start();
0: 		start2.start();
1: 
0: 		start1.join();
0: 		start2.join();
1: 
0: 		if ( ! testError )
0: 			this.testTempTopic(broker1.getConnectionUrl(), broker2.getConnectionUrl());
1: 
0: 		if ( ! testError )
0: 			this.testTempQueue(broker1.getConnectionUrl(), broker2.getConnectionUrl());
1: 
0: 		if ( ! testError )
0: 			this.testTopic(broker1.getConnectionUrl(), broker2.getConnectionUrl());
1: 
0: 		if ( ! testError )
0: 			this.testQueue(broker1.getConnectionUrl(), broker2.getConnectionUrl());
1: 
0: 		Thread.sleep(100);
1: 
0: 		shutdown();
1: 
0: 		assertTrue(! testError);
1: 	}
1: 
0: 	public void shutdown ()
0: 	throws Exception
0: 	{
0: 		broker1.stop();
0: 		broker2.stop();
1: 	}
1: 
0: 	/**
0: 	 * @param args the command line arguments
1: 	 */
0: 	public static void main(String[] args)
0: 	{
0: 		AMQ3274Test    main_obj;
1: 
0: 		try
0: 		{
0: 			main_obj = new AMQ3274Test();
0: 			main_obj.run();
1: 		}
0: 		catch (Exception ex)
0: 		{
0: 			ex.printStackTrace();
1: 			
0: 			LOG.error(null, ex);
1: 
0: 			System.exit(0);
1: 		}
1: 	}
1: 
0: 	protected Connection	createConnection (String url)
0: 	throws Exception
0: 	{
0: 		return	org.apache.activemq.ActiveMQConnection.makeConnection(url);
1: 	}
1: 
0: 	protected static void	removeQueue (Connection conn, String dest_name)
0: 	throws java.lang.Exception
0: 	{
0: 		org.apache.activemq.command.ActiveMQDestination		dest;
1: 
0: 		if ( conn instanceof org.apache.activemq.ActiveMQConnection )
0: 		{
0: 			dest = org.apache.activemq.command.ActiveMQDestination.
0: 			createDestination(dest_name, (byte) org.apache.activemq.command.ActiveMQDestination.QUEUE_TYPE);
0: 			((org.apache.activemq.ActiveMQConnection)conn).destroyDestination(dest);
1: 		}
1: 	}
1: 
0: 	protected static void	removeTopic (Connection conn, String dest_name)
0: 	throws java.lang.Exception
0: 	{
0: 		org.apache.activemq.command.ActiveMQDestination		dest;
1: 
0: 		if ( conn instanceof org.apache.activemq.ActiveMQConnection )
0: 		{
0: 			dest = org.apache.activemq.command.ActiveMQDestination.
0: 			createDestination(dest_name, (byte) org.apache.activemq.command.ActiveMQDestination.TOPIC_TYPE);
0: 			((org.apache.activemq.ActiveMQConnection)conn).destroyDestination(dest);
1: 		}
1: 	}
1: 
0: 	public static String fmtMsgInfo (Message msg)
0: 	throws Exception
0: 	{
0: 		StringBuilder		msg_desc;
0: 		String			prop;
0: 		Enumeration		prop_enum;
1: 
0: 		msg_desc = new StringBuilder();
0: 		msg_desc = new StringBuilder();
1: 
0: 		if ( msg instanceof TextMessage )
0: 		{
0: 			msg_desc.append(((TextMessage) msg).getText());
1: 		}
0: 		else
0: 		{
0: 			msg_desc.append("[");
0: 			msg_desc.append(msg.getClass().getName());
0: 			msg_desc.append("]");
1: 		}
1: 
0: 		prop_enum = msg.getPropertyNames();
0: 		while ( prop_enum.hasMoreElements() )
0: 		{
0: 			prop = (String) prop_enum.nextElement();
0: 			msg_desc.append("; ");
0: 			msg_desc.append(prop);
0: 			msg_desc.append("=");
0: 			msg_desc.append(msg.getStringProperty(prop));
1: 		}
1: 
0: 		return	msg_desc.toString();
1: 	}
1: 
0: //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
0: /////////////////////////////////////////////////  INTERNAL CLASSES  /////////////////////////////////////////////////
0: //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
1: 
0: 	protected class EmbeddedTcpBroker
0: 	{
0: 		protected BrokerService		brokerSvc;
0: 		protected int			brokerNum;
0: 		protected String		brokerName;
0: 		protected String		brokerId;
0: 		protected int			port;
0: 		protected String		tcpUrl;
1: 
0: 		public EmbeddedTcpBroker ()
0: 		throws Exception
0: 		{
0: 			brokerSvc = new BrokerService();
1: 
0: 			synchronized ( this.getClass() )
0: 			{
0: 				brokerNum = Next_broker_num;
0: 				Next_broker_num++;
1: 			}
1: 
0: 			brokerName = "broker" + brokerNum;
0: 			brokerId = "b" + brokerNum;
1: 
0: 			brokerSvc.setBrokerName(brokerName);
0: 			brokerSvc.setBrokerId(brokerId);
1: 
0: 			brokerSvc.setPersistent(false);
0: 			brokerSvc.setUseJmx(false); // TBD
1: 
0: 			port = 60000 + ( brokerNum * 10 );
1: 
0: 				// Configure the transport connector (TCP)
0: 			tcpUrl = "tcp://127.0.0.1:" + Integer.toString(port);
0: 			brokerSvc.addConnector(tcpUrl);
1: 		}
1: 
0: 		public Connection	createConnection ()
0: 		throws URISyntaxException, JMSException
0: 		{
0: 			Connection	result;
1: 
0: 			result = org.apache.activemq.ActiveMQConnection.makeConnection(this.tcpUrl);
1: 
0: 			return	result;
1: 		}
1: 
0: 		public String	getConnectionUrl ()
0: 		{
0: 			return	this.tcpUrl;
1: 		}
1: 
1: 
0: 		/**
0: 		 * Create network connections to the given broker using the network-connector
0: 		 * configuration of CORE brokers (e.g. core1.bus.dev1.coresys.tmcs)
0: 		 *
0: 		 * @param other
0: 		 * @param duplex_f
1: 		 */
0: 		public void coreConnectTo (EmbeddedTcpBroker other, boolean duplex_f)
0: 		throws Exception
0: 		{
0: 			this.makeConnectionTo(other, duplex_f, true);
0: 			this.makeConnectionTo(other, duplex_f, false);
1: 		}
1: 
0: 		public void start ()
0: 		throws Exception
0: 		{
0: 			brokerSvc.start();
0: 			//brokerSvc.waitUntilStarted();
1: 		}
1: 
0: 		public void stop ()
0: 		throws Exception
0: 		{
0: 			brokerSvc.stop();
1: 		}
1: 
1: 
0: 		/**
0: 		 * Make one connection to the other embedded broker, of the specified type (queue or topic)
0: 		 * using the standard CORE broker networking.
0: 		 * 
0: 		 * @param other
0: 		 * @param duplex_f
0: 		 * @param queue_f
0: 		 * @throws Exception
1: 		 */
0: 		protected void	makeConnectionTo (EmbeddedTcpBroker other, boolean duplex_f, boolean queue_f)
0: 		throws Exception
0: 		{
0: 			NetworkConnector	nw_conn;
0: 			String				prefix;
0: 			ActiveMQDestination excl_dest;
0: 			ArrayList			excludes;
1: 
0: 			nw_conn = new DiscoveryNetworkConnector(new URI("static:(" + other.tcpUrl + ")"));
0: 			nw_conn.setDuplex(duplex_f);
1: 
0: 			if ( queue_f )
0: 				nw_conn.setConduitSubscriptions(false);
0: 			else
0: 				nw_conn.setConduitSubscriptions(true);
1: 
0: 			nw_conn.setNetworkTTL(5);
0: 			nw_conn.setSuppressDuplicateQueueSubscriptions(true);
0: 			nw_conn.setDecreaseNetworkConsumerPriority(true);
0: 			nw_conn.setBridgeTempDestinations(true);
1: 
0: 			if ( queue_f )
0: 			{
0: 				prefix = "queue";
0: 				excl_dest = ActiveMQDestination.createDestination(">", ActiveMQDestination.QUEUE_TYPE);
1: 			}
0: 			else
0: 			{
0: 				prefix = "topic";
0: 				excl_dest = ActiveMQDestination.createDestination(">", ActiveMQDestination.TOPIC_TYPE);
1: 			}
1: 
0: 			excludes = new ArrayList();
0: 			excludes.add(excl_dest);
0: 			nw_conn.setExcludedDestinations(excludes);
1: 
0: 			if ( duplex_f )
0: 				nw_conn.setName(this.brokerId + "<-" + prefix + "->" + other.brokerId);
0: 			else
0: 				nw_conn.setName(this.brokerId + "-" + prefix + "->" + other.brokerId);
1: 
0: 			brokerSvc.addNetworkConnector(nw_conn);
1: 		}
1: 	}
1: 
0: 	protected class MessageClient extends java.lang.Thread
0: 	{
0: 		protected MessageConsumer	msgCons;
0: 		protected boolean		shutdownInd;
0: 		protected int			expectedCount;
0: 		protected int			lastSeq = 0;
0: 		protected int			msgCount = 0;
0: 		protected boolean		haveFirstSeq;
0: 		protected CountDownLatch	shutdownLatch;
1: 
0: 		public MessageClient (MessageConsumer cons, int num_to_expect)
0: 		{
0: 			msgCons = cons;
0: 			expectedCount = ( num_to_expect * ( echoResponseFill + 1 ) );
0: 			shutdownLatch = new CountDownLatch(1);
1: 		}
1: 
0: 		public void run ()
0: 		{
0: 			CountDownLatch	latch;
1: 
0: 			try
0: 			{
0: 				synchronized ( this )
0: 				{
0: 					latch = shutdownLatch;
1: 				}
1: 
0: 				shutdownInd = false;
0: 				processMessages();
1: 
0: 				latch.countDown();
1: 			}
0: 			catch ( Exception exc )
0: 			{
0: 				LOG.error("message client error", exc);
1: 			}
1: 		}
1: 
0: 		public void waitShutdown (long timeout)
0: 		{
0: 			CountDownLatch	latch;
1: 
0: 			try
0: 			{
0: 				synchronized ( this )
0: 				{
0: 					latch = shutdownLatch;
1: 				}
1: 
0: 				if ( latch != null )
0: 					latch.await(timeout, TimeUnit.MILLISECONDS);
0: 				else
0: 					LOG.info("echo client shutdown: client does not appear to be active");
1: 			}
0: 			catch ( InterruptedException int_exc )
0: 			{
0: 				LOG.warn("wait for message client shutdown interrupted", int_exc);
1: 			}
1: 		}
1: 
0: 		public boolean shutdown ()
0: 		{
0: 			boolean down_ind;
1: 
0: 			if ( ! shutdownInd )
0: 			{
0: 				shutdownInd = true;
1: 			}
1: 
0: 			waitShutdown(200);
1: 
0: 			synchronized ( this )
0: 			{
0: 				if ( ( shutdownLatch == null ) || ( shutdownLatch.getCount() == 0 ) )
0: 					down_ind = true;
0: 				else
0: 					down_ind = false;
1: 			}
1: 
0: 			return	down_ind;
1: 		}
1: 
0: 		public int	getNumMsgReceived ()
0: 		{
0: 			return	msgCount;
1: 		}
1: 
0: 		protected void processMessages ()
0: 		throws Exception
0: 		{
0: 			Message in_msg;
1: 
0: 			haveFirstSeq = false;
1: 
0: 				//
0: 				// Stop at shutdown time or after any test error is detected.
0: 				//
1: 
0: 			while ( ( ! shutdownInd ) && ( ! testError ) )
0: 			{
0: 				in_msg = msgCons.receive(100);
1: 
0: 				if ( in_msg != null )
0: 				{
0: 					msgCount++;
0: 					checkMessage(in_msg);
1: 				}
1: 			}
1: 		}
1: 
0: 		protected void	checkMessage (Message in_msg)
0: 		throws Exception
0: 		{
0: 			int				seq;
1: 
0: 			LOG.debug("received message " + fmtMsgInfo(in_msg));
1: 
0: 				//
0: 				// Only check messages with a sequence number.
0: 				//
1: 
0: 			if ( in_msg.propertyExists("SEQ") )
0: 			{
0: 				seq = in_msg.getIntProperty("SEQ");
1: 
0: 				if ( ( haveFirstSeq ) && ( seq != ( lastSeq + 1 ) ) )
0: 				{
0: 					LOG.error("***ERROR*** incorrect sequence number; expected " +
0: 					          Integer.toString(lastSeq + 1) + " but have " +
0: 					          Integer.toString(seq));
1: 
0: 					testError = true;
1: 				}
1: 
0: 				lastSeq = seq;
1: 
0: 				if ( msgCount > expectedCount )
0: 				{
0: 					LOG.warn("*** have more messages than expected; have "	+ msgCount +
0: 					         "; expect " + expectedCount);
1: 
0: 					testError = true;
1: 				}
1: 			}
1: 
0: 			if ( in_msg.propertyExists("end-of-response") )
0: 			{
0: 				LOG.trace("received end-of-response message");
0: 				shutdownInd = true;
1: 			}
1: 		}
1: 	}
1: 
0: 	/**
0: 	 *
1: 	 */
0: 	protected class EchoService extends java.lang.Thread
0: 	{
0: 		protected String		destName;
0: 		protected Connection		jmsConn;
0: 		protected Session		sess;
0: 		protected MessageConsumer	msg_cons;
0: 		protected boolean		Shutdown_ind;
1: 
0: 		protected Destination		req_dest;
0: 		protected Destination		resp_dest;
0: 		protected MessageProducer	msg_prod;
1: 
0: 		protected CountDownLatch	waitShutdown;
1: 
0: 		public EchoService (String dest, Connection broker_conn)
0: 		throws Exception
0: 		{
0: 			destName = dest;
0: 			jmsConn = broker_conn;
1: 
0: 			Shutdown_ind = false;
1: 
0: 			sess = jmsConn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 			req_dest = sess.createQueue(destName);
0: 			msg_cons = sess.createConsumer(req_dest);
1: 
0: 			jmsConn.start();
1: 
0: 			waitShutdown = new CountDownLatch(1);
1: 		}
1: 
0: 		public EchoService (String dest, String broker_url)
0: 		throws Exception
0: 		{
0: 			this(dest, ActiveMQConnection.makeConnection(broker_url));
1: 		}
1: 
0: 		public void run ()
0: 		{
0: 			Message	req;
1: 
0: 			try
0: 			{
0: 				LOG.info("STARTING ECHO SERVICE");
1: 
0: 				while ( ! Shutdown_ind )
0: 				{
0: 					req = msg_cons.receive(100);
0: 					if ( req != null )
0: 					{
0: 						if ( LOG.isDebugEnabled() )
0: 							LOG.debug("ECHO request message " + req.toString());
1: 						
0: 						resp_dest = req.getJMSReplyTo();
0: 						if ( resp_dest != null )
0: 						{
0: 							msg_prod = sess.createProducer(resp_dest);
0: 							msg_prod.send(req);
0: 							msg_prod.close();
0: 							msg_prod = null;
1: 						}
0: 						else
0: 						{
0: 							LOG.warn("invalid request: no reply-to destination given");
1: 						}
1: 					}
1: 				}
1: 			}
0: 			catch (Exception ex)
0: 			{
0: 				LOG.error(null, ex);
1: 			}
0: 			finally
0: 			{
0: 				LOG.info("shutting down test echo service");
1: 
0: 				try
0: 				{
0: 					jmsConn.stop();
1: 				}
0: 				catch ( javax.jms.JMSException jms_exc )
0: 				{
0: 					LOG.warn("error on shutting down JMS connection", jms_exc);
1: 				}
1: 
0: 				synchronized ( this )
0: 				{
0: 					waitShutdown.countDown();
1: 				}
1: 			}
1: 		}
1: 
1: 
0: 		/**
0: 		 * Shut down the service, waiting up to 3 seconds for the service to terminate.
1: 		 */
0: 		public void shutdown ()
0: 		{
0: 			CountDownLatch	wait_l;
1: 
0: 			synchronized ( this )
0: 			{
0: 				wait_l = waitShutdown;
1: 			}
1: 
0: 			Shutdown_ind = true;
1: 			
0: 			try
0: 			{
0: 				if ( wait_l != null )
0: 				{
0: 					if ( wait_l.await(3000, TimeUnit.MILLISECONDS) )
0: 						LOG.info("echo service shutdown complete");
0: 					else
0: 						LOG.warn("timeout waiting for echo service shutdown");
1: 				}
0: 				else
0: 				{
0: 					LOG.info("echo service shutdown: service does not appear to be active");
1: 				}
1: 			}
0: 			catch ( InterruptedException int_exc )
0: 			{
0: 				LOG.warn("interrupted while waiting for echo service shutdown");
1: 			}
1: 		}
1: 	}
1: }
============================================================================