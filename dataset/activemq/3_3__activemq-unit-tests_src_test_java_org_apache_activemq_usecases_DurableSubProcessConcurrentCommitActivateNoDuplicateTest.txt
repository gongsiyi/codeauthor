1:53b29a2: /**
1:53b29a2:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:53b29a2:  * contributor license agreements.  See the NOTICE file distributed with
1:53b29a2:  * this work for additional information regarding copyright ownership.
1:53b29a2:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:53b29a2:  * (the "License"); you may not use this file except in compliance with
1:53b29a2:  * the License.  You may obtain a copy of the License at
1:53b29a2:  *
1:53b29a2:  *      http://www.apache.org/licenses/LICENSE-2.0
1:53b29a2:  *
1:53b29a2:  * Unless required by applicable law or agreed to in writing, software
1:53b29a2:  * distributed under the License is distributed on an "AS IS" BASIS,
1:53b29a2:  * WITHOUT WARRANTIES OR ONDITIONS OF ANY KIND, either express or implied.
1:53b29a2:  * See the License for the specific language governing permissions and
1:53b29a2:  * limitations under the License.
2:53b29a2:  */
1:53b29a2: package org.apache.activemq.usecases;
15:53b29a2: 
1:4743a20: import static org.junit.Assert.assertTrue;
1:4743a20: 
1:53b29a2: import java.io.File;
1:53b29a2: import java.text.SimpleDateFormat;
1:53b29a2: import java.util.ArrayList;
1:53b29a2: import java.util.Arrays;
1:53b29a2: import java.util.Date;
1:53b29a2: import java.util.HashSet;
1:53b29a2: import java.util.Vector;
1:53b29a2: import java.util.concurrent.ConcurrentLinkedQueue;
1:53b29a2: import java.util.concurrent.CopyOnWriteArrayList;
1:53b29a2: import java.util.concurrent.atomic.AtomicInteger;
1:53b29a2: import java.util.concurrent.locks.ReentrantReadWriteLock;
1:4743a20: 
1:53b29a2: import javax.jms.Connection;
1:53b29a2: import javax.jms.ConnectionFactory;
1:53b29a2: import javax.jms.JMSException;
1:53b29a2: import javax.jms.Message;
1:53b29a2: import javax.jms.MessageProducer;
1:53b29a2: import javax.jms.Session;
1:53b29a2: 
1:53b29a2: import org.apache.activemq.ActiveMQConnection;
1:53b29a2: import org.apache.activemq.ActiveMQConnectionFactory;
1:53b29a2: import org.apache.activemq.ActiveMQMessageConsumer;
1:53b29a2: import org.apache.activemq.broker.BrokerFactory;
1:53b29a2: import org.apache.activemq.broker.BrokerService;
1:53b29a2: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:53b29a2: import org.apache.activemq.broker.region.policy.PolicyMap;
1:53b29a2: import org.apache.activemq.command.ActiveMQTopic;
1:b2fca26: import org.apache.activemq.leveldb.LevelDBStore;
1:53b29a2: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1:53b29a2: import org.apache.activemq.util.ThreadTracker;
1:53b29a2: import org.junit.After;
1:53b29a2: import org.junit.Before;
1:53b29a2: import org.junit.Ignore;
1:53b29a2: import org.junit.Test;
1:53b29a2: import org.slf4j.Logger;
1:53b29a2: import org.slf4j.LoggerFactory;
1:53b29a2: 
1:53b29a2: public class DurableSubProcessConcurrentCommitActivateNoDuplicateTest {
1:53b29a2:     private static final Logger LOG = LoggerFactory.getLogger(DurableSubProcessConcurrentCommitActivateNoDuplicateTest.class);
1:53b29a2:     public static final long RUNTIME = 5 * 60 * 1000;
1:53b29a2: 
1:53b29a2:     public static final int SERVER_SLEEP = 500; // max
1:53b29a2:     public static final int CARGO_SIZE = 600; // max
1:53b29a2: 
1:53b29a2:     public static final int MAX_CLIENTS = 2;
1:53b29a2:     public static final Random CLIENT_LIFETIME = new Random(30 * 1000, 2 * 60 * 1000);
1:53b29a2:     public static final Random CLIENT_ONLINE = new Random(30 * 1000, 40 * 1000);
1:53b29a2:     public static final Random CLIENT_OFFLINE = new Random(1 * 1000, 10 * 1000);
1:53b29a2: 
1:53b29a2:     public static final int CLIENT_OFFLINE_DURING_COMMIT = 2; // random(x) == x
1:4743a20: 
1:53b29a2:     public static final Persistence PERSISTENT_ADAPTER = Persistence.KAHADB;
1:4743a20: 
1:53b29a2:     public static final long BROKER_RESTART = -2 * 60 * 1000;
1:53b29a2: 
1:53b29a2:     public static final boolean ALLOW_SUBSCRIPTION_ABANDONMENT = true;
1:53b29a2:     public static final boolean CHECK_REDELIVERY = true;
1:53b29a2: 
1:53b29a2:     private BrokerService broker;
1:53b29a2:     private ActiveMQTopic topic;
1:53b29a2: 
1:53b29a2:     private ClientManager clientManager;
1:53b29a2:     private Server server;
1:53b29a2:     private HouseKeeper houseKeeper;
1:53b29a2: 
1:53b29a2:     private final ReentrantReadWriteLock processLock = new ReentrantReadWriteLock(
1:53b29a2:             true);
1:53b29a2:     private int restartCount = 0;
1:53b29a2:     private final AtomicInteger onlineCount = new AtomicInteger(0);
1:53b29a2:     static final Vector<Throwable> exceptions = new Vector<Throwable>();
1:53b29a2: 
1:53b29a2:     // long form of test that found https://issues.apache.org/jira/browse/AMQ-3805
1:6b4d077:     @Ignore ("short version in org.apache.activemq.usecases.DurableSubscriptionOfflineTest.testNoDuplicateOnConcurrentSendTranCommitAndActivate"
1:6b4d077:      + " and org.apache.activemq.usecases.DurableSubscriptionOfflineTest.testOrderOnActivateDeactivate")
1:53b29a2:     @Test
1:53b29a2:     public void testProcess() {
1:53b29a2:         try {
1:53b29a2:             server.start();
1:53b29a2:             clientManager.start();
1:53b29a2: 
1:53b29a2:             if (ALLOW_SUBSCRIPTION_ABANDONMENT)
1:53b29a2:                 houseKeeper.start();
1:53b29a2: 
1:53b29a2:             if (BROKER_RESTART <= 0)
1:53b29a2:                 Thread.sleep(RUNTIME);
1:53b29a2:             else {
1:53b29a2:                 long end = System.currentTimeMillis() + RUNTIME;
1:53b29a2: 
2:53b29a2:                 while (true) {
1:53b29a2:                     long now = System.currentTimeMillis();
1:53b29a2:                     if (now > end)
2:53b29a2:                         break;
1:53b29a2: 
1:53b29a2:                     now = end - now;
1:53b29a2:                     now = now < BROKER_RESTART ? now : BROKER_RESTART;
1:53b29a2:                     Thread.sleep(now);
1:53b29a2: 
1:53b29a2:                     restartBroker();
3:53b29a2:                 }
1:53b29a2:             }
1:53b29a2:         } catch (Throwable e) {
2:53b29a2:             exit("ProcessTest.testProcess failed.", e);
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         //allow the clients to unsubscribe before finishing
1:53b29a2:         clientManager.setEnd(true);
1:53b29a2:         try {
1:4743a20:             Thread.sleep(60 * 1000);
1:4743a20:         } catch (InterruptedException e) {
1:4743a20:              exit("ProcessTest.testProcess failed.", e);
1:4743a20:         }
1:6b4d077: 
1:6b4d077:         server.done = true;
1:6b4d077: 
1:6b4d077:         try {
1:6b4d077:             server.join(60*1000);
1:6b4d077:         } catch (Exception ignored) {}
1:53b29a2:         processLock.writeLock().lock();
1:53b29a2:         assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
1:53b29a2:         LOG.info("DONE.");
1:53b29a2:     }
1:53b29a2: 
1:53b29a2:     private void restartBroker() throws Exception {
1:53b29a2:         LOG.info("Broker restart: waiting for components.");
1:53b29a2: 
1:53b29a2:         processLock.writeLock().lock();
1:53b29a2:         try {
1:53b29a2:             destroyBroker();
1:53b29a2:             startBroker(false);
1:53b29a2: 
1:53b29a2:             restartCount++;
1:53b29a2:             LOG.info("Broker restarted. count: " + restartCount);
1:53b29a2:         } finally {
1:53b29a2:             processLock.writeLock().unlock();
1:53b29a2:         }
1:53b29a2:     }
1:53b29a2: 
1:53b29a2:     /**
1:53b29a2:      * Creates batch of messages in a transaction periodically. The last message
1:53b29a2:      * in the transaction is always a special message what contains info about
1:53b29a2:      * the whole transaction.
1:53b29a2:      * <p>
1:53b29a2:      * Notifies the clients about the created messages also.
1:53b29a2:      */
1:53b29a2:     final class Server extends Thread {
1:53b29a2: 
1:53b29a2:         final String url = "vm://"
1:53b29a2:                 + DurableSubProcessConcurrentCommitActivateNoDuplicateTest.getName()
1:53b29a2:                 + "?"
1:53b29a2:                 + "jms.redeliveryPolicy.maximumRedeliveries=2&jms.redeliveryPolicy.initialRedeliveryDelay=500&"
1:53b29a2:                 + "jms.producerWindowSize=20971520&jms.prefetchPolicy.all=100&"
1:53b29a2:                 + "jms.copyMessageOnSend=false&jms.disableTimeStampsByDefault=false&"
1:53b29a2:                 + "jms.alwaysSyncSend=true&jms.dispatchAsync=false&"
1:53b29a2:                 + "jms.watchTopicAdvisories=false&"
1:53b29a2:                 + "waitForStart=200&create=false";
1:53b29a2:         final ConnectionFactory cf = new ActiveMQConnectionFactory(url);
1:53b29a2: 
1:53b29a2:         final Object sendMutex = new Object();
1:53b29a2:         final String[] cargos = new String[500];
1:53b29a2: 
1:53b29a2:         int transRover = 0;
1:53b29a2:         int messageRover = 0;
1:4743a20:         public volatile int committingTransaction = -1;
1:6b4d077:         public boolean  done = false;
1:53b29a2:         public Server() {
1:53b29a2:             super("Server");
1:53b29a2:             setPriority(Thread.MIN_PRIORITY);
1:53b29a2:             setDaemon(true);
1:53b29a2:         }
1:53b29a2: 
2:53b29a2:         @Override
1:53b29a2:         public void run() {
1:53b29a2:             try {
1:6b4d077:                 while (!done) {
1:53b29a2: 
1:4743a20:                     Thread.sleep(1000);
1:4743a20: 
1:53b29a2:                     processLock.readLock().lock();
1:53b29a2:                     try {
1:53b29a2:                         send();
1:53b29a2:                     } finally {
1:53b29a2:                         processLock.readLock().unlock();
1:53b29a2:                     }
1:53b29a2:                 }
1:53b29a2:             } catch (Throwable e) {
1:53b29a2:                 exit("Server.run failed", e);
1:53b29a2:             }
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         public void send() throws JMSException {
1:53b29a2:             // do not create new clients now
1:53b29a2:             // ToDo: Test this case later.
1:53b29a2:             synchronized (sendMutex) {
1:53b29a2:                 int trans = ++transRover;
1:53b29a2:                 boolean relevantTrans = true; //random(2) > 1;
1:53b29a2:                 ClientType clientType = relevantTrans ? ClientType
1:53b29a2:                         .randomClientType() : null; // sends this types
1:53b29a2:                 //int count = random(500, 700);
1:53b29a2:                 int count = 1000;
1:53b29a2: 
1:53b29a2:                 LOG.info("Sending Trans[id=" + trans + ", count="
1:53b29a2:                         + count + ", clientType=" + clientType + ", firstID=" + (messageRover+1) + "]");
1:53b29a2: 
1:53b29a2:                 Connection con = cf.createConnection();
1:53b29a2:                 Session sess = con
1:53b29a2:                         .createSession(true, Session.SESSION_TRANSACTED);
1:53b29a2:                 MessageProducer prod = sess.createProducer(null);
1:53b29a2: 
1:53b29a2:                 for (int i = 0; i < count; i++) {
1:53b29a2:                     Message message = sess.createMessage();
1:53b29a2:                     message.setIntProperty("ID", ++messageRover);
1:53b29a2:                     message.setIntProperty("TRANS", trans);
1:53b29a2:                     String type = clientType != null ? clientType
1:53b29a2:                             .randomMessageType() : ClientType
1:53b29a2:                             .randomNonRelevantMessageType();
1:53b29a2:                     message.setStringProperty("TYPE", type);
1:53b29a2: 
1:53b29a2:                     if (CARGO_SIZE > 0)
1:53b29a2:                         message.setStringProperty("CARGO",
1:53b29a2:                                 getCargo(random(CARGO_SIZE)));
1:53b29a2: 
1:53b29a2:                     prod.send(topic, message);
1:53b29a2:                     clientManager.onServerMessage(message);
1:53b29a2:                 }
1:53b29a2: 
1:53b29a2:                 Message message = sess.createMessage();
1:53b29a2:                 message.setIntProperty("ID", ++messageRover);
1:53b29a2:                 message.setIntProperty("TRANS", trans);
1:53b29a2:                 message.setBooleanProperty("COMMIT", true);
1:53b29a2:                 message.setBooleanProperty("RELEVANT", relevantTrans);
1:53b29a2:                 prod.send(topic, message);
1:53b29a2:                 clientManager.onServerMessage(message);
1:53b29a2: 
1:53b29a2:                 committingTransaction = trans;
1:53b29a2:                 sess.commit();
1:53b29a2:                 committingTransaction = -1;
1:53b29a2: 
1:53b29a2:                 LOG.info("Committed Trans[id=" + trans + ", count="
1:53b29a2:                         + count + ", clientType=" + clientType + "], ID=" + messageRover);
1:53b29a2: 
1:53b29a2:                 sess.close();
1:53b29a2:                 con.close();
1:53b29a2:             }
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         private String getCargo(int length) {
1:53b29a2:             if (length == 0)
1:53b29a2:                 return null;
1:53b29a2: 
1:53b29a2:             if (length < cargos.length) {
1:53b29a2:                 String result = cargos[length];
1:53b29a2:                 if (result == null) {
1:53b29a2:                     result = getCargoImpl(length);
1:53b29a2:                     cargos[length] = result;
1:53b29a2:                 }
1:53b29a2:                 return result;
1:53b29a2:             }
1:53b29a2:             return getCargoImpl(length);
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         private String getCargoImpl(int length) {
1:53b29a2:             StringBuilder sb = new StringBuilder(length);
1:53b29a2:             for (int i = length; --i >= 0;) {
1:53b29a2:                 sb.append('a');
1:53b29a2:             }
1:53b29a2:             return sb.toString();
1:53b29a2:         }
1:53b29a2:     }
1:53b29a2: 
1:53b29a2:     /**
1:53b29a2:      * Clients listen on different messages in the topic. The 'TYPE' property
1:53b29a2:      * helps the client to select the proper messages.
1:53b29a2:      */
1:53b29a2:     private enum ClientType {
1:53b29a2:         A("a", "b", "c"), B("c", "d", "e"), C("d", "e", "f"), D("g", "h");
1:53b29a2: 
1:53b29a2:         public final String[] messageTypes;
1:53b29a2:         public final HashSet<String> messageTypeSet;
1:53b29a2:         public final String selector;
1:53b29a2: 
1:53b29a2:         ClientType(String... messageTypes) {
1:53b29a2:             this.messageTypes = messageTypes;
1:53b29a2:             messageTypeSet = new HashSet<String>(Arrays.asList(messageTypes));
1:53b29a2: 
1:53b29a2:             StringBuilder sb = new StringBuilder("TYPE in (");
1:53b29a2:             for (int i = 0; i < messageTypes.length; i++) {
1:53b29a2:                 if (i > 0)
1:53b29a2:                     sb.append(", ");
1:53b29a2:                 sb.append('\'').append(messageTypes[i]).append('\'');
1:53b29a2:             }
1:53b29a2:             sb.append(')');
1:53b29a2:             selector = sb.toString();
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         public static ClientType randomClientType() {
1:53b29a2:             return values()[DurableSubProcessConcurrentCommitActivateNoDuplicateTest
1:53b29a2:                     .random(values().length - 1)];
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         public final String randomMessageType() {
1:53b29a2:             return messageTypes[DurableSubProcessConcurrentCommitActivateNoDuplicateTest
1:53b29a2:                     .random(messageTypes.length - 1)];
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         public static String randomNonRelevantMessageType() {
1:53b29a2:             return Integer
1:53b29a2:                     .toString(DurableSubProcessConcurrentCommitActivateNoDuplicateTest.random(20));
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         public final boolean isRelevant(String messageType) {
1:53b29a2:             return messageTypeSet.contains(messageType);
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         @Override
1:53b29a2:         public final String toString() {
1:53b29a2:             return this.name() /* + '[' + selector + ']' */;
1:53b29a2:         }
1:53b29a2:     }
1:53b29a2: 
1:53b29a2:     /**
1:53b29a2:      * Creates new cliens.
1:53b29a2:      */
1:53b29a2:     private final class ClientManager extends Thread {
1:53b29a2: 
1:53b29a2:         private int clientRover = 0;
1:53b29a2: 
1:53b29a2:         private final CopyOnWriteArrayList<Client> clients = new CopyOnWriteArrayList<Client>();
1:53b29a2: 
1:4743a20:         private boolean end;
1:53b29a2: 
1:53b29a2:         public ClientManager() {
1:53b29a2:             super("ClientManager");
1:53b29a2:             setDaemon(true);
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         public synchronized void setEnd(boolean end) {
1:4743a20:             this.end = end;
1:4743a20: 
1:4743a20:         }
1:53b29a2: 
1:4743a20:         @Override
1:53b29a2:         public void run() {
1:53b29a2:             try {
1:53b29a2:                 while (true) {
1:53b29a2:                     if (clients.size() < MAX_CLIENTS && !end) {
1:53b29a2:                         processLock.readLock().lock();
1:53b29a2:                         try {
1:53b29a2:                             createNewClient();
1:53b29a2:                         } finally {
1:53b29a2:                             processLock.readLock().unlock();
1:53b29a2:                         }
1:53b29a2:                     }
1:53b29a2: 
1:53b29a2:                     int size = clients.size();
1:53b29a2:                     //sleepRandom(1000, 4000);
1:53b29a2:                     Thread.sleep(100);
1:53b29a2:                 }
1:53b29a2:             } catch (Throwable e) {
1:53b29a2:                 exit("ClientManager.run failed.", e);
1:53b29a2:             }
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         private void createNewClient() throws JMSException {
1:53b29a2:             ClientType type = ClientType.randomClientType();
1:53b29a2: 
1:53b29a2:             Client client;
1:53b29a2:             synchronized (server.sendMutex) {
1:53b29a2:                 client = new Client(++clientRover, type, CLIENT_LIFETIME,
1:53b29a2:                         CLIENT_ONLINE, CLIENT_OFFLINE);
1:53b29a2:                 clients.add(client);
1:53b29a2:             }
1:53b29a2:             client.start();
1:53b29a2: 
1:53b29a2:             LOG.info(client.toString() + " created. " + this);
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         public void removeClient(Client client) {
1:53b29a2:             clients.remove(client);
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         public void onServerMessage(Message message) throws JMSException {
1:53b29a2:             for (Client client : clients) {
1:53b29a2:                 client.onServerMessage(message);
1:53b29a2:             }
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         @Override
1:53b29a2:         public String toString() {
1:53b29a2:             StringBuilder sb = new StringBuilder("ClientManager[count=");
1:53b29a2:             sb.append(clients.size());
1:53b29a2:             sb.append(", clients=");
1:53b29a2:             boolean sep = false;
1:53b29a2:             for (Client client : clients) {
1:53b29a2:                 if (sep)
1:53b29a2:                     sb.append(", ");
1:53b29a2:                 else
1:53b29a2:                     sep = true;
1:53b29a2:                 sb.append(client.toString());
1:53b29a2:             }
1:53b29a2:             sb.append(']');
1:53b29a2:             return sb.toString();
1:53b29a2:         }
1:53b29a2:     }
1:53b29a2: 
1:53b29a2:     /**
1:53b29a2:      * Consumes massages from a durable subscription. Goes online/offline
1:53b29a2:      * periodically. Checks the incoming messages against the sent messages of
1:53b29a2:      * the server.
1:53b29a2:      */
1:53b29a2:     private final class Client extends Thread {
1:53b29a2: 
1:53b29a2:         String url = "failover:(tcp://localhost:61656?wireFormat.maxInactivityDuration=0)?"
1:53b29a2:                 + "jms.watchTopicAdvisories=false&"
1:53b29a2:                 + "jms.alwaysSyncSend=true&jms.dispatchAsync=true&"
1:53b29a2:                 + "jms.producerWindowSize=20971520&"
1:53b29a2:                 + "jms.copyMessageOnSend=false&"
1:53b29a2:                 + "jms.sendAcksAsync=false&"
1:53b29a2:                 + "initialReconnectDelay=100&maxReconnectDelay=30000&"
1:53b29a2:                 + "useExponentialBackOff=true";
1:53b29a2:         final ConnectionFactory cf = new ActiveMQConnectionFactory(url);
1:53b29a2: 
1:53b29a2:         public static final String SUBSCRIPTION_NAME = "subscription";
1:53b29a2: 
1:53b29a2:         private final int id;
1:53b29a2:         private final String conClientId;
1:53b29a2: 
1:53b29a2:         private final Random lifetime;
1:53b29a2:         private final Random online;
1:53b29a2:         private final Random offline;
1:53b29a2: 
1:53b29a2:         private final ClientType clientType;
1:53b29a2:         private final String selector;
1:53b29a2: 
1:53b29a2:         private final ConcurrentLinkedQueue<Message> waitingList = new ConcurrentLinkedQueue<Message>();
1:53b29a2:         private final HashSet<Integer> processed = CHECK_REDELIVERY ? new HashSet<Integer>(
1:53b29a2:                 10000) : null;
1:53b29a2: 
1:53b29a2:         private ActiveMQMessageConsumer consumer = null;
1:53b29a2: 
1:53b29a2:         public Client(int id, ClientType clientType, Random lifetime,
1:53b29a2:                 Random online, Random offline) throws JMSException {
1:53b29a2:             super("Client" + id);
1:53b29a2:             setDaemon(true);
1:53b29a2: 
1:53b29a2:             this.id = id;
1:53b29a2:             conClientId = "cli" + id;
1:53b29a2:             this.clientType = clientType;
1:53b29a2:             selector = "(COMMIT = true and RELEVANT = true) or "
1:53b29a2:                     + clientType.selector;
1:53b29a2: 
1:53b29a2:             this.lifetime = lifetime;
1:53b29a2:             this.online = online;
1:53b29a2:             this.offline = offline;
1:53b29a2: 
1:53b29a2:             subscribe();
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         @Override
1:53b29a2:         public void run() {
1:53b29a2:             long end = System.currentTimeMillis() + 60000;
1:53b29a2:             try {
1:53b29a2:                 boolean sleep = false;
1:53b29a2:                 while (true) {
1:53b29a2:                     long max = end - System.currentTimeMillis();
1:53b29a2:                     if (max <= 0)
1:53b29a2:                         break;
1:53b29a2: 
1:53b29a2:                     /*
1:53b29a2:                     if (sleep)
1:53b29a2:                         offline.sleepRandom();
1:53b29a2:                     else
1:53b29a2:                         sleep = true;
1:4743a20:                     */
1:4743a20: 
1:53b29a2:                     Thread.sleep(100);
1:4743a20: 
1:53b29a2:                     processLock.readLock().lock();
1:53b29a2:                     onlineCount.incrementAndGet();
1:53b29a2:                     try {
1:53b29a2:                         process(online.next());
1:53b29a2:                     } finally {
1:53b29a2:                         onlineCount.decrementAndGet();
1:53b29a2:                         processLock.readLock().unlock();
1:53b29a2:                     }
1:53b29a2:                 }
1:53b29a2: 
1:53b29a2:                 if (!ALLOW_SUBSCRIPTION_ABANDONMENT || random(1) > 0)
1:53b29a2:                     unsubscribe();
1:53b29a2:                 else {
1:53b29a2:                     LOG.info("Client abandon the subscription. "
1:53b29a2:                             + this);
1:53b29a2: 
1:53b29a2:                     // housekeeper should sweep these abandoned subscriptions
1:53b29a2:                     houseKeeper.abandonedSubscriptions.add(conClientId);
1:53b29a2:                 }
1:53b29a2:             } catch (Throwable e) {
1:53b29a2:                 exit(toString() + " failed.", e);
1:53b29a2:             }
1:53b29a2: 
1:53b29a2:             clientManager.removeClient(this);
1:53b29a2:             LOG.info(toString() + " DONE.");
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         private void process(long millis) throws JMSException {
1:53b29a2:             //long end = System.currentTimeMillis() + millis;
1:4743a20:             long end = System.currentTimeMillis() + 200;
1:53b29a2:             long hardEnd = end + 20000; // wait to finish the transaction.
1:53b29a2:             boolean inTransaction = false;
1:53b29a2:             int transCount = 0;
1:53b29a2: 
1:53b29a2:             Connection con = openConnection();
1:53b29a2:             Session sess = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:53b29a2:             consumer = (ActiveMQMessageConsumer) sess.createDurableSubscriber(topic,
1:53b29a2:                     SUBSCRIPTION_NAME, selector, false);
1:53b29a2:             LOG.info(toString() + " ONLINE.");
1:53b29a2:             try {
1:53b29a2:                 do {
1:53b29a2:                     long max = end - System.currentTimeMillis();
1:53b29a2:                     if (max <= 0) {
1:53b29a2:                         if (!inTransaction) {
1:53b29a2:                             LOG.info(toString() + " done after no work!");
1:53b29a2:                             break;
1:53b29a2:                         }
1:53b29a2: 
1:53b29a2:                         max = hardEnd - System.currentTimeMillis();
1:53b29a2:                         if (max <= 0)
1:53b29a2:                             exit("" + this
1:53b29a2:                                     + " failed: Transaction is not finished.");
1:53b29a2:                     }
1:53b29a2: 
1:53b29a2:                     Message message = consumer.receive(max);
1:53b29a2:                     if (message == null)
1:53b29a2:                         continue;
1:53b29a2: 
1:53b29a2:                     onClientMessage(message);
1:53b29a2: 
1:53b29a2:                     if (message.propertyExists("COMMIT")) {
1:53b29a2:                         message.acknowledge(); // CLIENT_ACKNOWLEDGE
1:53b29a2: 
1:53b29a2:                         int trans = message.getIntProperty("TRANS");
1:53b29a2:                         LOG.info("Received Trans[id="
1:53b29a2:                                 + trans + ", count="
1:53b29a2:                                 + transCount + "] in " + this + ".");
1:53b29a2: 
1:53b29a2:                         inTransaction = false;
1:53b29a2:                         transCount = 0;
1:4743a20: 
1:53b29a2:                         int committing = server.committingTransaction;
1:53b29a2:                         if (committing == trans) {
1:53b29a2:                             LOG.info("Going offline during transaction commit. messageID=" + message.getIntProperty("ID"));
1:53b29a2:                             break;
1:53b29a2:                         }
1:53b29a2:                     } else {
1:53b29a2:                         inTransaction = true;
1:53b29a2:                         transCount++;
1:53b29a2:                         if (1 == transCount) {
1:53b29a2:                             LOG.info("In Trans[id=" + message.getIntProperty("TRANS") + "] first ID=" + message.getIntProperty("ID"));
1:53b29a2:                         }
1:53b29a2:                     }
1:53b29a2:                 } while (true);
1:53b29a2:             } finally {
1:53b29a2:                 sess.close();
1:53b29a2:                 con.close();
1:53b29a2: 
1:53b29a2:                 LOG.info(toString() + " OFFLINE.");
1:53b29a2: 
1:53b29a2:                 // Check if the messages are in the waiting
1:53b29a2:                 // list for long time.
1:53b29a2:                 Message topMessage = waitingList.peek();
1:53b29a2:                 if (topMessage != null)
1:53b29a2:                     checkDeliveryTime(topMessage);
1:53b29a2:             }
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         public void onServerMessage(Message message) throws JMSException {
1:53b29a2:             if (Boolean.TRUE.equals(message.getObjectProperty("COMMIT"))) {
1:53b29a2:                 if (Boolean.TRUE.equals(message.getObjectProperty("RELEVANT")))
1:53b29a2:                     waitingList.add(message);
1:53b29a2:             } else {
1:53b29a2:                 String messageType = message.getStringProperty("TYPE");
1:53b29a2:                 if (clientType.isRelevant(messageType))
1:53b29a2:                     waitingList.add(message);
1:53b29a2:             }
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         public void onClientMessage(Message message) {
1:53b29a2:             Message serverMessage = waitingList.poll();
1:53b29a2:             try {
1:53b29a2:                 Integer receivedId = (Integer) message.getObjectProperty("ID");
1:53b29a2:                 if (processed != null && processed.contains(receivedId))
1:53b29a2:                     LOG.info("! Message has been processed before. "
1:53b29a2:                             + this + " redeliveredFlag=" + message.getJMSRedelivered() + ", message = " + message);
1:53b29a2: 
1:53b29a2:                 if (serverMessage == null)
1:53b29a2:                     exit(""
1:53b29a2:                             + this
1:53b29a2:                             + " failed: There is no next server message, but received: "
1:53b29a2:                             + message);
1:53b29a2: 
1:53b29a2:                 Integer serverId = (Integer) serverMessage
1:53b29a2:                         .getObjectProperty("ID");
1:53b29a2:                 if (receivedId == null || serverId == null)
1:53b29a2:                     exit("" + this + " failed: message ID not found.\r\n"
1:53b29a2:                             + " received: " + message + "\r\n" + "   server: "
1:53b29a2:                             + serverMessage);
1:53b29a2: 
1:53b29a2:                 if (!serverId.equals(receivedId)) {
1:53b29a2:                     StringBuilder missingList = new StringBuilder();
1:53b29a2:                     Object lastTrans = null;
1:53b29a2:                     int transCount = 0;
1:53b29a2:                     Message nextServerMessage = serverMessage;
1:53b29a2:                     do {
1:53b29a2:                         Integer nextServerId = (Integer) nextServerMessage.getObjectProperty("ID");
1:53b29a2:                         if (nextServerId.equals(receivedId)) {
1:53b29a2:                             if (lastTrans != null)
1:53b29a2:                                 missingList.append("Missing TRANS=").append(lastTrans).append(", size=").append(transCount).append("\r\n");
1:53b29a2:                             break;
1:53b29a2:                         }
1:53b29a2: 
1:53b29a2:                         Object trans = nextServerMessage.getObjectProperty("TRANS");
1:53b29a2:                         if (!trans.equals(lastTrans)) {
1:53b29a2:                             if (lastTrans != null)
1:53b29a2:                                 missingList.append("Missing TRANS=").append(lastTrans).append(", size=").append(transCount).append("\r\n");
1:53b29a2:                             lastTrans = trans;
1:53b29a2:                             transCount = 1;
1:53b29a2:                         }
1:53b29a2:                         else
1:53b29a2:                             transCount++;
1:53b29a2:                     } while ((nextServerMessage = waitingList.poll()) != null);
1:53b29a2: 
1:53b29a2:                     exit("Missing messages!\r\n" + missingList +
1:53b29a2:                             "Received message: " + message + "\r\n" +
1:53b29a2:                             "Expected message: " + serverMessage);
1:53b29a2:                 }
1:53b29a2: 
1:53b29a2:                 checkDeliveryTime(message);
1:53b29a2: 
1:53b29a2:                 if (processed != null)
1:53b29a2:                     processed.add(receivedId);
1:53b29a2:             } catch (Throwable e) {
1:53b29a2:                 exit("" + this + ".onClientMessage failed.\r\n" + " received: "
1:53b29a2:                         + message + "\r\n" + "   server: " + serverMessage, e);
1:53b29a2:             }
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         /**
1:53b29a2:          * Checks if the message was not delivered fast enough.
1:53b29a2:          */
1:53b29a2:         public void checkDeliveryTime(Message message) throws JMSException {
1:53b29a2:             long creation = message.getJMSTimestamp();
1:53b29a2:             long min = System.currentTimeMillis() - (offline.max + online.min)
1:53b29a2:                     * (BROKER_RESTART > 0 ? 4 : 1);
1:53b29a2: 
1:53b29a2:             if (false && min > creation) {
1:53b29a2:                 SimpleDateFormat df = new SimpleDateFormat("HH:mm:ss.SSS");
1:53b29a2:                 exit("" + this + ".checkDeliveryTime failed. Message time: "
1:53b29a2:                         + df.format(new Date(creation)) + ", min: "
1:53b29a2:                         + df.format(new Date(min)) + "\r\n" + message);
1:53b29a2:             }
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         private Connection openConnection() throws JMSException {
1:53b29a2:             Connection con = cf.createConnection();
1:53b29a2:             con.setClientID(conClientId);
1:53b29a2:             ((ActiveMQConnection) con).setCloseTimeout(60000);
1:53b29a2:             con.start();
1:53b29a2:             return con;
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         private void subscribe() throws JMSException {
1:53b29a2:             processLock.readLock().lock();
1:53b29a2:             try {
1:53b29a2:                 Connection con = openConnection();
1:53b29a2:                 Session session = con
1:53b29a2:                         .createSession(false, Session.AUTO_ACKNOWLEDGE);
1:53b29a2:                 session.createDurableSubscriber(topic, SUBSCRIPTION_NAME, selector,
1:53b29a2:                         true);
1:53b29a2:                 session.close();
1:53b29a2:                 con.close();
1:53b29a2:             }
1:53b29a2:             finally {
1:53b29a2:                 processLock.readLock().unlock();
1:53b29a2:             }
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         private void unsubscribe() throws JMSException {
1:53b29a2:             processLock.readLock().lock();
1:53b29a2:             LOG.info("Unsubscribe: " + this);
1:53b29a2:             try {
1:53b29a2:                 Connection con = openConnection();
1:53b29a2:                 Session session = con
1:53b29a2:                         .createSession(false, Session.AUTO_ACKNOWLEDGE);
1:53b29a2:                 session.unsubscribe(SUBSCRIPTION_NAME);
1:53b29a2:                 session.close();
1:53b29a2:                 con.close();
1:53b29a2:             }
1:53b29a2:             finally {
1:53b29a2:                 processLock.readLock().unlock();
1:53b29a2:             }
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         @Override
1:53b29a2:         public String toString() {
1:53b29a2:             return "Client[id=" + id + ", type=" + clientType + "] consumerId=" + (consumer != null ? consumer.getConsumerId() : "null");
1:53b29a2:         }
1:53b29a2:     }
1:53b29a2: 
1:53b29a2:     /**
1:53b29a2:      * Sweeps out not-used durable subscriptions.
1:53b29a2:      */
1:53b29a2:     private final class HouseKeeper extends Thread {
1:53b29a2: 
1:53b29a2:         private HouseKeeper() {
1:53b29a2:             super("HouseKeeper");
1:53b29a2:             setDaemon(true);
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         public final CopyOnWriteArrayList<String> abandonedSubscriptions = new CopyOnWriteArrayList<String>();
1:53b29a2: 
1:53b29a2:         @Override
1:53b29a2:         public void run() {
1:53b29a2:             while (true) {
1:53b29a2:                 try {
1:53b29a2:                     Thread.sleep(3 * 60 * 1000);
1:53b29a2: 
1:53b29a2:                     processLock.readLock().lock();
1:53b29a2:                     try {
1:53b29a2:                         sweep();
1:53b29a2:                     } finally {
1:53b29a2:                         processLock.readLock().unlock();
1:53b29a2:                     }
1:53b29a2:                 } catch (InterruptedException ex) {
1:53b29a2:                     break;
1:53b29a2:                 } catch (Throwable e) {
1:53b29a2:                     Exception log = new Exception("HouseKeeper failed.", e);
1:53b29a2:                     log.printStackTrace();
1:53b29a2:                 }
1:53b29a2:             }
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         private void sweep() throws Exception {
1:53b29a2:             LOG.info("Housekeeper sweeping.");
1:53b29a2: 
1:53b29a2:             int closed = 0;
1:53b29a2:             ArrayList<String> sweeped = new ArrayList<String>();
1:53b29a2:             try {
1:53b29a2:                 for (String clientId : abandonedSubscriptions) {
1:53b29a2:                     LOG.info("Sweeping out subscription of "
1:53b29a2:                             + clientId + ".");
1:53b29a2:                     broker.getAdminView().destroyDurableSubscriber(clientId,
1:53b29a2:                             Client.SUBSCRIPTION_NAME);
1:53b29a2:                     sweeped.add(clientId);
1:53b29a2:                     closed++;
1:53b29a2:                 }
1:53b29a2:             } catch (Exception ignored) {
1:53b29a2:                 LOG.info("Ex on destroy sub " + ignored);
1:53b29a2:             } finally {
1:53b29a2:                 abandonedSubscriptions.removeAll(sweeped);
1:53b29a2:             }
1:53b29a2: 
1:53b29a2:             LOG.info("Housekeeper sweeped out " + closed
1:53b29a2:                     + " subscriptions.");
1:53b29a2:         }
1:53b29a2:     }
1:53b29a2: 
1:53b29a2:     public static int random(int max) {
1:53b29a2:         return (int) (Math.random() * (max + 1));
1:53b29a2:     }
1:53b29a2: 
1:53b29a2:     public static int random(int min, int max) {
1:53b29a2:         return random(max - min) + min;
1:53b29a2:     }
1:53b29a2: 
1:53b29a2:     public static void sleepRandom(int maxMillis) throws InterruptedException {
1:53b29a2:         Thread.sleep(random(maxMillis));
1:53b29a2:     }
1:53b29a2: 
1:53b29a2:     public static void sleepRandom(int minMillis, int maxMillis)
1:53b29a2:             throws InterruptedException {
1:53b29a2:         Thread.sleep(random(minMillis, maxMillis));
1:53b29a2:     }
1:53b29a2: 
1:53b29a2:     public static final class Random {
1:53b29a2: 
1:53b29a2:         final int min;
1:53b29a2:         final int max;
1:53b29a2: 
1:53b29a2:         Random(int min, int max) {
1:53b29a2:             this.min = min;
1:53b29a2:             this.max = max;
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         public int next() {
1:53b29a2:             return random(min, max);
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         public void sleepRandom() throws InterruptedException {
1:53b29a2:             DurableSubProcessConcurrentCommitActivateNoDuplicateTest.sleepRandom(min, max);
1:53b29a2:         }
1:53b29a2:     }
1:53b29a2: 
1:53b29a2:     public static void exit(String message) {
1:53b29a2:         exit(message, null);
1:53b29a2:     }
1:53b29a2: 
1:53b29a2:     public static void exit(String message, Throwable e) {
1:53b29a2:         Throwable cause = new RuntimeException(message, e);
1:53b29a2:         LOG.error(message, cause);
1:53b29a2:         exceptions.add(cause);
1:53b29a2:         ThreadTracker.result();
1:53b29a2:         //fail(cause.toString());
1:53b29a2:         System.exit(-9);
1:53b29a2:     }
1:53b29a2: 
1:53b29a2:     @Before
1:53b29a2:     public void setUp() throws Exception {
1:53b29a2:         topic = new ActiveMQTopic("TopicT");
1:53b29a2:         startBroker();
1:53b29a2: 
1:53b29a2:         clientManager = new ClientManager();
1:53b29a2:         server = new Server();
1:53b29a2:         houseKeeper = new HouseKeeper();
1:53b29a2: 
1:53b29a2:     }
1:53b29a2: 
1:53b29a2:     @After
1:53b29a2:     public void tearDown() throws Exception {
1:53b29a2:         destroyBroker();
1:53b29a2:     }
1:53b29a2: 
1:53b29a2:     private enum Persistence {
1:b2fca26:         MEMORY, LEVELDB, KAHADB
1:53b29a2:     }
1:53b29a2: 
1:53b29a2:     private void startBroker() throws Exception {
1:53b29a2:         startBroker(true);
1:53b29a2:     }
1:53b29a2: 
1:53b29a2:     private void startBroker(boolean deleteAllMessages) throws Exception {
1:53b29a2:         if (broker != null)
1:53b29a2:             return;
1:53b29a2: 
1:53b29a2:         broker = BrokerFactory.createBroker("broker:(vm://" + getName() + ")");
1:53b29a2:         broker.setBrokerName(getName());
1:53b29a2:         broker.setAdvisorySupport(false);
1:53b29a2:         broker.setDeleteAllMessagesOnStartup(deleteAllMessages);
1:53b29a2: 
1:53b29a2:         switch (PERSISTENT_ADAPTER) {
1:53b29a2:         case MEMORY:
1:53b29a2:             broker.setPersistent(false);
1:53b29a2:             break;
1:53b29a2: 
1:b2fca26:         case LEVELDB:
1:b2fca26:             File amqData = new File("activemq-data/" + getName() + "-leveldb");
2:53b29a2:             if (deleteAllMessages)
1:53b29a2:                 delete(amqData);
1:53b29a2: 
2:53b29a2:             broker.setPersistent(true);
1:b2fca26:             LevelDBStore amq = new LevelDBStore();
1:53b29a2:             amq.setDirectory(amqData);
1:53b29a2:             broker.setPersistenceAdapter(amq);
1:53b29a2:             break;
1:53b29a2: 
1:53b29a2:         case KAHADB:
1:53b29a2:             File kahadbData = new File("activemq-data/" + getName() + "-kahadb");
1:53b29a2:             if (deleteAllMessages)
1:53b29a2:                 delete(kahadbData);
1:53b29a2: 
1:53b29a2:             broker.setPersistent(true);
1:53b29a2:             KahaDBPersistenceAdapter kahadb = new KahaDBPersistenceAdapter();
1:53b29a2:             kahadb.setDirectory(kahadbData);
1:53b29a2:             kahadb.setJournalMaxFileLength(5 * 1024 * 1024);
1:53b29a2:             broker.setPersistenceAdapter(kahadb);
1:53b29a2:             break;
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         broker.addConnector("tcp://localhost:61656");
1:53b29a2: 
1:53b29a2:         broker.getSystemUsage().getMemoryUsage().setLimit(256 * 1024 * 1024);
1:53b29a2:         broker.getSystemUsage().getTempUsage().setLimit(256 * 1024 * 1024);
1:53b29a2:         broker.getSystemUsage().getStoreUsage().setLimit(1024 * 1024 * 1024);
1:53b29a2: 
1:53b29a2: 
1:53b29a2:         PolicyMap policyMap = new PolicyMap();
1:53b29a2:         PolicyEntry defaultEntry = new PolicyEntry();
1:53b29a2:         defaultEntry.setMaxAuditDepth(20000);
1:53b29a2:         policyMap.setDefaultEntry(defaultEntry);
1:53b29a2:         broker.setDestinationPolicy(policyMap);
1:53b29a2:         broker.start();
1:53b29a2:     }
1:53b29a2: 
1:53b29a2:     protected static String getName() {
1:53b29a2:         return "DurableSubProcessWithRestartTest";
1:53b29a2:     }
1:53b29a2: 
1:53b29a2:     private static boolean delete(File path) {
1:53b29a2:         if (path == null)
1:53b29a2:             return true;
1:53b29a2: 
1:53b29a2:         if (path.isDirectory()) {
1:53b29a2:             for (File file : path.listFiles()) {
1:53b29a2:                 delete(file);
1:53b29a2:             }
1:53b29a2:         }
1:53b29a2:         return path.delete();
1:53b29a2:     }
1:53b29a2: 
1:53b29a2:     private void destroyBroker() throws Exception {
1:53b29a2:         if (broker == null)
1:53b29a2:             return;
1:53b29a2: 
1:53b29a2:         broker.stop();
1:53b29a2:         broker = null;
1:53b29a2:     }
1:53b29a2: }
============================================================================
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:b2fca26
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.leveldb.LevelDBStore;
/////////////////////////////////////////////////////////////////////////
1:         MEMORY, LEVELDB, KAHADB
/////////////////////////////////////////////////////////////////////////
1:         case LEVELDB:
1:             File amqData = new File("activemq-data/" + getName() + "-leveldb");
1:             LevelDBStore amq = new LevelDBStore();
commit:58aca86
/////////////////////////////////////////////////////////////////////////
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:4743a20
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertTrue;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:             Thread.sleep(60 * 1000);
1:         } catch (InterruptedException e) {
1:              exit("ProcessTest.testProcess failed.", e);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         public volatile int committingTransaction = -1;
/////////////////////////////////////////////////////////////////////////
1:                     Thread.sleep(1000);
1: 
/////////////////////////////////////////////////////////////////////////
1:         private boolean end;
/////////////////////////////////////////////////////////////////////////
1:             this.end = end;
1:         }
1: 
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:                     */
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:             long end = System.currentTimeMillis() + 200;
/////////////////////////////////////////////////////////////////////////
1: 
commit:ef24cc9
author:Gary Tully
-------------------------------------------------------------------------------
commit:6b4d077
/////////////////////////////////////////////////////////////////////////
0: import java.net.URL;
/////////////////////////////////////////////////////////////////////////
1:     @Ignore ("short version in org.apache.activemq.usecases.DurableSubscriptionOfflineTest.testNoDuplicateOnConcurrentSendTranCommitAndActivate"
1:      + " and org.apache.activemq.usecases.DurableSubscriptionOfflineTest.testOrderOnActivateDeactivate")
/////////////////////////////////////////////////////////////////////////
0: 			Thread.sleep(60 * 1000);
1: 
1:         server.done = true;
1: 
1:         try {
1:             server.join(60*1000);
1:         } catch (Exception ignored) {}
/////////////////////////////////////////////////////////////////////////
1:         public boolean  done = false;
/////////////////////////////////////////////////////////////////////////
1:                 while (!done) {
commit:53b29a2
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR ONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.usecases;
1: 
1: import java.io.File;
1: import java.text.SimpleDateFormat;
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Date;
1: import java.util.HashSet;
1: import java.util.Vector;
1: import java.util.concurrent.ConcurrentLinkedQueue;
1: import java.util.concurrent.CopyOnWriteArrayList;
1: import java.util.concurrent.atomic.AtomicInteger;
1: import java.util.concurrent.locks.ReentrantReadWriteLock;
1: import javax.jms.Connection;
1: import javax.jms.ConnectionFactory;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: 
1: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.ActiveMQMessageConsumer;
1: import org.apache.activemq.broker.BrokerFactory;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
1: import org.apache.activemq.command.ActiveMQTopic;
0: import org.apache.activemq.store.amq.AMQPersistenceAdapter;
0: import org.apache.activemq.store.kahadaptor.KahaPersistenceAdapter;
1: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1: import org.apache.activemq.util.ThreadTracker;
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Ignore;
1: import org.junit.Test;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: 
0: import static org.junit.Assert.assertTrue;
1: 
1: public class DurableSubProcessConcurrentCommitActivateNoDuplicateTest {
1:     private static final Logger LOG = LoggerFactory.getLogger(DurableSubProcessConcurrentCommitActivateNoDuplicateTest.class);
1:     public static final long RUNTIME = 5 * 60 * 1000;
1: 
1:     public static final int SERVER_SLEEP = 500; // max
1:     public static final int CARGO_SIZE = 600; // max
1: 
1:     public static final int MAX_CLIENTS = 2;
1:     public static final Random CLIENT_LIFETIME = new Random(30 * 1000, 2 * 60 * 1000);
1:     public static final Random CLIENT_ONLINE = new Random(30 * 1000, 40 * 1000);
1:     public static final Random CLIENT_OFFLINE = new Random(1 * 1000, 10 * 1000);
1: 
1:     public static final int CLIENT_OFFLINE_DURING_COMMIT = 2; // random(x) == x
1:             
1:     public static final Persistence PERSISTENT_ADAPTER = Persistence.KAHADB;
1:     
1:     public static final long BROKER_RESTART = -2 * 60 * 1000;
1: 
1:     public static final boolean ALLOW_SUBSCRIPTION_ABANDONMENT = true;
1:     public static final boolean CHECK_REDELIVERY = true;
1: 
1:     private BrokerService broker;
1:     private ActiveMQTopic topic;
1: 
1:     private ClientManager clientManager;
1:     private Server server;
1:     private HouseKeeper houseKeeper;
1: 
1:     private final ReentrantReadWriteLock processLock = new ReentrantReadWriteLock(
1:             true);
1:     private int restartCount = 0;
1:     private final AtomicInteger onlineCount = new AtomicInteger(0);
1:     static final Vector<Throwable> exceptions = new Vector<Throwable>();
1: 
1:     // long form of test that found https://issues.apache.org/jira/browse/AMQ-3805
0:     @Ignore ("short version in org.apache.activemq.usecases.DurableSubscriptionOfflineTest.testNoDuplicateOnConcurrentSendTranCommitAndActivate")
1:     @Test
1:     public void testProcess() {
1:         try {
1:             server.start();
1:             clientManager.start();
1: 
1:             if (ALLOW_SUBSCRIPTION_ABANDONMENT)
1:                 houseKeeper.start();
1: 
1:             if (BROKER_RESTART <= 0)
1:                 Thread.sleep(RUNTIME);
1:             else {
1:                 long end = System.currentTimeMillis() + RUNTIME;
1: 
1:                 while (true) {
1:                     long now = System.currentTimeMillis();
1:                     if (now > end)
1:                         break;
1: 
1:                     now = end - now;
1:                     now = now < BROKER_RESTART ? now : BROKER_RESTART;
1:                     Thread.sleep(now);
1: 
1:                     restartBroker();
1:                 }
1:             }
1:         } catch (Throwable e) {
1:             exit("ProcessTest.testProcess failed.", e);
1:         }
1: 
1:         //allow the clients to unsubscribe before finishing
1:         clientManager.setEnd(true);
1:         try {
0: 			Thread.sleep(600000);
0: 		} catch (InterruptedException e) {
1: 			 exit("ProcessTest.testProcess failed.", e);
1: 		}
1:         
1:         
1:         processLock.writeLock().lock();
1:         assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
1:         LOG.info("DONE.");
1:     }
1: 
1:     private void restartBroker() throws Exception {
1:         LOG.info("Broker restart: waiting for components.");
1: 
1:         processLock.writeLock().lock();
1:         try {
1:             destroyBroker();
1:             startBroker(false);
1: 
1:             restartCount++;
1:             LOG.info("Broker restarted. count: " + restartCount);
1:         } finally {
1:             processLock.writeLock().unlock();
1:         }
1:     }
1: 
1:     /**
1:      * Creates batch of messages in a transaction periodically. The last message
1:      * in the transaction is always a special message what contains info about
1:      * the whole transaction.
1:      * <p>
1:      * Notifies the clients about the created messages also.
1:      */
1:     final class Server extends Thread {
1: 
1:         final String url = "vm://"
1:                 + DurableSubProcessConcurrentCommitActivateNoDuplicateTest.getName()
1:                 + "?"
1:                 + "jms.redeliveryPolicy.maximumRedeliveries=2&jms.redeliveryPolicy.initialRedeliveryDelay=500&"
1:                 + "jms.producerWindowSize=20971520&jms.prefetchPolicy.all=100&"
1:                 + "jms.copyMessageOnSend=false&jms.disableTimeStampsByDefault=false&"
1:                 + "jms.alwaysSyncSend=true&jms.dispatchAsync=false&"
1:                 + "jms.watchTopicAdvisories=false&"
1:                 + "waitForStart=200&create=false";
1:         final ConnectionFactory cf = new ActiveMQConnectionFactory(url);
1: 
1:         final Object sendMutex = new Object();
1:         final String[] cargos = new String[500];
1: 
1:         int transRover = 0;
1:         int messageRover = 0;
0:         public volatile int committingTransaction = -1;        
1: 
1:         public Server() {
1:             super("Server");
1:             setPriority(Thread.MIN_PRIORITY);
1:             setDaemon(true);
1:         }
1: 
1:         @Override
1:         public void run() {
1:             try {
1:                 while (true) {
1: 
0:                 	Thread.sleep(1000);
1:                 	
1:                     processLock.readLock().lock();
1:                     try {
1:                         send();
1:                     } finally {
1:                         processLock.readLock().unlock();
1:                     }
1:                 }
1:             } catch (Throwable e) {
1:                 exit("Server.run failed", e);
1:             }
1:         }
1: 
1:         public void send() throws JMSException {
1:             // do not create new clients now
1:             // ToDo: Test this case later.
1:             synchronized (sendMutex) {
1:                 int trans = ++transRover;
1:                 boolean relevantTrans = true; //random(2) > 1;
1:                 ClientType clientType = relevantTrans ? ClientType
1:                         .randomClientType() : null; // sends this types
1:                 //int count = random(500, 700);
1:                 int count = 1000;
1: 
1:                 LOG.info("Sending Trans[id=" + trans + ", count="
1:                         + count + ", clientType=" + clientType + ", firstID=" + (messageRover+1) + "]");
1: 
1:                 Connection con = cf.createConnection();
1:                 Session sess = con
1:                         .createSession(true, Session.SESSION_TRANSACTED);
1:                 MessageProducer prod = sess.createProducer(null);
1: 
1:                 for (int i = 0; i < count; i++) {
1:                     Message message = sess.createMessage();
1:                     message.setIntProperty("ID", ++messageRover);
1:                     message.setIntProperty("TRANS", trans);
1:                     String type = clientType != null ? clientType
1:                             .randomMessageType() : ClientType
1:                             .randomNonRelevantMessageType();
1:                     message.setStringProperty("TYPE", type);
1: 
1:                     if (CARGO_SIZE > 0)
1:                         message.setStringProperty("CARGO",
1:                                 getCargo(random(CARGO_SIZE)));
1: 
1:                     prod.send(topic, message);
1:                     clientManager.onServerMessage(message);
1:                 }
1: 
1:                 Message message = sess.createMessage();
1:                 message.setIntProperty("ID", ++messageRover);
1:                 message.setIntProperty("TRANS", trans);
1:                 message.setBooleanProperty("COMMIT", true);
1:                 message.setBooleanProperty("RELEVANT", relevantTrans);
1:                 prod.send(topic, message);
1:                 clientManager.onServerMessage(message);
1: 
1:                 committingTransaction = trans;
1:                 sess.commit();
1:                 committingTransaction = -1;
1: 
1:                 LOG.info("Committed Trans[id=" + trans + ", count="
1:                         + count + ", clientType=" + clientType + "], ID=" + messageRover);
1: 
1:                 sess.close();
1:                 con.close();
1:             }
1:         }
1: 
1:         private String getCargo(int length) {
1:             if (length == 0)
1:                 return null;
1: 
1:             if (length < cargos.length) {
1:                 String result = cargos[length];
1:                 if (result == null) {
1:                     result = getCargoImpl(length);
1:                     cargos[length] = result;
1:                 }
1:                 return result;
1:             }
1:             return getCargoImpl(length);
1:         }
1: 
1:         private String getCargoImpl(int length) {
1:             StringBuilder sb = new StringBuilder(length);
1:             for (int i = length; --i >= 0;) {
1:                 sb.append('a');
1:             }
1:             return sb.toString();
1:         }
1:     }
1: 
1:     /**
1:      * Clients listen on different messages in the topic. The 'TYPE' property
1:      * helps the client to select the proper messages.
1:      */
1:     private enum ClientType {
1:         A("a", "b", "c"), B("c", "d", "e"), C("d", "e", "f"), D("g", "h");
1: 
1:         public final String[] messageTypes;
1:         public final HashSet<String> messageTypeSet;
1:         public final String selector;
1: 
1:         ClientType(String... messageTypes) {
1:             this.messageTypes = messageTypes;
1:             messageTypeSet = new HashSet<String>(Arrays.asList(messageTypes));
1: 
1:             StringBuilder sb = new StringBuilder("TYPE in (");
1:             for (int i = 0; i < messageTypes.length; i++) {
1:                 if (i > 0)
1:                     sb.append(", ");
1:                 sb.append('\'').append(messageTypes[i]).append('\'');
1:             }
1:             sb.append(')');
1:             selector = sb.toString();
1:         }
1: 
1:         public static ClientType randomClientType() {
1:             return values()[DurableSubProcessConcurrentCommitActivateNoDuplicateTest
1:                     .random(values().length - 1)];
1:         }
1: 
1:         public final String randomMessageType() {
1:             return messageTypes[DurableSubProcessConcurrentCommitActivateNoDuplicateTest
1:                     .random(messageTypes.length - 1)];
1:         }
1: 
1:         public static String randomNonRelevantMessageType() {
1:             return Integer
1:                     .toString(DurableSubProcessConcurrentCommitActivateNoDuplicateTest.random(20));
1:         }
1: 
1:         public final boolean isRelevant(String messageType) {
1:             return messageTypeSet.contains(messageType);
1:         }
1: 
1:         @Override
1:         public final String toString() {
1:             return this.name() /* + '[' + selector + ']' */;
1:         }
1:     }
1: 
1:     /**
1:      * Creates new cliens.
1:      */
1:     private final class ClientManager extends Thread {
1: 
1:         private int clientRover = 0;
1: 
1:         private final CopyOnWriteArrayList<Client> clients = new CopyOnWriteArrayList<Client>();
1: 
0: 		private boolean end;
1: 
1:         public ClientManager() {
1:             super("ClientManager");
1:             setDaemon(true);
1:         }
1: 
1:         public synchronized void setEnd(boolean end) {
0: 			this.end = end;
1: 			
1: 		}
1: 
1: 		@Override
1:         public void run() {
1:             try {
1:                 while (true) {
1:                     if (clients.size() < MAX_CLIENTS && !end) {
1:                         processLock.readLock().lock();
1:                         try {
1:                             createNewClient();
1:                         } finally {
1:                             processLock.readLock().unlock();
1:                         }
1:                     }
1: 
1:                     int size = clients.size();
1:                     //sleepRandom(1000, 4000);
1:                     Thread.sleep(100);
1:                 }
1:             } catch (Throwable e) {
1:                 exit("ClientManager.run failed.", e);
1:             }
1:         }
1: 
1:         private void createNewClient() throws JMSException {
1:             ClientType type = ClientType.randomClientType();
1: 
1:             Client client;
1:             synchronized (server.sendMutex) {
1:                 client = new Client(++clientRover, type, CLIENT_LIFETIME,
1:                         CLIENT_ONLINE, CLIENT_OFFLINE);
1:                 clients.add(client);
1:             }
1:             client.start();
1: 
1:             LOG.info(client.toString() + " created. " + this);
1:         }
1: 
1:         public void removeClient(Client client) {
1:             clients.remove(client);
1:         }
1: 
1:         public void onServerMessage(Message message) throws JMSException {
1:             for (Client client : clients) {
1:                 client.onServerMessage(message);
1:             }
1:         }
1: 
1:         @Override
1:         public String toString() {
1:             StringBuilder sb = new StringBuilder("ClientManager[count=");
1:             sb.append(clients.size());
1:             sb.append(", clients=");
1:             boolean sep = false;
1:             for (Client client : clients) {
1:                 if (sep)
1:                     sb.append(", ");
1:                 else
1:                     sep = true;
1:                 sb.append(client.toString());
1:             }
1:             sb.append(']');
1:             return sb.toString();
1:         }
1:     }
1: 
1:     /**
1:      * Consumes massages from a durable subscription. Goes online/offline
1:      * periodically. Checks the incoming messages against the sent messages of
1:      * the server.
1:      */
1:     private final class Client extends Thread {
1: 
1:         String url = "failover:(tcp://localhost:61656?wireFormat.maxInactivityDuration=0)?"
1:                 + "jms.watchTopicAdvisories=false&"
1:                 + "jms.alwaysSyncSend=true&jms.dispatchAsync=true&"
1:                 + "jms.producerWindowSize=20971520&"
1:                 + "jms.copyMessageOnSend=false&"
1:                 + "jms.sendAcksAsync=false&"
1:                 + "initialReconnectDelay=100&maxReconnectDelay=30000&"
1:                 + "useExponentialBackOff=true";
1:         final ConnectionFactory cf = new ActiveMQConnectionFactory(url);
1: 
1:         public static final String SUBSCRIPTION_NAME = "subscription";
1: 
1:         private final int id;
1:         private final String conClientId;
1: 
1:         private final Random lifetime;
1:         private final Random online;
1:         private final Random offline;
1: 
1:         private final ClientType clientType;
1:         private final String selector;
1: 
1:         private final ConcurrentLinkedQueue<Message> waitingList = new ConcurrentLinkedQueue<Message>();
1:         private final HashSet<Integer> processed = CHECK_REDELIVERY ? new HashSet<Integer>(
1:                 10000) : null;
1: 
1:         private ActiveMQMessageConsumer consumer = null;
1: 
1:         public Client(int id, ClientType clientType, Random lifetime,
1:                 Random online, Random offline) throws JMSException {
1:             super("Client" + id);
1:             setDaemon(true);
1: 
1:             this.id = id;
1:             conClientId = "cli" + id;
1:             this.clientType = clientType;
1:             selector = "(COMMIT = true and RELEVANT = true) or "
1:                     + clientType.selector;
1: 
1:             this.lifetime = lifetime;
1:             this.online = online;
1:             this.offline = offline;
1: 
1:             subscribe();
1:         }
1: 
1:         @Override
1:         public void run() {
1:             long end = System.currentTimeMillis() + 60000;
1:             try {
1:                 boolean sleep = false;
1:                 while (true) {
1:                     long max = end - System.currentTimeMillis();
1:                     if (max <= 0)
1:                         break;
1: 
1:                     /*
1:                     if (sleep)
1:                         offline.sleepRandom();
1:                     else
1:                         sleep = true;
1: 					*/
1:                     
1:                     Thread.sleep(100);
1:                     
1:                     processLock.readLock().lock();
1:                     onlineCount.incrementAndGet();
1:                     try {
1:                         process(online.next());
1:                     } finally {
1:                         onlineCount.decrementAndGet();
1:                         processLock.readLock().unlock();
1:                     }
1:                 }
1: 
1:                 if (!ALLOW_SUBSCRIPTION_ABANDONMENT || random(1) > 0)
1:                     unsubscribe();
1:                 else {
1:                     LOG.info("Client abandon the subscription. "
1:                             + this);
1: 
1:                     // housekeeper should sweep these abandoned subscriptions
1:                     houseKeeper.abandonedSubscriptions.add(conClientId);
1:                 }
1:             } catch (Throwable e) {
1:                 exit(toString() + " failed.", e);
1:             }
1: 
1:             clientManager.removeClient(this);
1:             LOG.info(toString() + " DONE.");
1:         }
1: 
1:         private void process(long millis) throws JMSException {
1:             //long end = System.currentTimeMillis() + millis;
0:         	long end = System.currentTimeMillis() + 200;
1:             long hardEnd = end + 20000; // wait to finish the transaction.
1:             boolean inTransaction = false;
1:             int transCount = 0;
1: 
1:             Connection con = openConnection();
1:             Session sess = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:             consumer = (ActiveMQMessageConsumer) sess.createDurableSubscriber(topic,
1:                     SUBSCRIPTION_NAME, selector, false);
1:             LOG.info(toString() + " ONLINE.");
1:             try {
1:                 do {
1:                     long max = end - System.currentTimeMillis();
1:                     if (max <= 0) {
1:                         if (!inTransaction) {
1:                             LOG.info(toString() + " done after no work!");
1:                             break;
1:                         }
1: 
1:                         max = hardEnd - System.currentTimeMillis();
1:                         if (max <= 0)
1:                             exit("" + this
1:                                     + " failed: Transaction is not finished.");
1:                     }
1: 
1:                     Message message = consumer.receive(max);
1:                     if (message == null)
1:                         continue;
1: 
1:                     onClientMessage(message);
1: 
1:                     if (message.propertyExists("COMMIT")) {
1:                         message.acknowledge(); // CLIENT_ACKNOWLEDGE
1: 
1:                         int trans = message.getIntProperty("TRANS");
1:                         LOG.info("Received Trans[id="
1:                                 + trans + ", count="
1:                                 + transCount + "] in " + this + ".");
1: 
1:                         inTransaction = false;
1:                         transCount = 0;
1:                         
1:                         int committing = server.committingTransaction;
1:                         if (committing == trans) {
1:                             LOG.info("Going offline during transaction commit. messageID=" + message.getIntProperty("ID"));
1:                             break;
1:                         }
1:                     } else {
1:                         inTransaction = true;
1:                         transCount++;
1:                         if (1 == transCount) {
1:                             LOG.info("In Trans[id=" + message.getIntProperty("TRANS") + "] first ID=" + message.getIntProperty("ID"));
1:                         }
1:                     }
1:                 } while (true);
1:             } finally {
1:                 sess.close();
1:                 con.close();
1: 
1:                 LOG.info(toString() + " OFFLINE.");
1: 
1:                 // Check if the messages are in the waiting
1:                 // list for long time.
1:                 Message topMessage = waitingList.peek();
1:                 if (topMessage != null)
1:                     checkDeliveryTime(topMessage);
1:             }
1:         }
1: 
1:         public void onServerMessage(Message message) throws JMSException {
1:             if (Boolean.TRUE.equals(message.getObjectProperty("COMMIT"))) {
1:                 if (Boolean.TRUE.equals(message.getObjectProperty("RELEVANT")))
1:                     waitingList.add(message);
1:             } else {
1:                 String messageType = message.getStringProperty("TYPE");
1:                 if (clientType.isRelevant(messageType))
1:                     waitingList.add(message);
1:             }
1:         }
1: 
1:         public void onClientMessage(Message message) {
1:             Message serverMessage = waitingList.poll();
1:             try {
1:                 Integer receivedId = (Integer) message.getObjectProperty("ID");
1:                 if (processed != null && processed.contains(receivedId))
1:                     LOG.info("! Message has been processed before. "
1:                             + this + " redeliveredFlag=" + message.getJMSRedelivered() + ", message = " + message);
1: 
1:                 if (serverMessage == null)
1:                     exit(""
1:                             + this
1:                             + " failed: There is no next server message, but received: "
1:                             + message);
1: 
1:                 Integer serverId = (Integer) serverMessage
1:                         .getObjectProperty("ID");
1:                 if (receivedId == null || serverId == null)
1:                     exit("" + this + " failed: message ID not found.\r\n"
1:                             + " received: " + message + "\r\n" + "   server: "
1:                             + serverMessage);
1: 
1:                 if (!serverId.equals(receivedId)) {
1:                     StringBuilder missingList = new StringBuilder();
1:                     Object lastTrans = null;
1:                     int transCount = 0;
1:                     Message nextServerMessage = serverMessage;
1:                     do {
1:                         Integer nextServerId = (Integer) nextServerMessage.getObjectProperty("ID");
1:                         if (nextServerId.equals(receivedId)) {
1:                             if (lastTrans != null)
1:                                 missingList.append("Missing TRANS=").append(lastTrans).append(", size=").append(transCount).append("\r\n");
1:                             break;
1:                         }
1: 
1:                         Object trans = nextServerMessage.getObjectProperty("TRANS");
1:                         if (!trans.equals(lastTrans)) {
1:                             if (lastTrans != null)
1:                                 missingList.append("Missing TRANS=").append(lastTrans).append(", size=").append(transCount).append("\r\n");
1:                             lastTrans = trans;
1:                             transCount = 1;
1:                         }
1:                         else
1:                             transCount++;
1:                     } while ((nextServerMessage = waitingList.poll()) != null);
1: 
1:                     exit("Missing messages!\r\n" + missingList +
1:                             "Received message: " + message + "\r\n" +
1:                             "Expected message: " + serverMessage);
1:                 }
1: 
1:                 checkDeliveryTime(message);
1: 
1:                 if (processed != null)
1:                     processed.add(receivedId);
1:             } catch (Throwable e) {
1:                 exit("" + this + ".onClientMessage failed.\r\n" + " received: "
1:                         + message + "\r\n" + "   server: " + serverMessage, e);
1:             }
1:         }
1: 
1:         /**
1:          * Checks if the message was not delivered fast enough.
1:          */
1:         public void checkDeliveryTime(Message message) throws JMSException {
1:             long creation = message.getJMSTimestamp();
1:             long min = System.currentTimeMillis() - (offline.max + online.min)
1:                     * (BROKER_RESTART > 0 ? 4 : 1);
1: 
1:             if (false && min > creation) {
1:                 SimpleDateFormat df = new SimpleDateFormat("HH:mm:ss.SSS");
1:                 exit("" + this + ".checkDeliveryTime failed. Message time: "
1:                         + df.format(new Date(creation)) + ", min: "
1:                         + df.format(new Date(min)) + "\r\n" + message);
1:             }
1:         }
1: 
1:         private Connection openConnection() throws JMSException {
1:             Connection con = cf.createConnection();
1:             con.setClientID(conClientId);
1:             ((ActiveMQConnection) con).setCloseTimeout(60000);
1:             con.start();
1:             return con;
1:         }
1: 
1:         private void subscribe() throws JMSException {
1:             processLock.readLock().lock();
1:             try {
1:                 Connection con = openConnection();
1:                 Session session = con
1:                         .createSession(false, Session.AUTO_ACKNOWLEDGE);
1:                 session.createDurableSubscriber(topic, SUBSCRIPTION_NAME, selector,
1:                         true);
1:                 session.close();
1:                 con.close();
1:             }
1:             finally {
1:                 processLock.readLock().unlock();
1:             }
1:         }
1: 
1:         private void unsubscribe() throws JMSException {
1:             processLock.readLock().lock();
1:             LOG.info("Unsubscribe: " + this);
1:             try {
1:                 Connection con = openConnection();
1:                 Session session = con
1:                         .createSession(false, Session.AUTO_ACKNOWLEDGE);
1:                 session.unsubscribe(SUBSCRIPTION_NAME);
1:                 session.close();
1:                 con.close();
1:             }
1:             finally {
1:                 processLock.readLock().unlock();
1:             }
1:         }
1: 
1:         @Override
1:         public String toString() {
1:             return "Client[id=" + id + ", type=" + clientType + "] consumerId=" + (consumer != null ? consumer.getConsumerId() : "null");
1:         }
1:     }
1: 
1:     /**
1:      * Sweeps out not-used durable subscriptions.
1:      */
1:     private final class HouseKeeper extends Thread {
1: 
1:         private HouseKeeper() {
1:             super("HouseKeeper");
1:             setDaemon(true);
1:         }
1: 
1:         public final CopyOnWriteArrayList<String> abandonedSubscriptions = new CopyOnWriteArrayList<String>();
1: 
1:         @Override
1:         public void run() {
1:             while (true) {
1:                 try {
1:                     Thread.sleep(3 * 60 * 1000);
1: 
1:                     processLock.readLock().lock();
1:                     try {
1:                         sweep();
1:                     } finally {
1:                         processLock.readLock().unlock();
1:                     }
1:                 } catch (InterruptedException ex) {
1:                     break;
1:                 } catch (Throwable e) {
1:                     Exception log = new Exception("HouseKeeper failed.", e);
1:                     log.printStackTrace();
1:                 }
1:             }
1:         }
1: 
1:         private void sweep() throws Exception {
1:             LOG.info("Housekeeper sweeping.");
1: 
1:             int closed = 0;
1:             ArrayList<String> sweeped = new ArrayList<String>();
1:             try {
1:                 for (String clientId : abandonedSubscriptions) {
1:                     LOG.info("Sweeping out subscription of "
1:                             + clientId + ".");
1:                     broker.getAdminView().destroyDurableSubscriber(clientId,
1:                             Client.SUBSCRIPTION_NAME);
1:                     sweeped.add(clientId);
1:                     closed++;
1:                 }
1:             } catch (Exception ignored) {
1:                 LOG.info("Ex on destroy sub " + ignored);
1:             } finally {
1:                 abandonedSubscriptions.removeAll(sweeped);
1:             }
1: 
1:             LOG.info("Housekeeper sweeped out " + closed
1:                     + " subscriptions.");
1:         }
1:     }
1: 
1:     public static int random(int max) {
1:         return (int) (Math.random() * (max + 1));
1:     }
1: 
1:     public static int random(int min, int max) {
1:         return random(max - min) + min;
1:     }
1: 
1:     public static void sleepRandom(int maxMillis) throws InterruptedException {
1:         Thread.sleep(random(maxMillis));
1:     }
1: 
1:     public static void sleepRandom(int minMillis, int maxMillis)
1:             throws InterruptedException {
1:         Thread.sleep(random(minMillis, maxMillis));
1:     }
1: 
1:     public static final class Random {
1: 
1:         final int min;
1:         final int max;
1: 
1:         Random(int min, int max) {
1:             this.min = min;
1:             this.max = max;
1:         }
1: 
1:         public int next() {
1:             return random(min, max);
1:         }
1: 
1:         public void sleepRandom() throws InterruptedException {
1:             DurableSubProcessConcurrentCommitActivateNoDuplicateTest.sleepRandom(min, max);
1:         }
1:     }
1: 
1:     public static void exit(String message) {
1:         exit(message, null);
1:     }
1: 
1:     public static void exit(String message, Throwable e) {
1:         Throwable cause = new RuntimeException(message, e);
1:         LOG.error(message, cause);
1:         exceptions.add(cause);
1:         ThreadTracker.result();
1:         //fail(cause.toString());
1:         System.exit(-9);
1:     }
1: 
1:     @Before
1:     public void setUp() throws Exception {
1:         topic = new ActiveMQTopic("TopicT");
1:         startBroker();
1: 
1:         clientManager = new ClientManager();
1:         server = new Server();
1:         houseKeeper = new HouseKeeper();
1: 
1:     }
1: 
1:     @After
1:     public void tearDown() throws Exception {
1:         destroyBroker();
1:     }
1: 
1:     private enum Persistence {
0:         MEMORY, AMQ, KAHA, KAHADB
1:     }
1: 
1:     private void startBroker() throws Exception {
1:         startBroker(true);
1:     }
1: 
1:     private void startBroker(boolean deleteAllMessages) throws Exception {
1:         if (broker != null)
1:             return;
1: 
1:         broker = BrokerFactory.createBroker("broker:(vm://" + getName() + ")");
1:         broker.setBrokerName(getName());
1:         broker.setAdvisorySupport(false);
1:         broker.setDeleteAllMessagesOnStartup(deleteAllMessages);
1: 
1:         switch (PERSISTENT_ADAPTER) {
1:         case MEMORY:
1:             broker.setPersistent(false);
1:             break;
1: 
0:         case AMQ:
0:             File amqData = new File("activemq-data/" + getName() + "-amq");
1:             if (deleteAllMessages)
1:                 delete(amqData);
1: 
1:             broker.setPersistent(true);
0:             AMQPersistenceAdapter amq = new AMQPersistenceAdapter();
1:             amq.setDirectory(amqData);
1:             broker.setPersistenceAdapter(amq);
1:             break;
1: 
0:         case KAHA:
0:             File kahaData = new File("activemq-data/" + getName() + "-kaha");
1:             if (deleteAllMessages)
0:                 delete(kahaData);
1: 
1:             broker.setPersistent(true);
0:             KahaPersistenceAdapter kaha = new KahaPersistenceAdapter();
0:             kaha.setDirectory(kahaData);
0:             broker.setPersistenceAdapter(kaha);
1:             break;
1: 
1:         case KAHADB:
1:             File kahadbData = new File("activemq-data/" + getName() + "-kahadb");
1:             if (deleteAllMessages)
1:                 delete(kahadbData);
1: 
1:             broker.setPersistent(true);
1:             KahaDBPersistenceAdapter kahadb = new KahaDBPersistenceAdapter();
1:             kahadb.setDirectory(kahadbData);
1:             kahadb.setJournalMaxFileLength(5 * 1024 * 1024);
1:             broker.setPersistenceAdapter(kahadb);
1:             break;
1:         }
1: 
1:         broker.addConnector("tcp://localhost:61656");
1: 
1:         broker.getSystemUsage().getMemoryUsage().setLimit(256 * 1024 * 1024);
1:         broker.getSystemUsage().getTempUsage().setLimit(256 * 1024 * 1024);
1:         broker.getSystemUsage().getStoreUsage().setLimit(1024 * 1024 * 1024);
1: 
1: 
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry defaultEntry = new PolicyEntry();
1:         defaultEntry.setMaxAuditDepth(20000);
1:         policyMap.setDefaultEntry(defaultEntry);
1:         broker.setDestinationPolicy(policyMap);
1:         broker.start();
1:     }
1: 
1:     protected static String getName() {
1:         return "DurableSubProcessWithRestartTest";
1:     }
1: 
1:     private static boolean delete(File path) {
1:         if (path == null)
1:             return true;
1: 
1:         if (path.isDirectory()) {
1:             for (File file : path.listFiles()) {
1:                 delete(file);
1:             }
1:         }
1:         return path.delete();
1:     }
1: 
1:     private void destroyBroker() throws Exception {
1:         if (broker == null)
1:             return;
1: 
1:         broker.stop();
1:         broker = null;
1:     }
1: }
============================================================================