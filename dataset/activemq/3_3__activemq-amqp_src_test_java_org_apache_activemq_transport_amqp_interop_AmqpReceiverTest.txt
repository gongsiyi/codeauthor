1:e050519: /*
1:72839b7:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:72839b7:  * contributor license agreements.  See the NOTICE file distributed with
1:72839b7:  * this work for additional information regarding copyright ownership.
1:72839b7:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:72839b7:  * (the "License"); you may not use this file except in compliance with
1:72839b7:  * the License.  You may obtain a copy of the License at
1:72839b7:  *
1:72839b7:  *      http://www.apache.org/licenses/LICENSE-2.0
1:72839b7:  *
1:72839b7:  * Unless required by applicable law or agreed to in writing, software
1:72839b7:  * distributed under the License is distributed on an "AS IS" BASIS,
1:72839b7:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:72839b7:  * See the License for the specific language governing permissions and
1:72839b7:  * limitations under the License.
1:72839b7:  */
1:72839b7: package org.apache.activemq.transport.amqp.interop;
1:72839b7: 
1:1a0f73e: import static org.apache.activemq.transport.amqp.AmqpSupport.JMS_SELECTOR_FILTER_IDS;
1:1a0f73e: import static org.apache.activemq.transport.amqp.AmqpSupport.NO_LOCAL_FILTER_IDS;
1:1a0f73e: import static org.apache.activemq.transport.amqp.AmqpSupport.findFilter;
1:72839b7: import static org.junit.Assert.assertEquals;
1:72839b7: import static org.junit.Assert.assertNotNull;
1:0cfd225: import static org.junit.Assert.assertNull;
1:72839b7: import static org.junit.Assert.assertTrue;
1:72839b7: 
1:ca456c4: import java.util.HashMap;
1:1a0f73e: import java.util.Map;
1:72839b7: import java.util.concurrent.TimeUnit;
1:1a811b7: import java.util.concurrent.atomic.AtomicBoolean;
1:72839b7: 
1:e050519: import org.apache.activemq.broker.jmx.DestinationViewMBean;
1:72839b7: import org.apache.activemq.broker.jmx.QueueViewMBean;
1:db71b43: import org.apache.activemq.junit.ActiveMQTestRunner;
1:db71b43: import org.apache.activemq.junit.Repeat;
1:72839b7: import org.apache.activemq.transport.amqp.client.AmqpClient;
1:72839b7: import org.apache.activemq.transport.amqp.client.AmqpClientTestSupport;
1:72839b7: import org.apache.activemq.transport.amqp.client.AmqpConnection;
1:72839b7: import org.apache.activemq.transport.amqp.client.AmqpMessage;
1:72839b7: import org.apache.activemq.transport.amqp.client.AmqpReceiver;
1:72839b7: import org.apache.activemq.transport.amqp.client.AmqpSession;
1:ca456c4: import org.apache.activemq.transport.amqp.client.AmqpUnknownFilterType;
1:1a0f73e: import org.apache.activemq.transport.amqp.client.AmqpValidator;
1:72839b7: import org.apache.activemq.util.Wait;
1:ca456c4: import org.apache.qpid.proton.amqp.DescribedType;
1:1a0f73e: import org.apache.qpid.proton.amqp.Symbol;
1:1a0f73e: import org.apache.qpid.proton.amqp.messaging.Source;
1:ca456c4: import org.apache.qpid.proton.amqp.messaging.TerminusDurability;
1:ca456c4: import org.apache.qpid.proton.amqp.messaging.TerminusExpiryPolicy;
1:381a1ae: import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;
1:381a1ae: import org.apache.qpid.proton.amqp.transport.SenderSettleMode;
1:1a0f73e: import org.apache.qpid.proton.engine.Receiver;
1:1a811b7: import org.apache.qpid.proton.engine.Session;
1:0cfd225: import org.apache.qpid.proton.message.Message;
1:72839b7: import org.junit.Test;
1:db71b43: import org.junit.runner.RunWith;
1:72839b7: 
2:72839b7: /**
1:72839b7:  * Test various behaviors of AMQP receivers with the broker.
1:72839b7:  */
1:db71b43: @RunWith(ActiveMQTestRunner.class)
1:72839b7: public class AmqpReceiverTest extends AmqpClientTestSupport {
1:72839b7: 
1:72839b7:     @Override
1:72839b7:     protected boolean isUseOpenWireConnector() {
1:72839b7:         return true;
1:72839b7:     }
1:72839b7: 
1:72839b7:     @Test(timeout = 60000)
1:1a811b7:     public void testReceiverCloseSendsRemoteClose() throws Exception {
1:1a811b7:         AmqpClient client = createAmqpClient();
1:1a811b7:         assertNotNull(client);
1:1a811b7: 
1:1a811b7:         final AtomicBoolean closed = new AtomicBoolean();
1:1a811b7: 
1:1a811b7:         client.setValidator(new AmqpValidator() {
1:1a811b7: 
1:1a811b7:             @Override
1:1a811b7:             public void inspectClosedResource(Session session) {
1:1a811b7:                 LOG.info("Session closed: {}", session.getContext());
1:1a811b7:             }
1:1a811b7: 
1:1a811b7:             @Override
1:1a811b7:             public void inspectDetachedResource(Receiver receiver) {
1:1a811b7:                 markAsInvalid("Broker should not detach receiver linked to closed session.");
1:1a811b7:             }
1:1a811b7: 
1:1a811b7:             @Override
1:1a811b7:             public void inspectClosedResource(Receiver receiver) {
1:1a811b7:                 LOG.info("Receiver closed: {}", receiver.getContext());
1:1a811b7:                 closed.set(true);
1:1a811b7:             }
1:1a811b7:         });
1:1a811b7: 
1:1a811b7:         AmqpConnection connection = trackConnection(client.connect());
1:1a811b7:         assertNotNull(connection);
1:1a811b7:         AmqpSession session = connection.createSession();
1:1a811b7:         assertNotNull(session);
1:1a811b7:         AmqpReceiver receiver = session.createReceiver("queue://" + getTestName());
1:1a811b7:         assertNotNull(receiver);
1:1a811b7: 
1:1a811b7:         receiver.close();
1:1a811b7: 
1:1a811b7:         assertTrue("Did not process remote close as expected", closed.get());
1:1a811b7:         connection.getStateInspector().assertValid();
1:1a811b7: 
1:1a811b7:         connection.close();
1:1a811b7:     }
1:1a811b7: 
1:1a811b7:     @Test(timeout = 60000)
1:72839b7:     public void testCreateQueueReceiver() throws Exception {
1:72839b7:         AmqpClient client = createAmqpClient();
1:1ac8954:         AmqpConnection connection = trackConnection(client.connect());
1:72839b7:         AmqpSession session = connection.createSession();
1:ca456c4: 
1:72839b7:         assertEquals(0, brokerService.getAdminView().getQueues().length);
1:ca456c4: 
1:72839b7:         AmqpReceiver receiver = session.createReceiver("queue://" + getTestName());
1:ca456c4: 
1:72839b7:         assertEquals(1, brokerService.getAdminView().getQueues().length);
1:72839b7:         assertNotNull(getProxyToQueue(getTestName()));
1:72839b7:         assertEquals(1, brokerService.getAdminView().getQueueSubscribers().length);
1:72839b7:         receiver.close();
1:72839b7:         assertEquals(0, brokerService.getAdminView().getQueueSubscribers().length);
1:72839b7: 
1:72839b7:         connection.close();
1:72839b7:     }
1:72839b7: 
1:ca456c4:     @Test(timeout = 60000)
1:381a1ae:     public void testSenderSettlementModeSettledIsHonored() throws Exception {
1:381a1ae:         doTestSenderSettlementModeIsHonored(SenderSettleMode.SETTLED);
1:381a1ae:     }
1:381a1ae: 
1:381a1ae:     @Test(timeout = 60000)
1:381a1ae:     public void testSenderSettlementModeUnsettledIsHonored() throws Exception {
1:381a1ae:         doTestSenderSettlementModeIsHonored(SenderSettleMode.UNSETTLED);
1:381a1ae:     }
1:381a1ae: 
1:381a1ae:     @Test(timeout = 60000)
1:381a1ae:     public void testSenderSettlementModeMixedIsHonored() throws Exception {
1:381a1ae:         doTestSenderSettlementModeIsHonored(SenderSettleMode.MIXED);
1:381a1ae:     }
1:381a1ae: 
1:381a1ae:     public void doTestSenderSettlementModeIsHonored(SenderSettleMode settleMode) throws Exception {
1:381a1ae:         AmqpClient client = createAmqpClient();
1:381a1ae:         AmqpConnection connection = trackConnection(client.connect());
1:381a1ae:         AmqpSession session = connection.createSession();
1:381a1ae: 
1:381a1ae:         assertEquals(0, brokerService.getAdminView().getQueues().length);
1:381a1ae: 
1:381a1ae:         AmqpReceiver receiver = session.createReceiver("queue://" + getTestName(), settleMode, ReceiverSettleMode.FIRST);
1:381a1ae: 
1:381a1ae:         assertEquals(1, brokerService.getAdminView().getQueues().length);
1:381a1ae:         assertNotNull(getProxyToQueue(getTestName()));
1:381a1ae:         assertEquals(1, brokerService.getAdminView().getQueueSubscribers().length);
1:381a1ae: 
1:381a1ae:         assertEquals(settleMode, receiver.getEndpoint().getRemoteSenderSettleMode());
1:381a1ae: 
1:381a1ae:         receiver.close();
1:381a1ae:         assertEquals(0, brokerService.getAdminView().getQueueSubscribers().length);
1:381a1ae: 
1:381a1ae:         connection.close();
1:381a1ae:     }
1:381a1ae: 
1:381a1ae:     @Test(timeout = 60000)
1:381a1ae:     public void testReceiverSettlementModeSetToFirst() throws Exception {
1:381a1ae:         doTestReceiverSettlementModeForcedToFirst(ReceiverSettleMode.FIRST);
1:381a1ae:     }
1:381a1ae: 
1:381a1ae:     @Test(timeout = 60000)
1:381a1ae:     public void testReceiverSettlementModeSetToSecond() throws Exception {
1:381a1ae:         doTestReceiverSettlementModeForcedToFirst(ReceiverSettleMode.SECOND);
1:381a1ae:     }
1:381a1ae: 
1:381a1ae:     /*
1:381a1ae:      * The Broker does not currently support ReceiverSettleMode of SECOND so we ensure that
1:381a1ae:      * it always drops that back to FIRST to let the client know.  The client will need to
1:381a1ae:      * check and react accordingly.
1:381a1ae:      */
1:381a1ae:     private void doTestReceiverSettlementModeForcedToFirst(ReceiverSettleMode modeToUse) throws Exception {
1:381a1ae:         AmqpClient client = createAmqpClient();
1:381a1ae:         AmqpConnection connection = trackConnection(client.connect());
1:381a1ae:         AmqpSession session = connection.createSession();
1:381a1ae: 
1:381a1ae:         assertEquals(0, brokerService.getAdminView().getQueues().length);
1:381a1ae: 
1:381a1ae:         AmqpReceiver receiver = session.createReceiver(
1:381a1ae:             "queue://" + getTestName(), SenderSettleMode.MIXED, modeToUse);
1:381a1ae: 
1:381a1ae:         assertEquals(1, brokerService.getAdminView().getQueues().length);
1:381a1ae:         assertNotNull(getProxyToQueue(getTestName()));
1:381a1ae:         assertEquals(1, brokerService.getAdminView().getQueueSubscribers().length);
1:381a1ae: 
1:381a1ae:         assertEquals(ReceiverSettleMode.FIRST, receiver.getEndpoint().getRemoteReceiverSettleMode());
1:381a1ae: 
1:381a1ae:         receiver.close();
1:381a1ae:         assertEquals(0, brokerService.getAdminView().getQueueSubscribers().length);
1:381a1ae: 
1:381a1ae:         connection.close();
1:381a1ae:     }
1:381a1ae: 
1:381a1ae:     @Test(timeout = 60000)
1:1a0f73e:     public void testCreateQueueReceiverWithJMSSelector() throws Exception {
1:1a0f73e:         AmqpClient client = createAmqpClient();
1:1a0f73e: 
1:ca456c4:         client.setValidator(new AmqpValidator() {
1:1a0f73e: 
1:1a0f73e:             @SuppressWarnings("unchecked")
1:1a0f73e:             @Override
1:1a0f73e:             public void inspectOpenedResource(Receiver receiver) {
1:1a0f73e:                 LOG.info("Receiver opened: {}", receiver);
1:1a0f73e: 
1:ca456c4:                 if (receiver.getRemoteSource() == null) {
1:1a0f73e:                     markAsInvalid("Link opened with null source.");
1:1a0f73e:                 }
1:1a0f73e: 
1:ca456c4:                 Source source = (Source) receiver.getRemoteSource();
1:1a0f73e:                 Map<Symbol, Object> filters = source.getFilter();
1:1a0f73e: 
1:1a0f73e:                 if (findFilter(filters, JMS_SELECTOR_FILTER_IDS) == null) {
1:1a0f73e:                     markAsInvalid("Broker did not return the JMS Filter on Attach");
1:1a0f73e:                 }
1:1a0f73e:             }
1:1a0f73e:         });
1:1a0f73e: 
1:1ac8954:         AmqpConnection connection = trackConnection(client.connect());
1:1a0f73e:         AmqpSession session = connection.createSession();
1:1a0f73e: 
1:1a0f73e:         assertEquals(0, brokerService.getAdminView().getQueues().length);
1:1a0f73e: 
1:1a0f73e:         session.createReceiver("queue://" + getTestName(), "JMSPriority > 8");
1:1a0f73e: 
1:1a0f73e:         assertEquals(1, brokerService.getAdminView().getQueueSubscribers().length);
1:1a0f73e: 
1:1a0f73e:         connection.getStateInspector().assertValid();
1:1a0f73e:         connection.close();
1:1a0f73e:     }
1:1a0f73e: 
1:1a0f73e:     @Test(timeout = 60000)
1:1a0f73e:     public void testCreateQueueReceiverWithNoLocalSet() throws Exception {
1:1a0f73e:         AmqpClient client = createAmqpClient();
1:1a0f73e: 
1:ca456c4:         client.setValidator(new AmqpValidator() {
1:1a0f73e: 
1:1a0f73e:             @SuppressWarnings("unchecked")
1:1a0f73e:             @Override
1:1a0f73e:             public void inspectOpenedResource(Receiver receiver) {
1:1a0f73e:                 LOG.info("Receiver opened: {}", receiver);
1:1a0f73e: 
1:ca456c4:                 if (receiver.getRemoteSource() == null) {
1:1a0f73e:                     markAsInvalid("Link opened with null source.");
1:1a0f73e:                 }
1:1a0f73e: 
1:ca456c4:                 Source source = (Source) receiver.getRemoteSource();
1:1a0f73e:                 Map<Symbol, Object> filters = source.getFilter();
1:1a0f73e: 
1:1a0f73e:                 if (findFilter(filters, NO_LOCAL_FILTER_IDS) == null) {
1:1a0f73e:                     markAsInvalid("Broker did not return the NoLocal Filter on Attach");
1:1a0f73e:                 }
1:1a0f73e:             }
1:1a0f73e:         });
1:1a0f73e: 
1:1ac8954:         AmqpConnection connection = trackConnection(client.connect());
1:1a0f73e:         AmqpSession session = connection.createSession();
1:1a0f73e: 
1:1a0f73e:         assertEquals(0, brokerService.getAdminView().getQueues().length);
1:1a0f73e: 
1:1a0f73e:         session.createReceiver("queue://" + getTestName(), null, true);
1:1a0f73e: 
1:1a0f73e:         assertEquals(1, brokerService.getAdminView().getQueueSubscribers().length);
1:1a0f73e: 
1:1a0f73e:         connection.getStateInspector().assertValid();
1:1a0f73e:         connection.close();
1:1a0f73e:     }
1:1a0f73e: 
1:1a0f73e:     @Test(timeout = 60000)
1:72839b7:     public void testCreateTopicReceiver() throws Exception {
1:72839b7:         AmqpClient client = createAmqpClient();
1:1ac8954:         AmqpConnection connection = trackConnection(client.connect());
1:72839b7:         AmqpSession session = connection.createSession();
1:72839b7: 
1:72839b7:         assertEquals(0, brokerService.getAdminView().getTopics().length);
1:72839b7: 
1:72839b7:         AmqpReceiver receiver = session.createReceiver("topic://" + getTestName());
1:72839b7: 
1:72839b7:         assertEquals(1, brokerService.getAdminView().getTopics().length);
1:72839b7:         assertNotNull(getProxyToTopic(getTestName()));
1:72839b7:         assertEquals(1, brokerService.getAdminView().getTopicSubscribers().length);
1:72839b7:         receiver.close();
1:72839b7:         assertEquals(0, brokerService.getAdminView().getTopicSubscribers().length);
1:72839b7: 
1:72839b7:         connection.close();
1:72839b7:     }
1:72839b7: 
1:72839b7:     @Test(timeout = 60000)
1:72839b7:     public void testQueueReceiverReadMessage() throws Exception {
1:72839b7:         sendMessages(getTestName(), 1, false);
1:f71e0ee: 
1:72839b7:         AmqpClient client = createAmqpClient();
1:1ac8954:         AmqpConnection connection = trackConnection(client.connect());
1:72839b7:         AmqpSession session = connection.createSession();
1:72839b7: 
1:72839b7:         AmqpReceiver receiver = session.createReceiver("queue://" + getTestName());
1:72839b7: 
2:72839b7:         QueueViewMBean queueView = getProxyToQueue(getTestName());
1:72839b7:         assertEquals(1, queueView.getQueueSize());
2:72839b7:         assertEquals(0, queueView.getDispatchCount());
1:72839b7: 
1:72839b7:         receiver.flow(1);
1:72839b7:         assertNotNull(receiver.receive(5, TimeUnit.SECONDS));
1:72839b7:         receiver.close();
1:72839b7: 
1:72839b7:         assertEquals(1, queueView.getQueueSize());
1:72839b7: 
1:72839b7:         connection.close();
1:72839b7:     }
1:72839b7: 
1:72839b7:     @Test(timeout = 60000)
1:db71b43:     @Repeat(repetitions = 1)
1:db71b43:     public void testPresettledReceiverReadsAllMessages() throws Exception {
1:db71b43:         final int MSG_COUNT = 100;
1:db71b43:         sendMessages(getTestName(), MSG_COUNT, false);
1:db71b43: 
1:db71b43:         AmqpClient client = createAmqpClient();
1:1ac8954:         AmqpConnection connection = trackConnection(client.connect());
1:db71b43:         AmqpSession session = connection.createSession();
1:db71b43: 
1:db71b43:         AmqpReceiver receiver = session.createReceiver("queue://" + getTestName(), null, false, true);
1:db71b43: 
1:db71b43:         QueueViewMBean queueView = getProxyToQueue(getTestName());
1:db71b43:         assertEquals(MSG_COUNT, queueView.getQueueSize());
1:db71b43:         assertEquals(0, queueView.getDispatchCount());
1:db71b43: 
1:db71b43:         receiver.flow(MSG_COUNT);
1:db71b43:         for (int i = 0; i < MSG_COUNT; ++i) {
1:db71b43:             assertNotNull(receiver.receive(5, TimeUnit.SECONDS));
1:db71b43:         }
1:db71b43:         receiver.close();
1:db71b43: 
1:db71b43:         assertEquals(0, queueView.getQueueSize());
1:db71b43: 
1:db71b43:         connection.close();
1:db71b43:     }
1:db71b43: 
1:db71b43:     @Test(timeout = 60000)
1:db71b43:     @Repeat(repetitions = 1)
1:e050519:     public void testPresettledReceiverReadsAllMessagesInNonFlowBatchQueue() throws Exception {
1:e050519:         doTestPresettledReceiverReadsAllMessagesInNonFlowBatch(false);
1:e050519:     }
1:e050519: 
1:e050519:     @Test(timeout = 60000)
1:e050519:     @Repeat(repetitions = 1)
1:e050519:     public void testPresettledReceiverReadsAllMessagesInNonFlowBatchTopic() throws Exception {
1:e050519:         doTestPresettledReceiverReadsAllMessagesInNonFlowBatch(true);
1:e050519:     }
1:e050519: 
1:e050519:     private void doTestPresettledReceiverReadsAllMessagesInNonFlowBatch(boolean topic) throws Exception {
1:e050519: 
1:e050519:         final String destinationName;
1:e050519:         if (topic) {
1:e050519:             destinationName = "topic://" + getTestName();
1:e050519:         } else {
1:e050519:             destinationName = "queue://" + getTestName();
1:e050519:         }
1:e050519: 
1:6c01b64:         final int MSG_COUNT = 100;
1:72839b7: 
1:6c01b64:         AmqpClient client = createAmqpClient();
1:1ac8954:         AmqpConnection connection = trackConnection(client.connect());
1:6c01b64:         AmqpSession session = connection.createSession();
1:72839b7: 
1:e050519:         AmqpReceiver receiver = session.createReceiver(destinationName, null, false, true);
1:72839b7: 
1:e050519:         sendMessages(getTestName(), MSG_COUNT, topic);
1:e050519: 
1:e050519:         final DestinationViewMBean destinationView;
1:e050519:         if (topic) {
1:e050519:             destinationView = getProxyToTopic(getTestName());
1:e050519:         } else {
1:e050519:             destinationView = getProxyToQueue(getTestName());
1:e050519:         }
1:e050519:         assertEquals(MSG_COUNT, destinationView.getEnqueueCount());
1:e050519:         assertEquals(0, destinationView.getDispatchCount());
1:72839b7: 
1:6c01b64:         receiver.flow(20);
1:6c01b64:         // consume less that flow
1:6c01b64:         for (int j=0;j<10;j++) {
1:6c01b64:             assertNotNull(receiver.receive(5, TimeUnit.SECONDS));
1:6c01b64:         }
1:72839b7: 
1:6c01b64:         // flow more and consume all
1:6c01b64:         receiver.flow(10);
1:6c01b64:         for (int j=0;j<20;j++) {
1:6c01b64:             assertNotNull(receiver.receive(5, TimeUnit.SECONDS));
1:6c01b64:         }
1:6c01b64: 
1:6c01b64:         // remainder
1:6c01b64:         receiver.flow(70);
1:6c01b64:         for (int j=0;j<70;j++) {
1:6c01b64:             assertNotNull(receiver.receive(5, TimeUnit.SECONDS));
1:6c01b64:         }
1:6c01b64: 
1:6c01b64:         receiver.close();
1:6c01b64: 
1:e050519:         assertEquals(0, destinationView.getEnqueueCount() - destinationView.getDequeueCount());
1:6c01b64: 
1:6c01b64:         connection.close();
1:6c01b64:     }
1:6c01b64: 
1:72839b7:     @Test(timeout = 60000)
1:6c01b64:     @Repeat(repetitions = 1)
1:72839b7:     public void testTwoQueueReceiversOnSameConnectionReadMessagesNoDispositions() throws Exception {
1:72839b7:         int MSG_COUNT = 4;
2:72839b7:         sendMessages(getTestName(), MSG_COUNT, false);
1:72839b7: 
1:72839b7:         AmqpClient client = createAmqpClient();
1:1ac8954:         AmqpConnection connection = trackConnection(client.connect());
1:72839b7:         AmqpSession session = connection.createSession();
1:72839b7: 
1:72839b7:         AmqpReceiver receiver1 = session.createReceiver("queue://" + getTestName());
1:72839b7: 
1:72839b7:         QueueViewMBean queueView = getProxyToQueue(getTestName());
2:72839b7:         assertEquals(MSG_COUNT, queueView.getQueueSize());
1:72839b7: 
1:72839b7:         receiver1.flow(2);
1:72839b7:         assertNotNull(receiver1.receive(5, TimeUnit.SECONDS));
1:72839b7:         assertNotNull(receiver1.receive(5, TimeUnit.SECONDS));
1:72839b7: 
1:72839b7:         AmqpReceiver receiver2 = session.createReceiver("queue://" + getTestName());
1:72839b7: 
1:72839b7:         assertEquals(2, brokerService.getAdminView().getQueueSubscribers().length);
1:72839b7: 
1:72839b7:         receiver2.flow(2);
1:72839b7:         assertNotNull(receiver2.receive(5, TimeUnit.SECONDS));
1:72839b7:         assertNotNull(receiver2.receive(5, TimeUnit.SECONDS));
1:72839b7: 
1:72839b7:         assertEquals(MSG_COUNT, queueView.getDispatchCount());
1:72839b7:         assertEquals(0, queueView.getDequeueCount());
1:72839b7: 
1:72839b7:         receiver1.close();
1:72839b7:         receiver2.close();
1:72839b7: 
1:72839b7:         assertEquals(MSG_COUNT, queueView.getQueueSize());
1:72839b7: 
1:72839b7:         connection.close();
1:72839b7:     }
1:72839b7: 
1:72839b7:     @Test(timeout = 60000)
1:72839b7:     public void testTwoQueueReceiversOnSameConnectionReadMessagesAcceptOnEach() throws Exception {
1:72839b7:         int MSG_COUNT = 4;
1:72839b7:         sendMessages(getTestName(), MSG_COUNT, false);
1:72839b7: 
1:72839b7:         AmqpClient client = createAmqpClient();
1:1ac8954:         AmqpConnection connection = trackConnection(client.connect());
1:72839b7:         AmqpSession session = connection.createSession();
1:72839b7: 
1:72839b7:         AmqpReceiver receiver1 = session.createReceiver("queue://" + getTestName());
1:72839b7: 
1:72839b7:         final QueueViewMBean queueView = getProxyToQueue(getTestName());
1:72839b7:         assertEquals(MSG_COUNT, queueView.getQueueSize());
1:72839b7: 
1:72839b7:         receiver1.flow(2);
1:72839b7:         AmqpMessage message = receiver1.receive(5, TimeUnit.SECONDS);
2:72839b7:         assertNotNull(message);
1:f71e0ee:         message.accept();
1:72839b7:         message = receiver1.receive(5, TimeUnit.SECONDS);
1:72839b7:         assertNotNull(message);
2:72839b7:         message.accept();
1:72839b7: 
1:72839b7:         assertTrue("Should have ack'd two", Wait.waitFor(new Wait.Condition() {
1:72839b7: 
1:72839b7:             @Override
1:72839b7:             public boolean isSatisified() throws Exception {
1:72839b7:                 return queueView.getDequeueCount() == 2;
1:72839b7:             }
1:72839b7:         }, TimeUnit.SECONDS.toMillis(5), TimeUnit.MILLISECONDS.toMillis(50)));
1:72839b7: 
1:72839b7:         AmqpReceiver receiver2 = session.createReceiver("queue://" + getTestName());
1:72839b7: 
1:72839b7:         assertEquals(2, brokerService.getAdminView().getQueueSubscribers().length);
1:72839b7: 
1:72839b7:         receiver2.flow(2);
1:72839b7:         message = receiver2.receive(5, TimeUnit.SECONDS);
1:72839b7:         assertNotNull(message);
1:72839b7:         message.accept();
1:72839b7:         message = receiver2.receive(5, TimeUnit.SECONDS);
1:72839b7:         assertNotNull(message);
1:72839b7:         message.accept();
1:72839b7: 
1:72839b7:         assertEquals(MSG_COUNT, queueView.getDispatchCount());
1:72839b7:         assertTrue("Queue should be empty now", Wait.waitFor(new Wait.Condition() {
1:72839b7: 
1:72839b7:             @Override
1:72839b7:             public boolean isSatisified() throws Exception {
1:72839b7:                 return queueView.getDequeueCount() == 4;
1:72839b7:             }
1:72839b7:         }, TimeUnit.SECONDS.toMillis(15), TimeUnit.MILLISECONDS.toMillis(10)));
1:72839b7: 
1:72839b7:         receiver1.close();
1:72839b7:         receiver2.close();
1:72839b7: 
2:72839b7:         assertEquals(0, queueView.getQueueSize());
1:72839b7: 
1:72839b7:         connection.close();
1:72839b7:     }
1:72839b7: 
1:72839b7:     @Test(timeout = 60000)
1:72839b7:     public void testSecondReceiverOnQueueGetsAllUnconsumedMessages() throws Exception {
2:72839b7:         int MSG_COUNT = 20;
1:72839b7:         sendMessages(getTestName(), MSG_COUNT, false);
1:72839b7: 
1:72839b7:         AmqpClient client = createAmqpClient();
1:1ac8954:         AmqpConnection connection = trackConnection(client.connect());
1:72839b7:         AmqpSession session = connection.createSession();
1:72839b7: 
1:72839b7:         AmqpReceiver receiver1 = session.createReceiver("queue://" + getTestName());
1:72839b7: 
1:72839b7:         final QueueViewMBean queueView = getProxyToQueue(getTestName());
1:72839b7:         assertEquals(MSG_COUNT, queueView.getQueueSize());
1:72839b7: 
1:72839b7:         receiver1.flow(20);
1:72839b7: 
1:72839b7:         assertTrue("Should have dispatch to prefetch", Wait.waitFor(new Wait.Condition() {
1:72839b7: 
1:72839b7:             @Override
1:72839b7:             public boolean isSatisified() throws Exception {
1:72839b7:                 return queueView.getInFlightCount() >= 2;
1:72839b7:             }
1:72839b7:         }, TimeUnit.SECONDS.toMillis(5), TimeUnit.MILLISECONDS.toMillis(50)));
1:72839b7: 
1:72839b7:         receiver1.close();
1:72839b7: 
1:72839b7:         AmqpReceiver receiver2 = session.createReceiver("queue://" + getTestName());
1:72839b7: 
1:72839b7:         assertEquals(1, brokerService.getAdminView().getQueueSubscribers().length);
1:72839b7: 
1:72839b7:         receiver2.flow(MSG_COUNT * 2);
1:72839b7:         AmqpMessage message = receiver2.receive(5, TimeUnit.SECONDS);
1:72839b7:         assertNotNull(message);
1:72839b7:         message.accept();
1:72839b7:         message = receiver2.receive(5, TimeUnit.SECONDS);
1:72839b7:         assertNotNull(message);
1:72839b7:         message.accept();
1:72839b7: 
1:72839b7:         assertTrue("Should have ack'd two", Wait.waitFor(new Wait.Condition() {
1:72839b7: 
1:72839b7:             @Override
1:72839b7:             public boolean isSatisified() throws Exception {
1:72839b7:                 return queueView.getDequeueCount() == 2;
1:72839b7:             }
1:72839b7:         }, TimeUnit.SECONDS.toMillis(5), TimeUnit.MILLISECONDS.toMillis(50)));
1:72839b7: 
1:72839b7:         receiver2.close();
1:72839b7: 
1:72839b7:         assertEquals(MSG_COUNT - 2, queueView.getQueueSize());
1:72839b7: 
1:72839b7:         connection.close();
1:72839b7:     }
1:72839b7: 
1:72839b7:     @Test(timeout = 60000)
1:ca456c4:     public void testUnsupportedFiltersAreNotListedAsSupported() throws Exception {
1:ca456c4:         AmqpClient client = createAmqpClient();
1:ca456c4: 
1:ca456c4:         client.setValidator(new AmqpValidator() {
1:ca456c4: 
1:ca456c4:             @SuppressWarnings("unchecked")
1:ca456c4:             @Override
1:ca456c4:             public void inspectOpenedResource(Receiver receiver) {
1:ca456c4:                 LOG.info("Receiver opened: {}", receiver);
1:ca456c4: 
1:ca456c4:                 if (receiver.getRemoteSource() == null) {
1:ca456c4:                     markAsInvalid("Link opened with null source.");
1:ca456c4:                 }
1:72839b7: 
1:ca456c4:                 Source source = (Source) receiver.getRemoteSource();
1:ca456c4:                 Map<Symbol, Object> filters = source.getFilter();
1:72839b7: 
1:ca456c4:                 if (findFilter(filters, AmqpUnknownFilterType.UNKNOWN_FILTER_IDS) != null) {
1:ca456c4:                     markAsInvalid("Broker should not return unsupported filter on attach.");
1:ca456c4:                 }
1:ca456c4:             }
1:ca456c4:         });
1:ca456c4: 
1:e050519:         Map<Symbol, DescribedType> filters = new HashMap<>();
1:ca456c4:         filters.put(AmqpUnknownFilterType.UNKNOWN_FILTER_NAME, AmqpUnknownFilterType.UNKOWN_FILTER);
1:ca456c4: 
1:ca456c4:         Source source = new Source();
1:ca456c4:         source.setAddress("queue://" + getTestName());
1:ca456c4:         source.setFilter(filters);
1:ca456c4:         source.setDurable(TerminusDurability.NONE);
1:ca456c4:         source.setExpiryPolicy(TerminusExpiryPolicy.LINK_DETACH);
1:ca456c4: 
1:1ac8954:         AmqpConnection connection = trackConnection(client.connect());
1:ca456c4:         AmqpSession session = connection.createSession();
1:ca456c4: 
1:ca456c4:         assertEquals(0, brokerService.getAdminView().getQueues().length);
1:ca456c4: 
1:ca456c4:         session.createReceiver(source);
1:ca456c4: 
1:ca456c4:         assertEquals(1, brokerService.getAdminView().getQueueSubscribers().length);
1:ca456c4: 
1:ca456c4:         connection.getStateInspector().assertValid();
1:ca456c4:         connection.close();
1:ca456c4:     }
1:72839b7: 
1:0cfd225:     @Test(timeout = 30000)
1:f71e0ee:     public void testReleasedDisposition() throws Exception {
1:f71e0ee:         sendMessages(getTestName(), 1, false);
1:f71e0ee: 
1:f71e0ee:         AmqpClient client = createAmqpClient();
1:f71e0ee:         AmqpConnection connection = trackConnection(client.connect());
1:f71e0ee:         AmqpSession session = connection.createSession();
1:f71e0ee: 
1:f71e0ee:         AmqpReceiver receiver = session.createReceiver(getTestName());
1:f71e0ee:         receiver.flow(2);
1:f71e0ee: 
1:f71e0ee:         AmqpMessage message = receiver.receive(5, TimeUnit.SECONDS);
1:f71e0ee:         assertNotNull("did not receive message first time", message);
1:f71e0ee: 
1:f71e0ee:         Message protonMessage = message.getWrappedMessage();
1:f71e0ee:         assertNotNull(protonMessage);
1:f71e0ee:         assertEquals("Unexpected initial value for AMQP delivery-count", 0, protonMessage.getDeliveryCount());
1:f71e0ee: 
1:f71e0ee:         message.release();
1:f71e0ee: 
2:f71e0ee:         // Read the message again and validate its state
1:f71e0ee: 
2:f71e0ee:         message = receiver.receive(10, TimeUnit.SECONDS);
1:f71e0ee:         assertNotNull("did not receive message again", message);
1:f71e0ee: 
1:f71e0ee:         message.accept();
1:f71e0ee: 
2:f71e0ee:         protonMessage = message.getWrappedMessage();
1:f71e0ee:         assertNotNull(protonMessage);
1:f71e0ee:         assertEquals("Unexpected updated value for AMQP delivery-count", 0, protonMessage.getDeliveryCount());
1:f71e0ee: 
1:f71e0ee:         connection.close();
1:f71e0ee:     }
1:f71e0ee: 
1:f71e0ee:     @Test(timeout = 30000)
1:f71e0ee:     public void testRejectedDisposition() throws Exception {
1:f71e0ee:         sendMessages(getTestName(), 1, false);
1:f71e0ee: 
1:f71e0ee:         AmqpClient client = createAmqpClient();
1:f71e0ee:         AmqpConnection connection = trackConnection(client.connect());
1:f71e0ee:         AmqpSession session = connection.createSession();
1:f71e0ee: 
1:f71e0ee:         AmqpReceiver receiver = session.createReceiver(getTestName());
1:f71e0ee:         receiver.flow(2);
1:f71e0ee: 
1:f71e0ee:         AmqpMessage message = receiver.receive(5, TimeUnit.SECONDS);
1:f71e0ee:         assertNotNull("did not receive message first time", message);
1:f71e0ee: 
1:f71e0ee:         Message protonMessage = message.getWrappedMessage();
1:f71e0ee:         assertNotNull(protonMessage);
1:f71e0ee:         assertEquals("Unexpected initial value for AMQP delivery-count", 0, protonMessage.getDeliveryCount());
1:f71e0ee: 
1:f71e0ee:         message.reject();
1:f71e0ee: 
1:a9f9d4a:         // Attempt to read the message again but should not get it.
1:a9f9d4a:         message = receiver.receive(2, TimeUnit.SECONDS);
1:a9f9d4a:         assertNull("shoudl not receive message again", message);
1:f71e0ee: 
1:f71e0ee:         connection.close();
1:f71e0ee:     }
1:f71e0ee: 
1:f71e0ee:     @Test(timeout = 30000)
1:0cfd225:     public void testModifiedDispositionWithDeliveryFailedWithoutUndeliverableHereFieldsSet() throws Exception {
1:0cfd225:         doModifiedDispositionTestImpl(Boolean.TRUE, null);
1:72839b7:     }
1:f71e0ee: 
1:0cfd225:     @Test(timeout = 30000)
1:0cfd225:     public void testModifiedDispositionWithoutDeliveryFailedWithoutUndeliverableHereFieldsSet() throws Exception {
1:0cfd225:         doModifiedDispositionTestImpl(null, null);
1:72839b7:     }
1:f71e0ee: 
1:0cfd225:     @Test(timeout = 30000)
1:0cfd225:     public void testModifiedDispositionWithoutDeliveryFailedWithUndeliverableHereFieldsSet() throws Exception {
1:0cfd225:         doModifiedDispositionTestImpl(null, Boolean.TRUE);
1:72839b7:     }
1:72839b7: 
1:0cfd225:     @Test(timeout = 30000)
1:0cfd225:     public void testModifiedDispositionWithDeliveryFailedWithUndeliverableHereFieldsSet() throws Exception {
1:0cfd225:         doModifiedDispositionTestImpl(Boolean.TRUE, Boolean.TRUE);
3:0cfd225:     }
1:72839b7: 
1:0cfd225:     private void doModifiedDispositionTestImpl(Boolean deliveryFailed, Boolean undeliverableHere) throws Exception {
1:0cfd225:         int msgCount = 1;
1:0cfd225:         sendMessages(getTestName(), msgCount, false);
1:6c01b64: 
1:72839b7:         AmqpClient client = createAmqpClient();
1:1ac8954:         AmqpConnection connection = trackConnection(client.connect());
1:72839b7:         AmqpSession session = connection.createSession();
1:6c01b64: 
1:72839b7:         AmqpReceiver receiver = session.createReceiver("queue://" + getTestName());
1:0cfd225:         receiver.flow(2 * msgCount);
1:6c01b64: 
1:72839b7:         AmqpMessage message = receiver.receive(5, TimeUnit.SECONDS);
1:0cfd225:         assertNotNull("did not receive message first time", message);
1:6c01b64: 
1:0cfd225:         Message protonMessage = message.getWrappedMessage();
1:f71e0ee:         assertNotNull(protonMessage);
1:0cfd225:         assertEquals("Unexpected initial value for AMQP delivery-count", 0, protonMessage.getDeliveryCount());
1:6c01b64: 
1:0cfd225:         message.modified(deliveryFailed, undeliverableHere);
11:0cfd225: 
1:0cfd225:         if(Boolean.TRUE.equals(undeliverableHere)) {
1:0cfd225:             message = receiver.receive(250, TimeUnit.MILLISECONDS);
1:0cfd225:             assertNull("Should not receive message again", message);
1:0cfd225:         } else {
1:0cfd225:             message = receiver.receive(5, TimeUnit.SECONDS);
1:f71e0ee:             assertNotNull("did not receive message again", message);
1:0cfd225: 
1:0cfd225:             int expectedDeliveryCount = 0;
1:0cfd225:             if(Boolean.TRUE.equals(deliveryFailed)) {
1:0cfd225:                 expectedDeliveryCount = 1;
1:0cfd225:             }
1:0cfd225: 
1:72839b7:             message.accept();
1:0cfd225: 
1:0cfd225:             Message protonMessage2 = message.getWrappedMessage();
1:0cfd225:             assertNotNull(protonMessage2);
1:0cfd225:             assertEquals("Unexpected updated value for AMQP delivery-count", expectedDeliveryCount, protonMessage2.getDeliveryCount());
1:0cfd225:         }
1:0cfd225: 
1:72839b7:         receiver.close();
1:72839b7:         connection.close();
1:0cfd225:     }
1:0cfd225: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:381a1ae
/////////////////////////////////////////////////////////////////////////
1: import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;
1: import org.apache.qpid.proton.amqp.transport.SenderSettleMode;
/////////////////////////////////////////////////////////////////////////
1:     public void testSenderSettlementModeSettledIsHonored() throws Exception {
1:         doTestSenderSettlementModeIsHonored(SenderSettleMode.SETTLED);
1:     }
1: 
1:     @Test(timeout = 60000)
1:     public void testSenderSettlementModeUnsettledIsHonored() throws Exception {
1:         doTestSenderSettlementModeIsHonored(SenderSettleMode.UNSETTLED);
1:     }
1: 
1:     @Test(timeout = 60000)
1:     public void testSenderSettlementModeMixedIsHonored() throws Exception {
1:         doTestSenderSettlementModeIsHonored(SenderSettleMode.MIXED);
1:     }
1: 
1:     public void doTestSenderSettlementModeIsHonored(SenderSettleMode settleMode) throws Exception {
1:         AmqpClient client = createAmqpClient();
1:         AmqpConnection connection = trackConnection(client.connect());
1:         AmqpSession session = connection.createSession();
1: 
1:         assertEquals(0, brokerService.getAdminView().getQueues().length);
1: 
1:         AmqpReceiver receiver = session.createReceiver("queue://" + getTestName(), settleMode, ReceiverSettleMode.FIRST);
1: 
1:         assertEquals(1, brokerService.getAdminView().getQueues().length);
1:         assertNotNull(getProxyToQueue(getTestName()));
1:         assertEquals(1, brokerService.getAdminView().getQueueSubscribers().length);
1: 
1:         assertEquals(settleMode, receiver.getEndpoint().getRemoteSenderSettleMode());
1: 
1:         receiver.close();
1:         assertEquals(0, brokerService.getAdminView().getQueueSubscribers().length);
1: 
1:         connection.close();
1:     }
1: 
1:     @Test(timeout = 60000)
1:     public void testReceiverSettlementModeSetToFirst() throws Exception {
1:         doTestReceiverSettlementModeForcedToFirst(ReceiverSettleMode.FIRST);
1:     }
1: 
1:     @Test(timeout = 60000)
1:     public void testReceiverSettlementModeSetToSecond() throws Exception {
1:         doTestReceiverSettlementModeForcedToFirst(ReceiverSettleMode.SECOND);
1:     }
1: 
1:     /*
1:      * The Broker does not currently support ReceiverSettleMode of SECOND so we ensure that
1:      * it always drops that back to FIRST to let the client know.  The client will need to
1:      * check and react accordingly.
1:      */
1:     private void doTestReceiverSettlementModeForcedToFirst(ReceiverSettleMode modeToUse) throws Exception {
1:         AmqpClient client = createAmqpClient();
1:         AmqpConnection connection = trackConnection(client.connect());
1:         AmqpSession session = connection.createSession();
1: 
1:         assertEquals(0, brokerService.getAdminView().getQueues().length);
1: 
1:         AmqpReceiver receiver = session.createReceiver(
1:             "queue://" + getTestName(), SenderSettleMode.MIXED, modeToUse);
1: 
1:         assertEquals(1, brokerService.getAdminView().getQueues().length);
1:         assertNotNull(getProxyToQueue(getTestName()));
1:         assertEquals(1, brokerService.getAdminView().getQueueSubscribers().length);
1: 
1:         assertEquals(ReceiverSettleMode.FIRST, receiver.getEndpoint().getRemoteReceiverSettleMode());
1: 
1:         receiver.close();
1:         assertEquals(0, brokerService.getAdminView().getQueueSubscribers().length);
1: 
1:         connection.close();
1:     }
1: 
1:     @Test(timeout = 60000)
commit:e050519
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.jmx.DestinationViewMBean;
/////////////////////////////////////////////////////////////////////////
1:     public void testPresettledReceiverReadsAllMessagesInNonFlowBatchQueue() throws Exception {
1:         doTestPresettledReceiverReadsAllMessagesInNonFlowBatch(false);
1:     }
1: 
1:     @Test(timeout = 60000)
1:     @Repeat(repetitions = 1)
1:     public void testPresettledReceiverReadsAllMessagesInNonFlowBatchTopic() throws Exception {
1:         doTestPresettledReceiverReadsAllMessagesInNonFlowBatch(true);
1:     }
1: 
1:     private void doTestPresettledReceiverReadsAllMessagesInNonFlowBatch(boolean topic) throws Exception {
1: 
1:         final String destinationName;
1:         if (topic) {
1:             destinationName = "topic://" + getTestName();
1:         } else {
1:             destinationName = "queue://" + getTestName();
1:         }
1: 
1:         AmqpReceiver receiver = session.createReceiver(destinationName, null, false, true);
1:         sendMessages(getTestName(), MSG_COUNT, topic);
1: 
1:         final DestinationViewMBean destinationView;
1:         if (topic) {
1:             destinationView = getProxyToTopic(getTestName());
1:         } else {
1:             destinationView = getProxyToQueue(getTestName());
1:         }
1:         assertEquals(MSG_COUNT, destinationView.getEnqueueCount());
1:         assertEquals(0, destinationView.getDispatchCount());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(0, destinationView.getEnqueueCount() - destinationView.getDequeueCount());
/////////////////////////////////////////////////////////////////////////
1:         Map<Symbol, DescribedType> filters = new HashMap<>();
commit:1a811b7
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.qpid.proton.engine.Session;
/////////////////////////////////////////////////////////////////////////
1:     public void testReceiverCloseSendsRemoteClose() throws Exception {
1:         AmqpClient client = createAmqpClient();
1:         assertNotNull(client);
1: 
1:         final AtomicBoolean closed = new AtomicBoolean();
1: 
1:         client.setValidator(new AmqpValidator() {
1: 
1:             @Override
1:             public void inspectClosedResource(Session session) {
1:                 LOG.info("Session closed: {}", session.getContext());
1:             }
1: 
1:             @Override
1:             public void inspectDetachedResource(Receiver receiver) {
1:                 markAsInvalid("Broker should not detach receiver linked to closed session.");
1:             }
1: 
1:             @Override
1:             public void inspectClosedResource(Receiver receiver) {
1:                 LOG.info("Receiver closed: {}", receiver.getContext());
1:                 closed.set(true);
1:             }
1:         });
1: 
1:         AmqpConnection connection = trackConnection(client.connect());
1:         assertNotNull(connection);
1:         AmqpSession session = connection.createSession();
1:         assertNotNull(session);
1:         AmqpReceiver receiver = session.createReceiver("queue://" + getTestName());
1:         assertNotNull(receiver);
1: 
1:         receiver.close();
1: 
1:         assertTrue("Did not process remote close as expected", closed.get());
1:         connection.getStateInspector().assertValid();
1: 
1:         connection.close();
1:     }
1: 
1:     @Test(timeout = 60000)
commit:a9f9d4a
/////////////////////////////////////////////////////////////////////////
1:         // Attempt to read the message again but should not get it.
1:         message = receiver.receive(2, TimeUnit.SECONDS);
1:         assertNull("shoudl not receive message again", message);
commit:f71e0ee
/////////////////////////////////////////////////////////////////////////
1:     public void testReleasedDisposition() throws Exception {
1:         sendMessages(getTestName(), 1, false);
1: 
1:         AmqpClient client = createAmqpClient();
1:         AmqpConnection connection = trackConnection(client.connect());
1:         AmqpSession session = connection.createSession();
1: 
1:         AmqpReceiver receiver = session.createReceiver(getTestName());
1:         receiver.flow(2);
1: 
1:         AmqpMessage message = receiver.receive(5, TimeUnit.SECONDS);
1:         assertNotNull("did not receive message first time", message);
1: 
1:         Message protonMessage = message.getWrappedMessage();
1:         assertNotNull(protonMessage);
1:         assertEquals("Unexpected initial value for AMQP delivery-count", 0, protonMessage.getDeliveryCount());
1: 
1:         message.release();
1: 
1:         // Read the message again and validate its state
1: 
1:         message = receiver.receive(10, TimeUnit.SECONDS);
1:         assertNotNull("did not receive message again", message);
1: 
1:         message.accept();
1: 
1:         protonMessage = message.getWrappedMessage();
1:         assertNotNull(protonMessage);
1:         assertEquals("Unexpected updated value for AMQP delivery-count", 0, protonMessage.getDeliveryCount());
1: 
1:         connection.close();
1:     }
1: 
1:     @Test(timeout = 30000)
1:     public void testRejectedDisposition() throws Exception {
1:         sendMessages(getTestName(), 1, false);
1: 
1:         AmqpClient client = createAmqpClient();
1:         AmqpConnection connection = trackConnection(client.connect());
1:         AmqpSession session = connection.createSession();
1: 
1:         AmqpReceiver receiver = session.createReceiver(getTestName());
1:         receiver.flow(2);
1: 
1:         AmqpMessage message = receiver.receive(5, TimeUnit.SECONDS);
1:         assertNotNull("did not receive message first time", message);
1: 
1:         Message protonMessage = message.getWrappedMessage();
1:         assertNotNull(protonMessage);
1:         assertEquals("Unexpected initial value for AMQP delivery-count", 0, protonMessage.getDeliveryCount());
1: 
1:         message.reject();
1: 
1:         // Read the message again and validate its state
1: 
1:         message = receiver.receive(10, TimeUnit.SECONDS);
1:         assertNotNull("did not receive message again", message);
1: 
1:         message.accept();
1: 
1:         protonMessage = message.getWrappedMessage();
1:         assertNotNull(protonMessage);
0:         assertEquals("Unexpected updated value for AMQP delivery-count", 1, protonMessage.getDeliveryCount());
1: 
1:         connection.close();
1:     }
1: 
1:     @Test(timeout = 30000)
commit:1ac8954
/////////////////////////////////////////////////////////////////////////
1:         AmqpConnection connection = trackConnection(client.connect());
/////////////////////////////////////////////////////////////////////////
1:         AmqpConnection connection = trackConnection(client.connect());
/////////////////////////////////////////////////////////////////////////
1:         AmqpConnection connection = trackConnection(client.connect());
/////////////////////////////////////////////////////////////////////////
1:         AmqpConnection connection = trackConnection(client.connect());
/////////////////////////////////////////////////////////////////////////
1:         AmqpConnection connection = trackConnection(client.connect());
/////////////////////////////////////////////////////////////////////////
1:         AmqpConnection connection = trackConnection(client.connect());
/////////////////////////////////////////////////////////////////////////
1:         AmqpConnection connection = trackConnection(client.connect());
/////////////////////////////////////////////////////////////////////////
1:         AmqpConnection connection = trackConnection(client.connect());
/////////////////////////////////////////////////////////////////////////
1:         AmqpConnection connection = trackConnection(client.connect());
/////////////////////////////////////////////////////////////////////////
1:         AmqpConnection connection = trackConnection(client.connect());
/////////////////////////////////////////////////////////////////////////
1:         AmqpConnection connection = trackConnection(client.connect());
/////////////////////////////////////////////////////////////////////////
1:         AmqpConnection connection = trackConnection(client.connect());
commit:db71b43
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.junit.ActiveMQTestRunner;
1: import org.apache.activemq.junit.Repeat;
/////////////////////////////////////////////////////////////////////////
1: import org.junit.runner.RunWith;
1: @RunWith(ActiveMQTestRunner.class)
/////////////////////////////////////////////////////////////////////////
1:     @Repeat(repetitions = 1)
1:     public void testPresettledReceiverReadsAllMessages() throws Exception {
1:         final int MSG_COUNT = 100;
1:         sendMessages(getTestName(), MSG_COUNT, false);
1: 
1:         AmqpClient client = createAmqpClient();
0:         AmqpConnection connection = client.connect();
1:         AmqpSession session = connection.createSession();
1: 
1:         AmqpReceiver receiver = session.createReceiver("queue://" + getTestName(), null, false, true);
1: 
1:         QueueViewMBean queueView = getProxyToQueue(getTestName());
1:         assertEquals(MSG_COUNT, queueView.getQueueSize());
1:         assertEquals(0, queueView.getDispatchCount());
1: 
1:         receiver.flow(MSG_COUNT);
1:         for (int i = 0; i < MSG_COUNT; ++i) {
1:             assertNotNull(receiver.receive(5, TimeUnit.SECONDS));
1:         }
1:         receiver.close();
1: 
1:         assertEquals(0, queueView.getQueueSize());
1: 
1:         connection.close();
1:     }
1: 
1:     @Test(timeout = 60000)
1:     @Repeat(repetitions = 1)
commit:8448cf1
/////////////////////////////////////////////////////////////////////////
commit:25c99a6
/////////////////////////////////////////////////////////////////////////
commit:05ff52d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     //@Ignore("Test fails currently due to improper implementation of drain.")
commit:ca456c4
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.amqp.client.AmqpUnknownFilterType;
1: import org.apache.qpid.proton.amqp.DescribedType;
1: import org.apache.qpid.proton.amqp.messaging.TerminusDurability;
1: import org.apache.qpid.proton.amqp.messaging.TerminusExpiryPolicy;
/////////////////////////////////////////////////////////////////////////
1:         client.setValidator(new AmqpValidator() {
1:                 if (receiver.getRemoteSource() == null) {
1:                 Source source = (Source) receiver.getRemoteSource();
/////////////////////////////////////////////////////////////////////////
1:         client.setValidator(new AmqpValidator() {
1:                 if (receiver.getRemoteSource() == null) {
1:                 Source source = (Source) receiver.getRemoteSource();
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test(timeout = 60000)
1:     public void testUnsupportedFiltersAreNotListedAsSupported() throws Exception {
1:         AmqpClient client = createAmqpClient();
1: 
1:         client.setValidator(new AmqpValidator() {
1: 
1:             @SuppressWarnings("unchecked")
1:             @Override
1:             public void inspectOpenedResource(Receiver receiver) {
1:                 LOG.info("Receiver opened: {}", receiver);
1: 
1:                 if (receiver.getRemoteSource() == null) {
1:                     markAsInvalid("Link opened with null source.");
1:                 }
1: 
1:                 Source source = (Source) receiver.getRemoteSource();
1:                 Map<Symbol, Object> filters = source.getFilter();
1: 
1:                 if (findFilter(filters, AmqpUnknownFilterType.UNKNOWN_FILTER_IDS) != null) {
1:                     markAsInvalid("Broker should not return unsupported filter on attach.");
1:                 }
1:             }
1:         });
1: 
0:         Map<Symbol, DescribedType> filters = new HashMap<Symbol, DescribedType>();
1:         filters.put(AmqpUnknownFilterType.UNKNOWN_FILTER_NAME, AmqpUnknownFilterType.UNKOWN_FILTER);
1: 
1:         Source source = new Source();
1:         source.setAddress("queue://" + getTestName());
1:         source.setFilter(filters);
1:         source.setDurable(TerminusDurability.NONE);
1:         source.setExpiryPolicy(TerminusExpiryPolicy.LINK_DETACH);
1: 
0:         AmqpConnection connection = client.connect();
1:         AmqpSession session = connection.createSession();
1: 
1:         assertEquals(0, brokerService.getAdminView().getQueues().length);
1: 
1:         session.createReceiver(source);
1: 
1:         assertEquals(1, brokerService.getAdminView().getQueueSubscribers().length);
1: 
1:         connection.getStateInspector().assertValid();
1:         connection.close();
1:     }
commit:1a0f73e
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.activemq.transport.amqp.AmqpSupport.JMS_SELECTOR_FILTER_IDS;
1: import static org.apache.activemq.transport.amqp.AmqpSupport.NO_LOCAL_FILTER_IDS;
1: import static org.apache.activemq.transport.amqp.AmqpSupport.findFilter;
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.amqp.client.AmqpValidator;
1: import org.apache.qpid.proton.amqp.Symbol;
1: import org.apache.qpid.proton.amqp.messaging.Source;
1: import org.apache.qpid.proton.engine.Receiver;
/////////////////////////////////////////////////////////////////////////
1:     public void testCreateQueueReceiverWithJMSSelector() throws Exception {
1:         AmqpClient client = createAmqpClient();
1: 
0:         client.setStateInspector(new AmqpValidator() {
1: 
1:             @SuppressWarnings("unchecked")
1:             @Override
1:             public void inspectOpenedResource(Receiver receiver) {
1:                 LOG.info("Receiver opened: {}", receiver);
1: 
0:                 if (receiver.getSource() == null) {
1:                     markAsInvalid("Link opened with null source.");
1:                 }
1: 
0:                 Source source = (Source) receiver.getSource();
1:                 Map<Symbol, Object> filters = source.getFilter();
1: 
1:                 if (findFilter(filters, JMS_SELECTOR_FILTER_IDS) == null) {
1:                     markAsInvalid("Broker did not return the JMS Filter on Attach");
1:                 }
1:             }
1:         });
1: 
0:         AmqpConnection connection = client.connect();
1:         AmqpSession session = connection.createSession();
1: 
1:         assertEquals(0, brokerService.getAdminView().getQueues().length);
1: 
1:         session.createReceiver("queue://" + getTestName(), "JMSPriority > 8");
1: 
1:         assertEquals(1, brokerService.getAdminView().getQueueSubscribers().length);
1: 
1:         connection.getStateInspector().assertValid();
1:         connection.close();
1:     }
1: 
1:     @Test(timeout = 60000)
1:     public void testCreateQueueReceiverWithNoLocalSet() throws Exception {
1:         AmqpClient client = createAmqpClient();
1: 
0:         client.setStateInspector(new AmqpValidator() {
1: 
1:             @SuppressWarnings("unchecked")
1:             @Override
1:             public void inspectOpenedResource(Receiver receiver) {
1:                 LOG.info("Receiver opened: {}", receiver);
1: 
0:                 if (receiver.getSource() == null) {
1:                     markAsInvalid("Link opened with null source.");
1:                 }
1: 
0:                 Source source = (Source) receiver.getSource();
1:                 Map<Symbol, Object> filters = source.getFilter();
1: 
1:                 if (findFilter(filters, NO_LOCAL_FILTER_IDS) == null) {
1:                     markAsInvalid("Broker did not return the NoLocal Filter on Attach");
1:                 }
1:             }
1:         });
1: 
0:         AmqpConnection connection = client.connect();
1:         AmqpSession session = connection.createSession();
1: 
1:         assertEquals(0, brokerService.getAdminView().getQueues().length);
1: 
1:         session.createReceiver("queue://" + getTestName(), null, true);
1: 
1:         assertEquals(1, brokerService.getAdminView().getQueueSubscribers().length);
1: 
1:         connection.getStateInspector().assertValid();
1:         connection.close();
1:     }
1: 
1:     @Test(timeout = 60000)
commit:6a6ef45
/////////////////////////////////////////////////////////////////////////
commit:72839b7
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport.amqp.interop;
1: 
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertNotNull;
1: import static org.junit.Assert.assertTrue;
1: 
1: import java.util.concurrent.TimeUnit;
1: 
1: import org.apache.activemq.broker.jmx.QueueViewMBean;
1: import org.apache.activemq.transport.amqp.client.AmqpClient;
1: import org.apache.activemq.transport.amqp.client.AmqpClientTestSupport;
1: import org.apache.activemq.transport.amqp.client.AmqpConnection;
1: import org.apache.activemq.transport.amqp.client.AmqpMessage;
1: import org.apache.activemq.transport.amqp.client.AmqpReceiver;
1: import org.apache.activemq.transport.amqp.client.AmqpSession;
1: import org.apache.activemq.util.Wait;
0: import org.junit.Ignore;
1: import org.junit.Test;
1: 
1: /**
1:  * Test various behaviors of AMQP receivers with the broker.
1:  */
1: public class AmqpReceiverTest extends AmqpClientTestSupport {
1: 
1:     @Override
1:     protected boolean isUseOpenWireConnector() {
1:         return true;
1:     }
1: 
1:     @Test(timeout = 60000)
1:     public void testCreateQueueReceiver() throws Exception {
1:         AmqpClient client = createAmqpClient();
0:         AmqpConnection connection = client.connect();
1:         AmqpSession session = connection.createSession();
1: 
1:         assertEquals(0, brokerService.getAdminView().getQueues().length);
1: 
1:         AmqpReceiver receiver = session.createReceiver("queue://" + getTestName());
1: 
1:         assertEquals(1, brokerService.getAdminView().getQueues().length);
1:         assertNotNull(getProxyToQueue(getTestName()));
1:         assertEquals(1, brokerService.getAdminView().getQueueSubscribers().length);
1:         receiver.close();
1:         assertEquals(0, brokerService.getAdminView().getQueueSubscribers().length);
1: 
1:         connection.close();
1:     }
1: 
1:     @Test(timeout = 60000)
1:     public void testCreateTopicReceiver() throws Exception {
1:         AmqpClient client = createAmqpClient();
0:         AmqpConnection connection = client.connect();
1:         AmqpSession session = connection.createSession();
1: 
1:         assertEquals(0, brokerService.getAdminView().getTopics().length);
1: 
1:         AmqpReceiver receiver = session.createReceiver("topic://" + getTestName());
1: 
1:         assertEquals(1, brokerService.getAdminView().getTopics().length);
1:         assertNotNull(getProxyToTopic(getTestName()));
1:         assertEquals(1, brokerService.getAdminView().getTopicSubscribers().length);
1:         receiver.close();
1:         assertEquals(0, brokerService.getAdminView().getTopicSubscribers().length);
1: 
1:         connection.close();
1:     }
1: 
1:     @Test(timeout = 60000)
1:     public void testQueueReceiverReadMessage() throws Exception {
1:         sendMessages(getTestName(), 1, false);
1: 
1:         AmqpClient client = createAmqpClient();
0:         AmqpConnection connection = client.connect();
1:         AmqpSession session = connection.createSession();
1: 
1:         AmqpReceiver receiver = session.createReceiver("queue://" + getTestName());
1: 
1:         QueueViewMBean queueView = getProxyToQueue(getTestName());
1:         assertEquals(1, queueView.getQueueSize());
1:         assertEquals(0, queueView.getDispatchCount());
1: 
1:         receiver.flow(1);
1:         assertNotNull(receiver.receive(5, TimeUnit.SECONDS));
1:         receiver.close();
1: 
1:         assertEquals(1, queueView.getQueueSize());
1: 
1:         connection.close();
1:     }
1: 
1:     @Test(timeout = 60000)
1:     public void testTwoQueueReceiversOnSameConnectionReadMessagesNoDispositions() throws Exception {
1:         int MSG_COUNT = 4;
1:         sendMessages(getTestName(), MSG_COUNT, false);
1: 
1:         AmqpClient client = createAmqpClient();
0:         AmqpConnection connection = client.connect();
1:         AmqpSession session = connection.createSession();
1: 
1:         AmqpReceiver receiver1 = session.createReceiver("queue://" + getTestName());
1: 
1:         QueueViewMBean queueView = getProxyToQueue(getTestName());
1:         assertEquals(MSG_COUNT, queueView.getQueueSize());
1: 
1:         receiver1.flow(2);
1:         assertNotNull(receiver1.receive(5, TimeUnit.SECONDS));
1:         assertNotNull(receiver1.receive(5, TimeUnit.SECONDS));
1: 
1:         AmqpReceiver receiver2 = session.createReceiver("queue://" + getTestName());
1: 
1:         assertEquals(2, brokerService.getAdminView().getQueueSubscribers().length);
1: 
1:         receiver2.flow(2);
1:         assertNotNull(receiver2.receive(5, TimeUnit.SECONDS));
1:         assertNotNull(receiver2.receive(5, TimeUnit.SECONDS));
1: 
1:         assertEquals(MSG_COUNT, queueView.getDispatchCount());
1:         assertEquals(0, queueView.getDequeueCount());
1: 
1:         receiver1.close();
1:         receiver2.close();
1: 
1:         assertEquals(MSG_COUNT, queueView.getQueueSize());
1: 
1:         connection.close();
1:     }
1: 
0:     @Ignore("Fails due to issues with accept and no credit")
1:     @Test(timeout = 60000)
1:     public void testTwoQueueReceiversOnSameConnectionReadMessagesAcceptOnEach() throws Exception {
1:         int MSG_COUNT = 4;
1:         sendMessages(getTestName(), MSG_COUNT, false);
1: 
1:         AmqpClient client = createAmqpClient();
0:         AmqpConnection connection = client.connect();
1:         AmqpSession session = connection.createSession();
1: 
1:         AmqpReceiver receiver1 = session.createReceiver("queue://" + getTestName());
1: 
1:         final QueueViewMBean queueView = getProxyToQueue(getTestName());
1:         assertEquals(MSG_COUNT, queueView.getQueueSize());
1: 
1:         receiver1.flow(2);
1:         AmqpMessage message = receiver1.receive(5, TimeUnit.SECONDS);
1:         assertNotNull(message);
1:         message.accept();
1:         message = receiver1.receive(5, TimeUnit.SECONDS);
1:         assertNotNull(message);
1:         message.accept();
1: 
1:         assertTrue("Should have ack'd two", Wait.waitFor(new Wait.Condition() {
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return queueView.getDequeueCount() == 2;
1:             }
1:         }, TimeUnit.SECONDS.toMillis(5), TimeUnit.MILLISECONDS.toMillis(50)));
1: 
1:         AmqpReceiver receiver2 = session.createReceiver("queue://" + getTestName());
1: 
1:         assertEquals(2, brokerService.getAdminView().getQueueSubscribers().length);
1: 
1:         receiver2.flow(2);
1:         message = receiver2.receive(5, TimeUnit.SECONDS);
1:         assertNotNull(message);
1:         message.accept();
1:         message = receiver2.receive(5, TimeUnit.SECONDS);
1:         assertNotNull(message);
1:         message.accept();
1: 
1:         assertEquals(MSG_COUNT, queueView.getDispatchCount());
1:         assertTrue("Queue should be empty now", Wait.waitFor(new Wait.Condition() {
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return queueView.getDequeueCount() == 4;
1:             }
1:         }, TimeUnit.SECONDS.toMillis(15), TimeUnit.MILLISECONDS.toMillis(10)));
1: 
1:         receiver1.close();
1:         receiver2.close();
1: 
1:         assertEquals(0, queueView.getQueueSize());
1: 
1:         connection.close();
1:     }
1: 
1:     @Test(timeout = 60000)
1:     public void testSecondReceiverOnQueueGetsAllUnconsumedMessages() throws Exception {
1:         int MSG_COUNT = 20;
1:         sendMessages(getTestName(), MSG_COUNT, false);
1: 
1:         AmqpClient client = createAmqpClient();
0:         AmqpConnection connection = client.connect();
1:         AmqpSession session = connection.createSession();
1: 
1:         AmqpReceiver receiver1 = session.createReceiver("queue://" + getTestName());
1: 
1:         final QueueViewMBean queueView = getProxyToQueue(getTestName());
1:         assertEquals(MSG_COUNT, queueView.getQueueSize());
1: 
1:         receiver1.flow(20);
1: 
1:         assertTrue("Should have dispatch to prefetch", Wait.waitFor(new Wait.Condition() {
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return queueView.getInFlightCount() >= 2;
1:             }
1:         }, TimeUnit.SECONDS.toMillis(5), TimeUnit.MILLISECONDS.toMillis(50)));
1: 
1:         receiver1.close();
1: 
1:         AmqpReceiver receiver2 = session.createReceiver("queue://" + getTestName());
1: 
1:         assertEquals(1, brokerService.getAdminView().getQueueSubscribers().length);
1: 
1:         receiver2.flow(MSG_COUNT * 2);
1:         AmqpMessage message = receiver2.receive(5, TimeUnit.SECONDS);
1:         assertNotNull(message);
1:         message.accept();
1:         message = receiver2.receive(5, TimeUnit.SECONDS);
1:         assertNotNull(message);
1:         message.accept();
1: 
1:         assertTrue("Should have ack'd two", Wait.waitFor(new Wait.Condition() {
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return queueView.getDequeueCount() == 2;
1:             }
1:         }, TimeUnit.SECONDS.toMillis(5), TimeUnit.MILLISECONDS.toMillis(50)));
1: 
1:         receiver2.close();
1: 
1:         assertEquals(MSG_COUNT - 2, queueView.getQueueSize());
1: 
1:         connection.close();
1:     }
1: 
0:     @Ignore("Test fails currently due to improper implementation of drain.")
1:     @Test(timeout = 60000)
0:     public void testReceiverCanDrainMessages() throws Exception {
1:         int MSG_COUNT = 20;
1:         sendMessages(getTestName(), MSG_COUNT, false);
1: 
1:         AmqpClient client = createAmqpClient();
0:         AmqpConnection connection = client.connect();
1:         AmqpSession session = connection.createSession();
1: 
1:         AmqpReceiver receiver = session.createReceiver("queue://" + getTestName());
1: 
1:         QueueViewMBean queueView = getProxyToQueue(getTestName());
1:         assertEquals(MSG_COUNT, queueView.getQueueSize());
1:         assertEquals(0, queueView.getDispatchCount());
1: 
0:         receiver.drain(MSG_COUNT);
0:         for (int i = 0; i < MSG_COUNT; ++i) {
1:             AmqpMessage message = receiver.receive(5, TimeUnit.SECONDS);
1:             assertNotNull(message);
1:             message.accept();
1:         }
1:         receiver.close();
1: 
1:         assertEquals(0, queueView.getQueueSize());
1: 
1:         connection.close();
1:     }
1: }
author:gtully
-------------------------------------------------------------------------------
commit:6c01b64
/////////////////////////////////////////////////////////////////////////
0:     public void testPresettledReceiverReadsAllMessagesInNonFlowBatch() throws Exception {
1:         final int MSG_COUNT = 100;
0:         sendMessages(getTestName(), MSG_COUNT, false);
1: 
1:         AmqpClient client = createAmqpClient();
0:         AmqpConnection connection = client.connect();
1:         AmqpSession session = connection.createSession();
1: 
0:         AmqpReceiver receiver = session.createReceiver("queue://" + getTestName(), null, false, true);
1: 
0:         QueueViewMBean queueView = getProxyToQueue(getTestName());
0:         assertEquals(MSG_COUNT, queueView.getQueueSize());
0:         assertEquals(0, queueView.getDispatchCount());
1: 
1:         receiver.flow(20);
1:         // consume less that flow
1:         for (int j=0;j<10;j++) {
1:             assertNotNull(receiver.receive(5, TimeUnit.SECONDS));
1:         }
1: 
1:         // flow more and consume all
1:         receiver.flow(10);
1:         for (int j=0;j<20;j++) {
1:             assertNotNull(receiver.receive(5, TimeUnit.SECONDS));
1:         }
1: 
1:         // remainder
1:         receiver.flow(70);
1:         for (int j=0;j<70;j++) {
1:             assertNotNull(receiver.receive(5, TimeUnit.SECONDS));
1:         }
1: 
1:         receiver.close();
1: 
0:         assertEquals(0, queueView.getQueueSize());
1: 
1:         connection.close();
1:     }
1: 
0:     @Test(timeout = 60000)
1:     @Repeat(repetitions = 1)
author:Robert Gemmell
-------------------------------------------------------------------------------
commit:0cfd225
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertNull;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.qpid.proton.message.Message;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test(timeout = 30000)
1:     public void testModifiedDispositionWithDeliveryFailedWithoutUndeliverableHereFieldsSet() throws Exception {
1:         doModifiedDispositionTestImpl(Boolean.TRUE, null);
1:     }
1: 
1:     @Test(timeout = 30000)
1:     public void testModifiedDispositionWithoutDeliveryFailedWithoutUndeliverableHereFieldsSet() throws Exception {
1:         doModifiedDispositionTestImpl(null, null);
1:     }
1: 
1:     @Test(timeout = 30000)
1:     public void testModifiedDispositionWithoutDeliveryFailedWithUndeliverableHereFieldsSet() throws Exception {
1:         doModifiedDispositionTestImpl(null, Boolean.TRUE);
1:     }
1: 
1:     @Test(timeout = 30000)
1:     public void testModifiedDispositionWithDeliveryFailedWithUndeliverableHereFieldsSet() throws Exception {
1:         doModifiedDispositionTestImpl(Boolean.TRUE, Boolean.TRUE);
1:     }
1: 
1:     private void doModifiedDispositionTestImpl(Boolean deliveryFailed, Boolean undeliverableHere) throws Exception {
1:         int msgCount = 1;
1:         sendMessages(getTestName(), msgCount, false);
1: 
0:         AmqpClient client = createAmqpClient();
0:         AmqpConnection connection = client.connect();
0:         AmqpSession session = connection.createSession();
1: 
0:         AmqpReceiver receiver = session.createReceiver("queue://" + getTestName());
1:         receiver.flow(2 * msgCount);
1: 
0:         AmqpMessage message = receiver.receive(5, TimeUnit.SECONDS);
1:         assertNotNull("did not receive message first time", message);
1: 
1:         Message protonMessage = message.getWrappedMessage();
0:         assertNotNull(protonMessage);
1:         assertEquals("Unexpected initial value for AMQP delivery-count", 0, protonMessage.getDeliveryCount());
1: 
1:         message.modified(deliveryFailed, undeliverableHere);
1: 
1:         if(Boolean.TRUE.equals(undeliverableHere)) {
1:             message = receiver.receive(250, TimeUnit.MILLISECONDS);
1:             assertNull("Should not receive message again", message);
1:         } else {
1:             message = receiver.receive(5, TimeUnit.SECONDS);
0:             assertNotNull("did not receive message again", message);
1: 
1:             int expectedDeliveryCount = 0;
1:             if(Boolean.TRUE.equals(deliveryFailed)) {
1:                 expectedDeliveryCount = 1;
1:             }
1: 
0:             message.accept();
1: 
1:             Message protonMessage2 = message.getWrappedMessage();
1:             assertNotNull(protonMessage2);
1:             assertEquals("Unexpected updated value for AMQP delivery-count", expectedDeliveryCount, protonMessage2.getDeliveryCount());
1:         }
1: 
0:         receiver.close();
0:         connection.close();
1:     }
============================================================================