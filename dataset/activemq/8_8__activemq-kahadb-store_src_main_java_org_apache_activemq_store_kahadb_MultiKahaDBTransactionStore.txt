1:1595378: /**
1:1595378:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:1595378:  * contributor license agreements.  See the NOTICE file distributed with
1:1595378:  * this work for additional information regarding copyright ownership.
1:1595378:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:1595378:  * (the "License"); you may not use this file except in compliance with
1:1595378:  * the License.  You may obtain a copy of the License at
1:1595378:  *
1:1595378:  *      http://www.apache.org/licenses/LICENSE-2.0
1:1595378:  *
1:1595378:  * Unless required by applicable law or agreed to in writing, software
1:1595378:  * distributed under the License is distributed on an "AS IS" BASIS,
1:1595378:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:1595378:  * See the License for the specific language governing permissions and
1:1595378:  * limitations under the License.
1:1595378:  */
1:1595378: package org.apache.activemq.store.kahadb;
1:1595378: 
1:1595378: import java.io.File;
1:1595378: import java.io.IOException;
1:1595378: import java.util.Date;
1:ceb97f6: import java.util.HashMap;
1:1595378: import java.util.HashSet;
1:ceb97f6: import java.util.Map;
1:1595378: import java.util.Set;
1:1595378: import java.util.TreeSet;
1:1595378: import java.util.concurrent.ConcurrentHashMap;
1:9ef4259: import java.util.concurrent.ConcurrentMap;
1:092c56d: import java.util.concurrent.atomic.AtomicBoolean;
1:d40f398: 
1:1595378: import org.apache.activemq.broker.Broker;
1:1595378: import org.apache.activemq.broker.ConnectionContext;
1:0ae90c0: import org.apache.activemq.broker.region.BaseDestination;
1:1595378: import org.apache.activemq.command.Message;
1:1595378: import org.apache.activemq.command.MessageAck;
1:1595378: import org.apache.activemq.command.MessageId;
1:1595378: import org.apache.activemq.command.TransactionId;
1:1595378: import org.apache.activemq.command.XATransactionId;
1:74846bb: import org.apache.activemq.store.AbstractMessageStore;
1:0ae90c0: import org.apache.activemq.store.IndexListener;
1:74846bb: import org.apache.activemq.store.ListenableFuture;
1:74846bb: import org.apache.activemq.store.MessageStore;
1:74846bb: import org.apache.activemq.store.PersistenceAdapter;
1:74846bb: import org.apache.activemq.store.ProxyMessageStore;
1:74846bb: import org.apache.activemq.store.ProxyTopicMessageStore;
1:74846bb: import org.apache.activemq.store.TopicMessageStore;
1:74846bb: import org.apache.activemq.store.TransactionRecoveryListener;
1:74846bb: import org.apache.activemq.store.TransactionStore;
1:1595378: import org.apache.activemq.store.kahadb.data.KahaCommitCommand;
1:1595378: import org.apache.activemq.store.kahadb.data.KahaEntryType;
1:1595378: import org.apache.activemq.store.kahadb.data.KahaPrepareCommand;
1:1595378: import org.apache.activemq.store.kahadb.data.KahaTraceCommand;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.journal.Journal;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.journal.Location;
1:0ae90c0: import org.apache.activemq.usage.StoreUsage;
1:1aab71b: import org.apache.activemq.util.DataByteArrayInputStream;
1:1aab71b: import org.apache.activemq.util.DataByteArrayOutputStream;
1:74846bb: import org.apache.activemq.util.IOHelper;
1:1595378: import org.slf4j.Logger;
1:1595378: import org.slf4j.LoggerFactory;
1:1595378: 
1:1595378: public class MultiKahaDBTransactionStore implements TransactionStore {
1:1595378:     static final Logger LOG = LoggerFactory.getLogger(MultiKahaDBTransactionStore.class);
1:1595378:     final MultiKahaDBPersistenceAdapter multiKahaDBPersistenceAdapter;
1:9ef4259:     final ConcurrentMap<TransactionId, Tx> inflightTransactions = new ConcurrentHashMap<TransactionId, Tx>();
1:1595378:     final Set<TransactionId> recoveredPendingCommit = new HashSet<TransactionId>();
1:1595378:     private Journal journal;
1:1595378:     private int journalMaxFileLength = Journal.DEFAULT_MAX_FILE_LENGTH;
1:1595378:     private int journalWriteBatchSize = Journal.DEFAULT_MAX_WRITE_BATCH_SIZE;
1:092c56d:     private final AtomicBoolean started = new AtomicBoolean(false);
1:1595378: 
1:1595378:     public MultiKahaDBTransactionStore(MultiKahaDBPersistenceAdapter multiKahaDBPersistenceAdapter) {
1:1595378:         this.multiKahaDBPersistenceAdapter = multiKahaDBPersistenceAdapter;
2:1595378:     }
1:1595378: 
1:1595378:     public MessageStore proxy(final TransactionStore transactionStore, MessageStore messageStore) {
1:1595378:         return new ProxyMessageStore(messageStore) {
1:74846bb:             @Override
1:1595378:             public void addMessage(ConnectionContext context, final Message send) throws IOException {
1:1595378:                 MultiKahaDBTransactionStore.this.addMessage(transactionStore, context, getDelegate(), send);
1:1595378:             }
1:1595378: 
1:74846bb:             @Override
1:d40f398:             public void addMessage(ConnectionContext context, final Message send, boolean canOptimizeHint) throws IOException {
1:d40f398:                 MultiKahaDBTransactionStore.this.addMessage(transactionStore, context, getDelegate(), send);
1:d40f398:             }
1:d40f398: 
1:74846bb:             @Override
1:ad1f751:             public ListenableFuture<Object> asyncAddQueueMessage(ConnectionContext context, Message message) throws IOException {
1:1595378:                 return MultiKahaDBTransactionStore.this.asyncAddQueueMessage(transactionStore, context, getDelegate(), message);
1:d40f398:             }
1:d40f398: 
1:d40f398:             @Override
1:ad1f751:             public ListenableFuture<Object> asyncAddQueueMessage(ConnectionContext context, Message message, boolean canOptimizeHint) throws IOException {
1:d40f398:                 return MultiKahaDBTransactionStore.this.asyncAddQueueMessage(transactionStore, context, getDelegate(), message);
1:1595378:             }
1:1595378: 
1:d40f398:             @Override
1:1595378:             public void removeMessage(ConnectionContext context, final MessageAck ack) throws IOException {
1:1595378:                 MultiKahaDBTransactionStore.this.removeMessage(transactionStore, context, getDelegate(), ack);
1:1595378:             }
1:1595378: 
2:1595378:             @Override
1:1595378:             public void removeAsyncMessage(ConnectionContext context, MessageAck ack) throws IOException {
1:1595378:                 MultiKahaDBTransactionStore.this.removeAsyncMessage(transactionStore, context, getDelegate(), ack);
1:1595378:             }
1:0ae90c0: 
1:0ae90c0:             @Override
1:0ae90c0:             public void registerIndexListener(IndexListener indexListener) {
1:0ae90c0:                 getDelegate().registerIndexListener(indexListener);
1:0ae90c0:                 try {
1:0ae90c0:                     if (indexListener instanceof BaseDestination) {
1:0ae90c0:                         // update queue storeUsage
1:0ae90c0:                         Object matchingPersistenceAdapter = multiKahaDBPersistenceAdapter.destinationMap.chooseValue(getDelegate().getDestination());
1:0ae90c0:                         if (matchingPersistenceAdapter instanceof FilteredKahaDBPersistenceAdapter) {
1:0ae90c0:                             FilteredKahaDBPersistenceAdapter filteredAdapter = (FilteredKahaDBPersistenceAdapter) matchingPersistenceAdapter;
1:0ae90c0:                             if (filteredAdapter.getUsage() != null && filteredAdapter.getPersistenceAdapter() instanceof KahaDBPersistenceAdapter) {
1:0ae90c0:                                 StoreUsage storeUsage = filteredAdapter.getUsage();
1:0ae90c0:                                 storeUsage.setStore(filteredAdapter.getPersistenceAdapter());
1:0ae90c0:                                 storeUsage.setParent(multiKahaDBPersistenceAdapter.getBrokerService().getSystemUsage().getStoreUsage());
1:0ae90c0:                                 ((BaseDestination) indexListener).getSystemUsage().setStoreUsage(storeUsage);
1:0ae90c0:                             }
1:0ae90c0:                         }
1:0ae90c0:                     }
1:0ae90c0:                 } catch (Exception ignored) {
1:0ae90c0:                     LOG.warn("Failed to set mKahaDB destination store usage", ignored);
1:0ae90c0:                 }
1:0ae90c0:             }
2:1595378:         };
1:1595378:     }
1:1595378: 
1:1595378:     public TopicMessageStore proxy(final TransactionStore transactionStore, final TopicMessageStore messageStore) {
1:1595378:         return new ProxyTopicMessageStore(messageStore) {
1:d40f398:             @Override
1:d40f398:             public void addMessage(ConnectionContext context, final Message send, boolean canOptimizeHint) throws IOException {
1:d40f398:                 MultiKahaDBTransactionStore.this.addMessage(transactionStore, context, getDelegate(), send);
1:d40f398:             }
1:d40f398: 
1:1595378:             @Override
1:1595378:             public void addMessage(ConnectionContext context, final Message send) throws IOException {
1:1595378:                 MultiKahaDBTransactionStore.this.addMessage(transactionStore, context, getDelegate(), send);
1:1595378:             }
1:1595378: 
1:1595378:             @Override
1:ad1f751:             public ListenableFuture<Object> asyncAddTopicMessage(ConnectionContext context, Message message, boolean canOptimizeHint) throws IOException {
1:d40f398:                 return MultiKahaDBTransactionStore.this.asyncAddTopicMessage(transactionStore, context, getDelegate(), message);
1:d40f398:             }
1:d40f398: 
1:d40f398:             @Override
1:ad1f751:             public ListenableFuture<Object> asyncAddTopicMessage(ConnectionContext context, Message message) throws IOException {
1:1595378:                 return MultiKahaDBTransactionStore.this.asyncAddTopicMessage(transactionStore, context, getDelegate(), message);
1:1595378:             }
1:1595378: 
1:1595378:             @Override
1:1595378:             public void removeMessage(ConnectionContext context, final MessageAck ack) throws IOException {
1:1595378:                 MultiKahaDBTransactionStore.this.removeMessage(transactionStore, context, getDelegate(), ack);
1:1595378:             }
1:1595378: 
1:1595378:             @Override
1:1595378:             public void removeAsyncMessage(ConnectionContext context, MessageAck ack) throws IOException {
1:1595378:                 MultiKahaDBTransactionStore.this.removeAsyncMessage(transactionStore, context, getDelegate(), ack);
1:1595378:             }
1:1595378: 
1:1595378:             @Override
1:1595378:             public void acknowledge(ConnectionContext context, String clientId, String subscriptionName,
1:1595378:                                     MessageId messageId, MessageAck ack) throws IOException {
1:1595378:                 MultiKahaDBTransactionStore.this.acknowledge(transactionStore, context, (TopicMessageStore) getDelegate(), clientId,
1:1595378:                         subscriptionName, messageId, ack);
1:1595378:             }
1:1595378:         };
1:1595378:     }
1:1595378: 
1:1595378:     public void deleteAllMessages() {
1:1595378:         IOHelper.deleteChildren(getDirectory());
1:1595378:     }
1:1595378: 
1:1595378:     public int getJournalMaxFileLength() {
1:1595378:         return journalMaxFileLength;
1:1595378:     }
1:1595378: 
1:1595378:     public void setJournalMaxFileLength(int journalMaxFileLength) {
1:1595378:         this.journalMaxFileLength = journalMaxFileLength;
1:1595378:     }
1:1595378: 
1:1595378:     public int getJournalMaxWriteBatchSize() {
1:1595378:         return journalWriteBatchSize;
1:1595378:     }
1:1595378: 
1:1595378:     public void setJournalMaxWriteBatchSize(int journalWriteBatchSize) {
1:1595378:         this.journalWriteBatchSize = journalWriteBatchSize;
1:1595378:     }
1:1595378: 
1:1595378:     public class Tx {
1:ceb97f6:         private final HashMap<TransactionStore, TransactionId> stores = new HashMap<TransactionStore, TransactionId>();
1:1595378:         private int prepareLocationId = 0;
1:1595378: 
1:ceb97f6:         public void trackStore(TransactionStore store, XATransactionId xid) {
1:ceb97f6:             stores.put(store, xid);
1:ceb97f6:         }
1:ceb97f6: 
1:1595378:         public void trackStore(TransactionStore store) {
1:ceb97f6:             stores.put(store, null);
1:ceb97f6:         }
1:ceb97f6: 
1:ceb97f6:         public HashMap<TransactionStore, TransactionId> getStoresMap() {
1:ceb97f6:             return stores;
1:1595378:         }
1:1595378: 
1:1595378:         public Set<TransactionStore> getStores() {
1:ceb97f6:             return stores.keySet();
1:1595378:         }
1:1595378: 
1:1595378:         public void trackPrepareLocation(Location location) {
1:1595378:             this.prepareLocationId = location.getDataFileId();
1:1595378:         }
1:1595378: 
1:1595378:         public int getPreparedLocationId() {
1:1595378:             return prepareLocationId;
1:1595378:         }
1:1595378:     }
1:1595378: 
1:1595378:     public Tx getTx(TransactionId txid) {
1:1595378:         Tx tx = inflightTransactions.get(txid);
1:1595378:         if (tx == null) {
1:1595378:             tx = new Tx();
1:1595378:             inflightTransactions.put(txid, tx);
1:1595378:         }
1:1595378:         return tx;
1:1595378:     }
1:1595378: 
1:1595378:     public Tx removeTx(TransactionId txid) {
1:1595378:         return inflightTransactions.remove(txid);
1:1595378:     }
1:1595378: 
1:74846bb:     @Override
1:1595378:     public void prepare(TransactionId txid) throws IOException {
1:1595378:         Tx tx = getTx(txid);
3:1595378:         for (TransactionStore store : tx.getStores()) {
1:1595378:             store.prepare(txid);
1:1595378:         }
1:1595378:     }
1:1595378: 
1:1595378:     @Override
1:1595378:     public void commit(TransactionId txid, boolean wasPrepared, Runnable preCommit, Runnable postCommit)
1:1595378:             throws IOException {
1:1595378: 
1:1595378:         if (preCommit != null) {
1:1595378:             preCommit.run();
1:1595378:         }
1:1595378: 
1:1595378:         Tx tx = getTx(txid);
1:1595378:         if (wasPrepared) {
1:ceb97f6:             for (Map.Entry<TransactionStore, TransactionId> storeTx : tx.getStoresMap().entrySet()) {
1:ceb97f6:                 TransactionId recovered = storeTx.getValue();
1:ceb97f6:                 if (recovered != null) {
1:ceb97f6:                     storeTx.getKey().commit(recovered, true, null, null);
1:ceb97f6:                 } else {
1:ceb97f6:                     storeTx.getKey().commit(txid, true, null, null);
1:ceb97f6:                 }
1:1595378:             }
1:1595378:         } else {
1:1595378:             // can only do 1pc on a single store
1:1595378:             if (tx.getStores().size() == 1) {
1:1595378:                 for (TransactionStore store : tx.getStores()) {
1:1595378:                     store.commit(txid, false, null, null);
1:1595378:                 }
1:1595378:             } else {
1:1595378:                 // need to do local 2pc
1:1595378:                 for (TransactionStore store : tx.getStores()) {
1:1595378:                     store.prepare(txid);
1:1595378:                 }
1:1595378:                 persistOutcome(tx, txid);
1:1595378:                 for (TransactionStore store : tx.getStores()) {
2:1595378:                     store.commit(txid, true, null, null);
1:1595378:                 }
1:1595378:                 persistCompletion(txid);
1:1595378:             }
1:1595378:         }
1:1595378:         removeTx(txid);
1:1595378:         if (postCommit != null) {
1:1595378:             postCommit.run();
1:1595378:         }
1:1595378:     }
1:1595378: 
1:1595378:     public void persistOutcome(Tx tx, TransactionId txid) throws IOException {
1:21fe8ca:         tx.trackPrepareLocation(store(new KahaPrepareCommand().setTransactionInfo(TransactionIdConversion.convert(multiKahaDBPersistenceAdapter.transactionIdTransformer.transform(txid)))));
1:1595378:     }
1:1595378: 
1:1595378:     public void persistCompletion(TransactionId txid) throws IOException {
1:21fe8ca:         store(new KahaCommitCommand().setTransactionInfo(TransactionIdConversion.convert(multiKahaDBPersistenceAdapter.transactionIdTransformer.transform(txid))));
1:1595378:     }
1:1595378: 
1:1595378:     private Location store(JournalCommand<?> data) throws IOException {
1:1595378:         int size = data.serializedSizeFramed();
1:1595378:         DataByteArrayOutputStream os = new DataByteArrayOutputStream(size + 1);
1:1595378:         os.writeByte(data.type().getNumber());
1:1595378:         data.writeFramed(os);
1:1595378:         Location location = journal.write(os.toByteSequence(), true);
1:1595378:         journal.setLastAppendLocation(location);
1:1595378:         return location;
1:1595378:     }
1:1595378: 
1:74846bb:     @Override
1:1595378:     public void rollback(TransactionId txid) throws IOException {
1:1595378:         Tx tx = removeTx(txid);
1:1595378:         if (tx != null) {
1:ceb97f6:             for (Map.Entry<TransactionStore, TransactionId> storeTx : tx.getStoresMap().entrySet()) {
1:ceb97f6:                 TransactionId recovered = storeTx.getValue();
1:ceb97f6:                 if (recovered != null) {
1:ceb97f6:                     storeTx.getKey().rollback(recovered);
1:ceb97f6:                 } else {
1:ceb97f6:                     storeTx.getKey().rollback(txid);
1:ceb97f6:                 }
1:1595378:             }
1:1595378:         }
1:1595378:     }
1:1595378: 
1:1595378:     @Override
1:1595378:     public void start() throws Exception {
1:092c56d:         if (started.compareAndSet(false, true)) {
1:092c56d:             journal = new Journal() {
1:092c56d:                 @Override
1:d427952:                 public void cleanup() {
1:092c56d:                     super.cleanup();
1:092c56d:                     txStoreCleanup();
1:092c56d:                 }
1:092c56d:             };
1:092c56d:             journal.setDirectory(getDirectory());
1:092c56d:             journal.setMaxFileLength(journalMaxFileLength);
1:092c56d:             journal.setWriteBatchSize(journalWriteBatchSize);
1:092c56d:             IOHelper.mkdirs(journal.getDirectory());
1:092c56d:             journal.start();
1:092c56d:             recoverPendingLocalTransactions();
1:092c56d:             store(new KahaTraceCommand().setMessage("LOADED " + new Date()));
1:092c56d:         }
1:1595378:     }
1:1595378: 
1:1595378:     private void txStoreCleanup() {
1:1595378:         Set<Integer> knownDataFileIds = new TreeSet<Integer>(journal.getFileMap().keySet());
1:1595378:         for (Tx tx : inflightTransactions.values()) {
1:1595378:             knownDataFileIds.remove(tx.getPreparedLocationId());
1:1595378:         }
1:1595378:         try {
1:1595378:             journal.removeDataFiles(knownDataFileIds);
1:1595378:         } catch (Exception e) {
1:1595378:             LOG.error(this + ", Failed to remove tx journal datafiles " + knownDataFileIds);
1:1595378:         }
1:1595378:     }
1:1595378: 
1:1595378:     private File getDirectory() {
1:1595378:         return new File(multiKahaDBPersistenceAdapter.getDirectory(), "txStore");
1:1595378:     }
1:1595378: 
1:74846bb:     @Override
1:1595378:     public void stop() throws Exception {
1:092c56d:         if (started.compareAndSet(true, false) && journal != null) {
1:092c56d:             journal.close();
1:092c56d:             journal = null;
1:092c56d:         }
1:1595378:     }
1:1595378: 
1:1595378:     private void recoverPendingLocalTransactions() throws IOException {
1:1595378:         Location location = journal.getNextLocation(null);
1:1595378:         while (location != null) {
1:1595378:             process(load(location));
1:1595378:             location = journal.getNextLocation(location);
1:1595378:         }
1:1595378:         recoveredPendingCommit.addAll(inflightTransactions.keySet());
1:1595378:         LOG.info("pending local transactions: " + recoveredPendingCommit);
1:1595378:     }
1:1595378: 
1:1595378:     public JournalCommand<?> load(Location location) throws IOException {
1:1595378:         DataByteArrayInputStream is = new DataByteArrayInputStream(journal.read(location));
1:1595378:         byte readByte = is.readByte();
1:1595378:         KahaEntryType type = KahaEntryType.valueOf(readByte);
1:1595378:         if (type == null) {
1:1595378:             throw new IOException("Could not load journal record. Invalid location: " + location);
1:1595378:         }
1:1595378:         JournalCommand<?> message = (JournalCommand<?>) type.createMessage();
1:1595378:         message.mergeFramed(is);
1:1595378:         return message;
1:1595378:     }
1:1595378: 
1:1595378:     public void process(JournalCommand<?> command) throws IOException {
1:1595378:         switch (command.type()) {
1:1595378:             case KAHA_PREPARE_COMMAND:
1:1595378:                 KahaPrepareCommand prepareCommand = (KahaPrepareCommand) command;
1:1595378:                 getTx(TransactionIdConversion.convert(prepareCommand.getTransactionInfo()));
1:1595378:                 break;
1:1595378:             case KAHA_COMMIT_COMMAND:
1:1595378:                 KahaCommitCommand commitCommand = (KahaCommitCommand) command;
1:1595378:                 removeTx(TransactionIdConversion.convert(commitCommand.getTransactionInfo()));
1:1595378:                 break;
1:1595378:             case KAHA_TRACE_COMMAND:
1:1595378:                 break;
1:1595378:             default:
1:1595378:                 throw new IOException("Unexpected command in transaction journal: " + command);
1:1595378:         }
1:1595378:     }
1:1595378: 
1:1595378: 
1:1595378:     @Override
1:1595378:     public synchronized void recover(final TransactionRecoveryListener listener) throws IOException {
1:1595378: 
1:21fe8ca:         for (final PersistenceAdapter adapter : multiKahaDBPersistenceAdapter.adapters) {
1:1595378:             adapter.createTransactionStore().recover(new TransactionRecoveryListener() {
1:1595378:                 @Override
1:1595378:                 public void recover(XATransactionId xid, Message[] addedMessages, MessageAck[] acks) {
1:1595378:                     try {
1:ceb97f6:                         getTx(xid).trackStore(adapter.createTransactionStore(), xid);
1:1595378:                     } catch (IOException e) {
1:1595378:                         LOG.error("Failed to access transaction store: " + adapter + " for prepared xa tid: " + xid, e);
1:1595378:                     }
1:1595378:                     listener.recover(xid, addedMessages, acks);
1:1595378:                 }
1:1595378:             });
1:1595378:         }
1:1595378: 
1:1595378:         try {
1:1595378:             Broker broker = multiKahaDBPersistenceAdapter.getBrokerService().getBroker();
1:1595378:             // force completion of local xa
1:1595378:             for (TransactionId txid : broker.getPreparedTransactions(null)) {
1:1595378:                 if (multiKahaDBPersistenceAdapter.isLocalXid(txid)) {
1:1595378:                     try {
1:1595378:                         if (recoveredPendingCommit.contains(txid)) {
1:1595378:                             LOG.info("delivering pending commit outcome for tid: " + txid);
1:1595378:                             broker.commitTransaction(null, txid, false);
1:1595378: 
1:1595378:                         } else {
1:1595378:                             LOG.info("delivering rollback outcome to store for tid: " + txid);
1:1595378:                             broker.forgetTransaction(null, txid);
1:1595378:                         }
1:1595378:                         persistCompletion(txid);
1:1595378:                     } catch (Exception ex) {
1:1595378:                         LOG.error("failed to deliver pending outcome for tid: " + txid, ex);
1:1595378:                     }
1:1595378:                 }
1:1595378:             }
1:1595378:         } catch (Exception e) {
1:1595378:             LOG.error("failed to resolve pending local transactions", e);
1:1595378:         }
1:1595378:     }
1:1595378: 
1:1595378:     void addMessage(final TransactionStore transactionStore, ConnectionContext context, final MessageStore destination, final Message message)
1:1595378:             throws IOException {
1:1595378:         if (message.getTransactionId() != null) {
1:1595378:             getTx(message.getTransactionId()).trackStore(transactionStore);
1:1595378:         }
1:1595378:         destination.addMessage(context, message);
1:1595378:     }
1:1595378: 
1:ad1f751:     ListenableFuture<Object> asyncAddQueueMessage(final TransactionStore transactionStore, ConnectionContext context, final MessageStore destination, final Message message)
1:1595378:             throws IOException {
1:1595378:         if (message.getTransactionId() != null) {
1:1595378:             getTx(message.getTransactionId()).trackStore(transactionStore);
1:1595378:             destination.addMessage(context, message);
1:1595378:             return AbstractMessageStore.FUTURE;
1:1595378:         } else {
1:1595378:             return destination.asyncAddQueueMessage(context, message);
1:1595378:         }
1:1595378:     }
1:1595378: 
1:ad1f751:     ListenableFuture<Object> asyncAddTopicMessage(final TransactionStore transactionStore, ConnectionContext context, final MessageStore destination, final Message message)
1:1595378:             throws IOException {
1:1595378: 
1:1595378:         if (message.getTransactionId() != null) {
1:1595378:             getTx(message.getTransactionId()).trackStore(transactionStore);
1:1595378:             destination.addMessage(context, message);
1:1595378:             return AbstractMessageStore.FUTURE;
1:1595378:         } else {
1:1595378:             return destination.asyncAddTopicMessage(context, message);
1:1595378:         }
1:1595378:     }
1:1595378: 
1:1595378:     final void removeMessage(final TransactionStore transactionStore, ConnectionContext context, final MessageStore destination, final MessageAck ack)
1:1595378:             throws IOException {
1:1595378:         if (ack.getTransactionId() != null) {
1:1595378:             getTx(ack.getTransactionId()).trackStore(transactionStore);
1:1595378:         }
1:1595378:         destination.removeMessage(context, ack);
1:1595378:     }
1:1595378: 
1:1595378:     final void removeAsyncMessage(final TransactionStore transactionStore, ConnectionContext context, final MessageStore destination, final MessageAck ack)
1:1595378:             throws IOException {
1:1595378:         if (ack.getTransactionId() != null) {
1:1595378:             getTx(ack.getTransactionId()).trackStore(transactionStore);
1:1595378:         }
1:1595378:         destination.removeAsyncMessage(context, ack);
1:1595378:     }
1:1595378: 
1:1595378:     final void acknowledge(final TransactionStore transactionStore, ConnectionContext context, final TopicMessageStore destination,
1:1595378:                            final String clientId, final String subscriptionName,
1:1595378:                            final MessageId messageId, final MessageAck ack) throws IOException {
1:1595378:         if (ack.getTransactionId() != null) {
1:1595378:             getTx(ack.getTransactionId()).trackStore(transactionStore);
1:1595378:         }
1:1595378:         destination.acknowledge(context, clientId, subscriptionName, messageId, ack);
1:1595378:     }
1:802e527: 
1:1595378: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:ceb97f6
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1:         private final HashMap<TransactionStore, TransactionId> stores = new HashMap<TransactionStore, TransactionId>();
1:         public void trackStore(TransactionStore store, XATransactionId xid) {
1:             stores.put(store, xid);
1:         }
1: 
1:             stores.put(store, null);
1:         }
1: 
1:         public HashMap<TransactionStore, TransactionId> getStoresMap() {
1:             return stores;
1:             return stores.keySet();
/////////////////////////////////////////////////////////////////////////
1:             for (Map.Entry<TransactionStore, TransactionId> storeTx : tx.getStoresMap().entrySet()) {
1:                 TransactionId recovered = storeTx.getValue();
1:                 if (recovered != null) {
1:                     storeTx.getKey().commit(recovered, true, null, null);
1:                 } else {
1:                     storeTx.getKey().commit(txid, true, null, null);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:             for (Map.Entry<TransactionStore, TransactionId> storeTx : tx.getStoresMap().entrySet()) {
1:                 TransactionId recovered = storeTx.getValue();
1:                 if (recovered != null) {
1:                     storeTx.getKey().rollback(recovered);
1:                 } else {
1:                     storeTx.getKey().rollback(txid);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                         getTx(xid).trackStore(adapter.createTransactionStore(), xid);
commit:0ae90c0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.BaseDestination;
1: import org.apache.activemq.store.IndexListener;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.StoreUsage;
/////////////////////////////////////////////////////////////////////////
1: 
1:             @Override
1:             public void registerIndexListener(IndexListener indexListener) {
1:                 getDelegate().registerIndexListener(indexListener);
1:                 try {
1:                     if (indexListener instanceof BaseDestination) {
1:                         // update queue storeUsage
1:                         Object matchingPersistenceAdapter = multiKahaDBPersistenceAdapter.destinationMap.chooseValue(getDelegate().getDestination());
1:                         if (matchingPersistenceAdapter instanceof FilteredKahaDBPersistenceAdapter) {
1:                             FilteredKahaDBPersistenceAdapter filteredAdapter = (FilteredKahaDBPersistenceAdapter) matchingPersistenceAdapter;
1:                             if (filteredAdapter.getUsage() != null && filteredAdapter.getPersistenceAdapter() instanceof KahaDBPersistenceAdapter) {
1:                                 StoreUsage storeUsage = filteredAdapter.getUsage();
1:                                 storeUsage.setStore(filteredAdapter.getPersistenceAdapter());
1:                                 storeUsage.setParent(multiKahaDBPersistenceAdapter.getBrokerService().getSystemUsage().getStoreUsage());
1:                                 ((BaseDestination) indexListener).getSystemUsage().setStoreUsage(storeUsage);
1:                             }
1:                         }
1:                     }
1:                 } catch (Exception ignored) {
1:                     LOG.warn("Failed to set mKahaDB destination store usage", ignored);
1:                 }
1:             }
commit:d427952
/////////////////////////////////////////////////////////////////////////
1:                 public void cleanup() {
commit:ad1f751
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             public ListenableFuture<Object> asyncAddQueueMessage(ConnectionContext context, Message message) throws IOException {
1:             public ListenableFuture<Object> asyncAddQueueMessage(ConnectionContext context, Message message, boolean canOptimizeHint) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:             public ListenableFuture<Object> asyncAddTopicMessage(ConnectionContext context, Message message, boolean canOptimizeHint) throws IOException {
1:             public ListenableFuture<Object> asyncAddTopicMessage(ConnectionContext context, Message message) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     ListenableFuture<Object> asyncAddQueueMessage(final TransactionStore transactionStore, ConnectionContext context, final MessageStore destination, final Message message)
/////////////////////////////////////////////////////////////////////////
1:     ListenableFuture<Object> asyncAddTopicMessage(final TransactionStore transactionStore, ConnectionContext context, final MessageStore destination, final Message message)
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:092c56d
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicBoolean started = new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
1:         if (started.compareAndSet(false, true)) {
1:             journal = new Journal() {
1:                 @Override
0:                 protected void cleanup() {
1:                     super.cleanup();
1:                     txStoreCleanup();
1:                 }
1:             };
1:             journal.setDirectory(getDirectory());
1:             journal.setMaxFileLength(journalMaxFileLength);
1:             journal.setWriteBatchSize(journalWriteBatchSize);
1:             IOHelper.mkdirs(journal.getDirectory());
1:             journal.start();
1:             recoverPendingLocalTransactions();
1:             store(new KahaTraceCommand().setMessage("LOADED " + new Date()));
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (started.compareAndSet(true, false) && journal != null) {
1:             journal.close();
1:             journal = null;
1:         }
author:Timothy Bish
-------------------------------------------------------------------------------
commit:9ef4259
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentMap;
/////////////////////////////////////////////////////////////////////////
1:     final ConcurrentMap<TransactionId, Tx> inflightTransactions = new ConcurrentHashMap<TransactionId, Tx>();
commit:74846bb
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.AbstractMessageStore;
1: import org.apache.activemq.store.ListenableFuture;
1: import org.apache.activemq.store.MessageStore;
1: import org.apache.activemq.store.PersistenceAdapter;
1: import org.apache.activemq.store.ProxyMessageStore;
1: import org.apache.activemq.store.ProxyTopicMessageStore;
1: import org.apache.activemq.store.TopicMessageStore;
1: import org.apache.activemq.store.TransactionRecoveryListener;
1: import org.apache.activemq.store.TransactionStore;
1: import org.apache.activemq.util.IOHelper;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:802e527
/////////////////////////////////////////////////////////////////////////
1: 
author:Hiram Chirino
-------------------------------------------------------------------------------
commit:21fe8ca
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.*;
/////////////////////////////////////////////////////////////////////////
1:         tx.trackPrepareLocation(store(new KahaPrepareCommand().setTransactionInfo(TransactionIdConversion.convert(multiKahaDBPersistenceAdapter.transactionIdTransformer.transform(txid)))));
1:         store(new KahaCommitCommand().setTransactionInfo(TransactionIdConversion.convert(multiKahaDBPersistenceAdapter.transactionIdTransformer.transform(txid))));
/////////////////////////////////////////////////////////////////////////
1:         for (final PersistenceAdapter adapter : multiKahaDBPersistenceAdapter.adapters) {
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:c5cf038
commit:1aab71b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.kahadb.disk.journal.Journal;
1: import org.apache.activemq.store.kahadb.disk.journal.Location;
1: import org.apache.activemq.util.DataByteArrayInputStream;
1: import org.apache.activemq.util.DataByteArrayOutputStream;
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:d40f398
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             public void addMessage(ConnectionContext context, final Message send, boolean canOptimizeHint) throws IOException {
1:                 MultiKahaDBTransactionStore.this.addMessage(transactionStore, context, getDelegate(), send);
1:             }
1: 
1:             @Override
0:             public Future<Object> asyncAddQueueMessage(ConnectionContext context, Message message, boolean canOptimizeHint) throws IOException {
1:                 return MultiKahaDBTransactionStore.this.asyncAddQueueMessage(transactionStore, context, getDelegate(), message);
1:             }
1: 
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             public void addMessage(ConnectionContext context, final Message send, boolean canOptimizeHint) throws IOException {
1:                 MultiKahaDBTransactionStore.this.addMessage(transactionStore, context, getDelegate(), send);
1:             }
1: 
1:             @Override
0:             public Future<Object> asyncAddTopicMessage(ConnectionContext context, Message message, boolean canOptimizeHint) throws IOException {
1:                 return MultiKahaDBTransactionStore.this.asyncAddTopicMessage(transactionStore, context, getDelegate(), message);
1:             }
1: 
1:             @Override
author:Gary Tully
-------------------------------------------------------------------------------
commit:1595378
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.store.kahadb;
1: 
1: import java.io.File;
1: import java.io.IOException;
1: import java.util.Date;
1: import java.util.HashSet;
1: import java.util.Set;
1: import java.util.TreeSet;
1: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.Future;
1: import org.apache.activemq.broker.Broker;
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.command.TransactionId;
1: import org.apache.activemq.command.XATransactionId;
0: import org.apache.activemq.store.AbstractMessageStore;
0: import org.apache.activemq.store.MessageStore;
0: import org.apache.activemq.store.ProxyMessageStore;
0: import org.apache.activemq.store.ProxyTopicMessageStore;
0: import org.apache.activemq.store.TopicMessageStore;
0: import org.apache.activemq.store.TransactionRecoveryListener;
0: import org.apache.activemq.store.TransactionStore;
1: import org.apache.activemq.store.kahadb.data.KahaCommitCommand;
1: import org.apache.activemq.store.kahadb.data.KahaEntryType;
1: import org.apache.activemq.store.kahadb.data.KahaPrepareCommand;
1: import org.apache.activemq.store.kahadb.data.KahaTraceCommand;
0: import org.apache.activemq.util.IOHelper;
0: import org.apache.kahadb.journal.Journal;
0: import org.apache.kahadb.journal.Location;
0: import org.apache.kahadb.util.DataByteArrayInputStream;
0: import org.apache.kahadb.util.DataByteArrayOutputStream;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: public class MultiKahaDBTransactionStore implements TransactionStore {
1:     static final Logger LOG = LoggerFactory.getLogger(MultiKahaDBTransactionStore.class);
1:     final MultiKahaDBPersistenceAdapter multiKahaDBPersistenceAdapter;
0:     final ConcurrentHashMap<TransactionId, Tx> inflightTransactions = new ConcurrentHashMap<TransactionId, Tx>();
1:     final Set<TransactionId> recoveredPendingCommit = new HashSet<TransactionId>();
1:     private Journal journal;
1:     private int journalMaxFileLength = Journal.DEFAULT_MAX_FILE_LENGTH;
1:     private int journalWriteBatchSize = Journal.DEFAULT_MAX_WRITE_BATCH_SIZE;
1: 
1:     public MultiKahaDBTransactionStore(MultiKahaDBPersistenceAdapter multiKahaDBPersistenceAdapter) {
1:         this.multiKahaDBPersistenceAdapter = multiKahaDBPersistenceAdapter;
1:     }
1: 
1:     public MessageStore proxy(final TransactionStore transactionStore, MessageStore messageStore) {
1:         return new ProxyMessageStore(messageStore) {
1:             @Override
1:             public void addMessage(ConnectionContext context, final Message send) throws IOException {
1:                 MultiKahaDBTransactionStore.this.addMessage(transactionStore, context, getDelegate(), send);
1:             }
1: 
1:             @Override
0:             public Future<Object> asyncAddQueueMessage(ConnectionContext context, Message message) throws IOException {
1:                 return MultiKahaDBTransactionStore.this.asyncAddQueueMessage(transactionStore, context, getDelegate(), message);
1:             }
1: 
1:             @Override
1:             public void removeMessage(ConnectionContext context, final MessageAck ack) throws IOException {
1:                 MultiKahaDBTransactionStore.this.removeMessage(transactionStore, context, getDelegate(), ack);
1:             }
1: 
1:             @Override
1:             public void removeAsyncMessage(ConnectionContext context, MessageAck ack) throws IOException {
1:                 MultiKahaDBTransactionStore.this.removeAsyncMessage(transactionStore, context, getDelegate(), ack);
1:             }
1:         };
1:     }
1: 
1:     public TopicMessageStore proxy(final TransactionStore transactionStore, final TopicMessageStore messageStore) {
1:         return new ProxyTopicMessageStore(messageStore) {
1:             @Override
1:             public void addMessage(ConnectionContext context, final Message send) throws IOException {
1:                 MultiKahaDBTransactionStore.this.addMessage(transactionStore, context, getDelegate(), send);
1:             }
1: 
1:             @Override
0:             public Future<Object> asyncAddTopicMessage(ConnectionContext context, Message message) throws IOException {
1:                 return MultiKahaDBTransactionStore.this.asyncAddTopicMessage(transactionStore, context, getDelegate(), message);
1:             }
1: 
1:             @Override
1:             public void removeMessage(ConnectionContext context, final MessageAck ack) throws IOException {
1:                 MultiKahaDBTransactionStore.this.removeMessage(transactionStore, context, getDelegate(), ack);
1:             }
1: 
1:             @Override
1:             public void removeAsyncMessage(ConnectionContext context, MessageAck ack) throws IOException {
1:                 MultiKahaDBTransactionStore.this.removeAsyncMessage(transactionStore, context, getDelegate(), ack);
1:             }
1: 
1:             @Override
1:             public void acknowledge(ConnectionContext context, String clientId, String subscriptionName,
1:                                     MessageId messageId, MessageAck ack) throws IOException {
1:                 MultiKahaDBTransactionStore.this.acknowledge(transactionStore, context, (TopicMessageStore) getDelegate(), clientId,
1:                         subscriptionName, messageId, ack);
1:             }
1:         };
1:     }
1: 
1:     public void deleteAllMessages() {
1:         IOHelper.deleteChildren(getDirectory());
1:     }
1: 
1:     public int getJournalMaxFileLength() {
1:         return journalMaxFileLength;
1:     }
1: 
1:     public void setJournalMaxFileLength(int journalMaxFileLength) {
1:         this.journalMaxFileLength = journalMaxFileLength;
1:     }
1: 
1:     public int getJournalMaxWriteBatchSize() {
1:         return journalWriteBatchSize;
1:     }
1: 
1:     public void setJournalMaxWriteBatchSize(int journalWriteBatchSize) {
1:         this.journalWriteBatchSize = journalWriteBatchSize;
1:     }
1: 
1:     public class Tx {
0:         private final Set<TransactionStore> stores = new HashSet<TransactionStore>();
1:         private int prepareLocationId = 0;
1: 
1:         public void trackStore(TransactionStore store) {
0:             stores.add(store);
1:         }
1: 
1:         public Set<TransactionStore> getStores() {
0:             return stores;
1:         }
1: 
1:         public void trackPrepareLocation(Location location) {
1:             this.prepareLocationId = location.getDataFileId();
1:         }
1: 
1:         public int getPreparedLocationId() {
1:             return prepareLocationId;
1:         }
1:     }
1: 
1:     public Tx getTx(TransactionId txid) {
1:         Tx tx = inflightTransactions.get(txid);
1:         if (tx == null) {
1:             tx = new Tx();
1:             inflightTransactions.put(txid, tx);
1:         }
1:         return tx;
1:     }
1: 
1:     public Tx removeTx(TransactionId txid) {
1:         return inflightTransactions.remove(txid);
1:     }
1: 
1:     public void prepare(TransactionId txid) throws IOException {
1:         Tx tx = getTx(txid);
1:         for (TransactionStore store : tx.getStores()) {
1:             store.prepare(txid);
1:         }
1:     }
1: 
1:     public void commit(TransactionId txid, boolean wasPrepared, Runnable preCommit, Runnable postCommit)
1:             throws IOException {
1: 
1:         if (preCommit != null) {
1:             preCommit.run();
1:         }
1: 
1:         Tx tx = getTx(txid);
1:         if (wasPrepared) {
1:             for (TransactionStore store : tx.getStores()) {
1:                 store.commit(txid, true, null, null);
1:             }
1:         } else {
1:             // can only do 1pc on a single store
1:             if (tx.getStores().size() == 1) {
1:                 for (TransactionStore store : tx.getStores()) {
1:                     store.commit(txid, false, null, null);
1:                 }
1:             } else {
1:                 // need to do local 2pc
1:                 for (TransactionStore store : tx.getStores()) {
1:                     store.prepare(txid);
1:                 }
1:                 persistOutcome(tx, txid);
1:                 for (TransactionStore store : tx.getStores()) {
1:                     store.commit(txid, true, null, null);
1:                 }
1:                 persistCompletion(txid);
1:             }
1:         }
1:         removeTx(txid);
1:         if (postCommit != null) {
1:             postCommit.run();
1:         }
1:     }
1: 
1:     public void persistOutcome(Tx tx, TransactionId txid) throws IOException {
0:         tx.trackPrepareLocation(store(new KahaPrepareCommand().setTransactionInfo(multiKahaDBPersistenceAdapter.transactionIdTransformer.transform(txid))));
1:     }
1: 
1:     public void persistCompletion(TransactionId txid) throws IOException {
0:         store(new KahaCommitCommand().setTransactionInfo(multiKahaDBPersistenceAdapter.transactionIdTransformer.transform(txid)));
1:     }
1: 
1:     private Location store(JournalCommand<?> data) throws IOException {
1:         int size = data.serializedSizeFramed();
1:         DataByteArrayOutputStream os = new DataByteArrayOutputStream(size + 1);
1:         os.writeByte(data.type().getNumber());
1:         data.writeFramed(os);
1:         Location location = journal.write(os.toByteSequence(), true);
1:         journal.setLastAppendLocation(location);
1:         return location;
1:     }
1: 
1:     public void rollback(TransactionId txid) throws IOException {
1:         Tx tx = removeTx(txid);
1:         if (tx != null) {
1:             for (TransactionStore store : tx.getStores()) {
0:                 store.rollback(txid);
1:             }
1:         }
1:     }
1: 
1:     public void start() throws Exception {
0:         journal = new Journal() {
1:             @Override
0:             protected void cleanup() {
0:                 super.cleanup();
0:                 txStoreCleanup();
1:             }
1:         };
0:         journal.setDirectory(getDirectory());
0:         journal.setMaxFileLength(journalMaxFileLength);
0:         journal.setWriteBatchSize(journalWriteBatchSize);
0:         IOHelper.mkdirs(journal.getDirectory());
0:         journal.start();
0:         recoverPendingLocalTransactions();
0:         store(new KahaTraceCommand().setMessage("LOADED " + new Date()));
1:     }
1: 
1:     private void txStoreCleanup() {
1:         Set<Integer> knownDataFileIds = new TreeSet<Integer>(journal.getFileMap().keySet());
1:         for (Tx tx : inflightTransactions.values()) {
1:             knownDataFileIds.remove(tx.getPreparedLocationId());
1:         }
1:         try {
1:             journal.removeDataFiles(knownDataFileIds);
1:         } catch (Exception e) {
1:             LOG.error(this + ", Failed to remove tx journal datafiles " + knownDataFileIds);
1:         }
1:     }
1: 
1:     private File getDirectory() {
1:         return new File(multiKahaDBPersistenceAdapter.getDirectory(), "txStore");
1:     }
1: 
1:     public void stop() throws Exception {
0:         journal.close();
0:         journal = null;
1:     }
1: 
1:     private void recoverPendingLocalTransactions() throws IOException {
1:         Location location = journal.getNextLocation(null);
1:         while (location != null) {
1:             process(load(location));
1:             location = journal.getNextLocation(location);
1:         }
1:         recoveredPendingCommit.addAll(inflightTransactions.keySet());
1:         LOG.info("pending local transactions: " + recoveredPendingCommit);
1:     }
1: 
1:     public JournalCommand<?> load(Location location) throws IOException {
1:         DataByteArrayInputStream is = new DataByteArrayInputStream(journal.read(location));
1:         byte readByte = is.readByte();
1:         KahaEntryType type = KahaEntryType.valueOf(readByte);
1:         if (type == null) {
1:             throw new IOException("Could not load journal record. Invalid location: " + location);
1:         }
1:         JournalCommand<?> message = (JournalCommand<?>) type.createMessage();
1:         message.mergeFramed(is);
1:         return message;
1:     }
1: 
1:     public void process(JournalCommand<?> command) throws IOException {
1:         switch (command.type()) {
1:             case KAHA_PREPARE_COMMAND:
1:                 KahaPrepareCommand prepareCommand = (KahaPrepareCommand) command;
1:                 getTx(TransactionIdConversion.convert(prepareCommand.getTransactionInfo()));
1:                 break;
1:             case KAHA_COMMIT_COMMAND:
1:                 KahaCommitCommand commitCommand = (KahaCommitCommand) command;
1:                 removeTx(TransactionIdConversion.convert(commitCommand.getTransactionInfo()));
1:                 break;
1:             case KAHA_TRACE_COMMAND:
1:                 break;
1:             default:
1:                 throw new IOException("Unexpected command in transaction journal: " + command);
1:         }
1:     }
1: 
1: 
1:     public synchronized void recover(final TransactionRecoveryListener listener) throws IOException {
1: 
0:         for (final KahaDBPersistenceAdapter adapter : multiKahaDBPersistenceAdapter.adapters) {
1:             adapter.createTransactionStore().recover(new TransactionRecoveryListener() {
1:                 @Override
1:                 public void recover(XATransactionId xid, Message[] addedMessages, MessageAck[] acks) {
1:                     try {
0:                         getTx(xid).trackStore(adapter.createTransactionStore());
1:                     } catch (IOException e) {
1:                         LOG.error("Failed to access transaction store: " + adapter + " for prepared xa tid: " + xid, e);
1:                     }
1:                     listener.recover(xid, addedMessages, acks);
1:                 }
1:             });
1:         }
1: 
1:         try {
1:             Broker broker = multiKahaDBPersistenceAdapter.getBrokerService().getBroker();
1:             // force completion of local xa
1:             for (TransactionId txid : broker.getPreparedTransactions(null)) {
1:                 if (multiKahaDBPersistenceAdapter.isLocalXid(txid)) {
1:                     try {
1:                         if (recoveredPendingCommit.contains(txid)) {
1:                             LOG.info("delivering pending commit outcome for tid: " + txid);
1:                             broker.commitTransaction(null, txid, false);
1: 
1:                         } else {
1:                             LOG.info("delivering rollback outcome to store for tid: " + txid);
1:                             broker.forgetTransaction(null, txid);
1:                         }
1:                         persistCompletion(txid);
1:                     } catch (Exception ex) {
1:                         LOG.error("failed to deliver pending outcome for tid: " + txid, ex);
1:                     }
1:                 }
1:             }
1:         } catch (Exception e) {
1:             LOG.error("failed to resolve pending local transactions", e);
1:         }
1:     }
1: 
1:     void addMessage(final TransactionStore transactionStore, ConnectionContext context, final MessageStore destination, final Message message)
1:             throws IOException {
1:         if (message.getTransactionId() != null) {
1:             getTx(message.getTransactionId()).trackStore(transactionStore);
1:         }
1:         destination.addMessage(context, message);
1:     }
1: 
0:     Future<Object> asyncAddQueueMessage(final TransactionStore transactionStore, ConnectionContext context, final MessageStore destination, final Message message)
1:             throws IOException {
1:         if (message.getTransactionId() != null) {
1:             getTx(message.getTransactionId()).trackStore(transactionStore);
1:             destination.addMessage(context, message);
1:             return AbstractMessageStore.FUTURE;
1:         } else {
1:             return destination.asyncAddQueueMessage(context, message);
1:         }
1:     }
1: 
0:     Future<Object> asyncAddTopicMessage(final TransactionStore transactionStore, ConnectionContext context, final MessageStore destination, final Message message)
1:             throws IOException {
1: 
1:         if (message.getTransactionId() != null) {
1:             getTx(message.getTransactionId()).trackStore(transactionStore);
1:             destination.addMessage(context, message);
1:             return AbstractMessageStore.FUTURE;
1:         } else {
1:             return destination.asyncAddTopicMessage(context, message);
1:         }
1:     }
1: 
1:     final void removeMessage(final TransactionStore transactionStore, ConnectionContext context, final MessageStore destination, final MessageAck ack)
1:             throws IOException {
1:         if (ack.getTransactionId() != null) {
1:             getTx(ack.getTransactionId()).trackStore(transactionStore);
1:         }
1:         destination.removeMessage(context, ack);
1:     }
1: 
1:     final void removeAsyncMessage(final TransactionStore transactionStore, ConnectionContext context, final MessageStore destination, final MessageAck ack)
1:             throws IOException {
1:         if (ack.getTransactionId() != null) {
1:             getTx(ack.getTransactionId()).trackStore(transactionStore);
1:         }
1:         destination.removeAsyncMessage(context, ack);
1:     }
1: 
1:     final void acknowledge(final TransactionStore transactionStore, ConnectionContext context, final TopicMessageStore destination,
1:                            final String clientId, final String subscriptionName,
1:                            final MessageId messageId, final MessageAck ack) throws IOException {
1:         if (ack.getTransactionId() != null) {
1:             getTx(ack.getTransactionId()).trackStore(transactionStore);
1:         }
1:         destination.acknowledge(context, clientId, subscriptionName, messageId, ack);
1:     }
1: }
============================================================================