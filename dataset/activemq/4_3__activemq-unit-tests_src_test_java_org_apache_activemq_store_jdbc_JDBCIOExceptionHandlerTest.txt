1:539a5f1: /**
1:539a5f1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:539a5f1:  * contributor license agreements.  See the NOTICE file distributed with
1:539a5f1:  * this work for additional information regarding copyright ownership.
1:539a5f1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:539a5f1:  * (the "License"); you may not use this file except in compliance with
1:539a5f1:  * the License.  You may obtain a copy of the License at
1:539a5f1:  *
1:539a5f1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:539a5f1:  *
1:539a5f1:  * Unless required by applicable law or agreed to in writing, software
1:539a5f1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:539a5f1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:539a5f1:  * See the License for the specific language governing permissions and
1:539a5f1:  * limitations under the License.
1:539a5f1:  */
1:539a5f1: package org.apache.activemq.store.jdbc;
4:539a5f1: 
1:c6837ac: import java.io.File;
1:5e656d3: import java.io.IOException;
1:5e656d3: import java.io.ObjectInputStream;
1:539a5f1: import java.io.PrintWriter;
1:5e656d3: import java.net.Socket;
1:5e656d3: import java.rmi.registry.Registry;
1:539a5f1: import java.sql.SQLException;
1:539a5f1: import java.sql.SQLFeatureNotSupportedException;
1:5e656d3: import java.util.ArrayList;
1:5e656d3: import java.util.List;
1:5e656d3: import java.util.Set;
1:539a5f1: import java.util.concurrent.TimeUnit;
1:5e656d3: import java.util.concurrent.atomic.AtomicBoolean;
1:d60022e: import java.util.concurrent.atomic.AtomicReference;
1:539a5f1: 
1:539a5f1: import javax.jms.Connection;
1:5e656d3: import javax.management.*;
1:5e656d3: import javax.management.loading.ClassLoaderRepository;
1:5e656d3: import javax.management.remote.JMXConnectorServer;
1:5e656d3: import javax.management.remote.JMXConnectorServerFactory;
1:5e656d3: import javax.management.remote.JMXServiceURL;
1:539a5f1: 
1:5e656d3: import com.sun.jndi.rmi.registry.RegistryContext;
1:5e656d3: import com.sun.jndi.rmi.registry.RegistryContextFactory;
1:539a5f1: import org.apache.activemq.ActiveMQConnectionFactory;
1:539a5f1: import org.apache.activemq.broker.BrokerService;
1:6f1f06f: import org.apache.activemq.broker.ft.SyncCreateDataSource;
1:5e656d3: import org.apache.activemq.broker.jmx.ManagementContext;
1:c7291f1: import org.apache.activemq.bugs.embedded.ThreadExplorer;
1:5e656d3: import org.apache.activemq.util.DefaultTestAppender;
1:c6837ac: import org.apache.activemq.util.IOHelper;
1:e16815a: import org.apache.activemq.util.LeaseLockerIOExceptionHandler;
1:d60022e: import org.apache.activemq.util.Wait;
1:539a5f1: import org.apache.derby.jdbc.EmbeddedDataSource;
1:5e656d3: import org.apache.log4j.Level;
1:5e656d3: import org.apache.log4j.spi.LoggingEvent;
1:165959e: import org.junit.After;
1:c6837ac: import org.junit.Before;
1:c6837ac: import org.junit.Test;
1:539a5f1: import org.slf4j.Logger;
1:539a5f1: import org.slf4j.LoggerFactory;
1:c6837ac: 
1:c6837ac: 
1:113a381: import static org.junit.Assert.assertTrue;
1:113a381: import static org.junit.Assert.fail;
1:539a5f1: 
1:539a5f1: /**
1:539a5f1:  * Test to see if the JDBCExceptionIOHandler will restart the transport connectors correctly after
1:539a5f1:  * the underlying DB has been stopped and restarted
1:539a5f1:  *
1:539a5f1:  * see AMQ-4575
1:539a5f1:  */
1:c6837ac: public class JDBCIOExceptionHandlerTest {
1:539a5f1: 
1:539a5f1:     private static final Logger LOG = LoggerFactory.getLogger(JDBCIOExceptionHandlerTest.class);
1:539a5f1:     private static final String TRANSPORT_URL = "tcp://0.0.0.0:0";
1:539a5f1: 
1:539a5f1:     private ActiveMQConnectionFactory factory;
1:539a5f1:     private ReconnectingEmbeddedDataSource dataSource;
1:539a5f1:     private BrokerService broker;
1:539a5f1: 
1:165959e:     @After
1:165959e:     public void stopDB() {
1:165959e:         if (dataSource != null) {
1:165959e:             dataSource.stopDB();
1:165959e:         }
1:c6837ac:     }
1:c6837ac: 
1:539a5f1:     protected BrokerService createBroker(boolean withJMX) throws Exception {
1:d60022e:         return createBroker("localhost", withJMX, true, true);
1:d60022e:     }
1:d60022e: 
1:d60022e:     protected BrokerService createBroker(String name, boolean withJMX, boolean leaseLocker, boolean startStopConnectors) throws Exception {
1:539a5f1:         BrokerService broker = new BrokerService();
1:d60022e:         broker.setBrokerName(name);
1:539a5f1: 
1:539a5f1:         broker.setUseJmx(withJMX);
1:539a5f1: 
1:165959e:         JDBCPersistenceAdapter jdbc = new JDBCPersistenceAdapter();
1:165959e:         EmbeddedDataSource embeddedDataSource = (EmbeddedDataSource) jdbc.getDataSource();
1:539a5f1:         // create a wrapper to EmbeddedDataSource to allow the connection be
1:539a5f1:         // reestablished to derby db
1:6f1f06f:         dataSource = new ReconnectingEmbeddedDataSource(new SyncCreateDataSource(embeddedDataSource));
1:539a5f1:         jdbc.setDataSource(dataSource);
1:539a5f1: 
1:539a5f1:         jdbc.setLockKeepAlivePeriod(1000l);
1:d60022e:         if (leaseLocker) {
1:d60022e:             LeaseDatabaseLocker leaseDatabaseLocker = new LeaseDatabaseLocker();
1:b5c6c1e:             leaseDatabaseLocker.setHandleStartException(true);
1:d60022e:             leaseDatabaseLocker.setLockAcquireSleepInterval(2000l);
1:d60022e:             jdbc.setLocker(leaseDatabaseLocker);
1:d60022e:         }
1:539a5f1: 
1:539a5f1:         broker.setPersistenceAdapter(jdbc);
1:e16815a:         LeaseLockerIOExceptionHandler ioExceptionHandler = new LeaseLockerIOExceptionHandler();
1:e16815a:         ioExceptionHandler.setResumeCheckSleepPeriod(1000l);
1:e16815a:         ioExceptionHandler.setStopStartConnectors(startStopConnectors);
1:e16815a:         broker.setIoExceptionHandler(ioExceptionHandler);
1:539a5f1:         String connectionUri = broker.addConnector(TRANSPORT_URL).getPublishableConnectString();
1:539a5f1: 
1:539a5f1:         factory = new ActiveMQConnectionFactory(connectionUri);
1:539a5f1: 
1:539a5f1:         return broker;
2:539a5f1:     }
1:539a5f1: 
1:c7291f1:     @Test
1:c7291f1:     public void testStartWithDatabaseDown() throws Exception {
1:5e656d3:         final AtomicBoolean connectorStarted = new AtomicBoolean(false);
1:5e656d3:         final AtomicBoolean connectorStopped = new AtomicBoolean(false);
1:5e656d3: 
1:5e656d3:         DefaultTestAppender appender = new DefaultTestAppender() {
1:5e656d3: 
1:5e656d3:             @Override
1:5e656d3:             public void doAppend(LoggingEvent event) {
1:5e656d3:                 if (event.getMessage().toString().startsWith("JMX consoles can connect to")) {
1:5e656d3:                     connectorStarted.set(true);
1:5e656d3:                 }
1:5e656d3: 
1:5e656d3:                 if (event.getMessage().toString().equals("Stopping jmx connector")) {
1:5e656d3:                     connectorStopped.set(true);
1:5e656d3:                 }
1:5e656d3:             }
1:5e656d3:         };
1:5e656d3: 
1:5e656d3:         org.apache.log4j.Logger rootLogger = org.apache.log4j.Logger.getRootLogger();
1:5e656d3:         Level previousLevel = rootLogger.getLevel();
1:5e656d3:         rootLogger.setLevel(Level.DEBUG);
1:5e656d3:         rootLogger.addAppender(appender);
1:5e656d3: 
1:5e656d3: 
1:c7291f1:         BrokerService broker = new BrokerService();
1:5e656d3:         broker.getManagementContext().setCreateConnector(true);
1:5e656d3:         broker.getManagementContext().setCreateMBeanServer(true);
1:c7291f1: 
1:c7291f1:         JDBCPersistenceAdapter jdbc = new JDBCPersistenceAdapter();
1:c7291f1:         EmbeddedDataSource embeddedDataSource = (EmbeddedDataSource) jdbc.getDataSource();
1:c7291f1:         // create a wrapper to EmbeddedDataSource to allow the connection be
1:c7291f1:         // reestablished to derby db
1:c7291f1:         dataSource = new ReconnectingEmbeddedDataSource(new SyncCreateDataSource(embeddedDataSource));
1:c7291f1:         dataSource.stopDB();
1:c7291f1:         jdbc.setDataSource(dataSource);
1:c7291f1: 
1:c7291f1:         jdbc.setLockKeepAlivePeriod(1000l);
1:c7291f1:         LeaseDatabaseLocker leaseDatabaseLocker = new LeaseDatabaseLocker();
1:c7291f1:         leaseDatabaseLocker.setHandleStartException(true);
1:c7291f1:         leaseDatabaseLocker.setLockAcquireSleepInterval(2000l);
1:c7291f1:         jdbc.setLocker(leaseDatabaseLocker);
1:c7291f1: 
1:c7291f1:         broker.setPersistenceAdapter(jdbc);
1:c7291f1:         LeaseLockerIOExceptionHandler ioExceptionHandler = new LeaseLockerIOExceptionHandler();
1:c7291f1:         ioExceptionHandler.setResumeCheckSleepPeriod(1000l);
1:c7291f1:         ioExceptionHandler.setStopStartConnectors(true);
1:c7291f1:         broker.setIoExceptionHandler(ioExceptionHandler);
1:c7291f1:         try {
1:c7291f1:             broker.start();
1:c7291f1:             fail("Broker should have been stopped!");
1:c7291f1:         } catch (Exception e) {
1:c7291f1:             Thread.sleep(5000);
1:c7291f1:             assertTrue("Broker should have been stopped!", broker.isStopped());
1:c7291f1:             Thread[] threads = ThreadExplorer.listThreads();
1:c7291f1:             for (int i = 0; i < threads.length; i++) {
1:c7291f1:                 if (threads[i].getName().startsWith("IOExceptionHandler")) {
1:c7291f1:                     fail("IOExceptionHanlder still active");
1:c7291f1:                 }
1:c7291f1:             }
1:5e656d3: 
1:5e656d3:             if (connectorStarted.get() && !connectorStopped.get()) {
1:5e656d3:                 fail("JMX Server Connector should have been stopped!");
1:5e656d3:             }
1:5e656d3: 
1:c7291f1:         } finally {
1:c7291f1:             dataSource = null;
1:c7291f1:             broker = null;
1:5e656d3:             rootLogger.removeAppender(appender);
1:5e656d3:             rootLogger.setLevel(previousLevel);
1:c7291f1:         }
1:c7291f1:     }
1:c7291f1: 
1:539a5f1:     /*
1:539a5f1:      * run test without JMX enabled
1:539a5f1:      */
1:c6837ac:     @Test
1:539a5f1:     public void testRecoverWithOutJMX() throws Exception {
1:539a5f1:         recoverFromDisconnectDB(false);
1:539a5f1:     }
1:539a5f1: 
1:539a5f1:     /*
1:539a5f1:      * run test with JMX enabled
1:539a5f1:      */
1:c6837ac:     @Test
1:539a5f1:     public void testRecoverWithJMX() throws Exception {
1:539a5f1:         recoverFromDisconnectDB(true);
1:539a5f1:     }
1:539a5f1: 
1:c6837ac:     @Test
1:d60022e:     public void testSlaveStoppedLease() throws Exception {
1:d60022e:         testSlaveStopped(true);
1:d60022e:     }
1:d60022e: 
1:c6837ac:     @Test
1:d60022e:     public void testSlaveStoppedDefault() throws Exception {
1:d60022e:         testSlaveStopped(false);
1:d60022e:     }
1:d60022e: 
1:d60022e:     public void testSlaveStopped(final boolean lease) throws Exception {
1:d60022e:         final BrokerService master = createBroker("master", true, lease, false);
1:d60022e:         master.start();
1:d60022e:         master.waitUntilStarted();
1:d60022e: 
1:d60022e:         final AtomicReference<BrokerService> slave = new AtomicReference<BrokerService>();
1:d60022e: 
1:d60022e:         Thread slaveThread = new Thread() {
1:d60022e:             public void run() {
1:d60022e:                 try {
1:d60022e:                     BrokerService broker = new BrokerService();
1:d60022e:                     broker.setBrokerName("slave");
1:d60022e: 
1:d60022e:                     JDBCPersistenceAdapter jdbc = new JDBCPersistenceAdapter();
1:d60022e:                     jdbc.setDataSource(dataSource);
1:d60022e: 
1:d60022e:                     jdbc.setLockKeepAlivePeriod(1000l);
1:d60022e: 
1:d60022e:                     if (lease) {
1:d60022e:                         LeaseDatabaseLocker leaseDatabaseLocker = new LeaseDatabaseLocker();
1:b5c6c1e:                         leaseDatabaseLocker.setHandleStartException(true);
1:d60022e:                         leaseDatabaseLocker.setLockAcquireSleepInterval(2000l);
1:d60022e:                         jdbc.setLocker(leaseDatabaseLocker);
1:d60022e:                     }
1:d60022e: 
1:d60022e:                     broker.setPersistenceAdapter(jdbc);
1:e16815a:                     LeaseLockerIOExceptionHandler ioExceptionHandler = new LeaseLockerIOExceptionHandler();
1:e16815a:                     ioExceptionHandler.setResumeCheckSleepPeriod(1000l);
1:e16815a:                     ioExceptionHandler.setStopStartConnectors(false);
1:e16815a:                     broker.setIoExceptionHandler(ioExceptionHandler);
1:d60022e:                     slave.set(broker);
1:d60022e:                     broker.start();
1:d60022e:                 } catch (Exception e) {
1:d60022e:                     e.printStackTrace();
1:d60022e:                 }
1:d60022e:             }
1:d60022e:         };
1:d60022e: 
1:d60022e:         slaveThread.start();
1:d60022e: 
1:d60022e:         Thread.sleep(5000);
1:d60022e: 
1:d60022e:         dataSource.stopDB();
1:d60022e: 
1:d60022e:         assertTrue("Master hasn't been stopped", Wait.waitFor(new Wait.Condition() {
1:d60022e:             @Override
1:d60022e:             public boolean isSatisified() throws Exception {
1:d60022e:                 return master.isStopped();
1:d60022e:             }
1:d60022e:         }));
1:d60022e: 
1:d60022e:         assertTrue("Slave hasn't been stopped", Wait.waitFor(new Wait.Condition() {
1:d60022e:             @Override
1:d60022e:             public boolean isSatisified() throws Exception {
1:d60022e:                 return slave.get().isStopped();
1:d60022e:             }
1:d60022e:         }));
1:d60022e: 
1:d60022e:     }
1:d60022e: 
1:539a5f1:     public void recoverFromDisconnectDB(boolean withJMX) throws Exception {
2:539a5f1:         try {
1:539a5f1:             broker = createBroker(withJMX);
1:539a5f1:             broker.start();
1:539a5f1:             broker.waitUntilStarted();
1:539a5f1: 
1:539a5f1:             // broker started - stop db underneath it
1:539a5f1:             dataSource.stopDB();
1:539a5f1: 
1:539a5f1:             // wait - allow the leaselocker to kick the JDBCIOExceptionHandler
2:539a5f1:             TimeUnit.SECONDS.sleep(3);
1:539a5f1: 
1:539a5f1:             // check connector has shutdown
1:539a5f1:             checkTransportConnectorStopped();
1:539a5f1: 
1:539a5f1:             // restart db underneath
1:539a5f1:             dataSource.restartDB();
1:539a5f1: 
1:c28d520:             Wait.waitFor(new Wait.Condition() {
1:c28d520:                 @Override
1:c28d520:                 public boolean isSatisified() throws Exception {
1:c28d520:                     LOG.debug("*** checking connector to start...");
1:c28d520:                     try {
1:c28d520:                         checkTransportConnectorStarted();
1:c28d520:                         return true;
1:c28d520:                     } catch (Throwable t) {
1:c28d520:                         LOG.debug(t.toString());
1:c28d520:                     }
1:c28d520:                     return false;
1:c28d520:                 }
1:c28d520:             });
1:539a5f1: 
1:539a5f1: 
1:539a5f1:         } finally {
1:539a5f1:             LOG.debug("*** broker is stopping...");
1:539a5f1:             broker.stop();
1:c7291f1:             broker.waitUntilStopped();
1:539a5f1:         }
1:539a5f1:     }
1:539a5f1: 
1:539a5f1:     private void checkTransportConnectorStopped() {
1:539a5f1:         // connection is expected to fail
1:539a5f1:         try {
1:539a5f1:             factory.createConnection();
1:539a5f1:             fail("Transport connector should be stopped");
2:539a5f1:         } catch (Exception ex) {
1:539a5f1:             // expected an exception
1:539a5f1:             LOG.debug(" checkTransportConnectorStopped() threw", ex);
1:539a5f1:         }
1:539a5f1:     }
1:539a5f1: 
1:539a5f1:     private void checkTransportConnectorStarted() {
1:539a5f1:         // connection is expected to succeed
1:539a5f1:         try {
1:539a5f1:             Connection conn = factory.createConnection();
1:539a5f1:             conn.close();
1:539a5f1:         } catch (Exception ex) {
1:539a5f1:             LOG.debug("checkTransportConnectorStarted() threw", ex);
1:539a5f1:             fail("Transport connector should have been started");
1:539a5f1:         }
1:539a5f1:     }
1:539a5f1: 
1:539a5f1:     /*
1:539a5f1:      * Wrapped the derby datasource object to get DB reconnect functionality as I not
1:539a5f1:      * manage to get that working directly on the EmbeddedDataSource
1:539a5f1:      *
1:539a5f1:      */
1:539a5f1:     public class ReconnectingEmbeddedDataSource implements javax.sql.DataSource {
1:539a5f1: 
1:6f1f06f:         private SyncCreateDataSource realDatasource;
1:539a5f1: 
1:6f1f06f:         public ReconnectingEmbeddedDataSource(SyncCreateDataSource datasource) {
1:539a5f1:             this.realDatasource = datasource;
1:539a5f1:         }
1:539a5f1: 
2:539a5f1:         @Override
1:539a5f1:         public PrintWriter getLogWriter() throws SQLException {
1:539a5f1:             return this.realDatasource.getLogWriter();
1:539a5f1:         }
1:539a5f1: 
1:539a5f1:         @Override
1:539a5f1:         public void setLogWriter(PrintWriter out) throws SQLException {
1:539a5f1:             this.realDatasource.setLogWriter(out);
1:539a5f1: 
1:539a5f1:         }
1:539a5f1: 
1:539a5f1:         @Override
1:539a5f1:         public void setLoginTimeout(int seconds) throws SQLException {
1:539a5f1:             this.realDatasource.setLoginTimeout(seconds);
1:539a5f1:         }
1:539a5f1: 
1:539a5f1:         @Override
1:539a5f1:         public int getLoginTimeout() throws SQLException {
1:539a5f1:             return this.realDatasource.getLoginTimeout();
1:539a5f1:         }
1:539a5f1: 
1:539a5f1:         @Override
1:539a5f1:         public <T> T unwrap(Class<T> iface) throws SQLException {
1:539a5f1:             return this.unwrap(iface);
1:539a5f1:         }
1:539a5f1: 
1:539a5f1:         @Override
1:539a5f1:         public boolean isWrapperFor(Class<?> iface) throws SQLException {
1:539a5f1:             return this.isWrapperFor(iface);
1:539a5f1:         }
1:539a5f1: 
1:539a5f1:         @Override
1:539a5f1:         public java.sql.Connection getConnection() throws SQLException {
1:539a5f1:             return this.realDatasource.getConnection();
1:539a5f1:         }
1:539a5f1: 
1:539a5f1:         @Override
1:539a5f1:         public java.sql.Connection getConnection(String username, String password) throws SQLException {
1:539a5f1:             return this.getConnection(username, password);
1:539a5f1:         }
1:539a5f1: 
1:539a5f1:         /**
1:539a5f1:          *
1:539a5f1:          * To simulate a db reconnect I just create a new EmbeddedDataSource .
1:539a5f1:          *
1:539a5f1:          * @throws SQLException
1:539a5f1:          */
1:165959e:         public void restartDB() throws Exception {
1:165959e:             EmbeddedDataSource newDatasource =
1:165959e:                     (EmbeddedDataSource) DataSourceServiceSupport.createDataSource(broker.getDataDirectoryFile().getCanonicalPath());
1:539a5f1:             newDatasource.getConnection();
1:539a5f1:             LOG.info("*** DB restarted now...");
1:6f1f06f:             Object existingDataSource = realDatasource;
1:6f1f06f:             synchronized (existingDataSource) {
1:6f1f06f:                 this.realDatasource = new SyncCreateDataSource(newDatasource);
1:6f1f06f:             }
1:539a5f1:         }
1:539a5f1: 
1:539a5f1:         public void stopDB() {
1:165959e:             LOG.info("***DB is being shutdown...");
1:6f1f06f:             synchronized (realDatasource) {
1:6f1f06f:                 DataSourceServiceSupport.shutdownDefaultDataSource(realDatasource.getDelegate());
1:6f1f06f:             }
1:539a5f1:         }
1:539a5f1: 
1:539a5f1:         public java.util.logging.Logger getParentLogger() throws SQLFeatureNotSupportedException {
1:539a5f1:             return null;
1:539a5f1:         }
1:539a5f1:     }
1:539a5f1: }
============================================================================
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:5e656d3
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.io.ObjectInputStream;
1: import java.net.Socket;
1: import java.rmi.registry.Registry;
1: import java.util.ArrayList;
1: import java.util.List;
1: import java.util.Set;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: import javax.management.*;
1: import javax.management.loading.ClassLoaderRepository;
1: import javax.management.remote.JMXConnectorServer;
1: import javax.management.remote.JMXConnectorServerFactory;
1: import javax.management.remote.JMXServiceURL;
1: import com.sun.jndi.rmi.registry.RegistryContext;
1: import com.sun.jndi.rmi.registry.RegistryContextFactory;
1: import org.apache.activemq.broker.jmx.ManagementContext;
1: import org.apache.activemq.util.DefaultTestAppender;
1: import org.apache.log4j.Level;
1: import org.apache.log4j.spi.LoggingEvent;
/////////////////////////////////////////////////////////////////////////
1:         final AtomicBoolean connectorStarted = new AtomicBoolean(false);
1:         final AtomicBoolean connectorStopped = new AtomicBoolean(false);
1: 
1:         DefaultTestAppender appender = new DefaultTestAppender() {
1: 
1:             @Override
1:             public void doAppend(LoggingEvent event) {
1:                 if (event.getMessage().toString().startsWith("JMX consoles can connect to")) {
1:                     connectorStarted.set(true);
1:                 }
1: 
1:                 if (event.getMessage().toString().equals("Stopping jmx connector")) {
1:                     connectorStopped.set(true);
1:                 }
1:             }
1:         };
1: 
1:         org.apache.log4j.Logger rootLogger = org.apache.log4j.Logger.getRootLogger();
1:         Level previousLevel = rootLogger.getLevel();
1:         rootLogger.setLevel(Level.DEBUG);
1:         rootLogger.addAppender(appender);
1: 
1: 
1:         broker.getManagementContext().setCreateConnector(true);
1:         broker.getManagementContext().setCreateMBeanServer(true);
/////////////////////////////////////////////////////////////////////////
1: 
1:             if (connectorStarted.get() && !connectorStopped.get()) {
1:                 fail("JMX Server Connector should have been stopped!");
1:             }
1: 
1:             rootLogger.removeAppender(appender);
1:             rootLogger.setLevel(previousLevel);
commit:c7291f1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.bugs.embedded.ThreadExplorer;
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void testStartWithDatabaseDown() throws Exception {
1:         BrokerService broker = new BrokerService();
1: 
1:         JDBCPersistenceAdapter jdbc = new JDBCPersistenceAdapter();
1:         EmbeddedDataSource embeddedDataSource = (EmbeddedDataSource) jdbc.getDataSource();
1:         // create a wrapper to EmbeddedDataSource to allow the connection be
1:         // reestablished to derby db
1:         dataSource = new ReconnectingEmbeddedDataSource(new SyncCreateDataSource(embeddedDataSource));
1:         dataSource.stopDB();
1:         jdbc.setDataSource(dataSource);
1: 
1:         jdbc.setLockKeepAlivePeriod(1000l);
1:         LeaseDatabaseLocker leaseDatabaseLocker = new LeaseDatabaseLocker();
1:         leaseDatabaseLocker.setHandleStartException(true);
1:         leaseDatabaseLocker.setLockAcquireSleepInterval(2000l);
1:         jdbc.setLocker(leaseDatabaseLocker);
1: 
1:         broker.setPersistenceAdapter(jdbc);
1:         LeaseLockerIOExceptionHandler ioExceptionHandler = new LeaseLockerIOExceptionHandler();
1:         ioExceptionHandler.setResumeCheckSleepPeriod(1000l);
1:         ioExceptionHandler.setStopStartConnectors(true);
1:         broker.setIoExceptionHandler(ioExceptionHandler);
1:         try {
1:             broker.start();
1:             fail("Broker should have been stopped!");
1:         } catch (Exception e) {
1:             Thread.sleep(5000);
1:             assertTrue("Broker should have been stopped!", broker.isStopped());
1:             Thread[] threads = ThreadExplorer.listThreads();
1:             for (int i = 0; i < threads.length; i++) {
1:                 if (threads[i].getName().startsWith("IOExceptionHandler")) {
1:                     fail("IOExceptionHanlder still active");
1:                 }
1:             }
1:         } finally {
1:             dataSource = null;
1:             broker = null;
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             broker.waitUntilStopped();
commit:b5c6c1e
/////////////////////////////////////////////////////////////////////////
1:             leaseDatabaseLocker.setHandleStartException(true);
/////////////////////////////////////////////////////////////////////////
1:                         leaseDatabaseLocker.setHandleStartException(true);
commit:d60022e
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicReference;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.Wait;
/////////////////////////////////////////////////////////////////////////
1:         return createBroker("localhost", withJMX, true, true);
1:     }
1: 
1:     protected BrokerService createBroker(String name, boolean withJMX, boolean leaseLocker, boolean startStopConnectors) throws Exception {
1:         broker.setBrokerName(name);
/////////////////////////////////////////////////////////////////////////
1:         if (leaseLocker) {
1:             LeaseDatabaseLocker leaseDatabaseLocker = new LeaseDatabaseLocker();
1:             leaseDatabaseLocker.setLockAcquireSleepInterval(2000l);
1:             jdbc.setLocker(leaseDatabaseLocker);
1:         }
0:         jdbcioExceptionHandler.setStopStartConnectors(startStopConnectors);
/////////////////////////////////////////////////////////////////////////
1:     public void testSlaveStoppedLease() throws Exception {
1:         testSlaveStopped(true);
1:     }
1: 
1:     public void testSlaveStoppedDefault() throws Exception {
1:         testSlaveStopped(false);
1:     }
1: 
1:     public void testSlaveStopped(final boolean lease) throws Exception {
1:         final BrokerService master = createBroker("master", true, lease, false);
1:         master.start();
1:         master.waitUntilStarted();
1: 
1:         final AtomicReference<BrokerService> slave = new AtomicReference<BrokerService>();
1: 
1:         Thread slaveThread = new Thread() {
1:             public void run() {
1:                 try {
1:                     BrokerService broker = new BrokerService();
1:                     broker.setBrokerName("slave");
1: 
1:                     JDBCPersistenceAdapter jdbc = new JDBCPersistenceAdapter();
1:                     jdbc.setDataSource(dataSource);
1: 
1:                     jdbc.setLockKeepAlivePeriod(1000l);
1: 
1:                     if (lease) {
1:                         LeaseDatabaseLocker leaseDatabaseLocker = new LeaseDatabaseLocker();
1:                         leaseDatabaseLocker.setLockAcquireSleepInterval(2000l);
1:                         jdbc.setLocker(leaseDatabaseLocker);
1:                     }
1: 
1:                     broker.setPersistenceAdapter(jdbc);
0:                     JDBCIOExceptionHandler jdbcioExceptionHandler = new JDBCIOExceptionHandler();
0:                     jdbcioExceptionHandler.setResumeCheckSleepPeriod(1000l);
0:                     jdbcioExceptionHandler.setStopStartConnectors(false);
0:                     broker.setIoExceptionHandler(jdbcioExceptionHandler);
1:                     slave.set(broker);
1:                     broker.start();
1:                 } catch (Exception e) {
1:                     e.printStackTrace();
1:                 }
1:             }
1:         };
1: 
1:         slaveThread.start();
1: 
1:         Thread.sleep(5000);
1: 
1:         dataSource.stopDB();
1: 
1:         assertTrue("Master hasn't been stopped", Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return master.isStopped();
1:             }
1:         }));
1: 
1:         assertTrue("Slave hasn't been stopped", Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return slave.get().isStopped();
1:             }
1:         }));
1: 
1:     }
1: 
author:gtully
-------------------------------------------------------------------------------
commit:6f1f06f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.ft.SyncCreateDataSource;
/////////////////////////////////////////////////////////////////////////
1:         dataSource = new ReconnectingEmbeddedDataSource(new SyncCreateDataSource(embeddedDataSource));
/////////////////////////////////////////////////////////////////////////
1:         private SyncCreateDataSource realDatasource;
1:         public ReconnectingEmbeddedDataSource(SyncCreateDataSource datasource) {
/////////////////////////////////////////////////////////////////////////
1:             Object existingDataSource = realDatasource;
1:             synchronized (existingDataSource) {
1:                 this.realDatasource = new SyncCreateDataSource(newDatasource);
1:             }
1:             synchronized (realDatasource) {
1:                 DataSourceServiceSupport.shutdownDefaultDataSource(realDatasource.getDelegate());
1:             }
commit:165959e
/////////////////////////////////////////////////////////////////////////
1: import org.junit.After;
/////////////////////////////////////////////////////////////////////////
1:     @After
1:     public void stopDB() {
1:         if (dataSource != null) {
1:             dataSource.stopDB();
1:         }
/////////////////////////////////////////////////////////////////////////
1:         JDBCPersistenceAdapter jdbc = new JDBCPersistenceAdapter();
1:         EmbeddedDataSource embeddedDataSource = (EmbeddedDataSource) jdbc.getDataSource();
/////////////////////////////////////////////////////////////////////////
1:         public void restartDB() throws Exception {
1:             EmbeddedDataSource newDatasource =
1:                     (EmbeddedDataSource) DataSourceServiceSupport.createDataSource(broker.getDataDirectoryFile().getCanonicalPath());
1:             LOG.info("***DB is being shutdown...");
0:             DataSourceServiceSupport.shutdownDefaultDataSource(realDatasource);
commit:113a381
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertTrue;
1: import static org.junit.Assert.fail;
commit:c6837ac
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.IOHelper;
1: import org.junit.Before;
1: import org.junit.Test;
1: 
0: import static junit.framework.Assert.assertTrue;
0: import static junit.framework.Assert.fail;
1: 
1: public class JDBCIOExceptionHandlerTest {
/////////////////////////////////////////////////////////////////////////
0:     @Before
0:     public void dbHomeSysProp() throws Exception {
0:         System.setProperty("derby.system.home", new File(IOHelper.getDefaultDataDirectory()).getCanonicalPath());
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     @Test
1:     @Test
commit:c28d520
/////////////////////////////////////////////////////////////////////////
0:     private static final String DATABASE_NAME = "DERBY_OVERRIDE";
/////////////////////////////////////////////////////////////////////////
0:         embeddedDataSource.setDatabaseName(DATABASE_NAME);
/////////////////////////////////////////////////////////////////////////
1:             Wait.waitFor(new Wait.Condition() {
1:                 @Override
1:                 public boolean isSatisified() throws Exception {
1:                     LOG.debug("*** checking connector to start...");
1:                     try {
1:                         checkTransportConnectorStarted();
1:                         return true;
1:                     } catch (Throwable t) {
1:                         LOG.debug(t.toString());
1:                     }
1:                     return false;
1:                 }
1:             });
/////////////////////////////////////////////////////////////////////////
0:             newDatasource.setDatabaseName(DATABASE_NAME);
commit:e16815a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.LeaseLockerIOExceptionHandler;
/////////////////////////////////////////////////////////////////////////
1:         LeaseLockerIOExceptionHandler ioExceptionHandler = new LeaseLockerIOExceptionHandler();
1:         ioExceptionHandler.setResumeCheckSleepPeriod(1000l);
1:         ioExceptionHandler.setStopStartConnectors(startStopConnectors);
1:         broker.setIoExceptionHandler(ioExceptionHandler);
/////////////////////////////////////////////////////////////////////////
1:                     LeaseLockerIOExceptionHandler ioExceptionHandler = new LeaseLockerIOExceptionHandler();
1:                     ioExceptionHandler.setResumeCheckSleepPeriod(1000l);
1:                     ioExceptionHandler.setStopStartConnectors(false);
1:                     broker.setIoExceptionHandler(ioExceptionHandler);
author:Gary Tully
-------------------------------------------------------------------------------
commit:13bbe52
/////////////////////////////////////////////////////////////////////////
0:         JDBCIOExceptionHandler jdbcioExceptionHandler = new JDBCIOExceptionHandler();
0:         jdbcioExceptionHandler.setResumeCheckSleepPeriod(1000l);
0:         broker.setIoExceptionHandler(jdbcioExceptionHandler);
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ddbe83a
/////////////////////////////////////////////////////////////////////////
commit:539a5f1
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.store.jdbc;
1: 
1: import java.io.PrintWriter;
1: import java.sql.SQLException;
1: import java.sql.SQLFeatureNotSupportedException;
1: import java.util.concurrent.TimeUnit;
1: 
1: import javax.jms.Connection;
1: 
0: import junit.framework.TestCase;
1: 
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.derby.jdbc.EmbeddedDataSource;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * Test to see if the JDBCExceptionIOHandler will restart the transport connectors correctly after
1:  * the underlying DB has been stopped and restarted
1:  *
1:  * see AMQ-4575
1:  */
0: public class JDBCIOExceptionHandlerTest extends TestCase {
1: 
1:     private static final Logger LOG = LoggerFactory.getLogger(JDBCIOExceptionHandlerTest.class);
1:     private static final String TRANSPORT_URL = "tcp://0.0.0.0:0";
1: 
1:     private ActiveMQConnectionFactory factory;
1:     private ReconnectingEmbeddedDataSource dataSource;
1:     private BrokerService broker;
1: 
1:     protected BrokerService createBroker(boolean withJMX) throws Exception {
1:         BrokerService broker = new BrokerService();
1: 
1:         broker.setUseJmx(withJMX);
1: 
0:         EmbeddedDataSource embeddedDataSource = new EmbeddedDataSource();
0:         embeddedDataSource.setDatabaseName("derbydb_15");
0:         embeddedDataSource.setCreateDatabase("create");
1: 
1:         // create a wrapper to EmbeddedDataSource to allow the connection be
1:         // reestablished to derby db
0:         dataSource = new ReconnectingEmbeddedDataSource(embeddedDataSource);
1: 
0:         JDBCPersistenceAdapter jdbc = new JDBCPersistenceAdapter();
1:         jdbc.setDataSource(dataSource);
1: 
1:         jdbc.setLockKeepAlivePeriod(1000l);
0:         LeaseDatabaseLocker leaseDatabaseLocker = new LeaseDatabaseLocker();
0:         leaseDatabaseLocker.setLockAcquireSleepInterval(2000l);
0:         jdbc.setLocker(leaseDatabaseLocker);
1: 
1:         broker.setPersistenceAdapter(jdbc);
0:         broker.setIoExceptionHandler(new JDBCIOExceptionHandler());
1:         String connectionUri = broker.addConnector(TRANSPORT_URL).getPublishableConnectString();
1: 
1:         factory = new ActiveMQConnectionFactory(connectionUri);
1: 
1:         return broker;
1:     }
1: 
1:     /*
1:      * run test without JMX enabled
1:      */
1:     public void testRecoverWithOutJMX() throws Exception {
1:         recoverFromDisconnectDB(false);
1:     }
1: 
1:     /*
1:      * run test with JMX enabled
1:      */
1:     public void testRecoverWithJMX() throws Exception {
1:         recoverFromDisconnectDB(true);
1:     }
1: 
1:     public void recoverFromDisconnectDB(boolean withJMX) throws Exception {
1:         try {
1:             broker = createBroker(withJMX);
1:             broker.start();
1:             broker.waitUntilStarted();
1: 
1:             // broker started - stop db underneath it
1:             dataSource.stopDB();
1: 
1:             // wait - allow the leaselocker to kick the JDBCIOExceptionHandler
1:             TimeUnit.SECONDS.sleep(3);
1: 
1:             // check connector has shutdown
1:             checkTransportConnectorStopped();
1: 
1:             // restart db underneath
1:             dataSource.restartDB();
1: 
0:             // give the transport connector a moment to start
0:             LOG.debug("*** Waiting for connector to start...");
1:             TimeUnit.SECONDS.sleep(3);
1: 
0:             LOG.debug("*** checking connector to start...");
0:             // check the connector has restarted
0:             checkTransportConnectorStarted();
1: 
1:         } finally {
1:             LOG.debug("*** broker is stopping...");
1:             broker.stop();
1:         }
1:     }
1: 
1:     private void checkTransportConnectorStopped() {
1:         // connection is expected to fail
1:         try {
1:             factory.createConnection();
1:             fail("Transport connector should be stopped");
1:         } catch (Exception ex) {
1:             // expected an exception
1:             LOG.debug(" checkTransportConnectorStopped() threw", ex);
1:         }
1:     }
1: 
1:     private void checkTransportConnectorStarted() {
1:         // connection is expected to succeed
1:         try {
1:             Connection conn = factory.createConnection();
1:             conn.close();
1:         } catch (Exception ex) {
1:             LOG.debug("checkTransportConnectorStarted() threw", ex);
1:             fail("Transport connector should have been started");
1:         }
1:     }
1: 
1:     /*
1:      * Wrapped the derby datasource object to get DB reconnect functionality as I not
1:      * manage to get that working directly on the EmbeddedDataSource
1:      *
0:      * NOTE: Not a thread Safe but for this unit test it should be fine
1:      */
1:     public class ReconnectingEmbeddedDataSource implements javax.sql.DataSource {
1: 
0:         private EmbeddedDataSource realDatasource;
1: 
0:         public ReconnectingEmbeddedDataSource(EmbeddedDataSource datasource) {
1:             this.realDatasource = datasource;
1:         }
1: 
1:         @Override
1:         public PrintWriter getLogWriter() throws SQLException {
1:             return this.realDatasource.getLogWriter();
1:         }
1: 
1:         @Override
1:         public void setLogWriter(PrintWriter out) throws SQLException {
1:             this.realDatasource.setLogWriter(out);
1: 
1:         }
1: 
1:         @Override
1:         public void setLoginTimeout(int seconds) throws SQLException {
1:             this.realDatasource.setLoginTimeout(seconds);
1:         }
1: 
1:         @Override
1:         public int getLoginTimeout() throws SQLException {
1:             return this.realDatasource.getLoginTimeout();
1:         }
1: 
1:         @Override
1:         public <T> T unwrap(Class<T> iface) throws SQLException {
1:             return this.unwrap(iface);
1:         }
1: 
1:         @Override
1:         public boolean isWrapperFor(Class<?> iface) throws SQLException {
1:             return this.isWrapperFor(iface);
1:         }
1: 
1:         @Override
1:         public java.sql.Connection getConnection() throws SQLException {
1:             return this.realDatasource.getConnection();
1:         }
1: 
1:         @Override
1:         public java.sql.Connection getConnection(String username, String password) throws SQLException {
1:             return this.getConnection(username, password);
1:         }
1: 
1:         /**
1:          *
1:          * To simulate a db reconnect I just create a new EmbeddedDataSource .
1:          *
1:          * @throws SQLException
1:          */
0:         public void restartDB() throws SQLException {
0:             EmbeddedDataSource newDatasource = new EmbeddedDataSource();
0:             newDatasource.setDatabaseName(this.realDatasource.getDatabaseName());
1:             newDatasource.getConnection();
1:             LOG.info("*** DB restarted now...");
0:             this.realDatasource = newDatasource;
1:         }
1: 
1:         public void stopDB() {
1:             try {
0:                 realDatasource.setShutdownDatabase("shutdown");
0:                 LOG.info("***DB is being shutdown...");
0:                 dataSource.getConnection();
0:                 fail("should have thrown a db closed exception");
1:             } catch (Exception ex) {
0:                 ex.printStackTrace(System.out);
1:             }
1:         }
1: 
1:         @Override
1:         public java.util.logging.Logger getParentLogger() throws SQLFeatureNotSupportedException {
1:             return null;
1:         }
1:     }
1: }
============================================================================