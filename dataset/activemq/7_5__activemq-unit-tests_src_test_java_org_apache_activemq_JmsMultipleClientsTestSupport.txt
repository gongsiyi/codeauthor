1:a107823: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
3:a107823:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:a107823:  *
1:a107823:  * Unless required by applicable law or agreed to in writing, software
1:a107823:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a107823:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a107823:  * See the License for the specific language governing permissions and
1:a107823:  * limitations under the License.
1:a107823:  */
1:a107823: package org.apache.activemq;
7:a107823: 
1:230a86c: import java.net.URI;
1:230a86c: import java.util.ArrayList;
1:230a86c: import java.util.Arrays;
1:230a86c: import java.util.Collections;
1:230a86c: import java.util.HashMap;
1:230a86c: import java.util.Iterator;
1:230a86c: import java.util.List;
1:230a86c: import java.util.Map;
1:230a86c: import java.util.concurrent.atomic.AtomicInteger;
1:230a86c: 
1:230a86c: import javax.jms.Connection;
1:230a86c: import javax.jms.ConnectionFactory;
1:230a86c: import javax.jms.DeliveryMode;
1:230a86c: import javax.jms.Destination;
1:230a86c: import javax.jms.JMSException;
1:230a86c: import javax.jms.MessageConsumer;
1:230a86c: import javax.jms.MessageProducer;
1:230a86c: import javax.jms.Session;
1:230a86c: import javax.jms.TextMessage;
1:230a86c: import javax.jms.TopicSubscriber;
1:230a86c: 
1:230a86c: import org.apache.activemq.broker.BrokerFactory;
1:230a86c: import org.apache.activemq.broker.BrokerService;
1:a107823: import org.apache.activemq.command.ActiveMQDestination;
1:a107823: import org.apache.activemq.command.ActiveMQQueue;
1:a107823: import org.apache.activemq.command.ActiveMQTopic;
1:a107823: import org.apache.activemq.util.MessageIdList;
1:bec711c: import org.junit.After;
1:bec711c: import org.junit.Before;
1:bec711c: import org.junit.Rule;
1:bec711c: import org.junit.rules.TestName;
1:bec711c: import org.slf4j.Logger;
1:bec711c: import org.slf4j.LoggerFactory;
1:bec711c: 
1:bec711c: import static org.junit.Assert.*;
1:a107823: 
1:a107823: /**
1:230a86c:  * Test case support used to test multiple message comsumers and message
1:230a86c:  * producers connecting to a single broker.
1:b0c2a40:  * 
1:a107823:  * 
1:a107823:  */
1:bec711c: public class JmsMultipleClientsTestSupport {
1:bec711c: 
1:bec711c:     @Rule
1:bec711c:     public TestName testName = new TestName();
1:bec711c: 
1:bec711c:     protected static final Logger LOG = LoggerFactory.getLogger(JmsMultipleClientsTestSupport.class);
1:a107823: 
1:933eb2f:     protected Map<MessageConsumer, MessageIdList> consumers = new HashMap<MessageConsumer, MessageIdList>(); // Map of consumer with messages
1:230a86c:                                                 // received
1:a107823:     protected int consumerCount = 1;
1:a107823:     protected int producerCount = 1;
1:a107823: 
1:230a86c:     protected int messageSize = 1024;
1:a107823: 
1:a107823:     protected boolean useConcurrentSend = true;
1:1b9e94f:     protected boolean autoFail = true;
1:230a86c:     protected boolean durable;
1:1b6d397:     public boolean topic;
1:230a86c:     protected boolean persistent;
1:a107823: 
1:a107823:     protected BrokerService broker;
1:a107823:     protected Destination destination;
1:933eb2f:     protected List<Connection> connections = Collections.synchronizedList(new ArrayList<Connection>());
1:a107823:     protected MessageIdList allMessagesList = new MessageIdList();
1:a107823: 
1:933eb2f:     private AtomicInteger producerLock;
1:933eb2f: 
1:a107823:     protected void startProducers(Destination dest, int msgCount) throws Exception {
1:a107823:         startProducers(createConnectionFactory(), dest, msgCount);
1:a107823:     }
1:a107823: 
1:a107823:     protected void startProducers(final ConnectionFactory factory, final Destination dest, final int msgCount) throws Exception {
1:a107823:         // Use concurrent send
1:a107823:         if (useConcurrentSend) {
1:a107823:             producerLock = new AtomicInteger(producerCount);
1:a107823: 
1:230a86c:             for (int i = 0; i < producerCount; i++) {
1:a107823:                 Thread t = new Thread(new Runnable() {
1:a107823:                     public void run() {
1:a107823:                         try {
1:a107823:                             sendMessages(factory.createConnection(), dest, msgCount);
1:a107823:                         } catch (Exception e) {
1:a107823:                             e.printStackTrace();
1:a107823:                         }
1:a107823: 
1:a107823:                         synchronized (producerLock) {
1:a107823:                             producerLock.decrementAndGet();
1:a107823:                             producerLock.notifyAll();
1:a107823:                         }
1:a107823:                     }
1:a107823:                 });
1:a107823: 
1:a107823:                 t.start();
1:a107823:             }
1:a107823: 
1:a107823:             // Wait for all producers to finish sending
1:a107823:             synchronized (producerLock) {
1:a107823:                 while (producerLock.get() != 0) {
1:a107823:                     producerLock.wait(2000);
1:a107823:                 }
1:a107823:             }
1:a107823: 
1:230a86c:             // Use serialized send
1:a107823:         } else {
1:230a86c:             for (int i = 0; i < producerCount; i++) {
1:a107823:                 sendMessages(factory.createConnection(), dest, msgCount);
1:a107823:             }
1:a107823:         }
1:a107823:     }
1:a107823: 
1:a107823:     protected void sendMessages(Connection connection, Destination destination, int count) throws Exception {
1:1b6d397:         connections.add(connection);
1:a107823:         connection.start();
1:a107823: 
1:a107823:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:a107823:         MessageProducer producer = session.createProducer(destination);
1:a107823:         producer.setDeliveryMode(persistent ? DeliveryMode.PERSISTENT : DeliveryMode.NON_PERSISTENT);
1:230a86c: 
1:a107823:         for (int i = 0; i < count; i++) {
1:a107823:             TextMessage msg = createTextMessage(session, "" + i);
1:a107823:             producer.send(msg);
1:a107823:         }
1:a107823: 
1:a107823:         producer.close();
1:a107823:         session.close();
1:a107823:         connection.close();
1:a107823:     }
1:a107823: 
1:a107823:     protected TextMessage createTextMessage(Session session, String initText) throws Exception {
1:a107823:         TextMessage msg = session.createTextMessage();
1:a107823: 
1:a107823:         // Pad message text
1:a107823:         if (initText.length() < messageSize) {
1:a107823:             char[] data = new char[messageSize - initText.length()];
1:a107823:             Arrays.fill(data, '*');
1:a107823:             String str = new String(data);
1:a107823:             msg.setText(initText + str);
1:a107823: 
1:230a86c:             // Do not pad message text
1:a107823:         } else {
1:a107823:             msg.setText(initText);
1:a107823:         }
1:a107823: 
1:a107823:         return msg;
1:a107823:     }
1:a107823: 
1:a107823:     protected void startConsumers(Destination dest) throws Exception {
1:a107823:         startConsumers(createConnectionFactory(), dest);
1:a107823:     }
1:a107823: 
1:a107823:     protected void startConsumers(ConnectionFactory factory, Destination dest) throws Exception {
1:a107823:         MessageConsumer consumer;
1:230a86c:         for (int i = 0; i < consumerCount; i++) {
1:a107823:             if (durable && topic) {
1:230a86c:                 consumer = createDurableSubscriber(factory.createConnection(), dest, "consumer" + (i + 1));
1:a107823:             } else {
1:a107823:                 consumer = createMessageConsumer(factory.createConnection(), dest);
1:a107823:             }
1:a107823:             MessageIdList list = new MessageIdList();
1:a107823:             list.setParent(allMessagesList);
1:a107823:             consumer.setMessageListener(list);
1:a107823:             consumers.put(consumer, list);
1:a107823:         }
1:a107823:     }
1:a107823: 
1:a107823:     protected MessageConsumer createMessageConsumer(Connection conn, Destination dest) throws Exception {
1:a107823:         connections.add(conn);
1:a0d05f8:         conn.start();
1:a107823: 
1:a107823:         Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:a107823:         final MessageConsumer consumer = sess.createConsumer(dest);
1:a107823: 
1:a107823:         return consumer;
1:a107823:     }
1:a107823: 
1:a107823:     protected TopicSubscriber createDurableSubscriber(Connection conn, Destination dest, String name) throws Exception {
1:a107823:         conn.setClientID(name);
1:a107823:         connections.add(conn);
2:a107823:         conn.start();
1:a107823: 
1:a107823:         Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:a107823:         final TopicSubscriber consumer = sess.createDurableSubscriber((javax.jms.Topic)dest, name);
1:a107823: 
1:a107823:         return consumer;
1:a107823:     }
1:a107823: 
1:a107823:     protected void waitForAllMessagesToBeReceived(int messageCount) throws Exception {
1:a107823:         allMessagesList.waitForMessagesToArrive(messageCount);
1:a107823:     }
1:a107823: 
1:a107823:     protected ActiveMQDestination createDestination() throws JMSException {
1:230a86c:         String name = "." + getClass().getName() + "." + getName();
1:1b6d397:         // ensure not inadvertently composite because of combos
1:1b6d397:         name = name.replace(' ','_');
1:1b6d397:         name = name.replace(',','&');
1:a107823:         if (topic) {
1:544ffe9:             destination = new ActiveMQTopic("Topic" + name);
1:a107823:             return (ActiveMQDestination)destination;
1:a107823:         } else {
1:544ffe9:             destination = new ActiveMQQueue("Queue" + name);
1:a107823:             return (ActiveMQDestination)destination;
1:a107823:         }
1:a107823:     }
1:a107823: 
1:a107823:     protected ConnectionFactory createConnectionFactory() throws Exception {
1:a107823:         return new ActiveMQConnectionFactory("vm://localhost");
1:a107823:     }
1:a107823: 
1:a107823:     protected BrokerService createBroker() throws Exception {
1:a107823:         return BrokerFactory.createBroker(new URI("broker://()/localhost?persistent=false&useJmx=true"));
1:a107823:     }
1:a107823: 
1:bec711c:     @Before
1:bec711c:     public void setUp() throws Exception {
1:a107823:         broker = createBroker();
1:a107823:         broker.start();
1:a107823:     }
1:a107823: 
1:bec711c:     @After
1:bec711c:     public void tearDown() throws Exception {
1:933eb2f:         for (Iterator<Connection> iter = connections.iterator(); iter.hasNext();) {
1:933eb2f:             Connection conn = iter.next();
1:a107823:             try {
1:a107823:                 conn.close();
1:a107823:             } catch (Throwable e) {
1:a107823:             }
1:a107823:         }
1:bec711c:         if (broker !=null ) { // FIXME remove
1:a107823:         broker.stop();
1:a107823:         allMessagesList.flushMessages();
1:a107823:         consumers.clear();
1:bec711c:         }
1:a107823:     }
1:a107823: 
1:a107823:     /*
1:a107823:      * Some helpful assertions for multiple consumers.
1:a107823:      */
1:a107823:     protected void assertConsumerReceivedAtLeastXMessages(MessageConsumer consumer, int msgCount) {
1:933eb2f:         MessageIdList messageIdList = consumers.get(consumer);
1:a107823:         messageIdList.assertAtLeastMessagesReceived(msgCount);
1:a107823:     }
1:a107823: 
1:a107823:     protected void assertConsumerReceivedAtMostXMessages(MessageConsumer consumer, int msgCount) {
1:933eb2f:         MessageIdList messageIdList = consumers.get(consumer);
1:a107823:         messageIdList.assertAtMostMessagesReceived(msgCount);
1:a107823:     }
1:a107823: 
1:a107823:     protected void assertConsumerReceivedXMessages(MessageConsumer consumer, int msgCount) {
1:933eb2f:         MessageIdList messageIdList = consumers.get(consumer);
1:a107823:         messageIdList.assertMessagesReceivedNoWait(msgCount);
1:a107823:     }
1:a107823: 
1:a107823:     protected void assertEachConsumerReceivedAtLeastXMessages(int msgCount) {
1:933eb2f:         for (Iterator<MessageConsumer> i = consumers.keySet().iterator(); i.hasNext();) {
1:933eb2f:             assertConsumerReceivedAtLeastXMessages(i.next(), msgCount);
1:a107823:         }
1:a107823:     }
1:a107823: 
1:a107823:     protected void assertEachConsumerReceivedAtMostXMessages(int msgCount) {
1:933eb2f:         for (Iterator<MessageConsumer> i = consumers.keySet().iterator(); i.hasNext();) {
1:933eb2f:             assertConsumerReceivedAtMostXMessages(i.next(), msgCount);
1:a107823:         }
1:a107823:     }
1:a107823: 
1:a107823:     protected void assertEachConsumerReceivedXMessages(int msgCount) {
1:933eb2f:         for (Iterator<MessageConsumer> i = consumers.keySet().iterator(); i.hasNext();) {
1:933eb2f:             assertConsumerReceivedXMessages(i.next(), msgCount);
1:a107823:         }
1:a107823:     }
1:a107823: 
1:a107823:     protected void assertTotalMessagesReceived(int msgCount) {
1:a107823:         allMessagesList.assertMessagesReceivedNoWait(msgCount);
1:230a86c: 
1:230a86c:         // now lets count the individual messages received
1:a107823:         int totalMsg = 0;
1:933eb2f:         for (Iterator<MessageConsumer> i = consumers.keySet().iterator(); i.hasNext();) {
1:933eb2f:             MessageIdList messageIdList = consumers.get(i.next());
1:a107823:             totalMsg += messageIdList.getMessageCount();
1:a107823:         }
1:a107823:         assertEquals("Total of consumers message count", msgCount, totalMsg);
1:a107823:     }
1:bec711c: 
1:bec711c: 
1:bec711c:     public String getName() {
1:bec711c:         return getName(false);
1:bec711c:     }
1:bec711c: 
1:bec711c:     public String getName(boolean original) {
1:bec711c:         String currentTestName = testName.getMethodName();
1:bec711c:         currentTestName = currentTestName.replace("[","");
1:bec711c:         currentTestName = currentTestName.replace("]","");
1:bec711c:         return currentTestName;
1:bec711c:     }
1:bec711c: 
1:ad1f751:     public void assertDestinationMemoryUsageGoesToZero() throws Exception {
1:ad1f751:         assertEquals("destination memory is back to 0", 0,
1:ad1f751:                 TestSupport.getDestination(broker, ActiveMQDestination.transform(destination)).getMemoryUsage().getPercentUsage());
1:ad1f751:     }
1:ad1f751: 
1:ad1f751: 
1:bec711c: 
1:bec711c:     /*
1:bec711c:      * This is copied from AutoFailTestSupport.  We may want to move it to someplace where more
1:bec711c:      * tests can use it.
1:bec711c:      */
1:bec711c:     public static void dumpAllThreads(String prefix) {
1:bec711c:         Map<Thread, StackTraceElement[]> stacks = Thread.getAllStackTraces();
1:bec711c:         for (Map.Entry<Thread, StackTraceElement[]> stackEntry : stacks.entrySet()) {
1:bec711c:             System.err.println(prefix + " " + stackEntry.getKey());
1:bec711c:             for(StackTraceElement element : stackEntry.getValue()) {
1:bec711c:                 System.err.println("     " + element);
1:bec711c:             }
1:bec711c:         }
1:bec711c:     }
1:a107823: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:a0d05f8
/////////////////////////////////////////////////////////////////////////
1:         conn.start();
commit:ad1f751
/////////////////////////////////////////////////////////////////////////
1:     public void assertDestinationMemoryUsageGoesToZero() throws Exception {
1:         assertEquals("destination memory is back to 0", 0,
1:                 TestSupport.getDestination(broker, ActiveMQDestination.transform(destination)).getMemoryUsage().getPercentUsage());
1:     }
1: 
1: 
author:Kevin Earls
-------------------------------------------------------------------------------
commit:bec711c
/////////////////////////////////////////////////////////////////////////
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Rule;
1: import org.junit.rules.TestName;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: import static org.junit.Assert.*;
/////////////////////////////////////////////////////////////////////////
1: public class JmsMultipleClientsTestSupport {
1: 
1:     @Rule
1:     public TestName testName = new TestName();
1: 
1:     protected static final Logger LOG = LoggerFactory.getLogger(JmsMultipleClientsTestSupport.class);
/////////////////////////////////////////////////////////////////////////
1:     @Before
1:     public void setUp() throws Exception {
1:     @After
1:     public void tearDown() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         if (broker !=null ) { // FIXME remove
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     public String getName() {
1:         return getName(false);
1:     }
1: 
1:     public String getName(boolean original) {
1:         String currentTestName = testName.getMethodName();
1:         currentTestName = currentTestName.replace("[","");
1:         currentTestName = currentTestName.replace("]","");
1:         return currentTestName;
1:     }
1: 
1: 
1:     /*
1:      * This is copied from AutoFailTestSupport.  We may want to move it to someplace where more
1:      * tests can use it.
1:      */
1:     public static void dumpAllThreads(String prefix) {
1:         Map<Thread, StackTraceElement[]> stacks = Thread.getAllStackTraces();
1:         for (Map.Entry<Thread, StackTraceElement[]> stackEntry : stacks.entrySet()) {
1:             System.err.println(prefix + " " + stackEntry.getKey());
1:             for(StackTraceElement element : stackEntry.getValue()) {
1:                 System.err.println("     " + element);
1:             }
1:         }
1:     }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
1:     protected Map<MessageConsumer, MessageIdList> consumers = new HashMap<MessageConsumer, MessageIdList>(); // Map of consumer with messages
/////////////////////////////////////////////////////////////////////////
1:     protected List<Connection> connections = Collections.synchronizedList(new ArrayList<Connection>());
1:     private AtomicInteger producerLock;
1: 
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<Connection> iter = connections.iterator(); iter.hasNext();) {
1:             Connection conn = iter.next();
/////////////////////////////////////////////////////////////////////////
1:         MessageIdList messageIdList = consumers.get(consumer);
1:         MessageIdList messageIdList = consumers.get(consumer);
1:         MessageIdList messageIdList = consumers.get(consumer);
1:         for (Iterator<MessageConsumer> i = consumers.keySet().iterator(); i.hasNext();) {
1:             assertConsumerReceivedAtLeastXMessages(i.next(), msgCount);
1:         for (Iterator<MessageConsumer> i = consumers.keySet().iterator(); i.hasNext();) {
1:             assertConsumerReceivedAtMostXMessages(i.next(), msgCount);
1:         for (Iterator<MessageConsumer> i = consumers.keySet().iterator(); i.hasNext();) {
1:             assertConsumerReceivedXMessages(i.next(), msgCount);
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<MessageConsumer> i = consumers.keySet().iterator(); i.hasNext();) {
1:             MessageIdList messageIdList = consumers.get(i.next());
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
1: import java.net.URI;
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Collections;
1: import java.util.HashMap;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.concurrent.atomic.AtomicInteger;
1: 
1: import javax.jms.Connection;
1: import javax.jms.ConnectionFactory;
1: import javax.jms.DeliveryMode;
1: import javax.jms.Destination;
1: import javax.jms.JMSException;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
1: import javax.jms.TopicSubscriber;
1: 
1: import org.apache.activemq.broker.BrokerFactory;
1: import org.apache.activemq.broker.BrokerService;
1:  * Test case support used to test multiple message comsumers and message
1:  * producers connecting to a single broker.
0:     protected Map consumers = new HashMap(); // Map of consumer with messages
1:                                                 // received
1:     protected int messageSize = 1024;
1:     protected boolean durable;
0:     protected boolean topic;
1:     protected boolean persistent;
/////////////////////////////////////////////////////////////////////////
1:             for (int i = 0; i < producerCount; i++) {
/////////////////////////////////////////////////////////////////////////
1:             // Use serialized send
1:             for (int i = 0; i < producerCount; i++) {
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             // Do not pad message text
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < consumerCount; i++) {
1:                 consumer = createDurableSubscriber(factory.createConnection(), dest, "consumer" + (i + 1));
/////////////////////////////////////////////////////////////////////////
1:         String name = "." + getClass().getName() + "." + getName();
/////////////////////////////////////////////////////////////////////////
0:             Connection conn = (Connection)iter.next();
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator i = consumers.keySet().iterator(); i.hasNext();) {
0:         for (Iterator i = consumers.keySet().iterator(); i.hasNext();) {
0:         for (Iterator i = consumers.keySet().iterator(); i.hasNext();) {
1: 
1:         // now lets count the individual messages received
0:         for (Iterator i = consumers.keySet().iterator(); i.hasNext();) {
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicInteger;
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:a107823
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq;
1: 
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.util.MessageIdList;
0: import org.apache.activemq.broker.BrokerService;
0: import org.apache.activemq.broker.BrokerFactory;
1: 
0: import java.util.List;
0: import java.util.ArrayList;
0: import java.util.Map;
0: import java.util.HashMap;
0: import java.util.Iterator;
0: import java.util.Arrays;
0: import java.util.Collections;
0: import java.net.URI;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicInteger;
1: 
0: import javax.jms.*;
1: 
1: /**
0:  * Test case support used to test multiple message comsumers and message producers connecting to a single broker.
1:  * 
0:  * @version $Revision$
1:  */
0: public class JmsMultipleClientsTestSupport extends CombinationTestSupport {
0:     private AtomicInteger producerLock;
1: 
0:     protected Map consumers = new HashMap(); // Map of consumer with messages received
1:     protected int consumerCount = 1;
1:     protected int producerCount = 1;
1: 
0:     protected int messageSize  = 1024;
1: 
1:     protected boolean useConcurrentSend = true;
0:     protected boolean durable = false;
0:     protected boolean topic = false;
0:     protected boolean persistent = false;
1: 
1:     protected BrokerService broker;
1:     protected Destination destination;
0:     protected List connections = Collections.synchronizedList(new ArrayList());
1:     protected MessageIdList allMessagesList = new MessageIdList();
1: 
1:     protected void startProducers(Destination dest, int msgCount) throws Exception {
1:         startProducers(createConnectionFactory(), dest, msgCount);
1:     }
1: 
1:     protected void startProducers(final ConnectionFactory factory, final Destination dest, final int msgCount) throws Exception {
1:         // Use concurrent send
1:         if (useConcurrentSend) {
1:             producerLock = new AtomicInteger(producerCount);
1: 
0:             for (int i=0; i<producerCount; i++) {
1:                 Thread t = new Thread(new Runnable() {
1:                     public void run() {
1:                         try {
1:                             sendMessages(factory.createConnection(), dest, msgCount);
1:                         } catch (Exception e) {
1:                             e.printStackTrace();
1:                         }
1: 
1:                         synchronized (producerLock) {
1:                             producerLock.decrementAndGet();
1:                             producerLock.notifyAll();
1:                         }
1:                     }
1:                 });
1: 
1:                 t.start();
1:             }
1: 
1:             // Wait for all producers to finish sending
1:             synchronized (producerLock) {
1:                 while (producerLock.get() != 0) {
1:                     producerLock.wait(2000);
1:                 }
1:             }
1: 
1: 
0:         // Use serialized send
1:         } else {
0:             for (int i=0; i<producerCount; i++) {
1:                 sendMessages(factory.createConnection(), dest, msgCount);
1:             }
1:         }
1:     }
1: 
1:     protected void sendMessages(Connection connection, Destination destination, int count) throws Exception {
1:         connection.start();
1: 
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageProducer producer = session.createProducer(destination);
1:         producer.setDeliveryMode(persistent ? DeliveryMode.PERSISTENT : DeliveryMode.NON_PERSISTENT);
1:         
1:         for (int i = 0; i < count; i++) {
1:             TextMessage msg = createTextMessage(session, "" + i);
1:             producer.send(msg);
1:         }
1: 
1:         producer.close();
1:         session.close();
1:         connection.close();
1:     }
1: 
1:     protected TextMessage createTextMessage(Session session, String initText) throws Exception {
1:         TextMessage msg = session.createTextMessage();
1: 
1:         // Pad message text
1:         if (initText.length() < messageSize) {
1:             char[] data = new char[messageSize - initText.length()];
1:             Arrays.fill(data, '*');
1:             String str = new String(data);
1:             msg.setText(initText + str);
1: 
0:         // Do not pad message text
1:         } else {
1:             msg.setText(initText);
1:         }
1: 
1:         return msg;
1:     }
1: 
1:     protected void startConsumers(Destination dest) throws Exception {
1:         startConsumers(createConnectionFactory(), dest);
1:     }
1: 
1:     protected void startConsumers(ConnectionFactory factory, Destination dest) throws Exception {
1:         MessageConsumer consumer;
0:         for (int i=0; i<consumerCount; i++) {
1:             if (durable && topic) {
0:                 consumer = createDurableSubscriber(factory.createConnection(), dest, "consumer" + (i+1));
1:             } else {
1:                 consumer = createMessageConsumer(factory.createConnection(), dest);
1:             }
1:             MessageIdList list = new MessageIdList();
1:             list.setParent(allMessagesList);
1:             consumer.setMessageListener(list);
1:             consumers.put(consumer, list);
1:         }
1:     }
1: 
1:     protected MessageConsumer createMessageConsumer(Connection conn, Destination dest) throws Exception {
1:         connections.add(conn);
1: 
1:         Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         final MessageConsumer consumer = sess.createConsumer(dest);
1:         conn.start();
1: 
1:         return consumer;
1:     }
1: 
1:     protected TopicSubscriber createDurableSubscriber(Connection conn, Destination dest, String name) throws Exception {
1:         conn.setClientID(name);
1:         connections.add(conn);
1:         conn.start();
1: 
1:         Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         final TopicSubscriber consumer = sess.createDurableSubscriber((javax.jms.Topic)dest, name);
1: 
1:         return consumer;
1:     }
1: 
1:     protected void waitForAllMessagesToBeReceived(int messageCount) throws Exception {
1:         allMessagesList.waitForMessagesToArrive(messageCount);
1:     }
1: 
1:     protected ActiveMQDestination createDestination() throws JMSException {
1:         if (topic) {
0:             destination = new ActiveMQTopic("Topic");
1:             return (ActiveMQDestination)destination;
1:         } else {
0:             destination = new ActiveMQQueue("Queue");
1:             return (ActiveMQDestination)destination;
1:         }
1:     }
1: 
1:     protected ConnectionFactory createConnectionFactory() throws Exception {
1:         return new ActiveMQConnectionFactory("vm://localhost");
1:     }
1: 
1:     protected BrokerService createBroker() throws Exception {
1:         return BrokerFactory.createBroker(new URI("broker://()/localhost?persistent=false&useJmx=true"));
1:     }
1: 
0:     protected void setUp() throws Exception {
0:         super.setAutoFail(true);
0:         super.setUp();
1:         broker = createBroker();
1:         broker.start();
1:     }
1: 
0:     protected void tearDown() throws Exception {
0:         for (Iterator iter = connections.iterator(); iter.hasNext();) {
0:             Connection conn= (Connection) iter.next();
1:             try {
1:                 conn.close();
1:             } catch (Throwable e) {
1:             }
1:         }
1:         broker.stop();
1:         allMessagesList.flushMessages();
1:         consumers.clear();
0:         super.tearDown();
1:     }
1: 
1:     /*
1:      * Some helpful assertions for multiple consumers.
1:      */
1:     protected void assertConsumerReceivedAtLeastXMessages(MessageConsumer consumer, int msgCount) {
0:         MessageIdList messageIdList = (MessageIdList)consumers.get(consumer);
1:         messageIdList.assertAtLeastMessagesReceived(msgCount);
1:     }
1: 
1:     protected void assertConsumerReceivedAtMostXMessages(MessageConsumer consumer, int msgCount) {
0:         MessageIdList messageIdList = (MessageIdList)consumers.get(consumer);
1:         messageIdList.assertAtMostMessagesReceived(msgCount);
1:     }
1: 
1:     protected void assertConsumerReceivedXMessages(MessageConsumer consumer, int msgCount) {
0:         MessageIdList messageIdList = (MessageIdList)consumers.get(consumer);
1:         messageIdList.assertMessagesReceivedNoWait(msgCount);
1:     }
1: 
1:     protected void assertEachConsumerReceivedAtLeastXMessages(int msgCount) {
0:         for (Iterator i=consumers.keySet().iterator();i.hasNext();) {
0:             assertConsumerReceivedAtLeastXMessages((MessageConsumer)i.next(), msgCount);
1:         }
1:     }
1: 
1:     protected void assertEachConsumerReceivedAtMostXMessages(int msgCount) {
0:         for (Iterator i=consumers.keySet().iterator();i.hasNext();) {
0:             assertConsumerReceivedAtMostXMessages((MessageConsumer)i.next(), msgCount);
1:         }
1:     }
1: 
1:     protected void assertEachConsumerReceivedXMessages(int msgCount) {
0:         for (Iterator i=consumers.keySet().iterator();i.hasNext();) {
0:             assertConsumerReceivedXMessages((MessageConsumer)i.next(), msgCount);
1:         }
1:     }
1: 
1:     protected void assertTotalMessagesReceived(int msgCount) {
1:         allMessagesList.assertMessagesReceivedNoWait(msgCount);
1:         
0:         // now lets count the individual messages received 
1:         int totalMsg = 0;
0:         for (Iterator i=consumers.keySet().iterator(); i.hasNext();) {
0:             MessageIdList messageIdList = (MessageIdList)consumers.get(i.next());
1:             totalMsg += messageIdList.getMessageCount();
1:         }
1:         assertEquals("Total of consumers message count", msgCount, totalMsg);
1:     }
1: }
commit:3516e10
/////////////////////////////////////////////////////////////////////////
0:         allMessagesList.flushMessages();
0:         consumers.clear();
commit:3d95025
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.MessageIdList;
/////////////////////////////////////////////////////////////////////////
0:     protected boolean persistent = false;
0:     protected MessageIdList allMessagesList = new MessageIdList();
/////////////////////////////////////////////////////////////////////////
0:         producer.setDeliveryMode(persistent ? DeliveryMode.PERSISTENT : DeliveryMode.NON_PERSISTENT);
0:         
/////////////////////////////////////////////////////////////////////////
0:             MessageIdList list = new MessageIdList();
/////////////////////////////////////////////////////////////////////////
0:         MessageIdList messageIdList = (MessageIdList)consumers.get(consumer);
0:         messageIdList.assertAtLeastMessagesReceived(msgCount);
0:         MessageIdList messageIdList = (MessageIdList)consumers.get(consumer);
0:         messageIdList.assertAtMostMessagesReceived(msgCount);
0:         MessageIdList messageIdList = (MessageIdList)consumers.get(consumer);
0:         messageIdList.assertMessagesReceivedNoWait(msgCount);
/////////////////////////////////////////////////////////////////////////
0:             MessageIdList messageIdList = (MessageIdList)consumers.get(i.next());
0:             totalMsg += messageIdList.getMessageCount();
commit:4759253
/////////////////////////////////////////////////////////////////////////
0:         return BrokerFactory.createBroker(new URI("broker://()/localhost?persistent=false&useJmx=true"));
author:Gary Tully
-------------------------------------------------------------------------------
commit:1b9e94f
/////////////////////////////////////////////////////////////////////////
1:     protected boolean autoFail = true;
/////////////////////////////////////////////////////////////////////////
0:         super.setAutoFail(autoFail);
commit:1b6d397
/////////////////////////////////////////////////////////////////////////
1:     public boolean topic;
/////////////////////////////////////////////////////////////////////////
1:         connections.add(connection);
/////////////////////////////////////////////////////////////////////////
1:         // ensure not inadvertently composite because of combos
1:         name = name.replace(' ','_');
1:         name = name.replace(',','&');
author:James Strachan
-------------------------------------------------------------------------------
commit:544ffe9
/////////////////////////////////////////////////////////////////////////
0:         String name =  "." + getClass().getName() + "." + getName();
1:             destination = new ActiveMQTopic("Topic" + name);
1:             destination = new ActiveMQQueue("Queue" + name);
commit:f1dc477
/////////////////////////////////////////////////////////////////////////
0:                     producerLock.wait(2000);
/////////////////////////////////////////////////////////////////////////
0:         conn.start();
0:     protected void waitForAllMessagesToBeReceived(int messageCount) throws Exception {
0:         allMessagesList.waitForMessagesToArrive(messageCount);
/////////////////////////////////////////////////////////////////////////
0:         messageList.assertMessagesReceivedNoWait(msgCount);
/////////////////////////////////////////////////////////////////////////
0:         allMessagesList.assertMessagesReceivedNoWait(msgCount);
commit:b49256b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.MessageList;
/////////////////////////////////////////////////////////////////////////
0:     protected MessageList allMessagesList = new MessageList();
/////////////////////////////////////////////////////////////////////////
0:             MessageList list = new MessageList();
0:             list.setParent(allMessagesList);
0:             consumer.setMessageListener(list);
0:             consumers.put(consumer, list);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         //Thread.sleep(timeout);
/////////////////////////////////////////////////////////////////////////
0:         MessageList messageList = (MessageList)consumers.get(consumer);
0:         messageList.assertAtLeastMessagesReceived(msgCount);
0:         MessageList messageList = (MessageList)consumers.get(consumer);
0:         messageList.assertAtMostMessagesReceived(msgCount);
0:         MessageList messageList = (MessageList)consumers.get(consumer);
0:         messageList.assertMessagesReceived(msgCount);
/////////////////////////////////////////////////////////////////////////
0:         allMessagesList.assertMessagesReceived(msgCount);
0:         
0:         // now lets count the individual messages received 
0:             MessageList messageList = (MessageList)consumers.get(i.next());
0:             totalMsg += messageList.getMessageCount();
0:         assertEquals("Total of consumers message count", msgCount, totalMsg);
author:Adrian T. Co
-------------------------------------------------------------------------------
commit:ff457e2
/////////////////////////////////////////////////////////////////////////
0: /**
0:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: package org.apache.activemq;
0: 
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQQueue;
0: import org.apache.activemq.command.ActiveMQTopic;
0: import org.apache.activemq.broker.BrokerService;
0: import org.apache.activemq.broker.BrokerFactory;
0: 
0: import java.util.List;
0: import java.util.ArrayList;
0: import java.util.Map;
0: import java.util.HashMap;
0: import java.util.Iterator;
0: import java.util.Arrays;
0: import java.util.Collections;
0: import java.net.URI;
0: 
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicInteger;
0: 
0: import javax.jms.*;
0: 
0: /**
0:  * Test case support used to test multiple message comsumers and message producers connecting to a single broker.
0:  * 
0:  * @version $Revision$
0:  */
0: public class JmsMultipleClientsTestSupport extends CombinationTestSupport {
0:     private AtomicInteger producerLock;
0: 
0:     protected Map consumers = new HashMap(); // Map of consumer with messages received
0:     protected int consumerCount = 1;
0:     protected int producerCount = 1;
0: 
0:     protected int messageSize  = 1024;
0: 
0:     protected boolean useConcurrentSend = true;
0:     protected boolean durable = false;
0:     protected boolean topic = false;
0: 
0:     protected BrokerService broker;
0:     protected Destination destination;
0:     protected List connections = Collections.synchronizedList(new ArrayList());
0: 
0:     protected void startProducers(Destination dest, int msgCount) throws Exception {
0:         startProducers(createConnectionFactory(), dest, msgCount);
0:     }
0: 
0:     protected void startProducers(final ConnectionFactory factory, final Destination dest, final int msgCount) throws Exception {
0:         // Use concurrent send
0:         if (useConcurrentSend) {
0:             producerLock = new AtomicInteger(producerCount);
0: 
0:             for (int i=0; i<producerCount; i++) {
0:                 Thread t = new Thread(new Runnable() {
0:                     public void run() {
0:                         try {
0:                             sendMessages(factory.createConnection(), dest, msgCount);
0:                         } catch (Exception e) {
0:                             e.printStackTrace();
0:                         }
0: 
0:                         synchronized (producerLock) {
0:                             producerLock.decrementAndGet();
0:                             producerLock.notifyAll();
0:                         }
0:                     }
0:                 });
0: 
0:                 t.start();
0:             }
0: 
0:             // Wait for all producers to finish sending
0:             synchronized (producerLock) {
0:                 while (producerLock.get() != 0) {
0:                     producerLock.wait();
0:                 }
0:             }
0: 
0: 
0:         // Use serialized send
0:         } else {
0:             for (int i=0; i<producerCount; i++) {
0:                 sendMessages(factory.createConnection(), dest, msgCount);
0:             }
0:         }
0:     }
0: 
0:     protected void sendMessages(Connection connection, Destination destination, int count) throws Exception {
0:         connection.start();
0: 
0:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageProducer producer = session.createProducer(destination);
0: 
0:         for (int i = 0; i < count; i++) {
0:             TextMessage msg = createTextMessage(session, "" + i);
0:             producer.send(msg);
0:         }
0: 
0:         producer.close();
0:         session.close();
0:         connection.close();
0:     }
0: 
0:     protected TextMessage createTextMessage(Session session, String initText) throws Exception {
0:         TextMessage msg = session.createTextMessage();
0: 
0:         // Pad message text
0:         if (initText.length() < messageSize) {
0:             char[] data = new char[messageSize - initText.length()];
0:             Arrays.fill(data, '*');
0:             String str = new String(data);
0:             msg.setText(initText + str);
0: 
0:         // Do not pad message text
0:         } else {
0:             msg.setText(initText);
0:         }
0: 
0:         return msg;
0:     }
0: 
0:     protected void startConsumers(Destination dest) throws Exception {
0:         startConsumers(createConnectionFactory(), dest);
0:     }
0: 
0:     protected void startConsumers(ConnectionFactory factory, Destination dest) throws Exception {
0:         MessageConsumer consumer;
0:         for (int i=0; i<consumerCount; i++) {
0:             if (durable && topic) {
0:                 consumer = createDurableSubscriber(factory.createConnection(), dest, "consumer" + (i+1));
0:             } else {
0:                 consumer = createMessageConsumer(factory.createConnection(), dest);
0:             }
0:             // Add consumer object and message list
0:             consumers.put(consumer, new ArrayList());
0:         }
0:     }
0: 
0:     protected MessageConsumer createMessageConsumer(Connection conn, Destination dest) throws Exception {
0:         connections.add(conn);
0: 
0:         Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         final MessageConsumer consumer = sess.createConsumer(dest);
0:         consumer.setMessageListener(new MessageListener() {
0:             public void onMessage(Message message) {
0:                 List messageList = (List)consumers.get(consumer);
0:                 messageList.add(message);
0:             }
0:         });
0:         conn.start();
0: 
0:         return consumer;
0:     }
0: 
0:     protected TopicSubscriber createDurableSubscriber(Connection conn, Destination dest, String name) throws Exception {
0:         conn.setClientID(name);
0:         connections.add(conn);
0: 
0:         Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         final TopicSubscriber consumer = sess.createDurableSubscriber((javax.jms.Topic)dest, name);
0:         consumer.setMessageListener(new MessageListener() {
0:             public void onMessage(Message message) {
0:                 List messageList = (List)consumers.get(consumer);
0:                 messageList.add(message);
0:             }
0:         });
0:         conn.start();
0: 
0:         return consumer;
0:     }
0: 
0:     protected void waitForAllMessagesToBeReceived(int timeout) throws Exception {
0:         Thread.sleep(timeout);
0:     }
0: 
0:     protected ActiveMQDestination createDestination() throws JMSException {
0:         if (topic) {
0:             destination = new ActiveMQTopic("Topic");
0:             return (ActiveMQDestination)destination;
0:         } else {
0:             destination = new ActiveMQQueue("Queue");
0:             return (ActiveMQDestination)destination;
0:         }
0:     }
0: 
0:     protected ConnectionFactory createConnectionFactory() throws Exception {
0:         return new ActiveMQConnectionFactory("vm://localhost");
0:     }
0: 
0:     protected BrokerService createBroker() throws Exception {
0:         return BrokerFactory.createBroker(new URI("broker://()/localhost?persistent=false"));
0:     }
0: 
0:     protected void setUp() throws Exception {
0:         super.setAutoFail(true);
0:         super.setUp();
0:         broker = createBroker();
0:         broker.start();
0:     }
0: 
0:     protected void tearDown() throws Exception {
0:         for (Iterator iter = connections.iterator(); iter.hasNext();) {
0:             Connection conn= (Connection) iter.next();
0:             try {
0:                 conn.close();
0:             } catch (Throwable e) {
0:             }
0:         }
0:         broker.stop();
0:         super.tearDown();
0:     }
0: 
0:     /*
0:      * Some helpful assertions for multiple consumers.
0:      */
0:     protected void assertConsumerReceivedAtLeastXMessages(MessageConsumer consumer, int msgCount) {
0:         List messageList = (List)consumers.get(consumer);
0:         assertTrue("Consumer received less than " + msgCount + " messages. Actual messages received is " + messageList.size(), (messageList.size() >= msgCount));
0:     }
0: 
0:     protected void assertConsumerReceivedAtMostXMessages(MessageConsumer consumer, int msgCount) {
0:         List messageList = (List)consumers.get(consumer);
0:         assertTrue("Consumer received more than " + msgCount + " messages. Actual messages received is " + messageList.size(), (messageList.size() <= msgCount));
0:     }
0: 
0:     protected void assertConsumerReceivedXMessages(MessageConsumer consumer, int msgCount) {
0:         List messageList = (List)consumers.get(consumer);
0:         assertTrue("Consumer should have received exactly " + msgCount + " messages. Actual messages received is " + messageList.size(), (messageList.size() == msgCount));
0:     }
0: 
0:     protected void assertEachConsumerReceivedAtLeastXMessages(int msgCount) {
0:         for (Iterator i=consumers.keySet().iterator();i.hasNext();) {
0:             assertConsumerReceivedAtLeastXMessages((MessageConsumer)i.next(), msgCount);
0:         }
0:     }
0: 
0:     protected void assertEachConsumerReceivedAtMostXMessages(int msgCount) {
0:         for (Iterator i=consumers.keySet().iterator();i.hasNext();) {
0:             assertConsumerReceivedAtMostXMessages((MessageConsumer)i.next(), msgCount);
0:         }
0:     }
0: 
0:     protected void assertEachConsumerReceivedXMessages(int msgCount) {
0:         for (Iterator i=consumers.keySet().iterator();i.hasNext();) {
0:             assertConsumerReceivedXMessages((MessageConsumer)i.next(), msgCount);
0:         }
0:     }
0: 
0:     protected void assertTotalMessagesReceived(int msgCount) {
0:         int totalMsg = 0;
0:         for (Iterator i=consumers.keySet().iterator(); i.hasNext();) {
0:             totalMsg += ((List)consumers.get(i.next())).size();
0:         }
0: 
0:         assertTrue("Total messages received should have been " + msgCount + ". Actual messages received is " + totalMsg, (totalMsg == msgCount));
0:     }
0: }
============================================================================