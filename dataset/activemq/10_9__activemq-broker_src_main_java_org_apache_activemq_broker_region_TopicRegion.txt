2:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:b0c2a40:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
5:d29ca2a:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
2:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.broker.region;
1:449981b: 
1:18571ce: import java.io.IOException;
1:fd2805f: import java.util.ArrayList;
1:8dc1c12: import java.util.HashSet;
1:8dc1c12: import java.util.Iterator;
1:8dc1c12: import java.util.List;
1:8dc1c12: import java.util.Map;
1:8dc1c12: import java.util.Set;
1:8dc1c12: import java.util.Timer;
1:8dc1c12: import java.util.TimerTask;
1:230a86c: import java.util.concurrent.ConcurrentHashMap;
1:9ef4259: import java.util.concurrent.ConcurrentMap;
1:8dc1c12: 
1:449981b: import javax.jms.InvalidDestinationException;
1:449981b: import javax.jms.JMSException;
1:8dc1c12: 
1:4eef609: import org.apache.activemq.advisory.AdvisorySupport;
1:d29ca2a: import org.apache.activemq.broker.ConnectionContext;
1:d29ca2a: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:d29ca2a: import org.apache.activemq.command.ActiveMQDestination;
1:449981b: import org.apache.activemq.command.ConnectionId;
1:449981b: import org.apache.activemq.command.ConsumerId;
1:d29ca2a: import org.apache.activemq.command.ConsumerInfo;
1:d29ca2a: import org.apache.activemq.command.RemoveSubscriptionInfo;
1:449981b: import org.apache.activemq.command.SessionId;
1:013f372: import org.apache.activemq.command.SubscriptionInfo;
1:18571ce: import org.apache.activemq.store.NoLocalSubscriptionAware;
1:18571ce: import org.apache.activemq.store.PersistenceAdapter;
1:d29ca2a: import org.apache.activemq.store.TopicMessageStore;
1:d29ca2a: import org.apache.activemq.thread.TaskRunnerFactory;
1:6d8e2c5: import org.apache.activemq.usage.SystemUsage;
1:449981b: import org.apache.activemq.util.LongSequenceGenerator;
1:d29ca2a: import org.apache.activemq.util.SubscriptionKey;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:2728ccb: 
1:d29ca2a: /**
1:3efd4b0:  *
1:d29ca2a:  */
1:d29ca2a: public class TopicRegion extends AbstractRegion {
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(TopicRegion.class);
1:9ef4259:     protected final ConcurrentMap<SubscriptionKey, DurableTopicSubscription> durableSubscriptions = new ConcurrentHashMap<SubscriptionKey, DurableTopicSubscription>();
1:449981b:     private final LongSequenceGenerator recoveredDurableSubIdGenerator = new LongSequenceGenerator();
1:230a86c:     private final SessionId recoveredDurableSubSessionId = new SessionId(new ConnectionId("OFFLINE"), recoveredDurableSubIdGenerator.getNextSequenceId());
1:230a86c:     private boolean keepDurableSubsActive;
1:2728ccb: 
1:6f70393:     private Timer cleanupTimer;
1:6f70393:     private TimerTask cleanupTask;
1:6f70393: 
1:6d8e2c5:     public TopicRegion(RegionBroker broker, DestinationStatistics destinationStatistics, SystemUsage memoryManager, TaskRunnerFactory taskRunnerFactory,
1:230a86c:                        DestinationFactory destinationFactory) {
1:230a86c:         super(broker, destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
1:6f70393:         if (broker.getBrokerService().getOfflineDurableSubscriberTaskSchedule() != -1 && broker.getBrokerService().getOfflineDurableSubscriberTimeout() != -1) {
1:6f70393:             this.cleanupTimer = new Timer("ActiveMQ Durable Subscriber Cleanup Timer", true);
1:6f70393:             this.cleanupTask = new TimerTask() {
1:0054941:                 @Override
1:6f70393:                 public void run() {
1:6f70393:                     doCleanup();
1:44ef96e:                 }
1:6f70393:             };
1:6f70393:             this.cleanupTimer.schedule(cleanupTask, broker.getBrokerService().getOfflineDurableSubscriberTaskSchedule(), broker.getBrokerService().getOfflineDurableSubscriberTaskSchedule());
1:6f70393:         }
1:6f70393:     }
1:6f70393: 
1:6f70393:     @Override
1:6f70393:     public void stop() throws Exception {
1:6f70393:         super.stop();
1:6f70393:         if (cleanupTimer != null) {
1:6f70393:             cleanupTimer.cancel();
1:6f70393:         }
1:6f70393:     }
1:6f70393: 
1:6f70393:     public void doCleanup() {
1:6f70393:         long now = System.currentTimeMillis();
1:6f70393:         for (Map.Entry<SubscriptionKey, DurableTopicSubscription> entry : durableSubscriptions.entrySet()) {
1:6f70393:             DurableTopicSubscription sub = entry.getValue();
1:6f70393:             if (!sub.isActive()) {
1:566039f:                 long offline = sub.getOfflineTimestamp();
1:6f70393:                 if (offline != -1 && now - offline >= broker.getBrokerService().getOfflineDurableSubscriberTimeout()) {
1:e1bbde7:                     LOG.info("Destroying durable subscriber due to inactivity: {}", sub);
1:6f70393:                     try {
1:6f70393:                         RemoveSubscriptionInfo info = new RemoveSubscriptionInfo();
1:6f70393:                         info.setClientId(entry.getKey().getClientId());
1:6f70393:                         info.setSubscriptionName(entry.getKey().getSubscriptionName());
1:6f70393:                         ConnectionContext context = new ConnectionContext();
1:6f70393:                         context.setBroker(broker);
1:6f70393:                         context.setClientId(entry.getKey().getClientId());
1:6f70393:                         removeSubscription(context, info);
1:6f70393:                     } catch (Exception e) {
1:6f70393:                         LOG.error("Failed to remove inactive durable subscriber", e);
1:6f70393:                     }
1:6f70393:                 }
1:6f70393:             }
1:6f70393:         }
1:6f70393:     }
1:230a86c: 
1:2728ccb:     @Override
1:230a86c:     public Subscription addConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
1:230a86c:         if (info.isDurable()) {
1:741e3aa:             if (broker.getBrokerService().isRejectDurableConsumers()) {
1:741e3aa:                 throw new JMSException("Durable Consumers are not allowed");
1:741e3aa:             }
1:230a86c:             ActiveMQDestination destination = info.getDestination();
1:230a86c:             if (!destination.isPattern()) {
1:a71a2a5:                 // Make sure the destination is created.
1:204f91f:                 lookup(context, destination,true);
1:2728ccb:             }
1:230a86c:             String clientId = context.getClientId();
1:230a86c:             String subscriptionName = info.getSubscriptionName();
1:230a86c:             SubscriptionKey key = new SubscriptionKey(clientId, subscriptionName);
1:ecf89a6:             DurableTopicSubscription sub = durableSubscriptions.get(key);
1:230a86c:             if (sub != null) {
1:164e303:                 // throw this exception only if link stealing is off
1:164e303:                 if (!context.isAllowLinkStealing() && sub.isActive()) {
1:164e303:                     throw new JMSException("Durable consumer is in use for client: " + clientId +
1:164e303:                                            " and subscriptionName: " + subscriptionName);
1:2728ccb:                 }
1:d29ca2a:                 // Has the selector changed??
1:230a86c:                 if (hasDurableSubChanged(info, sub.getConsumerInfo())) {
1:d29ca2a:                     // Remove the consumer first then add it.
2:d29ca2a:                     durableSubscriptions.remove(key);
1:3efd4b0:                     destinationsLock.readLock().lock();
1:3efd4b0:                     try {
1:3efd4b0:                         for (Destination dest : destinations.values()) {
1:833d308:                             // Account for virtual destinations
1:3b06e12:                             if (dest instanceof Topic){
1:3b06e12:                                 Topic topic = (Topic)dest;
1:230a86c:                                 topic.deleteSubscription(context, key);
1:a71a2a5:                             }
3:d29ca2a:                         }
1:3efd4b0:                     } finally {
1:3efd4b0:                         destinationsLock.readLock().unlock();
1:d29ca2a:                     }
1:4fc1712:                     super.removeConsumer(context, sub.getConsumerInfo());
1:230a86c:                     super.addConsumer(context, info);
1:ecf89a6:                     sub = durableSubscriptions.get(key);
1:4fc1712:                 } else {
1:d29ca2a:                     // Change the consumer id key of the durable sub.
1:ecf89a6:                     if (sub.getConsumerInfo().getConsumerId() != null) {
1:013f372:                         subscriptions.remove(sub.getConsumerInfo().getConsumerId());
1:ecf89a6:                     }
1:164e303:                     // set the info and context to the new ones.
1:164e303:                     // this is set in the activate() call below, but
1:164e303:                     // that call is a NOP if it is already active.
1:164e303:                     // hence need to set here and deactivate it first
1:164e303:                     if ((sub.context != context) || (sub.info != info)) {
1:164e303:                         sub.info = info;
1:164e303:                         sub.context = context;
1:dbb1d8b:                         sub.deactivate(keepDurableSubsActive, info.getLastDeliveredSequenceId());
1:164e303:                     }
1:7c293b6:                     //If NoLocal we need to update the NoLocal selector with the new connectionId
1:7c293b6:                     //Simply setting the selector with the current one will trigger a
1:7c293b6:                     //refresh of of the connectionId for the NoLocal expression
1:7c293b6:                     if (info.isNoLocal()) {
1:7c293b6:                         sub.setSelector(sub.getSelector());
1:7c293b6:                     }
1:230a86c:                     subscriptions.put(info.getConsumerId(), sub);
1:d29ca2a:                 }
1:230a86c:             } else {
1:230a86c:                 super.addConsumer(context, info);
1:ecf89a6:                 sub = durableSubscriptions.get(key);
1:230a86c:                 if (sub == null) {
1:164e303:                     throw new JMSException("Cannot use the same consumerId: " + info.getConsumerId() +
1:164e303:                                            " for two different durable subscriptions clientID: " + key.getClientId() +
1:164e303:                                            " subscriberName: " + key.getSubscriptionName());
1:d29ca2a:                 }
1:d29ca2a:             }
1:8dc1c12:             sub.activate(usageManager, context, info, broker);
1:d29ca2a:             return sub;
1:230a86c:         } else {
1:230a86c:             return super.addConsumer(context, info);
1:d29ca2a:         }
1:d29ca2a:     }
1:230a86c: 
1:204f91f:     @Override
1:7f5213b:     public void removeConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
1:230a86c:         if (info.isDurable()) {
1:333158a:             SubscriptionKey key = new SubscriptionKey(context.getClientId(), info.getSubscriptionName());
1:ecf89a6:             DurableTopicSubscription sub = durableSubscriptions.get(key);
2:d29ca2a:             if (sub != null) {
1:164e303:                 // deactivate only if given context is same
1:164e303:                 // as what is in the sub. otherwise, during linksteal
1:164e303:                 // sub will get new context, but will be removed here
1:7c293b6:                 if (sub.getContext() == context) {
1:dbb1d8b:                     sub.deactivate(keepDurableSubsActive, info.getLastDeliveredSequenceId());
1:7c293b6:                 }
1:d29ca2a:             }
1:230a86c:         } else {
1:d29ca2a:             super.removeConsumer(context, info);
1:d29ca2a:         }
1:d29ca2a:     }
1:2728ccb: 
1:204f91f:     @Override
1:7f5213b:     public void removeSubscription(ConnectionContext context, RemoveSubscriptionInfo info) throws Exception {
1:ecf89a6:         SubscriptionKey key = new SubscriptionKey(info.getClientId(), info.getSubscriptionName());
1:eec1091:         DurableTopicSubscription sub = durableSubscriptions.get(key);
2:d29ca2a:         if (sub == null) {
1:be66175:             throw new InvalidDestinationException("No durable subscription exists for clientID: " +
1:be66175:                                                   info.getClientId() + " and subscriptionName: " +
1:be66175:                                                   info.getSubscriptionName());
1:d29ca2a:         }
1:230a86c:         if (sub.isActive()) {
2:d29ca2a:             throw new JMSException("Durable consumer is in use");
1:eec1091:         } else {
1:4d480c9:             durableSubscriptions.remove(key);
1:3efd4b0:         }
1:3efd4b0: 
1:3efd4b0:         destinationsLock.readLock().lock();
1:3efd4b0:         try {
1:3efd4b0:             for (Destination dest : destinations.values()) {
1:3efd4b0:                 if (dest instanceof Topic){
1:3efd4b0:                     Topic topic = (Topic)dest;
1:3efd4b0:                     topic.deleteSubscription(context, key);
1:ba37cbb:                 } else if (dest instanceof DestinationFilter) {
1:ba37cbb:                     DestinationFilter filter = (DestinationFilter) dest;
1:ba37cbb:                     filter.deleteSubscription(context, key);
1:d29ca2a:                 }
1:d29ca2a:             }
1:3efd4b0:         } finally {
1:3efd4b0:             destinationsLock.readLock().unlock();
1:d29ca2a:         }
1:2728ccb: 
1:5aa8b30:         if (subscriptions.get(sub.getConsumerInfo().getConsumerId()) != null) {
1:230a86c:             super.removeConsumer(context, sub.getConsumerInfo());
1:230a86c:         } else {
1:4fc1712:             // try destroying inactive subscriptions
1:4fc1712:             destroySubscription(sub);
1:4fc1712:         }
1:d29ca2a:     }
1:2728ccb: 
1:204f91f:     @Override
1:d29ca2a:     public String toString() {
1:9dd11cb:         return "TopicRegion: destinations=" + destinations.size() + ", subscriptions=" + subscriptions.size() + ", memory=" + usageManager.getMemoryUsage().getPercentUsage() + "%";
1:d29ca2a:     }
1:230a86c: 
1:204f91f:     @Override
1:2728ccb:     protected List<Subscription> addSubscriptionsForDestination(ConnectionContext context, Destination dest) throws Exception {
1:230a86c:         List<Subscription> rc = super.addSubscriptionsForDestination(context, dest);
1:ecf89a6:         Set<Subscription> dupChecker = new HashSet<Subscription>(rc);
1:230a86c: 
1:230a86c:         TopicMessageStore store = (TopicMessageStore)dest.getMessageStore();
1:013f372:         // Eagerly recover the durable subscriptions
1:230a86c:         if (store != null) {
1:013f372:             SubscriptionInfo[] infos = store.getAllSubscriptions();
1:013f372:             for (int i = 0; i < infos.length; i++) {
1:230a86c: 
1:0f502fa:                 SubscriptionInfo info = infos[i];
1:e1bbde7:                 LOG.debug("Restoring durable subscription: {}", info);
1:0f502fa:                 SubscriptionKey key = new SubscriptionKey(info);
1:230a86c: 
1:230a86c:                 // A single durable sub may be subscribing to multiple topics.
1:230a86c:                 // so it might exist already.
1:ecf89a6:                 DurableTopicSubscription sub = durableSubscriptions.get(key);
1:449981b:                 ConsumerInfo consumerInfo = createInactiveConsumerInfo(info);
1:230a86c:                 if (sub == null) {
1:18d616c:                     ConnectionContext c = new ConnectionContext();
1:18d616c:                     c.setBroker(context.getBroker());
1:18d616c:                     c.setClientId(key.getClientId());
1:18d616c:                     c.setConnectionId(consumerInfo.getConsumerId().getParentId().getParentId());
1:230a86c:                     sub = (DurableTopicSubscription)createSubscription(c, consumerInfo);
1:566039f:                     sub.setOfflineTimestamp(System.currentTimeMillis());
1:0f502fa:                 }
1:230a86c: 
1:230a86c:                 if (dupChecker.contains(sub)) {
1:230a86c:                     continue;
1:230a86c:                 }
1:230a86c: 
1:2728ccb:                 dupChecker.add(sub);
2:2728ccb:                 rc.add(sub);
2:2728ccb:                 dest.addSubscription(context, sub);
1:2728ccb:             }
1:230a86c: 
1:230a86c:             // Now perhaps there other durable subscriptions (via wild card)
1:230a86c:             // that would match this destination..
1:2728ccb:             durableSubscriptions.values();
1:3efd4b0:             for (DurableTopicSubscription sub : durableSubscriptions.values()) {
1:566039f:                 // Skip over subscriptions that we already added..
1:230a86c:                 if (dupChecker.contains(sub)) {
1:230a86c:                     continue;
1:230a86c:                 }
1:230a86c: 
1:230a86c:                 if (sub.matches(dest.getActiveMQDestination())) {
1:230a86c:                     rc.add(sub);
1:230a86c:                     dest.addSubscription(context, sub);
1:230a86c:                 }
1:230a86c:             }
1:2728ccb:         }
1:2728ccb:         return rc;
1:2728ccb:     }
1:230a86c: 
1:caca105:     public ConsumerInfo createInactiveConsumerInfo(SubscriptionInfo info) {
1:0f502fa:         ConsumerInfo rc = new ConsumerInfo();
1:0f502fa:         rc.setSelector(info.getSelector());
1:350a2aa:         rc.setSubscriptionName(info.getSubscriptionName());
1:2728ccb:         rc.setDestination(info.getSubscribedDestination());
1:449981b:         rc.setConsumerId(createConsumerId());
1:833d308:         rc.setNoLocal(info.isNoLocal());
1:0f502fa:         return rc;
1:0f502fa:     }
1:2728ccb: 
1:449981b:     private ConsumerId createConsumerId() {
1:230a86c:         return new ConsumerId(recoveredDurableSubSessionId, recoveredDurableSubIdGenerator.getNextSequenceId());
1:449981b:     }
1:2728ccb: 
1:d29ca2a:     protected void configureTopic(Topic topic, ActiveMQDestination destination) {
1:6cb66e4:         if (broker.getDestinationPolicy() != null) {
1:6cb66e4:             PolicyEntry entry = broker.getDestinationPolicy().getEntryFor(destination);
1:d29ca2a:             if (entry != null) {
1:1a5ad28:                 entry.configure(broker,topic);
1:013f372:             }
1:013f372:         }
1:d29ca2a:     }
1:449981b: 
1:204f91f:     @Override
1:230a86c:     protected Subscription createSubscription(ConnectionContext context, ConsumerInfo info) throws JMSException {
2:230a86c:         ActiveMQDestination destination = info.getDestination();
1:3efd4b0: 
3:d29ca2a:         if (info.isDurable()) {
1:230a86c:             if (AdvisorySupport.isAdvisoryTopic(info.getDestination())) {
1:4eef609:                 throw new JMSException("Cannot create a durable subscription for an advisory Topic");
1:d29ca2a:             }
1:230a86c:             SubscriptionKey key = new SubscriptionKey(context.getClientId(), info.getSubscriptionName());
1:ecf89a6:             DurableTopicSubscription sub = durableSubscriptions.get(key);
1:3efd4b0: 
1:230a86c:             if (sub == null) {
1:3efd4b0: 
1:16f2d75:                 sub = new DurableTopicSubscription(broker, usageManager, context, info, keepDurableSubsActive);
1:4fc1712: 
1:230a86c:                 if (destination != null && broker.getDestinationPolicy() != null) {
1:230a86c:                     PolicyEntry entry = broker.getDestinationPolicy().getEntryFor(destination);
1:230a86c:                     if (entry != null) {
1:9dd11cb:                         entry.configure(broker, usageManager, sub);
1:d29ca2a:                     }
1:d29ca2a:                 }
1:230a86c:                 durableSubscriptions.put(key, sub);
1:230a86c:             } else {
1:be66175:                 throw new JMSException("Durable subscription is already active for clientID: " +
1:be66175:                                        context.getClientId() + " and subscriptionName: " +
1:be66175:                                        info.getSubscriptionName());
1:013f372:             }
1:013f372:             return sub;
1:d29ca2a:         }
1:230a86c:         try {
1:16f2d75:             TopicSubscription answer = new TopicSubscription(broker, context, info, usageManager);
1:95d0dec:             // lets configure the subscription depending on the destination
1:230a86c:             if (destination != null && broker.getDestinationPolicy() != null) {
1:230a86c:                 PolicyEntry entry = broker.getDestinationPolicy().getEntryFor(destination);
1:230a86c:                 if (entry != null) {
1:9dd11cb:                     entry.configure(broker, usageManager, answer);
1:d29ca2a:                 }
1:d29ca2a:             }
1:0c0be94:             answer.init();
1:95d0dec:             return answer;
1:230a86c:         } catch (Exception e) {
1:230a86c:             LOG.error("Failed to create TopicSubscription ", e);
1:230a86c:             JMSException jmsEx = new JMSException("Couldn't create TopicSubscription");
1:044c07d:             jmsEx.setLinkedException(e);
1:044c07d:             throw jmsEx;
1:d29ca2a:         }
1:d29ca2a:     }
1:449981b: 
1:18571ce:     private boolean hasDurableSubChanged(ConsumerInfo info1, ConsumerInfo info2) throws IOException {
1:ecf89a6:         if (info1.getSelector() != null ^ info2.getSelector() != null) {
1:d29ca2a:             return true;
1:ecf89a6:         }
1:ecf89a6:         if (info1.getSelector() != null && !info1.getSelector().equals(info2.getSelector())) {
1:d29ca2a:             return true;
1:ecf89a6:         }
1:18571ce:         //Not all persistence adapters store the noLocal value for a subscription
1:18571ce:         PersistenceAdapter adapter = broker.getBrokerService().getPersistenceAdapter();
1:18571ce:         if (adapter instanceof NoLocalSubscriptionAware) {
1:7c293b6:             if (info1.isNoLocal() ^ info2.isNoLocal()) {
1:7c293b6:                 return true;
1:7c293b6:             }
1:7c293b6:         }
1:d29ca2a:         return !info1.getDestination().equals(info2.getDestination());
1:d29ca2a:     }
1:0f502fa: 
1:204f91f:     @Override
1:933eb2f:     protected Set<ActiveMQDestination> getInactiveDestinations() {
1:933eb2f:         Set<ActiveMQDestination> inactiveDestinations = super.getInactiveDestinations();
1:933eb2f:         for (Iterator<ActiveMQDestination> iter = inactiveDestinations.iterator(); iter.hasNext();) {
1:933eb2f:             ActiveMQDestination dest = iter.next();
1:ecf89a6:             if (!dest.isTopic()) {
1:d29ca2a:                 iter.remove();
1:ecf89a6:             }
1:d29ca2a:         }
1:d29ca2a:         return inactiveDestinations;
1:d29ca2a:     }
3:0f502fa: 
1:7af7c01:     public DurableTopicSubscription lookupSubscription(String subscriptionName, String clientId) {
1:7af7c01:         SubscriptionKey key = new SubscriptionKey(clientId, subscriptionName);
1:7af7c01:         if (durableSubscriptions.containsKey(key)) {
1:7af7c01:             return durableSubscriptions.get(key);
1:7af7c01:         }
1:7af7c01: 
1:7af7c01:         return null;
1:7af7c01:     }
1:7af7c01: 
1:fd2805f:     public List<DurableTopicSubscription> lookupSubscriptions(String clientId) {
1:fd2805f:         List<DurableTopicSubscription> result = new ArrayList<DurableTopicSubscription>();
1:fd2805f: 
1:fd2805f:         for (Map.Entry<SubscriptionKey, DurableTopicSubscription> subscriptionEntry : durableSubscriptions.entrySet()) {
1:fd2805f:             if (subscriptionEntry.getKey().getClientId().equals(clientId)) {
1:fd2805f:                 result.add(subscriptionEntry.getValue());
1:fd2805f:             }
1:fd2805f:         }
1:fd2805f: 
1:fd2805f:         return result;
1:fd2805f:     }
1:fd2805f: 
1:449981b:     public boolean isKeepDurableSubsActive() {
1:449981b:         return keepDurableSubsActive;
1:449981b:     }
1:449981b: 
1:449981b:     public void setKeepDurableSubsActive(boolean keepDurableSubsActive) {
1:449981b:         this.keepDurableSubsActive = keepDurableSubsActive;
1:449981b:     }
1:449981b: 
1:05f82a9:     public boolean durableSubscriptionExists(SubscriptionKey key) {
1:05f82a9:         return this.durableSubscriptions.containsKey(key);
1:d29ca2a:     }
1:e06685f: 
1:e06685f:     public DurableTopicSubscription getDurableSubscription(SubscriptionKey key) {
1:e06685f:         return durableSubscriptions.get(key);
1:e06685f:     }
1:5684d09: 
1:5684d09:     public Map<SubscriptionKey, DurableTopicSubscription> getDurableSubscriptions() {
1:5684d09:         return durableSubscriptions;
1:5684d09:     }
1:d29ca2a: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:18571ce
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.NoLocalSubscriptionAware;
1: import org.apache.activemq.store.PersistenceAdapter;
/////////////////////////////////////////////////////////////////////////
1:     private boolean hasDurableSubChanged(ConsumerInfo info1, ConsumerInfo info2) throws IOException {
1:         //Not all persistence adapters store the noLocal value for a subscription
1:         PersistenceAdapter adapter = broker.getBrokerService().getPersistenceAdapter();
1:         if (adapter instanceof NoLocalSubscriptionAware) {
commit:7c293b6
/////////////////////////////////////////////////////////////////////////
1:                     //If NoLocal we need to update the NoLocal selector with the new connectionId
1:                     //Simply setting the selector with the current one will trigger a
1:                     //refresh of of the connectionId for the NoLocal expression
1:                     if (info.isNoLocal()) {
1:                         sub.setSelector(sub.getSelector());
1:                     }
/////////////////////////////////////////////////////////////////////////
1:                 if (sub.getContext() == context) {
1:                 }
/////////////////////////////////////////////////////////////////////////
0:         // Prior to V11 the broker did not store the noLocal value for durable subs.
0:         if (broker.getBrokerService().getStoreOpenWireVersion() >= 11) {
1:             if (info1.isNoLocal() ^ info2.isNoLocal()) {
1:                 return true;
1:             }
1:         }
commit:5684d09
/////////////////////////////////////////////////////////////////////////
1: 
1:     public Map<SubscriptionKey, DurableTopicSubscription> getDurableSubscriptions() {
1:         return durableSubscriptions;
1:     }
author:Timothy Bish
-------------------------------------------------------------------------------
commit:833d308
/////////////////////////////////////////////////////////////////////////
1:                             // Account for virtual destinations
/////////////////////////////////////////////////////////////////////////
1:         rc.setNoLocal(info.isNoLocal());
commit:fd2805f
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
1:     public List<DurableTopicSubscription> lookupSubscriptions(String clientId) {
1:         List<DurableTopicSubscription> result = new ArrayList<DurableTopicSubscription>();
1: 
1:         for (Map.Entry<SubscriptionKey, DurableTopicSubscription> subscriptionEntry : durableSubscriptions.entrySet()) {
1:             if (subscriptionEntry.getKey().getClientId().equals(clientId)) {
1:                 result.add(subscriptionEntry.getValue());
1:             }
1:         }
1: 
1:         return result;
1:     }
1: 
commit:9ef4259
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentMap;
/////////////////////////////////////////////////////////////////////////
1:     protected final ConcurrentMap<SubscriptionKey, DurableTopicSubscription> durableSubscriptions = new ConcurrentHashMap<SubscriptionKey, DurableTopicSubscription>();
commit:be66175
/////////////////////////////////////////////////////////////////////////
1:             throw new InvalidDestinationException("No durable subscription exists for clientID: " +
1:                                                   info.getClientId() + " and subscriptionName: " +
1:                                                   info.getSubscriptionName());
/////////////////////////////////////////////////////////////////////////
1:                 throw new JMSException("Durable subscription is already active for clientID: " +
1:                                        context.getClientId() + " and subscriptionName: " +
1:                                        info.getSubscriptionName());
commit:7af7c01
/////////////////////////////////////////////////////////////////////////
1:     public DurableTopicSubscription lookupSubscription(String subscriptionName, String clientId) {
1:         SubscriptionKey key = new SubscriptionKey(clientId, subscriptionName);
1:         if (durableSubscriptions.containsKey(key)) {
1:             return durableSubscriptions.get(key);
1:         }
1: 
1:         return null;
1:     }
1: 
commit:164e303
/////////////////////////////////////////////////////////////////////////
1:                 // throw this exception only if link stealing is off
1:                 if (!context.isAllowLinkStealing() && sub.isActive()) {
1:                     throw new JMSException("Durable consumer is in use for client: " + clientId +
1:                                            " and subscriptionName: " + subscriptionName);
/////////////////////////////////////////////////////////////////////////
1:                     // set the info and context to the new ones.
1:                     // this is set in the activate() call below, but
1:                     // that call is a NOP if it is already active.
1:                     // hence need to set here and deactivate it first
1:                     if ((sub.context != context) || (sub.info != info)) {
1:                         sub.info = info;
1:                         sub.context = context;
0:                         sub.deactivate(keepDurableSubsActive);
1:                     }
1:                     throw new JMSException("Cannot use the same consumerId: " + info.getConsumerId() +
1:                                            " for two different durable subscriptions clientID: " + key.getClientId() +
1:                                            " subscriberName: " + key.getSubscriptionName());
/////////////////////////////////////////////////////////////////////////
1:                 // deactivate only if given context is same
1:                 // as what is in the sub. otherwise, during linksteal
1:                 // sub will get new context, but will be removed here
0:                 if (sub.getContext() == context)
0:                     sub.deactivate(keepDurableSubsActive);
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
1:                     LOG.info("Destroying durable subscriber due to inactivity: {}", sub);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Restoring durable subscription: {}", info);
author:gtully
-------------------------------------------------------------------------------
commit:741e3aa
/////////////////////////////////////////////////////////////////////////
1:             if (broker.getBrokerService().isRejectDurableConsumers()) {
1:                 throw new JMSException("Durable Consumers are not allowed");
1:             }
commit:dbb1d8b
/////////////////////////////////////////////////////////////////////////
1:                         sub.deactivate(keepDurableSubsActive, info.getLastDeliveredSequenceId());
/////////////////////////////////////////////////////////////////////////
1:                     sub.deactivate(keepDurableSubsActive, info.getLastDeliveredSequenceId());
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ba37cbb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 } else if (dest instanceof DestinationFilter) {
1:                     DestinationFilter filter = (DestinationFilter) dest;
1:                     filter.deleteSubscription(context, key);
commit:0054941
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.virtual.VirtualTopicInterceptor;
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
0:                 } else if (dest instanceof VirtualTopicInterceptor) {
0:                     VirtualTopicInterceptor virtualTopic = (VirtualTopicInterceptor) dest;
0:                     virtualTopic.getTopic().deleteSubscription(context, key);
commit:566039f
/////////////////////////////////////////////////////////////////////////
1:                 long offline = sub.getOfflineTimestamp();
/////////////////////////////////////////////////////////////////////////
1:                     sub.setOfflineTimestamp(System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
1:                 // Skip over subscriptions that we already added..
commit:8dc1c12
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Set;
1: import java.util.Timer;
1: import java.util.TimerTask;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:             sub.activate(usageManager, context, info, broker);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:4d480c9
/////////////////////////////////////////////////////////////////////////
1:             durableSubscriptions.remove(key);
commit:5aa8b30
/////////////////////////////////////////////////////////////////////////
1:         if (subscriptions.get(sub.getConsumerInfo().getConsumerId()) != null) {
commit:eec1091
/////////////////////////////////////////////////////////////////////////
1:         DurableTopicSubscription sub = durableSubscriptions.get(key);
1:         } else {
0:             durableSubscriptions.get(key);
commit:3efd4b0
/////////////////////////////////////////////////////////////////////////
1:  *
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     destinationsLock.readLock().lock();
1:                     try {
1:                         for (Destination dest : destinations.values()) {
1:                     } finally {
1:                         destinationsLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:         destinationsLock.readLock().lock();
1:         try {
1:             for (Destination dest : destinations.values()) {
0:                 //Account for virtual destinations
1:                 if (dest instanceof Topic){
1:                     Topic topic = (Topic)dest;
1:                     topic.deleteSubscription(context, key);
1:                 }
1:         } finally {
1:             destinationsLock.readLock().unlock();
1: 
/////////////////////////////////////////////////////////////////////////
1:             for (DurableTopicSubscription sub : durableSubscriptions.values()) {
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:e06685f
/////////////////////////////////////////////////////////////////////////
1: 
1:     public DurableTopicSubscription getDurableSubscription(SubscriptionKey key) {
1:         return durableSubscriptions.get(key);
1:     }
commit:44ef96e
/////////////////////////////////////////////////////////////////////////
0:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug("Restoring durable subscription: " + info);
1:                 }
commit:6f70393
/////////////////////////////////////////////////////////////////////////
0: import java.util.*;
/////////////////////////////////////////////////////////////////////////
1:     private Timer cleanupTimer;
1:     private TimerTask cleanupTask;
1: 
1:         if (broker.getBrokerService().getOfflineDurableSubscriberTaskSchedule() != -1 && broker.getBrokerService().getOfflineDurableSubscriberTimeout() != -1) {
1:             this.cleanupTimer = new Timer("ActiveMQ Durable Subscriber Cleanup Timer", true);
1:             this.cleanupTask = new TimerTask() {
1:                 public void run() {
1:                     doCleanup();
1:                 }
1:             };
1:             this.cleanupTimer.schedule(cleanupTask, broker.getBrokerService().getOfflineDurableSubscriberTaskSchedule(), broker.getBrokerService().getOfflineDurableSubscriberTaskSchedule());
1:         }
1:     }
1: 
1:     @Override
1:     public void stop() throws Exception {
1:         super.stop();
1:         if (cleanupTimer != null) {
1:             cleanupTimer.cancel();
1:         }
1:     }
1: 
1:     public void doCleanup() {
1:         long now = System.currentTimeMillis();
1:         for (Map.Entry<SubscriptionKey, DurableTopicSubscription> entry : durableSubscriptions.entrySet()) {
1:             DurableTopicSubscription sub = entry.getValue();
1:             if (!sub.isActive()) {
0:                long offline = sub.getOfflineTimestamp();
1:                 if (offline != -1 && now - offline >= broker.getBrokerService().getOfflineDurableSubscriberTimeout()) {
0:                     LOG.info("Destroying durable subscriber due to inactivity: " + sub);
1:                     try {
1:                         RemoveSubscriptionInfo info = new RemoveSubscriptionInfo();
1:                         info.setClientId(entry.getKey().getClientId());
1:                         info.setSubscriptionName(entry.getKey().getSubscriptionName());
1:                         ConnectionContext context = new ConnectionContext();
1:                         context.setBroker(broker);
1:                         context.setClientId(entry.getKey().getClientId());
1:                         removeSubscription(context, info);
1:                     } catch (Exception e) {
1:                         LOG.error("Failed to remove inactive durable subscriber", e);
1:                     }
1:                 }
1:             }
1:         }
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(TopicRegion.class);
commit:e962298
/////////////////////////////////////////////////////////////////////////
0:         DurableTopicSubscription sub = durableSubscriptions.remove(key);
commit:4fc1712
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         if (subscriptions.get(sub.getConsumerInfo()) != null) {
1:             super.removeConsumer(context, sub.getConsumerInfo());
1:         } else {
1:             // try destroying inactive subscriptions
1:             destroySubscription(sub);
1:         }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
1:     protected Set<ActiveMQDestination> getInactiveDestinations() {
1:         Set<ActiveMQDestination> inactiveDestinations = super.getInactiveDestinations();
1:         for (Iterator<ActiveMQDestination> iter = inactiveDestinations.iterator(); iter.hasNext();) {
1:             ActiveMQDestination dest = iter.next();
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
0:     protected final ConcurrentHashMap<SubscriptionKey, DurableTopicSubscription> durableSubscriptions = new ConcurrentHashMap<SubscriptionKey, DurableTopicSubscription>();
/////////////////////////////////////////////////////////////////////////
1:             DurableTopicSubscription sub = durableSubscriptions.get(key);
/////////////////////////////////////////////////////////////////////////
0:                     for (Iterator<Destination> iter = destinations.values().iterator(); iter.hasNext();) {
1:                     sub = durableSubscriptions.get(key);
1:                     if (sub.getConsumerInfo().getConsumerId() != null) {
1:                     }
1:                 sub = durableSubscriptions.get(key);
/////////////////////////////////////////////////////////////////////////
1:             DurableTopicSubscription sub = durableSubscriptions.get(key);
/////////////////////////////////////////////////////////////////////////
1:         SubscriptionKey key = new SubscriptionKey(info.getClientId(), info.getSubscriptionName());
1:         DurableTopicSubscription sub = durableSubscriptions.get(key);
0:             throw new InvalidDestinationException("No durable subscription exists for: " + info.getSubscriptionName());
0:         for (Iterator<Destination> iter = destinations.values().iterator(); iter.hasNext();) {
/////////////////////////////////////////////////////////////////////////
1:         Set<Subscription> dupChecker = new HashSet<Subscription>(rc);
/////////////////////////////////////////////////////////////////////////
1:                 DurableTopicSubscription sub = durableSubscriptions.get(key);
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator<DurableTopicSubscription> iterator = durableSubscriptions.values().iterator(); iterator.hasNext();) {
0:                 DurableTopicSubscription sub = iterator.next();
/////////////////////////////////////////////////////////////////////////
0:             DurableTopicSubscription sub = durableSubscriptions.get(key);
/////////////////////////////////////////////////////////////////////////
1:         if (info1.getSelector() != null ^ info2.getSelector() != null) {
1:         }
1:         if (info1.getSelector() != null && !info1.getSelector().equals(info2.getSelector())) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:             if (!dest.isTopic()) {
1:             }
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentHashMap;
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(TopicRegion.class);
1:     private final SessionId recoveredDurableSubSessionId = new SessionId(new ConnectionId("OFFLINE"), recoveredDurableSubIdGenerator.getNextSequenceId());
1:     private boolean keepDurableSubsActive;
0:     public TopicRegion(RegionBroker broker, DestinationStatistics destinationStatistics, UsageManager memoryManager, TaskRunnerFactory taskRunnerFactory,
1:                        DestinationFactory destinationFactory) {
1:         super(broker, destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
1: 
1:     public Subscription addConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
1:         if (info.isDurable()) {
1:             ActiveMQDestination destination = info.getDestination();
1:             if (!destination.isPattern()) {
0:                 lookup(context, destination);
1:             String clientId = context.getClientId();
1:             String subscriptionName = info.getSubscriptionName();
1:             SubscriptionKey key = new SubscriptionKey(clientId, subscriptionName);
0:             DurableTopicSubscription sub = (DurableTopicSubscription)durableSubscriptions.get(key);
1:             if (sub != null) {
1:                 if (sub.isActive()) {
0:                     throw new JMSException("Durable consumer is in use for client: " + clientId + " and subscriptionName: " + subscriptionName);
1:                 if (hasDurableSubChanged(info, sub.getConsumerInfo())) {
0:                     for (Iterator iter = destinations.values().iterator(); iter.hasNext();) {
0:                         Topic topic = (Topic)iter.next();
1:                         topic.deleteSubscription(context, key);
1:                     super.removeConsumer(context, sub.getConsumerInfo());
1:                     super.addConsumer(context, info);
0:                     sub = (DurableTopicSubscription)durableSubscriptions.get(key);
1:                 } else {
0:                     if (sub.getConsumerInfo().getConsumerId() != null)
1:                     subscriptions.put(info.getConsumerId(), sub);
1:             } else {
1:                 super.addConsumer(context, info);
0:                 sub = (DurableTopicSubscription)durableSubscriptions.get(key);
1:                 if (sub == null) {
0:                     throw new JMSException("Cannot use the same consumerId: " + info.getConsumerId() + " for two different durable subscriptions clientID: " + key.getClientId()
0:                                            + " subscriberName: " + key.getSubscriptionName());
0:             sub.activate(memoryManager, context, info);
1:         } else {
1:             return super.addConsumer(context, info);
/////////////////////////////////////////////////////////////////////////
0:             DurableTopicSubscription sub = (DurableTopicSubscription)durableSubscriptions.get(key);
1:         } else {
0:         DurableTopicSubscription sub = (DurableTopicSubscription)durableSubscriptions.get(key);
/////////////////////////////////////////////////////////////////////////
0:             Topic topic = (Topic)iter.next();
0:         return "TopicRegion: destinations=" + destinations.size() + ", subscriptions=" + subscriptions.size() + ", memory=" + memoryManager.getPercentUsage() + "%";
1: 
1: 
1:         List<Subscription> rc = super.addSubscriptionsForDestination(context, dest);
0:         HashSet<Subscription> dupChecker = new HashSet<Subscription>(rc);
1: 
1:         TopicMessageStore store = (TopicMessageStore)dest.getMessageStore();
1:         if (store != null) {
1: 
0:                 LOG.debug("Restoring durable subscription: " + infos);
1: 
1:                 // A single durable sub may be subscribing to multiple topics.
1:                 // so it might exist already.
0:                 DurableTopicSubscription sub = (DurableTopicSubscription)durableSubscriptions.get(key);
1:                 if (sub == null) {
1:                     sub = (DurableTopicSubscription)createSubscription(c, consumerInfo);
1: 
1:                 if (dupChecker.contains(sub)) {
1:                     continue;
1:                 }
1: 
1:             // Now perhaps there other durable subscriptions (via wild card)
1:             // that would match this destination..
0:             for (Iterator iterator = durableSubscriptions.values().iterator(); iterator.hasNext();) {
0:                 DurableTopicSubscription sub = (DurableTopicSubscription)iterator.next();
0:                 // Skip over subscriptions that we allready added..
1:                 if (dupChecker.contains(sub)) {
1:                     continue;
1:                 }
1: 
1:                 if (sub.matches(dest.getActiveMQDestination())) {
1:                     rc.add(sub);
1:                     dest.addSubscription(context, sub);
1:                 }
1:             }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:         return new ConsumerId(recoveredDurableSubSessionId, recoveredDurableSubIdGenerator.getNextSequenceId());
/////////////////////////////////////////////////////////////////////////
1:     protected Subscription createSubscription(ConnectionContext context, ConsumerInfo info) throws JMSException {
1:         if (info.isDurable()) {
1:             if (AdvisorySupport.isAdvisoryTopic(info.getDestination())) {
1:             SubscriptionKey key = new SubscriptionKey(context.getClientId(), info.getSubscriptionName());
0:             DurableTopicSubscription sub = (DurableTopicSubscription)durableSubscriptions.get(key);
1:             if (sub == null) {
0:                 sub = new DurableTopicSubscription(broker, memoryManager, context, info, keepDurableSubsActive);
1:                 ActiveMQDestination destination = info.getDestination();
1:                 if (destination != null && broker.getDestinationPolicy() != null) {
1:                     PolicyEntry entry = broker.getDestinationPolicy().getEntryFor(destination);
1:                     if (entry != null) {
0:                         entry.configure(broker, memoryManager, sub);
1:                 durableSubscriptions.put(key, sub);
1:             } else {
1:         try {
0:             TopicSubscription answer = new TopicSubscription(broker, context, info, memoryManager);
1:             ActiveMQDestination destination = info.getDestination();
1:             if (destination != null && broker.getDestinationPolicy() != null) {
1:                 PolicyEntry entry = broker.getDestinationPolicy().getEntryFor(destination);
1:                 if (entry != null) {
0:                     entry.configure(broker, memoryManager, answer);
1:         } catch (Exception e) {
1:             LOG.error("Failed to create TopicSubscription ", e);
1:             JMSException jmsEx = new JMSException("Couldn't create TopicSubscription");
/////////////////////////////////////////////////////////////////////////
0:             ActiveMQDestination dest = (ActiveMQDestination)iter.next();
commit:2728ccb
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashSet;
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:     
1:     @Override
1:     protected List<Subscription> addSubscriptionsForDestination(ConnectionContext context, Destination dest) throws Exception {
1:     	
0:     	List<Subscription> rc = super.addSubscriptionsForDestination(context, dest);    	
0:     	HashSet<Subscription> dupChecker = new HashSet<Subscription>(rc);
1:     	
0:         TopicMessageStore store = (TopicMessageStore) dest.getMessageStore();
/////////////////////////////////////////////////////////////////////////
0: 				if( dupChecker.contains(sub ) ) {
0: 					continue;
1: 				}
1: 
1:                 dupChecker.add(sub);
1:                 rc.add(sub);
1:                 dest.addSubscription(context, sub);
1:             }
1:             
0:             // Now perhaps there other durable subscriptions (via wild card) that would match this destination..
1:             durableSubscriptions.values();
0:             for (Iterator iterator = durableSubscriptions.values().iterator(); iterator
0: 					.hasNext();) {
0: 				DurableTopicSubscription sub = (DurableTopicSubscription) iterator.next();
0: 				// Skip over subscriptions that we allready added..
0: 				if( dupChecker.contains(sub ) ) {
0: 					continue;
1: 				}
1: 				
0: 				if( sub.matches(dest.getActiveMQDestination()) ) {
1: 	                rc.add(sub);
1: 	                dest.addSubscription(context, sub);
1: 				}
1: 			}            
1:         
1:         return rc;
1:         rc.setDestination(info.getSubscribedDestination());
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
commit:333158a
/////////////////////////////////////////////////////////////////////////
0:             String subcriptionName=info.getSubscriptionName();
/////////////////////////////////////////////////////////////////////////
1:             SubscriptionKey key = new SubscriptionKey(context.getClientId(), info.getSubscriptionName());
/////////////////////////////////////////////////////////////////////////
0:         rc.setSubscriptionName(info.getSubcriptionName());
/////////////////////////////////////////////////////////////////////////
0:             SubscriptionKey key = new SubscriptionKey(context.getClientId(), info.getSubscriptionName());
0:                         context.getClientId(),info.getSubscriptionName(),broker.getTempDataStore(),
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:18d616c
/////////////////////////////////////////////////////////////////////////
1:                     ConnectionContext c = new ConnectionContext();
1:                     c.setBroker(context.getBroker());
1:                     c.setClientId(key.getClientId());
1:                     c.setConnectionId(consumerInfo.getConsumerId().getParentId().getParentId());
0:                     sub = (DurableTopicSubscription) createSubscription(c, consumerInfo );
commit:449981b
/////////////////////////////////////////////////////////////////////////
0: import java.util.Iterator;
0: import java.util.Set;
1: import javax.jms.InvalidDestinationException;
1: import javax.jms.JMSException;
1: 
1: import org.apache.activemq.command.ConnectionId;
1: import org.apache.activemq.command.ConsumerId;
1: import org.apache.activemq.command.SessionId;
1: import org.apache.activemq.util.LongSequenceGenerator;
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
/////////////////////////////////////////////////////////////////////////
1:     private final LongSequenceGenerator recoveredDurableSubIdGenerator = new LongSequenceGenerator();
0:     private final SessionId recoveredDurableSubSessionId = new SessionId(new ConnectionId("OFFLINE"), recoveredDurableSubIdGenerator.getNextSequenceId()); 
0:     private boolean keepDurableSubsActive=false;
/////////////////////////////////////////////////////////////////////////
0:                 sub.deactivate(keepDurableSubsActive);
/////////////////////////////////////////////////////////////////////////
1:                 ConsumerInfo consumerInfo = createInactiveConsumerInfo(info);
0:                 if( sub == null ) { 
0:                     sub = (DurableTopicSubscription) createSubscription(context, consumerInfo );
1:                 
0:                 subscriptions.put(consumerInfo.getConsumerId(), sub);
0:                 topic.addSubscription(context, sub);
0:     private ConsumerInfo createInactiveConsumerInfo(SubscriptionInfo info) {
1:         rc.setConsumerId(createConsumerId());
1:     private ConsumerId createConsumerId() {
0:         return new ConsumerId(recoveredDurableSubSessionId,recoveredDurableSubIdGenerator.getNextSequenceId());
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:                 sub = new DurableTopicSubscription(broker,context, info, keepDurableSubsActive);
/////////////////////////////////////////////////////////////////////////
1:     public boolean isKeepDurableSubsActive() {
1:         return keepDurableSubsActive;
1:     }
1: 
1:     public void setKeepDurableSubsActive(boolean keepDurableSubsActive) {
1:         this.keepDurableSubsActive = keepDurableSubsActive;
1:     }
1: 
commit:7f5213b
/////////////////////////////////////////////////////////////////////////
0:     public void addConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void removeConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void removeSubscription(ConnectionContext context, RemoveSubscriptionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     protected Destination createDestination(ConnectionContext context, ActiveMQDestination destination) throws Exception {
commit:0f502fa
/////////////////////////////////////////////////////////////////////////
0:                     sub = (DurableTopicSubscription) durableSubscriptions.get(key);
0:                 sub = (DurableTopicSubscription) durableSubscriptions.get(key);
1:             
0:             sub.activate(context, info);
/////////////////////////////////////////////////////////////////////////
0:     protected Destination createDestination(ConnectionContext context, ActiveMQDestination destination) throws Throwable {
/////////////////////////////////////////////////////////////////////////
1:                 
1:                 SubscriptionInfo info = infos[i];
0:                 log.debug("Restoring durable subscription: "+infos);
1:                 SubscriptionKey key = new SubscriptionKey(info);
1:                 
0:                 // A single durable sub may be subscribing to multiple topics.  so it might exist already.
0:                 DurableTopicSubscription sub = (DurableTopicSubscription) durableSubscriptions.get(key);
0:                 if( sub == null ) {
0:                     sub = (DurableTopicSubscription) createSubscription(context, createInactiveConsumerInfo(info));
1:                 }
0:                 topic.addInactiveSubscription(context, sub);
1:     
0:     private static ConsumerInfo createInactiveConsumerInfo(SubscriptionInfo info) {
1:         ConsumerInfo rc = new ConsumerInfo();
1:         rc.setSelector(info.getSelector());
0:         rc.setSubcriptionName(info.getSubcriptionName());
0:         rc.setDestination(info.getDestination());
1:         return rc;
1:     }
/////////////////////////////////////////////////////////////////////////
commit:a71a2a5
/////////////////////////////////////////////////////////////////////////
0: 
0:             ActiveMQDestination destination = info.getDestination();
0:             if( !destination.isPattern() ) {
1:                 // Make sure the destination is created.
0:                 lookup(context, destination);
1:             }
0: 
/////////////////////////////////////////////////////////////////////////
0:                 createDurableSubscription(topic, infos[i]);
/////////////////////////////////////////////////////////////////////////
0:     public Subscription createDurableSubscription(Topic topic, SubscriptionInfo info) throws Throwable {
0:         topic.createSubscription(key);
0:         sub.add(null, topic);
commit:013f372
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.SubscriptionInfo;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
/////////////////////////////////////////////////////////////////////////
0:     private static final Log log = LogFactory.getLog(TopicRegion.class);
0:     
/////////////////////////////////////////////////////////////////////////
0:                     if( sub.getConsumerInfo().getConsumerId()!=null )
1:                         subscriptions.remove(sub.getConsumerInfo().getConsumerId());
/////////////////////////////////////////////////////////////////////////
0:         
1:         // Eagerly recover the durable subscriptions
0:         if (store != null) {            
1:             SubscriptionInfo[] infos = store.getAllSubscriptions();
1:             for (int i = 0; i < infos.length; i++) {
0:                 log.info("Restoring durable subscription: "+infos[i]);
0:                 createDurableSubscription(infos[i]);
1:             }            
1:         }
0:         
/////////////////////////////////////////////////////////////////////////
0:     
0:     public Subscription createDurableSubscription(SubscriptionInfo info) throws JMSException {
0:         SubscriptionKey key = new SubscriptionKey(info.getClientId(), info.getSubcriptionName());
0:         DurableTopicSubscription sub = (DurableTopicSubscription) durableSubscriptions.get(key);
0:         sub = new DurableTopicSubscription(info);
0:         durableSubscriptions.put(key, sub);
1:         return sub;
1:     }
0:     
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker.region;
0: 
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
0: 
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
0: import org.apache.activemq.broker.region.policy.PolicyMap;
1: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.command.RemoveSubscriptionInfo;
0: import org.apache.activemq.memory.UsageManager;
0: import org.apache.activemq.store.PersistenceAdapter;
1: import org.apache.activemq.store.TopicMessageStore;
1: import org.apache.activemq.thread.TaskRunnerFactory;
1: import org.apache.activemq.util.SubscriptionKey;
0: 
0: import javax.jms.InvalidDestinationException;
0: import javax.jms.JMSException;
0: 
0: import java.util.Iterator;
0: import java.util.Set;
0: 
1: /**
1:  * 
0:  * @version $Revision: 1.12 $
1:  */
1: public class TopicRegion extends AbstractRegion {
0: 
0:     protected final ConcurrentHashMap durableSubscriptions = new ConcurrentHashMap();
0:     private final PolicyMap policyMap;
0: 
0:     public TopicRegion(DestinationStatistics destinationStatistics, UsageManager memoryManager, TaskRunnerFactory taskRunnerFactory,
0:             PersistenceAdapter persistenceAdapter, PolicyMap policyMap) {
0:         super(destinationStatistics, memoryManager, taskRunnerFactory, persistenceAdapter);
0:         this.policyMap = policyMap;
1:     }
0: 
0:     public void addConsumer(ConnectionContext context, ConsumerInfo info) throws Throwable {
1:         if (info.isDurable()) {
0:             SubscriptionKey key = new SubscriptionKey(context.getClientId(), info.getSubcriptionName());
0:             DurableTopicSubscription sub = (DurableTopicSubscription) durableSubscriptions.get(key);
1:             if (sub != null) {
0: 
0:                 if (sub.isActive()) {
1:                     throw new JMSException("Durable consumer is in use");
1:                 }
0: 
1:                 // Has the selector changed??
0:                 if (hasDurableSubChanged(info, sub.getConsumerInfo())) {
0: 
1:                     // Remove the consumer first then add it.
1:                     durableSubscriptions.remove(key);
0:                     for (Iterator iter = destinations.values().iterator(); iter.hasNext();) {
0:                         Topic topic = (Topic) iter.next();
0:                         topic.deleteSubscription(context, key);
1:                     }
0:                     super.removeConsumer(context, sub.getConsumerInfo());
0: 
0:                     super.addConsumer(context, info);
0: 
1:                 }
0:                 else {
1:                     // Change the consumer id key of the durable sub.
0:                     subscriptions.remove(sub.getConsumerInfo().getConsumerId());
0:                     subscriptions.put(info.getConsumerId(), sub);
0:                     sub.activate(context, info);
1:                 }
1:             }
0:             else {
0:                 super.addConsumer(context, info);
1:             }
1:         }
0:         else {
0:             super.addConsumer(context, info);
1:         }
1:     }
0: 
0:     public void removeConsumer(ConnectionContext context, ConsumerInfo info) throws Throwable {
1:         if (info.isDurable()) {
0: 
0:             SubscriptionKey key = new SubscriptionKey(context.getClientId(), info.getSubcriptionName());
0:             DurableTopicSubscription sub = (DurableTopicSubscription) durableSubscriptions.get(key);
1:             if (sub != null) {
0:                 sub.deactivate();
1:             }
0: 
1:         }
0:         else {
1:             super.removeConsumer(context, info);
1:         }
1:     }
0: 
0:     public void removeSubscription(ConnectionContext context, RemoveSubscriptionInfo info) throws Throwable {
0:         SubscriptionKey key = new SubscriptionKey(info.getClientId(), info.getSubcriptionName());
0:         DurableTopicSubscription sub = (DurableTopicSubscription) durableSubscriptions.get(key);
1:         if (sub == null) {
0:             throw new InvalidDestinationException("No durable subscription exists for: " + info.getSubcriptionName());
1:         }
0:         if (sub.isActive()) {
1:             throw new JMSException("Durable consumer is in use");
1:         }
0: 
1:         durableSubscriptions.remove(key);
0:         for (Iterator iter = destinations.values().iterator(); iter.hasNext();) {
0:             Topic topic = (Topic) iter.next();
0:             topic.deleteSubscription(context, key);
1:         }
0:         super.removeConsumer(context, sub.getConsumerInfo());
1:     }
0: 
1:     public String toString() {
0:         return "TopicRegion: destinations=" + destinations.size() + ", subscriptions=" + subscriptions.size() + ", memory=" + memoryManager.getPercentUsage()
0:                 + "%";
1:     }
0: 
0:     // Implementation methods
0:     // -------------------------------------------------------------------------
0:     protected Destination createDestination(ActiveMQDestination destination) throws Throwable {
0:         TopicMessageStore store = persistenceAdapter.createTopicMessageStore((ActiveMQTopic) destination);
0:         Topic topic = new Topic(destination, store, memoryManager, destinationStatistics, taskRunnerFactory);
0:         configureTopic(topic, destination);
0:         return topic;
1:     }
0: 
1:     protected void configureTopic(Topic topic, ActiveMQDestination destination) {
0:         if (policyMap != null) {
0:             PolicyEntry entry = policyMap.getEntryFor(destination);
1:             if (entry != null) {
0:                 entry.configure(topic);
1:             }
1:         }
1:     }
0: 
0:     protected Subscription createSubscription(ConnectionContext context, ConsumerInfo info) throws JMSException {
1:         if (info.isDurable()) {
0:             SubscriptionKey key = new SubscriptionKey(context.getClientId(), info.getSubcriptionName());
0:             DurableTopicSubscription sub = (DurableTopicSubscription) durableSubscriptions.get(key);
1:             if (sub == null) {
0:                 sub = new DurableTopicSubscription(context, info);
0:                 durableSubscriptions.put(key, sub);
1:             }
0:             else {
0:                 throw new JMSException("That durable subscription is already active.");
1:             }
1:             return sub;
1:         }
0:         else {
0:             return new TopicSubscription(context, info, memoryManager);
1:         }
1:     }
0: 
1:     /**
1:      */
0:     private boolean hasDurableSubChanged(ConsumerInfo info1, ConsumerInfo info2) {
0:         if (info1.getSelector() != null ^ info2.getSelector() != null)
1:             return true;
0:         if (info1.getSelector() != null && !info1.getSelector().equals(info2.getSelector()))
1:             return true;
1:         return !info1.getDestination().equals(info2.getDestination());
1:     }
0: 
0:     protected Set getInactiveDestinations() {
0:         Set inactiveDestinations = super.getInactiveDestinations();
0:         for (Iterator iter = inactiveDestinations.iterator(); iter.hasNext();) {
0:             ActiveMQDestination dest = (ActiveMQDestination) iter.next();
0:             if (!dest.isTopic())
1:                 iter.remove();
1:         }
1:         return inactiveDestinations;
1:     }
0: 
1: }
author:Gary Tully
-------------------------------------------------------------------------------
commit:caca105
/////////////////////////////////////////////////////////////////////////
1:     public ConsumerInfo createInactiveConsumerInfo(SubscriptionInfo info) {
commit:05f82a9
/////////////////////////////////////////////////////////////////////////
0:                 LOG.debug("Restoring durable subscription: " + info);
/////////////////////////////////////////////////////////////////////////
1:     public boolean durableSubscriptionExists(SubscriptionKey key) {
1:         return this.durableSubscriptions.containsKey(key);
0:     }
0: 
commit:3b06e12
/////////////////////////////////////////////////////////////////////////
0:                             Destination dest = iter.next();
0:                             //Account for virtual destinations
1:                             if (dest instanceof Topic){
1:                                 Topic topic = (Topic)dest;
0:                                 topic.deleteSubscription(context, key);
0:                             }
/////////////////////////////////////////////////////////////////////////
0:             	Destination dest = iter.next();
0:             	//Account for virtual destinations
0:             	if (dest instanceof Topic){
0:             	    Topic topic = (Topic)dest;
0:             	    topic.deleteSubscription(context, key);
0:             	}
author:Robert Davies
-------------------------------------------------------------------------------
commit:1a5ad28
/////////////////////////////////////////////////////////////////////////
1:                 entry.configure(broker,topic);
commit:204f91f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:                 lookup(context, destination,true);
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:16f2d75
/////////////////////////////////////////////////////////////////////////
0:         
/////////////////////////////////////////////////////////////////////////
1:                 sub = new DurableTopicSubscription(broker, usageManager, context, info, keepDurableSubsActive);
/////////////////////////////////////////////////////////////////////////
1:             TopicSubscription answer = new TopicSubscription(broker, context, info, usageManager);
commit:931ed76
/////////////////////////////////////////////////////////////////////////
0:                     synchronized (destinationsMutex) {
0:                         for (Iterator<Destination> iter = destinations.values().iterator(); iter.hasNext();) {
0:                             Topic topic = (Topic)iter.next();
0:                             topic.deleteSubscription(context, key);
0:                         }
/////////////////////////////////////////////////////////////////////////
0:         synchronized (destinationsMutex) {
0:             for (Iterator<Destination> iter = destinations.values().iterator(); iter.hasNext();) {
0:                 Topic topic = (Topic)iter.next();
0:                 topic.deleteSubscription(context, key);
0:             }
commit:044c07d
/////////////////////////////////////////////////////////////////////////
0:         ActiveMQDestination destination = info.getDestination();
0:         Destination dest=null;
0:         try {
0:             dest = lookup(context, destination);
0:         } catch (Exception e) {
0:             JMSException jmsEx = new JMSException("Failed to retrieve destination from region "+ e);
1:             jmsEx.setLinkedException(e);
1:             throw jmsEx;
0:         }
0:             
0:                 
/////////////////////////////////////////////////////////////////////////
0:             TopicSubscription answer = new TopicSubscription(broker, dest,context, info, usageManager);
commit:83c3dca
/////////////////////////////////////////////////////////////////////////
0:             ActiveMQDestination destination = info.getDestination();
0:                 Destination dest=null;
0:                 try {
0:                     dest = lookup(context, destination);
0:                 } catch (Exception e) {
0:                     JMSException jmsEx = new JMSException("Failed to retrieve destination from region "+ e);
0:                     jmsEx.setLinkedException(e);
0:                     throw jmsEx;
0:                 }
0:                 sub = new DurableTopicSubscription(broker,dest, usageManager, context, info, keepDurableSubsActive);
commit:9dd11cb
/////////////////////////////////////////////////////////////////////////
0:             sub.activate(usageManager, context, info);
/////////////////////////////////////////////////////////////////////////
1:         return "TopicRegion: destinations=" + destinations.size() + ", subscriptions=" + subscriptions.size() + ", memory=" + usageManager.getMemoryUsage().getPercentUsage() + "%";
/////////////////////////////////////////////////////////////////////////
0:                 sub = new DurableTopicSubscription(broker, usageManager, context, info, keepDurableSubsActive);
1:                         entry.configure(broker, usageManager, sub);
/////////////////////////////////////////////////////////////////////////
0:             TopicSubscription answer = new TopicSubscription(broker, context, info, usageManager);
1:                     entry.configure(broker, usageManager, answer);
commit:6d8e2c5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.SystemUsage;
/////////////////////////////////////////////////////////////////////////
1:     public TopicRegion(RegionBroker broker, DestinationStatistics destinationStatistics, SystemUsage memoryManager, TaskRunnerFactory taskRunnerFactory,
/////////////////////////////////////////////////////////////////////////
0:         return "TopicRegion: destinations=" + destinations.size() + ", subscriptions=" + subscriptions.size() + ", memory=" + memoryManager.getMemoryUsage().getPercentUsage() + "%";
commit:350a2aa
/////////////////////////////////////////////////////////////////////////
0:             String subscriptionName=info.getSubscriptionName();
0:             SubscriptionKey key=new SubscriptionKey(clientId,subscriptionName);
0:                             +subscriptionName);
/////////////////////////////////////////////////////////////////////////
1:         rc.setSubscriptionName(info.getSubscriptionName());
commit:8de60cf
/////////////////////////////////////////////////////////////////////////
0:                 sub=new DurableTopicSubscription(broker,memoryManager,context,info,keepDurableSubsActive);
commit:0c0be94
/////////////////////////////////////////////////////////////////////////
0:             sub.activate(memoryManager,context,info);
/////////////////////////////////////////////////////////////////////////
0:     protected Subscription createSubscription(ConnectionContext context,ConsumerInfo info) throws JMSException{
0:         if(info.isDurable()){
0:             if(AdvisorySupport.isAdvisoryTopic(info.getDestination())){
0:             SubscriptionKey key=new SubscriptionKey(context.getClientId(),info.getSubscriptionName());
0:             DurableTopicSubscription sub=(DurableTopicSubscription)durableSubscriptions.get(key);
0:                 sub=new DurableTopicSubscription(broker,context,info,keepDurableSubsActive);
0:                 ActiveMQDestination destination=info.getDestination();
0:                 if(destination!=null&&broker.getDestinationPolicy()!=null){
0:                     PolicyEntry entry=broker.getDestinationPolicy().getEntryFor(destination);
0:                     if(entry!=null){
0:                         entry.configure(broker,memoryManager,sub);
0:                     }
0:                 }
0:             }else{
0:         try{
0:             TopicSubscription answer=new TopicSubscription(broker,context,info,memoryManager);
0:             ActiveMQDestination destination=info.getDestination();
0:             if(destination!=null&&broker.getDestinationPolicy()!=null){
0:                 PolicyEntry entry=broker.getDestinationPolicy().getEntryFor(destination);
0:                 if(entry!=null){
0:                     entry.configure(broker,memoryManager,answer);
1:             answer.init();
0:         }catch(Exception e){
0:             log.error("Failed to create TopicSubscription ",e);
0:             JMSException jmsEx=new JMSException("Couldn't create TopicSubscription");
0:             jmsEx.setLinkedException(e);
0:             throw jmsEx;
commit:3bf0245
/////////////////////////////////////////////////////////////////////////
0:                 cursor.setUsageManager(memoryManager);
commit:3a9299b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.cursors.PendingMessageCursor;
/////////////////////////////////////////////////////////////////////////
0:     public Subscription addConsumer(ConnectionContext context,ConsumerInfo info) throws Exception{
0:         if(info.isDurable()){
0:             ActiveMQDestination destination=info.getDestination();
0:             if(!destination.isPattern()){
0:                 lookup(context,destination);
0:             String clientId=context.getClientId();
0:             String subcriptionName=info.getSubcriptionName();
0:             SubscriptionKey key=new SubscriptionKey(clientId,subcriptionName);
0:             DurableTopicSubscription sub=(DurableTopicSubscription)durableSubscriptions.get(key);
0:             if(sub!=null){
0:                 if(sub.isActive()){
0:                     throw new JMSException("Durable consumer is in use for client: "+clientId+" and subscriptionName: "
0:                             +subcriptionName);
0:                 if(hasDurableSubChanged(info,sub.getConsumerInfo())){
0:                     for(Iterator iter=destinations.values().iterator();iter.hasNext();){
0:                         Topic topic=(Topic)iter.next();
0:                         topic.deleteSubscription(context,key);
0:                     super.removeConsumer(context,sub.getConsumerInfo());
0:                     super.addConsumer(context,info);
0:                     sub=(DurableTopicSubscription)durableSubscriptions.get(key);
0:                 }else{
0:                     if(sub.getConsumerInfo().getConsumerId()!=null)
0:                     subscriptions.put(info.getConsumerId(),sub);
0:                 }
0:             }else{
0:                 super.addConsumer(context,info);
0:                 sub=(DurableTopicSubscription)durableSubscriptions.get(key);
0:                 if(sub==null){
0:                     throw new JMSException("Cannot use the same consumerId: "+info.getConsumerId()
0:                             +" for two different durable subscriptions clientID: "+key.getClientId()
0:                             +" subscriberName: "+key.getSubscriptionName());
0:             sub.activate(context,info);
0:         }else{
0:             return super.addConsumer(context,info);
/////////////////////////////////////////////////////////////////////////
0:             if(sub==null){
0:                 PendingMessageCursor cursor=broker.getPendingDurableSubscriberPolicy().getSubscriberPendingMessageCursor(
0:                         context.getClientId(),info.getSubcriptionName(),broker.getTempDataStore(),
0:                         info.getPrefetchSize());
0:                 sub=new DurableTopicSubscription(broker,context,info,keepDurableSubsActive,cursor);
0:                 durableSubscriptions.put(key,sub);
commit:4eef609
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.advisory.AdvisorySupport;
/////////////////////////////////////////////////////////////////////////
0:             if (AdvisorySupport.isAdvisoryTopic(info.getDestination())){
1:                 throw new JMSException("Cannot create a durable subscription for an advisory Topic");
0:             }
commit:bfaff9b
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             DestinationFactory destinationFactory) {
0:         super(broker,destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
/////////////////////////////////////////////////////////////////////////
0:         Topic topic = (Topic) super.createDestination(context, destination);
0:  
0:         recoverDurableSubscriptions(context, topic);
0:         return topic;
0:     }
0: 
0:     private void recoverDurableSubscriptions(ConnectionContext context, Topic topic) throws IOException, JMSException, Exception {
0:         TopicMessageStore store = (TopicMessageStore) topic.getMessageStore();
/////////////////////////////////////////////////////////////////////////
commit:b792f11
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.advisory.AdvisorySupport;
/////////////////////////////////////////////////////////////////////////
0:         TopicMessageStore store = null;
0:         if (!AdvisorySupport.isAdvisoryTopic(destination)){
0:             store = persistenceAdapter.createTopicMessageStore((ActiveMQTopic) destination);
0:         }
0:         
commit:6cb66e4
/////////////////////////////////////////////////////////////////////////
0:    
0:     public TopicRegion(RegionBroker broker,DestinationStatistics destinationStatistics, UsageManager memoryManager, TaskRunnerFactory taskRunnerFactory,
0:             PersistenceAdapter persistenceAdapter) {
0:         
/////////////////////////////////////////////////////////////////////////
1:         if (broker.getDestinationPolicy() != null) {
1:             PolicyEntry entry = broker.getDestinationPolicy().getEntryFor(destination);
/////////////////////////////////////////////////////////////////////////
0:             if (destination != null && broker.getDestinationPolicy() != null) {
0:                 PolicyEntry entry = broker.getDestinationPolicy().getEntryFor(destination);
commit:4098942
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.Broker;
/////////////////////////////////////////////////////////////////////////
0:     public TopicRegion(Broker broker,DestinationStatistics destinationStatistics, UsageManager memoryManager, TaskRunnerFactory taskRunnerFactory,
0:         super(broker,destinationStatistics, memoryManager, taskRunnerFactory, persistenceAdapter);
/////////////////////////////////////////////////////////////////////////
0:                 sub = new DurableTopicSubscription(broker,context, info);
/////////////////////////////////////////////////////////////////////////
0:             return new TopicSubscription(broker,context, info, memoryManager);
0:         sub = new DurableTopicSubscription(broker,info);
author:James Strachan
-------------------------------------------------------------------------------
commit:e8c8abc
/////////////////////////////////////////////////////////////////////////
0:                 if (sub == null) {
0:                     throw new JMSException("Cannot use the same consumerId: " + info.getConsumerId() + " for two different durable subscriptions clientID: "
0:                             + key.getClientId() + " subscriberName: " + key.getSubscriptionName());
0:                 }
commit:0def1d4
/////////////////////////////////////////////////////////////////////////
0:     public Subscription addConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:             return sub;
0:             return super.addConsumer(context, info);
commit:900f6e9
/////////////////////////////////////////////////////////////////////////
0:             String clientId = context.getClientId();
0:             String subcriptionName = info.getSubcriptionName();
0:             SubscriptionKey key = new SubscriptionKey(clientId, subcriptionName);
0:                     throw new JMSException("Durable consumer is in use for client: " + clientId + " and subscriptionName: " + subcriptionName);
commit:95d0dec
/////////////////////////////////////////////////////////////////////////
0:             TopicSubscription answer = new TopicSubscription(broker,context, info, memoryManager);
0:             
1:             // lets configure the subscription depending on the destination
0:             ActiveMQDestination destination = info.getDestination();
0:             if (destination != null && policyMap != null) {
0:                 PolicyEntry entry = policyMap.getEntryFor(destination);
0:                 if (entry != null) {
0:                     entry.configure(answer);
0:                 }
0:             }
1:             return answer;
============================================================================