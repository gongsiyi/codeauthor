1:31c55f7: /*
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
5:d29ca2a:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b0c2a40:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.transport.failover;
1:b6b6911: 
1:91059de: import java.io.BufferedReader;
1:91059de: import java.io.FileReader;
1:91059de: import java.io.IOException;
1:91059de: import java.io.InputStreamReader;
1:91059de: import java.io.InterruptedIOException;
1:c55a666: import java.net.InetAddress;
1:c55a666: import java.net.MalformedURLException;
1:c55a666: import java.net.URI;
1:c55a666: import java.net.URISyntaxException;
1:c55a666: import java.net.URL;
1:31c55f7: import java.security.cert.X509Certificate;
1:c55a666: import java.util.ArrayList;
1:c55a666: import java.util.Collections;
1:c55a666: import java.util.HashSet;
1:c55a666: import java.util.Iterator;
1:c55a666: import java.util.LinkedHashMap;
1:c55a666: import java.util.List;
1:c55a666: import java.util.Map;
1:c55a666: import java.util.StringTokenizer;
1:91059de: import java.util.concurrent.CopyOnWriteArrayList;
1:91059de: import java.util.concurrent.atomic.AtomicReference;
1:91059de: 
1:c4d8bc4: import org.apache.activemq.broker.SslContext;
1:d29ca2a: import org.apache.activemq.command.Command;
1:e225ba6: import org.apache.activemq.command.ConnectionControl;
1:8d3ca90: import org.apache.activemq.command.ConnectionId;
1:ffef4dc: import org.apache.activemq.command.ConsumerControl;
1:0227c08: import org.apache.activemq.command.MessageDispatch;
1:0227c08: import org.apache.activemq.command.MessagePull;
1:6c52d28: import org.apache.activemq.command.RemoveInfo;
1:d29ca2a: import org.apache.activemq.command.Response;
1:d29ca2a: import org.apache.activemq.state.ConnectionStateTracker;
1:220ad62: import org.apache.activemq.state.Tracked;
1:d29ca2a: import org.apache.activemq.thread.Task;
1:d29ca2a: import org.apache.activemq.thread.TaskRunner;
1:8a01c5d: import org.apache.activemq.thread.TaskRunnerFactory;
1:d29ca2a: import org.apache.activemq.transport.CompositeTransport;
1:70511a6: import org.apache.activemq.transport.DefaultTransportListener;
1:d29ca2a: import org.apache.activemq.transport.FutureResponse;
1:84fd773: import org.apache.activemq.transport.ResponseCallback;
1:d29ca2a: import org.apache.activemq.transport.Transport;
1:d29ca2a: import org.apache.activemq.transport.TransportFactory;
1:d29ca2a: import org.apache.activemq.transport.TransportListener;
1:d29ca2a: import org.apache.activemq.util.IOExceptionSupport;
1:d29ca2a: import org.apache.activemq.util.ServiceSupport;
1:0ff3593: import org.apache.activemq.util.URISupport;
1:31c55f7: import org.apache.activemq.wireformat.WireFormat;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:ffef4dc: 
1:d29ca2a: /**
1:d29ca2a:  * A Transport that is made reliable by being able to fail over to another
1:d29ca2a:  * transport when a transport failure is detected.
1:d29ca2a:  */
1:d29ca2a: public class FailoverTransport implements CompositeTransport {
1:a3060e7: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(FailoverTransport.class);
1:6ed942a:     private static final int DEFAULT_INITIAL_RECONNECT_DELAY = 10;
1:4acd132:     private static final int INFINITE = -1;
1:d29ca2a:     private TransportListener transportListener;
1:629ee28:     private volatile boolean disposed;
1:933eb2f:     private final CopyOnWriteArrayList<URI> uris = new CopyOnWriteArrayList<URI>();
1:f392884:     private final CopyOnWriteArrayList<URI> updated = new CopyOnWriteArrayList<URI>();
1:c4d8bc4: 
1:d29ca2a:     private final Object reconnectMutex = new Object();
1:cb65470:     private final Object backupMutex = new Object();
1:2bc09bb:     private final Object sleepMutex = new Object();
1:f7fa2bc:     private final Object listenerMutex = new Object();
1:d29ca2a:     private final ConnectionStateTracker stateTracker = new ConnectionStateTracker();
1:6b6cdae:     private final Map<Integer, Command> requestMap = new LinkedHashMap<Integer, Command>();
1:b836af8: 
1:d29ca2a:     private URI connectedTransportURI;
1:3ac0537:     private URI failedConnectTransportURI;
1:c0b74f0:     private final AtomicReference<Transport> connectedTransport = new AtomicReference<Transport>();
1:8a01c5d:     private final TaskRunnerFactory reconnectTaskFactory;
1:d29ca2a:     private final TaskRunner reconnectTask;
1:629ee28:     private volatile boolean started;
1:6ed942a:     private long initialReconnectDelay = DEFAULT_INITIAL_RECONNECT_DELAY;
1:d29ca2a:     private long maxReconnectDelay = 1000 * 30;
1:f3b1ea9:     private double backOffMultiplier = 2d;
1:4acd132:     private long timeout = INFINITE;
1:d29ca2a:     private boolean useExponentialBackOff = true;
1:4098942:     private boolean randomize = true;
1:4acd132:     private int maxReconnectAttempts = INFINITE;
1:4acd132:     private int startupMaxReconnectAttempts = INFINITE;
1:d29ca2a:     private int connectFailures;
1:c55a666:     private int warnAfterReconnectAttempts = 10;
1:6ed942a:     private long reconnectDelay = DEFAULT_INITIAL_RECONNECT_DELAY;
1:d29ca2a:     private Exception connectionFailure;
1:e210657:     private boolean firstConnection = true;
1:f392884:     // optionally always have a backup created
1:f392884:     private boolean backup = false;
1:f392884:     private final List<BackupTransport> backups = new CopyOnWriteArrayList<BackupTransport>();
1:f392884:     private int backupPoolSize = 1;
1:c0b00b2:     private boolean trackMessages = false;
1:b9e51d6:     private boolean trackTransactionProducers = true;
1:e225ba6:     private int maxCacheSize = 128 * 1024;
1:23a5beb:     private final TransportListener disposedListener = new DefaultTransportListener() {};
1:b6b6911:     private boolean updateURIsSupported = true;
1:b6b6911:     private boolean reconnectSupported = true;
1:c4d8bc4:     // remember for reconnect thread
1:c4d8bc4:     private SslContext brokerSslContext;
1:c14c7e7:     private String updateURIsURL = null;
1:b6b6911:     private boolean rebalanceUpdateURIs = true;
1:c752230:     private boolean doRebalance = false;
1:7388438:     private boolean connectedToPriority = false;
1:7388438: 
1:7388438:     private boolean priorityBackup = false;
1:fbac51c:     private final ArrayList<URI> priorityList = new ArrayList<URI>();
1:7388438:     private boolean priorityBackupAvailable = false;
1:0ff3593:     private String nestedExtraQueryOptions;
1:629ee28:     private volatile boolean shuttingDown = false;
1:b836af8: 
1:0a12bcb:     public FailoverTransport() {
1:c4d8bc4:         brokerSslContext = SslContext.getCurrentSslContext();
1:f812e34:         stateTracker.setTrackTransactions(true);
1:d29ca2a:         // Setup a task that is used to reconnect the a connection async.
1:8a01c5d:         reconnectTaskFactory = new TaskRunnerFactory();
1:8a01c5d:         reconnectTaskFactory.init();
1:8a01c5d:         reconnectTask = reconnectTaskFactory.createTaskRunner(new Task() {
1:fbac51c:             @Override
1:d29ca2a:             public boolean iterate() {
1:f392884:                 boolean result = false;
1:f4e0725:                 if (!started) {
1:f4e0725:                     return result;
1:19cb932:                 }
1:f392884:                 boolean buildBackup = true;
1:f392884:                 synchronized (backupMutex) {
1:7388438:                     if ((connectedTransport.get() == null || doRebalance || priorityBackupAvailable) && !disposed) {
1:f392884:                         result = doReconnect();
1:f392884:                         buildBackup = false;
1:beda82a:                     }
1:19cb932:                 }
1:f392884:                 if (buildBackup) {
1:19cb932:                     buildBackups();
1:7388438:                     if (priorityBackup && !connectedToPriority) {
1:7388438:                         try {
1:7388438:                             doDelay();
1:d92d3a8:                             if (reconnectTask == null) {
1:d92d3a8:                                 return true;
1:7388438:                             }
1:7388438:                             reconnectTask.wakeup();
1:7388438:                         } catch (InterruptedException e) {
1:7388438:                             LOG.debug("Reconnect task has been interrupted.", e);
1:7388438:                         }
1:7388438:                     }
1:1d52f3b:                 } else {
1:f392884:                     // build backups on the next iteration
1:986ed14:                     buildBackup = true;
1:1d52f3b:                     try {
1:d92d3a8:                         if (reconnectTask == null) {
1:fbac51c:                             return true;
1:d92d3a8:                         }
2:d29ca2a:                         reconnectTask.wakeup();
1:b6b6911:                     } catch (InterruptedException e) {
1:da6c2d6:                         LOG.debug("Reconnect task has been interrupted.", e);
1:d92d3a8:                     }
1:a3060e7:                 }
1:f392884:                 return result;
1:1d52f3b:             }
1:bc1ca6c: 
1:f812e34:         }, "ActiveMQ Failover Worker: " + System.identityHashCode(this));
1:23a5beb:     }
1:0ff3593: 
1:23a5beb:     private void processCommand(Object incoming) {
1:23a5beb:         Command command = (Command) incoming;
1:23a5beb:         if (command == null) {
1:23a5beb:             return;
1:23a5beb:         }
1:23a5beb:         if (command.isResponse()) {
1:23a5beb:             Object object = null;
1:23a5beb:             synchronized (requestMap) {
1:23a5beb:                 object = requestMap.remove(Integer.valueOf(((Response) command).getCorrelationId()));
1:23a5beb:             }
1:23a5beb:             if (object != null && object.getClass() == Tracked.class) {
1:23a5beb:                 ((Tracked) object).onResponses(command);
1:23a5beb:             }
1:23a5beb:         }
1:23a5beb: 
1:23a5beb:         if (command.isConnectionControl()) {
1:23a5beb:             handleConnectionControl((ConnectionControl) command);
1:23a5beb:         } else if (command.isConsumerControl()) {
1:ffef4dc:             ConsumerControl consumerControl = (ConsumerControl)command;
1:ffef4dc:             if (consumerControl.isClose()) {
1:ffef4dc:                 stateTracker.processRemoveConsumer(consumerControl.getConsumerId(), RemoveInfo.LAST_DELIVERED_UNKNOWN);
1:ffef4dc:             }
1:ffef4dc:         }
1:ffef4dc: 
1:23a5beb:         if (transportListener != null) {
1:23a5beb:             transportListener.onCommand(command);
1:23a5beb:         }
1:23a5beb:     }
1:23a5beb: 
1:23a5beb:     private TransportListener createTransportListener(final Transport owner) {
1:933eb2f:         return new TransportListener() {
1:23a5beb: 
1:fbac51c:             @Override
1:933eb2f:             public void onCommand(Object o) {
1:23a5beb:                 processCommand(o);
1:23a5beb:             }
1:23a5beb: 
1:fbac51c:             @Override
1:933eb2f:             public void onException(IOException error) {
1:b6b6911:                 try {
1:23a5beb:                     handleTransportFailure(owner, error);
1:933eb2f:                 } catch (InterruptedException e) {
1:b6b6911:                     Thread.currentThread().interrupt();
1:23a5beb:                     if (transportListener != null) {
1:23a5beb:                         transportListener.onException(new InterruptedIOException());
1:23a5beb:                     }
1:4a12796:                 }
1:b6b6911:             }
1:0ff3593: 
1:fbac51c:             @Override
1:933eb2f:             public void transportInterupted() {
1:b6b6911:             }
1:4a12796: 
1:fbac51c:             @Override
1:933eb2f:             public void transportResumed() {
1:b6b6911:             }
1:933eb2f:         };
1:f4e0725:     }
1:1d52f3b: 
1:6c09e84:     public final void disposeTransport(Transport transport) {
1:6c09e84:         transport.setTransportListener(disposedListener);
1:6c09e84:         ServiceSupport.dispose(transport);
1:6c09e84:     }
1:6c09e84: 
1:b34f730:     public final void handleTransportFailure(IOException e) throws InterruptedException {
1:23a5beb:         handleTransportFailure(getConnectedTransport(), e);
1:23a5beb:     }
1:23a5beb: 
1:23a5beb:     public final void handleTransportFailure(Transport failed, IOException e) throws InterruptedException {
1:3ef5389:         if (shuttingDown) {
1:3ef5389:             // shutdown info sent and remote socket closed and we see that before a local close
1:3ef5389:             // let the close do the work
1:3ef5389:             return;
1:3ef5389:         }
1:3ef5389: 
1:3ef5389:         if (LOG.isTraceEnabled()) {
1:3ef5389:             LOG.trace(this + " handleTransportFailure: " + e, e);
1:3ef5389:         }
1:3ef5389: 
1:3ef5389:         // could be blocked in write with the reconnectMutex held, but still needs to be whacked
1:23a5beb:         Transport transport = null;
1:23a5beb: 
1:23a5beb:         if (connectedTransport.compareAndSet(failed, null)) {
1:23a5beb:             transport = failed;
1:3ef5389:             if (transport != null) {
1:3ef5389:                 disposeTransport(transport);
1:3ef5389:             }
1:23a5beb:         }
1:3ef5389: 
1:bc1ca6c:         synchronized (reconnectMutex) {
1:3ef5389:             if (transport != null && connectedTransport.get() == null) {
1:bc1ca6c:                 boolean reconnectOk = false;
1:ce911ba: 
1:4acd132:                 if (canReconnect()) {
1:c04d8c5:                     reconnectOk = true;
1:ce911ba:                 }
1:23a5beb: 
1:23a5beb:                 LOG.warn("Transport ({}) failed {} attempting to automatically reconnect: {}",
1:3560d91:                          connectedTransportURI, (reconnectOk ? "," : ", not"), e);
1:bc1ca6c: 
1:f392884:                 failedConnectTransportURI = connectedTransportURI;
1:d29ca2a:                 connectedTransportURI = null;
1:e777126:                 connectedToPriority = false;
1:bc1ca6c: 
1:62eb5cf:                 if (reconnectOk) {
1:4f19f31:                     // notify before any reconnect attempt so ack state can be whacked
1:4f19f31:                     if (transportListener != null) {
1:4f19f31:                         transportListener.transportInterupted();
1:4f19f31:                     }
1:4f19f31: 
1:91059de:                     updated.remove(failedConnectTransportURI);
1:c04d8c5:                     reconnectTask.wakeup();
1:ce50e28:                 } else if (!isDisposed()) {
1:4acd132:                     propagateFailureToExceptionListener(e);
1:7d8ce02:                 }
1:5a03c37:             }
1:62eb5cf:         }
1:62eb5cf:     }
1:4a12796: 
1:4acd132:     private boolean canReconnect() {
1:4acd132:         return started && 0 != calculateReconnectAttemptLimit();
1:4acd132:     }
1:1d52f3b: 
1:f392884:     public final void handleConnectionControl(ConnectionControl control) {
1:f392884:         String reconnectStr = control.getReconnectTo();
1:bc1ca6c:         if (LOG.isTraceEnabled()) {
1:3a8eb74:             LOG.trace("Received ConnectionControl: {}", control);
1:3a8eb74:         }
1:3a8eb74: 
1:f392884:         if (reconnectStr != null) {
1:f392884:             reconnectStr = reconnectStr.trim();
1:f392884:             if (reconnectStr.length() > 0) {
1:933eb2f:                 try {
1:f392884:                     URI uri = new URI(reconnectStr);
1:f392884:                     if (isReconnectSupported()) {
1:f392884:                         reconnect(uri);
1:f392884:                         LOG.info("Reconnected to: " + uri);
1:132f662:                     }
1:f392884:                 } catch (Exception e) {
1:f392884:                     LOG.error("Failed to handle ConnectionControl reconnect to " + reconnectStr, e);
1:c04d8c5:                 }
1:c04d8c5:             }
1:c04d8c5:         }
1:c14c7e7:         processNewTransports(control.isRebalanceConnection(), control.getConnectedBrokers());
1:c6b88f1:     }
1:7d8ce02: 
1:c14c7e7:     private final void processNewTransports(boolean rebalance, String newTransports) {
1:c14c7e7:         if (newTransports != null) {
1:c14c7e7:             newTransports = newTransports.trim();
1:c14c7e7:             if (newTransports.length() > 0 && isUpdateURIsSupported()) {
1:f392884:                 List<URI> list = new ArrayList<URI>();
1:c14c7e7:                 StringTokenizer tokenizer = new StringTokenizer(newTransports, ",");
1:f392884:                 while (tokenizer.hasMoreTokens()) {
1:f392884:                     String str = tokenizer.nextToken();
1:f812e34:                     try {
1:f392884:                         URI uri = new URI(str);
1:f392884:                         list.add(uri);
1:f392884:                     } catch (Exception e) {
1:f392884:                         LOG.error("Failed to parse broker address: " + str, e);
1:933eb2f:                     }
1:933eb2f:                 }
1:f392884:                 if (list.isEmpty() == false) {
1:f812e34:                     try {
1:c14c7e7:                         updateURIs(rebalance, list.toArray(new URI[list.size()]));
1:f392884:                     } catch (IOException e) {
1:c14c7e7:                         LOG.error("Failed to update transport URI's from: " + newTransports, e);
1:933eb2f:                     }
1:933eb2f:                 }
1:933eb2f:             }
1:933eb2f:         }
1:933eb2f:     }
1:7d8ce02: 
1:fbac51c:     @Override
1:d29ca2a:     public void start() throws Exception {
1:8d3ca90:         synchronized (reconnectMutex) {
1:23a5beb:             LOG.debug("Started {}", this);
1:fc00993:             if (started) {
1:ce911ba:                 return;
1:933eb2f:             }
1:d29ca2a:             started = true;
1:e225ba6:             stateTracker.setMaxCacheSize(getMaxCacheSize());
1:e225ba6:             stateTracker.setTrackMessages(isTrackMessages());
1:b9e51d6:             stateTracker.setTrackTransactionProducers(isTrackTransactionProducers());
1:c0b74f0:             if (connectedTransport.get() != null) {
1:c0b74f0:                 stateTracker.restore(connectedTransport.get());
1:4acd132:             } else {
1:f392884:                 reconnect(false);
1:933eb2f:             }
1:933eb2f:         }
1:933eb2f:     }
1:7d8ce02: 
1:fbac51c:     @Override
1:d29ca2a:     public void stop() throws Exception {
1:f392884:         Transport transportToStop = null;
1:14e636b:         List<Transport> backupsToStop = new ArrayList<Transport>(backups.size());
1:14e636b: 
1:8a01c5d:         try {
1:8a01c5d:             synchronized (reconnectMutex) {
1:8a01c5d:                 if (LOG.isDebugEnabled()) {
1:23a5beb:                     LOG.debug("Stopped {}", this);
1:8a01c5d:                 }
1:8a01c5d:                 if (!started) {
1:8a01c5d:                     return;
1:8a01c5d:                 }
1:8a01c5d:                 started = false;
1:8a01c5d:                 disposed = true;
1:e777126: 
1:8a01c5d:                 if (connectedTransport.get() != null) {
1:8a01c5d:                     transportToStop = connectedTransport.getAndSet(null);
1:8a01c5d:                 }
1:8a01c5d:                 reconnectMutex.notifyAll();
1:4acd132:             }
1:8a01c5d:             synchronized (sleepMutex) {
1:8a01c5d:                 sleepMutex.notifyAll();
1:8a01c5d:             }
1:8a01c5d:         } finally {
1:8a01c5d:             reconnectTask.shutdown();
1:8a01c5d:             reconnectTaskFactory.shutdownNow();
1:4acd132:         }
1:8a01c5d: 
1:205d025:         synchronized(backupMutex) {
1:205d025:             for (BackupTransport backup : backups) {
1:205d025:                 backup.setDisposed(true);
1:205d025:                 Transport transport = backup.getTransport();
1:23a5beb:                 if (transport != null) {
1:205d025:                     transport.setTransportListener(disposedListener);
1:205d025:                     backupsToStop.add(transport);
1:205d025:                 }
1:205d025:             }
1:205d025:             backups.clear();
1:14e636b:         }
1:14e636b:         for (Transport transport : backupsToStop) {
1:ac66a09:             try {
1:23a5beb:                 LOG.trace("Stopped backup: {}", transport);
1:23a5beb:                 disposeTransport(transport);
1:f392884:             } catch (Exception e) {
1:205d025:             }
1:4acd132:         }
1:205d025:         if (transportToStop != null) {
1:205d025:             transportToStop.stop();
1:205d025:         }
1:14e636b:     }
1:b6b6911: 
1:d29ca2a:     public long getInitialReconnectDelay() {
1:d29ca2a:         return initialReconnectDelay;
1:14e636b:     }
1:b6b6911: 
1:d29ca2a:     public void setInitialReconnectDelay(long initialReconnectDelay) {
1:d29ca2a:         this.initialReconnectDelay = initialReconnectDelay;
1:4acd132:     }
1:b6b6911: 
1:d29ca2a:     public long getMaxReconnectDelay() {
1:d29ca2a:         return maxReconnectDelay;
1:132f662:     }
1:b6b6911: 
1:d29ca2a:     public void setMaxReconnectDelay(long maxReconnectDelay) {
1:d29ca2a:         this.maxReconnectDelay = maxReconnectDelay;
1:487e694:     }
1:b6b6911: 
1:d29ca2a:     public long getReconnectDelay() {
1:d29ca2a:         return reconnectDelay;
1:933eb2f:     }
1:b6b6911: 
1:d29ca2a:     public void setReconnectDelay(long reconnectDelay) {
1:d29ca2a:         this.reconnectDelay = reconnectDelay;
1:933eb2f:     }
1:b6b6911: 
1:f3b1ea9:     public double getReconnectDelayExponent() {
1:d29ca2a:         return backOffMultiplier;
1:fc00993:     }
1:4acd132: 
1:f3b1ea9:     public void setReconnectDelayExponent(double reconnectDelayExponent) {
1:d29ca2a:         this.backOffMultiplier = reconnectDelayExponent;
1:fc00993:     }
1:4acd132: 
1:d29ca2a:     public Transport getConnectedTransport() {
1:c0b74f0:         return connectedTransport.get();
1:fc00993:     }
1:738e9a1: 
1:d29ca2a:     public URI getConnectedTransportURI() {
1:d29ca2a:         return connectedTransportURI;
1:f812e34:     }
1:4eafccc: 
1:d29ca2a:     public int getMaxReconnectAttempts() {
1:d29ca2a:         return maxReconnectAttempts;
1:f812e34:     }
1:62eb5cf: 
1:d29ca2a:     public void setMaxReconnectAttempts(int maxReconnectAttempts) {
1:d29ca2a:         this.maxReconnectAttempts = maxReconnectAttempts;
1:f812e34:     }
1:62eb5cf: 
1:3720e84:     public int getStartupMaxReconnectAttempts() {
1:3720e84:         return this.startupMaxReconnectAttempts;
1:f812e34:     }
1:c04d8c5: 
1:3720e84:     public void setStartupMaxReconnectAttempts(int startupMaxReconnectAttempts) {
1:3720e84:         this.startupMaxReconnectAttempts = startupMaxReconnectAttempts;
1:f812e34:     }
1:c04d8c5: 
1:4a12796:     public long getTimeout() {
1:4a12796:         return timeout;
1:4a12796:     }
1:4a12796: 
1:4a12796:     public void setTimeout(long timeout) {
1:4a12796:         this.timeout = timeout;
1:4a12796:     }
1:4a12796: 
1:4a12796:     /**
1:4098942:      * @return Returns the randomize.
2:6c52d28:      */
1:f812e34:     public boolean isRandomize() {
1:4098942:         return randomize;
1:f812e34:     }
1:c04d8c5: 
1:d29ca2a:     /**
1:b6b6911:      * @param randomize The randomize to set.
1:6c52d28:      */
1:f812e34:     public void setRandomize(boolean randomize) {
1:f812e34:         this.randomize = randomize;
1:f812e34:     }
1:c6b88f1: 
1:418823a:     public boolean isBackup() {
1:f392884:         return backup;
1:f812e34:     }
1:c6b88f1: 
1:f392884:     public void setBackup(boolean backup) {
1:f392884:         this.backup = backup;
1:f812e34:     }
1:c0b74f0: 
1:f392884:     public int getBackupPoolSize() {
1:f392884:         return backupPoolSize;
1:f812e34:     }
1:933eb2f: 
1:f392884:     public void setBackupPoolSize(int backupPoolSize) {
1:f392884:         this.backupPoolSize = backupPoolSize;
1:f812e34:     }
1:933eb2f: 
1:7d8ce02:     public int getCurrentBackups() {
1:7d8ce02:         return this.backups.size();
1:7d8ce02:     }
1:7d8ce02: 
1:f392884:     public boolean isTrackMessages() {
1:e225ba6:         return trackMessages;
1:f812e34:     }
1:933eb2f: 
1:e225ba6:     public void setTrackMessages(boolean trackMessages) {
1:e225ba6:         this.trackMessages = trackMessages;
1:f812e34:     }
1:933eb2f: 
1:b9e51d6:     public boolean isTrackTransactionProducers() {
1:b9e51d6:         return this.trackTransactionProducers;
1:b9e51d6:     }
1:b9e51d6: 
1:b9e51d6:     public void setTrackTransactionProducers(boolean trackTransactionProducers) {
1:b9e51d6:         this.trackTransactionProducers = trackTransactionProducers;
1:b9e51d6:     }
1:b9e51d6: 
1:e225ba6:     public int getMaxCacheSize() {
1:e225ba6:         return maxCacheSize;
1:f812e34:     }
1:f812e34: 
1:e225ba6:     public void setMaxCacheSize(int maxCacheSize) {
1:e225ba6:         this.maxCacheSize = maxCacheSize;
1:220ad62:     }
1:f812e34: 
1:7388438:     public boolean isPriorityBackup() {
1:7388438:         return priorityBackup;
1:7388438:     }
1:7388438: 
1:7388438:     public void setPriorityBackup(boolean priorityBackup) {
1:7388438:         this.priorityBackup = priorityBackup;
1:7388438:     }
1:7388438: 
1:7388438:     public void setPriorityURIs(String priorityURIs) {
1:7388438:         StringTokenizer tokenizer = new StringTokenizer(priorityURIs, ",");
1:7388438:         while (tokenizer.hasMoreTokens()) {
1:7388438:             String str = tokenizer.nextToken();
1:7388438:             try {
1:7388438:                 URI uri = new URI(str);
1:7388438:                 priorityList.add(uri);
1:7388438:             } catch (Exception e) {
1:7388438:                 LOG.error("Failed to parse broker address: " + str, e);
1:7388438:             }
1:7388438:         }
1:7388438:     }
1:7388438: 
1:fbac51c:     @Override
1:9ca56a0:     public void oneway(Object o) throws IOException {
1:cdd2108: 
1:9ca56a0:         Command command = (Command) o;
1:d29ca2a:         Exception error = null;
1:14e636b:         try {
1:f812e34: 
1:c04d8c5:             synchronized (reconnectMutex) {
1:f812e34: 
1:ad76330:                 if (command != null && connectedTransport.get() == null) {
1:f392884:                     if (command.isShutdownInfo()) {
1:ad76330:                         // Skipping send of ShutdownInfo command when not connected.
1:933eb2f:                         return;
1:ad76330:                     } else if (command instanceof RemoveInfo || command.isMessageAck()) {
1:ad76330:                         // Simulate response to RemoveInfo command or MessageAck (as it will be stale)
1:9383c6d:                         stateTracker.track(command);
1:7d8ce02:                         if (command.isResponseRequired()) {
1:7d8ce02:                             Response response = new Response();
1:7d8ce02:                             response.setCorrelationId(command.getCommandId());
1:23a5beb:                             processCommand(response);
1:7d8ce02:                         }
1:f812e34:                         return;
1:0227c08:                     } else if (command instanceof MessagePull) {
1:0227c08:                         // Simulate response to MessagePull if timed as we can't honor that now.
1:14e636b:                         MessagePull pullRequest = (MessagePull) command;
1:14e636b:                         if (pullRequest.getTimeout() != 0) {
1:14e636b:                             MessageDispatch dispatch = new MessageDispatch();
1:14e636b:                             dispatch.setConsumerId(pullRequest.getConsumerId());
1:14e636b:                             dispatch.setDestination(pullRequest.getDestination());
1:23a5beb:                             processCommand(dispatch);
1:0227c08:                         }
1:0227c08:                         return;
1:ad76330:                     }
1:220ad62:                 }
1:ad76330: 
1:d29ca2a:                 // Keep trying until the message is sent.
1:f812e34:                 for (int i = 0; !disposed; i++) {
1:d29ca2a:                     try {
1:f812e34: 
1:d29ca2a:                         // Wait for transport to be connected.
1:cdd2108:                         Transport transport = connectedTransport.get();
1:4a12796:                         long start = System.currentTimeMillis();
1:4a12796:                         boolean timedout = false;
1:f392884:                         while (transport == null && !disposed && connectionFailure == null
1:8514e38:                                 && !Thread.currentThread().isInterrupted() && willReconnect()) {
1:23a5beb: 
1:23a5beb:                             LOG.trace("Waiting for transport to reconnect..: {}", command);
1:4a12796:                             long end = System.currentTimeMillis();
1:8824ac9:                             if (command.isMessage() && timeout > 0 && (end - start > timeout)) {
1:4a12796:                                 timedout = true;
1:23a5beb:                                 LOG.info("Failover timed out after {} ms", (end - start));
1:4a12796:                                 break;
1:4a12796:                             }
1:d29ca2a:                             try {
1:4a12796:                                 reconnectMutex.wait(100);
1:f812e34:                             } catch (InterruptedException e) {
1:933eb2f:                                 Thread.currentThread().interrupt();
1:23a5beb:                                 LOG.debug("Interupted:", e);
1:7d8ce02:                             }
1:cdd2108:                             transport = connectedTransport.get();
1:7d8ce02:                         }
1:c0b74f0: 
1:5a03c37:                         if (transport == null) {
1:d29ca2a:                             // Previous loop may have exited due to use being
1:d29ca2a:                             // disposed.
1:d29ca2a:                             if (disposed) {
1:d29ca2a:                                 error = new IOException("Transport disposed.");
1:f812e34:                             } else if (connectionFailure != null) {
1:d29ca2a:                                 error = connectionFailure;
1:4a12796:                             } else if (timedout == true) {
1:4a12796:                                 error = new IOException("Failover timeout of " + timeout + " ms reached.");
1:8514e38:                             } else if (!willReconnect()) {
1:8514e38:                                 error = new IOException("Reconnect attempts of " + maxReconnectAttempts + " exceeded");
1:1d52f3b:                             } else {
1:d29ca2a:                                 error = new IOException("Unexpected failure.");
1:5a03c37:                             }
1:fbac51c:                             break;
1:5a03c37:                         }
1:f812e34: 
1:8188f7f:                         Tracked tracked = null;
1:8188f7f:                         try {
1:8188f7f:                             tracked = stateTracker.track(command);
1:8188f7f:                         } catch (IOException ioe) {
1:23a5beb:                             LOG.debug("Cannot track the command {} {}", command, ioe);
1:8188f7f:                         }
1:d29ca2a:                         // If it was a request and it was not being tracked by
1:d29ca2a:                         // the state tracker,
1:d29ca2a:                         // then hold it in the requestMap so that we can replay
1:d29ca2a:                         // it later.
1:f392884:                         synchronized (requestMap) {
1:f812e34:                             if (tracked != null && tracked.isWaitingForResponse()) {
1:6b6cdae:                                 requestMap.put(Integer.valueOf(command.getCommandId()), tracked);
1:f812e34:                             } else if (tracked == null && command.isResponseRequired()) {
1:6b6cdae:                                 requestMap.put(Integer.valueOf(command.getCommandId()), command);
1:c0b74f0:                             }
1:220ad62:                         }
1:f812e34: 
1:d29ca2a:                         // Send the message.
1:d29ca2a:                         try {
1:cdd2108:                             transport.oneway(command);
1:e225ba6:                             stateTracker.trackBack(command);
1:ce911ba:                             if (command.isShutdownInfo()) {
1:ce911ba:                                 shuttingDown = true;
1:ce911ba:                             }
1:b6b6911:                         } catch (IOException e) {
1:f812e34: 
1:f812e34:                             // If the command was not tracked.. we will retry in
1:f812e34:                             // this method
1:ae9af4b:                             if (tracked == null && canReconnect()) {
1:f812e34: 
1:f812e34:                                 // since we will retry in this method.. take it
1:f812e34:                                 // out of the request
1:f812e34:                                 // map so that it is not sent 2 times on
1:f812e34:                                 // recovery
1:ad76330:                                 if (command.isResponseRequired()) {
1:f812e34:                                     requestMap.remove(Integer.valueOf(command.getCommandId()));
1:f812e34:                                 }
1:f812e34: 
1:f812e34:                                 // Rethrow the exception so it will handled by
1:f812e34:                                 // the outer catch
1:220ad62:                                 throw e;
1:a7e7bce:                             } else {
1:a7e7bce:                                 // Handle the error but allow the method to return since the
1:a7e7bce:                                 // tracked commands are replayed on reconnect.
1:23a5beb:                                 LOG.debug("Send oneway attempt: {} failed for command: {}", i, command);
1:a7e7bce:                                 handleTransportFailure(e);
1:a7e7bce:                             }
1:f812e34:                         }
1:f812e34: 
1:ac66a09:                         return;
1:f812e34:                     } catch (IOException e) {
1:23a5beb:                         LOG.debug("Send oneway attempt: {} failed for command: {}", i, command);
1:d29ca2a:                         handleTransportFailure(e);
1:295850d:                     }
1:ac66a09:                 }
1:ac66a09:             }
1:f812e34:         } catch (InterruptedException e) {
1:d29ca2a:             // Some one may be trying to stop our thread.
1:f812e34:             Thread.currentThread().interrupt();
1:d29ca2a:             throw new InterruptedIOException();
1:ac66a09:         }
1:7d8ce02: 
1:f812e34:         if (!disposed) {
1:f812e34:             if (error != null) {
1:fc00993:                 if (error instanceof IOException) {
1:f392884:                     throw (IOException) error;
1:fc00993:                 }
1:d29ca2a:                 throw IOExceptionSupport.create(error);
1:f812e34:             }
1:ac66a09:         }
1:ac66a09:     }
1:f812e34: 
1:8514e38:     private boolean willReconnect() {
1:8514e38:         return firstConnection || 0 != calculateReconnectAttemptLimit();
1:8514e38:     }
1:8514e38: 
1:fbac51c:     @Override
1:9ca56a0:     public FutureResponse asyncRequest(Object command, ResponseCallback responseCallback) throws IOException {
1:d29ca2a:         throw new AssertionError("Unsupported Method");
1:ac66a09:     }
1:f812e34: 
1:fbac51c:     @Override
1:9ca56a0:     public Object request(Object command) throws IOException {
1:d29ca2a:         throw new AssertionError("Unsupported Method");
1:ac66a09:     }
1:f812e34: 
1:fbac51c:     @Override
1:f812e34:     public Object request(Object command, int timeout) throws IOException {
1:5fe0a4c:         throw new AssertionError("Unsupported Method");
1:ac66a09:     }
1:f812e34: 
1:fbac51c:     @Override
1:f392884:     public void add(boolean rebalance, URI u[]) {
1:f392884:         boolean newURI = false;
1:b6b6911:         for (URI uri : u) {
1:b6b6911:             if (!contains(uri)) {
1:b6b6911:                 uris.add(uri);
1:f392884:                 newURI = true;
1:fc00993:             }
1:ac66a09:         }
1:f392884:         if (newURI) {
1:91059de:             reconnect(rebalance);
1:ac66a09:         }
1:ac66a09:     }
1:f812e34: 
1:fbac51c:     @Override
1:f392884:     public void remove(boolean rebalance, URI u[]) {
1:b6b6911:         for (URI uri : u) {
1:b6b6911:             uris.remove(uri);
1:ac66a09:         }
1:c752230:         // rebalance is automatic if any connected to removed/stopped broker
1:ac66a09:     }
1:f812e34: 
1:f392884:     public void add(boolean rebalance, String u) {
1:f812e34:         try {
1:f392884:             URI newURI = new URI(u);
1:b6b6911:             if (contains(newURI) == false) {
1:f392884:                 uris.add(newURI);
3:f392884:                 reconnect(rebalance);
11:d29ca2a:             }
1:b6b6911: 
1:14e636b:         } catch (Exception e) {
1:23a5beb:             LOG.error("Failed to parse URI: {}", u);
1:d29ca2a:         }
1:d29ca2a:     }
1:220ad62: 
1:f392884:     public void reconnect(boolean rebalance) {
1:5a03c37:         synchronized (reconnectMutex) {
1:d29ca2a:             if (started) {
1:f392884:                 if (rebalance) {
1:c752230:                     doRebalance = true;
1:d29ca2a:                 }
1:fc00993:                 LOG.debug("Waking up reconnect task");
1:d29ca2a:                 try {
1:14fda24:                     reconnectTask.wakeup();
1:b6b6911:                 } catch (InterruptedException e) {
1:b6b6911:                     Thread.currentThread().interrupt();
1:d29ca2a:                 }
1:d3d58fe:             } else {
1:4a052d2:                 LOG.debug("Reconnect was triggered but transport is not started yet. Wait for start to connect the transport.");
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:220ad62: 
1:e210657:     private List<URI> getConnectList() {
1:beda82a:         if (!updated.isEmpty()) {
1:beda82a:             return updated;
1:beda82a:         }
1:beda82a:         ArrayList<URI> l = new ArrayList<URI>(uris);
1:e210657:         boolean removed = false;
1:beda82a:         if (failedConnectTransportURI != null) {
1:3ac0537:             removed = l.remove(failedConnectTransportURI);
1:d29ca2a:         }
1:f812e34:         if (randomize) {
1:d29ca2a:             // Randomly, reorder the list by random swapping
1:f812e34:             for (int i = 0; i < l.size(); i++) {
1:06356db:                 // meed parenthesis due other JDKs (see AMQ-4826)
1:06356db:                 int p = ((int) (Math.random() * 100)) % l.size();
1:e210657:                 URI t = l.get(p);
1:f812e34:                 l.set(p, l.get(i));
1:f812e34:                 l.set(i, t);
1:d29ca2a:             }
1:d29ca2a:         }
1:beda82a:         if (removed) {
1:3ac0537:             l.add(failedConnectTransportURI);
1:b6b6911:         }
1:23a5beb: 
1:23a5beb:         LOG.debug("urlList connectionList:{}, from: {}", l, uris);
1:23a5beb: 
1:d29ca2a:         return l;
1:d29ca2a:     }
1:220ad62: 
1:fbac51c:     @Override
1:436fe42:     public TransportListener getTransportListener() {
1:436fe42:         return transportListener;
1:d29ca2a:     }
1:220ad62: 
1:fbac51c:     @Override
1:d29ca2a:     public void setTransportListener(TransportListener commandListener) {
1:f392884:         synchronized (listenerMutex) {
1:d29ca2a:             this.transportListener = commandListener;
1:f7fa2bc:             listenerMutex.notifyAll();
1:d29ca2a:         }
1:d29ca2a:     }
1:220ad62: 
1:fbac51c:     @Override
1:933eb2f:     public <T> T narrow(Class<T> target) {
1:d29ca2a:         if (target.isAssignableFrom(getClass())) {
1:933eb2f:             return target.cast(this);
1:d29ca2a:         }
1:c0b74f0:         Transport transport = connectedTransport.get();
1:bc1ca6c:         if (transport != null) {
1:c0b74f0:             return transport.narrow(target);
1:d29ca2a:         }
1:d29ca2a:         return null;
1:d29ca2a:     }
1:295850d: 
1:d29ca2a:     protected void restoreTransport(Transport t) throws Exception, IOException {
1:f392884:         t.start();
1:f392884:         // send information to the broker - informing it we are an ft client
1:e225ba6:         ConnectionControl cc = new ConnectionControl();
1:e225ba6:         cc.setFaultTolerant(true);
1:e225ba6:         t.oneway(cc);
1:d29ca2a:         stateTracker.restore(t);
1:b6b6911:         Map<Integer, Command> tmpMap = null;
1:f392884:         synchronized (requestMap) {
1:6b6cdae:             tmpMap = new LinkedHashMap<Integer, Command>(requestMap);
1:d29ca2a:         }
1:b6b6911:         for (Command command : tmpMap.values()) {
1:23a5beb:             LOG.trace("restore requestMap, replay: {}", command);
1:d29ca2a:             t.oneway(command);
1:d29ca2a:         }
1:d29ca2a:     }
1:ac66a09: 
1:d29ca2a:     public boolean isUseExponentialBackOff() {
1:d29ca2a:         return useExponentialBackOff;
1:d29ca2a:     }
1:ac66a09: 
1:d29ca2a:     public void setUseExponentialBackOff(boolean useExponentialBackOff) {
1:d29ca2a:         this.useExponentialBackOff = useExponentialBackOff;
1:d29ca2a:     }
1:ac66a09: 
1:fbac51c:     @Override
1:d29ca2a:     public String toString() {
1:f812e34:         return connectedTransportURI == null ? "unconnected" : connectedTransportURI.toString();
1:d29ca2a:     }
1:ac66a09: 
1:fbac51c:     @Override
1:f812e34:     public String getRemoteAddress() {
1:c0b74f0:         Transport transport = connectedTransport.get();
1:205d025:         if (transport != null) {
1:c0b74f0:             return transport.getRemoteAddress();
1:f812e34:         }
1:f812e34:         return null;
1:f812e34:     }
1:f812e34: 
1:fbac51c:     @Override
1:f812e34:     public boolean isFaultTolerant() {
1:fbac51c:         return true;
1:d29ca2a:     }
1:ac66a09: 
1:b6b6911:     private void doUpdateURIsFromDisk() {
1:b6b6911:         // If updateURIsURL is specified, read the file and add any new
1:b6b6911:         // transport URI's to this FailOverTransport.
1:b6b6911:         // Note: Could track file timestamp to avoid unnecessary reading.
1:b6b6911:         String fileURL = getUpdateURIsURL();
1:b6b6911:         if (fileURL != null) {
1:b6b6911:             BufferedReader in = null;
1:b6b6911:             String newUris = null;
1:b6b6911:             StringBuffer buffer = new StringBuffer();
1:b6b6911: 
1:b6b6911:             try {
1:b6b6911:                 in = new BufferedReader(getURLStream(fileURL));
1:b6b6911:                 while (true) {
1:b6b6911:                     String line = in.readLine();
1:b6b6911:                     if (line == null) {
1:b6b6911:                         break;
1:b6b6911:                     }
1:b6b6911:                     buffer.append(line);
1:b6b6911:                 }
1:b6b6911:                 newUris = buffer.toString();
1:b6b6911:             } catch (IOException ioe) {
1:23a5beb:                 LOG.error("Failed to read updateURIsURL: {} {}",fileURL, ioe);
1:b6b6911:             } finally {
1:b6b6911:                 if (in != null) {
1:b6b6911:                     try {
1:b6b6911:                         in.close();
1:b6b6911:                     } catch (IOException ioe) {
1:b6b6911:                         // ignore
1:b6b6911:                     }
1:b6b6911:                 }
1:b6b6911:             }
1:b6b6911: 
1:b6b6911:             processNewTransports(isRebalanceUpdateURIs(), newUris);
1:b6b6911:         }
1:b6b6911:     }
1:b6b6911: 
1:f392884:     final boolean doReconnect() {
1:f812e34:         Exception failure = null;
6:d29ca2a:         synchronized (reconnectMutex) {
1:1ea430e: 
1:b6b6911:             // First ensure we are up to date.
1:b6b6911:             doUpdateURIsFromDisk();
1:e2aad41: 
1:f812e34:             if (disposed || connectionFailure != null) {
2:d29ca2a:                 reconnectMutex.notifyAll();
1:d29ca2a:             }
1:7388438:             if ((connectedTransport.get() != null && !doRebalance && !priorityBackupAvailable) || disposed || connectionFailure != null) {
1:fbac51c:                 return false;
1:d29ca2a:             } else {
2:418823a:                 List<URI> connectList = getConnectList();
1:f812e34:                 if (connectList.isEmpty()) {
1:d29ca2a:                     failure = new IOException("No uris available to connect to.");
1:d29ca2a:                 } else {
1:c752230:                     if (doRebalance) {
1:e777126:                         if (connectedToPriority || compareURIs(connectList.get(0), connectedTransportURI)) {
1:c752230:                             // already connected to first in the list, no need to rebalance
1:c752230:                             doRebalance = false;
1:fbac51c:                             return false;
1:c752230:                         } else {
1:23a5beb:                             LOG.debug("Doing rebalance from: {} to {}", connectedTransportURI, connectList);
1:7388438: 
1:b6b6911:                             try {
1:c752230:                                 Transport transport = this.connectedTransport.getAndSet(null);
1:14e636b:                                 if (transport != null) {
1:bc1ca6c:                                     disposeTransport(transport);
1:b6b6911:                                 }
1:c752230:                             } catch (Exception e) {
1:23a5beb:                                 LOG.debug("Caught an exception stopping existing transport for rebalance", e);
1:b6b6911:                             }
1:c752230:                         }
1:c752230:                         doRebalance = false;
1:d29ca2a:                     }
1:a3060e7: 
1:4acd132:                     resetReconnectDelay();
1:7d8ce02: 
1:7d8ce02:                     Transport transport = null;
1:7d8ce02:                     URI uri = null;
1:7d8ce02: 
1:7d8ce02:                     // If we have a backup already waiting lets try it.
1:f392884:                     synchronized (backupMutex) {
1:7388438:                         if ((priorityBackup || backup) && !backups.isEmpty()) {
1:a3060e7:                             ArrayList<BackupTransport> l = new ArrayList<BackupTransport>(backups);
1:91059de:                             if (randomize) {
1:91059de:                                 Collections.shuffle(l);
1:91059de:                             }
1:91059de:                             BackupTransport bt = l.remove(0);
1:91059de:                             backups.remove(bt);
1:7d8ce02:                             transport = bt.getTransport();
1:7d8ce02:                             uri = bt.getUri();
1:23a5beb:                             processCommand(bt.getBrokerInfo());
1:7388438:                             if (priorityBackup && priorityBackupAvailable) {
1:7388438:                                 Transport old = this.connectedTransport.getAndSet(null);
1:d687324:                                 if (old != null) {
1:7388438:                                     disposeTransport(old);
1:7388438:                                 }
1:7388438:                                 priorityBackupAvailable = false;
1:7388438:                             }
1:d29ca2a:                         }
1:d29ca2a:                     }
1:b6b6911: 
1:c8af70f:                     // When there was no backup and we are reconnecting for the first time
1:c8af70f:                     // we honor the initialReconnectDelay before trying a new connection, after
1:c8af70f:                     // this normal reconnect delay happens following a failed attempt.
1:c8af70f:                     if (transport == null && !firstConnection && connectFailures == 0 && initialReconnectDelay > 0 && !disposed) {
1:c8af70f:                         // reconnectDelay will be equal to initialReconnectDelay since we are on
1:c8af70f:                         // the first connect attempt after we had a working connection, doDelay
1:c8af70f:                         // will apply updates to move to the next reconnectDelay value based on
1:c8af70f:                         // configuration.
1:c8af70f:                         doDelay();
1:d29ca2a:                     }
1:f812e34: 
1:418823a:                     Iterator<URI> iter = connectList.iterator();
1:7d8ce02:                     while ((transport != null || iter.hasNext()) && (connectedTransport.get() == null && !disposed)) {
1:f812e34: 
1:c752230:                         try {
1:7d8ce02:                             SslContext.setCurrentSslContext(brokerSslContext);
1:e2aad41: 
1:7d8ce02:                             // We could be starting with a backup and if so we wait to grab a
1:7d8ce02:                             // URI from the pool until next time around.
1:7d8ce02:                             if (transport == null) {
1:0ff3593:                                 uri = addExtraQueryOptions(iter.next());
1:7d8ce02:                                 transport = TransportFactory.compositeConnect(uri);
1:7d8ce02:                             }
1:7d8ce02: 
1:23a5beb:                             LOG.debug("Attempting {}th connect to: {}", connectFailures, uri);
1:23a5beb: 
1:23a5beb:                             transport.setTransportListener(createTransportListener(transport));
1:7d8ce02:                             transport.start();
49:d29ca2a: 
1:23a5beb:                             if (started && !firstConnection) {
1:7d8ce02:                                 restoreTransport(transport);
1:e777126:                             }
1:d29ca2a: 
1:23a5beb:                             LOG.debug("Connection established");
1:23a5beb: 
2:d29ca2a:                             reconnectDelay = initialReconnectDelay;
1:d29ca2a:                             connectedTransportURI = uri;
1:7d8ce02:                             connectedTransport.set(transport);
1:7388438:                             connectedToPriority = isPriority(connectedTransportURI);
1:d29ca2a:                             reconnectMutex.notifyAll();
1:d29ca2a:                             connectFailures = 0;
1:7d8ce02: 
1:7d8ce02:                             // Make sure on initial startup, that the transportListener
1:f392884:                             // has been initialized for this instance.
1:f392884:                             synchronized (listenerMutex) {
1:f392884:                                 if (transportListener == null) {
1:c14c7e7:                                     try {
1:7d8ce02:                                         // if it isn't set after 2secs - it probably never will be
1:60d4d48:                                         listenerMutex.wait(2000);
1:f392884:                                     } catch (InterruptedException ex) {
1:4acd132:                                     }
1:d29ca2a:                                 }
1:d29ca2a:                             }
1:7d8ce02: 
1:62eb5cf:                             if (transportListener != null) {
1:933eb2f:                                 transportListener.transportResumed();
1:d29ca2a:                             } else {
1:23a5beb:                                 LOG.debug("transport resumed by transport listener not set");
1:4acd132:                             }
1:7d8ce02: 
1:31ecfae:                             if (firstConnection) {
1:f392884:                                 firstConnection = false;
1:23a5beb:                                 LOG.info("Successfully connected to {}", uri);
1:f392884:                             } else {
1:23a5beb:                                 LOG.info("Successfully reconnected to {}", uri);
1:7d8ce02:                             }
1:7d8ce02: 
1:c752230:                             return false;
1:f812e34:                         } catch (Exception e) {
1:d29ca2a:                             failure = e;
1:23a5beb:                             LOG.debug("Connect fail to: {}, reason: {}", uri, e);
1:7388438:                             if (transport != null) {
1:4b4ce4a:                                 try {
1:7d8ce02:                                     transport.stop();
1:7d8ce02:                                     transport = null;
1:4b4ce4a:                                 } catch (Exception ee) {
1:23a5beb:                                     LOG.debug("Stop of failed transport: {} failed with reason: {}", transport, ee);
1:7d8ce02:                                 }
1:c752230:                             }
1:c4d8bc4:                         } finally {
1:c4d8bc4:                             SslContext.setCurrentSslContext(null);
1:c752230:                         }
1:c752230:                     }
1:4b4ce4a:                 }
1:4b4ce4a:             }
1:7d8ce02: 
1:4acd132:             int reconnectLimit = calculateReconnectAttemptLimit();
1:7d8ce02: 
1:599abc5:             connectFailures++;
1:599abc5:             if (reconnectLimit != INFINITE && connectFailures >= reconnectLimit) {
1:23a5beb:                 LOG.error("Failed to connect to {} after: {} attempt(s)", uris, connectFailures);
1:d29ca2a:                 connectionFailure = failure;
1:933eb2f: 
1:7d8ce02:                 // Make sure on initial startup, that the transportListener has been
1:7d8ce02:                 // initialized for this instance.
1:f392884:                 synchronized (listenerMutex) {
1:f392884:                     if (transportListener == null) {
1:d29ca2a:                         try {
1:60d4d48:                             listenerMutex.wait(2000);
1:f392884:                         } catch (InterruptedException ex) {
1:933eb2f:                         }
1:933eb2f:                     }
1:933eb2f:                 }
1:933eb2f: 
1:4acd132:                 propagateFailureToExceptionListener(connectionFailure);
2:d29ca2a:                 return false;
1:ac66a09:             }
1:c55a666: 
1:c55a666:             int warnInterval = getWarnAfterReconnectAttempts();
1:2b64b7b:             if (warnInterval > 0 && (connectFailures == 1 || (connectFailures % warnInterval) == 0)) {
1:2b64b7b:                 LOG.warn("Failed to connect to {} after: {} attempt(s) with {}, continuing to retry.",
1:2b64b7b:                          uris, connectFailures, (failure == null ? "?" : failure.getLocalizedMessage()));
1:c55a666:             }
1:ac66a09:         }
1:ac66a09: 
1:f812e34:         if (!disposed) {
1:7388438:             doDelay();
1:ac66a09:         }
1:d29ca2a: 
1:7388438:         return !disposed;
1:7388438:     }
1:7388438: 
1:7388438:     private void doDelay() {
1:7388438:         if (reconnectDelay > 0) {
1:7388438:             synchronized (sleepMutex) {
1:c8af70f:                 LOG.debug("Waiting {} ms before attempting connection", reconnectDelay);
1:7388438:                 try {
1:7388438:                     sleepMutex.wait(reconnectDelay);
1:7388438:                 } catch (InterruptedException e) {
1:7388438:                     Thread.currentThread().interrupt();
1:b6b6911:                 }
1:b6b6911:             }
1:d29ca2a:         }
1:b6b6911: 
1:7388438:         if (useExponentialBackOff) {
1:7388438:             // Exponential increment of reconnect delay.
1:7388438:             reconnectDelay *= backOffMultiplier;
1:7388438:             if (reconnectDelay > maxReconnectDelay) {
1:7388438:                 reconnectDelay = maxReconnectDelay;
1:7388438:             }
1:7388438:         }
1:fc00993:     }
1:d29ca2a: 
1:4acd132:     private void resetReconnectDelay() {
1:4acd132:         if (!useExponentialBackOff || reconnectDelay == DEFAULT_INITIAL_RECONNECT_DELAY) {
1:4acd132:             reconnectDelay = initialReconnectDelay;
1:4acd132:         }
1:4acd132:     }
1:4acd132: 
1:4acd132:     /*
1:4ea435b:      * called with reconnectMutex held
1:4acd132:      */
1:4acd132:     private void propagateFailureToExceptionListener(Exception exception) {
1:4acd132:         if (transportListener != null) {
1:4acd132:             if (exception instanceof IOException) {
1:4acd132:                 transportListener.onException((IOException)exception);
1:4acd132:             } else {
1:4acd132:                 transportListener.onException(IOExceptionSupport.create(exception));
1:4acd132:             }
1:4acd132:         }
1:4acd132:         reconnectMutex.notifyAll();
1:4acd132:     }
1:4acd132: 
1:4acd132:     private int calculateReconnectAttemptLimit() {
1:4acd132:         int maxReconnectValue = this.maxReconnectAttempts;
1:4acd132:         if (firstConnection && this.startupMaxReconnectAttempts != INFINITE) {
1:4acd132:             maxReconnectValue = this.startupMaxReconnectAttempts;
1:4acd132:         }
1:4acd132:         return maxReconnectValue;
1:4acd132:     }
1:4acd132: 
1:9490793:     private boolean shouldBuildBackups() {
1:9490793:        return (backup && backups.size() < backupPoolSize) || (priorityBackup && !(priorityBackupAvailable || connectedToPriority));
1:9490793:     }
1:9490793: 
1:f392884:     final boolean buildBackups() {
1:f392884:         synchronized (backupMutex) {
1:9490793:             if (!disposed && shouldBuildBackups()) {
1:7388438:                 ArrayList<URI> backupList = new ArrayList<URI>(priorityList);
1:f392884:                 List<URI> connectList = getConnectList();
1:7388438:                 for (URI uri: connectList) {
1:7388438:                     if (!backupList.contains(uri)) {
1:7388438:                         backupList.add(uri);
1:7388438:                     }
1:7388438:                 }
1:f392884:                 // removed disposed backups
1:f392884:                 List<BackupTransport> disposedList = new ArrayList<BackupTransport>();
1:f392884:                 for (BackupTransport bt : backups) {
1:f392884:                     if (bt.isDisposed()) {
1:f392884:                         disposedList.add(bt);
1:d29ca2a:                     }
1:d29ca2a:                 }
1:f392884:                 backups.removeAll(disposedList);
1:f392884:                 disposedList.clear();
1:9490793:                 for (Iterator<URI> iter = backupList.iterator(); !disposed && iter.hasNext() && shouldBuildBackups(); ) {
1:0ff3593:                     URI uri = addExtraQueryOptions(iter.next());
1:f392884:                     if (connectedTransportURI != null && !connectedTransportURI.equals(uri)) {
1:d29ca2a:                         try {
1:c4d8bc4:                             SslContext.setCurrentSslContext(brokerSslContext);
1:f392884:                             BackupTransport bt = new BackupTransport(this);
1:f392884:                             bt.setUri(uri);
1:f392884:                             if (!backups.contains(bt)) {
1:d29ca2a:                                 Transport t = TransportFactory.compositeConnect(uri);
1:f392884:                                 t.setTransportListener(bt);
1:d29ca2a:                                 t.start();
1:f392884:                                 bt.setTransport(t);
1:7388438:                                 if (priorityBackup && isPriority(uri)) {
1:7388438:                                    priorityBackupAvailable = true;
1:585a966:                                    backups.add(0, bt);
1:9490793:                                    // if this priority backup overflows the pool
1:9490793:                                    // remove the backup with the lowest priority
1:9490793:                                    if (backups.size() > backupPoolSize) {
1:9490793:                                        BackupTransport disposeTransport = backups.remove(backups.size() - 1);
1:9490793:                                        disposeTransport.setDisposed(true);
1:9490793:                                        Transport transport = disposeTransport.getTransport();
1:9490793:                                        if (transport != null) {
1:9490793:                                            transport.setTransportListener(disposedListener);
1:9490793:                                            disposeTransport(transport);
1:9490793:                                        }
1:9490793:                                    }
1:585a966:                                 } else {
1:585a966:                                     backups.add(bt);
1:7388438:                                 }
1:d29ca2a:                             }
1:f812e34:                         } catch (Exception e) {
1:f392884:                             LOG.debug("Failed to build backup ", e);
1:c4d8bc4:                         } finally {
1:c4d8bc4:                             SslContext.setCurrentSslContext(null);
1:d29ca2a:                         }
1:d29ca2a:                     }
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:         return false;
1:d29ca2a:     }
1:f812e34: 
1:7388438:     protected boolean isPriority(URI uri) {
1:e777126:         if (!priorityBackup) {
1:e777126:             return false;
1:e777126:         }
1:e777126: 
1:7388438:         if (!priorityList.isEmpty()) {
1:4ea435b:             for (URI priorityURI : priorityList) {
1:4ea435b:                 if (compareURIs(priorityURI, uri)) {
1:4ea435b:                     return true;
1:4ea435b:                 }
1:4ea435b:             }
1:4ea435b: 
1:4ea435b:         } else if (!uris.isEmpty()) {
1:4ea435b:             return compareURIs(uris.get(0), uri);
1:7388438:         }
1:4ea435b: 
1:4ea435b:         return false;
1:7388438:     }
1:d29ca2a: 
1:f392884:     @Override
1:ecc87ea:     public boolean isDisposed() {
1:f392884:         return disposed;
1:d29ca2a:     }
1:d29ca2a: 
1:fbac51c:     @Override
1:ecc87ea:     public boolean isConnected() {
1:3ef5389:         return connectedTransport.get() != null;
1:d29ca2a:     }
1:d29ca2a: 
1:fbac51c:     @Override
1:ecc87ea:     public void reconnect(URI uri) throws IOException {
1:b6b6911:         add(true, new URI[]{uri});
1:d29ca2a:     }
1:8978ac0: 
1:fbac51c:     @Override
1:f392884:     public boolean isReconnectSupported() {
1:a1c427e:         return this.reconnectSupported;
1:d29ca2a:     }
1:b6b6911: 
1:a1c427e:     public void setReconnectSupported(boolean value) {
1:b6b6911:         this.reconnectSupported = value;
1:d29ca2a:     }
1:b6b6911: 
1:fbac51c:     @Override
1:f392884:     public boolean isUpdateURIsSupported() {
1:a1c427e:         return this.updateURIsSupported;
1:d29ca2a:     }
1:b6b6911: 
1:a1c427e:     public void setUpdateURIsSupported(boolean value) {
1:b6b6911:         this.updateURIsSupported = value;
1:d29ca2a:     }
1:d29ca2a: 
1:fbac51c:     @Override
1:f392884:     public void updateURIs(boolean rebalance, URI[] updatedURIs) throws IOException {
1:a1c427e:         if (isUpdateURIsSupported()) {
1:2536c03:             HashSet<URI> copy = new HashSet<URI>();
1:2536c03:             synchronized (reconnectMutex) {
1:2536c03:                 copy.addAll(this.updated);
1:2536c03:                 updated.clear();
1:2536c03:                 if (updatedURIs != null && updatedURIs.length > 0) {
1:2536c03:                     for (URI uri : updatedURIs) {
1:2536c03:                         if (uri != null && !updated.contains(uri)) {
1:2536c03:                             updated.add(uri);
1:2536c03:                         }
1:2536c03:                     }
1:d29ca2a:                 }
1:d29ca2a:             }
1:2536c03:             if (!(copy.isEmpty() && updated.isEmpty()) && !copy.equals(new HashSet<URI>(updated))) {
1:2536c03:                 buildBackups();
1:2536c03:                 reconnect(rebalance);
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:c14c7e7:     /**
1:c14c7e7:      * @return the updateURIsURL
1:c14c7e7:      */
1:c14c7e7:     public String getUpdateURIsURL() {
1:c14c7e7:         return this.updateURIsURL;
1:d29ca2a:     }
1:d29ca2a: 
1:c14c7e7:     /**
1:c14c7e7:      * @param updateURIsURL the updateURIsURL to set
1:c14c7e7:      */
1:c14c7e7:     public void setUpdateURIsURL(String updateURIsURL) {
1:c14c7e7:         this.updateURIsURL = updateURIsURL;
1:d29ca2a:     }
1:b6b6911: 
1:c14c7e7:     /**
1:c14c7e7:      * @return the rebalanceUpdateURIs
1:c14c7e7:      */
1:c14c7e7:     public boolean isRebalanceUpdateURIs() {
1:c14c7e7:         return this.rebalanceUpdateURIs;
1:d29ca2a:     }
1:d29ca2a: 
1:c14c7e7:     /**
1:c14c7e7:      * @param rebalanceUpdateURIs the rebalanceUpdateURIs to set
1:c14c7e7:      */
1:c14c7e7:     public void setRebalanceUpdateURIs(boolean rebalanceUpdateURIs) {
1:c14c7e7:         this.rebalanceUpdateURIs = rebalanceUpdateURIs;
1:d29ca2a:     }
1:d29ca2a: 
1:fbac51c:     @Override
1:8978ac0:     public int getReceiveCounter() {
1:8978ac0:         Transport transport = connectedTransport.get();
1:cdd2108:         if (transport == null) {
1:8978ac0:             return 0;
1:8978ac0:         }
1:8978ac0:         return transport.getReceiveCounter();
1:8978ac0:     }
1:8d3ca90: 
1:599abc5:     public int getConnectFailures() {
1:599abc5:         return connectFailures;
1:599abc5:     }
1:599abc5: 
1:8d3ca90:     public void connectionInterruptProcessingComplete(ConnectionId connectionId) {
1:19cb932:         synchronized (reconnectMutex) {
1:8d3ca90:             stateTracker.connectionInterruptProcessingComplete(this, connectionId);
1:8d3ca90:         }
1:8d3ca90:     }
1:d29ca2a: 
1:4eafccc:     public ConnectionStateTracker getStateTracker() {
1:4eafccc:         return stateTracker;
1:4eafccc:     }
1:b6b6911: 
1:4ea435b:     public boolean isConnectedToPriority() {
1:4ea435b:         return connectedToPriority;
1:4ea435b:     }
1:4ea435b: 
1:f392884:     private boolean contains(URI newURI) {
1:f392884:         boolean result = false;
1:1d52f3b:         for (URI uri : uris) {
1:fbac51c:             if (compareURIs(newURI, uri)) {
1:fbac51c:                 result = true;
1:1d52f3b:                 break;
1:b6b6911:             }
1:d29ca2a:         }
1:1d52f3b: 
1:f392884:         return result;
1:d29ca2a:     }
1:1d52f3b: 
1:fbac51c:     private boolean compareURIs(final URI first, final URI second) {
1:fbac51c: 
1:e777126:         boolean result = false;
1:fbac51c:         if (first == null || second == null) {
1:e777126:             return result;
1:fbac51c:         }
1:fbac51c: 
1:fbac51c:         if (first.getPort() == second.getPort()) {
1:fbac51c:             InetAddress firstAddr = null;
1:fbac51c:             InetAddress secondAddr = null;
1:fbac51c:             try {
1:fbac51c:                 firstAddr = InetAddress.getByName(first.getHost());
1:fbac51c:                 secondAddr = InetAddress.getByName(second.getHost());
1:e777126: 
1:e777126:                 if (firstAddr.equals(secondAddr)) {
1:e777126:                     result = true;
1:e777126:                 }
1:e777126: 
1:fbac51c:             } catch(IOException e) {
1:fbac51c: 
1:fbac51c:                 if (firstAddr == null) {
1:23a5beb:                     LOG.error("Failed to Lookup INetAddress for URI[{}] : {}", first, e);
1:fbac51c:                 } else {
1:23a5beb:                     LOG.error("Failed to Lookup INetAddress for URI[{}] : {}", second, e);
1:fbac51c:                 }
1:fbac51c: 
1:fbac51c:                 if (first.getHost().equalsIgnoreCase(second.getHost())) {
1:e777126:                     result = true;
1:fbac51c:                 }
1:fbac51c:             }
1:fbac51c:         }
1:fbac51c: 
1:e777126:         return result;
1:fbac51c:     }
1:fbac51c: 
1:c14c7e7:     private InputStreamReader getURLStream(String path) throws IOException {
1:c14c7e7:         InputStreamReader result = null;
1:c14c7e7:         URL url = null;
1:c14c7e7:         try {
1:c14c7e7:             url = new URL(path);
1:c14c7e7:             result = new InputStreamReader(url.openStream());
1:c14c7e7:         } catch (MalformedURLException e) {
1:c14c7e7:             // ignore - it could be a path to a a local file
1:fbac51c:         }
1:c14c7e7:         if (result == null) {
1:c14c7e7:             result = new FileReader(path);
1:1d52f3b:         }
1:c14c7e7:         return result;
1:d29ca2a:     }
1:fbac51c: 
1:0ff3593:     private URI addExtraQueryOptions(URI uri) {
1:0ff3593:         try {
1:0ff3593:             if( nestedExtraQueryOptions!=null && !nestedExtraQueryOptions.isEmpty() ) {
1:0ff3593:                 if( uri.getQuery() == null ) {
1:0ff3593:                     uri = URISupport.createURIWithQuery(uri, nestedExtraQueryOptions);
1:0ff3593:                 } else {
1:0ff3593:                     uri = URISupport.createURIWithQuery(uri, uri.getQuery()+"&"+nestedExtraQueryOptions);
1:0ff3593:                 }
1:0ff3593:             }
1:0ff3593:         } catch (URISyntaxException e) {
1:0ff3593:             throw new RuntimeException(e);
1:0ff3593:         }
1:0ff3593:         return uri;
1:0ff3593:     }
1:0ff3593: 
1:0ff3593:     public void setNestedExtraQueryOptions(String nestedExtraQueryOptions) {
1:0ff3593:         this.nestedExtraQueryOptions = nestedExtraQueryOptions;
1:0ff3593:     }
1:c55a666: 
1:c55a666:     public int getWarnAfterReconnectAttempts() {
1:c55a666:         return warnAfterReconnectAttempts;
1:c55a666:     }
1:c55a666: 
1:c55a666:     /**
1:c55a666:      * Sets the number of Connect / Reconnect attempts that must occur before a warn message
1:c55a666:      * is logged indicating that the transport is not connected.  This can be useful when the
1:c55a666:      * client is running inside some container or service as it give an indication of some
1:c55a666:      * problem with the client connection that might not otherwise be visible.  To disable the
1:c55a666:      * log messages this value should be set to a value @{code attempts <= 0}
1:c55a666:      *
1:c55a666:      * @param warnAfterReconnectAttempts
1:c55a666:      *      The number of failed connection attempts that must happen before a warning is logged.
1:c55a666:      */
1:c55a666:     public void setWarnAfterReconnectAttempts(int warnAfterReconnectAttempts) {
1:c55a666:         this.warnAfterReconnectAttempts = warnAfterReconnectAttempts;
1:c55a666:     }
1:31c55f7: 
1:31c55f7:     @Override
1:31c55f7:     public X509Certificate[] getPeerCertificates() {
1:31c55f7:         Transport transport = connectedTransport.get();
1:31c55f7:         if (transport != null) {
1:31c55f7:             return transport.getPeerCertificates();
1:31c55f7:         } else {
1:31c55f7:             return null;
1:31c55f7:         }
1:31c55f7:     }
1:31c55f7: 
1:31c55f7:     @Override
1:31c55f7:     public void setPeerCertificates(X509Certificate[] certificates) {
1:31c55f7:     }
1:31c55f7: 
1:31c55f7:     @Override
1:31c55f7:     public WireFormat getWireFormat() {
1:31c55f7:         Transport transport = connectedTransport.get();
1:31c55f7:         if (transport != null) {
1:31c55f7:             return transport.getWireFormat();
1:31c55f7:         } else {
1:31c55f7:             return null;
1:31c55f7:         }
1:31c55f7:     }
1:d29ca2a: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:0b71b06
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:7974e8c
/////////////////////////////////////////////////////////////////////////
0:                             LOG.error("Connect fail to: {}, error message: {}", uri, e.getMessage());
/////////////////////////////////////////////////////////////////////////
0:                             LOG.info("Adding new URI to transport: {}", uri);
author:gtully
-------------------------------------------------------------------------------
commit:2b64b7b
/////////////////////////////////////////////////////////////////////////
1:             if (warnInterval > 0 && (connectFailures == 1 || (connectFailures % warnInterval) == 0)) {
1:                 LOG.warn("Failed to connect to {} after: {} attempt(s) with {}, continuing to retry.",
1:                          uris, connectFailures, (failure == null ? "?" : failure.getLocalizedMessage()));
commit:db1506a
/////////////////////////////////////////////////////////////////////////
0:                             myTransportListener.onCommand(bt.getBrokerInfo());
commit:0a12bcb
/////////////////////////////////////////////////////////////////////////
1:     public FailoverTransport() {
commit:8514e38
/////////////////////////////////////////////////////////////////////////
1:                                 && !Thread.currentThread().isInterrupted() && willReconnect()) {
/////////////////////////////////////////////////////////////////////////
1:                             } else if (!willReconnect()) {
1:                                 error = new IOException("Reconnect attempts of " + maxReconnectAttempts + " exceeded");
/////////////////////////////////////////////////////////////////////////
1:     private boolean willReconnect() {
1:         return firstConnection || 0 != calculateReconnectAttemptLimit();
1:     }
1: 
commit:ae9af4b
/////////////////////////////////////////////////////////////////////////
1:                             if (tracked == null && canReconnect()) {
commit:ffef4dc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ConsumerControl;
1: 
/////////////////////////////////////////////////////////////////////////
0:                 else if (command.isConsumerControl()) {
1:                     ConsumerControl consumerControl = (ConsumerControl)command;
1:                     if (consumerControl.isClose()) {
1:                         stateTracker.processRemoveConsumer(consumerControl.getConsumerId(), RemoveInfo.LAST_DELIVERED_UNKNOWN);
1:                     }
1: 
1:                 }
commit:2536c03
/////////////////////////////////////////////////////////////////////////
1:             HashSet<URI> copy = new HashSet<URI>();
1:             synchronized (reconnectMutex) {
1:                 copy.addAll(this.updated);
1:                 updated.clear();
1:                 if (updatedURIs != null && updatedURIs.length > 0) {
1:                     for (URI uri : updatedURIs) {
1:                         if (uri != null && !updated.contains(uri)) {
1:                             updated.add(uri);
1:                         }
1:             }
1:             if (!(copy.isEmpty() && updated.isEmpty()) && !copy.equals(new HashSet<URI>(updated))) {
1:                 buildBackups();
1:                 reconnect(rebalance);
commit:3ef5389
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (shuttingDown) {
1:             // shutdown info sent and remote socket closed and we see that before a local close
1:             // let the close do the work
1:             return;
1:         }
1: 
1:         if (LOG.isTraceEnabled()) {
1:             LOG.trace(this + " handleTransportFailure: " + e, e);
1:         }
1: 
1:         // could be blocked in write with the reconnectMutex held, but still needs to be whacked
0:         Transport transport = connectedTransport.getAndSet(null);
1:         if (transport != null) {
1:             disposeTransport(transport);
1:         }
1: 
1:             if (transport != null && connectedTransport.get() == null) {
0:                  LOG.warn("Transport (" + connectedTransportURI + ") failed"
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return connectedTransport.get() != null;
commit:ce911ba
/////////////////////////////////////////////////////////////////////////
0:     private boolean shuttingDown = false;
/////////////////////////////////////////////////////////////////////////
0:             if (shuttingDown) {
0:                 // shutdown info sent and remote socket closed and we see that before a local close
0:                 // let the close do the work
1:                 return;
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
0:                 LOG.warn("Transport (" + transport + ") failed"
/////////////////////////////////////////////////////////////////////////
1:                             if (command.isShutdownInfo()) {
1:                                 shuttingDown = true;
1:                             }
commit:146fb12
/////////////////////////////////////////////////////////////////////////
0:                 LOG.trace(this + " handleTransportFailure: " + e, e);
commit:4f19f31
/////////////////////////////////////////////////////////////////////////
1:                     // notify before any reconnect attempt so ack state can be whacked
1:                     if (transportListener != null) {
1:                         transportListener.transportInterupted();
1:                     }
1: 
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Timothy Bish
-------------------------------------------------------------------------------
commit:629ee28
/////////////////////////////////////////////////////////////////////////
1:     private volatile boolean disposed;
/////////////////////////////////////////////////////////////////////////
1:     private volatile boolean started;
/////////////////////////////////////////////////////////////////////////
1:     private volatile boolean shuttingDown = false;
commit:31c55f7
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
1: import java.security.cert.X509Certificate;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.wireformat.WireFormat;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     public X509Certificate[] getPeerCertificates() {
1:         Transport transport = connectedTransport.get();
1:         if (transport != null) {
1:             return transport.getPeerCertificates();
1:         } else {
1:             return null;
1:         }
1:     }
1: 
1:     @Override
1:     public void setPeerCertificates(X509Certificate[] certificates) {
1:     }
1: 
1:     @Override
1:     public WireFormat getWireFormat() {
1:         Transport transport = connectedTransport.get();
1:         if (transport != null) {
1:             return transport.getWireFormat();
1:         } else {
1:             return null;
1:         }
1:     }
commit:3560d91
/////////////////////////////////////////////////////////////////////////
1:                          connectedTransportURI, (reconnectOk ? "," : ", not"), e);
commit:23a5beb
/////////////////////////////////////////////////////////////////////////
1:     private final TransportListener disposedListener = new DefaultTransportListener() {};
/////////////////////////////////////////////////////////////////////////
1:     private void processCommand(Object incoming) {
1:         Command command = (Command) incoming;
1:         if (command == null) {
1:             return;
1:         }
1:         if (command.isResponse()) {
1:             Object object = null;
1:             synchronized (requestMap) {
1:                 object = requestMap.remove(Integer.valueOf(((Response) command).getCorrelationId()));
1:             }
1:             if (object != null && object.getClass() == Tracked.class) {
1:                 ((Tracked) object).onResponses(command);
1:             }
1:         }
1: 
1:         if (command.isConnectionControl()) {
1:             handleConnectionControl((ConnectionControl) command);
1:         } else if (command.isConsumerControl()) {
0:             ConsumerControl consumerControl = (ConsumerControl)command;
0:             if (consumerControl.isClose()) {
0:                 stateTracker.processRemoveConsumer(consumerControl.getConsumerId(), RemoveInfo.LAST_DELIVERED_UNKNOWN);
1:             }
1:         }
1: 
1:         if (transportListener != null) {
1:             transportListener.onCommand(command);
1:         }
1:     }
1: 
1:     private TransportListener createTransportListener(final Transport owner) {
1: 
1:                 processCommand(o);
1:                     handleTransportFailure(owner, error);
1:                     if (transportListener != null) {
1:                         transportListener.onException(new InterruptedIOException());
1:                     }
/////////////////////////////////////////////////////////////////////////
1:         handleTransportFailure(getConnectedTransport(), e);
1:     }
1: 
1:     public final void handleTransportFailure(Transport failed, IOException e) throws InterruptedException {
/////////////////////////////////////////////////////////////////////////
1:         Transport transport = null;
1: 
1:         if (connectedTransport.compareAndSet(failed, null)) {
1:             transport = failed;
1:             if (transport != null) {
1:                 disposeTransport(transport);
1:             }
1: 
1:                 LOG.warn("Transport ({}) failed {} attempting to automatically reconnect: {}",
0:                          connectedTransport, (reconnectOk ? "," : ", not"), e);
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug("Started {}", this);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.debug("Stopped {}", this);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.trace("Stopped backup: {}", transport);
/////////////////////////////////////////////////////////////////////////
1:                             processCommand(response);
/////////////////////////////////////////////////////////////////////////
1:                             processCommand(dispatch);
/////////////////////////////////////////////////////////////////////////
1: 
1:                             LOG.trace("Waiting for transport to reconnect..: {}", command);
1:                                 LOG.info("Failover timed out after {} ms", (end - start));
1:                                 LOG.debug("Interupted:", e);
/////////////////////////////////////////////////////////////////////////
1:                             LOG.debug("Cannot track the command {} {}", command, ioe);
/////////////////////////////////////////////////////////////////////////
1:                                 LOG.debug("Send oneway attempt: {} failed for command: {}", i, command);
1:                         LOG.debug("Send oneway attempt: {} failed for command: {}", i, command);
/////////////////////////////////////////////////////////////////////////
1:             LOG.error("Failed to parse URI: {}", u);
/////////////////////////////////////////////////////////////////////////
1: 
1:         LOG.debug("urlList connectionList:{}, from: {}", l, uris);
1: 
/////////////////////////////////////////////////////////////////////////
1:             LOG.trace("restore requestMap, replay: {}", command);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.error("Failed to read updateURIsURL: {} {}",fileURL, ioe);
/////////////////////////////////////////////////////////////////////////
1:                             LOG.debug("Doing rebalance from: {} to {}", connectedTransportURI, connectList);
/////////////////////////////////////////////////////////////////////////
1:                                 LOG.debug("Caught an exception stopping existing transport for rebalance", e);
/////////////////////////////////////////////////////////////////////////
1:                             processCommand(bt.getBrokerInfo());
/////////////////////////////////////////////////////////////////////////
1:                             LOG.debug("Attempting {}th connect to: {}", connectFailures, uri);
1: 
1:                             transport.setTransportListener(createTransportListener(transport));
1:                             if (started && !firstConnection) {
1:                             LOG.debug("Connection established");
1: 
/////////////////////////////////////////////////////////////////////////
1:                                 LOG.debug("transport resumed by transport listener not set");
1:                                 LOG.info("Successfully connected to {}", uri);
1:                                 LOG.info("Successfully reconnected to {}", uri);
1:                             LOG.debug("Connect fail to: {}, reason: {}", uri, e);
1:                                     LOG.debug("Stop of failed transport: {} failed with reason: {}", transport, ee);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.error("Failed to connect to {} after: {} attempt(s)", uris, connectFailures);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.error("Failed to Lookup INetAddress for URI[{}] : {}", first, e);
1:                     LOG.error("Failed to Lookup INetAddress for URI[{}] : {}", second, e);
commit:c8af70f
/////////////////////////////////////////////////////////////////////////
1:                     // When there was no backup and we are reconnecting for the first time
1:                     // we honor the initialReconnectDelay before trying a new connection, after
1:                     // this normal reconnect delay happens following a failed attempt.
1:                     if (transport == null && !firstConnection && connectFailures == 0 && initialReconnectDelay > 0 && !disposed) {
1:                         // reconnectDelay will be equal to initialReconnectDelay since we are on
1:                         // the first connect attempt after we had a working connection, doDelay
1:                         // will apply updates to move to the next reconnectDelay value based on
1:                         // configuration.
1:                         doDelay();
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Waiting {} ms before attempting connection", reconnectDelay);
commit:4ea435b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ConsumerControl;
/////////////////////////////////////////////////////////////////////////
0:                 LOG.warn("Transport (" + connectedTransportURI + ") failed"
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * called with reconnectMutex held
/////////////////////////////////////////////////////////////////////////
1:             for (URI priorityURI : priorityList) {
1:                 if (compareURIs(priorityURI, uri)) {
1:                     return true;
1:                 }
1:             }
1: 
1:         } else if (!uris.isEmpty()) {
1:             return compareURIs(uris.get(0), uri);
1: 
1:         return false;
/////////////////////////////////////////////////////////////////////////
1:     public boolean isConnectedToPriority() {
1:         return connectedToPriority;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
commit:8824ac9
/////////////////////////////////////////////////////////////////////////
1:                             if (command.isMessage() && timeout > 0 && (end - start > timeout)) {
commit:c55a666
/////////////////////////////////////////////////////////////////////////
1: import java.net.InetAddress;
1: import java.net.MalformedURLException;
1: import java.net.URI;
1: import java.net.URISyntaxException;
1: import java.net.URL;
1: import java.util.ArrayList;
1: import java.util.Collections;
1: import java.util.HashSet;
1: import java.util.Iterator;
1: import java.util.LinkedHashMap;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.StringTokenizer;
/////////////////////////////////////////////////////////////////////////
1:     private int warnAfterReconnectAttempts = 10;
/////////////////////////////////////////////////////////////////////////
1: 
1:             int warnInterval = getWarnAfterReconnectAttempts();
0:             if (warnInterval > 0 && (connectFailures % warnInterval) == 0) {
0:                 LOG.warn("Failed to connect to {} after: {} attempt(s) continuing to retry.",
0:                          uris, connectFailures);
1:             }
/////////////////////////////////////////////////////////////////////////
1:     public int getWarnAfterReconnectAttempts() {
1:         return warnAfterReconnectAttempts;
1:     }
1: 
1:     /**
1:      * Sets the number of Connect / Reconnect attempts that must occur before a warn message
1:      * is logged indicating that the transport is not connected.  This can be useful when the
1:      * client is running inside some container or service as it give an indication of some
1:      * problem with the client connection that might not otherwise be visible.  To disable the
1:      * log messages this value should be set to a value @{code attempts <= 0}
1:      *
1:      * @param warnAfterReconnectAttempts
1:      *      The number of failed connection attempts that must happen before a warning is logged.
1:      */
1:     public void setWarnAfterReconnectAttempts(int warnAfterReconnectAttempts) {
1:         this.warnAfterReconnectAttempts = warnAfterReconnectAttempts;
1:     }
1: 
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:8188f7f
/////////////////////////////////////////////////////////////////////////
0:                 LOG.warn("Transport (" + transport + ") failed, reason:  "
0:                         + (reconnectOk ? "," : ", not") + " attempting to automatically reconnect", e);
/////////////////////////////////////////////////////////////////////////
1:                         Tracked tracked = null;
1:                         try {
1:                             tracked = stateTracker.track(command);
1:                         } catch (IOException ioe) {
0:                             LOG.debug("Cannot track the command " + command, ioe);
1:                         }
commit:084d606
/////////////////////////////////////////////////////////////////////////
0:                 LOG.warn("Transport (" + transport + ") failed, reason:  " + e
commit:bc1ca6c
/////////////////////////////////////////////////////////////////////////
1:         synchronized (reconnectMutex) {
1:             if (LOG.isTraceEnabled()) {
0:                 LOG.trace(this + " handleTransportFailure: " + e);
0:             Transport transport = connectedTransport.getAndSet(null);
1:             if (transport != null) {
1: 
1:                 disposeTransport(transport);
1: 
1:                 boolean reconnectOk = false;
1: 
0:                         + (reconnectOk ? "," : ", not") + " attempting to automatically reconnect");
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:06356db
/////////////////////////////////////////////////////////////////////////
1:                 // meed parenthesis due other JDKs (see AMQ-4826)
1:                 int p = ((int) (Math.random() * 100)) % l.size();
commit:8a01c5d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.thread.TaskRunnerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private final TaskRunnerFactory reconnectTaskFactory;
/////////////////////////////////////////////////////////////////////////
1:         reconnectTaskFactory = new TaskRunnerFactory();
1:         reconnectTaskFactory.init();
1:         reconnectTask = reconnectTaskFactory.createTaskRunner(new Task() {
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             synchronized (reconnectMutex) {
1:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug("Stopped " + this);
1:                 }
1:                 if (!started) {
1:                     return;
1:                 }
1:                 started = false;
1:                 disposed = true;
0:                 connected = false;
1:                 if (connectedTransport.get() != null) {
1:                     transportToStop = connectedTransport.getAndSet(null);
1:                 }
1:                 reconnectMutex.notifyAll();
1:             synchronized (sleepMutex) {
1:                 sleepMutex.notifyAll();
1:             }
1:         } finally {
1:             reconnectTask.shutdown();
1:             reconnectTaskFactory.shutdownNow();
1: 
author:Hiram Chirino
-------------------------------------------------------------------------------
commit:0ff3593
/////////////////////////////////////////////////////////////////////////
0: import java.net.*;
0: import java.util.*;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.URISupport;
/////////////////////////////////////////////////////////////////////////
1:     private String nestedExtraQueryOptions;
/////////////////////////////////////////////////////////////////////////
1:                                 uri = addExtraQueryOptions(iter.next());
/////////////////////////////////////////////////////////////////////////
1:                     URI uri = addExtraQueryOptions(iter.next());
/////////////////////////////////////////////////////////////////////////
1: 
1:     private URI addExtraQueryOptions(URI uri) {
1:         try {
1:             if( nestedExtraQueryOptions!=null && !nestedExtraQueryOptions.isEmpty() ) {
1:                 if( uri.getQuery() == null ) {
1:                     uri = URISupport.createURIWithQuery(uri, nestedExtraQueryOptions);
1:                 } else {
1:                     uri = URISupport.createURIWithQuery(uri, uri.getQuery()+"&"+nestedExtraQueryOptions);
1:                 }
1:             }
1:         } catch (URISyntaxException e) {
1:             throw new RuntimeException(e);
1:         }
1:         return uri;
1:     }
1: 
1:     public void setNestedExtraQueryOptions(String nestedExtraQueryOptions) {
1:         this.nestedExtraQueryOptions = nestedExtraQueryOptions;
1:     }
1: 
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:9490793
/////////////////////////////////////////////////////////////////////////
1:     private boolean shouldBuildBackups() {
1:        return (backup && backups.size() < backupPoolSize) || (priorityBackup && !(priorityBackupAvailable || connectedToPriority));
1:     }
1: 
1:             if (!disposed && shouldBuildBackups()) {
/////////////////////////////////////////////////////////////////////////
1:                 for (Iterator<URI> iter = backupList.iterator(); !disposed && iter.hasNext() && shouldBuildBackups(); ) {
/////////////////////////////////////////////////////////////////////////
1:                                    // if this priority backup overflows the pool
1:                                    // remove the backup with the lowest priority
1:                                    if (backups.size() > backupPoolSize) {
1:                                        BackupTransport disposeTransport = backups.remove(backups.size() - 1);
1:                                        disposeTransport.setDisposed(true);
1:                                        Transport transport = disposeTransport.getTransport();
1:                                        if (transport != null) {
1:                                            transport.setTransportListener(disposedListener);
1:                                            disposeTransport(transport);
1:                                        }
1:                                    }
commit:15affd0
/////////////////////////////////////////////////////////////////////////
commit:585a966
/////////////////////////////////////////////////////////////////////////
1:                                    backups.add(0, bt);
1:                                 } else {
1:                                     backups.add(bt);
commit:ce50e28
/////////////////////////////////////////////////////////////////////////
1:                 } else if (!isDisposed()) {
commit:beda82a
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
1:         if (!updated.isEmpty()) {
1:             if (failedConnectTransportURI != null) {
0:                 boolean removed = updated.remove(failedConnectTransportURI);
1:                 if (removed) {
0:                     updated.add(failedConnectTransportURI);
1:                 }
1:             }            
1:             return updated;
1:         ArrayList<URI> l = new ArrayList<URI>(uris);
/////////////////////////////////////////////////////////////////////////
0:             HashSet<URI> copy = new HashSet<URI>(this.updated);
/////////////////////////////////////////////////////////////////////////
0:                 if (!(copy.isEmpty() && updated.isEmpty()) && !copy.equals(new HashSet(updated))) {
commit:19cb932
/////////////////////////////////////////////////////////////////////////
0:         for (URI uri : updated) {
0:             if (!l.contains(uri)) {
0:                 l.add(uri);
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
0:                     if (uri != null && !updated.contains(uri)) {
0:                 if (!(copy.isEmpty() && updated.isEmpty()) && !copy.equals(updated)) {
1:                     buildBackups();
1:                     synchronized (reconnectMutex) {
commit:7388438
/////////////////////////////////////////////////////////////////////////
1:     private boolean connectedToPriority = false;
1: 
1:     private boolean priorityBackup = false;
0:     private ArrayList<URI> priorityList = new ArrayList<URI>();
1:     private boolean priorityBackupAvailable = false;
/////////////////////////////////////////////////////////////////////////
1:                     if ((connectedTransport.get() == null || doRebalance || priorityBackupAvailable) && !disposed) {
1:                         connectedToPriority = isPriority(connectedTransportURI);
1:                     if (priorityBackup && !connectedToPriority) {
1:                         try {
1:                             doDelay();
1:                             reconnectTask.wakeup();
1:                         } catch (InterruptedException e) {
1:                             LOG.debug("Reconnect task has been interrupted.", e);
1:                         }
1:                     }
/////////////////////////////////////////////////////////////////////////
1:     public boolean isPriorityBackup() {
1:         return priorityBackup;
1:     }
1: 
1:     public void setPriorityBackup(boolean priorityBackup) {
1:         this.priorityBackup = priorityBackup;
1:     }
1: 
1:     public void setPriorityURIs(String priorityURIs) {
1:         StringTokenizer tokenizer = new StringTokenizer(priorityURIs, ",");
1:         while (tokenizer.hasMoreTokens()) {
1:             String str = tokenizer.nextToken();
1:             try {
1:                 URI uri = new URI(str);
1:                 priorityList.add(uri);
1:             } catch (Exception e) {
1:                 LOG.error("Failed to parse broker address: " + str, e);
1:             }
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             if ((connectedTransport.get() != null && !doRebalance && !priorityBackupAvailable) || disposed || connectionFailure != null) {
/////////////////////////////////////////////////////////////////////////
1:                         if ((priorityBackup || backup) && !backups.isEmpty()) {
/////////////////////////////////////////////////////////////////////////
1:                             if (priorityBackup && priorityBackupAvailable) {
1:                                 Transport old = this.connectedTransport.getAndSet(null);
1:                                 if (transport != null) {
1:                                     disposeTransport(old);
1:                                 }
1:                                 priorityBackupAvailable = false;
1:                             }
/////////////////////////////////////////////////////////////////////////
1:             doDelay();
1:         }
1:         return !disposed;
1:     }
1: 
1:     private void doDelay() {
1:         if (reconnectDelay > 0) {
1:             synchronized (sleepMutex) {
0:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug("Waiting " + reconnectDelay + " ms before attempting connection");
1:                 try {
1:                     sleepMutex.wait(reconnectDelay);
1:                 } catch (InterruptedException e) {
1:                     Thread.currentThread().interrupt();
1:         if (useExponentialBackOff) {
1:             // Exponential increment of reconnect delay.
1:             reconnectDelay *= backOffMultiplier;
1:             if (reconnectDelay > maxReconnectDelay) {
1:                 reconnectDelay = maxReconnectDelay;
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
0:             if (!disposed && (backup || priorityBackup) && backups.size() < backupPoolSize) {
1:                 ArrayList<URI> backupList = new ArrayList<URI>(priorityList);
1:                 for (URI uri: connectList) {
1:                     if (!backupList.contains(uri)) {
1:                         backupList.add(uri);
1:                     }
1:                 }
/////////////////////////////////////////////////////////////////////////
0:                 for (Iterator<URI> iter = backupList.iterator(); iter.hasNext() && backups.size() < backupPoolSize; ) {
/////////////////////////////////////////////////////////////////////////
1:                                 if (priorityBackup && isPriority(uri)) {
1:                                    priorityBackupAvailable = true;
1:                                 }
/////////////////////////////////////////////////////////////////////////
1:     
1:     protected boolean isPriority(URI uri) {
1:         if (!priorityList.isEmpty()) {
0:             return priorityList.contains(uri);
1:         }
0:         return uris.indexOf(uri) == 0;
1:     }
commit:91059de
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.io.BufferedReader;
1: import java.io.FileReader;
1: import java.io.IOException;
1: import java.io.InputStreamReader;
1: import java.io.InterruptedIOException;
0: import java.net.InetAddress;
0: import java.net.MalformedURLException;
0: import java.net.URI;
0: import java.net.URL;
0: import java.util.ArrayList;
0: import java.util.Collections;
0: import java.util.Iterator;
0: import java.util.LinkedHashMap;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.StringTokenizer;
1: import java.util.concurrent.CopyOnWriteArrayList;
1: import java.util.concurrent.atomic.AtomicReference;
1: 
/////////////////////////////////////////////////////////////////////////
1:                     updated.remove(failedConnectTransportURI);
/////////////////////////////////////////////////////////////////////////
0:         l.addAll(updated);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                             ArrayList<BackupTransport> l = new ArrayList(backups);
1:                             if (randomize) {
1:                                 Collections.shuffle(l);
1:                             }
1:                             BackupTransport bt = l.remove(0);
1:                             backups.remove(bt);
/////////////////////////////////////////////////////////////////////////
0:             updated.clear();
0:                     if (uri != null && !uris.contains(uri)) {
0:                         updated.add(uri);
0:                     if (!(copy.isEmpty() && updated.isEmpty()) && !copy.equals(updated)) {
0:                         buildBackups();
1:                         reconnect(rebalance);
commit:6c09e84
/////////////////////////////////////////////////////////////////////////
1:     public final void disposeTransport(Transport transport) {
1:         transport.setTransportListener(disposedListener);
1:         ServiceSupport.dispose(transport);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:             disposeTransport(transport);
/////////////////////////////////////////////////////////////////////////
0:                                     disposeTransport(transport);
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(FailoverTransport.class);
commit:32db9c5
/////////////////////////////////////////////////////////////////////////
0:     private long reconnectDelay = -1;
/////////////////////////////////////////////////////////////////////////
0:                     if (!useExponentialBackOff || reconnectDelay == -1) {
commit:4a12796
/////////////////////////////////////////////////////////////////////////
0:     private long timeout = -1;
/////////////////////////////////////////////////////////////////////////
1:     public long getTimeout() {
1: 		return timeout;
1: 	}
1: 
1: 	public void setTimeout(long timeout) {
1: 		this.timeout = timeout;
1: 	}
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1:             	
/////////////////////////////////////////////////////////////////////////
1:                 }
1:                         long start = System.currentTimeMillis();
1:                         boolean timedout = false;
1:                             long end = System.currentTimeMillis();
0:                             if (timeout > 0 && (end - start > timeout)) {
1:                             	timedout = true;
0:                             	LOG.info("Failover timed out after " + (end - start) + "ms");
1:                             	break;
1:                             }
1:                                 reconnectMutex.wait(100);
/////////////////////////////////////////////////////////////////////////
1:                             } else if (timedout == true) {
1:                             	error = new IOException("Failover timeout of " + timeout + " ms reached.");
0:                             }else {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:3a8eb74
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isTraceEnabled()) {
1:             LOG.trace("Received ConnectionControl: {}", control);
1:         }
1: 
commit:e777126
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 connectedToPriority = false;
/////////////////////////////////////////////////////////////////////////
1:                         if (connectedToPriority || compareURIs(connectList.get(0), connectedTransportURI)) {
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:                             if (LOG.isDebugEnabled()) {
1:                             }
0:                             connectedToPriority = isPriority(connectedTransportURI);
/////////////////////////////////////////////////////////////////////////
1:         if (!priorityBackup) {
1:             return false;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         boolean result = false;
1:             return result;
/////////////////////////////////////////////////////////////////////////
1: 
1:                 if (firstAddr.equals(secondAddr)) {
1:                     result = true;
1:                 }
1: 
0:                     LOG.error("Failed to Lookup INetAddress for URI[ " + first + " ] : " + e);
0:                     LOG.error("Failed to Lookup INetAddress for URI[ " + second + " ] : " + e);
1:                     result = true;
1:         return result;
commit:fbac51c
/////////////////////////////////////////////////////////////////////////
1:     private final ArrayList<URI> priorityList = new ArrayList<URI>();
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:                         if (compareURIs(connectList.get(0), connectedTransportURI)) {
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             if (compareURIs(newURI, uri)) {
1:                 result = true;
1:                 break;
1:     private boolean compareURIs(final URI first, final URI second) {
1: 
1:         if (first == null || second == null) {
1:             return false;
1:         }
1: 
1:         if (first.getPort() == second.getPort()) {
1:             InetAddress firstAddr = null;
1:             InetAddress secondAddr = null;
1:             try {
1:                 firstAddr = InetAddress.getByName(first.getHost());
1:                 secondAddr = InetAddress.getByName(second.getHost());
1:             } catch(IOException e) {
1: 
1:                 if (firstAddr == null) {
0:                     LOG.error("Failed to Lookup INetAddress for URI[ " + firstAddr + " ] : " + e);
1:                 } else {
0:                     LOG.error("Failed to Lookup INetAddress for URI[ " + secondAddr + " ] : " + e);
1:                 }
1: 
1:                 if (first.getHost().equalsIgnoreCase(second.getHost())) {
1:                     return true;
1:                 }
1:             }
1: 
0:             if (firstAddr.equals(secondAddr)) {
1:                 return true;
1:             }
1:         }
1: 
1:         return false;
1:     }
1: 
commit:ca15308
/////////////////////////////////////////////////////////////////////////
0:                 for (Iterator<URI> iter = backupList.iterator(); !disposed && iter.hasNext() && backups.size() < backupPoolSize; ) {
commit:205d025
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         synchronized(backupMutex) {
1:             for (BackupTransport backup : backups) {
1:                 backup.setDisposed(true);
1:                 Transport transport = backup.getTransport();
1:                 if (transport != null) {
1:                     transport.setTransportListener(disposedListener);
1:                     backupsToStop.add(transport);
1:                 }
1:             }
1:             backups.clear();
0:                 if (LOG.isTraceEnabled()) {
0:                     LOG.trace("Stopped backup: " + transport);
1:                 }
1:         if (transportToStop != null) {
1:             transportToStop.stop();
1:         }
commit:14e636b
/////////////////////////////////////////////////////////////////////////
1:         List<Transport> backupsToStop = new ArrayList<Transport>(backups.size());
1: 
/////////////////////////////////////////////////////////////////////////
0:             for (BackupTransport backup : backups) {
0:                 backup.setDisposed(true);
0:                 Transport transport = backup.getTransport();
1:                 if (transport != null) {
0:                     transport.setTransportListener(disposedListener);
0:                     backupsToStop.add(transport);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:         for (Transport transport : backupsToStop) {
1:             try {
0:                 disposeTransport(transport);
1:             } catch (Exception e) {
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:                         MessagePull pullRequest = (MessagePull) command;
1:                         if (pullRequest.getTimeout() != 0) {
1:                             MessageDispatch dispatch = new MessageDispatch();
1:                             dispatch.setConsumerId(pullRequest.getConsumerId());
1:                             dispatch.setDestination(pullRequest.getDestination());
commit:0227c08
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.MessageDispatch;
1: import org.apache.activemq.command.MessagePull;
/////////////////////////////////////////////////////////////////////////
1:                     } else if (command instanceof MessagePull) {
1:                         // Simulate response to MessagePull if timed as we can't honor that now.
0:                     	MessagePull pullRequest = (MessagePull) command;
0:                     	if (pullRequest.getTimeout() != 0) {
0: 	                        MessageDispatch dispatch = new MessageDispatch();
0: 	                        dispatch.setConsumerId(pullRequest.getConsumerId());
0: 	                        dispatch.setDestination(pullRequest.getDestination());
0:                             myTransportListener.onCommand(dispatch);
1:                         }
1:                         return;
commit:d92d3a8
/////////////////////////////////////////////////////////////////////////
1:                             if (reconnectTask == null) {
1:                                 return true;
1:                             }
/////////////////////////////////////////////////////////////////////////
1:                         if (reconnectTask == null) {
0:                             return true;
1:                         }
commit:a7e7bce
/////////////////////////////////////////////////////////////////////////
1:                             } else {
1:                                 // Handle the error but allow the method to return since the
1:                                 // tracked commands are replayed on reconnect.
0:                                 if (LOG.isDebugEnabled()) {
0:                                     LOG.debug("Send oneway attempt: " + i + " failed for command:" + command);
1:                                 }
1:                                 handleTransportFailure(e);
commit:a3060e7
/////////////////////////////////////////////////////////////////////////
0: import java.io.BufferedReader;
0: import java.io.FileReader;
0: import java.io.IOException;
0: import java.io.InputStreamReader;
0: import java.io.InterruptedIOException;
0: import java.net.InetAddress;
0: import java.net.MalformedURLException;
0: import java.net.URI;
0: import java.net.URL;
0: import java.util.ArrayList;
0: import java.util.Collections;
0: import java.util.HashSet;
0: import java.util.Iterator;
0: import java.util.LinkedHashMap;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.StringTokenizer;
0: import java.util.concurrent.CopyOnWriteArrayList;
0: import java.util.concurrent.atomic.AtomicReference;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             }
/////////////////////////////////////////////////////////////////////////
1:                             ArrayList<BackupTransport> l = new ArrayList<BackupTransport>(backups);
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:                 if (!(copy.isEmpty() && updated.isEmpty()) && !copy.equals(new HashSet<URI>(updated))) {
commit:1d52f3b
/////////////////////////////////////////////////////////////////////////
1:         for (URI uri : uris) {
0:             if (newURI.getPort() == uri.getPort()) {
0:                 InetAddress newAddr = null;
0:                 InetAddress addr = null;
1:                 try {
0:                     newAddr = InetAddress.getByName(newURI.getHost());
0:                     addr = InetAddress.getByName(uri.getHost());
0:                 } catch(IOException e) {
1: 
0:                     if (newAddr == null) {
0:                         LOG.error("Failed to Lookup INetAddress for URI[ " + newURI + " ] : " + e);
1:                     } else {
0:                         LOG.error("Failed to Lookup INetAddress for URI[ " + uri + " ] : " + e);
1:                     }
1: 
0:                     if (newURI.getHost().equalsIgnoreCase(uri.getHost())) {
1:                     } else {
0:                         continue;
1: 
0:                 if (addr.equals(newAddr)) {
0:                     result = true;
1:                     break;
1:                 }
1: 
commit:7d8ce02
/////////////////////////////////////////////////////////////////////////
1:     public int getCurrentBackups() {
1:         return this.backups.size();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                         if (command.isResponseRequired()) {
1:                             Response response = new Response();
1:                             response.setCorrelationId(command.getCommandId());
0:                             myTransportListener.onCommand(response);
1:                         }
/////////////////////////////////////////////////////////////////////////
0:                             if (LOG.isTraceEnabled()) {
0:                                 LOG.trace("Waiting for transport to reconnect..: " + command);
1:                             }
0:                                 if (LOG.isInfoEnabled()) {
0:                                     LOG.info("Failover timed out after " + (end - start) + "ms");
1:                                 }
0:                                 if (LOG.isDebugEnabled()) {
0:                                     LOG.debug("Interupted: " + e, e);
1:                                 }
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:                     Transport transport = null;
1:                     URI uri = null;
1: 
1:                     // If we have a backup already waiting lets try it.
1:                             transport = bt.getTransport();
1:                             uri = bt.getUri();
0:                     // Sleep for the reconnectDelay if there's no backup and we aren't trying
0:                     // for the first time, or we were disposed for some reason.
0:                     if (transport == null && !firstConnection && (reconnectDelay > 0) && !disposed) {
/////////////////////////////////////////////////////////////////////////
1:                     while ((transport != null || iter.hasNext()) && (connectedTransport.get() == null && !disposed)) {
1:                             SslContext.setCurrentSslContext(brokerSslContext);
1: 
1:                             // We could be starting with a backup and if so we wait to grab a
1:                             // URI from the pool until next time around.
1:                             if (transport == null) {
0:                                 uri = iter.next();
1:                                 transport = TransportFactory.compositeConnect(uri);
1:                             }
1: 
0:                             transport.setTransportListener(myTransportListener);
1:                             transport.start();
1:                                 restoreTransport(transport);
1:                             connectedTransport.set(transport);
1: 
1:                             // Make sure on initial startup, that the transportListener
1:                                         // if it isn't set after 2secs - it probably never will be
1: 
1: 
1: 
0:                             if (LOG.isDebugEnabled()) {
0:                                 LOG.debug("Connect fail to: " + uri + ", reason: " + e);
1:                             }
0:                             if (transport != null) {
1:                                     transport.stop();
1:                                     transport = null;
0:                                     if (LOG.isDebugEnabled()) {
0:                                         LOG.debug("Stop of failed transport: " + transport +
0:                                                   " failed with reason: " + ee);
1:                                     }
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1:                 // Make sure on initial startup, that the transportListener has been
1:                 // initialized for this instance.
/////////////////////////////////////////////////////////////////////////
commit:ad76330
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 if (command != null && connectedTransport.get() == null) {
1:                         // Skipping send of ShutdownInfo command when not connected.
1:                     } else if (command instanceof RemoveInfo || command.isMessageAck()) {
1:                         // Simulate response to RemoveInfo command or MessageAck (as it will be stale)
1:                     	if (command.isResponseRequired()) {
0: 	                        Response response = new Response();
0: 	                        response.setCorrelationId(command.getCommandId());
0: 	                        myTransportListener.onCommand(response);
1:                     	}
1: 
commit:b6b6911
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private boolean updateURIsSupported = true;
1:     private boolean reconnectSupported = true;
1:     private boolean rebalanceUpdateURIs = true;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 if (!initialized) {
1: 
0:                 if (command.isConnectionControl()) {
/////////////////////////////////////////////////////////////////////////
0:                 // notify before any reconnect attempt so ack state can be whacked
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @param randomize The randomize to set.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         for (URI uri : u) {
1:             if (!contains(uri)) {
1:                 uris.add(uri);
/////////////////////////////////////////////////////////////////////////
1:         for (URI uri : u) {
1:             uris.remove(uri);
/////////////////////////////////////////////////////////////////////////
1:             if (contains(newURI) == false) {
1: 
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isDebugEnabled()) {
0:             LOG.debug("urlList connectionList:" + l + ", from: " + uris);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         Map<Integer, Command> tmpMap = null;
1:         for (Command command : tmpMap.values()) {
/////////////////////////////////////////////////////////////////////////
1:     private void doUpdateURIsFromDisk() {
1: 
1:         // If updateURIsURL is specified, read the file and add any new
1:         // transport URI's to this FailOverTransport.
1:         // Note: Could track file timestamp to avoid unnecessary reading.
1:         String fileURL = getUpdateURIsURL();
1:         if (fileURL != null) {
1:             BufferedReader in = null;
1:             String newUris = null;
1:             StringBuffer buffer = new StringBuffer();
1: 
1:             try {
1:                 in = new BufferedReader(getURLStream(fileURL));
1:                 while (true) {
1:                     String line = in.readLine();
1:                     if (line == null) {
1:                         break;
1:                     }
1:                     buffer.append(line);
1:                 }
1:                 newUris = buffer.toString();
1:             } catch (IOException ioe) {
0:                 LOG.error("Failed to read updateURIsURL: " + fileURL, ioe);
1:             } finally {
1:                 if (in != null) {
1:                     try {
1:                         in.close();
1:                     } catch (IOException ioe) {
1:                         // ignore
1:                     }
1:                 }
1:             }
1: 
1:             processNewTransports(isRebalanceUpdateURIs(), newUris);
1:         }
1:     }
1: 
1:             // First ensure we are up to date.
1:             doUpdateURIsFromDisk();
/////////////////////////////////////////////////////////////////////////
0:                             if (LOG.isDebugEnabled()) {
0:                                 LOG.debug("Doing rebalance from: " + connectedTransportURI + " to " + connectList);
1:                             }
0:                                 if (LOG.isDebugEnabled()) {
0:                                     LOG.debug("Caught an exception stopping existing transport for rebalance", e);
1:                                 }
/////////////////////////////////////////////////////////////////////////
0:                     // Sleep for the reconnectDelay
0:                     if (!firstConnection && (reconnectDelay > 0) && !disposed) {
0:                         synchronized (sleepMutex) {
0:                             LOG.debug("Waiting " + reconnectDelay + " ms before attempting connection. ");
1:                             try {
0:                                 sleepMutex.wait(reconnectDelay);
1:                             } catch (InterruptedException e) {
1:                                 Thread.currentThread().interrupt();
1:                             }
1:                         }
1:                     }
1: 
1: 
0:                             if (LOG.isDebugEnabled()) {
0:                                 LOG.debug("Attempting connect to: " + uri);
1:                             }
/////////////////////////////////////////////////////////////////////////
0:                 // been initialized for this instance.
/////////////////////////////////////////////////////////////////////////
1: 
0:             if (reconnectDelay > 0) {
0:                 synchronized (sleepMutex) {
0:                     LOG.debug("Waiting " + reconnectDelay + " ms before attempting connection. ");
1:                     try {
0:                         sleepMutex.wait(reconnectDelay);
1:                     } catch (InterruptedException e) {
1:                         Thread.currentThread().interrupt();
1:                     }
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:                 for (Iterator<URI> iter = connectList.iterator(); iter.hasNext() && backups.size() < backupPoolSize; ) {
/////////////////////////////////////////////////////////////////////////
1:         add(true, new URI[]{uri});
1: 
1:         this.reconnectSupported = value;
1: 
1: 
1:         this.updateURIsSupported = value;
/////////////////////////////////////////////////////////////////////////
0:                 for (URI uri : updatedURIs) {
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0:             for (URI uri : uris) {
0:                 if (newURI.getPort() == uri.getPort()) {
0:                     InetAddress newAddr = InetAddress.getByName(newURI.getHost());
0:                     InetAddress addr = InetAddress.getByName(uri.getHost());
0:                     if (addr.equals(newAddr)) {
0:                         result = true;
0:                         break;
1:                     }
1:         } catch (IOException e) {
1: 
author:Gary Tully
-------------------------------------------------------------------------------
commit:d687324
/////////////////////////////////////////////////////////////////////////
1:                                 if (old != null) {
commit:599abc5
/////////////////////////////////////////////////////////////////////////
1:             connectFailures++;
1:             if (reconnectLimit != INFINITE && connectFailures >= reconnectLimit) {
/////////////////////////////////////////////////////////////////////////
1:     public int getConnectFailures() {
1:         return connectFailures;
1:     }
1: 
commit:f4e0725
/////////////////////////////////////////////////////////////////////////
1:                 if (!started) {
1:                     return result;
1:                 }
commit:4acd132
/////////////////////////////////////////////////////////////////////////
1:     private static final int INFINITE = -1;
/////////////////////////////////////////////////////////////////////////
1:     private long timeout = INFINITE;
1:     private int maxReconnectAttempts = INFINITE;
1:     private int startupMaxReconnectAttempts = INFINITE;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 if (canReconnect()) {
0:                 LOG.warn("Transport (" + transport.getRemoteAddress() + ") failed, reason:  " + e
0:                         + (reconnectOk ? "," : ", not")  +" attempting to automatically reconnect");
1: 
/////////////////////////////////////////////////////////////////////////
1:                 } else {
1:                     propagateFailureToExceptionListener(e);
1:     private boolean canReconnect() {
1:         return started && 0 != calculateReconnectAttemptLimit();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("Started " + this);
1:             }
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("Stopped " + this);
1:             }
/////////////////////////////////////////////////////////////////////////
1:                     resetReconnectDelay();
/////////////////////////////////////////////////////////////////////////
0:                             if (LOG.isDebugEnabled()) {
0:                                 LOG.debug("Waiting " + reconnectDelay + " ms before attempting connection. ");
1:                             }
/////////////////////////////////////////////////////////////////////////
0:                                 LOG.debug("Attempting  " + connectFailures + "th  connect to: " + uri);
0:                             if (started &&  !firstConnection) {
0:                              if (LOG.isDebugEnabled()) {
0:                                 LOG.debug("Connection established");
1:                              }
/////////////////////////////////////////////////////////////////////////
0:                                 if (LOG.isDebugEnabled()) {
0:                                     LOG.debug("transport resumed by transport listener not set");
1:                                 }
/////////////////////////////////////////////////////////////////////////
1:             int reconnectLimit = calculateReconnectAttemptLimit();
0:             if (reconnectLimit != INFINITE && ++connectFailures >= reconnectLimit) {
0:                 LOG.error("Failed to connect to " + uris + " after: " + connectFailures + " attempt(s)");
/////////////////////////////////////////////////////////////////////////
1:                 propagateFailureToExceptionListener(connectionFailure);
/////////////////////////////////////////////////////////////////////////
0:                     if (LOG.isDebugEnabled()) {
0:                         LOG.debug("Waiting " + reconnectDelay + " ms before attempting connection");
1:                     }
/////////////////////////////////////////////////////////////////////////
1:     private void resetReconnectDelay() {
1:         if (!useExponentialBackOff || reconnectDelay == DEFAULT_INITIAL_RECONNECT_DELAY) {
1:             reconnectDelay = initialReconnectDelay;
1:         }
1:     }
1: 
1:     /*
0:       * called with reconnectMutex held
1:      */
1:     private void propagateFailureToExceptionListener(Exception exception) {
1:         if (transportListener != null) {
1:             if (exception instanceof IOException) {
1:                 transportListener.onException((IOException)exception);
1:             } else {
1:                 transportListener.onException(IOExceptionSupport.create(exception));
1:             }
1:         }
1:         reconnectMutex.notifyAll();
1:     }
1: 
1:     private int calculateReconnectAttemptLimit() {
1:         int maxReconnectValue = this.maxReconnectAttempts;
1:         if (firstConnection && this.startupMaxReconnectAttempts != INFINITE) {
1:             maxReconnectValue = this.startupMaxReconnectAttempts;
1:         }
1:         return maxReconnectValue;
1:     }
1: 
commit:986ed14
/////////////////////////////////////////////////////////////////////////
1:                     buildBackup = true;
commit:c752230
/////////////////////////////////////////////////////////////////////////
1:     private boolean doRebalance = false;
/////////////////////////////////////////////////////////////////////////
0:                     if ((connectedTransport.get() == null || doRebalance) && !disposed) {
/////////////////////////////////////////////////////////////////////////
1:         // rebalance is automatic if any connected to removed/stopped broker
/////////////////////////////////////////////////////////////////////////
1:                     doRebalance = true;
/////////////////////////////////////////////////////////////////////////
0:         LOG.debug("urlList connectionList:" + l + ", from: " + uris);
/////////////////////////////////////////////////////////////////////////
0:             if ((connectedTransport.get() != null && !doRebalance) || disposed || connectionFailure != null) {
1:                     if (doRebalance) {
0:                         if (connectList.get(0).equals(connectedTransportURI)) {
1:                             // already connected to first in the list, no need to rebalance
1:                             doRebalance = false;
1:                             return false;
1:                         } else {
0:                             LOG.debug("Doing rebalance from: " + connectedTransportURI + " to " + connectList);
1:                             try {
1:                                 Transport transport = this.connectedTransport.getAndSet(null);
0:                                 if (transport != null) {
0:                                     transport.stop();
1:                                 }
1:                             } catch (Exception e) {
0:                                 LOG.debug("Caught an exception stopping existing transport for rebalance", e);
1:                             }
1:                         }
1:                         doRebalance = false;
1:                     }
commit:738e9a1
/////////////////////////////////////////////////////////////////////////
0:             if (!contains(u[i])) {
0:                 uris.add(u[i]);
/////////////////////////////////////////////////////////////////////////
1: 
commit:6ed942a
/////////////////////////////////////////////////////////////////////////
1:     private static final int DEFAULT_INITIAL_RECONNECT_DELAY = 10;
/////////////////////////////////////////////////////////////////////////
1:     private long initialReconnectDelay = DEFAULT_INITIAL_RECONNECT_DELAY;
/////////////////////////////////////////////////////////////////////////
1:     private long reconnectDelay = DEFAULT_INITIAL_RECONNECT_DELAY;
/////////////////////////////////////////////////////////////////////////
0:                     if (!useExponentialBackOff || reconnectDelay == DEFAULT_INITIAL_RECONNECT_DELAY) {
commit:4c4f0d1
/////////////////////////////////////////////////////////////////////////
commit:a6a6a70
/////////////////////////////////////////////////////////////////////////
0:                 LOG.trace("restore requestMap, replay: " + command);
commit:c4d8bc4
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.activemq.broker.SslContext;
/////////////////////////////////////////////////////////////////////////
1:     // remember for reconnect thread
1:     private SslContext brokerSslContext;
1:         brokerSslContext = SslContext.getCurrentSslContext();
/////////////////////////////////////////////////////////////////////////
1:                             SslContext.setCurrentSslContext(brokerSslContext);
/////////////////////////////////////////////////////////////////////////
1:                         } finally {
1:                             SslContext.setCurrentSslContext(null);
/////////////////////////////////////////////////////////////////////////
0:                             SslContext.setCurrentSslContext(brokerSslContext);
/////////////////////////////////////////////////////////////////////////
1:                         } finally {
1:                             SslContext.setCurrentSslContext(null);
commit:4eafccc
/////////////////////////////////////////////////////////////////////////
0:                         ((Tracked) object).onResponses(command);
/////////////////////////////////////////////////////////////////////////
1:     public ConnectionStateTracker getStateTracker() {
1:         return stateTracker;
1:     }
1:     
commit:b836af8
/////////////////////////////////////////////////////////////////////////
1: 
0:                 stateTracker.transportInterrupted();
1: 
commit:5a03c37
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isTraceEnabled()) {
0:             LOG.trace(this + " handleTransportFailure: " + e);
1:         }
1:         if (transport == null) {
0:             // sync with possible in progress reconnect
1:             synchronized (reconnectMutex) {
0:                 transport = connectedTransport.getAndSet(null); 
1:             }
1:         }
0:         if (transport != null) {
commit:8d3ca90
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ConnectionId;
/////////////////////////////////////////////////////////////////////////
0:     private boolean connectionInterruptProcessingComplete;
/////////////////////////////////////////////////////////////////////////
0:                     LOG.warn("Transport (" + transport.getRemoteAddress() + ") failed to " + connectedTransportURI+ " , attempting to automatically reconnect due to: " + e);
/////////////////////////////////////////////////////////////////////////
0:                 stateTracker.transportInterrupted();
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void connectionInterruptProcessingComplete(ConnectionId connectionId) {
1:         synchronized (reconnectMutex) {
1:             stateTracker.connectionInterruptProcessingComplete(this, connectionId);
1:         }
1:     }
commit:62eb5cf
/////////////////////////////////////////////////////////////////////////
0:             boolean reconnectOk = false;
1:                 }          
1:             
0:                 // notify before any reconnect attempt so ack state can be whacked
1:                 if (transportListener != null) {
0:                     transportListener.transportInterupted();
1:                 }
1:             
1:                 if (reconnectOk) {
/////////////////////////////////////////////////////////////////////////
0:                     if(command instanceof RemoveInfo || command.isMessageAck()) {
0:                         // Simulate response to RemoveInfo command or ack (as it will be stale)
/////////////////////////////////////////////////////////////////////////
0:                             LOG.trace("Waiting for transport to reconnect..: " + command);
/////////////////////////////////////////////////////////////////////////
0:                                     restoreTransport(t);  
/////////////////////////////////////////////////////////////////////////
0: 					   } catch(Exception e) {
commit:b9e51d6
/////////////////////////////////////////////////////////////////////////
1:     private boolean trackTransactionProducers = true;
/////////////////////////////////////////////////////////////////////////
1:             stateTracker.setTrackTransactionProducers(isTrackTransactionProducers());
/////////////////////////////////////////////////////////////////////////
1:     public boolean isTrackTransactionProducers() {
1:         return this.trackTransactionProducers;
1:     }
1: 
1:     public void setTrackTransactionProducers(boolean trackTransactionProducers) {
1:         this.trackTransactionProducers = trackTransactionProducers;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:                             LOG.debug("Send oneway attempt: " + i + " failed for command:" + command);
commit:684c901
/////////////////////////////////////////////////////////////////////////
0:                 int p = (int) (Math.random()*100 % l.size());
/////////////////////////////////////////////////////////////////////////
0:         LOG.debug("urlList connectionList:" + l);
commit:9383c6d
/////////////////////////////////////////////////////////////////////////
1:                         stateTracker.track(command);
commit:4b4ce4a
/////////////////////////////////////////////////////////////////////////
0:                         Transport t = null;
0:                             t = TransportFactory.compositeConnect(uri);
/////////////////////////////////////////////////////////////////////////
0:                             if (t!=null) {
1:                                 try {
0:                                     t.stop();       
1:                                 } catch (Exception ee) {
0:                                     LOG.debug("Stop of failed transport: " + t + " failed with reason: " + ee);
1:                                 }
1:                             }
commit:132f662
/////////////////////////////////////////////////////////////////////////
0:                         if (LOG.isDebugEnabled()) {
0:                             LOG.debug("Send oneway attempt: " + i + " failed for command:" + command);   
1:                         }
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isTraceEnabled()) {
0:                 LOG.trace("restore, replay: " + command);
1:             }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:9a8f6e4
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:8978ac0
/////////////////////////////////////////////////////////////////////////
1: 
1:     public int getReceiveCounter() {
1:         Transport transport = connectedTransport.get();
0:         if( transport == null ) {
1:             return 0;
1:         }
1:         return transport.getReceiveCounter();
1:     }
commit:c04d8c5
/////////////////////////////////////////////////////////////////////////
0:     private TransportListener disposedListener = new DefaultTransportListener() {};
/////////////////////////////////////////////////////////////////////////
0:         Transport transport = connectedTransport.getAndSet(null);
0:             transport.setTransportListener(disposedListener);
0:             ServiceSupport.dispose(transport);
1:             
1:             synchronized (reconnectMutex) {
0:                 boolean reconnectOk = false;
0:                 if(started) {
0:                     LOG.warn("Transport failed, attempting to automatically reconnect due to: " + e);
0:                     LOG.debug("Transport failed with the following exception:", e);
1:                     reconnectOk = true;
1:                 }
1:                 
1:                     
0:                 if(reconnectOk) {
1:                     reconnectTask.wakeup();
1:                 }
0:             if (transportListener != null) {
0:                 transportListener.transportInterupted();
1:             }
commit:cdd2108
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.Message;
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
1:                         Transport transport = connectedTransport.get();
0:                         while (transport == null && !disposed && connectionFailure == null) {
/////////////////////////////////////////////////////////////////////////
1:                             transport = connectedTransport.get();
1:                         if (transport == null) {
/////////////////////////////////////////////////////////////////////////
1:                             transport.oneway(command);
commit:c6b88f1
/////////////////////////////////////////////////////////////////////////
0:         boolean wasConnected=false;            
/////////////////////////////////////////////////////////////////////////
0:                 wasConnected=true;
/////////////////////////////////////////////////////////////////////////
1: 
0:         // Avoid double firing a transportInterupted() event due to an extra IOException
0:         if (transportListener != null && wasConnected) {
0:             transportListener.transportInterupted();
1:         }
1: 
commit:c0b74f0
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicReference;
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicReference<Transport> connectedTransport = new AtomicReference<Transport>();
/////////////////////////////////////////////////////////////////////////
0:             	if (connectedTransport.get()==null && !disposed) {
/////////////////////////////////////////////////////////////////////////
1:         
1:         Transport transport = connectedTransport.get();
0:         if( transport!=null ) {
0:             ServiceSupport.dispose(transport);
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:             if (connectedTransport.get() != null) {
0:                 connectedTransport.set(null);
/////////////////////////////////////////////////////////////////////////
0:             if (connectedTransport.get() != null) {
1:                 stateTracker.restore(connectedTransport.get());
/////////////////////////////////////////////////////////////////////////
0:             if (connectedTransport.get() != null) {
0:                 transportToStop = connectedTransport.getAndSet(null);
/////////////////////////////////////////////////////////////////////////
1:         return connectedTransport.get();
/////////////////////////////////////////////////////////////////////////
0:                 if (isShutdownCommand(command) && connectedTransport.get() == null) {
/////////////////////////////////////////////////////////////////////////
0:                         while (connectedTransport.get() == null && !disposed && connectionFailure == null) {
/////////////////////////////////////////////////////////////////////////
0:                         if (connectedTransport.get() == null) {
/////////////////////////////////////////////////////////////////////////
0:                             connectedTransport.get().oneway(command);
/////////////////////////////////////////////////////////////////////////
1:         Transport transport = connectedTransport.get();
0:         if ( transport != null) {
1:             return transport.narrow(target);
/////////////////////////////////////////////////////////////////////////
0:         Transport transport = connectedTransport.get();
0:         if ( transport != null) {
1:             return transport.getRemoteAddress();
/////////////////////////////////////////////////////////////////////////
0:             if (connectedTransport.get() != null || disposed || connectionFailure != null) {
/////////////////////////////////////////////////////////////////////////
0:                             connectedTransport.set(t);
/////////////////////////////////////////////////////////////////////////
0:                     while(iter.hasNext() && connectedTransport.get() == null && !disposed) {
/////////////////////////////////////////////////////////////////////////
0:                             connectedTransport.set(t);
commit:d3d58fe
/////////////////////////////////////////////////////////////////////////
1:             } else {
0:                 reconnect();
commit:487e694
/////////////////////////////////////////////////////////////////////////
0:         Transport transportToStop=null;
/////////////////////////////////////////////////////////////////////////
0:                 transportToStop = connectedTransport;
/////////////////////////////////////////////////////////////////////////
0:         if( transportToStop!=null ) {
0:             transportToStop.stop();
1:         }
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
1:     private final CopyOnWriteArrayList<URI> uris = new CopyOnWriteArrayList<URI>();
0:     private final ConcurrentHashMap<Integer, Command> requestMap = new ConcurrentHashMap<Integer, Command>();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                         ArrayList<Object> connectList = getConnectList();
0:                             Iterator<Object> iter = connectList.iterator();
/////////////////////////////////////////////////////////////////////////
0:     TransportListener createTransportListener() {
1:         return new TransportListener() {
1:             public void onCommand(Object o) {
0:                 Command command = (Command)o;
0:                 if (command == null) {
1:                     return;
1:                 }
0:                 if (command.isResponse()) {
0:                     Object object = requestMap.remove(Integer.valueOf(((Response)command).getCorrelationId()));
0:                     if (object != null && object.getClass() == Tracked.class) {
0:                         ((Tracked)object).onResponses();
1:                     }
1:                 }
0:                 if (!initialized) {
0:                     if (command.isBrokerInfo()) {
0:                         BrokerInfo info = (BrokerInfo)command;
0:                         BrokerInfo[] peers = info.getPeerBrokerInfos();
0:                         if (peers != null) {
0:                             for (int i = 0; i < peers.length; i++) {
0:                                 String brokerString = peers[i].getBrokerURL();
0:                                 add(brokerString);
1:                             }
1:                         }
0:                         initialized = true;
1:                     }
1: 
1:                 }
0:                 if (transportListener != null) {
0:                     transportListener.onCommand(command);
1:                 }
1:             }
1: 
1:             public void onException(IOException error) {
1:                 try {
0:                     handleTransportFailure(error);
1:                 } catch (InterruptedException e) {
1:                     Thread.currentThread().interrupt();
0:                     transportListener.onException(new InterruptedIOException());
1:                 }
1:             }
1: 
1:             public void transportInterupted() {
0:                 if (transportListener != null) {
0:                     transportListener.transportInterupted();
1:                 }
1:             }
1: 
1:             public void transportResumed() {
0:                 if (transportListener != null) {
1:                     transportListener.transportResumed();
1:                 }
1:             }
1:         };
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:     private ArrayList<Object> getConnectList() {
0:         ArrayList<Object> l = new ArrayList<Object>(uris);
/////////////////////////////////////////////////////////////////////////
1:     public <T> T narrow(Class<T> target) {
1:             return target.cast(this);
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator<Command> iter2 = requestMap.values().iterator(); iter2.hasNext();) {
0:             Command command = iter2.next();
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(FailoverTransport.class);
/////////////////////////////////////////////////////////////////////////
0:                                     LOG.debug("Attempting connect to: " + uri);
/////////////////////////////////////////////////////////////////////////
0:                                     LOG.debug("Connection established");
/////////////////////////////////////////////////////////////////////////
0:                                     LOG.info("Successfully reconnected to " + uri);
0:                                     LOG.debug("Connect fail to: " + uri + ", reason: " + e);
0:                         LOG.error("Failed to connect to transport after: " + connectFailures + " attempt(s)");
/////////////////////////////////////////////////////////////////////////
0:                     LOG.debug("Waiting " + reconnectDelay + " ms before attempting connection. ");
/////////////////////////////////////////////////////////////////////////
0:                         if (reconnectDelay > maxReconnectDelay) {
1:                         }
/////////////////////////////////////////////////////////////////////////
0:             LOG.warn("Transport failed, attempting to automatically reconnect due to: " + e, e);
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("Started.");
1:             if (started) {
1:             }
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("Stopped.");
0:             if (!started) {
1:             }
/////////////////////////////////////////////////////////////////////////
0:                             LOG.trace("Waiting for transport to reconnect.");
0:                                 LOG.debug("Interupted: " + e, e);
/////////////////////////////////////////////////////////////////////////
0:                         LOG.debug("Send oneway attempt: " + i + " failed.");
/////////////////////////////////////////////////////////////////////////
1:                 if (error instanceof IOException) {
1:                 }
/////////////////////////////////////////////////////////////////////////
0:             if (!uris.contains(u[i])) {
1:             }
/////////////////////////////////////////////////////////////////////////
0:             if (!uris.contains(uri)) {
1:             }
0:             LOG.error("Failed to parse URI: " + u);
1:         LOG.debug("Waking up reconnect task");
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.CopyOnWriteArrayList;
/////////////////////////////////////////////////////////////////////////
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1: 
0:         return new TransportListener() {
0:             public void onCommand(Object o) {
0:                 Command command = (Command)o;
0:                 if (command == null) {
1:                     return;
1:                 }
0:                 if (command.isResponse()) {
0:                     Object object = requestMap.remove(Integer.valueOf(((Response)command).getCorrelationId()));
0:                     if (object != null && object.getClass() == Tracked.class) {
0:                         ((Tracked)object).onResponses();
1:                 }
0:                 if (!initialized) {
0:                     if (command.isBrokerInfo()) {
0:                         BrokerInfo info = (BrokerInfo)command;
0:                         BrokerInfo[] peers = info.getPeerBrokerInfos();
0:                         if (peers != null) {
0:                             for (int i = 0; i < peers.length; i++) {
0:                                 String brokerString = peers[i].getBrokerURL();
0:                                 add(brokerString);
1:                             }
1:                         }
0:                         initialized = true;
1:                     }
1: 
1:                 }
0:                 if (transportListener != null) {
0:                     transportListener.onCommand(command);
1:                 }
1:             }
1: 
0:             public void onException(IOException error) {
1:                 try {
0:                     handleTransportFailure(error);
1:                 } catch (InterruptedException e) {
1:                     Thread.currentThread().interrupt();
0:                     transportListener.onException(new InterruptedIOException());
1:                 }
1:             }
1: 
0:             public void transportInterupted() {
0:                 if (transportListener != null) {
0:                     transportListener.transportInterupted();
1:                 }
1:             }
1: 
0:             public void transportResumed() {
0:                 if (transportListener != null) {
0:                     transportListener.transportResumed();
1:                 }
1:             }
0:         };
1: 
1:         stateTracker.setTrackTransactions(true);
1: 
1:                 Exception failure = null;
1:                     if (disposed || connectionFailure != null) {
0:                     if (connectedTransport != null || disposed || connectionFailure != null) {
1:                         if (connectList.isEmpty()) {
0:                             if (!useExponentialBackOff) {
0:                                 URI uri = (URI)iter.next();
1: 
1: 
0:                                     if (transportListener != null) {
1:                                 } catch (Exception e) {
1: 
/////////////////////////////////////////////////////////////////////////
1:                 if (!disposed) {
1: 
0:                     log.debug("Waiting " + reconnectDelay + " ms before attempting connection. ");
0:                     synchronized (sleepMutex) {
1:                         try {
0:                             sleepMutex.wait(reconnectDelay);
1:                         } catch (InterruptedException e) {
0:                             Thread.currentThread().interrupt();
1:                     }
1: 
0:                     if (useExponentialBackOff) {
0:                         reconnectDelay *= backOffMultiplier;
0:                         if (reconnectDelay > maxReconnectDelay)
0:                             reconnectDelay = maxReconnectDelay;
1:         }, "ActiveMQ Failover Worker: " + System.identityHashCode(this));
0:         if (transportListener != null) {
/////////////////////////////////////////////////////////////////////////
0:                 connectedTransport = null;
0:         synchronized (sleepMutex) {
/////////////////////////////////////////////////////////////////////////
1:     public boolean isRandomize() {
1:     public void setRandomize(boolean randomize) {
1:         this.randomize = randomize;
0:         Command command = (Command)o;
1:                 for (int i = 0; !disposed; i++) {
0:                         while (connectedTransport == null && !disposed && connectionFailure == null) {
0:                             } catch (InterruptedException e) {
0:                         if (connectedTransport == null) {
1:                             } else if (connectionFailure != null) {
/////////////////////////////////////////////////////////////////////////
1:                         if (tracked != null && tracked.isWaitingForResponse()) {
1:                         } else if (tracked == null && command.isResponseRequired()) {
1: 
1: 
1:                             // If the command was not tracked.. we will retry in
1:                             // this method
0:                             if (tracked == null) {
1: 
1:                                 // since we will retry in this method.. take it
1:                                 // out of the request
1:                                 // map so that it is not sent 2 times on
1:                                 // recovery
0:                                 if (command.isResponseRequired()) {
1:                                     requestMap.remove(Integer.valueOf(command.getCommandId()));
1:                                 }
1: 
1:                                 // Rethrow the exception so it will handled by
1:                                 // the outer catch
1:                             }
1: 
1: 
1:                     } catch (IOException e) {
0:         } catch (InterruptedException e) {
1:         if (!disposed) {
1:             if (error != null) {
0:                 if (error instanceof IOException)
0:                     throw (IOException)error;
/////////////////////////////////////////////////////////////////////////
1: 
1:     public Object request(Object command, int timeout) throws IOException {
0:             if (!uris.contains(u[i]))
/////////////////////////////////////////////////////////////////////////
0:     public void add(String u) {
1:         try {
0:             URI uri = new URI(u);
0:             if (!uris.contains(uri))
0:                 uris.add(uri);
1: 
0:             reconnect();
1:         } catch (Exception e) {
/////////////////////////////////////////////////////////////////////////
0:     private ArrayList getConnectList() {
0:         ArrayList l = new ArrayList(uris);
1:         if (randomize) {
0:             Random r = new Random();
1:             for (int i = 0; i < l.size(); i++) {
0:                 int p = r.nextInt(l.size());
0:                 Object t = l.get(p);
1:                 l.set(p, l.get(i));
1:                 l.set(i, t);
/////////////////////////////////////////////////////////////////////////
0:             Command command = (Command)iter2.next();
/////////////////////////////////////////////////////////////////////////
1:         return connectedTransportURI == null ? "unconnected" : connectedTransportURI.toString();
1:     public String getRemoteAddress() {
0:         if (connectedTransport != null) {
0:             return connectedTransport.getRemoteAddress();
1:         }
1:         return null;
1:     }
1: 
1:     public boolean isFaultTolerant() {
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.CopyOnWriteArrayList;
commit:9ca56a0
/////////////////////////////////////////////////////////////////////////
0: 	        public void onCommand(Object o) {
1:             	Command command = (Command) o;
/////////////////////////////////////////////////////////////////////////
1:     public void oneway(Object o) throws IOException {
0:     	Command command = (Command) o;
/////////////////////////////////////////////////////////////////////////
1:     public FutureResponse asyncRequest(Object command, ResponseCallback responseCallback) throws IOException {
1:     public Object request(Object command) throws IOException {
0:     public Object request(Object command,int timeout) throws IOException {
commit:220ad62
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.state.Tracked;
/////////////////////////////////////////////////////////////////////////
0:                     Object object = requestMap.remove(new Integer(((Response) command).getCorrelationId()));
0:                     if( object!=null && object.getClass() == Tracked.class ) {
0:                 	   ((Tracked)object).onResponses();
1:                     }
/////////////////////////////////////////////////////////////////////////
0:     	stateTracker.setTrackTransactions(true);
1:     	
/////////////////////////////////////////////////////////////////////////
0:                         Tracked tracked = stateTracker.track(command);
0:                         if( tracked!=null && tracked.isWaitingForResponse() ) {
0:                             requestMap.put(new Integer(command.getCommandId()), tracked);
0:                         } else if ( tracked==null && command.isResponseRequired()) {
/////////////////////////////////////////////////////////////////////////
1:                         	
0:                         	// If the command was not tracked.. we will retry in this method
0:                         	if( tracked==null ) {
1:                         		
0:                         		// since we will retry in this method.. take it out of the request
0:                         		// map so that it is not sent 2 times on recovery
0:                             	if( command.isResponseRequired() ) {
0:                             		requestMap.remove(new Integer(command.getCommandId()));
1:                             	}
1:                             	
0:                                 // Rethrow the exception so it will handled by the outer catch
1:                                 throw e;
1:                         	}
1:                         	
commit:295850d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	                requestMap.remove(new Integer(((Response) command).getCorrelationId()));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                         if (!stateTracker.track(command) && command.isResponseRequired()) {
/////////////////////////////////////////////////////////////////////////
0:                             // If there is an IOException in the send, remove the command from the requestMap
0:                             if (!stateTracker.track(command) && command.isResponseRequired()) {
0:                                 requestMap.remove(new Integer(command.getCommandId()), command);
1:                             }
1:                             
0:                             // Rethrow the exception so it will handled by the outer catch
0:                             throw e;
commit:b75a6da
/////////////////////////////////////////////////////////////////////////
0: 	                Thread.currentThread().interrupt();
/////////////////////////////////////////////////////////////////////////
0:                                 Thread.currentThread().interrupt();
/////////////////////////////////////////////////////////////////////////
0:             Thread.currentThread().interrupt();
commit:ac66a09
/////////////////////////////////////////////////////////////////////////
0:     private final TransportListener myTransportListener = createTransportListener();
1:     
0:     TransportListener createTransportListener() {
0:     	return new TransportListener() {
0: 	        public void onCommand(Command command) {
0: 	            if (command == null) {
1: 	                return;
1: 	            }
0: 	            if (command.isResponse()) {
0: 	                requestMap.remove(new Integer(((Response) command).getCorrelationId()));
1: 	            }
0: 	            if (!initialized){
0: 	                if (command.isBrokerInfo()){
0: 	                    BrokerInfo info = (BrokerInfo)command;
0: 	                    BrokerInfo[] peers = info.getPeerBrokerInfos();
0: 	                    if (peers!= null){
0: 	                        for (int i =0; i < peers.length;i++){
0: 	                            String brokerString = peers[i].getBrokerURL();
0: 	                            add(brokerString);
1: 	                        }
1: 	                    }
0: 	                initialized = true;
1: 	                }
1: 	                
1: 	            }
0: 	            if (transportListener != null) {
0: 	                transportListener.onCommand(command);
1: 	            }
1: 	        }
1: 	
0: 	        public void onException(IOException error) {
1: 	            try {
0: 	                handleTransportFailure(error);
1: 	            }
0: 	            catch (InterruptedException e) {
0: 	                transportListener.onException(new InterruptedIOException());
1: 	            }
1: 	        }
1: 	        
0: 	        public void transportInterupted(){
0: 	            if (transportListener != null){
0: 	                transportListener.transportInterupted();
1: 	            }
1: 	        }
1: 	
0: 	        public void transportResumed(){
0: 	            if(transportListener != null){
0: 	                transportListener.transportResumed();
1: 	            }
1: 	        }
0: 	    };
1:     }
1:     
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:1ea430e
/////////////////////////////////////////////////////////////////////////
1:                     
0:                         log.debug("Waiting "+reconnectDelay+" ms before attempting connection. ");
/////////////////////////////////////////////////////////////////////////
0:                             log.trace("Waiting for transport to reconnect.");
commit:c2a5111
/////////////////////////////////////////////////////////////////////////
0:                         if( log.isTraceEnabled() )
0:                             log.trace("Waiting "+reconnectDelay+" ms before attempting connection. ");
commit:14fda24
/////////////////////////////////////////////////////////////////////////
1:             reconnectTask.wakeup();
commit:e2aad41
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:         }, "ActiveMQ Failover Worker: "+System.identityHashCode(this));
/////////////////////////////////////////////////////////////////////////
0:         reconnectTask.shutdown();
commit:84fd773
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.ResponseCallback;
/////////////////////////////////////////////////////////////////////////
0:     public FutureResponse asyncRequest(Command command, ResponseCallback responseCallback) throws IOException {
commit:ead505d
/////////////////////////////////////////////////////////////////////////
0:                 connectedTransport=null;
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport.failover;
1: 
0: import java.io.IOException;
0: import java.io.InterruptedIOException;
0: import java.net.URI;
0: import java.util.ArrayList;
0: import java.util.Iterator;
0: import java.util.Random;
1: 
1: import org.apache.activemq.command.Command;
1: import org.apache.activemq.command.Response;
1: import org.apache.activemq.state.ConnectionStateTracker;
0: import org.apache.activemq.thread.DefaultThreadPools;
1: import org.apache.activemq.thread.Task;
1: import org.apache.activemq.thread.TaskRunner;
1: import org.apache.activemq.transport.CompositeTransport;
1: import org.apache.activemq.transport.FutureResponse;
1: import org.apache.activemq.transport.Transport;
1: import org.apache.activemq.transport.TransportFactory;
1: import org.apache.activemq.transport.TransportListener;
1: import org.apache.activemq.util.IOExceptionSupport;
1: import org.apache.activemq.util.ServiceSupport;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArrayList;
1: 
1: /**
1:  * A Transport that is made reliable by being able to fail over to another
1:  * transport when a transport failure is detected.
1:  * 
0:  * @version $Revision$
1:  */
1: public class FailoverTransport implements CompositeTransport {
1: 
0:     private static final Log log = LogFactory.getLog(FailoverTransport.class);
1: 
1:     private TransportListener transportListener;
0:     private boolean disposed;
0:     private final CopyOnWriteArrayList uris = new CopyOnWriteArrayList();
1: 
1:     private final Object reconnectMutex = new Object();
1:     private final ConnectionStateTracker stateTracker = new ConnectionStateTracker();
0:     private final ConcurrentHashMap requestMap = new ConcurrentHashMap();
1: 
1:     private URI connectedTransportURI;
0:     private Transport connectedTransport;
1:     private final TaskRunner reconnectTask;
0:     private boolean started;
1: 
0:     private long initialReconnectDelay = 10;
1:     private long maxReconnectDelay = 1000 * 30;
0:     private long backOffMultiplier = 2;
1:     private boolean useExponentialBackOff = true;
0:     private int maxReconnectAttempts;
1:     private int connectFailures;
0:     private long reconnectDelay = initialReconnectDelay;
1:     private Exception connectionFailure;
1: 
0:     private final TransportListener myTransportListener = new TransportListener() {
0:         public void onCommand(Command command) {
0:             if (command.isResponse()) {
0:                 requestMap.remove(new Short(((Response) command).getCorrelationId()));
1:             }
0:             transportListener.onCommand(command);
1:         }
1: 
0:         public void onException(IOException error) {
1:             try {
0:                 handleTransportFailure(error);
1:             }
0:             catch (InterruptedException e) {
0:                 transportListener.onException(new InterruptedIOException());
1:             }
1:         }
0:     };
1: 
0:     public FailoverTransport() throws InterruptedIOException {
1: 
1:         // Setup a task that is used to reconnect the a connection async.
0:         reconnectTask = DefaultThreadPools.getDefaultTaskRunnerFactory().createTaskRunner(new Task() {
1: 
1:             public boolean iterate() {
1: 
0:                 Exception failure=null;
1:                 synchronized (reconnectMutex) {
1: 
0:                     if (disposed || connectionFailure!=null) {
1:                         reconnectMutex.notifyAll();
1:                     }
1: 
0:                     if (connectedTransport != null || disposed || connectionFailure!=null) {
1:                         return false;
1:                     } else {
0:                         ArrayList connectList = getConnectList();
0:                         if( connectList.isEmpty() ) {
1:                             failure = new IOException("No uris available to connect to.");
1:                         } else {
1:                             reconnectDelay = initialReconnectDelay;
0:                             Iterator iter = connectList.iterator();
0:                             for (int i = 0; iter.hasNext() && connectedTransport == null && !disposed; i++) {
0:                                 URI uri = (URI) iter.next();
1:                                 try {
0:                                     log.debug("Attempting connect to: " + uri);
1:                                     Transport t = TransportFactory.compositeConnect(uri);
0:                                     t.setTransportListener(myTransportListener);
1:                                     if (started) {
0:                                         restoreTransport(t);
1:                                     }
0:                                     log.debug("Connection established");
1:                                     reconnectDelay = initialReconnectDelay;
1:                                     connectedTransportURI = uri;
0:                                     connectedTransport = t;
1:                                     reconnectMutex.notifyAll();
1:                                     connectFailures = 0;
1:                                     return false;
1:                                 }
0:                                 catch (Exception e) {
1:                                     failure = e;
0:                                     log.debug("Connect fail to: " + uri + ", reason: " + e);
1:                                 }
1:                             }
1:                         }
1:                     }
1:                     
0:                     if (maxReconnectAttempts > 0 && ++connectFailures >= maxReconnectAttempts) {
0:                         log.error("Failed to connect to transport after: " + connectFailures + " attempt(s)");
1:                         connectionFailure = failure;
1:                         reconnectMutex.notifyAll();
1:                         return false;
1:                     }
1:                 }
1: 
1:                 
1:                 try {
0:                     log.debug("Waiting " + reconnectDelay + " ms before attempting connection. ");
0:                     Thread.sleep(reconnectDelay);
1:                 }
0:                 catch (InterruptedException e1) {
0:                     Thread.currentThread().interrupt();
1:                 }
1: 
0:                 if (useExponentialBackOff) {
0:                     // Exponential increment of reconnect delay.
0:                     reconnectDelay *= backOffMultiplier;
0:                     if (reconnectDelay > maxReconnectDelay)
0:                         reconnectDelay = maxReconnectDelay;
1:                 }
0:                 return true;
1:             }
1: 
0:         });
1:     }
1: 
0:     private void handleTransportFailure(IOException e) throws InterruptedException {
1:         synchronized (reconnectMutex) {
0:             log.debug("Transport failed, starting up reconnect task", e);
0:             if (connectedTransport != null) {
0:                 ServiceSupport.dispose(connectedTransport);
0:                 connectedTransport = null;
1:                 connectedTransportURI = null;
1:                 reconnectTask.wakeup();
1:             }
1:         }
1:     }
1: 
1:     public void start() throws Exception {
1:         synchronized (reconnectMutex) {
0:             log.debug("Started.");
0:             if (started)
0:                 return;
1:             started = true;
0:             if (connectedTransport != null) {
0:                 connectedTransport.start();
0:                 stateTracker.restore(connectedTransport);
1:             }
1:         }
1:     }
1: 
1:     public void stop() throws Exception {
1:         synchronized (reconnectMutex) {
0:             log.debug("Stopped.");
0:             if (!started)
0:                 return;
0:             started = false;
0:             disposed = true;
1: 
0:             if (connectedTransport != null) {
0:                 connectedTransport.stop();
1:             }
1:         }
1:     }
1: 
1:     public long getInitialReconnectDelay() {
1:         return initialReconnectDelay;
1:     }
1: 
1:     public void setInitialReconnectDelay(long initialReconnectDelay) {
1:         this.initialReconnectDelay = initialReconnectDelay;
1:     }
1: 
1:     public long getMaxReconnectDelay() {
1:         return maxReconnectDelay;
1:     }
1: 
1:     public void setMaxReconnectDelay(long maxReconnectDelay) {
1:         this.maxReconnectDelay = maxReconnectDelay;
1:     }
1: 
1:     public long getReconnectDelay() {
1:         return reconnectDelay;
1:     }
1: 
1:     public void setReconnectDelay(long reconnectDelay) {
1:         this.reconnectDelay = reconnectDelay;
1:     }
1: 
0:     public long getReconnectDelayExponent() {
1:         return backOffMultiplier;
1:     }
1: 
0:     public void setReconnectDelayExponent(long reconnectDelayExponent) {
1:         this.backOffMultiplier = reconnectDelayExponent;
1:     }
1: 
1:     public Transport getConnectedTransport() {
0:         return connectedTransport;
1:     }
1: 
1:     public URI getConnectedTransportURI() {
1:         return connectedTransportURI;
1:     }
1: 
1:     public int getMaxReconnectAttempts() {
1:         return maxReconnectAttempts;
1:     }
1: 
1:     public void setMaxReconnectAttempts(int maxReconnectAttempts) {
1:         this.maxReconnectAttempts = maxReconnectAttempts;
1:     }
1: 
0:     public void oneway(Command command) throws IOException {
1:         Exception error = null;
1:         try {
1: 
1:             synchronized (reconnectMutex) {
1:                 // Keep trying until the message is sent.
0:                 for (int i = 0;; i++) {
1:                     try {
1: 
1:                         // Wait for transport to be connected.
0:                         while (connectedTransport == null && !disposed && connectionFailure==null ) {
0:                             log.debug("Waiting for transport to reconnect.");
0:                             reconnectMutex.wait(1000);
1:                         }
1: 
0:                         if( connectedTransport==null ) {
1:                             // Previous loop may have exited due to use being
1:                             // disposed.
1:                             if (disposed) {
1:                                 error = new IOException("Transport disposed.");
0:                             } else if (connectionFailure!=null) {
1:                                 error = connectionFailure;
1:                             } else {
1:                                 error = new IOException("Unexpected failure.");
1:                             }
0:                             break;
1:                         }
1:                         
1:                         // Send the message.
0:                         connectedTransport.oneway(command);
1: 
1:                         // If it was a request and it was not being tracked by
1:                         // the state tracker,
1:                         // then hold it in the requestMap so that we can replay
1:                         // it later.
0:                         if (!stateTracker.track(command) && command.isResponseRequired()) {
0:                             requestMap.put(new Short(command.getCommandId()), command);
1:                         }
0:                         return;
1: 
1:                     }
0:                     catch (IOException e) {
0:                         log.debug("Send oneway attempt: " + i + " failed.");
1:                         handleTransportFailure(e);
1:                     }
1:                 }
1:             }
1:         }
0:         catch (InterruptedException e) {
1:             // Some one may be trying to stop our thread.
1:             throw new InterruptedIOException();
1:         }
0:         if( error instanceof IOException )
0:             throw (IOException)error;
1:         throw IOExceptionSupport.create(error);
1:     }
1: 
0:     public FutureResponse asyncRequest(Command command) throws IOException {
1:         throw new AssertionError("Unsupported Method");
1:     }
1: 
0:     public Response request(Command command) throws IOException {
1:         throw new AssertionError("Unsupported Method");
1:     }
1: 
0:     public void add(URI u[]) {
0:         for (int i = 0; i < u.length; i++) {
0:             if( !uris.contains(u[i]) )
0:                 uris.add(u[i]);
1:         }
0:         reconnect();
1:     }
1: 
0:     public void remove(URI u[]) {
0:         for (int i = 0; i < u.length; i++) {
0:             uris.remove(u[i]);
1:         }
0:         reconnect();
1:     }
1: 
0:     public void reconnect() {
0:         log.debug("Waking up reconnect task");
1:         try {
1:             reconnectTask.wakeup();
0:         } catch (InterruptedException e) {
0:             Thread.currentThread().interrupt();
1:         }
1:     }
1: 
0:     private ArrayList getConnectList() {
0:         ArrayList l = new ArrayList(uris);
1: 
1:         // Randomly, reorder the list by random swapping
0:         Random r = new Random();
0:         r.setSeed(System.currentTimeMillis());
0:         for (int i = 0; i < l.size(); i++) {
0:             int p = r.nextInt(l.size());
0:             Object t = l.get(p);
0:             l.set(p, l.get(i));
0:             l.set(i, t);
1:         }
1:         return l;
1:     }
1: 
1:     public void setTransportListener(TransportListener commandListener) {
1:         this.transportListener = commandListener;
1:     }
1: 
0:     public Object narrow(Class target) {
1: 
1:         if (target.isAssignableFrom(getClass())) {
0:             return this;
1:         }
1:         synchronized (reconnectMutex) {
0:             if (connectedTransport != null) {
0:                 return connectedTransport.narrow(target);
1:             }
1:         }
1:         return null;
1: 
1:     }
1: 
1:     protected void restoreTransport(Transport t) throws Exception, IOException {
1:         t.start();
1:         stateTracker.restore(t);
0:         for (Iterator iter2 = requestMap.values().iterator(); iter2.hasNext();) {
0:             Command command = (Command) iter2.next();
1:             t.oneway(command);
1:         }
1:     }
1: 
1:     public boolean isUseExponentialBackOff() {
1:         return useExponentialBackOff;
1:     }
1: 
1:     public void setUseExponentialBackOff(boolean useExponentialBackOff) {
1:         this.useExponentialBackOff = useExponentialBackOff;
1:     }
1: 
1:     public String toString() {
0:         return connectedTransportURI==null ? "unconnected" : connectedTransportURI.toString();
1:     }
1: 
1: }
author:Robert Davies
-------------------------------------------------------------------------------
commit:c14c7e7
/////////////////////////////////////////////////////////////////////////
0: import java.io.BufferedReader;
0: import java.io.FileNotFoundException;
0: import java.io.FileReader;
0: import java.io.InputStreamReader;
0: import java.net.MalformedURLException;
0: import java.net.URL;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private String updateURIsURL = null;
0:     private boolean rebalanceUpdateURIs=true;
/////////////////////////////////////////////////////////////////////////
1:         processNewTransports(control.isRebalanceConnection(), control.getConnectedBrokers());
0:     }
0: 
1:     private final void processNewTransports(boolean rebalance, String newTransports) {
1:         if (newTransports != null) {
1:             newTransports = newTransports.trim();
1:             if (newTransports.length() > 0 && isUpdateURIsSupported()) {
1:                 StringTokenizer tokenizer = new StringTokenizer(newTransports, ",");
/////////////////////////////////////////////////////////////////////////
1:                         updateURIs(rebalance, list.toArray(new URI[list.size()]));
1:                         LOG.error("Failed to update transport URI's from: " + newTransports, e);
/////////////////////////////////////////////////////////////////////////
0:             // If updateURIsURL is specified, read the file and add any new
0:             // transport URI's to this FailOverTransport. 
0:             // Note: Could track file timestamp to avoid unnecessary reading.
0:             String fileURL = getUpdateURIsURL();
0:             if (fileURL != null) {
0:                 BufferedReader in = null;
0:                 String newUris = null;
0:                 StringBuffer buffer = new StringBuffer();
0: 
1:                 try {
0:                     in = new BufferedReader(getURLStream(fileURL));
0:                     while (true) {
0:                         String line = in.readLine();
0:                         if (line == null) {
0:                             break;
0:                         }
0:                         buffer.append(line);
0:                     }
0:                     newUris = buffer.toString();
0:                 } catch (IOException ioe) {
0:                     LOG.error("Failed to read updateURIsURL: " + fileURL, ioe);
0:                 } finally {
0:                     if (in != null) {
1:                         try {
0:                             in.close();
0:                         } catch (IOException ioe) {
0:                             // ignore
0:                         }
0:                     }
0:                 }
0:                 
0:                 processNewTransports(isRebalanceUpdateURIs(), newUris);
0:             }
0: 
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
1:      * @return the updateURIsURL
1:      */
1:     public String getUpdateURIsURL() {
1:         return this.updateURIsURL;
0:     }
0: 
1:     /**
1:      * @param updateURIsURL the updateURIsURL to set
1:      */
1:     public void setUpdateURIsURL(String updateURIsURL) {
1:         this.updateURIsURL = updateURIsURL;
0:     }
0:     
1:     /**
1:      * @return the rebalanceUpdateURIs
1:      */
1:     public boolean isRebalanceUpdateURIs() {
1:         return this.rebalanceUpdateURIs;
0:     }
0: 
1:     /**
1:      * @param rebalanceUpdateURIs the rebalanceUpdateURIs to set
1:      */
1:     public void setRebalanceUpdateURIs(boolean rebalanceUpdateURIs) {
1:         this.rebalanceUpdateURIs = rebalanceUpdateURIs;
0:     }
/////////////////////////////////////////////////////////////////////////
0:     
1:     private InputStreamReader getURLStream(String path) throws IOException {
1:         InputStreamReader result = null;
1:         URL url = null;
0:         try {
1:             url = new URL(path);
1:             result = new InputStreamReader(url.openStream());
1:         } catch (MalformedURLException e) {
1:             // ignore - it could be a path to a a local file
0:         }
1:         if (result == null) {
1:             result = new FileReader(path);
0:         }
1:         return result;
0:     }
commit:a1c427e
/////////////////////////////////////////////////////////////////////////
0:     //private boolean connectionInterruptProcessingComplete;
0:     private boolean updateURIsSupported=true;
0:     private boolean reconnectSupported=true;
/////////////////////////////////////////////////////////////////////////
1:         return this.reconnectSupported;
0:     
1:     public void setReconnectSupported(boolean value) {
0:         this.reconnectSupported=value;
0:     }
0:    
1:         return this.updateURIsSupported;
0:     }
0:     
1:     public void setUpdateURIsSupported(boolean value) {
0:         this.updateURIsSupported=value;
1:         if (isUpdateURIsSupported()) {
0:             List<URI> copy = new ArrayList<URI>(this.updated);
0:             List<URI> add = new ArrayList<URI>();
0:             if (updatedURIs != null && updatedURIs.length > 0) {
0:                 Set<URI> set = new HashSet<URI>();
0:                 for (int i = 0; i < updatedURIs.length; i++) {
0:                     URI uri = updatedURIs[i];
0:                     if (uri != null) {
0:                         set.add(uri);
0:                     }
0:                 for (URI uri : set) {
0:                     if (copy.remove(uri) == false) {
0:                         add.add(uri);
0:                     }
0:                 synchronized (reconnectMutex) {
0:                     this.updated.clear();
0:                     this.updated.addAll(add);
0:                     for (URI uri : copy) {
0:                         this.uris.remove(uri);
0:                     }
0:                     add(rebalance, add.toArray(new URI[add.size()]));
commit:f392884
/////////////////////////////////////////////////////////////////////////
0: import java.net.InetAddress;
0: import java.util.HashSet;
0: import java.util.Set;
0: import java.util.StringTokenizer;
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1:     private final CopyOnWriteArrayList<URI> updated = new CopyOnWriteArrayList<URI>();
/////////////////////////////////////////////////////////////////////////
0:     private boolean initialized;
1:     // optionally always have a backup created
1:     private boolean backup = false;
1:     private final List<BackupTransport> backups = new CopyOnWriteArrayList<BackupTransport>();
1:     private int backupPoolSize = 1;
0:     private final TransportListener disposedListener = new DefaultTransportListener() {
0:     };
/////////////////////////////////////////////////////////////////////////
1:                 boolean result = false;
1:                 boolean buildBackup = true;
0:                 boolean doReconnect = !disposed;
1:                 synchronized (backupMutex) {
0:                     if (connectedTransport.get() == null && !disposed) {
1:                         result = doReconnect();
1:                         buildBackup = false;
0:                     }
0:                 }
1:                 if (buildBackup) {
0:                     buildBackups();
1:                 } else {
1:                     // build backups on the next iteration
0:                     result = true;
0:                     try {
0:                 }
1:                 return result;
/////////////////////////////////////////////////////////////////////////
0:                 Command command = (Command) o;
1:                     synchronized (requestMap) {
0:                         object = requestMap.remove(Integer.valueOf(((Response) command).getCorrelationId()));
0:                         ((Tracked) object).onResponses();
0:                 if (!initialized) {      
0:                     initialized = true;
0:                 }
0:                 
0:                 if(command.isConnectionControl()) {
0:                     handleConnectionControl((ConnectionControl) command);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 transport = connectedTransport.getAndSet(null);
0: 
0: 
0:                 if (started) {
0:                     LOG.warn("Transport (" + transport.getRemoteAddress() + ") failed to " + connectedTransportURI
0:                             + " , attempting to automatically reconnect due to: " + e);
0:                 }
1:                 failedConnectTransportURI = connectedTransportURI;
0:                 connected = false;
0:                 // notify before any reconnect attempt so ack state can be
0:                 // whacked
0: 
0:     }
1:     public final void handleConnectionControl(ConnectionControl control) {
1:         String reconnectStr = control.getReconnectTo();
1:         if (reconnectStr != null) {
1:             reconnectStr = reconnectStr.trim();
1:             if (reconnectStr.length() > 0) {
0:                 try {
1:                     URI uri = new URI(reconnectStr);
1:                     if (isReconnectSupported()) {
1:                         reconnect(uri);
1:                         LOG.info("Reconnected to: " + uri);
0:                     }
1:                 } catch (Exception e) {
1:                     LOG.error("Failed to handle ConnectionControl reconnect to " + reconnectStr, e);
0:                 }
0:             }
0:         }
0:         String connectedStr = control.getConnectedBrokers();
0:         if (connectedStr != null) {
0:             connectedStr = connectedStr.trim();
0:             if (connectedStr.length() > 0 && isUpdateURIsSupported()) {
1:                 List<URI> list = new ArrayList<URI>();
0:                 StringTokenizer tokenizer = new StringTokenizer(connectedStr, ",");
1:                 while (tokenizer.hasMoreTokens()) {
1:                     String str = tokenizer.nextToken();
0:                     try {
1:                         URI uri = new URI(str);
1:                         list.add(uri);
1:                     } catch (Exception e) {
1:                         LOG.error("Failed to parse broker address: " + str, e);
0:                     }
0:                 }
1:                 if (list.isEmpty() == false) {
0:                     try {
0:                         updateURIs(control.isRebalanceConnection(), list.toArray(new URI[list.size()]));
1:                     } catch (IOException e) {
0:                         LOG.error("Failed to update transport URI's from: " + connectedStr, e);
0:                     }
0:                 }
0: 
0:             }
0:         }
/////////////////////////////////////////////////////////////////////////
1:                 reconnect(false);
1:         Transport transportToStop = null;
/////////////////////////////////////////////////////////////////////////
0:             for (BackupTransport t : backups) {
/////////////////////////////////////////////////////////////////////////
0:         if (transportToStop != null) {
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:         return timeout;
0:     }
0:     public void setTimeout(long timeout) {
0:         this.timeout = timeout;
0:     }
0:     /**
/////////////////////////////////////////////////////////////////////////
0:      * @param randomize
0:      *            The randomize to set.
0: 
1:         return backup;
0:     }
1:     public void setBackup(boolean backup) {
1:         this.backup = backup;
0:     }
1:     public int getBackupPoolSize() {
1:         return backupPoolSize;
0:     }
1:     public void setBackupPoolSize(int backupPoolSize) {
1:         this.backupPoolSize = backupPoolSize;
0:     }
0: 
1:     public boolean isTrackMessages() {
/////////////////////////////////////////////////////////////////////////
0: 
0:      * @return Returns true if the command is one sent when a connection is
0:      *         being closed.
0:         return (command != null && (command.isShutdownInfo() || command instanceof RemoveInfo));
0: 
0:         Command command = (Command) o;
0: 
1:                     if (command.isShutdownInfo()) {
0:                         // Skipping send of ShutdownInfo command when not
0:                         // connected.
0:                     if (command instanceof RemoveInfo || command.isMessageAck()) {
0:                         // Simulate response to RemoveInfo command or ack (as it
0:                         // will be stale)
/////////////////////////////////////////////////////////////////////////
1:                         while (transport == null && !disposed && connectionFailure == null
0:                                 timedout = true;
0:                                 LOG.info("Failover timed out after " + (end - start) + "ms");
0:                                 break;
/////////////////////////////////////////////////////////////////////////
0:                                 error = new IOException("Failover timeout of " + timeout + " ms reached.");
0:                             } else {
/////////////////////////////////////////////////////////////////////////
1:                         synchronized (requestMap) {
/////////////////////////////////////////////////////////////////////////
1:                     throw (IOException) error;
/////////////////////////////////////////////////////////////////////////
1:     public void add(boolean rebalance, URI u[]) {
1:         boolean newURI = false;
0:             if (contains(u[i])==false) {
0:                 uris.add(i, u[i]);
1:                 newURI = true;
1:         if (newURI) {
1:             reconnect(rebalance);
0:         }
1:     public void remove(boolean rebalance, URI u[]) {
1:         reconnect(rebalance);
1:     public void add(boolean rebalance, String u) {
1:             URI newURI = new URI(u);
0:             if (contains(newURI)==false) {
1:                 uris.add(newURI);
1:                 reconnect(rebalance);
0:        
1:     public void reconnect(boolean rebalance) {
1:                 if (rebalance) {
0:                     Transport transport = this.connectedTransport.getAndSet(null);
0:                     if (transport != null) {
0:                         try {
0:                             transport.stop();
1:                         } catch (Exception e) {
0:                             LOG.debug("Caught an exception stopping existing transport", e);
0:                         }
0:                     }
0: 
0:                 }
/////////////////////////////////////////////////////////////////////////
0:                 int p = (int) (Math.random() * 100 % l.size());
/////////////////////////////////////////////////////////////////////////
1:         synchronized (listenerMutex) {
/////////////////////////////////////////////////////////////////////////
0:         if (transport != null) {
/////////////////////////////////////////////////////////////////////////
1:         // send information to the broker - informing it we are an ft client
0:         synchronized (requestMap) {
/////////////////////////////////////////////////////////////////////////
1:     @Override
0:         if (transport != null) {
/////////////////////////////////////////////////////////////////////////
0: 
1:     final boolean doReconnect() {
/////////////////////////////////////////////////////////////////////////
1:                     synchronized (backupMutex) {
0:                             BackupTransport bt = backups.remove(0);
0:                                 if (started) {
0:                                     restoreTransport(t);
0:                                 failedConnectTransportURI = null;
0:                             } catch (Exception e) {
0:                                 LOG.debug("Backup transport failed", e);
0:                             }
0: 
0:                     while (iter.hasNext() && connectedTransport.get() == null && !disposed) {
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:                             // Make sure on initial startup, that the
0:                             // transportListener
1:                             // has been initialized for this instance.
1:                             synchronized (listenerMutex) {
1:                                 if (transportListener == null) {
0:                                         // if it isn't set after 2secs - it
0:                                         // probably never will be
1:                                     } catch (InterruptedException ex) {
0:                                     }
0:                             } else {
1:                                 firstConnection = false;
0:                             } else {
0:                             connected = true;
0:                             if (t != null) {
0:                                     t.stop();
/////////////////////////////////////////////////////////////////////////
0:             if (reconnectAttempts == 0) {
0:             }
0: 
0:                 // Make sure on initial startup, that the transportListener has
0:                 // been initialized
1:                 synchronized (listenerMutex) {
1:                     if (transportListener == null) {
1:                         } catch (InterruptedException ex) {
0:                         }
0:                 if (transportListener != null) {
0:                         transportListener.onException((IOException) connectionFailure);
0:                         transportListener.onException(IOExceptionSupport.create(connectionFailure));
0:                 }
/////////////////////////////////////////////////////////////////////////
1:     final boolean buildBackups() {
1:         synchronized (backupMutex) {
0:             if (!disposed && backup && backups.size() < backupPoolSize) {
1:                 List<URI> connectList = getConnectList();
1:                 // removed disposed backups
1:                 List<BackupTransport> disposedList = new ArrayList<BackupTransport>();
1:                 for (BackupTransport bt : backups) {
1:                     if (bt.isDisposed()) {
1:                         disposedList.add(bt);
0:                     }
0:                 }
1:                 backups.removeAll(disposedList);
1:                 disposedList.clear();
0:                 for (Iterator<URI> iter = connectList.iterator(); iter.hasNext() && backups.size() < backupPoolSize;) {
0:                     URI uri = iter.next();
1:                     if (connectedTransportURI != null && !connectedTransportURI.equals(uri)) {
0:                         try {
1:                             BackupTransport bt = new BackupTransport(this);
1:                             bt.setUri(uri);
1:                             if (!backups.contains(bt)) {
0:                                 Transport t = TransportFactory.compositeConnect(uri);
1:                                 t.setTransportListener(bt);
1:                                 t.start();
1:                                 bt.setTransport(t);
0:                                 backups.add(bt);
0:                             }
0:                         } catch (Exception e) {
1:                             LOG.debug("Failed to build backup ", e);
0:                         }
0:                     }
0:                 }
0:             }
0:         }
0:         return false;
0:     }
1:         return disposed;
0: 
0: 
0:         add(true, new URI[] { uri });
0:     }
0: 
1:     public boolean isReconnectSupported() {
0:         return true;
0:     }
0: 
1:     public boolean isUpdateURIsSupported() {
0:         return true;
0:     }
0: 
1:     public void updateURIs(boolean rebalance, URI[] updatedURIs) throws IOException {
0:         List<URI> copy = new ArrayList<URI>(this.updated);
0:         List<URI> add = new ArrayList<URI>();
0:         if (updatedURIs != null && updatedURIs.length > 0) {
0:             Set<URI> set = new HashSet<URI>();
0:             for (int i = 0; i < updatedURIs.length; i++) {
0:                 URI uri = updatedURIs[i];
0:                 if (uri != null) {
0:                     set.add(uri);
0:                 }
0:             }
0:             for (URI uri : set) {
0:                 if (copy.remove(uri) == false) {
0:                     add.add(uri);
0:                 }
0:             }
0:             synchronized (reconnectMutex) {
0:                 this.updated.clear();
0:                 this.updated.addAll(add);
0:                 for (URI uri : copy) {
0:                     this.uris.remove(uri);
0:                 }
0:                 add(rebalance, add.toArray(new URI[add.size()]));
0:             }
0:         }
0:         if (transport == null) {
/////////////////////////////////////////////////////////////////////////
0:     
1:     private boolean contains(URI newURI) {
0:        
1:         boolean result = false;
0:         try {
0:         for (URI uri:uris) {
0:             if (newURI.getPort()==uri.getPort()) {
0:                 InetAddress newAddr = InetAddress.getByName(newURI.getHost());
0:                 InetAddress addr = InetAddress.getByName(uri.getHost());
0:                 if (addr.equals(newAddr)) {
0:                     result = true;
0:                     break;
0:                 }
0:             }
0:         }
0:         }catch(IOException e) {
0:             result = true;
0:             LOG.error("Failed to verify URI " + newURI + " already known: " + e);
0:         }
1:         return result;
0:     }
commit:31ecfae
/////////////////////////////////////////////////////////////////////////
0:             int reconnectAttempts = 0;
1:             if (firstConnection) {
0:                 if (this.startupMaxReconnectAttempts != 0) {
0:                     reconnectAttempts = this.startupMaxReconnectAttempts;
0:                 }
0:             }
0:             if (reconnectAttempts==0) {
0:                 reconnectAttempts = this.maxReconnectAttempts;
0:             }            
commit:3720e84
/////////////////////////////////////////////////////////////////////////
0:     private int startupMaxReconnectAttempts;
/////////////////////////////////////////////////////////////////////////
0:     
1:     public int getStartupMaxReconnectAttempts() {
1:         return this.startupMaxReconnectAttempts;
0:     }
0: 
1:     public void setStartupMaxReconnectAttempts(int startupMaxReconnectAttempts) {
1:         this.startupMaxReconnectAttempts = startupMaxReconnectAttempts;
0:     }
/////////////////////////////////////////////////////////////////////////
0:             long reconnectAttempts = firstConnection ? this.startupMaxReconnectAttempts : this.maxReconnectAttempts;
0:             if (reconnectAttempts > 0 && ++connectFailures >= reconnectAttempts) {
commit:f3b1ea9
/////////////////////////////////////////////////////////////////////////
1:     private double backOffMultiplier = 2d;
/////////////////////////////////////////////////////////////////////////
1:     public double getReconnectDelayExponent() {
1:     public void setReconnectDelayExponent(double reconnectDelayExponent) {
commit:4228281
/////////////////////////////////////////////////////////////////////////
commit:4a052d2
/////////////////////////////////////////////////////////////////////////
0:         synchronized (reconnectMutex) {
0:             if (started) {
0:                 LOG.debug("Waking up reconnect task");
0:                 try {
0:                     reconnectTask.wakeup();
0:                 } catch (InterruptedException e) {
0:                     Thread.currentThread().interrupt();
0:                 }
0:             } else {
1:                 LOG.debug("Reconnect was triggered but transport is not started yet. Wait for start to connect the transport.");
0:             }
commit:60d4d48
/////////////////////////////////////////////////////////////////////////
1:                                         listenerMutex.wait(2000);
/////////////////////////////////////////////////////////////////////////
0:                 synchronized(listenerMutex) {
0:                     if (transportListener==null) {
0:                         try {
1:                             listenerMutex.wait(2000);
0:                         }catch(InterruptedException ex) {}
commit:f7fa2bc
/////////////////////////////////////////////////////////////////////////
1:     private final Object listenerMutex = new Object();
/////////////////////////////////////////////////////////////////////////
0:         synchronized(listenerMutex) {
0:             this.transportListener = commandListener;
1:             listenerMutex.notifyAll();
0:         }
/////////////////////////////////////////////////////////////////////////
0:                          // Make sure on initial startup, that the transportListener 
0:                          // has been initialized for this instance.
0:                             synchronized(listenerMutex) {
0:                                 if (transportListener==null) {
0:                                     try {
0:                                         //if it isn't set after 2secs - it
0:                                         //probably never will be
0:                                     listenerMutex.wait(2000);
0:                                     }catch(InterruptedException ex) {}
0:                                 }
0:                             }
0:                             }else {
0:                                 LOG.debug("transport resumed by transport listener not set");
commit:6b6cdae
/////////////////////////////////////////////////////////////////////////
0: import java.util.LinkedHashMap;
0: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1:     private final Map<Integer, Command> requestMap = new LinkedHashMap<Integer, Command>();
/////////////////////////////////////////////////////////////////////////
0:                     Object object = null;
0:                     synchronized(requestMap) {
0:                      object = requestMap.remove(Integer.valueOf(((Response)command).getCorrelationId()));
0:                     }
/////////////////////////////////////////////////////////////////////////
0:                         synchronized(requestMap) {
0:                             if (tracked != null && tracked.isWaitingForResponse()) {
1:                                 requestMap.put(Integer.valueOf(command.getCommandId()), tracked);
0:                             } else if (tracked == null && command.isResponseRequired()) {
1:                                 requestMap.put(Integer.valueOf(command.getCommandId()), command);
0:                             }
/////////////////////////////////////////////////////////////////////////
0:         Map tmpMap = null;
0:         synchronized(requestMap) {
1:             tmpMap = new LinkedHashMap<Integer, Command>(requestMap);
0:         }
0:         for (Iterator<Command> iter2 = tmpMap.values().iterator(); iter2.hasNext();) {
commit:cec77fd
/////////////////////////////////////////////////////////////////////////
0:                     LOG.warn("Transport failed to " + connectedTransportURI+ " , attempting to automatically reconnect due to: " + e);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                         while (transport == null && !disposed
0:                                 && connectionFailure == null
0:                                 && !Thread.currentThread().isInterrupted()) {
commit:f559236
/////////////////////////////////////////////////////////////////////////
0:             	boolean doReconnect = !disposed;
0:             	synchronized(backupMutex) {
0:                 	if (connectedTransport.get()==null && !disposed) {
0:                 		result=doReconnect();
0:                 		buildBackup=false;
0:                 	}
/////////////////////////////////////////////////////////////////////////
0:             for (BackupTransport t:backups) {
0:                 t.setDisposed(true);
0:             }
0:             backups.clear();
commit:3957eb0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:70511a6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.DefaultTransportListener;
/////////////////////////////////////////////////////////////////////////
0:     private TransportListener disposedListener = new DefaultTransportListener();
/////////////////////////////////////////////////////////////////////////
0:                 Transport old = connectedTransport.get();
0:                 if(old != null) {
0:                     //don't want errors from old transport
0:                     old.setTransportListener(disposedListener);
0:                 }
commit:cb65470
/////////////////////////////////////////////////////////////////////////
1:     private final Object backupMutex = new Object();
/////////////////////////////////////////////////////////////////////////
0:                     synchronized(backupMutex) {
0:                         if (backup && !backups.isEmpty()) {
0:                         	BackupTransport bt = backups.remove(0);
0:                             Transport t = bt.getTransport();
0:                             URI uri = bt.getUri();
0:                             t.setTransportListener(myTransportListener);
0:                             try {
0:                                 if (started) { 
0:                                         restoreTransport(t);  
0:                                 }
0:                                 reconnectDelay = initialReconnectDelay;
0:                                 failedConnectTransportURI=null;
0:                                 connectedTransportURI = uri;
0:                                 connectedTransport.set(t);
0:                                 reconnectMutex.notifyAll();
0:                                 connectFailures = 0;
0:                                 LOG.info("Successfully reconnected to backup " + uri);
0:                                 return false;
0:                             }catch (Exception e) {
0:                                 LOG.debug("Backup transport failed",e);
0:                              }
0:                         }
/////////////////////////////////////////////////////////////////////////
0: 	   synchronized (backupMutex) {
commit:c0b00b2
/////////////////////////////////////////////////////////////////////////
1:     private boolean trackMessages = false;
commit:710db26
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.thread.DefaultThreadPools;
/////////////////////////////////////////////////////////////////////////
0:         reconnectTask = DefaultThreadPools.getDefaultTaskRunnerFactory().createTaskRunner(new Task() {
/////////////////////////////////////////////////////////////////////////
0:         }, "ActiveMQ Failover Worker: " + System.identityHashCode(this));
commit:e225ba6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ConnectionControl;
/////////////////////////////////////////////////////////////////////////
0:     private boolean trackMessages = true;
1:     private int maxCacheSize = 128 * 1024;
/////////////////////////////////////////////////////////////////////////
1:             stateTracker.setMaxCacheSize(getMaxCacheSize());
1:             stateTracker.setTrackMessages(isTrackMessages());
/////////////////////////////////////////////////////////////////////////
0: 	public boolean isTrackMessages() {
1:         return trackMessages;
0:     }
0: 
1:     public void setTrackMessages(boolean trackMessages) {
1:         this.trackMessages = trackMessages;
0:     }
0: 
1:     public int getMaxCacheSize() {
1:         return maxCacheSize;
0:     }
0: 
1:     public void setMaxCacheSize(int maxCacheSize) {
1:         this.maxCacheSize = maxCacheSize;
0:     }
0: 	
/////////////////////////////////////////////////////////////////////////
1:                             stateTracker.trackBack(command);
/////////////////////////////////////////////////////////////////////////
0:         //send information to the broker - informing it we are an ft client
1:         ConnectionControl cc = new ConnectionControl();
1:         cc.setFaultTolerant(true);
1:         t.oneway(cc);
/////////////////////////////////////////////////////////////////////////
commit:b34f730
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.Response;
/////////////////////////////////////////////////////////////////////////
1:     public final void handleTransportFailure(IOException e) throws InterruptedException {
commit:204f6d8
/////////////////////////////////////////////////////////////////////////
0:     private boolean backup=false;
commit:2a153b0
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ExecutorService;
0: import java.util.concurrent.Executors;
0: import java.util.concurrent.ThreadFactory;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.thread.DeterministicTaskRunner;
/////////////////////////////////////////////////////////////////////////
0:     private final ExecutorService executor;
/////////////////////////////////////////////////////////////////////////
0:     private long reconnectDelay = this.initialReconnectDelay;
0:     private boolean backup=true;
/////////////////////////////////////////////////////////////////////////
0:         this.executor =  Executors.newSingleThreadExecutor(new ThreadFactory() {
0:             public Thread newThread(Runnable runnable) {
0:                 Thread thread = new Thread(runnable, "FailoverTransport:"+toString()+"."+System.identityHashCode(this));
0:                 thread.setDaemon(true);
0:                 thread.setPriority(Thread.NORM_PRIORITY);
0:                 return thread;
0:             }
0:         });
0:         reconnectTask = new DeterministicTaskRunner(this.executor,new Task() {
/////////////////////////////////////////////////////////////////////////
0:             		try {
0:                         reconnectTask.wakeup();
0:                     } catch (InterruptedException e) {
0:                         // TODO Auto-generated catch block
0:                         e.printStackTrace();
0:                     }
0:         });
/////////////////////////////////////////////////////////////////////////
0:         executor.shutdown();
commit:5460b7b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:6c52d28
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.RemoveInfo;
/////////////////////////////////////////////////////////////////////////
0:             boolean reconnectOk = false;
0:             if(started) {
0:                 LOG.warn("Transport failed, attempting to automatically reconnect due to: " + e, e);
0:                 reconnectOk = true;
0:             }
0:             
/////////////////////////////////////////////////////////////////////////
0:             	
0:             if(reconnectOk) {
0:             	reconnectTask.wakeup();
0:             }
/////////////////////////////////////////////////////////////////////////
0: 	
0: /*
0: * BEGIN Patch segment for issue AMQ-1116
1: */	
0:     /**
0:      * @return Returns true if the command is one sent when a connection
0:      * is being closed.
1:      */
0:     private boolean isShutdownCommand(Command command) {
0: 	return (command != null && (command.isShutdownInfo() || command instanceof RemoveInfo));
0:     }
0: /*
0: * END Patch segment
1: */
0: 	 
/////////////////////////////////////////////////////////////////////////
0:  
0:                 if (isShutdownCommand(command) && connectedTransport == null) {
0:                     if(command.isShutdownInfo()) {
0:                         // Skipping send of ShutdownInfo command when not connected.
0:                         return;
0:                     }
0:                     if(command instanceof RemoveInfo) {
0:                         // Simulate response to RemoveInfo command
0:                         Response response = new Response();
0:                         response.setCorrelationId(command.getCommandId());
0:                         myTransportListener.onCommand(response);
0:                         return;
0:                     }
0:                 }                      
/////////////////////////////////////////////////////////////////////////
0:  	
0:                 // Make sure on initial startup, that the transportListener has been initialized
0:                 // for this instance.
0:                 while(transportListener == null) {
0:                     try {
0:                         Thread.sleep(100);
0:                     }
0:                     catch(InterruptedException iEx) {}
0:                 }
0: 
0:           
0:                 if(transportListener != null) {
0:                     if (connectionFailure instanceof IOException) {
0:                     	transportListener.onException((IOException)connectionFailure);
0:                     } else {
0:                     	transportListener.onException(IOExceptionSupport.create(connectionFailure));
0:                     }
0:                 }        
commit:ecc87ea
/////////////////////////////////////////////////////////////////////////
0:     private boolean connected;
/////////////////////////////////////////////////////////////////////////
0:                 connected=false;
/////////////////////////////////////////////////////////////////////////
0:             connected = false;
/////////////////////////////////////////////////////////////////////////
0:                             connected=true;
/////////////////////////////////////////////////////////////////////////
1:     public boolean isDisposed() {
0:     	return disposed;
0:     }
0:     
0:     
1:     public boolean isConnected() {
0:         return connected;
0:     }
0:     
1:     public void reconnect(URI uri) throws IOException {
0:     	add(new URI[] {uri});
0:     }
commit:3ac0537
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private URI failedConnectTransportURI;
/////////////////////////////////////////////////////////////////////////
0:             	boolean result=false;
0:             	boolean buildBackup=true;
0:             	if (connectedTransport==null && !disposed) {
0:             		result=doReconnect();
0:             		buildBackup=false;
0:             	}
0:             	if(buildBackup) {
0:             	}else {
0:             		//build backups on the next iteration
0:             		result=true;
/////////////////////////////////////////////////////////////////////////
0:                 failedConnectTransportURI=connectedTransportURI;
/////////////////////////////////////////////////////////////////////////
0:         if (failedConnectTransportURI != null) {
1:             removed = l.remove(failedConnectTransportURI);
/////////////////////////////////////////////////////////////////////////
1:             l.add(failedConnectTransportURI);
/////////////////////////////////////////////////////////////////////////
0:                             failedConnectTransportURI=null;
/////////////////////////////////////////////////////////////////////////
0: 		   if (!disposed && backup && backups.size() < backupPoolSize) {
0: 			   //removed disposed backups
0: 			   List<BackupTransport>disposedList = new ArrayList<BackupTransport>();
0: 			   for (BackupTransport bt:backups) {
0: 				   if (bt.isDisposed()) {
0: 					   disposedList.add(bt);
0: 				   }
0: 			   }
0: 			   backups.removeAll(disposedList);
0: 			   disposedList.clear();
0: 						   BackupTransport bt = new BackupTransport(this);
0: 		                       t.setTransportListener(bt);
/////////////////////////////////////////////////////////////////////////
0: public boolean isDisposed() {
0: 	return disposed;
0: }
0: 
0: public void reconnect(URI uri) throws IOException {
0: 	add(new URI[] {uri});
0: }
0: 
commit:a55149c
/////////////////////////////////////////////////////////////////////////
0:     private int backupPoolSize=1;
commit:418823a
/////////////////////////////////////////////////////////////////////////
0:     private List<BackupTransport> backups=new CopyOnWriteArrayList<BackupTransport>();
0:     private int backupPoolSize=2;
/////////////////////////////////////////////////////////////////////////
0:             	boolean result = doReconnect();
0:             	if(!result) {
0:             		buildBackups();
0:             	}
0:             	return result;
/////////////////////////////////////////////////////////////////////////
0:     
1:     public boolean isBackup() {
0: 		return backup;
0: 	}
0: 
0: 	public void setBackup(boolean backup) {
0: 		this.backup = backup;
0: 	}
0: 
0: 	public int getBackupPoolSize() {
0: 		return backupPoolSize;
0: 	}
0: 
0: 	public void setBackupPoolSize(int backupPoolSize) {
0: 		this.backupPoolSize = backupPoolSize;
0: 	}
/////////////////////////////////////////////////////////////////////////
0:     
0:    final boolean doReconnect() {
0: 
0:         Exception failure = null;
0:         synchronized (reconnectMutex) {
0: 
0:             if (disposed || connectionFailure != null) {
0:                 reconnectMutex.notifyAll();
0:             }
0: 
0:             if (connectedTransport != null || disposed || connectionFailure != null) {
0:                 return false;
0:             } else {
1:                 List<URI> connectList = getConnectList();
0:                 if (connectList.isEmpty()) {
0:                     failure = new IOException("No uris available to connect to.");
0:                 } else {
0:                     if (!useExponentialBackOff) {
0:                         reconnectDelay = initialReconnectDelay;
0:                     }
0:                     if (backup && !backups.isEmpty()) {
0:                     	BackupTransport bt = backups.remove(0);
0:                         Transport t = bt.getTransport();
0:                         URI uri = bt.getUri();
0:                         t.setTransportListener(myTransportListener);
0:                         try {
0:                             if (started) { 
0:                                     restoreTransport(t);  
0:                             }
0:                             reconnectDelay = initialReconnectDelay;
0:                             connectedTransportURI = uri;
0:                             connectedTransport = t;
0:                             reconnectMutex.notifyAll();
0:                             connectFailures = 0;
0:                             LOG.info("Successfully reconnected to backup " + uri);
0:                             return false;
0:                         }catch (Exception e) {
0:                             LOG.debug("Backup transport failed",e);
0:                          }
0:                     }
0:                     
1:                     Iterator<URI> iter = connectList.iterator();
0:                     while(iter.hasNext() && connectedTransport == null && !disposed) {
0:                         URI uri = iter.next();
0:                         try {
0:                             LOG.debug("Attempting connect to: " + uri);
0:                             Transport t = TransportFactory.compositeConnect(uri);
0:                             t.setTransportListener(myTransportListener);
0:                             t.start();
0:                             
0:                             if (started) {
0:                                 restoreTransport(t);
0:                             }
0: 
0:                             LOG.debug("Connection established");
0:                             reconnectDelay = initialReconnectDelay;
0:                             connectedTransportURI = uri;
0:                             connectedTransport = t;
0:                             reconnectMutex.notifyAll();
0:                             connectFailures = 0;
0:                             if (transportListener != null) {
0:                                 transportListener.transportResumed();
0:                             }
0:                             if (firstConnection) {
0:                                 firstConnection=false;
0:                                 LOG.info("Successfully connected to " + uri);
0:                             }else {
0:                                 LOG.info("Successfully reconnected to " + uri);
0:                             }
0:                             return false;
0:                         } catch (Exception e) {
0:                             failure = e;
0:                             LOG.debug("Connect fail to: " + uri + ", reason: " + e);
0:                         }
0:                     }
0:                 }
0:             }
0: 
0:             if (maxReconnectAttempts > 0 && ++connectFailures >= maxReconnectAttempts) {
0:                 LOG.error("Failed to connect to transport after: " + connectFailures + " attempt(s)");
0:                 connectionFailure = failure;
0:                 reconnectMutex.notifyAll();
0:                 return false;
0:             }
0:         }
0: 
0:         if (!disposed) {
0: 
0:             LOG.debug("Waiting " + reconnectDelay + " ms before attempting connection. ");
0:             synchronized (sleepMutex) {
0:                 try {
0:                     sleepMutex.wait(reconnectDelay);
0:                 } catch (InterruptedException e) {
0:                     Thread.currentThread().interrupt();
0:                 }
0:             }
0: 
0:             if (useExponentialBackOff) {
0:                 // Exponential increment of reconnect delay.
0:                 reconnectDelay *= backOffMultiplier;
0:                 if (reconnectDelay > maxReconnectDelay) {
0:                     reconnectDelay = maxReconnectDelay;
0:                 }
0:             }
0:         }
0:         return !disposed;
0:     }
0: 
0:    
0:    final boolean buildBackups() {
0: 	   synchronized (reconnectMutex) {
0: 		   if (backup && backups.size() < backupPoolSize) {
1: 			   List<URI> connectList = getConnectList();
0: 			   for (Iterator<URI>iter = connectList.iterator();iter.hasNext() && backups.size() < backupPoolSize;) {
0: 				   URI uri = iter.next();
0: 				   if (connectedTransportURI != null && !connectedTransportURI.equals(uri)) {
0: 					   try {
0: 						   BackupTransport bt = new BackupTransport();
0: 						   bt.setUri(uri);
0: 						   if (!backups.contains(bt)) {
0: 							   Transport t = TransportFactory.compositeConnect(uri);
0: 		                       t.setTransportListener(new DefaultTransportListener());
0: 		                       t.start();
0: 		                       bt.setTransport(t);
0: 		                       backups.add(bt);
0: 						   }
0: 					   }catch(Exception e) {
0: 						   LOG.debug("Failed to build backup ",e);
0: 					   }
0: 				   }
0: 			   }
0: 		   }
0: 	   }
0: 	   return false;
0:    }
0: 
0: 
commit:e210657
/////////////////////////////////////////////////////////////////////////
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transport.DefaultTransportListener;
/////////////////////////////////////////////////////////////////////////
1:     private boolean firstConnection = true;
0:     //optionally always have a backup created
0:     private boolean backup=false;
0:     private URI backupTransportURI;
0:     private Transport backupTransport;
0:     
/////////////////////////////////////////////////////////////////////////
0:                         List<URI> connectList = getConnectList();
0:                             if (backup && backupTransport != null) {
0:                                 Transport t = backupTransport;
0:                                 URI uri = backupTransportURI;
0:                                 backupTransport=null;
0:                                 backupTransportURI=null;
0:                                 t.setTransportListener(myTransportListener);
0:                                 try {
0:                                     if (started) { 
0:                                             restoreTransport(t);  
0:                                     }
0:                                     reconnectDelay = initialReconnectDelay;
0:                                     connectedTransportURI = uri;
0:                                     connectedTransport = t;
0:                                     reconnectMutex.notifyAll();
0:                                     connectFailures = 0;
0:                                     LOG.info("Successfully reconnected to backup " + uri);
0:                                     return false;
0:                                 }catch (Exception e) {
0:                                     LOG.debug("Backup transport failed",e);
0:                                  }
0:                             }
0:                             
0:                             Iterator<URI> iter = connectList.iterator();
0:                             while(iter.hasNext() && connectedTransport == null && !disposed) {
0:                                 URI uri = iter.next();
0:                                     
/////////////////////////////////////////////////////////////////////////
0:                                     if (firstConnection) {
0:                                         firstConnection=false;
0:                                         LOG.info("Successfully connected to " + uri);
0:                                         if(backup) {
0:                                             while(iter.hasNext() && backupTransport==null){
0:                                                 uri = iter.next();
0:                                                 try {
0:                                                     t = TransportFactory.compositeConnect(uri);
0:                                                     t.setTransportListener(new DefaultTransportListener());
0:                                                     t.start();
0:                                                     backupTransport=t;
0:                                                     backupTransportURI=uri;
0:                                                 }catch(Exception e) {
0:                                                     LOG.debug("Failed to create backup to " + uri,e);
0:                                                 }
0:                                             }
0:                                         }
0:                                     }else {
0:                                         LOG.info("Successfully reconnected to " + uri);
0:                                     }
/////////////////////////////////////////////////////////////////////////
1:     private List<URI> getConnectList() {
0:         ArrayList<URI> l = new ArrayList<URI>(uris);
1:         boolean removed = false;
0:         if (connectedTransportURI != null) {
0:             removed = l.remove(connectedTransportURI);
0:         }
1:                 URI t = l.get(p);
0:         if (removed) {
0:             l.add(connectedTransportURI);
0:         }
commit:c7469c4
/////////////////////////////////////////////////////////////////////////
0:     
0:     public boolean isFaultTolerant(){
0:         return true;
0:     }
commit:a3e3821
/////////////////////////////////////////////////////////////////////////
0:                     Object object = requestMap.remove(Integer.valueOf(((Response) command).getCorrelationId()));
/////////////////////////////////////////////////////////////////////////
0:     final void handleTransportFailure(IOException e) throws InterruptedException {
/////////////////////////////////////////////////////////////////////////
0:                             requestMap.put(Integer.valueOf(command.getCommandId()), tracked);
0:                             requestMap.put(Integer.valueOf(command.getCommandId()), command);
/////////////////////////////////////////////////////////////////////////
0:                             		requestMap.remove(Integer.valueOf(command.getCommandId()));
commit:22e007f
/////////////////////////////////////////////////////////////////////////
0:                                     log.info("Successfully reconnected to " + uri);
/////////////////////////////////////////////////////////////////////////
0:             log.warn("Transport failed, attempting to automatically reconnect due to: " + e, e);
commit:ef0734b
/////////////////////////////////////////////////////////////////////////
0:     private final TransportListener myTransportListener = new TransportListener() {
/////////////////////////////////////////////////////////////////////////
0:         
0:         public void transportInterupted(){
0:             if (transportListener != null){
0:                 transportListener.transportInterupted();
0:             }
0:         }
0: 
0:         public void transportResumed(){
0:             if(transportListener != null){
0:                 transportListener.transportResumed();
0:             }
0:         }
/////////////////////////////////////////////////////////////////////////
0:                                     
0:                                     
/////////////////////////////////////////////////////////////////////////
0:                                    
commit:5fe0a4c
/////////////////////////////////////////////////////////////////////////
0:     
0:     public Response request(Command command,int timeout) throws IOException {
1:         throw new AssertionError("Unsupported Method");
0:     }
commit:3155d41
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         if(!disposed){
0:             if(error!=null){
0:                 if(error instanceof IOException)
0:                     throw (IOException) error;
0:                 throw IOExceptionSupport.create(error);
0:             }
0:         }
commit:2bc09bb
/////////////////////////////////////////////////////////////////////////
1:     private final Object sleepMutex = new Object();
/////////////////////////////////////////////////////////////////////////
0:                             if (!useExponentialBackOff){
0:                                 reconnectDelay = initialReconnectDelay;
0:                             }
/////////////////////////////////////////////////////////////////////////
0:                     
0:                         synchronized(sleepMutex){
0:                             try{
0:                                 sleepMutex.wait(reconnectDelay);
0:                             }catch(InterruptedException e){
0:                                Thread.currentThread().interrupt();
0:                             }
0:                         }
0:                         
0:                     
/////////////////////////////////////////////////////////////////////////
0:             reconnectMutex.notifyAll();
0:         }
0:         synchronized(sleepMutex){
0:             sleepMutex.notifyAll();
commit:8b572cb
/////////////////////////////////////////////////////////////////////////
0:                 for (int i = 0;!disposed; i++) {
commit:f915da5
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transport.DefaultTransportListener;
/////////////////////////////////////////////////////////////////////////
0:     private final TransportListener myTransportListener = new DefaultTransportListener() {
/////////////////////////////////////////////////////////////////////////
0:                                     if (transportListener != null){
0:                                         transportListener.transportResumed();
0:                                     }
/////////////////////////////////////////////////////////////////////////
0:         if (transportListener != null){
0:             transportListener.transportInterupted();
0:         }
commit:3e7ebc2
/////////////////////////////////////////////////////////////////////////
0:                 if(!disposed){
0:                     try{
0:                         log.debug("Waiting "+reconnectDelay+" ms before attempting connection. ");
0:                         Thread.sleep(reconnectDelay);
0:                     }catch(InterruptedException e1){
0:                         Thread.currentThread().interrupt();
0:                     }
0:                     if(useExponentialBackOff){
0:                         // Exponential increment of reconnect delay.
0:                         reconnectDelay*=backOffMultiplier;
0:                         if(reconnectDelay>maxReconnectDelay)
0:                             reconnectDelay=maxReconnectDelay;
0:                     }
0:                 return !disposed;
commit:4098942
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.BrokerInfo;
/////////////////////////////////////////////////////////////////////////
1:     private boolean randomize = true;
0:     private boolean initialized;
/////////////////////////////////////////////////////////////////////////
0:             if (!initialized){
0:                 if (command.isBrokerInfo()){
0:                     BrokerInfo info = (BrokerInfo)command;
0:                     BrokerInfo[] peers = info.getPeerBrokerInfos();
0:                     if (peers!= null){
0:                         for (int i =0; i < peers.length;i++){
0:                             String brokerString = peers[i].getBrokerURL();
0:                             add(brokerString);
0:                         }
0:                     }
0:                 initialized = true;
0:                 }
0:                 
0:             }
/////////////////////////////////////////////////////////////////////////
0:                 initialized = false;
/////////////////////////////////////////////////////////////////////////
0:     /**
1:      * @return Returns the randomize.
0:      */
0:     public boolean isRandomize(){
1:         return randomize;
0:     }
0: 
0:     /**
0:      * @param randomize The randomize to set.
0:      */
0:     public void setRandomize(boolean randomize){
0:         this.randomize=randomize;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     
0:     public void add(String u){
0:         try {
0:         URI uri = new URI(u);
0:         if (!uris.contains(uri))
0:             uris.add(uri);
0: 
0:         reconnect();
0:         }catch(Exception e){
0:             log.error("Failed to parse URI: " + u);
0:         }
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     private ArrayList getConnectList(){
0:         ArrayList l=new ArrayList(uris);
0:         if (randomize){
0:             // Randomly, reorder the list by random swapping
0:             Random r=new Random();
0:             r.setSeed(System.currentTimeMillis());
0:             for (int i=0;i<l.size();i++){
0:                 int p=r.nextInt(l.size());
0:                 Object t=l.get(p);
0:                 l.set(p,l.get(i));
0:                 l.set(i,t);
0:             }
author:Adrian T. Co
-------------------------------------------------------------------------------
commit:a6e227d
/////////////////////////////////////////////////////////////////////////
0:                 LOG.warn("Transport failed, attempting to automatically reconnect due to: " + e);
0:                 LOG.debug("Transport failed with the following exception:", e);
commit:da6c2d6
/////////////////////////////////////////////////////////////////////////
1:                         LOG.debug("Reconnect task has been interrupted.", e);
/////////////////////////////////////////////////////////////////////////
0:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug("Transport failed, attempting to automatically reconnect due to: " + e, e);
0:                 } else {
0:                     LOG.warn("Transport failed, attempting to automatically reconnect due to: " + e);
0:                 }
commit:04c3b07
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.state.Tracked;
/////////////////////////////////////////////////////////////////////////
0:                         Object object = requestMap.remove(new Integer(((Response) command).getCorrelationId()));
0:                         if( object!=null && object.getClass() == Tracked.class ) {
0:                              ((Tracked)object).onResponses();
0:                         }
/////////////////////////////////////////////////////////////////////////
0:     	stateTracker.setTrackTransactions(true);
0:     	
/////////////////////////////////////////////////////////////////////////
0:                         Tracked tracked = stateTracker.track(command);
0:                         if( tracked!=null && tracked.isWaitingForResponse() ) {
0:                             requestMap.put(new Integer(command.getCommandId()), tracked);
0:                         } else if ( tracked==null && command.isResponseRequired()) {
/////////////////////////////////////////////////////////////////////////
0:                         	
0:                         	// If the command was not tracked.. we will retry in this method
0:                         	if( tracked==null ) {
0:                         		
0:                         		// since we will retry in this method.. take it out of the request
0:                         		// map so that it is not sent 2 times on recovery
0:                             	if( command.isResponseRequired() ) {
0:                             		requestMap.remove(new Integer(command.getCommandId()));
0:                             	}
0:                             	
0:                                 // Rethrow the exception so it will handled by the outer catch
0:                                 throw e;
0:                         	}
commit:e99fc62
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                                                 
0:                         // Send the message.
0:                         try {
0:                             connectedTransport.oneway(command);
0:                         } catch (IOException e) {
0:                             // If there is an IOException in the send, remove the command from the requestMap
0:                             if (!stateTracker.track(command) && command.isResponseRequired()) {
0:                                 requestMap.remove(new Short(command.getCommandId()), command);
0:                             }
0:                             
0:                             // Rethrow the exception so it will handled by the outer catch
0:                             throw e;
0:                         }
0:                         
author:James Strachan
-------------------------------------------------------------------------------
commit:6e714a2
/////////////////////////////////////////////////////////////////////////
0:             log.info("Transport failed, attempting to automatically reconnect due to: " + e, e);
commit:0f1dcce
/////////////////////////////////////////////////////////////////////////
0: 	public String getRemoteAddress() {
0: 		if(connectedTransport != null){
0: 			return connectedTransport.getRemoteAddress();
0: 		}
0: 		return null;
0: 	}
0: 
commit:9c19776
/////////////////////////////////////////////////////////////////////////
0:                             try {
0:                                 reconnectMutex.wait(1000);
0:                             }
0:                             catch (InterruptedException e) {
0:                                 log.debug("Interupted: " + e, e);
0:                             }
commit:8704338
/////////////////////////////////////////////////////////////////////////
0:                 requestMap.remove(new Integer(((Response) command).getCorrelationId()));
/////////////////////////////////////////////////////////////////////////
0:                             requestMap.put(new Integer(command.getCommandId()), command);
/////////////////////////////////////////////////////////////////////////
0:                                 requestMap.remove(new Integer(command.getCommandId()), command);
commit:436fe42
/////////////////////////////////////////////////////////////////////////
1:     public TransportListener getTransportListener() {
1:         return transportListener;
0:     }
0: 
commit:99c1a67
/////////////////////////////////////////////////////////////////////////
0:                                     t.start();
/////////////////////////////////////////////////////////////////////////
commit:2ae7169
/////////////////////////////////////////////////////////////////////////
0:             if (transportListener != null) {
0:                 transportListener.onCommand(command);
0:             }
commit:40ce55b
/////////////////////////////////////////////////////////////////////////
0:             if (command == null) {
0:                 return;
0:             }
============================================================================