1:456a2ba: /**
1:456a2ba:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:456a2ba:  * contributor license agreements.  See the NOTICE file distributed with
1:456a2ba:  * this work for additional information regarding copyright ownership.
1:456a2ba:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:456a2ba:  * (the "License"); you may not use this file except in compliance with
1:456a2ba:  * the License.  You may obtain a copy of the License at
2:456a2ba:  *
1:456a2ba:  *      http://www.apache.org/licenses/LICENSE-2.0
1:456a2ba:  *
1:456a2ba:  * Unless required by applicable law or agreed to in writing, software
1:456a2ba:  * distributed under the License is distributed on an "AS IS" BASIS,
1:456a2ba:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:456a2ba:  * See the License for the specific language governing permissions and
1:456a2ba:  * limitations under the License.
1:456a2ba:  */
1:1aab71b: package org.apache.activemq.store.kahadb.disk.index;
1:456a2ba: 
1:8d5f07b: import java.io.ByteArrayInputStream;
1:8d5f07b: import java.io.ByteArrayOutputStream;
1:8d5f07b: import java.io.DataInput;
1:8d5f07b: import java.io.DataOutput;
1:8d5f07b: import java.io.IOException;
1:8d5f07b: import java.io.ObjectInputStream;
1:8d5f07b: import java.io.ObjectOutputStream;
1:456a2ba: import java.io.PrintWriter;
1:456a2ba: import java.text.NumberFormat;
1:8e60ca9: import java.util.Arrays;
1:8d5f07b: import java.util.HashSet;
1:456a2ba: import java.util.Iterator;
1:456a2ba: import java.util.List;
1:456a2ba: import java.util.Map;
1:530ab04: import java.util.Random;
1:456a2ba: 
1:1aab71b: import org.apache.activemq.store.kahadb.disk.page.PageFile;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.page.Transaction;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.util.LongMarshaller;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.util.StringMarshaller;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.util.VariableMarshaller;
1:81c167b: import org.junit.Test;
1:53b29a2: import org.slf4j.Logger;
1:53b29a2: import org.slf4j.LoggerFactory;
1:456a2ba: 
1:456a2ba: public class BTreeIndexTest extends IndexTestSupport {
1:53b29a2:     private static final Logger LOG = LoggerFactory.getLogger(BTreeIndexTest.class);
1:456a2ba:     private NumberFormat nf;
1:456a2ba: 
1:456a2ba:     @Override
1:456a2ba:     protected void setUp() throws Exception {
1:456a2ba:         super.setUp();
1:456a2ba:         nf = NumberFormat.getIntegerInstance();
1:456a2ba:         nf.setMinimumIntegerDigits(6);
1:456a2ba:         nf.setGroupingUsed(false);
1:456a2ba:     }
1:81c167b: 
1:456a2ba:     @Override
1:456a2ba:     protected Index<String, Long> createIndex() throws Exception {
1:81c167b: 
1:456a2ba:         long id = tx.allocate().getPageId();
1:456a2ba:         tx.commit();
1:456a2ba: 
1:456a2ba:         BTreeIndex<String, Long> index = new BTreeIndex<String,Long>(pf, id);
1:456a2ba:         index.setKeyMarshaller(StringMarshaller.INSTANCE);
1:456a2ba:         index.setValueMarshaller(LongMarshaller.INSTANCE);
1:81c167b: 
1:456a2ba:         return index;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:81c167b:      * Yeah, the current implementation does NOT try to balance the tree.  Here is
1:81c167b:      * a test case showing that it gets out of balance.
1:81c167b:      *
1:456a2ba:      * @throws Exception
1:456a2ba:      */
1:456a2ba:     public void disabled_testTreeBalancing() throws Exception {
1:456a2ba:         createPageFileAndIndex(100);
1:456a2ba: 
1:456a2ba:         BTreeIndex index = ((BTreeIndex)this.index);
1:456a2ba:         this.index.load(tx);
1:456a2ba:         tx.commit();
1:81c167b: 
1:456a2ba:         doInsert(50);
1:81c167b: 
1:456a2ba:         int minLeafDepth = index.getMinLeafDepth(tx);
1:456a2ba:         int maxLeafDepth = index.getMaxLeafDepth(tx);
1:456a2ba:         assertTrue("Tree is balanced", maxLeafDepth-minLeafDepth <= 1);
1:81c167b: 
1:456a2ba:         // Remove some of the data
1:456a2ba:         doRemove(16);
1:456a2ba:         minLeafDepth = index.getMinLeafDepth(tx);
1:456a2ba:         maxLeafDepth = index.getMaxLeafDepth(tx);
1:456a2ba: 
1:456a2ba:         System.out.println( "min:"+minLeafDepth );
1:456a2ba:         System.out.println( "max:"+maxLeafDepth );
1:456a2ba:         index.printStructure(tx, new PrintWriter(System.out));
1:456a2ba: 
1:456a2ba:         assertTrue("Tree is balanced", maxLeafDepth-minLeafDepth <= 1);
1:456a2ba: 
1:456a2ba:         this.index.unload(tx);
1:456a2ba:     }
1:81c167b: 
1:81c167b:     @Test(timeout=60000)
1:456a2ba:     public void testPruning() throws Exception {
1:456a2ba:         createPageFileAndIndex(100);
1:81c167b: 
1:456a2ba:         BTreeIndex<String,Long> index = ((BTreeIndex<String,Long>)this.index);
1:456a2ba: 
1:456a2ba:         this.index.load(tx);
1:456a2ba:         tx.commit();
1:456a2ba: 
1:456a2ba:         int minLeafDepth = index.getMinLeafDepth(tx);
1:456a2ba:         int maxLeafDepth = index.getMaxLeafDepth(tx);
1:456a2ba:         assertEquals(1, minLeafDepth);
1:456a2ba:         assertEquals(1, maxLeafDepth);
1:81c167b: 
1:456a2ba:         doInsert(1000);
1:81c167b: 
1:456a2ba:         minLeafDepth = index.getMinLeafDepth(tx);
1:456a2ba:         maxLeafDepth = index.getMaxLeafDepth(tx);
1:456a2ba:         assertTrue("Depth of tree grew", minLeafDepth > 1);
1:456a2ba:         assertTrue("Depth of tree grew", maxLeafDepth > 1);
1:456a2ba: 
1:456a2ba:         // Remove the data.
1:456a2ba:         doRemove(1000);
1:456a2ba:         minLeafDepth = index.getMinLeafDepth(tx);
1:456a2ba:         maxLeafDepth = index.getMaxLeafDepth(tx);
1:456a2ba: 
1:456a2ba:         assertEquals(1, minLeafDepth);
1:456a2ba:         assertEquals(1, maxLeafDepth);
1:456a2ba: 
1:456a2ba:         this.index.unload(tx);
1:456a2ba:         tx.commit();
1:456a2ba:     }
1:456a2ba: 
1:81c167b:     @Test(timeout=60000)
1:456a2ba:     public void testIteration() throws Exception {
1:53b29a2:         createPageFileAndIndex(500);
1:456a2ba:         BTreeIndex<String,Long> index = ((BTreeIndex<String,Long>)this.index);
1:456a2ba:         this.index.load(tx);
1:54e2e3b:         tx.commit();
1:54e2e3b: 
1:456a2ba:         // Insert in reverse order..
1:456a2ba:         doInsertReverse(1000);
1:81c167b: 
1:456a2ba:         this.index.unload(tx);
1:456a2ba:         tx.commit();
1:456a2ba:         this.index.load(tx);
1:456a2ba:         tx.commit();
1:81c167b: 
1:53b29a2:         exerciseAnotherIndex(tx);
1:456a2ba: 
1:456a2ba:         // BTree should iterate it in sorted order.
1:456a2ba:         int counter=0;
1:456a2ba:         for (Iterator<Map.Entry<String,Long>> i = index.iterator(tx); i.hasNext();) {
1:81c167b:             Map.Entry<String,Long> entry = i.next();
1:456a2ba:             assertEquals(key(counter),entry.getKey());
1:456a2ba:             assertEquals(counter,(long)entry.getValue());
1:456a2ba:             counter++;
1:456a2ba:         }
1:456a2ba: 
1:456a2ba:         this.index.unload(tx);
1:456a2ba:         tx.commit();
1:456a2ba:     }
1:456a2ba: 
1:81c167b:     @Test(timeout=60000)
1:54e2e3b:     public void testLimitedIteration() throws Exception {
1:54e2e3b:         createPageFileAndIndex(500);
1:54e2e3b:         BTreeIndex<String,Long> index = ((BTreeIndex<String,Long>)this.index);
1:54e2e3b:         this.index.load(tx);
1:54e2e3b:         tx.commit();
1:54e2e3b: 
1:54e2e3b:         // Insert in reverse order..
1:54e2e3b:         doInsertReverse(1000);
1:54e2e3b: 
1:54e2e3b:         this.index.unload(tx);
1:54e2e3b:         tx.commit();
1:54e2e3b:         this.index.load(tx);
1:456a2ba:         tx.commit();
1:456a2ba: 
1:54e2e3b:         // BTree should iterate it in sorted order up to limit
1:54e2e3b:         int counter=0;
1:54e2e3b:         for (Iterator<Map.Entry<String,Long>> i = index.iterator(tx, key(0), key(500)); i.hasNext();) {
1:54e2e3b:             Map.Entry<String,Long> entry = i.next();
1:54e2e3b:             assertEquals(key(counter),entry.getKey());
1:54e2e3b:             assertEquals(counter,(long)entry.getValue());
1:54e2e3b:             counter++;
1:54e2e3b:         }
1:54e2e3b: 
1:54e2e3b:         assertEquals("got to 500", 500, counter);
1:54e2e3b:         this.index.unload(tx);
1:54e2e3b:         tx.commit();
1:54e2e3b:     }
1:54e2e3b: 
1:54e2e3b:     @Test(timeout=60000)
1:456a2ba:     public void testVisitor() throws Exception {
1:456a2ba:         createPageFileAndIndex(100);
1:456a2ba:         BTreeIndex<String,Long> index = ((BTreeIndex<String,Long>)this.index);
1:456a2ba:         this.index.load(tx);
1:456a2ba:         tx.commit();
1:81c167b: 
1:456a2ba:         // Insert in reverse order..
1:456a2ba:         doInsert(1000);
1:81c167b: 
1:456a2ba:         this.index.unload(tx);
1:456a2ba:         tx.commit();
1:456a2ba:         this.index.load(tx);
1:456a2ba:         tx.commit();
1:81c167b: 
1:456a2ba:         // BTree should iterate it in sorted order.
1:456a2ba: 
1:456a2ba:         index.visit(tx, new BTreeVisitor<String, Long>(){
1:81c167b:             @Override
1:94b9d55:             public boolean isInterestedInKeysBetween(String first, String second) {
1:456a2ba:                 return true;
1:456a2ba:             }
1:81c167b:             @Override
1:94b9d55:             public void visit(List<String> keys, List<Long> values) {
1:456a2ba:             }
1:456a2ba:         });
1:81c167b: 
1:456a2ba: 
1:456a2ba:         this.index.unload(tx);
1:456a2ba:         tx.commit();
1:456a2ba:     }
1:456a2ba: 
1:81c167b:     @Test(timeout=60000)
1:530ab04:     public void testRandomRemove() throws Exception {
1:456a2ba: 
1:456a2ba:         createPageFileAndIndex(100);
1:530ab04:         BTreeIndex<String,Long> index = ((BTreeIndex<String,Long>)this.index);
1:530ab04:         this.index.load(tx);
1:456a2ba: 
1:53b29a2:         long id = tx.allocate().getPageId();
1:530ab04:         tx.commit();
1:456a2ba: 
1:53b29a2:         BTreeIndex<String, String> sindex = new BTreeIndex<String,String>(pf, id);
1:53b29a2:         sindex.setKeyMarshaller(StringMarshaller.INSTANCE);
1:53b29a2:         sindex.setValueMarshaller(StringMarshaller.INSTANCE);
1:53b29a2:         sindex.load(tx);
1:456a2ba: 
1:53b29a2:         tx.commit();
1:456a2ba: 
1:53b29a2:         final int count = 5000;
1:456a2ba: 
1:53b29a2:         String payload = new String(new byte[2]);
1:53b29a2:         for (int i = 0; i < count; i++) {
1:53b29a2:             index.put(tx, key(i), (long)i);
1:53b29a2:             sindex.put(tx, key(i), String.valueOf(i) + payload);
1:53b29a2:             tx.commit();
1:53b29a2:         }
1:456a2ba: 
1:456a2ba: 
1:530ab04:         Random rand = new Random(System.currentTimeMillis());
1:530ab04:         int i = 0, prev = 0;
1:53b29a2:         while (!index.isEmpty(tx) || !sindex.isEmpty(tx)) {
1:530ab04:             prev = i;
1:530ab04:             i = rand.nextInt(count);
1:530ab04:             try {
1:530ab04:                 index.remove(tx, key(i));
1:53b29a2:                 sindex.remove(tx, key(i));
1:53b29a2:             } catch (Exception e) {
1:53b29a2:                 e.printStackTrace();
1:53b29a2:                 fail("unexpected exception on " + i + ", prev: " + prev + ", ex: " + e);
1:53b29a2:             }
1:53b29a2:         }
1:53b29a2:     }
1:456a2ba: 
1:94b9d55:     @Test(timeout=900000)
1:53b29a2:     public void testRandomAddRemove() throws Exception {
1:456a2ba: 
1:53b29a2:         createPageFileAndIndex(1024);
1:53b29a2:         BTreeIndex<String,Long> index = ((BTreeIndex<String,Long>)this.index);
1:53b29a2:         this.index.load(tx);
1:456a2ba: 
1:53b29a2:         long id = tx.allocate().getPageId();
1:53b29a2:         tx.commit();
1:456a2ba: 
1:53b29a2:         BTreeIndex<String, String> sindex = new BTreeIndex<String,String>(pf, id);
1:53b29a2:         sindex.setKeyMarshaller(StringMarshaller.INSTANCE);
1:53b29a2:         sindex.setValueMarshaller(StringMarshaller.INSTANCE);
1:53b29a2:         sindex.load(tx);
1:456a2ba: 
1:53b29a2:         tx.commit();
1:456a2ba: 
1:53b29a2:         Random rand = new Random(System.currentTimeMillis());
1:27e11a3:         final int count = 1000;
1:456a2ba: 
1:53b29a2:         String payload = new String(new byte[200]);
1:53b29a2:         for (int i = 0; i < count; i++) {
1:53b29a2:             int insertIndex = rand.nextInt(count);
1:53b29a2:             index.put(tx, key(insertIndex), (long)insertIndex);
1:53b29a2:             sindex.put(tx, key(insertIndex), String.valueOf(insertIndex) + payload);
1:53b29a2:             tx.commit();
1:53b29a2:         }
1:456a2ba: 
1:456a2ba: 
1:53b29a2:         int i = 0, prev = 0;
1:53b29a2:         while (!index.isEmpty(tx) || !sindex.isEmpty(tx)) {
1:53b29a2:             prev = i;
1:53b29a2:             i = rand.nextInt(count);
1:53b29a2:             try {
1:53b29a2:                 index.remove(tx, key(i));
1:53b29a2:                 sindex.remove(tx, key(i));
1:530ab04:             } catch (Exception e) {
1:530ab04:                 e.printStackTrace();
1:530ab04:                 fail("unexpected exception on " + i + ", prev: " + prev + ", ex: " + e);
1:8d5f07b:             }
1:530ab04:         }
1:530ab04:     }
1:53b29a2: 
1:81c167b:     @Test(timeout=60000)
1:530ab04:     public void testRemovePattern() throws Exception {
2:530ab04:         createPageFileAndIndex(100);
1:530ab04:         BTreeIndex<String,Long> index = ((BTreeIndex<String,Long>)this.index);
1:530ab04:         this.index.load(tx);
1:530ab04:         tx.commit();
1:53b29a2: 
2:530ab04:         final int count = 4000;
2:530ab04:         doInsert(count);
1:53b29a2: 
1:530ab04:         index.remove(tx, key(3697));
1:530ab04:         index.remove(tx, key(1566));
1:53b29a2: 
1:53b29a2:         tx.commit();
1:53b29a2:         index.clear(tx);
1:53b29a2:         tx.commit();
1:53b29a2: 
1:53b29a2:         doInsert(count);
1:53b29a2: 
1:53b29a2:         Iterator<Map.Entry<String, Long>> iterator = index.iterator(tx, key(1345));
1:53b29a2:         while (iterator.hasNext()) {
1:53b29a2:             Map.Entry<String, Long> val = iterator.next();
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         doRemoveBackwards(666);
1:53b29a2:         Map.Entry<String, Long> first = index.getFirst(tx);
1:53b29a2:         assertEquals(first.getValue(), Long.valueOf(666L));
1:53b29a2: 
1:53b29a2:         for (int i=0; i<2000; i++) {
1:53b29a2:             Map.Entry<String, Long> last = index.getLast(tx);
1:53b29a2:             index.remove(tx, last.getKey());
1:53b29a2:             tx.commit();
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         exerciseAnotherIndex(tx);
1:53b29a2: 
1:53b29a2:         iterator = index.iterator(tx, key(100));
1:53b29a2:         while (iterator.hasNext()) {
1:53b29a2:             Map.Entry<String, Long> val = iterator.next();
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         Map.Entry<String, Long> last = index.getLast(tx);
1:53b29a2:         assertEquals(last.getValue(), Long.valueOf(1999L));
1:53b29a2:         index.clear(tx);
1:53b29a2:         assertNull(index.getLast(tx));
1:530ab04:     }
1:53b29a2: 
1:81c167b:     @Test(timeout=60000)
1:d1e7d69:     public void testLargeValue() throws Exception {
1:d1e7d69:         //System.setProperty("maxKahaDBTxSize", "" + (1024*1024*1024));
1:81c167b:         pf = new PageFile(getDirectory(), getClass().getName());
1:d1e7d69:         pf.setPageSize(4*1024);
1:53b29a2:         //pf.setEnablePageCaching(false);
1:d1e7d69:         pf.load();
1:d1e7d69:         tx = pf.tx();
1:8d5f07b:         long id = tx.allocate().getPageId();
1:8d5f07b:         tx.commit();
1:53b29a2: 
1:8d5f07b:         BTreeIndex<Long, HashSet<String>> test = new BTreeIndex<Long, HashSet<String>>(pf, id);
1:8d5f07b:         test.setKeyMarshaller(LongMarshaller.INSTANCE);
1:8d5f07b:         test.setValueMarshaller(HashSetStringMarshaller.INSTANCE);
1:8d5f07b:         test.load(tx);
1:8d5f07b:         tx.commit();
1:53b29a2: 
1:8d5f07b:         tx =  pf.tx();
1:d1e7d69:         String val = new String(new byte[1024]);
1:d1e7d69:         final long numMessages = 10;
1:d1e7d69:         final int numConsumers = 200;
1:53b29a2: 
1:8d5f07b:         for (long i=0; i<numMessages; i++) {
1:8d5f07b:             HashSet<String> hs = new HashSet<String>();
1:8d5f07b:             for (int j=0; j<numConsumers;j++) {
1:8d5f07b:                 hs.add(val + "SOME TEXT" + j);
1:8d5f07b:             }
1:8d5f07b:             test.put(tx, i, hs);
1:8d5f07b:         }
1:d1e7d69:         tx.commit();
1:d1e7d69:         tx =  pf.tx();
1:d1e7d69:         for (long i=0; i<numMessages; i++) {
1:d1e7d69:             HashSet<String> hs = new HashSet<String>();
1:d1e7d69:             for (int j=numConsumers; j<numConsumers*2;j++) {
1:d1e7d69:                 hs.add(val + "SOME TEXT" + j);
1:d1e7d69:             }
1:d1e7d69:             test.put(tx, i, hs);
1:d1e7d69:         }
1:53b29a2: 
1:d1e7d69:         tx.commit();
1:d1e7d69:         tx =  pf.tx();
1:8d5f07b:         for (long i=0; i<numMessages; i++) {
1:53b29a2:             assertTrue(test.containsKey(tx, i));
1:8d5f07b:             test.get(tx, i);
1:8d5f07b:         }
1:8d5f07b:         tx.commit();
1:8d5f07b:     }
1:53b29a2: 
1:81c167b:     @Test(timeout=60000)
1:d1e7d69:     public void testLargeValueOverflow() throws Exception {
1:81c167b:         pf = new PageFile(getDirectory(), getClass().getName());
1:d1e7d69:         pf.setPageSize(4*1024);
1:d1e7d69:         pf.setWriteBatchSize(1);
1:d1e7d69:         pf.load();
1:d1e7d69:         tx = pf.tx();
1:d1e7d69:         long id = tx.allocate().getPageId();
1:53b29a2: 
1:d1e7d69:         BTreeIndex<Long, String> test = new BTreeIndex<Long, String>(pf, id);
1:d1e7d69:         test.setKeyMarshaller(LongMarshaller.INSTANCE);
1:d1e7d69:         test.setValueMarshaller(StringMarshaller.INSTANCE);
1:d1e7d69:         test.load(tx);
1:d1e7d69:         tx.commit();
1:53b29a2: 
1:d1e7d69:         final int stringSize = 6*1024;
1:d1e7d69:         tx =  pf.tx();
1:d1e7d69:         String val = new String(new byte[stringSize]);
1:d1e7d69:         final long numMessages = 1;
1:53b29a2: 
1:d1e7d69:         for (long i=0; i<numMessages; i++) {
1:d1e7d69:             test.put(tx, i, val);
1:d1e7d69:         }
1:d1e7d69:         tx.commit();
1:53b29a2: 
1:53b29a2:         exerciseAnotherIndex(tx);
1:53b29a2: 
1:d1e7d69:         tx =  pf.tx();
1:d1e7d69:         for (long i=0; i<numMessages; i++) {
1:53b29a2:             assertTrue(test.containsKey(tx, i));
1:d1e7d69:             String s = test.get(tx, i);
1:d1e7d69:             assertEquals("len is as expected", stringSize, s.length());
1:d1e7d69:         }
1:d1e7d69:         tx.commit();
1:d1e7d69:     }
1:53b29a2: 
1:53b29a2:     public void exerciseAnotherIndex(Transaction tx) throws Exception {
1:53b29a2:         long id = tx.allocate().getPageId();
1:53b29a2: 
1:53b29a2:         ListIndex<String, String> test = new ListIndex<String, String>(pf, id);
1:53b29a2:         test.setKeyMarshaller(StringMarshaller.INSTANCE);
1:53b29a2:         test.setValueMarshaller(StringMarshaller.INSTANCE);
1:53b29a2:         test.load(tx);
1:53b29a2:         tx.commit();
1:53b29a2: 
1:53b29a2:         final int count = 10000;
1:53b29a2: 
1:53b29a2:         String payload = new String(new byte[1]);
1:53b29a2:         for (int i = 0; i < count; i++) {
1:53b29a2:             test.put(tx, key(i), String.valueOf(i) + payload);
1:53b29a2:         }
1:53b29a2:         tx.commit();
1:53b29a2: 
1:53b29a2:         test.clear(tx);
1:53b29a2:         tx.commit();
1:53b29a2:     }
1:53b29a2: 
1:81c167b:     @Test(timeout=60000)
1:8e60ca9:     public void testIndexRepeatFillClearIncrementingPageReuse() throws Exception {
1:81c167b:         pf = new PageFile(getDirectory(), getClass().getName());
1:8e60ca9:         pf.setPageSize(4*1024);
1:8e60ca9:         pf.load();
1:8e60ca9: 
1:8e60ca9:         tx = pf.tx();
1:8e60ca9:         long id = tx.allocate().getPageId();
1:8e60ca9: 
1:8e60ca9:         BTreeIndex<Long, String> test = new BTreeIndex<Long, String>(pf, id);
1:8e60ca9:         test.setKeyMarshaller(LongMarshaller.INSTANCE);
1:8e60ca9:         test.setValueMarshaller(StringMarshaller.INSTANCE);
1:8e60ca9:         test.load(tx);
1:8e60ca9:         tx.commit();
1:8e60ca9: 
1:8e60ca9:         final int count = 5000;
1:8e60ca9:         final int reps = 2;
1:8e60ca9:         final long[] diffs = new long[reps];
1:8e60ca9:         long keyVal = 0;
1:8e60ca9:         final String payload = new String(new byte[50]);
1:8e60ca9: 
1:8e60ca9:         LOG.info("PF diff:" + (pf.getPageCount() - pf.getFreePageCount()) + " pc:" + pf.getPageCount() + " f:" + pf.getFreePageCount() );
1:8e60ca9: 
1:8e60ca9:         for (int i=0; i<reps; i++) {
1:8e60ca9: 
1:8e60ca9:             for (int j = 0; j < count; j++) {
1:8e60ca9:                 tx = pf.tx();
1:8e60ca9:                 test.put(tx, keyVal++, payload);
1:8e60ca9:                 tx.commit();
1:8e60ca9:             }
1:8e60ca9: 
1:8e60ca9:             tx = pf.tx();
1:8e60ca9:             for (long k = keyVal - count; k < keyVal; k++) {
1:8e60ca9:                 test.remove(tx, k);
1:8e60ca9:             }
1:8e60ca9:             test.clear(tx);
1:8e60ca9:             tx.commit();
1:8e60ca9:             diffs[i] = pf.getPageCount() - pf.getFreePageCount();
1:8e60ca9: 
1:8e60ca9:             LOG.info("PF diff:" + (pf.getPageCount() - pf.getFreePageCount()) + " pc:" + pf.getPageCount() + " f:" + pf.getFreePageCount());
1:8e60ca9:         }
1:8e60ca9:         for (int i=1; i<diffs.length; i++) {
1:8e60ca9:             assertEquals("diff is constant:" + Arrays.toString(diffs), diffs[0],diffs[i]);
1:8e60ca9:         }
1:8e60ca9:     }
1:8e60ca9: 
1:81c167b:     @Test(timeout=60000)
1:53b29a2:     public void testListIndexConsistancyOverTime() throws Exception {
1:53b29a2: 
1:53b29a2:         final int NUM_ITERATIONS = 50;
1:53b29a2: 
1:81c167b:         pf = new PageFile(getDirectory(), getClass().getName());
1:53b29a2:         pf.setPageSize(4*1024);
1:53b29a2:         //pf.setEnablePageCaching(false);
1:53b29a2:         pf.setWriteBatchSize(1);
1:53b29a2:         pf.load();
1:53b29a2:         tx = pf.tx();
1:53b29a2:         long id = tx.allocate().getPageId();
1:53b29a2: 
1:53b29a2:         ListIndex<String, String> test = new ListIndex<String, String>(pf, id);
1:53b29a2:         test.setKeyMarshaller(StringMarshaller.INSTANCE);
1:53b29a2:         test.setValueMarshaller(StringMarshaller.INSTANCE);
1:53b29a2:         test.load(tx);
1:53b29a2:         tx.commit();
1:53b29a2: 
1:53b29a2:         int expectedListEntries = 0;
1:53b29a2:         int nextSequenceId = 0;
1:53b29a2: 
1:53b29a2:         LOG.info("Loading up the ListIndex with "+NUM_ITERATIONS+" entires and sparsely populating the sequences.");
1:53b29a2: 
1:53b29a2:         for (int i = 0; i < NUM_ITERATIONS; ++i) {
1:53b29a2:             test.add(tx, String.valueOf(expectedListEntries++), new String("AA"));
1:53b29a2: 
1:53b29a2:             for (int j = 0; j < expectedListEntries; j++) {
1:53b29a2: 
1:53b29a2:                 String sequenceSet = test.get(tx, String.valueOf(j));
1:53b29a2: 
1:53b29a2:                 int startSequenceId = nextSequenceId;
1:53b29a2:                 for (int ix = 0; ix < NUM_ITERATIONS; ix++) {
1:53b29a2:                     sequenceSet.concat(String.valueOf(nextSequenceId++));
1:53b29a2:                     test.put(tx, String.valueOf(j), sequenceSet);
1:53b29a2:                 }
1:53b29a2: 
1:53b29a2:                 sequenceSet = test.get(tx, String.valueOf(j));
1:53b29a2: 
1:53b29a2:                 for (int ix = 0; ix < NUM_ITERATIONS - 1; ix++) {
1:53b29a2:                     //sequenceSet.remove(startSequenceId++);
1:53b29a2:                     test.put(tx, String.valueOf(j), String.valueOf(j));
1:53b29a2:                 }
1:53b29a2:             }
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         exerciseAnotherIndex(tx);
1:53b29a2:         LOG.info("Checking if Index has the expected number of entries.");
1:53b29a2: 
1:53b29a2:         for (int i = 0; i < NUM_ITERATIONS; ++i) {
1:53b29a2:             assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));
1:53b29a2:             assertNotNull("List contents of Key["+i+"] should not be null", test.get(tx, String.valueOf(i)));
1:53b29a2:         }
1:53b29a2: 
1:53b29a2:         LOG.info("Index has the expected number of entries.");
1:53b29a2: 
1:53b29a2:         assertEquals(expectedListEntries, test.size());
1:53b29a2: 
1:53b29a2:         for (int i = 0; i < NUM_ITERATIONS; ++i) {
1:53b29a2:             LOG.debug("Size of ListIndex before removal of entry ["+i+"] is: " + test.size());
1:53b29a2: 
1:53b29a2:             assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));
1:53b29a2:             assertNotNull("List contents of Key["+i+"] should not be null", test.remove(tx, String.valueOf(i)));
1:53b29a2:             LOG.debug("Size of ListIndex after removal of entry ["+i+"] is: " + test.size());
1:53b29a2: 
1:53b29a2:             assertEquals(expectedListEntries - (i + 1), test.size());
1:53b29a2:         }
1:53b29a2:     }
1:53b29a2: 
1:456a2ba:     void doInsertReverse(int count) throws Exception {
1:456a2ba:         for (int i = count-1; i >= 0; i--) {
1:456a2ba:             index.put(tx, key(i), (long)i);
1:456a2ba:             tx.commit();
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba:     /**
1:456a2ba:      * Overriding so that this generates keys that are the worst case for the BTree. Keys that
1:81c167b:      * always insert to the end of the BTree.
1:456a2ba:      */
1:456a2ba:     @Override
1:456a2ba:     protected String key(int i) {
1:456a2ba:         return "key:"+nf.format(i);
1:456a2ba:     }
1:53b29a2: 
1:8d5f07b:     static class HashSetStringMarshaller extends VariableMarshaller<HashSet<String>> {
1:8d5f07b:         final static HashSetStringMarshaller INSTANCE = new HashSetStringMarshaller();
4:d1e7d69: 
1:81c167b:         @Override
1:94b9d55:         public void writePayload(HashSet<String> object, DataOutput dataOut) throws IOException {
1:8d5f07b:             ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:8d5f07b:             ObjectOutputStream oout = new ObjectOutputStream(baos);
1:8d5f07b:             oout.writeObject(object);
1:8d5f07b:             oout.flush();
1:8d5f07b:             oout.close();
1:8d5f07b:             byte[] data = baos.toByteArray();
1:8d5f07b:             dataOut.writeInt(data.length);
1:8d5f07b:             dataOut.write(data);
1:456a2ba:         }
1:d1e7d69: 
1:81c167b:         @Override
1:94b9d55:         public HashSet<String> readPayload(DataInput dataIn) throws IOException {
1:8d5f07b:             int dataLen = dataIn.readInt();
1:8d5f07b:             byte[] data = new byte[dataLen];
1:8d5f07b:             dataIn.readFully(data);
1:8d5f07b:             ByteArrayInputStream bais = new ByteArrayInputStream(data);
1:8d5f07b:             ObjectInputStream oin = new ObjectInputStream(bais);
1:8d5f07b:             try {
1:8d5f07b:                 return (HashSet<String>) oin.readObject();
1:8d5f07b:             } catch (ClassNotFoundException cfe) {
1:8d5f07b:                 IOException ioe = new IOException("Failed to read HashSet<String>: " + cfe);
1:8d5f07b:                 ioe.initCause(cfe);
1:8d5f07b:                 throw ioe;
1:8d5f07b:             }
1:8d5f07b:         }
1:8d5f07b:     }
1:530ab04: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:27e11a3
/////////////////////////////////////////////////////////////////////////
1:         final int count = 1000;
commit:54e2e3b
/////////////////////////////////////////////////////////////////////////
1:     public void testLimitedIteration() throws Exception {
1:         createPageFileAndIndex(500);
1:         BTreeIndex<String,Long> index = ((BTreeIndex<String,Long>)this.index);
1:         this.index.load(tx);
1:         tx.commit();
1: 
1:         // Insert in reverse order..
1:         doInsertReverse(1000);
1: 
1:         this.index.unload(tx);
1:         tx.commit();
1:         this.index.load(tx);
1:         tx.commit();
1: 
1:         // BTree should iterate it in sorted order up to limit
1:         int counter=0;
1:         for (Iterator<Map.Entry<String,Long>> i = index.iterator(tx, key(0), key(500)); i.hasNext();) {
1:             Map.Entry<String,Long> entry = i.next();
1:             assertEquals(key(counter),entry.getKey());
1:             assertEquals(counter,(long)entry.getValue());
1:             counter++;
1:         }
1: 
1:         assertEquals("got to 500", 500, counter);
1:         this.index.unload(tx);
1:         tx.commit();
1:     }
1: 
1:     @Test(timeout=60000)
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:94b9d55
/////////////////////////////////////////////////////////////////////////
1:             public boolean isInterestedInKeysBetween(String first, String second) {
1:             public void visit(List<String> keys, List<Long> values) {
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=900000)
/////////////////////////////////////////////////////////////////////////
1:         public void writePayload(HashSet<String> object, DataOutput dataOut) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:         public HashSet<String> readPayload(DataInput dataIn) throws IOException {
commit:81c167b
/////////////////////////////////////////////////////////////////////////
1: import org.junit.Test;
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1:      * Yeah, the current implementation does NOT try to balance the tree.  Here is
1:      * a test case showing that it gets out of balance.
1:      *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test(timeout=60000)
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=60000)
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:             Map.Entry<String,Long> entry = i.next();
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test(timeout=60000)
1: 
1: 
1: 
1:             @Override
0: 			public boolean isInterestedInKeysBetween(String first, String second) {
1:             @Override
0: 			public void visit(List<String> keys, List<Long> values) {
1: 
1:     @Test(timeout=60000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=300000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=60000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=60000)
1:         pf = new PageFile(getDirectory(), getClass().getName());
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=60000)
1:         pf = new PageFile(getDirectory(), getClass().getName());
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=60000)
1:         pf = new PageFile(getDirectory(), getClass().getName());
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=60000)
1:         pf = new PageFile(getDirectory(), getClass().getName());
/////////////////////////////////////////////////////////////////////////
1:      * always insert to the end of the BTree.
/////////////////////////////////////////////////////////////////////////
1:         @Override
0: 		public void writePayload(HashSet<String> object, DataOutput dataOut) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:         @Override
0: 		public HashSet<String> readPayload(DataInput dataIn) throws IOException {
commit:6010bd3
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:1aab71b
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.store.kahadb.disk.index;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.kahadb.disk.page.PageFile;
1: import org.apache.activemq.store.kahadb.disk.page.Transaction;
1: import org.apache.activemq.store.kahadb.disk.util.LongMarshaller;
1: import org.apache.activemq.store.kahadb.disk.util.StringMarshaller;
1: import org.apache.activemq.store.kahadb.disk.util.VariableMarshaller;
commit:715010a
commit:456a2ba
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: package org.apache.kahadb.index;
1: 
1: import java.io.PrintWriter;
1: import java.text.NumberFormat;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Map;
1: 
0: import org.apache.kahadb.index.BTreeIndex;
0: import org.apache.kahadb.index.Index;
0: import org.apache.kahadb.util.LongMarshaller;
0: import org.apache.kahadb.util.StringMarshaller;
1: 
1: public class BTreeIndexTest extends IndexTestSupport {
1: 
1:     private NumberFormat nf;
1: 
1:     @Override
1:     protected void setUp() throws Exception {
1:         super.setUp();
1:         nf = NumberFormat.getIntegerInstance();
1:         nf.setMinimumIntegerDigits(6);
1:         nf.setGroupingUsed(false);
1:     }
1:     
1:     @Override
1:     protected Index<String, Long> createIndex() throws Exception {
1:         
1:         long id = tx.allocate().getPageId();
1:         tx.commit();
1: 
1:         BTreeIndex<String, Long> index = new BTreeIndex<String,Long>(pf, id);
1:         index.setKeyMarshaller(StringMarshaller.INSTANCE);
1:         index.setValueMarshaller(LongMarshaller.INSTANCE);
1:         
1:         return index;
1:     }
1: 
1:     /**
0:      * Yeah, the current implementation does NOT try to balance the tree.  Here is 
0:      * a test case showing that it gets out of balance.  
1:      * 
1:      * @throws Exception
1:      */
1:     public void disabled_testTreeBalancing() throws Exception {
1:         createPageFileAndIndex(100);
1: 
1:         BTreeIndex index = ((BTreeIndex)this.index);
1:         this.index.load(tx);
1:         tx.commit();
1:         
1:         doInsert(50);
1:         
1:         int minLeafDepth = index.getMinLeafDepth(tx);
1:         int maxLeafDepth = index.getMaxLeafDepth(tx);
1:         assertTrue("Tree is balanced", maxLeafDepth-minLeafDepth <= 1);
1: 
1:         // Remove some of the data
1:         doRemove(16);
1:         minLeafDepth = index.getMinLeafDepth(tx);
1:         maxLeafDepth = index.getMaxLeafDepth(tx);
1: 
1:         System.out.println( "min:"+minLeafDepth );
1:         System.out.println( "max:"+maxLeafDepth );
1:         index.printStructure(tx, new PrintWriter(System.out));
1: 
1:         assertTrue("Tree is balanced", maxLeafDepth-minLeafDepth <= 1);
1: 
1:         this.index.unload(tx);
1:     }
1:     
1:     public void testPruning() throws Exception {
1:         createPageFileAndIndex(100);
1: 
1:         BTreeIndex<String,Long> index = ((BTreeIndex<String,Long>)this.index);
1: 
1:         this.index.load(tx);
1:         tx.commit();
1:      
1:         int minLeafDepth = index.getMinLeafDepth(tx);
1:         int maxLeafDepth = index.getMaxLeafDepth(tx);
1:         assertEquals(1, minLeafDepth);
1:         assertEquals(1, maxLeafDepth);
1:         
1:         doInsert(1000);
1:         
1:         minLeafDepth = index.getMinLeafDepth(tx);
1:         maxLeafDepth = index.getMaxLeafDepth(tx);
1:         assertTrue("Depth of tree grew", minLeafDepth > 1);
1:         assertTrue("Depth of tree grew", maxLeafDepth > 1);
1: 
1:         // Remove the data.
1:         doRemove(1000);
1:         minLeafDepth = index.getMinLeafDepth(tx);
1:         maxLeafDepth = index.getMaxLeafDepth(tx);
1: 
1:         assertEquals(1, minLeafDepth);
1:         assertEquals(1, maxLeafDepth);
1: 
1:         this.index.unload(tx);
1:         tx.commit();
1:     }
1: 
1:     public void testIteration() throws Exception {
1:         createPageFileAndIndex(100);
1:         BTreeIndex<String,Long> index = ((BTreeIndex<String,Long>)this.index);
1:         this.index.load(tx);
1:         tx.commit();
1:           
1:         // Insert in reverse order..
1:         doInsertReverse(1000);
1:         
1:         this.index.unload(tx);
1:         tx.commit();
1:         this.index.load(tx);
1:         tx.commit();
1: 
1:         // BTree should iterate it in sorted order.
1:         int counter=0;
1:         for (Iterator<Map.Entry<String,Long>> i = index.iterator(tx); i.hasNext();) {
0:             Map.Entry<String,Long> entry = (Map.Entry<String,Long>)i.next();
1:             assertEquals(key(counter),entry.getKey());
1:             assertEquals(counter,(long)entry.getValue());
1:             counter++;
1:         }
1: 
1:         this.index.unload(tx);
1:         tx.commit();
1:     }
1:     
1:     
1:     public void testVisitor() throws Exception {
1:         createPageFileAndIndex(100);
1:         BTreeIndex<String,Long> index = ((BTreeIndex<String,Long>)this.index);
1:         this.index.load(tx);
1:         tx.commit();
1:           
1:         // Insert in reverse order..
1:         doInsert(1000);
1:         
1:         this.index.unload(tx);
1:         tx.commit();
1:         this.index.load(tx);
1:         tx.commit();
1: 
1:         // BTree should iterate it in sorted order.
1:         
1:         index.visit(tx, new BTreeVisitor<String, Long>(){
0:             public boolean isInterestedInKeysBetween(String first, String second) {
1:                 return true;
1:             }
0:             public void visit(List<String> keys, List<Long> values) {
1:             }
1:         });
1:         
1: 
1:         this.index.unload(tx);
1:         tx.commit();
1:     }
1:     
1:     void doInsertReverse(int count) throws Exception {
1:         for (int i = count-1; i >= 0; i--) {
1:             index.put(tx, key(i), (long)i);
1:             tx.commit();
1:         }
1:     }
1:     /**
1:      * Overriding so that this generates keys that are the worst case for the BTree. Keys that
0:      * always insert to the end of the BTree.  
1:      */
1:     @Override
1:     protected String key(int i) {
1:         return "key:"+nf.format(i);
1:     }
1: }
author:Gary Tully
-------------------------------------------------------------------------------
commit:8e60ca9
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
1:     public void testIndexRepeatFillClearIncrementingPageReuse() throws Exception {
0:         pf = new PageFile(directory, getClass().getName());
1:         pf.setPageSize(4*1024);
1:         pf.load();
1: 
1:         tx = pf.tx();
1:         long id = tx.allocate().getPageId();
1: 
1:         BTreeIndex<Long, String> test = new BTreeIndex<Long, String>(pf, id);
1:         test.setKeyMarshaller(LongMarshaller.INSTANCE);
1:         test.setValueMarshaller(StringMarshaller.INSTANCE);
1:         test.load(tx);
1:         tx.commit();
1: 
1:         final int count = 5000;
1:         final int reps = 2;
1:         final long[] diffs = new long[reps];
1:         long keyVal = 0;
1:         final String payload = new String(new byte[50]);
1: 
1:         LOG.info("PF diff:" + (pf.getPageCount() - pf.getFreePageCount()) + " pc:" + pf.getPageCount() + " f:" + pf.getFreePageCount() );
1: 
1:         for (int i=0; i<reps; i++) {
1: 
1:             for (int j = 0; j < count; j++) {
1:                 tx = pf.tx();
1:                 test.put(tx, keyVal++, payload);
1:                 tx.commit();
1:             }
1: 
1:             tx = pf.tx();
1:             for (long k = keyVal - count; k < keyVal; k++) {
1:                 test.remove(tx, k);
1:             }
1:             test.clear(tx);
1:             tx.commit();
1:             diffs[i] = pf.getPageCount() - pf.getFreePageCount();
1: 
1:             LOG.info("PF diff:" + (pf.getPageCount() - pf.getFreePageCount()) + " pc:" + pf.getPageCount() + " f:" + pf.getFreePageCount());
1:         }
1:         for (int i=1; i<diffs.length; i++) {
1:             assertEquals("diff is constant:" + Arrays.toString(diffs), diffs[0],diffs[i]);
1:         }
1:     }
1: 
commit:53b29a2
/////////////////////////////////////////////////////////////////////////
0: import org.apache.kahadb.page.Transaction;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(BTreeIndexTest.class);
/////////////////////////////////////////////////////////////////////////
1:         createPageFileAndIndex(500);
/////////////////////////////////////////////////////////////////////////
1:         exerciseAnotherIndex(tx);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         long id = tx.allocate().getPageId();
1:         BTreeIndex<String, String> sindex = new BTreeIndex<String,String>(pf, id);
1:         sindex.setKeyMarshaller(StringMarshaller.INSTANCE);
1:         sindex.setValueMarshaller(StringMarshaller.INSTANCE);
1:         sindex.load(tx);
1: 
1:         tx.commit();
1: 
1:         final int count = 5000;
1: 
1:         String payload = new String(new byte[2]);
1:         for (int i = 0; i < count; i++) {
1:             index.put(tx, key(i), (long)i);
1:             sindex.put(tx, key(i), String.valueOf(i) + payload);
1:             tx.commit();
1:         }
1: 
1:         while (!index.isEmpty(tx) || !sindex.isEmpty(tx)) {
1:                 sindex.remove(tx, key(i));
1:             } catch (Exception e) {
1:                 e.printStackTrace();
1:                 fail("unexpected exception on " + i + ", prev: " + prev + ", ex: " + e);
1:             }
1:         }
1:     }
1: 
1:     public void testRandomAddRemove() throws Exception {
1: 
1:         createPageFileAndIndex(1024);
1:         BTreeIndex<String,Long> index = ((BTreeIndex<String,Long>)this.index);
1:         this.index.load(tx);
1: 
1:         long id = tx.allocate().getPageId();
1:         tx.commit();
1: 
1:         BTreeIndex<String, String> sindex = new BTreeIndex<String,String>(pf, id);
1:         sindex.setKeyMarshaller(StringMarshaller.INSTANCE);
1:         sindex.setValueMarshaller(StringMarshaller.INSTANCE);
1:         sindex.load(tx);
1: 
1:         tx.commit();
1: 
1:         Random rand = new Random(System.currentTimeMillis());
0:         final int count = 50000;
1: 
1:         String payload = new String(new byte[200]);
1:         for (int i = 0; i < count; i++) {
1:             int insertIndex = rand.nextInt(count);
1:             index.put(tx, key(insertIndex), (long)insertIndex);
1:             sindex.put(tx, key(insertIndex), String.valueOf(insertIndex) + payload);
1:             tx.commit();
1:         }
1: 
1: 
1:         int i = 0, prev = 0;
1:         while (!index.isEmpty(tx) || !sindex.isEmpty(tx)) {
1:             prev = i;
1:             i = rand.nextInt(count);
1:             try {
1:                 index.remove(tx, key(i));
1:                 sindex.remove(tx, key(i));
/////////////////////////////////////////////////////////////////////////
1: 
1:         tx.commit();
1:         index.clear(tx);
1:         tx.commit();
1: 
1:         doInsert(count);
1: 
1:         Iterator<Map.Entry<String, Long>> iterator = index.iterator(tx, key(1345));
1:         while (iterator.hasNext()) {
1:             Map.Entry<String, Long> val = iterator.next();
1:         }
1: 
1:         doRemoveBackwards(666);
1:         Map.Entry<String, Long> first = index.getFirst(tx);
1:         assertEquals(first.getValue(), Long.valueOf(666L));
1: 
1:         for (int i=0; i<2000; i++) {
1:             Map.Entry<String, Long> last = index.getLast(tx);
1:             index.remove(tx, last.getKey());
1:             tx.commit();
1:         }
1: 
1:         exerciseAnotherIndex(tx);
1: 
1:         iterator = index.iterator(tx, key(100));
1:         while (iterator.hasNext()) {
1:             Map.Entry<String, Long> val = iterator.next();
1:         }
1: 
1:         Map.Entry<String, Long> last = index.getLast(tx);
1:         assertEquals(last.getValue(), Long.valueOf(1999L));
1:         index.clear(tx);
1:         assertNull(index.getLast(tx));
1:         //pf.setEnablePageCaching(false);
/////////////////////////////////////////////////////////////////////////
1:             assertTrue(test.containsKey(tx, i));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         exerciseAnotherIndex(tx);
1: 
1:             assertTrue(test.containsKey(tx, i));
1:     public void exerciseAnotherIndex(Transaction tx) throws Exception {
1:         long id = tx.allocate().getPageId();
1: 
1:         ListIndex<String, String> test = new ListIndex<String, String>(pf, id);
1:         test.setKeyMarshaller(StringMarshaller.INSTANCE);
1:         test.setValueMarshaller(StringMarshaller.INSTANCE);
1:         test.load(tx);
1:         tx.commit();
1: 
1:         final int count = 10000;
1: 
1:         String payload = new String(new byte[1]);
1:         for (int i = 0; i < count; i++) {
1:             test.put(tx, key(i), String.valueOf(i) + payload);
1:         }
1:         tx.commit();
1: 
1:         test.clear(tx);
1:         tx.commit();
1:     }
1: 
1:     public void testListIndexConsistancyOverTime() throws Exception {
1: 
1:         final int NUM_ITERATIONS = 50;
1: 
0:         pf = new PageFile(directory, getClass().getName());
1:         pf.setPageSize(4*1024);
1:         //pf.setEnablePageCaching(false);
1:         pf.setWriteBatchSize(1);
1:         pf.load();
1:         tx = pf.tx();
1:         long id = tx.allocate().getPageId();
1: 
1:         ListIndex<String, String> test = new ListIndex<String, String>(pf, id);
1:         test.setKeyMarshaller(StringMarshaller.INSTANCE);
1:         test.setValueMarshaller(StringMarshaller.INSTANCE);
1:         test.load(tx);
1:         tx.commit();
1: 
1:         int expectedListEntries = 0;
1:         int nextSequenceId = 0;
1: 
1:         LOG.info("Loading up the ListIndex with "+NUM_ITERATIONS+" entires and sparsely populating the sequences.");
1: 
1:         for (int i = 0; i < NUM_ITERATIONS; ++i) {
1:             test.add(tx, String.valueOf(expectedListEntries++), new String("AA"));
1: 
1:             for (int j = 0; j < expectedListEntries; j++) {
1: 
1:                 String sequenceSet = test.get(tx, String.valueOf(j));
1: 
1:                 int startSequenceId = nextSequenceId;
1:                 for (int ix = 0; ix < NUM_ITERATIONS; ix++) {
1:                     sequenceSet.concat(String.valueOf(nextSequenceId++));
1:                     test.put(tx, String.valueOf(j), sequenceSet);
1:                 }
1: 
1:                 sequenceSet = test.get(tx, String.valueOf(j));
1: 
1:                 for (int ix = 0; ix < NUM_ITERATIONS - 1; ix++) {
1:                     //sequenceSet.remove(startSequenceId++);
1:                     test.put(tx, String.valueOf(j), String.valueOf(j));
1:                 }
1:             }
1:         }
1: 
1:         exerciseAnotherIndex(tx);
1:         LOG.info("Checking if Index has the expected number of entries.");
1: 
1:         for (int i = 0; i < NUM_ITERATIONS; ++i) {
1:             assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));
1:             assertNotNull("List contents of Key["+i+"] should not be null", test.get(tx, String.valueOf(i)));
1:         }
1: 
1:         LOG.info("Index has the expected number of entries.");
1: 
1:         assertEquals(expectedListEntries, test.size());
1: 
1:         for (int i = 0; i < NUM_ITERATIONS; ++i) {
1:             LOG.debug("Size of ListIndex before removal of entry ["+i+"] is: " + test.size());
1: 
1:             assertTrue("List should contain Key["+i+"]",test.containsKey(tx, String.valueOf(i)));
1:             assertNotNull("List contents of Key["+i+"] should not be null", test.remove(tx, String.valueOf(i)));
1:             LOG.debug("Size of ListIndex after removal of entry ["+i+"] is: " + test.size());
1: 
1:             assertEquals(expectedListEntries - (i + 1), test.size());
1:         }
1:     }
1: 
commit:d1e7d69
/////////////////////////////////////////////////////////////////////////
0: import org.apache.kahadb.page.PageFile;
/////////////////////////////////////////////////////////////////////////
1:     public void testLargeValue() throws Exception {
1:         //System.setProperty("maxKahaDBTxSize", "" + (1024*1024*1024));
0:         pf = new PageFile(directory, getClass().getName());
1:         pf.setPageSize(4*1024);
0:         pf.setEnablePageCaching(false);
1:         pf.load();
1:         tx = pf.tx();
/////////////////////////////////////////////////////////////////////////
1:         String val = new String(new byte[1024]);
1:         final long numMessages = 10;
1:         final int numConsumers = 200;
/////////////////////////////////////////////////////////////////////////
1:         tx.commit();
1:         tx =  pf.tx();
1:         for (long i=0; i<numMessages; i++) {
1:             HashSet<String> hs = new HashSet<String>();
1:             for (int j=numConsumers; j<numConsumers*2;j++) {
1:                 hs.add(val + "SOME TEXT" + j);
1:             }
1:             test.put(tx, i, hs);
1:         }
1:         tx.commit();
1:         tx =  pf.tx();
1:     public void testLargeValueOverflow() throws Exception {
0:         pf = new PageFile(directory, getClass().getName());
1:         pf.setPageSize(4*1024);
0:         pf.setEnablePageCaching(false);
1:         pf.setWriteBatchSize(1);
1:         pf.load();
1:         tx = pf.tx();
1:         long id = tx.allocate().getPageId();
1: 
1:         BTreeIndex<Long, String> test = new BTreeIndex<Long, String>(pf, id);
1:         test.setKeyMarshaller(LongMarshaller.INSTANCE);
1:         test.setValueMarshaller(StringMarshaller.INSTANCE);
1:         test.load(tx);
1:         tx.commit();
1: 
1:         final int stringSize = 6*1024;
1:         tx =  pf.tx();
1:         String val = new String(new byte[stringSize]);
1:         final long numMessages = 1;
1: 
1:         for (long i=0; i<numMessages; i++) {
1:             test.put(tx, i, val);
1:         }
1:         tx.commit();
1: 
1:         tx =  pf.tx();
1:         for (long i=0; i<numMessages; i++) {
1:             String s = test.get(tx, i);
1:             assertEquals("len is as expected", stringSize, s.length());
1:         }
1:         tx.commit();
1:     }
1: 
commit:8d5f07b
/////////////////////////////////////////////////////////////////////////
1: import java.io.ByteArrayInputStream;
1: import java.io.ByteArrayOutputStream;
1: import java.io.DataInput;
1: import java.io.DataOutput;
1: import java.io.IOException;
1: import java.io.ObjectInputStream;
1: import java.io.ObjectOutputStream;
1: import java.util.HashSet;
0: import org.apache.kahadb.util.VariableMarshaller;
/////////////////////////////////////////////////////////////////////////
0: 
0:     public void x_testLargeValue() throws Exception {
0:         createPageFileAndIndex(4*1024);
1:         long id = tx.allocate().getPageId();
1:         tx.commit();
0: 
1:         BTreeIndex<Long, HashSet<String>> test = new BTreeIndex<Long, HashSet<String>>(pf, id);
1:         test.setKeyMarshaller(LongMarshaller.INSTANCE);
1:         test.setValueMarshaller(HashSetStringMarshaller.INSTANCE);
1:         test.load(tx);
1:         tx.commit();
0: 
1:         tx =  pf.tx();
0:         String val = new String(new byte[93]);
0:         final long numMessages = 2000;
0:         final int numConsumers = 10000;
0: 
1:         for (long i=0; i<numMessages; i++) {
1:             HashSet<String> hs = new HashSet<String>();
1:             for (int j=0; j<numConsumers;j++) {
1:                 hs.add(val + "SOME TEXT" + j);
1:             }
1:             test.put(tx, i, hs);
1:         }
0: 
1:         for (long i=0; i<numMessages; i++) {
1:             test.get(tx, i);
1:         }
1:         tx.commit();
1:     }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:     static class HashSetStringMarshaller extends VariableMarshaller<HashSet<String>> {
1:         final static HashSetStringMarshaller INSTANCE = new HashSetStringMarshaller();
0: 
0:         public void writePayload(HashSet<String> object, DataOutput dataOut) throws IOException {
1:             ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:             ObjectOutputStream oout = new ObjectOutputStream(baos);
1:             oout.writeObject(object);
1:             oout.flush();
1:             oout.close();
1:             byte[] data = baos.toByteArray();
1:             dataOut.writeInt(data.length);
1:             dataOut.write(data);
1:         }
0: 
0:         public HashSet<String> readPayload(DataInput dataIn) throws IOException {
1:             int dataLen = dataIn.readInt();
1:             byte[] data = new byte[dataLen];
1:             dataIn.readFully(data);
1:             ByteArrayInputStream bais = new ByteArrayInputStream(data);
1:             ObjectInputStream oin = new ObjectInputStream(bais);
1:             try {
1:                 return (HashSet<String>) oin.readObject();
1:             } catch (ClassNotFoundException cfe) {
1:                 IOException ioe = new IOException("Failed to read HashSet<String>: " + cfe);
1:                 ioe.initCause(cfe);
1:                 throw ioe;
1:             }
1:         }
1:     }
commit:530ab04
/////////////////////////////////////////////////////////////////////////
1: import java.util.Random;
/////////////////////////////////////////////////////////////////////////
0: 
0: 
1:     public void testRandomRemove() throws Exception {
0: 
1:         createPageFileAndIndex(100);
1:         BTreeIndex<String,Long> index = ((BTreeIndex<String,Long>)this.index);
1:         this.index.load(tx);
1:         tx.commit();
0: 
1:         final int count = 4000;
1:         doInsert(count);
0: 
1:         Random rand = new Random(System.currentTimeMillis());
1:         int i = 0, prev = 0;
0:         while (!index.isEmpty(tx)) {
1:             prev = i;
1:             i = rand.nextInt(count);
1:             try {
1:                 index.remove(tx, key(i));
1:             } catch (Exception e) {
1:                 e.printStackTrace();
1:                 fail("unexpected exception on " + i + ", prev: " + prev + ", ex: " + e);
1:             }
1:         }
1:     }
0: 
1:     public void testRemovePattern() throws Exception {
1:         createPageFileAndIndex(100);
1:         BTreeIndex<String,Long> index = ((BTreeIndex<String,Long>)this.index);
1:         this.index.load(tx);
1:         tx.commit();
0: 
1:         final int count = 4000;
1:         doInsert(count);
0: 
1:         index.remove(tx, key(3697));
1:         index.remove(tx, key(1566));
1:     }
============================================================================