2:40a7d3b: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:f888cc2:  * <p/>
1:f888cc2:  * http://www.apache.org/licenses/LICENSE-2.0
1:f888cc2:  * <p/>
1:40a7d3b:  * Unless required by applicable law or agreed to in writing, software
1:40a7d3b:  * distributed under the License is distributed on an "AS IS" BASIS,
1:40a7d3b:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:40a7d3b:  * See the License for the specific language governing permissions and
1:40a7d3b:  * limitations under the License.
2:40a7d3b:  */
1:b71b349: 
1:f1a084e: package org.apache.activemq.web;
1:7504bc7: 
1:88d5857: import org.apache.activemq.MessageAvailableConsumer;
1:88d5857: import org.apache.activemq.MessageAvailableListener;
1:e8a06c4: import org.eclipse.jetty.continuation.Continuation;
1:e8a06c4: import org.eclipse.jetty.continuation.ContinuationSupport;
1:7504bc7: import org.slf4j.Logger;
1:7504bc7: import org.slf4j.LoggerFactory;
1:2b2b3e8: 
1:f888cc2: import javax.jms.*;
1:f888cc2: import javax.servlet.ServletConfig;
1:f888cc2: import javax.servlet.ServletException;
1:f888cc2: import javax.servlet.http.HttpServletRequest;
1:f888cc2: import javax.servlet.http.HttpServletResponse;
1:f888cc2: import java.io.IOException;
1:f888cc2: import java.io.PrintWriter;
1:f888cc2: import java.util.Enumeration;
1:f888cc2: import java.util.HashMap;
1:f888cc2: import java.util.HashSet;
1:f888cc2: 
1:40a7d3b: /**
1:40a7d3b:  * A servlet for sending and receiving messages to/from JMS destinations using
1:a2ede97:  * HTTP POST for sending and HTTP GET for receiving.
1:a2ede97:  * <p/>
1:a2ede97:  * You can specify the destination and whether it is a topic or queue via
1:a2ede97:  * configuration details on the servlet or as request parameters.
1:a2ede97:  * <p/>
1:a2ede97:  * For reading messages you can specify a readTimeout parameter to determine how
1:a2ede97:  * long the servlet should block for.
1:a2ede97:  *
1:a2ede97:  * One thing to keep in mind with this solution - due to the nature of REST,
1:a2ede97:  * there will always be a chance of losing messages. Consider what happens when
1:a2ede97:  * a message is retrieved from the broker but the web call is interrupted before
1:a2ede97:  * the client receives the message in the response - the message is lost.
1:40a7d3b:  */
1:40a7d3b: public class MessageServlet extends MessageServletSupport {
1:c980168: 
1:b13c8c1:     // its a bit pita that this servlet got intermixed with jetty continuation/rest
1:b13c8c1:     // instead of creating a special for that. We should have kept a simple servlet
1:b13c8c1:     // for good old fashioned request/response blocked communication.
1:b13c8c1: 
1:c980168:     private static final long serialVersionUID = 8737914695188481219L;
1:c980168: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(MessageServlet.class);
1:540dd5c: 
1:de49f2e:     private final String readTimeoutParameter = "readTimeout";
1:a2ede97:     private final String readTimeoutRequestAtt = "xamqReadDeadline";
1:a2ede97:     private final String oneShotParameter = "oneShot";
1:40a7d3b:     private long defaultReadTimeout = -1;
1:40a7d3b:     private long maximumReadTimeout = 20000;
1:2b2b3e8:     private long requestTimeout = 1000;
1:a3e3d48:     private String defaultContentType = "application/xml";
1:7504bc7: 
1:de49f2e:     private final HashMap<String, WebClient> clients = new HashMap<String, WebClient>();
1:a2ede97:     private final HashSet<MessageAvailableConsumer> activeConsumers = new HashSet<MessageAvailableConsumer>();
1:2b2b3e8: 
1:de49f2e:     @Override
1:40a7d3b:     public void init() throws ServletException {
1:40a7d3b:         ServletConfig servletConfig = getServletConfig();
1:40a7d3b:         String name = servletConfig.getInitParameter("defaultReadTimeout");
2:40a7d3b:         if (name != null) {
1:40a7d3b:             defaultReadTimeout = asLong(name);
1:540dd5c:         }
1:40a7d3b:         name = servletConfig.getInitParameter("maximumReadTimeout");
1:40a7d3b:         if (name != null) {
1:40a7d3b:             maximumReadTimeout = asLong(name);
1:2b2b3e8:         }
1:2b2b3e8:         name = servletConfig.getInitParameter("replyTimeout");
1:2b2b3e8:         if (name != null) {
1:7504bc7:             requestTimeout = asLong(name);
1:7504bc7:         }
1:51927e6:         name = servletConfig.getInitParameter("defaultContentType");
1:51927e6:         if (name != null) {
1:51927e6:             defaultContentType = name;
1:51927e6:         }
1:2b2b3e8:     }
1:7504bc7: 
1:829787a:     /**
1:40a7d3b:      * Sends a message to a destination
1:7504bc7:      *
2:40a7d3b:      * @param request
2:40a7d3b:      * @param response
2:40a7d3b:      * @throws ServletException
2:40a7d3b:      * @throws IOException
1:40a7d3b:      */
1:de49f2e:     @Override
1:40a7d3b:     protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
1:40a7d3b:         // lets turn the HTTP post into a JMS Message
1:2b9c59c:         try {
1:3c734ce: 
1:3c734ce:             String action = request.getParameter("action");
1:3c734ce:             String clientId = request.getParameter("clientId");
1:3c734ce:             if (action != null && clientId != null && action.equals("unsubscribe")) {
1:3c734ce:                 LOG.info("Unsubscribing client " + clientId);
1:3c734ce:                 WebClient client = getWebClient(request);
1:3c734ce:                 client.close();
1:3c734ce:                 clients.remove(clientId);
1:3c734ce:                 return;
1:3c734ce:             }
1:3c734ce: 
1:2b2b3e8:             WebClient client = getWebClient(request);
1:c980168: 
1:40a7d3b:             String text = getPostedMessageBody(request);
1:2b2b3e8: 
1:40a7d3b:             // lets create the destination from the URI?
2:40a7d3b:             Destination destination = getDestination(client, request);
1:540dd5c:             if (destination == null) {
1:4e5012c:                 throw new NoDestinationSuppliedException();
1:2b2b3e8:             }
1:2b9c59c: 
1:540dd5c:             if (LOG.isDebugEnabled()) {
1:540dd5c:                 LOG.debug("Sending message to: " + destination + " with text: " + text);
1:2b9c59c:             }
1:2b9c59c: 
1:2b2b3e8:             boolean sync = isSync(request);
1:40a7d3b:             TextMessage message = client.getSession().createTextMessage(text);
1:2b9c59c: 
1:062adbb:             appendParametersToMessage(request, message);
1:062adbb:             boolean persistent = isSendPersistent(request);
1:062adbb:             int priority = getSendPriority(request);
1:062adbb:             long timeToLive = getSendTimeToLive(request);
1:062adbb:             client.send(destination, message, persistent, priority, timeToLive);
1:2b9c59c: 
1:40a7d3b:             // lets return a unique URI for reliable messaging
1:40a7d3b:             response.setHeader("messageID", message.getJMSMessageID());
1:b71b349:             response.setStatus(HttpServletResponse.SC_OK);
1:b71b349:             response.getWriter().write("Message sent");
1:b71b349: 
1:540dd5c:         } catch (JMSException e) {
2:40a7d3b:             throw new ServletException("Could not post JMS message: " + e, e);
1:540dd5c:         }
1:540dd5c:     }
1:7504bc7: 
1:40a7d3b:     /**
1:a2ede97:      * Supports a HTTP DELETE to be equivalent of consuming a singe message
1:40a7d3b:      * from a queue
1:40a7d3b:      */
1:de49f2e:     @Override
1:40a7d3b:     protected void doDelete(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
1:c980168:         doMessages(request, response);
1:540dd5c:     }
1:2b9c59c: 
1:40a7d3b:     /**
1:a2ede97:      * Supports a HTTP DELETE to be equivalent of consuming a singe message
1:40a7d3b:      * from a queue
1:40a7d3b:      */
1:de49f2e:     @Override
1:40a7d3b:     protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
1:c980168:         doMessages(request, response);
1:540dd5c:     }
1:2b9c59c: 
1:40a7d3b:     /**
1:829787a:      * Reads a message from a destination up to some specific timeout period
1:7504bc7:      *
1:829787a:      * @param request
1:829787a:      * @param response
1:829787a:      * @throws ServletException
1:829787a:      * @throws IOException
1:829787a:      */
1:c980168:     protected void doMessages(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
1:a2ede97:         MessageAvailableConsumer consumer = null;
1:a2ede97: 
1:2b2b3e8:         try {
1:2b2b3e8:             WebClient client = getWebClient(request);
1:829787a:             Destination destination = getDestination(client, request);
1:540dd5c:             if (destination == null) {
1:4e5012c:                 throw new NoDestinationSuppliedException();
1:540dd5c:             }
1:a2ede97:             consumer = (MessageAvailableConsumer) client.getConsumer(destination, request.getHeader(WebClient.selectorName));
1:a2ede97:             Continuation continuation = ContinuationSupport.getContinuation(request);
1:a2ede97: 
1:a2ede97:             // Don't allow concurrent use of the consumer. Do make sure to allow
1:a2ede97:             // subsequent calls on continuation to use the consumer.
1:a2ede97:             if (continuation.isInitial()) {
1:a2ede97:                 synchronized (activeConsumers) {
1:a2ede97:                     if (activeConsumers.contains(consumer)) {
1:a2ede97:                         throw new ServletException("Concurrent access to consumer is not supported");
1:a2ede97:                     } else {
1:a2ede97:                         activeConsumers.add(consumer);
1:a2ede97:                     }
1:a2ede97:                 }
1:2b2b3e8:             }
1:a2ede97: 
1:a2ede97:             Message message = null;
1:a2ede97: 
1:a2ede97:             long deadline = getReadDeadline(request);
1:a2ede97:             long timeout = deadline - System.currentTimeMillis();
1:a2ede97: 
1:a2ede97:             // Set the message available listener *before* calling receive to eliminate any
1:a2ede97:             // chance of a missed notification between the time receive() completes without
1:a2ede97:             // a message and the time the listener is set.
1:a2ede97:             synchronized (consumer) {
1:a2ede97:                 Listener listener = (Listener) consumer.getAvailableListener();
1:a2ede97:                 if (listener == null) {
1:a2ede97:                     listener = new Listener(consumer);
1:a2ede97:                     consumer.setAvailableListener(listener);
1:a2ede97:                 }
1:a2ede97:             }
1:2b9c59c: 
1:540dd5c:             if (LOG.isDebugEnabled()) {
1:540dd5c:                 LOG.debug("Receiving message(s) from: " + destination + " with timeout: " + timeout);
1:2b9c59c:             }
1:2b9c59c: 
1:a2ede97:             // Look for any available messages (need a little timeout). Always
1:a2ede97:             // try at least one lookup; don't block past the deadline.
1:a2ede97:             if (timeout <= 0) {
1:a2ede97:                 message = consumer.receiveNoWait();
1:a2ede97:             } else if (timeout < 10) {
1:a2ede97:                 message = consumer.receive(timeout);
1:a2ede97:             } else {
1:a2ede97:                 message = consumer.receive(10);
1:2b9c59c:             }
1:2b9c59c: 
1:a2ede97:             if (message == null) {
1:a2ede97:                 handleContinuation(request, response, client, destination, consumer, deadline);
1:b71b349:             } else {
1:a2ede97:                 writeResponse(request, response, message);
1:a2ede97:                 closeConsumerOnOneShot(request, client, destination);
1:a2ede97: 
1:a2ede97:                 synchronized (activeConsumers) {
1:a2ede97:                     activeConsumers.remove(consumer);
1:a2ede97:                 }
1:a2ede97:             }
1:540dd5c:         } catch (JMSException e) {
1:829787a:             throw new ServletException("Could not post JMS message: " + e, e);
1:2b9c59c:         }
1:2b9c59c:     }
1:7504bc7: 
1:a2ede97:     protected void handleContinuation(HttpServletRequest request, HttpServletResponse response, WebClient client, Destination destination,
1:f888cc2:                                       MessageAvailableConsumer consumer, long deadline) {
1:a2ede97:         // Get an existing Continuation or create a new one if there are no events.
1:a2ede97:         Continuation continuation = ContinuationSupport.getContinuation(request);
1:a2ede97: 
1:a2ede97:         long timeout = deadline - System.currentTimeMillis();
1:a2ede97:         if ((continuation.isExpired()) || (timeout <= 0)) {
1:a2ede97:             // Reset the continuation on the available listener for the consumer to prevent the
1:a2ede97:             // next message receipt from being consumed without a valid, active continuation.
1:a2ede97:             synchronized (consumer) {
1:a2ede97:                 Object obj = consumer.getAvailableListener();
1:a2ede97:                 if (obj instanceof Listener) {
1:a2ede97:                     ((Listener) obj).setContinuation(null);
1:a2ede97:                 }
1:a2ede97:             }
1:a2ede97:             response.setStatus(HttpServletResponse.SC_NO_CONTENT);
1:a2ede97:             closeConsumerOnOneShot(request, client, destination);
1:a2ede97:             synchronized (activeConsumers) {
1:a2ede97:                 activeConsumers.remove(consumer);
1:a2ede97:             }
1:a2ede97:             return;
1:a2ede97:         }
1:a2ede97: 
1:a2ede97:         continuation.setTimeout(timeout);
1:a2ede97:         continuation.suspend();
1:a2ede97: 
1:a2ede97:         synchronized (consumer) {
1:a2ede97:             Listener listener = (Listener) consumer.getAvailableListener();
1:a2ede97: 
1:a2ede97:             // register this continuation with our listener.
1:a2ede97:             listener.setContinuation(continuation);
1:a2ede97:         }
1:a2ede97:     }
1:a2ede97: 
1:c980168:     protected void writeResponse(HttpServletRequest request, HttpServletResponse response, Message message) throws IOException, JMSException {
1:2b9c59c:         int messages = 0;
1:2b9c59c:         try {
1:a2ede97:             response.setHeader("Cache-Control", "no-cache, no-store, must-revalidate"); // HTTP
1:f888cc2:             // 1.1
1:a2ede97:             response.setHeader("Pragma", "no-cache"); // HTTP 1.0
1:a2ede97:             response.setDateHeader("Expires", 0);
1:f888cc2: 
1:f888cc2: 
1:f888cc2:             // Set content type as in request. This should be done before calling getWriter by specification
1:f888cc2:             String type = request.getContentType();
1:f888cc2: 
1:f888cc2:             if (type != null) {
1:f888cc2:                 response.setContentType(type);
1:f888cc2:             } else {
1:f888cc2:                 if (isXmlContent(message)) {
1:f888cc2:                     response.setContentType(defaultContentType);
1:f888cc2:                 } else {
1:f888cc2:                     response.setContentType("text/plain");
1:f888cc2:                 }
1:f888cc2:             }
1:f888cc2: 
1:2b9c59c:             // write a responds
1:2b9c59c:             PrintWriter writer = response.getWriter();
1:7504bc7: 
1:2b9c59c:             // handle any message(s)
2:2b9c59c:             if (message == null) {
1:2b9c59c:                 // No messages so OK response of for ajax else no content.
1:b13c8c1:                 response.setStatus(HttpServletResponse.SC_NO_CONTENT);
1:b71b349:             } else {
1:2b9c59c:                 // We have at least one message so set up the response
1:b71b349:                 messages = 1;
1:b71b349: 
1:b71b349:                 response.setStatus(HttpServletResponse.SC_OK);
1:7504bc7: 
1:c980168:                 setResponseHeaders(response, message);
1:c980168:                 writeMessageResponse(writer, message);
2:b71b349:                 writer.flush();
1:b71b349:             }
1:987769a:         } finally {
1:540dd5c:             if (LOG.isDebugEnabled()) {
1:540dd5c:                 LOG.debug("Received " + messages + " message(s)");
1:2b9c59c:             }
1:2b9c59c:         }
1:2b9c59c:     }
1:2b9c59c: 
1:40a7d3b:     protected void writeMessageResponse(PrintWriter writer, Message message) throws JMSException, IOException {
1:40a7d3b:         if (message instanceof TextMessage) {
1:a2ede97:             TextMessage textMsg = (TextMessage) message;
1:aa2188c:             String txt = textMsg.getText();
1:7504bc7:             if (txt != null) {
1:7504bc7:                 if (txt.startsWith("<?")) {
1:7504bc7:                     txt = txt.substring(txt.indexOf("?>") + 2);
1:7504bc7:                 }
1:7504bc7:                 writer.print(txt);
1:2b9c59c:             }
1:540dd5c:         } else if (message instanceof ObjectMessage) {
1:a2ede97:             ObjectMessage objectMsg = (ObjectMessage) message;
1:40a7d3b:             Object object = objectMsg.getObject();
1:7504bc7:             if (object != null) {
1:7504bc7:                 writer.print(object.toString());
1:7504bc7:             }
1:2b9c59c:         }
1:2b9c59c:     }
1:2b9c59c: 
1:b71b349:     protected boolean isXmlContent(Message message) throws JMSException {
1:b71b349:         if (message instanceof TextMessage) {
1:a2ede97:             TextMessage textMsg = (TextMessage) message;
1:b71b349:             String txt = textMsg.getText();
1:b71b349:             if (txt != null) {
1:b71b349:                 // assume its xml when it starts with <
1:b71b349:                 if (txt.startsWith("<")) {
1:b71b349:                     return true;
1:b71b349:                 }
1:b71b349:             }
1:b71b349:         }
1:b71b349:         // for any other kind of messages we dont assume xml
1:b71b349:         return false;
1:b71b349:     }
1:b71b349: 
1:2b2b3e8:     public WebClient getWebClient(HttpServletRequest request) {
1:7504bc7:         String clientId = request.getParameter("clientId");
1:7504bc7:         if (clientId != null) {
1:a2ede97:             synchronized (this) {
1:7504bc7:                 LOG.debug("Getting local client [" + clientId + "]");
1:7504bc7:                 WebClient client = clients.get(clientId);
1:7504bc7:                 if (client == null) {
1:7504bc7:                     LOG.debug("Creating new client [" + clientId + "]");
1:7504bc7:                     client = new WebClient();
1:7504bc7:                     clients.put(clientId, client);
1:7504bc7:                 }
1:7504bc7:                 return client;
1:7504bc7:             }
1:7504bc7: 
1:a2ede97:         } else {
1:7504bc7:             return WebClient.getWebClient(request);
1:7504bc7:         }
1:7504bc7:     }
1:2b9c59c: 
1:40a7d3b:     protected String getContentType(HttpServletRequest request) {
1:40a7d3b:         String value = request.getParameter("xml");
1:40a7d3b:         if (value != null && "true".equalsIgnoreCase(value)) {
1:a3e3d48:             return "application/xml";
1:2b9c59c:         }
1:51927e6:         value = request.getParameter("json");
1:51927e6:         if (value != null && "true".equalsIgnoreCase(value)) {
1:51927e6:             return "application/json";
1:51927e6:         }
1:40a7d3b:         return null;
1:2b2b3e8:     }
1:2b9c59c: 
1:3c1b477:     @SuppressWarnings("rawtypes")
1:40a7d3b:     protected void setResponseHeaders(HttpServletResponse response, Message message) throws JMSException {
1:40a7d3b:         response.setHeader("destination", message.getJMSDestination().toString());
1:40a7d3b:         response.setHeader("id", message.getJMSMessageID());
1:3c1b477: 
1:3c1b477:         // Return JMS properties as header values.
1:f888cc2:         for (Enumeration names = message.getPropertyNames(); names.hasMoreElements(); ) {
1:3c1b477:             String name = (String) names.nextElement();
1:a2ede97:             response.setHeader(name, message.getObjectProperty(name).toString());
1:3c1b477:         }
1:2b2b3e8:     }
1:2b9c59c: 
1:40a7d3b:     /**
1:40a7d3b:      * @return the timeout value for read requests which is always >= 0 and <=
1:40a7d3b:      *         maximumReadTimeout to avoid DoS attacks
1:40a7d3b:      */
1:a2ede97:     protected long getReadDeadline(HttpServletRequest request) {
1:a2ede97:         Long answer;
1:2b9c59c: 
1:a2ede97:         answer = (Long) request.getAttribute(readTimeoutRequestAtt);
1:a2ede97: 
1:a2ede97:         if (answer == null) {
1:a2ede97:             long timeout = defaultReadTimeout;
1:a2ede97:             String name = request.getParameter(readTimeoutParameter);
1:a2ede97:             if (name != null) {
1:a2ede97:                 timeout = asLong(name);
1:a2ede97:             }
1:a2ede97:             if (timeout < 0 || timeout > maximumReadTimeout) {
1:a2ede97:                 timeout = maximumReadTimeout;
1:a2ede97:             }
1:a2ede97: 
1:a2ede97:             answer = Long.valueOf(System.currentTimeMillis() + timeout);
1:2b2b3e8:         }
1:a2ede97:         return answer.longValue();
1:a2ede97:     }
1:a2ede97: 
1:a2ede97:     /**
1:a2ede97:      * Close the consumer if one-shot mode is used on the given request.
1:a2ede97:      */
1:a2ede97:     protected void closeConsumerOnOneShot(HttpServletRequest request, WebClient client, Destination dest) {
1:a2ede97:         if (asBoolean(request.getParameter(oneShotParameter), false)) {
1:a2ede97:             try {
1:a2ede97:                 client.closeConsumer(dest);
1:a2ede97:             } catch (JMSException jms_exc) {
1:a2ede97:                 LOG.warn("JMS exception on closing consumer after request with one-shot mode", jms_exc);
1:a2ede97:             }
1:2b2b3e8:         }
1:2b2b3e8:     }
1:2b2b3e8: 
2:40a7d3b:     /*
1:40a7d3b:      * Listen for available messages and wakeup any continuations.
1:40a7d3b:      */
1:702b13b:     private static class Listener implements MessageAvailableListener {
1:40a7d3b:         MessageConsumer consumer;
1:40a7d3b:         Continuation continuation;
1:2b2b3e8: 
1:40a7d3b:         Listener(MessageConsumer consumer) {
1:40a7d3b:             this.consumer = consumer;
1:540dd5c:         }
1:540dd5c: 
1:40a7d3b:         public void setContinuation(Continuation continuation) {
2:40a7d3b:             synchronized (consumer) {
1:40a7d3b:                 this.continuation = continuation;
1:540dd5c:             }
1:540dd5c:         }
1:540dd5c: 
1:de49f2e:         @Override
1:40a7d3b:         public void onMessageAvailable(MessageConsumer consumer) {
1:40a7d3b:             assert this.consumer == consumer;
14:829787a: 
1:de49f2e:             ((MessageAvailableConsumer) consumer).setAvailableListener(null);
1:de49f2e: 
1:40a7d3b:             synchronized (this.consumer) {
1:540dd5c:                 if (continuation != null) {
1:987769a:                     continuation.resume();
1:2b9c59c:                 }
1:540dd5c:             }
1:540dd5c:         }
1:540dd5c:     }
1:540dd5c: }
============================================================================
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:f888cc2
/////////////////////////////////////////////////////////////////////////
1:  * <p/>
1:  * http://www.apache.org/licenses/LICENSE-2.0
1:  * <p/>
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.*;
1: import javax.servlet.ServletConfig;
1: import javax.servlet.ServletException;
1: import javax.servlet.http.HttpServletRequest;
1: import javax.servlet.http.HttpServletResponse;
1: import java.io.IOException;
1: import java.io.PrintWriter;
1: import java.util.Enumeration;
1: import java.util.HashMap;
1: import java.util.HashSet;
1: 
/////////////////////////////////////////////////////////////////////////
1:                                       MessageAvailableConsumer consumer, long deadline) {
/////////////////////////////////////////////////////////////////////////
1:             // 1.1
1: 
1: 
1:             // Set content type as in request. This should be done before calling getWriter by specification
1:             String type = request.getContentType();
1: 
1:             if (type != null) {
1:                 response.setContentType(type);
1:             } else {
1:                 if (isXmlContent(message)) {
1:                     response.setContentType(defaultContentType);
1:                 } else {
1:                     response.setContentType("text/plain");
1:                 }
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         for (Enumeration names = message.getPropertyNames(); names.hasMoreElements(); ) {
commit:a3e3d48
/////////////////////////////////////////////////////////////////////////
1:     private String defaultContentType = "application/xml";
/////////////////////////////////////////////////////////////////////////
1:             return "application/xml";
commit:987769a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             // Look for any available messages (need a little timeout)
/////////////////////////////////////////////////////////////////////////
0:                         LOG.warn("Error receiving message due " + e.getMessage() + ". This exception is ignored.", e);
1:                     } finally {
1:                         continuation.resume();
commit:b13c8c1
/////////////////////////////////////////////////////////////////////////
1:     // its a bit pita that this servlet got intermixed with jetty continuation/rest
1:     // instead of creating a special for that. We should have kept a simple servlet
1:     // for good old fashioned request/response blocked communication.
1: 
/////////////////////////////////////////////////////////////////////////
0:                    writeMessageResponse(response.getWriter(), answer);
/////////////////////////////////////////////////////////////////////////
1:                 response.setStatus(HttpServletResponse.SC_NO_CONTENT);
0: //                response.setContentType("text/plain");
0: //                writer.write("No message received");
0: //                writer.flush();
commit:b71b349
/////////////////////////////////////////////////////////////////////////
1: 
0:                    writeResponse(request, response, answer);
/////////////////////////////////////////////////////////////////////////
1:             response.getWriter().write("Message sent");
1: 
/////////////////////////////////////////////////////////////////////////
1:                 response.setStatus(HttpServletResponse.SC_OK);
0:                 response.setContentType("text/plain");
0:                 writer.write("No message received");
1:                 writer.flush();
1:                 messages = 1;
1: 
1:                 } else {
0:                     if (isXmlContent(message)) {
0:                         response.setContentType(defaultContentType);
1:                     } else {
0:                         response.setContentType("text/plain");
1:                     }
1:                 response.setStatus(HttpServletResponse.SC_OK);
1:                 writer.flush();
/////////////////////////////////////////////////////////////////////////
1:     protected boolean isXmlContent(Message message) throws JMSException {
1:         if (message instanceof TextMessage) {
0:             TextMessage textMsg = (TextMessage)message;
1:             String txt = textMsg.getText();
1:             if (txt != null) {
1:                 // assume its xml when it starts with <
1:                 if (txt.startsWith("<")) {
1:                     return true;
1:                 }
1:             }
1:         }
1:         // for any other kind of messages we dont assume xml
1:         return false;
1:     }
1: 
author:Timothy Bish
-------------------------------------------------------------------------------
commit:a2ede97
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
1:  * HTTP POST for sending and HTTP GET for receiving.
1:  * <p/>
1:  * You can specify the destination and whether it is a topic or queue via
1:  * configuration details on the servlet or as request parameters.
1:  * <p/>
1:  * For reading messages you can specify a readTimeout parameter to determine how
1:  * long the servlet should block for.
1:  *
1:  * One thing to keep in mind with this solution - due to the nature of REST,
1:  * there will always be a chance of losing messages. Consider what happens when
1:  * a message is retrieved from the broker but the web call is interrupted before
1:  * the client receives the message in the response - the message is lost.
/////////////////////////////////////////////////////////////////////////
1:     private final String readTimeoutRequestAtt = "xamqReadDeadline";
1:     private final String oneShotParameter = "oneShot";
1:     private final HashSet<MessageAvailableConsumer> activeConsumers = new HashSet<MessageAvailableConsumer>();
/////////////////////////////////////////////////////////////////////////
1:      * Supports a HTTP DELETE to be equivalent of consuming a singe message
/////////////////////////////////////////////////////////////////////////
1:      * Supports a HTTP DELETE to be equivalent of consuming a singe message
/////////////////////////////////////////////////////////////////////////
1:         MessageAvailableConsumer consumer = null;
1: 
1:             consumer = (MessageAvailableConsumer) client.getConsumer(destination, request.getHeader(WebClient.selectorName));
1:             Continuation continuation = ContinuationSupport.getContinuation(request);
1: 
1:             // Don't allow concurrent use of the consumer. Do make sure to allow
1:             // subsequent calls on continuation to use the consumer.
1:             if (continuation.isInitial()) {
1:                 synchronized (activeConsumers) {
1:                     if (activeConsumers.contains(consumer)) {
1:                         throw new ServletException("Concurrent access to consumer is not supported");
1:                     } else {
1:                         activeConsumers.add(consumer);
1:                     }
1:                 }
1: 
1:             Message message = null;
1: 
1:             long deadline = getReadDeadline(request);
1:             long timeout = deadline - System.currentTimeMillis();
1: 
1:             // Set the message available listener *before* calling receive to eliminate any
1:             // chance of a missed notification between the time receive() completes without
1:             // a message and the time the listener is set.
1:             synchronized (consumer) {
1:                 Listener listener = (Listener) consumer.getAvailableListener();
1:                 if (listener == null) {
1:                     listener = new Listener(consumer);
1:                     consumer.setAvailableListener(listener);
1:                 }
1:             }
1:             // Look for any available messages (need a little timeout). Always
1:             // try at least one lookup; don't block past the deadline.
1:             if (timeout <= 0) {
1:                 message = consumer.receiveNoWait();
1:             } else if (timeout < 10) {
1:                 message = consumer.receive(timeout);
1:             } else {
1:                 message = consumer.receive(10);
1:             if (message == null) {
1:                 handleContinuation(request, response, client, destination, consumer, deadline);
1:             } else {
1:                 writeResponse(request, response, message);
1:                 closeConsumerOnOneShot(request, client, destination);
1: 
1:                 synchronized (activeConsumers) {
1:                     activeConsumers.remove(consumer);
1:                 }
1:             }
1:     protected void handleContinuation(HttpServletRequest request, HttpServletResponse response, WebClient client, Destination destination,
0:         MessageAvailableConsumer consumer, long deadline) {
1:         // Get an existing Continuation or create a new one if there are no events.
1:         Continuation continuation = ContinuationSupport.getContinuation(request);
1: 
1:         long timeout = deadline - System.currentTimeMillis();
1:         if ((continuation.isExpired()) || (timeout <= 0)) {
1:             // Reset the continuation on the available listener for the consumer to prevent the
1:             // next message receipt from being consumed without a valid, active continuation.
1:             synchronized (consumer) {
1:                 Object obj = consumer.getAvailableListener();
1:                 if (obj instanceof Listener) {
1:                     ((Listener) obj).setContinuation(null);
1:                 }
1:             }
1:             response.setStatus(HttpServletResponse.SC_NO_CONTENT);
1:             closeConsumerOnOneShot(request, client, destination);
1:             synchronized (activeConsumers) {
1:                 activeConsumers.remove(consumer);
1:             }
1:             return;
1:         }
1: 
1:         continuation.setTimeout(timeout);
1:         continuation.suspend();
1: 
1:         synchronized (consumer) {
1:             Listener listener = (Listener) consumer.getAvailableListener();
1: 
1:             // register this continuation with our listener.
1:             listener.setContinuation(continuation);
1:         }
1:     }
1: 
1:             response.setHeader("Cache-Control", "no-cache, no-store, must-revalidate"); // HTTP
0:                                                                                         // 1.1
1:             response.setHeader("Pragma", "no-cache"); // HTTP 1.0
1:             response.setDateHeader("Expires", 0);
/////////////////////////////////////////////////////////////////////////
1:             TextMessage textMsg = (TextMessage) message;
/////////////////////////////////////////////////////////////////////////
1:             ObjectMessage objectMsg = (ObjectMessage) message;
/////////////////////////////////////////////////////////////////////////
1:             TextMessage textMsg = (TextMessage) message;
/////////////////////////////////////////////////////////////////////////
1:             synchronized (this) {
/////////////////////////////////////////////////////////////////////////
0:         for (Enumeration names = message.getPropertyNames(); names.hasMoreElements();) {
1:             response.setHeader(name, message.getObjectProperty(name).toString());
/////////////////////////////////////////////////////////////////////////
1:     protected long getReadDeadline(HttpServletRequest request) {
1:         Long answer;
1:         answer = (Long) request.getAttribute(readTimeoutRequestAtt);
1: 
1:         if (answer == null) {
1:             long timeout = defaultReadTimeout;
1:             String name = request.getParameter(readTimeoutParameter);
1:             if (name != null) {
1:                 timeout = asLong(name);
1:             }
1:             if (timeout < 0 || timeout > maximumReadTimeout) {
1:                 timeout = maximumReadTimeout;
1:             }
1: 
1:             answer = Long.valueOf(System.currentTimeMillis() + timeout);
1:         return answer.longValue();
1:     }
1: 
1:     /**
1:      * Close the consumer if one-shot mode is used on the given request.
1:      */
1:     protected void closeConsumerOnOneShot(HttpServletRequest request, WebClient client, Destination dest) {
1:         if (asBoolean(request.getParameter(oneShotParameter), false)) {
1:             try {
1:                 client.closeConsumer(dest);
1:             } catch (JMSException jms_exc) {
1:                 LOG.warn("JMS exception on closing consumer after request with one-shot mode", jms_exc);
1:             }
/////////////////////////////////////////////////////////////////////////
0:                     continuation.resume();
commit:062adbb
/////////////////////////////////////////////////////////////////////////
1:             appendParametersToMessage(request, message);
1:             boolean persistent = isSendPersistent(request);
1:             int priority = getSendPriority(request);
1:             long timeToLive = getSendTimeToLive(request);
1:             client.send(destination, message, persistent, priority, timeToLive);
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:42b4e0c
/////////////////////////////////////////////////////////////////////////
0:         	response.setHeader("Cache-Control", "no-cache, no-store, must-revalidate"); // HTTP 1.1
0:         	response.setHeader("Pragma", "no-cache"); // HTTP 1.0
0:         	response.setDateHeader("Expires", 0);
commit:de49f2e
/////////////////////////////////////////////////////////////////////////
1:     private final String readTimeoutParameter = "readTimeout";
1:     private final HashMap<String, WebClient> clients = new HashMap<String, WebClient>();
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:             ((MessageAvailableConsumer) consumer).setAvailableListener(null);
1: 
commit:3c1b477
/////////////////////////////////////////////////////////////////////////
0: import java.util.Enumeration;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("rawtypes")
1: 
1:         // Return JMS properties as header values.
0:         for(Enumeration names = message.getPropertyNames(); names.hasMoreElements();) {
1:             String name = (String) names.nextElement();
0:             response.setHeader(name , message.getObjectProperty(name).toString());
1:         }
commit:7504bc7
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             requestTimeout = asLong(name);
1:         }
0:      *
/////////////////////////////////////////////////////////////////////////
0:                String point = "activemq:"
0:                    + ((ActiveMQDestination)destination).getPhysicalName().replace("//", "")
0:                    + "?requestTimeout=" + requestTimeout;
0:                    String body = (String)client.getProducerTemplate().requestBody(point, text);
0:                    writeMessageResponse(response.getWriter(), answer);
0:                    IOException ex = new IOException();
0:                    ex.initCause(e);
0:                    throw ex;
0:                 long timeToLive = getSendTimeToLive(request);
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:             message = (Message)request.getAttribute("message");
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             if (txt != null) {
1:                 if (txt.startsWith("<?")) {
1:                     txt = txt.substring(txt.indexOf("?>") + 2);
1:                 }
1:                 writer.print(txt);
1:             if (object != null) {
1:                 writer.print(object.toString());
1:             }
/////////////////////////////////////////////////////////////////////////
1: 
1:         String clientId = request.getParameter("clientId");
1:         if (clientId != null) {
0:             synchronized(this) {
1:                 LOG.debug("Getting local client [" + clientId + "]");
1:                 WebClient client = clients.get(clientId);
1:                 if (client == null) {
1:                     LOG.debug("Creating new client [" + clientId + "]");
1:                     client = new WebClient();
1:                     clients.put(clientId, client);
1:                 }
1:                 return client;
1:             }
1: 
0:         } else {
1:             return WebClient.getWebClient(request);
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
0:                     continuation.resume();
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:51927e6
/////////////////////////////////////////////////////////////////////////
0:     private String defaultContentType = "text/xml";
/////////////////////////////////////////////////////////////////////////
1:         name = servletConfig.getInitParameter("defaultContentType");
1:         if (name != null) {
1:             defaultContentType = name;
1:         }
/////////////////////////////////////////////////////////////////////////
0:             response.setContentType(defaultContentType);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         value = request.getParameter("json");
1:         if (value != null && "true".equalsIgnoreCase(value)) {
1:             return "application/json";
1:         }
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(MessageServlet.class);
commit:3c734ce
/////////////////////////////////////////////////////////////////////////
1: 
1:             String action = request.getParameter("action");
1:             String clientId = request.getParameter("clientId");
1:             if (action != null && clientId != null && action.equals("unsubscribe")) {
1:                 LOG.info("Unsubscribing client " + clientId);
1:                 WebClient client = getWebClient(request);
1:                 client.close();
1:                 clients.remove(clientId);
1:                 return;
1:             }
1: 
commit:c980168
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     private static final long serialVersionUID = 8737914695188481219L;
1: 
/////////////////////////////////////////////////////////////////////////
1:         doMessages(request, response);
/////////////////////////////////////////////////////////////////////////
1:         doMessages(request, response);
/////////////////////////////////////////////////////////////////////////
1:     protected void doMessages(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
/////////////////////////////////////////////////////////////////////////
0:                 writeResponse(request, response, message);
/////////////////////////////////////////////////////////////////////////
0:                     response.setStatus(HttpServletResponse.SC_NO_CONTENT);
/////////////////////////////////////////////////////////////////////////
0:             writeResponse(request, response, message);
1:     protected void writeResponse(HttpServletRequest request, HttpServletResponse response, Message message) throws IOException, JMSException {
0:                 response.setStatus(HttpServletResponse.SC_NO_CONTENT);
/////////////////////////////////////////////////////////////////////////
1:                 
1:                 setResponseHeaders(response, message);
1:                 writeMessageResponse(writer, message);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                         LOG.error("Error receiving message " + e, e);
commit:2b9c59c
/////////////////////////////////////////////////////////////////////////
0:             MessageAvailableConsumer consumer = (MessageAvailableConsumer)client.getConsumer(destination, request.getHeader(WebClient.selectorName));
0:             Message message = null;
0:             message = (Message)request.getAttribute("message"); 
0:             if (message != null) {
0:                 // we're resuming continuation,
0:                 // so just write the message and return
0:                 writeResponse(request, response, maxMessages, message, consumer);
0:                 return;
0:             long timeout = getReadTimeout(request);
1:             
0:             // Look for any available messages
0:             message = consumer.receive(10);
1: 
0:             // Get an existing Continuation or create a new one if there are
0:             // no events.
1:             if (message == null) {
0:                 continuation = ContinuationSupport.getContinuation(request);
1:                 
0:                 if (continuation.isExpired()) {
0:                     response.setStatus(isRicoAjax(request) ? HttpServletResponse.SC_OK : HttpServletResponse.SC_NO_CONTENT);
0:                     return;
1:                 }
1: 
0:                 continuation.setTimeout(timeout);
0:                 continuation.suspend();
1:                 
0:                 // register this continuation with our listener.
0:                 listener.setContinuation(continuation);
1: 
0:             writeResponse(request, response, maxMessages, message, consumer);
1:         }
1:     }
1:     
0:     protected void writeResponse(HttpServletRequest request, HttpServletResponse response, int maxMessages, Message message, MessageAvailableConsumer consumer) throws IOException, JMSException {
1:         int messages = 0;
1:         try {
0:             boolean ajax = isRicoAjax(request);
0:             if (!ajax) {
0:                 maxMessages = 1;
1:             }
1: 
1:             // write a responds
0:             response.setContentType("text/xml");
1:             PrintWriter writer = response.getWriter();
1: 
0:             if (ajax) {
0:                 writer.println("<ajax-response>");
1:             }
1: 
1:             // handle any message(s)
1:             if (message == null) {
1:                 // No messages so OK response of for ajax else no content.
0:                 response.setStatus(ajax ? HttpServletResponse.SC_OK
0:                         : HttpServletResponse.SC_NO_CONTENT);
0:             } else {
1:                 // We have at least one message so set up the response
0:                 response.setStatus(HttpServletResponse.SC_OK);
0:                 String type = getContentType(request);
0:                 if (type != null) {
0:                     response.setContentType(type);
1:                 }
1: 
0:                 // send a response for each available message (up to max
0:                 // messages)
0:                 while ((maxMessages < 0 || messages < maxMessages)
0:                         && message != null) {
0:                     if (ajax) {
0:                         writer.print("<response type='object' id='");
0:                         writer.print(request.getParameter("id"));
0:                         writer.println("'>");
0:                     } else {
0:                         // only ever 1 message for non ajax!
0:                         setResponseHeaders(response, message);
1:                     }
1: 
0:                     writeMessageResponse(writer, message);
1: 
0:                     if (ajax) {
0:                         writer.println("</response>");
1:                     }
1: 
0:                     // look for next message
0:                     messages++;
0:                     if (maxMessages < 0 || messages < maxMessages) {
0:                         message = consumer.receiveNoWait();
1:                     }
1:                 }
1:             }
1: 
0:             if (ajax) {
0:                 writer
0:                         .println("<response type='object' id='poll'><ok/></response>");
0:                 writer.println("</ajax-response>");
1:             }
/////////////////////////////////////////////////////////////////////////
1:                     try {
0:                         Message message = consumer.receiveNoWait();
0:                         continuation.setAttribute("message", message);
0:                     } catch (Exception e) {
0:                         e.printStackTrace();
1:                     }
0:                     continuation.resume();   
commit:a05e84e
/////////////////////////////////////////////////////////////////////////
0:             MessageAvailableConsumer consumer = (MessageAvailableConsumer)client.getConsumer(destination, request.getHeader(WebClient.selectorName));
/////////////////////////////////////////////////////////////////////////
0:             MessageAvailableConsumer consumer = (MessageAvailableConsumer)client.getConsumer(destination, request.getHeader(WebClient.selectorName));
commit:ce9f83c
/////////////////////////////////////////////////////////////////////////
0:             MessageAvailableConsumer consumer = (MessageAvailableConsumer)client.getConsumer(destination, request.getHeader(WebClient.SELECTOR_NAME));
/////////////////////////////////////////////////////////////////////////
0:             MessageAvailableConsumer consumer = (MessageAvailableConsumer)client.getConsumer(destination, request.getHeader(WebClient.SELECTOR_NAME));
commit:5dd95ea
/////////////////////////////////////////////////////////////////////////
0:                     continuation.setTimeout(timeout);
commit:e8a06c4
/////////////////////////////////////////////////////////////////////////
1: import org.eclipse.jetty.continuation.Continuation;
1: import org.eclipse.jetty.continuation.ContinuationSupport;
/////////////////////////////////////////////////////////////////////////
0:                     continuation = ContinuationSupport.getContinuation(request);
0:                     continuation.suspend();
commit:ac2d263
/////////////////////////////////////////////////////////////////////////
0:             	   IOException ex = new IOException();
0:             	   ex.initCause(e);
0:             	   throw ex;
commit:2b2b3e8
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
0: import javax.servlet.ServletContext;
0: import org.apache.activemq.camel.converter.ActiveMQMessageConverter;
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQTextMessage;
0: import org.apache.camel.Endpoint;
0: import org.apache.camel.Exchange;
0: import org.apache.camel.ExchangePattern;
0: import org.apache.camel.Producer;
/////////////////////////////////////////////////////////////////////////
1:     private long requestTimeout = 1000;
1:     
0:     private HashMap<String, WebClient> clients = new HashMap<String, WebClient>();
/////////////////////////////////////////////////////////////////////////
1:         name = servletConfig.getInitParameter("replyTimeout");
1:         if (name != null) {
0:         	requestTimeout = asLong(name);
1:         }        
/////////////////////////////////////////////////////////////////////////
1:             WebClient client = getWebClient(request);
/////////////////////////////////////////////////////////////////////////
1:             boolean sync = isSync(request);
1: 
0:             if (sync) {
0:                String point = "activemq:" 
0:             	   + ((ActiveMQDestination)destination).getPhysicalName().replace("//", "")
0:             	   + "?requestTimeout=" + requestTimeout;
1:                try {
0:             	   String body = (String)client.getProducerTemplate().requestBody(point, text);
0:                    ActiveMQTextMessage answer = new ActiveMQTextMessage();
0:                    answer.setText(body);
0:             	   writeMessageResponse(response.getWriter(), answer);
0:                } catch (Exception e) {
0:             	   throw new IOException(e);
1:                }
0:             } else {
0:                 appendParametersToMessage(request, message);
0:                 boolean persistent = isSendPersistent(request);
0:                 int priority = getSendPriority(request);
0:                 long timeToLive = getSendTimeToLive(request);            	
0:                 client.send(destination, message, persistent, priority, timeToLive);
1:             }
/////////////////////////////////////////////////////////////////////////
1:             WebClient client = getWebClient(request);
/////////////////////////////////////////////////////////////////////////
0:                         if(maxMessages < 0 || messages < maxMessages) {
0:                         	message = consumer.receiveNoWait();
1:                         }
/////////////////////////////////////////////////////////////////////////
0:             WebClient client = getWebClient(request);
/////////////////////////////////////////////////////////////////////////
0:                             if(maxMessages < 0 || messages < maxMessages) {
0:                             	message = consumer.receiveNoWait();
1:                             }
1: 
/////////////////////////////////////////////////////////////////////////
1:     
1:     public WebClient getWebClient(HttpServletRequest request) {
0:     	String clientId = request.getParameter("clientId");
0:     	if (clientId != null) {
0:     		synchronized(this) {
0:     			LOG.debug("Getting local client [" + clientId + "]");
0:     			WebClient client = clients.get(clientId);
0:     			if (client == null) {
0:     				LOG.debug("Creating new client [" + clientId + "]");
0:     				client = new WebClient();
0:     				clients.put(clientId, client);
1:     			}
0:     			return client;
1:     		}
1:     		
0:     	} else {
0:     		return WebClient.getWebClient(request);
1:     	}
1:     }    
commit:9ed183d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
0:  * 
commit:540dd5c
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(MessageServlet.class);
/////////////////////////////////////////////////////////////////////////
1:             if (destination == null) {
1: 
1:             if (LOG.isDebugEnabled()) {
1:                 LOG.debug("Sending message to: " + destination + " with text: " + text);
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:         } catch (JMSException e) {
/////////////////////////////////////////////////////////////////////////
1:             if (destination == null) {
1:             }
0:             if (!ajax) {
1:             if (LOG.isDebugEnabled()) {
1:                 LOG.debug("Receiving message(s) from: " + destination + " with timeout: " + timeout);
1:             }
1: 
0:             MessageAvailableConsumer consumer = (MessageAvailableConsumer)client.getConsumer(destination);
0:                 listener = (Listener)consumer.getAvailableListener();
/////////////////////////////////////////////////////////////////////////
0:                 if (message == null) {
1:                 }
0:                 if (ajax) {
1:                 }
0:                 } else {
0:                     if (type != null) {
1:                     }
/////////////////////////////////////////////////////////////////////////
0:                         } else {
1:                         }
0:                         if (ajax) {
1:                         }
/////////////////////////////////////////////////////////////////////////
1:         } catch (JMSException e) {
0:         } finally {
1:             if (LOG.isDebugEnabled()) {
1:                 LOG.debug("Received " + messages + " message(s)");
/////////////////////////////////////////////////////////////////////////
0:     protected void doMessagesWithoutContinuation(HttpServletRequest request, HttpServletResponse response, int maxMessages) throws ServletException, IOException {
/////////////////////////////////////////////////////////////////////////
0:             if (!ajax) {
1:             }
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("Receiving message(s) from: " + destination + " with timeout: " + timeout);
0:             MessageAvailableConsumer consumer = (MessageAvailableConsumer)client.getConsumer(destination);
0:             if (ajax) {
1:             }
/////////////////////////////////////////////////////////////////////////
0:                         if (type != null) {
1:                         }
/////////////////////////////////////////////////////////////////////////
0:                             } else {
1:                             }
0:                             if (ajax) {
1:                             }
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("Received " + messages + " message(s)");
0:             TextMessage textMsg = (TextMessage)message;
1:         } else if (message instanceof ObjectMessage) {
0:             ObjectMessage objectMsg = (ObjectMessage)message;
/////////////////////////////////////////////////////////////////////////
1:                 if (continuation != null) {
0:                 }
commit:5f1adbe
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:88d5857
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.MessageAvailableConsumer;
1: import org.apache.activemq.MessageAvailableListener;
commit:f1a084e
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.web;
commit:639265d
/////////////////////////////////////////////////////////////////////////
0:         doMessages(request, response, 1);
/////////////////////////////////////////////////////////////////////////
0:         doMessages(request, response, -1);
commit:829787a
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.io.PrintWriter;
0: import java.util.LinkedList;
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: import org.activemq.MessageAvailableConsumer;
0: import org.activemq.MessageAvailableListener;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: import org.mortbay.util.ajax.Continuation;
0: import org.mortbay.util.ajax.ContinuationSupport;
/////////////////////////////////////////////////////////////////////////
0:         doMessagesWithoutContinuation(request, response, 1);
/////////////////////////////////////////////////////////////////////////
0:         doMessagesWithoutContinuation(request, response, -1);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Reads a message from a destination up to some specific timeout period
0:      * 
1:      * @param request
1:      * @param response
1:      * @throws ServletException
1:      * @throws IOException
1:      */
0:     protected void doMessagesWithoutContinuation(HttpServletRequest request, HttpServletResponse response,
0:             int maxMessages) throws ServletException, IOException {
1: 
0:         int messages = 0;
0:         try {
0:             WebClient client = getWebClient(request);
1:             Destination destination = getDestination(client, request);
0:             long timeout = getReadTimeout(request);
0:             boolean ajax = isRicoAjax(request);
0:             if (!ajax)
0:                 maxMessages = 1;
1: 
0:             if (log.isDebugEnabled()) {
0:                 log.debug("Receiving message(s) from: " + destination + " with timeout: " + timeout);
0:             }
1: 
0:             MessageAvailableConsumer consumer = (MessageAvailableConsumer) client.getConsumer(destination);
0:             Continuation continuation = null;
0:             Listener listener = null;
0:             Message message = null;
1: 
0:             // write a responds
0:             response.setContentType("text/xml");
0:             PrintWriter writer = response.getWriter();
1: 
0:             if (ajax)
0:                 writer.println("<ajax-response>");
1: 
0:             // Only one client thread at a time should poll for messages.
0:             if (client.getSemaphore().tryAcquire()) {
0:                 try {
0:                     // Look for any available messages
0:                     message = consumer.receive(timeout);
1: 
0:                     // handle any message(s)
0:                     if (message == null) {
0:                         // No messages so OK response of for ajax else no
0:                         // content.
0:                         response.setStatus(ajax ? HttpServletResponse.SC_OK : HttpServletResponse.SC_NO_CONTENT);
0:                     } else {
0:                         // We have at least one message so set up the
0:                         // response
0:                         response.setStatus(HttpServletResponse.SC_OK);
0:                         String type = getContentType(request);
0:                         if (type != null)
0:                             response.setContentType(type);
1: 
0:                         // send a response for each available message (up to
0:                         // max
0:                         // messages)
0:                         while ((maxMessages < 0 || messages < maxMessages) && message != null) {
0:                             // System.err.println("message["+messages+"]="+message);
0:                             if (ajax) {
0:                                 writer.print("<response type='object' id='");
0:                                 writer.print(request.getParameter("id"));
0:                                 writer.println("'>");
0:                             } else
0:                                 // only ever 1 message for non ajax!
0:                                 setResponseHeaders(response, message);
1: 
0:                             writeMessageResponse(writer, message);
1: 
0:                             if (ajax)
0:                                 writer.println("</response>");
1: 
0:                             // look for next message
0:                             message = consumer.receiveNoWait();
0:                             messages++;
0:                         }
0:                     }
0:                 } finally {
0:                     client.getSemaphore().release();
0:                 }
0:             } else {
0:                 // Client is using us in another thread.
0:                 response.setStatus(ajax ? HttpServletResponse.SC_OK : HttpServletResponse.SC_NO_CONTENT);
0:             }
1: 
0:             if (ajax) {
0:                 writer.println("<response type='object' id='poll'><ok/></response>");
0:                 writer.println("</ajax-response>");
0:             }
1: 
0:         } catch (JMSException e) {
1:             throw new ServletException("Could not post JMS message: " + e, e);
0:         } finally {
0:             if (log.isDebugEnabled()) {
0:                 log.debug("Received " + messages + " message(s)");
0:             }
0:         }
0:     }
1: 
author:Robert Davies
-------------------------------------------------------------------------------
commit:702b13b
/////////////////////////////////////////////////////////////////////////
1:     private static class Listener implements MessageAvailableListener {
author:James Strachan
-------------------------------------------------------------------------------
commit:e7ca882
/////////////////////////////////////////////////////////////////////////
0:             
0:             client.send(destination, message, persistent, priority, timeToLive);
commit:c1a1dd2
/////////////////////////////////////////////////////////////////////////
0:             WebClient client = WebClient.getWebClient(request);
/////////////////////////////////////////////////////////////////////////
0:             WebClient client = WebClient.getWebClient(request);
/////////////////////////////////////////////////////////////////////////
0:             WebClient client = WebClient.getWebClient(request);
commit:33cf032
/////////////////////////////////////////////////////////////////////////
0:             boolean persistent = isSendPersistent(request);
0:             int priority = getSendPriority(request);
0:             long timeToLive = getSendTimeToLive(request);
commit:40a7d3b
/////////////////////////////////////////////////////////////////////////
1: /** 
0:  *
0:  * Copyright 2004 Protique Ltd
0:  * 
0:  * Licensed under the Apache License, Version 2.0 (the "License"); 
0:  * you may not use this file except in compliance with the License. 
0:  * You may obtain a copy of the License at 
0:  * 
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  * 
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS, 
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
1:  * See the License for the specific language governing permissions and 
1:  * limitations under the License. 
0:  * 
0:  **/
0: 
0: package org.activemq.web;
0: 
0: import org.activemq.MessageAvailableConsumer;
0: import org.activemq.MessageAvailableListener;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: import org.mortbay.util.ajax.Continuation;
0: import org.mortbay.util.ajax.ContinuationSupport;
0: 
0: import javax.jms.Destination;
0: import javax.jms.JMSException;
0: import javax.jms.Message;
0: import javax.jms.MessageConsumer;
0: import javax.jms.ObjectMessage;
0: import javax.jms.TextMessage;
0: import javax.servlet.ServletConfig;
0: import javax.servlet.ServletException;
0: import javax.servlet.http.HttpServletRequest;
0: import javax.servlet.http.HttpServletResponse;
0: 
0: import java.io.IOException;
0: import java.io.PrintWriter;
0: import java.util.LinkedList;
0: import java.util.List;
0: 
1: /**
1:  * A servlet for sending and receiving messages to/from JMS destinations using
0:  * HTTP POST for sending and HTTP GET for receiving. <p/> You can specify the
0:  * destination and whether it is a topic or queue via configuration details on
0:  * the servlet or as request parameters. <p/> For reading messages you can
0:  * specify a readTimeout parameter to determine how long the servlet should
0:  * block for.
0:  * 
0:  * @version $Revision: 1.1.1.1 $
1:  */
1: public class MessageServlet extends MessageServletSupport {
0:     private static final Log log = LogFactory.getLog(MessageServlet.class);
0: 
0:     private String readTimeoutParameter = "readTimeout";
1:     private long defaultReadTimeout = -1;
1:     private long maximumReadTimeout = 20000;
0: 
1:     public void init() throws ServletException {
1:         ServletConfig servletConfig = getServletConfig();
1:         String name = servletConfig.getInitParameter("defaultReadTimeout");
1:         if (name != null) {
1:             defaultReadTimeout = asLong(name);
0:         }
1:         name = servletConfig.getInitParameter("maximumReadTimeout");
1:         if (name != null) {
1:             maximumReadTimeout = asLong(name);
0:         }
0:     }
0: 
1:     /**
1:      * Sends a message to a destination
0:      * 
1:      * @param request
1:      * @param response
1:      * @throws ServletException
1:      * @throws IOException
1:      */
1:     protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
1:         // lets turn the HTTP post into a JMS Message
0:         try {
0:             WebClient client = getWebClient(request);
0: 
1:             String text = getPostedMessageBody(request);
0: 
1:             // lets create the destination from the URI?
1:             Destination destination = getDestination(client, request);
0: 
0:             if (log.isDebugEnabled()) {
0:                 log.debug("Sending message to: " + destination + " with text: " + text);
0:             }
0: 
1:             TextMessage message = client.getSession().createTextMessage(text);
0:             appendParametersToMessage(request, message);
0:             client.send(destination, message);
0: 
1:             // lets return a unique URI for reliable messaging
1:             response.setHeader("messageID", message.getJMSMessageID());
0:             response.setStatus(HttpServletResponse.SC_OK);
0:         }
0:         catch (JMSException e) {
1:             throw new ServletException("Could not post JMS message: " + e, e);
0:         }
0:     }
0: 
1:     /**
0:      * Supports a HTTP DELETE to be equivlanent of consuming a singe message
1:      * from a queue
1:      */
1:     protected void doDelete(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
0:         doMessages(request, response, 1);
0:     }
0: 
1:     /**
0:      * Supports a HTTP DELETE to be equivlanent of consuming a singe message
1:      * from a queue
1:      */
1:     protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
0:         doMessages(request, response, -1);
0:     }
0: 
1:     /**
0:      * Reads a message from a destination up to some specific timeout period
0:      * 
1:      * @param request
1:      * @param response
1:      * @throws ServletException
1:      * @throws IOException
1:      */
0:     protected void doMessages(HttpServletRequest request, HttpServletResponse response, int maxMessages) throws ServletException, IOException {
0: 
0:         int messages = 0;
0:         try {
0:             WebClient client = getWebClient(request);
1:             Destination destination = getDestination(client, request);
0:             long timeout = getReadTimeout(request);
0:             boolean ajax = isRicoAjax(request);
0:             if (!ajax)
0:                 maxMessages = 1;
0: 
0:             if (log.isDebugEnabled()) {
0:                 log.debug("Receiving message(s) from: " + destination + " with timeout: " + timeout);
0:             }
0: 
0:             MessageAvailableConsumer consumer = (MessageAvailableConsumer) client.getConsumer(destination);
0:             Continuation continuation = null;
0:             Listener listener = null;
0:             Message message = null;
0: 
1:             synchronized (consumer) {
0:                 // Fetch the listeners
0:                 listener = (Listener) consumer.getAvailableListener();
0:                 if (listener == null) {
0:                     listener = new Listener(consumer);
0:                     consumer.setAvailableListener(listener);
0:                 }
0:                 // Look for any available messages
0:                 message = consumer.receiveNoWait();
0: 
0:                 // Get an existing Continuation or create a new one if there are
0:                 // no events.
0:                 if (message == null) {
0:                     continuation = ContinuationSupport.getContinuation(request, consumer);
0: 
0:                     // register this continuation with our listener.
0:                     listener.setContinuation(continuation);
0: 
0:                     // Get the continuation object (may wait and/or retry
0:                     // request here).
0:                     continuation.suspend(timeout);
0:                 }
0: 
0:                 // Try again now
0:                 if (message == null)
0:                     message = consumer.receiveNoWait();
0: 
0:                 // write a responds
0:                 response.setContentType("text/xml");
0:                 PrintWriter writer = response.getWriter();
0: 
0:                 if (ajax)
0:                     writer.println("<ajax-response>");
0: 
0:                 // handle any message(s)
0:                 if (message == null) {
0:                     // No messages so OK response of for ajax else no content.
0:                     response.setStatus(ajax ? HttpServletResponse.SC_OK : HttpServletResponse.SC_NO_CONTENT);
0:                 }
0:                 else {
0:                     // We have at least one message so set up the response
0:                     response.setStatus(HttpServletResponse.SC_OK);
0:                     String type = getContentType(request);
0:                     if (type != null)
0:                         response.setContentType(type);
0: 
0:                     // send a response for each available message (up to max
0:                     // messages)
0:                     while ((maxMessages < 0 || messages < maxMessages) && message != null) {
0:                         // System.err.println("message["+messages+"]="+message);
0:                         if (ajax) {
0:                             writer.print("<response type='object' id='");
0:                             writer.print(request.getParameter("id"));
0:                             writer.println("'>");
0:                         }
0:                         else
0:                             // only ever 1 message for non ajax!
0:                             setResponseHeaders(response, message);
0: 
0:                         writeMessageResponse(writer, message);
0: 
0:                         if (ajax)
0:                             writer.println("</response>");
0: 
0:                         // look for next message
0:                         message = consumer.receiveNoWait();
0:                         messages++;
0:                     }
0:                 }
0: 
0:                 if (ajax) {
0:                     writer.println("<response type='object' id='poll'><ok/></response>");
0:                     writer.println("</ajax-response>");
0:                 }
0:             }
0:         }
0:         catch (JMSException e) {
1:             throw new ServletException("Could not post JMS message: " + e, e);
0:         }
0:         finally {
0:             if (log.isDebugEnabled()) {
0:                 log.debug("Received " + messages + " message(s)");
0:             }
0:         }
0:     }
0: 
1:     protected void writeMessageResponse(PrintWriter writer, Message message) throws JMSException, IOException {
1:         if (message instanceof TextMessage) {
0:             TextMessage textMsg = (TextMessage) message;
0:             writer.print(textMsg.getText());
0:         }
0:         else if (message instanceof ObjectMessage) {
0:             ObjectMessage objectMsg = (ObjectMessage) message;
1:             Object object = objectMsg.getObject();
0:             writer.print(object.toString());
0:         }
0:     }
0: 
0:     protected boolean isRicoAjax(HttpServletRequest request) {
0:         String rico = request.getParameter("rico");
0:         return rico != null && rico.equals("true");
0:     }
0: 
1:     protected String getContentType(HttpServletRequest request) {
1:         /*
0:          * log("Params: " + request.getParameterMap()); Enumeration iter =
0:          * request.getHeaderNames(); while (iter.hasMoreElements()) { String
0:          * name = (String) iter.nextElement(); log("Header: " + name + " = " +
0:          * request.getHeader(name)); }
1:          */
1:         String value = request.getParameter("xml");
1:         if (value != null && "true".equalsIgnoreCase(value)) {
0:             return "text/xml";
0:         }
1:         return null;
0:     }
0: 
1:     protected void setResponseHeaders(HttpServletResponse response, Message message) throws JMSException {
1:         response.setHeader("destination", message.getJMSDestination().toString());
1:         response.setHeader("id", message.getJMSMessageID());
0:     }
0: 
1:     /**
1:      * @return the timeout value for read requests which is always >= 0 and <=
1:      *         maximumReadTimeout to avoid DoS attacks
1:      */
0:     protected long getReadTimeout(HttpServletRequest request) {
0:         long answer = defaultReadTimeout;
0: 
0:         String name = request.getParameter(readTimeoutParameter);
1:         if (name != null) {
0:             answer = asLong(name);
0:         }
0:         if (answer < 0 || answer > maximumReadTimeout) {
0:             answer = maximumReadTimeout;
0:         }
0:         return answer;
0:     }
0: 
1:     /*
1:      * Listen for available messages and wakeup any continuations.
1:      */
0:     private class Listener implements MessageAvailableListener {
1:         MessageConsumer consumer;
1:         Continuation continuation;
0:         List queue = new LinkedList();
0: 
1:         Listener(MessageConsumer consumer) {
1:             this.consumer = consumer;
0:         }
0: 
1:         public void setContinuation(Continuation continuation) {
1:             synchronized (consumer) {
1:                 this.continuation = continuation;
0:             }
0:         }
0: 
1:         public void onMessageAvailable(MessageConsumer consumer) {
1:             assert this.consumer == consumer;
0: 
1:             synchronized (this.consumer) {
0:                 if (continuation != null)
0:                     continuation.resume();
0:                 continuation = null;
0:             }
0:         }
0:     }
0: 
0: }
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:aa2188c
/////////////////////////////////////////////////////////////////////////
1:             String txt = textMsg.getText();
0:             if (txt.startsWith("<?")) {
0:                 txt = txt.substring(txt.indexOf("?>") + 2);
0:             }
0:             writer.print(txt);
author:Gregory John Wilkins
-------------------------------------------------------------------------------
commit:4e5012c
/////////////////////////////////////////////////////////////////////////
0:             if (destination==null)
1:                 throw new NoDestinationSuppliedException();
/////////////////////////////////////////////////////////////////////////
0:             if (destination==null)
1:                 throw new NoDestinationSuppliedException();
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:92a698f
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  *
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
author:Frederick G. Oconer
-------------------------------------------------------------------------------
commit:b6b7cce
============================================================================