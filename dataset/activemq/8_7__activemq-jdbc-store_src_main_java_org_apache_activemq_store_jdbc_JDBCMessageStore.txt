1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:b0c2a40:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
4:d29ca2a:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.store.jdbc;
1:f812e34: 
1:c3801c4: import org.apache.activemq.ActiveMQMessageAudit;
1:d29ca2a: import org.apache.activemq.broker.ConnectionContext;
1:d29ca2a: import org.apache.activemq.command.ActiveMQDestination;
1:d29ca2a: import org.apache.activemq.command.Message;
1:d29ca2a: import org.apache.activemq.command.MessageAck;
1:d29ca2a: import org.apache.activemq.command.MessageId;
1:3155c62: import org.apache.activemq.command.XATransactionId;
1:63e3f41: import org.apache.activemq.store.AbstractMessageStore;
1:54e2e3b: import org.apache.activemq.store.IndexListener;
1:d29ca2a: import org.apache.activemq.store.MessageRecoveryListener;
1:88acb0e: import org.apache.activemq.util.ByteSequence;
1:88acb0e: import org.apache.activemq.util.ByteSequenceData;
1:d29ca2a: import org.apache.activemq.util.IOExceptionSupport;
1:88acb0e: import org.apache.activemq.wireformat.WireFormat;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
6:d29ca2a: 
1:0d90a2a: import java.io.IOException;
1:0d90a2a: import java.sql.SQLException;
1:efaf9cd: import java.util.ArrayList;
1:a2697b8: import java.util.Arrays;
1:6348d11: import java.util.LinkedList;
1:efaf9cd: import java.util.Map;
1:efaf9cd: import java.util.TreeMap;
1:0d90a2a: 
1:d29ca2a: /**
1:b9fad53:  *
1:d29ca2a:  */
1:63e3f41: public class JDBCMessageStore extends AbstractMessageStore {
1:d29ca2a: 
1:cb96783:     class Duration {
1:cb96783:         static final int LIMIT = 100;
1:cb96783:         final long start = System.currentTimeMillis();
1:cb96783:         final String name;
1:d29ca2a: 
1:cb96783:         Duration(String name) {
1:cb96783:             this.name = name;
2:d29ca2a:         }
1:cb96783:         void end() {
1:cb96783:             end(null);
1:eece28a:         }
1:cb96783:         void end(Object o) {
1:cb96783:             long duration = System.currentTimeMillis() - start;
1:eece28a: 
1:cb96783:             if (duration > LIMIT) {
1:cb96783:                 System.err.println(name + " took a long time: " + duration + "ms " + o);
1:cfe099d:             }
1:18d616c:         }
1:d29ca2a:     }
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(JDBCMessageStore.class);
1:d29ca2a:     protected final WireFormat wireFormat;
1:d29ca2a:     protected final JDBCAdapter adapter;
1:d29ca2a:     protected final JDBCPersistenceAdapter persistenceAdapter;
1:24a7626:     protected ActiveMQMessageAudit audit;
1:3042797:     protected final LinkedList<Long> pendingAdditions = new LinkedList<Long>();
1:efaf9cd:     protected final TreeMap<Long, Message> rolledBackAcks = new TreeMap<Long, Message>();
1:a2697b8:     final long[] perPriorityLastRecovered = new long[10];
1:a2697b8: 
1:b6f63b0:     public JDBCMessageStore(JDBCPersistenceAdapter persistenceAdapter, JDBCAdapter adapter, WireFormat wireFormat, ActiveMQDestination destination, ActiveMQMessageAudit audit) throws IOException {
1:63e3f41:         super(destination);
1:d29ca2a:         this.persistenceAdapter = persistenceAdapter;
1:d29ca2a:         this.adapter = adapter;
1:d29ca2a:         this.wireFormat = wireFormat;
1:c3801c4:         this.audit = audit;
1:f812e34: 
1:b6f63b0:         if (destination.isQueue() && persistenceAdapter.getBrokerService().shouldRecordVirtualDestination(destination)) {
1:b6f63b0:             recordDestinationCreation(destination);
1:d29ca2a:         }
1:a2697b8:         resetBatching();
1:d29ca2a:     }
1:d29ca2a: 
1:b6f63b0:     private void recordDestinationCreation(ActiveMQDestination destination) throws IOException {
1:b6f63b0:         TransactionContext c = persistenceAdapter.getTransactionContext();
1:d29ca2a:         try {
1:b6f63b0:             if (adapter.doGetLastAckedDurableSubscriberMessageId(c, destination, destination.getQualifiedName(), destination.getQualifiedName()) < 0) {
1:b6f63b0:                 adapter.doRecordDestination(c, destination);
1:d29ca2a:             }
1:b6f63b0:         } catch (SQLException e) {
1:f812e34:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:b6f63b0:             throw IOExceptionSupport.create("Failed to record destination: " + destination + ". Reason: " + e, e);
1:b6f63b0:         } finally {
1:b6f63b0:             c.close();
1:6348d11:         }
1:6348d11:     }
1:6348d11: 
1:266d23e:     @Override
1:54e2e3b:     public void addMessage(final ConnectionContext context, final Message message) throws IOException {
1:d49b6e5:         MessageId messageId = message.getMessageId();
1:c3801c4:         if (audit != null && audit.isDuplicate(message)) {
2:24a7626:             if (LOG.isDebugEnabled()) {
1:c3801c4:                 LOG.debug(destination.getPhysicalName()
1:c3801c4:                     + " ignoring duplicated (add) message, already stored: "
1:c3801c4:                     + messageId);
1:6348d11:             }
1:d49b6e5:             return;
1:d29ca2a:         }
1:6348d11: 
1:3155c62:         // if xaXid present - this is a prepare - so we don't yet have an outcome
1:3155c62:         final XATransactionId xaXid =  context != null ? context.getXid() : null;
1:3155c62: 
1:d29ca2a:         // Serialize the Message..
1:d29ca2a:         byte data[];
1:d29ca2a:         try {
1:88acb0e:             ByteSequence packet = wireFormat.marshal(message);
1:88acb0e:             data = ByteSequenceData.toByteArray(packet);
1:d29ca2a:         } catch (IOException e) {
1:f812e34:             throw IOExceptionSupport.create("Failed to broker message: " + messageId + " in container: " + e, e);
1:d29ca2a:         }
1:d29ca2a: 
1:d29ca2a:         // Get a connection and insert the message into the DB.
1:d29ca2a:         TransactionContext c = persistenceAdapter.getTransactionContext(context);
1:6348d11:         long sequenceId;
1:6348d11:         synchronized (pendingAdditions) {
1:6348d11:             sequenceId = persistenceAdapter.getNextSequenceId();
1:54e2e3b:             final long sequence = sequenceId;
1:3155c62:             message.getMessageId().setEntryLocator(sequence);
1:54e2e3b: 
1:3155c62:             if (xaXid == null) {
1:3155c62:                 pendingAdditions.add(sequence);
1:3155c62: 
1:3155c62:                 c.onCompletion(new Runnable() {
1:54e2e3b:                     @Override
2:54e2e3b:                     public void run() {
1:3155c62:                         // jdbc close or jms commit - while futureOrSequenceLong==null ordered
1:3155c62:                         // work will remain pending on the Queue
1:3155c62:                         message.getMessageId().setFutureOrSequenceLong(sequence);
1:54e2e3b:                     }
1:3155c62:                 });
1:3155c62: 
1:3155c62:                 if (indexListener != null) {
1:3155c62:                     indexListener.onAdd(new IndexListener.MessageContext(context, message, new Runnable() {
1:3155c62:                         @Override
1:3155c62:                         public void run() {
1:3155c62:                             // cursor add complete
1:3155c62:                             synchronized (pendingAdditions) { pendingAdditions.remove(sequence); }
1:3155c62:                         }
1:3155c62:                     }));
1:3155c62:                 } else {
1:3155c62:                     pendingAdditions.remove(sequence);
1:3155c62:                 }
1:54e2e3b:             }
1:6348d11:         }
1:6348d11:         try {
1:64f3492:             adapter.doAddMessage(c, sequenceId, messageId, destination, data, message.getExpiration(),
1:3155c62:                     this.isPrioritizedMessages() ? message.getPriority() : 0, xaXid);
1:d29ca2a:         } catch (SQLException e) {
1:f812e34:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:d49b6e5:             throw IOExceptionSupport.create("Failed to broker message: " + messageId + " in container: " + e, e);
1:d29ca2a:         } finally {
1:d29ca2a:             c.close();
1:6348d11:         }
1:3155c62:         if (xaXid == null) {
1:3155c62:             onAdd(message, sequenceId, message.getPriority());
1:eece28a:         }
1:3155c62:     }
1:6348d11: 
1:6348d11:     // jdbc commit order is random with concurrent connections - limit scan to lowest pending
1:6348d11:     private long minPendingSequeunceId() {
1:6348d11:         synchronized (pendingAdditions) {
1:6348d11:             if (!pendingAdditions.isEmpty()) {
1:6348d11:                 return pendingAdditions.get(0);
1:54e2e3b:             } else {
1:6348d11:                 // nothing pending, ensure scan is limited to current state
1:6348d11:                 return persistenceAdapter.sequenceGenerator.getLastSequenceId() + 1;
1:6348d11:             }
1:6348d11:         }
1:d29ca2a:     }
1:d29ca2a: 
1:b9fad53:     @Override
1:266d23e:     public void updateMessage(Message message) throws IOException {
1:266d23e:         TransactionContext c = persistenceAdapter.getTransactionContext();
1:266d23e:         try {
1:266d23e:             adapter.doUpdateMessage(c, destination, message.getMessageId(), ByteSequenceData.toByteArray(wireFormat.marshal(message)));
1:266d23e:         } catch (SQLException e) {
1:266d23e:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:266d23e:             throw IOExceptionSupport.create("Failed to update message: " + message.getMessageId() + " in container: " + e, e);
1:266d23e:         } finally {
1:266d23e:             c.close();
1:266d23e:         }
1:266d23e:     }
1:266d23e: 
1:3155c62:     protected void onAdd(Message message, long sequenceId, byte priority) {}
1:d29ca2a: 
1:d29ca2a:     public void addMessageReference(ConnectionContext context, MessageId messageId, long expirationTime, String messageRef) throws IOException {
1:d29ca2a:         // Get a connection and insert the message into the DB.
1:d29ca2a:         TransactionContext c = persistenceAdapter.getTransactionContext(context);
1:d29ca2a:         try {
1:24a7626:             adapter.doAddMessageReference(c, persistenceAdapter.getNextSequenceId(), messageId, destination, expirationTime, messageRef);
1:d29ca2a:         } catch (SQLException e) {
1:f812e34:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:d49b6e5:             throw IOExceptionSupport.create("Failed to broker message: " + messageId + " in container: " + e, e);
1:d29ca2a:         } finally {
1:d29ca2a:             c.close();
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:b9fad53:     @Override
1:d29ca2a:     public Message getMessage(MessageId messageId) throws IOException {
1:d29ca2a:         // Get a connection and pull the message out of the DB
1:d29ca2a:         TransactionContext c = persistenceAdapter.getTransactionContext();
1:d29ca2a:         try {
1:24a7626:             byte data[] = adapter.doGetMessage(c, messageId);
1:ecf89a6:             if (data == null) {
1:d29ca2a:                 return null;
1:ecf89a6:             }
1:d29ca2a: 
1:f812e34:             Message answer = (Message)wireFormat.unmarshal(new ByteSequence(data));
1:d29ca2a:             return answer;
1:d29ca2a:         } catch (IOException e) {
1:d29ca2a:             throw IOExceptionSupport.create("Failed to broker message: " + messageId + " in container: " + e, e);
1:d29ca2a:         } catch (SQLException e) {
1:f812e34:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:d29ca2a:             throw IOExceptionSupport.create("Failed to broker message: " + messageId + " in container: " + e, e);
1:d29ca2a:         } finally {
1:d29ca2a:             c.close();
1:d29ca2a:         }
1:d29ca2a:     }
1:f812e34: 
1:d29ca2a:     public String getMessageReference(MessageId messageId) throws IOException {
2:d29ca2a:         long id = messageId.getBrokerSequenceId();
1:f812e34: 
1:d29ca2a:         // Get a connection and pull the message out of the DB
1:d29ca2a:         TransactionContext c = persistenceAdapter.getTransactionContext();
1:d29ca2a:         try {
1:d29ca2a:             return adapter.doGetMessageReference(c, id);
1:d29ca2a:         } catch (IOException e) {
1:d29ca2a:             throw IOExceptionSupport.create("Failed to broker message: " + messageId + " in container: " + e, e);
1:d29ca2a:         } catch (SQLException e) {
1:f812e34:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:d29ca2a:             throw IOExceptionSupport.create("Failed to broker message: " + messageId + " in container: " + e, e);
1:d29ca2a:         } finally {
1:d29ca2a:             c.close();
1:d29ca2a:         }
1:d29ca2a:     }
1:f812e34: 
1:b9fad53:     @Override
1:d29ca2a:     public void removeMessage(ConnectionContext context, MessageAck ack) throws IOException {
1:d29ca2a: 
1:54e2e3b:     	long seq = ack.getLastMessageId().getFutureOrSequenceLong() != null ?
1:54e2e3b:                 (Long) ack.getLastMessageId().getFutureOrSequenceLong() :
1:ad770ea:                 persistenceAdapter.getStoreSequenceIdForMessageId(context, ack.getLastMessageId(), destination)[0];
1:d29ca2a: 
1:d29ca2a:         // Get a connection and remove the message from the DB
1:d29ca2a:         TransactionContext c = persistenceAdapter.getTransactionContext(context);
1:d29ca2a:         try {
1:64f3492:             adapter.doRemoveMessage(c, seq, context != null ? context.getXid() : null);
1:d29ca2a:         } catch (SQLException e) {
1:24a7626:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:d29ca2a:             throw IOExceptionSupport.create("Failed to broker message: " + ack.getLastMessageId() + " in container: " + e, e);
1:d29ca2a:         } finally {
1:d29ca2a:             c.close();
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:b9fad53:     @Override
1:7f5213b:     public void recover(final MessageRecoveryListener listener) throws Exception {
1:d29ca2a: 
1:d29ca2a:         // Get all the Message ids out of the database.
1:d29ca2a:         TransactionContext c = persistenceAdapter.getTransactionContext();
1:d29ca2a:         try {
1:d29ca2a:             adapter.doRecover(c, destination, new JDBCMessageRecoveryListener() {
1:b9fad53:                 @Override
1:d8cf54b:                 public boolean recoverMessage(long sequenceId, byte[] data) throws Exception {
1:b9fad53:                     if (listener.hasSpace()) {
1:6348d11:                         Message msg = (Message) wireFormat.unmarshal(new ByteSequence(data));
1:d8cf54b:                         msg.getMessageId().setBrokerSequenceId(sequenceId);
1:b9fad53:                         return listener.recoverMessage(msg);
1:6348d11:                     } else {
1:3042797:                         if (LOG.isTraceEnabled()) {
1:b9fad53:                             LOG.trace("Message recovery limit reached for MessageRecoveryListener");
1:d8cf54b:                         }
1:b9fad53:                         return false;
1:3042797:                     }
1:b9fad53:                 }
1:f812e34: 
1:b9fad53:                 @Override
1:d8cf54b:                 public boolean recoverMessageReference(String reference) throws Exception {
1:b9fad53:                     if (listener.hasSpace()) {
1:b9fad53:                         return listener.recoverMessageReference(new MessageId(reference));
2:b9fad53:                     } else {
1:b9fad53:                         if (LOG.isTraceEnabled()) {
1:b9fad53:                             LOG.trace("Message recovery limit reached for MessageRecoveryListener");
1:d8cf54b:                         }
1:b9fad53:                         return false;
1:b9fad53:                     }
1:b9fad53:                 }
1:d8cf54b:             });
1:d29ca2a:         } catch (SQLException e) {
1:f812e34:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:d29ca2a:             throw IOExceptionSupport.create("Failed to recover container. Reason: " + e, e);
1:d29ca2a:         } finally {
1:d29ca2a:             c.close();
1:b9fad53:         }
1:f812e34:     }
1:d8cf54b: 
1:d29ca2a:     /**
1:d29ca2a:      * @see org.apache.activemq.store.MessageStore#removeAllMessages(ConnectionContext)
1:d29ca2a:      */
1:b9fad53:     @Override
1:d29ca2a:     public void removeAllMessages(ConnectionContext context) throws IOException {
1:d29ca2a:         // Get a connection and remove the message from the DB
1:d29ca2a:         TransactionContext c = persistenceAdapter.getTransactionContext(context);
1:d29ca2a:         try {
1:d29ca2a:             adapter.doRemoveAllMessages(c, destination);
1:d29ca2a:         } catch (SQLException e) {
1:f812e34:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:d29ca2a:             throw IOExceptionSupport.create("Failed to broker remove all messages: " + e, e);
1:d29ca2a:         } finally {
1:24a7626:             c.close();
1:f812e34:         }
1:d29ca2a:     }
1:f812e34: 
1:b9fad53:     @Override
1:f812e34:     public int getMessageCount() throws IOException {
1:629bc81:         int result = 0;
1:24a7626:         TransactionContext c = persistenceAdapter.getTransactionContext();
1:24a7626:         try {
1:f812e34: 
1:629bc81:             result = adapter.doGetMessageCount(c, destination);
1:f812e34: 
1:24a7626:         } catch (SQLException e) {
1:f812e34:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:629bc81:             throw IOExceptionSupport.create("Failed to get Message Count: " + destination + ". Reason: " + e, e);
1:24a7626:         } finally {
2:629bc81:             c.close();
1:d29ca2a:         }
1:24a7626:         return result;
1:d29ca2a:     }
1:d29ca2a: 
1:629bc81:     /**
1:629bc81:      * @param maxReturned
1:629bc81:      * @param listener
1:629bc81:      * @throws Exception
1:f812e34:      * @see org.apache.activemq.store.MessageStore#recoverNextMessages(int,
1:f812e34:      *      org.apache.activemq.store.MessageRecoveryListener)
1:8732f70:      */
1:b9fad53:     @Override
1:f812e34:     public void recoverNextMessages(int maxReturned, final MessageRecoveryListener listener) throws Exception {
1:f812e34:         TransactionContext c = persistenceAdapter.getTransactionContext();
1:f812e34:         try {
1:b9fad53:             if (LOG.isTraceEnabled()) {
1:a2697b8:                 LOG.trace(this + " recoverNext lastRecovered:" + Arrays.toString(perPriorityLastRecovered) + ", minPending:" + minPendingSequeunceId());
1:cfe099d:             }
1:efaf9cd: 
1:efaf9cd:             maxReturned -= recoverRolledBackAcks(maxReturned, listener);
1:efaf9cd: 
1:a2697b8:             adapter.doRecoverNextMessages(c, destination, perPriorityLastRecovered, minPendingSequeunceId(),
1:4679c8a:                     maxReturned, isPrioritizedMessages(), new JDBCMessageRecoveryListener() {
1:d29ca2a: 
1:b9fad53:                 @Override
1:13ec994:                 public boolean recoverMessage(long sequenceId, byte[] data) throws Exception {
1:13ec994:                         Message msg = (Message)wireFormat.unmarshal(new ByteSequence(data));
1:13ec994:                         msg.getMessageId().setBrokerSequenceId(sequenceId);
1:13ec994:                         msg.getMessageId().setFutureOrSequenceLong(sequenceId);
1:efaf9cd:                         msg.getMessageId().setEntryLocator(sequenceId);
1:13ec994:                         listener.recoverMessage(msg);
1:13ec994:                         trackLastRecovered(sequenceId, msg.getPriority());
1:13ec994:                         return true;
1:13ec994:                 }
1:f812e34: 
1:b9fad53:                 @Override
1:13ec994:                 public boolean recoverMessageReference(String reference) throws Exception {
1:13ec994:                     if (listener.hasSpace()) {
1:13ec994:                         listener.recoverMessageReference(new MessageId(reference));
1:13ec994:                         return true;
1:13ec994:                     }
1:13ec994:                     return false;
1:13ec994:                 }
1:d8cf54b: 
1:13ec994:             });
1:f812e34:         } catch (SQLException e) {
1:f812e34:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:f812e34:         } finally {
1:d29ca2a:             c.close();
1:d8cf54b:         }
1:f812e34: 
1:d8cf54b:     }
1:d29ca2a: 
1:efaf9cd:     public void trackRollbackAck(Message message) {
1:efaf9cd:         synchronized (rolledBackAcks) {
1:efaf9cd:             rolledBackAcks.put((Long)message.getMessageId().getEntryLocator(), message);
1:efaf9cd:         }
1:efaf9cd:     }
1:efaf9cd: 
1:efaf9cd:     private int recoverRolledBackAcks(int max, MessageRecoveryListener listener) throws Exception {
1:efaf9cd:         int recovered = 0;
1:efaf9cd:         ArrayList<Long> toRemove = new ArrayList<Long>();
1:efaf9cd:         synchronized (rolledBackAcks) {
1:efaf9cd:             if (!rolledBackAcks.isEmpty()) {
1:efaf9cd:                 for ( Map.Entry<Long,Message> candidate : rolledBackAcks.entrySet()) {
1:efaf9cd:                     if (candidate.getKey() <= lastRecovered(candidate.getValue().getPriority())) {
1:efaf9cd:                         listener.recoverMessage(candidate.getValue());
1:efaf9cd:                         recovered++;
1:efaf9cd:                         toRemove.add(candidate.getKey());
1:efaf9cd:                         if (recovered == max) {
1:efaf9cd:                             break;
1:efaf9cd:                         }
1:efaf9cd:                     } else {
1:efaf9cd:                         toRemove.add(candidate.getKey());
1:efaf9cd:                     }
1:efaf9cd:                 }
1:efaf9cd:                 for (Long key : toRemove) {
1:efaf9cd:                     rolledBackAcks.remove(key);
1:efaf9cd:                 }
1:efaf9cd:             }
1:efaf9cd:         }
1:efaf9cd:         return recovered;
1:efaf9cd:     }
1:efaf9cd: 
1:efaf9cd:     private long lastRecovered(int priority) {
1:efaf9cd:         return perPriorityLastRecovered[isPrioritizedMessages() ? priority : 0];
1:efaf9cd:     }
1:efaf9cd: 
1:a2697b8:     private void trackLastRecovered(long sequenceId, int priority) {
1:a2697b8:         perPriorityLastRecovered[isPrioritizedMessages() ? priority : 0] = sequenceId;
1:a2697b8:     }
1:a2697b8: 
1:629bc81:     /**
1:629bc81:      * @see org.apache.activemq.store.MessageStore#resetBatching()
2:629bc81:      */
1:b9fad53:     @Override
1:f812e34:     public void resetBatching() {
1:3432a75:         if (LOG.isTraceEnabled()) {
1:a2697b8:             LOG.trace(this + " resetBatching. last recovered: " + Arrays.toString(perPriorityLastRecovered));
1:cfe099d:         }
1:3985e72:         setLastRecovered(-1);
1:3985e72:     }
1:3985e72: 
1:3985e72:     private void setLastRecovered(long val) {
1:a2697b8:         for (int i=0;i<perPriorityLastRecovered.length;i++) {
1:3985e72:             perPriorityLastRecovered[i] = val;
1:a2697b8:         }
1:cfe099d:     }
1:f812e34: 
1:d29ca2a: 
1:b9fad53:     @Override
1:9bb4682:     public void setBatch(MessageId messageId) {
1:3985e72:         if (LOG.isTraceEnabled()) {
1:3985e72:             LOG.trace(this + " setBatch: last recovered: " + Arrays.toString(perPriorityLastRecovered));
1:3985e72:         }
2:24a7626:         try {
1:ad770ea:             long[] storedValues = persistenceAdapter.getStoreSequenceIdForMessageId(null, messageId, destination);
1:3985e72:             setLastRecovered(storedValues[0]);
1:24a7626:         } catch (IOException ignoredAsAlreadyLogged) {
1:a2697b8:             resetBatching();
1:f812e34:         }
1:3432a75:         if (LOG.isTraceEnabled()) {
1:a2697b8:             LOG.trace(this + " setBatch: new last recovered: " + Arrays.toString(perPriorityLastRecovered));
1:f812e34:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a: 
1:785b16b:     @Override
1:12f0195:     public void setPrioritizedMessages(boolean prioritizedMessages) {
1:12f0195:         super.setPrioritizedMessages(prioritizedMessages);
1:266d23e:     }
1:3042797: 
1:3042797:     @Override
1:3042797:     public String toString() {
1:3042797:         return destination.getPhysicalName() + ",pendingSize:" + pendingAdditions.size();
1:3042797:     }
1:785b16b: 
1:d29ca2a: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:efaf9cd
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.Map;
1: import java.util.TreeMap;
/////////////////////////////////////////////////////////////////////////
1:     protected final TreeMap<Long, Message> rolledBackAcks = new TreeMap<Long, Message>();
/////////////////////////////////////////////////////////////////////////
1: 
1:             maxReturned -= recoverRolledBackAcks(maxReturned, listener);
1: 
/////////////////////////////////////////////////////////////////////////
1:                         msg.getMessageId().setEntryLocator(sequenceId);
/////////////////////////////////////////////////////////////////////////
1:     public void trackRollbackAck(Message message) {
1:         synchronized (rolledBackAcks) {
1:             rolledBackAcks.put((Long)message.getMessageId().getEntryLocator(), message);
1:         }
1:     }
1: 
1:     private int recoverRolledBackAcks(int max, MessageRecoveryListener listener) throws Exception {
1:         int recovered = 0;
1:         ArrayList<Long> toRemove = new ArrayList<Long>();
1:         synchronized (rolledBackAcks) {
1:             if (!rolledBackAcks.isEmpty()) {
1:                 for ( Map.Entry<Long,Message> candidate : rolledBackAcks.entrySet()) {
1:                     if (candidate.getKey() <= lastRecovered(candidate.getValue().getPriority())) {
1:                         listener.recoverMessage(candidate.getValue());
1:                         recovered++;
1:                         toRemove.add(candidate.getKey());
1:                         if (recovered == max) {
1:                             break;
1:                         }
1:                     } else {
1:                         toRemove.add(candidate.getKey());
1:                     }
1:                 }
1:                 for (Long key : toRemove) {
1:                     rolledBackAcks.remove(key);
1:                 }
1:             }
1:         }
1:         return recovered;
1:     }
1: 
1:     private long lastRecovered(int priority) {
1:         return perPriorityLastRecovered[isPrioritizedMessages() ? priority : 0];
1:     }
1: 
commit:13ec994
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 public boolean recoverMessage(long sequenceId, byte[] data) throws Exception {
1:                         Message msg = (Message)wireFormat.unmarshal(new ByteSequence(data));
1:                         msg.getMessageId().setBrokerSequenceId(sequenceId);
1:                         msg.getMessageId().setFutureOrSequenceLong(sequenceId);
1:                         listener.recoverMessage(msg);
1:                         trackLastRecovered(sequenceId, msg.getPriority());
1:                         return true;
1:                 }
1:                 public boolean recoverMessageReference(String reference) throws Exception {
1:                     if (listener.hasSpace()) {
1:                         listener.recoverMessageReference(new MessageId(reference));
1:                         return true;
1:                     }
1:                     return false;
1:                 }
1:             });
commit:d8cf54b
/////////////////////////////////////////////////////////////////////////
1: 
0:                 public boolean hasSpace() {
0:                     return listener.hasSpace();
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                         public boolean recoverMessage(long sequenceId, byte[] data) throws Exception {
0:                             Message msg = (Message)wireFormat.unmarshal(new ByteSequence(data));
1:                             msg.getMessageId().setBrokerSequenceId(sequenceId);
0:                             msg.getMessageId().setFutureOrSequenceLong(sequenceId);
0:                             listener.recoverMessage(msg);
0:                             trackLastRecovered(sequenceId, msg.getPriority());
0:                             return true;
1:                         }
1:                         public boolean recoverMessageReference(String reference) throws Exception {
0:                             listener.recoverMessageReference(new MessageId(reference));
0:                             return true;
1:                         }
0:                         public boolean hasSpace() {
0:                             return listener.hasSpace();
1:                         }
1: 
1:                     });
commit:3985e72
/////////////////////////////////////////////////////////////////////////
1:         setLastRecovered(-1);
1:     }
1: 
1:     private void setLastRecovered(long val) {
1:             perPriorityLastRecovered[i] = val;
1:         if (LOG.isTraceEnabled()) {
1:             LOG.trace(this + " setBatch: last recovered: " + Arrays.toString(perPriorityLastRecovered));
1:         }
1:             setLastRecovered(storedValues[0]);
commit:a2697b8
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
1:     final long[] perPriorityLastRecovered = new long[10];
1: 
/////////////////////////////////////////////////////////////////////////
1:         resetBatching();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 LOG.trace(this + " recoverNext lastRecovered:" + Arrays.toString(perPriorityLastRecovered) + ", minPending:" + minPendingSequeunceId());
1:             adapter.doRecoverNextMessages(c, destination, perPriorityLastRecovered, minPendingSequeunceId(),
/////////////////////////////////////////////////////////////////////////
0:                         trackLastRecovered(sequenceId, msg.getPriority());
/////////////////////////////////////////////////////////////////////////
1:     private void trackLastRecovered(long sequenceId, int priority) {
1:         perPriorityLastRecovered[isPrioritizedMessages() ? priority : 0] = sequenceId;
1:     }
1: 
1:             LOG.trace(this + " resetBatching. last recovered: " + Arrays.toString(perPriorityLastRecovered));
1:         for (int i=0;i<perPriorityLastRecovered.length;i++) {
0:             perPriorityLastRecovered[i] = -1;
1:         }
0:             trackLastRecovered(storedValues[0], (int)storedValues[1]);
1:             resetBatching();
1:             LOG.trace(this + " setBatch: new last recovered: " + Arrays.toString(perPriorityLastRecovered));
commit:eece28a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         if (this.isPrioritizedMessages() && message.getPriority() > lastRecoveredPriority.get()) {
0:             resetTrackedLastRecoveredPriority();
1:         }
/////////////////////////////////////////////////////////////////////////
0:         resetTrackedLastRecoveredPriority();
0:     private final void resetTrackedLastRecoveredPriority() {
0:         lastRecoveredPriority.set(Byte.MAX_VALUE - 1);
1:     }
1: 
commit:3155c62
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.XATransactionId;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // if xaXid present - this is a prepare - so we don't yet have an outcome
1:         final XATransactionId xaXid =  context != null ? context.getXid() : null;
1: 
/////////////////////////////////////////////////////////////////////////
1:             message.getMessageId().setEntryLocator(sequence);
1:             if (xaXid == null) {
1:                 pendingAdditions.add(sequence);
1: 
1:                 c.onCompletion(new Runnable() {
1:                         // jdbc close or jms commit - while futureOrSequenceLong==null ordered
1:                         // work will remain pending on the Queue
1:                         message.getMessageId().setFutureOrSequenceLong(sequence);
1:                 });
1: 
1:                 if (indexListener != null) {
1:                     indexListener.onAdd(new IndexListener.MessageContext(context, message, new Runnable() {
1:                         @Override
1:                         public void run() {
1:                             // cursor add complete
1:                             synchronized (pendingAdditions) { pendingAdditions.remove(sequence); }
1:                         }
1:                     }));
1:                 } else {
1:                     pendingAdditions.remove(sequence);
1:                 }
1:                     this.isPrioritizedMessages() ? message.getPriority() : 0, xaXid);
1:         if (xaXid == null) {
1:             onAdd(message, sequenceId, message.getPriority());
1:         }
/////////////////////////////////////////////////////////////////////////
1:     protected void onAdd(Message message, long sequenceId, byte priority) {}
/////////////////////////////////////////////////////////////////////////
commit:3042797
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected final LinkedList<Long> pendingAdditions = new LinkedList<Long>();
/////////////////////////////////////////////////////////////////////////
0:                     // jdbc close or jms commit - while futureOrSequenceLong==null ordered
0:                     // work will remain pending on the Queue
/////////////////////////////////////////////////////////////////////////
1:             if (LOG.isTraceEnabled()) {
0:                 LOG.trace(this + " recoverNext lastRecovered:" + lastRecoveredSequenceId.get() + ", minPending:" + minPendingSequeunceId());
1:             }
/////////////////////////////////////////////////////////////////////////
0:             LOG.trace(this + " resetBatching, existing last recovered seqId: " + lastRecoveredSequenceId.get());
/////////////////////////////////////////////////////////////////////////
0:             LOG.trace(this + " setBatch: new sequenceId: " + lastRecoveredSequenceId.get()
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     public String toString() {
1:         return destination.getPhysicalName() + ",pendingSize:" + pendingAdditions.size();
1:     }
commit:ad770ea
/////////////////////////////////////////////////////////////////////////
1:                 persistenceAdapter.getStoreSequenceIdForMessageId(context, ack.getLastMessageId(), destination)[0];
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             long[] storedValues = persistenceAdapter.getStoreSequenceIdForMessageId(null, messageId, destination);
commit:54e2e3b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.IndexListener;
/////////////////////////////////////////////////////////////////////////
1:     public void addMessage(final ConnectionContext context, final Message message) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:             final long sequence = sequenceId;
0:             pendingAdditions.add(sequence);
0:             c.onCompletion(new Runnable() {
1:                 public void run() {
0:                     // message added to db
0:                     message.getMessageId().setFutureOrSequenceLong(sequence);
0:                     message.getMessageId().setEntryLocator(sequence);
1:                 }
0:             });
1: 
0:             if (indexListener != null) {
0:                 indexListener.onAdd(new IndexListener.MessageContext(context, message, new Runnable() {
1:                     @Override
1:                     public void run() {
0:                         // cursor add complete
0:                         synchronized (pendingAdditions) { pendingAdditions.remove(sequence); }
1:                     }
0:                 }));
1:             } else {
0:                 pendingAdditions.remove(sequence);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     	long seq = ack.getLastMessageId().getFutureOrSequenceLong() != null ?
1:                 (Long) ack.getLastMessageId().getFutureOrSequenceLong() :
/////////////////////////////////////////////////////////////////////////
0:         //if (context != null && context.getXid() != null) {
0:         //    ack.getLastMessageId().setEntryLocator(seq);
0:         //}
/////////////////////////////////////////////////////////////////////////
0:                         msg.getMessageId().setFutureOrSequenceLong(sequenceId);
commit:3b5d89a
/////////////////////////////////////////////////////////////////////////
0:     	long seq = ack.getLastMessageId().getEntryLocator() != null ?
0:                 (Long) ack.getLastMessageId().getEntryLocator() :
0:                 persistenceAdapter.getStoreSequenceIdForMessageId(ack.getLastMessageId(), destination)[0];
/////////////////////////////////////////////////////////////////////////
0:                         msg.getMessageId().setEntryLocator(sequenceId);
commit:6348d11
/////////////////////////////////////////////////////////////////////////
1: import java.util.LinkedList;
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0:     protected final List<Long> pendingAdditions = new LinkedList<Long>();
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         long sequenceId;
1:         synchronized (pendingAdditions) {
1:             sequenceId = persistenceAdapter.getNextSequenceId();
0:             if (message.isInTransaction()) {
0:                 trackPendingSequence(c, sequenceId);
1:             }
1:         }
1:         try {
/////////////////////////////////////////////////////////////////////////
0:         onAdd(message, sequenceId, message.getPriority());
1:     }
1: 
1:     // jdbc commit order is random with concurrent connections - limit scan to lowest pending
0:     private void trackPendingSequence(final TransactionContext transactionContext, final long sequenceId) {
0:         synchronized (pendingAdditions) { pendingAdditions.add(sequenceId); }
0:         transactionContext.onCompletion(new Runnable() {
0:             public void run() {
0:                 synchronized (pendingAdditions) { pendingAdditions.remove(sequenceId); }
1:             }
0:         });
1:     }
1: 
1:     private long minPendingSequeunceId() {
1:         synchronized (pendingAdditions) {
1:             if (!pendingAdditions.isEmpty()) {
1:                 return pendingAdditions.get(0);
1:             } else {
1:                 // nothing pending, ensure scan is limited to current state
1:                 return persistenceAdapter.sequenceGenerator.getLastSequenceId() + 1;
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
0:     protected void onAdd(Message message, long sequenceId, byte priority) {
0:         if (message.getTransactionId() != null && message.getTransactionId().isXATransaction()
0:                 && lastRecoveredSequenceId.get() > 0 && sequenceId < lastRecoveredSequenceId.get()) {
/////////////////////////////////////////////////////////////////////////
1:                     Message msg = (Message) wireFormat.unmarshal(new ByteSequence(data));
/////////////////////////////////////////////////////////////////////////
0:             adapter.doRecoverNextMessages(c, destination, minPendingSequeunceId(), lastRecoveredSequenceId.get(), lastRecoveredPriority.get(),
commit:27b3a7c
/////////////////////////////////////////////////////////////////////////
0:         message.getMessageId().setEntryLocator(sequenceId);
0:         onAdd(messageId, sequenceId, message.getPriority());
commit:266d23e
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public void updateMessage(Message message) throws IOException {
1:         TransactionContext c = persistenceAdapter.getTransactionContext();
1:         try {
1:             adapter.doUpdateMessage(c, destination, message.getMessageId(), ByteSequenceData.toByteArray(wireFormat.marshal(message)));
1:         } catch (SQLException e) {
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:             throw IOExceptionSupport.create("Failed to update message: " + message.getMessageId() + " in container: " + e, e);
1:         } finally {
1:             c.close();
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     }
commit:cfe099d
/////////////////////////////////////////////////////////////////////////
0: import java.util.Iterator;
0: import java.util.LinkedHashSet;
0: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
0:     final Set<Long> recoveredAdditions = new LinkedHashSet<Long>();
/////////////////////////////////////////////////////////////////////////
0:         if (lastRecoveredSequenceId.get() > 0 && sequenceId < lastRecoveredSequenceId.get()) {
0:             recoveredAdditions.add(sequenceId);
1:         }
/////////////////////////////////////////////////////////////////////////
0:             if (!recoveredAdditions.isEmpty()) {
0:                 for (Iterator<Long> iterator = recoveredAdditions.iterator(); iterator.hasNext(); )  {
0:                     Long sequenceId = iterator.next();
0:                     iterator.remove();
0:                     maxReturned--;
0:                     if (sequenceId <= lastRecoveredSequenceId.get()) {
0:                         Message msg = (Message)wireFormat.unmarshal(new ByteSequence(adapter.doGetMessageById(c, sequenceId)));
0:                         LOG.trace("recovered add {} {}", this, msg.getMessageId());
0:                         listener.recoverMessage(msg);
1:                     }
1:                 }
1:             }
author:Dominik Przybysz
-------------------------------------------------------------------------------
commit:0d90a2a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.sql.SQLException;
0: import java.util.Arrays;
0: import java.util.LinkedList;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:b9fad53
/////////////////////////////////////////////////////////////////////////
1:  *
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
1:                     if (listener.hasSpace()) {
0:                         Message msg = (Message) wireFormat.unmarshal(new ByteSequence(data));
0:                         msg.getMessageId().setBrokerSequenceId(sequenceId);
1:                         return listener.recoverMessage(msg);
1:                     } else {
1:                         if (LOG.isTraceEnabled()) {
1:                             LOG.trace("Message recovery limit reached for MessageRecoveryListener");
1:                         }
1:                         return false;
1:                     }
1:                 @Override
1:                     if (listener.hasSpace()) {
1:                         return listener.recoverMessageReference(new MessageId(reference));
1:                     } else {
1:                         if (LOG.isTraceEnabled()) {
1:                             LOG.trace("Message recovery limit reached for MessageRecoveryListener");
1:                         }
1:                         return false;
1:                     }
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:785b16b
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1: 
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:1399cf9
/////////////////////////////////////////////////////////////////////////
0:             message.getMessageId().setEntryLocator(sequenceId);
/////////////////////////////////////////////////////////////////////////
0:             ack.getLastMessageId().setEntryLocator(seq);
commit:c5cf038
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
1:             if (data == null) {
1:             }
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public JDBCMessageStore(JDBCPersistenceAdapter persistenceAdapter, JDBCAdapter adapter, WireFormat wireFormat, ActiveMQDestination destination) {
/////////////////////////////////////////////////////////////////////////
1: 
0:             throw IOExceptionSupport.create("Failed to broker message: " + message.getMessageId() + " in container: " + e, e);
/////////////////////////////////////////////////////////////////////////
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
0:             throw IOExceptionSupport.create("Failed to broker message: " + message.getMessageId() + " in container: " + e, e);
/////////////////////////////////////////////////////////////////////////
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:             throw IOExceptionSupport.create("Failed to broker message: " + messageId + " in container: " + e, e);
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             Message answer = (Message)wireFormat.unmarshal(new ByteSequence(data));
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
/////////////////////////////////////////////////////////////////////////
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
/////////////////////////////////////////////////////////////////////////
0:                     Message msg = (Message)wireFormat.unmarshal(new ByteSequence(data));
1: 
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
/////////////////////////////////////////////////////////////////////////
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1: 
/////////////////////////////////////////////////////////////////////////
1:     public int getMessageCount() throws IOException {
1: 
1: 
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
/////////////////////////////////////////////////////////////////////////
1:      * @see org.apache.activemq.store.MessageStore#recoverNextMessages(int,
1:      *      org.apache.activemq.store.MessageRecoveryListener)
1:     public void recoverNextMessages(int maxReturned, final MessageRecoveryListener listener) throws Exception {
1:         TransactionContext c = persistenceAdapter.getTransactionContext();
1:         try {
0:             adapter.doRecoverNextMessages(c, destination, lastMessageId.get(), maxReturned, new JDBCMessageRecoveryListener() {
0:                 public boolean recoverMessage(long sequenceId, byte[] data) throws Exception {
0:                     if (listener.hasSpace()) {
0:                         Message msg = (Message)wireFormat.unmarshal(new ByteSequence(data));
0:                         msg.getMessageId().setBrokerSequenceId(sequenceId);
0:                         listener.recoverMessage(msg);
0:                         lastMessageId.set(sequenceId);
0:                         return true;
1:                     }
0:                     return false;
1:                 }
0:                 public boolean recoverMessageReference(String reference) throws Exception {
0:                     if (listener.hasSpace()) {
0:                         listener.recoverMessageReference(new MessageId(reference));
0:                         return true;
1:                     }
0:                     return false;
1:                 }
1: 
0:             });
1:         } catch (SQLException e) {
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:         } finally {
1: 
1:     public void resetBatching() {
1: 
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:0afb7f9
/////////////////////////////////////////////////////////////////////////
0:                     listener.recoverMessageReference(new MessageId(reference));
/////////////////////////////////////////////////////////////////////////
0:                                 listener.recoverMessageReference(new MessageId(reference));
commit:88acb0e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.ByteSequence;
1: import org.apache.activemq.util.ByteSequenceData;
1: import org.apache.activemq.wireformat.WireFormat;
/////////////////////////////////////////////////////////////////////////
1:             ByteSequence packet = wireFormat.marshal(message);
1:             data = ByteSequenceData.toByteArray(packet);
/////////////////////////////////////////////////////////////////////////
0:             Message answer = (Message) wireFormat.unmarshal(new ByteSequence(data));
/////////////////////////////////////////////////////////////////////////
0:                     Message msg = (Message) wireFormat.unmarshal(new ByteSequence(data));
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:18d616c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.memory.UsageManager;
/////////////////////////////////////////////////////////////////////////
0:     public void setUsageManager(UsageManager usageManager) {
0:         // we can ignore since we don't buffer up messages.
1:     }
commit:f451ad0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activeio.command.WireFormat;
0: import org.apache.activeio.packet.ByteArrayPacket;
0: import org.apache.activeio.packet.Packet;
/////////////////////////////////////////////////////////////////////////
0:     public void start() {
0:     public void stop() {
commit:7f5213b
/////////////////////////////////////////////////////////////////////////
1:     public void recover(final MessageRecoveryListener listener) throws Exception {
0:                 public void recoverMessage(long sequenceId, byte[] data) throws Exception {
0:                 public void recoverMessageReference(String reference) throws Exception {
commit:911177e
/////////////////////////////////////////////////////////////////////////
0:             JDBCPersistenceAdapter.log("JDBC Failure: ",e);
/////////////////////////////////////////////////////////////////////////
0:             JDBCPersistenceAdapter.log("JDBC Failure: ",e);
/////////////////////////////////////////////////////////////////////////
0:             JDBCPersistenceAdapter.log("JDBC Failure: ",e);
/////////////////////////////////////////////////////////////////////////
0:             JDBCPersistenceAdapter.log("JDBC Failure: ",e);
/////////////////////////////////////////////////////////////////////////
0:             JDBCPersistenceAdapter.log("JDBC Failure: ",e);
/////////////////////////////////////////////////////////////////////////
0:             JDBCPersistenceAdapter.log("JDBC Failure: ",e);
/////////////////////////////////////////////////////////////////////////
0:             JDBCPersistenceAdapter.log("JDBC Failure: ",e);
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.store.jdbc;
1: 
0: import java.io.IOException;
0: import java.sql.SQLException;
1: 
0: import org.activeio.Packet;
0: import org.activeio.command.WireFormat;
0: import org.activeio.packet.ByteArrayPacket;
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.store.MessageRecoveryListener;
0: import org.apache.activemq.store.MessageStore;
1: import org.apache.activemq.util.IOExceptionSupport;
1: 
1: /**
0:  * @version $Revision: 1.10 $
1:  */
0: public class JDBCMessageStore implements MessageStore {
1: 
1:     protected final WireFormat wireFormat;
0:     protected final ActiveMQDestination destination;
1:     protected final JDBCAdapter adapter;
1:     protected final JDBCPersistenceAdapter persistenceAdapter;
1: 
0:     public JDBCMessageStore(JDBCPersistenceAdapter persistenceAdapter, JDBCAdapter adapter, WireFormat wireFormat,
0:             ActiveMQDestination destination) {
1:         this.persistenceAdapter = persistenceAdapter;
1:         this.adapter = adapter;
1:         this.wireFormat = wireFormat;
0:         this.destination = destination;
1:     }
1: 
0:     public void addMessage(ConnectionContext context, Message message) throws IOException {
1:         
1:         // Serialize the Message..
1:         byte data[];
1:         try {
0:             Packet packet = wireFormat.marshal(message);
0:             data = packet.sliceAsBytes();
1:         } catch (IOException e) {
0:             throw IOExceptionSupport.create("Failed to broker message: " + message.getMessageId() + " in container: "
0:                     + e, e);
1:         }
1: 
1:         // Get a connection and insert the message into the DB.
1:         TransactionContext c = persistenceAdapter.getTransactionContext(context);
1:         try {
0:             adapter.doAddMessage(c, message.getMessageId(), destination, data, message.getExpiration());
1:         } catch (SQLException e) {
0:             throw IOExceptionSupport.create("Failed to broker message: " + message.getMessageId() + " in container: "
0:                     + e, e);
1:         } finally {
1:             c.close();
1:         }
1:     }
1: 
1:     public void addMessageReference(ConnectionContext context, MessageId messageId, long expirationTime, String messageRef) throws IOException {
1:         // Get a connection and insert the message into the DB.
1:         TransactionContext c = persistenceAdapter.getTransactionContext(context);
1:         try {
0:             adapter.doAddMessageReference(c, messageId, destination, expirationTime, messageRef);
1:         } catch (SQLException e) {
0:             throw IOExceptionSupport.create("Failed to broker message: " + messageId + " in container: "
0:                     + e, e);
1:         } finally {
1:             c.close();
1:         }
1:     }
1: 
1:     public Message getMessage(MessageId messageId) throws IOException {
1: 
1:         long id = messageId.getBrokerSequenceId();
1:         
1:         // Get a connection and pull the message out of the DB
1:         TransactionContext c = persistenceAdapter.getTransactionContext();
1:         try {
0:             byte data[] = adapter.doGetMessage(c, id);
0:             if (data == null)
1:                 return null;
1: 
0:             Message answer = (Message) wireFormat.unmarshal(new ByteArrayPacket(data));
1:             return answer;
1:         } catch (IOException e) {
1:             throw IOExceptionSupport.create("Failed to broker message: " + messageId + " in container: " + e, e);
1:         } catch (SQLException e) {
1:             throw IOExceptionSupport.create("Failed to broker message: " + messageId + " in container: " + e, e);
1:         } finally {
1:             c.close();
1:         }
1:     }
1:     
1:     public String getMessageReference(MessageId messageId) throws IOException {
1:         long id = messageId.getBrokerSequenceId();
1:         
1:         // Get a connection and pull the message out of the DB
1:         TransactionContext c = persistenceAdapter.getTransactionContext();
1:         try {
1:             return adapter.doGetMessageReference(c, id);
1:         } catch (IOException e) {
1:             throw IOExceptionSupport.create("Failed to broker message: " + messageId + " in container: " + e, e);
1:         } catch (SQLException e) {
1:             throw IOExceptionSupport.create("Failed to broker message: " + messageId + " in container: " + e, e);
1:         } finally {
1:             c.close();
1:         }
1:     }
1: 
1:     public void removeMessage(ConnectionContext context, MessageAck ack) throws IOException {
0:         long seq = ack.getLastMessageId().getBrokerSequenceId();
1: 
1:         // Get a connection and remove the message from the DB
1:         TransactionContext c = persistenceAdapter.getTransactionContext(context);
1:         try {
0:             adapter.doRemoveMessage(c, seq);
1:         } catch (SQLException e) {
1:             throw IOExceptionSupport.create("Failed to broker message: " + ack.getLastMessageId() + " in container: " + e, e);
1:         } finally {
1:             c.close();
1:         }
1:     }
1: 
0:     public void recover(final MessageRecoveryListener listener) throws Throwable {
1: 
1:         // Get all the Message ids out of the database.
1:         TransactionContext c = persistenceAdapter.getTransactionContext();
1:         try {
0:             c = persistenceAdapter.getTransactionContext();
1:             adapter.doRecover(c, destination, new JDBCMessageRecoveryListener() {
0:                 public void recoverMessage(long sequenceId, byte[] data) throws Throwable {
0:                     Message msg = (Message) wireFormat.unmarshal(new ByteArrayPacket(data));
0:                     msg.getMessageId().setBrokerSequenceId(sequenceId);
0:                     listener.recoverMessage(msg);
1:                 }
0:                 public void recoverMessageReference(String reference) throws IOException, Throwable {
0:                     listener.recoverMessageReference(reference);
1:                 }
0:             });
1:         } catch (SQLException e) {
1:             throw IOExceptionSupport.create("Failed to recover container. Reason: " + e, e);
1:         } finally {
1:             c.close();
1:         }
1:     }
1: 
0:     public void start() throws IOException {
1:     }
1: 
0:     public void stop(long timeout) throws IOException {
1:     }
1: 
1:     /**
1:      * @see org.apache.activemq.store.MessageStore#removeAllMessages(ConnectionContext)
1:      */
1:     public void removeAllMessages(ConnectionContext context) throws IOException {
1:         // Get a connection and remove the message from the DB
1:         TransactionContext c = persistenceAdapter.getTransactionContext(context);
1:         try {
1:             adapter.doRemoveAllMessages(c, destination);
1:         } catch (SQLException e) {
1:             throw IOExceptionSupport.create("Failed to broker remove all messages: " + e, e);
1:         } finally {
1:             c.close();
1:         }
1:     }
1:     
0:     public ActiveMQDestination getDestination() {
0:         return destination;
1:     }
1: 
1: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:7450a32
/////////////////////////////////////////////////////////////////////////
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(JDBCMessageStore.class);
commit:4f5e620
/////////////////////////////////////////////////////////////////////////
0:             result = adapter.getStoreSequenceId(c, destination, messageId)[0];
commit:12f0195
/////////////////////////////////////////////////////////////////////////
0:             adapter.doAddMessage(c,sequenceId, messageId, destination, data, message.getExpiration(), message.getPriority());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     
1:     public void setPrioritizedMessages(boolean prioritizedMessages) {
1:         super.setPrioritizedMessages(prioritizedMessages);
0:         adapter.setPrioritizedMessages(prioritizedMessages);
0:     }   
commit:24a7626
/////////////////////////////////////////////////////////////////////////
0:     protected AtomicLong lastStoreSequenceId = new AtomicLong(-1);
1:     protected ActiveMQMessageAudit audit;
0:     
/////////////////////////////////////////////////////////////////////////
0:         long sequenceId = persistenceAdapter.getNextSequenceId();
0:         
/////////////////////////////////////////////////////////////////////////
1:         try {      
0:             adapter.doAddMessage(c,sequenceId, messageId, destination, data, message.getExpiration());
/////////////////////////////////////////////////////////////////////////
1:             adapter.doAddMessageReference(c, persistenceAdapter.getNextSequenceId(), messageId, destination, expirationTime, messageRef);
/////////////////////////////////////////////////////////////////////////
1:             byte data[] = adapter.doGetMessage(c, messageId);
/////////////////////////////////////////////////////////////////////////
0:     	
0:     	long seq = getStoreSequenceIdForMessageId(ack.getLastMessageId());
/////////////////////////////////////////////////////////////////////////
0:             adapter.doRecoverNextMessages(c, destination, lastStoreSequenceId.get(), maxReturned, new JDBCMessageRecoveryListener() {
0:                         lastStoreSequenceId.set(sequenceId);
/////////////////////////////////////////////////////////////////////////
1:         if (LOG.isDebugEnabled()) {
0:             LOG.debug(destination.getPhysicalName() + " resetBatch, existing last seqId: " + lastStoreSequenceId.get());
0:         }
0:         lastStoreSequenceId.set(-1);
0:         long storeSequenceId = -1;
1:         try {
0:             storeSequenceId = getStoreSequenceIdForMessageId(messageId);
1:         } catch (IOException ignoredAsAlreadyLogged) {
0:             // reset batch in effect with default -1 value
0:         }
1:         if (LOG.isDebugEnabled()) {
0:             LOG.debug(destination.getPhysicalName() + " setBatch: new sequenceId: " + storeSequenceId + ",existing last seqId: " + lastStoreSequenceId.get());
0:         }
0:         lastStoreSequenceId.set(storeSequenceId);
0:     private long getStoreSequenceIdForMessageId(MessageId messageId) throws IOException {
0:         long result = -1;
1:         TransactionContext c = persistenceAdapter.getTransactionContext();
1:         try {
0:             result = adapter.getStoreSequenceId(c, messageId);
1:         } catch (SQLException e) {
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
0:             throw IOExceptionSupport.create("Failed to get store sequenceId for messageId: " + messageId +", on: " + destination + ". Reason: " + e, e);
1:         } finally {
1:             c.close();
0:         }
1:         return result;
0:     }
commit:50dc880
/////////////////////////////////////////////////////////////////////////
0:                         listener.recoverMessage(msg);
0:                         lastMessageId.set(sequenceId);
commit:5170a8b
/////////////////////////////////////////////////////////////////////////
0:                         if (listener.recoverMessage(msg)) {
0:                             lastMessageId.set(sequenceId);
0:                         }
commit:ae840c4
/////////////////////////////////////////////////////////////////////////
commit:c3801c4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.ActiveMQMessageAudit;
/////////////////////////////////////////////////////////////////////////
0:     protected ActiveMQMessageAudit audit;
0:     public JDBCMessageStore(JDBCPersistenceAdapter persistenceAdapter, JDBCAdapter adapter, WireFormat wireFormat, ActiveMQDestination destination, ActiveMQMessageAudit audit) {
1:         this.audit = audit;
1:         if (audit != null && audit.isDuplicate(message)) {
1:                 LOG.debug(destination.getPhysicalName()
1:                     + " ignoring duplicated (add) message, already stored: "
1:                     + messageId);
/////////////////////////////////////////////////////////////////////////
commit:d49b6e5
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
0: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ProducerId;
0: import org.apache.activemq.store.MessageRecoveryListener;
0: import org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0:     private static final Log LOG = LogFactory.getLog(JDBCMessageStore.class);
0:     protected Map<ProducerId, Long> addedMessages = new HashMap<ProducerId, Long>();
/////////////////////////////////////////////////////////////////////////
1:         MessageId messageId = message.getMessageId();
0:         Long lastAddedMessage = addedMessages.get(messageId.getProducerId());
0:         if (lastAddedMessage != null && lastAddedMessage >= messageId.getProducerSequenceId()) {
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("Message " + message + " already added to the database. Skipping.");
0:             }
1:             return;
0:         }
0:         
1:             throw IOExceptionSupport.create("Failed to broker message: " + messageId + " in container: " + e, e);
0:             adapter.doAddMessage(c, messageId, destination, data, message.getExpiration());
0:             addedMessages.put(messageId.getProducerId(), messageId.getProducerSequenceId());
1:             throw IOExceptionSupport.create("Failed to broker message: " + messageId + " in container: " + e, e);
author:Gary Tully
-------------------------------------------------------------------------------
commit:64f3492
/////////////////////////////////////////////////////////////////////////
1:             adapter.doAddMessage(c, sequenceId, messageId, destination, data, message.getExpiration(),
0:                     this.isPrioritizedMessages() ? message.getPriority() : 0, context != null ? context.getXid() : null);
0:         if (context != null && context.getXid() != null) {
0:             message.getMessageId().setDataLocator(sequenceId);
0:         } else {
0:             onAdd(messageId, sequenceId, message.getPriority());
0:         }
/////////////////////////////////////////////////////////////////////////
0: 
0:     	long seq = persistenceAdapter.getStoreSequenceIdForMessageId(ack.getLastMessageId(), destination)[0];
1:             adapter.doRemoveMessage(c, seq, context != null ? context.getXid() : null);
0:         if (context != null && context.getXid() != null) {
0:             ack.getLastMessageId().setDataLocator(seq);
0:         }
/////////////////////////////////////////////////////////////////////////
0:             long[] storedValues = persistenceAdapter.getStoreSequenceIdForMessageId(messageId, destination);
/////////////////////////////////////////////////////////////////////////
0: 
commit:b6f63b0
/////////////////////////////////////////////////////////////////////////
1:     public JDBCMessageStore(JDBCPersistenceAdapter persistenceAdapter, JDBCAdapter adapter, WireFormat wireFormat, ActiveMQDestination destination, ActiveMQMessageAudit audit) throws IOException {
0: 
1:         if (destination.isQueue() && persistenceAdapter.getBrokerService().shouldRecordVirtualDestination(destination)) {
1:             recordDestinationCreation(destination);
0:         }
0: 
1:     private void recordDestinationCreation(ActiveMQDestination destination) throws IOException {
1:         TransactionContext c = persistenceAdapter.getTransactionContext();
0:         try {
0:             c = persistenceAdapter.getTransactionContext();
1:             if (adapter.doGetLastAckedDurableSubscriberMessageId(c, destination, destination.getQualifiedName(), destination.getQualifiedName()) < 0) {
1:                 adapter.doRecordDestination(c, destination);
0:             }
1:         } catch (SQLException e) {
0:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:             throw IOExceptionSupport.create("Failed to record destination: " + destination + ". Reason: " + e, e);
1:         } finally {
1:             c.close();
0:         }
0:     }
0: 
commit:1f816d4
/////////////////////////////////////////////////////////////////////////
0:         onAdd(messageId, sequenceId, message.getPriority());
0:     protected void onAdd(MessageId messageId, long sequenceId, byte priority) {
commit:fe31092
/////////////////////////////////////////////////////////////////////////
0:             adapter.doAddMessage(c,sequenceId, messageId, destination, data, message.getExpiration(),
0:                     this.isPrioritizedMessages() ? message.getPriority() : 0);
commit:cb96783
/////////////////////////////////////////////////////////////////////////
1:     class Duration {
1:         static final int LIMIT = 100;
1:         final long start = System.currentTimeMillis();
1:         final String name;
0: 
1:         Duration(String name) {
1:             this.name = name;
0:         }
1:         void end() {
1:             end(null);
0:         }
1:         void end(Object o) {
1:             long duration = System.currentTimeMillis() - start;
0: 
1:             if (duration > LIMIT) {
1:                 System.err.println(name + " took a long time: " + duration + "ms " + o);
0:             }
0:         }
0:     }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         onAdd(sequenceId, message.getPriority());
0:     }
0: 
0:     protected void onAdd(long sequenceId, byte priority) {
commit:4679c8a
/////////////////////////////////////////////////////////////////////////
0:             adapter.doRecoverNextMessages(c, destination, lastRecoveredSequenceId.get(), lastRecoveredPriority.get(),
1:                     maxReturned, isPrioritizedMessages(), new JDBCMessageRecoveryListener() {
/////////////////////////////////////////////////////////////////////////
commit:3432a75
/////////////////////////////////////////////////////////////////////////
0:     protected AtomicLong lastRecoveredSequenceId = new AtomicLong(-1);
0:     protected AtomicLong lastRecoveredPriority = new AtomicLong(Byte.MAX_VALUE -1);
/////////////////////////////////////////////////////////////////////////
0:     	long seq = getStoreSequenceIdForMessageId(ack.getLastMessageId())[0];
/////////////////////////////////////////////////////////////////////////
0:             adapter.doRecoverNextMessages(c, destination, lastRecoveredSequenceId.get(), lastRecoveredPriority.get(), maxReturned, new JDBCMessageRecoveryListener() {
0:                         lastRecoveredSequenceId.set(sequenceId);
0:                         lastRecoveredPriority.set(msg.getPriority());
/////////////////////////////////////////////////////////////////////////
1:         if (LOG.isTraceEnabled()) {
0:             LOG.trace(destination.getPhysicalName() + " resetBatching, existing last recovered seqId: " + lastRecoveredSequenceId.get());
0:         lastRecoveredSequenceId.set(-1);
0:         lastRecoveredPriority.set(Byte.MAX_VALUE - 1);
0:             long[] storedValues = getStoreSequenceIdForMessageId(messageId);
0:             lastRecoveredSequenceId.set(storedValues[0]);
0:             lastRecoveredPriority.set(storedValues[1]);
0:             lastRecoveredSequenceId.set(-1);
0:             lastRecoveredPriority.set(Byte.MAX_VALUE -1);
1:         if (LOG.isTraceEnabled()) {
0:             LOG.trace(destination.getPhysicalName() + " setBatch: new sequenceId: " + lastRecoveredSequenceId.get()
0:                     + ", priority: " + lastRecoveredPriority.get());
0:     private long[] getStoreSequenceIdForMessageId(MessageId messageId) throws IOException {
0:         long[] result = new long[]{-1, Byte.MAX_VALUE -1};
0:             result = adapter.getStoreSequenceId(c, destination, messageId);
commit:a6a6a70
/////////////////////////////////////////////////////////////////////////
0:             result = adapter.getStoreSequenceId(c, destination, messageId);
commit:8732f70
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         initAudit();
0:     /*
0:      * revisit: This can be destination agnostic and back in the jdbc persistence adapter start
1:      */
0:     public void initAudit() {
0:         if (audit != null) {
0:             try {
0:                 TransactionContext c = persistenceAdapter.getTransactionContext(null);
0:                 adapter.doMessageIdScan(c, destination, 100, new JDBCMessageIdScanListener() {
0:                     public boolean messageId(MessageId id) {
0:                         audit.isDuplicate(id);
0:                         return true;
0:                     }
0:                 });
0:             } catch (Exception e) {
0:                 LOG.error("Failed to reload store message audit for queue store " + destination);
0:             }
0:         }
0:     }
0:     
commit:9bb4682
/////////////////////////////////////////////////////////////////////////
0:     @Override
1:     public void setBatch(MessageId messageId) {
0:         lastMessageId.set(messageId.getBrokerSequenceId());
0:     }
0: 
author:Robert Davies
-------------------------------------------------------------------------------
commit:63e3f41
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.AbstractMessageStore;
/////////////////////////////////////////////////////////////////////////
1: public class JDBCMessageStore extends AbstractMessageStore {
1:         super(destination);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:6d8e2c5
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.usage.MemoryUsage;
0: import org.apache.activemq.usage.SystemUsage;
/////////////////////////////////////////////////////////////////////////
0:     public void setMemoryUsage(MemoryUsage memoryUsage) {
0:        //can ignore as messages aren't buffered
0:    
commit:3a5f48d
/////////////////////////////////////////////////////////////////////////
0:                 public boolean recoverMessage(long sequenceId, byte[] data) throws Exception {
0:                     return listener.recoverMessage(msg);
0:                 public boolean recoverMessageReference(String reference) throws Exception {
0:                     return listener.recoverMessageReference(new MessageId(reference));
/////////////////////////////////////////////////////////////////////////
0:                         public  boolean recoverMessage(long sequenceId,byte[] data) throws Exception{
0:                                 return true;
0:                             return false;
0:                         public boolean recoverMessageReference(String reference) throws Exception{
0:                                 return true;
0:                             return false;
commit:3bf0245
/////////////////////////////////////////////////////////////////////////
0:                             if(listener.hasSpace()){
0:                                 Message msg=(Message)wireFormat.unmarshal(new ByteSequence(data));
0:                                 msg.getMessageId().setBrokerSequenceId(sequenceId);
0:                                 listener.recoverMessage(msg);
0:                                 lastMessageId.set(sequenceId);
0:                             }
0:                             if(listener.hasSpace()) {
0:                                 listener.recoverMessageReference(reference);
0:                             }
commit:629bc81
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicLong;
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:     protected AtomicLong lastMessageId = new AtomicLong(-1);
/////////////////////////////////////////////////////////////////////////
0: 
0:   
0:     public int getMessageCount() throws IOException{
1:         int result = 0;
0:         TransactionContext c = persistenceAdapter.getTransactionContext();
0:         try {
0:             
1:             result = adapter.doGetMessageCount(c, destination);
0:                
0:         } catch (SQLException e) {
0:             JDBCPersistenceAdapter.log("JDBC Failure: ",e);
1:             throw IOExceptionSupport.create("Failed to get Message Count: " + destination + ". Reason: " + e, e);
0:         } finally {
1:             c.close();
0:         }
0:         return result;
0:     }
0: 
1:     /**
1:      * @param maxReturned
1:      * @param listener
1:      * @throws Exception
0:      * @see org.apache.activemq.store.MessageStore#recoverNextMessages(int, org.apache.activemq.store.MessageRecoveryListener)
1:      */
0:     public void recoverNextMessages(int maxReturned,final MessageRecoveryListener listener) throws Exception{
0:         TransactionContext c=persistenceAdapter.getTransactionContext();
0:         
0:         try{
0:             adapter.doRecoverNextMessages(c,destination,lastMessageId.get(),maxReturned,
0:                     new JDBCMessageRecoveryListener(){
0: 
0:                         public void recoverMessage(long sequenceId,byte[] data) throws Exception{
0:                             Message msg=(Message)wireFormat.unmarshal(new ByteSequence(data));
0:                             msg.getMessageId().setBrokerSequenceId(sequenceId);
0:                             listener.recoverMessage(msg);
0:                             lastMessageId.set(sequenceId);
0:                         }
0: 
0:                         public void recoverMessageReference(String reference) throws Exception{
0:                             listener.recoverMessageReference(reference);
0:                         }
0: 
0:                         public void finished(){
0:                             listener.finished();
0:                         }
0:                     });
0:         }catch(SQLException e){
0:             JDBCPersistenceAdapter.log("JDBC Failure: ",e);
0:         }finally{
1:             c.close();
0:         }
0:         
0:     }
0: 
1:     /**
0:      * 
1:      * @see org.apache.activemq.store.MessageStore#resetBatching()
1:      */
0:     public void resetBatching(){
0:         lastMessageId.set(-1);
0:         
0:     }
0: 
commit:2748ae1
/////////////////////////////////////////////////////////////////////////
0:                 public void finished(){
0:                     listener.finished();
0:                 }
============================================================================