1:31c55f7: /*
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:9ef4259:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:9ef4259:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.transport.fanout;
49:d29ca2a: 
1:d29ca2a: import java.io.IOException;
1:d29ca2a: import java.io.InterruptedIOException;
1:d29ca2a: import java.net.URI;
1:31c55f7: import java.security.cert.X509Certificate;
1:d29ca2a: import java.util.ArrayList;
1:d29ca2a: import java.util.Iterator;
1:74a7a8b: import java.util.concurrent.ConcurrentHashMap;
1:9ef4259: import java.util.concurrent.ConcurrentMap;
1:74a7a8b: import java.util.concurrent.atomic.AtomicInteger;
1:d29ca2a: 
1:d29ca2a: import org.apache.activemq.command.Command;
1:d29ca2a: import org.apache.activemq.command.ConsumerInfo;
1:d29ca2a: import org.apache.activemq.command.Message;
1:aace7c6: import org.apache.activemq.command.RemoveInfo;
1:d29ca2a: import org.apache.activemq.command.Response;
1:d29ca2a: import org.apache.activemq.state.ConnectionStateTracker;
1:d29ca2a: import org.apache.activemq.thread.Task;
1:d29ca2a: import org.apache.activemq.thread.TaskRunner;
1:8a01c5d: import org.apache.activemq.thread.TaskRunnerFactory;
1:d29ca2a: import org.apache.activemq.transport.CompositeTransport;
1:f915da5: import org.apache.activemq.transport.DefaultTransportListener;
1:d29ca2a: import org.apache.activemq.transport.FutureResponse;
1:84fd773: import org.apache.activemq.transport.ResponseCallback;
1:d29ca2a: import org.apache.activemq.transport.Transport;
1:d29ca2a: import org.apache.activemq.transport.TransportFactory;
1:d29ca2a: import org.apache.activemq.transport.TransportListener;
1:d29ca2a: import org.apache.activemq.util.IOExceptionSupport;
1:ef61027: import org.apache.activemq.util.ServiceStopper;
1:d29ca2a: import org.apache.activemq.util.ServiceSupport;
1:31c55f7: import org.apache.activemq.wireformat.WireFormat;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:d29ca2a: 
2:d29ca2a: /**
1:d29ca2a:  * A Transport that fans out a connection to multiple brokers.
1:d29ca2a:  */
1:d29ca2a: public class FanoutTransport implements CompositeTransport {
1:d29ca2a: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(FanoutTransport.class);
1:d29ca2a: 
1:d29ca2a:     private TransportListener transportListener;
1:d29ca2a:     private boolean disposed;
1:ecc87ea:     private boolean connected;
1:d29ca2a: 
1:d29ca2a:     private final Object reconnectMutex = new Object();
1:d29ca2a:     private final ConnectionStateTracker stateTracker = new ConnectionStateTracker();
1:9ef4259:     private final ConcurrentMap<Integer, RequestCounter> requestMap = new ConcurrentHashMap<Integer, RequestCounter>();
1:d29ca2a: 
1:8a01c5d:     private final TaskRunnerFactory reconnectTaskFactory;
1:d29ca2a:     private final TaskRunner reconnectTask;
1:d29ca2a:     private boolean started;
1:f812e34: 
1:f392884:     private final ArrayList<FanoutTransportHandler> transports = new ArrayList<FanoutTransportHandler>();
1:933eb2f:     private int connectedCount;
1:f812e34: 
1:d29ca2a:     private int minAckCount = 2;
1:f812e34: 
1:d29ca2a:     private long initialReconnectDelay = 10;
1:d29ca2a:     private long maxReconnectDelay = 1000 * 30;
1:f812e34:     private long backOffMultiplier = 2;
1:f392884:     private final boolean useExponentialBackOff = true;
1:d29ca2a:     private int maxReconnectAttempts;
1:d29ca2a:     private Exception connectionFailure;
1:d29ca2a:     private FanoutTransportHandler primary;
1:ecfae00:     private boolean fanOutQueues = false;
1:f812e34: 
1:d29ca2a:     static class RequestCounter {
1:f812e34: 
1:d29ca2a:         final Command command;
1:d29ca2a:         final AtomicInteger ackCount;
1:f812e34: 
1:d29ca2a:         RequestCounter(Command command, int count) {
1:d29ca2a:             this.command = command;
1:d29ca2a:             this.ackCount = new AtomicInteger(count);
1:d29ca2a:         }
1:31c55f7: 
1:9ef4259:         @Override
1:d29ca2a:         public String toString() {
1:f812e34:             return command.getCommandId() + "=" + ackCount.get();
1:d29ca2a:         }
1:d29ca2a:     }
1:9ef4259: 
1:f915da5:     class FanoutTransportHandler extends DefaultTransportListener {
1:9ef4259: 
1:d29ca2a:         private final URI uri;
1:d29ca2a:         private Transport transport;
1:f812e34: 
1:d29ca2a:         private int connectFailures;
1:d29ca2a:         private long reconnectDelay = initialReconnectDelay;
1:d29ca2a:         private long reconnectDate;
1:f812e34: 
1:d29ca2a:         public FanoutTransportHandler(URI uri) {
1:f812e34:             this.uri = uri;
1:d29ca2a:         }
1:f812e34: 
1:9ef4259:         @Override
1:9ca56a0:         public void onCommand(Object o) {
1:31c55f7:             Command command = (Command) o;
1:d29ca2a:             if (command.isResponse()) {
1:31c55f7:                 Integer id = new Integer(((Response) command).getCorrelationId());
1:933eb2f:                 RequestCounter rc = requestMap.get(id);
1:f812e34:                 if (rc != null) {
1:f812e34:                     if (rc.ackCount.decrementAndGet() <= 0) {
1:d29ca2a:                         requestMap.remove(id);
1:f6e1ac7:                         transportListenerOnCommand(command);
1:d29ca2a:                     }
1:d29ca2a:                 } else {
1:f6e1ac7:                     transportListenerOnCommand(command);
1:d29ca2a:                 }
1:d29ca2a:             } else {
1:f6e1ac7:                 transportListenerOnCommand(command);
1:d29ca2a:             }
1:d29ca2a:         }
1:f812e34: 
1:9ef4259:         @Override
1:d29ca2a:         public void onException(IOException error) {
1:d29ca2a:             try {
1:d29ca2a:                 synchronized (reconnectMutex) {
1:aace7c6:                     if (transport == null || !transport.isConnected()) {
1:d29ca2a:                         return;
1:fc00993:                     }
1:f812e34: 
1:fc00993:                     LOG.debug("Transport failed, starting up reconnect task", error);
1:f812e34: 
1:d29ca2a:                     ServiceSupport.dispose(transport);
1:f812e34:                     transport = null;
1:d29ca2a:                     connectedCount--;
1:f812e34:                     if (primary == this) {
1:d29ca2a:                         primary = null;
1:d29ca2a:                     }
1:d29ca2a:                     reconnectTask.wakeup();
1:d29ca2a:                 }
1:f812e34:             } catch (InterruptedException e) {
1:b75a6da:                 Thread.currentThread().interrupt();
1:f6e1ac7:                 if (transportListener != null) {
1:d29ca2a:                     transportListener.onException(new InterruptedIOException());
1:f812e34:                 }
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:f812e34: 
1:0a12bcb:     public FanoutTransport() {
1:d29ca2a:         // Setup a task that is used to reconnect the a connection async.
1:8a01c5d:         reconnectTaskFactory = new TaskRunnerFactory();
1:8a01c5d:         reconnectTaskFactory.init();
1:8a01c5d:         reconnectTask = reconnectTaskFactory.createTaskRunner(new Task() {
1:9ef4259:             @Override
1:d29ca2a:             public boolean iterate() {
1:d29ca2a:                 return doConnect();
1:d29ca2a:             }
1:f812e34:         }, "ActiveMQ Fanout Worker: " + System.identityHashCode(this));
1:d29ca2a:     }
1:f812e34: 
1:d29ca2a:     /**
1:d29ca2a:      * @return
1:d29ca2a:      */
1:d29ca2a:     private boolean doConnect() {
1:f812e34:         long closestReconnectDate = 0;
1:d29ca2a:         synchronized (reconnectMutex) {
1:ef61027: 
1:f812e34:             if (disposed || connectionFailure != null) {
1:d29ca2a:                 reconnectMutex.notifyAll();
1:d29ca2a:             }
1:d29ca2a: 
1:f812e34:             if (transports.size() == connectedCount || disposed || connectionFailure != null) {
1:d29ca2a:                 return false;
1:d29ca2a:             } else {
1:f812e34: 
1:f812e34:                 if (transports.isEmpty()) {
1:f812e34:                     // connectionFailure = new IOException("No uris available to
1:f812e34:                     // connect to.");
1:d29ca2a:                 } else {
1:f812e34: 
1:d29ca2a:                     // Try to connect them up.
1:933eb2f:                     Iterator<FanoutTransportHandler> iter = transports.iterator();
1:31c55f7:                     while (iter.hasNext() && !disposed) {
1:f812e34: 
1:d29ca2a:                         long now = System.currentTimeMillis();
1:f812e34: 
1:933eb2f:                         FanoutTransportHandler fanoutHandler = iter.next();
1:f812e34:                         if (fanoutHandler.transport != null) {
1:d29ca2a:                             continue;
1:d29ca2a:                         }
1:f812e34: 
1:d29ca2a:                         // Are we waiting a little to try to reconnect this one?
1:f812e34:                         if (fanoutHandler.reconnectDate != 0 && fanoutHandler.reconnectDate > now) {
1:f812e34:                             if (closestReconnectDate == 0 || fanoutHandler.reconnectDate < closestReconnectDate) {
1:d29ca2a:                                 closestReconnectDate = fanoutHandler.reconnectDate;
1:d29ca2a:                             }
1:d29ca2a:                             continue;
1:d29ca2a:                         }
1:f812e34: 
1:d29ca2a:                         URI uri = fanoutHandler.uri;
1:d29ca2a:                         try {
1:fc00993:                             LOG.debug("Stopped: " + this);
1:fc00993:                             LOG.debug("Attempting connect to: " + uri);
1:d29ca2a:                             Transport t = TransportFactory.compositeConnect(uri);
1:d29ca2a:                             fanoutHandler.transport = t;
1:d29ca2a:                             t.setTransportListener(fanoutHandler);
1:d29ca2a:                             if (started) {
1:d29ca2a:                                 restoreTransport(fanoutHandler);
1:d29ca2a:                             }
1:fc00993:                             LOG.debug("Connection established");
1:e547cbd:                             fanoutHandler.reconnectDelay = initialReconnectDelay;
1:d29ca2a:                             fanoutHandler.connectFailures = 0;
1:f812e34:                             if (primary == null) {
1:d29ca2a:                                 primary = fanoutHandler;
1:d29ca2a:                             }
1:328229b:                             connectedCount++;
1:f812e34:                         } catch (Exception e) {
1:fc00993:                             LOG.debug("Connect fail to: " + uri + ", reason: " + e);
1:328229b: 
1:31c55f7:                             if (fanoutHandler.transport != null) {
1:328229b:                                 ServiceSupport.dispose(fanoutHandler.transport);
1:31c55f7:                                 fanoutHandler.transport = null;
1:328229b:                             }
1:9ef4259: 
1:d29ca2a:                             if (maxReconnectAttempts > 0 && ++fanoutHandler.connectFailures >= maxReconnectAttempts) {
1:fc00993:                                 LOG.error("Failed to connect to transport after: " + fanoutHandler.connectFailures + " attempt(s)");
1:d29ca2a:                                 connectionFailure = e;
1:d29ca2a:                                 reconnectMutex.notifyAll();
1:d29ca2a:                                 return false;
1:d29ca2a:                             } else {
1:f812e34: 
1:d29ca2a:                                 if (useExponentialBackOff) {
1:d29ca2a:                                     // Exponential increment of reconnect delay.
1:d29ca2a:                                     fanoutHandler.reconnectDelay *= backOffMultiplier;
1:fc00993:                                     if (fanoutHandler.reconnectDelay > maxReconnectDelay) {
1:d29ca2a:                                         fanoutHandler.reconnectDelay = maxReconnectDelay;
1:fc00993:                                     }
1:d29ca2a:                                 }
1:f812e34: 
1:d29ca2a:                                 fanoutHandler.reconnectDate = now + fanoutHandler.reconnectDelay;
1:f812e34: 
1:f812e34:                                 if (closestReconnectDate == 0 || fanoutHandler.reconnectDate < closestReconnectDate) {
1:d29ca2a:                                     closestReconnectDate = fanoutHandler.reconnectDate;
1:d29ca2a:                                 }
1:d29ca2a:                             }
1:d29ca2a:                         }
1:d29ca2a:                     }
1:f812e34: 
1:f812e34:                     if (transports.size() == connectedCount || disposed) {
1:d29ca2a:                         reconnectMutex.notifyAll();
1:d29ca2a:                         return false;
1:d29ca2a:                     }
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a:         }
1:f812e34: 
1:d29ca2a:         try {
1:d29ca2a:             long reconnectDelay = closestReconnectDate - System.currentTimeMillis();
1:f812e34:             if (reconnectDelay > 0) {
1:fc00993:                 LOG.debug("Waiting " + reconnectDelay + " ms before attempting connection. ");
1:d29ca2a:                 Thread.sleep(reconnectDelay);
1:d29ca2a:             }
1:f812e34:         } catch (InterruptedException e1) {
1:d29ca2a:             Thread.currentThread().interrupt();
1:d29ca2a:         }
1:d29ca2a:         return true;
1:d29ca2a:     }
1:d29ca2a: 
1:9ef4259:     @Override
1:d29ca2a:     public void start() throws Exception {
1:d29ca2a:         synchronized (reconnectMutex) {
1:fc00993:             LOG.debug("Started.");
1:fc00993:             if (started) {
1:d29ca2a:                 return;
1:fc00993:             }
1:d29ca2a:             started = true;
1:933eb2f:             for (Iterator<FanoutTransportHandler> iter = transports.iterator(); iter.hasNext();) {
1:933eb2f:                 FanoutTransportHandler th = iter.next();
1:f812e34:                 if (th.transport != null) {
1:d29ca2a:                     restoreTransport(th);
1:d29ca2a:                 }
1:d29ca2a:             }
1:31c55f7:             connected = true;
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:9ef4259:     @Override
1:d29ca2a:     public void stop() throws Exception {
1:8a01c5d:         try {
1:d29ca2a:             synchronized (reconnectMutex) {
1:f812e34:                 ServiceStopper ss = new ServiceStopper();
1:f812e34: 
1:fc00993:                 if (!started) {
1:d29ca2a:                     return;
1:fc00993:                 }
1:d29ca2a:                 started = false;
1:d29ca2a:                 disposed = true;
1:31c55f7:                 connected = false;
1:ef61027: 
1:933eb2f:                 for (Iterator<FanoutTransportHandler> iter = transports.iterator(); iter.hasNext();) {
1:933eb2f:                     FanoutTransportHandler th = iter.next();
1:f812e34:                     if (th.transport != null) {
1:f812e34:                         ss.stop(th.transport);
1:d29ca2a:                     }
1:d29ca2a:                 }
1:f812e34: 
1:fc00993:                 LOG.debug("Stopped: " + this);
1:ef61027:                 ss.throwFirstException();
1:d29ca2a:             }
1:8a01c5d:         } finally {
1:ef61027:             reconnectTask.shutdown();
1:8a01c5d:             reconnectTaskFactory.shutdownNow();
1:d29ca2a:         }
1:d29ca2a:     }
1:ef61027: 
1:9ef4259:     public int getMinAckCount() {
1:9ef4259:         return minAckCount;
1:9ef4259:     }
1:ef61027: 
1:9ef4259:     public void setMinAckCount(int minAckCount) {
1:9ef4259:         this.minAckCount = minAckCount;
1:9ef4259:     }
1:9ef4259: 
1:d29ca2a:     public long getInitialReconnectDelay() {
1:d29ca2a:         return initialReconnectDelay;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public void setInitialReconnectDelay(long initialReconnectDelay) {
1:d29ca2a:         this.initialReconnectDelay = initialReconnectDelay;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public long getMaxReconnectDelay() {
1:d29ca2a:         return maxReconnectDelay;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public void setMaxReconnectDelay(long maxReconnectDelay) {
1:d29ca2a:         this.maxReconnectDelay = maxReconnectDelay;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public long getReconnectDelayExponent() {
1:d29ca2a:         return backOffMultiplier;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public void setReconnectDelayExponent(long reconnectDelayExponent) {
1:d29ca2a:         this.backOffMultiplier = reconnectDelayExponent;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public int getMaxReconnectAttempts() {
1:d29ca2a:         return maxReconnectAttempts;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public void setMaxReconnectAttempts(int maxReconnectAttempts) {
1:d29ca2a:         this.maxReconnectAttempts = maxReconnectAttempts;
1:d29ca2a:     }
1:d29ca2a: 
1:9ef4259:     @Override
1:9ca56a0:     public void oneway(Object o) throws IOException {
1:31c55f7:         final Command command = (Command) o;
1:d29ca2a:         try {
1:d29ca2a:             synchronized (reconnectMutex) {
1:f812e34: 
1:d29ca2a:                 // Wait for transport to be connected.
1:1ea24bf:                 while (connectedCount < minAckCount && !disposed && connectionFailure == null) {
1:fc00993:                     LOG.debug("Waiting for at least " + minAckCount + " transports to be connected.");
1:d29ca2a:                     reconnectMutex.wait(1000);
1:d29ca2a:                 }
1:d29ca2a: 
1:d29ca2a:                 // Still not fully connected.
1:1ea24bf:                 if (connectedCount < minAckCount) {
1:d29ca2a: 
1:d29ca2a:                     Exception error;
1:f812e34: 
1:d29ca2a:                     // Throw the right kind of error..
1:d29ca2a:                     if (disposed) {
1:d29ca2a:                         error = new IOException("Transport disposed.");
1:f812e34:                     } else if (connectionFailure != null) {
1:d29ca2a:                         error = connectionFailure;
1:d29ca2a:                     } else {
1:d29ca2a:                         error = new IOException("Unexpected failure.");
1:d29ca2a:                     }
1:d29ca2a: 
1:fc00993:                     if (error instanceof IOException) {
1:31c55f7:                         throw (IOException) error;
1:fc00993:                     }
1:d29ca2a:                     throw IOExceptionSupport.create(error);
1:d29ca2a:                 }
1:d29ca2a: 
1:d29ca2a:                 // If it was a request and it was not being tracked by
1:d29ca2a:                 // the state tracker,
1:d29ca2a:                 // then hold it in the requestMap so that we can replay
1:d29ca2a:                 // it later.
1:d29ca2a:                 boolean fanout = isFanoutCommand(command);
1:f812e34:                 if (stateTracker.track(command) == null && command.isResponseRequired()) {
1:d29ca2a:                     int size = fanout ? minAckCount : 1;
1:1ea24bf:                     requestMap.put(new Integer(command.getCommandId()), new RequestCounter(command, size));
1:d29ca2a:                 }
1:9ef4259: 
1:d29ca2a:                 // Send the message.
1:f812e34:                 if (fanout) {
1:933eb2f:                     for (Iterator<FanoutTransportHandler> iter = transports.iterator(); iter.hasNext();) {
1:933eb2f:                         FanoutTransportHandler th = iter.next();
1:f812e34:                         if (th.transport != null) {
1:d29ca2a:                             try {
1:d29ca2a:                                 th.transport.oneway(command);
1:d29ca2a:                             } catch (IOException e) {
1:fc00993:                                 LOG.debug("Send attempt: failed.");
1:d29ca2a:                                 th.onException(e);
1:d29ca2a:                             }
1:d29ca2a:                         }
1:d29ca2a:                     }
1:d29ca2a:                 } else {
1:d29ca2a:                     try {
1:d29ca2a:                         primary.transport.oneway(command);
1:d29ca2a:                     } catch (IOException e) {
1:fc00993:                         LOG.debug("Send attempt: failed.");
1:d29ca2a:                         primary.onException(e);
1:d29ca2a:                     }
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a:         } catch (InterruptedException e) {
1:d29ca2a:             // Some one may be trying to stop our thread.
1:b75a6da:             Thread.currentThread().interrupt();
1:d29ca2a:             throw new InterruptedIOException();
1:d29ca2a:         }
1:d29ca2a:     }
1:f812e34: 
1:d29ca2a:     /**
1:d29ca2a:      * @param command
1:d29ca2a:      * @return
1:d29ca2a:      */
1:d29ca2a:     private boolean isFanoutCommand(Command command) {
1:f812e34:         if (command.isMessage()) {
1:31c55f7:             if (fanOutQueues) {
1:328229b:                 return true;
1:328229b:             }
1:31c55f7:             return ((Message) command).getDestination().isTopic();
1:f812e34:         }
1:31c55f7:         if (command.getDataStructureType() == ConsumerInfo.DATA_STRUCTURE_TYPE || command.getDataStructureType() == RemoveInfo.DATA_STRUCTURE_TYPE) {
1:d29ca2a:             return false;
1:d29ca2a:         }
1:d29ca2a:         return true;
1:d29ca2a:     }
1:f812e34: 
1:9ef4259:     @Override
1:9ca56a0:     public FutureResponse asyncRequest(Object command, ResponseCallback responseCallback) throws IOException {
1:d29ca2a:         throw new AssertionError("Unsupported Method");
1:d29ca2a:     }
1:d29ca2a: 
1:9ef4259:     @Override
1:9ca56a0:     public Object request(Object command) throws IOException {
1:d29ca2a:         throw new AssertionError("Unsupported Method");
1:d29ca2a:     }
1:f812e34: 
1:9ef4259:     @Override
1:f812e34:     public Object request(Object command, int timeout) throws IOException {
1:5fe0a4c:         throw new AssertionError("Unsupported Method");
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public void reconnect() {
1:fc00993:         LOG.debug("Waking up reconnect task");
1:d29ca2a:         try {
1:d29ca2a:             reconnectTask.wakeup();
1:d29ca2a:         } catch (InterruptedException e) {
1:d29ca2a:             Thread.currentThread().interrupt();
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:9ef4259:     @Override
1:436fe42:     public TransportListener getTransportListener() {
1:436fe42:         return transportListener;
1:d29ca2a:     }
1:d29ca2a: 
1:9ef4259:     @Override
1:d29ca2a:     public void setTransportListener(TransportListener commandListener) {
1:d29ca2a:         this.transportListener = commandListener;
1:d29ca2a:     }
1:d29ca2a: 
1:9ef4259:     @Override
1:933eb2f:     public <T> T narrow(Class<T> target) {
1:d29ca2a:         if (target.isAssignableFrom(getClass())) {
1:933eb2f:             return target.cast(this);
1:d29ca2a:         }
1:f812e34: 
1:d29ca2a:         synchronized (reconnectMutex) {
1:933eb2f:             for (Iterator<FanoutTransportHandler> iter = transports.iterator(); iter.hasNext();) {
1:933eb2f:                 FanoutTransportHandler th = iter.next();
1:f812e34:                 if (th.transport != null) {
1:933eb2f:                     T rc = th.transport.narrow(target);
1:fc00993:                     if (rc != null) {
1:d29ca2a:                         return rc;
1:fc00993:                     }
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a:         }
1:31c55f7: 
1:d29ca2a:         return null;
1:d29ca2a:     }
1:f812e34: 
1:d29ca2a:     protected void restoreTransport(FanoutTransportHandler th) throws Exception, IOException {
1:d29ca2a:         th.transport.start();
1:f812e34:         stateTracker.setRestoreConsumers(th.transport == primary);
1:d29ca2a:         stateTracker.restore(th.transport);
1:933eb2f:         for (Iterator<RequestCounter> iter2 = requestMap.values().iterator(); iter2.hasNext();) {
1:933eb2f:             RequestCounter rc = iter2.next();
1:d29ca2a:             th.transport.oneway(rc.command);
1:d29ca2a:         }
1:d29ca2a:     }
1:f812e34: 
1:31c55f7:     @Override
1:31c55f7:     public void add(boolean reblance, URI uris[]) {
1:d29ca2a:         synchronized (reconnectMutex) {
1:d29ca2a:             for (int i = 0; i < uris.length; i++) {
1:d29ca2a:                 URI uri = uris[i];
1:f812e34: 
2:f812e34:                 boolean match = false;
1:933eb2f:                 for (Iterator<FanoutTransportHandler> iter = transports.iterator(); iter.hasNext();) {
1:933eb2f:                     FanoutTransportHandler th = iter.next();
1:f812e34:                     if (th.uri.equals(uri)) {
1:f812e34:                         match = true;
1:d29ca2a:                         break;
1:d29ca2a:                     }
1:d29ca2a:                 }
1:31c55f7: 
1:f812e34:                 if (!match) {
1:d29ca2a:                     FanoutTransportHandler th = new FanoutTransportHandler(uri);
1:d29ca2a:                     transports.add(th);
1:d29ca2a:                     reconnect();
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:f812e34: 
1:9ef4259:     @Override
1:31c55f7:     public void remove(boolean rebalance, URI uris[]) {
1:d29ca2a:         synchronized (reconnectMutex) {
1:d29ca2a:             for (int i = 0; i < uris.length; i++) {
1:d29ca2a:                 URI uri = uris[i];
1:f812e34: 
1:933eb2f:                 for (Iterator<FanoutTransportHandler> iter = transports.iterator(); iter.hasNext();) {
1:933eb2f:                     FanoutTransportHandler th = iter.next();
1:f812e34:                     if (th.uri.equals(uri)) {
1:f812e34:                         if (th.transport != null) {
1:d29ca2a:                             ServiceSupport.dispose(th.transport);
1:d29ca2a:                             connectedCount--;
1:d29ca2a:                         }
1:d29ca2a:                         iter.remove();
1:d29ca2a:                         break;
1:d29ca2a:                     }
1:d29ca2a:                 }
1:8a01c5d:             }
1:8a01c5d:         }
1:8a01c5d:     }
1:f812e34: 
1:9ef4259:     @Override
1:3ac0537:     public void reconnect(URI uri) throws IOException {
1:31c55f7:         add(true, new URI[] { uri });
1:9ef4259:     }
1:9ef4259: 
1:9ef4259:     @Override
1:f392884:     public boolean isReconnectSupported() {
1:f392884:         return true;
1:e547cbd:     }
1:f812e34: 
1:9ef4259:     @Override
1:f392884:     public boolean isUpdateURIsSupported() {
1:f392884:         return true;
3:f392884:     }
1:d29ca2a: 
1:31c55f7:     @Override
1:31c55f7:     public void updateURIs(boolean reblance, URI[] uris) throws IOException {
1:31c55f7:         add(reblance, uris);
1:31c55f7:     }
1:d29ca2a: 
1:9ef4259:     @Override
1:f812e34:     public String getRemoteAddress() {
1:f812e34:         if (primary != null) {
1:f812e34:             if (primary.transport != null) {
1:f812e34:                 return primary.transport.getRemoteAddress();
1:f812e34:             }
1:f812e34:         }
1:f812e34:         return null;
1:f812e34:     }
1:d29ca2a: 
1:f6e1ac7:     protected void transportListenerOnCommand(Command command) {
1:f6e1ac7:         if (transportListener != null) {
3:d29ca2a:             transportListener.onCommand(command);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:f392884:     @Override
1:f812e34:     public boolean isFaultTolerant() {
1:c7469c4:         return true;
1:d29ca2a:     }
1:d29ca2a: 
1:328229b:     public boolean isFanOutQueues() {
1:328229b:         return fanOutQueues;
1:328229b:     }
1:328229b: 
1:328229b:     public void setFanOutQueues(boolean fanOutQueues) {
1:328229b:         this.fanOutQueues = fanOutQueues;
1:328229b:     }
1:328229b: 
1:9ef4259:     @Override
1:9ef4259:     public boolean isDisposed() {
1:9ef4259:         return disposed;
1:9ef4259:     }
1:9ef4259: 
1:9ef4259:     @Override
1:ecc87ea:     public boolean isConnected() {
1:ecc87ea:         return connected;
1:d29ca2a:     }
1:8978ac0: 
1:9ef4259:     @Override
1:8978ac0:     public int getReceiveCounter() {
1:8978ac0:         int rc = 0;
1:8978ac0:         synchronized (reconnectMutex) {
1:8978ac0:             for (FanoutTransportHandler th : transports) {
1:8978ac0:                 if (th.transport != null) {
1:8978ac0:                     rc += th.transport.getReceiveCounter();
1:8978ac0:                 }
1:8978ac0:             }
1:8978ac0:         }
1:8978ac0:         return rc;
1:8978ac0:     }
1:d29ca2a: 
1:f392884:     @Override
1:31c55f7:     public X509Certificate[] getPeerCertificates() {
1:31c55f7:         return null;
1:31c55f7:     }
1:31c55f7: 
1:31c55f7:     @Override
1:31c55f7:     public void setPeerCertificates(X509Certificate[] certificates) {
1:31c55f7: 
1:31c55f7:     }
1:31c55f7: 
1:31c55f7:     @Override
1:31c55f7:     public WireFormat getWireFormat() {
1:31c55f7:         return null;
1:31c55f7:     }
1:d29ca2a: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
commit:ecfae00
/////////////////////////////////////////////////////////////////////////
1:     private boolean fanOutQueues = false;
author:Timothy Bish
-------------------------------------------------------------------------------
commit:31c55f7
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
1: import java.security.cert.X509Certificate;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.wireformat.WireFormat;
/////////////////////////////////////////////////////////////////////////
1:             Command command = (Command) o;
1:                 Integer id = new Integer(((Response) command).getCorrelationId());
/////////////////////////////////////////////////////////////////////////
1:                     while (iter.hasNext() && !disposed) {
/////////////////////////////////////////////////////////////////////////
1:                             if (fanoutHandler.transport != null) {
1:                                 fanoutHandler.transport = null;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             connected = true;
/////////////////////////////////////////////////////////////////////////
1:                 connected = false;
/////////////////////////////////////////////////////////////////////////
1:         final Command command = (Command) o;
/////////////////////////////////////////////////////////////////////////
1:                         throw (IOException) error;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             if (fanOutQueues) {
1:             return ((Message) command).getDestination().isTopic();
1:         if (command.getDataStructureType() == ConsumerInfo.DATA_STRUCTURE_TYPE || command.getDataStructureType() == RemoveInfo.DATA_STRUCTURE_TYPE) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void add(boolean reblance, URI uris[]) {
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void remove(boolean rebalance, URI uris[]) {
/////////////////////////////////////////////////////////////////////////
1:         add(true, new URI[] { uri });
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public void updateURIs(boolean reblance, URI[] uris) throws IOException {
1:         add(reblance, uris);
1:     }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     public X509Certificate[] getPeerCertificates() {
1:         return null;
1:     }
1: 
1:     @Override
1:     public void setPeerCertificates(X509Certificate[] certificates) {
1: 
1:     }
1: 
1:     @Override
1:     public WireFormat getWireFormat() {
1:         return null;
1:     }
commit:9ef4259
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentMap;
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
/////////////////////////////////////////////////////////////////////////
1:     private final ConcurrentMap<Integer, RequestCounter> requestMap = new ConcurrentHashMap<Integer, RequestCounter>();
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     public int getMinAckCount() {
1:         return minAckCount;
1:     }
1:     public void setMinAckCount(int minAckCount) {
1:         this.minAckCount = minAckCount;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
0:         add(true,new URI[]{uri});
1: 
1:     }
1: 
1:     @Override
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public boolean isDisposed() {
1:         return disposed;
1:     }
1: 
1:     @Override
1:     @Override
author:gtully
-------------------------------------------------------------------------------
commit:0a12bcb
/////////////////////////////////////////////////////////////////////////
1:     public FanoutTransport() {
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:9a8f6e4
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
0:  * 
commit:8978ac0
/////////////////////////////////////////////////////////////////////////
1: 
1:     public int getReceiveCounter() {
1:         int rc = 0;
1:         synchronized (reconnectMutex) {
1:             for (FanoutTransportHandler th : transports) {
1:                 if (th.transport != null) {
1:                     rc += th.transport.getReceiveCounter();
1:                 }
1:             }
1:         }
1:         return rc;
1:     }
commit:328229b
/////////////////////////////////////////////////////////////////////////
0:     private boolean fanOutQueues;
/////////////////////////////////////////////////////////////////////////
1:                             connectedCount++;
0:                             if( fanoutHandler.transport !=null ) {
1:                                 ServiceSupport.dispose(fanoutHandler.transport);
0:                                 fanoutHandler.transport=null;
1:                             }
1:                             
/////////////////////////////////////////////////////////////////////////
0:             if( fanOutQueues ) {
1:                 return true;
1:             }
/////////////////////////////////////////////////////////////////////////
1:     public boolean isFanOutQueues() {
1:         return fanOutQueues;
1:     }
1: 
1:     public void setFanOutQueues(boolean fanOutQueues) {
1:         this.fanOutQueues = fanOutQueues;
1:     }
1: 
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
0:     private final ConcurrentHashMap<Integer, RequestCounter> requestMap = new ConcurrentHashMap<Integer, RequestCounter>();
0:     private ArrayList<FanoutTransportHandler> transports = new ArrayList<FanoutTransportHandler>();
1:     private int connectedCount;
/////////////////////////////////////////////////////////////////////////
1:                 RequestCounter rc = requestMap.get(id);
/////////////////////////////////////////////////////////////////////////
1:                     Iterator<FanoutTransportHandler> iter = transports.iterator();
1:                         FanoutTransportHandler fanoutHandler = iter.next();
/////////////////////////////////////////////////////////////////////////
1:             for (Iterator<FanoutTransportHandler> iter = transports.iterator(); iter.hasNext();) {
1:                 FanoutTransportHandler th = iter.next();
/////////////////////////////////////////////////////////////////////////
1:             for (Iterator<FanoutTransportHandler> iter = transports.iterator(); iter.hasNext();) {
1:                 FanoutTransportHandler th = iter.next();
/////////////////////////////////////////////////////////////////////////
1:                     for (Iterator<FanoutTransportHandler> iter = transports.iterator(); iter.hasNext();) {
1:                         FanoutTransportHandler th = iter.next();
/////////////////////////////////////////////////////////////////////////
1:     public <T> T narrow(Class<T> target) {
1:             return target.cast(this);
1:             for (Iterator<FanoutTransportHandler> iter = transports.iterator(); iter.hasNext();) {
1:                 FanoutTransportHandler th = iter.next();
1:                     T rc = th.transport.narrow(target);
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<RequestCounter> iter2 = requestMap.values().iterator(); iter2.hasNext();) {
1:             RequestCounter rc = iter2.next();
/////////////////////////////////////////////////////////////////////////
1:                 for (Iterator<FanoutTransportHandler> iter = transports.iterator(); iter.hasNext();) {
1:                     FanoutTransportHandler th = iter.next();
/////////////////////////////////////////////////////////////////////////
1:                 for (Iterator<FanoutTransportHandler> iter = transports.iterator(); iter.hasNext();) {
1:                     FanoutTransportHandler th = iter.next();
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(FanoutTransport.class);
/////////////////////////////////////////////////////////////////////////
0:                     if (transport == null) {
1:                     }
1:                     LOG.debug("Transport failed, starting up reconnect task", error);
/////////////////////////////////////////////////////////////////////////
1:                             LOG.debug("Stopped: " + this);
1:                             LOG.debug("Attempting connect to: " + uri);
1:                             LOG.debug("Connection established");
/////////////////////////////////////////////////////////////////////////
1:                             LOG.debug("Connect fail to: " + uri + ", reason: " + e);
1:                                 LOG.error("Failed to connect to transport after: " + fanoutHandler.connectFailures + " attempt(s)");
/////////////////////////////////////////////////////////////////////////
1:                                     if (fanoutHandler.reconnectDelay > maxReconnectDelay) {
1:                                     }
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Waiting " + reconnectDelay + " ms before attempting connection. ");
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug("Started.");
1:             if (started) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if (!started) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug("Stopped: " + this);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.debug("Waiting for at least " + minAckCount + " transports to be connected.");
/////////////////////////////////////////////////////////////////////////
1:                     if (error instanceof IOException) {
1:                     }
/////////////////////////////////////////////////////////////////////////
1:                                 LOG.debug("Send attempt: failed.");
/////////////////////////////////////////////////////////////////////////
1:                         LOG.debug("Send attempt: failed.");
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("Waking up reconnect task");
/////////////////////////////////////////////////////////////////////////
1:                     if (rc != null) {
1:                     }
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.atomic.AtomicInteger;
/////////////////////////////////////////////////////////////////////////
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1: 
0:     private int connectedCount = 0;
1: 
1: 
1:     private long backOffMultiplier = 2;
1: 
1: 
1: 
1: 
1:             return command.getCommandId() + "=" + ackCount.get();
1: 
/////////////////////////////////////////////////////////////////////////
1:             this.uri = uri;
0:             Command command = (Command)o;
0:                 Integer id = new Integer(((Response)command).getCorrelationId());
0:                 RequestCounter rc = (RequestCounter)requestMap.get(id);
1:                 if (rc != null) {
1:                     if (rc.ackCount.decrementAndGet() <= 0) {
/////////////////////////////////////////////////////////////////////////
0:                     if (transport == null)
1: 
1: 
1:                     transport = null;
1:                     if (primary == this) {
1:             } catch (InterruptedException e) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         }, "ActiveMQ Fanout Worker: " + System.identityHashCode(this));
1: 
1:         long closestReconnectDate = 0;
1:             if (disposed || connectionFailure != null) {
1:             if (transports.size() == connectedCount || disposed || connectionFailure != null) {
1: 
1:                 if (transports.isEmpty()) {
1:                     // connectionFailure = new IOException("No uris available to
1:                     // connect to.");
1: 
1: 
1: 
0:                         FanoutTransportHandler fanoutHandler = (FanoutTransportHandler)iter.next();
1:                         if (fanoutHandler.transport != null) {
1: 
1:                         if (fanoutHandler.reconnectDate != 0 && fanoutHandler.reconnectDate > now) {
1:                             if (closestReconnectDate == 0 || fanoutHandler.reconnectDate < closestReconnectDate) {
1: 
0:                             log.debug("Stopped: " + this);
1:                             if (primary == null) {
/////////////////////////////////////////////////////////////////////////
1:                         } catch (Exception e) {
1: 
1: 
1: 
1: 
1:                                 if (closestReconnectDate == 0 || fanoutHandler.reconnectDate < closestReconnectDate) {
1:                     if (transports.size() == connectedCount || disposed) {
1: 
1: 
1:             if (reconnectDelay > 0) {
1:         } catch (InterruptedException e1) {
/////////////////////////////////////////////////////////////////////////
0:                 FanoutTransportHandler th = (FanoutTransportHandler)iter.next();
1:                 if (th.transport != null) {
/////////////////////////////////////////////////////////////////////////
1:             ServiceStopper ss = new ServiceStopper();
1: 
0:                 FanoutTransportHandler th = (FanoutTransportHandler)iter.next();
1:                 if (th.transport != null) {
1:                     ss.stop(th.transport);
1: 
0:             log.debug("Stopped: " + this);
/////////////////////////////////////////////////////////////////////////
0:         final Command command = (Command)o;
1: 
1:                 if (stateTracker.track(command) == null && command.isResponseRequired()) {
0:                 while (connectedCount != minAckCount && !disposed && connectionFailure == null) {
0:                     log.debug("Waiting for at least " + minAckCount + " transports to be connected.");
0:                 if (connectedCount != minAckCount) {
1: 
1:                     } else if (connectionFailure != null) {
1: 
0:                     if (error instanceof IOException)
1: 
1:                 if (fanout) {
0:                         FanoutTransportHandler th = (FanoutTransportHandler)iter.next();
1:                         if (th.transport != null) {
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (command.isMessage()) {
1:         }
0:         if (command.getDataStructureType() == ConsumerInfo.DATA_STRUCTURE_TYPE) {
/////////////////////////////////////////////////////////////////////////
1: 
1:     public Object request(Object command, int timeout) throws IOException {
/////////////////////////////////////////////////////////////////////////
1: 
0:                 FanoutTransportHandler th = (FanoutTransportHandler)iter.next();
1:                 if (th.transport != null) {
0:                     if (rc != null)
1: 
1:         stateTracker.setRestoreConsumers(th.transport == primary);
0:             RequestCounter rc = (RequestCounter)iter2.next();
1: 
1: 
1:                 boolean match = false;
0:                     FanoutTransportHandler th = (FanoutTransportHandler)iter.next();
1:                     if (th.uri.equals(uri)) {
1:                         match = true;
1:                 if (!match) {
1: 
1: 
1: 
1: 
1:                 boolean match = false;
0:                     FanoutTransportHandler th = (FanoutTransportHandler)iter.next();
1:                     if (th.uri.equals(uri)) {
1:                         if (th.transport != null) {
/////////////////////////////////////////////////////////////////////////
1: 
1:     public String getRemoteAddress() {
1:         if (primary != null) {
1:             if (primary.transport != null) {
1:                 return primary.transport.getRemoteAddress();
1:             }
1:         }
1:         return null;
1:     }
/////////////////////////////////////////////////////////////////////////
1:     public boolean isFaultTolerant() {
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.atomic.AtomicInteger;
commit:9ca56a0
/////////////////////////////////////////////////////////////////////////
1:         public void onCommand(Object o) {
0:         	Command command = (Command) o;
/////////////////////////////////////////////////////////////////////////
1:     public void oneway(Object o) throws IOException {
0:     	final Command command = (Command) o;
/////////////////////////////////////////////////////////////////////////
1:     public FutureResponse asyncRequest(Object command, ResponseCallback responseCallback) throws IOException {
1:     public Object request(Object command) throws IOException {
0:     public Object request(Object command,int timeout) throws IOException {
commit:220ad62
/////////////////////////////////////////////////////////////////////////
0:                 if (stateTracker.track(command)==null && command.isResponseRequired() ) {
commit:295850d
/////////////////////////////////////////////////////////////////////////
0:                 if (!stateTracker.track(command) && command.isResponseRequired() ) {
commit:b75a6da
/////////////////////////////////////////////////////////////////////////
1:                 Thread.currentThread().interrupt();
/////////////////////////////////////////////////////////////////////////
1:             Thread.currentThread().interrupt();
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:e2aad41
/////////////////////////////////////////////////////////////////////////
0:         }, "ActiveMQ Fanout Worker: "+System.identityHashCode(this));
/////////////////////////////////////////////////////////////////////////
commit:84fd773
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.ResponseCallback;
/////////////////////////////////////////////////////////////////////////
0:     public FutureResponse asyncRequest(Command command, ResponseCallback responseCallback) throws IOException {
commit:ef61027
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.ServiceStopper;
/////////////////////////////////////////////////////////////////////////
0:                             log.debug("Stopped: "+this);
/////////////////////////////////////////////////////////////////////////
0:         	ServiceStopper ss = new ServiceStopper();
1:         	
1:             
1:             reconnectTask.shutdown();
1:             
0:                 	ss.stop(th.transport);
1:             
0:             log.debug("Stopped: "+this);
1:             ss.throwFirstException();
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport.fanout;
1: 
1: import java.io.IOException;
1: import java.io.InterruptedIOException;
1: import java.net.URI;
1: import java.util.ArrayList;
1: import java.util.Iterator;
1: 
1: import org.apache.activemq.command.Command;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.Response;
1: import org.apache.activemq.state.ConnectionStateTracker;
0: import org.apache.activemq.thread.DefaultThreadPools;
1: import org.apache.activemq.thread.Task;
1: import org.apache.activemq.thread.TaskRunner;
1: import org.apache.activemq.transport.CompositeTransport;
1: import org.apache.activemq.transport.FutureResponse;
1: import org.apache.activemq.transport.Transport;
1: import org.apache.activemq.transport.TransportFactory;
1: import org.apache.activemq.transport.TransportListener;
1: import org.apache.activemq.util.IOExceptionSupport;
1: import org.apache.activemq.util.ServiceSupport;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicInteger;
1: 
1: /**
1:  * A Transport that fans out a connection to multiple brokers.
0:  * 
0:  * @version $Revision$
1:  */
1: public class FanoutTransport implements CompositeTransport {
1: 
0:     private static final Log log = LogFactory.getLog(FanoutTransport.class);
1: 
1:     private TransportListener transportListener;
1:     private boolean disposed;
1: 
1:     private final Object reconnectMutex = new Object();
1:     private final ConnectionStateTracker stateTracker = new ConnectionStateTracker();
0:     private final ConcurrentHashMap requestMap = new ConcurrentHashMap();
1: 
1:     private final TaskRunner reconnectTask;
1:     private boolean started;
1:     
0:     private ArrayList transports = new ArrayList();
0:     private int connectedCount=0;
1:     
1:     private int minAckCount = 2;
1:     
1:     private long initialReconnectDelay = 10;
1:     private long maxReconnectDelay = 1000 * 30;
0:     private long backOffMultiplier = 2;    
0:     private boolean useExponentialBackOff = true;
1:     private int maxReconnectAttempts;
1:     private Exception connectionFailure;
1:     private FanoutTransportHandler primary;
1:     
1:     static class RequestCounter {
1:         
1:         final Command command;
1:         final AtomicInteger ackCount;
1:         
1:         RequestCounter(Command command, int count) {
1:             this.command = command;
1:             this.ackCount = new AtomicInteger(count);
1:         }
1:         
1:         public String toString() {
0:             return command.getCommandId()+"="+ackCount.get();
1:         }
1:     }
1: 
0:     class FanoutTransportHandler implements TransportListener {
1:         
1:         private final URI uri;
1:         private Transport transport;
1: 
1:         private int connectFailures;
1:         private long reconnectDelay = initialReconnectDelay;
1:         private long reconnectDate;
1: 
1:         public FanoutTransportHandler(URI uri) {
0:             this.uri=uri;
1:         }
1: 
0:         public void onCommand(Command command) {
1:             if (command.isResponse()) {
0:                 Short id = new Short(((Response) command).getCorrelationId());
0:                 RequestCounter rc = (RequestCounter) requestMap.get(id);
0:                 if( rc != null ) {
0:                     if( rc.ackCount.decrementAndGet() <= 0 ) {
1:                         requestMap.remove(id);
1:                         transportListener.onCommand(command);
1:                     }
1:                 } else {
1:                     transportListener.onCommand(command);
1:                 }
1:             } else {
1:                 transportListener.onCommand(command);
1:             }
1:         }
1: 
1:         public void onException(IOException error) {
1:             try {
1:                 synchronized (reconnectMutex) {
0:                     if( transport == null )
1:                         return;
1:                     
0:                     log.debug("Transport failed, starting up reconnect task", error);
1:                     
1:                     ServiceSupport.dispose(transport);
0:                     transport=null;
1:                     connectedCount--;
0:                     if( primary == this) {
1:                         primary = null;
1:                     }
1:                     reconnectTask.wakeup();
1:                 }
1:             }
0:             catch (InterruptedException e) {
1:                 transportListener.onException(new InterruptedIOException());
1:             }
1:         }        
1:     }
1: 
0:     public FanoutTransport() throws InterruptedIOException {
1:         // Setup a task that is used to reconnect the a connection async.
0:         reconnectTask = DefaultThreadPools.getDefaultTaskRunnerFactory().createTaskRunner(new Task() {
1:             public boolean iterate() {
1:                 return doConnect();
1:             }
0:         });
1:     }
1:     
1:     /**
1:      * @return
1:      */
1:     private boolean doConnect() {
0:         long closestReconnectDate=0;
1:         synchronized (reconnectMutex) {
1: 
0:             if (disposed || connectionFailure!=null) {
1:                 reconnectMutex.notifyAll();
1:             }
1: 
0:             if (transports.size() == connectedCount || disposed || connectionFailure!=null) {
1:                 return false;
1:             } else {
1:                 
0:                 if( transports.isEmpty() ) {
0: //                    connectionFailure = new IOException("No uris available to connect to.");
1:                 } else {
1:                     
1:                     
1:                     // Try to connect them up.
0:                     Iterator iter = transports.iterator();
0:                     for (int i = 0; iter.hasNext() && !disposed; i++) {
1:                         
1:                         long now = System.currentTimeMillis();
1:                         
0:                         FanoutTransportHandler fanoutHandler = (FanoutTransportHandler) iter.next();
0:                         if( fanoutHandler.transport!=null ) {
1:                             continue;
1:                         }
1:                         
1:                         // Are we waiting a little to try to reconnect this one?
0:                         if( fanoutHandler.reconnectDate!=0 && fanoutHandler.reconnectDate>now ) {
0:                             if( closestReconnectDate==0 || fanoutHandler.reconnectDate < closestReconnectDate ) {
1:                                 closestReconnectDate = fanoutHandler.reconnectDate;
1:                             }
1:                             continue;
1:                         }
1:                         
1:                         URI uri = fanoutHandler.uri;
1:                         try {
0:                             log.debug("Attempting connect to: " + uri);
1:                             Transport t = TransportFactory.compositeConnect(uri);
0:                             log.debug("Connection established");
1:                             fanoutHandler.transport = t;
0:                             fanoutHandler.reconnectDelay = 10;
1:                             fanoutHandler.connectFailures = 0;
0:                             if( primary == null ) {
1:                                 primary = fanoutHandler;
1:                             }
1:                             t.setTransportListener(fanoutHandler);
0:                             connectedCount++;
1:                             if (started) {
1:                                 restoreTransport(fanoutHandler);
1:                             }
1:                         }
0:                         catch (Exception e) {
0:                             log.debug("Connect fail to: " + uri + ", reason: " + e);
1:                             
1:                             if (maxReconnectAttempts > 0 && ++fanoutHandler.connectFailures >= maxReconnectAttempts) {
0:                                 log.error("Failed to connect to transport after: " + fanoutHandler.connectFailures + " attempt(s)");
1:                                 connectionFailure = e;
1:                                 reconnectMutex.notifyAll();
1:                                 return false;
1:                             } else {
1:                                 
1:                                 if (useExponentialBackOff) {
1:                                     // Exponential increment of reconnect delay.
1:                                     fanoutHandler.reconnectDelay *= backOffMultiplier;
0:                                     if (fanoutHandler.reconnectDelay > maxReconnectDelay)
1:                                         fanoutHandler.reconnectDelay = maxReconnectDelay;
1:                                 }
1:                                 
1:                                 fanoutHandler.reconnectDate = now + fanoutHandler.reconnectDelay;
1:                                 
0:                                 if( closestReconnectDate==0 || fanoutHandler.reconnectDate < closestReconnectDate ) {
1:                                     closestReconnectDate = fanoutHandler.reconnectDate;
1:                                 }
1:                             }
1:                         }
1:                     }
0:                     if (transports.size() == connectedCount || disposed ) {
1:                         reconnectMutex.notifyAll();
1:                         return false;
1:                     }
1:                     
1:                 }
1:             }
1:             
1:         }
1: 
1:         try {
1:             long reconnectDelay = closestReconnectDate - System.currentTimeMillis();
0:             if(reconnectDelay>0) {
0:                 log.debug("Waiting " + reconnectDelay + " ms before attempting connection. ");
1:                 Thread.sleep(reconnectDelay);
1:             }
1:         }
0:         catch (InterruptedException e1) {
1:             Thread.currentThread().interrupt();
1:         }
1:         return true;
1:     }
1: 
1:     public void start() throws Exception {
1:         synchronized (reconnectMutex) {
0:             log.debug("Started.");
0:             if (started)
1:                 return;
1:             started = true;
0:             for (Iterator iter = transports.iterator(); iter.hasNext();) {
0:                 FanoutTransportHandler th = (FanoutTransportHandler) iter.next();
0:                 if( th.transport != null ) {
1:                     restoreTransport(th);
1:                 }
1:             }
1:         }
1:     }
1: 
1:     public void stop() throws Exception {
1:         synchronized (reconnectMutex) {
0:             log.debug("Stopped.");
0:             if (!started)
1:                 return;
1:             started = false;
1:             disposed = true;
1: 
0:             for (Iterator iter = transports.iterator(); iter.hasNext();) {
0:                 FanoutTransportHandler th = (FanoutTransportHandler) iter.next();
0:                 if( th.transport != null ) {
0:                     th.transport.stop();
1:                 }
1:             }
1:         }
1:     }
1: 
1:     public long getInitialReconnectDelay() {
1:         return initialReconnectDelay;
1:     }
1: 
1:     public void setInitialReconnectDelay(long initialReconnectDelay) {
1:         this.initialReconnectDelay = initialReconnectDelay;
1:     }
1: 
1:     public long getMaxReconnectDelay() {
1:         return maxReconnectDelay;
1:     }
1: 
1:     public void setMaxReconnectDelay(long maxReconnectDelay) {
1:         this.maxReconnectDelay = maxReconnectDelay;
1:     }
1: 
1:     public long getReconnectDelayExponent() {
1:         return backOffMultiplier;
1:     }
1: 
1:     public void setReconnectDelayExponent(long reconnectDelayExponent) {
1:         this.backOffMultiplier = reconnectDelayExponent;
1:     }
1: 
1:     public int getMaxReconnectAttempts() {
1:         return maxReconnectAttempts;
1:     }
1: 
1:     public void setMaxReconnectAttempts(int maxReconnectAttempts) {
1:         this.maxReconnectAttempts = maxReconnectAttempts;
1:     }
1: 
0:     public void oneway(Command command) throws IOException {
1:         try {
1:             synchronized (reconnectMutex) {
1:                 
1:                 // If it was a request and it was not being tracked by
1:                 // the state tracker,
1:                 // then hold it in the requestMap so that we can replay
1:                 // it later.
1:                 boolean fanout = isFanoutCommand(command);
0:                 if (!stateTracker.track(command) && command.isResponseRequired() ) {
1:                     int size = fanout ? minAckCount : 1;
0:                     requestMap.put(new Short(command.getCommandId()), new RequestCounter(command, size));
1:                 }
1: 
1:                 // Wait for transport to be connected.
0:                 while (connectedCount != minAckCount && !disposed && connectionFailure==null ) {
0:                     log.debug("Waiting for at least "+minAckCount+" transports to be connected.");
1:                     reconnectMutex.wait(1000);
1:                 }
1: 
1:                 // Still not fully connected.
0:                 if( connectedCount != minAckCount ) {
1: 
1:                     Exception error;
1:                     
1:                     // Throw the right kind of error..
1:                     if (disposed) {
1:                         error = new IOException("Transport disposed.");
0:                     } else if (connectionFailure!=null) {
1:                         error = connectionFailure;
1:                     } else {
1:                         error = new IOException("Unexpected failure.");
1:                     }
1:                     
0:                     if( error instanceof IOException )
0:                         throw (IOException)error;
1:                     throw IOExceptionSupport.create(error);
1:                 }
1:                 
1:                 // Send the message.
0:                 if( fanout ) {
0:                     for (Iterator iter = transports.iterator(); iter.hasNext();) {
0:                         FanoutTransportHandler th = (FanoutTransportHandler) iter.next();
0:                         if( th.transport!=null ) {
1:                             try {
1:                                 th.transport.oneway(command);
1:                             } catch (IOException e) {
0:                                 log.debug("Send attempt: failed.");
1:                                 th.onException(e);
1:                             }
1:                         }
1:                     }
1:                 } else {
1:                     try {
1:                         primary.transport.oneway(command);
1:                     } catch (IOException e) {
0:                         log.debug("Send attempt: failed.");
1:                         primary.onException(e);
1:                     }
1:                 }
1:                 
1:             }
1:         } catch (InterruptedException e) {
1:             // Some one may be trying to stop our thread.
1:             throw new InterruptedIOException();
1:         }
1:     }
1: 
1:     /**
1:      * @param command
1:      * @return
1:      */
1:     private boolean isFanoutCommand(Command command) {
0:         if( command.isMessage() ) {
0:             return ((Message)command).getDestination().isTopic();
1:         } 
0:         if( command.getDataStructureType() == ConsumerInfo.DATA_STRUCTURE_TYPE ) {
1:             return false;
1:         }
1:         return true;
1:     }
1: 
0:     public FutureResponse asyncRequest(Command command) throws IOException {
1:         throw new AssertionError("Unsupported Method");
1:     }
1: 
0:     public Response request(Command command) throws IOException {
1:         throw new AssertionError("Unsupported Method");
1:     }
1: 
1:     public void reconnect() {
0:         log.debug("Waking up reconnect task");
1:         try {
1:             reconnectTask.wakeup();
1:         } catch (InterruptedException e) {
1:             Thread.currentThread().interrupt();
1:         }
1:     }
1: 
1:     public void setTransportListener(TransportListener commandListener) {
1:         this.transportListener = commandListener;
1:     }
1: 
0:     public Object narrow(Class target) {
1: 
1:         if (target.isAssignableFrom(getClass())) {
0:             return this;
1:         }
1:         
1:         synchronized (reconnectMutex) {
0:             for (Iterator iter = transports.iterator(); iter.hasNext();) {
0:                 FanoutTransportHandler th = (FanoutTransportHandler) iter.next();
0:                 if( th.transport!=null ) {
0:                     Object rc = th.transport.narrow(target);
0:                     if( rc !=null )
1:                         return rc;
1:                 }
1:             }
1:         }
1:         
1:         return null;
1: 
1:     }
1: 
1:     protected void restoreTransport(FanoutTransportHandler th) throws Exception, IOException {
1:         th.transport.start();
0:         stateTracker.setRestoreConsumers(th.transport==primary);
1:         stateTracker.restore(th.transport);
0:         for (Iterator iter2 = requestMap.values().iterator(); iter2.hasNext();) {
0:             RequestCounter rc = (RequestCounter) iter2.next();
1:             th.transport.oneway(rc.command);
1:         }
1:     }
1: 
0:     public void add(URI uris[]) {
1:         
1:         synchronized (reconnectMutex) {
1:             for (int i = 0; i < uris.length; i++) {
1:                 URI uri = uris[i];
1:                 
0:                 boolean match=false;
0:                 for (Iterator iter = transports.iterator(); iter.hasNext();) {
0:                     FanoutTransportHandler th = (FanoutTransportHandler) iter.next();
0:                     if( th.uri.equals(uri)) {
0:                         match=true;
1:                         break;
1:                     }
1:                 }
0:                 if( !match ) {
1:                     FanoutTransportHandler th = new FanoutTransportHandler(uri);
1:                     transports.add(th);
1:                     reconnect();
1:                 }
1:             }
1:         }
1:         
1:     }
1:     
0:     public void remove(URI uris[]) {
1:         
1:         synchronized (reconnectMutex) {
1:             for (int i = 0; i < uris.length; i++) {
1:                 URI uri = uris[i];
1:                 
0:                 boolean match=false;
0:                 for (Iterator iter = transports.iterator(); iter.hasNext();) {
0:                     FanoutTransportHandler th = (FanoutTransportHandler) iter.next();
0:                     if( th.uri.equals(uri)) {
0:                         if( th.transport!=null ) {
1:                             ServiceSupport.dispose(th.transport);
1:                             connectedCount--;
1:                         }
1:                         iter.remove();
1:                         break;
1:                     }
1:                 }
1:             }
1:         }
1:         
1:     }
1: 
1: }
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:8a01c5d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.thread.TaskRunnerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private final TaskRunnerFactory reconnectTaskFactory;
/////////////////////////////////////////////////////////////////////////
1:         reconnectTaskFactory = new TaskRunnerFactory();
1:         reconnectTaskFactory.init();
1:         reconnectTask = reconnectTaskFactory.createTaskRunner(new Task() {
/////////////////////////////////////////////////////////////////////////
1:         try {
0:             synchronized (reconnectMutex) {
0:                 ServiceStopper ss = new ServiceStopper();
0:                 if (!started) {
0:                     return;
0:                 started = false;
0:                 disposed = true;
0:                 connected=false;
0:                 for (Iterator<FanoutTransportHandler> iter = transports.iterator(); iter.hasNext();) {
0:                     FanoutTransportHandler th = iter.next();
0:                     if (th.transport != null) {
0:                         ss.stop(th.transport);
1:                     }
1:                 }
0: 
0:                 LOG.debug("Stopped: " + this);
0:                 ss.throwFirstException();
1:             }
1:         } finally {
0:             reconnectTask.shutdown();
1:             reconnectTaskFactory.shutdownNow();
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(FanoutTransport.class);
commit:aace7c6
/////////////////////////////////////////////////////////////////////////
0: 
1: import org.apache.activemq.command.RemoveInfo;
/////////////////////////////////////////////////////////////////////////
1:                     if (transport == null || !transport.isConnected()) {
/////////////////////////////////////////////////////////////////////////
0:         if (command.getDataStructureType() == ConsumerInfo.DATA_STRUCTURE_TYPE ||
0:                 command.getDataStructureType() == RemoveInfo.DATA_STRUCTURE_TYPE) {
commit:e547cbd
/////////////////////////////////////////////////////////////////////////
0:                             LOG.debug("Connection established");
1:                             fanoutHandler.reconnectDelay = initialReconnectDelay;
0:                             fanoutHandler.connectFailures = 0;
0:                             if (primary == null) {
0:                                 primary = fanoutHandler;
1:                             }
author:Robert Davies
-------------------------------------------------------------------------------
commit:f392884
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final ArrayList<FanoutTransportHandler> transports = new ArrayList<FanoutTransportHandler>();
/////////////////////////////////////////////////////////////////////////
1:     private final boolean useExponentialBackOff = true;
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
0:         @Override
/////////////////////////////////////////////////////////////////////////
0:     public void add(boolean reblance,URI uris[]) {
/////////////////////////////////////////////////////////////////////////
0:     public void remove(boolean rebalance,URI uris[]) {
/////////////////////////////////////////////////////////////////////////
0: 		add(true,new URI[]{uri});
0:     
1:     public boolean isReconnectSupported() {
1:         return true;
1:     }
0: 
1:     public boolean isUpdateURIsSupported() {
1:         return true;
1:     }
0:     public void updateURIs(boolean reblance,URI[] uris) throws IOException {
0:         add(reblance,uris);
1:     }
commit:ecc87ea
/////////////////////////////////////////////////////////////////////////
1:     private boolean connected;
/////////////////////////////////////////////////////////////////////////
0:             connected=true;
/////////////////////////////////////////////////////////////////////////
0:             connected=false;
/////////////////////////////////////////////////////////////////////////
0: 	
0: 
1:     public boolean isConnected() {
1:         return connected;
0:     }
commit:3ac0537
/////////////////////////////////////////////////////////////////////////
0:     
1:     public void reconnect(URI uri) throws IOException {
0: 		add(new URI[]{uri});
0: 		
0: 	}
0: 
/////////////////////////////////////////////////////////////////////////
0: 	public boolean isDisposed() {
0: 		return disposed;
0: 	}
commit:c7469c4
/////////////////////////////////////////////////////////////////////////
0: 
0:     
0:     public boolean isFaultTolerant(){
1:         return true;
0:     }
commit:5fe0a4c
/////////////////////////////////////////////////////////////////////////
0:     
0:     public Response request(Command command,int timeout) throws IOException {
1:         throw new AssertionError("Unsupported Method");
0:     }
commit:f915da5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.DefaultTransportListener;
/////////////////////////////////////////////////////////////////////////
1:     class FanoutTransportHandler extends DefaultTransportListener {
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:1ea24bf
/////////////////////////////////////////////////////////////////////////
0: 	public int getMinAckCount() {
0: 		return minAckCount;
0: 	}
0: 
0: 	public void setMinAckCount(int minAckCount) {
0: 		this.minAckCount = minAckCount;
0: 	}    
0:     
/////////////////////////////////////////////////////////////////////////
1:                 while (connectedCount < minAckCount && !disposed && connectionFailure == null) {
1:                 if (connectedCount < minAckCount) {
/////////////////////////////////////////////////////////////////////////
0:                 // If it was a request and it was not being tracked by
0:                 // the state tracker,
0:                 // then hold it in the requestMap so that we can replay
0:                 // it later.
0:                 boolean fanout = isFanoutCommand(command);
0:                 if (stateTracker.track(command) == null && command.isResponseRequired()) {
0:                     int size = fanout ? minAckCount : 1;
1:                     requestMap.put(new Integer(command.getCommandId()), new RequestCounter(command, size));
0:                 }
0:                 
/////////////////////////////////////////////////////////////////////////
0: 
author:James Strachan
-------------------------------------------------------------------------------
commit:f6e1ac7
/////////////////////////////////////////////////////////////////////////
1:                         transportListenerOnCommand(command);
1:                     transportListenerOnCommand(command);
1:                 transportListenerOnCommand(command);
/////////////////////////////////////////////////////////////////////////
1:                 if (transportListener != null) {
0:                     transportListener.onException(new InterruptedIOException());
0:                 }
/////////////////////////////////////////////////////////////////////////
1:     protected void transportListenerOnCommand(Command command) {
1:         if (transportListener != null) {
0:             transportListener.onCommand(command);
0:         }
0:     }
commit:0f1dcce
/////////////////////////////////////////////////////////////////////////
0: 	public String getRemoteAddress() {
0: 		if(primary != null){
0: 		   if(primary.transport != null){
0: 			   return primary.transport.getRemoteAddress(); 
0: 		   }
0: 		}
0: 		return null;
0: 	}
0: 
commit:8704338
/////////////////////////////////////////////////////////////////////////
0:                 Integer id = new Integer(((Response) command).getCorrelationId());
/////////////////////////////////////////////////////////////////////////
0:                     requestMap.put(new Integer(command.getCommandId()), new RequestCounter(command, size));
commit:436fe42
/////////////////////////////////////////////////////////////////////////
1:     public TransportListener getTransportListener() {
1:         return transportListener;
0:     }
0: 
author:Adrian T. Co
-------------------------------------------------------------------------------
commit:04c3b07
/////////////////////////////////////////////////////////////////////////
0:                 if (stateTracker.track(command)==null && command.isResponseRequired() ) {
commit:83ab261
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:         reconnectTask.shutdown();
============================================================================