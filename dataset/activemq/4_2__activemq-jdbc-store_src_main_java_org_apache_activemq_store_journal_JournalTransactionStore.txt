1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
3:d29ca2a:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:d29ca2a:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
24:d29ca2a: 
1:d29ca2a: package org.apache.activemq.store.journal;
1:d29ca2a: 
1:d29ca2a: import java.io.IOException;
1:d29ca2a: import java.util.ArrayList;
1:d29ca2a: import java.util.Iterator;
1:4a16f45: import java.util.LinkedHashMap;
1:4a16f45: import java.util.Map;
1:d29ca2a: import javax.transaction.xa.XAException;
1:f451ad0: import org.apache.activeio.journal.RecordLocation;
1:d29ca2a: import org.apache.activemq.command.JournalTopicAck;
1:d29ca2a: import org.apache.activemq.command.JournalTransaction;
1:d29ca2a: import org.apache.activemq.command.Message;
1:d29ca2a: import org.apache.activemq.command.MessageAck;
1:d29ca2a: import org.apache.activemq.command.TransactionId;
1:d29ca2a: import org.apache.activemq.command.XATransactionId;
1:d29ca2a: import org.apache.activemq.store.TransactionRecoveryListener;
1:d29ca2a: import org.apache.activemq.store.TransactionStore;
1:d29ca2a: 
1:d29ca2a: /**
1:d29ca2a:  */
1:d29ca2a: public class JournalTransactionStore implements TransactionStore {
1:d29ca2a: 
1:d29ca2a:     private final JournalPersistenceAdapter peristenceAdapter;
1:27262c8:     private final Map<Object, Tx> inflightTransactions = new LinkedHashMap<Object, Tx>();
1:27262c8:     private final Map<TransactionId, Tx> preparedTransactions = new LinkedHashMap<TransactionId, Tx>();
1:d29ca2a:     private boolean doingRecover;
1:d29ca2a: 
1:d29ca2a:     public static class TxOperation {
1:f812e34: 
1:f812e34:         static final byte ADD_OPERATION_TYPE = 0;
1:f812e34:         static final byte REMOVE_OPERATION_TYPE = 1;
1:f812e34:         static final byte ACK_OPERATION_TYPE = 3;
1:f812e34: 
1:d29ca2a:         public byte operationType;
1:d29ca2a:         public JournalMessageStore store;
1:d29ca2a:         public Object data;
1:f812e34: 
1:d29ca2a:         public TxOperation(byte operationType, JournalMessageStore store, Object data) {
1:f812e34:             this.operationType = operationType;
1:f812e34:             this.store = store;
1:f812e34:             this.data = data;
1:d29ca2a:         }
1:f812e34: 
1:d29ca2a:     }
1:f812e34: 
1:d29ca2a:     /**
1:d29ca2a:      * Operations
1:b0c2a40:      * 
1:f812e34:      * 
1:d29ca2a:      */
1:d29ca2a:     public static class Tx {
1:d29ca2a: 
1:d29ca2a:         private final RecordLocation location;
1:27262c8:         private final ArrayList<TxOperation> operations = new ArrayList<TxOperation>();
1:d29ca2a: 
1:d29ca2a:         public Tx(RecordLocation location) {
1:f812e34:             this.location = location;
1:d29ca2a:         }
1:d29ca2a: 
1:d29ca2a:         public void add(JournalMessageStore store, Message msg) {
1:d29ca2a:             operations.add(new TxOperation(TxOperation.ADD_OPERATION_TYPE, store, msg));
1:d29ca2a:         }
1:d29ca2a: 
1:d29ca2a:         public void add(JournalMessageStore store, MessageAck ack) {
1:d29ca2a:             operations.add(new TxOperation(TxOperation.REMOVE_OPERATION_TYPE, store, ack));
1:d29ca2a:         }
1:d29ca2a: 
1:d29ca2a:         public void add(JournalTopicMessageStore store, JournalTopicAck ack) {
1:d29ca2a:             operations.add(new TxOperation(TxOperation.ACK_OPERATION_TYPE, store, ack));
1:d29ca2a:         }
1:f812e34: 
1:d29ca2a:         public Message[] getMessages() {
1:933eb2f:             ArrayList<Object> list = new ArrayList<Object>();
1:933eb2f:             for (Iterator<TxOperation> iter = operations.iterator(); iter.hasNext();) {
1:933eb2f:                 TxOperation op = iter.next();
1:f812e34:                 if (op.operationType == TxOperation.ADD_OPERATION_TYPE) {
1:d29ca2a:                     list.add(op.data);
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a:             Message rc[] = new Message[list.size()];
1:d29ca2a:             list.toArray(rc);
1:d29ca2a:             return rc;
1:d29ca2a:         }
1:d29ca2a: 
1:d29ca2a:         public MessageAck[] getAcks() {
1:933eb2f:             ArrayList<Object> list = new ArrayList<Object>();
1:933eb2f:             for (Iterator<TxOperation> iter = operations.iterator(); iter.hasNext();) {
1:933eb2f:                 TxOperation op = iter.next();
1:f812e34:                 if (op.operationType == TxOperation.REMOVE_OPERATION_TYPE) {
1:d29ca2a:                     list.add(op.data);
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a:             MessageAck rc[] = new MessageAck[list.size()];
1:d29ca2a:             list.toArray(rc);
1:d29ca2a:             return rc;
1:d29ca2a:         }
1:d29ca2a: 
1:933eb2f:         public ArrayList<TxOperation> getOperations() {
1:d29ca2a:             return operations;
1:d29ca2a:         }
1:d29ca2a: 
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public JournalTransactionStore(JournalPersistenceAdapter adapter) {
1:d29ca2a:         this.peristenceAdapter = adapter;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @throws IOException
1:d29ca2a:      * @see org.apache.activemq.store.TransactionStore#prepare(TransactionId)
1:d29ca2a:      */
1:f812e34:     public void prepare(TransactionId txid) throws IOException {
1:f812e34:         Tx tx = null;
1:f812e34:         synchronized (inflightTransactions) {
1:933eb2f:             tx = inflightTransactions.remove(txid);
1:d29ca2a:         }
1:fc00993:         if (tx == null) {
1:d29ca2a:             return;
1:fc00993:         }
1:f812e34:         peristenceAdapter.writeCommand(new JournalTransaction(JournalTransaction.XA_PREPARE, txid, false),
1:f812e34:                                        true);
1:f812e34:         synchronized (preparedTransactions) {
1:f812e34:             preparedTransactions.put(txid, tx);
1:fc00993:         }
1:fc00993:     }
1:f812e34: 
1:d29ca2a:     /**
1:d29ca2a:      * @throws IOException
1:d29ca2a:      * @see org.apache.activemq.store.TransactionStore#prepare(TransactionId)
1:d29ca2a:      */
1:f812e34:     public void replayPrepare(TransactionId txid) throws IOException {
1:f812e34:         Tx tx = null;
1:f812e34:         synchronized (inflightTransactions) {
1:933eb2f:             tx = inflightTransactions.remove(txid);
1:d29ca2a:         }
1:fc00993:         if (tx == null) {
1:d29ca2a:             return;
1:4a16f45:         }
1:f812e34:         synchronized (preparedTransactions) {
1:f812e34:             preparedTransactions.put(txid, tx);
1:4a16f45:         }
1:4a16f45:     }
1:d29ca2a: 
1:f812e34:     public Tx getTx(Object txid, RecordLocation location) {
1:f812e34:         Tx tx = null;
1:f812e34:         synchronized (inflightTransactions) {
1:933eb2f:             tx = inflightTransactions.get(txid);
1:4a16f45:         }
1:fc00993:         if (tx == null) {
1:f812e34:             tx = new Tx(location);
1:f812e34:             inflightTransactions.put(txid, tx);
1:d29ca2a:         }
1:d29ca2a:         return tx;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @throws XAException
1:d29ca2a:      * @see org.apache.activemq.store.TransactionStore#commit(org.apache.activemq.service.Transaction)
1:d29ca2a:      */
1:27262c8:     public void commit(TransactionId txid, boolean wasPrepared, Runnable preCommit,Runnable postCommit) throws IOException {
1:d29ca2a:         Tx tx;
1:27262c8:         if (preCommit != null) {
1:27262c8:             preCommit.run();
1:27262c8:         }
1:f812e34:         if (wasPrepared) {
1:f812e34:             synchronized (preparedTransactions) {
1:933eb2f:                 tx = preparedTransactions.remove(txid);
1:4a16f45:             }
1:f812e34:         } else {
1:f812e34:             synchronized (inflightTransactions) {
1:933eb2f:                 tx = inflightTransactions.remove(txid);
1:d29ca2a:             }
1:4a16f45:         }
1:f812e34:         if (tx == null) {
1:27262c8:             if (postCommit != null) {
1:27262c8:                 postCommit.run();
1:27262c8:             }
1:d29ca2a:             return;
1:4a16f45:         }
1:f812e34:         if (txid.isXATransaction()) {
1:f812e34:             peristenceAdapter.writeCommand(new JournalTransaction(JournalTransaction.XA_COMMIT, txid,
1:f812e34:                                                                   wasPrepared), true);
1:f812e34:         } else {
1:f812e34:             peristenceAdapter.writeCommand(new JournalTransaction(JournalTransaction.LOCAL_COMMIT, txid,
1:f812e34:                                                                   wasPrepared), true);
1:d29ca2a:         }
1:27262c8:         if (postCommit != null) {
1:27262c8:             postCommit.run();
1:d29ca2a:         }
1:27262c8:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @throws XAException
1:d29ca2a:      * @see org.apache.activemq.store.TransactionStore#commit(org.apache.activemq.service.Transaction)
1:d29ca2a:      */
1:f812e34:     public Tx replayCommit(TransactionId txid, boolean wasPrepared) throws IOException {
1:f812e34:         if (wasPrepared) {
1:f812e34:             synchronized (preparedTransactions) {
1:933eb2f:                 return preparedTransactions.remove(txid);
1:d29ca2a:             }
1:f812e34:         } else {
1:f812e34:             synchronized (inflightTransactions) {
1:933eb2f:                 return inflightTransactions.remove(txid);
1:d29ca2a:             }
1:4a16f45:         }
1:4a16f45:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @throws IOException
1:d29ca2a:      * @see org.apache.activemq.store.TransactionStore#rollback(TransactionId)
1:d29ca2a:      */
1:f812e34:     public void rollback(TransactionId txid) throws IOException {
1:f812e34:         Tx tx = null;
1:f812e34:         synchronized (inflightTransactions) {
1:933eb2f:             tx = inflightTransactions.remove(txid);
1:4a16f45:         }
1:fc00993:         if (tx != null) {
1:f812e34:             synchronized (preparedTransactions) {
1:933eb2f:                 tx = preparedTransactions.remove(txid);
1:fc00993:             }
1:d29ca2a:         }
1:f812e34:         if (tx != null) {
1:f812e34:             if (txid.isXATransaction()) {
1:f812e34:                 peristenceAdapter.writeCommand(new JournalTransaction(JournalTransaction.XA_ROLLBACK, txid,
1:f812e34:                                                                       false), true);
1:f812e34:             } else {
1:f812e34:                 peristenceAdapter.writeCommand(new JournalTransaction(JournalTransaction.LOCAL_ROLLBACK,
1:f812e34:                                                                       txid, false), true);
1:d29ca2a:             }
1:d29ca2a:         }
1:4a16f45:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @throws IOException
1:d29ca2a:      * @see org.apache.activemq.store.TransactionStore#rollback(TransactionId)
1:d29ca2a:      */
1:f812e34:     public void replayRollback(TransactionId txid) throws IOException {
1:f812e34:         boolean inflight = false;
1:f812e34:         synchronized (inflightTransactions) {
1:f812e34:             inflight = inflightTransactions.remove(txid) != null;
1:4a16f45:         }
1:f812e34:         if (inflight) {
1:f812e34:             synchronized (preparedTransactions) {
1:d29ca2a:                 preparedTransactions.remove(txid);
1:d29ca2a:             }
1:4a16f45:         }
1:4a16f45:     }
1:f812e34: 
1:d29ca2a:     public void start() throws Exception {
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public void stop() throws Exception {
1:d29ca2a:     }
1:f812e34: 
1:fc00993:     public synchronized void recover(TransactionRecoveryListener listener) throws IOException {
1:d29ca2a:         // All the in-flight transactions get rolled back..
1:f812e34:         synchronized (inflightTransactions) {
1:d29ca2a:             inflightTransactions.clear();
1:4a16f45:         }
1:f812e34:         this.doingRecover = true;
1:f812e34:         try {
1:933eb2f:             Map<TransactionId, Tx> txs = null;
1:f812e34:             synchronized (preparedTransactions) {
1:933eb2f:                 txs = new LinkedHashMap<TransactionId, Tx>(preparedTransactions);
1:d29ca2a:             }
1:933eb2f:             for (Iterator<TransactionId> iter = txs.keySet().iterator(); iter.hasNext();) {
1:933eb2f:                 Object txid = iter.next();
1:933eb2f:                 Tx tx = txs.get(txid);
1:f812e34:                 listener.recover((XATransactionId)txid, tx.getMessages(), tx.getAcks());
1:4a16f45:             }
1:f812e34:         } finally {
1:f812e34:             this.doingRecover = false;
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @param message
1:d29ca2a:      * @throws IOException
1:d29ca2a:      */
1:d29ca2a:     void addMessage(JournalMessageStore store, Message message, RecordLocation location) throws IOException {
1:d29ca2a:         Tx tx = getTx(message.getTransactionId(), location);
1:d29ca2a:         tx.add(store, message);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @param ack
1:d29ca2a:      * @throws IOException
1:d29ca2a:      */
1:f812e34:     public void removeMessage(JournalMessageStore store, MessageAck ack, RecordLocation location)
1:f812e34:         throws IOException {
1:d29ca2a:         Tx tx = getTx(ack.getTransactionId(), location);
1:d29ca2a:         tx.add(store, ack);
1:d29ca2a:     }
1:f812e34: 
1:d29ca2a:     public void acknowledge(JournalTopicMessageStore store, JournalTopicAck ack, RecordLocation location) {
1:d29ca2a:         Tx tx = getTx(ack.getTransactionId(), location);
1:d29ca2a:         tx.add(store, ack);
1:d29ca2a:     }
1:d29ca2a: 
1:f812e34:     public RecordLocation checkpoint() throws IOException {
1:d29ca2a:         // Nothing really to checkpoint.. since, we don't
1:f812e34:         // checkpoint tx operations in to long term store until they are
1:f812e34:         // committed.
1:d29ca2a:         // But we keep track of the first location of an operation
1:d29ca2a:         // that was associated with an active tx. The journal can not
1:d29ca2a:         // roll over active tx records.
1:f812e34:         RecordLocation rc = null;
1:f812e34:         synchronized (inflightTransactions) {
1:933eb2f:             for (Iterator<Tx> iter = inflightTransactions.values().iterator(); iter.hasNext();) {
1:933eb2f:                 Tx tx = iter.next();
1:f812e34:                 RecordLocation location = tx.location;
1:f812e34:                 if (rc == null || rc.compareTo(location) < 0) {
1:f812e34:                     rc = location;
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a:         }
1:f812e34:         synchronized (preparedTransactions) {
1:933eb2f:             for (Iterator<Tx> iter = preparedTransactions.values().iterator(); iter.hasNext();) {
1:933eb2f:                 Tx tx = iter.next();
1:f812e34:                 RecordLocation location = tx.location;
1:f812e34:                 if (rc == null || rc.compareTo(location) < 0) {
1:f812e34:                     rc = location;
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a:             return rc;
1:4a16f45:         }
1:4a16f45:     }
1:d29ca2a: 
1:d29ca2a:     public boolean isDoingRecover() {
1:d29ca2a:         return doingRecover;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:c5cf038
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:      * 
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
0:     private Map<Object, Tx> inflightTransactions = new LinkedHashMap<Object, Tx>();
0:     private Map<TransactionId, Tx> preparedTransactions = new LinkedHashMap<TransactionId, Tx>();
/////////////////////////////////////////////////////////////////////////
0:         private ArrayList<TxOperation> operations = new ArrayList<TxOperation>();
/////////////////////////////////////////////////////////////////////////
1:             ArrayList<Object> list = new ArrayList<Object>();
1:             for (Iterator<TxOperation> iter = operations.iterator(); iter.hasNext();) {
1:                 TxOperation op = iter.next();
/////////////////////////////////////////////////////////////////////////
1:             ArrayList<Object> list = new ArrayList<Object>();
1:             for (Iterator<TxOperation> iter = operations.iterator(); iter.hasNext();) {
1:                 TxOperation op = iter.next();
/////////////////////////////////////////////////////////////////////////
1:         public ArrayList<TxOperation> getOperations() {
/////////////////////////////////////////////////////////////////////////
1:             tx = inflightTransactions.remove(txid);
/////////////////////////////////////////////////////////////////////////
1:             tx = inflightTransactions.remove(txid);
/////////////////////////////////////////////////////////////////////////
1:             tx = inflightTransactions.get(txid);
/////////////////////////////////////////////////////////////////////////
1:                 tx = preparedTransactions.remove(txid);
1:                 tx = inflightTransactions.remove(txid);
/////////////////////////////////////////////////////////////////////////
1:                 return preparedTransactions.remove(txid);
1:                 return inflightTransactions.remove(txid);
/////////////////////////////////////////////////////////////////////////
1:             tx = inflightTransactions.remove(txid);
1:                 tx = preparedTransactions.remove(txid);
/////////////////////////////////////////////////////////////////////////
1:             Map<TransactionId, Tx> txs = null;
1:                 txs = new LinkedHashMap<TransactionId, Tx>(preparedTransactions);
1:             for (Iterator<TransactionId> iter = txs.keySet().iterator(); iter.hasNext();) {
1:                 Object txid = iter.next();
1:                 Tx tx = txs.get(txid);
/////////////////////////////////////////////////////////////////////////
1:             for (Iterator<Tx> iter = inflightTransactions.values().iterator(); iter.hasNext();) {
1:                 Tx tx = iter.next();
/////////////////////////////////////////////////////////////////////////
1:             for (Iterator<Tx> iter = preparedTransactions.values().iterator(); iter.hasNext();) {
1:                 Tx tx = iter.next();
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:         if (tx == null) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (tx == null) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (tx == null) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (tx != null) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:     public synchronized void recover(TransactionRecoveryListener listener) throws IOException {
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
commit:f812e34
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         static final byte ADD_OPERATION_TYPE = 0;
1:         static final byte REMOVE_OPERATION_TYPE = 1;
1:         static final byte ACK_OPERATION_TYPE = 3;
1: 
1: 
1:             this.operationType = operationType;
1:             this.store = store;
1:             this.data = data;
1: 
1: 
1:      * 
/////////////////////////////////////////////////////////////////////////
1:             this.location = location;
/////////////////////////////////////////////////////////////////////////
1: 
0:                 TxOperation op = (TxOperation)iter.next();
1:                 if (op.operationType == TxOperation.ADD_OPERATION_TYPE) {
/////////////////////////////////////////////////////////////////////////
0:                 TxOperation op = (TxOperation)iter.next();
1:                 if (op.operationType == TxOperation.REMOVE_OPERATION_TYPE) {
/////////////////////////////////////////////////////////////////////////
1:     public void prepare(TransactionId txid) throws IOException {
1:         Tx tx = null;
1:         synchronized (inflightTransactions) {
0:             tx = (Tx)inflightTransactions.remove(txid);
0:         if (tx == null)
1:         peristenceAdapter.writeCommand(new JournalTransaction(JournalTransaction.XA_PREPARE, txid, false),
1:                                        true);
1:         synchronized (preparedTransactions) {
1:             preparedTransactions.put(txid, tx);
1: 
1:     public void replayPrepare(TransactionId txid) throws IOException {
1:         Tx tx = null;
1:         synchronized (inflightTransactions) {
0:             tx = (Tx)inflightTransactions.remove(txid);
0:         if (tx == null)
1:         synchronized (preparedTransactions) {
1:             preparedTransactions.put(txid, tx);
1:     public Tx getTx(Object txid, RecordLocation location) {
1:         Tx tx = null;
1:         synchronized (inflightTransactions) {
0:             tx = (Tx)inflightTransactions.get(txid);
1:         if (tx == null) {
1:             tx = new Tx(location);
1:             inflightTransactions.put(txid, tx);
/////////////////////////////////////////////////////////////////////////
0:     public void commit(TransactionId txid, boolean wasPrepared) throws IOException {
1:         if (wasPrepared) {
1:             synchronized (preparedTransactions) {
0:                 tx = (Tx)preparedTransactions.remove(txid);
1:         } else {
1:             synchronized (inflightTransactions) {
0:                 tx = (Tx)inflightTransactions.remove(txid);
0:         if (tx == null)
1:         if (txid.isXATransaction()) {
1:             peristenceAdapter.writeCommand(new JournalTransaction(JournalTransaction.XA_COMMIT, txid,
1:                                                                   wasPrepared), true);
1:         } else {
1:             peristenceAdapter.writeCommand(new JournalTransaction(JournalTransaction.LOCAL_COMMIT, txid,
1:                                                                   wasPrepared), true);
/////////////////////////////////////////////////////////////////////////
1:     public Tx replayCommit(TransactionId txid, boolean wasPrepared) throws IOException {
1:         if (wasPrepared) {
1:             synchronized (preparedTransactions) {
1:         } else {
1:             synchronized (inflightTransactions) {
/////////////////////////////////////////////////////////////////////////
1:     public void rollback(TransactionId txid) throws IOException {
1:         Tx tx = null;
1:         synchronized (inflightTransactions) {
0:             tx = (Tx)inflightTransactions.remove(txid);
0:         if (tx != null)
1:             synchronized (preparedTransactions) {
0:                 tx = (Tx)preparedTransactions.remove(txid);
1:         if (tx != null) {
1:             if (txid.isXATransaction()) {
1:                 peristenceAdapter.writeCommand(new JournalTransaction(JournalTransaction.XA_ROLLBACK, txid,
1:                                                                       false), true);
1:             } else {
1:                 peristenceAdapter.writeCommand(new JournalTransaction(JournalTransaction.LOCAL_ROLLBACK,
1:                                                                       txid, false), true);
/////////////////////////////////////////////////////////////////////////
1:     public void replayRollback(TransactionId txid) throws IOException {
1:         boolean inflight = false;
1:         synchronized (inflightTransactions) {
1:             inflight = inflightTransactions.remove(txid) != null;
1:         if (inflight) {
1:             synchronized (preparedTransactions) {
1: 
1: 
0:     synchronized public void recover(TransactionRecoveryListener listener) throws IOException {
1:         synchronized (inflightTransactions) {
1:         this.doingRecover = true;
1:         try {
0:             Map txs = null;
1:             synchronized (preparedTransactions) {
0:                 txs = new LinkedHashMap(preparedTransactions);
0:             for (Iterator iter = txs.keySet().iterator(); iter.hasNext();) {
0:                 Object txid = (Object)iter.next();
0:                 Tx tx = (Tx)txs.get(txid);
1:                 listener.recover((XATransactionId)txid, tx.getMessages(), tx.getAcks());
1:         } finally {
1:             this.doingRecover = false;
/////////////////////////////////////////////////////////////////////////
1:     public void removeMessage(JournalMessageStore store, MessageAck ack, RecordLocation location)
1:         throws IOException {
1: 
1:     public RecordLocation checkpoint() throws IOException {
1:         // checkpoint tx operations in to long term store until they are
1:         // committed.
1:         RecordLocation rc = null;
1:         synchronized (inflightTransactions) {
0:             for (Iterator iter = inflightTransactions.values().iterator(); iter.hasNext();) {
0:                 Tx tx = (Tx)iter.next();
1:                 RecordLocation location = tx.location;
1:                 if (rc == null || rc.compareTo(location) < 0) {
1:                     rc = location;
1:         synchronized (preparedTransactions) {
0:             for (Iterator iter = preparedTransactions.values().iterator(); iter.hasNext();) {
0:                 Tx tx = (Tx)iter.next();
1:                 RecordLocation location = tx.location;
1:                 if (rc == null || rc.compareTo(location) < 0) {
1:                     rc = location;
/////////////////////////////////////////////////////////////////////////
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:f451ad0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activeio.journal.RecordLocation;
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.activemq.store.journal;
1: 
1: import java.io.IOException;
1: import java.util.ArrayList;
1: import java.util.Iterator;
1: 
1: import javax.transaction.xa.XAException;
1: 
0: import org.activeio.journal.RecordLocation;
1: import org.apache.activemq.command.JournalTopicAck;
1: import org.apache.activemq.command.JournalTransaction;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.TransactionId;
1: import org.apache.activemq.command.XATransactionId;
1: import org.apache.activemq.store.TransactionRecoveryListener;
1: import org.apache.activemq.store.TransactionStore;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
1: 
1: /**
1:  */
1: public class JournalTransactionStore implements TransactionStore {
1: 
1:     private final JournalPersistenceAdapter peristenceAdapter;
0:     ConcurrentHashMap inflightTransactions = new ConcurrentHashMap();
0:     ConcurrentHashMap preparedTransactions = new ConcurrentHashMap();
1:     private boolean doingRecover;
1: 
1:     
1:     public static class TxOperation {
1:         
0:         static final byte ADD_OPERATION_TYPE       = 0;
0:         static final byte REMOVE_OPERATION_TYPE    = 1;
0:         static final byte ACK_OPERATION_TYPE       = 3;
1:         
1:         public byte operationType;
1:         public JournalMessageStore store;
1:         public Object data;
1:         
1:         public TxOperation(byte operationType, JournalMessageStore store, Object data) {
0:             this.operationType=operationType;
0:             this.store=store;
0:             this.data=data;
1:         }
1:         
1:     }
1:     /**
1:      * Operations
0:      * @version $Revision: 1.6 $
1:      */
1:     public static class Tx {
1: 
1:         private final RecordLocation location;
0:         private ArrayList operations = new ArrayList();
1: 
1:         public Tx(RecordLocation location) {
0:             this.location=location;
1:         }
1: 
1:         public void add(JournalMessageStore store, Message msg) {
1:             operations.add(new TxOperation(TxOperation.ADD_OPERATION_TYPE, store, msg));
1:         }
1: 
1:         public void add(JournalMessageStore store, MessageAck ack) {
1:             operations.add(new TxOperation(TxOperation.REMOVE_OPERATION_TYPE, store, ack));
1:         }
1: 
1:         public void add(JournalTopicMessageStore store, JournalTopicAck ack) {
1:             operations.add(new TxOperation(TxOperation.ACK_OPERATION_TYPE, store, ack));
1:         }
1:         
1:         public Message[] getMessages() {
0:             ArrayList list = new ArrayList();
0:             for (Iterator iter = operations.iterator(); iter.hasNext();) {
0:                 TxOperation op = (TxOperation) iter.next();
0:                 if( op.operationType==TxOperation.ADD_OPERATION_TYPE ) {
1:                     list.add(op.data);
1:                 }
1:             }
1:             Message rc[] = new Message[list.size()];
1:             list.toArray(rc);
1:             return rc;
1:         }
1: 
1:         public MessageAck[] getAcks() {
0:             ArrayList list = new ArrayList();
0:             for (Iterator iter = operations.iterator(); iter.hasNext();) {
0:                 TxOperation op = (TxOperation) iter.next();
0:                 if( op.operationType==TxOperation.REMOVE_OPERATION_TYPE ) {
1:                     list.add(op.data);
1:                 }
1:             }
1:             MessageAck rc[] = new MessageAck[list.size()];
1:             list.toArray(rc);
1:             return rc;
1:         }
1: 
0:         public ArrayList getOperations() {
1:             return operations;
1:         }
1: 
1:     }
1: 
1:     public JournalTransactionStore(JournalPersistenceAdapter adapter) {
1:         this.peristenceAdapter = adapter;
1:     }
1: 
1:     /**
1:      * @throws IOException
1:      * @see org.apache.activemq.store.TransactionStore#prepare(TransactionId)
1:      */
0:     public void prepare(TransactionId txid) throws IOException {
0:         Tx tx = (Tx) inflightTransactions.remove(txid);
0:         if (tx == null)
1:             return;
0:         peristenceAdapter.writeCommand(new JournalTransaction(JournalTransaction.XA_PREPARE, txid, false), true);
0:         preparedTransactions.put(txid, tx);
1:     }
1:     
1:     /**
1:      * @throws IOException
1:      * @see org.apache.activemq.store.TransactionStore#prepare(TransactionId)
1:      */
0:     public void replayPrepare(TransactionId txid) throws IOException {
0:         Tx tx = (Tx) inflightTransactions.remove(txid);
0:         if (tx == null)
1:             return;
0:         preparedTransactions.put(txid, tx);
1:     }
1: 
0:     public Tx getTx(Object txid, RecordLocation location) {
0:         Tx tx = (Tx) inflightTransactions.get(txid);
0:         if (tx == null) {
0:             tx = new Tx(location);
0:             inflightTransactions.put(txid, tx);
1:         }
1:         return tx;
1:     }
1: 
1:     /**
1:      * @throws XAException
1:      * @see org.apache.activemq.store.TransactionStore#commit(org.apache.activemq.service.Transaction)
1:      */
0:     public void commit(TransactionId txid, boolean wasPrepared) throws IOException {
1:         Tx tx;
0:         if (wasPrepared) {
0:             tx = (Tx) preparedTransactions.remove(txid);
0:         } else {
0:             tx = (Tx) inflightTransactions.remove(txid);
1:         }
1: 
0:         if (tx == null)
1:             return;
1: 
0:         if (txid.isXATransaction()) {
0:             peristenceAdapter.writeCommand(new JournalTransaction(JournalTransaction.XA_COMMIT, txid, wasPrepared),
0:                     true);
0:         } else {
0:             peristenceAdapter.writeCommand(new JournalTransaction(JournalTransaction.LOCAL_COMMIT, txid, wasPrepared),
0:                     true);
1:         }
1:     }
1: 
1:     /**
1:      * @throws XAException
1:      * @see org.apache.activemq.store.TransactionStore#commit(org.apache.activemq.service.Transaction)
1:      */
0:     public Tx replayCommit(TransactionId txid, boolean wasPrepared) throws IOException {
0:         if (wasPrepared) {
0:             return (Tx) preparedTransactions.remove(txid);
0:         } else {
0:             return (Tx) inflightTransactions.remove(txid);
1:         }
1:     }
1: 
1:     /**
1:      * @throws IOException
1:      * @see org.apache.activemq.store.TransactionStore#rollback(TransactionId)
1:      */
0:     public void rollback(TransactionId txid) throws IOException {
1: 
0:         Tx tx = (Tx) inflightTransactions.remove(txid);
0:         if (tx != null)
0:             tx = (Tx) preparedTransactions.remove(txid);
1: 
0:         if (tx != null) {
0:             if (txid.isXATransaction()) {
0:                 peristenceAdapter.writeCommand(new JournalTransaction(JournalTransaction.XA_ROLLBACK, txid, false),
0:                         true);
0:             } else {
0:                 peristenceAdapter.writeCommand(new JournalTransaction(JournalTransaction.LOCAL_ROLLBACK, txid, false),
0:                         true);
1:             }
1:         }
1: 
1:     }
1: 
1:     /**
1:      * @throws IOException
1:      * @see org.apache.activemq.store.TransactionStore#rollback(TransactionId)
1:      */
0:     public void replayRollback(TransactionId txid) throws IOException {
0:         if (inflightTransactions.remove(txid) != null)
1:             preparedTransactions.remove(txid);
1:     }
1:     
1:     public void start() throws Exception {
1:     }
1: 
1:     public void stop() throws Exception {
1:     }
1:     
0:     synchronized public void recover(TransactionRecoveryListener listener) throws IOException {
1:         // All the in-flight transactions get rolled back..
1:         inflightTransactions.clear();
0:         this.doingRecover = true;
0:         try {
0:             for (Iterator iter = preparedTransactions.keySet().iterator(); iter.hasNext();) {
0:                 Object txid = (Object) iter.next();
0:                 Tx tx = (Tx) preparedTransactions.get(txid);
0:                 listener.recover((XATransactionId) txid, tx.getMessages(), tx.getAcks());
1:             }
0:         } finally {
0:             this.doingRecover = false;
1:         }
1:     }
1: 
1:     /**
1:      * @param message
1:      * @throws IOException
1:      */
1:     void addMessage(JournalMessageStore store, Message message, RecordLocation location) throws IOException {
1:         Tx tx = getTx(message.getTransactionId(), location);
1:         tx.add(store, message);
1:     }
1: 
1:     /**
1:      * @param ack
1:      * @throws IOException
1:      */
0:     public void removeMessage(JournalMessageStore store, MessageAck ack, RecordLocation location) throws IOException {
1:         Tx tx = getTx(ack.getTransactionId(), location);
1:         tx.add(store, ack);
1:     }
1:     
1:     
1:     public void acknowledge(JournalTopicMessageStore store, JournalTopicAck ack, RecordLocation location) {
1:         Tx tx = getTx(ack.getTransactionId(), location);
1:         tx.add(store, ack);
1:     }
1: 
1: 
0:     public RecordLocation checkpoint() throws IOException {
1:         
1:         // Nothing really to checkpoint.. since, we don't
0:         // checkpoint tx operations in to long term store until they are committed.
1: 
1:         // But we keep track of the first location of an operation
1:         // that was associated with an active tx. The journal can not
1:         // roll over active tx records.        
0:         RecordLocation rc = null;
0:         for (Iterator iter = inflightTransactions.values().iterator(); iter.hasNext();) {
0:             Tx tx = (Tx) iter.next();
0:             RecordLocation location = tx.location;
0:             if (rc == null || rc.compareTo(location) < 0) {
0:                 rc = location;
1:             }
1:         }
0:         for (Iterator iter = preparedTransactions.values().iterator(); iter.hasNext();) {
0:             Tx tx = (Tx) iter.next();
0:             RecordLocation location = tx.location;
0:             if (rc == null || rc.compareTo(location) < 0) {
0:                 rc = location;
1:             }
1:         }
1:         return rc;
1:     }
1: 
1:     public boolean isDoingRecover() {
1:         return doingRecover;
1:     }
1: 
1: 
1: }
author:Robert Davies
-------------------------------------------------------------------------------
commit:27262c8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final Map<Object, Tx> inflightTransactions = new LinkedHashMap<Object, Tx>();
1:     private final Map<TransactionId, Tx> preparedTransactions = new LinkedHashMap<TransactionId, Tx>();
/////////////////////////////////////////////////////////////////////////
1:         private final ArrayList<TxOperation> operations = new ArrayList<TxOperation>();
/////////////////////////////////////////////////////////////////////////
1:     public void commit(TransactionId txid, boolean wasPrepared, Runnable preCommit,Runnable postCommit) throws IOException {
1:         if (preCommit != null) {
1:             preCommit.run();
1:         }
/////////////////////////////////////////////////////////////////////////
1:             if (postCommit != null) {
1:                 postCommit.run();
1:             }
/////////////////////////////////////////////////////////////////////////
1:         if (postCommit != null) {
1:             postCommit.run();
1:         }
commit:4a16f45
/////////////////////////////////////////////////////////////////////////
1: import java.util.LinkedHashMap;
0: import java.util.List;
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
0:     Map inflightTransactions = new LinkedHashMap();
0:     Map preparedTransactions = new LinkedHashMap();
/////////////////////////////////////////////////////////////////////////
0:     public void prepare(TransactionId txid) throws IOException{
0:         Tx tx=null;
0:         synchronized(inflightTransactions){
0:             tx=(Tx)inflightTransactions.remove(txid);
1:         }
0:         if(tx==null)
0:         peristenceAdapter.writeCommand(new JournalTransaction(JournalTransaction.XA_PREPARE,txid,false),true);
0:         synchronized(preparedTransactions){
0:             preparedTransactions.put(txid,tx);
1:         }
0:     public void replayPrepare(TransactionId txid) throws IOException{
0:         Tx tx=null;
0:         synchronized(inflightTransactions){
0:             tx=(Tx)inflightTransactions.remove(txid);
1:         }
0:         if(tx==null)
0:         synchronized(preparedTransactions){
0:             preparedTransactions.put(txid,tx);
1:         }
0:     public Tx getTx(Object txid,RecordLocation location){
0:         Tx tx=null;
0:         synchronized(inflightTransactions){
0:             tx=(Tx)inflightTransactions.get(txid);
1:         }
0:         if(tx==null){
0:             tx=new Tx(location);
0:             inflightTransactions.put(txid,tx);
/////////////////////////////////////////////////////////////////////////
0:     public void commit(TransactionId txid,boolean wasPrepared) throws IOException{
0:         if(wasPrepared){
0:             synchronized(preparedTransactions){
0:                 tx=(Tx)preparedTransactions.remove(txid);
1:             }
0:         }else{
0:             synchronized(inflightTransactions){
0:                 tx=(Tx)inflightTransactions.remove(txid);
1:             }
0:         if(tx==null)
0:         if(txid.isXATransaction()){
0:             peristenceAdapter.writeCommand(new JournalTransaction(JournalTransaction.XA_COMMIT,txid,wasPrepared),true);
0:         }else{
0:             peristenceAdapter.writeCommand(new JournalTransaction(JournalTransaction.LOCAL_COMMIT,txid,wasPrepared),
/////////////////////////////////////////////////////////////////////////
0:     public Tx replayCommit(TransactionId txid,boolean wasPrepared) throws IOException{
0:         if(wasPrepared){
0:             synchronized(preparedTransactions){
0:                 return (Tx)preparedTransactions.remove(txid);
1:             }
0:         }else{
0:             synchronized(inflightTransactions){
0:                 return (Tx)inflightTransactions.remove(txid);
1:             }
/////////////////////////////////////////////////////////////////////////
0:     public void rollback(TransactionId txid) throws IOException{
0:         Tx tx=null;
0:         synchronized(inflightTransactions){
0:             tx=(Tx)inflightTransactions.remove(txid);
1:         }
0:         if(tx!=null)
0:             synchronized(preparedTransactions){
0:                 tx=(Tx)preparedTransactions.remove(txid);
1:             }
0:         if(tx!=null){
0:             if(txid.isXATransaction()){
0:                 peristenceAdapter.writeCommand(new JournalTransaction(JournalTransaction.XA_ROLLBACK,txid,false),true);
0:             }else{
0:                 peristenceAdapter.writeCommand(new JournalTransaction(JournalTransaction.LOCAL_ROLLBACK,txid,false),
0:     public void replayRollback(TransactionId txid) throws IOException{
0:         boolean inflight=false;
0:         synchronized(inflightTransactions){
0:             inflight=inflightTransactions.remove(txid)!=null;
1:         }
0:         if(inflight){
0:             synchronized(preparedTransactions){
0:                 preparedTransactions.remove(txid);
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
0:     synchronized public void recover(TransactionRecoveryListener listener) throws IOException{
0:         synchronized(inflightTransactions){
0:             inflightTransactions.clear();
1:         }
0:         this.doingRecover=true;
0:         try{
0:             Map txs=null;
0:             synchronized(preparedTransactions){
0:                 txs=new LinkedHashMap(preparedTransactions);
0:             for(Iterator iter=txs.keySet().iterator();iter.hasNext();){
0:                 Object txid=(Object)iter.next();
0:                 Tx tx=(Tx)txs.get(txid);
0:                 listener.recover((XATransactionId)txid,tx.getMessages(),tx.getAcks());
1:             }
0:         }finally{
0:             this.doingRecover=false;
/////////////////////////////////////////////////////////////////////////
0:     public RecordLocation checkpoint() throws IOException{
0:         // roll over active tx records.
0:         RecordLocation rc=null;
0:         synchronized(inflightTransactions){
0:             for(Iterator iter=inflightTransactions.values().iterator();iter.hasNext();){
0:                 Tx tx=(Tx)iter.next();
0:                 RecordLocation location=tx.location;
0:                 if(rc==null||rc.compareTo(location)<0){
0:                     rc=location;
1:                 }
0:         synchronized(preparedTransactions){
0:             for(Iterator iter=preparedTransactions.values().iterator();iter.hasNext();){
0:                 Tx tx=(Tx)iter.next();
0:                 RecordLocation location=tx.location;
0:                 if(rc==null||rc.compareTo(location)<0){
0:                     rc=location;
1:                 }
0:             return rc;
author:Gary Tully
-------------------------------------------------------------------------------
commit:e1389a6
/////////////////////////////////////////////////////////////////////////
0:     public void commit(TransactionId txid, boolean wasPrepared, Runnable done) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:             done.run();
/////////////////////////////////////////////////////////////////////////
0:         done.run();
============================================================================