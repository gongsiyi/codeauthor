1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
7:d29ca2a:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b0c2a40:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.store.journal;
1:18d616c: 
1:d29ca2a: import java.io.IOException;
1:d29ca2a: import java.util.ArrayList;
1:d29ca2a: import java.util.Collections;
1:d29ca2a: import java.util.HashSet;
1:d29ca2a: import java.util.Iterator;
1:d29ca2a: import java.util.LinkedHashMap;
1:ecf89a6: import java.util.List;
1:ecf89a6: import java.util.Map;
1:ecf89a6: import java.util.Set;
1:f812e34: 
1:f451ad0: import org.apache.activeio.journal.RecordLocation;
1:d29ca2a: import org.apache.activemq.broker.ConnectionContext;
1:d29ca2a: import org.apache.activemq.command.ActiveMQDestination;
1:d29ca2a: import org.apache.activemq.command.JournalQueueAck;
1:d29ca2a: import org.apache.activemq.command.Message;
1:d29ca2a: import org.apache.activemq.command.MessageAck;
1:d29ca2a: import org.apache.activemq.command.MessageId;
1:3b0afd6: import org.apache.activemq.filter.NonCachedMessageEvaluationContext;
1:e8f8155: import org.apache.activemq.store.IndexListener;
1:d29ca2a: import org.apache.activemq.store.MessageRecoveryListener;
1:d29ca2a: import org.apache.activemq.store.MessageStore;
1:d29ca2a: import org.apache.activemq.store.PersistenceAdapter;
1:63e3f41: import org.apache.activemq.store.AbstractMessageStore;
1:d29ca2a: import org.apache.activemq.transaction.Synchronization;
1:6d8e2c5: import org.apache.activemq.usage.MemoryUsage;
1:d29ca2a: import org.apache.activemq.util.Callback;
1:d29ca2a: import org.apache.activemq.util.TransactionTemplate;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
23:d29ca2a: 
1:d29ca2a: /**
1:d29ca2a:  * A MessageStore that uses a Journal to store it's messages.
1:785b16b:  *
1:785b16b:  *
1:d29ca2a:  */
1:63e3f41: public class JournalMessageStore extends AbstractMessageStore {
1:d29ca2a: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(JournalMessageStore.class);
1:d29ca2a: 
1:d29ca2a:     protected final JournalPersistenceAdapter peristenceAdapter;
1:d29ca2a:     protected final JournalTransactionStore transactionStore;
1:d29ca2a:     protected final MessageStore longTermStore;
1:d29ca2a:     protected final TransactionTemplate transactionTemplate;
1:ecf89a6:     protected RecordLocation lastLocation;
1:ecf89a6:     protected Set<RecordLocation> inFlightTxLocations = new HashSet<RecordLocation>();
1:18d616c: 
1:ecf89a6:     private Map<MessageId, Message> messages = new LinkedHashMap<MessageId, Message>();
1:ecf89a6:     private List<MessageAck> messageAcks = new ArrayList<MessageAck>();
1:d29ca2a: 
1:d29ca2a:     /** A MessageStore that we can use to retrieve messages quickly. */
1:ecf89a6:     private Map<MessageId, Message> cpAddedMessageIds;
1:f812e34: 
1:d29ca2a: 
1:6d8e2c5:     private MemoryUsage memoryUsage;
1:d29ca2a: 
1:fc00993:     public JournalMessageStore(JournalPersistenceAdapter adapter, MessageStore checkpointStore, ActiveMQDestination destination) {
1:63e3f41:         super(destination);
1:d29ca2a:         this.peristenceAdapter = adapter;
1:d29ca2a:         this.transactionStore = adapter.getTransactionStore();
1:d29ca2a:         this.longTermStore = checkpointStore;
1:3b0afd6:         this.transactionTemplate = new TransactionTemplate(adapter, new ConnectionContext(new NonCachedMessageEvaluationContext()));
1:d29ca2a:     }
1:785b16b: 
1:f812e34: 
1:6d8e2c5:     public void setMemoryUsage(MemoryUsage memoryUsage) {
1:6d8e2c5:         this.memoryUsage=memoryUsage;
1:6d8e2c5:         longTermStore.setMemoryUsage(memoryUsage);
1:18d616c:     }
1:f812e34: 
1:d29ca2a:     /**
1:d29ca2a:      * Not synchronized since the Journal has better throughput if you increase
1:d29ca2a:      * the number of concurrent writes that it is doing.
1:d29ca2a:      */
1:e8f8155:     public void addMessage(final ConnectionContext context, final Message message) throws IOException {
1:f812e34: 
1:d29ca2a:         final MessageId id = message.getMessageId();
1:f812e34: 
1:ecf89a6:         final boolean debug = LOG.isDebugEnabled();
1:d29ca2a:         message.incrementReferenceCount();
1:f812e34: 
1:d29ca2a:         final RecordLocation location = peristenceAdapter.writeCommand(message, message.isResponseRequired());
1:f812e34:         if (!context.isInTransaction()) {
1:fc00993:             if (debug) {
1:ecf89a6:                 LOG.debug("Journalled message add for: " + id + ", at: " + location);
1:fc00993:             }
1:e8f8155:             addMessage(context, message, location);
2:d29ca2a:         } else {
1:fc00993:             if (debug) {
1:ecf89a6:                 LOG.debug("Journalled transacted message add for: " + id + ", at: " + location);
1:fc00993:             }
1:f812e34:             synchronized (this) {
1:d29ca2a:                 inFlightTxLocations.add(location);
1:d29ca2a:             }
1:d29ca2a:             transactionStore.addMessage(this, message, location);
1:f812e34:             context.getTransaction().addSynchronization(new Synchronization() {
1:f812e34:                 public void afterCommit() throws Exception {
1:fc00993:                     if (debug) {
1:ecf89a6:                         LOG.debug("Transacted message add commit for: " + id + ", at: " + location);
1:fc00993:                     }
1:f812e34:                     synchronized (JournalMessageStore.this) {
1:d29ca2a:                         inFlightTxLocations.remove(location);
1:e8f8155:                         addMessage(context, message, location);
1:d29ca2a:                     }
1:d29ca2a:                 }
1:f812e34: 
1:f812e34:                 public void afterRollback() throws Exception {
1:ecf89a6:                     if (debug) {
1:ecf89a6:                         LOG.debug("Transacted message add rollback for: " + id + ", at: " + location);
1:fc00993:                     }
1:f812e34:                     synchronized (JournalMessageStore.this) {
1:d29ca2a:                         inFlightTxLocations.remove(location);
1:d29ca2a:                     }
1:d29ca2a:                     message.decrementReferenceCount();
1:d29ca2a:                 }
1:d29ca2a:             });
1:d29ca2a:         }
1:d29ca2a:     }
1:f812e34: 
1:e8f8155:     void addMessage(ConnectionContext context, final Message message, final RecordLocation location) {
1:d29ca2a:         synchronized (this) {
1:d29ca2a:             lastLocation = location;
1:d29ca2a:             MessageId id = message.getMessageId();
1:d29ca2a:             messages.put(id, message);
1:e8f8155:             message.getMessageId().setFutureOrSequenceLong(0l);
1:e8f8155:             if (indexListener != null) {
1:e8f8155:                 indexListener.onAdd(new IndexListener.MessageContext(context, message, null));
1:e8f8155:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:f812e34: 
1:d29ca2a:     public void replayAddMessage(ConnectionContext context, Message message) {
2:d29ca2a:         try {
1:d29ca2a:             // Only add the message if it has not already been added.
1:d29ca2a:             Message t = longTermStore.getMessage(message.getMessageId());
1:f812e34:             if (t == null) {
2:d29ca2a:                 longTermStore.addMessage(context, message);
1:d29ca2a:             }
1:f812e34:         } catch (Throwable e) {
1:ecf89a6:             LOG.warn("Could not replay add for message '" + message.getMessageId() + "'.  Message may have already been added. reason: " + e);
1:d29ca2a:         }
1:d29ca2a:     }
1:18d616c: 
1:d29ca2a:     /**
1:d29ca2a:      */
1:d29ca2a:     public void removeMessage(ConnectionContext context, final MessageAck ack) throws IOException {
1:ecf89a6:         final boolean debug = LOG.isDebugEnabled();
1:d29ca2a:         JournalQueueAck remove = new JournalQueueAck();
1:d29ca2a:         remove.setDestination(destination);
1:d29ca2a:         remove.setMessageAck(ack);
1:f812e34: 
1:d29ca2a:         final RecordLocation location = peristenceAdapter.writeCommand(remove, ack.isResponseRequired());
1:f812e34:         if (!context.isInTransaction()) {
1:fc00993:             if (debug) {
1:ecf89a6:                 LOG.debug("Journalled message remove for: " + ack.getLastMessageId() + ", at: " + location);
1:fc00993:             }
1:d29ca2a:             removeMessage(ack, location);
1:d29ca2a:         } else {
1:fc00993:             if (debug) {
1:ecf89a6:                 LOG.debug("Journalled transacted message remove for: " + ack.getLastMessageId() + ", at: " + location);
1:fc00993:             }
1:f812e34:             synchronized (this) {
1:d29ca2a:                 inFlightTxLocations.add(location);
1:d29ca2a:             }
1:d29ca2a:             transactionStore.removeMessage(this, ack, location);
1:f812e34:             context.getTransaction().addSynchronization(new Synchronization() {
1:f812e34:                 public void afterCommit() throws Exception {
1:fc00993:                     if (debug) {
1:ecf89a6:                         LOG.debug("Transacted message remove commit for: " + ack.getLastMessageId() + ", at: " + location);
1:fc00993:                     }
1:f812e34:                     synchronized (JournalMessageStore.this) {
1:d29ca2a:                         inFlightTxLocations.remove(location);
1:d29ca2a:                         removeMessage(ack, location);
1:d29ca2a:                     }
1:d29ca2a:                 }
1:f812e34: 
1:f812e34:                 public void afterRollback() throws Exception {
1:fc00993:                     if (debug) {
1:ecf89a6:                         LOG.debug("Transacted message remove rollback for: " + ack.getLastMessageId() + ", at: " + location);
1:ecf89a6:                     }
1:f812e34:                     synchronized (JournalMessageStore.this) {
1:d29ca2a:                         inFlightTxLocations.remove(location);
1:d29ca2a:                     }
1:d29ca2a:                 }
1:d29ca2a:             });
1:d29ca2a: 
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:a3e3821:     final void removeMessage(final MessageAck ack, final RecordLocation location) {
1:d29ca2a:         synchronized (this) {
1:d29ca2a:             lastLocation = location;
1:d29ca2a:             MessageId id = ack.getLastMessageId();
1:ecf89a6:             Message message = messages.remove(id);
1:d29ca2a:             if (message == null) {
1:d29ca2a:                 messageAcks.add(ack);
1:d29ca2a:             } else {
1:d29ca2a:                 message.decrementReferenceCount();
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public void replayRemoveMessage(ConnectionContext context, MessageAck messageAck) {
1:d29ca2a:         try {
1:d29ca2a:             // Only remove the message if it has not already been removed.
1:d29ca2a:             Message t = longTermStore.getMessage(messageAck.getLastMessageId());
1:f812e34:             if (t != null) {
1:d29ca2a:                 longTermStore.removeMessage(context, messageAck);
1:d29ca2a:             }
1:f812e34:         } catch (Throwable e) {
1:ecf89a6:             LOG.warn("Could not replay acknowledge for message '" + messageAck.getLastMessageId() + "'.  Message may have already been acknowledged. reason: " + e);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return
1:f812e34:      * @throws IOException
1:d29ca2a:      */
1:d29ca2a:     public RecordLocation checkpoint() throws IOException {
1:d29ca2a:         return checkpoint(null);
1:d29ca2a:     }
1:f812e34: 
1:d29ca2a:     /**
1:d29ca2a:      * @return
1:d29ca2a:      * @throws IOException
1:d29ca2a:      */
1:933eb2f:     @SuppressWarnings("unchecked")
1:d29ca2a:     public RecordLocation checkpoint(final Callback postCheckpointTest) throws IOException {
1:d29ca2a: 
1:ecf89a6:         final List<MessageAck> cpRemovedMessageLocations;
1:ecf89a6:         final List<RecordLocation> cpActiveJournalLocations;
1:d29ca2a:         final int maxCheckpointMessageAddSize = peristenceAdapter.getMaxCheckpointMessageAddSize();
1:d29ca2a: 
1:d29ca2a:         // swap out the message hash maps..
1:d29ca2a:         synchronized (this) {
1:d29ca2a:             cpAddedMessageIds = this.messages;
1:d29ca2a:             cpRemovedMessageLocations = this.messageAcks;
1:f812e34: 
1:ecf89a6:             cpActiveJournalLocations = new ArrayList<RecordLocation>(inFlightTxLocations);
1:d29ca2a: 
1:ecf89a6:             this.messages = new LinkedHashMap<MessageId, Message>();
1:ecf89a6:             this.messageAcks = new ArrayList<MessageAck>();
1:d29ca2a:         }
1:d29ca2a: 
1:d29ca2a:         transactionTemplate.run(new Callback() {
1:7f5213b:             public void execute() throws Exception {
1:d29ca2a: 
1:d29ca2a:                 int size = 0;
1:f812e34: 
1:d29ca2a:                 PersistenceAdapter persitanceAdapter = transactionTemplate.getPersistenceAdapter();
1:d29ca2a:                 ConnectionContext context = transactionTemplate.getContext();
1:f812e34: 
1:d29ca2a:                 // Checkpoint the added messages.
1:f812e34:                 synchronized (JournalMessageStore.this) {
1:ecf89a6:                     Iterator<Message> iterator = cpAddedMessageIds.values().iterator();
1:f812e34:                     while (iterator.hasNext()) {
1:ecf89a6:                         Message message = iterator.next();
1:f812e34:                         try {
1:f812e34:                             longTermStore.addMessage(context, message);
1:f812e34:                         } catch (Throwable e) {
1:ecf89a6:                             LOG.warn("Message could not be added to long term store: " + e.getMessage(), e);
1:d29ca2a:                         }
1:f812e34:                         size += message.getSize();
1:d29ca2a:                         message.decrementReferenceCount();
1:d29ca2a:                         // Commit the batch if it's getting too big
1:f812e34:                         if (size >= maxCheckpointMessageAddSize) {
1:d29ca2a:                             persitanceAdapter.commitTransaction(context);
1:d29ca2a:                             persitanceAdapter.beginTransaction(context);
1:f812e34:                             size = 0;
1:d29ca2a:                         }
1:d29ca2a:                     }
1:d29ca2a:                 }
1:d29ca2a: 
1:d29ca2a:                 persitanceAdapter.commitTransaction(context);
1:d29ca2a:                 persitanceAdapter.beginTransaction(context);
1:d29ca2a: 
1:d29ca2a:                 // Checkpoint the removed messages.
1:ecf89a6:                 Iterator<MessageAck> iterator = cpRemovedMessageLocations.iterator();
2:d29ca2a:                 while (iterator.hasNext()) {
1:d29ca2a:                     try {
1:ecf89a6:                         MessageAck ack = iterator.next();
1:d29ca2a:                         longTermStore.removeMessage(transactionTemplate.getContext(), ack);
2:d29ca2a:                     } catch (Throwable e) {
1:ecf89a6:                         LOG.debug("Message could not be removed from long term store: " + e.getMessage(), e);
1:d29ca2a:                     }
1:d29ca2a:                 }
1:f812e34: 
1:f812e34:                 if (postCheckpointTest != null) {
1:d29ca2a:                     postCheckpointTest.execute();
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a: 
1:d29ca2a:         });
1:d29ca2a: 
1:d29ca2a:         synchronized (this) {
1:d29ca2a:             cpAddedMessageIds = null;
1:d29ca2a:         }
1:f812e34: 
1:f812e34:         if (cpActiveJournalLocations.size() > 0) {
1:d29ca2a:             Collections.sort(cpActiveJournalLocations);
1:ecf89a6:             return cpActiveJournalLocations.get(0);
1:d29ca2a:         }
1:f812e34:         synchronized (this) {
1:d29ca2a:             return lastLocation;
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:785b16b:      *
1:d29ca2a:      */
1:d29ca2a:     public Message getMessage(MessageId identity) throws IOException {
1:d29ca2a:         Message answer = null;
1:d29ca2a: 
1:d29ca2a:         synchronized (this) {
1:d29ca2a:             // Do we have a still have it in the journal?
1:ecf89a6:             answer = messages.get(identity);
1:ecf89a6:             if (answer == null && cpAddedMessageIds != null) {
1:ecf89a6:                 answer = cpAddedMessageIds.get(identity);
1:ecf89a6:             }
1:d29ca2a:         }
1:f812e34: 
1:f812e34:         if (answer != null) {
1:d29ca2a:             return answer;
1:d29ca2a:         }
1:f812e34: 
1:d29ca2a:         // If all else fails try the long term message store.
1:d29ca2a:         return longTermStore.getMessage(identity);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Replays the checkpointStore first as those messages are the oldest ones,
1:d29ca2a:      * then messages are replayed from the transaction log and then the cache is
1:d29ca2a:      * updated.
1:785b16b:      *
1:d29ca2a:      * @param listener
1:f812e34:      * @throws Exception
1:d29ca2a:      */
1:7f5213b:     public void recover(final MessageRecoveryListener listener) throws Exception {
1:d29ca2a:         peristenceAdapter.checkpoint(true, true);
1:d29ca2a:         longTermStore.recover(listener);
1:d29ca2a:     }
1:d29ca2a: 
1:f451ad0:     public void start() throws Exception {
1:6d8e2c5:         if (this.memoryUsage != null) {
1:6d8e2c5:             this.memoryUsage.addUsageListener(peristenceAdapter);
1:ecf89a6:         }
1:d29ca2a:         longTermStore.start();
1:d29ca2a:     }
1:d29ca2a: 
1:f451ad0:     public void stop() throws Exception {
1:f451ad0:         longTermStore.stop();
1:6d8e2c5:         if (this.memoryUsage != null) {
1:6d8e2c5:             this.memoryUsage.removeUsageListener(peristenceAdapter);
1:ecf89a6:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the longTermStore.
1:d29ca2a:      */
1:d29ca2a:     public MessageStore getLongTermMessageStore() {
1:d29ca2a:         return longTermStore;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @see org.apache.activemq.store.MessageStore#removeAllMessages(ConnectionContext)
1:d29ca2a:      */
1:d29ca2a:     public void removeAllMessages(ConnectionContext context) throws IOException {
1:d29ca2a:         peristenceAdapter.checkpoint(true, true);
1:d29ca2a:         longTermStore.removeAllMessages(context);
1:d29ca2a:     }
1:f812e34: 
1:fc00993:     public void addMessageReference(ConnectionContext context, MessageId messageId, long expirationTime, String messageRef) throws IOException {
1:d29ca2a:         throw new IOException("The journal does not support message references.");
1:86cbdfd:     }
1:d29ca2a: 
1:d29ca2a:     public String getMessageReference(MessageId identity) throws IOException {
1:d29ca2a:         throw new IOException("The journal does not support message references.");
1:d29ca2a:     }
1:d29ca2a: 
1:629bc81:     /**
1:629bc81:      * @return
1:d29ca2a:      * @throws IOException
1:629bc81:      * @see org.apache.activemq.store.MessageStore#getMessageCount()
1:629bc81:      */
1:f812e34:     public int getMessageCount() throws IOException {
1:629bc81:         peristenceAdapter.checkpoint(true, true);
1:629bc81:         return longTermStore.getMessageCount();
1:d29ca2a:     }
1:d29ca2a: 
1:785b16b:     public long getMessageSize() throws IOException {
1:785b16b:         peristenceAdapter.checkpoint(true, true);
1:785b16b:         return longTermStore.getMessageSize();
1:785b16b:     }
1:785b16b: 
1:f812e34:     public void recoverNextMessages(int maxReturned, MessageRecoveryListener listener) throws Exception {
1:629bc81:         peristenceAdapter.checkpoint(true, true);
1:f812e34:         longTermStore.recoverNextMessages(maxReturned, listener);
1:f812e34: 
1:d29ca2a:     }
1:d29ca2a: 
1:f812e34:     public void resetBatching() {
1:629bc81:         longTermStore.resetBatching();
1:f812e34: 
1:f812e34:     }
1:d29ca2a: 
1:9bb4682:     @Override
1:2739333:     public void setBatch(MessageId messageId) throws Exception {
1:9bb4682:         peristenceAdapter.checkpoint(true, true);
1:9bb4682:         longTermStore.setBatch(messageId);
1:d29ca2a:     }
1:d29ca2a: 
1:9bb4682: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:785b16b
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:     public long getMessageSize() throws IOException {
1:         peristenceAdapter.checkpoint(true, true);
1:         return longTermStore.getMessageSize();
1:     }
1: 
author:gtully
-------------------------------------------------------------------------------
commit:e8f8155
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.IndexListener;
/////////////////////////////////////////////////////////////////////////
1:     public void addMessage(final ConnectionContext context, final Message message) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:             addMessage(context, message, location);
/////////////////////////////////////////////////////////////////////////
1:                         addMessage(context, message, location);
/////////////////////////////////////////////////////////////////////////
1:     void addMessage(ConnectionContext context, final Message message, final RecordLocation location) {
1:             message.getMessageId().setFutureOrSequenceLong(0l);
1:             if (indexListener != null) {
1:                 indexListener.onAdd(new IndexListener.MessageContext(context, message, null));
1:             }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:c5cf038
commit:9a8f6e4
/////////////////////////////////////////////////////////////////////////
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:2739333
/////////////////////////////////////////////////////////////////////////
1:     public void setBatch(MessageId messageId) throws Exception {
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("unchecked")
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(JournalMessageStore.class);
1:     protected RecordLocation lastLocation;
1:     protected Set<RecordLocation> inFlightTxLocations = new HashSet<RecordLocation>();
1:     private Map<MessageId, Message> messages = new LinkedHashMap<MessageId, Message>();
1:     private List<MessageAck> messageAcks = new ArrayList<MessageAck>();
1:     private Map<MessageId, Message> cpAddedMessageIds;
/////////////////////////////////////////////////////////////////////////
1:         final boolean debug = LOG.isDebugEnabled();
1:                 LOG.debug("Journalled message add for: " + id + ", at: " + location);
1:                 LOG.debug("Journalled transacted message add for: " + id + ", at: " + location);
/////////////////////////////////////////////////////////////////////////
1:                         LOG.debug("Transacted message add commit for: " + id + ", at: " + location);
/////////////////////////////////////////////////////////////////////////
1:                         LOG.debug("Transacted message add rollback for: " + id + ", at: " + location);
/////////////////////////////////////////////////////////////////////////
1:             LOG.warn("Could not replay add for message '" + message.getMessageId() + "'.  Message may have already been added. reason: " + e);
1:         final boolean debug = LOG.isDebugEnabled();
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Journalled message remove for: " + ack.getLastMessageId() + ", at: " + location);
1:                 LOG.debug("Journalled transacted message remove for: " + ack.getLastMessageId() + ", at: " + location);
/////////////////////////////////////////////////////////////////////////
1:                         LOG.debug("Transacted message remove commit for: " + ack.getLastMessageId() + ", at: " + location);
/////////////////////////////////////////////////////////////////////////
1:                     if (debug) {
1:                         LOG.debug("Transacted message remove rollback for: " + ack.getLastMessageId() + ", at: " + location);
1:                     }
/////////////////////////////////////////////////////////////////////////
1:             Message message = messages.remove(id);
/////////////////////////////////////////////////////////////////////////
1:             LOG.warn("Could not replay acknowledge for message '" + messageAck.getLastMessageId() + "'.  Message may have already been acknowledged. reason: " + e);
/////////////////////////////////////////////////////////////////////////
1:         final List<MessageAck> cpRemovedMessageLocations;
1:         final List<RecordLocation> cpActiveJournalLocations;
/////////////////////////////////////////////////////////////////////////
1:             cpActiveJournalLocations = new ArrayList<RecordLocation>(inFlightTxLocations);
1:             this.messages = new LinkedHashMap<MessageId, Message>();
1:             this.messageAcks = new ArrayList<MessageAck>();
/////////////////////////////////////////////////////////////////////////
1:                     Iterator<Message> iterator = cpAddedMessageIds.values().iterator();
1:                         Message message = iterator.next();
1:                             LOG.warn("Message could not be added to long term store: " + e.getMessage(), e);
/////////////////////////////////////////////////////////////////////////
1:                 Iterator<MessageAck> iterator = cpRemovedMessageLocations.iterator();
1:                         MessageAck ack = iterator.next();
1:                         LOG.debug("Message could not be removed from long term store: " + e.getMessage(), e);
/////////////////////////////////////////////////////////////////////////
1:             return cpActiveJournalLocations.get(0);
/////////////////////////////////////////////////////////////////////////
1:             answer = messages.get(identity);
1:             if (answer == null && cpAddedMessageIds != null) {
1:                 answer = cpAddedMessageIds.get(identity);
1:             }
/////////////////////////////////////////////////////////////////////////
0:         if (this.usageManager != null) {
1:         }
0:         if (this.usageManager != null) {
1:         }
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:     public JournalMessageStore(JournalPersistenceAdapter adapter, MessageStore checkpointStore, ActiveMQDestination destination) {
/////////////////////////////////////////////////////////////////////////
1:             if (debug) {
1:             }
1:             if (debug) {
1:             }
1:                     if (debug) {
1:                     }
/////////////////////////////////////////////////////////////////////////
1:                     if (debug) {
1:                     }
/////////////////////////////////////////////////////////////////////////
0:             log.warn("Could not replay add for message '" + message.getMessageId() + "'.  Message may have already been added. reason: " + e);
/////////////////////////////////////////////////////////////////////////
1:             if (debug) {
1:             }
1:             if (debug) {
1:             }
1:                     if (debug) {
1:                     }
/////////////////////////////////////////////////////////////////////////
0:             log.warn("Could not replay acknowledge for message '" + messageAck.getLastMessageId() + "'.  Message may have already been acknowledged. reason: " + e);
/////////////////////////////////////////////////////////////////////////
1:     public void addMessageReference(ConnectionContext context, MessageId messageId, long expirationTime, String messageRef) throws IOException {
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0:     public JournalMessageStore(JournalPersistenceAdapter adapter, MessageStore checkpointStore,
0:                                ActiveMQDestination destination) {
1: 
1: 
1: 
1: 
1:         if (!context.isInTransaction()) {
0:             if (debug)
0:                 log.debug("Journalled message add for: " + id + ", at: " + location);
0:             if (debug)
0:                 log.debug("Journalled transacted message add for: " + id + ", at: " + location);
1:             synchronized (this) {
1:             context.getTransaction().addSynchronization(new Synchronization() {
1:                 public void afterCommit() throws Exception {
0:                     if (debug)
0:                         log.debug("Transacted message add commit for: " + id + ", at: " + location);
1:                     synchronized (JournalMessageStore.this) {
1: 
1:                 public void afterRollback() throws Exception {
0:                     if (debug)
0:                         log.debug("Transacted message add rollback for: " + id + ", at: " + location);
1:                     synchronized (JournalMessageStore.this) {
/////////////////////////////////////////////////////////////////////////
1: 
1:             if (t == null) {
1:         } catch (Throwable e) {
0:             log.warn("Could not replay add for message '" + message.getMessageId()
0:                      + "'.  Message may have already been added. reason: " + e);
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (!context.isInTransaction()) {
0:             if (debug)
0:                 log.debug("Journalled message remove for: " + ack.getLastMessageId() + ", at: " + location);
0:             if (debug)
0:                 log.debug("Journalled transacted message remove for: " + ack.getLastMessageId() + ", at: "
0:                           + location);
1:             synchronized (this) {
1:             context.getTransaction().addSynchronization(new Synchronization() {
1:                 public void afterCommit() throws Exception {
0:                     if (debug)
0:                         log.debug("Transacted message remove commit for: " + ack.getLastMessageId()
0:                                   + ", at: " + location);
1:                     synchronized (JournalMessageStore.this) {
1: 
1:                 public void afterRollback() throws Exception {
0:                     if (debug)
0:                         log.debug("Transacted message remove rollback for: " + ack.getLastMessageId()
0:                                   + ", at: " + location);
1:                     synchronized (JournalMessageStore.this) {
/////////////////////////////////////////////////////////////////////////
1: 
0:             Message message = (Message)messages.remove(id);
/////////////////////////////////////////////////////////////////////////
1: 
1:             if (t != null) {
1:         } catch (Throwable e) {
0:             log.warn("Could not replay acknowledge for message '" + messageAck.getLastMessageId()
0:                      + "'.  Message may have already been acknowledged. reason: " + e);
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:             cpActiveJournalLocations = new ArrayList(inFlightTxLocations);
1: 
0:             this.messageAcks = new ArrayList();
1: 
1: 
1:                 synchronized (JournalMessageStore.this) {
0:                     Iterator iterator = cpAddedMessageIds.values().iterator();
1:                     while (iterator.hasNext()) {
0:                         Message message = (Message)iterator.next();
1:                         try {
1:                             longTermStore.addMessage(context, message);
1:                         } catch (Throwable e) {
0:                             log.warn("Message could not be added to long term store: " + e.getMessage(), e);
1:                         size += message.getSize();
1:                         if (size >= maxCheckpointMessageAddSize) {
1:                             size = 0;
/////////////////////////////////////////////////////////////////////////
0:                         MessageAck ack = (MessageAck)iterator.next();
1: 
1:                 if (postCheckpointTest != null) {
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (cpActiveJournalLocations.size() > 0) {
0:             return (RecordLocation)cpActiveJournalLocations.get(0);
1:         synchronized (this) {
/////////////////////////////////////////////////////////////////////////
0:             answer = (Message)messages.get(identity);
0:             if (answer == null && cpAddedMessageIds != null)
0:                 answer = (Message)cpAddedMessageIds.get(identity);
1: 
1:         if (answer != null) {
1: 
/////////////////////////////////////////////////////////////////////////
1:      * @throws Exception
/////////////////////////////////////////////////////////////////////////
0:         if (this.usageManager != null)
0:         if (this.usageManager != null)
/////////////////////////////////////////////////////////////////////////
1: 
0:     public void addMessageReference(ConnectionContext context, MessageId messageId, long expirationTime,
0:                                     String messageRef) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:      * @throws IOException
1:     public int getMessageCount() throws IOException {
1:     public void recoverNextMessages(int maxReturned, MessageRecoveryListener listener) throws Exception {
1:         longTermStore.recoverNextMessages(maxReturned, listener);
1: 
1:     public void resetBatching() {
1: 
1: }
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
1: }
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:18d616c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.memory.UsageManager;
/////////////////////////////////////////////////////////////////////////
1: 
0:     private UsageManager usageManager;
/////////////////////////////////////////////////////////////////////////
1:     
0:     public void setUsageManager(UsageManager usageManager) {
0:         this.usageManager = usageManager;
0:         longTermStore.setUsageManager(usageManager);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         if( this.usageManager != null )
0:             this.usageManager.addUsageListener(peristenceAdapter);
0:         if( this.usageManager != null )
0:             this.usageManager.removeUsageListener(peristenceAdapter);
commit:f451ad0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activeio.journal.RecordLocation;
/////////////////////////////////////////////////////////////////////////
1:     public void start() throws Exception {
1:     public void stop() throws Exception {
1:         longTermStore.stop();
commit:7f5213b
/////////////////////////////////////////////////////////////////////////
0:                 public void afterCommit() throws Exception {                    
/////////////////////////////////////////////////////////////////////////
0:                 public void afterRollback() throws Exception {                    
/////////////////////////////////////////////////////////////////////////
0:                 public void afterCommit() throws Exception {                    
/////////////////////////////////////////////////////////////////////////
0:                 public void afterRollback() throws Exception {                    
/////////////////////////////////////////////////////////////////////////
1:             public void execute() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:      * @throws Exception 
1:     public void recover(final MessageRecoveryListener listener) throws Exception {
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.store.journal;
1: 
1: import java.io.IOException;
1: import java.util.ArrayList;
1: import java.util.Collections;
1: import java.util.HashSet;
1: import java.util.Iterator;
1: import java.util.LinkedHashMap;
1: 
0: import org.activeio.journal.RecordLocation;
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.JournalQueueAck;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.store.MessageRecoveryListener;
1: import org.apache.activemq.store.MessageStore;
1: import org.apache.activemq.store.PersistenceAdapter;
1: import org.apache.activemq.transaction.Synchronization;
1: import org.apache.activemq.util.Callback;
1: import org.apache.activemq.util.TransactionTemplate;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
1: /**
1:  * A MessageStore that uses a Journal to store it's messages.
1:  * 
0:  * @version $Revision: 1.14 $
1:  */
0: public class JournalMessageStore implements MessageStore {
1: 
0:     private static final Log log = LogFactory.getLog(JournalMessageStore.class);
1: 
1:     protected final JournalPersistenceAdapter peristenceAdapter;
1:     protected final JournalTransactionStore transactionStore;
1:     protected final MessageStore longTermStore;
0:     protected final ActiveMQDestination destination;
1:     protected final TransactionTemplate transactionTemplate;
1: 
0:     private LinkedHashMap messages = new LinkedHashMap();
0:     private ArrayList messageAcks = new ArrayList();
1: 
1:     /** A MessageStore that we can use to retrieve messages quickly. */
0:     private LinkedHashMap cpAddedMessageIds;
1:     
0:     protected RecordLocation lastLocation;
0:     protected HashSet inFlightTxLocations = new HashSet();
1:     
0:     public JournalMessageStore(JournalPersistenceAdapter adapter, MessageStore checkpointStore, ActiveMQDestination destination) {
1:         this.peristenceAdapter = adapter;
1:         this.transactionStore = adapter.getTransactionStore();
1:         this.longTermStore = checkpointStore;
0:         this.destination = destination;
0:         this.transactionTemplate = new TransactionTemplate(adapter, new ConnectionContext());
1:     }
1: 
1:     /**
1:      * Not synchronized since the Journal has better throughput if you increase
1:      * the number of concurrent writes that it is doing.
1:      */
0:     public void addMessage(ConnectionContext context, final Message message) throws IOException {
1:         
1:         final MessageId id = message.getMessageId();
1:         
0:         final boolean debug = log.isDebugEnabled();
1:         message.incrementReferenceCount();
1:         
1:         final RecordLocation location = peristenceAdapter.writeCommand(message, message.isResponseRequired());
0:         if( !context.isInTransaction() ) {
0:             if( debug )
0:                 log.debug("Journalled message add for: "+id+", at: "+location);
0:             addMessage(message, location);
1:         } else {
0:             if( debug )
0:                 log.debug("Journalled transacted message add for: "+id+", at: "+location);
0:             synchronized( this ) {
1:                 inFlightTxLocations.add(location);
1:             }
1:             transactionStore.addMessage(this, message, location);
0:             context.getTransaction().addSynchronization(new Synchronization(){
0:                 public void afterCommit() {                    
0:                     if( debug )
0:                         log.debug("Transacted message add commit for: "+id+", at: "+location);
0:                     synchronized( JournalMessageStore.this ) {
1:                         inFlightTxLocations.remove(location);
0:                         addMessage(message, location);
1:                     }
1:                 }
0:                 public void afterRollback() {                    
0:                     if( debug )
0:                         log.debug("Transacted message add rollback for: "+id+", at: "+location);
0:                     synchronized( JournalMessageStore.this ) {
1:                         inFlightTxLocations.remove(location);
1:                     }
1:                     message.decrementReferenceCount();
1:                 }
1:             });
1:         }
1:     }
1: 
0:     private void addMessage(final Message message, final RecordLocation location) {
1:         synchronized (this) {
1:             lastLocation = location;
1:             MessageId id = message.getMessageId();
1:             messages.put(id, message);
1:         }
1:     }
1:     
1:     public void replayAddMessage(ConnectionContext context, Message message) {
1:         try {
1:             // Only add the message if it has not already been added.
1:             Message t = longTermStore.getMessage(message.getMessageId());
0:             if( t==null ) {
1:                 longTermStore.addMessage(context, message);
1:             }
1:         }
0:         catch (Throwable e) {
0:             log.warn("Could not replay add for message '" + message.getMessageId() + "'.  Message may have already been added. reason: " + e);
1:         }
1:     }
1: 
1:     /**
1:      */
1:     public void removeMessage(ConnectionContext context, final MessageAck ack) throws IOException {
0:         final boolean debug = log.isDebugEnabled();
1:         JournalQueueAck remove = new JournalQueueAck();
1:         remove.setDestination(destination);
1:         remove.setMessageAck(ack);
1:         
1:         final RecordLocation location = peristenceAdapter.writeCommand(remove, ack.isResponseRequired());
0:         if( !context.isInTransaction() ) {
0:             if( debug )
0:                 log.debug("Journalled message remove for: "+ack.getLastMessageId()+", at: "+location);
1:             removeMessage(ack, location);
1:         } else {
0:             if( debug )
0:                 log.debug("Journalled transacted message remove for: "+ack.getLastMessageId()+", at: "+location);
0:             synchronized( this ) {
1:                 inFlightTxLocations.add(location);
1:             }
1:             transactionStore.removeMessage(this, ack, location);
0:             context.getTransaction().addSynchronization(new Synchronization(){
0:                 public void afterCommit() {                    
0:                     if( debug )
0:                         log.debug("Transacted message remove commit for: "+ack.getLastMessageId()+", at: "+location);
0:                     synchronized( JournalMessageStore.this ) {
1:                         inFlightTxLocations.remove(location);
1:                         removeMessage(ack, location);
1:                     }
1:                 }
0:                 public void afterRollback() {                    
0:                     if( debug )
0:                         log.debug("Transacted message remove rollback for: "+ack.getLastMessageId()+", at: "+location);
0:                     synchronized( JournalMessageStore.this ) {
1:                         inFlightTxLocations.remove(location);
1:                     }
1:                 }
1:             });
1: 
1:         }
1:     }
1:     
0:     private void removeMessage(final MessageAck ack, final RecordLocation location) {
1:         synchronized (this) {
1:             lastLocation = location;
1:             MessageId id = ack.getLastMessageId();
0:             Message message = (Message) messages.remove(id);
1:             if (message == null) {
1:                 messageAcks.add(ack);
1:             } else {
1:                 message.decrementReferenceCount();
1:             }
1:         }
1:     }
1:     
1:     public void replayRemoveMessage(ConnectionContext context, MessageAck messageAck) {
1:         try {
1:             // Only remove the message if it has not already been removed.
1:             Message t = longTermStore.getMessage(messageAck.getLastMessageId());
0:             if( t!=null ) {
1:                 longTermStore.removeMessage(context, messageAck);
1:             }
1:         }
0:         catch (Throwable e) {
0:             log.warn("Could not replay acknowledge for message '" + messageAck.getLastMessageId() + "'.  Message may have already been acknowledged. reason: " + e);
1:         }
1:     }
1: 
1:     /**
1:      * @return
1:      * @throws IOException
1:      */
1:     public RecordLocation checkpoint() throws IOException {
1:         return checkpoint(null);
1:     }
1:     
1:     /**
1:      * @return
1:      * @throws IOException
1:      */
1:     public RecordLocation checkpoint(final Callback postCheckpointTest) throws IOException {
1: 
1:         
0:         RecordLocation rc;
0:         final ArrayList cpRemovedMessageLocations;
0:         final ArrayList cpActiveJournalLocations;
1:         final int maxCheckpointMessageAddSize = peristenceAdapter.getMaxCheckpointMessageAddSize();
1: 
1:         // swap out the message hash maps..
1:         synchronized (this) {
1:             cpAddedMessageIds = this.messages;
1:             cpRemovedMessageLocations = this.messageAcks;
1: 
0:             cpActiveJournalLocations=new ArrayList(inFlightTxLocations);
1:             
0:             this.messages = new LinkedHashMap();
0:             this.messageAcks = new ArrayList();            
1:         }
1: 
1:         transactionTemplate.run(new Callback() {
0:             public void execute() throws Throwable {
1: 
1:                 int size = 0;
1:                 
1:                 PersistenceAdapter persitanceAdapter = transactionTemplate.getPersistenceAdapter();
1:                 ConnectionContext context = transactionTemplate.getContext();
1:                 
1:                 // Checkpoint the added messages.
0:                 Iterator iterator = cpAddedMessageIds.values().iterator();
1:                 while (iterator.hasNext()) {
0:                     Message message = (Message) iterator.next();
1:                     try {
1:                         longTermStore.addMessage(context, message);
1:                     } catch (Throwable e) {
0:                         log.warn("Message could not be added to long term store: " + e.getMessage(), e);
1:                     }
1:                     
0:                     size += message.getSize();
1:                     
0:                     iterator.remove();
1:                     message.decrementReferenceCount();
1:                     
1:                     // Commit the batch if it's getting too big
0:                     if( size >= maxCheckpointMessageAddSize ) {
1:                         persitanceAdapter.commitTransaction(context);
1:                         persitanceAdapter.beginTransaction(context);
0:                         size=0;
1:                     }
1:                     
1:                 }
1: 
1:                 persitanceAdapter.commitTransaction(context);
1:                 persitanceAdapter.beginTransaction(context);
1: 
1:                 // Checkpoint the removed messages.
0:                 iterator = cpRemovedMessageLocations.iterator();
1:                 while (iterator.hasNext()) {
1:                     try {
0:                         MessageAck ack = (MessageAck) iterator.next();
1:                         longTermStore.removeMessage(transactionTemplate.getContext(), ack);
1:                     } catch (Throwable e) {
0:                         log.debug("Message could not be removed from long term store: " + e.getMessage(), e);
1:                     }
1:                 }
1:                 
0:                 if( postCheckpointTest!= null ) {
1:                     postCheckpointTest.execute();
1:                 }
1:             }
1: 
1:         });
1: 
1:         synchronized (this) {
1:             cpAddedMessageIds = null;
1:         }
1:         
0:         if( cpActiveJournalLocations.size() > 0 ) {
1:             Collections.sort(cpActiveJournalLocations);
0:             return (RecordLocation) cpActiveJournalLocations.get(0);
1:         } else {
1:             return lastLocation;
1:         }
1:     }
1: 
1:     /**
1:      * 
1:      */
1:     public Message getMessage(MessageId identity) throws IOException {
1:         Message answer = null;
1: 
1:         synchronized (this) {
1:             // Do we have a still have it in the journal?
0:             answer = (Message) messages.get(identity);
0:             if( answer==null && cpAddedMessageIds!=null )
0:                 answer = (Message) cpAddedMessageIds.get(identity);
1:         }
1:         
0:         if (answer != null ) {
1:             return answer;
1:         }
1:         
1:         // If all else fails try the long term message store.
1:         return longTermStore.getMessage(identity);
1:     }
1: 
1:     /**
1:      * Replays the checkpointStore first as those messages are the oldest ones,
1:      * then messages are replayed from the transaction log and then the cache is
1:      * updated.
1:      * 
1:      * @param listener
0:      * @throws Throwable 
1:      */
0:     public void recover(final MessageRecoveryListener listener) throws Throwable {
1:         peristenceAdapter.checkpoint(true, true);
1:         longTermStore.recover(listener);
1:     }
1: 
0:     public void start() throws IOException {
1:         longTermStore.start();
1:     }
1: 
0:     public void stop(long timeout) throws IOException {
0:         longTermStore.stop(timeout);
1:     }
1: 
1:     /**
1:      * @return Returns the longTermStore.
1:      */
1:     public MessageStore getLongTermMessageStore() {
1:         return longTermStore;
1:     }
1: 
1:     /**
1:      * @see org.apache.activemq.store.MessageStore#removeAllMessages(ConnectionContext)
1:      */
1:     public void removeAllMessages(ConnectionContext context) throws IOException {
1:         peristenceAdapter.checkpoint(true, true);
1:         longTermStore.removeAllMessages(context);
1:     }
1:     
0:     public ActiveMQDestination getDestination() {
0:         return destination;
1:     }
1: 
0:     public void addMessageReference(ConnectionContext context, MessageId messageId, long expirationTime, String messageRef) throws IOException {
1:         throw new IOException("The journal does not support message references.");
1:     }
1: 
1:     public String getMessageReference(MessageId identity) throws IOException {
1:         throw new IOException("The journal does not support message references.");
1:     }
1: 
1: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(JournalMessageStore.class);
author:Gary Tully
-------------------------------------------------------------------------------
commit:9bb4682
/////////////////////////////////////////////////////////////////////////
1:     @Override
0:     public void setBatch(MessageId messageId) {
1:         peristenceAdapter.checkpoint(true, true);
1:         longTermStore.setBatch(messageId);
1:     }
0: 
author:Robert Davies
-------------------------------------------------------------------------------
commit:63e3f41
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.AbstractMessageStore;
/////////////////////////////////////////////////////////////////////////
1: public class JournalMessageStore extends AbstractMessageStore {
/////////////////////////////////////////////////////////////////////////
1:         super(destination);
/////////////////////////////////////////////////////////////////////////
commit:3b0afd6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.filter.NonCachedMessageEvaluationContext;
/////////////////////////////////////////////////////////////////////////
1:         this.transactionTemplate = new TransactionTemplate(adapter, new ConnectionContext(new NonCachedMessageEvaluationContext()));
commit:6d8e2c5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.MemoryUsage;
0: import org.apache.activemq.usage.SystemUsage;
/////////////////////////////////////////////////////////////////////////
1:     private MemoryUsage memoryUsage;
/////////////////////////////////////////////////////////////////////////
0:     
1:     public void setMemoryUsage(MemoryUsage memoryUsage) {
1:         this.memoryUsage=memoryUsage;
1:         longTermStore.setMemoryUsage(memoryUsage);
/////////////////////////////////////////////////////////////////////////
1:         if (this.memoryUsage != null) {
1:             this.memoryUsage.addUsageListener(peristenceAdapter);
1:         if (this.memoryUsage != null) {
1:             this.memoryUsage.removeUsageListener(peristenceAdapter);
commit:a3e3821
/////////////////////////////////////////////////////////////////////////
0:     void addMessage(final Message message, final RecordLocation location) {
/////////////////////////////////////////////////////////////////////////
1:     final void removeMessage(final MessageAck ack, final RecordLocation location) {
/////////////////////////////////////////////////////////////////////////
0:                 synchronized(JournalMessageStore.this){
0:                     Iterator iterator=cpAddedMessageIds.values().iterator();
0:                     while(iterator.hasNext()){
0:                         Message message=(Message)iterator.next();
0:                         try{
0:                             longTermStore.addMessage(context,message);
0:                         }catch(Throwable e){
0:                             log.warn("Message could not be added to long term store: "+e.getMessage(),e);
0:                         }
0:                         size+=message.getSize();
0:                         message.decrementReferenceCount();
0:                         // Commit the batch if it's getting too big
0:                         if(size>=maxCheckpointMessageAddSize){
0:                             persitanceAdapter.commitTransaction(context);
0:                             persitanceAdapter.beginTransaction(context);
0:                             size=0;
0:                         }
0:                 Iterator iterator = cpRemovedMessageLocations.iterator();
/////////////////////////////////////////////////////////////////////////
0:         }
0:         synchronized (this){
commit:629bc81
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @return
0:      * @throws IOException 
1:      * @see org.apache.activemq.store.MessageStore#getMessageCount()
1:      */
0:     public int getMessageCount() throws IOException{
1:         peristenceAdapter.checkpoint(true, true);
1:         return longTermStore.getMessageCount();
0:     }
0: 
0:    
0:     public void recoverNextMessages(int maxReturned,MessageRecoveryListener listener) throws Exception{
1:         peristenceAdapter.checkpoint(true, true);
0:         longTermStore.recoverNextMessages(maxReturned,listener);
0:         
0:     }
0: 
0:     
0:     public void resetBatching(){
1:         longTermStore.resetBatching();
0:         
0:     }
0: 
0: }
author:James Strachan
-------------------------------------------------------------------------------
commit:72555fe
/////////////////////////////////////////////////////////////////////////
============================================================================