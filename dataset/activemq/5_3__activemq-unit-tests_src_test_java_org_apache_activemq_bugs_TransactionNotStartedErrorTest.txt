1:6f69f19: /**
1:6f69f19:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:6f69f19:  * contributor license agreements.  See the NOTICE file distributed with
1:6f69f19:  * this work for additional information regarding copyright ownership.
1:6f69f19:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:6f69f19:  * (the "License"); you may not use this file except in compliance with
1:6f69f19:  * the License.  You may obtain a copy of the License at
1:6f69f19:  *
1:6f69f19:  *      http://www.apache.org/licenses/LICENSE-2.0
1:6f69f19:  *
1:6f69f19:  * Unless required by applicable law or agreed to in writing, software
1:6f69f19:  * distributed under the License is distributed on an "AS IS" BASIS,
1:6f69f19:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:6f69f19:  * See the License for the specific language governing permissions and
1:6f69f19:  * limitations under the License.
1:6f69f19:  */
1:6f69f19: package org.apache.activemq.bugs;
5:6f69f19: 
1:6f69f19: import javax.jms.Connection;
1:6f69f19: import javax.jms.JMSException;
1:6f69f19: import javax.jms.Message;
1:6f69f19: import javax.jms.MessageConsumer;
1:6f69f19: import javax.jms.MessageListener;
1:6f69f19: import javax.jms.ObjectMessage;
1:6f69f19: import javax.jms.Session;
1:6f69f19: 
1:6f69f19: import junit.framework.TestCase;
1:6f69f19: import org.apache.activemq.ActiveMQConnectionFactory;
1:6f69f19: import org.apache.activemq.broker.BrokerService;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:6f69f19: 
1:6f69f19: /*
1:6f69f19:  * simulate message flow which cause the following exception in the broker
1:6f69f19:  * (exception logged by client) <p/> 2007-07-24 13:51:23,624
1:6f69f19:  * com.easynet.halo.Halo ERROR (LoggingErrorHandler.java: 23) JMS failure
1:6f69f19:  * javax.jms.JMSException: Transaction 'TX:ID:dmt-53625-1185281414694-1:0:344'
1:6f69f19:  * has not been started. at
1:6f69f19:  * org.apache.activemq.broker.TransactionBroker.getTransaction(TransactionBroker.java:230)
1:6f69f19:  * This appears to be consistent in a MacBook. Haven't been able to replicate it
1:6f69f19:  * on Windows though
1:6f69f19:  */
1:6f69f19: public class TransactionNotStartedErrorTest extends TestCase {
1:6f69f19: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(TransactionNotStartedErrorTest.class);
1:42e51a3: 
1:42e51a3:     private static final int counter = 500;
1:6f69f19: 
1:6f69f19:     private static int hectorToHaloCtr;
1:6f69f19:     private static int xenaToHaloCtr;
1:6f69f19:     private static int troyToHaloCtr;
1:6f69f19: 
1:6f69f19:     private static int haloToHectorCtr;
1:6f69f19:     private static int haloToXenaCtr;
1:6f69f19:     private static int haloToTroyCtr;
1:6f69f19: 
1:42e51a3:     private final String hectorToHalo = "hectorToHalo";
1:42e51a3:     private final String xenaToHalo = "xenaToHalo";
1:42e51a3:     private final String troyToHalo = "troyToHalo";
1:6f69f19: 
1:42e51a3:     private final String haloToHector = "haloToHector";
1:42e51a3:     private final String haloToXena = "haloToXena";
1:42e51a3:     private final String haloToTroy = "haloToTroy";
1:6f69f19: 
1:6f69f19:     private BrokerService broker;
1:6f69f19: 
1:6f69f19:     private Connection hectorConnection;
1:6f69f19:     private Connection xenaConnection;
1:6f69f19:     private Connection troyConnection;
1:6f69f19:     private Connection haloConnection;
1:6f69f19: 
1:6f69f19:     private final Object lock = new Object();
1:6f69f19: 
1:42e51a3:     public Connection createConnection() throws Exception {
1:42e51a3:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(
1:42e51a3:             broker.getTransportConnectors().get(0).getPublishableConnectString());
1:6f69f19:         return factory.createConnection();
1:6f69f19:     }
1:6f69f19: 
1:6f69f19:     public Session createSession(Connection connection, boolean transacted) throws JMSException {
1:6f69f19:         return connection.createSession(transacted, Session.AUTO_ACKNOWLEDGE);
1:6f69f19:     }
1:6f69f19: 
1:6f69f19:     public void startBroker() throws Exception {
1:6f69f19:         broker = new BrokerService();
1:6f69f19:         broker.setDeleteAllMessagesOnStartup(true);
1:6f69f19:         broker.setPersistent(true);
1:6f69f19:         broker.setUseJmx(true);
1:42e51a3:         broker.addConnector("tcp://localhost:0").setName("Default");
1:6f69f19:         broker.start();
1:6f69f19:         LOG.info("Starting broker..");
1:6f69f19:     }
1:6f69f19: 
1:6f69f19:     public void tearDown() throws Exception {
1:6f69f19:         hectorConnection.close();
1:6f69f19:         xenaConnection.close();
1:6f69f19:         troyConnection.close();
1:6f69f19:         haloConnection.close();
1:6f69f19:         broker.stop();
1:6f69f19:     }
1:6f69f19: 
1:6f69f19:     public void testTransactionNotStartedError() throws Exception {
1:6f69f19:         startBroker();
1:6f69f19:         hectorConnection = createConnection();
1:6f69f19:         Thread hectorThread = buildProducer(hectorConnection, hectorToHalo);
1:6f69f19:         Receiver hHectorReceiver = new Receiver() {
1:6f69f19:             public void receive(String s) throws Exception {
1:6f69f19:                 haloToHectorCtr++;
1:6f69f19:                 if (haloToHectorCtr >= counter) {
1:6f69f19:                     synchronized (lock) {
1:6f69f19:                         lock.notifyAll();
1:6f69f19:                     }
1:6f69f19:                 }
1:6f69f19:             }
1:6f69f19:         };
1:6f69f19:         buildReceiver(hectorConnection, haloToHector, false, hHectorReceiver);
1:6f69f19: 
1:6f69f19:         troyConnection = createConnection();
1:6f69f19:         Thread troyThread = buildProducer(troyConnection, troyToHalo);
1:6f69f19:         Receiver hTroyReceiver = new Receiver() {
1:6f69f19:             public void receive(String s) throws Exception {
1:6f69f19:                 haloToTroyCtr++;
1:6f69f19:                 if (haloToTroyCtr >= counter) {
1:6f69f19:                     synchronized (lock) {
1:6f69f19:                         lock.notifyAll();
1:6f69f19:                     }
1:6f69f19:                 }
1:6f69f19:             }
1:6f69f19:         };
1:6f69f19:         buildReceiver(hectorConnection, haloToTroy, false, hTroyReceiver);
1:6f69f19: 
1:6f69f19:         xenaConnection = createConnection();
1:6f69f19:         Thread xenaThread = buildProducer(xenaConnection, xenaToHalo);
1:6f69f19:         Receiver hXenaReceiver = new Receiver() {
1:6f69f19:             public void receive(String s) throws Exception {
1:6f69f19:                 haloToXenaCtr++;
1:6f69f19:                 if (haloToXenaCtr >= counter) {
1:6f69f19:                     synchronized (lock) {
1:6f69f19:                         lock.notifyAll();
1:6f69f19:                     }
1:6f69f19:                 }
1:6f69f19:             }
1:6f69f19:         };
1:6f69f19:         buildReceiver(xenaConnection, haloToXena, false, hXenaReceiver);
1:6f69f19: 
1:6f69f19:         haloConnection = createConnection();
1:6f69f19:         final MessageSender hectorSender = buildTransactionalProducer(haloToHector, haloConnection);
1:6f69f19:         final MessageSender troySender = buildTransactionalProducer(haloToTroy, haloConnection);
1:6f69f19:         final MessageSender xenaSender = buildTransactionalProducer(haloToXena, haloConnection);
1:6f69f19:         Receiver hectorReceiver = new Receiver() {
1:6f69f19:             public void receive(String s) throws Exception {
1:6f69f19:                 hectorToHaloCtr++;
1:6f69f19:                 troySender.send("halo to troy because of hector");
1:6f69f19:                 if (hectorToHaloCtr >= counter) {
1:6f69f19:                     synchronized (lock) {
1:6f69f19:                         lock.notifyAll();
1:6f69f19:                     }
1:6f69f19:                 }
1:6f69f19:             }
1:6f69f19:         };
1:6f69f19:         Receiver xenaReceiver = new Receiver() {
1:6f69f19:             public void receive(String s) throws Exception {
1:6f69f19:                 xenaToHaloCtr++;
1:6f69f19:                 hectorSender.send("halo to hector because of xena");
1:6f69f19:                 if (xenaToHaloCtr >= counter) {
1:6f69f19:                     synchronized (lock) {
1:6f69f19:                         lock.notifyAll();
1:6f69f19:                     }
1:6f69f19:                 }
1:6f69f19:             }
1:6f69f19:         };
1:6f69f19:         Receiver troyReceiver = new Receiver() {
1:6f69f19:             public void receive(String s) throws Exception {
1:6f69f19:                 troyToHaloCtr++;
1:6f69f19:                 xenaSender.send("halo to xena because of troy");
1:6f69f19:                 if (troyToHaloCtr >= counter) {
1:6f69f19:                     synchronized (lock) {
1:6f69f19:                         lock.notifyAll();
1:6f69f19:                     }
1:6f69f19:                 }
1:6f69f19:             }
1:6f69f19:         };
1:6f69f19:         buildReceiver(haloConnection, hectorToHalo, true, hectorReceiver);
1:6f69f19:         buildReceiver(haloConnection, xenaToHalo, true, xenaReceiver);
1:6f69f19:         buildReceiver(haloConnection, troyToHalo, true, troyReceiver);
1:6f69f19: 
1:6f69f19:         haloConnection.start();
1:6f69f19: 
1:6f69f19:         troyConnection.start();
1:6f69f19:         troyThread.start();
1:6f69f19: 
1:6f69f19:         xenaConnection.start();
1:6f69f19:         xenaThread.start();
1:6f69f19: 
1:6f69f19:         hectorConnection.start();
1:6f69f19:         hectorThread.start();
1:6f69f19:         waitForMessagesToBeDelivered();
1:6f69f19:         // number of messages received should match messages sent
1:6f69f19:         assertEquals(hectorToHaloCtr, counter);
1:6f69f19:         LOG.info("hectorToHalo received " + hectorToHaloCtr + " messages");
1:6f69f19:         assertEquals(xenaToHaloCtr, counter);
1:6f69f19:         LOG.info("xenaToHalo received " + xenaToHaloCtr + " messages");
1:6f69f19:         assertEquals(troyToHaloCtr, counter);
1:6f69f19:         LOG.info("troyToHalo received " + troyToHaloCtr + " messages");
1:6f69f19:         assertEquals(haloToHectorCtr, counter);
1:6f69f19:         LOG.info("haloToHector received " + haloToHectorCtr + " messages");
1:6f69f19:         assertEquals(haloToXenaCtr, counter);
1:6f69f19:         LOG.info("haloToXena received " + haloToXenaCtr + " messages");
1:6f69f19:         assertEquals(haloToTroyCtr, counter);
1:6f69f19:         LOG.info("haloToTroy received " + haloToTroyCtr + " messages");
1:6f69f19: 
1:6f69f19:     }
1:6f69f19: 
1:6f69f19:     protected void waitForMessagesToBeDelivered() {
1:6f69f19:         // let's give the listeners enough time to read all messages
1:6f69f19:         long maxWaitTime = counter * 3000;
1:6f69f19:         long waitTime = maxWaitTime;
1:6f69f19:         long start = (maxWaitTime <= 0) ? 0 : System.currentTimeMillis();
1:6f69f19: 
1:6f69f19:         synchronized (lock) {
1:6f69f19:             boolean hasMessages = true;
1:6f69f19:             while (hasMessages && waitTime >= 0) {
1:6f69f19:                 try {
1:6f69f19:                     lock.wait(200);
1:6f69f19:                 } catch (InterruptedException e) {
1:8bf987b:                     LOG.error(e.toString());
1:6f69f19:                 }
1:6f69f19:                 // check if all messages have been received
1:6f69f19:                 hasMessages = hectorToHaloCtr < counter || xenaToHaloCtr < counter || troyToHaloCtr < counter || haloToHectorCtr < counter || haloToXenaCtr < counter
1:6f69f19:                               || haloToTroyCtr < counter;
1:6f69f19:                 waitTime = maxWaitTime - (System.currentTimeMillis() - start);
1:6f69f19:             }
1:6f69f19:         }
1:6f69f19:     }
1:6f69f19: 
1:6f69f19:     public MessageSender buildTransactionalProducer(String queueName, Connection connection) throws Exception {
1:6f69f19:         return new MessageSender(queueName, connection, true, false);
1:6f69f19:     }
1:6f69f19: 
1:6f69f19:     public Thread buildProducer(Connection connection, final String queueName) throws Exception {
1:6f69f19:         final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:6f69f19:         final MessageSender producer = new MessageSender(queueName, connection, false, false);
1:6f69f19:         Thread thread = new Thread() {
1:6f69f19: 
1:6f69f19:             public synchronized void run() {
1:6f69f19:                 for (int i = 0; i < counter; i++) {
1:6f69f19:                     try {
1:6f69f19:                         producer.send(queueName);
1:6f69f19:                         if (session.getTransacted()) {
1:6f69f19:                             session.commit();
1:6f69f19:                         }
1:6f69f19: 
1:6f69f19:                     } catch (Exception e) {
1:6f69f19:                         throw new RuntimeException("on " + queueName + " send", e);
1:6f69f19:                     }
1:6f69f19:                 }
1:6f69f19:             }
1:6f69f19:         };
1:6f69f19:         return thread;
1:6f69f19:     }
1:6f69f19: 
1:6f69f19:     public void buildReceiver(Connection connection, final String queueName, boolean transacted, final Receiver receiver) throws Exception {
1:6f69f19:         final Session session = transacted ? connection.createSession(true, Session.SESSION_TRANSACTED) : connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:6f69f19:         MessageConsumer inputMessageConsumer = session.createConsumer(session.createQueue(queueName));
1:6f69f19:         MessageListener messageListener = new MessageListener() {
1:6f69f19: 
1:6f69f19:             public void onMessage(Message message) {
1:6f69f19:                 try {
1:6f69f19:                     ObjectMessage objectMessage = (ObjectMessage)message;
1:6f69f19:                     String s = (String)objectMessage.getObject();
1:6f69f19:                     receiver.receive(s);
1:6f69f19:                     if (session.getTransacted()) {
1:6f69f19:                         session.commit();
1:6f69f19:                     }
1:6f69f19: 
1:6f69f19:                 } catch (Exception e) {
1:6f69f19:                     e.printStackTrace();
1:6f69f19:                 }
1:6f69f19:             }
1:6f69f19:         };
1:6f69f19:         inputMessageConsumer.setMessageListener(messageListener);
1:6f69f19:     }
1:6f69f19: 
1:6f69f19: }
============================================================================
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
commit:42e51a3
/////////////////////////////////////////////////////////////////////////
1: 
1:     private static final int counter = 500;
/////////////////////////////////////////////////////////////////////////
1:     private final String hectorToHalo = "hectorToHalo";
1:     private final String xenaToHalo = "xenaToHalo";
1:     private final String troyToHalo = "troyToHalo";
1:     private final String haloToHector = "haloToHector";
1:     private final String haloToXena = "haloToXena";
1:     private final String haloToTroy = "haloToTroy";
/////////////////////////////////////////////////////////////////////////
1:     public Connection createConnection() throws Exception {
1:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(
1:             broker.getTransportConnectors().get(0).getPublishableConnectString());
/////////////////////////////////////////////////////////////////////////
1:         broker.addConnector("tcp://localhost:0").setName("Default");
/////////////////////////////////////////////////////////////////////////
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(TransactionNotStartedErrorTest.class);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.error(e.toString());
author:Robert Davies
-------------------------------------------------------------------------------
commit:6f69f19
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.bugs;
1: 
1: import javax.jms.Connection;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageListener;
1: import javax.jms.ObjectMessage;
1: import javax.jms.Session;
1: 
1: import junit.framework.TestCase;
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.broker.BrokerService;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
1: /*
1:  * simulate message flow which cause the following exception in the broker
1:  * (exception logged by client) <p/> 2007-07-24 13:51:23,624
1:  * com.easynet.halo.Halo ERROR (LoggingErrorHandler.java: 23) JMS failure
1:  * javax.jms.JMSException: Transaction 'TX:ID:dmt-53625-1185281414694-1:0:344'
1:  * has not been started. at
1:  * org.apache.activemq.broker.TransactionBroker.getTransaction(TransactionBroker.java:230)
1:  * This appears to be consistent in a MacBook. Haven't been able to replicate it
1:  * on Windows though
1:  */
1: public class TransactionNotStartedErrorTest extends TestCase {
1: 
0:     private static final Log LOG = LogFactory.getLog(TransactionNotStartedErrorTest.class);
1:     
0:     private static int counter = 500;
1: 
1:     private static int hectorToHaloCtr;
1:     private static int xenaToHaloCtr;
1:     private static int troyToHaloCtr;
1: 
1:     private static int haloToHectorCtr;
1:     private static int haloToXenaCtr;
1:     private static int haloToTroyCtr;
1: 
0:     private String hectorToHalo = "hectorToHalo";
0:     private String xenaToHalo = "xenaToHalo";
0:     private String troyToHalo = "troyToHalo";
1: 
0:     private String haloToHector = "haloToHector";
0:     private String haloToXena = "haloToXena";
0:     private String haloToTroy = "haloToTroy";
1: 
1: 
1:     private BrokerService broker;
1: 
1:     private Connection hectorConnection;
1:     private Connection xenaConnection;
1:     private Connection troyConnection;
1:     private Connection haloConnection;
1: 
1:     private final Object lock = new Object();
1: 
0:     public Connection createConnection() throws JMSException {
0:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616");
1:         return factory.createConnection();
1:     }
1: 
1:     public Session createSession(Connection connection, boolean transacted) throws JMSException {
1:         return connection.createSession(transacted, Session.AUTO_ACKNOWLEDGE);
1:     }
1: 
1:     public void startBroker() throws Exception {
1:         broker = new BrokerService();
1:         broker.setDeleteAllMessagesOnStartup(true);
1:         broker.setPersistent(true);
1:         broker.setUseJmx(true);
0:         broker.addConnector("tcp://localhost:61616").setName("Default");
1:         broker.start();
1:         LOG.info("Starting broker..");
1:     }
1: 
1:     public void tearDown() throws Exception {
1:         hectorConnection.close();
1:         xenaConnection.close();
1:         troyConnection.close();
1:         haloConnection.close();
1:         broker.stop();
1:     }
1: 
1:     public void testTransactionNotStartedError() throws Exception {
1:         startBroker();
1:         hectorConnection = createConnection();
1:         Thread hectorThread = buildProducer(hectorConnection, hectorToHalo);
1:         Receiver hHectorReceiver = new Receiver() {
1:             public void receive(String s) throws Exception {
1:                 haloToHectorCtr++;
1:                 if (haloToHectorCtr >= counter) {
1:                     synchronized (lock) {
1:                         lock.notifyAll();
1:                     }
1:                 }
1:             }
1:         };
1:         buildReceiver(hectorConnection, haloToHector, false, hHectorReceiver);
1: 
1:         troyConnection = createConnection();
1:         Thread troyThread = buildProducer(troyConnection, troyToHalo);
1:         Receiver hTroyReceiver = new Receiver() {
1:             public void receive(String s) throws Exception {
1:                 haloToTroyCtr++;
1:                 if (haloToTroyCtr >= counter) {
1:                     synchronized (lock) {
1:                         lock.notifyAll();
1:                     }
1:                 }
1:             }
1:         };
1:         buildReceiver(hectorConnection, haloToTroy, false, hTroyReceiver);
1: 
1:         xenaConnection = createConnection();
1:         Thread xenaThread = buildProducer(xenaConnection, xenaToHalo);
1:         Receiver hXenaReceiver = new Receiver() {
1:             public void receive(String s) throws Exception {
1:                 haloToXenaCtr++;
1:                 if (haloToXenaCtr >= counter) {
1:                     synchronized (lock) {
1:                         lock.notifyAll();
1:                     }
1:                 }
1:             }
1:         };
1:         buildReceiver(xenaConnection, haloToXena, false, hXenaReceiver);
1: 
1:         haloConnection = createConnection();
1:         final MessageSender hectorSender = buildTransactionalProducer(haloToHector, haloConnection);
1:         final MessageSender troySender = buildTransactionalProducer(haloToTroy, haloConnection);
1:         final MessageSender xenaSender = buildTransactionalProducer(haloToXena, haloConnection);
1:         Receiver hectorReceiver = new Receiver() {
1:             public void receive(String s) throws Exception {
1:                 hectorToHaloCtr++;
1:                 troySender.send("halo to troy because of hector");
1:                 if (hectorToHaloCtr >= counter) {
1:                     synchronized (lock) {
1:                         lock.notifyAll();
1:                     }
1:                 }
1:             }
1:         };
1:         Receiver xenaReceiver = new Receiver() {
1:             public void receive(String s) throws Exception {
1:                 xenaToHaloCtr++;
1:                 hectorSender.send("halo to hector because of xena");
1:                 if (xenaToHaloCtr >= counter) {
1:                     synchronized (lock) {
1:                         lock.notifyAll();
1:                     }
1:                 }
1:             }
1:         };
1:         Receiver troyReceiver = new Receiver() {
1:             public void receive(String s) throws Exception {
1:                 troyToHaloCtr++;
1:                 xenaSender.send("halo to xena because of troy");
1:                 if (troyToHaloCtr >= counter) {
1:                     synchronized (lock) {
1:                         lock.notifyAll();
1:                     }
1:                 }
1:             }
1:         };
1:         buildReceiver(haloConnection, hectorToHalo, true, hectorReceiver);
1:         buildReceiver(haloConnection, xenaToHalo, true, xenaReceiver);
1:         buildReceiver(haloConnection, troyToHalo, true, troyReceiver);
1: 
1:         haloConnection.start();
1: 
1:         troyConnection.start();
1:         troyThread.start();
1: 
1:         xenaConnection.start();
1:         xenaThread.start();
1: 
1:         hectorConnection.start();
1:         hectorThread.start();
1:         waitForMessagesToBeDelivered();
1:         // number of messages received should match messages sent
1:         assertEquals(hectorToHaloCtr, counter);
1:         LOG.info("hectorToHalo received " + hectorToHaloCtr + " messages");
1:         assertEquals(xenaToHaloCtr, counter);
1:         LOG.info("xenaToHalo received " + xenaToHaloCtr + " messages");
1:         assertEquals(troyToHaloCtr, counter);
1:         LOG.info("troyToHalo received " + troyToHaloCtr + " messages");
1:         assertEquals(haloToHectorCtr, counter);
1:         LOG.info("haloToHector received " + haloToHectorCtr + " messages");
1:         assertEquals(haloToXenaCtr, counter);
1:         LOG.info("haloToXena received " + haloToXenaCtr + " messages");
1:         assertEquals(haloToTroyCtr, counter);
1:         LOG.info("haloToTroy received " + haloToTroyCtr + " messages");
1: 
1:     }
1: 
1:     protected void waitForMessagesToBeDelivered() {
1:         // let's give the listeners enough time to read all messages
1:         long maxWaitTime = counter * 3000;
1:         long waitTime = maxWaitTime;
1:         long start = (maxWaitTime <= 0) ? 0 : System.currentTimeMillis();
1: 
1:         synchronized (lock) {
1:             boolean hasMessages = true;
1:             while (hasMessages && waitTime >= 0) {
1:                 try {
1:                     lock.wait(200);
1:                 } catch (InterruptedException e) {
0:                     LOG.error(e);
1:                 }
1:                 // check if all messages have been received
1:                 hasMessages = hectorToHaloCtr < counter || xenaToHaloCtr < counter || troyToHaloCtr < counter || haloToHectorCtr < counter || haloToXenaCtr < counter
1:                               || haloToTroyCtr < counter;
1:                 waitTime = maxWaitTime - (System.currentTimeMillis() - start);
1:             }
1:         }
1:     }
1: 
1:     public MessageSender buildTransactionalProducer(String queueName, Connection connection) throws Exception {
1: 
1:         return new MessageSender(queueName, connection, true, false);
1:     }
1: 
1:     public Thread buildProducer(Connection connection, final String queueName) throws Exception {
1: 
1:         final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         final MessageSender producer = new MessageSender(queueName, connection, false, false);
1:         Thread thread = new Thread() {
1: 
1:             public synchronized void run() {
1:                 for (int i = 0; i < counter; i++) {
1:                     try {
1:                         producer.send(queueName);
1:                         if (session.getTransacted()) {
1:                             session.commit();
1:                         }
1: 
1:                     } catch (Exception e) {
1:                         throw new RuntimeException("on " + queueName + " send", e);
1:                     }
1:                 }
1:             }
1:         };
1:         return thread;
1:     }
1: 
1:     public void buildReceiver(Connection connection, final String queueName, boolean transacted, final Receiver receiver) throws Exception {
1:         final Session session = transacted ? connection.createSession(true, Session.SESSION_TRANSACTED) : connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageConsumer inputMessageConsumer = session.createConsumer(session.createQueue(queueName));
1:         MessageListener messageListener = new MessageListener() {
1: 
1:             public void onMessage(Message message) {
1:                 try {
1:                     ObjectMessage objectMessage = (ObjectMessage)message;
1:                     String s = (String)objectMessage.getObject();
1:                     receiver.receive(s);
1:                     if (session.getTransacted()) {
1:                         session.commit();
1:                     }
1: 
1:                 } catch (Exception e) {
1:                     e.printStackTrace();
1:                 }
1:             }
1:         };
1:         inputMessageConsumer.setMessageListener(messageListener);
1:     }
1: 
1: }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
0: import junit.framework.TestCase;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0:  * simulate message flow which cause the following exception in the broker
0:  * (exception logged by client) <p/> 2007-07-24 13:51:23,624
0:  * com.easynet.halo.Halo ERROR (LoggingErrorHandler.java: 23) JMS failure
0:  * javax.jms.JMSException: Transaction 'TX:ID:dmt-53625-1185281414694-1:0:344'
0:  * has not been started. at
0:  * org.apache.activemq.broker.TransactionBroker.getTransaction(TransactionBroker.java:230)
0:  * This appears to be consistent in a MacBook. Haven't been able to replicate it
0:  * on Windows though
0:     private static final Log LOG = LogFactory.getLog(TransactionNotStartedErrorTest.class);
0:     
0:     private static int counter = 500;
0:     private static int hectorToHaloCtr;
0:     private static int xenaToHaloCtr;
0:     private static int troyToHaloCtr;
0:     private static int haloToHectorCtr;
0:     private static int haloToXenaCtr;
0:     private static int haloToTroyCtr;
0:     private String hectorToHalo = "hectorToHalo";
0:     private String xenaToHalo = "xenaToHalo";
0:     private String troyToHalo = "troyToHalo";
0:     private String haloToHector = "haloToHector";
0:     private String haloToXena = "haloToXena";
0:     private String haloToTroy = "haloToTroy";
0:     private BrokerService broker;
0:     private Connection hectorConnection;
0:     private Connection xenaConnection;
0:     private Connection troyConnection;
0:     private Connection haloConnection;
0:     private final Object lock = new Object();
0:     public Connection createConnection() throws JMSException {
0:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616");
0:         return factory.createConnection();
0:     }
0:     public Session createSession(Connection connection, boolean transacted) throws JMSException {
0:         return connection.createSession(transacted, Session.AUTO_ACKNOWLEDGE);
0:     }
0:     public void startBroker() throws Exception {
0:         broker = new BrokerService();
0:         broker.setDeleteAllMessagesOnStartup(true);
0:         broker.setPersistent(true);
0:         broker.setUseJmx(true);
0:         broker.addConnector("tcp://localhost:61616").setName("Default");
0:         broker.start();
0:         LOG.info("Starting broker..");
0:     }
0:     public void tearDown() throws Exception {
0:         hectorConnection.close();
0:         xenaConnection.close();
0:         troyConnection.close();
0:         haloConnection.close();
0:         broker.stop();
0:     }
0:     public void testTransactionNotStartedError() throws Exception {
0:         startBroker();
0:         hectorConnection = createConnection();
0:         Thread hectorThread = buildProducer(hectorConnection, hectorToHalo);
0:         Receiver hHectorReceiver = new Receiver() {
0:             public void receive(String s) throws Exception {
0:                 haloToHectorCtr++;
0:                 if (haloToHectorCtr >= counter) {
0:                     synchronized (lock) {
0:                         lock.notifyAll();
0:                     }
0:                 }
0:             }
0:         };
0:         buildReceiver(hectorConnection, haloToHector, false, hHectorReceiver);
0:         troyConnection = createConnection();
0:         Thread troyThread = buildProducer(troyConnection, troyToHalo);
0:         Receiver hTroyReceiver = new Receiver() {
0:             public void receive(String s) throws Exception {
0:                 haloToTroyCtr++;
0:                 if (haloToTroyCtr >= counter) {
0:                     synchronized (lock) {
0:                         lock.notifyAll();
0:                     }
0:                 }
0:             }
0:         };
0:         buildReceiver(hectorConnection, haloToTroy, false, hTroyReceiver);
0:         xenaConnection = createConnection();
0:         Thread xenaThread = buildProducer(xenaConnection, xenaToHalo);
0:         Receiver hXenaReceiver = new Receiver() {
0:             public void receive(String s) throws Exception {
0:                 haloToXenaCtr++;
0:                 if (haloToXenaCtr >= counter) {
0:                     synchronized (lock) {
0:                         lock.notifyAll();
0:                     }
0:                 }
0:             }
0:         };
0:         buildReceiver(xenaConnection, haloToXena, false, hXenaReceiver);
0:         haloConnection = createConnection();
0:         final MessageSender hectorSender = buildTransactionalProducer(haloToHector, haloConnection);
0:         final MessageSender troySender = buildTransactionalProducer(haloToTroy, haloConnection);
0:         final MessageSender xenaSender = buildTransactionalProducer(haloToXena, haloConnection);
0:         Receiver hectorReceiver = new Receiver() {
0:             public void receive(String s) throws Exception {
0:                 hectorToHaloCtr++;
0:                 troySender.send("halo to troy because of hector");
0:                 if (hectorToHaloCtr >= counter) {
0:                     synchronized (lock) {
0:                         lock.notifyAll();
0:                     }
0:                 }
0:             }
0:         };
0:         Receiver xenaReceiver = new Receiver() {
0:             public void receive(String s) throws Exception {
0:                 xenaToHaloCtr++;
0:                 hectorSender.send("halo to hector because of xena");
0:                 if (xenaToHaloCtr >= counter) {
0:                     synchronized (lock) {
0:                         lock.notifyAll();
0:                     }
0:                 }
0:             }
0:         };
0:         Receiver troyReceiver = new Receiver() {
0:             public void receive(String s) throws Exception {
0:                 troyToHaloCtr++;
0:                 xenaSender.send("halo to xena because of troy");
0:                 if (troyToHaloCtr >= counter) {
0:                     synchronized (lock) {
0:                         lock.notifyAll();
0:                     }
0:                 }
0:             }
0:         };
0:         buildReceiver(haloConnection, hectorToHalo, true, hectorReceiver);
0:         buildReceiver(haloConnection, xenaToHalo, true, xenaReceiver);
0:         buildReceiver(haloConnection, troyToHalo, true, troyReceiver);
0:         haloConnection.start();
0:         troyConnection.start();
0:         troyThread.start();
0:         xenaConnection.start();
0:         xenaThread.start();
0:         hectorConnection.start();
0:         hectorThread.start();
0:         waitForMessagesToBeDelivered();
0:         // number of messages received should match messages sent
0:         assertEquals(hectorToHaloCtr, counter);
0:         LOG.info("hectorToHalo received " + hectorToHaloCtr + " messages");
0:         assertEquals(xenaToHaloCtr, counter);
0:         LOG.info("xenaToHalo received " + xenaToHaloCtr + " messages");
0:         assertEquals(troyToHaloCtr, counter);
0:         LOG.info("troyToHalo received " + troyToHaloCtr + " messages");
0:         assertEquals(haloToHectorCtr, counter);
0:         LOG.info("haloToHector received " + haloToHectorCtr + " messages");
0:         assertEquals(haloToXenaCtr, counter);
0:         LOG.info("haloToXena received " + haloToXenaCtr + " messages");
0:         assertEquals(haloToTroyCtr, counter);
0:         LOG.info("haloToTroy received " + haloToTroyCtr + " messages");
0:     }
0:     protected void waitForMessagesToBeDelivered() {
0:         // let's give the listeners enough time to read all messages
0:         long maxWaitTime = counter * 3000;
0:         long waitTime = maxWaitTime;
0:         long start = (maxWaitTime <= 0) ? 0 : System.currentTimeMillis();
0:         synchronized (lock) {
0:             boolean hasMessages = true;
0:             while (hasMessages && waitTime >= 0) {
0:                 try {
0:                     lock.wait(200);
0:                 } catch (InterruptedException e) {
0:                     LOG.error(e);
0:                 }
0:                 // check if all messages have been received
0:                 hasMessages = hectorToHaloCtr < counter || xenaToHaloCtr < counter || troyToHaloCtr < counter || haloToHectorCtr < counter || haloToXenaCtr < counter
0:                               || haloToTroyCtr < counter;
0:                 waitTime = maxWaitTime - (System.currentTimeMillis() - start);
0:             }
0:         }
0:     }
0:     public MessageSender buildTransactionalProducer(String queueName, Connection connection) throws Exception {
0:         return new MessageSender(queueName, connection, true);
0:     }
0:     public Thread buildProducer(Connection connection, final String queueName) throws Exception {
0:         final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         final MessageSender producer = new MessageSender(queueName, connection, false);
0:         Thread thread = new Thread() {
0:             public synchronized void run() {
0:                 for (int i = 0; i < counter; i++) {
0:                     try {
0:                         producer.send(queueName);
0:                         if (session.getTransacted()) {
0:                             session.commit();
0:                         }
0:                     } catch (Exception e) {
0:                         throw new RuntimeException("on " + queueName + " send", e);
0:                     }
0:                 }
0:             }
0:         };
0:         return thread;
0:     }
0:     public void buildReceiver(Connection connection, final String queueName, boolean transacted, final Receiver receiver) throws Exception {
0:         final Session session = transacted ? connection.createSession(true, Session.SESSION_TRANSACTED) : connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer inputMessageConsumer = session.createConsumer(session.createQueue(queueName));
0:         MessageListener messageListener = new MessageListener() {
0:             public void onMessage(Message message) {
0:                 try {
0:                     ObjectMessage objectMessage = (ObjectMessage)message;
0:                     String s = (String)objectMessage.getObject();
0:                     receiver.receive(s);
0:                     if (session.getTransacted()) {
0:                         session.commit();
0:                     }
0: 
0:                 } catch (Exception e) {
0:                     e.printStackTrace();
0:                 }
0:             }
0:         };
0:         inputMessageConsumer.setMessageListener(messageListener);
0:     }
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:1963ea4
/////////////////////////////////////////////////////////////////////////
0: /**
0:  *
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
0:  * contributor license agreements.  See the NOTICE file distributed with
0:  * this work for additional information regarding copyright ownership.
0:  * The ASF licenses this file to You under the Apache License, Version 2.0
0:  * (the "License"); you may not use this file except in compliance with
0:  * the License.  You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: package org.apache.activemq.bugs;
0: 
0: import javax.jms.Connection;
0: import javax.jms.JMSException;
0: import javax.jms.Message;
0: import javax.jms.MessageConsumer;
0: import javax.jms.MessageListener;
0: 
0: import javax.jms.ObjectMessage;
0: import javax.jms.Session;
0: import junit.framework.TestCase;
0: 
0: import org.apache.activemq.ActiveMQConnectionFactory;
0: import org.apache.activemq.broker.BrokerService;
0: import org.apache.activemq.bugs.Receiver;
0: import org.apache.activemq.bugs.MessageSender;
0: 
0: /*
0:  * simulate message flow which  cause the following exception
0:  * in the broker (exception logged by client)
0:  * <p/>
0:  * 2007-07-24 13:51:23,624 com.easynet.halo.Halo ERROR (LoggingErrorHandler.java: 23) JMS failure
0:  * javax.jms.JMSException: Transaction 'TX:ID:dmt-53625-1185281414694-1:0:344' has not been started.
0:  * at org.apache.activemq.broker.TransactionBroker.getTransaction(TransactionBroker.java:230)
0:  * 
0:  * 
0:  * This appears to be consistent in a MacBook. Haven't been able to replicate it on Windows though
0:  */
0: public class TransactionNotStartedErrorTest extends TestCase {
0: 
0: 	private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory
0: 			.getLog(TransactionNotStartedErrorTest.class);
0: 	private String hectorToHalo = "hectorToHalo";
0: 	private String xenaToHalo = "xenaToHalo";
0: 	private String troyToHalo = "troyToHalo";
0: 
0: 	private String haloToHector = "haloToHector";
0: 	private String haloToXena = "haloToXena";
0: 	private String haloToTroy = "haloToTroy";
0: 
0: 	private static int counter = 500;
0: 
0: 	private static int hectorToHaloCtr = 0;
0: 	private static int xenaToHaloCtr = 0;
0: 	private static int troyToHaloCtr = 0;
0: 
0: 	private static int haloToHectorCtr = 0;
0: 	private static int haloToXenaCtr = 0;
0: 	private static int haloToTroyCtr = 0;
0: 
0: 	private BrokerService broker;
0: 
0: 	private Connection hectorConnection;
0: 	private Connection xenaConnection;
0: 	private Connection troyConnection;
0: 	private Connection haloConnection;
0: 
0: 	private final Object lock = new Object();
0: 
0: 	public Connection createConnection() throws JMSException {
0: 		ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(
0: 				"tcp://localhost:61616");
0: 		return factory.createConnection();
0: 	}
0: 
0: 	public Session createSession(Connection connection, boolean transacted)
0: 			throws JMSException {
0: 		return connection.createSession(transacted, Session.AUTO_ACKNOWLEDGE);
0: 	}
0: 
0: 	public void startBroker() throws Exception {
0: 		broker = new BrokerService();
0: 		broker.setDeleteAllMessagesOnStartup(true);
0: 		broker.setPersistent(true);
0: 		broker.setUseJmx(true);
0: 		broker.addConnector("tcp://localhost:61616").setName("Default");
0: 		broker.start();
0: 		log.info("Starting broker..");
0: 	}
0: 
0: 	public void tearDown() throws Exception {
0: 		hectorConnection.close();
0: 		xenaConnection.close();
0: 		troyConnection.close();
0: 		haloConnection.close();
0: 		broker.stop();
0: 	}
0: 
0: 	public void testTransactionNotStartedError() throws Exception {
0: 		startBroker();
0: 		hectorConnection = createConnection();
0: 		Thread hectorThread = buildProducer(hectorConnection, hectorToHalo);
0: 		Receiver hHectorReceiver = new Receiver() {
0: 			public void receive(String s) throws Exception {
0: 				haloToHectorCtr++;
0: 				if (haloToHectorCtr >= counter) {
0: 					synchronized (lock) {
0: 						lock.notifyAll();
0: 					}
0: 				}
0: 			}
0: 		};
0: 		buildReceiver(hectorConnection, haloToHector, false, hHectorReceiver);
0: 
0: 		troyConnection = createConnection();
0: 		Thread troyThread = buildProducer(troyConnection, troyToHalo);
0: 		Receiver hTroyReceiver = new Receiver() {
0: 			public void receive(String s) throws Exception {
0: 				haloToTroyCtr++;
0: 				if (haloToTroyCtr >= counter) {
0: 					synchronized (lock) {
0: 						lock.notifyAll();
0: 					}
0: 				}
0: 			}
0: 		};
0: 		buildReceiver(hectorConnection, haloToTroy, false, hTroyReceiver);
0: 
0: 		xenaConnection = createConnection();
0: 		Thread xenaThread = buildProducer(xenaConnection, xenaToHalo);
0: 		Receiver hXenaReceiver = new Receiver() {
0: 			public void receive(String s) throws Exception {
0: 				haloToXenaCtr++;
0: 				if (haloToXenaCtr >= counter) {
0: 					synchronized (lock) {
0: 						lock.notifyAll();
0: 					}
0: 				}
0: 			}
0: 		};
0: 		buildReceiver(xenaConnection, haloToXena, false, hXenaReceiver);
0: 
0: 		haloConnection = createConnection();
0: 		final MessageSender hectorSender = buildTransactionalProducer(
0: 				haloToHector, haloConnection);
0: 		final MessageSender troySender = buildTransactionalProducer(haloToTroy,
0: 				haloConnection);
0: 		final MessageSender xenaSender = buildTransactionalProducer(haloToXena,
0: 				haloConnection);
0: 		Receiver hectorReceiver = new Receiver() {
0: 			public void receive(String s) throws Exception {
0: 				hectorToHaloCtr++;
0: 				troySender.send("halo to troy because of hector");
0: 				if (hectorToHaloCtr >= counter) {
0: 					synchronized (lock) {
0: 						lock.notifyAll();
0: 					}
0: 				}
0: 			}
0: 		};
0: 		Receiver xenaReceiver = new Receiver() {
0: 			public void receive(String s) throws Exception {
0: 				xenaToHaloCtr++;
0: 				hectorSender.send("halo to hector because of xena");
0: 				if (xenaToHaloCtr >= counter) {
0: 					synchronized (lock) {
0: 						lock.notifyAll();
0: 					}
0: 				}
0: 			}
0: 		};
0: 		Receiver troyReceiver = new Receiver() {
0: 			public void receive(String s) throws Exception {
0: 				troyToHaloCtr++;
0: 				xenaSender.send("halo to xena because of troy");
0: 				if (troyToHaloCtr >= counter) {
0: 					synchronized (lock) {
0: 						lock.notifyAll();
0: 					}
0: 				}
0: 			}
0: 		};
0: 		buildReceiver(haloConnection, hectorToHalo, true, hectorReceiver);
0: 		buildReceiver(haloConnection, xenaToHalo, true, xenaReceiver);
0: 		buildReceiver(haloConnection, troyToHalo, true, troyReceiver);
0: 
0: 		haloConnection.start();
0: 
0: 		troyConnection.start();
0: 		troyThread.start();
0: 
0: 		xenaConnection.start();
0: 		xenaThread.start();
0: 
0: 		hectorConnection.start();
0: 		hectorThread.start();
0: 		waitForMessagesToBeDelivered();
0: 		//number of messages received should match messages sent
0: 		assertEquals(hectorToHaloCtr, counter);
0: 		log.info("hectorToHalo received " + hectorToHaloCtr + " messages");
0: 		assertEquals(xenaToHaloCtr, counter);
0: 		log.info("xenaToHalo received " + xenaToHaloCtr + " messages");
0: 		assertEquals(troyToHaloCtr, counter);
0: 		log.info("troyToHalo received " + troyToHaloCtr + " messages");
0: 		assertEquals(haloToHectorCtr, counter);
0: 		log.info("haloToHector received " + haloToHectorCtr + " messages");
0: 		assertEquals(haloToXenaCtr, counter);
0: 		log.info("haloToXena received " + haloToXenaCtr + " messages");
0: 		assertEquals(haloToTroyCtr, counter);
0: 		log.info("haloToTroy received " + haloToTroyCtr + " messages");
0: 
0: 	}
0: 
0: 	protected void waitForMessagesToBeDelivered() {
0: 		// let's give the listeners enough time to read all messages
0: 		long maxWaitTime = counter * 3000;
0: 		long waitTime = maxWaitTime;
0: 		long start = (maxWaitTime <= 0) ? 0 : System.currentTimeMillis();
0: 
0: 		synchronized (lock) {
0: 			boolean hasMessages = true;
0: 			while (hasMessages && waitTime >= 0) {
0: 				try {
0: 					lock.wait(200);
0: 				} catch (InterruptedException e) {
0: 					log.error(e);
0: 				}
0:                 //check if all messages have been received
0: 				hasMessages = hectorToHaloCtr < counter
0: 						|| xenaToHaloCtr < counter || troyToHaloCtr < counter || haloToHectorCtr < counter
0: 						|| haloToXenaCtr < counter || haloToTroyCtr < counter;
0: 				waitTime = maxWaitTime - (System.currentTimeMillis() - start);
0: 			}
0: 		}
0: 	}
0: 
0: 	public MessageSender buildTransactionalProducer(String queueName,
0: 			Connection connection) throws Exception {
0: 
0: 		return new MessageSender(queueName, connection, true);
0: 	}
0: 
0: 	public Thread buildProducer(Connection connection, final String queueName)
0: 			throws Exception {
0: 
0: 		final Session session = connection.createSession(false,
0: 				Session.AUTO_ACKNOWLEDGE);
0: 		final MessageSender producer = new MessageSender(queueName, connection,
0: 				false);
0: 		Thread thread = new Thread() {
0: 
0: 			public synchronized void run() {
0: 				for (int i = 0; i < counter; i++) {
0: 					try {
0: 						producer.send(queueName);
0: 						if (session.getTransacted()) {
0: 							session.commit();
0: 						}
0: 
0: 					} catch (Exception e) {
0: 						throw new RuntimeException("on " + queueName + " send",
0: 								e);
0: 					}
0: 				}
0: 			}
0: 		};
0: 		return thread;
0: 	}
0: 
0: 	public void buildReceiver(Connection connection, final String queueName,
0: 			boolean transacted, final Receiver receiver) throws Exception {
0: 		final Session session = transacted ? connection.createSession(true,
0: 				Session.SESSION_TRANSACTED) : connection.createSession(false,
0: 				Session.AUTO_ACKNOWLEDGE);
0: 		MessageConsumer inputMessageConsumer = session.createConsumer(session
0: 				.createQueue(queueName));
0: 		MessageListener messageListener = new MessageListener() {
0: 
0: 			public void onMessage(Message message) {
0: 				try {
0: 					ObjectMessage objectMessage = (ObjectMessage) message;
0: 					String s = (String) objectMessage.getObject();
0: 					receiver.receive(s);
0: 					if (session.getTransacted()) {
0: 						session.commit();
0: 					}
0: 
0: 				} catch (Exception e) {
0: 					e.printStackTrace();
0: 				}
0: 			}
0: 		};
0: 		inputMessageConsumer.setMessageListener(messageListener);
0: 	}
0: 
0: }
============================================================================