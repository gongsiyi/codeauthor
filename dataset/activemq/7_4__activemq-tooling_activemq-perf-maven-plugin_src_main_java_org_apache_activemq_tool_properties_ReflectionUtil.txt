1:a88906f: /**
1:7f883f6:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:7f883f6:  * contributor license agreements.  See the NOTICE file distributed with
1:7f883f6:  * this work for additional information regarding copyright ownership.
1:7f883f6:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:7f883f6:  * (the "License"); you may not use this file except in compliance with
1:7f883f6:  * the License.  You may obtain a copy of the License at
2:7f883f6:  *
1:5f1adbe:  *      http://www.apache.org/licenses/LICENSE-2.0
1:7f883f6:  *
1:a88906f:  * Unless required by applicable law or agreed to in writing, software
1:a88906f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a88906f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a88906f:  * See the License for the specific language governing permissions and
1:a88906f:  * limitations under the License.
1:a88906f:  */
1:a88906f: package org.apache.activemq.tool.properties;
3:a88906f: 
1:540dd5c: import java.lang.reflect.Constructor;
1:540dd5c: import java.lang.reflect.InvocationTargetException;
1:540dd5c: import java.lang.reflect.Method;
1:540dd5c: import java.util.ArrayList;
1:540dd5c: import java.util.Iterator;
1:540dd5c: import java.util.List;
1:540dd5c: import java.util.Properties;
1:540dd5c: import java.util.StringTokenizer;
1:540dd5c: 
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:a88906f: 
1:a88906f: public final class ReflectionUtil {
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(ReflectionUtil.class);
1:a88906f: 
1:a88906f:     private ReflectionUtil() {
1:a88906f:     }
1:a88906f: 
1:a88906f:     public static void configureClass(Object obj, String key, String val) {
1:a88906f:         try {
1:a88906f:             String debugInfo;
1:a88906f: 
1:a88906f:             Object target = obj;
1:e47e0e0:             Class<?> targetClass = obj.getClass();
1:a88906f: 
1:a88906f:             // DEBUG: Debugging Info
1:a88906f:             debugInfo = "Invoking: " + targetClass.getName();
1:a88906f: 
1:a88906f:             StringTokenizer tokenizer = new StringTokenizer(key, ".");
1:a88906f:             String keySubString = key;
1:a88906f:             int tokenCount = tokenizer.countTokens();
1:a88906f: 
1:540dd5c:             // For nested settings, get the object first. -1, do not count the
1:540dd5c:             // last token
1:540dd5c:             for (int j = 0; j < tokenCount - 1; j++) {
1:a88906f:                 // Find getter method first
1:a88906f:                 String name = tokenizer.nextToken();
1:a88906f: 
1:a88906f:                 // Check if the target object will accept the settings
1:a88906f:                 if (target instanceof ReflectionConfigurable && !((ReflectionConfigurable)target).acceptConfig(keySubString, val)) {
1:a88906f:                     return;
1:a88906f:                 } else {
1:540dd5c:                     // This will reduce the key, so that it will be recognize by
1:540dd5c:                     // the next object. i.e.
1:a88906f:                     // Property name: factory.prefetchPolicy.queuePrefetch
1:540dd5c:                     // Calling order:
1:540dd5c:                     // this.getFactory().prefetchPolicy().queuePrefetch();
1:540dd5c:                     // If factory does not accept the config, it should be given
1:540dd5c:                     // prefetchPolicy.queuePrefetch as the key
1:540dd5c:                     // +1 to account for the '.'
1:540dd5c:                     keySubString = keySubString.substring(name.length() + 1);
1:a88906f:                 }
1:a88906f: 
1:540dd5c:                 String getMethod = "get" + name.substring(0, 1).toUpperCase() + name.substring(1);
1:a88906f:                 Method method = targetClass.getMethod(getMethod, new Class[] {});
1:a88906f:                 target = method.invoke(target, null);
1:a88906f:                 targetClass = target.getClass();
1:a88906f: 
1:540dd5c:                 debugInfo += "." + getMethod + "()";
1:a88906f:             }
1:a88906f: 
1:a88906f:             // Property name
1:a88906f:             String property = tokenizer.nextToken();
1:a88906f:             // Check if the target object will accept the settings
1:a88906f:             if (target instanceof ReflectionConfigurable && !((ReflectionConfigurable)target).acceptConfig(property, val)) {
1:a88906f:                 return;
1:a88906f:             }
1:a88906f: 
1:a88906f:             // Find setter method
1:a88906f:             Method setterMethod = findSetterMethod(targetClass, property);
1:a88906f: 
1:540dd5c:             // Get the first parameter type. This assumes that there is only one
1:540dd5c:             // parameter.
1:a88906f:             if (setterMethod == null) {
1:a88906f:                 throw new IllegalAccessException("Unable to find appropriate setter method signature for property: " + property);
1:a88906f:             }
1:e47e0e0:             Class<?> paramType = setterMethod.getParameterTypes()[0];
1:a88906f: 
1:a88906f:             // Set primitive type
1:540dd5c:             debugInfo += "." + setterMethod + "(" + paramType.getName() + ": " + val + ")";
1:a88906f:             if (paramType.isPrimitive()) {
1:a88906f:                 if (paramType == Boolean.TYPE) {
1:540dd5c:                     setterMethod.invoke(target, new Object[] {
1:540dd5c:                         Boolean.valueOf(val)
1:540dd5c:                     });
1:a88906f:                 } else if (paramType == Integer.TYPE) {
1:540dd5c:                     setterMethod.invoke(target, new Object[] {
1:540dd5c:                         Integer.valueOf(val)
1:540dd5c:                     });
1:a88906f:                 } else if (paramType == Long.TYPE) {
1:540dd5c:                     setterMethod.invoke(target, new Object[] {
1:540dd5c:                         Long.valueOf(val)
1:540dd5c:                     });
1:a88906f:                 } else if (paramType == Double.TYPE) {
1:540dd5c:                     setterMethod.invoke(target, new Object[] {
1:540dd5c:                         Double.valueOf(val)
1:540dd5c:                     });
1:a88906f:                 } else if (paramType == Float.TYPE) {
1:540dd5c:                     setterMethod.invoke(target, new Object[] {
1:540dd5c:                         Float.valueOf(val)
1:540dd5c:                     });
1:a88906f:                 } else if (paramType == Short.TYPE) {
1:540dd5c:                     setterMethod.invoke(target, new Object[] {
1:540dd5c:                         Short.valueOf(val)
1:540dd5c:                     });
1:a88906f:                 } else if (paramType == Byte.TYPE) {
1:540dd5c:                     setterMethod.invoke(target, new Object[] {
1:540dd5c:                         Byte.valueOf(val)
1:540dd5c:                     });
1:a88906f:                 } else if (paramType == Character.TYPE) {
1:540dd5c:                     setterMethod.invoke(target, new Object[] {
1:540dd5c:                         new Character(val.charAt(0))
1:540dd5c:                     });
1:a88906f:                 }
1:a88906f:             } else {
1:a88906f:                 // Set String type
1:a88906f:                 if (paramType == String.class) {
1:540dd5c:                     setterMethod.invoke(target, new Object[] {
1:540dd5c:                         val
1:540dd5c:                     });
1:a88906f: 
1:540dd5c:                     // For unknown object type, try to create an instance of the
1:540dd5c:                     // object using a String constructor
1:a88906f:                 } else {
1:540dd5c:                     Constructor c = paramType.getConstructor(new Class[] {
1:540dd5c:                         String.class
1:540dd5c:                     });
1:540dd5c:                     Object paramObject = c.newInstance(new Object[] {
1:540dd5c:                         val
1:540dd5c:                     });
1:a88906f: 
1:540dd5c:                     setterMethod.invoke(target, new Object[] {
1:540dd5c:                         paramObject
1:540dd5c:                     });
1:a88906f:                 }
1:a88906f:             }
1:540dd5c:             LOG.debug(debugInfo);
1:a88906f: 
1:a88906f:         } catch (Exception e) {
1:8bf987b:             LOG.warn(e.toString());
1:a88906f:         }
1:a88906f:     }
1:a88906f: 
1:a88906f:     public static void configureClass(Object obj, Properties props) {
1:e47e0e0:         for (Iterator<Object> i = props.keySet().iterator(); i.hasNext();) {
1:a88906f:             try {
1:a88906f:                 String key = (String)i.next();
1:a88906f:                 String val = props.getProperty(key);
1:a88906f: 
1:a88906f:                 configureClass(obj, key, val);
1:a88906f:             } catch (Throwable t) {
1:540dd5c:                 // Let's catch any exception as this could be cause by the
1:540dd5c:                 // foreign class
1:a88906f:                 t.printStackTrace();
1:a88906f:             }
1:a88906f:         }
1:a88906f:     }
1:a88906f: 
1:a88906f:     public static Properties retrieveObjectProperties(Object obj) {
1:a88906f:         Properties props = new Properties();
1:a88906f:         try {
1:a88906f:             props.putAll(retrieveClassProperties("", obj.getClass(), obj));
1:a88906f:         } catch (Exception e) {
1:8bf987b:             LOG.warn(e.toString());
1:a88906f:         }
1:a88906f:         return props;
1:a88906f:     }
1:a88906f: 
1:a88906f:     protected static Properties retrieveClassProperties(String prefix, Class targetClass, Object targetObject) {
1:a88906f:         if (targetClass == null || targetObject == null) {
1:a88906f:             return new Properties();
1:a88906f:         } else {
1:a88906f:             Properties props = new Properties();
1:a88906f:             Method[] getterMethods = findAllGetterMethods(targetClass);
1:540dd5c:             for (int i = 0; i < getterMethods.length; i++) {
1:a88906f:                 try {
1:a88906f:                     String propertyName = getPropertyName(getterMethods[i].getName());
1:a88906f:                     Class retType = getterMethods[i].getReturnType();
1:a88906f: 
1:a88906f:                     // If primitive or string type, return it
1:a88906f:                     if (retType.isPrimitive() || retType == String.class) {
1:540dd5c:                         // Check for an appropriate setter method to consider it
1:540dd5c:                         // as a property
1:a88906f:                         if (findSetterMethod(targetClass, propertyName) != null) {
1:a88906f:                             Object val = null;
1:a88906f:                             try {
1:a88906f:                                 val = getterMethods[i].invoke(targetObject, null);
1:a88906f:                             } catch (InvocationTargetException e) {
1:a88906f:                                 e.printStackTrace();
1:a88906f:                             } catch (IllegalAccessException e) {
1:a88906f:                                 e.printStackTrace();
1:a88906f:                             }
1:a88906f:                             props.setProperty(prefix + propertyName, val + "");
1:a88906f:                         }
1:a88906f:                     } else {
1:a88906f:                         try {
1:a88906f:                             Object val = getterMethods[i].invoke(targetObject, null);
1:863f479:                             if (val != null && val != targetObject) {
1:a88906f:                                 props.putAll(retrieveClassProperties(propertyName + ".", val.getClass(), val));
1:a88906f:                             }
1:a88906f:                         } catch (InvocationTargetException e) {
1:a88906f:                             e.printStackTrace();
1:a88906f:                         } catch (IllegalAccessException e) {
1:a88906f:                             e.printStackTrace();
1:a88906f:                         }
1:a88906f:                     }
1:a88906f:                 } catch (Throwable t) {
1:540dd5c:                     // Let's catch any exception, cause this could be cause by
1:540dd5c:                     // the foreign class
1:a88906f:                     t.printStackTrace();
1:a88906f:                 }
1:a88906f:             }
1:a88906f:             return props;
1:a88906f:         }
1:a88906f:     }
1:a88906f: 
1:a88906f:     private static Method findSetterMethod(Class targetClass, String propertyName) {
1:540dd5c:         String methodName = "set" + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);
1:a88906f: 
1:a88906f:         Method[] methods = targetClass.getMethods();
1:540dd5c:         for (int i = 0; i < methods.length; i++) {
1:a88906f:             if (methods[i].getName().equals(methodName) && isSetterMethod(methods[i])) {
1:a88906f:                 return methods[i];
1:a88906f:             }
1:a88906f:         }
1:a88906f:         return null;
1:a88906f:     }
1:a88906f: 
1:a88906f:     private static Method findGetterMethod(Class targetClass, String propertyName) {
1:540dd5c:         String methodName1 = "get" + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);
1:540dd5c:         String methodName2 = "is" + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);
1:a88906f: 
1:a88906f:         Method[] methods = targetClass.getMethods();
1:540dd5c:         for (int i = 0; i < methods.length; i++) {
1:a88906f:             if ((methods[i].getName().equals(methodName1) || methods[i].getName().equals(methodName2)) && isGetterMethod(methods[i])) {
1:a88906f:                 return methods[i];
1:a88906f:             }
1:a88906f:         }
1:a88906f:         return null;
1:a88906f:     }
1:a88906f: 
1:a88906f:     private static Method[] findAllGetterMethods(Class targetClass) {
1:a88906f:         List getterMethods = new ArrayList();
1:a88906f:         Method[] methods = targetClass.getMethods();
1:a88906f: 
1:540dd5c:         for (int i = 0; i < methods.length; i++) {
1:a88906f:             if (isGetterMethod(methods[i])) {
1:a88906f:                 getterMethods.add(methods[i]);
1:a88906f:             }
1:a88906f:         }
1:a88906f: 
1:a88906f:         return (Method[])getterMethods.toArray(new Method[] {});
1:a88906f:     }
1:a88906f: 
1:a88906f:     private static boolean isGetterMethod(Method method) {
1:a88906f:         // Check method signature first
1:a88906f:         // If 'get' method, must return a non-void value
1:a88906f:         // If 'is' method, must return a boolean value
1:a88906f:         // Both must have no parameters
1:a88906f:         // Method must not belong to the Object class to prevent infinite loop
1:540dd5c:         return ((method.getName().startsWith("is") && method.getReturnType() == Boolean.TYPE) || (method.getName().startsWith("get") && method.getReturnType() != Void.TYPE))
1:540dd5c:                && (method.getParameterTypes().length == 0) && method.getDeclaringClass() != Object.class;
1:a88906f:     }
1:a88906f: 
1:a88906f:     private static boolean isSetterMethod(Method method) {
1:a88906f:         // Check method signature first
1:a88906f:         if (method.getName().startsWith("set") && method.getReturnType() == Void.TYPE) {
1:a88906f:             Class[] paramType = method.getParameterTypes();
1:a88906f:             // Check that it can only accept one parameter
1:a88906f:             if (paramType.length == 1) {
1:540dd5c:                 // Check if parameter is a primitive or can accept a String
1:540dd5c:                 // parameter
1:a88906f:                 if (paramType[0].isPrimitive() || paramType[0] == String.class) {
1:a88906f:                     return true;
1:a88906f:                 } else {
1:a88906f:                     // Check if object can accept a string as a constructor
1:a88906f:                     try {
1:540dd5c:                         if (paramType[0].getConstructor(new Class[] {
1:540dd5c:                             String.class
1:540dd5c:                         }) != null) {
1:a88906f:                             return true;
1:a88906f:                         }
1:a88906f:                     } catch (NoSuchMethodException e) {
1:a88906f:                         // Do nothing
1:a88906f:                     }
1:a88906f:                 }
1:a88906f:             }
1:a88906f:         }
1:a88906f:         return false;
1:a88906f:     }
1:a88906f: 
1:a88906f:     private static String getPropertyName(String methodName) {
1:a88906f:         String name;
1:a88906f:         if (methodName.startsWith("get")) {
1:a88906f:             name = methodName.substring(3);
1:a88906f:         } else if (methodName.startsWith("set")) {
1:a88906f:             name = methodName.substring(3);
1:a88906f:         } else if (methodName.startsWith("is")) {
1:a88906f:             name = methodName.substring(2);
1:a88906f:         } else {
1:a88906f:             name = "";
1:a88906f:         }
1:a88906f: 
1:540dd5c:         return name.substring(0, 1).toLowerCase() + name.substring(1);
1:a88906f:     }
1:a88906f: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:e47e0e0
/////////////////////////////////////////////////////////////////////////
1:             Class<?> targetClass = obj.getClass();
/////////////////////////////////////////////////////////////////////////
1:             Class<?> paramType = setterMethod.getParameterTypes()[0];
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<Object> i = props.keySet().iterator(); i.hasNext();) {
author:Christian Posta
-------------------------------------------------------------------------------
commit:863f479
/////////////////////////////////////////////////////////////////////////
1:                             if (val != null && val != targetObject) {
commit:9a2d3d8
/////////////////////////////////////////////////////////////////////////
0: //                            if (val != null && val != targetObject) {
0:                             if (val != null ) {
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:87e878b
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(ReflectionUtil.class);
/////////////////////////////////////////////////////////////////////////
1:             LOG.warn(e.toString());
/////////////////////////////////////////////////////////////////////////
1:             LOG.warn(e.toString());
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:540dd5c
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.Constructor;
1: import java.lang.reflect.InvocationTargetException;
1: import java.lang.reflect.Method;
1: import java.util.ArrayList;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Properties;
1: import java.util.StringTokenizer;
1: 
0:     private static final Log LOG = LogFactory.getLog(ReflectionUtil.class);
/////////////////////////////////////////////////////////////////////////
0:             Class targetClass = obj.getClass();
/////////////////////////////////////////////////////////////////////////
1:             // For nested settings, get the object first. -1, do not count the
1:             // last token
1:             for (int j = 0; j < tokenCount - 1; j++) {
/////////////////////////////////////////////////////////////////////////
1:                     // This will reduce the key, so that it will be recognize by
1:                     // the next object. i.e.
1:                     // Calling order:
1:                     // this.getFactory().prefetchPolicy().queuePrefetch();
1:                     // If factory does not accept the config, it should be given
1:                     // prefetchPolicy.queuePrefetch as the key
1:                     // +1 to account for the '.'
1:                     keySubString = keySubString.substring(name.length() + 1);
1:                 String getMethod = "get" + name.substring(0, 1).toUpperCase() + name.substring(1);
1:                 debugInfo += "." + getMethod + "()";
/////////////////////////////////////////////////////////////////////////
1:             // Get the first parameter type. This assumes that there is only one
1:             // parameter.
1:             debugInfo += "." + setterMethod + "(" + paramType.getName() + ": " + val + ")";
1:                     setterMethod.invoke(target, new Object[] {
1:                         Boolean.valueOf(val)
1:                     });
1:                     setterMethod.invoke(target, new Object[] {
1:                         Integer.valueOf(val)
1:                     });
1:                     setterMethod.invoke(target, new Object[] {
1:                         Long.valueOf(val)
1:                     });
1:                     setterMethod.invoke(target, new Object[] {
1:                         Double.valueOf(val)
1:                     });
1:                     setterMethod.invoke(target, new Object[] {
1:                         Float.valueOf(val)
1:                     });
1:                     setterMethod.invoke(target, new Object[] {
1:                         Short.valueOf(val)
1:                     });
1:                     setterMethod.invoke(target, new Object[] {
1:                         Byte.valueOf(val)
1:                     });
1:                     setterMethod.invoke(target, new Object[] {
1:                         new Character(val.charAt(0))
1:                     });
1:                     setterMethod.invoke(target, new Object[] {
1:                         val
1:                     });
1:                     // For unknown object type, try to create an instance of the
1:                     // object using a String constructor
1:                     Constructor c = paramType.getConstructor(new Class[] {
1:                         String.class
1:                     });
1:                     Object paramObject = c.newInstance(new Object[] {
1:                         val
1:                     });
1:                     setterMethod.invoke(target, new Object[] {
1:                         paramObject
1:                     });
1:             LOG.debug(debugInfo);
0:             LOG.warn(e);
/////////////////////////////////////////////////////////////////////////
1:                 // Let's catch any exception as this could be cause by the
1:                 // foreign class
/////////////////////////////////////////////////////////////////////////
0:             LOG.warn(e);
/////////////////////////////////////////////////////////////////////////
1:             for (int i = 0; i < getterMethods.length; i++) {
1:                         // Check for an appropriate setter method to consider it
1:                         // as a property
/////////////////////////////////////////////////////////////////////////
1:                     // Let's catch any exception, cause this could be cause by
1:                     // the foreign class
/////////////////////////////////////////////////////////////////////////
1:         String methodName = "set" + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);
1:         for (int i = 0; i < methods.length; i++) {
/////////////////////////////////////////////////////////////////////////
1:         String methodName1 = "get" + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);
1:         String methodName2 = "is" + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);
1:         for (int i = 0; i < methods.length; i++) {
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < methods.length; i++) {
/////////////////////////////////////////////////////////////////////////
1:         return ((method.getName().startsWith("is") && method.getReturnType() == Boolean.TYPE) || (method.getName().startsWith("get") && method.getReturnType() != Void.TYPE))
1:                && (method.getParameterTypes().length == 0) && method.getDeclaringClass() != Object.class;
/////////////////////////////////////////////////////////////////////////
1:                 // Check if parameter is a primitive or can accept a String
1:                 // parameter
1:                         if (paramType[0].getConstructor(new Class[] {
1:                             String.class
1:                         }) != null) {
/////////////////////////////////////////////////////////////////////////
1:         return name.substring(0, 1).toLowerCase() + name.substring(1);
commit:5f1adbe
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:7f883f6
/////////////////////////////////////////////////////////////////////////
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *
commit:a88906f
/////////////////////////////////////////////////////////////////////////
1: /**
0:  * Copyright 2005-2006 The Apache Software Foundation
0:  * <p/>
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  * <p/>
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  * <p/>
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.tool.properties;
1: 
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
0: import java.util.Iterator;
0: import java.util.StringTokenizer;
0: import java.util.Properties;
0: import java.util.List;
0: import java.util.ArrayList;
0: import java.lang.reflect.Method;
0: import java.lang.reflect.InvocationTargetException;
0: import java.lang.reflect.Constructor;
1: 
1: public final class ReflectionUtil {
0:     private static final Log log = LogFactory.getLog(ReflectionUtil.class);
1: 
1:     private ReflectionUtil() {
1:     }
1: 
1:     public static void configureClass(Object obj, String key, String val) {
1:         try {
1:             String debugInfo;
1: 
1:             Object target = obj;
0:             Class  targetClass = obj.getClass();
1: 
1:             // DEBUG: Debugging Info
1:             debugInfo = "Invoking: " + targetClass.getName();
1: 
1:             StringTokenizer tokenizer = new StringTokenizer(key, ".");
1:             String keySubString = key;
1:             int tokenCount = tokenizer.countTokens();
1: 
0:             // For nested settings, get the object first. -1, do not count the last token
0:             for (int j=0; j<tokenCount-1; j++) {
1:                 // Find getter method first
1:                 String name = tokenizer.nextToken();
1: 
1:                 // Check if the target object will accept the settings
1:                 if (target instanceof ReflectionConfigurable && !((ReflectionConfigurable)target).acceptConfig(keySubString, val)) {
1:                     return;
1:                 } else {
0:                     // This will reduce the key, so that it will be recognize by the next object. i.e.
1:                     // Property name: factory.prefetchPolicy.queuePrefetch
0:                     // Calling order: this.getFactory().prefetchPolicy().queuePrefetch();
0:                     // If factory does not accept the config, it should be given prefetchPolicy.queuePrefetch as the key
0:                     keySubString = keySubString.substring(name.length() + 1); // +1 to account for the '.'
1:                 }
1: 
0:                 String getMethod = "get" + name.substring(0,1).toUpperCase() + name.substring(1);
1:                 Method method = targetClass.getMethod(getMethod, new Class[] {});
1:                 target = method.invoke(target, null);
1:                 targetClass = target.getClass();
1: 
1: 
0:                 debugInfo += ("." + getMethod + "()");
1:             }
1: 
1:             // Property name
1:             String property = tokenizer.nextToken();
1:             // Check if the target object will accept the settings
1:             if (target instanceof ReflectionConfigurable && !((ReflectionConfigurable)target).acceptConfig(property, val)) {
1:                 return;
1:             }
1: 
1:             // Find setter method
1:             Method setterMethod = findSetterMethod(targetClass, property);
1: 
0:             // Get the first parameter type. This assumes that there is only one parameter.
1:             if (setterMethod == null) {
1:                 throw new IllegalAccessException("Unable to find appropriate setter method signature for property: " + property);
1:             }
0:             Class paramType = setterMethod.getParameterTypes()[0];
1: 
1:             // Set primitive type
0:             debugInfo += ("." + setterMethod + "(" + paramType.getName() + ": " + val + ")");
1:             if (paramType.isPrimitive()) {
1:                 if (paramType == Boolean.TYPE) {
0:                     setterMethod.invoke(target, new Object[] {Boolean.valueOf(val)});
1:                 } else if (paramType == Integer.TYPE) {
0:                     setterMethod.invoke(target, new Object[] {Integer.valueOf(val)});
1:                 } else if (paramType == Long.TYPE) {
0:                     setterMethod.invoke(target, new Object[] {Long.valueOf(val)});
1:                 } else if (paramType == Double.TYPE) {
0:                     setterMethod.invoke(target, new Object[] {Double.valueOf(val)});
1:                 } else if (paramType == Float.TYPE) {
0:                     setterMethod.invoke(target, new Object[] {Float.valueOf(val)});
1:                 } else if (paramType == Short.TYPE) {
0:                     setterMethod.invoke(target, new Object[] {Short.valueOf(val)});
1:                 } else if (paramType == Byte.TYPE) {
0:                     setterMethod.invoke(target, new Object[] {Byte.valueOf(val)});
1:                 } else if (paramType == Character.TYPE) {
0:                     setterMethod.invoke(target, new Object[] {new Character(val.charAt(0))});
1:                 }
1:             } else {
1:                 // Set String type
1:                 if (paramType == String.class) {
0:                     setterMethod.invoke(target, new Object[] {val});
1: 
0:                 // For unknown object type, try to create an instance of the object using a String constructor
1:                 } else {
0:                     Constructor c = paramType.getConstructor(new Class[] {String.class});
0:                     Object paramObject = c.newInstance(new Object[] {val});
1: 
0:                     setterMethod.invoke(target, new Object[] {paramObject});
1:                 }
1:             }
0:             log.debug(debugInfo);
1: 
1:         } catch (Exception e) {
0:             log.warn(e);
1:         }
1:     }
1: 
1:     public static void configureClass(Object obj, Properties props) {
0:         for (Iterator i = props.keySet().iterator(); i.hasNext();) {
1:             try {
1:                 String key = (String)i.next();
1:                 String val = props.getProperty(key);
1: 
1:                 configureClass(obj, key, val);
1:             } catch (Throwable t) {
0:                 // Let's catch any exception as this could be cause by the foreign class
1:                 t.printStackTrace();
1:             }
1:         }
1:     }
1: 
1:     public static Properties retrieveObjectProperties(Object obj) {
1:         Properties props = new Properties();
1:         try {
1:             props.putAll(retrieveClassProperties("", obj.getClass(), obj));
1:         } catch (Exception e) {
0:             log.warn(e);
1:         }
1:         return props;
1:     }
1: 
1:     protected static Properties retrieveClassProperties(String prefix, Class targetClass, Object targetObject) {
1:         if (targetClass == null || targetObject == null) {
1:             return new Properties();
1:         } else {
1:             Properties props = new Properties();
1:             Method[] getterMethods = findAllGetterMethods(targetClass);
0:             for (int i=0; i<getterMethods.length; i++) {
1:                 try {
1:                     String propertyName = getPropertyName(getterMethods[i].getName());
1:                     Class retType = getterMethods[i].getReturnType();
1: 
1:                     // If primitive or string type, return it
1:                     if (retType.isPrimitive() || retType == String.class) {
0:                         // Check for an appropriate setter method to consider it as a property
1:                         if (findSetterMethod(targetClass, propertyName) != null) {
1:                             Object val = null;
1:                             try {
1:                                 val = getterMethods[i].invoke(targetObject, null);
1:                             } catch (InvocationTargetException e) {
1:                                 e.printStackTrace();
1:                             } catch (IllegalAccessException e) {
1:                                 e.printStackTrace();
1:                             }
1:                             props.setProperty(prefix + propertyName, val + "");
1:                         }
1:                     } else {
1:                         try {
1:                             Object val = getterMethods[i].invoke(targetObject, null);
0:                             if (val != null) {
1:                                 props.putAll(retrieveClassProperties(propertyName + ".", val.getClass(), val));
1:                             }
1:                         } catch (InvocationTargetException e) {
1:                             e.printStackTrace();
1:                         } catch (IllegalAccessException e) {
1:                             e.printStackTrace();
1:                         }
1:                     }
1:                 } catch (Throwable t) {
0:                     // Let's catch any exception, cause this could be cause by the foreign class
1:                     t.printStackTrace();
1:                 }
1:             }
1:             return props;
1:         }
1:     }
1: 
1:     private static Method findSetterMethod(Class targetClass, String propertyName) {
0:         String methodName = "set" + propertyName.substring(0,1).toUpperCase() + propertyName.substring(1);
1: 
1:         Method[] methods = targetClass.getMethods();
0:         for (int i=0; i<methods.length; i++) {
1:             if (methods[i].getName().equals(methodName) && isSetterMethod(methods[i])) {
1:                 return methods[i];
1:             }
1:         }
1:         return null;
1:     }
1: 
1:     private static Method findGetterMethod(Class targetClass, String propertyName) {
0:         String methodName1 = "get" + propertyName.substring(0,1).toUpperCase() + propertyName.substring(1);
0:         String methodName2 = "is"  + propertyName.substring(0,1).toUpperCase() + propertyName.substring(1);
1: 
1:         Method[] methods = targetClass.getMethods();
0:         for (int i=0; i<methods.length; i++) {
1:             if ((methods[i].getName().equals(methodName1) || methods[i].getName().equals(methodName2)) && isGetterMethod(methods[i])) {
1:                 return methods[i];
1:             }
1:         }
1:         return null;
1:     }
1: 
1:     private static Method[] findAllGetterMethods(Class targetClass) {
1:         List getterMethods = new ArrayList();
1:         Method[] methods = targetClass.getMethods();
1: 
0:         for (int i=0; i<methods.length; i++) {
1:             if (isGetterMethod(methods[i])) {
1:                 getterMethods.add(methods[i]);
1:             }
1:         }
1: 
1:         return (Method[])getterMethods.toArray(new Method[] {});
1:     }
1: 
1:     private static boolean isGetterMethod(Method method) {
1:         // Check method signature first
1:         // If 'get' method, must return a non-void value
1:         // If 'is' method, must return a boolean value
1:         // Both must have no parameters
1:         // Method must not belong to the Object class to prevent infinite loop
0:         return (((method.getName().startsWith("is") && method.getReturnType() == Boolean.TYPE) ||
0:                  (method.getName().startsWith("get") && method.getReturnType() != Void.TYPE)) &&
0:                 (method.getParameterTypes().length == 0) && method.getDeclaringClass() != Object.class);
1:     }
1: 
1:     private static boolean isSetterMethod(Method method) {
1:         // Check method signature first
1:         if (method.getName().startsWith("set") && method.getReturnType() == Void.TYPE) {
1:             Class[] paramType = method.getParameterTypes();
1:             // Check that it can only accept one parameter
1:             if (paramType.length == 1) {
0:                 // Check if parameter is a primitive or can accept a String parameter
1:                 if (paramType[0].isPrimitive() || paramType[0] == String.class) {
1:                     return true;
1:                 } else {
1:                     // Check if object can accept a string as a constructor
1:                     try {
0:                         if (paramType[0].getConstructor(new Class[] {String.class}) != null) {
1:                             return true;
1:                         }
1:                     } catch (NoSuchMethodException e) {
1:                         // Do nothing
1:                     }
1:                 }
1:             }
1:         }
1:         return false;
1:     }
1: 
1:     private static String getPropertyName(String methodName) {
1:         String name;
1:         if (methodName.startsWith("get")) {
1:             name = methodName.substring(3);
1:         } else if (methodName.startsWith("set")) {
1:             name = methodName.substring(3);
1:         } else if (methodName.startsWith("is")) {
1:             name = methodName.substring(2);
1:         } else {
1:             name = "";
1:         }
1: 
0:         return name.substring(0,1).toLowerCase() + name.substring(1);
1:     }
1: }
author:James Strachan
-------------------------------------------------------------------------------
commit:dd55c21
author:Adrian T. Co
-------------------------------------------------------------------------------
commit:9f3fcde
/////////////////////////////////////////////////////////////////////////
0:             String keySubString = key;
0: 
0:                 // Check if the target object will accept the settings
0:                 if (target instanceof ReflectionConfigurable && !((ReflectionConfigurable)target).acceptConfig(keySubString, val)) {
0:                     return;
0:                 } else {
0:                     // This will reduce the key, so that it will be recognize by the next object. i.e.
0:                     // Property name: factory.prefetchPolicy.queuePrefetch
0:                     // Calling order: this.getFactory().prefetchPolicy().queuePrefetch();
0:                     // If factory does not accept the config, it should be given prefetchPolicy.queuePrefetch as the key
0:                     keySubString = keySubString.substring(name.length() + 1); // +1 to account for the '.'
0:                 }
0: 
0: 
0:             if (target instanceof ReflectionConfigurable && !((ReflectionConfigurable)target).acceptConfig(property, val)) {
commit:0dbcc1f
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.Constructor;
/////////////////////////////////////////////////////////////////////////
0:             // For nested settings, get the object first. -1, do not count the last token
/////////////////////////////////////////////////////////////////////////
0:             // Find setter method
0:             Method setterMethod = findSetterMethod(targetClass, property);
0:             // Get the first parameter type. This assumes that there is only one parameter.
0:             if (setterMethod == null) {
0:                 throw new IllegalAccessException("Unable to find appropriate setter method signature for property: " + property);
0:             }
0:             Class paramType = setterMethod.getParameterTypes()[0];
0:             debugInfo += ("." + setterMethod + "(" + paramType.getName() + ": " + val + ")");
0:             if (paramType.isPrimitive()) {
0:                 if (paramType == Boolean.TYPE) {
0:                     setterMethod.invoke(target, new Object[] {Boolean.valueOf(val)});
0:                 } else if (paramType == Integer.TYPE) {
0:                     setterMethod.invoke(target, new Object[] {Integer.valueOf(val)});
0:                 } else if (paramType == Long.TYPE) {
0:                     setterMethod.invoke(target, new Object[] {Long.valueOf(val)});
0:                 } else if (paramType == Double.TYPE) {
0:                     setterMethod.invoke(target, new Object[] {Double.valueOf(val)});
0:                 } else if (paramType == Float.TYPE) {
0:                     setterMethod.invoke(target, new Object[] {Float.valueOf(val)});
0:                 } else if (paramType == Short.TYPE) {
0:                     setterMethod.invoke(target, new Object[] {Short.valueOf(val)});
0:                 } else if (paramType == Byte.TYPE) {
0:                     setterMethod.invoke(target, new Object[] {Byte.valueOf(val)});
0:                 } else if (paramType == Character.TYPE) {
0:                     setterMethod.invoke(target, new Object[] {new Character(val.charAt(0))});
0:                 if (paramType == String.class) {
0:                     setterMethod.invoke(target, new Object[] {val});
0:                 // For unknown object type, try to create an instance of the object using a String constructor
0:                     Constructor c = paramType.getConstructor(new Class[] {String.class});
0:                     Object paramObject = c.newInstance(new Object[] {val});
0: 
0:                     setterMethod.invoke(target, new Object[] {paramObject});
/////////////////////////////////////////////////////////////////////////
0:             Method[] getterMethods = findAllGetterMethods(targetClass);
0:             for (int i=0; i<getterMethods.length; i++) {
0:                     String propertyName = getPropertyName(getterMethods[i].getName());
0:                     Class retType = getterMethods[i].getReturnType();
0: 
0:                     // If primitive or string type, return it
0:                     if (retType.isPrimitive() || retType == String.class) {
0:                         // Check for an appropriate setter method to consider it as a property
0:                         if (findSetterMethod(targetClass, propertyName) != null) {
0:                                 val = getterMethods[i].invoke(targetObject, null);
0:                             props.setProperty(prefix + propertyName, val + "");
0:                         }
0:                     } else {
0:                         try {
0:                             Object val = getterMethods[i].invoke(targetObject, null);
0:                             if (val != null) {
0:                                 props.putAll(retrieveClassProperties(propertyName + ".", val.getClass(), val));
0:                         } catch (InvocationTargetException e) {
0:                             e.printStackTrace();
0:                         } catch (IllegalAccessException e) {
0:                             e.printStackTrace();
/////////////////////////////////////////////////////////////////////////
0:     private static Method findSetterMethod(Class targetClass, String propertyName) {
0:         String methodName = "set" + propertyName.substring(0,1).toUpperCase() + propertyName.substring(1);
0:         Method[] methods = targetClass.getMethods();
0:         for (int i=0; i<methods.length; i++) {
0:             if (methods[i].getName().equals(methodName) && isSetterMethod(methods[i])) {
0:                 return methods[i];
0:         return null;
0:     private static Method findGetterMethod(Class targetClass, String propertyName) {
0:         String methodName1 = "get" + propertyName.substring(0,1).toUpperCase() + propertyName.substring(1);
0:         String methodName2 = "is"  + propertyName.substring(0,1).toUpperCase() + propertyName.substring(1);
0: 
0:         Method[] methods = targetClass.getMethods();
0:         for (int i=0; i<methods.length; i++) {
0:             if ((methods[i].getName().equals(methodName1) || methods[i].getName().equals(methodName2)) && isGetterMethod(methods[i])) {
0:                 return methods[i];
0:         return null;
0:     private static Method[] findAllGetterMethods(Class targetClass) {
0:         List getterMethods = new ArrayList();
0:         Method[] methods = targetClass.getMethods();
0: 
0:         for (int i=0; i<methods.length; i++) {
0:             if (isGetterMethod(methods[i])) {
0:                 getterMethods.add(methods[i]);
0:             }
0: 
0:         return (Method[])getterMethods.toArray(new Method[] {});
0:     }
0: 
0:     private static boolean isGetterMethod(Method method) {
0:         // Check method signature first
0:         // If 'get' method, must return a non-void value
0:         // If 'is' method, must return a boolean value
0:         // Both must have no parameters
0:         // Method must not belong to the Object class to prevent infinite loop
0:         return (((method.getName().startsWith("is") && method.getReturnType() == Boolean.TYPE) ||
0:                  (method.getName().startsWith("get") && method.getReturnType() != Void.TYPE)) &&
0:                 (method.getParameterTypes().length == 0) && method.getDeclaringClass() != Object.class);
0:     }
0: 
0:     private static boolean isSetterMethod(Method method) {
0:         // Check method signature first
0:         if (method.getName().startsWith("set") && method.getReturnType() == Void.TYPE) {
0:             Class[] paramType = method.getParameterTypes();
0:             // Check that it can only accept one parameter
0:             if (paramType.length == 1) {
0:                 // Check if parameter is a primitive or can accept a String parameter
0:                 if (paramType[0].isPrimitive() || paramType[0] == String.class) {
0:                     return true;
0:                 } else {
0:                     // Check if object can accept a string as a constructor
0:                     try {
0:                         if (paramType[0].getConstructor(new Class[] {String.class}) != null) {
0:                             return true;
0:                         }
0:                     } catch (NoSuchMethodException e) {
0:                         // Do nothing
0:                     }
0:                 }
0:             }
0:         }
0:         return false;
0:     }
0: 
0:     private static String getPropertyName(String methodName) {
0:         String name;
0:         if (methodName.startsWith("get")) {
0:             name = methodName.substring(3);
0:         } else if (methodName.startsWith("set")) {
0:             name = methodName.substring(3);
0:         } else if (methodName.startsWith("is")) {
0:             name = methodName.substring(2);
0:         } else {
0:             name = "";
0:         }
0: 
0:         return name.substring(0,1).toLowerCase() + name.substring(1);
commit:ffcbd0c
/////////////////////////////////////////////////////////////////////////
commit:6a794d8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             // Check if the target object will accept the settings
0:             if (obj instanceof ReflectionConfigurable && !((ReflectionConfigurable)target).acceptConfig(property, val)) {
0:                 return;
0:             }
0: 
commit:4bcac89
/////////////////////////////////////////////////////////////////////////
0: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
0:             fieldList.addAll(Arrays.asList(targetClass.getDeclaredFields()));
commit:f1c6e4c
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Copyright 2005-2006 The Apache Software Foundation
0:  * <p/>
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  * <p/>
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  * <p/>
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: package org.apache.activemq.tool.properties;
0: 
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: 
0: import java.util.Iterator;
0: import java.util.StringTokenizer;
0: import java.util.Properties;
0: import java.util.List;
0: import java.util.ArrayList;
0: import java.util.Collections;
0: import java.lang.reflect.Method;
0: import java.lang.reflect.Field;
0: import java.lang.reflect.InvocationTargetException;
0: 
0: public final class ReflectionUtil {
0:     private static final Log log = LogFactory.getLog(ReflectionUtil.class);
0: 
0:     private ReflectionUtil() {
0:     }
0: 
0:     public static void configureClass(Object obj, String key, String val) {
0:         // Check if we will recognize the property first
0:         if (obj instanceof ReflectionConfigurable && !((ReflectionConfigurable)obj).acceptConfig(key, val)) {
0:             return;
0:         }
0: 
0:         try {
0:             String debugInfo;
0: 
0:             Object target = obj;
0:             Class  targetClass = obj.getClass();
0: 
0:             // DEBUG: Debugging Info
0:             debugInfo = "Invoking: " + targetClass.getName();
0: 
0:             StringTokenizer tokenizer = new StringTokenizer(key, ".");
0:             int tokenCount = tokenizer.countTokens();
0: 
0:             // For nested settings, get the object first. -2, do not count the first and last token
0:             for (int j=0; j<tokenCount-1; j++) {
0:                 // Find getter method first
0:                 String name = tokenizer.nextToken();
0:                 String getMethod = "get" + name.substring(0,1).toUpperCase() + name.substring(1);
0:                 Method method = targetClass.getMethod(getMethod, new Class[] {});
0:                 target = method.invoke(target, null);
0:                 targetClass = target.getClass();
0: 
0:                 debugInfo += ("." + getMethod + "()");
0:             }
0: 
0:             // Property name
0:             String property = tokenizer.nextToken();
0: 
0:             // Determine data type of property
0:             Class propertyType = getField(targetClass, property).getType();
0: 
0:             // Get setter method
0:             String setterMethod = "set" + property.substring(0,1).toUpperCase() + property.substring(1);
0: 
0:             // Set primitive type
0:             debugInfo += ("." + setterMethod + "(" + propertyType.getName() + ": " + val + ")");
0:             if (propertyType.isPrimitive()) {
0:                 if (propertyType == Boolean.TYPE) {
0:                     targetClass.getMethod(setterMethod, new Class[] {boolean.class}).invoke(target, new Object[] {Boolean.valueOf(val)});
0:                 } else if (propertyType == Integer.TYPE) {
0:                     targetClass.getMethod(setterMethod, new Class[] {int.class}).invoke(target, new Object[] {Integer.valueOf(val)});
0:                 } else if (propertyType == Long.TYPE) {
0:                     targetClass.getMethod(setterMethod, new Class[] {long.class}).invoke(target, new Object[] {Long.valueOf(val)});
0:                 } else if (propertyType == Double.TYPE) {
0:                     targetClass.getMethod(setterMethod, new Class[] {double.class}).invoke(target, new Object[] {Double.valueOf(val)});
0:                 } else if (propertyType == Float.TYPE) {
0:                     targetClass.getMethod(setterMethod, new Class[] {float.class}).invoke(target, new Object[] {Float.valueOf(val)});
0:                 } else if (propertyType == Short.TYPE) {
0:                     targetClass.getMethod(setterMethod, new Class[] {short.class}).invoke(target, new Object[] {Short.valueOf(val)});
0:                 } else if (propertyType == Byte.TYPE) {
0:                     targetClass.getMethod(setterMethod, new Class[] {byte.class}).invoke(target, new Object[] {Byte.valueOf(val)});
0:                 } else if (propertyType == Character.TYPE) {
0:                     targetClass.getMethod(setterMethod, new Class[] {char.class}).invoke(target, new Object[] {new Character(val.charAt(0))});
0:                 }
0:             } else {
0:                 // Set String type
0:                 if (propertyType == String.class) {
0:                     targetClass.getMethod(setterMethod, new Class[] {String.class}).invoke(target, new Object[] {val});
0: 
0:                 // For unknown object type, try to call the valueOf method of the object
0:                 // to convert the string to the target object type
0:                 } else {
0:                     // Note valueOf method should be public and static
0:                     Object param = propertyType.getMethod("valueOf", new Class[] {String.class}).invoke(null, new Object[] {val});
0:                     targetClass.getMethod(setterMethod, new Class[] {propertyType}).invoke(target, new Object[] {param});
0:                 }
0:             }
0:             log.debug(debugInfo);
0: 
0:         } catch (Exception e) {
0:             log.warn(e);
0:         }
0:     }
0: 
0:     public static void configureClass(Object obj, Properties props) {
0:         for (Iterator i = props.keySet().iterator(); i.hasNext();) {
0:             try {
0:                 String key = (String)i.next();
0:                 String val = props.getProperty(key);
0: 
0:                 configureClass(obj, key, val);
0:             } catch (Throwable t) {
0:                 // Let's catch any exception as this could be cause by the foreign class
0:                 t.printStackTrace();
0:             }
0:         }
0:     }
0: 
0:     public static Properties retrieveObjectProperties(Object obj) {
0:         Properties props = new Properties();
0:         try {
0:             props.putAll(retrieveClassProperties("", obj.getClass(), obj));
0:         } catch (Exception e) {
0:             log.warn(e);
0:         }
0:         return props;
0:     }
0: 
0:     protected static Properties retrieveClassProperties(String prefix, Class targetClass, Object targetObject) {
0:         if (targetClass == null || targetObject == null) {
0:             return new Properties();
0:         } else {
0:             Properties props = new Properties();
0:             Field[] fields = getAllFields(targetClass);
0:             Method getterMethod;
0:             for (int i=0; i<fields.length; i++) {
0:                 try {
0:                     if ((getterMethod = isPropertyField(targetClass, fields[i])) != null) {
0:                         if (fields[i].getType().isPrimitive() || fields[i].getType() == String.class) {
0:                             Object val = null;
0:                             try {
0:                                 val = getterMethod.invoke(targetObject, null);
0:                             } catch (InvocationTargetException e) {
0:                                 e.printStackTrace();
0:                             } catch (IllegalAccessException e) {
0:                                 e.printStackTrace();
0:                             }
0:                             props.setProperty(prefix + fields[i].getName(), val + "");
0:                         } else {
0:                             try {
0:                                 Object val = getterMethod.invoke(targetObject, null);
0:                                 if (val != null) {
0:                                     props.putAll(retrieveClassProperties(fields[i].getName() + ".", val.getClass(), val));
0:                                 }
0:                             } catch (InvocationTargetException e) {
0:                                 e.printStackTrace();
0:                             } catch (IllegalAccessException e) {
0:                                 e.printStackTrace();
0:                             }
0:                         }
0:                     }
0:                 } catch (Throwable t) {
0:                     // Let's catch any exception, cause this could be cause by the foreign class
0:                     t.printStackTrace();
0:                 }
0:             }
0:             return props;
0:         }
0:     }
0: 
0:     protected static Method isPropertyField(Class targetClass, Field targetField) {
0:         String fieldName = targetField.getName();
0:         String getMethod = "get" + fieldName.substring(0,1).toUpperCase() + fieldName.substring(1);
0:         String isMethod  = "is"  + fieldName.substring(0,1).toUpperCase() + fieldName.substring(1);
0:         String setMethod = "set" + fieldName.substring(0,1).toUpperCase() + fieldName.substring(1);
0: 
0:         // Check setter method
0:         try {
0:             targetClass.getMethod(setMethod, new Class[]{targetField.getType()});
0:         } catch (NoSuchMethodException e) {
0:             return null;
0:         }
0: 
0:         // Check getter method and return it if it exists
0:         try {
0:             return targetClass.getMethod(getMethod, null);
0:         } catch (NoSuchMethodException e1) {
0:             try {
0:                 return targetClass.getMethod(isMethod, null);
0:             } catch (NoSuchMethodException e2) {
0:                 return null;
0:             }
0:         }
0:     }
0: 
0:     public static Field getField(Class targetClass, String fieldName) throws NoSuchFieldException {
0:         while (targetClass != null) {
0:             try {
0:                 return targetClass.getDeclaredField(fieldName);
0:             } catch (NoSuchFieldException e) {
0:                 targetClass = targetClass.getSuperclass();
0:             }
0:         }
0:         throw new NoSuchFieldException(fieldName);
0:     }
0: 
0:     public static Field[] getAllFields(Class targetClass) {
0:         List fieldList = new ArrayList();
0:         while (targetClass != null) {
0:             Collections.addAll(fieldList, targetClass.getDeclaredFields());
0:             targetClass = targetClass.getSuperclass();
0:         }
0:         return (Field[])fieldList.toArray(new Field[0]);
0:     }
0: }
============================================================================