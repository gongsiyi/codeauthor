1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:543935b:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:543935b:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.util;
1:9befb11: 
1:d29ca2a: import java.io.DataInput;
1:d29ca2a: import java.io.DataInputStream;
1:d29ca2a: import java.io.DataOutput;
1:d29ca2a: import java.io.DataOutputStream;
1:d29ca2a: import java.io.IOException;
1:d29ca2a: import java.io.UTFDataFormatException;
1:ca067a6: import java.util.ArrayList;
1:d29ca2a: import java.util.HashMap;
1:ca067a6: import java.util.List;
1:ca067a6: import java.util.Map;
1:ae73f86: import java.util.Properties;
1:543935b: 
1:543935b: import org.fusesource.hawtbuf.UTF8Buffer;
1:543935b: 
1:d29ca2a: /**
1:f812e34:  * The fixed version of the UTF8 encoding function. Some older JVM's UTF8
1:f812e34:  * encoding function breaks when handling large strings.
1:d29ca2a:  */
1:ecf89a6: public final class MarshallingSupport {
1:d29ca2a: 
1:f812e34:     public static final byte NULL = 0;
1:f812e34:     public static final byte BOOLEAN_TYPE = 1;
1:f812e34:     public static final byte BYTE_TYPE = 2;
1:f812e34:     public static final byte CHAR_TYPE = 3;
1:f812e34:     public static final byte SHORT_TYPE = 4;
1:f812e34:     public static final byte INTEGER_TYPE = 5;
1:f812e34:     public static final byte LONG_TYPE = 6;
1:f812e34:     public static final byte DOUBLE_TYPE = 7;
1:f812e34:     public static final byte FLOAT_TYPE = 8;
1:f812e34:     public static final byte STRING_TYPE = 9;
1:f812e34:     public static final byte BYTE_ARRAY_TYPE = 10;
1:f812e34:     public static final byte MAP_TYPE = 11;
1:f812e34:     public static final byte LIST_TYPE = 12;
1:f812e34:     public static final byte BIG_STRING_TYPE = 13;
1:ecf89a6: 
1:8a6ebc2:     private MarshallingSupport() {}
1:f812e34: 
1:8a6ebc2:     public static void marshalPrimitiveMap(Map<String, Object> map, DataOutputStream out) throws IOException {
1:f812e34:         if (map == null) {
1:d29ca2a:             out.writeInt(-1);
1:9befb11:         } else {
1:d29ca2a:             out.writeInt(map.size());
1:8a6ebc2:             for (String name : map.keySet()) {
1:d29ca2a:                 out.writeUTF(name);
1:d29ca2a:                 Object value = map.get(name);
1:d29ca2a:                 marshalPrimitive(out, value);
1:ecf89a6:             }
1:f812e34:         }
1:f812e34:     }
1:6583ef1: 
1:ecf89a6:     public static Map<String, Object> unmarshalPrimitiveMap(DataInputStream in) throws IOException {
1:f812e34:         return unmarshalPrimitiveMap(in, Integer.MAX_VALUE);
1:f812e34:     }
1:6583ef1: 
1:0704eda:     public static Map<String, Object> unmarshalPrimitiveMap(DataInputStream in, boolean force) throws IOException {
1:0704eda:         return unmarshalPrimitiveMap(in, Integer.MAX_VALUE, force);
1:0704eda:     }
1:0704eda: 
1:0704eda:     public static Map<String, Object> unmarshalPrimitiveMap(DataInputStream in, int maxPropertySize) throws IOException {
1:f3407fe:         return unmarshalPrimitiveMap(in, maxPropertySize, false);
1:0704eda:     }
1:0704eda: 
1:d29ca2a:     /**
1:d29ca2a:      * @param in
1:d29ca2a:      * @return
1:f812e34:      * @throws IOException
1:6583ef1:      * @throws IOException
1:d29ca2a:      */
1:0704eda:     public static Map<String, Object> unmarshalPrimitiveMap(DataInputStream in, int maxPropertySize, boolean force) throws IOException {
1:d29ca2a:         int size = in.readInt();
1:fc00993:         if (size > maxPropertySize) {
1:f812e34:             throw new IOException("Primitive map is larger than the allowed size: " + size);
1:6583ef1:         }
1:f812e34:         if (size < 0) {
1:d29ca2a:             return null;
5:d29ca2a:         } else {
1:ecf89a6:             Map<String, Object> rc = new HashMap<String, Object>(size);
1:f812e34:             for (int i = 0; i < size; i++) {
1:d29ca2a:                 String name = in.readUTF();
1:0704eda:                 rc.put(name, unmarshalPrimitive(in, force));
1:6583ef1:             }
1:d29ca2a:             return rc;
1:d29ca2a:         }
1:d29ca2a:     }
1:f812e34: 
1:f3407fe:     public static void marshalPrimitiveList(List<Object> list, DataOutputStream out) throws IOException {
1:ca067a6:         out.writeInt(list.size());
1:0704eda:         for (Object element : list) {
1:ca067a6:             marshalPrimitive(out, element);
1:d29ca2a:         }
1:d29ca2a:     }
1:f812e34: 
1:ecf89a6:     public static List<Object> unmarshalPrimitiveList(DataInputStream in) throws IOException {
1:0704eda:         return unmarshalPrimitiveList(in, false);
1:0704eda:     }
1:0704eda: 
1:0704eda:     public static List<Object> unmarshalPrimitiveList(DataInputStream in, boolean force) throws IOException {
1:ca067a6:         int size = in.readInt();
1:ecf89a6:         List<Object> answer = new ArrayList<Object>(size);
1:ca067a6:         while (size-- > 0) {
1:0704eda:             answer.add(unmarshalPrimitive(in, force));
1:d29ca2a:         }
1:ca067a6:         return answer;
1:d29ca2a:     }
1:d29ca2a: 
1:fc00993:     public static void marshalPrimitive(DataOutputStream out, Object value) throws IOException {
1:f812e34:         if (value == null) {
1:09ebb72:             marshalNull(out);
1:f812e34:         } else if (value.getClass() == Boolean.class) {
1:09ebb72:             marshalBoolean(out, ((Boolean)value).booleanValue());
1:f812e34:         } else if (value.getClass() == Byte.class) {
1:09ebb72:             marshalByte(out, ((Byte)value).byteValue());
1:f812e34:         } else if (value.getClass() == Character.class) {
1:09ebb72:             marshalChar(out, ((Character)value).charValue());
1:f812e34:         } else if (value.getClass() == Short.class) {
1:09ebb72:             marshalShort(out, ((Short)value).shortValue());
1:f812e34:         } else if (value.getClass() == Integer.class) {
1:09ebb72:             marshalInt(out, ((Integer)value).intValue());
1:f812e34:         } else if (value.getClass() == Long.class) {
1:09ebb72:             marshalLong(out, ((Long)value).longValue());
1:f812e34:         } else if (value.getClass() == Float.class) {
1:09ebb72:             marshalFloat(out, ((Float)value).floatValue());
1:f812e34:         } else if (value.getClass() == Double.class) {
1:09ebb72:             marshalDouble(out, ((Double)value).doubleValue());
1:f812e34:         } else if (value.getClass() == byte[].class) {
1:74a7a8b:             marshalByteArray(out, (byte[])value);
1:f812e34:         } else if (value.getClass() == String.class) {
1:0028272:             marshalString(out, (String)value);
1:ec0a0a3:         } else  if (value.getClass() == UTF8Buffer.class) {
1:ec0a0a3:             marshalString(out, value.toString());
1:f812e34:         } else if (value instanceof Map) {
1:ca067a6:             out.writeByte(MAP_TYPE);
1:8a6ebc2:             marshalPrimitiveMap((Map<String, Object>)value, out);
1:f812e34:         } else if (value instanceof List) {
1:ca067a6:             out.writeByte(LIST_TYPE);
1:8a6ebc2:             marshalPrimitiveList((List<Object>)value, out);
1:d29ca2a:         } else {
1:f812e34:             throw new IOException("Object is not a primitive: " + value);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:fc00993:     public static Object unmarshalPrimitive(DataInputStream in) throws IOException {
1:3a6bbfe:         return unmarshalPrimitive(in, false);
1:3a6bbfe:     }
1:3a6bbfe: 
1:3a6bbfe:     public static Object unmarshalPrimitive(DataInputStream in, boolean force) throws IOException {
1:f812e34:         Object value = null;
1:74a7a8b:         byte type = in.readByte();
1:74a7a8b:         switch (type) {
1:d29ca2a:         case BYTE_TYPE:
1:ecf89a6:             value = Byte.valueOf(in.readByte());
1:f812e34:             break;
1:d29ca2a:         case BOOLEAN_TYPE:
1:d29ca2a:             value = in.readBoolean() ? Boolean.TRUE : Boolean.FALSE;
1:f812e34:             break;
1:d29ca2a:         case CHAR_TYPE:
1:d36c0d4:             value = Character.valueOf(in.readChar());
1:f812e34:             break;
1:d29ca2a:         case SHORT_TYPE:
1:d36c0d4:             value = Short.valueOf(in.readShort());
5:d29ca2a:             break;
1:d29ca2a:         case INTEGER_TYPE:
1:d36c0d4:             value = Integer.valueOf(in.readInt());
1:d29ca2a:             break;
1:d29ca2a:         case LONG_TYPE:
1:d36c0d4:             value = Long.valueOf(in.readLong());
1:d29ca2a:             break;
1:d29ca2a:         case FLOAT_TYPE:
1:d29ca2a:             value = new Float(in.readFloat());
1:d29ca2a:             break;
1:d29ca2a:         case DOUBLE_TYPE:
1:d29ca2a:             value = new Double(in.readDouble());
1:d29ca2a:             break;
1:d29ca2a:         case BYTE_ARRAY_TYPE:
1:d29ca2a:             value = new byte[in.readInt()];
1:d29ca2a:             in.readFully((byte[])value);
1:d29ca2a:             break;
1:3a6bbfe:         case STRING_TYPE:
1:3a6bbfe:             if (force) {
1:543935b:                 value = in.readUTF();
1:543935b:             } else {
1:3a6bbfe:                 value = readUTF(in, in.readUnsignedShort());
1:543935b:             }
1:d29ca2a:             break;
1:543935b:         case BIG_STRING_TYPE: {
1:3a6bbfe:             if (force) {
1:543935b:                 value = readUTF8(in);
1:3a6bbfe:             } else {
1:3a6bbfe:                 value = readUTF(in, in.readInt());
1:543935b:             }
1:9befb11:             break;
1:3a6bbfe:         }
1:ca067a6:         case MAP_TYPE:
1:0704eda:             value = unmarshalPrimitiveMap(in, true);
1:d29ca2a:             break;
1:ca067a6:         case LIST_TYPE:
1:0704eda:             value = unmarshalPrimitiveList(in, true);
1:d29ca2a:             break;
1:6084b60:         case NULL:
1:6084b60:             value = null;
1:6084b60:             break;
1:74a7a8b:         default:
1:74a7a8b:             throw new IOException("Unknown primitive type: " + type);
1:3a6bbfe:         }
1:d29ca2a:         return value;
3:ae73f86:     }
1:d29ca2a: 
1:3a6bbfe:     public static UTF8Buffer readUTF(DataInputStream in, int length) throws IOException {
2:6f0a335:         byte data[] = new byte[length];
2:6f0a335:         in.readFully(data);
1:3a6bbfe:         return new UTF8Buffer(data);
1:543935b:     }
1:3a6bbfe: 
1:09ebb72:     public static void marshalNull(DataOutputStream out) throws IOException {
1:d29ca2a:         out.writeByte(NULL);
1:543935b:     }
1:d29ca2a: 
1:09ebb72:     public static void marshalBoolean(DataOutputStream out, boolean value) throws IOException {
1:d29ca2a:         out.writeByte(BOOLEAN_TYPE);
1:09ebb72:         out.writeBoolean(value);
1:3a6bbfe:     }
1:d29ca2a: 
1:09ebb72:     public static void marshalByte(DataOutputStream out, byte value) throws IOException {
1:d29ca2a:         out.writeByte(BYTE_TYPE);
1:09ebb72:         out.writeByte(value);
1:ae73f86:     }
1:d29ca2a: 
1:09ebb72:     public static void marshalChar(DataOutputStream out, char value) throws IOException {
1:d29ca2a:         out.writeByte(CHAR_TYPE);
1:09ebb72:         out.writeChar(value);
1:d29ca2a:     }
1:ae73f86: 
1:09ebb72:     public static void marshalShort(DataOutputStream out, short value) throws IOException {
1:d29ca2a:         out.writeByte(SHORT_TYPE);
1:09ebb72:         out.writeShort(value);
1:d29ca2a:     }
1:ae73f86: 
1:09ebb72:     public static void marshalInt(DataOutputStream out, int value) throws IOException {
1:d29ca2a:         out.writeByte(INTEGER_TYPE);
1:09ebb72:         out.writeInt(value);
1:d29ca2a:     }
11:09ebb72: 
1:09ebb72:     public static void marshalLong(DataOutputStream out, long value) throws IOException {
1:d29ca2a:         out.writeByte(LONG_TYPE);
1:09ebb72:         out.writeLong(value);
1:d29ca2a:     }
1:09ebb72: 
1:09ebb72:     public static void marshalFloat(DataOutputStream out, float value) throws IOException {
1:d29ca2a:         out.writeByte(FLOAT_TYPE);
1:09ebb72:         out.writeFloat(value);
1:d29ca2a:     }
1:d29ca2a: 
1:09ebb72:     public static void marshalDouble(DataOutputStream out, double value) throws IOException {
1:d29ca2a:         out.writeByte(DOUBLE_TYPE);
1:09ebb72:         out.writeDouble(value);
1:d29ca2a:     }
1:d29ca2a: 
1:09ebb72:     public static void marshalByteArray(DataOutputStream out, byte[] value) throws IOException {
1:09ebb72:         marshalByteArray(out, value, 0, value.length);
1:d29ca2a:     }
1:d29ca2a: 
1:09ebb72:     public static void marshalByteArray(DataOutputStream out, byte[] value, int offset, int length) throws IOException {
1:d29ca2a:         out.writeByte(BYTE_ARRAY_TYPE);
1:09ebb72:         out.writeInt(length);
1:09ebb72:         out.write(value, offset, length);
1:d29ca2a:     }
1:d29ca2a: 
1:0028272:     public static void marshalString(DataOutputStream out, String s) throws IOException {
1:9befb11:         // If it's too big, out.writeUTF may not able able to write it out.
1:f812e34:         if (s.length() < Short.MAX_VALUE / 4) {
1:9befb11:             out.writeByte(STRING_TYPE);
1:0028272:             out.writeUTF(s);
1:543935b:         } else {
1:9befb11:             out.writeByte(BIG_STRING_TYPE);
1:9befb11:             writeUTF8(out, s);
1:9befb11:         }
1:d29ca2a:     }
1:9befb11: 
1:fc00993:     public static void writeUTF8(DataOutput dataOut, String text) throws IOException {
1:d29ca2a:         if (text != null) {
1:172c290:             long utfCount = countUTFBytes(text);
1:172c290:             dataOut.writeInt((int)utfCount);
1:d29ca2a: 
1:172c290:             byte[] buffer = new byte[(int)utfCount];
1:172c290:             int len = writeUTFBytesToBuffer(text, (int) utfCount, buffer, 0);
1:172c290:             dataOut.write(buffer, 0, len);
1:d29ca2a: 
1:172c290:             assert utfCount==len;
1:3a6bbfe:         } else {
1:d29ca2a:             dataOut.writeInt(-1);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:172c290:     /**
1:172c290:      * From: http://svn.apache.org/repos/asf/harmony/enhanced/java/trunk/classlib/modules/luni/src/main/java/java/io/DataOutputStream.java
1:172c290:      */
1:172c290:     public static long countUTFBytes(String str) {
1:172c290:         int utfCount = 0, length = str.length();
1:172c290:         for (int i = 0; i < length; i++) {
1:172c290:             int charValue = str.charAt(i);
1:172c290:             if (charValue > 0 && charValue <= 127) {
1:172c290:                 utfCount++;
1:172c290:             } else if (charValue <= 2047) {
1:172c290:                 utfCount += 2;
1:172c290:             } else {
1:172c290:                 utfCount += 3;
1:172c290:             }
1:d29ca2a:         }
1:172c290:         return utfCount;
1:172c290:     }
1:172c290: 
1:172c290:     /**
1:172c290:      * From: http://svn.apache.org/repos/asf/harmony/enhanced/java/trunk/classlib/modules/luni/src/main/java/java/io/DataOutputStream.java
1:172c290:      */
1:172c290:     public static int writeUTFBytesToBuffer(String str, long count,
1:172c290:                                      byte[] buffer, int offset) throws IOException {
1:172c290:         int length = str.length();
1:172c290:         for (int i = 0; i < length; i++) {
1:172c290:             int charValue = str.charAt(i);
1:172c290:             if (charValue > 0 && charValue <= 127) {
1:172c290:                 buffer[offset++] = (byte) charValue;
1:172c290:             } else if (charValue <= 2047) {
1:172c290:                 buffer[offset++] = (byte) (0xc0 | (0x1f & (charValue >> 6)));
1:172c290:                 buffer[offset++] = (byte) (0x80 | (0x3f & charValue));
1:172c290:             } else {
1:172c290:                 buffer[offset++] = (byte) (0xe0 | (0x0f & (charValue >> 12)));
1:172c290:                 buffer[offset++] = (byte) (0x80 | (0x3f & (charValue >> 6)));
1:172c290:                 buffer[offset++] = (byte) (0x80 | (0x3f & charValue));
1:172c290:             }
1:172c290:         }
1:172c290:         return offset;
1:172c290:     }
1:172c290: 
1:172c290:     public static String readUTF8(DataInput dataIn) throws IOException {
1:172c290:         int utflen = dataIn.readInt();
1:172c290:         if (utflen > -1) {
1:172c290:             byte bytearr[] = new byte[utflen];
1:172c290:             char chararr[] = new char[utflen];
1:172c290:             dataIn.readFully(bytearr, 0, utflen);
1:172c290:             return convertUTF8WithBuf(bytearr, chararr, 0, utflen);
1:d29ca2a:         } else {
1:d29ca2a:             return null;
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:172c290:     /**
1:172c290:      * From: http://svn.apache.org/repos/asf/harmony/enhanced/java/trunk/classlib/modules/luni/src/main/java/org/apache/harmony/luni/util/Util.java
1:172c290:      */
1:172c290:     public static String convertUTF8WithBuf(byte[] buf, char[] out, int offset,
1:172c290:                                             int utfSize) throws UTFDataFormatException {
1:172c290:         int count = 0, s = 0, a;
1:172c290:         while (count < utfSize) {
1:172c290:             if ((out[s] = (char) buf[offset + count++]) < '\u0080')
1:172c290:                 s++;
1:172c290:             else if (((a = out[s]) & 0xe0) == 0xc0) {
1:172c290:                 if (count >= utfSize)
1:172c290:                     throw new UTFDataFormatException();
1:172c290:                 int b = buf[offset + count++];
1:172c290:                 if ((b & 0xC0) != 0x80)
1:172c290:                     throw new UTFDataFormatException();
1:172c290:                 out[s++] = (char) (((a & 0x1F) << 6) | (b & 0x3F));
1:172c290:             } else if ((a & 0xf0) == 0xe0) {
1:172c290:                 if (count + 1 >= utfSize)
1:172c290:                     throw new UTFDataFormatException();
1:172c290:                 int b = buf[offset + count++];
1:172c290:                 int c = buf[offset + count++];
1:172c290:                 if (((b & 0xC0) != 0x80) || ((c & 0xC0) != 0x80))
1:172c290:                     throw new UTFDataFormatException();
1:172c290:                 out[s++] = (char) (((a & 0x0F) << 12) | ((b & 0x3F) << 6) | (c & 0x3F));
1:172c290:             } else {
1:172c290:                 throw new UTFDataFormatException();
1:172c290:             }
1:172c290:         }
1:172c290:         return new String(out, 0, s);
1:172c290:     }
1:172c290: 
1:f812e34:     public static String propertiesToString(Properties props) throws IOException {
1:f812e34:         String result = "";
1:f812e34:         if (props != null) {
1:f812e34:             DataByteArrayOutputStream dataOut = new DataByteArrayOutputStream();
1:f812e34:             props.store(dataOut, "");
1:f812e34:             result = new String(dataOut.getData(), 0, dataOut.size());
1:d36c0d4:             dataOut.close();
1:f812e34:         }
1:ae73f86:         return result;
1:f812e34:     }
1:f812e34: 
1:ae73f86:     public static Properties stringToProperties(String str) throws IOException {
1:ae73f86:         Properties result = new Properties();
1:f812e34:         if (str != null && str.length() > 0) {
1:ae73f86:             DataByteArrayInputStream dataIn = new DataByteArrayInputStream(str.getBytes());
1:ae73f86:             result.load(dataIn);
1:d36c0d4:             dataIn.close();
1:d29ca2a:         }
1:ae73f86:         return result;
1:d29ca2a:     }
1:d29ca2a: 
1:d618ab3:     public static String truncate64(String text) {
1:d618ab3:         if (text.length() > 63) {
1:d618ab3:             text = text.substring(0, 45) + "..." + text.substring(text.length() - 12);
1:d618ab3:         }
1:d618ab3:         return text;
1:d618ab3:     }
1:d29ca2a: }
============================================================================
author:Hiram Chirino
-------------------------------------------------------------------------------
commit:172c290
/////////////////////////////////////////////////////////////////////////
1:             long utfCount = countUTFBytes(text);
1:             dataOut.writeInt((int)utfCount);
1:             byte[] buffer = new byte[(int)utfCount];
1:             int len = writeUTFBytesToBuffer(text, (int) utfCount, buffer, 0);
1:             dataOut.write(buffer, 0, len);
1:             assert utfCount==len;
1:     /**
1:      * From: http://svn.apache.org/repos/asf/harmony/enhanced/java/trunk/classlib/modules/luni/src/main/java/java/io/DataOutputStream.java
1:      */
1:     public static long countUTFBytes(String str) {
1:         int utfCount = 0, length = str.length();
1:         for (int i = 0; i < length; i++) {
1:             int charValue = str.charAt(i);
1:             if (charValue > 0 && charValue <= 127) {
1:                 utfCount++;
1:             } else if (charValue <= 2047) {
1:                 utfCount += 2;
1:             } else {
1:                 utfCount += 3;
1:         }
1:         return utfCount;
1:     }
1: 
1:     /**
1:      * From: http://svn.apache.org/repos/asf/harmony/enhanced/java/trunk/classlib/modules/luni/src/main/java/java/io/DataOutputStream.java
1:      */
1:     public static int writeUTFBytesToBuffer(String str, long count,
1:                                      byte[] buffer, int offset) throws IOException {
1:         int length = str.length();
1:         for (int i = 0; i < length; i++) {
1:             int charValue = str.charAt(i);
1:             if (charValue > 0 && charValue <= 127) {
1:                 buffer[offset++] = (byte) charValue;
1:             } else if (charValue <= 2047) {
1:                 buffer[offset++] = (byte) (0xc0 | (0x1f & (charValue >> 6)));
1:                 buffer[offset++] = (byte) (0x80 | (0x3f & charValue));
1:             } else {
1:                 buffer[offset++] = (byte) (0xe0 | (0x0f & (charValue >> 12)));
1:                 buffer[offset++] = (byte) (0x80 | (0x3f & (charValue >> 6)));
1:                 buffer[offset++] = (byte) (0x80 | (0x3f & charValue));
1:             }
1:         }
1:         return offset;
1:     }
1: 
1:     public static String readUTF8(DataInput dataIn) throws IOException {
1:         int utflen = dataIn.readInt();
1:         if (utflen > -1) {
1:             byte bytearr[] = new byte[utflen];
1:             char chararr[] = new char[utflen];
1:             dataIn.readFully(bytearr, 0, utflen);
1:             return convertUTF8WithBuf(bytearr, chararr, 0, utflen);
1:     /**
1:      * From: http://svn.apache.org/repos/asf/harmony/enhanced/java/trunk/classlib/modules/luni/src/main/java/org/apache/harmony/luni/util/Util.java
1:      */
1:     public static String convertUTF8WithBuf(byte[] buf, char[] out, int offset,
1:                                             int utfSize) throws UTFDataFormatException {
1:         int count = 0, s = 0, a;
1:         while (count < utfSize) {
1:             if ((out[s] = (char) buf[offset + count++]) < '\u0080')
1:                 s++;
1:             else if (((a = out[s]) & 0xe0) == 0xc0) {
1:                 if (count >= utfSize)
1:                     throw new UTFDataFormatException();
1:                 int b = buf[offset + count++];
1:                 if ((b & 0xC0) != 0x80)
1:                     throw new UTFDataFormatException();
1:                 out[s++] = (char) (((a & 0x1F) << 6) | (b & 0x3F));
1:             } else if ((a & 0xf0) == 0xe0) {
1:                 if (count + 1 >= utfSize)
1:                     throw new UTFDataFormatException();
1:                 int b = buf[offset + count++];
1:                 int c = buf[offset + count++];
1:                 if (((b & 0xC0) != 0x80) || ((c & 0xC0) != 0x80))
1:                     throw new UTFDataFormatException();
1:                 out[s++] = (char) (((a & 0x0F) << 12) | ((b & 0x3F) << 6) | (c & 0x3F));
1:             } else {
1:                 throw new UTFDataFormatException();
1:             }
1:         }
1:         return new String(out, 0, s);
1:     }
1: 
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:8a6ebc2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private MarshallingSupport() {}
1:     public static void marshalPrimitiveMap(Map<String, Object> map, DataOutputStream out) throws IOException {
1:             for (String name : map.keySet()) {
/////////////////////////////////////////////////////////////////////////
1:             marshalPrimitiveMap((Map<String, Object>)value, out);
1:             marshalPrimitiveList((List<Object>)value, out);
commit:f3407fe
/////////////////////////////////////////////////////////////////////////
1:         return unmarshalPrimitiveMap(in, maxPropertySize, false);
/////////////////////////////////////////////////////////////////////////
1:     public static void marshalPrimitiveList(List<Object> list, DataOutputStream out) throws IOException {
commit:0704eda
/////////////////////////////////////////////////////////////////////////
1:     public static Map<String, Object> unmarshalPrimitiveMap(DataInputStream in, boolean force) throws IOException {
1:         return unmarshalPrimitiveMap(in, Integer.MAX_VALUE, force);
1:     }
1: 
1:     public static Map<String, Object> unmarshalPrimitiveMap(DataInputStream in, int maxPropertySize) throws IOException {
0:         return unmarshalPrimitiveMap(in, Integer.MAX_VALUE, false);
1:     }
1: 
1:     public static Map<String, Object> unmarshalPrimitiveMap(DataInputStream in, int maxPropertySize, boolean force) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:                 rc.put(name, unmarshalPrimitive(in, force));
/////////////////////////////////////////////////////////////////////////
1:         for (Object element : list) {
1:         return unmarshalPrimitiveList(in, false);
1:     }
1: 
1:     public static List<Object> unmarshalPrimitiveList(DataInputStream in, boolean force) throws IOException {
1:             answer.add(unmarshalPrimitive(in, force));
/////////////////////////////////////////////////////////////////////////
1:             value = unmarshalPrimitiveMap(in, true);
1:             value = unmarshalPrimitiveList(in, true);
commit:6f0a335
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             int length = in.readUnsignedShort();
1:             byte data[] = new byte[length];
1:             in.readFully(data);
0:             value = new UTF8Buffer(data);
0:             int length = in.readInt();
1:             byte data[] = new byte[length];
1:             in.readFully(data);
0:             value = new UTF8Buffer(data);
commit:543935b
/////////////////////////////////////////////////////////////////////////
1: import org.fusesource.hawtbuf.UTF8Buffer;
1: 
1:  *
1:  *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:             Object element = iter.next();
/////////////////////////////////////////////////////////////////////////
0:         case STRING_TYPE: {
0:             if (true) {
0:                 int length = in.readUnsignedShort();
0:                 byte data[] = new byte[length];
0:                 in.readFully(data);
0:                 value = new UTF8Buffer(data);
1:             } else {
1:                 value = in.readUTF();
1:             }
1:         }
1:         case BIG_STRING_TYPE: {
0:             if (true) {
0:                 int length = in.readInt();
0:                 byte data[] = new byte[length];
0:                 in.readFully(data);
0:                 value = new UTF8Buffer(data);
1:             } else {
1:                 value = readUTF8(in);
1:             }
1:         }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:3a6bbfe
/////////////////////////////////////////////////////////////////////////
0:                 rc.put(name, unmarshalPrimitive(in, true));
/////////////////////////////////////////////////////////////////////////
0:             answer.add(unmarshalPrimitive(in, true));
/////////////////////////////////////////////////////////////////////////
1:         return unmarshalPrimitive(in, false);
1:     }
1: 
1:     public static Object unmarshalPrimitive(DataInputStream in, boolean force) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:         case STRING_TYPE:
1:             if (force) {
0:                 value = in.readUTF();
1:             } else {
1:                 value = readUTF(in, in.readUnsignedShort());
1:             }
1:             if (force) {
0:                 value = readUTF8(in);
1:             } else {
1:                 value = readUTF(in, in.readInt());
1:             }
/////////////////////////////////////////////////////////////////////////
1:     public static UTF8Buffer readUTF(DataInputStream in, int length) throws IOException {
0:         byte data[] = new byte[length];
0:         in.readFully(data);
1:         return new UTF8Buffer(data);
1:     }
1: 
author:Gary Tully
-------------------------------------------------------------------------------
commit:ec0a0a3
/////////////////////////////////////////////////////////////////////////
1:         } else  if (value.getClass() == UTF8Buffer.class) {
1:             marshalString(out, value.toString());
commit:d618ab3
/////////////////////////////////////////////////////////////////////////
1:     public static String truncate64(String text) {
1:         if (text.length() > 63) {
1:             text = text.substring(0, 45) + "..." + text.substring(text.length() - 12);
1:         }
1:         return text;
1:     }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:9a8f6e4
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
0:  * 
commit:6084b60
/////////////////////////////////////////////////////////////////////////
1:         case NULL:
1:             value = null;
1:             break;
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
1: public final class MarshallingSupport {
/////////////////////////////////////////////////////////////////////////
0:     private MarshallingSupport() {
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:     public static Map<String, Object> unmarshalPrimitiveMap(DataInputStream in) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:     public static Map<String, Object> unmarshalPrimitiveMap(DataInputStream in, int maxPropertySize) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:             Map<String, Object> rc = new HashMap<String, Object>(size);
/////////////////////////////////////////////////////////////////////////
1:     public static List<Object> unmarshalPrimitiveList(DataInputStream in) throws IOException {
1:         List<Object> answer = new ArrayList<Object>(size);
/////////////////////////////////////////////////////////////////////////
1:             value = Byte.valueOf(in.readByte());
/////////////////////////////////////////////////////////////////////////
0:             int c = 0;
0:             int count = 0;
/////////////////////////////////////////////////////////////////////////
0:             int c;
0:             int char2;
0:             int char3;
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:     public static void marshalPrimitiveMap(Map map, DataOutputStream out) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:     public static Map unmarshalPrimitiveMap(DataInputStream in) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:     public static Map unmarshalPrimitiveMap(DataInputStream in, int maxPropertySize) throws IOException {
1:         if (size > maxPropertySize) {
/////////////////////////////////////////////////////////////////////////
1:     public static void marshalPrimitive(DataOutputStream out, Object value) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     public static Object unmarshalPrimitive(DataInputStream in) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     public static void writeUTF8(DataOutput dataOut, String text) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:     public static String readUTF8(DataInput dataIn) throws IOException {
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             marshalByteArray(out, (byte[])value);
/////////////////////////////////////////////////////////////////////////
1:         byte type = in.readByte();
1:         switch (type) {
0:             value = Byte.valueOf(type);
/////////////////////////////////////////////////////////////////////////
1:         default:
1:             throw new IOException("Unknown primitive type: " + type);
/////////////////////////////////////////////////////////////////////////
0:             // Sun code
0:             // Sun code
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1:  * The fixed version of the UTF8 encoding function. Some older JVM's UTF8
1:  * encoding function breaks when handling large strings.
1:     public static final byte NULL = 0;
1:     public static final byte BOOLEAN_TYPE = 1;
1:     public static final byte BYTE_TYPE = 2;
1:     public static final byte CHAR_TYPE = 3;
1:     public static final byte SHORT_TYPE = 4;
1:     public static final byte INTEGER_TYPE = 5;
1:     public static final byte LONG_TYPE = 6;
1:     public static final byte DOUBLE_TYPE = 7;
1:     public static final byte FLOAT_TYPE = 8;
1:     public static final byte STRING_TYPE = 9;
1:     public static final byte BYTE_ARRAY_TYPE = 10;
1:     public static final byte MAP_TYPE = 11;
1:     public static final byte LIST_TYPE = 12;
1:     public static final byte BIG_STRING_TYPE = 13;
1: 
0:     static public void marshalPrimitiveMap(Map map, DataOutputStream out) throws IOException {
1:         if (map == null) {
0:                 String name = (String)iter.next();
/////////////////////////////////////////////////////////////////////////
1:         return unmarshalPrimitiveMap(in, Integer.MAX_VALUE);
1:     }
1:      * @throws IOException
0:     public static Map unmarshalPrimitiveMap(DataInputStream in, int max_property_size) throws IOException {
0:         if (size > max_property_size) {
1:             throw new IOException("Primitive map is larger than the allowed size: " + size);
1:         if (size < 0) {
1:             for (int i = 0; i < size; i++) {
1: 
0:             Object element = (Object)iter.next();
/////////////////////////////////////////////////////////////////////////
1:         if (value == null) {
1:         } else if (value.getClass() == Boolean.class) {
1:         } else if (value.getClass() == Byte.class) {
1:         } else if (value.getClass() == Character.class) {
1:         } else if (value.getClass() == Short.class) {
1:         } else if (value.getClass() == Integer.class) {
1:         } else if (value.getClass() == Long.class) {
1:         } else if (value.getClass() == Float.class) {
1:         } else if (value.getClass() == Double.class) {
1:         } else if (value.getClass() == byte[].class) {
1:         } else if (value.getClass() == String.class) {
1:         } else if (value instanceof Map) {
0:             marshalPrimitiveMap((Map)value, out);
1:         } else if (value instanceof List) {
0:             marshalPrimitiveList((List)value, out);
1:             throw new IOException("Object is not a primitive: " + value);
1:         Object value = null;
0:         switch (in.readByte()) {
/////////////////////////////////////////////////////////////////////////
1:         if (s.length() < Short.MAX_VALUE / 4) {
/////////////////////////////////////////////////////////////////////////
0:             // TODO diff: Sun code - removed
0:             byte[] bytearr = new byte[utflen + 4]; // TODO diff: Sun code
0:             bytearr[count++] = (byte)((utflen >>> 24) & 0xFF); // TODO diff:
0:                                                                 // Sun code
0:             bytearr[count++] = (byte)((utflen >>> 16) & 0xFF); // TODO diff:
0:                                                                 // Sun code
0:             bytearr[count++] = (byte)((utflen >>> 8) & 0xFF);
0:             bytearr[count++] = (byte)((utflen >>> 0) & 0xFF);
0:                     bytearr[count++] = (byte)c;
0:                     bytearr[count++] = (byte)(0xE0 | ((c >> 12) & 0x0F));
0:                     bytearr[count++] = (byte)(0x80 | ((c >> 6) & 0x3F));
0:                     bytearr[count++] = (byte)(0x80 | ((c >> 0) & 0x3F));
0:                     bytearr[count++] = (byte)(0xC0 | ((c >> 6) & 0x1F));
0:                     bytearr[count++] = (byte)(0x80 | ((c >> 0) & 0x3F));
/////////////////////////////////////////////////////////////////////////
0:         int utflen = dataIn.readInt(); // TODO diff: Sun code
/////////////////////////////////////////////////////////////////////////
0:                 case 0:
0:                 case 1:
0:                 case 2:
0:                 case 3:
0:                 case 4:
0:                 case 5:
0:                 case 6:
0:                 case 7:
0:                     /* 0xxxxxxx */
0:                     count++;
0:                     str.append((char)c);
1:                     break;
0:                 case 12:
0:                 case 13:
0:                     /* 110x xxxx 10xx xxxx */
0:                     count += 2;
0:                     if (count > utflen) {
1:                     }
0:                     char2 = bytearr[count - 1];
0:                     if ((char2 & 0xC0) != 0x80) {
0:                         throw new UTFDataFormatException();
1:                     }
0:                     str.append((char)(((c & 0x1F) << 6) | (char2 & 0x3F)));
1:                     break;
0:                 case 14:
0:                     /* 1110 xxxx 10xx xxxx 10xx xxxx */
0:                     count += 3;
0:                     if (count > utflen) {
0:                         throw new UTFDataFormatException();
1:                     }
0:                     char2 = bytearr[count - 2]; // TODO diff: Sun code
0:                     char3 = bytearr[count - 1]; // TODO diff: Sun code
0:                     if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80)) {
0:                         throw new UTFDataFormatException();
1:                     }
0:                     str.append((char)(((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | ((char3 & 0x3F) << 0)));
1:                     break;
0:                 default:
0:                     /* 10xx xxxx, 1111 xxxx */
0:                     throw new UTFDataFormatException();
/////////////////////////////////////////////////////////////////////////
1: 
1:     public static String propertiesToString(Properties props) throws IOException {
1:         String result = "";
1:         if (props != null) {
1:             DataByteArrayOutputStream dataOut = new DataByteArrayOutputStream();
1:             props.store(dataOut, "");
1:             result = new String(dataOut.getData(), 0, dataOut.size());
1: 
1:         if (str != null && str.length() > 0) {
/////////////////////////////////////////////////////////////////////////
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:9befb11
/////////////////////////////////////////////////////////////////////////
0:     public static final byte BIG_STRING_TYPE         = 13;
/////////////////////////////////////////////////////////////////////////
0:             String s = (String)value;
1:             
1:             // If it's too big, out.writeUTF may not able able to write it out.
0:             if( s.length() < Short.MAX_VALUE/4 ) {
1:                 out.writeByte(STRING_TYPE);
0:                 out.writeUTF((String)value);
1:             } else {
1:                 out.writeByte(BIG_STRING_TYPE);
1:                 writeUTF8(out, s);
1:             }
1:             
/////////////////////////////////////////////////////////////////////////
0:         case BIG_STRING_TYPE:
0:             value = readUTF8(in);
1:             break;
commit:6583ef1
/////////////////////////////////////////////////////////////////////////
0:     static public HashMap unmarshalPrimitiveMap(DataInputStream in) throws IOException {
0: 		return unmarshalPrimitiveMap(in, Integer.MAX_VALUE);
1: 	}
1: 
1:      * @throws IOException 
0: 	public static HashMap unmarshalPrimitiveMap(DataInputStream in, int max_property_size) throws IOException {
0:         if( size > max_property_size ) {
0:         	throw new IOException("Primitive map is larger than the allowed size: "+size);
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.util;
1: 
1: import java.io.DataInput;
1: import java.io.DataInputStream;
1: import java.io.DataOutput;
1: import java.io.DataOutputStream;
1: import java.io.IOException;
1: import java.io.UTFDataFormatException;
1: import java.util.HashMap;
0: import java.util.Iterator;
1: 
1: /**
0:  * 
0:  * 
0:  * The fixed version of the UTF8 encoding function.  Some older JVM's UTF8 encoding function
0:  * breaks when handling large strings. 
0:  * 
0:  * @version $Revision$
1:  */
0: public class MarshallingSupport {
1:    
0:     public static final byte NULL                    = 0;
0:     public static final byte BOOLEAN_TYPE            = 1;
0:     public static final byte BYTE_TYPE               = 2;
0:     public static final byte CHAR_TYPE               = 3;
0:     public static final byte SHORT_TYPE              = 4;
0:     public static final byte INTEGER_TYPE            = 5;
0:     public static final byte LONG_TYPE               = 6;
0:     public static final byte DOUBLE_TYPE             = 7;
0:     public static final byte FLOAT_TYPE              = 8;
0:     public static final byte STRING_TYPE             = 9;
0:     public static final byte BYTE_ARRAY_TYPE         = 10;
1: 
0:     static  public void marshalPrimitiveMap(HashMap map, DataOutputStream out) throws IOException {
0:         if( map == null ) {
1:             out.writeInt(-1);
1:         } else {
1:             out.writeInt(map.size());
0:             for (Iterator iter = map.keySet().iterator(); iter.hasNext();) {
0:                 String name = (String) iter.next();
1:                 out.writeUTF(name);
1:                 Object value = map.get(name);
1:                 marshalPrimitive(out, value);
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * @param in
1:      * @return
0:      * @throws IOException
1:      */
0:     static public HashMap unmarshalPrimitiveMap(DataInputStream in) throws IOException {
1:         int size = in.readInt();
0:         if( size < 0 ) {
1:             return null;
1:         } else {
0:             HashMap rc = new HashMap(size);
0:             for(int i=0; i < size; i++) {
1:                 String name = in.readUTF();
0:                 rc.put(name, unmarshalPrimitive(in));
1:             }
1:             return rc;
1:         }
1:         
1:     }
1: 
0:     static public void marshalPrimitive(DataOutputStream out, Object value) throws IOException {
0:         if( value == null ) {
1:             out.writeByte(NULL);
0:         } else if( value.getClass() == Boolean.class ) {
1:             out.writeByte(BOOLEAN_TYPE);
0:             out.writeBoolean(((Boolean)value).booleanValue());
0:         } else if( value.getClass() == Byte.class ) {
1:             out.writeByte(BYTE_TYPE);
0:             out.writeByte(((Byte)value).byteValue());
0:         } else if( value.getClass() == Character.class ) {
1:             out.writeByte(CHAR_TYPE);
0:             out.writeChar(((Character)value).charValue());
0:         } else if( value.getClass() == Short.class ) {
1:             out.writeByte(SHORT_TYPE);
0:             out.writeShort(((Short)value).shortValue());
0:         } else if( value.getClass() == Integer.class ) {
1:             out.writeByte(INTEGER_TYPE);
0:             out.writeInt(((Integer)value).intValue());
0:         } else if( value.getClass() == Long.class ) {
1:             out.writeByte(LONG_TYPE);
0:             out.writeLong(((Long)value).longValue());
0:         } else if( value.getClass() == Float.class ) {
1:             out.writeByte(FLOAT_TYPE);
0:             out.writeFloat(((Float)value).floatValue());
0:         } else if( value.getClass() == Double.class ) {
1:             out.writeByte(DOUBLE_TYPE);
0:             out.writeDouble(((Double)value).doubleValue());
0:         } else if( value.getClass() == byte[].class ) {
1:             out.writeByte(BYTE_ARRAY_TYPE);
0:             out.writeInt(((byte[])value).length);
0:             out.write(((byte[])value));
0:         } else if( value.getClass() == String.class ) {
0:             out.writeByte(STRING_TYPE);
0:             out.writeUTF((String)value);
1:         } else {
0:             throw new IOException("Object is not a primitive: "+value);
1:         }
1:     }
1: 
0:     static public Object unmarshalPrimitive(DataInputStream in) throws IOException {
0:         Object value=null;
0:         switch( in.readByte() ) {
1:         case BYTE_TYPE:
0:             value = new Byte(in.readByte());
1:             break;
1:         case BOOLEAN_TYPE:
1:             value = in.readBoolean() ? Boolean.TRUE : Boolean.FALSE;
1:             break;
1:         case CHAR_TYPE:
0:             value = new Character(in.readChar());
1:             break;
1:         case SHORT_TYPE:
0:             value = new Short(in.readShort());
1:             break;
1:         case INTEGER_TYPE:
0:             value = new Integer(in.readInt());
1:             break;
1:         case LONG_TYPE:
0:             value = new Long(in.readLong());
1:             break;
1:         case FLOAT_TYPE:
1:             value = new Float(in.readFloat());
1:             break;
1:         case DOUBLE_TYPE:
1:             value = new Double(in.readDouble());
1:             break;
1:         case BYTE_ARRAY_TYPE:
1:             value = new byte[in.readInt()];
1:             in.readFully((byte[])value);
1:             break;
0:         case STRING_TYPE:
0:             value = in.readUTF();
1:             break;
1:         }
1:         return value;
1:     }
1: 
0:     static public void writeUTF8(DataOutput dataOut, String text) throws IOException {
1:         if (text != null) {
0:             int strlen = text.length();
0:             int utflen = 0;
0:             char[] charr = new char[strlen];
0:             int c, count = 0;
1: 
0:             text.getChars(0, strlen, charr, 0);
1: 
0:             for (int i = 0; i < strlen; i++) {
0:                 c = charr[i];
0:                 if ((c >= 0x0001) && (c <= 0x007F)) {
0:                     utflen++;
0:                 } else if (c > 0x07FF) {
0:                     utflen += 3;
1:                 } else {
0:                     utflen += 2;
1:                 }
1:             }
0:             //TODO diff: Sun code - removed
0:             byte[] bytearr = new byte[utflen + 4]; //TODO diff: Sun code
0:             bytearr[count++] = (byte) ((utflen >>> 24) & 0xFF); //TODO diff: Sun code
0:             bytearr[count++] = (byte) ((utflen >>> 16) & 0xFF); //TODO diff: Sun code
0:             bytearr[count++] = (byte) ((utflen >>> 8) & 0xFF);
0:             bytearr[count++] = (byte) ((utflen >>> 0) & 0xFF);
0:             for (int i = 0; i < strlen; i++) {
0:                 c = charr[i];
0:                 if ((c >= 0x0001) && (c <= 0x007F)) {
0:                     bytearr[count++] = (byte) c;
0:                 } else if (c > 0x07FF) {
0:                     bytearr[count++] = (byte) (0xE0 | ((c >> 12) & 0x0F));
0:                     bytearr[count++] = (byte) (0x80 | ((c >> 6) & 0x3F));
0:                     bytearr[count++] = (byte) (0x80 | ((c >> 0) & 0x3F));
1:                 } else {
0:                     bytearr[count++] = (byte) (0xC0 | ((c >> 6) & 0x1F));
0:                     bytearr[count++] = (byte) (0x80 | ((c >> 0) & 0x3F));
1:                 }
1:             }
0:             dataOut.write(bytearr);
1: 
1:         } else {
1:             dataOut.writeInt(-1);
1:         }
1:     }
1: 
0:     static public String readUTF8(DataInput dataIn) throws IOException {
0:         int utflen = dataIn.readInt(); //TODO diff: Sun code
0:         if (utflen > -1) {
0:             StringBuffer str = new StringBuffer(utflen);
0:             byte bytearr[] = new byte[utflen];
0:             int c, char2, char3;
0:             int count = 0;
1: 
0:             dataIn.readFully(bytearr, 0, utflen);
1: 
0:             while (count < utflen) {
0:                 c = bytearr[count] & 0xff;
0:                 switch (c >> 4) {
0:                     case 0:
0:                     case 1:
0:                     case 2:
0:                     case 3:
0:                     case 4:
0:                     case 5:
0:                     case 6:
0:                     case 7:
0:                         /* 0xxxxxxx */
0:                         count++;
0:                         str.append((char) c);
1:                         break;
0:                     case 12:
0:                     case 13:
0:                         /* 110x xxxx 10xx xxxx */
0:                         count += 2;
0:                         if (count > utflen) {
0:                             throw new UTFDataFormatException();
1:                         }
0:                         char2 = bytearr[count - 1];
0:                         if ((char2 & 0xC0) != 0x80) {
0:                             throw new UTFDataFormatException();
1:                         }
0:                         str.append((char) (((c & 0x1F) << 6) | (char2 & 0x3F)));
1:                         break;
0:                     case 14:
0:                         /* 1110 xxxx 10xx xxxx 10xx xxxx */
0:                         count += 3;
0:                         if (count > utflen) {
0:                             throw new UTFDataFormatException();
1:                         }
0:                         char2 = bytearr[count - 2]; //TODO diff: Sun code
0:                         char3 = bytearr[count - 1]; //TODO diff: Sun code
0:                         if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80)) {
0:                             throw new UTFDataFormatException();
1:                         }
0:                         str.append((char) (((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | ((char3 & 0x3F) << 0)));
1:                         break;
0:                     default :
0:                         /* 10xx xxxx, 1111 xxxx */
0:                         throw new UTFDataFormatException();
1:                 }
1:             }
0:             // The number of chars produced may be less than utflen
0:             return new String(str);
1:         } else {
1:             return null;
1:         }
1:     }
1: 
1: }
author:Robert Davies
-------------------------------------------------------------------------------
commit:d36c0d4
/////////////////////////////////////////////////////////////////////////
0:             value = Byte.valueOf(in.readByte());
1:             value = Character.valueOf(in.readChar());
1:             value = Short.valueOf(in.readShort());
1:             value = Integer.valueOf(in.readInt());
1:             value = Long.valueOf(in.readLong());
/////////////////////////////////////////////////////////////////////////
1:             dataOut.close();
/////////////////////////////////////////////////////////////////////////
1:             dataIn.close();
commit:ae73f86
/////////////////////////////////////////////////////////////////////////
0: import java.io.OutputStreamWriter;
0: import java.io.StringWriter;
1: import java.util.Properties;
/////////////////////////////////////////////////////////////////////////
1:     
0:     public static String propertiesToString(Properties props) throws IOException{
0:         String result="";
0:         if(props!=null){
0:             DataByteArrayOutputStream dataOut=new DataByteArrayOutputStream();
0:             props.store(dataOut,"");
0:             result=new String(dataOut.getData(),0,dataOut.size());
1:         }
1:         return result;
1:     }
1:     
1:     public static Properties stringToProperties(String str) throws IOException {
1:         Properties result = new Properties();
0:         if (str != null && str.length() > 0 ) {
1:             DataByteArrayInputStream dataIn = new DataByteArrayInputStream(str.getBytes());
1:             result.load(dataIn);
1:         }
1:         return result;
1:     }
author:Adrian T. Co
-------------------------------------------------------------------------------
commit:09ebb72
/////////////////////////////////////////////////////////////////////////
1:             marshalNull(out);
1:             marshalBoolean(out, ((Boolean)value).booleanValue());
1:             marshalByte(out, ((Byte)value).byteValue());
1:             marshalChar(out, ((Character)value).charValue());
1:             marshalShort(out, ((Short)value).shortValue());
1:             marshalInt(out, ((Integer)value).intValue());
1:             marshalLong(out, ((Long)value).longValue());
1:             marshalFloat(out, ((Float)value).floatValue());
1:             marshalDouble(out, ((Double)value).doubleValue());
0:             marshalByteArray(out, ((byte[])value));
/////////////////////////////////////////////////////////////////////////
1:     public static void marshalNull(DataOutputStream out) throws IOException {
0:         out.writeByte(NULL);
0:     }
1: 
1:     public static void marshalBoolean(DataOutputStream out, boolean value) throws IOException {
0:         out.writeByte(BOOLEAN_TYPE);
1:         out.writeBoolean(value);
0:     }
1: 
1:     public static void marshalByte(DataOutputStream out, byte value) throws IOException {
0:         out.writeByte(BYTE_TYPE);
1:         out.writeByte(value);
0:     }
1: 
1:     public static void marshalChar(DataOutputStream out, char value) throws IOException {
0:         out.writeByte(CHAR_TYPE);
1:         out.writeChar(value);
0:     }
1: 
1:     public static void marshalShort(DataOutputStream out, short value) throws IOException {
0:         out.writeByte(SHORT_TYPE);
1:         out.writeShort(value);
0:     }
1: 
1:     public static void marshalInt(DataOutputStream out, int value) throws IOException {
0:         out.writeByte(INTEGER_TYPE);
1:         out.writeInt(value);
0:     }
1: 
1:     public static void marshalLong(DataOutputStream out, long value) throws IOException {
0:         out.writeByte(LONG_TYPE);
1:         out.writeLong(value);
0:     }
1: 
1:     public static void marshalFloat(DataOutputStream out, float value) throws IOException {
0:         out.writeByte(FLOAT_TYPE);
1:         out.writeFloat(value);
0:     }
1: 
1:     public static void marshalDouble(DataOutputStream out, double value) throws IOException {
0:         out.writeByte(DOUBLE_TYPE);
1:         out.writeDouble(value);
0:     }
1: 
1:     public static void marshalByteArray(DataOutputStream out, byte[] value) throws IOException {
1:         marshalByteArray(out, value, 0, value.length);
0:     }
1: 
1:     public static void marshalByteArray(DataOutputStream out, byte[] value, int offset, int length) throws IOException {
0:         out.writeByte(BYTE_ARRAY_TYPE);
1:         out.writeInt(length);
1:         out.write(value, offset, length);
0:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
author:James Strachan
-------------------------------------------------------------------------------
commit:0028272
/////////////////////////////////////////////////////////////////////////
1:             marshalString(out, (String)value);
/////////////////////////////////////////////////////////////////////////
1:     public static void marshalString(DataOutputStream out, String s) throws IOException {
0:         // If it's too big, out.writeUTF may not able able to write it out.
0:         if( s.length() < Short.MAX_VALUE/4 ) {
0:             out.writeByte(STRING_TYPE);
1:             out.writeUTF(s);
0:         } else {
0:             out.writeByte(BIG_STRING_TYPE);
0:             writeUTF8(out, s);
0:         }
0:     }
0: 
0: 
commit:ca067a6
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.List;
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
0:     public static final byte MAP_TYPE                = 11;
0:     public static final byte LIST_TYPE               = 12;
0:     static  public void marshalPrimitiveMap(Map map, DataOutputStream out) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:     static public Map unmarshalPrimitiveMap(DataInputStream in) throws IOException {
/////////////////////////////////////////////////////////////////////////
0: 	public static Map unmarshalPrimitiveMap(DataInputStream in, int max_property_size) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:     public static void marshalPrimitiveList(List list, DataOutputStream out) throws IOException {
1:         out.writeInt(list.size());
0:         for (Iterator iter = list.iterator(); iter.hasNext();) {
0:             Object element = (Object) iter.next();
1:             marshalPrimitive(out, element);
0:         }
0:     }
0: 
0:     public static List unmarshalPrimitiveList(DataInputStream in) throws IOException {
1:         int size = in.readInt();
0:         List answer = new ArrayList(size);
1:         while (size-- > 0) {
0:             answer.add(unmarshalPrimitive(in));
0:         }
1:         return answer;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         } else if( value instanceof Map) {
1:             out.writeByte(MAP_TYPE);
0:             marshalPrimitiveMap((Map) value, out);
0:         } else if( value instanceof List) {
1:             out.writeByte(LIST_TYPE);
0:             marshalPrimitiveList((List) value, out);
0: 
/////////////////////////////////////////////////////////////////////////
1:         case MAP_TYPE:
0:             value = unmarshalPrimitiveMap(in);
0:             break;
1:         case LIST_TYPE:
0:             value = unmarshalPrimitiveList(in);
0:             break;
============================================================================