1:82a5839: /*
1:82a5839:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:82a5839:  * contributor license agreements.  See the NOTICE file distributed with
1:82a5839:  * this work for additional information regarding copyright ownership.
1:82a5839:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:82a5839:  * (the "License"); you may not use this file except in compliance with
1:82a5839:  * the License.  You may obtain a copy of the License at
1:82a5839:  *
1:82a5839:  *      http://www.apache.org/licenses/LICENSE-2.0
1:82a5839:  *
1:82a5839:  * Unless required by applicable law or agreed to in writing, software
1:82a5839:  * distributed under the License is distributed on an "AS IS" BASIS,
1:82a5839:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:82a5839:  * See the License for the specific language governing permissions and
1:82a5839:  * limitations under the License.
1:82a5839:  */
1:82a5839: package org.apache.activemq.transport.amqp.client.util;
1:82a5839: 
1:82a5839: import java.beans.BeanInfo;
1:82a5839: import java.beans.Introspector;
1:82a5839: import java.beans.PropertyDescriptor;
1:82a5839: import java.io.UnsupportedEncodingException;
1:82a5839: import java.lang.reflect.Method;
1:82a5839: import java.net.URI;
1:82a5839: import java.net.URISyntaxException;
1:82a5839: import java.net.URL;
1:82a5839: import java.net.URLDecoder;
1:82a5839: import java.net.URLEncoder;
1:82a5839: import java.util.Collections;
1:82a5839: import java.util.HashMap;
1:82a5839: import java.util.Iterator;
1:82a5839: import java.util.LinkedHashMap;
1:82a5839: import java.util.Map;
1:82a5839: import java.util.Map.Entry;
1:82a5839: import java.util.Properties;
1:82a5839: 
1:82a5839: import javax.net.ssl.SSLContext;
1:82a5839: 
1:82a5839: /**
1:82a5839:  * Utilities for properties
1:82a5839:  */
1:82a5839: public class PropertyUtil {
1:82a5839: 
1:82a5839:     /**
1:82a5839:      * Creates a URI from the original URI and the given parameters.
1:82a5839:      *
1:82a5839:      * @param originalURI
1:82a5839:      *        The URI whose current parameters are removed and replaced with the given remainder value.
1:82a5839:      * @param params
1:82a5839:      *        The URI params that should be used to replace the current ones in the target.
1:82a5839:      *
1:82a5839:      * @return a new URI that matches the original one but has its query options replaced with
1:82a5839:      *         the given ones.
1:82a5839:      *
1:82a5839:      * @throws URISyntaxException if the given URI is invalid.
1:82a5839:      */
1:82a5839:     public static URI replaceQuery(URI originalURI, Map<String, String> params) throws URISyntaxException {
1:82a5839:         String s = createQueryString(params);
1:82a5839:         if (s.length() == 0) {
1:82a5839:             s = null;
1:82a5839:         }
1:82a5839:         return replaceQuery(originalURI, s);
1:82a5839:     }
1:82a5839: 
1:82a5839:     /**
1:82a5839:      * Creates a URI with the given query, removing an previous query value from the given URI.
1:82a5839:      *
1:82a5839:      * @param uri
1:82a5839:      *        The source URI whose existing query is replaced with the newly supplied one.
1:82a5839:      * @param query
1:82a5839:      *        The new URI query string that should be appended to the given URI.
1:82a5839:      *
1:82a5839:      * @return a new URI that is a combination of the original URI and the given query string.
1:82a5839:      *
1:82a5839:      * @throws URISyntaxException if the given URI is invalid.
1:82a5839:      */
1:82a5839:     public static URI replaceQuery(URI uri, String query) throws URISyntaxException {
1:82a5839:         String schemeSpecificPart = uri.getRawSchemeSpecificPart();
1:82a5839:         // strip existing query if any
1:82a5839:         int questionMark = schemeSpecificPart.lastIndexOf("?");
1:82a5839:         // make sure question mark is not within parentheses
1:82a5839:         if (questionMark < schemeSpecificPart.lastIndexOf(")")) {
1:82a5839:             questionMark = -1;
1:82a5839:         }
1:82a5839:         if (questionMark > 0) {
1:82a5839:             schemeSpecificPart = schemeSpecificPart.substring(0, questionMark);
1:82a5839:         }
1:82a5839:         if (query != null && query.length() > 0) {
1:82a5839:             schemeSpecificPart += "?" + query;
1:82a5839:         }
1:82a5839:         return new URI(uri.getScheme(), schemeSpecificPart, uri.getFragment());
1:82a5839:     }
1:82a5839: 
1:82a5839:     /**
1:82a5839:      * Creates a URI with the given query, removing an previous query value from the given URI.
1:82a5839:      *
1:82a5839:      * @param uri
1:82a5839:      *        The source URI whose existing query is replaced with the newly supplied one.
1:82a5839:      *
1:82a5839:      * @return a new URI that is a combination of the original URI and the given query string.
1:82a5839:      *
1:82a5839:      * @throws URISyntaxException if the given URI is invalid.
1:82a5839:      */
1:82a5839:     public static URI eraseQuery(URI uri) throws URISyntaxException {
1:82a5839:         return replaceQuery(uri, (String) null);
1:82a5839:     }
1:82a5839: 
1:82a5839:     /**
1:82a5839:      * Given a key / value mapping, create and return a URI formatted query string that is valid
1:82a5839:      * and can be appended to a URI.
1:82a5839:      *
1:82a5839:      * @param options
1:82a5839:      *        The Mapping that will create the new Query string.
1:82a5839:      *
1:82a5839:      * @return a URI formatted query string.
1:82a5839:      *
1:82a5839:      * @throws URISyntaxException if the given URI is invalid.
1:82a5839:      */
1:82a5839:     public static String createQueryString(Map<String, ? extends Object> options) throws URISyntaxException {
1:82a5839:         try {
1:82a5839:             if (options.size() > 0) {
1:82a5839:                 StringBuffer rc = new StringBuffer();
1:82a5839:                 boolean first = true;
1:82a5839:                 for (Entry<String, ? extends Object> entry : options.entrySet()) {
1:82a5839:                     if (first) {
1:82a5839:                         first = false;
1:82a5839:                     } else {
1:82a5839:                         rc.append("&");
1:82a5839:                     }
1:82a5839:                     rc.append(URLEncoder.encode(entry.getKey(), "UTF-8"));
1:82a5839:                     rc.append("=");
1:82a5839:                     rc.append(URLEncoder.encode((String) entry.getValue(), "UTF-8"));
1:82a5839:                 }
1:82a5839:                 return rc.toString();
1:82a5839:             } else {
1:82a5839:                 return "";
1:82a5839:             }
1:82a5839:         } catch (UnsupportedEncodingException e) {
1:82a5839:             throw (URISyntaxException) new URISyntaxException(e.toString(), "Invalid encoding").initCause(e);
1:82a5839:         }
1:82a5839:     }
1:82a5839: 
1:82a5839:     /**
1:82a5839:      * Get properties from a URI and return them in a new {@code Map<String, String>} instance.
1:82a5839:      *
1:82a5839:      * If the URI is null or the query string of the URI is null an empty Map is returned.
1:82a5839:      *
1:82a5839:      * @param uri
1:82a5839:      *        the URI whose parameters are to be parsed.
1:82a5839:      *
1:82a5839:      * @return <Code>Map</Code> of properties
1:82a5839:      *
1:82a5839:      * @throws Exception if an error occurs while parsing the query options.
1:82a5839:      */
1:82a5839:     public static Map<String, String> parseParameters(URI uri) throws Exception {
1:82a5839:         if (uri == null || uri.getQuery() == null) {
1:82a5839:             return Collections.emptyMap();
1:82a5839:         }
1:82a5839: 
1:82a5839:         return parseQuery(stripPrefix(uri.getQuery(), "?"));
1:82a5839:     }
1:82a5839: 
1:82a5839:     /**
1:82a5839:      * Parse properties from a named resource -eg. a URI or a simple name e.g.
1:82a5839:      * {@literal foo?name="fred"&size=2}
1:82a5839:      *
1:82a5839:      * @param uri
1:82a5839:      *        the URI whose parameters are to be parsed.
1:82a5839:      *
1:82a5839:      * @return <Code>Map</Code> of properties
1:82a5839:      *
1:82a5839:      * @throws Exception if an error occurs while parsing the query options.
1:82a5839:      */
1:82a5839:     public static Map<String, String> parseParameters(String uri) throws Exception {
1:82a5839:         if (uri == null) {
1:82a5839:             return Collections.emptyMap();
1:82a5839:         }
1:82a5839: 
1:82a5839:         return parseQuery(stripUpto(uri, '?'));
1:82a5839:     }
1:82a5839: 
1:82a5839:     /**
1:82a5839:      * Get properties from a URI query string.
1:82a5839:      *
1:82a5839:      * @param queryString
1:82a5839:      *        the string value returned from a call to the URI class getQuery method.
1:82a5839:      *
1:82a5839:      * @return <Code>Map</Code> of properties from the parsed string.
1:82a5839:      *
1:82a5839:      * @throws Exception if an error occurs while parsing the query options.
1:82a5839:      */
1:82a5839:     public static Map<String, String> parseQuery(String queryString) throws Exception {
1:82a5839:         if (queryString != null && !queryString.isEmpty()) {
1:82a5839:             Map<String, String> rc = new HashMap<String, String>();
1:82a5839:             String[] parameters = queryString.split("&");
1:82a5839:             for (int i = 0; i < parameters.length; i++) {
1:82a5839:                 int p = parameters[i].indexOf("=");
1:82a5839:                 if (p >= 0) {
1:82a5839:                     String name = URLDecoder.decode(parameters[i].substring(0, p), "UTF-8");
1:82a5839:                     String value = URLDecoder.decode(parameters[i].substring(p + 1), "UTF-8");
1:82a5839:                     rc.put(name, value);
1:82a5839:                 } else {
1:82a5839:                     rc.put(parameters[i], null);
1:82a5839:                 }
1:82a5839:             }
1:82a5839:             return rc;
1:82a5839:         }
1:82a5839: 
1:82a5839:         return Collections.emptyMap();
1:82a5839:     }
1:82a5839: 
1:82a5839:     /**
1:82a5839:      * Given a map of properties, filter out only those prefixed with the given value, the
1:82a5839:      * values filtered are returned in a new Map instance.
1:82a5839:      *
1:82a5839:      * @param properties
1:82a5839:      *        The map of properties to filter.
1:82a5839:      * @param optionPrefix
1:82a5839:      *        The prefix value to use when filtering.
1:82a5839:      *
1:82a5839:      * @return a filter map with only values that match the given prefix.
1:82a5839:      */
1:82a5839:     public static Map<String, String> filterProperties(Map<String, String> properties, String optionPrefix) {
1:82a5839:         if (properties == null) {
1:82a5839:             throw new IllegalArgumentException("The given properties object was null.");
1:82a5839:         }
1:82a5839: 
1:82a5839:         HashMap<String, String> rc = new HashMap<String, String>(properties.size());
1:82a5839: 
1:82a5839:         for (Iterator<Entry<String, String>> iter = properties.entrySet().iterator(); iter.hasNext();) {
1:82a5839:             Entry<String, String> entry = iter.next();
1:82a5839:             if (entry.getKey().startsWith(optionPrefix)) {
1:82a5839:                 String name = entry.getKey().substring(optionPrefix.length());
1:82a5839:                 rc.put(name, entry.getValue());
1:82a5839:                 iter.remove();
1:82a5839:             }
1:82a5839:         }
1:82a5839: 
1:82a5839:         return rc;
1:82a5839:     }
1:82a5839: 
1:82a5839:     /**
1:82a5839:      * Enumerate the properties of the target object and add them as additional entries
1:82a5839:      * to the query string of the given string URI.
1:82a5839:      *
1:82a5839:      * @param uri
1:82a5839:      *        The string URI value to append the object properties to.
1:82a5839:      * @param bean
1:82a5839:      *        The Object whose properties will be added to the target URI.
1:82a5839:      *
1:82a5839:      * @return a new String value that is the original URI with the added bean properties.
1:82a5839:      *
1:82a5839:      * @throws Exception if an error occurs while enumerating the bean properties.
1:82a5839:      */
1:82a5839:     public static String addPropertiesToURIFromBean(String uri, Object bean) throws Exception {
1:82a5839:         Map<String, String> properties = PropertyUtil.getProperties(bean);
1:82a5839:         return PropertyUtil.addPropertiesToURI(uri, properties);
1:82a5839:     }
1:82a5839: 
1:82a5839:     /**
1:82a5839:      * Enumerate the properties of the target object and add them as additional entries
1:82a5839:      * to the query string of the given URI.
1:82a5839:      *
1:82a5839:      * @param uri
1:82a5839:      *        The URI value to append the object properties to.
1:82a5839:      * @param properties
1:82a5839:      *        The Object whose properties will be added to the target URI.
1:82a5839:      *
1:82a5839:      * @return a new String value that is the original URI with the added bean properties.
1:82a5839:      *
1:82a5839:      * @throws Exception if an error occurs while enumerating the bean properties.
1:82a5839:      */
1:82a5839:     public static String addPropertiesToURI(URI uri, Map<String, String> properties) throws Exception {
1:82a5839:         return addPropertiesToURI(uri.toString(), properties);
1:82a5839:     }
1:82a5839: 
1:82a5839:     /**
1:82a5839:      * Append the given properties to the query portion of the given URI.
1:82a5839:      *
1:82a5839:      * @param uri
1:82a5839:      *        The string URI value to append the object properties to.
1:82a5839:      * @param properties
1:82a5839:      *        The properties that will be added to the target URI.
1:82a5839:      *
1:82a5839:      * @return a new String value that is the original URI with the added properties.
1:82a5839:      *
1:82a5839:      * @throws Exception if an error occurs while building the new URI string.
1:82a5839:      */
1:82a5839:     public static String addPropertiesToURI(String uri, Map<String, String> properties) throws Exception {
1:82a5839:         String result = uri;
1:82a5839:         if (uri != null && properties != null) {
1:82a5839:             StringBuilder base = new StringBuilder(stripBefore(uri, '?'));
1:82a5839:             Map<String, String> map = parseParameters(uri);
1:82a5839:             if (!map.isEmpty()) {
1:82a5839:                 map.putAll(properties);
1:82a5839:             } else {
1:82a5839:                 map = properties;
1:82a5839:             }
1:82a5839:             if (!map.isEmpty()) {
1:82a5839:                 base.append('?');
1:82a5839:                 boolean first = true;
1:82a5839:                 for (Map.Entry<String, String> entry : map.entrySet()) {
1:82a5839:                     if (!first) {
1:82a5839:                         base.append('&');
1:82a5839:                     }
1:82a5839:                     first = false;
1:82a5839:                     base.append(entry.getKey()).append("=").append(entry.getValue());
1:82a5839:                 }
1:82a5839:                 result = base.toString();
1:82a5839:             }
1:82a5839:         }
1:82a5839:         return result;
1:82a5839:     }
1:82a5839: 
1:82a5839:     /**
1:82a5839:      * Set properties on an object using the provided map. The return value
1:82a5839:      * indicates if all properties from the given map were set on the target object.
1:82a5839:      *
1:82a5839:      * @param target
1:82a5839:      *        the object whose properties are to be set from the map options.
1:82a5839:      * @param properties
1:82a5839:      *        the properties that should be applied to the given object.
1:82a5839:      *
1:82a5839:      * @return true if all values in the properties map were applied to the target object.
1:82a5839:      */
1:82a5839:     public static Map<String, String> setProperties(Object target, Map<String, String> properties) {
1:82a5839:         if (target == null) {
1:82a5839:             throw new IllegalArgumentException("target object cannot be null");
1:82a5839:         }
1:82a5839:         if (properties == null) {
1:82a5839:             throw new IllegalArgumentException("Given Properties object cannot be null");
1:82a5839:         }
1:82a5839: 
1:82a5839:         Map<String, String> unmatched = new HashMap<String, String>();
1:82a5839: 
1:82a5839:         for (Map.Entry<String, String> entry : properties.entrySet()) {
1:82a5839:             if (!setProperty(target, entry.getKey(), entry.getValue())) {
1:82a5839:                 unmatched.put(entry.getKey(), entry.getValue());
1:82a5839:             }
1:82a5839:         }
1:82a5839: 
1:82a5839:         return Collections.unmodifiableMap(unmatched);
1:82a5839:     }
1:82a5839: 
1:82a5839:     //TODO: common impl for above and below methods.
1:82a5839: 
1:82a5839:     /**
1:82a5839:      * Set properties on an object using the provided Properties object. The return value
1:82a5839:      * indicates if all properties from the given map were set on the target object.
1:82a5839:      *
1:82a5839:      * @param target
1:82a5839:      *        the object whose properties are to be set from the map options.
1:82a5839:      * @param properties
1:82a5839:      *        the properties that should be applied to the given object.
1:82a5839:      *
1:82a5839:      * @return an unmodifiable map with any values that could not be applied to the target.
1:82a5839:      */
1:82a5839:     public static Map<String, Object> setProperties(Object target, Properties properties) {
1:82a5839:         if (target == null) {
1:82a5839:             throw new IllegalArgumentException("target object cannot be null");
1:82a5839:         }
1:82a5839:         if (properties == null) {
1:82a5839:             throw new IllegalArgumentException("Given Properties object cannot be null");
1:82a5839:         }
1:82a5839: 
1:82a5839:         Map<String, Object> unmatched = new HashMap<String, Object>();
1:82a5839: 
1:82a5839:         for (Map.Entry<Object, Object> entry : properties.entrySet()) {
1:82a5839:             if (!setProperty(target, (String) entry.getKey(), entry.getValue())) {
1:82a5839:                 unmatched.put((String) entry.getKey(), entry.getValue());
1:82a5839:             }
1:82a5839:         }
1:82a5839: 
1:82a5839:         return Collections.<String, Object>unmodifiableMap(unmatched);
1:82a5839:     }
1:82a5839: 
1:82a5839:     /**
1:82a5839:      * Get properties from an object using reflection.  If the passed object is null an
1:82a5839:      * empty <code>Map</code> is returned.
1:82a5839:      *
1:82a5839:      * @param object
1:82a5839:      *        the Object whose properties are to be extracted.
1:82a5839:      *
1:82a5839:      * @return <Code>Map</Code> of properties extracted from the given object.
1:82a5839:      *
1:82a5839:      * @throws Exception if an error occurs while examining the object's properties.
1:82a5839:      */
1:82a5839:     public static Map<String, String> getProperties(Object object) throws Exception {
1:82a5839:         if (object == null) {
1:82a5839:             return Collections.emptyMap();
1:82a5839:         }
1:82a5839: 
1:82a5839:         Map<String, String> properties = new LinkedHashMap<String, String>();
1:82a5839:         BeanInfo beanInfo = Introspector.getBeanInfo(object.getClass());
1:82a5839:         Object[] NULL_ARG = {};
1:82a5839:         PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();
1:82a5839:         if (propertyDescriptors != null) {
1:82a5839:             for (int i = 0; i < propertyDescriptors.length; i++) {
1:82a5839:                 PropertyDescriptor pd = propertyDescriptors[i];
1:82a5839:                 if (pd.getReadMethod() != null && !pd.getName().equals("class") && !pd.getName().equals("properties") && !pd.getName().equals("reference")) {
1:82a5839:                     Object value = pd.getReadMethod().invoke(object, NULL_ARG);
1:82a5839:                     if (value != null) {
1:82a5839:                         if (value instanceof Boolean || value instanceof Number || value instanceof String || value instanceof URI || value instanceof URL) {
1:82a5839:                             properties.put(pd.getName(), ("" + value));
1:82a5839:                         } else if (value instanceof SSLContext) {
1:82a5839:                             // ignore this one..
1:82a5839:                         } else {
1:82a5839:                             Map<String, String> inner = getProperties(value);
1:82a5839:                             for (Map.Entry<String, String> entry : inner.entrySet()) {
1:82a5839:                                 properties.put(pd.getName() + "." + entry.getKey(), entry.getValue());
1:82a5839:                             }
1:82a5839:                         }
1:82a5839:                     }
1:82a5839:                 }
1:82a5839:             }
1:82a5839:         }
1:82a5839: 
1:82a5839:         return properties;
1:82a5839:     }
1:82a5839: 
1:82a5839:     /**
1:82a5839:      * Find a specific property getter in a given object based on a property name.
1:82a5839:      *
1:82a5839:      * @param object
1:82a5839:      *        the object to search.
1:82a5839:      * @param name
1:82a5839:      *        the property name to search for.
1:82a5839:      *
1:82a5839:      * @return the result of invoking the specific property get method.
1:82a5839:      *
1:82a5839:      * @throws Exception if an error occurs while searching the object's bean info.
1:82a5839:      */
1:82a5839:     public static Object getProperty(Object object, String name) throws Exception {
1:82a5839:         BeanInfo beanInfo = Introspector.getBeanInfo(object.getClass());
1:82a5839:         PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();
1:82a5839:         if (propertyDescriptors != null) {
1:82a5839:             for (int i = 0; i < propertyDescriptors.length; i++) {
1:82a5839:                 PropertyDescriptor pd = propertyDescriptors[i];
1:82a5839:                 if (pd.getReadMethod() != null && pd.getName().equals(name)) {
1:82a5839:                     return pd.getReadMethod().invoke(object);
1:82a5839:                 }
1:82a5839:             }
1:82a5839:         }
1:82a5839:         return null;
1:82a5839:     }
1:82a5839: 
1:82a5839:     /**
1:82a5839:      * Set a property named property on a given Object.
1:82a5839:      * <p>
1:82a5839:      * The object is searched for an set method that would match the given named
1:82a5839:      * property and if one is found.  If necessary an attempt will be made to convert
1:82a5839:      * the new value to an acceptable type.
1:82a5839:      *
1:82a5839:      * @param target
1:82a5839:      *        The object whose property is to be set.
1:82a5839:      * @param name
1:82a5839:      *        The name of the property to set.
1:82a5839:      * @param value
1:82a5839:      *        The new value to set for the named property.
1:82a5839:      *
1:82a5839:      * @return true if the property was able to be set on the target object.
1:82a5839:      */
1:82a5839:     public static boolean setProperty(Object target, String name, Object value) {
1:82a5839:         try {
1:82a5839:             int dotPos = name.indexOf(".");
1:82a5839:             while (dotPos >= 0) {
1:82a5839:                 String getterName = name.substring(0, dotPos);
1:82a5839:                 target = getProperty(target, getterName);
1:82a5839:                 name = name.substring(dotPos + 1);
1:82a5839:                 dotPos = name.indexOf(".");
1:82a5839:             }
1:82a5839: 
1:82a5839:             Class<? extends Object> clazz = target.getClass();
1:82a5839:             Method setter = findSetterMethod(clazz, name);
1:82a5839:             if (setter == null) {
1:82a5839:                 return false;
1:82a5839:             }
1:82a5839:             // If the type is null or it matches the needed type, just use the
1:82a5839:             // value directly
1:82a5839:             if (value == null || value.getClass() == setter.getParameterTypes()[0]) {
1:82a5839:                 setter.invoke(target, new Object[] { value });
1:82a5839:             } else {
1:82a5839:                 setter.invoke(target, new Object[] { convert(value, setter.getParameterTypes()[0]) });
1:82a5839:             }
1:82a5839:             return true;
1:82a5839:         } catch (Throwable ignore) {
1:82a5839:             return false;
1:82a5839:         }
1:82a5839:     }
1:82a5839: 
1:82a5839:     /**
1:82a5839:      * Return a String minus the given prefix.  If the string does not start
1:82a5839:      * with the given prefix the original string value is returned.
1:82a5839:      *
1:82a5839:      * @param value
1:82a5839:      *        The String whose prefix is to be removed.
1:82a5839:      * @param prefix
1:82a5839:      *        The prefix string to remove from the target string.
1:82a5839:      *
1:82a5839:      * @return stripped version of the original input string.
1:82a5839:      */
1:82a5839:     public static String stripPrefix(String value, String prefix) {
1:82a5839:         if (value != null && prefix != null && value.startsWith(prefix)) {
1:82a5839:             return value.substring(prefix.length());
1:82a5839:         }
1:82a5839:         return value;
1:82a5839:     }
1:82a5839: 
1:82a5839:     /**
1:82a5839:      * Return a portion of a String value by looking beyond the given
1:82a5839:      * character.
1:82a5839:      *
1:82a5839:      * @param value
1:82a5839:      *        The string value to split
1:82a5839:      * @param c
1:82a5839:      *        The character that marks the split point.
1:82a5839:      *
1:82a5839:      * @return the sub-string value starting beyond the given character.
1:82a5839:      */
1:82a5839:     public static String stripUpto(String value, char c) {
1:82a5839:         String result = null;
1:82a5839:         if (value != null) {
1:82a5839:             int index = value.indexOf(c);
1:82a5839:             if (index > 0) {
1:82a5839:                 result = value.substring(index + 1);
1:82a5839:             }
1:82a5839:         }
1:82a5839:         return result;
1:82a5839:     }
1:82a5839: 
1:82a5839:     /**
1:82a5839:      * Return a String up to and including character
1:82a5839:      *
1:82a5839:      * @param value
1:82a5839:      *        The string value to split
1:82a5839:      * @param c
1:82a5839:      *        The character that marks the start of split point.
1:82a5839:      *
1:82a5839:      * @return the sub-string value starting from the given character.
1:82a5839:      */
1:82a5839:     public static String stripBefore(String value, char c) {
1:82a5839:         String result = value;
1:82a5839:         if (value != null) {
1:82a5839:             int index = value.indexOf(c);
1:82a5839:             if (index > 0) {
1:82a5839:                 result = value.substring(0, index);
1:82a5839:             }
1:82a5839:         }
1:82a5839:         return result;
1:82a5839:     }
1:82a5839: 
1:82a5839:     private static Method findSetterMethod(Class<? extends Object> clazz, String name) {
1:82a5839:         // Build the method name.
1:82a5839:         name = "set" + name.substring(0, 1).toUpperCase() + name.substring(1);
1:82a5839:         Method[] methods = clazz.getMethods();
1:82a5839:         for (int i = 0; i < methods.length; i++) {
1:82a5839:             Method method = methods[i];
1:82a5839:             Class<? extends Object> params[] = method.getParameterTypes();
1:82a5839:             if (method.getName().equals(name) && params.length == 1) {
1:82a5839:                 return method;
1:82a5839:             }
1:82a5839:         }
1:82a5839:         return null;
1:82a5839:     }
1:82a5839: 
1:82a5839:     private static Object convert(Object value, Class<?> type) throws Exception {
1:82a5839:         if (value == null) {
1:82a5839:             if (boolean.class.isAssignableFrom(type)) {
1:82a5839:                 return Boolean.FALSE;
1:82a5839:             }
1:82a5839:             return null;
1:82a5839:         }
1:82a5839: 
1:82a5839:         if (type.isAssignableFrom(value.getClass())) {
1:82a5839:             return type.cast(value);
1:82a5839:         }
1:82a5839: 
1:82a5839:         // special for String[] as we do not want to use a PropertyEditor for that
1:82a5839:         if (type.isAssignableFrom(String[].class)) {
1:82a5839:             return StringArrayConverter.convertToStringArray(value);
1:82a5839:         }
1:82a5839: 
1:82a5839:         if (type == URI.class) {
1:82a5839:             return new URI(value.toString());
1:82a5839:         }
1:82a5839: 
1:82a5839:         return TypeConversionSupport.convert(value, type);
1:82a5839:     }
1:82a5839: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:82a5839
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport.amqp.client.util;
1: 
1: import java.beans.BeanInfo;
1: import java.beans.Introspector;
1: import java.beans.PropertyDescriptor;
1: import java.io.UnsupportedEncodingException;
1: import java.lang.reflect.Method;
1: import java.net.URI;
1: import java.net.URISyntaxException;
1: import java.net.URL;
1: import java.net.URLDecoder;
1: import java.net.URLEncoder;
1: import java.util.Collections;
1: import java.util.HashMap;
1: import java.util.Iterator;
1: import java.util.LinkedHashMap;
1: import java.util.Map;
1: import java.util.Map.Entry;
1: import java.util.Properties;
1: 
1: import javax.net.ssl.SSLContext;
1: 
1: /**
1:  * Utilities for properties
1:  */
1: public class PropertyUtil {
1: 
1:     /**
1:      * Creates a URI from the original URI and the given parameters.
1:      *
1:      * @param originalURI
1:      *        The URI whose current parameters are removed and replaced with the given remainder value.
1:      * @param params
1:      *        The URI params that should be used to replace the current ones in the target.
1:      *
1:      * @return a new URI that matches the original one but has its query options replaced with
1:      *         the given ones.
1:      *
1:      * @throws URISyntaxException if the given URI is invalid.
1:      */
1:     public static URI replaceQuery(URI originalURI, Map<String, String> params) throws URISyntaxException {
1:         String s = createQueryString(params);
1:         if (s.length() == 0) {
1:             s = null;
1:         }
1:         return replaceQuery(originalURI, s);
1:     }
1: 
1:     /**
1:      * Creates a URI with the given query, removing an previous query value from the given URI.
1:      *
1:      * @param uri
1:      *        The source URI whose existing query is replaced with the newly supplied one.
1:      * @param query
1:      *        The new URI query string that should be appended to the given URI.
1:      *
1:      * @return a new URI that is a combination of the original URI and the given query string.
1:      *
1:      * @throws URISyntaxException if the given URI is invalid.
1:      */
1:     public static URI replaceQuery(URI uri, String query) throws URISyntaxException {
1:         String schemeSpecificPart = uri.getRawSchemeSpecificPart();
1:         // strip existing query if any
1:         int questionMark = schemeSpecificPart.lastIndexOf("?");
1:         // make sure question mark is not within parentheses
1:         if (questionMark < schemeSpecificPart.lastIndexOf(")")) {
1:             questionMark = -1;
1:         }
1:         if (questionMark > 0) {
1:             schemeSpecificPart = schemeSpecificPart.substring(0, questionMark);
1:         }
1:         if (query != null && query.length() > 0) {
1:             schemeSpecificPart += "?" + query;
1:         }
1:         return new URI(uri.getScheme(), schemeSpecificPart, uri.getFragment());
1:     }
1: 
1:     /**
1:      * Creates a URI with the given query, removing an previous query value from the given URI.
1:      *
1:      * @param uri
1:      *        The source URI whose existing query is replaced with the newly supplied one.
1:      *
1:      * @return a new URI that is a combination of the original URI and the given query string.
1:      *
1:      * @throws URISyntaxException if the given URI is invalid.
1:      */
1:     public static URI eraseQuery(URI uri) throws URISyntaxException {
1:         return replaceQuery(uri, (String) null);
1:     }
1: 
1:     /**
1:      * Given a key / value mapping, create and return a URI formatted query string that is valid
1:      * and can be appended to a URI.
1:      *
1:      * @param options
1:      *        The Mapping that will create the new Query string.
1:      *
1:      * @return a URI formatted query string.
1:      *
1:      * @throws URISyntaxException if the given URI is invalid.
1:      */
1:     public static String createQueryString(Map<String, ? extends Object> options) throws URISyntaxException {
1:         try {
1:             if (options.size() > 0) {
1:                 StringBuffer rc = new StringBuffer();
1:                 boolean first = true;
1:                 for (Entry<String, ? extends Object> entry : options.entrySet()) {
1:                     if (first) {
1:                         first = false;
1:                     } else {
1:                         rc.append("&");
1:                     }
1:                     rc.append(URLEncoder.encode(entry.getKey(), "UTF-8"));
1:                     rc.append("=");
1:                     rc.append(URLEncoder.encode((String) entry.getValue(), "UTF-8"));
1:                 }
1:                 return rc.toString();
1:             } else {
1:                 return "";
1:             }
1:         } catch (UnsupportedEncodingException e) {
1:             throw (URISyntaxException) new URISyntaxException(e.toString(), "Invalid encoding").initCause(e);
1:         }
1:     }
1: 
1:     /**
1:      * Get properties from a URI and return them in a new {@code Map<String, String>} instance.
1:      *
1:      * If the URI is null or the query string of the URI is null an empty Map is returned.
1:      *
1:      * @param uri
1:      *        the URI whose parameters are to be parsed.
1:      *
1:      * @return <Code>Map</Code> of properties
1:      *
1:      * @throws Exception if an error occurs while parsing the query options.
1:      */
1:     public static Map<String, String> parseParameters(URI uri) throws Exception {
1:         if (uri == null || uri.getQuery() == null) {
1:             return Collections.emptyMap();
1:         }
1: 
1:         return parseQuery(stripPrefix(uri.getQuery(), "?"));
1:     }
1: 
1:     /**
1:      * Parse properties from a named resource -eg. a URI or a simple name e.g.
1:      * {@literal foo?name="fred"&size=2}
1:      *
1:      * @param uri
1:      *        the URI whose parameters are to be parsed.
1:      *
1:      * @return <Code>Map</Code> of properties
1:      *
1:      * @throws Exception if an error occurs while parsing the query options.
1:      */
1:     public static Map<String, String> parseParameters(String uri) throws Exception {
1:         if (uri == null) {
1:             return Collections.emptyMap();
1:         }
1: 
1:         return parseQuery(stripUpto(uri, '?'));
1:     }
1: 
1:     /**
1:      * Get properties from a URI query string.
1:      *
1:      * @param queryString
1:      *        the string value returned from a call to the URI class getQuery method.
1:      *
1:      * @return <Code>Map</Code> of properties from the parsed string.
1:      *
1:      * @throws Exception if an error occurs while parsing the query options.
1:      */
1:     public static Map<String, String> parseQuery(String queryString) throws Exception {
1:         if (queryString != null && !queryString.isEmpty()) {
1:             Map<String, String> rc = new HashMap<String, String>();
1:             String[] parameters = queryString.split("&");
1:             for (int i = 0; i < parameters.length; i++) {
1:                 int p = parameters[i].indexOf("=");
1:                 if (p >= 0) {
1:                     String name = URLDecoder.decode(parameters[i].substring(0, p), "UTF-8");
1:                     String value = URLDecoder.decode(parameters[i].substring(p + 1), "UTF-8");
1:                     rc.put(name, value);
1:                 } else {
1:                     rc.put(parameters[i], null);
1:                 }
1:             }
1:             return rc;
1:         }
1: 
1:         return Collections.emptyMap();
1:     }
1: 
1:     /**
1:      * Given a map of properties, filter out only those prefixed with the given value, the
1:      * values filtered are returned in a new Map instance.
1:      *
1:      * @param properties
1:      *        The map of properties to filter.
1:      * @param optionPrefix
1:      *        The prefix value to use when filtering.
1:      *
1:      * @return a filter map with only values that match the given prefix.
1:      */
1:     public static Map<String, String> filterProperties(Map<String, String> properties, String optionPrefix) {
1:         if (properties == null) {
1:             throw new IllegalArgumentException("The given properties object was null.");
1:         }
1: 
1:         HashMap<String, String> rc = new HashMap<String, String>(properties.size());
1: 
1:         for (Iterator<Entry<String, String>> iter = properties.entrySet().iterator(); iter.hasNext();) {
1:             Entry<String, String> entry = iter.next();
1:             if (entry.getKey().startsWith(optionPrefix)) {
1:                 String name = entry.getKey().substring(optionPrefix.length());
1:                 rc.put(name, entry.getValue());
1:                 iter.remove();
1:             }
1:         }
1: 
1:         return rc;
1:     }
1: 
1:     /**
1:      * Enumerate the properties of the target object and add them as additional entries
1:      * to the query string of the given string URI.
1:      *
1:      * @param uri
1:      *        The string URI value to append the object properties to.
1:      * @param bean
1:      *        The Object whose properties will be added to the target URI.
1:      *
1:      * @return a new String value that is the original URI with the added bean properties.
1:      *
1:      * @throws Exception if an error occurs while enumerating the bean properties.
1:      */
1:     public static String addPropertiesToURIFromBean(String uri, Object bean) throws Exception {
1:         Map<String, String> properties = PropertyUtil.getProperties(bean);
1:         return PropertyUtil.addPropertiesToURI(uri, properties);
1:     }
1: 
1:     /**
1:      * Enumerate the properties of the target object and add them as additional entries
1:      * to the query string of the given URI.
1:      *
1:      * @param uri
1:      *        The URI value to append the object properties to.
1:      * @param properties
1:      *        The Object whose properties will be added to the target URI.
1:      *
1:      * @return a new String value that is the original URI with the added bean properties.
1:      *
1:      * @throws Exception if an error occurs while enumerating the bean properties.
1:      */
1:     public static String addPropertiesToURI(URI uri, Map<String, String> properties) throws Exception {
1:         return addPropertiesToURI(uri.toString(), properties);
1:     }
1: 
1:     /**
1:      * Append the given properties to the query portion of the given URI.
1:      *
1:      * @param uri
1:      *        The string URI value to append the object properties to.
1:      * @param properties
1:      *        The properties that will be added to the target URI.
1:      *
1:      * @return a new String value that is the original URI with the added properties.
1:      *
1:      * @throws Exception if an error occurs while building the new URI string.
1:      */
1:     public static String addPropertiesToURI(String uri, Map<String, String> properties) throws Exception {
1:         String result = uri;
1:         if (uri != null && properties != null) {
1:             StringBuilder base = new StringBuilder(stripBefore(uri, '?'));
1:             Map<String, String> map = parseParameters(uri);
1:             if (!map.isEmpty()) {
1:                 map.putAll(properties);
1:             } else {
1:                 map = properties;
1:             }
1:             if (!map.isEmpty()) {
1:                 base.append('?');
1:                 boolean first = true;
1:                 for (Map.Entry<String, String> entry : map.entrySet()) {
1:                     if (!first) {
1:                         base.append('&');
1:                     }
1:                     first = false;
1:                     base.append(entry.getKey()).append("=").append(entry.getValue());
1:                 }
1:                 result = base.toString();
1:             }
1:         }
1:         return result;
1:     }
1: 
1:     /**
1:      * Set properties on an object using the provided map. The return value
1:      * indicates if all properties from the given map were set on the target object.
1:      *
1:      * @param target
1:      *        the object whose properties are to be set from the map options.
1:      * @param properties
1:      *        the properties that should be applied to the given object.
1:      *
1:      * @return true if all values in the properties map were applied to the target object.
1:      */
1:     public static Map<String, String> setProperties(Object target, Map<String, String> properties) {
1:         if (target == null) {
1:             throw new IllegalArgumentException("target object cannot be null");
1:         }
1:         if (properties == null) {
1:             throw new IllegalArgumentException("Given Properties object cannot be null");
1:         }
1: 
1:         Map<String, String> unmatched = new HashMap<String, String>();
1: 
1:         for (Map.Entry<String, String> entry : properties.entrySet()) {
1:             if (!setProperty(target, entry.getKey(), entry.getValue())) {
1:                 unmatched.put(entry.getKey(), entry.getValue());
1:             }
1:         }
1: 
1:         return Collections.unmodifiableMap(unmatched);
1:     }
1: 
1:     //TODO: common impl for above and below methods.
1: 
1:     /**
1:      * Set properties on an object using the provided Properties object. The return value
1:      * indicates if all properties from the given map were set on the target object.
1:      *
1:      * @param target
1:      *        the object whose properties are to be set from the map options.
1:      * @param properties
1:      *        the properties that should be applied to the given object.
1:      *
1:      * @return an unmodifiable map with any values that could not be applied to the target.
1:      */
1:     public static Map<String, Object> setProperties(Object target, Properties properties) {
1:         if (target == null) {
1:             throw new IllegalArgumentException("target object cannot be null");
1:         }
1:         if (properties == null) {
1:             throw new IllegalArgumentException("Given Properties object cannot be null");
1:         }
1: 
1:         Map<String, Object> unmatched = new HashMap<String, Object>();
1: 
1:         for (Map.Entry<Object, Object> entry : properties.entrySet()) {
1:             if (!setProperty(target, (String) entry.getKey(), entry.getValue())) {
1:                 unmatched.put((String) entry.getKey(), entry.getValue());
1:             }
1:         }
1: 
1:         return Collections.<String, Object>unmodifiableMap(unmatched);
1:     }
1: 
1:     /**
1:      * Get properties from an object using reflection.  If the passed object is null an
1:      * empty <code>Map</code> is returned.
1:      *
1:      * @param object
1:      *        the Object whose properties are to be extracted.
1:      *
1:      * @return <Code>Map</Code> of properties extracted from the given object.
1:      *
1:      * @throws Exception if an error occurs while examining the object's properties.
1:      */
1:     public static Map<String, String> getProperties(Object object) throws Exception {
1:         if (object == null) {
1:             return Collections.emptyMap();
1:         }
1: 
1:         Map<String, String> properties = new LinkedHashMap<String, String>();
1:         BeanInfo beanInfo = Introspector.getBeanInfo(object.getClass());
1:         Object[] NULL_ARG = {};
1:         PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();
1:         if (propertyDescriptors != null) {
1:             for (int i = 0; i < propertyDescriptors.length; i++) {
1:                 PropertyDescriptor pd = propertyDescriptors[i];
1:                 if (pd.getReadMethod() != null && !pd.getName().equals("class") && !pd.getName().equals("properties") && !pd.getName().equals("reference")) {
1:                     Object value = pd.getReadMethod().invoke(object, NULL_ARG);
1:                     if (value != null) {
1:                         if (value instanceof Boolean || value instanceof Number || value instanceof String || value instanceof URI || value instanceof URL) {
1:                             properties.put(pd.getName(), ("" + value));
1:                         } else if (value instanceof SSLContext) {
1:                             // ignore this one..
1:                         } else {
1:                             Map<String, String> inner = getProperties(value);
1:                             for (Map.Entry<String, String> entry : inner.entrySet()) {
1:                                 properties.put(pd.getName() + "." + entry.getKey(), entry.getValue());
1:                             }
1:                         }
1:                     }
1:                 }
1:             }
1:         }
1: 
1:         return properties;
1:     }
1: 
1:     /**
1:      * Find a specific property getter in a given object based on a property name.
1:      *
1:      * @param object
1:      *        the object to search.
1:      * @param name
1:      *        the property name to search for.
1:      *
1:      * @return the result of invoking the specific property get method.
1:      *
1:      * @throws Exception if an error occurs while searching the object's bean info.
1:      */
1:     public static Object getProperty(Object object, String name) throws Exception {
1:         BeanInfo beanInfo = Introspector.getBeanInfo(object.getClass());
1:         PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();
1:         if (propertyDescriptors != null) {
1:             for (int i = 0; i < propertyDescriptors.length; i++) {
1:                 PropertyDescriptor pd = propertyDescriptors[i];
1:                 if (pd.getReadMethod() != null && pd.getName().equals(name)) {
1:                     return pd.getReadMethod().invoke(object);
1:                 }
1:             }
1:         }
1:         return null;
1:     }
1: 
1:     /**
1:      * Set a property named property on a given Object.
1:      * <p>
1:      * The object is searched for an set method that would match the given named
1:      * property and if one is found.  If necessary an attempt will be made to convert
1:      * the new value to an acceptable type.
1:      *
1:      * @param target
1:      *        The object whose property is to be set.
1:      * @param name
1:      *        The name of the property to set.
1:      * @param value
1:      *        The new value to set for the named property.
1:      *
1:      * @return true if the property was able to be set on the target object.
1:      */
1:     public static boolean setProperty(Object target, String name, Object value) {
1:         try {
1:             int dotPos = name.indexOf(".");
1:             while (dotPos >= 0) {
1:                 String getterName = name.substring(0, dotPos);
1:                 target = getProperty(target, getterName);
1:                 name = name.substring(dotPos + 1);
1:                 dotPos = name.indexOf(".");
1:             }
1: 
1:             Class<? extends Object> clazz = target.getClass();
1:             Method setter = findSetterMethod(clazz, name);
1:             if (setter == null) {
1:                 return false;
1:             }
1:             // If the type is null or it matches the needed type, just use the
1:             // value directly
1:             if (value == null || value.getClass() == setter.getParameterTypes()[0]) {
1:                 setter.invoke(target, new Object[] { value });
1:             } else {
1:                 setter.invoke(target, new Object[] { convert(value, setter.getParameterTypes()[0]) });
1:             }
1:             return true;
1:         } catch (Throwable ignore) {
1:             return false;
1:         }
1:     }
1: 
1:     /**
1:      * Return a String minus the given prefix.  If the string does not start
1:      * with the given prefix the original string value is returned.
1:      *
1:      * @param value
1:      *        The String whose prefix is to be removed.
1:      * @param prefix
1:      *        The prefix string to remove from the target string.
1:      *
1:      * @return stripped version of the original input string.
1:      */
1:     public static String stripPrefix(String value, String prefix) {
1:         if (value != null && prefix != null && value.startsWith(prefix)) {
1:             return value.substring(prefix.length());
1:         }
1:         return value;
1:     }
1: 
1:     /**
1:      * Return a portion of a String value by looking beyond the given
1:      * character.
1:      *
1:      * @param value
1:      *        The string value to split
1:      * @param c
1:      *        The character that marks the split point.
1:      *
1:      * @return the sub-string value starting beyond the given character.
1:      */
1:     public static String stripUpto(String value, char c) {
1:         String result = null;
1:         if (value != null) {
1:             int index = value.indexOf(c);
1:             if (index > 0) {
1:                 result = value.substring(index + 1);
1:             }
1:         }
1:         return result;
1:     }
1: 
1:     /**
1:      * Return a String up to and including character
1:      *
1:      * @param value
1:      *        The string value to split
1:      * @param c
1:      *        The character that marks the start of split point.
1:      *
1:      * @return the sub-string value starting from the given character.
1:      */
1:     public static String stripBefore(String value, char c) {
1:         String result = value;
1:         if (value != null) {
1:             int index = value.indexOf(c);
1:             if (index > 0) {
1:                 result = value.substring(0, index);
1:             }
1:         }
1:         return result;
1:     }
1: 
1:     private static Method findSetterMethod(Class<? extends Object> clazz, String name) {
1:         // Build the method name.
1:         name = "set" + name.substring(0, 1).toUpperCase() + name.substring(1);
1:         Method[] methods = clazz.getMethods();
1:         for (int i = 0; i < methods.length; i++) {
1:             Method method = methods[i];
1:             Class<? extends Object> params[] = method.getParameterTypes();
1:             if (method.getName().equals(name) && params.length == 1) {
1:                 return method;
1:             }
1:         }
1:         return null;
1:     }
1: 
1:     private static Object convert(Object value, Class<?> type) throws Exception {
1:         if (value == null) {
1:             if (boolean.class.isAssignableFrom(type)) {
1:                 return Boolean.FALSE;
1:             }
1:             return null;
1:         }
1: 
1:         if (type.isAssignableFrom(value.getClass())) {
1:             return type.cast(value);
1:         }
1: 
1:         // special for String[] as we do not want to use a PropertyEditor for that
1:         if (type.isAssignableFrom(String[].class)) {
1:             return StringArrayConverter.convertToStringArray(value);
1:         }
1: 
1:         if (type == URI.class) {
1:             return new URI(value.toString());
1:         }
1: 
1:         return TypeConversionSupport.convert(value, type);
1:     }
1: }
============================================================================