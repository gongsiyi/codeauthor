1:3f32507: /**
1:3f32507:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:3f32507:  * contributor license agreements.  See the NOTICE file distributed with
1:3f32507:  * this work for additional information regarding copyright ownership.
1:3f32507:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:3f32507:  * (the "License"); you may not use this file except in compliance with
1:3f32507:  * the License.  You may obtain a copy of the License at
1:3f32507:  *
1:3f32507:  *      http://www.apache.org/licenses/LICENSE-2.0
1:3f32507:  *
1:3f32507:  * Unless required by applicable law or agreed to in writing, software
1:3f32507:  * distributed under the License is distributed on an "AS IS" BASIS,
1:3f32507:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:3f32507:  * See the License for the specific language governing permissions and
1:3f32507:  * limitations under the License.
1:3f32507:  */
1:3f32507: package org.apache.activemq;
17:3f32507: 
1:02dc6ce: import static org.junit.Assert.assertNotNull;
1:02dc6ce: import static org.junit.Assert.assertNull;
1:02dc6ce: 
1:3f32507: import javax.jms.Connection;
1:3f32507: import javax.jms.ConnectionFactory;
1:3f32507: import javax.jms.JMSException;
1:3f32507: import javax.jms.Message;
1:3f32507: import javax.jms.MessageConsumer;
1:3f32507: import javax.jms.MessageProducer;
1:3f32507: import javax.jms.Session;
1:3f32507: 
1:02dc6ce: import org.apache.activemq.broker.BrokerService;
1:3f32507: import org.apache.activemq.command.ActiveMQQueue;
1:02dc6ce: import org.junit.After;
1:02dc6ce: import org.junit.Before;
1:02dc6ce: import org.junit.Test;
1:3f32507: 
1:02dc6ce: public class ExclusiveConsumerTest {
1:3f32507: 
1:02dc6ce:     private static final String VM_BROKER_URL = "vm://localhost";
1:3f32507: 
1:02dc6ce:     private BrokerService brokerService;
1:02dc6ce: 
1:02dc6ce:     @Before
1:02dc6ce:     public void setUp() throws Exception {
1:02dc6ce:         brokerService = new BrokerService();
1:02dc6ce:         brokerService.setPersistent(false);
1:02dc6ce:         brokerService.setUseJmx(false);
1:02dc6ce:         brokerService.setSchedulerSupport(false);
1:02dc6ce:         brokerService.setAdvisorySupport(false);
1:02dc6ce: 
1:02dc6ce:         brokerService.start();
2:3f32507:     }
1:3f32507: 
1:02dc6ce:     @After
1:02dc6ce:     public void tearDown() throws Exception {
1:02dc6ce:         if (brokerService != null) {
1:02dc6ce:             brokerService.stop();
1:02dc6ce:             brokerService = null;
1:02dc6ce:         }
1:3f32507:     }
1:3f32507: 
1:3f32507:     private Connection createConnection(final boolean start) throws JMSException {
1:3f32507:         ConnectionFactory cf = new ActiveMQConnectionFactory(VM_BROKER_URL);
1:3f32507:         Connection conn = cf.createConnection();
1:3f32507:         if (start) {
1:3f32507:             conn.start();
1:3f32507:         }
1:3f32507:         return conn;
1:3f32507:     }
1:3f32507: 
1:02dc6ce:     @Test(timeout = 60000)
1:3f32507:     public void testExclusiveConsumerSelectedCreatedFirst() throws JMSException, InterruptedException {
1:3f32507:         Connection conn = createConnection(true);
1:3f32507: 
1:3f32507:         Session exclusiveSession = null;
1:3f32507:         Session fallbackSession = null;
1:3f32507:         Session senderSession = null;
1:3f32507: 
1:3f32507:         try {
1:3f32507:             exclusiveSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3f32507:             fallbackSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3f32507:             senderSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3f32507: 
1:3f32507:             ActiveMQQueue exclusiveQueue = new ActiveMQQueue("TEST.QUEUE1?consumer.exclusive=true");
1:3f32507:             MessageConsumer exclusiveConsumer = exclusiveSession.createConsumer(exclusiveQueue);
1:3f32507: 
1:3f32507:             ActiveMQQueue fallbackQueue = new ActiveMQQueue("TEST.QUEUE1");
1:3f32507:             MessageConsumer fallbackConsumer = fallbackSession.createConsumer(fallbackQueue);
1:3f32507: 
1:3f32507:             ActiveMQQueue senderQueue = new ActiveMQQueue("TEST.QUEUE1");
1:3f32507: 
1:3f32507:             MessageProducer producer = senderSession.createProducer(senderQueue);
1:3f32507: 
1:3f32507:             Message msg = senderSession.createTextMessage("test");
1:3f32507:             producer.send(msg);
1:3f32507:             // TODO need two send a 2nd message - bug AMQ-1024
1:3f32507:             // producer.send(msg);
1:3f32507:             Thread.sleep(100);
1:3f32507: 
1:3f32507:             // Verify exclusive consumer receives the message.
1:3f32507:             assertNotNull(exclusiveConsumer.receive(100));
1:3f32507:             assertNull(fallbackConsumer.receive(100));
1:3f32507:         } finally {
1:3f32507:             fallbackSession.close();
1:3f32507:             senderSession.close();
1:3f32507:             conn.close();
1:3f32507:         }
1:3f32507:     }
1:3f32507: 
1:02dc6ce:     @Test(timeout = 60000)
1:3f32507:     public void testExclusiveConsumerSelectedCreatedAfter() throws JMSException, InterruptedException {
1:3f32507:         Connection conn = createConnection(true);
1:3f32507: 
1:3f32507:         Session exclusiveSession = null;
1:3f32507:         Session fallbackSession = null;
1:3f32507:         Session senderSession = null;
1:3f32507: 
1:3f32507:         try {
1:3f32507:             exclusiveSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3f32507:             fallbackSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3f32507:             senderSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3f32507: 
1:3f32507:             ActiveMQQueue fallbackQueue = new ActiveMQQueue("TEST.QUEUE5");
1:3f32507:             MessageConsumer fallbackConsumer = fallbackSession.createConsumer(fallbackQueue);
1:3f32507: 
1:3f32507:             ActiveMQQueue exclusiveQueue = new ActiveMQQueue("TEST.QUEUE5?consumer.exclusive=true");
1:3f32507:             MessageConsumer exclusiveConsumer = exclusiveSession.createConsumer(exclusiveQueue);
1:3f32507: 
1:3f32507:             ActiveMQQueue senderQueue = new ActiveMQQueue("TEST.QUEUE5");
1:3f32507: 
1:3f32507:             MessageProducer producer = senderSession.createProducer(senderQueue);
1:3f32507: 
1:3f32507:             Message msg = senderSession.createTextMessage("test");
1:3f32507:             producer.send(msg);
1:3f32507:             Thread.sleep(100);
1:3f32507: 
1:3f32507:             // Verify exclusive consumer receives the message.
1:3f32507:             assertNotNull(exclusiveConsumer.receive(100));
1:3f32507:             assertNull(fallbackConsumer.receive(100));
1:3f32507: 
1:3f32507:         } finally {
1:3f32507:             fallbackSession.close();
1:3f32507:             senderSession.close();
1:3f32507:             conn.close();
1:3f32507:         }
1:3f32507:     }
1:3f32507: 
1:02dc6ce:     @Test(timeout = 60000)
1:02dc6ce:     public void testFailoverToAnotherExclusiveConsumerCreatedFirst() throws JMSException, InterruptedException {
1:3f32507:         Connection conn = createConnection(true);
1:3f32507: 
1:3f32507:         Session exclusiveSession1 = null;
1:3f32507:         Session exclusiveSession2 = null;
1:3f32507:         Session fallbackSession = null;
1:3f32507:         Session senderSession = null;
1:3f32507: 
1:3f32507:         try {
1:3f32507:             exclusiveSession1 = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3f32507:             exclusiveSession2 = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3f32507:             fallbackSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3f32507:             senderSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3f32507: 
1:02dc6ce:             // This creates the exclusive consumer first which avoids AMQ-1024 bug.
1:3f32507:             ActiveMQQueue exclusiveQueue = new ActiveMQQueue("TEST.QUEUE2?consumer.exclusive=true");
1:3f32507:             MessageConsumer exclusiveConsumer1 = exclusiveSession1.createConsumer(exclusiveQueue);
1:3f32507:             MessageConsumer exclusiveConsumer2 = exclusiveSession2.createConsumer(exclusiveQueue);
1:3f32507: 
1:3f32507:             ActiveMQQueue fallbackQueue = new ActiveMQQueue("TEST.QUEUE2");
1:3f32507:             MessageConsumer fallbackConsumer = fallbackSession.createConsumer(fallbackQueue);
1:3f32507: 
1:3f32507:             ActiveMQQueue senderQueue = new ActiveMQQueue("TEST.QUEUE2");
1:3f32507: 
1:3f32507:             MessageProducer producer = senderSession.createProducer(senderQueue);
1:3f32507: 
1:3f32507:             Message msg = senderSession.createTextMessage("test");
1:3f32507:             producer.send(msg);
1:3f32507:             Thread.sleep(100);
1:3f32507: 
1:3f32507:             // Verify exclusive consumer receives the message.
1:3f32507:             assertNotNull(exclusiveConsumer1.receive(100));
1:3f32507:             assertNull(exclusiveConsumer2.receive(100));
1:3f32507:             assertNull(fallbackConsumer.receive(100));
1:3f32507: 
1:02dc6ce:             // Close the exclusive consumer to verify the non-exclusive consumer takes over
1:3f32507:             exclusiveConsumer1.close();
1:3f32507: 
1:3f32507:             producer.send(msg);
1:3f32507:             producer.send(msg);
1:3f32507: 
1:3f32507:             assertNotNull(exclusiveConsumer2.receive(100));
1:3f32507:             assertNull(fallbackConsumer.receive(100));
1:3f32507: 
1:3f32507:         } finally {
1:3f32507:             fallbackSession.close();
1:3f32507:             senderSession.close();
1:3f32507:             conn.close();
1:3f32507:         }
1:3f32507:     }
1:3f32507: 
1:02dc6ce:     @Test(timeout = 60000)
1:02dc6ce:     public void testFailoverToAnotherExclusiveConsumerCreatedAfter() throws JMSException, InterruptedException {
1:3f32507:         Connection conn = createConnection(true);
1:3f32507: 
1:3f32507:         Session exclusiveSession1 = null;
1:3f32507:         Session exclusiveSession2 = null;
1:3f32507:         Session fallbackSession = null;
1:3f32507:         Session senderSession = null;
1:3f32507: 
1:3f32507:         try {
1:3f32507:             exclusiveSession1 = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3f32507:             exclusiveSession2 = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3f32507:             fallbackSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3f32507:             senderSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3f32507: 
1:02dc6ce:             // This creates the exclusive consumer first which avoids AMQ-1024 bug.
1:3f32507:             ActiveMQQueue exclusiveQueue = new ActiveMQQueue("TEST.QUEUE6?consumer.exclusive=true");
1:3f32507:             MessageConsumer exclusiveConsumer1 = exclusiveSession1.createConsumer(exclusiveQueue);
1:3f32507: 
1:3f32507:             ActiveMQQueue fallbackQueue = new ActiveMQQueue("TEST.QUEUE6");
1:3f32507:             MessageConsumer fallbackConsumer = fallbackSession.createConsumer(fallbackQueue);
1:3f32507: 
1:3f32507:             MessageConsumer exclusiveConsumer2 = exclusiveSession2.createConsumer(exclusiveQueue);
1:3f32507: 
1:3f32507:             ActiveMQQueue senderQueue = new ActiveMQQueue("TEST.QUEUE6");
1:3f32507: 
1:3f32507:             MessageProducer producer = senderSession.createProducer(senderQueue);
1:3f32507: 
1:3f32507:             Message msg = senderSession.createTextMessage("test");
1:3f32507:             producer.send(msg);
1:3f32507:             Thread.sleep(100);
1:3f32507: 
1:3f32507:             // Verify exclusive consumer receives the message.
1:3f32507:             assertNotNull(exclusiveConsumer1.receive(100));
1:3f32507:             assertNull(exclusiveConsumer2.receive(100));
1:3f32507:             assertNull(fallbackConsumer.receive(100));
1:3f32507: 
1:02dc6ce:             // Close the exclusive consumer to verify the non-exclusive consumer takes over
1:3f32507:             exclusiveConsumer1.close();
1:3f32507: 
1:3f32507:             producer.send(msg);
1:3f32507:             producer.send(msg);
1:3f32507: 
1:3f32507:             assertNotNull(exclusiveConsumer2.receive(1000));
1:3f32507:             assertNull(fallbackConsumer.receive(100));
1:3f32507:         } finally {
1:3f32507:             fallbackSession.close();
1:3f32507:             senderSession.close();
1:3f32507:             conn.close();
1:3f32507:         }
1:3f32507:     }
1:3f32507: 
1:02dc6ce:     @Test(timeout = 60000)
1:3f32507:     public void testFailoverToNonExclusiveConsumer() throws JMSException, InterruptedException {
1:3f32507:         Connection conn = createConnection(true);
1:3f32507: 
1:3f32507:         Session exclusiveSession = null;
1:3f32507:         Session fallbackSession = null;
1:3f32507:         Session senderSession = null;
1:3f32507: 
1:3f32507:         try {
1:3f32507: 
1:3f32507:             exclusiveSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3f32507:             fallbackSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3f32507:             senderSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3f32507: 
1:02dc6ce:             // This creates the exclusive consumer first which avoids AMQ-1024 bug.
1:3f32507:             ActiveMQQueue exclusiveQueue = new ActiveMQQueue("TEST.QUEUE3?consumer.exclusive=true");
1:3f32507:             MessageConsumer exclusiveConsumer = exclusiveSession.createConsumer(exclusiveQueue);
1:3f32507: 
1:3f32507:             ActiveMQQueue fallbackQueue = new ActiveMQQueue("TEST.QUEUE3");
1:3f32507:             MessageConsumer fallbackConsumer = fallbackSession.createConsumer(fallbackQueue);
1:3f32507: 
1:3f32507:             ActiveMQQueue senderQueue = new ActiveMQQueue("TEST.QUEUE3");
1:3f32507: 
1:3f32507:             MessageProducer producer = senderSession.createProducer(senderQueue);
1:3f32507: 
1:3f32507:             Message msg = senderSession.createTextMessage("test");
1:3f32507:             producer.send(msg);
1:3f32507:             Thread.sleep(100);
1:3f32507: 
1:3f32507:             // Verify exclusive consumer receives the message.
1:3f32507:             assertNotNull(exclusiveConsumer.receive(100));
1:3f32507:             assertNull(fallbackConsumer.receive(100));
1:3f32507: 
1:02dc6ce:             // Close the exclusive consumer to verify the non-exclusive consumer takes over
1:3f32507:             exclusiveConsumer.close();
1:3f32507: 
1:3f32507:             producer.send(msg);
1:3f32507: 
1:3f32507:             assertNotNull(fallbackConsumer.receive(100));
1:3f32507:         } finally {
1:3f32507:             fallbackSession.close();
1:3f32507:             senderSession.close();
1:3f32507:             conn.close();
1:3f32507:         }
1:3f32507:     }
1:3f32507: 
1:02dc6ce:     @Test(timeout = 60000)
1:3f32507:     public void testFallbackToExclusiveConsumer() throws JMSException, InterruptedException {
1:3f32507:         Connection conn = createConnection(true);
1:3f32507: 
1:3f32507:         Session exclusiveSession = null;
1:3f32507:         Session fallbackSession = null;
1:3f32507:         Session senderSession = null;
1:3f32507: 
1:3f32507:         try {
1:3f32507: 
1:3f32507:             exclusiveSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3f32507:             fallbackSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3f32507:             senderSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3f32507: 
1:02dc6ce:             // This creates the exclusive consumer first which avoids AMQ-1024 bug.
1:3f32507:             ActiveMQQueue exclusiveQueue = new ActiveMQQueue("TEST.QUEUE4?consumer.exclusive=true");
1:3f32507:             MessageConsumer exclusiveConsumer = exclusiveSession.createConsumer(exclusiveQueue);
1:3f32507: 
1:3f32507:             ActiveMQQueue fallbackQueue = new ActiveMQQueue("TEST.QUEUE4");
1:3f32507:             MessageConsumer fallbackConsumer = fallbackSession.createConsumer(fallbackQueue);
1:3f32507: 
1:3f32507:             ActiveMQQueue senderQueue = new ActiveMQQueue("TEST.QUEUE4");
1:3f32507: 
1:3f32507:             MessageProducer producer = senderSession.createProducer(senderQueue);
1:3f32507: 
1:3f32507:             Message msg = senderSession.createTextMessage("test");
1:3f32507:             producer.send(msg);
1:3f32507:             Thread.sleep(100);
1:3f32507: 
1:3f32507:             // Verify exclusive consumer receives the message.
1:3f32507:             assertNotNull(exclusiveConsumer.receive(100));
1:3f32507:             assertNull(fallbackConsumer.receive(100));
1:3f32507: 
1:02dc6ce:             // Close the exclusive consumer to verify the non-exclusive consumer takes over
1:3f32507:             exclusiveConsumer.close();
1:3f32507: 
1:3f32507:             producer.send(msg);
1:3f32507: 
1:3f32507:             // Verify other non-exclusive consumer receices the message.
1:3f32507:             assertNotNull(fallbackConsumer.receive(100));
1:3f32507: 
1:02dc6ce:             // Create exclusive consumer to determine if it will start receiving the messages.
1:3f32507:             exclusiveConsumer = exclusiveSession.createConsumer(exclusiveQueue);
1:3f32507: 
1:3f32507:             producer.send(msg);
1:3f32507:             assertNotNull(exclusiveConsumer.receive(100));
1:3f32507:             assertNull(fallbackConsumer.receive(100));
1:3f32507:         } finally {
1:3f32507:             fallbackSession.close();
1:3f32507:             senderSession.close();
1:3f32507:             conn.close();
1:3f32507:         }
1:3f32507:     }
1:3f32507: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:02dc6ce
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertNotNull;
1: import static org.junit.Assert.assertNull;
1: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.BrokerService;
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Test;
1: public class ExclusiveConsumerTest {
1:     private static final String VM_BROKER_URL = "vm://localhost";
1:     private BrokerService brokerService;
1: 
1:     @Before
1:     public void setUp() throws Exception {
1:         brokerService = new BrokerService();
1:         brokerService.setPersistent(false);
1:         brokerService.setUseJmx(false);
1:         brokerService.setSchedulerSupport(false);
1:         brokerService.setAdvisorySupport(false);
1: 
1:         brokerService.start();
1:     @After
1:     public void tearDown() throws Exception {
1:         if (brokerService != null) {
1:             brokerService.stop();
1:             brokerService = null;
1:         }
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60000)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60000)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60000)
1:     public void testFailoverToAnotherExclusiveConsumerCreatedFirst() throws JMSException, InterruptedException {
/////////////////////////////////////////////////////////////////////////
1:             // This creates the exclusive consumer first which avoids AMQ-1024 bug.
/////////////////////////////////////////////////////////////////////////
1:             // Close the exclusive consumer to verify the non-exclusive consumer takes over
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60000)
1:     public void testFailoverToAnotherExclusiveConsumerCreatedAfter() throws JMSException, InterruptedException {
/////////////////////////////////////////////////////////////////////////
1:             // This creates the exclusive consumer first which avoids AMQ-1024 bug.
/////////////////////////////////////////////////////////////////////////
1:             // Close the exclusive consumer to verify the non-exclusive consumer takes over
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60000)
/////////////////////////////////////////////////////////////////////////
1:             // This creates the exclusive consumer first which avoids AMQ-1024 bug.
/////////////////////////////////////////////////////////////////////////
1:             // Close the exclusive consumer to verify the non-exclusive consumer takes over
1:     @Test(timeout = 60000)
/////////////////////////////////////////////////////////////////////////
1:             // This creates the exclusive consumer first which avoids AMQ-1024 bug.
/////////////////////////////////////////////////////////////////////////
1:             // Close the exclusive consumer to verify the non-exclusive consumer takes over
/////////////////////////////////////////////////////////////////////////
1:             // Create exclusive consumer to determine if it will start receiving the messages.
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:3f32507
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq;
1: 
1: import javax.jms.Connection;
1: import javax.jms.ConnectionFactory;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: 
0: import junit.framework.TestCase;
1: 
1: import org.apache.activemq.command.ActiveMQQueue;
1: 
0: public class ExclusiveConsumerTest extends TestCase {
1: 
0:     private static final String VM_BROKER_URL = "vm://localhost?broker.persistent=false&broker.useJmx=true";
1: 
0:     public ExclusiveConsumerTest(String name) {
0:         super(name);
1:     }
1: 
0:     @Override
0:     protected void setUp() throws Exception {
0:         super.setUp();
1:     }
1: 
0:     @Override
0:     protected void tearDown() throws Exception {
0:         super.tearDown();
1:     }
1: 
1:     private Connection createConnection(final boolean start) throws JMSException {
1:         ConnectionFactory cf = new ActiveMQConnectionFactory(VM_BROKER_URL);
1:         Connection conn = cf.createConnection();
1:         if (start) {
1:             conn.start();
1:         }
1:         return conn;
1:     }
1: 
1:     public void testExclusiveConsumerSelectedCreatedFirst() throws JMSException, InterruptedException {
1:         Connection conn = createConnection(true);
1: 
1:         Session exclusiveSession = null;
1:         Session fallbackSession = null;
1:         Session senderSession = null;
1: 
1:         try {
1: 
1:             exclusiveSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             fallbackSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             senderSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:             ActiveMQQueue exclusiveQueue = new ActiveMQQueue("TEST.QUEUE1?consumer.exclusive=true");
1:             MessageConsumer exclusiveConsumer = exclusiveSession.createConsumer(exclusiveQueue);
1: 
1:             ActiveMQQueue fallbackQueue = new ActiveMQQueue("TEST.QUEUE1");
1:             MessageConsumer fallbackConsumer = fallbackSession.createConsumer(fallbackQueue);
1: 
1:             ActiveMQQueue senderQueue = new ActiveMQQueue("TEST.QUEUE1");
1: 
1:             MessageProducer producer = senderSession.createProducer(senderQueue);
1: 
1:             Message msg = senderSession.createTextMessage("test");
1:             producer.send(msg);
1:             // TODO need two send a 2nd message - bug AMQ-1024
1:             // producer.send(msg);
1:             Thread.sleep(100);
1: 
1:             // Verify exclusive consumer receives the message.
1:             assertNotNull(exclusiveConsumer.receive(100));
1:             assertNull(fallbackConsumer.receive(100));
1: 
1:         } finally {
1:             fallbackSession.close();
1:             senderSession.close();
1:             conn.close();
1:         }
1: 
1:     }
1: 
1:     public void testExclusiveConsumerSelectedCreatedAfter() throws JMSException, InterruptedException {
1:         Connection conn = createConnection(true);
1: 
1:         Session exclusiveSession = null;
1:         Session fallbackSession = null;
1:         Session senderSession = null;
1: 
1:         try {
1: 
1:             exclusiveSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             fallbackSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             senderSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:             ActiveMQQueue fallbackQueue = new ActiveMQQueue("TEST.QUEUE5");
1:             MessageConsumer fallbackConsumer = fallbackSession.createConsumer(fallbackQueue);
1: 
1:             ActiveMQQueue exclusiveQueue = new ActiveMQQueue("TEST.QUEUE5?consumer.exclusive=true");
1:             MessageConsumer exclusiveConsumer = exclusiveSession.createConsumer(exclusiveQueue);
1: 
1:             ActiveMQQueue senderQueue = new ActiveMQQueue("TEST.QUEUE5");
1: 
1:             MessageProducer producer = senderSession.createProducer(senderQueue);
1: 
1:             Message msg = senderSession.createTextMessage("test");
1:             producer.send(msg);
1:             Thread.sleep(100);
1: 
1:             // Verify exclusive consumer receives the message.
1:             assertNotNull(exclusiveConsumer.receive(100));
1:             assertNull(fallbackConsumer.receive(100));
1: 
1:         } finally {
1:             fallbackSession.close();
1:             senderSession.close();
1:             conn.close();
1:         }
1: 
1:     }
1: 
0:     public void testFailoverToAnotherExclusiveConsumerCreatedFirst() throws JMSException,
0:         InterruptedException {
1:         Connection conn = createConnection(true);
1: 
1:         Session exclusiveSession1 = null;
1:         Session exclusiveSession2 = null;
1:         Session fallbackSession = null;
1:         Session senderSession = null;
1: 
1:         try {
1: 
1:             exclusiveSession1 = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             exclusiveSession2 = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             fallbackSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             senderSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
0:             // This creates the exclusive consumer first which avoids AMQ-1024
0:             // bug.
1:             ActiveMQQueue exclusiveQueue = new ActiveMQQueue("TEST.QUEUE2?consumer.exclusive=true");
1:             MessageConsumer exclusiveConsumer1 = exclusiveSession1.createConsumer(exclusiveQueue);
1:             MessageConsumer exclusiveConsumer2 = exclusiveSession2.createConsumer(exclusiveQueue);
1: 
1:             ActiveMQQueue fallbackQueue = new ActiveMQQueue("TEST.QUEUE2");
1:             MessageConsumer fallbackConsumer = fallbackSession.createConsumer(fallbackQueue);
1: 
1:             ActiveMQQueue senderQueue = new ActiveMQQueue("TEST.QUEUE2");
1: 
1:             MessageProducer producer = senderSession.createProducer(senderQueue);
1: 
1:             Message msg = senderSession.createTextMessage("test");
1:             producer.send(msg);
1:             Thread.sleep(100);
1: 
1:             // Verify exclusive consumer receives the message.
1:             assertNotNull(exclusiveConsumer1.receive(100));
1:             assertNull(exclusiveConsumer2.receive(100));
1:             assertNull(fallbackConsumer.receive(100));
1: 
0:             // Close the exclusive consumer to verify the non-exclusive consumer
0:             // takes over
1:             exclusiveConsumer1.close();
1: 
1:             producer.send(msg);
1:             producer.send(msg);
1: 
1:             assertNotNull(exclusiveConsumer2.receive(100));
1:             assertNull(fallbackConsumer.receive(100));
1: 
1:         } finally {
1:             fallbackSession.close();
1:             senderSession.close();
1:             conn.close();
1:         }
1: 
1:     }
1: 
0:     public void testFailoverToAnotherExclusiveConsumerCreatedAfter() throws JMSException,
0:         InterruptedException {
1:         Connection conn = createConnection(true);
1: 
1:         Session exclusiveSession1 = null;
1:         Session exclusiveSession2 = null;
1:         Session fallbackSession = null;
1:         Session senderSession = null;
1: 
1:         try {
1: 
1:             exclusiveSession1 = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             exclusiveSession2 = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             fallbackSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             senderSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
0:             // This creates the exclusive consumer first which avoids AMQ-1024
0:             // bug.
1:             ActiveMQQueue exclusiveQueue = new ActiveMQQueue("TEST.QUEUE6?consumer.exclusive=true");
1:             MessageConsumer exclusiveConsumer1 = exclusiveSession1.createConsumer(exclusiveQueue);
1: 
1:             ActiveMQQueue fallbackQueue = new ActiveMQQueue("TEST.QUEUE6");
1:             MessageConsumer fallbackConsumer = fallbackSession.createConsumer(fallbackQueue);
1: 
1:             MessageConsumer exclusiveConsumer2 = exclusiveSession2.createConsumer(exclusiveQueue);
1: 
1:             ActiveMQQueue senderQueue = new ActiveMQQueue("TEST.QUEUE6");
1: 
1:             MessageProducer producer = senderSession.createProducer(senderQueue);
1: 
1:             Message msg = senderSession.createTextMessage("test");
1:             producer.send(msg);
1:             Thread.sleep(100);
1: 
1:             // Verify exclusive consumer receives the message.
1:             assertNotNull(exclusiveConsumer1.receive(100));
1:             assertNull(exclusiveConsumer2.receive(100));
1:             assertNull(fallbackConsumer.receive(100));
1: 
0:             // Close the exclusive consumer to verify the non-exclusive consumer
0:             // takes over
1:             exclusiveConsumer1.close();
1: 
1:             producer.send(msg);
1:             producer.send(msg);
1: 
1:             assertNotNull(exclusiveConsumer2.receive(1000));
1:             assertNull(fallbackConsumer.receive(100));
1: 
1:         } finally {
1:             fallbackSession.close();
1:             senderSession.close();
1:             conn.close();
1:         }
1: 
1:     }
1: 
1:     public void testFailoverToNonExclusiveConsumer() throws JMSException, InterruptedException {
1:         Connection conn = createConnection(true);
1: 
1:         Session exclusiveSession = null;
1:         Session fallbackSession = null;
1:         Session senderSession = null;
1: 
1:         try {
1: 
1:             exclusiveSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             fallbackSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             senderSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
0:             // This creates the exclusive consumer first which avoids AMQ-1024
0:             // bug.
1:             ActiveMQQueue exclusiveQueue = new ActiveMQQueue("TEST.QUEUE3?consumer.exclusive=true");
1:             MessageConsumer exclusiveConsumer = exclusiveSession.createConsumer(exclusiveQueue);
1: 
1:             ActiveMQQueue fallbackQueue = new ActiveMQQueue("TEST.QUEUE3");
1:             MessageConsumer fallbackConsumer = fallbackSession.createConsumer(fallbackQueue);
1: 
1:             ActiveMQQueue senderQueue = new ActiveMQQueue("TEST.QUEUE3");
1: 
1:             MessageProducer producer = senderSession.createProducer(senderQueue);
1: 
1:             Message msg = senderSession.createTextMessage("test");
1:             producer.send(msg);
1:             Thread.sleep(100);
1: 
1:             // Verify exclusive consumer receives the message.
1:             assertNotNull(exclusiveConsumer.receive(100));
1:             assertNull(fallbackConsumer.receive(100));
1: 
0:             // Close the exclusive consumer to verify the non-exclusive consumer
0:             // takes over
1:             exclusiveConsumer.close();
1: 
1:             producer.send(msg);
1: 
1:             assertNotNull(fallbackConsumer.receive(100));
1: 
1:         } finally {
1:             fallbackSession.close();
1:             senderSession.close();
1:             conn.close();
1:         }
1: 
1:     }
1: 
1:     public void testFallbackToExclusiveConsumer() throws JMSException, InterruptedException {
1:         Connection conn = createConnection(true);
1: 
1:         Session exclusiveSession = null;
1:         Session fallbackSession = null;
1:         Session senderSession = null;
1: 
1:         try {
1: 
1:             exclusiveSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             fallbackSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             senderSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
0:             // This creates the exclusive consumer first which avoids AMQ-1024
0:             // bug.
1:             ActiveMQQueue exclusiveQueue = new ActiveMQQueue("TEST.QUEUE4?consumer.exclusive=true");
1:             MessageConsumer exclusiveConsumer = exclusiveSession.createConsumer(exclusiveQueue);
1: 
1:             ActiveMQQueue fallbackQueue = new ActiveMQQueue("TEST.QUEUE4");
1:             MessageConsumer fallbackConsumer = fallbackSession.createConsumer(fallbackQueue);
1: 
1:             ActiveMQQueue senderQueue = new ActiveMQQueue("TEST.QUEUE4");
1: 
1:             MessageProducer producer = senderSession.createProducer(senderQueue);
1: 
1:             Message msg = senderSession.createTextMessage("test");
1:             producer.send(msg);
1:             Thread.sleep(100);
1: 
1:             // Verify exclusive consumer receives the message.
1:             assertNotNull(exclusiveConsumer.receive(100));
1:             assertNull(fallbackConsumer.receive(100));
1: 
0:             // Close the exclusive consumer to verify the non-exclusive consumer
0:             // takes over
1:             exclusiveConsumer.close();
1: 
1:             producer.send(msg);
1: 
1:             // Verify other non-exclusive consumer receices the message.
1:             assertNotNull(fallbackConsumer.receive(100));
1: 
0:             // Create exclusive consumer to determine if it will start receiving
0:             // the messages.
1:             exclusiveConsumer = exclusiveSession.createConsumer(exclusiveQueue);
1: 
1:             producer.send(msg);
1:             assertNotNull(exclusiveConsumer.receive(100));
1:             assertNull(fallbackConsumer.receive(100));
1: 
1:         } finally {
1:             fallbackSession.close();
1:             senderSession.close();
1:             conn.close();
1:         }
1: 
1:     }
1: }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:c7d559f
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:     @Override
0:     @Override
/////////////////////////////////////////////////////////////////////////
0:             assertNotNull(exclusiveConsumer.receive(100));
0:             assertNull(fallbackConsumer.receive(100));
/////////////////////////////////////////////////////////////////////////
0:             assertNotNull(exclusiveConsumer.receive(100));
0:             assertNull(fallbackConsumer.receive(100));
/////////////////////////////////////////////////////////////////////////
0:             assertNotNull(exclusiveConsumer1.receive(100));
0:             assertNull(exclusiveConsumer2.receive(100));
0:             assertNull(fallbackConsumer.receive(100));
/////////////////////////////////////////////////////////////////////////
0:             assertNotNull(exclusiveConsumer2.receive(100));
0:             assertNull(fallbackConsumer.receive(100));
/////////////////////////////////////////////////////////////////////////
0:             assertNotNull(exclusiveConsumer1.receive(100));
0:             assertNull(exclusiveConsumer2.receive(100));
0:             assertNull(fallbackConsumer.receive(100));
/////////////////////////////////////////////////////////////////////////
0:             assertNotNull(exclusiveConsumer2.receive(1000));
0:             assertNull(fallbackConsumer.receive(100));
/////////////////////////////////////////////////////////////////////////
0:             assertNotNull(exclusiveConsumer.receive(100));
0:             assertNull(fallbackConsumer.receive(100));
/////////////////////////////////////////////////////////////////////////
0:             assertNotNull(fallbackConsumer.receive(100));
/////////////////////////////////////////////////////////////////////////
0:             assertNotNull(exclusiveConsumer.receive(100));
0:             assertNull(fallbackConsumer.receive(100));
/////////////////////////////////////////////////////////////////////////
0:             assertNotNull(fallbackConsumer.receive(100));
0:             assertNotNull(exclusiveConsumer.receive(100));
0:             assertNull(fallbackConsumer.receive(100));
commit:ef24cc9
author:Robert Davies
-------------------------------------------------------------------------------
commit:8250a3c
/////////////////////////////////////////////////////////////////////////
0:             Assert.assertNotNull(exclusiveConsumer2.receive(1000));
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
0:  * contributor license agreements.  See the NOTICE file distributed with
0:  * this work for additional information regarding copyright ownership.
0:  * The ASF licenses this file to You under the Apache License, Version 2.0
0:  * (the "License"); you may not use this file except in compliance with
0:  * the License.  You may obtain a copy of the License at
0:  *      http://www.apache.org/licenses/LICENSE-2.0
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
commit:230a86c
/////////////////////////////////////////////////////////////////////////
0:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
0:  *
0:  *  Licensed under the Apache License, Version 2.0 (the "License");
0:  *  you may not use this file except in compliance with the License.
0:  *  You may obtain a copy of the License at
0:  *
0:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  *  Unless required by applicable law or agreed to in writing, software
0:  *  distributed under the License is distributed on an "AS IS" BASIS,
0:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  *  See the License for the specific language governing permissions and
0:  *  limitations under the License.
0:  */
/////////////////////////////////////////////////////////////////////////
0:     private static final String VM_BROKER_URL = "vm://localhost?broker.persistent=false&broker.useJmx=true";
0:     public ExclusiveConsumerTest(String name) {
0:         super(name);
0:     }
0:     protected void setUp() throws Exception {
0:         super.setUp();
0:     }
0:     protected void tearDown() throws Exception {
0:         super.tearDown();
0:     }
0:     private Connection createConnection(final boolean start) throws JMSException {
0:         ConnectionFactory cf = new ActiveMQConnectionFactory(VM_BROKER_URL);
0:         Connection conn = cf.createConnection();
0:         if (start) {
0:             conn.start();
0:         }
0:         return conn;
0:     }
0:     public void testExclusiveConsumerSelectedCreatedFirst() throws JMSException, InterruptedException {
0:         Connection conn = createConnection(true);
0:         Session exclusiveSession = null;
0:         Session fallbackSession = null;
0:         Session senderSession = null;
0:         try {
0:             exclusiveSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             fallbackSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             senderSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             ActiveMQQueue exclusiveQueue = new ActiveMQQueue("TEST.QUEUE1?consumer.exclusive=true");
0:             MessageConsumer exclusiveConsumer = exclusiveSession.createConsumer(exclusiveQueue);
0:             ActiveMQQueue fallbackQueue = new ActiveMQQueue("TEST.QUEUE1");
0:             MessageConsumer fallbackConsumer = fallbackSession.createConsumer(fallbackQueue);
0:             ActiveMQQueue senderQueue = new ActiveMQQueue("TEST.QUEUE1");
0:             MessageProducer producer = senderSession.createProducer(senderQueue);
0:             Message msg = senderSession.createTextMessage("test");
0:             producer.send(msg);
0:             // TODO need two send a 2nd message - bug AMQ-1024
0:             // producer.send(msg);
0:             Thread.sleep(100);
0:             // Verify exclusive consumer receives the message.
0:             Assert.assertNotNull(exclusiveConsumer.receive(100));
0:             Assert.assertNull(fallbackConsumer.receive(100));
0:         } finally {
0:             fallbackSession.close();
0:             senderSession.close();
0:             conn.close();
0:         }
0:     }
0:     public void testExclusiveConsumerSelectedCreatedAfter() throws JMSException, InterruptedException {
0:         Connection conn = createConnection(true);
0:         Session exclusiveSession = null;
0:         Session fallbackSession = null;
0:         Session senderSession = null;
0:         try {
0:             exclusiveSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             fallbackSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             senderSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             ActiveMQQueue fallbackQueue = new ActiveMQQueue("TEST.QUEUE5");
0:             MessageConsumer fallbackConsumer = fallbackSession.createConsumer(fallbackQueue);
0:             ActiveMQQueue exclusiveQueue = new ActiveMQQueue("TEST.QUEUE5?consumer.exclusive=true");
0:             MessageConsumer exclusiveConsumer = exclusiveSession.createConsumer(exclusiveQueue);
0:             ActiveMQQueue senderQueue = new ActiveMQQueue("TEST.QUEUE5");
0:             MessageProducer producer = senderSession.createProducer(senderQueue);
0:             Message msg = senderSession.createTextMessage("test");
0:             producer.send(msg);
0:             Thread.sleep(100);
0:             // Verify exclusive consumer receives the message.
0:             Assert.assertNotNull(exclusiveConsumer.receive(100));
0:             Assert.assertNull(fallbackConsumer.receive(100));
0:         } finally {
0:             fallbackSession.close();
0:             senderSession.close();
0:             conn.close();
0:         }
0:     }
0:     public void testFailoverToAnotherExclusiveConsumerCreatedFirst() throws JMSException,
0:         InterruptedException {
0:         Connection conn = createConnection(true);
0:         Session exclusiveSession1 = null;
0:         Session exclusiveSession2 = null;
0:         Session fallbackSession = null;
0:         Session senderSession = null;
0: 
0:         try {
0: 
0:             exclusiveSession1 = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             exclusiveSession2 = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             fallbackSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             senderSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 
0:             // This creates the exclusive consumer first which avoids AMQ-1024
0:             // bug.
0:             ActiveMQQueue exclusiveQueue = new ActiveMQQueue("TEST.QUEUE2?consumer.exclusive=true");
0:             MessageConsumer exclusiveConsumer1 = exclusiveSession1.createConsumer(exclusiveQueue);
0:             MessageConsumer exclusiveConsumer2 = exclusiveSession2.createConsumer(exclusiveQueue);
0: 
0:             ActiveMQQueue fallbackQueue = new ActiveMQQueue("TEST.QUEUE2");
0:             MessageConsumer fallbackConsumer = fallbackSession.createConsumer(fallbackQueue);
0: 
0:             ActiveMQQueue senderQueue = new ActiveMQQueue("TEST.QUEUE2");
0: 
0:             MessageProducer producer = senderSession.createProducer(senderQueue);
0: 
0:             Message msg = senderSession.createTextMessage("test");
0:             producer.send(msg);
0:             Thread.sleep(100);
0: 
0:             // Verify exclusive consumer receives the message.
0:             Assert.assertNotNull(exclusiveConsumer1.receive(100));
0:             Assert.assertNull(exclusiveConsumer2.receive(100));
0:             Assert.assertNull(fallbackConsumer.receive(100));
0: 
0:             // Close the exclusive consumer to verify the non-exclusive consumer
0:             // takes over
0:             exclusiveConsumer1.close();
0: 
0:             producer.send(msg);
0:             producer.send(msg);
0: 
0:             Assert.assertNotNull(exclusiveConsumer2.receive(100));
0:             Assert.assertNull(fallbackConsumer.receive(100));
0: 
0:         } finally {
0:             fallbackSession.close();
0:             senderSession.close();
0:             conn.close();
0:         }
0: 
0:     }
0: 
0:     public void testFailoverToAnotherExclusiveConsumerCreatedAfter() throws JMSException,
0:         InterruptedException {
0:         Connection conn = createConnection(true);
0: 
0:         Session exclusiveSession1 = null;
0:         Session exclusiveSession2 = null;
0:         Session fallbackSession = null;
0:         Session senderSession = null;
0: 
0:         try {
0: 
0:             exclusiveSession1 = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             exclusiveSession2 = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             fallbackSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             senderSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 
0:             // This creates the exclusive consumer first which avoids AMQ-1024
0:             // bug.
0:             ActiveMQQueue exclusiveQueue = new ActiveMQQueue("TEST.QUEUE6?consumer.exclusive=true");
0:             MessageConsumer exclusiveConsumer1 = exclusiveSession1.createConsumer(exclusiveQueue);
0: 
0:             ActiveMQQueue fallbackQueue = new ActiveMQQueue("TEST.QUEUE6");
0:             MessageConsumer fallbackConsumer = fallbackSession.createConsumer(fallbackQueue);
0: 
0:             MessageConsumer exclusiveConsumer2 = exclusiveSession2.createConsumer(exclusiveQueue);
0: 
0:             ActiveMQQueue senderQueue = new ActiveMQQueue("TEST.QUEUE6");
0: 
0:             MessageProducer producer = senderSession.createProducer(senderQueue);
0: 
0:             Message msg = senderSession.createTextMessage("test");
0:             producer.send(msg);
0:             Thread.sleep(100);
0: 
0:             // Verify exclusive consumer receives the message.
0:             Assert.assertNotNull(exclusiveConsumer1.receive(100));
0:             Assert.assertNull(exclusiveConsumer2.receive(100));
0:             Assert.assertNull(fallbackConsumer.receive(100));
0: 
0:             // Close the exclusive consumer to verify the non-exclusive consumer
0:             // takes over
0:             exclusiveConsumer1.close();
0: 
0:             producer.send(msg);
0:             producer.send(msg);
0: 
0:             Assert.assertNotNull(exclusiveConsumer2.receive(100));
0:             Assert.assertNull(fallbackConsumer.receive(100));
0: 
0:         } finally {
0:             fallbackSession.close();
0:             senderSession.close();
0:             conn.close();
0:         }
0: 
0:     }
0: 
0:     public void testFailoverToNonExclusiveConsumer() throws JMSException, InterruptedException {
0:         Connection conn = createConnection(true);
0: 
0:         Session exclusiveSession = null;
0:         Session fallbackSession = null;
0:         Session senderSession = null;
0: 
0:         try {
0: 
0:             exclusiveSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             fallbackSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             senderSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 
0:             // This creates the exclusive consumer first which avoids AMQ-1024
0:             // bug.
0:             ActiveMQQueue exclusiveQueue = new ActiveMQQueue("TEST.QUEUE3?consumer.exclusive=true");
0:             MessageConsumer exclusiveConsumer = exclusiveSession.createConsumer(exclusiveQueue);
0: 
0:             ActiveMQQueue fallbackQueue = new ActiveMQQueue("TEST.QUEUE3");
0:             MessageConsumer fallbackConsumer = fallbackSession.createConsumer(fallbackQueue);
0: 
0:             ActiveMQQueue senderQueue = new ActiveMQQueue("TEST.QUEUE3");
0: 
0:             MessageProducer producer = senderSession.createProducer(senderQueue);
0: 
0:             Message msg = senderSession.createTextMessage("test");
0:             producer.send(msg);
0:             Thread.sleep(100);
0: 
0:             // Verify exclusive consumer receives the message.
0:             Assert.assertNotNull(exclusiveConsumer.receive(100));
0:             Assert.assertNull(fallbackConsumer.receive(100));
0: 
0:             // Close the exclusive consumer to verify the non-exclusive consumer
0:             // takes over
0:             exclusiveConsumer.close();
0: 
0:             producer.send(msg);
0: 
0:             Assert.assertNotNull(fallbackConsumer.receive(100));
0: 
0:         } finally {
0:             fallbackSession.close();
0:             senderSession.close();
0:             conn.close();
0:         }
0: 
0:     }
0: 
0:     public void testFallbackToExclusiveConsumer() throws JMSException, InterruptedException {
0:         Connection conn = createConnection(true);
0: 
0:         Session exclusiveSession = null;
0:         Session fallbackSession = null;
0:         Session senderSession = null;
0: 
0:         try {
0: 
0:             exclusiveSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             fallbackSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             senderSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 
0:             // This creates the exclusive consumer first which avoids AMQ-1024
0:             // bug.
0:             ActiveMQQueue exclusiveQueue = new ActiveMQQueue("TEST.QUEUE4?consumer.exclusive=true");
0:             MessageConsumer exclusiveConsumer = exclusiveSession.createConsumer(exclusiveQueue);
0: 
0:             ActiveMQQueue fallbackQueue = new ActiveMQQueue("TEST.QUEUE4");
0:             MessageConsumer fallbackConsumer = fallbackSession.createConsumer(fallbackQueue);
0: 
0:             ActiveMQQueue senderQueue = new ActiveMQQueue("TEST.QUEUE4");
0: 
0:             MessageProducer producer = senderSession.createProducer(senderQueue);
0: 
0:             Message msg = senderSession.createTextMessage("test");
0:             producer.send(msg);
0:             Thread.sleep(100);
0: 
0:             // Verify exclusive consumer receives the message.
0:             Assert.assertNotNull(exclusiveConsumer.receive(100));
0:             Assert.assertNull(fallbackConsumer.receive(100));
0: 
0:             // Close the exclusive consumer to verify the non-exclusive consumer
0:             // takes over
0:             exclusiveConsumer.close();
0: 
0:             producer.send(msg);
0: 
0:             // Verify other non-exclusive consumer receices the message.
0:             Assert.assertNotNull(fallbackConsumer.receive(100));
0: 
0:             // Create exclusive consumer to determine if it will start receiving
0:             // the messages.
0:             exclusiveConsumer = exclusiveSession.createConsumer(exclusiveQueue);
0: 
0:             producer.send(msg);
0:             Assert.assertNotNull(exclusiveConsumer.receive(100));
0:             Assert.assertNull(fallbackConsumer.receive(100));
0: 
0:         } finally {
0:             fallbackSession.close();
0:             senderSession.close();
0:             conn.close();
0:         }
0: 
0:     }
commit:6ce8c3b
/////////////////////////////////////////////////////////////////////////
0: /**
0: *
0: * Copyright 2005-2006 The Apache Software Foundation
0: *
0: *  Licensed under the Apache License, Version 2.0 (the "License");
0: *  you may not use this file except in compliance with the License.
0: *  You may obtain a copy of the License at
0: *
0: *     http://www.apache.org/licenses/LICENSE-2.0
0: *
0: *  Unless required by applicable law or agreed to in writing, software
0: *  distributed under the License is distributed on an "AS IS" BASIS,
0: *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0: *  See the License for the specific language governing permissions and
0: *  limitations under the License.
0: */
0: package org.apache.activemq;
0: 
0: import javax.jms.Connection;
0: import javax.jms.ConnectionFactory;
0: import javax.jms.JMSException;
0: import javax.jms.Message;
0: import javax.jms.MessageConsumer;
0: import javax.jms.MessageProducer;
0: import javax.jms.Session;
0: 
0: import junit.framework.Assert;
0: import junit.framework.TestCase;
0: 
0: import org.apache.activemq.ActiveMQConnectionFactory;
0: import org.apache.activemq.command.ActiveMQQueue;
0: 
0: public class ExclusiveConsumerTest extends TestCase {
0: 
0: 	private static final String VM_BROKER_URL = "vm://localhost?broker.persistent=false&broker.useJmx=true";
0: 	
0: 	public ExclusiveConsumerTest(String name) {
0: 		super(name);
0: 	}
0: 
0: 	protected void setUp() throws Exception {
0: 		super.setUp();
0: 	}
0: 
0: 	protected void tearDown() throws Exception {
0: 		super.tearDown();
0: 	}
0: 
0: 	private Connection createConnection(final boolean start) throws JMSException {
0: 		ConnectionFactory cf = new ActiveMQConnectionFactory(VM_BROKER_URL);
0: 		Connection conn = cf.createConnection();
0: 		if (start) {
0: 			conn.start();
0: 		}
0: 		return conn;
0: 	}
0: 	
0: 	public void testExclusiveConsumerSelectedCreatedFirst() throws JMSException, InterruptedException {
0: 		Connection conn = createConnection(true);
0: 		
0: 		Session exclusiveSession = null;
0: 		Session fallbackSession = null;
0: 		Session senderSession = null;
0: 
0: 		try {
0: 			
0: 			exclusiveSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 			fallbackSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 			senderSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 			
0: 			ActiveMQQueue exclusiveQueue = new ActiveMQQueue("TEST.QUEUE1?consumer.exclusive=true");
0: 			MessageConsumer exclusiveConsumer = exclusiveSession.createConsumer(exclusiveQueue);
0: 
0: 			ActiveMQQueue fallbackQueue = new ActiveMQQueue("TEST.QUEUE1");
0: 			MessageConsumer fallbackConsumer = fallbackSession.createConsumer(fallbackQueue);
0: 	
0: 	
0: 			ActiveMQQueue senderQueue = new ActiveMQQueue("TEST.QUEUE1");
0: 
0: 			MessageProducer producer = senderSession.createProducer(senderQueue);
0: 		
0: 			Message msg = senderSession.createTextMessage("test");
0: 			producer.send(msg);
0: 			//TODO need two send a 2nd message - bug AMQ-1024
0: 			//producer.send(msg);
0: 			Thread.sleep(100);
0: 			
0: 			//Verify exclusive consumer receives the message.
0: 			Assert.assertNotNull(exclusiveConsumer.receive(100));
0: 			Assert.assertNull(fallbackConsumer.receive(100));
0: 			
0: 		} finally {
0: 			fallbackSession.close();
0: 			senderSession.close();
0: 			conn.close();
0: 		}
0: 		
0: 	}
0: 	
0: 	public void testExclusiveConsumerSelectedCreatedAfter() throws JMSException, InterruptedException {
0: 		Connection conn = createConnection(true);
0: 		
0: 		Session exclusiveSession = null;
0: 		Session fallbackSession = null;
0: 		Session senderSession = null;
0: 
0: 		try {
0: 			
0: 			exclusiveSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 			fallbackSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 			senderSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 			
0: 			ActiveMQQueue fallbackQueue = new ActiveMQQueue("TEST.QUEUE5");
0: 			MessageConsumer fallbackConsumer = fallbackSession.createConsumer(fallbackQueue);
0: 	
0: 			ActiveMQQueue exclusiveQueue = new ActiveMQQueue("TEST.QUEUE5?consumer.exclusive=true");
0: 			MessageConsumer exclusiveConsumer = exclusiveSession.createConsumer(exclusiveQueue);
0: 	
0: 			ActiveMQQueue senderQueue = new ActiveMQQueue("TEST.QUEUE5");
0: 
0: 			MessageProducer producer = senderSession.createProducer(senderQueue);
0: 		
0: 			Message msg = senderSession.createTextMessage("test");
0: 			producer.send(msg);
0: 			Thread.sleep(100);
0: 			
0: 			//Verify exclusive consumer receives the message.
0: 			Assert.assertNotNull(exclusiveConsumer.receive(100));
0: 			Assert.assertNull(fallbackConsumer.receive(100));
0: 			
0: 		} finally {
0: 			fallbackSession.close();
0: 			senderSession.close();
0: 			conn.close();
0: 		}
0: 		
0: 	}
0: 	
0: 	public void testFailoverToAnotherExclusiveConsumerCreatedFirst() throws JMSException, InterruptedException {
0: 		Connection conn = createConnection(true);
0: 		
0: 		Session exclusiveSession1 = null;
0: 		Session exclusiveSession2 = null;
0: 		Session fallbackSession = null;
0: 		Session senderSession = null;
0: 
0: 		try {
0: 			
0: 			exclusiveSession1 = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 			exclusiveSession2 = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 			fallbackSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 			senderSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 			
0: 			// This creates the exclusive consumer first which avoids AMQ-1024 bug.
0: 			ActiveMQQueue exclusiveQueue = new ActiveMQQueue("TEST.QUEUE2?consumer.exclusive=true");
0: 			MessageConsumer exclusiveConsumer1 = exclusiveSession1.createConsumer(exclusiveQueue);
0: 			MessageConsumer exclusiveConsumer2 = exclusiveSession2.createConsumer(exclusiveQueue);
0: 
0: 			ActiveMQQueue fallbackQueue = new ActiveMQQueue("TEST.QUEUE2");
0: 			MessageConsumer fallbackConsumer = fallbackSession.createConsumer(fallbackQueue);
0: 	
0: 			ActiveMQQueue senderQueue = new ActiveMQQueue("TEST.QUEUE2");
0: 
0: 			MessageProducer producer = senderSession.createProducer(senderQueue);
0: 		
0: 			Message msg = senderSession.createTextMessage("test");
0: 			producer.send(msg);
0: 			Thread.sleep(100);
0: 			
0: 			//Verify exclusive consumer receives the message.
0: 			Assert.assertNotNull(exclusiveConsumer1.receive(100));
0: 			Assert.assertNull(exclusiveConsumer2.receive(100));
0: 			Assert.assertNull(fallbackConsumer.receive(100));
0: 			
0: 			// Close the exclusive consumer to verify the non-exclusive consumer takes over
0: 			exclusiveConsumer1.close();
0: 	
0: 			producer.send(msg);
0: 			producer.send(msg);
0: 			
0: 			Assert.assertNotNull(exclusiveConsumer2.receive(100));
0: 			Assert.assertNull(fallbackConsumer.receive(100));
0: 
0: 
0: 		} finally {
0: 			fallbackSession.close();
0: 			senderSession.close();
0: 			conn.close();
0: 		}
0: 		
0: 	}
0: 	
0: 	public void testFailoverToAnotherExclusiveConsumerCreatedAfter() throws JMSException, InterruptedException {
0: 		Connection conn = createConnection(true);
0: 		
0: 		Session exclusiveSession1 = null;
0: 		Session exclusiveSession2 = null;
0: 		Session fallbackSession = null;
0: 		Session senderSession = null;
0: 
0: 		try {
0: 			
0: 			exclusiveSession1 = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 			exclusiveSession2 = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 			fallbackSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 			senderSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 			
0: 			// This creates the exclusive consumer first which avoids AMQ-1024 bug.
0: 			ActiveMQQueue exclusiveQueue = new ActiveMQQueue("TEST.QUEUE6?consumer.exclusive=true");
0: 			MessageConsumer exclusiveConsumer1 = exclusiveSession1.createConsumer(exclusiveQueue);
0: 
0: 			ActiveMQQueue fallbackQueue = new ActiveMQQueue("TEST.QUEUE6");
0: 			MessageConsumer fallbackConsumer = fallbackSession.createConsumer(fallbackQueue);
0: 	
0: 			MessageConsumer exclusiveConsumer2 = exclusiveSession2.createConsumer(exclusiveQueue);
0: 
0: 			ActiveMQQueue senderQueue = new ActiveMQQueue("TEST.QUEUE6");
0: 
0: 			MessageProducer producer = senderSession.createProducer(senderQueue);
0: 		
0: 			Message msg = senderSession.createTextMessage("test");
0: 			producer.send(msg);
0: 			Thread.sleep(100);
0: 			
0: 			//Verify exclusive consumer receives the message.
0: 			Assert.assertNotNull(exclusiveConsumer1.receive(100));
0: 			Assert.assertNull(exclusiveConsumer2.receive(100));
0: 			Assert.assertNull(fallbackConsumer.receive(100));
0: 			
0: 			// Close the exclusive consumer to verify the non-exclusive consumer takes over
0: 			exclusiveConsumer1.close();
0: 	
0: 			producer.send(msg);
0: 			producer.send(msg);
0: 			
0: 			Assert.assertNotNull(exclusiveConsumer2.receive(100));
0: 			Assert.assertNull(fallbackConsumer.receive(100));
0: 
0: 
0: 		} finally {
0: 			fallbackSession.close();
0: 			senderSession.close();
0: 			conn.close();
0: 		}
0: 		
0: 	}
0: 	public void testFailoverToNonExclusiveConsumer() throws JMSException, InterruptedException {
0: 		Connection conn = createConnection(true);
0: 		
0: 		Session exclusiveSession = null;
0: 		Session fallbackSession = null;
0: 		Session senderSession = null;
0: 
0: 		try {
0: 			
0: 			exclusiveSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 			fallbackSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 			senderSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 			
0: 			// This creates the exclusive consumer first which avoids AMQ-1024 bug.
0: 			ActiveMQQueue exclusiveQueue = new ActiveMQQueue("TEST.QUEUE3?consumer.exclusive=true");
0: 			MessageConsumer exclusiveConsumer = exclusiveSession.createConsumer(exclusiveQueue);
0: 
0: 			ActiveMQQueue fallbackQueue = new ActiveMQQueue("TEST.QUEUE3");
0: 			MessageConsumer fallbackConsumer = fallbackSession.createConsumer(fallbackQueue);
0: 	
0: 			ActiveMQQueue senderQueue = new ActiveMQQueue("TEST.QUEUE3");
0: 
0: 			MessageProducer producer = senderSession.createProducer(senderQueue);
0: 		
0: 			Message msg = senderSession.createTextMessage("test");
0: 			producer.send(msg);
0: 			Thread.sleep(100);
0: 			
0: 			//Verify exclusive consumer receives the message.
0: 			Assert.assertNotNull(exclusiveConsumer.receive(100));
0: 			Assert.assertNull(fallbackConsumer.receive(100));
0: 			
0: 			// Close the exclusive consumer to verify the non-exclusive consumer takes over
0: 			exclusiveConsumer.close();
0: 	
0: 			producer.send(msg);
0: 	
0: 			Assert.assertNotNull(fallbackConsumer.receive(100));
0: 
0: 		} finally {
0: 			fallbackSession.close();
0: 			senderSession.close();
0: 			conn.close();
0: 		}
0: 		
0: 	}
0: 	
0: 	public void testFallbackToExclusiveConsumer() throws JMSException, InterruptedException {
0: 		Connection conn = createConnection(true);
0: 		
0: 		Session exclusiveSession = null;
0: 		Session fallbackSession = null;
0: 		Session senderSession = null;
0: 
0: 		try {
0: 			
0: 			exclusiveSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 			fallbackSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 			senderSession = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 			
0: 			// This creates the exclusive consumer first which avoids AMQ-1024 bug.
0: 			ActiveMQQueue exclusiveQueue = new ActiveMQQueue("TEST.QUEUE4?consumer.exclusive=true");
0: 			MessageConsumer exclusiveConsumer = exclusiveSession.createConsumer(exclusiveQueue);
0: 
0: 			ActiveMQQueue fallbackQueue = new ActiveMQQueue("TEST.QUEUE4");
0: 			MessageConsumer fallbackConsumer = fallbackSession.createConsumer(fallbackQueue);
0: 		
0: 			ActiveMQQueue senderQueue = new ActiveMQQueue("TEST.QUEUE4");
0: 
0: 			MessageProducer producer = senderSession.createProducer(senderQueue);
0: 		
0: 			Message msg = senderSession.createTextMessage("test");
0: 			producer.send(msg);
0: 			Thread.sleep(100);
0: 			
0: 			//Verify exclusive consumer receives the message.
0: 			Assert.assertNotNull(exclusiveConsumer.receive(100));
0: 			Assert.assertNull(fallbackConsumer.receive(100));
0: 			
0: 			// Close the exclusive consumer to verify the non-exclusive consumer takes over
0: 			exclusiveConsumer.close();
0: 	
0: 			producer.send(msg);
0: 
0: 			// Verify other non-exclusive consumer receices the message.
0: 			Assert.assertNotNull(fallbackConsumer.receive(100));
0: 
0: 			// Create exclusive consumer to determine if it will start receiving the messages.
0: 			exclusiveConsumer = exclusiveSession.createConsumer(exclusiveQueue);
0: 
0: 			producer.send(msg);
0: 			Assert.assertNotNull(exclusiveConsumer.receive(100));	
0: 			Assert.assertNull(fallbackConsumer.receive(100));
0: 
0: 		} finally {
0: 			fallbackSession.close();
0: 			senderSession.close();
0: 			conn.close();
0: 		}
0: 		
0: 	}
0: }
============================================================================