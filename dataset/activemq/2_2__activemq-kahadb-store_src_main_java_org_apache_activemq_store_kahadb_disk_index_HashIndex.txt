1:456a2ba: /**
1:456a2ba:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:456a2ba:  * contributor license agreements.  See the NOTICE file distributed with
1:456a2ba:  * this work for additional information regarding copyright ownership.
1:456a2ba:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:456a2ba:  * (the "License"); you may not use this file except in compliance with
1:456a2ba:  * the License.  You may obtain a copy of the License at
1:456a2ba:  *
1:456a2ba:  *      http://www.apache.org/licenses/LICENSE-2.0
1:456a2ba:  *
1:456a2ba:  * Unless required by applicable law or agreed to in writing, software
1:456a2ba:  * distributed under the License is distributed on an "AS IS" BASIS,
1:456a2ba:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:456a2ba:  * See the License for the specific language governing permissions and
1:456a2ba:  * limitations under the License.
1:456a2ba:  */
1:1aab71b: package org.apache.activemq.store.kahadb.disk.index;
2:456a2ba: 
1:456a2ba: import java.io.DataInput;
1:456a2ba: import java.io.DataOutput;
1:456a2ba: import java.io.IOException;
1:456a2ba: import java.util.Iterator;
1:456a2ba: import java.util.Map;
1:456a2ba: import java.util.Map.Entry;
1:456a2ba: import java.util.concurrent.atomic.AtomicBoolean;
1:456a2ba: 
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.page.Page;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.page.PageFile;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.page.Transaction;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.util.Marshaller;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.util.VariableMarshaller;
1:456a2ba: 
1:456a2ba: /**
1:456a2ba:  * BTree implementation
1:0bbc0ac:  * 
1:456a2ba:  * 
1:456a2ba:  */
1:456a2ba: public class HashIndex<Key,Value> implements Index<Key,Value> {
1:456a2ba: 
1:456a2ba:     public static final int CLOSED_STATE = 1;
1:456a2ba:     public static final int OPEN_STATE = 2;
1:456a2ba: 
1:456a2ba: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(HashIndex.class);
1:456a2ba: 
1:456a2ba:     public static final int DEFAULT_BIN_CAPACITY;
1:456a2ba:     public static final int DEFAULT_MAXIMUM_BIN_CAPACITY;
1:456a2ba:     public static final int DEFAULT_MINIMUM_BIN_CAPACITY;
1:456a2ba:     public static final int DEFAULT_LOAD_FACTOR;
1:456a2ba: 
1:456a2ba:     static {
1:456a2ba:         DEFAULT_BIN_CAPACITY = Integer.parseInt(System.getProperty("defaultBinSize", "1024"));
1:456a2ba:         DEFAULT_MAXIMUM_BIN_CAPACITY = Integer.parseInt(System.getProperty("maximumCapacity", "16384"));
1:456a2ba:         DEFAULT_MINIMUM_BIN_CAPACITY = Integer.parseInt(System.getProperty("minimumCapacity", "16"));
1:456a2ba:         DEFAULT_LOAD_FACTOR = Integer.parseInt(System.getProperty("defaultLoadFactor", "75"));
2:456a2ba:     }
1:456a2ba: 
1:456a2ba:     private AtomicBoolean loaded = new AtomicBoolean();
1:456a2ba: 
1:456a2ba: 
1:456a2ba:     private int increaseThreshold;
1:456a2ba:     private int decreaseThreshold;
1:456a2ba: 
1:456a2ba:     // Where the bin page array starts at.
1:456a2ba:     private int maximumBinCapacity = DEFAULT_MAXIMUM_BIN_CAPACITY;
1:456a2ba:     private int minimumBinCapacity = DEFAULT_MINIMUM_BIN_CAPACITY;
1:456a2ba: 
1:456a2ba: 
1:456a2ba: 
1:456a2ba:     // Once binsActive/binCapacity reaches the loadFactor, then we need to
1:456a2ba:     // increase the capacity
1:456a2ba:     private int loadFactor = DEFAULT_LOAD_FACTOR;
1:456a2ba: 
1:456a2ba:     private PageFile pageFile;
1:456a2ba:     // This page holds the index metadata.
1:456a2ba:     private long pageId;
1:456a2ba: 
1:456a2ba:     static class Metadata {
1:456a2ba:         
1:456a2ba:         private Page<Metadata> page;
1:456a2ba:         
1:456a2ba:         // When the index is initializing or resizing.. state changes so that
1:456a2ba:         // on failure it can be properly recovered.
1:456a2ba:         private int state;
1:456a2ba:         private long binPageId;
1:456a2ba:         private int binCapacity = DEFAULT_BIN_CAPACITY;
1:456a2ba:         private int binsActive;
1:456a2ba:         private int size;
1:456a2ba: 
1:456a2ba:         
1:456a2ba:         public void read(DataInput is) throws IOException {
1:456a2ba:             state = is.readInt();
1:456a2ba:             binPageId = is.readLong();
1:456a2ba:             binCapacity = is.readInt();
1:456a2ba:             size = is.readInt();
1:456a2ba:             binsActive = is.readInt();
1:456a2ba:         }
1:456a2ba:         public void write(DataOutput os) throws IOException {
1:456a2ba:             os.writeInt(state);
1:456a2ba:             os.writeLong(binPageId);
1:456a2ba:             os.writeInt(binCapacity);
1:456a2ba:             os.writeInt(size);
1:456a2ba:             os.writeInt(binsActive);
1:456a2ba:         }
1:456a2ba:         
1:e22a37a:         static class Marshaller extends VariableMarshaller<Metadata> {
1:456a2ba:             public Metadata readPayload(DataInput dataIn) throws IOException {
1:456a2ba:                 Metadata rc = new Metadata();
1:456a2ba:                 rc.read(dataIn);
1:456a2ba:                 return rc;
1:456a2ba:             }
1:456a2ba: 
1:456a2ba:             public void writePayload(Metadata object, DataOutput dataOut) throws IOException {
1:456a2ba:                 object.write(dataOut);
1:456a2ba:             }
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba:     
1:456a2ba:     private Metadata metadata = new Metadata();
1:456a2ba:     
1:456a2ba:     private Metadata.Marshaller metadataMarshaller = new Metadata.Marshaller();
1:456a2ba:     private HashBin.Marshaller<Key,Value> hashBinMarshaller = new HashBin.Marshaller<Key,Value>(this);
1:456a2ba:     private Marshaller<Key> keyMarshaller;
1:456a2ba:     private Marshaller<Value> valueMarshaller;
1:456a2ba: 
1:456a2ba:     
1:456a2ba:     /**
1:456a2ba:      * Constructor
1:456a2ba:      * 
1:456a2ba:      * @param directory
1:456a2ba:      * @param name
1:456a2ba:      * @param indexManager
1:456a2ba:      * @param numberOfBins
1:456a2ba:      * @throws IOException
1:456a2ba:      */
1:456a2ba:     public HashIndex(PageFile pageFile, long pageId) throws IOException {
1:456a2ba:         this.pageFile = pageFile;
1:456a2ba:         this.pageId = pageId;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public synchronized void load(Transaction tx) throws IOException {
1:456a2ba:         if (loaded.compareAndSet(false, true)) {
1:456a2ba:             final Page<Metadata> metadataPage = tx.load(pageId, metadataMarshaller);
1:456a2ba:             // Is this a brand new index?
1:456a2ba:             if (metadataPage.getType() == Page.PAGE_FREE_TYPE) {
1:456a2ba:                 // We need to create the pages for the bins
1:456a2ba:                 Page binPage = tx.allocate(metadata.binCapacity);
1:456a2ba:                 metadata.binPageId = binPage.getPageId();
1:456a2ba:                 metadata.page = metadataPage;
1:456a2ba:                 metadataPage.set(metadata);
1:456a2ba:                 clear(tx);
1:456a2ba: 
1:456a2ba:                 // If failure happens now we can continue initializing the
1:456a2ba:                 // the hash bins...
1:456a2ba:             } else {
1:456a2ba: 
1:456a2ba:                 metadata = metadataPage.get();
1:456a2ba:                 metadata.page = metadataPage;
1:456a2ba:                 
1:456a2ba:                 // If we did not have a clean shutdown...
1:456a2ba:                 if (metadata.state == OPEN_STATE ) {
1:456a2ba:                     // Figure out the size and the # of bins that are
1:456a2ba:                     // active. Yeah This loads the first page of every bin. :(
1:456a2ba:                     // We might want to put this in the metadata page, but
1:456a2ba:                     // then that page would be getting updated on every write.
1:456a2ba:                     metadata.size = 0;
1:456a2ba:                     for (int i = 0; i < metadata.binCapacity; i++) {
1:456a2ba:                         int t = sizeOfBin(tx, i);
1:456a2ba:                         if (t > 0) {
1:456a2ba:                             metadata.binsActive++;
1:456a2ba:                         }
1:456a2ba:                         metadata.size += t;
1:456a2ba:                     }
1:456a2ba:                 }
1:456a2ba:             }
1:456a2ba: 
1:456a2ba:             calcThresholds();
1:456a2ba: 
1:456a2ba:             metadata.state = OPEN_STATE;
1:456a2ba:             tx.store(metadataPage, metadataMarshaller, true);
1:456a2ba:             
1:456a2ba:             LOG.debug("HashIndex loaded. Using "+metadata.binCapacity+" bins starting at page "+metadata.binPageId);
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public synchronized void unload(Transaction tx) throws IOException {
1:456a2ba:         if (loaded.compareAndSet(true, false)) {
1:456a2ba:             metadata.state = CLOSED_STATE;
1:456a2ba:             tx.store(metadata.page, metadataMarshaller, true);
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     private int sizeOfBin(Transaction tx, int index) throws IOException {
1:456a2ba:         return getBin(tx, index).size();
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public synchronized Value get(Transaction tx, Key key) throws IOException {
1:456a2ba:         assertLoaded();
1:456a2ba:         return getBin(tx, key).get(key);
1:456a2ba:     }
1:456a2ba:     
1:456a2ba:     public synchronized boolean containsKey(Transaction tx, Key key) throws IOException {
1:456a2ba:         assertLoaded();
1:456a2ba:         return getBin(tx, key).containsKey(key);
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     synchronized public Value put(Transaction tx, Key key, Value value) throws IOException {
1:456a2ba:         assertLoaded();
1:456a2ba:         HashBin<Key,Value> bin = getBin(tx, key);
1:456a2ba: 
1:456a2ba:         int originalSize = bin.size();
1:456a2ba:         Value result = bin.put(key,value);
1:456a2ba:         store(tx, bin);
1:456a2ba: 
1:456a2ba:         int newSize = bin.size();
1:456a2ba: 
1:456a2ba:         if (newSize != originalSize) {
1:456a2ba:             metadata.size++;
1:456a2ba:             if (newSize == 1) {
1:456a2ba:                 metadata.binsActive++;
1:456a2ba:             }
1:456a2ba:         }
1:456a2ba: 
1:456a2ba:         if (metadata.binsActive >= this.increaseThreshold) {
1:456a2ba:             newSize = Math.min(maximumBinCapacity, metadata.binCapacity*2);
1:456a2ba:             if(metadata.binCapacity!=newSize) {
1:456a2ba:                 resize(tx, newSize);
1:456a2ba:             }
1:456a2ba:         }
1:456a2ba:         return result;
1:456a2ba:     }
1:456a2ba:     
1:456a2ba:     synchronized public Value remove(Transaction tx, Key key) throws IOException {
1:456a2ba:         assertLoaded();
1:456a2ba: 
1:456a2ba:         HashBin<Key,Value> bin = getBin(tx, key);
1:456a2ba:         int originalSize = bin.size();
1:456a2ba:         Value result = bin.remove(key);
1:456a2ba:         int newSize = bin.size();
1:456a2ba:         
1:456a2ba:         if (newSize != originalSize) {
1:456a2ba:             store(tx, bin);
1:456a2ba: 
1:456a2ba:             metadata.size--;
1:456a2ba:             if (newSize == 0) {
1:456a2ba:                 metadata.binsActive--;
1:456a2ba:             }
1:456a2ba:         }
1:456a2ba: 
1:456a2ba:         if (metadata.binsActive <= this.decreaseThreshold) {
1:456a2ba:             newSize = Math.max(minimumBinCapacity, metadata.binCapacity/2);
1:456a2ba:             if(metadata.binCapacity!=newSize) {
1:456a2ba:                 resize(tx, newSize);
1:456a2ba:             }
1:456a2ba:         }
1:456a2ba:         return result;
1:456a2ba:     }
1:456a2ba:     
1:456a2ba: 
1:456a2ba:     public synchronized void clear(Transaction tx) throws IOException {
1:456a2ba:         assertLoaded();
1:456a2ba:         for (int i = 0; i < metadata.binCapacity; i++) {
1:456a2ba:             long pageId = metadata.binPageId + i;
1:456a2ba:             clearBinAtPage(tx, pageId);
1:456a2ba:         }
1:456a2ba:         metadata.size = 0;
1:456a2ba:         metadata.binsActive = 0;
1:456a2ba:     }
1:456a2ba:     
1:456a2ba:     public Iterator<Entry<Key, Value>> iterator(Transaction tx) throws IOException, UnsupportedOperationException {
1:456a2ba:         throw new UnsupportedOperationException();
1:456a2ba:     }
1:456a2ba: 
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * @param tx
1:456a2ba:      * @param pageId
1:456a2ba:      * @throws IOException
1:456a2ba:      */
1:456a2ba:     private void clearBinAtPage(Transaction tx, long pageId) throws IOException {
1:456a2ba:         Page<HashBin<Key,Value>> page = tx.load(pageId, null);
1:456a2ba:         HashBin<Key, Value> bin = new HashBin<Key,Value>();
1:456a2ba:         bin.setPage(page);
1:456a2ba:         page.set(bin);
1:456a2ba:         store(tx, bin);
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public String toString() {
1:456a2ba:         String str = "HashIndex" + System.identityHashCode(this) + ": " + pageFile;
1:456a2ba:         return str;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     // /////////////////////////////////////////////////////////////////
1:456a2ba:     // Implementation Methods
1:456a2ba:     // /////////////////////////////////////////////////////////////////
1:456a2ba: 
1:456a2ba:     private void assertLoaded() throws IllegalStateException {
1:456a2ba:         if( !loaded.get() ) {
1:456a2ba:             throw new IllegalStateException("The HashIndex is not loaded");
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public synchronized void store(Transaction tx, HashBin<Key,Value> bin) throws IOException {
1:456a2ba:         tx.store(bin.getPage(), hashBinMarshaller, true);
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     // While resizing, the following contains the new resize data.
1:456a2ba:     
1:456a2ba:     private void resize(Transaction tx, final int newSize) throws IOException {
1:456a2ba:         LOG.debug("Resizing to: "+newSize);
1:456a2ba:         
1:456a2ba:         int resizeCapacity = newSize;
1:456a2ba:         long resizePageId = tx.allocate(resizeCapacity).getPageId();
1:456a2ba: 
1:456a2ba:         // In Phase 1 we copy the data to the new bins..
1:456a2ba:         // Initialize the bins..
1:456a2ba:         for (int i = 0; i < resizeCapacity; i++) {
1:456a2ba:             long pageId = resizePageId + i;
1:456a2ba:             clearBinAtPage(tx, pageId);
1:456a2ba:         }
1:456a2ba: 
1:456a2ba:         metadata.binsActive = 0;
1:456a2ba:         // Copy the data from the old bins to the new bins.
1:456a2ba:         for (int i = 0; i < metadata.binCapacity; i++) {
1:456a2ba:             
1:456a2ba:             HashBin<Key,Value> bin = getBin(tx, i);
1:456a2ba:             for (Map.Entry<Key, Value> entry : bin.getAll(tx).entrySet()) {
1:456a2ba:                 HashBin<Key,Value> resizeBin = getBin(tx, entry.getKey(), resizePageId, resizeCapacity);
1:456a2ba:                 resizeBin.put(entry.getKey(), entry.getValue());
1:456a2ba:                 store(tx, resizeBin);
1:456a2ba:                 if( resizeBin.size() == 1) {
1:456a2ba:                     metadata.binsActive++;
1:456a2ba:                 }
1:456a2ba:             }
1:456a2ba:         }
1:456a2ba:         
1:456a2ba:         // In phase 2 we free the old bins and switch the the new bins.
1:456a2ba:         tx.free(metadata.binPageId, metadata.binCapacity);
1:456a2ba:         
1:456a2ba:         metadata.binCapacity = resizeCapacity;
1:456a2ba:         metadata.binPageId = resizePageId;
1:456a2ba:         metadata.state = OPEN_STATE;
1:456a2ba:         tx.store(metadata.page, metadataMarshaller, true);
1:456a2ba:         calcThresholds();
1:456a2ba: 
1:456a2ba:         LOG.debug("Resizing done.  New bins start at: "+metadata.binPageId);
1:456a2ba:         resizeCapacity=0;
1:456a2ba:         resizePageId=0;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     private void calcThresholds() {
1:456a2ba:         increaseThreshold = (metadata.binCapacity * loadFactor)/100;
1:456a2ba:         decreaseThreshold = (metadata.binCapacity * loadFactor * loadFactor ) / 20000;
1:456a2ba:     }
1:456a2ba:     
1:456a2ba:     private HashBin<Key,Value> getBin(Transaction tx, Key key) throws IOException {
1:456a2ba:         return getBin(tx, key, metadata.binPageId, metadata.binCapacity);
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     private HashBin<Key,Value> getBin(Transaction tx, int i) throws IOException {
1:456a2ba:         return getBin(tx, i, metadata.binPageId);
1:456a2ba:     }
1:456a2ba:     
1:456a2ba:     private HashBin<Key,Value> getBin(Transaction tx, Key key, long basePage, int capacity) throws IOException {
1:456a2ba:         int i = indexFor(key, capacity);
1:456a2ba:         return getBin(tx, i, basePage);
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     private HashBin<Key,Value> getBin(Transaction tx, int i, long basePage) throws IOException {
1:456a2ba:         Page<HashBin<Key, Value>> page = tx.load(basePage + i, hashBinMarshaller);
1:456a2ba:         HashBin<Key, Value> rc = page.get();
1:456a2ba:         rc.setPage(page);
1:456a2ba:         return rc;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     int indexFor(Key x, int length) {
1:456a2ba:         return Math.abs(x.hashCode()%length);
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     // /////////////////////////////////////////////////////////////////
1:456a2ba:     // Property Accessors
1:456a2ba:     // /////////////////////////////////////////////////////////////////
1:456a2ba: 
1:456a2ba:     public Marshaller<Key> getKeyMarshaller() {
1:456a2ba:         return keyMarshaller;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * Set the marshaller for key objects
1:456a2ba:      * 
1:456a2ba:      * @param marshaller
1:456a2ba:      */
1:456a2ba:     public synchronized void setKeyMarshaller(Marshaller<Key> marshaller) {
1:456a2ba:         this.keyMarshaller = marshaller;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public Marshaller<Value> getValueMarshaller() {
1:456a2ba:         return valueMarshaller;
1:456a2ba:     }
1:456a2ba:     /**
1:456a2ba:      * Set the marshaller for value objects
1:456a2ba:      * 
1:456a2ba:      * @param marshaller
1:456a2ba:      */
1:456a2ba:     public void setValueMarshaller(Marshaller<Value> valueMarshaller) {
1:456a2ba:         this.valueMarshaller = valueMarshaller;
1:456a2ba:     }
1:456a2ba:     
1:456a2ba:     /**
1:456a2ba:      * @return number of bins in the index
1:456a2ba:      */
1:456a2ba:     public int getBinCapacity() {
1:456a2ba:         return metadata.binCapacity;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * @param binCapacity
1:456a2ba:      */
1:456a2ba:     public void setBinCapacity(int binCapacity) {
1:456a2ba:         if (loaded.get() && binCapacity != metadata.binCapacity) {
1:456a2ba:             throw new RuntimeException("Pages already loaded - can't reset bin capacity");
1:456a2ba:         }
1:456a2ba:         metadata.binCapacity = binCapacity;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public boolean isTransient() {
1:456a2ba:         return false;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * @return the loadFactor
1:456a2ba:      */
1:456a2ba:     public int getLoadFactor() {
1:456a2ba:         return loadFactor;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * @param loadFactor the loadFactor to set
1:456a2ba:      */
1:456a2ba:     public void setLoadFactor(int loadFactor) {
1:456a2ba:         this.loadFactor = loadFactor;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * @return the maximumCapacity
1:456a2ba:      */
1:456a2ba:     public int setMaximumBinCapacity() {
1:456a2ba:         return maximumBinCapacity;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * @param maximumCapacity the maximumCapacity to set
1:456a2ba:      */
1:456a2ba:     public void setMaximumBinCapacity(int maximumCapacity) {
1:456a2ba:         this.maximumBinCapacity = maximumCapacity;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public synchronized int size(Transaction tx) {
1:456a2ba:         return metadata.size;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public synchronized int getActiveBins() {
1:456a2ba:         return metadata.binsActive;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public long getBinPageId() {
1:456a2ba:         return metadata.binPageId;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public PageFile getPageFile() {
1:456a2ba:         return pageFile;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public int getBinsActive() {
1:456a2ba:         return metadata.binsActive;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba: }
============================================================================
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:c5cf038
commit:1aab71b
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.store.kahadb.disk.index;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.kahadb.disk.page.Page;
1: import org.apache.activemq.store.kahadb.disk.page.PageFile;
1: import org.apache.activemq.store.kahadb.disk.page.Transaction;
1: import org.apache.activemq.store.kahadb.disk.util.Marshaller;
1: import org.apache.activemq.store.kahadb.disk.util.VariableMarshaller;
commit:715010a
commit:0bbc0ac
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:e22a37a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.kahadb.util.VariableMarshaller;
/////////////////////////////////////////////////////////////////////////
1:         static class Marshaller extends VariableMarshaller<Metadata> {
commit:f73b622
/////////////////////////////////////////////////////////////////////////
commit:456a2ba
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: package org.apache.kahadb.index;
1: 
1: import java.io.DataInput;
1: import java.io.DataOutput;
1: import java.io.IOException;
1: import java.util.Iterator;
1: import java.util.Map;
1: import java.util.Map.Entry;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: 
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: import org.apache.kahadb.page.Page;
0: import org.apache.kahadb.page.PageFile;
0: import org.apache.kahadb.page.Transaction;
0: import org.apache.kahadb.page.Transaction.Closure;
0: import org.apache.kahadb.util.Marshaller;
1: 
1: /**
1:  * BTree implementation
1:  * 
0:  * @version $Revision$
1:  */
1: public class HashIndex<Key,Value> implements Index<Key,Value> {
1: 
1:     public static final int CLOSED_STATE = 1;
1:     public static final int OPEN_STATE = 2;
1: 
1: 
0:     private static final Log LOG = LogFactory.getLog(HashIndex.class);
1: 
1:     public static final int DEFAULT_BIN_CAPACITY;
1:     public static final int DEFAULT_MAXIMUM_BIN_CAPACITY;
1:     public static final int DEFAULT_MINIMUM_BIN_CAPACITY;
1:     public static final int DEFAULT_LOAD_FACTOR;
1: 
1:     static {
1:         DEFAULT_BIN_CAPACITY = Integer.parseInt(System.getProperty("defaultBinSize", "1024"));
1:         DEFAULT_MAXIMUM_BIN_CAPACITY = Integer.parseInt(System.getProperty("maximumCapacity", "16384"));
1:         DEFAULT_MINIMUM_BIN_CAPACITY = Integer.parseInt(System.getProperty("minimumCapacity", "16"));
1:         DEFAULT_LOAD_FACTOR = Integer.parseInt(System.getProperty("defaultLoadFactor", "75"));
1:     }
1: 
1:     private AtomicBoolean loaded = new AtomicBoolean();
1: 
1: 
1:     private int increaseThreshold;
1:     private int decreaseThreshold;
1: 
1:     // Where the bin page array starts at.
1:     private int maximumBinCapacity = DEFAULT_MAXIMUM_BIN_CAPACITY;
1:     private int minimumBinCapacity = DEFAULT_MINIMUM_BIN_CAPACITY;
1: 
1: 
1: 
1:     // Once binsActive/binCapacity reaches the loadFactor, then we need to
1:     // increase the capacity
1:     private int loadFactor = DEFAULT_LOAD_FACTOR;
1: 
1:     private PageFile pageFile;
1:     // This page holds the index metadata.
1:     private long pageId;
1: 
1:     static class Metadata {
1:         
1:         private Page<Metadata> page;
1:         
1:         // When the index is initializing or resizing.. state changes so that
1:         // on failure it can be properly recovered.
1:         private int state;
1:         private long binPageId;
1:         private int binCapacity = DEFAULT_BIN_CAPACITY;
1:         private int binsActive;
1:         private int size;
1: 
1:         
1:         public void read(DataInput is) throws IOException {
1:             state = is.readInt();
1:             binPageId = is.readLong();
1:             binCapacity = is.readInt();
1:             size = is.readInt();
1:             binsActive = is.readInt();
1:         }
1:         public void write(DataOutput os) throws IOException {
1:             os.writeInt(state);
1:             os.writeLong(binPageId);
1:             os.writeInt(binCapacity);
1:             os.writeInt(size);
1:             os.writeInt(binsActive);
1:         }
1:         
0:         static class Marshaller implements org.apache.kahadb.util.Marshaller<Metadata> {
0:             public Class<Metadata> getType() {
0:                 return Metadata.class;
1:             }
1: 
1:             public Metadata readPayload(DataInput dataIn) throws IOException {
1:                 Metadata rc = new Metadata();
1:                 rc.read(dataIn);
1:                 return rc;
1:             }
1: 
1:             public void writePayload(Metadata object, DataOutput dataOut) throws IOException {
1:                 object.write(dataOut);
1:             }
1:         }
1:     }
1:     
1:     private Metadata metadata = new Metadata();
1:     
1:     private Metadata.Marshaller metadataMarshaller = new Metadata.Marshaller();
1:     private HashBin.Marshaller<Key,Value> hashBinMarshaller = new HashBin.Marshaller<Key,Value>(this);
1:     private Marshaller<Key> keyMarshaller;
1:     private Marshaller<Value> valueMarshaller;
1: 
1:     
1:     /**
1:      * Constructor
1:      * 
1:      * @param directory
1:      * @param name
1:      * @param indexManager
1:      * @param numberOfBins
1:      * @throws IOException
1:      */
1:     public HashIndex(PageFile pageFile, long pageId) throws IOException {
1:         this.pageFile = pageFile;
1:         this.pageId = pageId;
1:     }
1: 
1:     public synchronized void load(Transaction tx) throws IOException {
1:         if (loaded.compareAndSet(false, true)) {
1:             final Page<Metadata> metadataPage = tx.load(pageId, metadataMarshaller);
1:             // Is this a brand new index?
1:             if (metadataPage.getType() == Page.PAGE_FREE_TYPE) {
1:                 // We need to create the pages for the bins
1:                 Page binPage = tx.allocate(metadata.binCapacity);
1:                 metadata.binPageId = binPage.getPageId();
1:                 metadata.page = metadataPage;
1:                 metadataPage.set(metadata);
1:                 clear(tx);
1: 
1:                 // If failure happens now we can continue initializing the
1:                 // the hash bins...
1:             } else {
1: 
1:                 metadata = metadataPage.get();
1:                 metadata.page = metadataPage;
1:                 
1:                 // If we did not have a clean shutdown...
1:                 if (metadata.state == OPEN_STATE ) {
1:                     // Figure out the size and the # of bins that are
1:                     // active. Yeah This loads the first page of every bin. :(
1:                     // We might want to put this in the metadata page, but
1:                     // then that page would be getting updated on every write.
1:                     metadata.size = 0;
1:                     for (int i = 0; i < metadata.binCapacity; i++) {
1:                         int t = sizeOfBin(tx, i);
1:                         if (t > 0) {
1:                             metadata.binsActive++;
1:                         }
1:                         metadata.size += t;
1:                     }
1:                 }
1:             }
1: 
1:             calcThresholds();
1: 
1:             metadata.state = OPEN_STATE;
1:             tx.store(metadataPage, metadataMarshaller, true);
1:             
1:             LOG.debug("HashIndex loaded. Using "+metadata.binCapacity+" bins starting at page "+metadata.binPageId);
1:         }
1:     }
1: 
1:     public synchronized void unload(Transaction tx) throws IOException {
1:         if (loaded.compareAndSet(true, false)) {
1:             metadata.state = CLOSED_STATE;
1:             tx.store(metadata.page, metadataMarshaller, true);
1:         }
1:     }
1: 
1:     private int sizeOfBin(Transaction tx, int index) throws IOException {
1:         return getBin(tx, index).size();
1:     }
1: 
1:     public synchronized Value get(Transaction tx, Key key) throws IOException {
1:         assertLoaded();
1:         return getBin(tx, key).get(key);
1:     }
1:     
1:     public synchronized boolean containsKey(Transaction tx, Key key) throws IOException {
1:         assertLoaded();
1:         return getBin(tx, key).containsKey(key);
1:     }
1: 
1:     synchronized public Value put(Transaction tx, Key key, Value value) throws IOException {
1:         assertLoaded();
1:         HashBin<Key,Value> bin = getBin(tx, key);
1: 
1:         int originalSize = bin.size();
1:         Value result = bin.put(key,value);
1:         store(tx, bin);
1: 
1:         int newSize = bin.size();
1: 
1:         if (newSize != originalSize) {
1:             metadata.size++;
1:             if (newSize == 1) {
1:                 metadata.binsActive++;
1:             }
1:         }
1: 
1:         if (metadata.binsActive >= this.increaseThreshold) {
1:             newSize = Math.min(maximumBinCapacity, metadata.binCapacity*2);
1:             if(metadata.binCapacity!=newSize) {
1:                 resize(tx, newSize);
1:             }
1:         }
1:         return result;
1:     }
1:     
1:     synchronized public Value remove(Transaction tx, Key key) throws IOException {
1:         assertLoaded();
1: 
1:         HashBin<Key,Value> bin = getBin(tx, key);
1:         int originalSize = bin.size();
1:         Value result = bin.remove(key);
1:         int newSize = bin.size();
1:         
1:         if (newSize != originalSize) {
1:             store(tx, bin);
1: 
1:             metadata.size--;
1:             if (newSize == 0) {
1:                 metadata.binsActive--;
1:             }
1:         }
1: 
1:         if (metadata.binsActive <= this.decreaseThreshold) {
1:             newSize = Math.max(minimumBinCapacity, metadata.binCapacity/2);
1:             if(metadata.binCapacity!=newSize) {
1:                 resize(tx, newSize);
1:             }
1:         }
1:         return result;
1:     }
1:     
1: 
1:     public synchronized void clear(Transaction tx) throws IOException {
1:         assertLoaded();
1:         for (int i = 0; i < metadata.binCapacity; i++) {
1:             long pageId = metadata.binPageId + i;
1:             clearBinAtPage(tx, pageId);
1:         }
1:         metadata.size = 0;
1:         metadata.binsActive = 0;
1:     }
1:     
1:     public Iterator<Entry<Key, Value>> iterator(Transaction tx) throws IOException, UnsupportedOperationException {
1:         throw new UnsupportedOperationException();
1:     }
1: 
1: 
1:     /**
1:      * @param tx
1:      * @param pageId
1:      * @throws IOException
1:      */
1:     private void clearBinAtPage(Transaction tx, long pageId) throws IOException {
1:         Page<HashBin<Key,Value>> page = tx.load(pageId, null);
1:         HashBin<Key, Value> bin = new HashBin<Key,Value>();
1:         bin.setPage(page);
1:         page.set(bin);
1:         store(tx, bin);
1:     }
1: 
1:     public String toString() {
1:         String str = "HashIndex" + System.identityHashCode(this) + ": " + pageFile;
1:         return str;
1:     }
1: 
1:     // /////////////////////////////////////////////////////////////////
1:     // Implementation Methods
1:     // /////////////////////////////////////////////////////////////////
1: 
1:     private void assertLoaded() throws IllegalStateException {
1:         if( !loaded.get() ) {
1:             throw new IllegalStateException("The HashIndex is not loaded");
1:         }
1:     }
1: 
1:     public synchronized void store(Transaction tx, HashBin<Key,Value> bin) throws IOException {
1:         tx.store(bin.getPage(), hashBinMarshaller, true);
1:     }
1: 
1:     // While resizing, the following contains the new resize data.
1:     
1:     private void resize(Transaction tx, final int newSize) throws IOException {
1:         LOG.debug("Resizing to: "+newSize);
1:         
1:         int resizeCapacity = newSize;
1:         long resizePageId = tx.allocate(resizeCapacity).getPageId();
1: 
1:         // In Phase 1 we copy the data to the new bins..
1:         // Initialize the bins..
1:         for (int i = 0; i < resizeCapacity; i++) {
1:             long pageId = resizePageId + i;
1:             clearBinAtPage(tx, pageId);
1:         }
1: 
1:         metadata.binsActive = 0;
1:         // Copy the data from the old bins to the new bins.
1:         for (int i = 0; i < metadata.binCapacity; i++) {
1:             
1:             HashBin<Key,Value> bin = getBin(tx, i);
1:             for (Map.Entry<Key, Value> entry : bin.getAll(tx).entrySet()) {
1:                 HashBin<Key,Value> resizeBin = getBin(tx, entry.getKey(), resizePageId, resizeCapacity);
1:                 resizeBin.put(entry.getKey(), entry.getValue());
1:                 store(tx, resizeBin);
1:                 if( resizeBin.size() == 1) {
1:                     metadata.binsActive++;
1:                 }
1:             }
1:         }
1:         
1:         // In phase 2 we free the old bins and switch the the new bins.
1:         tx.free(metadata.binPageId, metadata.binCapacity);
1:         
1:         metadata.binCapacity = resizeCapacity;
1:         metadata.binPageId = resizePageId;
1:         metadata.state = OPEN_STATE;
1:         tx.store(metadata.page, metadataMarshaller, true);
1:         calcThresholds();
1: 
1:         LOG.debug("Resizing done.  New bins start at: "+metadata.binPageId);        
1:         resizeCapacity=0;
1:         resizePageId=0;
1:     }
1: 
1:     private void calcThresholds() {
1:         increaseThreshold = (metadata.binCapacity * loadFactor)/100;
1:         decreaseThreshold = (metadata.binCapacity * loadFactor * loadFactor ) / 20000;
1:     }
1:     
1:     private HashBin<Key,Value> getBin(Transaction tx, Key key) throws IOException {
1:         return getBin(tx, key, metadata.binPageId, metadata.binCapacity);
1:     }
1: 
1:     private HashBin<Key,Value> getBin(Transaction tx, int i) throws IOException {
1:         return getBin(tx, i, metadata.binPageId);
1:     }
1:     
1:     private HashBin<Key,Value> getBin(Transaction tx, Key key, long basePage, int capacity) throws IOException {
1:         int i = indexFor(key, capacity);
1:         return getBin(tx, i, basePage);
1:     }
1: 
1:     private HashBin<Key,Value> getBin(Transaction tx, int i, long basePage) throws IOException {
1:         Page<HashBin<Key, Value>> page = tx.load(basePage + i, hashBinMarshaller);
1:         HashBin<Key, Value> rc = page.get();
1:         rc.setPage(page);
1:         return rc;
1:     }
1: 
1:     int indexFor(Key x, int length) {
1:         return Math.abs(x.hashCode()%length);
1:     }
1: 
1:     // /////////////////////////////////////////////////////////////////
1:     // Property Accessors
1:     // /////////////////////////////////////////////////////////////////
1: 
1:     public Marshaller<Key> getKeyMarshaller() {
1:         return keyMarshaller;
1:     }
1: 
1:     /**
1:      * Set the marshaller for key objects
1:      * 
1:      * @param marshaller
1:      */
1:     public synchronized void setKeyMarshaller(Marshaller<Key> marshaller) {
1:         this.keyMarshaller = marshaller;
1:     }
1: 
1:     public Marshaller<Value> getValueMarshaller() {
1:         return valueMarshaller;
1:     }
1:     /**
1:      * Set the marshaller for value objects
1:      * 
1:      * @param marshaller
1:      */
1:     public void setValueMarshaller(Marshaller<Value> valueMarshaller) {
1:         this.valueMarshaller = valueMarshaller;
1:     }
1:     
1:     /**
1:      * @return number of bins in the index
1:      */
1:     public int getBinCapacity() {
1:         return metadata.binCapacity;
1:     }
1: 
1:     /**
1:      * @param binCapacity
1:      */
1:     public void setBinCapacity(int binCapacity) {
1:         if (loaded.get() && binCapacity != metadata.binCapacity) {
1:             throw new RuntimeException("Pages already loaded - can't reset bin capacity");
1:         }
1:         metadata.binCapacity = binCapacity;
1:     }
1: 
1:     public boolean isTransient() {
1:         return false;
1:     }
1: 
1:     /**
1:      * @return the loadFactor
1:      */
1:     public int getLoadFactor() {
1:         return loadFactor;
1:     }
1: 
1:     /**
1:      * @param loadFactor the loadFactor to set
1:      */
1:     public void setLoadFactor(int loadFactor) {
1:         this.loadFactor = loadFactor;
1:     }
1: 
1:     /**
1:      * @return the maximumCapacity
1:      */
1:     public int setMaximumBinCapacity() {
1:         return maximumBinCapacity;
1:     }
1: 
1:     /**
1:      * @param maximumCapacity the maximumCapacity to set
1:      */
1:     public void setMaximumBinCapacity(int maximumCapacity) {
1:         this.maximumBinCapacity = maximumCapacity;
1:     }
1: 
1:     public synchronized int size(Transaction tx) {
1:         return metadata.size;
1:     }
1: 
1:     public synchronized int getActiveBins() {
1:         return metadata.binsActive;
1:     }
1: 
1:     public long getBinPageId() {
1:         return metadata.binPageId;
1:     }
1: 
1:     public PageFile getPageFile() {
1:         return pageFile;
1:     }
1: 
1:     public int getBinsActive() {
1:         return metadata.binsActive;
1:     }
1: 
1: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:40ae055
/////////////////////////////////////////////////////////////////////////
0:         LOG.debug("Resizing done.  New bins start at: "+metadata.binPageId);
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(HashIndex.class);
============================================================================