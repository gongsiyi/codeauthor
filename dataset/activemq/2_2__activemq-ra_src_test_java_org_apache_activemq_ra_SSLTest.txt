1:9becfc0: /**
1:9becfc0:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:9becfc0:  * contributor license agreements.  See the NOTICE file distributed with
1:9becfc0:  * this work for additional information regarding copyright ownership.
1:9becfc0:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:9becfc0:  * (the "License"); you may not use this file except in compliance with
1:9becfc0:  * the License.  You may obtain a copy of the License at
1:9becfc0:  * <p/>
1:9becfc0:  * http://www.apache.org/licenses/LICENSE-2.0
1:9becfc0:  * <p/>
1:9becfc0:  * Unless required by applicable law or agreed to in writing, software
1:9becfc0:  * distributed under the License is distributed on an "AS IS" BASIS,
1:9becfc0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:9becfc0:  * See the License for the specific language governing permissions and
1:9becfc0:  * limitations under the License.
1:9becfc0:  */
1:9becfc0: package org.apache.activemq.ra;
11:9becfc0: 
1:ba1bd26: import static org.junit.Assert.assertEquals;
1:ba1bd26: import static org.junit.Assert.assertTrue;
1:ba1bd26: import static org.junit.Assert.fail;
1:ba1bd26: 
1:ba1bd26: import java.io.ByteArrayInputStream;
1:ba1bd26: import java.io.ByteArrayOutputStream;
1:ba1bd26: import java.io.DataOutputStream;
1:ba1bd26: import java.io.FileInputStream;
1:ba1bd26: import java.io.IOException;
1:ba1bd26: import java.lang.reflect.Method;
1:ba1bd26: import java.security.KeyStore;
1:ba1bd26: import java.util.Timer;
1:ba1bd26: import java.util.concurrent.CountDownLatch;
1:ba1bd26: import java.util.concurrent.TimeUnit;
1:9becfc0: 
1:9becfc0: import javax.jms.Connection;
1:9becfc0: import javax.jms.Message;
1:9becfc0: import javax.jms.MessageConsumer;
1:9becfc0: import javax.jms.MessageListener;
1:9becfc0: import javax.jms.MessageProducer;
1:9becfc0: import javax.jms.Queue;
1:9becfc0: import javax.jms.Session;
1:9becfc0: import javax.net.ssl.KeyManager;
1:9becfc0: import javax.net.ssl.KeyManagerFactory;
1:9becfc0: import javax.net.ssl.SSLContext;
1:9becfc0: import javax.net.ssl.SSLSocket;
1:9becfc0: import javax.net.ssl.TrustManager;
1:9becfc0: import javax.net.ssl.TrustManagerFactory;
1:9becfc0: import javax.resource.ResourceException;
1:9becfc0: import javax.resource.spi.BootstrapContext;
1:9becfc0: import javax.resource.spi.UnavailableException;
1:9becfc0: import javax.resource.spi.XATerminator;
1:9becfc0: import javax.resource.spi.endpoint.MessageEndpoint;
1:9becfc0: import javax.resource.spi.endpoint.MessageEndpointFactory;
1:9becfc0: import javax.resource.spi.work.ExecutionContext;
1:9becfc0: import javax.resource.spi.work.Work;
1:9becfc0: import javax.resource.spi.work.WorkException;
1:9becfc0: import javax.resource.spi.work.WorkListener;
1:9becfc0: import javax.resource.spi.work.WorkManager;
1:9becfc0: import javax.transaction.xa.XAResource;
1:9becfc0: import javax.transaction.xa.Xid;
1:9becfc0: 
1:ba1bd26: import org.apache.activemq.ActiveMQSslConnectionFactory;
1:ba1bd26: import org.apache.activemq.advisory.AdvisorySupport;
1:ba1bd26: import org.apache.activemq.broker.SslBrokerService;
1:ba1bd26: import org.apache.activemq.broker.SslContext;
1:ba1bd26: import org.apache.activemq.broker.TransportConnector;
1:ba1bd26: import org.apache.activemq.command.ActiveMQMessage;
1:ba1bd26: import org.apache.activemq.command.ActiveMQQueue;
1:ba1bd26: import org.apache.activemq.command.ConsumerInfo;
1:ba1bd26: import org.apache.activemq.transport.TransportFactory;
1:ba1bd26: import org.apache.activemq.transport.tcp.SslTransportFactory;
1:ba1bd26: import org.junit.After;
1:ba1bd26: import org.junit.Before;
1:ba1bd26: import org.junit.Test;
1:9becfc0: 
1:ba1bd26: public class SSLTest {
1:ba1bd26: 
1:ba1bd26:     private static final String KEYSTORE_TYPE = "jks";
1:ba1bd26:     private static final String PASSWORD = "password";
1:ba1bd26:     private static final String SERVER_KEYSTORE = "src/test/resources/server.keystore";
1:ba1bd26:     private static final String TRUST_KEYSTORE = "src/test/resources/client.keystore";
1:ba1bd26:     private static final String KAHADB_DIRECTORY = "target/activemq-data/";
1:9becfc0: 
1:9becfc0:     private static final String BIND_ADDRESS = "ssl://0.0.0.0:61616";
1:9becfc0: 
1:ba1bd26:     private long txGenerator = System.currentTimeMillis();
1:9becfc0: 
1:ba1bd26:     private SslBrokerService broker;
1:9becfc0:     private TransportConnector connector;
1:9becfc0: 
1:ba1bd26:     @Before
1:ba1bd26:     public void setUp() throws Exception {
1:9becfc0:         createAndStartBroker();
2:9becfc0:     }
1:9becfc0: 
1:ba1bd26:     @After
1:ba1bd26:     public void tearDown() throws Exception {
1:9becfc0:         if (broker != null) {
1:9becfc0:             broker.stop();
1:9becfc0:         }
1:9becfc0:     }
1:9becfc0: 
1:9becfc0:     private void createAndStartBroker() throws Exception {
1:9becfc0:         broker = new SslBrokerService();
1:9becfc0:         broker.setDeleteAllMessagesOnStartup(true);
1:9becfc0:         broker.setUseJmx(false);
1:9becfc0:         broker.setBrokerName("BROKER");
1:ba1bd26:         broker.setDataDirectory(KAHADB_DIRECTORY);
1:9becfc0:         KeyManager[] km = getKeyManager();
1:9becfc0:         TrustManager[] tm = getTrustManager();
1:9becfc0:         connector = broker.addSslConnector(BIND_ADDRESS, km, tm, null);
1:9becfc0:         broker.start();
1:9becfc0:         broker.waitUntilStarted();     // for client side
1:ba1bd26: 
1:9becfc0:         SslTransportFactory sslFactory = new SslTransportFactory();
1:9becfc0:         SslContext ctx = new SslContext(km, tm, null);
1:9becfc0:         SslContext.setCurrentSslContext(ctx);
1:9becfc0:         TransportFactory.registerTransportFactory("ssl", sslFactory);
1:9becfc0:     }
1:9becfc0: 
1:9becfc0:     private static final class StubBootstrapContext implements BootstrapContext {
1:ba1bd26:         @Override
1:9becfc0:         public WorkManager getWorkManager() {
1:9becfc0:             return new WorkManager() {
1:ba1bd26:                 @Override
1:9becfc0:                 public void doWork(Work work) throws WorkException {
1:9becfc0:                     new Thread(work).start();
1:9becfc0:                 }
1:9becfc0: 
1:ba1bd26:                 @Override
1:9becfc0:                 public void doWork(Work work, long arg1, ExecutionContext arg2, WorkListener arg3) throws WorkException {
1:9becfc0:                     new Thread(work).start();
1:9becfc0:                 }
1:9becfc0: 
1:ba1bd26:                 @Override
1:9becfc0:                 public long startWork(Work work) throws WorkException {
1:9becfc0:                     new Thread(work).start();
1:9becfc0:                     return 0;
1:9becfc0:                 }
1:9becfc0: 
1:ba1bd26:                 @Override
1:9becfc0:                 public long startWork(Work work, long arg1, ExecutionContext arg2, WorkListener arg3) throws WorkException {
1:9becfc0:                     new Thread(work).start();
1:9becfc0:                     return 0;
1:9becfc0:                 }
1:9becfc0: 
1:ba1bd26:                 @Override
1:9becfc0:                 public void scheduleWork(Work work) throws WorkException {
1:9becfc0:                     new Thread(work).start();
1:9becfc0:                 }
1:9becfc0: 
1:ba1bd26:                 @Override
1:9becfc0:                 public void scheduleWork(Work work, long arg1, ExecutionContext arg2, WorkListener arg3) throws WorkException {
1:9becfc0:                     new Thread(work).start();
1:9becfc0:                 }
1:9becfc0:             };
1:9becfc0:         }
1:9becfc0: 
1:ba1bd26:         @Override
1:9becfc0:         public XATerminator getXATerminator() {
1:9becfc0:             return null;
1:9becfc0:         }
1:9becfc0: 
1:ba1bd26:         @Override
1:9becfc0:         public Timer createTimer() throws UnavailableException {
1:9becfc0:             return null;
1:9becfc0:         }
1:9becfc0:     }
1:9becfc0: 
1:9becfc0:     public class StubMessageEndpoint implements MessageEndpoint, MessageListener {
1:9becfc0:         public int messageCount;
1:9becfc0:         public XAResource xaresource;
1:9becfc0:         public Xid xid;
1:9becfc0: 
1:ba1bd26:         @Override
1:9becfc0:         public void beforeDelivery(Method method) throws NoSuchMethodException, ResourceException {
1:9becfc0:             try {
1:9becfc0:                 if (xid == null) {
1:9becfc0:                     xid = createXid();
1:9becfc0:                 }
1:9becfc0:                 xaresource.start(xid, 0);
1:9becfc0:             } catch (Throwable e) {
1:9becfc0:                 throw new ResourceException(e);
1:9becfc0:             }
1:9becfc0:         }
1:9becfc0: 
1:ba1bd26:         @Override
1:9becfc0:         public void afterDelivery() throws ResourceException {
1:9becfc0:             try {
1:9becfc0:                 xaresource.end(xid, 0);
1:9becfc0:                 xaresource.prepare(xid);
1:9becfc0:                 xaresource.commit(xid, false);
1:9becfc0:             } catch (Throwable e) {
1:9becfc0:                 throw new ResourceException(e);
1:9becfc0:             }
1:9becfc0:         }
1:9becfc0: 
1:ba1bd26:         @Override
1:9becfc0:         public void release() {
1:9becfc0:         }
1:9becfc0: 
1:ba1bd26:         @Override
1:9becfc0:         public void onMessage(Message message) {
1:9becfc0:             messageCount++;
1:9becfc0:         }
1:9becfc0:     }
1:9becfc0: 
1:ba1bd26:     @Test(timeout = 60000)
1:9becfc0:     public void testMessageDeliveryUsingSSLTruststoreOnly() throws Exception {
1:9becfc0:         SSLContext context = SSLContext.getInstance("TLS");
1:9becfc0:         context.init(getKeyManager(), getTrustManager(), null);
1:9becfc0:         makeSSLConnection(context, null, connector);
1:9becfc0:         ActiveMQSslConnectionFactory factory = new ActiveMQSslConnectionFactory("ssl://localhost:61616");
1:9becfc0:         factory.setTrustStore("server.keystore");
1:9becfc0:         factory.setTrustStorePassword("password");
1:9becfc0:         Connection connection = factory.createConnection();
1:9becfc0:         connection.start();
1:9becfc0:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:9becfc0: 
1:9becfc0:         MessageConsumer advisory = session.createConsumer(AdvisorySupport.getConsumerAdvisoryTopic(new ActiveMQQueue("TEST")));
1:9becfc0: 
1:9becfc0:         ActiveMQResourceAdapter adapter = new ActiveMQResourceAdapter();
1:9becfc0:         adapter.setServerUrl("ssl://localhost:61616");
1:9becfc0:         adapter.setTrustStore("server.keystore");
1:9becfc0:         adapter.setTrustStorePassword("password");
1:9becfc0:         adapter.setQueuePrefetch(1);
1:9becfc0:         adapter.start(new StubBootstrapContext());
1:9becfc0: 
1:9becfc0:         final CountDownLatch messageDelivered = new CountDownLatch(1);
1:9becfc0: 
1:9becfc0:         final StubMessageEndpoint endpoint = new StubMessageEndpoint() {
1:ba1bd26:             @Override
1:9becfc0:             public void onMessage(Message message) {
1:9becfc0:                 super.onMessage(message);
1:9becfc0:                 messageDelivered.countDown();
1:9becfc0:             }
1:9becfc0:         };
1:9becfc0: 
1:9becfc0:         ActiveMQActivationSpec activationSpec = new ActiveMQActivationSpec();
1:9becfc0:         activationSpec.setDestinationType(Queue.class.getName());
1:9becfc0:         activationSpec.setDestination("TEST");
1:9becfc0:         activationSpec.setResourceAdapter(adapter);
1:9becfc0:         activationSpec.validate();
1:9becfc0: 
1:9becfc0:         MessageEndpointFactory messageEndpointFactory = new MessageEndpointFactory() {
1:ba1bd26:             @Override
1:9becfc0:             public MessageEndpoint createEndpoint(XAResource resource) throws UnavailableException {
1:9becfc0:                 endpoint.xaresource = resource;
1:9becfc0:                 return endpoint;
1:9becfc0:             }
1:9becfc0: 
1:ba1bd26:             @Override
1:9becfc0:             public boolean isDeliveryTransacted(Method method) throws NoSuchMethodException {
1:9becfc0:                 return true;
1:9becfc0:             }
1:9becfc0:         };
1:9becfc0: 
1:9becfc0:         // Activate an Endpoint
1:9becfc0:         adapter.endpointActivation(messageEndpointFactory, activationSpec);
1:9becfc0: 
1:9becfc0:         ActiveMQMessage msg = (ActiveMQMessage) advisory.receive(1000);
1:9becfc0:         if (msg != null) {
1:9becfc0:             assertEquals("Prefetch size hasn't been set", 1, ((ConsumerInfo) msg.getDataStructure()).getPrefetchSize());
1:9becfc0:         } else {
1:9becfc0:             fail("Consumer hasn't been created");
1:9becfc0:         }
1:9becfc0: 
1:9becfc0:         // Send the broker a message to that endpoint
1:9becfc0:         MessageProducer producer = session.createProducer(new ActiveMQQueue("TEST"));
1:9becfc0:         producer.send(session.createTextMessage("Hello!"));
1:9becfc0: 
1:9becfc0:         connection.close();
1:9becfc0: 
1:9becfc0:         // Wait for the message to be delivered.
1:9becfc0:         assertTrue(messageDelivered.await(5000, TimeUnit.MILLISECONDS));
1:9becfc0: 
1:9becfc0:         // Shut the Endpoint down.
1:9becfc0:         adapter.endpointDeactivation(messageEndpointFactory, activationSpec);
1:9becfc0:         adapter.stop();
1:ba1bd26:     }
1:9becfc0: 
1:ba1bd26:     @Test(timeout = 60000)
1:9becfc0:     public void testMessageDeliveryUsingSSLTruststoreAndKeystore() throws Exception {
1:9becfc0:         SSLContext context = SSLContext.getInstance("TLS");
1:9becfc0:         context.init(getKeyManager(), getTrustManager(), null);
1:9becfc0:         makeSSLConnection(context, null, connector);
1:9becfc0:         ActiveMQSslConnectionFactory factory = new ActiveMQSslConnectionFactory("ssl://localhost:61616");
1:9becfc0:         factory.setTrustStore("server.keystore");
1:9becfc0:         factory.setTrustStorePassword("password");
1:9becfc0:         factory.setKeyStore("client.keystore");
1:9becfc0:         factory.setKeyStorePassword("password");
1:9becfc0:         Connection connection = factory.createConnection();
1:9becfc0:         connection.start();
1:9becfc0:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:9becfc0: 
1:9becfc0:         MessageConsumer advisory = session.createConsumer(AdvisorySupport.getConsumerAdvisoryTopic(new ActiveMQQueue("TEST")));
1:9becfc0: 
1:9becfc0:         ActiveMQResourceAdapter adapter = new ActiveMQResourceAdapter();
1:9becfc0:         adapter.setServerUrl("ssl://localhost:61616");
1:9becfc0:         adapter.setTrustStore("server.keystore");
1:9becfc0:         adapter.setTrustStorePassword("password");
1:9becfc0:         adapter.setKeyStore("client.keystore");
1:9becfc0:         adapter.setKeyStorePassword("password");
1:9becfc0:         adapter.setQueuePrefetch(1);
1:9becfc0:         adapter.start(new StubBootstrapContext());
1:9becfc0: 
1:9becfc0:         final CountDownLatch messageDelivered = new CountDownLatch(1);
1:9becfc0: 
1:9becfc0:         final StubMessageEndpoint endpoint = new StubMessageEndpoint() {
1:ba1bd26:             @Override
1:9becfc0:             public void onMessage(Message message) {
1:9becfc0:                 super.onMessage(message);
1:9becfc0:                 messageDelivered.countDown();
1:9becfc0:             }
1:9becfc0:         };
1:9becfc0: 
1:9becfc0:         ActiveMQActivationSpec activationSpec = new ActiveMQActivationSpec();
1:9becfc0:         activationSpec.setDestinationType(Queue.class.getName());
1:9becfc0:         activationSpec.setDestination("TEST");
1:9becfc0:         activationSpec.setResourceAdapter(adapter);
1:9becfc0:         activationSpec.validate();
1:9becfc0: 
1:9becfc0:         MessageEndpointFactory messageEndpointFactory = new MessageEndpointFactory() {
1:ba1bd26:             @Override
1:9becfc0:             public MessageEndpoint createEndpoint(XAResource resource) throws UnavailableException {
1:9becfc0:                 endpoint.xaresource = resource;
1:9becfc0:                 return endpoint;
1:9becfc0:             }
1:9becfc0: 
1:ba1bd26:             @Override
1:9becfc0:             public boolean isDeliveryTransacted(Method method) throws NoSuchMethodException {
1:9becfc0:                 return true;
1:9becfc0:             }
1:9becfc0:         };
1:9becfc0: 
1:9becfc0:         // Activate an Endpoint
1:9becfc0:         adapter.endpointActivation(messageEndpointFactory, activationSpec);
1:9becfc0: 
1:9becfc0:         ActiveMQMessage msg = (ActiveMQMessage) advisory.receive(1000);
1:9becfc0:         if (msg != null) {
1:9becfc0:             assertEquals("Prefetch size hasn't been set", 1, ((ConsumerInfo) msg.getDataStructure()).getPrefetchSize());
1:9becfc0:         } else {
1:9becfc0:             fail("Consumer hasn't been created");
1:9becfc0:         }
1:9becfc0: 
1:9becfc0:         // Send the broker a message to that endpoint
1:9becfc0:         MessageProducer producer = session.createProducer(new ActiveMQQueue("TEST"));
1:9becfc0:         producer.send(session.createTextMessage("Hello!"));
1:9becfc0: 
1:9becfc0:         connection.close();
1:9becfc0: 
1:9becfc0:         // Wait for the message to be delivered.
1:9becfc0:         assertTrue(messageDelivered.await(5000, TimeUnit.MILLISECONDS));
1:9becfc0: 
1:9becfc0:         // Shut the Endpoint down.
1:9becfc0:         adapter.endpointDeactivation(messageEndpointFactory, activationSpec);
1:9becfc0:         adapter.stop();
1:9becfc0:     }
1:9becfc0: 
1:ba1bd26:     @Test(timeout = 60000)
1:9becfc0:     public void testMessageDeliveryUsingSSLTruststoreAndKeystoreOverrides() throws Exception {
1:9becfc0:         SSLContext context = SSLContext.getInstance("TLS");
1:9becfc0:         context.init(getKeyManager(), getTrustManager(), null);
1:9becfc0:         makeSSLConnection(context, null, connector);
1:9becfc0:         ActiveMQSslConnectionFactory factory = new ActiveMQSslConnectionFactory("ssl://localhost:61616");
1:9becfc0:         factory.setTrustStore("server.keystore");
1:9becfc0:         factory.setTrustStorePassword("password");
1:9becfc0:         factory.setKeyStore("client.keystore");
1:9becfc0:         factory.setKeyStorePassword("password");
1:9becfc0:         Connection connection = factory.createConnection();
1:9becfc0:         connection.start();
1:9becfc0:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:9becfc0: 
1:9becfc0:         MessageConsumer advisory = session.createConsumer(AdvisorySupport.getConsumerAdvisoryTopic(new ActiveMQQueue("TEST")));
1:9becfc0: 
1:9becfc0:         ActiveMQResourceAdapter adapter = new ActiveMQResourceAdapter();
1:9becfc0:         adapter.setServerUrl("ssl://localhost:61616");
1:9becfc0:         adapter.setQueuePrefetch(1);
1:9becfc0:         adapter.start(new StubBootstrapContext());
1:9becfc0: 
1:9becfc0:         final CountDownLatch messageDelivered = new CountDownLatch(1);
1:9becfc0: 
1:9becfc0:         final StubMessageEndpoint endpoint = new StubMessageEndpoint() {
1:ba1bd26:             @Override
1:9becfc0:             public void onMessage(Message message) {
1:9becfc0:                 super.onMessage(message);
1:9becfc0:                 messageDelivered.countDown();
1:9becfc0:             }
1:9becfc0:         };
1:9becfc0: 
1:9becfc0:         ActiveMQActivationSpec activationSpec = new ActiveMQActivationSpec();
1:9becfc0:         activationSpec.setDestinationType(Queue.class.getName());
1:9becfc0:         activationSpec.setDestination("TEST");
1:9becfc0:         activationSpec.setResourceAdapter(adapter);
1:9becfc0:         activationSpec.setTrustStore("server.keystore");
1:9becfc0:         activationSpec.setTrustStorePassword("password");
1:9becfc0:         activationSpec.setKeyStore("client.keystore");
1:9becfc0:         activationSpec.setKeyStorePassword("password");
1:9becfc0:         activationSpec.validate();
1:9becfc0: 
1:9becfc0:         MessageEndpointFactory messageEndpointFactory = new MessageEndpointFactory() {
1:ba1bd26:             @Override
1:9becfc0:             public MessageEndpoint createEndpoint(XAResource resource) throws UnavailableException {
1:9becfc0:                 endpoint.xaresource = resource;
1:9becfc0:                 return endpoint;
1:9becfc0:             }
1:9becfc0: 
1:ba1bd26:             @Override
1:9becfc0:             public boolean isDeliveryTransacted(Method method) throws NoSuchMethodException {
1:9becfc0:                 return true;
1:9becfc0:             }
1:9becfc0:         };
1:9becfc0: 
1:9becfc0:         // Activate an Endpoint
1:9becfc0:         adapter.endpointActivation(messageEndpointFactory, activationSpec);
1:9becfc0: 
1:9becfc0:         ActiveMQMessage msg = (ActiveMQMessage) advisory.receive(1000);
1:9becfc0:         if (msg != null) {
1:9becfc0:             assertEquals("Prefetch size hasn't been set", 1, ((ConsumerInfo) msg.getDataStructure()).getPrefetchSize());
1:9becfc0:         } else {
1:9becfc0:             fail("Consumer hasn't been created");
1:9becfc0:         }
1:9becfc0: 
1:9becfc0:         // Send the broker a message to that endpoint
1:9becfc0:         MessageProducer producer = session.createProducer(new ActiveMQQueue("TEST"));
1:9becfc0:         producer.send(session.createTextMessage("Hello!"));
1:9becfc0: 
1:9becfc0:         connection.close();
1:9becfc0: 
1:9becfc0:         // Wait for the message to be delivered.
1:9becfc0:         assertTrue(messageDelivered.await(5000, TimeUnit.MILLISECONDS));
1:9becfc0: 
1:9becfc0:         // Shut the Endpoint down.
1:9becfc0:         adapter.endpointDeactivation(messageEndpointFactory, activationSpec);
1:9becfc0:         adapter.stop();
1:9becfc0:     }
1:9becfc0: 
1:9becfc0:     public Xid createXid() throws IOException {
1:9becfc0:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:9becfc0:         DataOutputStream os = new DataOutputStream(baos);
1:9becfc0:         os.writeLong(++txGenerator);
1:9becfc0:         os.close();
1:9becfc0:         final byte[] bs = baos.toByteArray();
1:9becfc0: 
1:9becfc0:         return new Xid() {
1:ba1bd26:             @Override
1:9becfc0:             public int getFormatId() {
1:9becfc0:                 return 86;
1:9becfc0:             }
1:9becfc0: 
1:ba1bd26:             @Override
1:9becfc0:             public byte[] getGlobalTransactionId() {
1:9becfc0:                 return bs;
1:9becfc0:             }
1:9becfc0: 
1:ba1bd26:             @Override
1:9becfc0:             public byte[] getBranchQualifier() {
1:9becfc0:                 return bs;
1:9becfc0:             }
1:9becfc0:         };
1:9becfc0:     }
1:9becfc0: 
1:9becfc0:     public static TrustManager[] getTrustManager() throws Exception {
1:9becfc0:         TrustManager[] trustStoreManagers = null;
1:9becfc0:         KeyStore trustedCertStore = KeyStore.getInstance(KEYSTORE_TYPE);
1:9becfc0: 
1:9becfc0:         trustedCertStore.load(new FileInputStream(TRUST_KEYSTORE), null);
1:9becfc0:         TrustManagerFactory tmf =
1:9becfc0:                 TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
1:9becfc0: 
1:9becfc0:         tmf.init(trustedCertStore);
1:9becfc0:         trustStoreManagers = tmf.getTrustManagers();
1:9becfc0:         return trustStoreManagers;
1:9becfc0:     }
1:9becfc0: 
1:9becfc0:     public static KeyManager[] getKeyManager() throws Exception {
1:9becfc0:         KeyManagerFactory kmf =
1:9becfc0:                 KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
1:9becfc0:         KeyStore ks = KeyStore.getInstance(KEYSTORE_TYPE);
1:9becfc0:         KeyManager[] keystoreManagers = null;
1:9becfc0: 
1:9becfc0:         byte[] sslCert = loadClientCredential(SERVER_KEYSTORE);
1:9becfc0: 
1:9becfc0:         if (sslCert != null && sslCert.length > 0) {
1:9becfc0:             ByteArrayInputStream bin = new ByteArrayInputStream(sslCert);
1:9becfc0:             ks.load(bin, PASSWORD.toCharArray());
1:9becfc0:             kmf.init(ks, PASSWORD.toCharArray());
1:9becfc0:             keystoreManagers = kmf.getKeyManagers();
1:9becfc0:         }
1:9becfc0:         return keystoreManagers;
1:9becfc0:     }
1:9becfc0: 
1:9becfc0:     private static byte[] loadClientCredential(String fileName) throws IOException {
1:9becfc0:         if (fileName == null) {
1:9becfc0:             return null;
1:9becfc0:         }
1:ba1bd26: 
1:9becfc0:         FileInputStream in = new FileInputStream(fileName);
1:9becfc0:         ByteArrayOutputStream out = new ByteArrayOutputStream();
1:9becfc0:         byte[] buf = new byte[512];
1:9becfc0:         int i = in.read(buf);
1:ba1bd26: 
1:9becfc0:         while (i > 0) {
1:9becfc0:             out.write(buf, 0, i);
1:9becfc0:             i = in.read(buf);
1:9becfc0:         }
1:ba1bd26: 
1:9becfc0:         in.close();
1:9becfc0:         return out.toByteArray();
1:9becfc0:     }
1:9becfc0: 
1:ba1bd26:     private void makeSSLConnection(SSLContext context, String enabledSuites[], TransportConnector connector) throws Exception {
1:9becfc0:         SSLSocket sslSocket = (SSLSocket) context.getSocketFactory().createSocket("localhost", connector.getUri().getPort());
1:9becfc0: 
1:9becfc0:         if (enabledSuites != null) {
1:9becfc0:             sslSocket.setEnabledCipherSuites(enabledSuites);
1:9becfc0:         }
1:9becfc0: 
1:ba1bd26:         sslSocket.setSoTimeout(5000);
1:ba1bd26:         sslSocket.getSession();
1:9becfc0:         sslSocket.startHandshake();
1:9becfc0:     }
1:9becfc0: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:ba1bd26
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertTrue;
1: import static org.junit.Assert.fail;
1: 
1: import java.io.ByteArrayInputStream;
1: import java.io.ByteArrayOutputStream;
1: import java.io.DataOutputStream;
1: import java.io.FileInputStream;
1: import java.io.IOException;
1: import java.lang.reflect.Method;
1: import java.security.KeyStore;
1: import java.util.Timer;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.ActiveMQSslConnectionFactory;
1: import org.apache.activemq.advisory.AdvisorySupport;
1: import org.apache.activemq.broker.SslBrokerService;
1: import org.apache.activemq.broker.SslContext;
1: import org.apache.activemq.broker.TransportConnector;
1: import org.apache.activemq.command.ActiveMQMessage;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.transport.TransportFactory;
1: import org.apache.activemq.transport.tcp.SslTransportFactory;
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Test;
1: public class SSLTest {
1: 
1:     private static final String KEYSTORE_TYPE = "jks";
1:     private static final String PASSWORD = "password";
1:     private static final String SERVER_KEYSTORE = "src/test/resources/server.keystore";
1:     private static final String TRUST_KEYSTORE = "src/test/resources/client.keystore";
1:     private static final String KAHADB_DIRECTORY = "target/activemq-data/";
1:     private long txGenerator = System.currentTimeMillis();
1:     private SslBrokerService broker;
1:     @Before
1:     public void setUp() throws Exception {
1:     @After
1:     public void tearDown() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         broker.setDataDirectory(KAHADB_DIRECTORY);
1: 
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:                 @Override
1:                 @Override
1:                 @Override
1:                 @Override
1:                 @Override
1:                 @Override
1:         @Override
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:         @Override
1:     @Test(timeout = 60000)
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60000)
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:     }
1:     @Test(timeout = 60000)
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:             @Override
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:             @Override
1:             @Override
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1:     private void makeSSLConnection(SSLContext context, String enabledSuites[], TransportConnector connector) throws Exception {
1:         sslSocket.setSoTimeout(5000);
1:         sslSocket.getSession();
author:Andy Taylor
-------------------------------------------------------------------------------
commit:9becfc0
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  * <p/>
1:  * http://www.apache.org/licenses/LICENSE-2.0
1:  * <p/>
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.ra;
1: 
0: import junit.framework.TestCase;
0: import org.apache.activemq.ActiveMQSslConnectionFactory;
0: import org.apache.activemq.advisory.AdvisorySupport;
0: import org.apache.activemq.broker.SslBrokerService;
0: import org.apache.activemq.broker.SslContext;
0: import org.apache.activemq.broker.TransportConnector;
0: import org.apache.activemq.command.ActiveMQMessage;
0: import org.apache.activemq.command.ActiveMQQueue;
0: import org.apache.activemq.command.ConsumerInfo;
0: import org.apache.activemq.transport.TransportFactory;
0: import org.apache.activemq.transport.tcp.SslTransportFactory;
1: 
1: import javax.jms.Connection;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageListener;
1: import javax.jms.MessageProducer;
1: import javax.jms.Queue;
1: import javax.jms.Session;
1: import javax.net.ssl.KeyManager;
1: import javax.net.ssl.KeyManagerFactory;
1: import javax.net.ssl.SSLContext;
0: import javax.net.ssl.SSLSession;
1: import javax.net.ssl.SSLSocket;
1: import javax.net.ssl.TrustManager;
1: import javax.net.ssl.TrustManagerFactory;
1: import javax.resource.ResourceException;
1: import javax.resource.spi.BootstrapContext;
1: import javax.resource.spi.UnavailableException;
1: import javax.resource.spi.XATerminator;
1: import javax.resource.spi.endpoint.MessageEndpoint;
1: import javax.resource.spi.endpoint.MessageEndpointFactory;
1: import javax.resource.spi.work.ExecutionContext;
1: import javax.resource.spi.work.Work;
1: import javax.resource.spi.work.WorkException;
1: import javax.resource.spi.work.WorkListener;
1: import javax.resource.spi.work.WorkManager;
1: import javax.transaction.xa.XAResource;
1: import javax.transaction.xa.Xid;
0: import java.io.ByteArrayInputStream;
0: import java.io.ByteArrayOutputStream;
0: import java.io.DataOutputStream;
0: import java.io.FileInputStream;
0: import java.io.IOException;
0: import java.lang.reflect.Method;
0: import java.net.SocketException;
0: import java.net.UnknownHostException;
0: import java.security.KeyStore;
0: import java.util.Timer;
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.TimeUnit;
1: 
0: public class SSLTest extends TestCase {
0:     public static final String KEYSTORE_TYPE = "jks";
0:     public static final String PASSWORD = "password";
0:     public static final String SERVER_KEYSTORE = "src/test/resources/server.keystore";
0:     public static final String TRUST_KEYSTORE = "src/test/resources/client.keystore";
1: 
0:     long txGenerator = System.currentTimeMillis();
1: 
1:     private static final String BIND_ADDRESS = "ssl://0.0.0.0:61616";
1: 
0:     private SslBrokerService broker;
1: 
1:     private TransportConnector connector;
1: 
0:     @Override
0:     protected void setUp() throws Exception {
1:         createAndStartBroker();
1:     }
1: 
0:     @Override
0:     protected void tearDown() throws Exception {
1:         if (broker != null) {
1:             broker.stop();
1:         }
1:     }
1: 
1:     private void createAndStartBroker() throws Exception {
1:         broker = new SslBrokerService();
1:         broker.setDeleteAllMessagesOnStartup(true);
1:         broker.setUseJmx(false);
1:         broker.setBrokerName("BROKER");
1:         KeyManager[] km = getKeyManager();
1:         TrustManager[] tm = getTrustManager();
1:         connector = broker.addSslConnector(BIND_ADDRESS, km, tm, null);
1:         broker.start();
1:         broker.waitUntilStarted();     // for client side
1:         SslTransportFactory sslFactory = new SslTransportFactory();
1:         SslContext ctx = new SslContext(km, tm, null);
1:         SslContext.setCurrentSslContext(ctx);
1:         TransportFactory.registerTransportFactory("ssl", sslFactory);
1:     }
1: 
1:     private static final class StubBootstrapContext implements BootstrapContext {
1:         public WorkManager getWorkManager() {
1:             return new WorkManager() {
1:                 public void doWork(Work work) throws WorkException {
1:                     new Thread(work).start();
1:                 }
1: 
1:                 public void doWork(Work work, long arg1, ExecutionContext arg2, WorkListener arg3) throws WorkException {
1:                     new Thread(work).start();
1:                 }
1: 
1:                 public long startWork(Work work) throws WorkException {
1:                     new Thread(work).start();
1:                     return 0;
1:                 }
1: 
1:                 public long startWork(Work work, long arg1, ExecutionContext arg2, WorkListener arg3) throws WorkException {
1:                     new Thread(work).start();
1:                     return 0;
1:                 }
1: 
1:                 public void scheduleWork(Work work) throws WorkException {
1:                     new Thread(work).start();
1:                 }
1: 
1:                 public void scheduleWork(Work work, long arg1, ExecutionContext arg2, WorkListener arg3) throws WorkException {
1:                     new Thread(work).start();
1:                 }
1:             };
1:         }
1: 
1:         public XATerminator getXATerminator() {
1:             return null;
1:         }
1: 
1:         public Timer createTimer() throws UnavailableException {
1:             return null;
1:         }
1:     }
1: 
1:     public class StubMessageEndpoint implements MessageEndpoint, MessageListener {
1:         public int messageCount;
1:         public XAResource xaresource;
1:         public Xid xid;
1: 
1:         public void beforeDelivery(Method method) throws NoSuchMethodException, ResourceException {
1:             try {
1:                 if (xid == null) {
1:                     xid = createXid();
1:                 }
1:                 xaresource.start(xid, 0);
1:             } catch (Throwable e) {
1:                 throw new ResourceException(e);
1:             }
1:         }
1: 
1:         public void afterDelivery() throws ResourceException {
1:             try {
1:                 xaresource.end(xid, 0);
1:                 xaresource.prepare(xid);
1:                 xaresource.commit(xid, false);
1:             } catch (Throwable e) {
1:                 throw new ResourceException(e);
1:             }
1:         }
1: 
1:         public void release() {
1:         }
1: 
1:         public void onMessage(Message message) {
1:             messageCount++;
1:         }
1: 
1:     }
1: 
1:     public void testMessageDeliveryUsingSSLTruststoreOnly() throws Exception {
1:         SSLContext context = SSLContext.getInstance("TLS");
1:         context.init(getKeyManager(), getTrustManager(), null);
1:         makeSSLConnection(context, null, connector);
1:         ActiveMQSslConnectionFactory factory = new ActiveMQSslConnectionFactory("ssl://localhost:61616");
1:         factory.setTrustStore("server.keystore");
1:         factory.setTrustStorePassword("password");
1:         Connection connection = factory.createConnection();
1:         connection.start();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:         MessageConsumer advisory = session.createConsumer(AdvisorySupport.getConsumerAdvisoryTopic(new ActiveMQQueue("TEST")));
1: 
1:         ActiveMQResourceAdapter adapter = new ActiveMQResourceAdapter();
1:         adapter.setServerUrl("ssl://localhost:61616");
1:         adapter.setTrustStore("server.keystore");
1:         adapter.setTrustStorePassword("password");
1:         adapter.setQueuePrefetch(1);
1:         adapter.start(new StubBootstrapContext());
1: 
1:         final CountDownLatch messageDelivered = new CountDownLatch(1);
1: 
1:         final StubMessageEndpoint endpoint = new StubMessageEndpoint() {
1:             public void onMessage(Message message) {
1:                 super.onMessage(message);
1:                 messageDelivered.countDown();
1:             }
1: 
0:             ;
1:         };
1: 
1:         ActiveMQActivationSpec activationSpec = new ActiveMQActivationSpec();
1:         activationSpec.setDestinationType(Queue.class.getName());
1:         activationSpec.setDestination("TEST");
1:         activationSpec.setResourceAdapter(adapter);
1:         activationSpec.validate();
1: 
1:         MessageEndpointFactory messageEndpointFactory = new MessageEndpointFactory() {
1:             public MessageEndpoint createEndpoint(XAResource resource) throws UnavailableException {
1:                 endpoint.xaresource = resource;
1:                 return endpoint;
1:             }
1: 
1:             public boolean isDeliveryTransacted(Method method) throws NoSuchMethodException {
1:                 return true;
1:             }
1:         };
1: 
1:         // Activate an Endpoint
1:         adapter.endpointActivation(messageEndpointFactory, activationSpec);
1: 
1:         ActiveMQMessage msg = (ActiveMQMessage) advisory.receive(1000);
1:         if (msg != null) {
1:             assertEquals("Prefetch size hasn't been set", 1, ((ConsumerInfo) msg.getDataStructure()).getPrefetchSize());
1:         } else {
1:             fail("Consumer hasn't been created");
1:         }
1: 
1:         // Send the broker a message to that endpoint
1:         MessageProducer producer = session.createProducer(new ActiveMQQueue("TEST"));
1:         producer.send(session.createTextMessage("Hello!"));
1: 
1:         connection.close();
1: 
1:         // Wait for the message to be delivered.
1:         assertTrue(messageDelivered.await(5000, TimeUnit.MILLISECONDS));
1: 
1:         // Shut the Endpoint down.
1:         adapter.endpointDeactivation(messageEndpointFactory, activationSpec);
1:         adapter.stop();
1: 
1:     }
1: 
1:     public void testMessageDeliveryUsingSSLTruststoreAndKeystore() throws Exception {
1:         SSLContext context = SSLContext.getInstance("TLS");
1:         context.init(getKeyManager(), getTrustManager(), null);
1:         makeSSLConnection(context, null, connector);
1:         ActiveMQSslConnectionFactory factory = new ActiveMQSslConnectionFactory("ssl://localhost:61616");
1:         factory.setTrustStore("server.keystore");
1:         factory.setTrustStorePassword("password");
1:         factory.setKeyStore("client.keystore");
1:         factory.setKeyStorePassword("password");
1:         Connection connection = factory.createConnection();
1:         connection.start();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:         MessageConsumer advisory = session.createConsumer(AdvisorySupport.getConsumerAdvisoryTopic(new ActiveMQQueue("TEST")));
1: 
1:         ActiveMQResourceAdapter adapter = new ActiveMQResourceAdapter();
1:         adapter.setServerUrl("ssl://localhost:61616");
1:         adapter.setTrustStore("server.keystore");
1:         adapter.setTrustStorePassword("password");
1:         adapter.setKeyStore("client.keystore");
1:         adapter.setKeyStorePassword("password");
1:         adapter.setQueuePrefetch(1);
1:         adapter.start(new StubBootstrapContext());
1: 
1:         final CountDownLatch messageDelivered = new CountDownLatch(1);
1: 
1:         final StubMessageEndpoint endpoint = new StubMessageEndpoint() {
1:             public void onMessage(Message message) {
1:                 super.onMessage(message);
1:                 messageDelivered.countDown();
1:             }
1: 
0:             ;
1:         };
1: 
1:         ActiveMQActivationSpec activationSpec = new ActiveMQActivationSpec();
1:         activationSpec.setDestinationType(Queue.class.getName());
1:         activationSpec.setDestination("TEST");
1:         activationSpec.setResourceAdapter(adapter);
1:         activationSpec.validate();
1: 
1:         MessageEndpointFactory messageEndpointFactory = new MessageEndpointFactory() {
1:             public MessageEndpoint createEndpoint(XAResource resource) throws UnavailableException {
1:                 endpoint.xaresource = resource;
1:                 return endpoint;
1:             }
1: 
1:             public boolean isDeliveryTransacted(Method method) throws NoSuchMethodException {
1:                 return true;
1:             }
1:         };
1: 
1:         // Activate an Endpoint
1:         adapter.endpointActivation(messageEndpointFactory, activationSpec);
1: 
1:         ActiveMQMessage msg = (ActiveMQMessage) advisory.receive(1000);
1:         if (msg != null) {
1:             assertEquals("Prefetch size hasn't been set", 1, ((ConsumerInfo) msg.getDataStructure()).getPrefetchSize());
1:         } else {
1:             fail("Consumer hasn't been created");
1:         }
1: 
1:         // Send the broker a message to that endpoint
1:         MessageProducer producer = session.createProducer(new ActiveMQQueue("TEST"));
1:         producer.send(session.createTextMessage("Hello!"));
1: 
1:         connection.close();
1: 
1:         // Wait for the message to be delivered.
1:         assertTrue(messageDelivered.await(5000, TimeUnit.MILLISECONDS));
1: 
1:         // Shut the Endpoint down.
1:         adapter.endpointDeactivation(messageEndpointFactory, activationSpec);
1:         adapter.stop();
1: 
1:         }
1: 
1:     public void testMessageDeliveryUsingSSLTruststoreAndKeystoreOverrides() throws Exception {
1:         SSLContext context = SSLContext.getInstance("TLS");
1:         context.init(getKeyManager(), getTrustManager(), null);
1:         makeSSLConnection(context, null, connector);
1:         ActiveMQSslConnectionFactory factory = new ActiveMQSslConnectionFactory("ssl://localhost:61616");
1:         factory.setTrustStore("server.keystore");
1:         factory.setTrustStorePassword("password");
1:         factory.setKeyStore("client.keystore");
1:         factory.setKeyStorePassword("password");
1:         Connection connection = factory.createConnection();
1:         connection.start();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:         MessageConsumer advisory = session.createConsumer(AdvisorySupport.getConsumerAdvisoryTopic(new ActiveMQQueue("TEST")));
1: 
1:         ActiveMQResourceAdapter adapter = new ActiveMQResourceAdapter();
1:         adapter.setServerUrl("ssl://localhost:61616");
1:         adapter.setQueuePrefetch(1);
1:         adapter.start(new StubBootstrapContext());
1: 
1:         final CountDownLatch messageDelivered = new CountDownLatch(1);
1: 
1:         final StubMessageEndpoint endpoint = new StubMessageEndpoint() {
1:             public void onMessage(Message message) {
1:                 super.onMessage(message);
1:                 messageDelivered.countDown();
1:             }
1: 
0:             ;
1:         };
1: 
1:         ActiveMQActivationSpec activationSpec = new ActiveMQActivationSpec();
1:         activationSpec.setDestinationType(Queue.class.getName());
1:         activationSpec.setDestination("TEST");
1:         activationSpec.setResourceAdapter(adapter);
1:         activationSpec.setTrustStore("server.keystore");
1:         activationSpec.setTrustStorePassword("password");
1:         activationSpec.setKeyStore("client.keystore");
1:         activationSpec.setKeyStorePassword("password");
1:         activationSpec.validate();
1: 
1:         MessageEndpointFactory messageEndpointFactory = new MessageEndpointFactory() {
1:             public MessageEndpoint createEndpoint(XAResource resource) throws UnavailableException {
1:                 endpoint.xaresource = resource;
1:                 return endpoint;
1:             }
1: 
1:             public boolean isDeliveryTransacted(Method method) throws NoSuchMethodException {
1:                 return true;
1:             }
1:         };
1: 
1:         // Activate an Endpoint
1:         adapter.endpointActivation(messageEndpointFactory, activationSpec);
1: 
1:         ActiveMQMessage msg = (ActiveMQMessage) advisory.receive(1000);
1:         if (msg != null) {
1:             assertEquals("Prefetch size hasn't been set", 1, ((ConsumerInfo) msg.getDataStructure()).getPrefetchSize());
1:         } else {
1:             fail("Consumer hasn't been created");
1:         }
1: 
1:         // Send the broker a message to that endpoint
1:         MessageProducer producer = session.createProducer(new ActiveMQQueue("TEST"));
1:         producer.send(session.createTextMessage("Hello!"));
1: 
1:         connection.close();
1: 
1:         // Wait for the message to be delivered.
1:         assertTrue(messageDelivered.await(5000, TimeUnit.MILLISECONDS));
1: 
1:         // Shut the Endpoint down.
1:         adapter.endpointDeactivation(messageEndpointFactory, activationSpec);
1:         adapter.stop();
1: 
1:     }
1: 
1: 
1:     public Xid createXid() throws IOException {
1:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:         DataOutputStream os = new DataOutputStream(baos);
1:         os.writeLong(++txGenerator);
1:         os.close();
1:         final byte[] bs = baos.toByteArray();
1: 
1:         return new Xid() {
1:             public int getFormatId() {
1:                 return 86;
1:             }
1: 
1:             public byte[] getGlobalTransactionId() {
1:                 return bs;
1:             }
1: 
1:             public byte[] getBranchQualifier() {
1:                 return bs;
1:             }
1:         };
1: 
1:     }
1: 
1:     public static TrustManager[] getTrustManager() throws Exception {
1:         TrustManager[] trustStoreManagers = null;
1:         KeyStore trustedCertStore = KeyStore.getInstance(KEYSTORE_TYPE);
1: 
1:         trustedCertStore.load(new FileInputStream(TRUST_KEYSTORE), null);
1:         TrustManagerFactory tmf =
1:                 TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
1: 
1:         tmf.init(trustedCertStore);
1:         trustStoreManagers = tmf.getTrustManagers();
1:         return trustStoreManagers;
1:     }
1: 
1:     public static KeyManager[] getKeyManager() throws Exception {
1:         KeyManagerFactory kmf =
1:                 KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
1:         KeyStore ks = KeyStore.getInstance(KEYSTORE_TYPE);
1:         KeyManager[] keystoreManagers = null;
1: 
1:         byte[] sslCert = loadClientCredential(SERVER_KEYSTORE);
1: 
1: 
1:         if (sslCert != null && sslCert.length > 0) {
1:             ByteArrayInputStream bin = new ByteArrayInputStream(sslCert);
1:             ks.load(bin, PASSWORD.toCharArray());
1:             kmf.init(ks, PASSWORD.toCharArray());
1:             keystoreManagers = kmf.getKeyManagers();
1:         }
1:         return keystoreManagers;
1:     }
1: 
1:     private static byte[] loadClientCredential(String fileName) throws IOException {
1:         if (fileName == null) {
1:             return null;
1:         }
1:         FileInputStream in = new FileInputStream(fileName);
1:         ByteArrayOutputStream out = new ByteArrayOutputStream();
1:         byte[] buf = new byte[512];
1:         int i = in.read(buf);
1:         while (i > 0) {
1:             out.write(buf, 0, i);
1:             i = in.read(buf);
1:         }
1:         in.close();
1:         return out.toByteArray();
1:     }
1: 
0:     private void makeSSLConnection(SSLContext context, String enabledSuites[], TransportConnector connector) throws Exception,
0:             UnknownHostException, SocketException {
1:         SSLSocket sslSocket = (SSLSocket) context.getSocketFactory().createSocket("localhost", connector.getUri().getPort());
1: 
1:         if (enabledSuites != null) {
1:             sslSocket.setEnabledCipherSuites(enabledSuites);
1:         }
0:         sslSocket.setSoTimeout(5000);
1: 
0:         SSLSession session = sslSocket.getSession();
1:         sslSocket.startHandshake();
1:     }
1: }
============================================================================