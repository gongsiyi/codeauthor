1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
5:d29ca2a:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:d29ca2a:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq;
1:4207bd9: 
1:862cd71: import java.io.File;
1:862cd71: import java.io.InputStream;
1:862cd71: import java.io.Serializable;
1:862cd71: import java.net.URL;
1:862cd71: import java.util.Collections;
1:862cd71: import java.util.Iterator;
1:862cd71: import java.util.List;
1:862cd71: import java.util.concurrent.CopyOnWriteArrayList;
1:1a5ad28: import java.util.concurrent.ThreadPoolExecutor;
1:862cd71: import java.util.concurrent.atomic.AtomicBoolean;
1:dc0291b: import java.util.concurrent.atomic.AtomicInteger;
1:862cd71: 
1:862cd71: import javax.jms.BytesMessage;
1:862cd71: import javax.jms.Destination;
1:862cd71: import javax.jms.IllegalStateException;
1:862cd71: import javax.jms.InvalidDestinationException;
1:862cd71: import javax.jms.InvalidSelectorException;
1:862cd71: import javax.jms.JMSException;
1:862cd71: import javax.jms.MapMessage;
1:862cd71: import javax.jms.Message;
1:862cd71: import javax.jms.MessageConsumer;
1:862cd71: import javax.jms.MessageListener;
1:862cd71: import javax.jms.MessageProducer;
1:862cd71: import javax.jms.ObjectMessage;
1:862cd71: import javax.jms.Queue;
1:862cd71: import javax.jms.QueueBrowser;
1:862cd71: import javax.jms.QueueReceiver;
1:862cd71: import javax.jms.QueueSender;
1:862cd71: import javax.jms.QueueSession;
1:862cd71: import javax.jms.Session;
1:862cd71: import javax.jms.StreamMessage;
1:862cd71: import javax.jms.TemporaryQueue;
1:862cd71: import javax.jms.TemporaryTopic;
1:862cd71: import javax.jms.TextMessage;
1:862cd71: import javax.jms.Topic;
1:862cd71: import javax.jms.TopicPublisher;
1:862cd71: import javax.jms.TopicSession;
1:862cd71: import javax.jms.TopicSubscriber;
1:862cd71: import javax.jms.TransactionRolledBackException;
1:862cd71: 
1:862cd71: import org.apache.activemq.blob.BlobDownloader;
1:4207bd9: import org.apache.activemq.blob.BlobTransferPolicy;
1:4207bd9: import org.apache.activemq.blob.BlobUploader;
1:862cd71: import org.apache.activemq.command.ActiveMQBlobMessage;
1:862cd71: import org.apache.activemq.command.ActiveMQBytesMessage;
1:862cd71: import org.apache.activemq.command.ActiveMQDestination;
1:862cd71: import org.apache.activemq.command.ActiveMQMapMessage;
1:862cd71: import org.apache.activemq.command.ActiveMQMessage;
1:862cd71: import org.apache.activemq.command.ActiveMQObjectMessage;
1:862cd71: import org.apache.activemq.command.ActiveMQQueue;
1:862cd71: import org.apache.activemq.command.ActiveMQStreamMessage;
1:862cd71: import org.apache.activemq.command.ActiveMQTempDestination;
1:862cd71: import org.apache.activemq.command.ActiveMQTempQueue;
1:862cd71: import org.apache.activemq.command.ActiveMQTempTopic;
1:862cd71: import org.apache.activemq.command.ActiveMQTextMessage;
1:862cd71: import org.apache.activemq.command.ActiveMQTopic;
1:862cd71: import org.apache.activemq.command.Command;
1:862cd71: import org.apache.activemq.command.ConsumerId;
1:862cd71: import org.apache.activemq.command.MessageAck;
1:862cd71: import org.apache.activemq.command.MessageDispatch;
1:862cd71: import org.apache.activemq.command.MessageId;
1:862cd71: import org.apache.activemq.command.ProducerId;
1:862cd71: import org.apache.activemq.command.RemoveInfo;
1:862cd71: import org.apache.activemq.command.Response;
1:862cd71: import org.apache.activemq.command.SessionId;
1:862cd71: import org.apache.activemq.command.SessionInfo;
1:862cd71: import org.apache.activemq.command.TransactionId;
1:4207bd9: import org.apache.activemq.management.JMSSessionStatsImpl;
1:4207bd9: import org.apache.activemq.management.StatsCapable;
1:4207bd9: import org.apache.activemq.management.StatsImpl;
1:4207bd9: import org.apache.activemq.thread.Scheduler;
1:4207bd9: import org.apache.activemq.transaction.Synchronization;
1:6d8e2c5: import org.apache.activemq.usage.MemoryUsage;
1:4207bd9: import org.apache.activemq.util.Callback;
1:4207bd9: import org.apache.activemq.util.LongSequenceGenerator;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:4207bd9: 
1:d29ca2a: /**
1:d29ca2a:  * <P>
1:d29ca2a:  * A <CODE>Session</CODE> object is a single-threaded context for producing
1:d29ca2a:  * and consuming messages. Although it may allocate provider resources outside
1:d29ca2a:  * the Java virtual machine (JVM), it is considered a lightweight JMS object.
1:d29ca2a:  * <P>
1:d29ca2a:  * A session serves several purposes:
1:d29ca2a:  * <UL>
1:d29ca2a:  * <LI>It is a factory for its message producers and consumers.
1:d29ca2a:  * <LI>It supplies provider-optimized message factories.
1:230a86c:  * <LI>It is a factory for <CODE>TemporaryTopics</CODE> and
1:230a86c:  * <CODE>TemporaryQueues</CODE>.
1:d29ca2a:  * <LI>It provides a way to create <CODE>Queue</CODE> or <CODE>Topic</CODE>
1:d29ca2a:  * objects for those clients that need to dynamically manipulate
1:d29ca2a:  * provider-specific destination names.
1:d29ca2a:  * <LI>It supports a single series of transactions that combine work spanning
1:d29ca2a:  * its producers and consumers into atomic units.
1:d29ca2a:  * <LI>It defines a serial order for the messages it consumes and the messages
1:d29ca2a:  * it produces.
1:d29ca2a:  * <LI>It retains messages it consumes until they have been acknowledged.
1:d29ca2a:  * <LI>It serializes execution of message listeners registered with its message
1:d29ca2a:  * consumers.
1:d29ca2a:  * <LI>It is a factory for <CODE>QueueBrowsers</CODE>.
1:d29ca2a:  * </UL>
1:d29ca2a:  * <P>
1:d29ca2a:  * A session can create and service multiple message producers and consumers.
1:d29ca2a:  * <P>
1:230a86c:  * One typical use is to have a thread block on a synchronous
1:230a86c:  * <CODE>MessageConsumer</CODE> until a message arrives. The thread may then
1:230a86c:  * use one or more of the <CODE>Session</CODE>'s<CODE>MessageProducer</CODE>s.
1:d29ca2a:  * <P>
1:d29ca2a:  * If a client desires to have one thread produce messages while others consume
1:d29ca2a:  * them, the client should use a separate session for its producing thread.
1:d29ca2a:  * <P>
1:d29ca2a:  * Once a connection has been started, any session with one or more registered
1:d29ca2a:  * message listeners is dedicated to the thread of control that delivers
1:d29ca2a:  * messages to it. It is erroneous for client code to use this session or any of
1:d29ca2a:  * its constituent objects from another thread of control. The only exception to
1:d29ca2a:  * this rule is the use of the session or connection <CODE>close</CODE>
1:d29ca2a:  * method.
1:d29ca2a:  * <P>
1:d29ca2a:  * It should be easy for most clients to partition their work naturally into
1:d29ca2a:  * sessions. This model allows clients to start simply and incrementally add
1:d29ca2a:  * message processing complexity as their need for concurrency grows.
1:d29ca2a:  * <P>
1:d29ca2a:  * The <CODE>close</CODE> method is the only session method that can be called
1:d29ca2a:  * while some other session method is being executed in another thread.
1:d29ca2a:  * <P>
1:d29ca2a:  * A session may be specified as transacted. Each transacted session supports a
1:d29ca2a:  * single series of transactions. Each transaction groups a set of message sends
1:d29ca2a:  * and a set of message receives into an atomic unit of work. In effect,
1:d29ca2a:  * transactions organize a session's input message stream and output message
1:d29ca2a:  * stream into series of atomic units. When a transaction commits, its atomic
1:d29ca2a:  * unit of input is acknowledged and its associated atomic unit of output is
1:d29ca2a:  * sent. If a transaction rollback is done, the transaction's sent messages are
1:d29ca2a:  * destroyed and the session's input is automatically recovered.
1:d29ca2a:  * <P>
1:d29ca2a:  * The content of a transaction's input and output units is simply those
1:d29ca2a:  * messages that have been produced and consumed within the session's current
1:d29ca2a:  * transaction.
1:d29ca2a:  * <P>
1:d29ca2a:  * A transaction is completed using either its session's <CODE>commit</CODE>
1:d29ca2a:  * method or its session's <CODE>rollback </CODE> method. The completion of a
1:d29ca2a:  * session's current transaction automatically begins the next. The result is
1:d29ca2a:  * that a transacted session always has a current transaction within which its
1:d29ca2a:  * work is done.
1:d29ca2a:  * <P>
1:d29ca2a:  * The Java Transaction Service (JTS) or some other transaction monitor may be
1:d29ca2a:  * used to combine a session's transaction with transactions on other resources
1:d29ca2a:  * (databases, other JMS sessions, etc.). Since Java distributed transactions
1:d29ca2a:  * are controlled via the Java Transaction API (JTA), use of the session's
1:d29ca2a:  * <CODE>commit</CODE> and <CODE>rollback</CODE> methods in this context is
1:d29ca2a:  * prohibited.
1:d29ca2a:  * <P>
1:d29ca2a:  * The JMS API does not require support for JTA; however, it does define how a
1:d29ca2a:  * provider supplies this support.
1:d29ca2a:  * <P>
1:d29ca2a:  * Although it is also possible for a JMS client to handle distributed
1:d29ca2a:  * transactions directly, it is unlikely that many JMS clients will do this.
1:d29ca2a:  * Support for JTA in the JMS API is targeted at systems vendors who will be
1:d29ca2a:  * integrating the JMS API into their application server products.
1:b0c2a40:  *
1:d29ca2a:  *
1:d29ca2a:  * @see javax.jms.Session
1:d29ca2a:  * @see javax.jms.QueueSession
1:d29ca2a:  * @see javax.jms.TopicSession
1:d29ca2a:  * @see javax.jms.XASession
1:d29ca2a:  */
1:d29ca2a: public class ActiveMQSession implements Session, QueueSession, TopicSession, StatsCapable, ActiveMQDispatcher {
28:d29ca2a: 
1:251dc7b:     /**
1:251dc7b:      * Only acknowledge an individual message - using message.acknowledge()
1:251dc7b:      * as opposed to CLIENT_ACKNOWLEDGE which
1:251dc7b:      * acknowledges all messages consumed by a session at when acknowledge()
1:251dc7b:      * is called
1:251dc7b:      */
1:2387612:     public static final int INDIVIDUAL_ACKNOWLEDGE = 4;
1:ab438f6:     public static final int MAX_ACK_CONSTANT = INDIVIDUAL_ACKNOWLEDGE;
1:d29ca2a: 
1:d29ca2a:     public static interface DeliveryListener {
1:fc00993:         void beforeDelivery(ActiveMQSession session, Message msg);
1:230a86c: 
1:fc00993:         void afterDelivery(ActiveMQSession session, Message msg);
1:d29ca2a:     }
1:c9a3202: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(ActiveMQSession.class);
1:1a5ad28:     private final ThreadPoolExecutor connectionExecutor;
1:c9a3202: 
1:d29ca2a:     protected int acknowledgementMode;
1:d29ca2a:     protected final ActiveMQConnection connection;
1:d29ca2a:     protected final SessionInfo info;
1:d29ca2a:     protected final LongSequenceGenerator consumerIdGenerator = new LongSequenceGenerator();
1:d29ca2a:     protected final LongSequenceGenerator producerIdGenerator = new LongSequenceGenerator();
1:d29ca2a:     protected final LongSequenceGenerator deliveryIdGenerator = new LongSequenceGenerator();
1:7ad152b:     protected final ActiveMQSessionExecutor executor;
1:d29ca2a:     protected final AtomicBoolean started = new AtomicBoolean(false);
1:230a86c: 
1:ecf89a6:     protected final CopyOnWriteArrayList<ActiveMQMessageConsumer> consumers = new CopyOnWriteArrayList<ActiveMQMessageConsumer>();
1:ecf89a6:     protected final CopyOnWriteArrayList<ActiveMQMessageProducer> producers = new CopyOnWriteArrayList<ActiveMQMessageProducer>();
1:230a86c: 
1:d29ca2a:     protected boolean closed;
1:2387612:     private volatile boolean synchronizationRegistered;
1:d29ca2a:     protected boolean asyncDispatch;
1:d964145:     protected boolean sessionAsyncDispatch;
1:341a1d4:     protected final boolean debug;
1:c85c7c1:     protected final Object sendMutex = new Object();
1:c85c7c1:     protected final Object redeliveryGuard = new Object();
1:c85c7c1: 
1:c7d66e9:     private final AtomicBoolean clearInProgress = new AtomicBoolean();
1:230a86c: 
1:fc00993:     private MessageListener messageListener;
1:1a5ad28:     private final JMSSessionStatsImpl stats;
1:fc00993:     private TransactionContext transactionContext;
1:fc00993:     private DeliveryListener deliveryListener;
1:fc00993:     private MessageTransformer transformer;
1:fc00993:     private BlobTransferPolicy blobTransferPolicy;
1:eb6c082:     private long lastDeliveredSequenceId = -2;
1:fc00993: 
1:d29ca2a:     /**
1:d29ca2a:      * Construct the Session
1:d29ca2a:      *
1:d29ca2a:      * @param connection
1:230a86c:      * @param sessionId
1:230a86c:      * @param acknowledgeMode n.b if transacted - the acknowledgeMode ==
1:230a86c:      *                Session.SESSION_TRANSACTED
1:230a86c:      * @param asyncDispatch
1:230a86c:      * @param sessionAsyncDispatch
1:230a86c:      * @throws JMSException on internal error
1:d29ca2a:      */
1:230a86c:     protected ActiveMQSession(ActiveMQConnection connection, SessionId sessionId, int acknowledgeMode, boolean asyncDispatch, boolean sessionAsyncDispatch) throws JMSException {
1:fc00993:         this.debug = LOG.isDebugEnabled();
1:d29ca2a:         this.connection = connection;
1:d29ca2a:         this.acknowledgementMode = acknowledgeMode;
1:230a86c:         this.asyncDispatch = asyncDispatch;
1:d964145:         this.sessionAsyncDispatch = sessionAsyncDispatch;
1:c59246d:         this.info = new SessionInfo(connection.getConnectionInfo(), sessionId.getValue());
1:d29ca2a:         setTransactionContext(new TransactionContext(connection));
1:d29ca2a:         stats = new JMSSessionStatsImpl(producers, consumers);
1:d29ca2a:         this.connection.asyncSendPacket(info);
1:86faaef:         setTransformer(connection.getTransformer());
1:05a8cba:         setBlobTransferPolicy(connection.getBlobTransferPolicy());
1:1a5ad28:         this.connectionExecutor=connection.getExecutor();
1:7ad152b:         this.executor = new ActiveMQSessionExecutor(this);
1:c62b951:         connection.addSession(this);
1:ecf89a6:         if (connection.isStarted()) {
1:d29ca2a:             start();
1:c9a3202:         }
1:230a86c: 
1:ecf89a6:     }
1:230a86c: 
1:230a86c:     protected ActiveMQSession(ActiveMQConnection connection, SessionId sessionId, int acknowledgeMode, boolean asyncDispatch) throws JMSException {
1:230a86c:         this(connection, sessionId, acknowledgeMode, asyncDispatch, true);
1:d29ca2a:     }
1:c9bb1c9: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets the transaction context of the session.
1:d29ca2a:      *
1:230a86c:      * @param transactionContext - provides the means to control a JMS
1:230a86c:      *                transaction.
1:d29ca2a:      */
1:d29ca2a:     public void setTransactionContext(TransactionContext transactionContext) {
1:d29ca2a:         this.transactionContext = transactionContext;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Returns the transaction context of the session.
1:d29ca2a:      *
1:d29ca2a:      * @return transactionContext - session's transaction context.
1:d29ca2a:      */
1:d29ca2a:     public TransactionContext getTransactionContext() {
1:d29ca2a:         return transactionContext;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /*
1:d29ca2a:      * (non-Javadoc)
1:d29ca2a:      *
1:d29ca2a:      * @see org.apache.activemq.management.StatsCapable#getStats()
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public StatsImpl getStats() {
1:d29ca2a:         return stats;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Returns the session's statistics.
1:d29ca2a:      *
1:d29ca2a:      * @return stats - session's statistics.
1:d29ca2a:      */
1:d29ca2a:     public JMSSessionStatsImpl getSessionStats() {
1:d29ca2a:         return stats;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a <CODE>BytesMessage</CODE> object. A <CODE>BytesMessage</CODE>
1:d29ca2a:      * object is used to send a message containing a stream of uninterpreted
1:d29ca2a:      * bytes.
1:d29ca2a:      *
1:d29ca2a:      * @return the an ActiveMQBytesMessage
1:230a86c:      * @throws JMSException if the JMS provider fails to create this message due
1:230a86c:      *                 to some internal error.
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public BytesMessage createBytesMessage() throws JMSException {
1:d29ca2a:         ActiveMQBytesMessage message = new ActiveMQBytesMessage();
1:8cf4795:         configureMessage(message);
1:d29ca2a:         return message;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a <CODE>MapMessage</CODE> object. A <CODE>MapMessage</CODE>
1:d29ca2a:      * object is used to send a self-defining set of name-value pairs, where
1:d29ca2a:      * names are <CODE>String</CODE> objects and values are primitive values
1:d29ca2a:      * in the Java programming language.
1:d29ca2a:      *
1:d29ca2a:      * @return an ActiveMQMapMessage
1:230a86c:      * @throws JMSException if the JMS provider fails to create this message due
1:230a86c:      *                 to some internal error.
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public MapMessage createMapMessage() throws JMSException {
1:d29ca2a:         ActiveMQMapMessage message = new ActiveMQMapMessage();
1:8cf4795:         configureMessage(message);
1:d29ca2a:         return message;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a <CODE>Message</CODE> object. The <CODE>Message</CODE>
1:230a86c:      * interface is the root interface of all JMS messages. A
1:230a86c:      * <CODE>Message</CODE> object holds all the standard message header
1:230a86c:      * information. It can be sent when a message containing only header
1:230a86c:      * information is sufficient.
1:d29ca2a:      *
1:d29ca2a:      * @return an ActiveMQMessage
1:230a86c:      * @throws JMSException if the JMS provider fails to create this message due
1:230a86c:      *                 to some internal error.
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public Message createMessage() throws JMSException {
1:d29ca2a:         ActiveMQMessage message = new ActiveMQMessage();
1:8cf4795:         configureMessage(message);
1:d29ca2a:         return message;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * Creates an <CODE>ObjectMessage</CODE> object. An
1:230a86c:      * <CODE>ObjectMessage</CODE> object is used to send a message that
1:230a86c:      * contains a serializable Java object.
1:d29ca2a:      *
1:d29ca2a:      * @return an ActiveMQObjectMessage
1:230a86c:      * @throws JMSException if the JMS provider fails to create this message due
1:230a86c:      *                 to some internal error.
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public ObjectMessage createObjectMessage() throws JMSException {
1:d29ca2a:         ActiveMQObjectMessage message = new ActiveMQObjectMessage();
1:8cf4795:         configureMessage(message);
1:d29ca2a:         return message;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * Creates an initialized <CODE>ObjectMessage</CODE> object. An
1:230a86c:      * <CODE>ObjectMessage</CODE> object is used to send a message that
1:230a86c:      * contains a serializable Java object.
1:d29ca2a:      *
1:230a86c:      * @param object the object to use to initialize this message
1:d29ca2a:      * @return an ActiveMQObjectMessage
1:230a86c:      * @throws JMSException if the JMS provider fails to create this message due
1:230a86c:      *                 to some internal error.
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public ObjectMessage createObjectMessage(Serializable object) throws JMSException {
1:d29ca2a:         ActiveMQObjectMessage message = new ActiveMQObjectMessage();
1:8cf4795:         configureMessage(message);
1:d29ca2a:         message.setObject(object);
1:d29ca2a:         return message;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * Creates a <CODE>StreamMessage</CODE> object. A
1:230a86c:      * <CODE>StreamMessage</CODE> object is used to send a self-defining
1:230a86c:      * stream of primitive values in the Java programming language.
1:d29ca2a:      *
1:d29ca2a:      * @return an ActiveMQStreamMessage
1:230a86c:      * @throws JMSException if the JMS provider fails to create this message due
1:230a86c:      *                 to some internal error.
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public StreamMessage createStreamMessage() throws JMSException {
1:d29ca2a:         ActiveMQStreamMessage message = new ActiveMQStreamMessage();
1:8cf4795:         configureMessage(message);
1:d29ca2a:         return message;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a <CODE>TextMessage</CODE> object. A <CODE>TextMessage</CODE>
1:d29ca2a:      * object is used to send a message containing a <CODE>String</CODE>
3:d29ca2a:      * object.
1:d29ca2a:      *
1:d29ca2a:      * @return an ActiveMQTextMessage
1:230a86c:      * @throws JMSException if the JMS provider fails to create this message due
1:230a86c:      *                 to some internal error.
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public TextMessage createTextMessage() throws JMSException {
1:d29ca2a:         ActiveMQTextMessage message = new ActiveMQTextMessage();
1:8cf4795:         configureMessage(message);
1:d29ca2a:         return message;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * Creates an initialized <CODE>TextMessage</CODE> object. A
1:230a86c:      * <CODE>TextMessage</CODE> object is used to send a message containing a
1:230a86c:      * <CODE>String</CODE>.
1:d29ca2a:      *
1:230a86c:      * @param text the string used to initialize this message
1:d29ca2a:      * @return an ActiveMQTextMessage
1:230a86c:      * @throws JMSException if the JMS provider fails to create this message due
1:230a86c:      *                 to some internal error.
1:ab3b155:      */
1:a88e19e:     @Override
1:d29ca2a:     public TextMessage createTextMessage(String text) throws JMSException {
1:d29ca2a:         ActiveMQTextMessage message = new ActiveMQTextMessage();
1:d29ca2a:         message.setText(text);
1:8cf4795:         configureMessage(message);
1:d29ca2a:         return message;
1:cbaa58b:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * Creates an initialized <CODE>BlobMessage</CODE> object. A
1:230a86c:      * <CODE>BlobMessage</CODE> object is used to send a message containing a
1:230a86c:      * <CODE>URL</CODE> which points to some network addressible BLOB.
1:230a86c:      *
1:230a86c:      * @param url the network addressable URL used to pass directly to the
1:230a86c:      *                consumer
1:8cf4795:      * @return a BlobMessage
1:230a86c:      * @throws JMSException if the JMS provider fails to create this message due
1:230a86c:      *                 to some internal error.
1:d29ca2a:      */
1:8cf4795:     public BlobMessage createBlobMessage(URL url) throws JMSException {
1:53bf323:         return createBlobMessage(url, false);
1:84eb9f8:     }
1:d29ca2a: 
1:ab3b155:     /**
1:230a86c:      * Creates an initialized <CODE>BlobMessage</CODE> object. A
1:230a86c:      * <CODE>BlobMessage</CODE> object is used to send a message containing a
1:230a86c:      * <CODE>URL</CODE> which points to some network addressible BLOB.
1:230a86c:      *
1:230a86c:      * @param url the network addressable URL used to pass directly to the
1:230a86c:      *                consumer
1:230a86c:      * @param deletedByBroker indicates whether or not the resource is deleted
1:230a86c:      *                by the broker when the message is acknowledged
1:53bf323:      * @return a BlobMessage
1:230a86c:      * @throws JMSException if the JMS provider fails to create this message due
1:230a86c:      *                 to some internal error.
1:d964145:      */
1:53bf323:     public BlobMessage createBlobMessage(URL url, boolean deletedByBroker) throws JMSException {
1:8cf4795:         ActiveMQBlobMessage message = new ActiveMQBlobMessage();
1:8cf4795:         configureMessage(message);
1:8cf4795:         message.setURL(url);
1:53bf323:         message.setDeletedByBroker(deletedByBroker);
1:b08ae50:         message.setBlobDownloader(new BlobDownloader(getBlobTransferPolicy()));
1:8cf4795:         return message;
1:ef0734b:     }
1:d29ca2a: 
1:d964145:     /**
1:230a86c:      * Creates an initialized <CODE>BlobMessage</CODE> object. A
1:230a86c:      * <CODE>BlobMessage</CODE> object is used to send a message containing
1:230a86c:      * the <CODE>File</CODE> content. Before the message is sent the file
1:230a86c:      * conent will be uploaded to the broker or some other remote repository
1:53bf323:      * depending on the {@link #getBlobTransferPolicy()}.
1:230a86c:      *
1:230a86c:      * @param file the file to be uploaded to some remote repo (or the broker)
1:230a86c:      *                depending on the strategy
1:8cf4795:      * @return a BlobMessage
1:230a86c:      * @throws JMSException if the JMS provider fails to create this message due
1:230a86c:      *                 to some internal error.
1:d964145:      */
1:8cf4795:     public BlobMessage createBlobMessage(File file) throws JMSException {
1:8cf4795:         ActiveMQBlobMessage message = new ActiveMQBlobMessage();
1:8cf4795:         configureMessage(message);
1:05a8cba:         message.setBlobUploader(new BlobUploader(getBlobTransferPolicy(), file));
1:b08ae50:         message.setBlobDownloader(new BlobDownloader((getBlobTransferPolicy())));
1:8cf4795:         message.setDeletedByBroker(true);
1:05a8cba:         message.setName(file.getName());
1:8cf4795:         return message;
1:ef0734b:     }
1:d29ca2a: 
1:fba0742:     /**
1:230a86c:      * Creates an initialized <CODE>BlobMessage</CODE> object. A
1:230a86c:      * <CODE>BlobMessage</CODE> object is used to send a message containing
1:230a86c:      * the <CODE>File</CODE> content. Before the message is sent the file
1:230a86c:      * conent will be uploaded to the broker or some other remote repository
1:12b26b6:      * depending on the {@link #getBlobTransferPolicy()}. <br/>
1:12b26b6:      * <p>
1:12b26b6:      * The caller of this method is responsible for closing the
1:12b26b6:      * input stream that is used, however the stream can not be closed
1:12b26b6:      * until <b>after</b> the message has been sent.  To have this class
1:12b26b6:      * manage the stream and close it automatically, use the method
1:12b26b6:      * {@link ActiveMQSession#createBlobMessage(File)}
1:230a86c:      *
1:230a86c:      * @param in the stream to be uploaded to some remote repo (or the broker)
1:230a86c:      *                depending on the strategy
1:8cf4795:      * @return a BlobMessage
1:230a86c:      * @throws JMSException if the JMS provider fails to create this message due
1:230a86c:      *                 to some internal error.
1:fba0742:      */
1:8cf4795:     public BlobMessage createBlobMessage(InputStream in) throws JMSException {
1:8cf4795:         ActiveMQBlobMessage message = new ActiveMQBlobMessage();
1:8cf4795:         configureMessage(message);
1:05a8cba:         message.setBlobUploader(new BlobUploader(getBlobTransferPolicy(), in));
1:b08ae50:         message.setBlobDownloader(new BlobDownloader(getBlobTransferPolicy()));
1:8cf4795:         message.setDeletedByBroker(true);
1:8cf4795:         return message;
4:ef0734b:     }
1:d29ca2a: 
1:53bf323:     /**
1:d29ca2a:      * Indicates whether the session is in transacted mode.
1:d29ca2a:      *
1:d29ca2a:      * @return true if the session is in transacted mode
1:230a86c:      * @throws JMSException if there is some internal error.
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public boolean getTransacted() throws JMSException {
11:d29ca2a:         checkClosed();
1:62daac4:         return isTransacted();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Returns the acknowledgement mode of the session. The acknowledgement mode
1:d29ca2a:      * is set at the time that the session is created. If the session is
1:d29ca2a:      * transacted, the acknowledgement mode is ignored.
1:d29ca2a:      *
1:d29ca2a:      * @return If the session is not transacted, returns the current
1:d29ca2a:      *         acknowledgement mode for the session. If the session is
1:d29ca2a:      *         transacted, returns SESSION_TRANSACTED.
39:d29ca2a:      * @throws JMSException
1:d29ca2a:      * @see javax.jms.Connection#createSession(boolean,int)
1:d29ca2a:      * @since 1.1 exception JMSException if there is some internal error.
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public int getAcknowledgeMode() throws JMSException {
1:d29ca2a:         checkClosed();
1:d29ca2a:         return this.acknowledgementMode;
1:d29ca2a:     }
1:4207bd9: 
1:d29ca2a:     /**
1:d29ca2a:      * Commits all messages done in this transaction and releases any locks
1:d29ca2a:      * currently held.
1:d29ca2a:      *
1:230a86c:      * @throws JMSException if the JMS provider fails to commit the transaction
1:230a86c:      *                 due to some internal error.
1:230a86c:      * @throws TransactionRolledBackException if the transaction is rolled back
1:230a86c:      *                 due to some internal error during commit.
1:230a86c:      * @throws javax.jms.IllegalStateException if the method is not called by a
1:230a86c:      *                 transacted session.
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public void commit() throws JMSException {
1:d29ca2a:         checkClosed();
1:d29ca2a:         if (!getTransacted()) {
1:d29ca2a:             throw new javax.jms.IllegalStateException("Not a transacted session");
1:d29ca2a:         }
1:5829d70:         if (LOG.isDebugEnabled()) {
1:0fe1944:             LOG.debug(getSessionId() + " Transaction Commit :" + transactionContext.getTransactionId());
1:d29ca2a:         }
1:d29ca2a:         transactionContext.commit();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Rolls back any messages done in this transaction and releases any locks
1:d29ca2a:      * currently held.
1:d29ca2a:      *
1:230a86c:      * @throws JMSException if the JMS provider fails to roll back the
1:230a86c:      *                 transaction due to some internal error.
1:230a86c:      * @throws javax.jms.IllegalStateException if the method is not called by a
1:230a86c:      *                 transacted session.
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public void rollback() throws JMSException {
1:d29ca2a:         checkClosed();
1:d29ca2a:         if (!getTransacted()) {
1:d29ca2a:             throw new javax.jms.IllegalStateException("Not a transacted session");
1:d29ca2a:         }
1:5829d70:         if (LOG.isDebugEnabled()) {
1:d2bc650:             LOG.debug(getSessionId() + " Transaction Rollback, txid:"  + transactionContext.getTransactionId());
1:251dc7b:         }
1:d29ca2a:         transactionContext.rollback();
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     /**
1:d29ca2a:      * Closes the session.
1:d29ca2a:      * <P>
1:d29ca2a:      * Since a provider may allocate some resources on behalf of a session
1:d29ca2a:      * outside the JVM, clients should close the resources when they are not
1:d29ca2a:      * needed. Relying on garbage collection to eventually reclaim these
1:d29ca2a:      * resources may not be timely enough.
1:d29ca2a:      * <P>
1:d29ca2a:      * There is no need to close the producers and consumers of a closed
1:d29ca2a:      * session.
1:d29ca2a:      * <P>
1:d29ca2a:      * This call will block until a <CODE>receive</CODE> call or message
1:230a86c:      * listener in progress has completed. A blocked message consumer
1:230a86c:      * <CODE>receive</CODE> call returns <CODE>null</CODE> when this session
1:230a86c:      * is closed.
1:d29ca2a:      * <P>
1:d29ca2a:      * Closing a transacted session must roll back the transaction in progress.
1:d29ca2a:      * <P>
1:d29ca2a:      * This method is the only <CODE>Session</CODE> method that can be called
1:d29ca2a:      * concurrently.
1:d29ca2a:      * <P>
1:d29ca2a:      * Invoking any other <CODE>Session</CODE> method on a closed session must
1:d29ca2a:      * throw a <CODE> JMSException.IllegalStateException</CODE>. Closing a
1:d29ca2a:      * closed session must <I>not </I> throw an exception.
1:d29ca2a:      *
1:230a86c:      * @throws JMSException if the JMS provider fails to close the session due
1:230a86c:      *                 to some internal error.
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public void close() throws JMSException {
1:d29ca2a:         if (!closed) {
1:85181d6:             if (getTransactionContext().isInXATransaction()) {
1:2387612:                 if (!synchronizationRegistered) {
1:2387612:                     synchronizationRegistered = true;
1:230a86c:                     getTransactionContext().addSynchronization(new Synchronization() {
1:1408e7f: 
1:151e251:                                         @Override
1:2387612:                                         public void afterCommit() throws Exception {
1:2387612:                                             doClose();
1:2387612:                                             synchronizationRegistered = false;
1:1408e7f:                                         }
1:e2aad41: 
1:151e251:                                         @Override
1:230a86c:                                         public void afterRollback() throws Exception {
1:2387612:                                             doClose();
1:2387612:                                             synchronizationRegistered = false;
1:e500f2e:                                         }
1:d29ca2a:                                     });
1:e500f2e:                 }
1:1408e7f: 
1:230a86c:             } else {
1:2387612:                 doClose();
1:e500f2e:             }
1:e500f2e:         }
1:e500f2e:     }
1:1408e7f: 
1:2387612:     private void doClose() throws JMSException {
1:d29ca2a:         dispose();
1:3b08860:         RemoveInfo removeCommand = info.createRemoveCommand();
1:3b08860:         removeCommand.setLastDeliveredSequenceId(lastDeliveredSequenceId);
1:3b08860:         connection.asyncSendPacket(removeCommand);
1:d29ca2a:     }
1:c256dcf: 
1:e8818fa:     final AtomicInteger clearRequestsCounter = new AtomicInteger(0);
1:dc0291b:     void clearMessagesInProgress(AtomicInteger transportInterruptionProcessingComplete) {
1:e8818fa:         clearRequestsCounter.incrementAndGet();
1:862cd71:         executor.clearMessagesInProgress();
1:c7d66e9:         // we are called from inside the transport reconnection logic which involves us
1:c7d66e9:         // clearing all the connections' consumers dispatch and delivered lists. So rather
1:c7d66e9:         // than trying to grab a mutex (which could be already owned by the message listener
1:c7d66e9:         // calling the send or an ack) we allow it to complete in a separate thread via the
1:c7d66e9:         // scheduler and notify us via connection.transportInterruptionProcessingComplete()
1:862cd71:         //
1:c7d66e9:         // We must be careful though not to allow multiple calls to this method from a
1:c7d66e9:         // connection that is having issue becoming fully established from causing a large
1:c7d66e9:         // build up of scheduled tasks to clear the same consumers over and over.
1:c7d66e9:         if (consumers.isEmpty()) {
1:c7d66e9:             return;
1:c7d66e9:         }
1:c7d66e9: 
1:c7d66e9:         if (clearInProgress.compareAndSet(false, true)) {
1:c7d66e9:             for (final ActiveMQMessageConsumer consumer : consumers) {
1:c7d66e9:                 consumer.inProgressClearRequired();
1:dc0291b:                 transportInterruptionProcessingComplete.incrementAndGet();
1:c7d66e9:                 try {
1:c7d66e9:                     connection.getScheduler().executeAfterDelay(new Runnable() {
1:a88e19e:                         @Override
1:c7d66e9:                         public void run() {
1:c7d66e9:                             consumer.clearMessagesInProgress();
1:c7d66e9:                         }}, 0l);
1:c7d66e9:                 } catch (JMSException e) {
1:c7d66e9:                     connection.onClientInternalException(e);
1:c7d66e9:                 }
1:c7d66e9:             }
1:c7d66e9: 
1:230a86c:             try {
1:97ae323:                 connection.getScheduler().executeAfterDelay(new Runnable() {
1:c7d66e9:                     @Override
1:862cd71:                     public void run() {
1:c7d66e9:                         clearInProgress.set(false);
1:862cd71:                     }}, 0l);
1:d29ca2a:             } catch (JMSException e) {
1:97ae323:                 connection.onClientInternalException(e);
1:151e251:             }
1:d29ca2a:         }
1:97ae323:     }
1:230a86c: 
1:230a86c:     void deliverAcks() {
1:e45bb06:         for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
1:e45bb06:             ActiveMQMessageConsumer consumer = iter.next();
1:ef0734b:             consumer.deliverAcks();
1:e45bb06:         }
1:e45bb06:     }
1:e45bb06: 
1:fc00993:     public synchronized void dispose() throws JMSException {
1:d29ca2a:         if (!closed) {
1:d29ca2a: 
2:d29ca2a:             try {
1:c9a3202:                 executor.close();
1:d29ca2a: 
1:ecf89a6:                 for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
2:ecf89a6:                     ActiveMQMessageConsumer consumer = iter.next();
1:f8ef7ff:                     consumer.setFailureError(connection.getFirstFailureError());
1:d29ca2a:                     consumer.dispose();
1:3b08860:                     lastDeliveredSequenceId = Math.max(lastDeliveredSequenceId, consumer.getLastDeliveredSequenceId());
1:e500f2e:                 }
1:d29ca2a:                 consumers.clear();
1:d29ca2a: 
1:ecf89a6:                 for (Iterator<ActiveMQMessageProducer> iter = producers.iterator(); iter.hasNext();) {
1:ecf89a6:                     ActiveMQMessageProducer producer = iter.next();
1:d29ca2a:                     producer.dispose();
1:d29ca2a:                 }
1:d29ca2a:                 producers.clear();
1:d29ca2a: 
1:d29ca2a:                 try {
1:d29ca2a:                     if (getTransactionContext().isInLocalTransaction()) {
1:d29ca2a:                         rollback();
1:d29ca2a:                     }
1:230a86c:                 } catch (JMSException e) {
1:d29ca2a:                 }
1:d29ca2a: 
1:1408e7f:             } finally {
1:d29ca2a:                 connection.removeSession(this);
1:7249191:                 this.transactionContext = null;
1:d29ca2a:                 closed = true;
1:d29ca2a:             }
1:d29ca2a:         }
1:ef0734b:     }
1:e2aad41: 
1:05a8cba:     /**
1:8cf4795:      * Checks that the session is not closed then configures the message
1:fba0742:      */
1:8cf4795:     protected void configureMessage(ActiveMQMessage message) throws IllegalStateException {
1:d29ca2a:         checkClosed();
8:d29ca2a:         message.setConnection(connection);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Check if the session is closed. It is used for ensuring that the session
1:d29ca2a:      * is open before performing various operations.
1:d29ca2a:      *
1:230a86c:      * @throws IllegalStateException if the Session is closed
1:d29ca2a:      */
1:d29ca2a:     protected void checkClosed() throws IllegalStateException {
1:d29ca2a:         if (closed) {
1:d29ca2a:             throw new IllegalStateException("The Session is closed");
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:be37064:      * Checks if the session is closed.
1:d29ca2a:      *
1:be37064:      * @return true if the session is closed, false otherwise.
1:be37064:      */
1:be37064:     public boolean isClosed() {
1:be37064:         return closed;
1:d29ca2a:     }
1:d29ca2a: 
1:be37064:     /**
1:d29ca2a:      * Stops message delivery in this session, and restarts message delivery
1:d29ca2a:      * with the oldest unacknowledged message.
1:d29ca2a:      * <P>
1:d29ca2a:      * All consumers deliver messages in a serial order. Acknowledging a
1:d29ca2a:      * received message automatically acknowledges all messages that have been
1:d29ca2a:      * delivered to the client.
1:d29ca2a:      * <P>
1:d29ca2a:      * Restarting a session causes it to take the following actions:
1:d29ca2a:      * <UL>
1:d29ca2a:      * <LI>Stop message delivery
1:d29ca2a:      * <LI>Mark all messages that might have been delivered but not
1:d29ca2a:      * acknowledged as "redelivered"
1:d29ca2a:      * <LI>Restart the delivery sequence including all unacknowledged messages
1:d29ca2a:      * that had been previously delivered. Redelivered messages do not have to
1:d29ca2a:      * be delivered in exactly their original delivery order.
1:d29ca2a:      * </UL>
1:d29ca2a:      *
1:230a86c:      * @throws JMSException if the JMS provider fails to stop and restart
1:230a86c:      *                 message delivery due to some internal error.
1:230a86c:      * @throws IllegalStateException if the method is called by a transacted
1:230a86c:      *                 session.
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public void recover() throws JMSException {
1:d29ca2a: 
1:d29ca2a:         checkClosed();
1:d29ca2a:         if (getTransacted()) {
1:d29ca2a:             throw new IllegalStateException("This session is transacted");
1:d29ca2a:         }
1:d29ca2a: 
1:ecf89a6:         for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
1:ecf89a6:             ActiveMQMessageConsumer c = iter.next();
1:d29ca2a:             c.rollback();
1:d29ca2a:         }
1:d29ca2a: 
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Returns the session's distinguished message listener (optional).
1:d29ca2a:      *
1:d29ca2a:      * @return the message listener associated with this session
1:230a86c:      * @throws JMSException if the JMS provider fails to get the message
1:230a86c:      *                 listener due to an internal error.
1:d29ca2a:      * @see javax.jms.Session#setMessageListener(javax.jms.MessageListener)
1:d29ca2a:      * @see javax.jms.ServerSessionPool
1:d29ca2a:      * @see javax.jms.ServerSession
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public MessageListener getMessageListener() throws JMSException {
1:d29ca2a:         checkClosed();
1:d29ca2a:         return this.messageListener;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets the session's distinguished message listener (optional).
1:d29ca2a:      * <P>
1:d29ca2a:      * When the distinguished message listener is set, no other form of message
1:d29ca2a:      * receipt in the session can be used; however, all forms of sending
1:d29ca2a:      * messages are still supported.
1:d29ca2a:      * <P>
1:b080d5f:      * If this session has been closed, then an {@link IllegalStateException} is
1:b080d5f:      * thrown, if trying to set a new listener. However setting the listener
1:b080d5f:      * to <tt>null</tt> is allowed, to clear the listener, even if this session
1:b080d5f:      * has been closed prior.
1:b080d5f:      * <P>
1:d29ca2a:      * This is an expert facility not used by regular JMS clients.
1:d29ca2a:      *
1:230a86c:      * @param listener the message listener to associate with this session
1:230a86c:      * @throws JMSException if the JMS provider fails to set the message
1:230a86c:      *                 listener due to an internal error.
1:d29ca2a:      * @see javax.jms.Session#getMessageListener()
1:d29ca2a:      * @see javax.jms.ServerSessionPool
1:d29ca2a:      * @see javax.jms.ServerSession
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public void setMessageListener(MessageListener listener) throws JMSException {
1:b080d5f:         // only check for closed if we set a new listener, as we allow to clear
1:b080d5f:         // the listener, such as when an application is shutting down, and is
1:b080d5f:         // no longer using a message listener on this session
1:b080d5f:         if (listener != null) {
1:d29ca2a:             checkClosed();
1:d29ca2a:         }
1:d29ca2a:         this.messageListener = listener;
1:d29ca2a: 
1:d29ca2a:         if (listener != null) {
1:d29ca2a:             executor.setDispatchedBySessionPool(true);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Optional operation, intended to be used only by Application Servers, not
1:d29ca2a:      * by ordinary JMS clients.
1:d29ca2a:      *
1:d29ca2a:      * @see javax.jms.ServerSession
1:d29ca2a:      */
1:a88e19e:     @Override
1:230a86c:     public void run() {
1:d29ca2a:         MessageDispatch messageDispatch;
1:d29ca2a:         while ((messageDispatch = executor.dequeueNoWait()) != null) {
1:d29ca2a:             final MessageDispatch md = messageDispatch;
1:eb6c082:             final ActiveMQMessage message = (ActiveMQMessage)md.getMessage();
1:e8818fa: 
1:e8818fa:             MessageAck earlyAck = null;
1:e8818fa:             if (message.isExpired()) {
1:b136df1:                 earlyAck = new MessageAck(md, MessageAck.EXPIRED_ACK_TYPE, 1);
1:f10aab6:                 earlyAck.setFirstMessageId(message.getMessageId());
1:e8818fa:             } else if (connection.isDuplicate(ActiveMQSession.this, message)) {
1:e8818fa:                 LOG.debug("{} got duplicate: {}", this, message.getMessageId());
1:e8818fa:                 earlyAck = new MessageAck(md, MessageAck.POSION_ACK_TYPE, 1);
1:e8818fa:                 earlyAck.setFirstMessageId(md.getMessage().getMessageId());
1:e8818fa:                 earlyAck.setPoisonCause(new Throwable("Duplicate delivery to " + this));
1:e8818fa:             }
1:e8818fa:             if (earlyAck != null) {
1:e8818fa:                 try {
1:e8818fa:                     asyncSendPacket(earlyAck);
1:e8818fa:                 } catch (Throwable t) {
1:e8818fa:                     LOG.error("error dispatching ack: {} ", earlyAck, t);
1:e8818fa:                     connection.onClientInternalException(t);
1:e8818fa:                 } finally {
1:e8818fa:                     continue;
1:e8818fa:                 }
1:d29ca2a:             }
1:230a86c: 
1:2076f45:             if (isClientAcknowledge()||isIndividualAcknowledge()) {
1:d29ca2a:                 message.setAcknowledgeCallback(new Callback() {
1:a88e19e:                     @Override
1:7f5213b:                     public void execute() throws Exception {
1:d29ca2a:                     }
1:d29ca2a:                 });
1:d29ca2a:             }
1:230a86c: 
2:d29ca2a:             if (deliveryListener != null) {
1:d29ca2a:                 deliveryListener.beforeDelivery(this, message);
1:d29ca2a:             }
1:c9a3202: 
1:230a86c:             md.setDeliverySequenceId(getNextDeliveryId());
1:eb6c082:             lastDeliveredSequenceId = message.getMessageId().getBrokerSequenceId();
1:d29ca2a: 
1:1408e7f:             final MessageAck ack = new MessageAck(md, MessageAck.STANDARD_ACK_TYPE, 1);
1:d29ca2a: 
1:151e251:             final AtomicBoolean afterDeliveryError = new AtomicBoolean(false);
1:151e251:             /*
1:151e251:             * The redelivery guard is to allow the endpoint lifecycle to complete before the messsage is dispatched.
1:151e251:             * We dont want the after deliver being called after the redeliver as it may cause some weird stuff.
1:151e251:             * */
1:c85c7c1:             synchronized (redeliveryGuard) {
1:151e251:                 try {
1:151e251:                     ack.setFirstMessageId(md.getMessage().getMessageId());
1:151e251:                     doStartTransaction();
1:151e251:                     ack.setTransactionId(getTransactionContext().getTransactionId());
1:151e251:                     if (ack.getTransactionId() != null) {
1:151e251:                         getTransactionContext().addSynchronization(new Synchronization() {
1:151e251: 
1:e8818fa:                             final int clearRequestCount = (clearRequestsCounter.get() == Integer.MAX_VALUE ? clearRequestsCounter.incrementAndGet() : clearRequestsCounter.get());
1:151e251: 
1:a88e19e:                             @Override
1:151e251:                             public void beforeEnd() throws Exception {
1:e8818fa:                                 // validate our consumer so we don't push stale acks that get ignored
1:e8818fa:                                 if (ack.getTransactionId().isXATransaction() && !connection.hasDispatcher(ack.getConsumerId())) {
1:e8818fa:                                     LOG.debug("forcing rollback - {} consumer no longer active on {}", ack, connection);
1:e8818fa:                                     throw new TransactionRolledBackException("consumer " + ack.getConsumerId() + " no longer active on " + connection);
1:e8818fa:                                 }
1:e8818fa:                                 LOG.trace("beforeEnd ack {}", ack);
1:e8818fa:                                 sendAck(ack);
1:151e251:                             }
1:151e251: 
1:c7d66e9:                             @Override
1:151e251:                             public void afterRollback() throws Exception {
1:2a95348:                                 if (LOG.isTraceEnabled()) {
1:e8818fa:                                     LOG.trace("rollback {}", ack, new Throwable("here"));
1:2a95348:                                 }
1:151e251:                                 // ensure we don't filter this as a duplicate
1:151e251:                                 connection.rollbackDuplicate(ActiveMQSession.this, md.getMessage());
1:e8818fa: 
1:e8818fa:                                 // don't redeliver if we have been interrupted b/c the broker will redeliver on reconnect
1:e8818fa:                                 if (clearRequestsCounter.get() > clearRequestCount) {
1:e8818fa:                                     LOG.debug("No redelivery of {} on rollback of {} due to failover of {}", md, ack.getTransactionId(), connection.getTransport());
1:e8818fa:                                     return;
1:e8818fa:                                 }
1:e8818fa: 
1:e8818fa:                                 // validate our consumer so we don't push stale acks that get ignored or redeliver what will be redispatched
1:e8818fa:                                 if (ack.getTransactionId().isXATransaction() && !connection.hasDispatcher(ack.getConsumerId())) {
1:e8818fa:                                     LOG.debug("No local redelivery of {} on rollback of {} because consumer is no longer active on {}", md, ack.getTransactionId(), connection.getTransport());
1:e8818fa:                                     return;
1:e8818fa:                                 }
1:e8818fa: 
1:151e251:                                 RedeliveryPolicy redeliveryPolicy = connection.getRedeliveryPolicy();
1:151e251:                                 int redeliveryCounter = md.getMessage().getRedeliveryCounter();
1:151e251:                                 if (redeliveryPolicy.getMaximumRedeliveries() != RedeliveryPolicy.NO_MAXIMUM_REDELIVERIES
1:151e251:                                         && redeliveryCounter >= redeliveryPolicy.getMaximumRedeliveries()) {
1:151e251:                                     // We need to NACK the messages so that they get
1:151e251:                                     // sent to the
1:151e251:                                     // DLQ.
1:151e251:                                     // Acknowledge the last message.
1:151e251:                                     MessageAck ack = new MessageAck(md, MessageAck.POSION_ACK_TYPE, 1);
1:151e251:                                     ack.setFirstMessageId(md.getMessage().getMessageId());
1:151e251:                                     ack.setPoisonCause(new Throwable("Exceeded ra redelivery policy limit:" + redeliveryPolicy));
1:151e251:                                     asyncSendPacket(ack);
1:151e251: 
1:151e251:                                 } else {
1:151e251: 
1:151e251:                                     MessageAck ack = new MessageAck(md, MessageAck.REDELIVERED_ACK_TYPE, 1);
1:151e251:                                     ack.setFirstMessageId(md.getMessage().getMessageId());
1:151e251:                                     asyncSendPacket(ack);
1:151e251: 
1:151e251:                                     // Figure out how long we should wait to resend
1:151e251:                                     // this message.
1:151e251:                                     long redeliveryDelay = redeliveryPolicy.getInitialRedeliveryDelay();
1:151e251:                                     for (int i = 0; i < redeliveryCounter; i++) {
1:151e251:                                         redeliveryDelay = redeliveryPolicy.getNextRedeliveryDelay(redeliveryDelay);
1:151e251:                                     }
1:151e251: 
1:151e251:                                     /*
1:151e251:                                     * If we are a non blocking delivery then we need to stop the executor to avoid more
1:151e251:                                     * messages being delivered, once the message is redelivered we can restart it.
1:151e251:                                     * */
1:151e251:                                     if (!connection.isNonBlockingRedelivery()) {
1:151e251:                                         LOG.debug("Blocking session until re-delivery...");
1:151e251:                                         executor.stop();
1:151e251:                                     }
1:151e251: 
1:151e251:                                     connection.getScheduler().executeAfterDelay(new Runnable() {
1:151e251: 
1:151e251:                                         @Override
1:151e251:                                         public void run() {
1:151e251:                                             /*
1:151e251:                                             * wait for the first delivery to be complete, i.e. after delivery has been called.
1:151e251:                                             * */
1:c85c7c1:                                             synchronized (redeliveryGuard) {
1:151e251:                                                 /*
1:151e251:                                                 * If its non blocking then we can just dispatch in a new session.
1:151e251:                                                 * */
1:151e251:                                                 if (connection.isNonBlockingRedelivery()) {
1:151e251:                                                     ((ActiveMQDispatcher) md.getConsumer()).dispatch(md);
1:151e251:                                                 } else {
1:151e251:                                                     /*
1:151e251:                                                     * If there has been an error thrown during afterDelivery then the
1:151e251:                                                     * endpoint will be marked as dead so redelivery will fail (and eventually
1:151e251:                                                     * the session marked as stale), in this case we can only call dispatch
1:151e251:                                                     * which will create a new session with a new endpoint.
1:151e251:                                                     * */
1:151e251:                                                     if (afterDeliveryError.get()) {
1:151e251:                                                         ((ActiveMQDispatcher) md.getConsumer()).dispatch(md);
1:151e251:                                                     } else {
1:151e251:                                                         executor.executeFirst(md);
1:151e251:                                                         executor.start();
1:151e251:                                                     }
1:151e251:                                                 }
1:151e251:                                             }
1:151e251:                                         }
1:151e251:                                     }, redeliveryDelay);
1:151e251:                                 }
1:151e251:                                 md.getMessage().onMessageRolledBack();
1:151e251:                             }
1:151e251:                         });
1:c9a3202:                     }
1:151e251: 
1:e8818fa:                     LOG.trace("{} onMessage({})", this, message.getMessageId());
1:151e251:                     messageListener.onMessage(message);
1:151e251: 
1:151e251:                 } catch (Throwable e) {
1:5ebee0a:                     if (!isClosed()) {
1:5ebee0a:                         LOG.error("{} error dispatching message: {} ", this, message.getMessageId(), e);
1:5ebee0a:                     }
1:151e251: 
1:5ebee0a:                     if (getTransactionContext() != null && getTransactionContext().isInXATransaction()) {
1:85181d6:                         LOG.debug("Marking transaction: {} rollbackOnly", getTransactionContext());
1:85181d6:                         getTransactionContext().setRollbackOnly(true);
1:85181d6:                     }
1:85181d6: 
1:151e251:                     // A problem while invoking the MessageListener does not
1:151e251:                     // in general indicate a problem with the connection to the broker, i.e.
1:151e251:                     // it will usually be sufficient to let the afterDelivery() method either
1:151e251:                     // commit or roll back in order to deal with the exception.
1:151e251:                     // However, we notify any registered client internal exception listener
1:151e251:                     // of the problem.
1:151e251:                     connection.onClientInternalException(e);
1:151e251:                 } finally {
1:151e251:                     if (ack.getTransactionId() == null) {
1:151e251:                         try {
1:151e251:                             asyncSendPacket(ack);
1:151e251:                         } catch (Throwable e) {
1:151e251:                             connection.onClientInternalException(e);
1:151e251:                         }
1:1408e7f:                     }
1:1408e7f:                 }
1:c9a3202: 
1:151e251:                 if (deliveryListener != null) {
1:1408e7f:                     try {
1:151e251:                         deliveryListener.afterDelivery(this, message);
1:151e251:                     } catch (Throwable t) {
1:151e251:                         LOG.debug("Unable to call after delivery", t);
1:151e251:                         afterDeliveryError.set(true);
1:26eb103:                         throw new RuntimeException(t);
1:d29ca2a:                     }
1:d29ca2a:                 }
1:d29ca2a:             }
1:151e251:             /*
1:151e251:             * this can be outside the try/catch as if an exception is thrown then this session will be marked as stale anyway.
1:151e251:             * It also needs to be outside the redelivery guard.
1:151e251:             * */
1:c9a3202:             try {
1:c9a3202:                 executor.waitForQueueRestart();
1:c9a3202:             } catch (InterruptedException ex) {
1:c9a3202:                 connection.onClientInternalException(ex);
1:151e251:             }
1:c9a3202:         }
1:d29ca2a:     }
1:1408e7f: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a <CODE>MessageProducer</CODE> to send messages to the
1:d29ca2a:      * specified destination.
1:d29ca2a:      * <P>
1:d29ca2a:      * A client uses a <CODE>MessageProducer</CODE> object to send messages to
1:d29ca2a:      * a destination. Since <CODE>Queue </CODE> and <CODE>Topic</CODE> both
1:d29ca2a:      * inherit from <CODE>Destination</CODE>, they can be used in the
1:d29ca2a:      * destination parameter to create a <CODE>MessageProducer</CODE> object.
1:d29ca2a:      *
1:230a86c:      * @param destination the <CODE>Destination</CODE> to send to, or null if
1:230a86c:      *                this is a producer which does not have a specified
1:230a86c:      *                destination.
1:d29ca2a:      * @return the MessageProducer
1:230a86c:      * @throws JMSException if the session fails to create a MessageProducer due
1:230a86c:      *                 to some internal error.
1:230a86c:      * @throws InvalidDestinationException if an invalid destination is
1:230a86c:      *                 specified.
1:d29ca2a:      * @since 1.1
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public MessageProducer createProducer(Destination destination) throws JMSException {
1:d29ca2a:         checkClosed();
1:230a86c:         if (destination instanceof CustomDestination) {
1:230a86c:             CustomDestination customDestination = (CustomDestination)destination;
1:677c22b:             return customDestination.createProducer(this);
1:d29ca2a:         }
1:114a923:         int timeSendOut = connection.getSendTimeout();
1:114a923:         return new ActiveMQMessageProducer(this, getNextProducerId(), ActiveMQMessageTransformation.transformDestination(destination),timeSendOut);
1:d29ca2a:     }
1:c256dcf: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a <CODE>MessageConsumer</CODE> for the specified destination.
1:d29ca2a:      * Since <CODE>Queue</CODE> and <CODE> Topic</CODE> both inherit from
1:d29ca2a:      * <CODE>Destination</CODE>, they can be used in the destination
1:d29ca2a:      * parameter to create a <CODE>MessageConsumer</CODE>.
1:d29ca2a:      *
1:230a86c:      * @param destination the <CODE>Destination</CODE> to access.
1:d29ca2a:      * @return the MessageConsumer
1:230a86c:      * @throws JMSException if the session fails to create a consumer due to
1:230a86c:      *                 some internal error.
1:230a86c:      * @throws InvalidDestinationException if an invalid destination is
1:230a86c:      *                 specified.
1:d29ca2a:      * @since 1.1
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public MessageConsumer createConsumer(Destination destination) throws JMSException {
1:fba0742:         return createConsumer(destination, (String) null);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a <CODE>MessageConsumer</CODE> for the specified destination,
1:230a86c:      * using a message selector. Since <CODE> Queue</CODE> and
1:230a86c:      * <CODE>Topic</CODE> both inherit from <CODE>Destination</CODE>, they
1:230a86c:      * can be used in the destination parameter to create a
1:230a86c:      * <CODE>MessageConsumer</CODE>.
1:d29ca2a:      * <P>
1:d29ca2a:      * A client uses a <CODE>MessageConsumer</CODE> object to receive messages
1:d29ca2a:      * that have been sent to a destination.
1:d29ca2a:      *
1:230a86c:      * @param destination the <CODE>Destination</CODE> to access
1:230a86c:      * @param messageSelector only messages with properties matching the message
1:230a86c:      *                selector expression are delivered. A value of null or an
1:230a86c:      *                empty string indicates that there is no message selector
1:230a86c:      *                for the message consumer.
1:d29ca2a:      * @return the MessageConsumer
1:230a86c:      * @throws JMSException if the session fails to create a MessageConsumer due
1:230a86c:      *                 to some internal error.
1:230a86c:      * @throws InvalidDestinationException if an invalid destination is
1:230a86c:      *                 specified.
1:230a86c:      * @throws InvalidSelectorException if the message selector is invalid.
1:d29ca2a:      * @since 1.1
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public MessageConsumer createConsumer(Destination destination, String messageSelector) throws JMSException {
1:fba0742:         return createConsumer(destination, messageSelector, false);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:fba0742:      * Creates a <CODE>MessageConsumer</CODE> for the specified destination.
1:fba0742:      * Since <CODE>Queue</CODE> and <CODE> Topic</CODE> both inherit from
1:fba0742:      * <CODE>Destination</CODE>, they can be used in the destination
1:fba0742:      * parameter to create a <CODE>MessageConsumer</CODE>.
1:d29ca2a:      *
1:fba0742:      * @param destination the <CODE>Destination</CODE> to access.
1:fba0742:      * @param messageListener the listener to use for async consumption of messages
1:fba0742:      * @return the MessageConsumer
1:fba0742:      * @throws JMSException if the session fails to create a consumer due to
1:fba0742:      *                 some internal error.
1:fba0742:      * @throws InvalidDestinationException if an invalid destination is
1:fba0742:      *                 specified.
1:fba0742:      * @since 1.1
1:d29ca2a:      */
1:fba0742:     public MessageConsumer createConsumer(Destination destination, MessageListener messageListener) throws JMSException {
1:fba0742:         return createConsumer(destination, null, messageListener);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:fba0742:      * Creates a <CODE>MessageConsumer</CODE> for the specified destination,
1:fba0742:      * using a message selector. Since <CODE> Queue</CODE> and
1:fba0742:      * <CODE>Topic</CODE> both inherit from <CODE>Destination</CODE>, they
1:fba0742:      * can be used in the destination parameter to create a
1:fba0742:      * <CODE>MessageConsumer</CODE>.
1:fba0742:      * <P>
1:fba0742:      * A client uses a <CODE>MessageConsumer</CODE> object to receive messages
1:fba0742:      * that have been sent to a destination.
1:d29ca2a:      *
1:fba0742:      * @param destination the <CODE>Destination</CODE> to access
1:fba0742:      * @param messageSelector only messages with properties matching the message
1:fba0742:      *                selector expression are delivered. A value of null or an
1:fba0742:      *                empty string indicates that there is no message selector
1:fba0742:      *                for the message consumer.
1:fba0742:      * @param messageListener the listener to use for async consumption of messages
1:fba0742:      * @return the MessageConsumer
1:fba0742:      * @throws JMSException if the session fails to create a MessageConsumer due
1:fba0742:      *                 to some internal error.
1:fba0742:      * @throws InvalidDestinationException if an invalid destination is
1:fba0742:      *                 specified.
1:fba0742:      * @throws InvalidSelectorException if the message selector is invalid.
1:fba0742:      * @since 1.1
1:d29ca2a:      */
1:fba0742:     public MessageConsumer createConsumer(Destination destination, String messageSelector, MessageListener messageListener) throws JMSException {
1:fba0742:         return createConsumer(destination, messageSelector, false, messageListener);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates <CODE>MessageConsumer</CODE> for the specified destination,
1:d29ca2a:      * using a message selector. This method can specify whether messages
1:d29ca2a:      * published by its own connection should be delivered to it, if the
1:d29ca2a:      * destination is a topic.
1:d29ca2a:      * <P>
1:d29ca2a:      * Since <CODE>Queue</CODE> and <CODE>Topic</CODE> both inherit from
1:d29ca2a:      * <CODE>Destination</CODE>, they can be used in the destination
1:d29ca2a:      * parameter to create a <CODE>MessageConsumer</CODE>.
1:d29ca2a:      * <P>
1:d29ca2a:      * A client uses a <CODE>MessageConsumer</CODE> object to receive messages
1:d29ca2a:      * that have been published to a destination.
1:d29ca2a:      * <P>
1:d29ca2a:      * In some cases, a connection may both publish and subscribe to a topic.
1:d29ca2a:      * The consumer <CODE>NoLocal</CODE> attribute allows a consumer to
1:d29ca2a:      * inhibit the delivery of messages published by its own connection. The
1:d29ca2a:      * default value for this attribute is False. The <CODE>noLocal</CODE>
1:d29ca2a:      * value must be supported by destinations that are topics.
1:d29ca2a:      *
1:230a86c:      * @param destination the <CODE>Destination</CODE> to access
1:230a86c:      * @param messageSelector only messages with properties matching the message
1:230a86c:      *                selector expression are delivered. A value of null or an
1:230a86c:      *                empty string indicates that there is no message selector
1:230a86c:      *                for the message consumer.
1:230a86c:      * @param noLocal - if true, and the destination is a topic, inhibits the
1:230a86c:      *                delivery of messages published by its own connection. The
1:230a86c:      *                behavior for <CODE>NoLocal</CODE> is not specified if
1:230a86c:      *                the destination is a queue.
1:d29ca2a:      * @return the MessageConsumer
1:230a86c:      * @throws JMSException if the session fails to create a MessageConsumer due
1:230a86c:      *                 to some internal error.
1:230a86c:      * @throws InvalidDestinationException if an invalid destination is
1:230a86c:      *                 specified.
1:230a86c:      * @throws InvalidSelectorException if the message selector is invalid.
1:d29ca2a:      * @since 1.1
1:d29ca2a:      */
1:a88e19e:     @Override
1:230a86c:     public MessageConsumer createConsumer(Destination destination, String messageSelector, boolean noLocal) throws JMSException {
1:fba0742:         return createConsumer(destination, messageSelector, noLocal, null);
1:d29ca2a:     }
1:d29ca2a: 
1:fba0742:     /**
1:fba0742:      * Creates <CODE>MessageConsumer</CODE> for the specified destination,
1:fba0742:      * using a message selector. This method can specify whether messages
1:fba0742:      * published by its own connection should be delivered to it, if the
1:fba0742:      * destination is a topic.
1:fba0742:      * <P>
1:fba0742:      * Since <CODE>Queue</CODE> and <CODE>Topic</CODE> both inherit from
1:fba0742:      * <CODE>Destination</CODE>, they can be used in the destination
1:fba0742:      * parameter to create a <CODE>MessageConsumer</CODE>.
1:fba0742:      * <P>
1:fba0742:      * A client uses a <CODE>MessageConsumer</CODE> object to receive messages
1:fba0742:      * that have been published to a destination.
1:fba0742:      * <P>
1:fba0742:      * In some cases, a connection may both publish and subscribe to a topic.
1:fba0742:      * The consumer <CODE>NoLocal</CODE> attribute allows a consumer to
1:fba0742:      * inhibit the delivery of messages published by its own connection. The
1:fba0742:      * default value for this attribute is False. The <CODE>noLocal</CODE>
1:fba0742:      * value must be supported by destinations that are topics.
1:d29ca2a:      *
1:fba0742:      * @param destination the <CODE>Destination</CODE> to access
1:fba0742:      * @param messageSelector only messages with properties matching the message
1:fba0742:      *                selector expression are delivered. A value of null or an
1:fba0742:      *                empty string indicates that there is no message selector
1:fba0742:      *                for the message consumer.
1:fba0742:      * @param noLocal - if true, and the destination is a topic, inhibits the
1:fba0742:      *                delivery of messages published by its own connection. The
1:fba0742:      *                behavior for <CODE>NoLocal</CODE> is not specified if
1:fba0742:      *                the destination is a queue.
1:fba0742:      * @param messageListener the listener to use for async consumption of messages
1:fba0742:      * @return the MessageConsumer
1:fba0742:      * @throws JMSException if the session fails to create a MessageConsumer due
1:fba0742:      *                 to some internal error.
1:fba0742:      * @throws InvalidDestinationException if an invalid destination is
1:fba0742:      *                 specified.
1:fba0742:      * @throws InvalidSelectorException if the message selector is invalid.
1:fba0742:      * @since 1.1
1:e500f2e:      */
1:fba0742:     public MessageConsumer createConsumer(Destination destination, String messageSelector, boolean noLocal, MessageListener messageListener) throws JMSException {
1:d29ca2a:         checkClosed();
1:d29ca2a: 
1:230a86c:         if (destination instanceof CustomDestination) {
1:230a86c:             CustomDestination customDestination = (CustomDestination)destination;
1:677c22b:             return customDestination.createConsumer(this, messageSelector, noLocal);
1:d29ca2a:         }
1:d29ca2a: 
1:bed10aa:         ActiveMQPrefetchPolicy prefetchPolicy = connection.getPrefetchPolicy();
1:d29ca2a:         int prefetch = 0;
1:d29ca2a:         if (destination instanceof Topic) {
1:fba0742:             prefetch = prefetchPolicy.getTopicPrefetch();
1:c9a3202:         } else {
1:fba0742:             prefetch = prefetchPolicy.getQueuePrefetch();
1:d29ca2a:         }
1:fba0742:         ActiveMQDestination activemqDestination = ActiveMQMessageTransformation.transformDestination(destination);
1:fba0742:         return new ActiveMQMessageConsumer(this, getNextConsumerId(), activemqDestination, null, messageSelector,
1:62fb85e:                 prefetch, prefetchPolicy.getMaximumPendingMessageLimit(), noLocal, false, isAsyncDispatch(), messageListener);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a queue identity given a <CODE>Queue</CODE> name.
1:d29ca2a:      * <P>
1:d29ca2a:      * This facility is provided for the rare cases where clients need to
1:d29ca2a:      * dynamically manipulate queue identity. It allows the creation of a queue
1:d29ca2a:      * identity with a provider-specific name. Clients that depend on this
1:d29ca2a:      * ability are not portable.
1:d29ca2a:      * <P>
1:d29ca2a:      * Note that this method is not for creating the physical queue. The
1:d29ca2a:      * physical creation of queues is an administrative task and is not to be
1:d29ca2a:      * initiated by the JMS API. The one exception is the creation of temporary
1:d29ca2a:      * queues, which is accomplished with the <CODE>createTemporaryQueue</CODE>
1:d29ca2a:      * method.
1:d29ca2a:      *
1:230a86c:      * @param queueName the name of this <CODE>Queue</CODE>
1:d29ca2a:      * @return a <CODE>Queue</CODE> with the given name
1:230a86c:      * @throws JMSException if the session fails to create a queue due to some
1:230a86c:      *                 internal error.
1:d29ca2a:      * @since 1.1
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public Queue createQueue(String queueName) throws JMSException {
1:d29ca2a:         checkClosed();
1:0eae288:         if (queueName.startsWith(ActiveMQDestination.TEMP_DESTINATION_NAME_PREFIX)) {
1:0eae288:             return new ActiveMQTempQueue(queueName);
1:d29ca2a:         }
1:d29ca2a:         return new ActiveMQQueue(queueName);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a topic identity given a <CODE>Topic</CODE> name.
1:d29ca2a:      * <P>
1:d29ca2a:      * This facility is provided for the rare cases where clients need to
1:d29ca2a:      * dynamically manipulate topic identity. This allows the creation of a
1:d29ca2a:      * topic identity with a provider-specific name. Clients that depend on this
1:d29ca2a:      * ability are not portable.
1:d29ca2a:      * <P>
1:d29ca2a:      * Note that this method is not for creating the physical topic. The
1:d29ca2a:      * physical creation of topics is an administrative task and is not to be
1:d29ca2a:      * initiated by the JMS API. The one exception is the creation of temporary
1:d29ca2a:      * topics, which is accomplished with the <CODE>createTemporaryTopic</CODE>
1:d29ca2a:      * method.
1:d29ca2a:      *
1:230a86c:      * @param topicName the name of this <CODE>Topic</CODE>
1:d29ca2a:      * @return a <CODE>Topic</CODE> with the given name
1:230a86c:      * @throws JMSException if the session fails to create a topic due to some
1:230a86c:      *                 internal error.
1:d29ca2a:      * @since 1.1
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public Topic createTopic(String topicName) throws JMSException {
1:d29ca2a:         checkClosed();
1:0eae288:         if (topicName.startsWith(ActiveMQDestination.TEMP_DESTINATION_NAME_PREFIX)) {
1:0eae288:             return new ActiveMQTempTopic(topicName);
1:d29ca2a:         }
1:d29ca2a:         return new ActiveMQTopic(topicName);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a <CODE>QueueBrowser</CODE> object to peek at the messages on
1:d29ca2a:      * the specified queue.
1:d29ca2a:      *
1:230a86c:      * @param queue the <CODE>queue</CODE> to access
1:230a86c:      * @exception InvalidDestinationException if an invalid destination is
1:230a86c:      *                    specified
1:d29ca2a:      * @since 1.1
1:d29ca2a:      */
1:d29ca2a:     /**
1:d29ca2a:      * Creates a durable subscriber to the specified topic.
1:d29ca2a:      * <P>
1:d29ca2a:      * If a client needs to receive all the messages published on a topic,
1:d29ca2a:      * including the ones published while the subscriber is inactive, it uses a
1:d29ca2a:      * durable <CODE>TopicSubscriber</CODE>. The JMS provider retains a
1:d29ca2a:      * record of this durable subscription and insures that all messages from
1:d29ca2a:      * the topic's publishers are retained until they are acknowledged by this
1:d29ca2a:      * durable subscriber or they have expired.
1:d29ca2a:      * <P>
1:d29ca2a:      * Sessions with durable subscribers must always provide the same client
1:d29ca2a:      * identifier. In addition, each client must specify a name that uniquely
1:d29ca2a:      * identifies (within client identifier) each durable subscription it
1:230a86c:      * creates. Only one session at a time can have a
1:230a86c:      * <CODE>TopicSubscriber</CODE> for a particular durable subscription.
1:d29ca2a:      * <P>
1:d29ca2a:      * A client can change an existing durable subscription by creating a
1:d29ca2a:      * durable <CODE>TopicSubscriber</CODE> with the same name and a new topic
1:d29ca2a:      * and/or message selector. Changing a durable subscriber is equivalent to
1:d29ca2a:      * unsubscribing (deleting) the old one and creating a new one.
1:d29ca2a:      * <P>
1:d29ca2a:      * In some cases, a connection may both publish and subscribe to a topic.
1:d29ca2a:      * The subscriber <CODE>NoLocal</CODE> attribute allows a subscriber to
1:d29ca2a:      * inhibit the delivery of messages published by its own connection. The
1:d29ca2a:      * default value for this attribute is false.
1:d29ca2a:      *
1:230a86c:      * @param topic the non-temporary <CODE>Topic</CODE> to subscribe to
1:230a86c:      * @param name the name used to identify this subscription
1:d29ca2a:      * @return the TopicSubscriber
1:230a86c:      * @throws JMSException if the session fails to create a subscriber due to
1:230a86c:      *                 some internal error.
1:230a86c:      * @throws InvalidDestinationException if an invalid topic is specified.
1:d29ca2a:      * @since 1.1
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public TopicSubscriber createDurableSubscriber(Topic topic, String name) throws JMSException {
1:d29ca2a:         checkClosed();
1:d29ca2a:         return createDurableSubscriber(topic, name, null, false);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a durable subscriber to the specified topic, using a message
1:d29ca2a:      * selector and specifying whether messages published by its own connection
1:d29ca2a:      * should be delivered to it.
1:d29ca2a:      * <P>
1:d29ca2a:      * If a client needs to receive all the messages published on a topic,
1:d29ca2a:      * including the ones published while the subscriber is inactive, it uses a
1:d29ca2a:      * durable <CODE>TopicSubscriber</CODE>. The JMS provider retains a
1:d29ca2a:      * record of this durable subscription and insures that all messages from
1:d29ca2a:      * the topic's publishers are retained until they are acknowledged by this
1:d29ca2a:      * durable subscriber or they have expired.
1:d29ca2a:      * <P>
1:d29ca2a:      * Sessions with durable subscribers must always provide the same client
1:d29ca2a:      * identifier. In addition, each client must specify a name which uniquely
1:d29ca2a:      * identifies (within client identifier) each durable subscription it
1:230a86c:      * creates. Only one session at a time can have a
1:230a86c:      * <CODE>TopicSubscriber</CODE> for a particular durable subscription. An
1:230a86c:      * inactive durable subscriber is one that exists but does not currently
1:230a86c:      * have a message consumer associated with it.
1:d29ca2a:      * <P>
1:d29ca2a:      * A client can change an existing durable subscription by creating a
1:d29ca2a:      * durable <CODE>TopicSubscriber</CODE> with the same name and a new topic
1:d29ca2a:      * and/or message selector. Changing a durable subscriber is equivalent to
1:d29ca2a:      * unsubscribing (deleting) the old one and creating a new one.
1:d29ca2a:      *
1:230a86c:      * @param topic the non-temporary <CODE>Topic</CODE> to subscribe to
1:230a86c:      * @param name the name used to identify this subscription
1:230a86c:      * @param messageSelector only messages with properties matching the message
1:230a86c:      *                selector expression are delivered. A value of null or an
1:230a86c:      *                empty string indicates that there is no message selector
1:230a86c:      *                for the message consumer.
1:230a86c:      * @param noLocal if set, inhibits the delivery of messages published by its
1:230a86c:      *                own connection
1:d29ca2a:      * @return the Queue Browser
1:230a86c:      * @throws JMSException if the session fails to create a subscriber due to
1:230a86c:      *                 some internal error.
1:230a86c:      * @throws InvalidDestinationException if an invalid topic is specified.
1:230a86c:      * @throws InvalidSelectorException if the message selector is invalid.
1:d29ca2a:      * @since 1.1
1:d29ca2a:      */
1:a88e19e:     @Override
1:230a86c:     public TopicSubscriber createDurableSubscriber(Topic topic, String name, String messageSelector, boolean noLocal) throws JMSException {
1:d29ca2a:         checkClosed();
1:d29ca2a: 
1:29ecfd6:         if (topic == null) {
1:aaead5b:             throw new InvalidDestinationException("Topic cannot be null");
1:29ecfd6:         }
1:aaead5b: 
1:230a86c:         if (topic instanceof CustomDestination) {
1:230a86c:             CustomDestination customDestination = (CustomDestination)topic;
1:677c22b:             return customDestination.createDurableSubscriber(this, name, messageSelector, noLocal);
1:aaead5b:         }
1:d29ca2a: 
1:d29ca2a:         connection.checkClientIDWasManuallySpecified();
1:230a86c:         ActiveMQPrefetchPolicy prefetchPolicy = this.connection.getPrefetchPolicy();
1:230a86c:         int prefetch = isAutoAcknowledge() && connection.isOptimizedMessageDispatch() ? prefetchPolicy.getOptimizeDurableTopicPrefetch() : prefetchPolicy.getDurableTopicPrefetch();
1:230a86c:         int maxPrendingLimit = prefetchPolicy.getMaximumPendingMessageLimit();
1:230a86c:         return new ActiveMQTopicSubscriber(this, getNextConsumerId(), ActiveMQMessageTransformation.transformDestination(topic), name, messageSelector, prefetch, maxPrendingLimit,
1:230a86c:                                            noLocal, false, asyncDispatch);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a <CODE>QueueBrowser</CODE> object to peek at the messages on
1:d29ca2a:      * the specified queue.
1:d29ca2a:      *
1:230a86c:      * @param queue the <CODE>queue</CODE> to access
1:d29ca2a:      * @return the Queue Browser
1:230a86c:      * @throws JMSException if the session fails to create a browser due to some
1:230a86c:      *                 internal error.
1:230a86c:      * @throws InvalidDestinationException if an invalid destination is
1:230a86c:      *                 specified
1:d29ca2a:      * @since 1.1
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public QueueBrowser createBrowser(Queue queue) throws JMSException {
1:d29ca2a:         checkClosed();
1:d29ca2a:         return createBrowser(queue, null);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a <CODE>QueueBrowser</CODE> object to peek at the messages on
1:d29ca2a:      * the specified queue using a message selector.
1:d29ca2a:      *
1:230a86c:      * @param queue the <CODE>queue</CODE> to access
1:230a86c:      * @param messageSelector only messages with properties matching the message
1:230a86c:      *                selector expression are delivered. A value of null or an
1:230a86c:      *                empty string indicates that there is no message selector
1:230a86c:      *                for the message consumer.
1:d29ca2a:      * @return the Queue Browser
1:230a86c:      * @throws JMSException if the session fails to create a browser due to some
1:230a86c:      *                 internal error.
1:230a86c:      * @throws InvalidDestinationException if an invalid destination is
1:230a86c:      *                 specified
1:230a86c:      * @throws InvalidSelectorException if the message selector is invalid.
1:d29ca2a:      * @since 1.1
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public QueueBrowser createBrowser(Queue queue, String messageSelector) throws JMSException {
1:d29ca2a:         checkClosed();
1:230a86c:         return new ActiveMQQueueBrowser(this, getNextConsumerId(), ActiveMQMessageTransformation.transformDestination(queue), messageSelector, asyncDispatch);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a <CODE>TemporaryQueue</CODE> object. Its lifetime will be that
1:d29ca2a:      * of the <CODE>Connection</CODE> unless it is deleted earlier.
1:d29ca2a:      *
1:d29ca2a:      * @return a temporary queue identity
1:230a86c:      * @throws JMSException if the session fails to create a temporary queue due
1:230a86c:      *                 to some internal error.
1:d29ca2a:      * @since 1.1
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public TemporaryQueue createTemporaryQueue() throws JMSException {
1:d29ca2a:         checkClosed();
1:230a86c:         return (TemporaryQueue)connection.createTempDestination(false);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a <CODE>TemporaryTopic</CODE> object. Its lifetime will be that
1:d29ca2a:      * of the <CODE>Connection</CODE> unless it is deleted earlier.
1:d29ca2a:      *
1:d29ca2a:      * @return a temporary topic identity
1:230a86c:      * @throws JMSException if the session fails to create a temporary topic due
1:230a86c:      *                 to some internal error.
1:d29ca2a:      * @since 1.1
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public TemporaryTopic createTemporaryTopic() throws JMSException {
1:d29ca2a:         checkClosed();
1:d29ca2a:         return (TemporaryTopic)connection.createTempDestination(true);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a <CODE>QueueReceiver</CODE> object to receive messages from
1:d29ca2a:      * the specified queue.
1:d29ca2a:      *
1:230a86c:      * @param queue the <CODE>Queue</CODE> to access
1:61b2f6b:      * @return a new QueueBrowser instance.
1:230a86c:      * @throws JMSException if the session fails to create a receiver due to
1:230a86c:      *                 some internal error.
1:d29ca2a:      * @throws JMSException
1:230a86c:      * @throws InvalidDestinationException if an invalid queue is specified.
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public QueueReceiver createReceiver(Queue queue) throws JMSException {
1:d29ca2a:         checkClosed();
1:d29ca2a:         return createReceiver(queue, null);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a <CODE>QueueReceiver</CODE> object to receive messages from
1:d29ca2a:      * the specified queue using a message selector.
1:d29ca2a:      *
1:230a86c:      * @param queue the <CODE>Queue</CODE> to access
1:230a86c:      * @param messageSelector only messages with properties matching the message
1:230a86c:      *                selector expression are delivered. A value of null or an
1:230a86c:      *                empty string indicates that there is no message selector
1:230a86c:      *                for the message consumer.
1:d29ca2a:      * @return QueueReceiver
1:230a86c:      * @throws JMSException if the session fails to create a receiver due to
1:230a86c:      *                 some internal error.
1:230a86c:      * @throws InvalidDestinationException if an invalid queue is specified.
1:230a86c:      * @throws InvalidSelectorException if the message selector is invalid.
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public QueueReceiver createReceiver(Queue queue, String messageSelector) throws JMSException {
1:d29ca2a:         checkClosed();
1:d29ca2a: 
1:230a86c:         if (queue instanceof CustomDestination) {
1:230a86c:             CustomDestination customDestination = (CustomDestination)queue;
1:677c22b:             return customDestination.createReceiver(this, messageSelector);
1:d29ca2a:         }
1:d29ca2a: 
1:bed10aa:         ActiveMQPrefetchPolicy prefetchPolicy = this.connection.getPrefetchPolicy();
1:230a86c:         return new ActiveMQQueueReceiver(this, getNextConsumerId(), ActiveMQMessageTransformation.transformDestination(queue), messageSelector, prefetchPolicy.getQueuePrefetch(),
1:230a86c:                                          prefetchPolicy.getMaximumPendingMessageLimit(), asyncDispatch);
1:b080d5f:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a <CODE>QueueSender</CODE> object to send messages to the
1:d29ca2a:      * specified queue.
1:d29ca2a:      *
1:230a86c:      * @param queue the <CODE>Queue</CODE> to access, or null if this is an
1:230a86c:      *                unidentified producer
1:d29ca2a:      * @return QueueSender
1:230a86c:      * @throws JMSException if the session fails to create a sender due to some
1:230a86c:      *                 internal error.
1:230a86c:      * @throws InvalidDestinationException if an invalid queue is specified.
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public QueueSender createSender(Queue queue) throws JMSException {
1:d29ca2a:         checkClosed();
1:230a86c:         if (queue instanceof CustomDestination) {
1:230a86c:             CustomDestination customDestination = (CustomDestination)queue;
1:677c22b:             return customDestination.createSender(this);
1:d29ca2a:         }
1:114a923:         int timeSendOut = connection.getSendTimeout();
1:114a923:         return new ActiveMQQueueSender(this, ActiveMQMessageTransformation.transformDestination(queue),timeSendOut);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a nondurable subscriber to the specified topic. <p/>
1:d29ca2a:      * <P>
1:d29ca2a:      * A client uses a <CODE>TopicSubscriber</CODE> object to receive messages
1:d29ca2a:      * that have been published to a topic. <p/>
1:d29ca2a:      * <P>
1:d29ca2a:      * Regular <CODE>TopicSubscriber</CODE> objects are not durable. They
1:d29ca2a:      * receive only messages that are published while they are active. <p/>
1:d29ca2a:      * <P>
1:d29ca2a:      * In some cases, a connection may both publish and subscribe to a topic.
1:d29ca2a:      * The subscriber <CODE>NoLocal</CODE> attribute allows a subscriber to
1:d29ca2a:      * inhibit the delivery of messages published by its own connection. The
1:d29ca2a:      * default value for this attribute is false.
1:d29ca2a:      *
1:230a86c:      * @param topic the <CODE>Topic</CODE> to subscribe to
1:d29ca2a:      * @return TopicSubscriber
1:230a86c:      * @throws JMSException if the session fails to create a subscriber due to
1:230a86c:      *                 some internal error.
1:230a86c:      * @throws InvalidDestinationException if an invalid topic is specified.
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public TopicSubscriber createSubscriber(Topic topic) throws JMSException {
1:d29ca2a:         checkClosed();
1:d29ca2a:         return createSubscriber(topic, null, false);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a nondurable subscriber to the specified topic, using a message
1:d29ca2a:      * selector or specifying whether messages published by its own connection
1:d29ca2a:      * should be delivered to it. <p/>
1:d29ca2a:      * <P>
1:d29ca2a:      * A client uses a <CODE>TopicSubscriber</CODE> object to receive messages
1:d29ca2a:      * that have been published to a topic. <p/>
1:d29ca2a:      * <P>
1:d29ca2a:      * Regular <CODE>TopicSubscriber</CODE> objects are not durable. They
1:d29ca2a:      * receive only messages that are published while they are active. <p/>
1:d29ca2a:      * <P>
1:d29ca2a:      * Messages filtered out by a subscriber's message selector will never be
1:d29ca2a:      * delivered to the subscriber. From the subscriber's perspective, they do
1:d29ca2a:      * not exist. <p/>
1:d29ca2a:      * <P>
1:d29ca2a:      * In some cases, a connection may both publish and subscribe to a topic.
1:d29ca2a:      * The subscriber <CODE>NoLocal</CODE> attribute allows a subscriber to
1:d29ca2a:      * inhibit the delivery of messages published by its own connection. The
1:d29ca2a:      * default value for this attribute is false.
1:d29ca2a:      *
1:230a86c:      * @param topic the <CODE>Topic</CODE> to subscribe to
1:230a86c:      * @param messageSelector only messages with properties matching the message
1:230a86c:      *                selector expression are delivered. A value of null or an
1:230a86c:      *                empty string indicates that there is no message selector
1:230a86c:      *                for the message consumer.
1:230a86c:      * @param noLocal if set, inhibits the delivery of messages published by its
1:230a86c:      *                own connection
1:d29ca2a:      * @return TopicSubscriber
1:230a86c:      * @throws JMSException if the session fails to create a subscriber due to
1:230a86c:      *                 some internal error.
1:230a86c:      * @throws InvalidDestinationException if an invalid topic is specified.
1:230a86c:      * @throws InvalidSelectorException if the message selector is invalid.
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public TopicSubscriber createSubscriber(Topic topic, String messageSelector, boolean noLocal) throws JMSException {
1:d29ca2a:         checkClosed();
1:d29ca2a: 
1:230a86c:         if (topic instanceof CustomDestination) {
1:230a86c:             CustomDestination customDestination = (CustomDestination)topic;
1:677c22b:             return customDestination.createSubscriber(this, messageSelector, noLocal);
1:d29ca2a:         }
1:d29ca2a: 
1:bed10aa:         ActiveMQPrefetchPolicy prefetchPolicy = this.connection.getPrefetchPolicy();
1:230a86c:         return new ActiveMQTopicSubscriber(this, getNextConsumerId(), ActiveMQMessageTransformation.transformDestination(topic), null, messageSelector, prefetchPolicy
1:230a86c:             .getTopicPrefetch(), prefetchPolicy.getMaximumPendingMessageLimit(), noLocal, false, asyncDispatch);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a publisher for the specified topic. <p/>
1:d29ca2a:      * <P>
1:d29ca2a:      * A client uses a <CODE>TopicPublisher</CODE> object to publish messages
1:d29ca2a:      * on a topic. Each time a client creates a <CODE>TopicPublisher</CODE> on
1:d29ca2a:      * a topic, it defines a new sequence of messages that have no ordering
1:d29ca2a:      * relationship with the messages it has previously sent.
1:d29ca2a:      *
1:230a86c:      * @param topic the <CODE>Topic</CODE> to publish to, or null if this is
1:230a86c:      *                an unidentified producer
1:d29ca2a:      * @return TopicPublisher
1:230a86c:      * @throws JMSException if the session fails to create a publisher due to
1:230a86c:      *                 some internal error.
1:230a86c:      * @throws InvalidDestinationException if an invalid topic is specified.
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public TopicPublisher createPublisher(Topic topic) throws JMSException {
1:d29ca2a:         checkClosed();
1:230a86c: 
1:230a86c:         if (topic instanceof CustomDestination) {
1:230a86c:             CustomDestination customDestination = (CustomDestination)topic;
1:677c22b:             return customDestination.createPublisher(this);
1:d29ca2a:         }
1:114a923:         int timeSendOut = connection.getSendTimeout();
1:114a923:         return new ActiveMQTopicPublisher(this, ActiveMQMessageTransformation.transformDestination(topic),timeSendOut);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Unsubscribes a durable subscription that has been created by a client.
1:d29ca2a:      * <P>
1:d29ca2a:      * This method deletes the state being maintained on behalf of the
1:d29ca2a:      * subscriber by its provider.
1:d29ca2a:      * <P>
1:d29ca2a:      * It is erroneous for a client to delete a durable subscription while there
1:230a86c:      * is an active <CODE>MessageConsumer </CODE> or
1:230a86c:      * <CODE>TopicSubscriber</CODE> for the subscription, or while a consumed
1:230a86c:      * message is part of a pending transaction or has not been acknowledged in
1:230a86c:      * the session.
1:d29ca2a:      *
1:230a86c:      * @param name the name used to identify this subscription
1:230a86c:      * @throws JMSException if the session fails to unsubscribe to the durable
1:230a86c:      *                 subscription due to some internal error.
1:230a86c:      * @throws InvalidDestinationException if an invalid subscription name is
1:230a86c:      *                 specified.
1:d29ca2a:      * @since 1.1
1:d29ca2a:      */
1:a88e19e:     @Override
1:d29ca2a:     public void unsubscribe(String name) throws JMSException {
1:d29ca2a:         checkClosed();
1:d29ca2a:         connection.unsubscribe(name);
1:d29ca2a:     }
1:d29ca2a: 
1:a88e19e:     @Override
1:d29ca2a:     public void dispatch(MessageDispatch messageDispatch) {
1:d29ca2a:         try {
1:d29ca2a:             executor.execute(messageDispatch);
1:d29ca2a:         } catch (InterruptedException e) {
1:b75a6da:             Thread.currentThread().interrupt();
1:1408e7f:             connection.onClientInternalException(e);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Acknowledges all consumed messages of the session of this consumed
1:d29ca2a:      * message.
1:d29ca2a:      * <P>
1:d29ca2a:      * All consumed JMS messages support the <CODE>acknowledge</CODE> method
1:d29ca2a:      * for use when a client has specified that its JMS session's consumed
1:230a86c:      * messages are to be explicitly acknowledged. By invoking
1:230a86c:      * <CODE>acknowledge</CODE> on a consumed message, a client acknowledges
1:230a86c:      * all messages consumed by the session that the message was delivered to.
1:d29ca2a:      * <P>
1:d29ca2a:      * Calls to <CODE>acknowledge</CODE> are ignored for both transacted
1:d29ca2a:      * sessions and sessions specified to use implicit acknowledgement modes.
1:d29ca2a:      * <P>
1:d29ca2a:      * A client may individually acknowledge each message as it is consumed, or
1:d29ca2a:      * it may choose to acknowledge messages as an application-defined group
1:d29ca2a:      * (which is done by calling acknowledge on the last received message of the
1:d29ca2a:      * group, thereby acknowledging all messages consumed by the session.)
1:d29ca2a:      * <P>
1:d29ca2a:      * Messages that have been received but not acknowledged may be redelivered.
1:d29ca2a:      *
1:230a86c:      * @throws JMSException if the JMS provider fails to acknowledge the
1:230a86c:      *                 messages due to some internal error.
1:230a86c:      * @throws javax.jms.IllegalStateException if this method is called on a
1:230a86c:      *                 closed session.
1:d29ca2a:      * @see javax.jms.Session#CLIENT_ACKNOWLEDGE
1:d29ca2a:      */
1:d29ca2a:     public void acknowledge() throws JMSException {
1:ecf89a6:         for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
1:ecf89a6:             ActiveMQMessageConsumer c = iter.next();
1:d29ca2a:             c.acknowledge();
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Add a message consumer.
1:230a86c:      *
1:230a86c:      * @param consumer - message consumer.
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     protected void addConsumer(ActiveMQMessageConsumer consumer) throws JMSException {
1:d29ca2a:         this.consumers.add(consumer);
1:d29ca2a:         if (consumer.isDurableSubscriber()) {
1:d29ca2a:             stats.onCreateDurableSubscriber();
1:d29ca2a:         }
1:d29ca2a:         this.connection.addDispatcher(consumer.getConsumerId(), this);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Remove the message consumer.
1:d29ca2a:      *
1:230a86c:      * @param consumer - consumer to be removed.
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     protected void removeConsumer(ActiveMQMessageConsumer consumer) {
1:d29ca2a:         this.connection.removeDispatcher(consumer.getConsumerId());
1:d29ca2a:         if (consumer.isDurableSubscriber()) {
1:d29ca2a:             stats.onRemoveDurableSubscriber();
1:d29ca2a:         }
1:d29ca2a:         this.consumers.remove(consumer);
1:cbaa58b:         this.connection.removeDispatcher(consumer);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Adds a message producer.
1:d29ca2a:      *
1:230a86c:      * @param producer - message producer to be added.
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     protected void addProducer(ActiveMQMessageProducer producer) throws JMSException {
1:d29ca2a:         this.producers.add(producer);
1:c9bb1c9:         this.connection.addProducer(producer.getProducerInfo().getProducerId(), producer);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Removes a message producer.
1:d29ca2a:      *
1:230a86c:      * @param producer - message producer to be removed.
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     protected void removeProducer(ActiveMQMessageProducer producer) {
1:c9bb1c9:         this.connection.removeProducer(producer.getProducerInfo().getProducerId());
1:d29ca2a:         this.producers.remove(producer);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Start this Session.
1:d29ca2a:      *
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     protected void start() throws JMSException {
1:d29ca2a:         started.set(true);
1:ecf89a6:         for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
1:ecf89a6:             ActiveMQMessageConsumer c = iter.next();
1:d29ca2a:             c.start();
1:d29ca2a:         }
1:c9a3202:         executor.start();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Stops this session.
1:230a86c:      *
1:230a86c:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     protected void stop() throws JMSException {
1:230a86c: 
1:ecf89a6:         for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
1:ecf89a6:             ActiveMQMessageConsumer c = iter.next();
1:d29ca2a:             c.stop();
1:d29ca2a:         }
1:d29ca2a: 
1:d29ca2a:         started.set(false);
1:c9a3202:         executor.stop();
1:d29ca2a:     }
1:d29ca2a: 
2:8cf4795:     /**
1:d29ca2a:      * Returns the session id.
1:d29ca2a:      *
1:c59246d:      * @return value - session id.
1:e500f2e:      */
1:d29ca2a:     protected SessionId getSessionId() {
1:d29ca2a:         return info.getSessionId();
1:d29ca2a:     }
1:d29ca2a: 
1:8cf4795:     /**
1:61b2f6b:      * @return a unique ConsumerId instance.
1:fba0742:      */
1:d29ca2a:     protected ConsumerId getNextConsumerId() {
1:d29ca2a:         return new ConsumerId(info.getSessionId(), consumerIdGenerator.getNextSequenceId());
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:61b2f6b:      * @return a unique ProducerId instance.
1:d29ca2a:      */
1:d29ca2a:     protected ProducerId getNextProducerId() {
1:d29ca2a:         return new ProducerId(info.getSessionId(), producerIdGenerator.getNextSequenceId());
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Sends the message for dispatch by the broker.
1:d4cd7f9:      *
1:230a86c:      * @param producer - message producer.
1:230a86c:      * @param destination - message destination.
1:230a86c:      * @param message - message to be sent.
1:61b2f6b:      * @param deliveryMode - JMS message delivery mode.
1:230a86c:      * @param priority - message priority.
1:230a86c:      * @param timeToLive - message expiration.
1:230a86c:      * @param producerWindow
1:d4cd7f9:      * @param onComplete
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:230a86c:     protected void send(ActiveMQMessageProducer producer, ActiveMQDestination destination, Message message, int deliveryMode, int priority, long timeToLive,
1:d4cd7f9:                         MemoryUsage producerWindow, int sendTimeout, AsyncCallback onComplete) throws JMSException {
1:230a86c: 
1:230a86c:         checkClosed();
1:230a86c:         if (destination.isTemporary() && connection.isDeleted(destination)) {
1:50bc597:             throw new InvalidDestinationException("Cannot publish to a deleted Destination: " + destination);
1:230a86c:         }
1:230a86c:         synchronized (sendMutex) {
1:230a86c:             // tell the Broker we are about to start a new transaction
1:230a86c:             doStartTransaction();
1:230a86c:             TransactionId txid = transactionContext.getTransactionId();
1:230a86c:             long sequenceNumber = producer.getMessageSequence();
1:d29ca2a: 
1:715bf26:             //Set the "JMS" header fields on the original message, see 1.1 spec section 3.4.11
1:d29ca2a:             message.setJMSDeliveryMode(deliveryMode);
1:230a86c:             long expiration = 0L;
1:230a86c:             if (!producer.getDisableMessageTimestamp()) {
1:230a86c:                 long timeStamp = System.currentTimeMillis();
1:d29ca2a:                 message.setJMSTimestamp(timeStamp);
1:230a86c:                 if (timeToLive > 0) {
1:230a86c:                     expiration = timeToLive + timeStamp;
1:230a86c:                 }
1:d29ca2a:             }
1:d29ca2a:             message.setJMSExpiration(expiration);
1:d29ca2a:             message.setJMSPriority(priority);
1:d29ca2a:             message.setJMSRedelivered(false);
1:d29ca2a: 
1:d29ca2a:             // transform to our own message format here
1:230a86c:             ActiveMQMessage msg = ActiveMQMessageTransformation.transformMessage(message, connection);
1:ba2d0c6:             msg.setDestination(destination);
1:ba2d0c6:             msg.setMessageId(new MessageId(producer.getProducerInfo().getProducerId(), sequenceNumber));
1:d29ca2a: 
1:d29ca2a:             // Set the message id.
1:ba2d0c6:             if (msg != message) {
1:ba2d0c6:                 message.setJMSMessageID(msg.getMessageId().toString());
1:044e6bf:                 // Make sure the JMS destination is set on the foreign messages too.
1:044e6bf:                 message.setJMSDestination(destination);
1:230a86c:             }
1:8b33c1c:             //clear the brokerPath in case we are re-sending this message
1:8b33c1c:             msg.setBrokerPath(null);
1:d29ca2a: 
1:d29ca2a:             msg.setTransactionId(txid);
1:230a86c:             if (connection.isCopyMessageOnSend()) {
1:230a86c:                 msg = (ActiveMQMessage)msg.copy();
1:230a86c:             }
1:230a86c:             msg.setConnection(connection);
1:230a86c:             msg.onSend();
1:230a86c:             msg.setProducerId(msg.getMessageId().getProducerId());
1:e45bb06:             if (LOG.isTraceEnabled()) {
1:e45bb06:                 LOG.trace(getSessionId() + " sending message: " + msg);
1:230a86c:             }
1:d4cd7f9:             if (onComplete==null && sendTimeout <= 0 && !msg.isResponseRequired() && !connection.isAlwaysSyncSend() && (!msg.isPersistent() || connection.isUseAsyncSend() || txid != null)) {
1:d29ca2a:                 this.connection.asyncSendPacket(msg);
1:230a86c:                 if (producerWindow != null) {
1:230a86c:                     // Since we defer lots of the marshaling till we hit the
1:230a86c:                     // wire, this might not
1:230a86c:                     // provide and accurate size. We may change over to doing
1:230a86c:                     // more aggressive marshaling,
1:230a86c:                     // to get more accurate sizes.. this is more important once
1:230a86c:                     // users start using producer window
1:230a86c:                     // flow control.
1:230a86c:                     int size = msg.getSize();
1:230a86c:                     producerWindow.increaseUsage(size);
1:230a86c:                 }
1:230a86c:             } else {
1:d4cd7f9:                 if (sendTimeout > 0 && onComplete==null) {
1:114a923:                     this.connection.syncSendPacket(msg,sendTimeout);
1:114a923:                 }else {
1:d4cd7f9:                     this.connection.syncSendPacket(msg, onComplete);
1:230a86c:                 }
1:230a86c:             }
1:d29ca2a: 
1:4207bd9:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * Send TransactionInfo to indicate transaction has started
1:230a86c:      *
1:230a86c:      * @throws JMSException if some internal error occurs
1:230a86c:      */
1:230a86c:     protected void doStartTransaction() throws JMSException {
1:230a86c:         if (getTransacted() && !transactionContext.isInXATransaction()) {
1:230a86c:             transactionContext.begin();
1:230a86c:         }
1:230a86c:     }
1:230a86c: 
1:230a86c:     /**
1:230a86c:      * Checks whether the session has unconsumed messages.
1:230a86c:      *
1:230a86c:      * @return true - if there are unconsumed messages.
1:230a86c:      */
1:d29ca2a:     public boolean hasUncomsumedMessages() {
1:b6673c4:         return executor.hasUncomsumedMessages();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * Checks whether the session uses transactions.
1:230a86c:      *
1:230a86c:      * @return true - if the session uses transactions.
1:230a86c:      */
1:d29ca2a:     public boolean isTransacted() {
1:62daac4:         return this.acknowledgementMode == Session.SESSION_TRANSACTED || (transactionContext.isInXATransaction());
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Checks whether the session used client acknowledgment.
1:d29ca2a:      *
1:d29ca2a:      * @return true - if the session uses client acknowledgment.
1:d29ca2a:      */
1:d29ca2a:     protected boolean isClientAcknowledge() {
1:d29ca2a:         return this.acknowledgementMode == Session.CLIENT_ACKNOWLEDGE;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     /**
1:d29ca2a:      * Checks whether the session used auto acknowledgment.
1:d29ca2a:      *
1:d29ca2a:      * @return true - if the session uses client acknowledgment.
1:d29ca2a:      */
1:d29ca2a:     public boolean isAutoAcknowledge() {
1:230a86c:         return acknowledgementMode == Session.AUTO_ACKNOWLEDGE;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     /**
1:d29ca2a:      * Checks whether the session used dup ok acknowledgment.
1:d29ca2a:      *
1:d29ca2a:      * @return true - if the session uses client acknowledgment.
1:d29ca2a:      */
1:d29ca2a:     public boolean isDupsOkAcknowledge() {
1:230a86c:         return acknowledgementMode == Session.DUPS_OK_ACKNOWLEDGE;
1:d29ca2a:     }
1:d29ca2a: 
1:2076f45:     public boolean isIndividualAcknowledge(){
1:251dc7b:         return acknowledgementMode == ActiveMQSession.INDIVIDUAL_ACKNOWLEDGE;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Returns the message delivery listener.
1:d29ca2a:      *
1:d29ca2a:      * @return deliveryListener - message delivery listener.
1:d29ca2a:      */
1:d29ca2a:     public DeliveryListener getDeliveryListener() {
1:d29ca2a:         return deliveryListener;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets the message delivery listener.
1:d29ca2a:      *
1:230a86c:      * @param deliveryListener - message delivery listener.
1:d29ca2a:      */
1:d29ca2a:     public void setDeliveryListener(DeliveryListener deliveryListener) {
1:d29ca2a:         this.deliveryListener = deliveryListener;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Returns the SessionInfo bean.
1:d29ca2a:      *
1:d29ca2a:      * @return info - SessionInfo bean.
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     protected SessionInfo getSessionInfo() throws JMSException {
1:c59246d:         SessionInfo info = new SessionInfo(connection.getConnectionInfo(), getSessionId().getValue());
1:d29ca2a:         return info;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:61b2f6b:      * Send the asynchronous command.
1:d29ca2a:      *
1:230a86c:      * @param command - command to be executed.
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     public void asyncSendPacket(Command command) throws JMSException {
1:d29ca2a:         connection.asyncSendPacket(command);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:61b2f6b:      * Send the synchronous command.
1:d29ca2a:      *
1:230a86c:      * @param command - command to be executed.
1:d29ca2a:      * @return Response
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     public Response syncSendPacket(Command command) throws JMSException {
1:d29ca2a:         return connection.syncSendPacket(command);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public long getNextDeliveryId() {
1:d29ca2a:         return deliveryIdGenerator.getNextSequenceId();
1:d29ca2a:     }
1:d29ca2a: 
1:230a86c:     public void redispatch(ActiveMQDispatcher dispatcher, MessageDispatchChannel unconsumedMessages) throws JMSException {
1:230a86c: 
1:230a86c:         List<MessageDispatch> c = unconsumedMessages.removeAll();
1:230a86c:         for (MessageDispatch md : c) {
1:230a86c:             this.connection.rollbackDuplicate(dispatcher, md.getMessage());
1:d29ca2a:         }
1:d29ca2a:         Collections.reverse(c);
1:230a86c: 
1:ecf89a6:         for (Iterator<MessageDispatch> iter = c.iterator(); iter.hasNext();) {
1:ecf89a6:             MessageDispatch md = iter.next();
1:c9a3202:             executor.executeFirst(md);
1:d29ca2a:         }
1:230a86c: 
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public boolean isRunning() {
1:d29ca2a:         return started.get();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public boolean isAsyncDispatch() {
1:d29ca2a:         return asyncDispatch;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public void setAsyncDispatch(boolean asyncDispatch) {
1:d29ca2a:         this.asyncDispatch = asyncDispatch;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     /**
1:d964145:      * @return Returns the sessionAsyncDispatch.
1:d29ca2a:      */
1:230a86c:     public boolean isSessionAsyncDispatch() {
1:d964145:         return sessionAsyncDispatch;
1:d29ca2a:     }
1:d29ca2a: 
1:e500f2e:     /**
1:d964145:      * @param sessionAsyncDispatch The sessionAsyncDispatch to set.
1:d29ca2a:      */
1:230a86c:     public void setSessionAsyncDispatch(boolean sessionAsyncDispatch) {
1:230a86c:         this.sessionAsyncDispatch = sessionAsyncDispatch;
1:d29ca2a:     }
1:d29ca2a: 
1:86faaef:     public MessageTransformer getTransformer() {
1:86faaef:         return transformer;
1:0a66b79:     }
1:d29ca2a: 
1:677c22b:     public ActiveMQConnection getConnection() {
1:677c22b:         return connection;
1:be37064:     }
1:d29ca2a: 
1:d964145:     /**
1:230a86c:      * Sets the transformer used to transform messages before they are sent on
1:230a86c:      * to the JMS bus or when they are received from the bus but before they are
1:230a86c:      * delivered to the JMS client
1:d29ca2a:      */
1:86faaef:     public void setTransformer(MessageTransformer transformer) {
1:86faaef:         this.transformer = transformer;
1:2076f45:     }
1:d29ca2a: 
1:05a8cba:     public BlobTransferPolicy getBlobTransferPolicy() {
1:05a8cba:         return blobTransferPolicy;
1:114a923:     }
1:d29ca2a: 
1:fba0742:     /**
1:230a86c:      * Sets the policy used to describe how out-of-band BLOBs (Binary Large
1:230a86c:      * OBjects) are transferred from producers to brokers to consumers
1:e500f2e:      */
1:05a8cba:     public void setBlobTransferPolicy(BlobTransferPolicy blobTransferPolicy) {
1:05a8cba:         this.blobTransferPolicy = blobTransferPolicy;
1:4e2acd4:     }
1:d29ca2a: 
1:0a66b79:     public List<MessageDispatch> getUnconsumedMessages() {
1:230a86c:         return executor.getUnconsumedMessages();
1:230a86c:     }
1:d29ca2a: 
1:1408e7f:     @Override
1:d29ca2a:     public String toString() {
1:5ebee0a:         return "ActiveMQSession {id=" + info.getSessionId() + ",started=" + started.get() + ",closed=" + closed + "} " + sendMutex;
1:d29ca2a:     }
1:d29ca2a: 
1:d86f77f:     public void checkMessageListener() throws JMSException {
1:d86f77f:         if (messageListener != null) {
1:d86f77f:             throw new IllegalStateException("Cannot synchronously receive a message when a MessageListener is set");
1:d86f77f:         }
1:ecf89a6:         for (Iterator<ActiveMQMessageConsumer> i = consumers.iterator(); i.hasNext();) {
1:ecf89a6:             ActiveMQMessageConsumer consumer = i.next();
1:dc0291b:             if (consumer.hasMessageListener()) {
1:d86f77f:                 throw new IllegalStateException("Cannot synchronously receive a message when a MessageListener is set");
1:d86f77f:             }
1:d86f77f:         }
1:d86f77f:     }
1:230a86c: 
1:230a86c:     protected void setOptimizeAcknowledge(boolean value) {
1:ecf89a6:         for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
1:ecf89a6:             ActiveMQMessageConsumer c = iter.next();
1:ef0734b:             c.setOptimizeAcknowledge(value);
1:d29ca2a:         }
1:e500f2e:     }
1:230a86c: 
1:230a86c:     protected void setPrefetchSize(ConsumerId id, int prefetch) {
1:ecf89a6:         for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
1:ecf89a6:             ActiveMQMessageConsumer c = iter.next();
1:230a86c:             if (c.getConsumerId().equals(id)) {
1:ef0734b:                 c.setPrefetchSize(prefetch);
1:ef0734b:                 break;
1:e500f2e:             }
1:e500f2e:         }
1:e500f2e:     }
1:230a86c: 
1:230a86c:     protected void close(ConsumerId id) {
1:ecf89a6:         for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
1:ecf89a6:             ActiveMQMessageConsumer c = iter.next();
1:230a86c:             if (c.getConsumerId().equals(id)) {
1:230a86c:                 try {
1:ef0734b:                     c.close();
1:230a86c:                 } catch (JMSException e) {
1:fc00993:                     LOG.warn("Exception closing consumer", e);
1:e500f2e:                 }
1:a95c6db:                 LOG.warn("Closed consumer on Command, " + id);
1:ef0734b:                 break;
1:ef0734b:             }
1:ef0734b:         }
1:ef0734b:     }
1:d29ca2a: 
1:230a86c:     public boolean isInUse(ActiveMQTempDestination destination) {
1:ecf89a6:         for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
1:ecf89a6:             ActiveMQMessageConsumer c = iter.next();
1:230a86c:             if (c.isInUse(destination)) {
1:230a86c:                 return true;
1:ef0734b:             }
1:ef0734b:         }
1:bd7d59c:         return false;
1:230a86c:     }
1:d29ca2a: 
1:3b08860:     /**
1:3b08860:      * highest sequence id of the last message delivered by this session.
1:3b08860:      * Passed to the broker in the close command, maintained by dispose()
1:3b08860:      * @return lastDeliveredSequenceId
1:3b08860:      */
1:3b08860:     public long getLastDeliveredSequenceId() {
1:3b08860:         return lastDeliveredSequenceId;
1:3b08860:     }
1:3b08860: 
1:d8b5d5c:     protected void sendAck(MessageAck ack) throws JMSException {
1:d8b5d5c:         sendAck(ack,false);
1:d8b5d5c:     }
1:d29ca2a: 
1:d8b5d5c:     protected void sendAck(MessageAck ack, boolean lazy) throws JMSException {
1:4046599:         if (lazy || connection.isSendAcksAsync() || getTransacted()) {
1:1408e7f:             asyncSendPacket(ack);
1:230a86c:         } else {
1:d8b5d5c:             syncSendPacket(ack);
1:1a5ad28:         }
1:d8b5d5c:     }
1:d29ca2a: 
1:97ae323:     protected Scheduler getScheduler() throws JMSException {
1:97ae323:         return this.connection.getScheduler();
1:d8b5d5c:     }
1:d29ca2a: 
1:1a5ad28:     protected ThreadPoolExecutor getConnectionExecutor() {
1:1a5ad28:         return this.connectionExecutor;
1:1a5ad28:     }
1:ef0734b: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:5ebee0a
/////////////////////////////////////////////////////////////////////////
1:                     if (!isClosed()) {
1:                         LOG.error("{} error dispatching message: {} ", this, message.getMessageId(), e);
1:                     }
1:                     if (getTransactionContext() != null && getTransactionContext().isInXATransaction()) {
/////////////////////////////////////////////////////////////////////////
1:         return "ActiveMQSession {id=" + info.getSessionId() + ",started=" + started.get() + ",closed=" + closed + "} " + sendMutex;
commit:85181d6
/////////////////////////////////////////////////////////////////////////
1:                     if (getTransactionContext().isInXATransaction()) {
1:                         LOG.debug("Marking transaction: {} rollbackOnly", getTransactionContext());
1:                         getTransactionContext().setRollbackOnly(true);
1:                     }
1: 
commit:6a0c658
/////////////////////////////////////////////////////////////////////////
commit:29ecfd6
/////////////////////////////////////////////////////////////////////////
1:         if (topic == null) {
0:             throw new InvalidDestinationException("topic is null");
1:         }
commit:0a12bcb
/////////////////////////////////////////////////////////////////////////
commit:c85c7c1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected final Object sendMutex = new Object();
1:     protected final Object redeliveryGuard = new Object();
1: 
/////////////////////////////////////////////////////////////////////////
1:             synchronized (redeliveryGuard) {
/////////////////////////////////////////////////////////////////////////
1:                                             synchronized (redeliveryGuard) {
commit:eb6c082
/////////////////////////////////////////////////////////////////////////
1:     private long lastDeliveredSequenceId = -2;
/////////////////////////////////////////////////////////////////////////
1:             final ActiveMQMessage message = (ActiveMQMessage)md.getMessage();
/////////////////////////////////////////////////////////////////////////
1:             lastDeliveredSequenceId = message.getMessageId().getBrokerSequenceId();
commit:b136df1
/////////////////////////////////////////////////////////////////////////
1:                 earlyAck = new MessageAck(md, MessageAck.EXPIRED_ACK_TYPE, 1);
commit:e8818fa
/////////////////////////////////////////////////////////////////////////
1:     final AtomicInteger clearRequestsCounter = new AtomicInteger(0);
1:         clearRequestsCounter.incrementAndGet();
/////////////////////////////////////////////////////////////////////////
1: 
1:             MessageAck earlyAck = null;
1:             if (message.isExpired()) {
0:                 earlyAck = new MessageAck(md, MessageAck.DELIVERED_ACK_TYPE, 1);
1:             } else if (connection.isDuplicate(ActiveMQSession.this, message)) {
1:                 LOG.debug("{} got duplicate: {}", this, message.getMessageId());
1:                 earlyAck = new MessageAck(md, MessageAck.POSION_ACK_TYPE, 1);
1:                 earlyAck.setFirstMessageId(md.getMessage().getMessageId());
1:                 earlyAck.setPoisonCause(new Throwable("Duplicate delivery to " + this));
1:             }
1:             if (earlyAck != null) {
1:                 try {
1:                     asyncSendPacket(earlyAck);
1:                 } catch (Throwable t) {
1:                     LOG.error("error dispatching ack: {} ", earlyAck, t);
1:                     connection.onClientInternalException(t);
1:                 } finally {
1:                     continue;
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                         final int clearRequestCount = (clearRequestsCounter.get() == Integer.MAX_VALUE ? clearRequestsCounter.incrementAndGet() : clearRequestsCounter.get());
1:                             // validate our consumer so we don't push stale acks that get ignored
1:                             if (ack.getTransactionId().isXATransaction() && !connection.hasDispatcher(ack.getConsumerId())) {
1:                                 LOG.debug("forcing rollback - {} consumer no longer active on {}", ack, connection);
1:                                 throw new TransactionRolledBackException("consumer " + ack.getConsumerId() + " no longer active on " + connection);
1:                             }
1:                             LOG.trace("beforeEnd ack {}", ack);
1:                             sendAck(ack);
1:                             LOG.trace("rollback {}", ack, new Throwable("here"));
1: 
1:                             // don't redeliver if we have been interrupted b/c the broker will redeliver on reconnect
1:                             if (clearRequestsCounter.get() > clearRequestCount) {
1:                                 LOG.debug("No redelivery of {} on rollback of {} due to failover of {}", md, ack.getTransactionId(), connection.getTransport());
1:                                 return;
1:                             }
1: 
1:                             // validate our consumer so we don't push stale acks that get ignored or redeliver what will be redispatched
1:                             if (ack.getTransactionId().isXATransaction() && !connection.hasDispatcher(ack.getConsumerId())) {
1:                                 LOG.debug("No local redelivery of {} on rollback of {} because consumer is no longer active on {}", md, ack.getTransactionId(), connection.getTransport());
1:                                 return;
1:                             }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 LOG.trace("{} onMessage({})", this, message.getMessageId());
commit:dc0291b
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicInteger;
/////////////////////////////////////////////////////////////////////////
1:     void clearMessagesInProgress(AtomicInteger transportInterruptionProcessingComplete) {
/////////////////////////////////////////////////////////////////////////
1:             transportInterruptionProcessingComplete.incrementAndGet();
/////////////////////////////////////////////////////////////////////////
1:             if (consumer.hasMessageListener()) {
author:saivr1t
-------------------------------------------------------------------------------
commit:2a95348
/////////////////////////////////////////////////////////////////////////
1:                                 if (LOG.isTraceEnabled()) {
0:                                     LOG.trace("rollback {}", ack, new Throwable("here"));
1:                                 }
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Timothy Bish
-------------------------------------------------------------------------------
commit:61b2f6b
/////////////////////////////////////////////////////////////////////////
1:      * @return a new QueueBrowser instance.
/////////////////////////////////////////////////////////////////////////
1:      * @return a unique ConsumerId instance.
1:      * @return a unique ProducerId instance.
/////////////////////////////////////////////////////////////////////////
1:      * @param deliveryMode - JMS message delivery mode.
/////////////////////////////////////////////////////////////////////////
1:      * Send the asynchronous command.
/////////////////////////////////////////////////////////////////////////
1:      * Send the synchronous command.
commit:a88e19e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:                         @Override
/////////////////////////////////////////////////////////////////////////
1:                                     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
commit:c7d66e9
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicBoolean clearInProgress = new AtomicBoolean();
/////////////////////////////////////////////////////////////////////////
1:         // we are called from inside the transport reconnection logic which involves us
1:         // clearing all the connections' consumers dispatch and delivered lists. So rather
1:         // than trying to grab a mutex (which could be already owned by the message listener
1:         // calling the send or an ack) we allow it to complete in a separate thread via the
1:         // scheduler and notify us via connection.transportInterruptionProcessingComplete()
1:         // We must be careful though not to allow multiple calls to this method from a
1:         // connection that is having issue becoming fully established from causing a large
1:         // build up of scheduled tasks to clear the same consumers over and over.
1:         if (consumers.isEmpty()) {
1:             return;
1:         }
1: 
1:         if (clearInProgress.compareAndSet(false, true)) {
1:             for (final ActiveMQMessageConsumer consumer : consumers) {
1:                 consumer.inProgressClearRequired();
0:                 transportInterruptionProcessingComplete.incrementAndGet();
1:                 try {
1:                     connection.getScheduler().executeAfterDelay(new Runnable() {
1:                         @Override
1:                         public void run() {
1:                             consumer.clearMessagesInProgress();
1:                         }}, 0l);
1:                 } catch (JMSException e) {
1:                     connection.onClientInternalException(e);
1:                 }
1:             }
1: 
1:                     @Override
1:                         clearInProgress.set(false);
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:f10aab6
/////////////////////////////////////////////////////////////////////////
1:                 earlyAck.setFirstMessageId(message.getMessageId());
commit:12b26b6
/////////////////////////////////////////////////////////////////////////
1:      * depending on the {@link #getBlobTransferPolicy()}. <br/>
1:      * <p>
1:      * The caller of this method is responsible for closing the
1:      * input stream that is used, however the stream can not be closed
1:      * until <b>after</b> the message has been sent.  To have this class
1:      * manage the stream and close it automatically, use the method
1:      * {@link ActiveMQSession#createBlobMessage(File)}
author:Andy Taylor
-------------------------------------------------------------------------------
commit:26eb103
/////////////////////////////////////////////////////////////////////////
1:                         throw new RuntimeException(t);
commit:151e251
/////////////////////////////////////////////////////////////////////////
0:     private static final Object REDELIVERY_GUARD = new Object();
/////////////////////////////////////////////////////////////////////////
1:             final AtomicBoolean afterDeliveryError = new AtomicBoolean(false);
1:             /*
1:             * The redelivery guard is to allow the endpoint lifecycle to complete before the messsage is dispatched.
1:             * We dont want the after deliver being called after the redeliver as it may cause some weird stuff.
1:             * */
0:             synchronized (REDELIVERY_GUARD) {
1:                 try {
1:                     ack.setFirstMessageId(md.getMessage().getMessageId());
1:                     doStartTransaction();
1:                     ack.setTransactionId(getTransactionContext().getTransactionId());
1:                     if (ack.getTransactionId() != null) {
1:                         getTransactionContext().addSynchronization(new Synchronization() {
0:                             final int clearRequestCount = (clearRequestsCounter.get() == Integer.MAX_VALUE ? clearRequestsCounter.incrementAndGet() : clearRequestsCounter.get());
1:                             @Override
1:                             public void beforeEnd() throws Exception {
0:                                 // validate our consumer so we don't push stale acks that get ignored
0:                                 if (ack.getTransactionId().isXATransaction() && !connection.hasDispatcher(ack.getConsumerId())) {
0:                                     LOG.debug("forcing rollback - {} consumer no longer active on {}", ack, connection);
0:                                     throw new TransactionRolledBackException("consumer " + ack.getConsumerId() + " no longer active on " + connection);
0:                                 LOG.trace("beforeEnd ack {}", ack);
0:                                 sendAck(ack);
1:                             }
1:                             @Override
1:                             public void afterRollback() throws Exception {
0:                                 LOG.trace("rollback {}", ack, new Throwable("here"));
1:                                 // ensure we don't filter this as a duplicate
1:                                 connection.rollbackDuplicate(ActiveMQSession.this, md.getMessage());
1: 
0:                                 // don't redeliver if we have been interrupted b/c the broker will redeliver on reconnect
0:                                 if (clearRequestsCounter.get() > clearRequestCount) {
0:                                     LOG.debug("No redelivery of {} on rollback of {} due to failover of {}", md, ack.getTransactionId(), connection.getTransport());
0:                                     return;
1:                                 }
1: 
0:                                 // validate our consumer so we don't push stale acks that get ignored or redeliver what will be redispatched
0:                                 if (ack.getTransactionId().isXATransaction() && !connection.hasDispatcher(ack.getConsumerId())) {
0:                                     LOG.debug("No local redelivery of {} on rollback of {} because consumer is no longer active on {}", md, ack.getTransactionId(), connection.getTransport());
0:                                     return;
1:                                 }
1: 
1:                                 RedeliveryPolicy redeliveryPolicy = connection.getRedeliveryPolicy();
1:                                 int redeliveryCounter = md.getMessage().getRedeliveryCounter();
1:                                 if (redeliveryPolicy.getMaximumRedeliveries() != RedeliveryPolicy.NO_MAXIMUM_REDELIVERIES
1:                                         && redeliveryCounter >= redeliveryPolicy.getMaximumRedeliveries()) {
1:                                     // We need to NACK the messages so that they get
1:                                     // sent to the
1:                                     // DLQ.
1:                                     // Acknowledge the last message.
1:                                     MessageAck ack = new MessageAck(md, MessageAck.POSION_ACK_TYPE, 1);
1:                                     ack.setFirstMessageId(md.getMessage().getMessageId());
1:                                     ack.setPoisonCause(new Throwable("Exceeded ra redelivery policy limit:" + redeliveryPolicy));
1:                                     asyncSendPacket(ack);
1: 
1:                                 } else {
1: 
1:                                     MessageAck ack = new MessageAck(md, MessageAck.REDELIVERED_ACK_TYPE, 1);
1:                                     ack.setFirstMessageId(md.getMessage().getMessageId());
1:                                     asyncSendPacket(ack);
1: 
1:                                     // Figure out how long we should wait to resend
1:                                     // this message.
1:                                     long redeliveryDelay = redeliveryPolicy.getInitialRedeliveryDelay();
1:                                     for (int i = 0; i < redeliveryCounter; i++) {
1:                                         redeliveryDelay = redeliveryPolicy.getNextRedeliveryDelay(redeliveryDelay);
1: 
1:                                     /*
1:                                     * If we are a non blocking delivery then we need to stop the executor to avoid more
1:                                     * messages being delivered, once the message is redelivered we can restart it.
1:                                     * */
1:                                     if (!connection.isNonBlockingRedelivery()) {
1:                                         LOG.debug("Blocking session until re-delivery...");
1:                                         executor.stop();
1:                                     }
1: 
1:                                     connection.getScheduler().executeAfterDelay(new Runnable() {
1: 
1:                                         @Override
1:                                         public void run() {
1:                                             /*
1:                                             * wait for the first delivery to be complete, i.e. after delivery has been called.
1:                                             * */
0:                                             synchronized (REDELIVERY_GUARD) {
1:                                                 /*
1:                                                 * If its non blocking then we can just dispatch in a new session.
1:                                                 * */
1:                                                 if (connection.isNonBlockingRedelivery()) {
1:                                                     ((ActiveMQDispatcher) md.getConsumer()).dispatch(md);
1:                                                 } else {
1:                                                     /*
1:                                                     * If there has been an error thrown during afterDelivery then the
1:                                                     * endpoint will be marked as dead so redelivery will fail (and eventually
1:                                                     * the session marked as stale), in this case we can only call dispatch
1:                                                     * which will create a new session with a new endpoint.
1:                                                     * */
1:                                                     if (afterDeliveryError.get()) {
1:                                                         ((ActiveMQDispatcher) md.getConsumer()).dispatch(md);
1:                                                     } else {
1:                                                         executor.executeFirst(md);
1:                                                         executor.start();
1:                                                     }
1:                                                 }
1:                                             }
1:                                         }
1:                                     }, redeliveryDelay);
1:                                 }
1:                                 md.getMessage().onMessageRolledBack();
1:                         });
1:                     }
1: 
0:                     LOG.trace("{} onMessage({})", this, message.getMessageId());
1:                     messageListener.onMessage(message);
1: 
1:                 } catch (Throwable e) {
0:                     LOG.error("error dispatching message: ", e);
1: 
1:                     // A problem while invoking the MessageListener does not
1:                     // in general indicate a problem with the connection to the broker, i.e.
1:                     // it will usually be sufficient to let the afterDelivery() method either
1:                     // commit or roll back in order to deal with the exception.
1:                     // However, we notify any registered client internal exception listener
1:                     // of the problem.
1:                     connection.onClientInternalException(e);
1:                 } finally {
1:                     if (ack.getTransactionId() == null) {
1:                         try {
1:                             asyncSendPacket(ack);
1:                         } catch (Throwable e) {
1:                             connection.onClientInternalException(e);
1:                     }
1:                 if (deliveryListener != null) {
1:                         deliveryListener.afterDelivery(this, message);
1:                     } catch (Throwable t) {
1:                         LOG.debug("Unable to call after delivery", t);
1:                         afterDeliveryError.set(true);
0:                         throw t;
1:             /*
1:             * this can be outside the try/catch as if an exception is thrown then this session will be marked as stale anyway.
1:             * It also needs to be outside the redelivery guard.
1:             * */
1:             }
/////////////////////////////////////////////////////////////////////////
0:         return "ActiveMQSession {id=" + info.getSessionId() + ",started=" + started.get() + "} " + sendMutex;
commit:c9a3202
/////////////////////////////////////////////////////////////////////////
1:                 executor.close();
/////////////////////////////////////////////////////////////////////////
1:                                 
0:                                 if ( connection.isNonBlockingRedelivery() == false) {
0:                                     LOG.debug("Blocking session until re-delivery...");
1:                                     executor.stop();
1:                                 }
1:                                 
1:                                         
0:                                         if (connection.isNonBlockingRedelivery()) {
0:                                             ((ActiveMQDispatcher)md.getConsumer()).dispatch(md);
1:                                         } else {
0:                                             LOG.debug("Session released, issuing re-delivery...");
1:                                             executor.executeFirst(md);
1:                                             executor.start();
1:                                         }
/////////////////////////////////////////////////////////////////////////
1:             
1:             try {
1:                 executor.waitForQueueRestart();
1:             } catch (InterruptedException ex) {
1:                 connection.onClientInternalException(ex);
1:             }            
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:20832f1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                                 && redeliveryCounter >= redeliveryPolicy.getMaximumRedeliveries()) {
/////////////////////////////////////////////////////////////////////////
0:                             md.getMessage().onMessageRolledBack();
author:Gary Tully
-------------------------------------------------------------------------------
commit:1408e7f
/////////////////////////////////////////////////////////////////////////
1:             final MessageAck ack = new MessageAck(md, MessageAck.STANDARD_ACK_TYPE, 1);
/////////////////////////////////////////////////////////////////////////
0:                         public void beforeEnd() throws Exception {
1:                             asyncSendPacket(ack);
1:                         }
1: 
1:                         @Override
/////////////////////////////////////////////////////////////////////////
0:                                 ack.setPoisonCause(new Throwable("Exceeded ra redelivery policy limit:" + redeliveryPolicy));
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:                 messageListener.onMessage(message);
1: 
0:                 LOG.error("error dispatching message: ", e);
0:                 // A problem while invoking the MessageListener does not
0:                 // in general indicate a problem with the connection to the broker, i.e.
0:                 // it will usually be sufficient to let the afterDelivery() method either
0:                 // commit or roll back in order to deal with the exception.
0:                 // However, we notify any registered client internal exception listener
0:                 // of the problem.
1:             } finally {
0:                 if (ack.getTransactionId() == null) {
1:                     try {
0:                         asyncSendPacket(ack);
0:                     } catch (Throwable e) {
1:                         connection.onClientInternalException(e);
1:                     }
1:                 }
commit:a95c6db
/////////////////////////////////////////////////////////////////////////
1:                 LOG.warn("Closed consumer on Command, " + id);
commit:d2bc650
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug(getSessionId() + " Transaction Rollback, txid:"  + transactionContext.getTransactionId());
commit:715bf26
/////////////////////////////////////////////////////////////////////////
1:             //Set the "JMS" header fields on the original message, see 1.1 spec section 3.4.11
/////////////////////////////////////////////////////////////////////////
0:             // destination format is provider specific so only set on transformed message
0:             msg.setJMSDestination(destination);
commit:c62b951
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         connection.addSession(this);        
commit:c23f9e6
/////////////////////////////////////////////////////////////////////////
0:                                 long redeliveryDelay = redeliveryPolicy.getInitialRedeliveryDelay();
0:                                     redeliveryDelay = redeliveryPolicy.getNextRedeliveryDelay(redeliveryDelay);
commit:9e54516
/////////////////////////////////////////////////////////////////////////
0:             consumer.inProgressClearRequired();
commit:62daac4
/////////////////////////////////////////////////////////////////////////
1:         return isTransacted();
/////////////////////////////////////////////////////////////////////////
1:         return this.acknowledgementMode == Session.SESSION_TRANSACTED || (transactionContext.isInXATransaction());
commit:862cd71
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
1: import java.io.InputStream;
1: import java.io.Serializable;
1: import java.net.URL;
1: import java.util.Collections;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.concurrent.CopyOnWriteArrayList;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: 
1: import javax.jms.BytesMessage;
1: import javax.jms.Destination;
1: import javax.jms.IllegalStateException;
1: import javax.jms.InvalidDestinationException;
1: import javax.jms.InvalidSelectorException;
1: import javax.jms.JMSException;
1: import javax.jms.MapMessage;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageListener;
1: import javax.jms.MessageProducer;
1: import javax.jms.ObjectMessage;
1: import javax.jms.Queue;
1: import javax.jms.QueueBrowser;
1: import javax.jms.QueueReceiver;
1: import javax.jms.QueueSender;
1: import javax.jms.QueueSession;
1: import javax.jms.Session;
1: import javax.jms.StreamMessage;
1: import javax.jms.TemporaryQueue;
1: import javax.jms.TemporaryTopic;
1: import javax.jms.TextMessage;
1: import javax.jms.Topic;
1: import javax.jms.TopicPublisher;
1: import javax.jms.TopicSession;
1: import javax.jms.TopicSubscriber;
1: import javax.jms.TransactionRolledBackException;
1: 
1: import org.apache.activemq.blob.BlobDownloader;
1: import org.apache.activemq.command.ActiveMQBlobMessage;
1: import org.apache.activemq.command.ActiveMQBytesMessage;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQMapMessage;
1: import org.apache.activemq.command.ActiveMQMessage;
1: import org.apache.activemq.command.ActiveMQObjectMessage;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.command.ActiveMQStreamMessage;
1: import org.apache.activemq.command.ActiveMQTempDestination;
1: import org.apache.activemq.command.ActiveMQTempQueue;
1: import org.apache.activemq.command.ActiveMQTempTopic;
1: import org.apache.activemq.command.ActiveMQTextMessage;
1: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.command.Command;
1: import org.apache.activemq.command.ConsumerId;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.MessageDispatch;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.command.ProducerId;
1: import org.apache.activemq.command.RemoveInfo;
1: import org.apache.activemq.command.Response;
1: import org.apache.activemq.command.SessionId;
1: import org.apache.activemq.command.SessionInfo;
1: import org.apache.activemq.command.TransactionId;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         executor.clearMessagesInProgress();        
0:         // we are called from inside the transport reconnection logic
0:         // which involves us clearing all the connections' consumers
0:         // dispatch and delivered lists. So rather than trying to 
0:         // grab a mutex (which could be already owned by the message 
0:         // listener calling the send or an ack) we allow it to complete in 
0:         // a separate thread via the scheduler and notify us via 
0:         // connection.transportInterruptionProcessingComplete()
1:         //
0:         for (final ActiveMQMessageConsumer consumer : consumers) {
0:             scheduler.executeAfterDelay(new Runnable() {
1:                 public void run() {
0:                     consumer.clearMessagesInProgress();
1:                 }}, 0l);
commit:9f548bb
/////////////////////////////////////////////////////////////////////////
commit:e45bb06
/////////////////////////////////////////////////////////////////////////
1:             if (LOG.isTraceEnabled()) {
1:                 LOG.trace(getSessionId() + " sending message: " + msg);
/////////////////////////////////////////////////////////////////////////
0:     public void transportResumed() {
1:         for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
1:             ActiveMQMessageConsumer consumer = iter.next();
0:             consumer.transportResumed();
1:         }
1:     }
1: 
commit:4046599
/////////////////////////////////////////////////////////////////////////
1:         if (lazy || connection.isSendAcksAsync() || getTransacted()) {
commit:3b08860
/////////////////////////////////////////////////////////////////////////
0:     private long lastDeliveredSequenceId;
/////////////////////////////////////////////////////////////////////////
1:         RemoveInfo removeCommand = info.createRemoveCommand();
1:         removeCommand.setLastDeliveredSequenceId(lastDeliveredSequenceId);
1:         connection.asyncSendPacket(removeCommand);
/////////////////////////////////////////////////////////////////////////
1:                     lastDeliveredSequenceId = Math.max(lastDeliveredSequenceId, consumer.getLastDeliveredSequenceId());
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * highest sequence id of the last message delivered by this session.
1:      * Passed to the broker in the close command, maintained by dispose()
1:      * @return lastDeliveredSequenceId
1:      */
1:     public long getLastDeliveredSequenceId() {
1:         return lastDeliveredSequenceId;
1:     }
1:     
commit:3a56070
/////////////////////////////////////////////////////////////////////////
0:             if (getTransactionContext().isInXATransaction()) {
commit:0fe1944
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug(getSessionId() + " Transaction Commit :" + transactionContext.getTransactionId());
commit:2b2b35e
/////////////////////////////////////////////////////////////////////////
0:     protected static final Scheduler scheduler = Scheduler.getInstance();
/////////////////////////////////////////////////////////////////////////
0:                                 scheduler.executeAfterDelay(new Runnable() {
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:ba2d0c6
/////////////////////////////////////////////////////////////////////////
1:             msg.setDestination(destination);
1:             msg.setMessageId(new MessageId(producer.getProducerInfo().getProducerId(), sequenceNumber));
1:             if (msg != message) {
1:                 message.setJMSMessageID(msg.getMessageId().toString());
commit:044e6bf
/////////////////////////////////////////////////////////////////////////
0:            msg.setDestination(destination);
1:                 // Make sure the JMS destination is set on the foreign messages too.
1:                 message.setJMSDestination(destination);
commit:aaead5b
/////////////////////////////////////////////////////////////////////////
0:         if (topic == null) {
1:             throw new InvalidDestinationException("Topic cannot be null");
1:         }
1: 
commit:9a8f6e4
commit:d4cd7f9
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      * @param onComplete
1:                         MemoryUsage producerWindow, int sendTimeout, AsyncCallback onComplete) throws JMSException {
/////////////////////////////////////////////////////////////////////////
1:             if (onComplete==null && sendTimeout <= 0 && !msg.isResponseRequired() && !connection.isAlwaysSyncSend() && (!msg.isPersistent() || connection.isUseAsyncSend() || txid != null)) {
/////////////////////////////////////////////////////////////////////////
1:                 if (sendTimeout > 0 && onComplete==null) {
1:                     this.connection.syncSendPacket(msg, onComplete);
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:c256dcf
/////////////////////////////////////////////////////////////////////////
1:                                 
0:                                 MessageAck ack = new MessageAck(md, MessageAck.REDELIVERED_ACK_TYPE, 1);
0:                                 ack.setFirstMessageId(md.getMessage().getMessageId());
0:                                 asyncSendPacket(ack);
1: 
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
1:     protected final CopyOnWriteArrayList<ActiveMQMessageConsumer> consumers = new CopyOnWriteArrayList<ActiveMQMessageConsumer>();
1:     protected final CopyOnWriteArrayList<ActiveMQMessageProducer> producers = new CopyOnWriteArrayList<ActiveMQMessageProducer>();
/////////////////////////////////////////////////////////////////////////
1:         if (connection.isStarted()) {
1:         }
/////////////////////////////////////////////////////////////////////////
0:         return (acknowledgementMode == Session.SESSION_TRANSACTED) || (transactionContext.isInXATransaction());
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
1:             ActiveMQMessageConsumer consumer = iter.next();
1:         for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
1:             ActiveMQMessageConsumer consumer = iter.next();
/////////////////////////////////////////////////////////////////////////
1:                 for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
0:                     ActiveMQMessageConsumer consumer = iter.next();
1:                 for (Iterator<ActiveMQMessageProducer> iter = producers.iterator(); iter.hasNext();) {
1:                     ActiveMQMessageProducer producer = iter.next();
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
1:             ActiveMQMessageConsumer c = iter.next();
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
1:             ActiveMQMessageConsumer c = iter.next();
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
1:             ActiveMQMessageConsumer c = iter.next();
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
1:             ActiveMQMessageConsumer c = iter.next();
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<MessageDispatch> iter = c.iterator(); iter.hasNext();) {
1:             MessageDispatch md = iter.next();
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<ActiveMQMessageConsumer> i = consumers.iterator(); i.hasNext();) {
1:             ActiveMQMessageConsumer consumer = i.next();
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
1:             ActiveMQMessageConsumer c = iter.next();
1:         for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
1:             ActiveMQMessageConsumer c = iter.next();
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
1:             ActiveMQMessageConsumer c = iter.next();
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator<ActiveMQMessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
1:             ActiveMQMessageConsumer c = iter.next();
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:         void beforeDelivery(ActiveMQSession session, Message msg);
1:         void afterDelivery(ActiveMQSession session, Message msg);
0:     private static final Log LOG = LogFactory.getLog(ActiveMQSession.class);
/////////////////////////////////////////////////////////////////////////
1:     private MessageListener messageListener;
0:     private JMSSessionStatsImpl stats;
1:     private TransactionContext transactionContext;
1:     private DeliveryListener deliveryListener;
1:     private MessageTransformer transformer;
1:     private BlobTransferPolicy blobTransferPolicy;
1: 
/////////////////////////////////////////////////////////////////////////
1:         this.debug = LOG.isDebugEnabled();
/////////////////////////////////////////////////////////////////////////
1:     public synchronized void dispose() throws JMSException {
/////////////////////////////////////////////////////////////////////////
0:                 LOG.error("error dispatching message: ", e);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.debug("Sending message: " + msg);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.warn("Exception closing consumer", e);
0:                 LOG.warn("Closed consumer on Command");
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ActiveMQBlobMessage;
0: import org.apache.activemq.command.ActiveMQBytesMessage;
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQMapMessage;
0: import org.apache.activemq.command.ActiveMQMessage;
0: import org.apache.activemq.command.ActiveMQObjectMessage;
0: import org.apache.activemq.command.ActiveMQQueue;
0: import org.apache.activemq.command.ActiveMQStreamMessage;
0: import org.apache.activemq.command.ActiveMQTempDestination;
0: import org.apache.activemq.command.ActiveMQTempQueue;
0: import org.apache.activemq.command.ActiveMQTempTopic;
0: import org.apache.activemq.command.ActiveMQTextMessage;
0: import org.apache.activemq.command.ActiveMQTopic;
0: import org.apache.activemq.command.Command;
0: import org.apache.activemq.command.ConsumerId;
0: import org.apache.activemq.command.MessageAck;
0: import org.apache.activemq.command.MessageDispatch;
0: import org.apache.activemq.command.MessageId;
0: import org.apache.activemq.command.ProducerId;
0: import org.apache.activemq.command.Response;
0: import org.apache.activemq.command.SessionId;
0: import org.apache.activemq.command.SessionInfo;
0: import org.apache.activemq.command.TransactionId;
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
1:  * <LI>It is a factory for <CODE>TemporaryTopics</CODE> and
1:  * <CODE>TemporaryQueues</CODE>.
/////////////////////////////////////////////////////////////////////////
1:  * One typical use is to have a thread block on a synchronous
1:  * <CODE>MessageConsumer</CODE> until a message arrives. The thread may then
1:  * use one or more of the <CODE>Session</CODE>'s<CODE>MessageProducer</CODE>s.
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:      * @param sessionId
1:      * @param acknowledgeMode n.b if transacted - the acknowledgeMode ==
1:      *                Session.SESSION_TRANSACTED
1:      * @param asyncDispatch
1:      * @param sessionAsyncDispatch
1:      * @throws JMSException on internal error
1:     protected ActiveMQSession(ActiveMQConnection connection, SessionId sessionId, int acknowledgeMode, boolean asyncDispatch, boolean sessionAsyncDispatch) throws JMSException {
1:         this.asyncDispatch = asyncDispatch;
/////////////////////////////////////////////////////////////////////////
1: 
0:         if (connection.isStarted())
1: 
1:     protected ActiveMQSession(ActiveMQConnection connection, SessionId sessionId, int acknowledgeMode, boolean asyncDispatch) throws JMSException {
1:         this(connection, sessionId, acknowledgeMode, asyncDispatch, true);
1:      * @param transactionContext - provides the means to control a JMS
1:      *                transaction.
/////////////////////////////////////////////////////////////////////////
1:      * @throws JMSException if the JMS provider fails to create this message due
1:      *                 to some internal error.
/////////////////////////////////////////////////////////////////////////
1:      * @throws JMSException if the JMS provider fails to create this message due
1:      *                 to some internal error.
/////////////////////////////////////////////////////////////////////////
1:      * interface is the root interface of all JMS messages. A
1:      * <CODE>Message</CODE> object holds all the standard message header
1:      * information. It can be sent when a message containing only header
1:      * information is sufficient.
1:      * @throws JMSException if the JMS provider fails to create this message due
1:      *                 to some internal error.
/////////////////////////////////////////////////////////////////////////
1:      * Creates an <CODE>ObjectMessage</CODE> object. An
1:      * <CODE>ObjectMessage</CODE> object is used to send a message that
1:      * contains a serializable Java object.
1:      * @throws JMSException if the JMS provider fails to create this message due
1:      *                 to some internal error.
/////////////////////////////////////////////////////////////////////////
1:      * Creates an initialized <CODE>ObjectMessage</CODE> object. An
1:      * <CODE>ObjectMessage</CODE> object is used to send a message that
1:      * contains a serializable Java object.
1:      * @param object the object to use to initialize this message
1:      * @throws JMSException if the JMS provider fails to create this message due
1:      *                 to some internal error.
/////////////////////////////////////////////////////////////////////////
1:      * Creates a <CODE>StreamMessage</CODE> object. A
1:      * <CODE>StreamMessage</CODE> object is used to send a self-defining
1:      * stream of primitive values in the Java programming language.
1:      * @throws JMSException if the JMS provider fails to create this message due
1:      *                 to some internal error.
/////////////////////////////////////////////////////////////////////////
1:      * @throws JMSException if the JMS provider fails to create this message due
1:      *                 to some internal error.
/////////////////////////////////////////////////////////////////////////
1:      * Creates an initialized <CODE>TextMessage</CODE> object. A
1:      * <CODE>TextMessage</CODE> object is used to send a message containing a
1:      * <CODE>String</CODE>.
1:      * @param text the string used to initialize this message
1:      * @throws JMSException if the JMS provider fails to create this message due
1:      *                 to some internal error.
/////////////////////////////////////////////////////////////////////////
1:      * Creates an initialized <CODE>BlobMessage</CODE> object. A
1:      * <CODE>BlobMessage</CODE> object is used to send a message containing a
1:      * <CODE>URL</CODE> which points to some network addressible BLOB.
1:      * 
1:      * @param url the network addressable URL used to pass directly to the
1:      *                consumer
1:      * @throws JMSException if the JMS provider fails to create this message due
1:      *                 to some internal error.
1:      * Creates an initialized <CODE>BlobMessage</CODE> object. A
1:      * <CODE>BlobMessage</CODE> object is used to send a message containing a
1:      * <CODE>URL</CODE> which points to some network addressible BLOB.
1:      * 
1:      * @param url the network addressable URL used to pass directly to the
1:      *                consumer
1:      * @param deletedByBroker indicates whether or not the resource is deleted
1:      *                by the broker when the message is acknowledged
1:      * @throws JMSException if the JMS provider fails to create this message due
1:      *                 to some internal error.
/////////////////////////////////////////////////////////////////////////
1:      * Creates an initialized <CODE>BlobMessage</CODE> object. A
1:      * <CODE>BlobMessage</CODE> object is used to send a message containing
1:      * the <CODE>File</CODE> content. Before the message is sent the file
1:      * conent will be uploaded to the broker or some other remote repository
1:      * 
1:      * @param file the file to be uploaded to some remote repo (or the broker)
1:      *                depending on the strategy
1:      * @throws JMSException if the JMS provider fails to create this message due
1:      *                 to some internal error.
/////////////////////////////////////////////////////////////////////////
1:      * Creates an initialized <CODE>BlobMessage</CODE> object. A
1:      * <CODE>BlobMessage</CODE> object is used to send a message containing
1:      * the <CODE>File</CODE> content. Before the message is sent the file
1:      * conent will be uploaded to the broker or some other remote repository
1:      * 
1:      * @param in the stream to be uploaded to some remote repo (or the broker)
1:      *                depending on the strategy
1:      * @throws JMSException if the JMS provider fails to create this message due
1:      *                 to some internal error.
/////////////////////////////////////////////////////////////////////////
1:      * @throws JMSException if there is some internal error.
/////////////////////////////////////////////////////////////////////////
1:      * @throws JMSException if the JMS provider fails to commit the transaction
1:      *                 due to some internal error.
1:      * @throws TransactionRolledBackException if the transaction is rolled back
1:      *                 due to some internal error during commit.
1:      * @throws javax.jms.IllegalStateException if the method is not called by a
1:      *                 transacted session.
/////////////////////////////////////////////////////////////////////////
1:      * @throws JMSException if the JMS provider fails to roll back the
1:      *                 transaction due to some internal error.
1:      * @throws javax.jms.IllegalStateException if the method is not called by a
1:      *                 transacted session.
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:      * listener in progress has completed. A blocked message consumer
1:      * <CODE>receive</CODE> call returns <CODE>null</CODE> when this session
1:      * is closed.
/////////////////////////////////////////////////////////////////////////
1:      * @throws JMSException if the JMS provider fails to close the session due
1:      *                 to some internal error.
/////////////////////////////////////////////////////////////////////////
1: 
0:     void clearMessagesInProgress() {
0:             ActiveMQMessageConsumer consumer = (ActiveMQMessageConsumer)iter.next();
1: 
1:     void deliverAcks() {
0:             ActiveMQMessageConsumer consumer = (ActiveMQMessageConsumer)iter.next();
/////////////////////////////////////////////////////////////////////////
0:                     ActiveMQMessageConsumer consumer = (ActiveMQMessageConsumer)iter.next();
0:                     ActiveMQMessageProducer producer = (ActiveMQMessageProducer)iter.next();
/////////////////////////////////////////////////////////////////////////
1:                 } catch (JMSException e) {
0:             } finally {
/////////////////////////////////////////////////////////////////////////
1:      * @throws IllegalStateException if the Session is closed
/////////////////////////////////////////////////////////////////////////
1:      * @throws JMSException if the JMS provider fails to stop and restart
1:      *                 message delivery due to some internal error.
1:      * @throws IllegalStateException if the method is called by a transacted
1:      *                 session.
/////////////////////////////////////////////////////////////////////////
0:             ActiveMQMessageConsumer c = (ActiveMQMessageConsumer)iter.next();
/////////////////////////////////////////////////////////////////////////
1:      * @throws JMSException if the JMS provider fails to get the message
1:      *                 listener due to an internal error.
/////////////////////////////////////////////////////////////////////////
1:      * @param listener the message listener to associate with this session
1:      * @throws JMSException if the JMS provider fails to set the message
1:      *                 listener due to an internal error.
/////////////////////////////////////////////////////////////////////////
0:             if (message.isExpired() || connection.isDuplicate(ActiveMQSession.this, message)) {
0:                 // TODO: Ack it without delivery to client
1: 
0:             if (isClientAcknowledge()) {
1: 
1:             md.setDeliverySequenceId(getNextDeliveryId());
1:             try {
0:             } catch (Throwable e) {
0:                 log.error("error dispatching message: ", e);
0:                 MessageAck ack = new MessageAck(md, MessageAck.STANDARD_ACK_TYPE, 1);
0:                 if (ack.getTransactionId() != null) {
1:                     getTransactionContext().addSynchronization(new Synchronization() {
1:                         public void afterRollback() throws Exception {
0:                             connection.rollbackDuplicate(ActiveMQSession.this, md.getMessage());
0:                             RedeliveryPolicy redeliveryPolicy = connection.getRedeliveryPolicy();
0:                             int redeliveryCounter = md.getMessage().getRedeliveryCounter();
0:                             if (redeliveryPolicy.getMaximumRedeliveries() != RedeliveryPolicy.NO_MAXIMUM_REDELIVERIES
0:                                 && redeliveryCounter > redeliveryPolicy.getMaximumRedeliveries()) {
0:                                 // We need to NACK the messages so that they get
0:                                 // sent to the
0:                                 MessageAck ack = new MessageAck(md, MessageAck.POSION_ACK_TYPE, 1);
1:                             } else {
0:                                 // Figure out how long we should wait to resend
0:                                 // this message.
0:                                 long redeliveryDelay = 0;
0:                                 for (int i = 0; i < redeliveryCounter; i++) {
0:                                     redeliveryDelay = redeliveryPolicy.getRedeliveryDelay(redeliveryDelay);
0:                                 Scheduler.executeAfterDelay(new Runnable() {
1:                                     public void run() {
0:                                 }, redeliveryDelay);
0:             } catch (Throwable e) {
/////////////////////////////////////////////////////////////////////////
1:      * @param destination the <CODE>Destination</CODE> to send to, or null if
1:      *                this is a producer which does not have a specified
1:      *                destination.
1:      * @throws JMSException if the session fails to create a MessageProducer due
1:      *                 to some internal error.
1:      * @throws InvalidDestinationException if an invalid destination is
1:      *                 specified.
1:         if (destination instanceof CustomDestination) {
1:             CustomDestination customDestination = (CustomDestination)destination;
0:         return new ActiveMQMessageProducer(this, getNextProducerId(), ActiveMQMessageTransformation.transformDestination(destination));
/////////////////////////////////////////////////////////////////////////
1:      * @param destination the <CODE>Destination</CODE> to access.
1:      * @throws JMSException if the session fails to create a consumer due to
1:      *                 some internal error.
1:      * @throws InvalidDestinationException if an invalid destination is
1:      *                 specified.
/////////////////////////////////////////////////////////////////////////
1:      * using a message selector. Since <CODE> Queue</CODE> and
1:      * <CODE>Topic</CODE> both inherit from <CODE>Destination</CODE>, they
1:      * can be used in the destination parameter to create a
1:      * <CODE>MessageConsumer</CODE>.
1:      * @param destination the <CODE>Destination</CODE> to access
1:      * @param messageSelector only messages with properties matching the message
1:      *                selector expression are delivered. A value of null or an
1:      *                empty string indicates that there is no message selector
1:      *                for the message consumer.
1:      * @throws JMSException if the session fails to create a MessageConsumer due
1:      *                 to some internal error.
1:      * @throws InvalidDestinationException if an invalid destination is
1:      *                 specified.
1:      * @throws InvalidSelectorException if the message selector is invalid.
1:         if (destination instanceof CustomDestination) {
1:             CustomDestination customDestination = (CustomDestination)destination;
/////////////////////////////////////////////////////////////////////////
0:         return new ActiveMQMessageConsumer(this, getNextConsumerId(), ActiveMQMessageTransformation.transformDestination(destination), null, messageSelector, prefetch,
0:                                            prefetchPolicy.getMaximumPendingMessageLimit(), false, false, asyncDispatch);
/////////////////////////////////////////////////////////////////////////
1:      * @param destination the <CODE>Destination</CODE> to access
1:      * @param messageSelector only messages with properties matching the message
1:      *                selector expression are delivered. A value of null or an
1:      *                empty string indicates that there is no message selector
1:      *                for the message consumer.
1:      * @param noLocal - if true, and the destination is a topic, inhibits the
1:      *                delivery of messages published by its own connection. The
1:      *                behavior for <CODE>NoLocal</CODE> is not specified if
1:      *                the destination is a queue.
1:      * @throws JMSException if the session fails to create a MessageConsumer due
1:      *                 to some internal error.
1:      * @throws InvalidDestinationException if an invalid destination is
1:      *                 specified.
1:      * @throws InvalidSelectorException if the message selector is invalid.
1:     public MessageConsumer createConsumer(Destination destination, String messageSelector, boolean noLocal) throws JMSException {
0:         if (destination instanceof CustomDestination) {
0:             CustomDestination customDestination = (CustomDestination)destination;
0:         return new ActiveMQMessageConsumer(this, getNextConsumerId(), ActiveMQMessageTransformation.transformDestination(destination), null, messageSelector, prefetchPolicy
1:             .getTopicPrefetch(), prefetchPolicy.getMaximumPendingMessageLimit(), noLocal, false, asyncDispatch);
/////////////////////////////////////////////////////////////////////////
1:      * @param queueName the name of this <CODE>Queue</CODE>
1:      * @throws JMSException if the session fails to create a queue due to some
1:      *                 internal error.
/////////////////////////////////////////////////////////////////////////
1:      * @param topicName the name of this <CODE>Topic</CODE>
1:      * @throws JMSException if the session fails to create a topic due to some
1:      *                 internal error.
/////////////////////////////////////////////////////////////////////////
1:      * @param queue the <CODE>queue</CODE> to access
1:      * @exception InvalidDestinationException if an invalid destination is
1:      *                    specified
/////////////////////////////////////////////////////////////////////////
1:      * creates. Only one session at a time can have a
1:      * <CODE>TopicSubscriber</CODE> for a particular durable subscription.
/////////////////////////////////////////////////////////////////////////
1:      * @param topic the non-temporary <CODE>Topic</CODE> to subscribe to
1:      * @param name the name used to identify this subscription
1:      * @throws JMSException if the session fails to create a subscriber due to
1:      *                 some internal error.
1:      * @throws InvalidDestinationException if an invalid topic is specified.
/////////////////////////////////////////////////////////////////////////
1:      * creates. Only one session at a time can have a
1:      * <CODE>TopicSubscriber</CODE> for a particular durable subscription. An
1:      * inactive durable subscriber is one that exists but does not currently
1:      * have a message consumer associated with it.
1:      * @param topic the non-temporary <CODE>Topic</CODE> to subscribe to
1:      * @param name the name used to identify this subscription
1:      * @param messageSelector only messages with properties matching the message
1:      *                selector expression are delivered. A value of null or an
1:      *                empty string indicates that there is no message selector
1:      *                for the message consumer.
1:      * @param noLocal if set, inhibits the delivery of messages published by its
1:      *                own connection
1:      * @throws JMSException if the session fails to create a subscriber due to
1:      *                 some internal error.
1:      * @throws InvalidDestinationException if an invalid topic is specified.
1:      * @throws InvalidSelectorException if the message selector is invalid.
1:     public TopicSubscriber createDurableSubscriber(Topic topic, String name, String messageSelector, boolean noLocal) throws JMSException {
1:         if (topic instanceof CustomDestination) {
1:             CustomDestination customDestination = (CustomDestination)topic;
1:         ActiveMQPrefetchPolicy prefetchPolicy = this.connection.getPrefetchPolicy();
1:         int prefetch = isAutoAcknowledge() && connection.isOptimizedMessageDispatch() ? prefetchPolicy.getOptimizeDurableTopicPrefetch() : prefetchPolicy.getDurableTopicPrefetch();
1:         int maxPrendingLimit = prefetchPolicy.getMaximumPendingMessageLimit();
1:         return new ActiveMQTopicSubscriber(this, getNextConsumerId(), ActiveMQMessageTransformation.transformDestination(topic), name, messageSelector, prefetch, maxPrendingLimit,
1:                                            noLocal, false, asyncDispatch);
1:      * @param queue the <CODE>queue</CODE> to access
1:      * @throws JMSException if the session fails to create a browser due to some
1:      *                 internal error.
1:      * @throws InvalidDestinationException if an invalid destination is
1:      *                 specified
/////////////////////////////////////////////////////////////////////////
1:      * @param queue the <CODE>queue</CODE> to access
1:      * @param messageSelector only messages with properties matching the message
1:      *                selector expression are delivered. A value of null or an
1:      *                empty string indicates that there is no message selector
1:      *                for the message consumer.
1:      * @throws JMSException if the session fails to create a browser due to some
1:      *                 internal error.
1:      * @throws InvalidDestinationException if an invalid destination is
1:      *                 specified
1:      * @throws InvalidSelectorException if the message selector is invalid.
1:         return new ActiveMQQueueBrowser(this, getNextConsumerId(), ActiveMQMessageTransformation.transformDestination(queue), messageSelector, asyncDispatch);
/////////////////////////////////////////////////////////////////////////
1:      * @throws JMSException if the session fails to create a temporary queue due
1:      *                 to some internal error.
1:         return (TemporaryQueue)connection.createTempDestination(false);
/////////////////////////////////////////////////////////////////////////
1:      * @throws JMSException if the session fails to create a temporary topic due
1:      *                 to some internal error.
/////////////////////////////////////////////////////////////////////////
1:      * @param queue the <CODE>Queue</CODE> to access
1:      * @throws JMSException if the session fails to create a receiver due to
1:      *                 some internal error.
1:      * @throws InvalidDestinationException if an invalid queue is specified.
/////////////////////////////////////////////////////////////////////////
1:      * @param queue the <CODE>Queue</CODE> to access
1:      * @param messageSelector only messages with properties matching the message
1:      *                selector expression are delivered. A value of null or an
1:      *                empty string indicates that there is no message selector
1:      *                for the message consumer.
1:      * @throws JMSException if the session fails to create a receiver due to
1:      *                 some internal error.
1:      * @throws InvalidDestinationException if an invalid queue is specified.
1:      * @throws InvalidSelectorException if the message selector is invalid.
1:         if (queue instanceof CustomDestination) {
1:             CustomDestination customDestination = (CustomDestination)queue;
1:         return new ActiveMQQueueReceiver(this, getNextConsumerId(), ActiveMQMessageTransformation.transformDestination(queue), messageSelector, prefetchPolicy.getQueuePrefetch(),
1:                                          prefetchPolicy.getMaximumPendingMessageLimit(), asyncDispatch);
1:      * @param queue the <CODE>Queue</CODE> to access, or null if this is an
1:      *                unidentified producer
1:      * @throws JMSException if the session fails to create a sender due to some
1:      *                 internal error.
1:      * @throws InvalidDestinationException if an invalid queue is specified.
1:         if (queue instanceof CustomDestination) {
1:             CustomDestination customDestination = (CustomDestination)queue;
/////////////////////////////////////////////////////////////////////////
1:      * @param topic the <CODE>Topic</CODE> to subscribe to
1:      * @throws JMSException if the session fails to create a subscriber due to
1:      *                 some internal error.
1:      * @throws InvalidDestinationException if an invalid topic is specified.
/////////////////////////////////////////////////////////////////////////
1:      * @param topic the <CODE>Topic</CODE> to subscribe to
1:      * @param messageSelector only messages with properties matching the message
1:      *                selector expression are delivered. A value of null or an
1:      *                empty string indicates that there is no message selector
1:      *                for the message consumer.
1:      * @param noLocal if set, inhibits the delivery of messages published by its
1:      *                own connection
1:      * @throws JMSException if the session fails to create a subscriber due to
1:      *                 some internal error.
1:      * @throws InvalidDestinationException if an invalid topic is specified.
1:      * @throws InvalidSelectorException if the message selector is invalid.
1:         if (topic instanceof CustomDestination) {
1:             CustomDestination customDestination = (CustomDestination)topic;
1:         return new ActiveMQTopicSubscriber(this, getNextConsumerId(), ActiveMQMessageTransformation.transformDestination(topic), null, messageSelector, prefetchPolicy
0:             .getTopicPrefetch(), prefetchPolicy.getMaximumPendingMessageLimit(), noLocal, false, asyncDispatch);
/////////////////////////////////////////////////////////////////////////
1:      * @param topic the <CODE>Topic</CODE> to publish to, or null if this is
1:      *                an unidentified producer
1:      * @throws JMSException if the session fails to create a publisher due to
1:      *                 some internal error.
1:      * @throws InvalidDestinationException if an invalid topic is specified.
1: 
1:         if (topic instanceof CustomDestination) {
1:             CustomDestination customDestination = (CustomDestination)topic;
/////////////////////////////////////////////////////////////////////////
1:      * is an active <CODE>MessageConsumer </CODE> or
1:      * <CODE>TopicSubscriber</CODE> for the subscription, or while a consumed
1:      * message is part of a pending transaction or has not been acknowledged in
1:      * the session.
1:      * @param name the name used to identify this subscription
1:      * @throws JMSException if the session fails to unsubscribe to the durable
1:      *                 subscription due to some internal error.
1:      * @throws InvalidDestinationException if an invalid subscription name is
1:      *                 specified.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:      * messages are to be explicitly acknowledged. By invoking
1:      * <CODE>acknowledge</CODE> on a consumed message, a client acknowledges
1:      * all messages consumed by the session that the message was delivered to.
/////////////////////////////////////////////////////////////////////////
1:      * @throws JMSException if the JMS provider fails to acknowledge the
1:      *                 messages due to some internal error.
1:      * @throws javax.jms.IllegalStateException if this method is called on a
1:      *                 closed session.
0:             ActiveMQMessageConsumer c = (ActiveMQMessageConsumer)iter.next();
1:      * 
1:      * @param consumer - message consumer.
/////////////////////////////////////////////////////////////////////////
1:      * @param consumer - consumer to be removed.
/////////////////////////////////////////////////////////////////////////
1:      * @param producer - message producer to be added.
/////////////////////////////////////////////////////////////////////////
1:      * @param producer - message producer to be removed.
/////////////////////////////////////////////////////////////////////////
0:             ActiveMQMessageConsumer c = (ActiveMQMessageConsumer)iter.next();
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @throws JMSException
1: 
0:             ActiveMQMessageConsumer c = (ActiveMQMessageConsumer)iter.next();
/////////////////////////////////////////////////////////////////////////
1:      * @param producer - message producer.
1:      * @param destination - message destination.
1:      * @param message - message to be sent.
0:      * @param deliveryMode - JMS messsage delivery mode.
1:      * @param priority - message priority.
1:      * @param timeToLive - message expiration.
1:      * @param producerWindow
1:     protected void send(ActiveMQMessageProducer producer, ActiveMQDestination destination, Message message, int deliveryMode, int priority, long timeToLive,
0:                         UsageManager producerWindow) throws JMSException {
1: 
1:         checkClosed();
1:         if (destination.isTemporary() && connection.isDeleted(destination)) {
0:             throw new JMSException("Cannot publish to a deleted Destination: " + destination);
1:         }
1:         synchronized (sendMutex) {
1:             // tell the Broker we are about to start a new transaction
1:             doStartTransaction();
1:             TransactionId txid = transactionContext.getTransactionId();
1:             long sequenceNumber = producer.getMessageSequence();
1:             ActiveMQMessage msg = ActiveMQMessageTransformation.transformMessage(message, connection);
0:             if (msg == message) {
0:                 msg.setMessageId(new MessageId(producer.getProducerInfo().getProducerId(), sequenceNumber));
1:             } else {
0:                 msg.setMessageId(new MessageId(producer.getProducerInfo().getProducerId(), sequenceNumber));
0:                 message.setJMSMessageID(msg.getMessageId().toString());
1:             }
0:             msg.setJMSDeliveryMode(deliveryMode);
1:             long expiration = 0L;
1:             if (!producer.getDisableMessageTimestamp()) {
1:                 long timeStamp = System.currentTimeMillis();
0:                 msg.setJMSTimestamp(timeStamp);
1:                 if (timeToLive > 0) {
1:                     expiration = timeToLive + timeStamp;
1:                 }
1:             }
0:             msg.setJMSExpiration(expiration);
0:             msg.setJMSPriority(priority);
0:             msg.setJMSRedelivered(false);
1:             if (connection.isCopyMessageOnSend()) {
1:                 msg = (ActiveMQMessage)msg.copy();
1:             msg.setConnection(connection);
1:             msg.onSend();
1:             msg.setProducerId(msg.getMessageId().getProducerId());
0:             if (this.debug) {
0:                 log.debug("Sending message: " + msg);
1:             }
0:             if (!connection.isAlwaysSyncSend() && (!msg.isPersistent() || connection.isUseAsyncSend() || txid != null)) {
1:                 if (producerWindow != null) {
1:                     // Since we defer lots of the marshaling till we hit the
1:                     // wire, this might not
1:                     // provide and accurate size. We may change over to doing
1:                     // more aggressive marshaling,
1:                     // to get more accurate sizes.. this is more important once
1:                     // users start using producer window
1:                     // flow control.
1:                     int size = msg.getSize();
1:                     producerWindow.increaseUsage(size);
1:                 }
1:             } else {
1:         }
1:     }
1:      * Send TransactionInfo to indicate transaction has started
1:      * 
1:      * @throws JMSException if some internal error occurs
1:      */
1:     protected void doStartTransaction() throws JMSException {
1:         if (getTransacted() && !transactionContext.isInXATransaction()) {
1:             transactionContext.begin();
1:         }
1:     }
1: 
1:     /**
1:      * Checks whether the session has unconsumed messages.
1:      * 
1:      * @return true - if there are unconsumed messages.
1:      */
1:      * Checks whether the session uses transactions.
1:      * 
1:      * @return true - if the session uses transactions.
1:      */
/////////////////////////////////////////////////////////////////////////
1: 
1:         return acknowledgementMode == Session.AUTO_ACKNOWLEDGE;
1: 
1:         return acknowledgementMode == Session.DUPS_OK_ACKNOWLEDGE;
/////////////////////////////////////////////////////////////////////////
1:      * @param deliveryListener - message delivery listener.
/////////////////////////////////////////////////////////////////////////
1:      * @param command - command to be executed.
/////////////////////////////////////////////////////////////////////////
1:      * @param command - command to be executed.
/////////////////////////////////////////////////////////////////////////
1:     public void redispatch(ActiveMQDispatcher dispatcher, MessageDispatchChannel unconsumedMessages) throws JMSException {
1: 
1:         List<MessageDispatch> c = unconsumedMessages.removeAll();
1:         for (MessageDispatch md : c) {
1:             this.connection.rollbackDuplicate(dispatcher, md.getMessage());
1: 
0:             MessageDispatch md = (MessageDispatch)iter.next();
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public boolean isSessionAsyncDispatch() {
1:     public void setSessionAsyncDispatch(boolean sessionAsyncDispatch) {
1:         this.sessionAsyncDispatch = sessionAsyncDispatch;
/////////////////////////////////////////////////////////////////////////
1:      * Sets the transformer used to transform messages before they are sent on
1:      * to the JMS bus or when they are received from the bus but before they are
1:      * delivered to the JMS client
/////////////////////////////////////////////////////////////////////////
1:      * Sets the policy used to describe how out-of-band BLOBs (Binary Large
1:      * OBjects) are transferred from producers to brokers to consumers
1:         return executor.getUnconsumedMessages();
1:     }
0:         return "ActiveMQSession {id=" + info.getSessionId() + ",started=" + started.get() + "}";
/////////////////////////////////////////////////////////////////////////
0:             ActiveMQMessageConsumer consumer = (ActiveMQMessageConsumer)i.next();
0:             if (consumer.getMessageListener() != null) {
1: 
1:     protected void setOptimizeAcknowledge(boolean value) {
0:             ActiveMQMessageConsumer c = (ActiveMQMessageConsumer)iter.next();
1: 
1:     protected void setPrefetchSize(ConsumerId id, int prefetch) {
0:         for (Iterator iter = consumers.iterator(); iter.hasNext();) {
0:             ActiveMQMessageConsumer c = (ActiveMQMessageConsumer)iter.next();
1:             if (c.getConsumerId().equals(id)) {
1: 
1:     protected void close(ConsumerId id) {
0:         for (Iterator iter = consumers.iterator(); iter.hasNext();) {
0:             ActiveMQMessageConsumer c = (ActiveMQMessageConsumer)iter.next();
1:             if (c.getConsumerId().equals(id)) {
1:                 try {
1:                 } catch (JMSException e) {
0:                     log.warn("Exception closing consumer", e);
/////////////////////////////////////////////////////////////////////////
1:     public boolean isInUse(ActiveMQTempDestination destination) {
0:         for (Iterator iter = consumers.iterator(); iter.hasNext();) {
0:             ActiveMQMessageConsumer c = (ActiveMQMessageConsumer)iter.next();
1:             if (c.isInUse(destination)) {
1:                 return true;
1:     }
commit:4207bd9
/////////////////////////////////////////////////////////////////////////
0: import java.io.Serializable;
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.BytesMessage;
0: import javax.jms.Destination;
0: import javax.jms.IllegalStateException;
0: import javax.jms.InvalidDestinationException;
0: import javax.jms.InvalidSelectorException;
0: import javax.jms.JMSException;
0: import javax.jms.MapMessage;
0: import javax.jms.Message;
0: import javax.jms.MessageConsumer;
0: import javax.jms.MessageListener;
0: import javax.jms.MessageProducer;
0: import javax.jms.ObjectMessage;
0: import javax.jms.Queue;
0: import javax.jms.QueueBrowser;
0: import javax.jms.QueueReceiver;
0: import javax.jms.QueueSender;
0: import javax.jms.QueueSession;
0: import javax.jms.Session;
0: import javax.jms.StreamMessage;
0: import javax.jms.TemporaryQueue;
0: import javax.jms.TemporaryTopic;
0: import javax.jms.TextMessage;
0: import javax.jms.Topic;
0: import javax.jms.TopicPublisher;
0: import javax.jms.TopicSession;
0: import javax.jms.TopicSubscriber;
0: import javax.jms.TransactionRolledBackException;
1: 
1: import org.apache.activemq.blob.BlobTransferPolicy;
1: import org.apache.activemq.blob.BlobUploader;
0: import org.apache.activemq.command.ActiveMQBlobMessage;
0: import org.apache.activemq.command.ActiveMQBytesMessage;
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQMapMessage;
0: import org.apache.activemq.command.ActiveMQMessage;
0: import org.apache.activemq.command.ActiveMQObjectMessage;
0: import org.apache.activemq.command.ActiveMQQueue;
0: import org.apache.activemq.command.ActiveMQStreamMessage;
0: import org.apache.activemq.command.ActiveMQTempDestination;
0: import org.apache.activemq.command.ActiveMQTextMessage;
0: import org.apache.activemq.command.ActiveMQTopic;
0: import org.apache.activemq.command.Command;
0: import org.apache.activemq.command.ConsumerId;
0: import org.apache.activemq.command.MessageAck;
0: import org.apache.activemq.command.MessageDispatch;
0: import org.apache.activemq.command.MessageId;
0: import org.apache.activemq.command.ProducerId;
0: import org.apache.activemq.command.Response;
0: import org.apache.activemq.command.SessionId;
0: import org.apache.activemq.command.SessionInfo;
0: import org.apache.activemq.command.TransactionId;
1: import org.apache.activemq.management.JMSSessionStatsImpl;
1: import org.apache.activemq.management.StatsCapable;
1: import org.apache.activemq.management.StatsImpl;
0: import org.apache.activemq.memory.UsageManager;
1: import org.apache.activemq.thread.Scheduler;
1: import org.apache.activemq.transaction.Synchronization;
1: import org.apache.activemq.util.Callback;
1: import org.apache.activemq.util.LongSequenceGenerator;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
/////////////////////////////////////////////////////////////////////////
0:      * @param producerWindow 
0:     protected void send(ActiveMQMessageProducer producer,
0: 	        int priority,long timeToLive, UsageManager producerWindow) throws JMSException{
1:     	
/////////////////////////////////////////////////////////////////////////
0:     			if( producerWindow!=null ) {
0:     				// Since we defer lots of the marshaling till we hit the wire, this might not 
0:     				// provide and accurate size.  We may change over to doing more aggressive marshaling,
0:     				// to get more accurate sizes.. this is more important once users start using producer window
0:     				// flow control.			
0:     				int size = msg.getSize();
0:     				producerWindow.increaseUsage(size);
1:     			}
commit:c9bb1c9
/////////////////////////////////////////////////////////////////////////
1:         this.connection.addProducer(producer.getProducerInfo().getProducerId(), producer);
/////////////////////////////////////////////////////////////////////////
1:         this.connection.removeProducer(producer.getProducerInfo().getProducerId());
/////////////////////////////////////////////////////////////////////////
0:     protected int send(ActiveMQMessageProducer producer,
/////////////////////////////////////////////////////////////////////////
1: 
0: 			// Since we defer lots of the marshaling till we hit the wire, this might not 
0: 			// provide and accurate size.  We may change over to doing more aggressive marshaling,
0: 			// to get more accurate sizes.. this is more important once users start using producer window
0: 			// flow control.
0: 			return msg.getSize();
commit:be35271
/////////////////////////////////////////////////////////////////////////
0: 			msg.setConnection(connection);
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.CopyOnWriteArrayList;
0: import java.util.concurrent.atomic.AtomicBoolean;
commit:b75a6da
/////////////////////////////////////////////////////////////////////////
1:             Thread.currentThread().interrupt();
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:686db79
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e2aad41
/////////////////////////////////////////////////////////////////////////
1: 
0:             executor.stop();
/////////////////////////////////////////////////////////////////////////
1:             
commit:b6673c4
/////////////////////////////////////////////////////////////////////////
1:         return executor.hasUncomsumedMessages();
commit:7f5213b
/////////////////////////////////////////////////////////////////////////
1:                     public void execute() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:                         public void afterRollback() throws Exception {
commit:6f99fe8
/////////////////////////////////////////////////////////////////////////
0:     synchronized public void dispose() throws JMSException {
commit:d86f77f
/////////////////////////////////////////////////////////////////////////
1:     public void checkMessageListener() throws JMSException {
1:         if (messageListener != null) {
1:             throw new IllegalStateException("Cannot synchronously receive a message when a MessageListener is set");
1:         }
0:         for (Iterator i = consumers.iterator(); i.hasNext();) {
0:             ActiveMQMessageConsumer consumer = (ActiveMQMessageConsumer) i.next();
0:             if( consumer.getMessageListener()!=null ) {
1:                 throw new IllegalStateException("Cannot synchronously receive a message when a MessageListener is set");
1:             }
1:         }
1:     }
commit:c59246d
/////////////////////////////////////////////////////////////////////////
1:         this.info = new SessionInfo(connection.getConnectionInfo(), sessionId.getValue());
/////////////////////////////////////////////////////////////////////////
1:      * @return value - session id.
/////////////////////////////////////////////////////////////////////////
1:         SessionInfo info = new SessionInfo(connection.getConnectionInfo(), getSessionId().getValue());
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq;
1: 
0: import java.io.Serializable;
0: import java.util.Collections;
0: import java.util.Iterator;
0: import java.util.List;
1: 
0: import javax.jms.BytesMessage;
0: import javax.jms.Destination;
0: import javax.jms.IllegalStateException;
0: import javax.jms.InvalidDestinationException;
0: import javax.jms.InvalidSelectorException;
0: import javax.jms.JMSException;
0: import javax.jms.MapMessage;
0: import javax.jms.Message;
0: import javax.jms.MessageConsumer;
0: import javax.jms.MessageListener;
0: import javax.jms.MessageProducer;
0: import javax.jms.ObjectMessage;
0: import javax.jms.Queue;
0: import javax.jms.QueueBrowser;
0: import javax.jms.QueueReceiver;
0: import javax.jms.QueueSender;
0: import javax.jms.QueueSession;
0: import javax.jms.Session;
0: import javax.jms.StreamMessage;
0: import javax.jms.TemporaryQueue;
0: import javax.jms.TemporaryTopic;
0: import javax.jms.TextMessage;
0: import javax.jms.Topic;
0: import javax.jms.TopicPublisher;
0: import javax.jms.TopicSession;
0: import javax.jms.TopicSubscriber;
0: import javax.jms.TransactionRolledBackException;
1: 
0: import org.apache.activemq.command.ActiveMQBytesMessage;
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQMapMessage;
0: import org.apache.activemq.command.ActiveMQMessage;
0: import org.apache.activemq.command.ActiveMQObjectMessage;
0: import org.apache.activemq.command.ActiveMQQueue;
0: import org.apache.activemq.command.ActiveMQStreamMessage;
0: import org.apache.activemq.command.ActiveMQTextMessage;
0: import org.apache.activemq.command.ActiveMQTopic;
0: import org.apache.activemq.command.Command;
0: import org.apache.activemq.command.ConsumerId;
0: import org.apache.activemq.command.MessageAck;
0: import org.apache.activemq.command.MessageDispatch;
0: import org.apache.activemq.command.MessageId;
0: import org.apache.activemq.command.ProducerId;
0: import org.apache.activemq.command.RedeliveryPolicy;
0: import org.apache.activemq.command.Response;
0: import org.apache.activemq.command.SessionId;
0: import org.apache.activemq.command.SessionInfo;
0: import org.apache.activemq.command.TransactionId;
0: import org.apache.activemq.management.JMSSessionStatsImpl;
0: import org.apache.activemq.management.StatsCapable;
0: import org.apache.activemq.management.StatsImpl;
0: import org.apache.activemq.thread.Scheduler;
0: import org.apache.activemq.transaction.Synchronization;
0: import org.apache.activemq.util.Callback;
0: import org.apache.activemq.util.LongSequenceGenerator;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArrayList;
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean;
1: 
1: /**
1:  * <P>
1:  * A <CODE>Session</CODE> object is a single-threaded context for producing
1:  * and consuming messages. Although it may allocate provider resources outside
1:  * the Java virtual machine (JVM), it is considered a lightweight JMS object.
1:  * <P>
1:  * A session serves several purposes:
1:  * <UL>
1:  * <LI>It is a factory for its message producers and consumers.
1:  * <LI>It supplies provider-optimized message factories.
0:  * <LI>It is a factory for <CODE>TemporaryTopics</CODE> and <CODE>TemporaryQueues</CODE>.
1:  * <LI>It provides a way to create <CODE>Queue</CODE> or <CODE>Topic</CODE>
1:  * objects for those clients that need to dynamically manipulate
1:  * provider-specific destination names.
1:  * <LI>It supports a single series of transactions that combine work spanning
1:  * its producers and consumers into atomic units.
1:  * <LI>It defines a serial order for the messages it consumes and the messages
1:  * it produces.
1:  * <LI>It retains messages it consumes until they have been acknowledged.
1:  * <LI>It serializes execution of message listeners registered with its message
1:  * consumers.
1:  * <LI>It is a factory for <CODE>QueueBrowsers</CODE>.
1:  * </UL>
1:  * <P>
1:  * A session can create and service multiple message producers and consumers.
1:  * <P>
0:  * One typical use is to have a thread block on a synchronous <CODE>MessageConsumer</CODE>
0:  * until a message arrives. The thread may then use one or more of the <CODE>Session</CODE>'s<CODE>MessageProducer</CODE>s.
1:  * <P>
1:  * If a client desires to have one thread produce messages while others consume
1:  * them, the client should use a separate session for its producing thread.
1:  * <P>
1:  * Once a connection has been started, any session with one or more registered
1:  * message listeners is dedicated to the thread of control that delivers
1:  * messages to it. It is erroneous for client code to use this session or any of
1:  * its constituent objects from another thread of control. The only exception to
1:  * this rule is the use of the session or connection <CODE>close</CODE>
1:  * method.
1:  * <P>
1:  * It should be easy for most clients to partition their work naturally into
1:  * sessions. This model allows clients to start simply and incrementally add
1:  * message processing complexity as their need for concurrency grows.
1:  * <P>
1:  * The <CODE>close</CODE> method is the only session method that can be called
1:  * while some other session method is being executed in another thread.
1:  * <P>
1:  * A session may be specified as transacted. Each transacted session supports a
1:  * single series of transactions. Each transaction groups a set of message sends
1:  * and a set of message receives into an atomic unit of work. In effect,
1:  * transactions organize a session's input message stream and output message
1:  * stream into series of atomic units. When a transaction commits, its atomic
1:  * unit of input is acknowledged and its associated atomic unit of output is
1:  * sent. If a transaction rollback is done, the transaction's sent messages are
1:  * destroyed and the session's input is automatically recovered.
1:  * <P>
1:  * The content of a transaction's input and output units is simply those
1:  * messages that have been produced and consumed within the session's current
1:  * transaction.
1:  * <P>
1:  * A transaction is completed using either its session's <CODE>commit</CODE>
1:  * method or its session's <CODE>rollback </CODE> method. The completion of a
1:  * session's current transaction automatically begins the next. The result is
1:  * that a transacted session always has a current transaction within which its
1:  * work is done.
1:  * <P>
1:  * The Java Transaction Service (JTS) or some other transaction monitor may be
1:  * used to combine a session's transaction with transactions on other resources
1:  * (databases, other JMS sessions, etc.). Since Java distributed transactions
1:  * are controlled via the Java Transaction API (JTA), use of the session's
1:  * <CODE>commit</CODE> and <CODE>rollback</CODE> methods in this context is
1:  * prohibited.
1:  * <P>
1:  * The JMS API does not require support for JTA; however, it does define how a
1:  * provider supplies this support.
1:  * <P>
1:  * Although it is also possible for a JMS client to handle distributed
1:  * transactions directly, it is unlikely that many JMS clients will do this.
1:  * Support for JTA in the JMS API is targeted at systems vendors who will be
1:  * integrating the JMS API into their application server products.
1:  * 
0:  * @version $Revision: 1.34 $
1:  * @see javax.jms.Session
1:  * @see javax.jms.QueueSession
1:  * @see javax.jms.TopicSession
1:  * @see javax.jms.XASession
1:  */
1: public class ActiveMQSession implements Session, QueueSession, TopicSession, StatsCapable, ActiveMQDispatcher {
1: 
1:     public static interface DeliveryListener {
0:         public void beforeDelivery(ActiveMQSession session, Message msg);
0:         public void afterDelivery(ActiveMQSession session, Message msg);
1:     }
1: 
0:     private static final Log log = LogFactory.getLog(ActiveMQSession.class);
1: 
1:     protected int acknowledgementMode;
1: 
0:     private MessageListener messageListener;
0:     private JMSSessionStatsImpl stats;
0:     private TransactionContext transactionContext;
0:     private DeliveryListener deliveryListener;
1:     
1:     protected final ActiveMQConnection connection;
1:     protected final SessionInfo info;
1:     protected final LongSequenceGenerator consumerIdGenerator = new LongSequenceGenerator();
1:     protected final LongSequenceGenerator producerIdGenerator = new LongSequenceGenerator();
1:     protected final LongSequenceGenerator deliveryIdGenerator = new LongSequenceGenerator();
0:     protected final ActiveMQSessionExecutor executor = new ActiveMQSessionExecutor(this);
1:     protected final AtomicBoolean started = new AtomicBoolean(false);
1:     
0:     protected final CopyOnWriteArrayList consumers = new CopyOnWriteArrayList();
0:     protected final CopyOnWriteArrayList producers = new CopyOnWriteArrayList();
1: 
1:     protected boolean closed;
1:     protected boolean asyncDispatch;
1: 
1:     /**
1:      * Construct the Session
1:      * 
1:      * @param connection
0:      * @param acknowledgeMode
0:      *            n.b if transacted - the acknowledgeMode ==
0:      *            Session.SESSION_TRANSACTED
1:      * @throws JMSException
0:      *             on internal error
1:      */
0:     protected ActiveMQSession(ActiveMQConnection connection, SessionId sessionId, int acknowledgeMode, boolean asyncDispatch)
0:             throws JMSException {
1: 
1:         this.connection = connection;
1:         this.acknowledgementMode = acknowledgeMode;
0:         this.asyncDispatch=asyncDispatch;
1:         
0:         this.info = new SessionInfo(connection.getConnectionInfo(), sessionId.getSessionId());
1:         setTransactionContext(new TransactionContext(connection));
0:         connection.addSession(this);
1:         stats = new JMSSessionStatsImpl(producers, consumers);
1:         this.connection.asyncSendPacket(info);
1:         
0:         if( connection.isStarted() )
1:             start();
1: 
1:     }
1: 
1:     /**
1:      * Sets the transaction context of the session.
1:      * 
0:      * @param transactionContext -
0:      *            provides the means to control a JMS transaction.
1:      */
1:     public void setTransactionContext(TransactionContext transactionContext) {
1:         this.transactionContext = transactionContext;
1:     }
1: 
1:     /**
1:      * Returns the transaction context of the session.
1:      * 
1:      * @return transactionContext - session's transaction context.
1:      */
1:     public TransactionContext getTransactionContext() {
1:         return transactionContext;
1:     }
1: 
1:     /*
1:      * (non-Javadoc)
1:      * 
1:      * @see org.apache.activemq.management.StatsCapable#getStats()
1:      */
1:     public StatsImpl getStats() {
1:         return stats;
1:     }
1: 
1:     /**
1:      * Returns the session's statistics.
1:      * 
1:      * @return stats - session's statistics.
1:      */
1:     public JMSSessionStatsImpl getSessionStats() {
1:         return stats;
1:     }
1: 
1:     /**
1:      * Creates a <CODE>BytesMessage</CODE> object. A <CODE>BytesMessage</CODE>
1:      * object is used to send a message containing a stream of uninterpreted
1:      * bytes.
1:      * 
1:      * @return the an ActiveMQBytesMessage
1:      * @throws JMSException
0:      *             if the JMS provider fails to create this message due to some
0:      *             internal error.
1:      */
1:     public BytesMessage createBytesMessage() throws JMSException {
1:         checkClosed();
1:         ActiveMQBytesMessage message = new ActiveMQBytesMessage();
1:         message.setConnection(connection);
1:         return message;
1:     }
1: 
1:     /**
1:      * Creates a <CODE>MapMessage</CODE> object. A <CODE>MapMessage</CODE>
1:      * object is used to send a self-defining set of name-value pairs, where
1:      * names are <CODE>String</CODE> objects and values are primitive values
1:      * in the Java programming language.
1:      * 
1:      * @return an ActiveMQMapMessage
1:      * @throws JMSException
0:      *             if the JMS provider fails to create this message due to some
0:      *             internal error.
1:      */
1:     public MapMessage createMapMessage() throws JMSException {
1:         checkClosed();
1:         ActiveMQMapMessage message = new ActiveMQMapMessage();
1:         message.setConnection(connection);
1:         return message;
1:     }
1: 
1:     /**
1:      * Creates a <CODE>Message</CODE> object. The <CODE>Message</CODE>
0:      * interface is the root interface of all JMS messages. A <CODE>Message</CODE>
0:      * object holds all the standard message header information. It can be sent
0:      * when a message containing only header information is sufficient.
1:      * 
1:      * @return an ActiveMQMessage
1:      * @throws JMSException
0:      *             if the JMS provider fails to create this message due to some
0:      *             internal error.
1:      */
1:     public Message createMessage() throws JMSException {
1:         checkClosed();
1:         ActiveMQMessage message = new ActiveMQMessage();
1:         message.setConnection(connection);
1:         return message;
1:     }
1: 
1:     /**
0:      * Creates an <CODE>ObjectMessage</CODE> object. An <CODE>ObjectMessage</CODE>
0:      * object is used to send a message that contains a serializable Java
1:      * object.
1:      * 
1:      * @return an ActiveMQObjectMessage
1:      * @throws JMSException
0:      *             if the JMS provider fails to create this message due to some
0:      *             internal error.
1:      */
1:     public ObjectMessage createObjectMessage() throws JMSException {
1:         checkClosed();
1:         ActiveMQObjectMessage message = new ActiveMQObjectMessage();
1:         message.setConnection(connection);
1:         return message;
1:     }
1: 
1:     /**
0:      * Creates an initialized <CODE>ObjectMessage</CODE> object. An <CODE>ObjectMessage</CODE>
0:      * object is used to send a message that contains a serializable Java
1:      * object.
1:      * 
0:      * @param object
0:      *            the object to use to initialize this message
1:      * @return an ActiveMQObjectMessage
1:      * @throws JMSException
0:      *             if the JMS provider fails to create this message due to some
0:      *             internal error.
1:      */
1:     public ObjectMessage createObjectMessage(Serializable object) throws JMSException {
1:         checkClosed();
1:         ActiveMQObjectMessage message = new ActiveMQObjectMessage();
1:         message.setConnection(connection);
1:         message.setObject(object);
1:         return message;
1:     }
1: 
1:     /**
0:      * Creates a <CODE>StreamMessage</CODE> object. A <CODE>StreamMessage</CODE>
0:      * object is used to send a self-defining stream of primitive values in the
0:      * Java programming language.
1:      * 
1:      * @return an ActiveMQStreamMessage
1:      * @throws JMSException
0:      *             if the JMS provider fails to create this message due to some
0:      *             internal error.
1:      */
1:     public StreamMessage createStreamMessage() throws JMSException {
1:         checkClosed();
1:         ActiveMQStreamMessage message = new ActiveMQStreamMessage();
1:         message.setConnection(connection);
1:         return message;
1:     }
1: 
1:     /**
1:      * Creates a <CODE>TextMessage</CODE> object. A <CODE>TextMessage</CODE>
1:      * object is used to send a message containing a <CODE>String</CODE>
1:      * object.
1:      * 
1:      * @return an ActiveMQTextMessage
1:      * @throws JMSException
0:      *             if the JMS provider fails to create this message due to some
0:      *             internal error.
1:      */
1:     public TextMessage createTextMessage() throws JMSException {
1:         checkClosed();
1:         ActiveMQTextMessage message = new ActiveMQTextMessage();
1:         message.setConnection(connection);
1:         return message;
1:     }
1: 
1:     /**
0:      * Creates an initialized <CODE>TextMessage</CODE> object. A <CODE>TextMessage</CODE>
0:      * object is used to send a message containing a <CODE>String</CODE>.
1:      * 
0:      * @param text
0:      *            the string used to initialize this message
1:      * @return an ActiveMQTextMessage
1:      * @throws JMSException
0:      *             if the JMS provider fails to create this message due to some
0:      *             internal error.
1:      */
1:     public TextMessage createTextMessage(String text) throws JMSException {
1:         checkClosed();
1:         ActiveMQTextMessage message = new ActiveMQTextMessage();
1:         message.setText(text);
1:         message.setConnection(connection);
1:         return message;
1:     }
1: 
1:     /**
1:      * Indicates whether the session is in transacted mode.
1:      * 
1:      * @return true if the session is in transacted mode
1:      * @throws JMSException
0:      *             if there is some internal error.
1:      */
1:     public boolean getTransacted() throws JMSException {
1:         checkClosed();
0:         return ((acknowledgementMode == Session.SESSION_TRANSACTED) || (transactionContext.isInXATransaction()));
1:     }
1: 
1:     /**
1:      * Returns the acknowledgement mode of the session. The acknowledgement mode
1:      * is set at the time that the session is created. If the session is
1:      * transacted, the acknowledgement mode is ignored.
1:      * 
1:      * @return If the session is not transacted, returns the current
1:      *         acknowledgement mode for the session. If the session is
1:      *         transacted, returns SESSION_TRANSACTED.
1:      * @throws JMSException
1:      * @see javax.jms.Connection#createSession(boolean,int)
1:      * @since 1.1 exception JMSException if there is some internal error.
1:      */
1:     public int getAcknowledgeMode() throws JMSException {
1:         checkClosed();
1:         return this.acknowledgementMode;
1:     }
1: 
1:     /**
1:      * Commits all messages done in this transaction and releases any locks
1:      * currently held.
1:      * 
1:      * @throws JMSException
0:      *             if the JMS provider fails to commit the transaction due to
0:      *             some internal error.
0:      * @throws TransactionRolledBackException
0:      *             if the transaction is rolled back due to some internal error
0:      *             during commit.
0:      * @throws javax.jms.IllegalStateException
0:      *             if the method is not called by a transacted session.
1:      */
1:     public void commit() throws JMSException {
1:         checkClosed();
1:         if (!getTransacted()) {
1:             throw new javax.jms.IllegalStateException("Not a transacted session");
1:         }
1:         transactionContext.commit();
1:     }
1: 
1:     /**
1:      * Rolls back any messages done in this transaction and releases any locks
1:      * currently held.
1:      * 
1:      * @throws JMSException
0:      *             if the JMS provider fails to roll back the transaction due to
0:      *             some internal error.
0:      * @throws javax.jms.IllegalStateException
0:      *             if the method is not called by a transacted session.
1:      */
1:     public void rollback() throws JMSException {
1:         checkClosed();
1:         if (!getTransacted()) {
1:             throw new javax.jms.IllegalStateException("Not a transacted session");
1:         }
1:         transactionContext.rollback();
1:     }
1:     
1:     /**
1:      * Closes the session.
1:      * <P>
1:      * Since a provider may allocate some resources on behalf of a session
1:      * outside the JVM, clients should close the resources when they are not
1:      * needed. Relying on garbage collection to eventually reclaim these
1:      * resources may not be timely enough.
1:      * <P>
1:      * There is no need to close the producers and consumers of a closed
1:      * session.
1:      * <P>
1:      * This call will block until a <CODE>receive</CODE> call or message
0:      * listener in progress has completed. A blocked message consumer <CODE>receive</CODE>
0:      * call returns <CODE>null</CODE> when this session is closed.
1:      * <P>
1:      * Closing a transacted session must roll back the transaction in progress.
1:      * <P>
1:      * This method is the only <CODE>Session</CODE> method that can be called
1:      * concurrently.
1:      * <P>
1:      * Invoking any other <CODE>Session</CODE> method on a closed session must
1:      * throw a <CODE> JMSException.IllegalStateException</CODE>. Closing a
1:      * closed session must <I>not </I> throw an exception.
1:      * 
1:      * @throws JMSException
0:      *             if the JMS provider fails to close the session due to some
0:      *             internal error.
1:      */
1:     public void close() throws JMSException {
1:         if (!closed) {
1:             dispose();
0:             connection.asyncSendPacket(info.createRemoveCommand());
1:         }
1:     }
1:     
1: 
0:     public void dispose() throws JMSException {
1:         if (!closed) {
1:             
0:             for (Iterator iter = consumers.iterator(); iter.hasNext();) {
0:                 ActiveMQMessageConsumer consumer = (ActiveMQMessageConsumer) iter.next();
1:                 consumer.dispose();
1:             }
1:             consumers.clear();
1: 
0:             for (Iterator iter = producers.iterator(); iter.hasNext();) {
0:                 ActiveMQMessageProducer producer = (ActiveMQMessageProducer) iter.next();
1:                 producer.dispose();
1:             }
1:             producers.clear();
1:             
1:             try {
1:                 if (getTransactionContext().isInLocalTransaction()) {
1:                     rollback();
1:                 }
1:             } catch (JMSException e) {
1:             }
1:             
1:             
1:             connection.removeSession(this);
0:             this.transactionContext=null;
1:             closed = true;
1:         }
1:     }
1: 
1:     /**
1:      * Check if the session is closed. It is used for ensuring that the session
1:      * is open before performing various operations.
1:      * 
0:      * @throws IllegalStateException
0:      *             if the Session is closed
1:      */
1:     protected void checkClosed() throws IllegalStateException {
1:         if (closed) {
1:             throw new IllegalStateException("The Session is closed");
1:         }
1:     }
1: 
1:     /**
1:      * Stops message delivery in this session, and restarts message delivery
1:      * with the oldest unacknowledged message.
1:      * <P>
1:      * All consumers deliver messages in a serial order. Acknowledging a
1:      * received message automatically acknowledges all messages that have been
1:      * delivered to the client.
1:      * <P>
1:      * Restarting a session causes it to take the following actions:
1:      * <UL>
1:      * <LI>Stop message delivery
1:      * <LI>Mark all messages that might have been delivered but not
1:      * acknowledged as "redelivered"
1:      * <LI>Restart the delivery sequence including all unacknowledged messages
1:      * that had been previously delivered. Redelivered messages do not have to
1:      * be delivered in exactly their original delivery order.
1:      * </UL>
1:      * 
1:      * @throws JMSException
0:      *             if the JMS provider fails to stop and restart message
0:      *             delivery due to some internal error.
0:      * @throws IllegalStateException
0:      *             if the method is called by a transacted session.
1:      */
1:     public void recover() throws JMSException {
1: 
1:         checkClosed();
1:         if (getTransacted()) {
1:             throw new IllegalStateException("This session is transacted");
1:         }
1: 
0:         for (Iterator iter = consumers.iterator(); iter.hasNext();) {
0:             ActiveMQMessageConsumer c = (ActiveMQMessageConsumer) iter.next();
1:             c.rollback();
1:         }
1: 
1:     }
1: 
1:     /**
1:      * Returns the session's distinguished message listener (optional).
1:      * 
1:      * @return the message listener associated with this session
1:      * @throws JMSException
0:      *             if the JMS provider fails to get the message listener due to
0:      *             an internal error.
1:      * @see javax.jms.Session#setMessageListener(javax.jms.MessageListener)
1:      * @see javax.jms.ServerSessionPool
1:      * @see javax.jms.ServerSession
1:      */
1:     public MessageListener getMessageListener() throws JMSException {
1:         checkClosed();
1:         return this.messageListener;
1:     }
1: 
1:     /**
1:      * Sets the session's distinguished message listener (optional).
1:      * <P>
1:      * When the distinguished message listener is set, no other form of message
1:      * receipt in the session can be used; however, all forms of sending
1:      * messages are still supported.
1:      * <P>
1:      * This is an expert facility not used by regular JMS clients.
1:      * 
0:      * @param listener
0:      *            the message listener to associate with this session
1:      * @throws JMSException
0:      *             if the JMS provider fails to set the message listener due to
0:      *             an internal error.
1:      * @see javax.jms.Session#getMessageListener()
1:      * @see javax.jms.ServerSessionPool
1:      * @see javax.jms.ServerSession
1:      */
1:     public void setMessageListener(MessageListener listener) throws JMSException {
1:         checkClosed();
1:         this.messageListener = listener;
1: 
1:         if (listener != null) {
1:             executor.setDispatchedBySessionPool(true);
1:         }
1:     }
1: 
1:     /**
1:      * Optional operation, intended to be used only by Application Servers, not
1:      * by ordinary JMS clients.
1:      * 
1:      * @see javax.jms.ServerSession
1:      */
0:     public void run() {
1:         MessageDispatch messageDispatch;
1:         while ((messageDispatch = executor.dequeueNoWait()) != null) {
1:             final MessageDispatch md = messageDispatch;
0:             ActiveMQMessage message = (ActiveMQMessage)md.getMessage();
0:             if( message.isExpired() ) {
0:                 //TODO: Ack it without delivery to client
0:                 continue;
1:             }
1:             
0:             if( isClientAcknowledge() ) {
1:                 message.setAcknowledgeCallback(new Callback() {
0:                     public void execute() throws Throwable {
1:                     }
1:                 });
1:             }
1:             
1:             if (deliveryListener != null) {
1:                 deliveryListener.beforeDelivery(this, message);
1:             }
1: 
0:             md.setDeliverySequenceId(getNextDeliveryId());            
1: 
1:             try { 
0:                 messageListener.onMessage(message);
0:             } catch ( Throwable e ) {  
0:                 // TODO: figure out proper way to handle error.
1:             }
1: 
1:             try {
0:                 MessageAck ack = new MessageAck(md,MessageAck.STANDARD_ACK_TYPE,1);
0:                 ack.setFirstMessageId(md.getMessage().getMessageId());
0:                 doStartTransaction();
0:                 ack.setTransactionId(getTransactionContext().getTransactionId());
0:                 if( ack.getTransactionId()!=null ) {
0:                     getTransactionContext().addSynchronization(new Synchronization(){
0:                         public void afterRollback() throws Throwable {
1: 
0:                             md.getMessage().incrementRedeliveryCounter();
1:                             
0:                             RedeliveryPolicy redeliveryPolicy = connection.getRedeliveryPolicy();
0:                             int redeliveryCounter = md.getMessage().getRedeliveryCounter();
0:                             if (redeliveryCounter > redeliveryPolicy.getMaximumRedeliveries()) {
1:                                 
0:                                 // We need to NACK the messages so that they get sent to the
0:                                 // DLQ.
1: 
0:                                 // Acknowledge the last message.
0:                                 MessageAck ack = new MessageAck(md,MessageAck.POSION_ACK_TYPE,1);
0:                                 ack.setFirstMessageId(md.getMessage().getMessageId());
0:                                 asyncSendPacket(ack);
1: 
0:                             } else {
1:                                 
0:                                 // Figure out how long we should wait to resend this message.
0:                                 long redeliveryDelay=0;
0:                                 for( int i=0; i < redeliveryCounter; i++) {
0:                                     if (redeliveryDelay == 0) {
0:                                         redeliveryDelay = redeliveryPolicy.getInitialRedeliveryDelay();
0:                                     } else {
0:                                         if (redeliveryPolicy.isUseExponentialBackOff())
0:                                             redeliveryDelay *= redeliveryPolicy.getBackOffMultiplier();
1:                                     }
1:                                 }
1:                                 
0:                                 Scheduler.executeAfterDelay(new Runnable() {
0:                                     public void run() {
0:                                         ((ActiveMQDispatcher)md.getConsumer()).dispatch(md);
1:                                     }
0:                                 }, redeliveryDelay);
1:                                 
1:                             }
1:                         }
1:                     });
1:                 }
0:                 asyncSendPacket(ack);
0:             } catch ( Throwable e ) {
0:                 connection.onAsyncException(e);
1:             }
1: 
1:             if (deliveryListener != null) {
0:                 deliveryListener.afterDelivery(this, message);
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Creates a <CODE>MessageProducer</CODE> to send messages to the
1:      * specified destination.
1:      * <P>
1:      * A client uses a <CODE>MessageProducer</CODE> object to send messages to
1:      * a destination. Since <CODE>Queue </CODE> and <CODE>Topic</CODE> both
1:      * inherit from <CODE>Destination</CODE>, they can be used in the
1:      * destination parameter to create a <CODE>MessageProducer</CODE> object.
1:      * 
0:      * @param destination
0:      *            the <CODE>Destination</CODE> to send to, or null if this is
0:      *            a producer which does not have a specified destination.
1:      * @return the MessageProducer
1:      * @throws JMSException
0:      *             if the session fails to create a MessageProducer due to some
0:      *             internal error.
0:      * @throws InvalidDestinationException
0:      *             if an invalid destination is specified.
1:      * @since 1.1
1:      */
1:     public MessageProducer createProducer(Destination destination) throws JMSException {
1:         checkClosed();
0:         return new ActiveMQMessageProducer(this, getNextProducerId(), ActiveMQMessageTransformation
0:                 .transformDestination(destination));
1:     }
1: 
1:     /**
1:      * Creates a <CODE>MessageConsumer</CODE> for the specified destination.
1:      * Since <CODE>Queue</CODE> and <CODE> Topic</CODE> both inherit from
1:      * <CODE>Destination</CODE>, they can be used in the destination
1:      * parameter to create a <CODE>MessageConsumer</CODE>.
1:      * 
0:      * @param destination
0:      *            the <CODE>Destination</CODE> to access.
1:      * @return the MessageConsumer
1:      * @throws JMSException
0:      *             if the session fails to create a consumer due to some
0:      *             internal error.
0:      * @throws InvalidDestinationException
0:      *             if an invalid destination is specified.
1:      * @since 1.1
1:      */
1:     public MessageConsumer createConsumer(Destination destination) throws JMSException {
1:         checkClosed();
0:         return createConsumer(destination, null);
1:     }
1: 
1:     /**
1:      * Creates a <CODE>MessageConsumer</CODE> for the specified destination,
0:      * using a message selector. Since <CODE> Queue</CODE> and <CODE>Topic</CODE>
0:      * both inherit from <CODE>Destination</CODE>, they can be used in the
0:      * destination parameter to create a <CODE>MessageConsumer</CODE>.
1:      * <P>
1:      * A client uses a <CODE>MessageConsumer</CODE> object to receive messages
1:      * that have been sent to a destination.
1:      * 
0:      * @param destination
0:      *            the <CODE>Destination</CODE> to access
0:      * @param messageSelector
0:      *            only messages with properties matching the message selector
0:      *            expression are delivered. A value of null or an empty string
0:      *            indicates that there is no message selector for the message
0:      *            consumer.
1:      * @return the MessageConsumer
1:      * @throws JMSException
0:      *             if the session fails to create a MessageConsumer due to some
0:      *             internal error.
0:      * @throws InvalidDestinationException
0:      *             if an invalid destination is specified.
0:      * @throws InvalidSelectorException
0:      *             if the message selector is invalid.
1:      * @since 1.1
1:      */
1:     public MessageConsumer createConsumer(Destination destination, String messageSelector) throws JMSException {
1:         checkClosed();
1:         int prefetch = 0;
1: 
1:         if (destination instanceof Topic) {
0:             prefetch = connection.getPrefetchPolicy().getTopicPrefetch();
0:         } else {
0:             prefetch = connection.getPrefetchPolicy().getQueuePrefetch();
1:         }
1: 
0:         return new ActiveMQMessageConsumer(this, getNextConsumerId(), ActiveMQMessageTransformation
0:                 .transformDestination(destination), null, messageSelector, prefetch, false, false, asyncDispatch);
1:     }
1: 
1:     /**
0:      * @return
1:      */
1:     protected ConsumerId getNextConsumerId() {
1:         return new ConsumerId(info.getSessionId(), consumerIdGenerator.getNextSequenceId());
1:     }
1: 
1:     /**
0:      * @return
1:      */
1:     protected ProducerId getNextProducerId() {
1:         return new ProducerId(info.getSessionId(), producerIdGenerator.getNextSequenceId());
1:     }
1: 
1:     /**
1:      * Creates <CODE>MessageConsumer</CODE> for the specified destination,
1:      * using a message selector. This method can specify whether messages
1:      * published by its own connection should be delivered to it, if the
1:      * destination is a topic.
1:      * <P>
1:      * Since <CODE>Queue</CODE> and <CODE>Topic</CODE> both inherit from
1:      * <CODE>Destination</CODE>, they can be used in the destination
1:      * parameter to create a <CODE>MessageConsumer</CODE>.
1:      * <P>
1:      * A client uses a <CODE>MessageConsumer</CODE> object to receive messages
1:      * that have been published to a destination.
1:      * <P>
1:      * In some cases, a connection may both publish and subscribe to a topic.
1:      * The consumer <CODE>NoLocal</CODE> attribute allows a consumer to
1:      * inhibit the delivery of messages published by its own connection. The
1:      * default value for this attribute is False. The <CODE>noLocal</CODE>
1:      * value must be supported by destinations that are topics.
1:      * 
0:      * @param destination
0:      *            the <CODE>Destination</CODE> to access
0:      * @param messageSelector
0:      *            only messages with properties matching the message selector
0:      *            expression are delivered. A value of null or an empty string
0:      *            indicates that there is no message selector for the message
0:      *            consumer.
0:      * @param NoLocal -
0:      *            if true, and the destination is a topic, inhibits the delivery
0:      *            of messages published by its own connection. The behavior for
0:      *            <CODE>NoLocal</CODE> is not specified if the destination is
0:      *            a queue.
1:      * @return the MessageConsumer
1:      * @throws JMSException
0:      *             if the session fails to create a MessageConsumer due to some
0:      *             internal error.
0:      * @throws InvalidDestinationException
0:      *             if an invalid destination is specified.
0:      * @throws InvalidSelectorException
0:      *             if the message selector is invalid.
1:      * @since 1.1
1:      */
0:     public MessageConsumer createConsumer(Destination destination, String messageSelector, boolean NoLocal)
0:             throws JMSException {
1:         checkClosed();
0:         return new ActiveMQMessageConsumer(this, getNextConsumerId(), ActiveMQMessageTransformation
0:                 .transformDestination(destination), null, messageSelector, connection.getPrefetchPolicy()
0:                 .getTopicPrefetch(), NoLocal, false, asyncDispatch);
1:     }
1: 
1:     /**
1:      * Creates a queue identity given a <CODE>Queue</CODE> name.
1:      * <P>
1:      * This facility is provided for the rare cases where clients need to
1:      * dynamically manipulate queue identity. It allows the creation of a queue
1:      * identity with a provider-specific name. Clients that depend on this
1:      * ability are not portable.
1:      * <P>
1:      * Note that this method is not for creating the physical queue. The
1:      * physical creation of queues is an administrative task and is not to be
1:      * initiated by the JMS API. The one exception is the creation of temporary
1:      * queues, which is accomplished with the <CODE>createTemporaryQueue</CODE>
1:      * method.
1:      * 
0:      * @param queueName
0:      *            the name of this <CODE>Queue</CODE>
1:      * @return a <CODE>Queue</CODE> with the given name
1:      * @throws JMSException
0:      *             if the session fails to create a queue due to some internal
0:      *             error.
1:      * @since 1.1
1:      */
1:     public Queue createQueue(String queueName) throws JMSException {
1:         checkClosed();
1:         return new ActiveMQQueue(queueName);
1:     }
1: 
1:     /**
1:      * Creates a topic identity given a <CODE>Topic</CODE> name.
1:      * <P>
1:      * This facility is provided for the rare cases where clients need to
1:      * dynamically manipulate topic identity. This allows the creation of a
1:      * topic identity with a provider-specific name. Clients that depend on this
1:      * ability are not portable.
1:      * <P>
1:      * Note that this method is not for creating the physical topic. The
1:      * physical creation of topics is an administrative task and is not to be
1:      * initiated by the JMS API. The one exception is the creation of temporary
1:      * topics, which is accomplished with the <CODE>createTemporaryTopic</CODE>
1:      * method.
1:      * 
0:      * @param topicName
0:      *            the name of this <CODE>Topic</CODE>
1:      * @return a <CODE>Topic</CODE> with the given name
1:      * @throws JMSException
0:      *             if the session fails to create a topic due to some internal
0:      *             error.
1:      * @since 1.1
1:      */
1:     public Topic createTopic(String topicName) throws JMSException {
1:         checkClosed();
1:         return new ActiveMQTopic(topicName);
1:     }
1: 
1:     /**
1:      * Creates a <CODE>QueueBrowser</CODE> object to peek at the messages on
1:      * the specified queue.
1:      * 
0:      * @param queue
0:      *            the <CODE>queue</CODE> to access
0:      * @exception InvalidDestinationException
0:      *                if an invalid destination is specified
1:      * @since 1.1
1:      */
1:     /**
1:      * Creates a durable subscriber to the specified topic.
1:      * <P>
1:      * If a client needs to receive all the messages published on a topic,
1:      * including the ones published while the subscriber is inactive, it uses a
1:      * durable <CODE>TopicSubscriber</CODE>. The JMS provider retains a
1:      * record of this durable subscription and insures that all messages from
1:      * the topic's publishers are retained until they are acknowledged by this
1:      * durable subscriber or they have expired.
1:      * <P>
1:      * Sessions with durable subscribers must always provide the same client
1:      * identifier. In addition, each client must specify a name that uniquely
1:      * identifies (within client identifier) each durable subscription it
0:      * creates. Only one session at a time can have a <CODE>TopicSubscriber</CODE>
0:      * for a particular durable subscription.
1:      * <P>
1:      * A client can change an existing durable subscription by creating a
1:      * durable <CODE>TopicSubscriber</CODE> with the same name and a new topic
1:      * and/or message selector. Changing a durable subscriber is equivalent to
1:      * unsubscribing (deleting) the old one and creating a new one.
1:      * <P>
1:      * In some cases, a connection may both publish and subscribe to a topic.
1:      * The subscriber <CODE>NoLocal</CODE> attribute allows a subscriber to
1:      * inhibit the delivery of messages published by its own connection. The
1:      * default value for this attribute is false.
1:      * 
0:      * @param topic
0:      *            the non-temporary <CODE>Topic</CODE> to subscribe to
0:      * @param name
0:      *            the name used to identify this subscription
1:      * @return the TopicSubscriber
1:      * @throws JMSException
0:      *             if the session fails to create a subscriber due to some
0:      *             internal error.
0:      * @throws InvalidDestinationException
0:      *             if an invalid topic is specified.
1:      * @since 1.1
1:      */
1:     public TopicSubscriber createDurableSubscriber(Topic topic, String name) throws JMSException {
1:         checkClosed();
1:         return createDurableSubscriber(topic, name, null, false);
1:     }
1: 
1:     /**
1:      * Creates a durable subscriber to the specified topic, using a message
1:      * selector and specifying whether messages published by its own connection
1:      * should be delivered to it.
1:      * <P>
1:      * If a client needs to receive all the messages published on a topic,
1:      * including the ones published while the subscriber is inactive, it uses a
1:      * durable <CODE>TopicSubscriber</CODE>. The JMS provider retains a
1:      * record of this durable subscription and insures that all messages from
1:      * the topic's publishers are retained until they are acknowledged by this
1:      * durable subscriber or they have expired.
1:      * <P>
1:      * Sessions with durable subscribers must always provide the same client
1:      * identifier. In addition, each client must specify a name which uniquely
1:      * identifies (within client identifier) each durable subscription it
0:      * creates. Only one session at a time can have a <CODE>TopicSubscriber</CODE>
0:      * for a particular durable subscription. An inactive durable subscriber is
0:      * one that exists but does not currently have a message consumer associated
0:      * with it.
1:      * <P>
1:      * A client can change an existing durable subscription by creating a
1:      * durable <CODE>TopicSubscriber</CODE> with the same name and a new topic
1:      * and/or message selector. Changing a durable subscriber is equivalent to
1:      * unsubscribing (deleting) the old one and creating a new one.
1:      * 
0:      * @param topic
0:      *            the non-temporary <CODE>Topic</CODE> to subscribe to
0:      * @param name
0:      *            the name used to identify this subscription
0:      * @param messageSelector
0:      *            only messages with properties matching the message selector
0:      *            expression are delivered. A value of null or an empty string
0:      *            indicates that there is no message selector for the message
0:      *            consumer.
0:      * @param noLocal
0:      *            if set, inhibits the delivery of messages published by its own
0:      *            connection
1:      * @return the Queue Browser
1:      * @throws JMSException
0:      *             if the session fails to create a subscriber due to some
0:      *             internal error.
0:      * @throws InvalidDestinationException
0:      *             if an invalid topic is specified.
0:      * @throws InvalidSelectorException
0:      *             if the message selector is invalid.
1:      * @since 1.1
1:      */
0:     public TopicSubscriber createDurableSubscriber(Topic topic, String name, String messageSelector, boolean noLocal)
0:             throws JMSException {
1:         checkClosed();
1:         connection.checkClientIDWasManuallySpecified();
0:         return new ActiveMQTopicSubscriber(this, getNextConsumerId(), ActiveMQMessageTransformation
0:                 .transformDestination(topic), name, messageSelector, this.connection.getPrefetchPolicy()
0:                 .getDurableTopicPrefetch(), noLocal, false, asyncDispatch);
1:     }
1: 
1:     /**
1:      * Creates a <CODE>QueueBrowser</CODE> object to peek at the messages on
1:      * the specified queue.
1:      * 
0:      * @param queue
0:      *            the <CODE>queue</CODE> to access
1:      * @return the Queue Browser
1:      * @throws JMSException
0:      *             if the session fails to create a browser due to some internal
0:      *             error.
0:      * @throws InvalidDestinationException
0:      *             if an invalid destination is specified
1:      * @since 1.1
1:      */
1:     public QueueBrowser createBrowser(Queue queue) throws JMSException {
1:         checkClosed();
1:         return createBrowser(queue, null);
1:     }
1: 
1:     /**
1:      * Creates a <CODE>QueueBrowser</CODE> object to peek at the messages on
1:      * the specified queue using a message selector.
1:      * 
0:      * @param queue
0:      *            the <CODE>queue</CODE> to access
0:      * @param messageSelector
0:      *            only messages with properties matching the message selector
0:      *            expression are delivered. A value of null or an empty string
0:      *            indicates that there is no message selector for the message
0:      *            consumer.
1:      * @return the Queue Browser
1:      * @throws JMSException
0:      *             if the session fails to create a browser due to some internal
0:      *             error.
0:      * @throws InvalidDestinationException
0:      *             if an invalid destination is specified
0:      * @throws InvalidSelectorException
0:      *             if the message selector is invalid.
1:      * @since 1.1
1:      */
1:     public QueueBrowser createBrowser(Queue queue, String messageSelector) throws JMSException {
1:         checkClosed();
0:         return new ActiveMQQueueBrowser(this, getNextConsumerId(), ActiveMQMessageTransformation
0:                 .transformDestination(queue), messageSelector, asyncDispatch);
1:     }
1: 
1:     /**
1:      * Creates a <CODE>TemporaryQueue</CODE> object. Its lifetime will be that
1:      * of the <CODE>Connection</CODE> unless it is deleted earlier.
1:      * 
1:      * @return a temporary queue identity
1:      * @throws JMSException
0:      *             if the session fails to create a temporary queue due to some
0:      *             internal error.
1:      * @since 1.1
1:      */
1:     public TemporaryQueue createTemporaryQueue() throws JMSException {
1:         checkClosed();
0:         return (TemporaryQueue) connection.createTempDestination(false);
1:     }
1: 
1:     /**
1:      * Creates a <CODE>TemporaryTopic</CODE> object. Its lifetime will be that
1:      * of the <CODE>Connection</CODE> unless it is deleted earlier.
1:      * 
1:      * @return a temporary topic identity
1:      * @throws JMSException
0:      *             if the session fails to create a temporary topic due to some
0:      *             internal error.
1:      * @since 1.1
1:      */
1:     public TemporaryTopic createTemporaryTopic() throws JMSException {
1:         checkClosed();
1:         return (TemporaryTopic)connection.createTempDestination(true);
1:     }
1: 
1:     /**
1:      * Creates a <CODE>QueueReceiver</CODE> object to receive messages from
1:      * the specified queue.
1:      * 
0:      * @param queue
0:      *            the <CODE>Queue</CODE> to access
0:      * @return
1:      * @throws JMSException
0:      *             if the session fails to create a receiver due to some
0:      *             internal error.
1:      * @throws JMSException
0:      * @throws InvalidDestinationException
0:      *             if an invalid queue is specified.
1:      */
1:     public QueueReceiver createReceiver(Queue queue) throws JMSException {
1:         checkClosed();
1:         return createReceiver(queue, null);
1:     }
1: 
1:     /**
1:      * Creates a <CODE>QueueReceiver</CODE> object to receive messages from
1:      * the specified queue using a message selector.
1:      * 
0:      * @param queue
0:      *            the <CODE>Queue</CODE> to access
0:      * @param messageSelector
0:      *            only messages with properties matching the message selector
0:      *            expression are delivered. A value of null or an empty string
0:      *            indicates that there is no message selector for the message
0:      *            consumer.
1:      * @return QueueReceiver
1:      * @throws JMSException
0:      *             if the session fails to create a receiver due to some
0:      *             internal error.
0:      * @throws InvalidDestinationException
0:      *             if an invalid queue is specified.
0:      * @throws InvalidSelectorException
0:      *             if the message selector is invalid.
1:      */
1:     public QueueReceiver createReceiver(Queue queue, String messageSelector) throws JMSException {
1:         checkClosed();
0:         return new ActiveMQQueueReceiver(this, getNextConsumerId(), ActiveMQMessageTransformation
0:                 .transformDestination(queue), messageSelector, this.connection.getPrefetchPolicy().getQueuePrefetch(), asyncDispatch);
1:     }
1: 
1:     /**
1:      * Creates a <CODE>QueueSender</CODE> object to send messages to the
1:      * specified queue.
1:      * 
0:      * @param queue
0:      *            the <CODE>Queue</CODE> to access, or null if this is an
0:      *            unidentified producer
1:      * @return QueueSender
1:      * @throws JMSException
0:      *             if the session fails to create a sender due to some internal
0:      *             error.
0:      * @throws InvalidDestinationException
0:      *             if an invalid queue is specified.
1:      */
1:     public QueueSender createSender(Queue queue) throws JMSException {
1:         checkClosed();
0:         return new ActiveMQQueueSender(this, ActiveMQMessageTransformation.transformDestination(queue));
1:     }
1: 
1:     /**
1:      * Creates a nondurable subscriber to the specified topic. <p/>
1:      * <P>
1:      * A client uses a <CODE>TopicSubscriber</CODE> object to receive messages
1:      * that have been published to a topic. <p/>
1:      * <P>
1:      * Regular <CODE>TopicSubscriber</CODE> objects are not durable. They
1:      * receive only messages that are published while they are active. <p/>
1:      * <P>
1:      * In some cases, a connection may both publish and subscribe to a topic.
1:      * The subscriber <CODE>NoLocal</CODE> attribute allows a subscriber to
1:      * inhibit the delivery of messages published by its own connection. The
1:      * default value for this attribute is false.
1:      * 
0:      * @param topic
0:      *            the <CODE>Topic</CODE> to subscribe to
1:      * @return TopicSubscriber
1:      * @throws JMSException
0:      *             if the session fails to create a subscriber due to some
0:      *             internal error.
0:      * @throws InvalidDestinationException
0:      *             if an invalid topic is specified.
1:      */
1:     public TopicSubscriber createSubscriber(Topic topic) throws JMSException {
1:         checkClosed();
1:         return createSubscriber(topic, null, false);
1:     }
1: 
1:     /**
1:      * Creates a nondurable subscriber to the specified topic, using a message
1:      * selector or specifying whether messages published by its own connection
1:      * should be delivered to it. <p/>
1:      * <P>
1:      * A client uses a <CODE>TopicSubscriber</CODE> object to receive messages
1:      * that have been published to a topic. <p/>
1:      * <P>
1:      * Regular <CODE>TopicSubscriber</CODE> objects are not durable. They
1:      * receive only messages that are published while they are active. <p/>
1:      * <P>
1:      * Messages filtered out by a subscriber's message selector will never be
1:      * delivered to the subscriber. From the subscriber's perspective, they do
1:      * not exist. <p/>
1:      * <P>
1:      * In some cases, a connection may both publish and subscribe to a topic.
1:      * The subscriber <CODE>NoLocal</CODE> attribute allows a subscriber to
1:      * inhibit the delivery of messages published by its own connection. The
1:      * default value for this attribute is false.
1:      * 
0:      * @param topic
0:      *            the <CODE>Topic</CODE> to subscribe to
0:      * @param messageSelector
0:      *            only messages with properties matching the message selector
0:      *            expression are delivered. A value of null or an empty string
0:      *            indicates that there is no message selector for the message
0:      *            consumer.
0:      * @param noLocal
0:      *            if set, inhibits the delivery of messages published by its own
0:      *            connection
1:      * @return TopicSubscriber
1:      * @throws JMSException
0:      *             if the session fails to create a subscriber due to some
0:      *             internal error.
0:      * @throws InvalidDestinationException
0:      *             if an invalid topic is specified.
0:      * @throws InvalidSelectorException
0:      *             if the message selector is invalid.
1:      */
1:     public TopicSubscriber createSubscriber(Topic topic, String messageSelector, boolean noLocal) throws JMSException {
1:         checkClosed();
0:         return new ActiveMQTopicSubscriber(this, getNextConsumerId(), ActiveMQMessageTransformation
0:                 .transformDestination(topic), null, messageSelector, this.connection.getPrefetchPolicy()
0:                 .getTopicPrefetch(), noLocal, false, asyncDispatch);
1:     }
1: 
1:     /**
1:      * Creates a publisher for the specified topic. <p/>
1:      * <P>
1:      * A client uses a <CODE>TopicPublisher</CODE> object to publish messages
1:      * on a topic. Each time a client creates a <CODE>TopicPublisher</CODE> on
1:      * a topic, it defines a new sequence of messages that have no ordering
1:      * relationship with the messages it has previously sent.
1:      * 
0:      * @param topic
0:      *            the <CODE>Topic</CODE> to publish to, or null if this is an
0:      *            unidentified producer
1:      * @return TopicPublisher
1:      * @throws JMSException
0:      *             if the session fails to create a publisher due to some
0:      *             internal error.
0:      * @throws InvalidDestinationException
0:      *             if an invalid topic is specified.
1:      */
1:     public TopicPublisher createPublisher(Topic topic) throws JMSException {
1:         checkClosed();
0:         return new ActiveMQTopicPublisher(this, ActiveMQMessageTransformation.transformDestination(topic));
1:     }
1: 
1:     /**
1:      * Unsubscribes a durable subscription that has been created by a client.
1:      * <P>
1:      * This method deletes the state being maintained on behalf of the
1:      * subscriber by its provider.
1:      * <P>
1:      * It is erroneous for a client to delete a durable subscription while there
0:      * is an active <CODE>MessageConsumer </CODE> or <CODE>TopicSubscriber</CODE>
0:      * for the subscription, or while a consumed message is part of a pending
0:      * transaction or has not been acknowledged in the session.
1:      * 
0:      * @param name
0:      *            the name used to identify this subscription
1:      * @throws JMSException
0:      *             if the session fails to unsubscribe to the durable
0:      *             subscription due to some internal error.
0:      * @throws InvalidDestinationException
0:      *             if an invalid subscription name is specified.
1:      * @since 1.1
1:      */
1:     public void unsubscribe(String name) throws JMSException {
1:         checkClosed();
1:         connection.unsubscribe(name);
1:     }
1: 
1:     
1:     public void dispatch(MessageDispatch messageDispatch) {
1:         try {
1:             executor.execute(messageDispatch);
1:         } catch (InterruptedException e) {
0:             connection.onAsyncException(e);
1:         }
1:     }
1:     
1:     
1:     
1:     /**
1:      * Acknowledges all consumed messages of the session of this consumed
1:      * message.
1:      * <P>
1:      * All consumed JMS messages support the <CODE>acknowledge</CODE> method
1:      * for use when a client has specified that its JMS session's consumed
0:      * messages are to be explicitly acknowledged. By invoking <CODE>acknowledge</CODE>
0:      * on a consumed message, a client acknowledges all messages consumed by the
0:      * session that the message was delivered to.
1:      * <P>
1:      * Calls to <CODE>acknowledge</CODE> are ignored for both transacted
1:      * sessions and sessions specified to use implicit acknowledgement modes.
1:      * <P>
1:      * A client may individually acknowledge each message as it is consumed, or
1:      * it may choose to acknowledge messages as an application-defined group
1:      * (which is done by calling acknowledge on the last received message of the
1:      * group, thereby acknowledging all messages consumed by the session.)
1:      * <P>
1:      * Messages that have been received but not acknowledged may be redelivered.
1:      * 
0:      * @param caller -
0:      *            the message calling acknowledge on the session
1:      * 
1:      * @throws JMSException
0:      *             if the JMS provider fails to acknowledge the messages due to
0:      *             some internal error.
0:      * @throws javax.jms.IllegalStateException
0:      *             if this method is called on a closed session.
1:      * @see javax.jms.Session#CLIENT_ACKNOWLEDGE
1:      */
1:     public void acknowledge() throws JMSException {
0:         for (Iterator iter = consumers.iterator(); iter.hasNext();) {
0:             ActiveMQMessageConsumer c = (ActiveMQMessageConsumer) iter.next();
1:             c.acknowledge();
1:         }
1:     }
1: 
1:    
1:     /**
1:      * Add a message consumer.
0:      * @param id 
1:      * 
0:      * @param consumer -
0:      *            message consumer.
1:      * @throws JMSException
1:      */
1:     protected void addConsumer(ActiveMQMessageConsumer consumer) throws JMSException {
1:         this.consumers.add(consumer);
1:         if (consumer.isDurableSubscriber()) {
1:             stats.onCreateDurableSubscriber();
1:         }
1:         this.connection.addDispatcher(consumer.getConsumerId(), this);
1:     }
1: 
1:     /**
1:      * Remove the message consumer.
1:      * 
0:      * @param consumer -
0:      *            consumer to be removed.
1:      * @throws JMSException
1:      */
1:     protected void removeConsumer(ActiveMQMessageConsumer consumer) {
1:         this.connection.removeDispatcher(consumer.getConsumerId());
1:         if (consumer.isDurableSubscriber()) {
1:             stats.onRemoveDurableSubscriber();
1:         }
1:         this.consumers.remove(consumer);
1:     }
1: 
1:     /**
1:      * Adds a message producer.
1:      * 
0:      * @param producer -
0:      *            message producer to be added.
1:      * @throws JMSException
1:      */
1:     protected void addProducer(ActiveMQMessageProducer producer) throws JMSException {
1:         this.producers.add(producer);
1:     }
1: 
1:     /**
1:      * Removes a message producer.
1:      * 
0:      * @param producer -
0:      *            message producer to be removed.
1:      * @throws JMSException
1:      */
1:     protected void removeProducer(ActiveMQMessageProducer producer) {
1:         this.producers.remove(producer);
1:     }
1: 
1:     /**
1:      * Start this Session.
1:      * 
1:      * @throws JMSException
1:      */
1:     protected void start() throws JMSException {
1:         started.set(true);
0:         for (Iterator iter = consumers.iterator(); iter.hasNext();) {
0:             ActiveMQMessageConsumer c = (ActiveMQMessageConsumer) iter.next();
1:             c.start();
1:         }
0:         executor.start();
1:     }
1: 
1:     /**
1:      * Stops this session.
1:      * @throws JMSException 
1:      */
1:     protected void stop() throws JMSException {
1:         
0:         for (Iterator iter = consumers.iterator(); iter.hasNext();) {
0:             ActiveMQMessageConsumer c = (ActiveMQMessageConsumer) iter.next();
1:             c.stop();
1:         }
1: 
1:         started.set(false);
0:         executor.stop();
1:     }
1: 
1:     /**
1:      * Returns the session id.
1:      * 
0:      * @return sessionId - session id.
1:      */
1:     protected SessionId getSessionId() {
1:         return info.getSessionId();
1:     }
1: 
1:     /**
1:      * Sends the message for dispatch by the broker.
1:      * 
0:      * @param producer -
0:      *            message producer.
0:      * @param destination -
0:      *            message destination.
0:      * @param message -
0:      *            message to be sent.
0:      * @param deliveryMode -
0:      *            JMS messsage delivery mode.
0:      * @param priority -
0:      *            message priority.
0:      * @param timeToLive -
0:      *            message expiration.
0:      * @param reuseMessageId -
0:      *            true if the message id will be reused.
1:      * @throws JMSException
1:      */
0:     protected void send(ActiveMQMessageProducer producer, ActiveMQDestination destination, Message message, int deliveryMode,
0:             int priority, long timeToLive) throws JMSException {
1:         checkClosed();
1: 
0:         if( destination.isTemporary() && connection.isDeleted(destination) ) {
0:             throw new JMSException("Cannot publish to a deleted Destination: "+destination);
1:         }
1: 
0:         // tell the Broker we are about to start a new transaction
0:         doStartTransaction();
0:         TransactionId txid = transactionContext.getTransactionId();
1:         
0:         message.setJMSDestination(destination);
1:         message.setJMSDeliveryMode(deliveryMode);        
0:         long expiration = 0L;
1: 
0:         if (!producer.getDisableMessageTimestamp()) {
0:             long timeStamp = System.currentTimeMillis();
1:             message.setJMSTimestamp(timeStamp);
0:             if (timeToLive > 0) {
0:                 expiration = timeToLive + timeStamp;
1:             }
1:         }
1: 
1:         message.setJMSExpiration(expiration);
1:         message.setJMSPriority(priority);
0:         long sequenceNumber = producer.getMessageSequence();
1:         
1:         message.setJMSRedelivered(false);        
1: 
1:         // transform to our own message format here
0:         ActiveMQMessage msg = ActiveMQMessageTransformation.transformMessage(message, connection);
1:         // Set the message id.
0:         if( msg == message ) {
0:             msg.setMessageId( new MessageId(producer.getProducerInfo().getProducerId(), sequenceNumber) );
0:         } else {
0:             msg.setMessageId( new MessageId(producer.getProducerInfo().getProducerId(), sequenceNumber) );
0:             message.setJMSMessageID(msg.getMessageId().toString());
1:         }
1:         
1:         msg.setTransactionId(txid);
1: 
0:         if ( connection.isCopyMessageOnSend() ){
0:             msg = (ActiveMQMessage) msg.copy();
1:         }        
0:         msg.onSend();
0:         msg.setProducerId(msg.getMessageId().getProducerId());
1: 
0:         if (log.isDebugEnabled()) {
0:             log.debug("Sending message: " + msg);
1:         }
1: 
0:         if(!msg.isPersistent() || connection.isUseAsyncSend() || txid!=null) {
1:             this.connection.asyncSendPacket(msg);
0:         } else {
0:             this.connection.syncSendPacket(msg);
1:         }
1: 
1:     }
1: 
1:     /**
0:      * Send TransactionInfo to indicate transaction has started
1:      * 
1:      * @throws JMSException
0:      *             if some internal error occurs
1:      */
0:     protected void doStartTransaction() throws JMSException {
0:         if (getTransacted() && !transactionContext.isInXATransaction()) {
0:             transactionContext.begin();
1:         }
1:     }
1: 
1:     /**
0:      * Checks whether the session has unconsumed messages.
1:      * 
0:      * @return true - if there are unconsumed messages.
1:      */
1:     public boolean hasUncomsumedMessages() {
0:         return !executor.isEmpty();
1:     }
1: 
1:     /**
0:      * Checks whether the session uses transactions.
1:      * 
0:      * @return true - if the session uses transactions.
1:      */
1:     public boolean isTransacted() {
0:         return this.acknowledgementMode == Session.SESSION_TRANSACTED;
1:     }
1: 
1:     /**
1:      * Checks whether the session used client acknowledgment.
1:      * 
1:      * @return true - if the session uses client acknowledgment.
1:      */
1:     protected boolean isClientAcknowledge() {
1:         return this.acknowledgementMode == Session.CLIENT_ACKNOWLEDGE;
1:     }
1:     
1:     /**
1:      * Checks whether the session used auto acknowledgment.
1:      * 
1:      * @return true - if the session uses client acknowledgment.
1:      */
1:     public boolean isAutoAcknowledge() {
0:         return acknowledgementMode==Session.AUTO_ACKNOWLEDGE;
1:     }
1:     
1:     /**
1:      * Checks whether the session used dup ok acknowledgment.
1:      * 
1:      * @return true - if the session uses client acknowledgment.
1:      */
1:     public boolean isDupsOkAcknowledge() {
0:         return acknowledgementMode==Session.DUPS_OK_ACKNOWLEDGE;
1:     }
1: 
1:     /**
1:      * Returns the message delivery listener.
1:      * 
1:      * @return deliveryListener - message delivery listener.
1:      */
1:     public DeliveryListener getDeliveryListener() {
1:         return deliveryListener;
1:     }
1: 
1:     /**
1:      * Sets the message delivery listener.
1:      * 
0:      * @param deliveryListener -
0:      *            message delivery listener.
1:      */
1:     public void setDeliveryListener(DeliveryListener deliveryListener) {
1:         this.deliveryListener = deliveryListener;
1:     }
1: 
1:     /**
1:      * Returns the SessionInfo bean.
1:      * 
1:      * @return info - SessionInfo bean.
1:      * @throws JMSException
1:      */
1:     protected SessionInfo getSessionInfo() throws JMSException {
0:         SessionInfo info = new SessionInfo(connection.getConnectionInfo(), getSessionId().getSessionId());
1:         return info;
1:     }
1: 
1:     /**
0:      * Send the asynchronus command.
1:      * 
0:      * @param command -
0:      *            command to be executed.
1:      * @throws JMSException
1:      */
1:     public void asyncSendPacket(Command command) throws JMSException {
1:         connection.asyncSendPacket(command);
1:     }
1: 
1:     /**
0:      * Send the synchronus command.
1:      * 
0:      * @param command -
0:      *            command to be executed.
1:      * @return Response
1:      * @throws JMSException
1:      */
1:     public Response syncSendPacket(Command command) throws JMSException {
1:         return connection.syncSendPacket(command);
1:     }
1: 
1:     public long getNextDeliveryId() {
1:         return deliveryIdGenerator.getNextSequenceId();
1:     }
1: 
0:     public void redispatch(MessageDispatchChannel unconsumedMessages) throws JMSException {
1:         
0:         List c = unconsumedMessages.removeAll();
1:         Collections.reverse(c);
1:         
0:         for (Iterator iter = c.iterator(); iter.hasNext();) {
0:             MessageDispatch md = (MessageDispatch) iter.next();
0:             executor.executeFirst(md);
1:         }
1:                 
1:     }
1: 
1:     public boolean isRunning() {
1:         return started.get();
1:     }
1: 
1:     public boolean isAsyncDispatch() {
1:         return asyncDispatch;
1:     }
1: 
1:     public void setAsyncDispatch(boolean asyncDispatch) {
1:         this.asyncDispatch = asyncDispatch;
1:     }
1: 
0: 	public List getUnconsumedMessages() {
0: 		return executor.getUnconsumedMessages();
1: 	}
1:     
1:     public String toString() {
0:         return "ActiveMQSession {id="+info.getSessionId()+",started="+started.get()+"}";
1:     }
1: 
1: 
1: }
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:b080d5f
/////////////////////////////////////////////////////////////////////////
1:      * If this session has been closed, then an {@link IllegalStateException} is
1:      * thrown, if trying to set a new listener. However setting the listener
1:      * to <tt>null</tt> is allowed, to clear the listener, even if this session
1:      * has been closed prior.
1:      * <P>
/////////////////////////////////////////////////////////////////////////
1:         // only check for closed if we set a new listener, as we allow to clear
1:         // the listener, such as when an application is shutting down, and is
1:         // no longer using a message listener on this session
1:         if (listener != null) {
0:             checkClosed();
1:         }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:97ae323
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             try {
1:                 connection.getScheduler().executeAfterDelay(new Runnable() {
0:                     public void run() {
0:                         consumer.clearMessagesInProgress();
0:                     }}, 0l);
0:             } catch (JMSException e) {
1:                 connection.onClientInternalException(e);
1:             }
/////////////////////////////////////////////////////////////////////////
0:                                 connection.getScheduler().executeAfterDelay(new Runnable() {
/////////////////////////////////////////////////////////////////////////
1:     protected Scheduler getScheduler() throws JMSException {
1:         return this.connection.getScheduler();
commit:0a66b79
/////////////////////////////////////////////////////////////////////////
0:         boolean interrupted = Thread.interrupted();
0:         if (interrupted) {
0:             Thread.currentThread().interrupt();
1:         }
/////////////////////////////////////////////////////////////////////////
1:     public List<MessageDispatch> getUnconsumedMessages() {
commit:251dc7b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.JMSExceptionSupport;
/////////////////////////////////////////////////////////////////////////
0:  *
0:  *
0: 
1:     /**
1:      * Only acknowledge an individual message - using message.acknowledge()
1:      * as opposed to CLIENT_ACKNOWLEDGE which
1:      * acknowledges all messages consumed by a session at when acknowledge()
1:      * is called
1:      */
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:         connection.addSession(this);
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:         executor.clearMessagesInProgress();
0:         // dispatch and delivered lists. So rather than trying to
0:         // grab a mutex (which could be already owned by the message
0:         // listener calling the send or an ack) we allow it to complete in
0:         // a separate thread via the scheduler and notify us via
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:         if (isIndividualAcknowledge()) {
0:             throw JMSExceptionSupport.create("Cannot create a durable consumer for a Session in "+
0:                                              "INDIVIDUAL_ACKNOWLEDGE mode.", null);
1:         }
0: 
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
0: 
1:         return acknowledgementMode == ActiveMQSession.INDIVIDUAL_ACKNOWLEDGE;
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:be37064
/////////////////////////////////////////////////////////////////////////
1:      * Checks if the session is closed.
0:      *
1:      * @return true if the session is closed, false otherwise.
1:      */
1:     public boolean isClosed() {
1:         return closed;
1:     }
0: 
1:     /**
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(ActiveMQSession.class);
commit:f8ef7ff
/////////////////////////////////////////////////////////////////////////
1:                     consumer.setFailureError(connection.getFirstFailureError());
author:Robert Davies
-------------------------------------------------------------------------------
commit:7ad152b
/////////////////////////////////////////////////////////////////////////
1:     protected final ActiveMQSessionExecutor executor;
/////////////////////////////////////////////////////////////////////////
1:         this.executor = new ActiveMQSessionExecutor(this);
commit:1a5ad28
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ThreadPoolExecutor;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private final Scheduler scheduler;
1:     private final ThreadPoolExecutor connectionExecutor;
/////////////////////////////////////////////////////////////////////////
1:     private final JMSSessionStatsImpl stats;
/////////////////////////////////////////////////////////////////////////
0:         this.scheduler=connection.getScheduler();
1:         this.connectionExecutor=connection.getExecutor();
/////////////////////////////////////////////////////////////////////////
0:                                         @Override
0:                                         @Override
/////////////////////////////////////////////////////////////////////////
0:                         @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected Scheduler getScheduler() {
0:         return this.scheduler;
1:     }
0:     
1:     protected ThreadPoolExecutor getConnectionExecutor() {
1:         return this.connectionExecutor;
1:     }
commit:b08ae50
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.blob.BlobDownloader;
/////////////////////////////////////////////////////////////////////////
1:         message.setBlobDownloader(new BlobDownloader(getBlobTransferPolicy()));
/////////////////////////////////////////////////////////////////////////
1:         message.setBlobDownloader(new BlobDownloader((getBlobTransferPolicy())));
/////////////////////////////////////////////////////////////////////////
1:         message.setBlobDownloader(new BlobDownloader(getBlobTransferPolicy()));
commit:0acf545
/////////////////////////////////////////////////////////////////////////
0:             } catch (RuntimeException e) {
0:                 // A problem while invoking the MessageListener does not
0:                 // in general indicate a problem with the connection to the broker, i.e.
0:                 // it will usually be sufficient to let the afterDelivery() method either
0:                 // commit or roll back in order to deal with the exception.
0:                 // However, we notify any registered client internal exception listener
0:                 // of the problem.
0:                 connection.onClientInternalException(e);
/////////////////////////////////////////////////////////////////////////
0:                 connection.onClientInternalException(e);
/////////////////////////////////////////////////////////////////////////
0:             connection.onClientInternalException(e);
commit:d8b5d5c
/////////////////////////////////////////////////////////////////////////
0:     
1:     protected void sendAck(MessageAck ack) throws JMSException {
1:         sendAck(ack,false);
1:     }
0:     
1:     protected void sendAck(MessageAck ack, boolean lazy) throws JMSException {
0:         if (lazy || connection.isSendAcksAsync() || isTransacted()) {
0:             asyncSendPacket(ack);
0:         } else {
1:             syncSendPacket(ack);
1:         }
1:     }
commit:ab3b155
/////////////////////////////////////////////////////////////////////////
1: 	/**
0: 	 * Only acknowledge an individual message - using message.acknowledge()
0: 	 * as opposed to CLIENT_ACKNOWLEDGE which 
0: 	 * acknowledges all messages consumed by a session at when acknowledge()
0: 	 * is called
1: 	 */
commit:2076f45
/////////////////////////////////////////////////////////////////////////
0: 	
0: 	public static final int INDIVIDUAL_ACKNOWLEDGE=4;
/////////////////////////////////////////////////////////////////////////
1:             if (isClientAcknowledge()||isIndividualAcknowledge()) {
/////////////////////////////////////////////////////////////////////////
0:     
1:     public boolean isIndividualAcknowledge(){
0:     	return acknowledgementMode == ActiveMQSession.INDIVIDUAL_ACKNOWLEDGE;
1:     }
commit:8b33c1c
/////////////////////////////////////////////////////////////////////////
1:             //clear the brokerPath in case we are re-sending this message
1:             msg.setBrokerPath(null);
commit:114a923
/////////////////////////////////////////////////////////////////////////
1:         int timeSendOut = connection.getSendTimeout();
1:         return new ActiveMQMessageProducer(this, getNextProducerId(), ActiveMQMessageTransformation.transformDestination(destination),timeSendOut);
/////////////////////////////////////////////////////////////////////////
1:         int timeSendOut = connection.getSendTimeout();
1:         return new ActiveMQQueueSender(this, ActiveMQMessageTransformation.transformDestination(queue),timeSendOut);
/////////////////////////////////////////////////////////////////////////
1:         int timeSendOut = connection.getSendTimeout();
1:         return new ActiveMQTopicPublisher(this, ActiveMQMessageTransformation.transformDestination(topic),timeSendOut);
/////////////////////////////////////////////////////////////////////////
0:                         MemoryUsage producerWindow, int sendTimeout) throws JMSException {
/////////////////////////////////////////////////////////////////////////
0:             if (sendTimeout <= 0 && !msg.isResponseRequired() && !connection.isAlwaysSyncSend() && (!msg.isPersistent() || connection.isUseAsyncSend() || txid != null)) {
/////////////////////////////////////////////////////////////////////////
0:                 if (sendTimeout > 0) {
1:                     this.connection.syncSendPacket(msg,sendTimeout);
1:                 }else {
0:                     this.connection.syncSendPacket(msg);
1:                 }
commit:50bc597
/////////////////////////////////////////////////////////////////////////
1:             throw new InvalidDestinationException("Cannot publish to a deleted Destination: " + destination);
commit:3ee5854
/////////////////////////////////////////////////////////////////////////
0:             if (!msg.isResponseRequired() && !connection.isAlwaysSyncSend() && (!msg.isPersistent() || connection.isUseAsyncSend() || txid != null)) {
commit:62fb85e
/////////////////////////////////////////////////////////////////////////
1:                 prefetch, prefetchPolicy.getMaximumPendingMessageLimit(), noLocal, false, isAsyncDispatch(), messageListener);
commit:6d8e2c5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.MemoryUsage;
0: import org.apache.activemq.usage.Usage;
0: import org.apache.activemq.usage.SystemUsage;
/////////////////////////////////////////////////////////////////////////
0:                         MemoryUsage producerWindow) throws JMSException {
commit:cbaa58b
/////////////////////////////////////////////////////////////////////////
0:             if( message.isExpired() || connection.isDuplicate(ActiveMQSession.this,message)) {
/////////////////////////////////////////////////////////////////////////
0:                 if(ack.getTransactionId()!=null){
0:                         public void afterRollback() throws Exception{
0:                             // ensure we don't filter this as a duplicate
0:                             connection.rollbackDuplicate(ActiveMQSession.this,md.getMessage());
0:                             RedeliveryPolicy redeliveryPolicy=connection.getRedeliveryPolicy();
0:                             int redeliveryCounter=md.getMessage().getRedeliveryCounter();
0:                             if(redeliveryPolicy.getMaximumRedeliveries()!=RedeliveryPolicy.NO_MAXIMUM_REDELIVERIES
0:                                     &&redeliveryCounter>redeliveryPolicy.getMaximumRedeliveries()){
0:                                 MessageAck ack=new MessageAck(md,MessageAck.POSION_ACK_TYPE,1);
0:                             }else{
0:                                 for(int i=0;i<redeliveryCounter;i++){
0:                                     redeliveryDelay=redeliveryPolicy.getRedeliveryDelay(redeliveryDelay);
0:                                 Scheduler.executeAfterDelay(new Runnable(){
0: 
0:                                     public void run(){
0:                                 },redeliveryDelay);
/////////////////////////////////////////////////////////////////////////
1:         this.connection.removeDispatcher(consumer);
/////////////////////////////////////////////////////////////////////////
0:     public void redispatch(ActiveMQDispatcher dispatcher,MessageDispatchChannel unconsumedMessages) throws JMSException {
0:         List <MessageDispatch>c = unconsumedMessages.removeAll();
0:         for (MessageDispatch md: c) {
0:             this.connection.rollbackDuplicate(dispatcher,md.getMessage());
1:         }
commit:84eb9f8
/////////////////////////////////////////////////////////////////////////
0:             if(connection.isCopyMessageOnSend()){
0:                 msg=(ActiveMQMessage)msg.copy();
1:             }
commit:55fa954
/////////////////////////////////////////////////////////////////////////
commit:4e2acd4
/////////////////////////////////////////////////////////////////////////
0: 			if(!connection.isAlwaysSyncSend()&&(!msg.isPersistent()||connection.isUseAsyncSend()||txid!=null)){
0:                 this.connection.asyncSendPacket(msg);
0:             }else{
0:                 this.connection.syncSendPacket(msg);
1:             }
commit:341a1d4
/////////////////////////////////////////////////////////////////////////
1:     protected final boolean debug;
/////////////////////////////////////////////////////////////////////////
0:         this.debug = log.isDebugEnabled();
/////////////////////////////////////////////////////////////////////////
0: 			if(this.debug){
commit:e500f2e
/////////////////////////////////////////////////////////////////////////
0:     protected Object sendMutex = new Object();
/////////////////////////////////////////////////////////////////////////
0:     protected void send(ActiveMQMessageProducer producer,
0: 	        ActiveMQDestination destination,Message message,int deliveryMode,
0: 	        int priority,long timeToLive) throws JMSException{
0: 		checkClosed();
0: 		if(destination.isTemporary()&&connection.isDeleted(destination)){
0: 			throw new JMSException("Cannot publish to a deleted Destination: "
0: 			        +destination);
1: 		}
0: 		synchronized(sendMutex){
0: 			// tell the Broker we are about to start a new transaction
0: 			doStartTransaction();
0: 			TransactionId txid=transactionContext.getTransactionId();
0: 			message.setJMSDestination(destination);
0: 			message.setJMSDeliveryMode(deliveryMode);
0: 			long expiration=0L;
0: 			if(!producer.getDisableMessageTimestamp()){
0: 				long timeStamp=System.currentTimeMillis();
0: 				message.setJMSTimestamp(timeStamp);
0: 				if(timeToLive>0){
0: 					expiration=timeToLive+timeStamp;
1: 				}
1: 			}
0: 			message.setJMSExpiration(expiration);
0: 			message.setJMSPriority(priority);
0: 			long sequenceNumber=producer.getMessageSequence();
0: 			message.setJMSRedelivered(false);
0: 			// transform to our own message format here
0: 			ActiveMQMessage msg=ActiveMQMessageTransformation.transformMessage(
0: 			        message,connection);
0: 			// Set the message id.
0: 			if(msg==message){
0: 				msg.setMessageId(new MessageId(producer.getProducerInfo()
0: 				        .getProducerId(),sequenceNumber));
0: 			}else{
0: 				msg.setMessageId(new MessageId(producer.getProducerInfo()
0: 				        .getProducerId(),sequenceNumber));
0: 				message.setJMSMessageID(msg.getMessageId().toString());
1: 			}
0: 			msg.setTransactionId(txid);
0: 			if(connection.isCopyMessageOnSend()){
0: 				msg=(ActiveMQMessage)msg.copy();
1: 			}
0: 			msg.onSend();
0: 			msg.setProducerId(msg.getMessageId().getProducerId());
0: 			if(log.isDebugEnabled()){
0: 				log.debug("Sending message: "+msg);
1: 			}
0: 			if(!msg.isPersistent()||connection.isUseAsyncSend()||txid!=null){
0: 				this.connection.asyncSendPacket(msg);
0: 			}else{
0: 				this.connection.syncSendPacket(msg);
1: 			}
1: 		}
1: 	}
1: 	/**
0: 	 * Send TransactionInfo to indicate transaction has started
0: 	 * 
0: 	 * @throws JMSException
0: 	 *             if some internal error occurs
1: 	 */
0: 	protected void doStartTransaction() throws JMSException{
0: 		if(getTransacted()&&!transactionContext.isInXATransaction()){
0: 			transactionContext.begin();
1: 		}
1: 	}
0: 	 * Checks whether the session has unconsumed messages.
0: 	 * 
0: 	 * @return true - if there are unconsumed messages.
1: 	 */
0: 	 * Checks whether the session uses transactions.
0: 	 * 
0: 	 * @return true - if the session uses transactions.
1: 	 */
commit:fa8b889
/////////////////////////////////////////////////////////////////////////
0:     public TopicSubscriber createDurableSubscriber(Topic topic,String name,String messageSelector,boolean noLocal)
0:                     throws JMSException{
0:         ActiveMQPrefetchPolicy prefetchPolicy=this.connection.getPrefetchPolicy();
0:         int prefetch=isAutoAcknowledge()&&connection.isOptimizedMessageDispatch()?prefetchPolicy
0:                         .getOptimizeDurableTopicPrefetch():prefetchPolicy.getDurableTopicPrefetch();
0:         int maxPrendingLimit=prefetchPolicy.getMaximumPendingMessageLimit();
0:         return new ActiveMQTopicSubscriber(this,getNextConsumerId(),ActiveMQMessageTransformation
0:                         .transformDestination(topic),name,messageSelector,prefetch,maxPrendingLimit,noLocal,false,
0:                         asyncDispatch);
commit:ef0734b
/////////////////////////////////////////////////////////////////////////
0:     
0:     void clearMessagesInProgress(){
0:         executor.clearMessagesInProgress();
0:         for (Iterator iter = consumers.iterator(); iter.hasNext();) {
0:             ActiveMQMessageConsumer consumer = (ActiveMQMessageConsumer) iter.next();
0:             consumer.clearMessagesInProgress();
1:         }
1:     }
0:     
0:     void deliverAcks(){
0:         for (Iterator iter = consumers.iterator(); iter.hasNext();) {
0:             ActiveMQMessageConsumer consumer = (ActiveMQMessageConsumer) iter.next();
1:             consumer.deliverAcks();
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected void setOptimizeAcknowledge(boolean value){
0:         for (Iterator iter = consumers.iterator(); iter.hasNext();) {
0:             ActiveMQMessageConsumer c = (ActiveMQMessageConsumer) iter.next();
1:             c.setOptimizeAcknowledge(value);
1:         }
1:     }
0:     
0:     protected void setPrefetchSize(ConsumerId id,int prefetch){
0:         for(Iterator iter=consumers.iterator();iter.hasNext();){
0:             ActiveMQMessageConsumer c=(ActiveMQMessageConsumer) iter.next();
0:             if(c.getConsumerId().equals(id)){
1:                 c.setPrefetchSize(prefetch);
1:                 break;
1:             }
1:         }
1:     }
0:     
0:     protected void close(ConsumerId id){
0:         for(Iterator iter=consumers.iterator();iter.hasNext();){
0:             ActiveMQMessageConsumer c=(ActiveMQMessageConsumer) iter.next();
0:             if(c.getConsumerId().equals(id)){
0:                 try{
1:                     c.close();
0:                 }catch(JMSException e){
0:                     log.warn("Exception closing consumer",e);
1:                 }
0:                 log.warn("Closed consumer on Command");
1:                 break;
1:             }
1:         }
1:     }
commit:d964145
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.thread.TaskRunner;
/////////////////////////////////////////////////////////////////////////
1:     protected boolean sessionAsyncDispatch;
0:     protected TaskRunner taskRunner;
0:      * @param sessionId 
0:      * @param asyncDispatch 
0:      * @param sessionAsyncDispatch 
0:     protected ActiveMQSession(ActiveMQConnection connection, SessionId sessionId, int acknowledgeMode, boolean asyncDispatch,boolean sessionAsyncDispatch)
1:         this.sessionAsyncDispatch = sessionAsyncDispatch;
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected ActiveMQSession(ActiveMQConnection connection, SessionId sessionId, int acknowledgeMode, boolean asyncDispatch)throws JMSException {
0:         this(connection,sessionId,acknowledgeMode,asyncDispatch,true);
0:     }
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
1:      * @return Returns the sessionAsyncDispatch.
1:      */
0:     public boolean isSessionAsyncDispatch(){
1:         return sessionAsyncDispatch;
0:     }
0: 
1:     /**
1:      * @param sessionAsyncDispatch The sessionAsyncDispatch to set.
1:      */
0:     public void setSessionAsyncDispatch(boolean sessionAsyncDispatch){
0:         this.sessionAsyncDispatch=sessionAsyncDispatch;
0:     }
/////////////////////////////////////////////////////////////////////////
0:     
0: 
commit:7f63490
/////////////////////////////////////////////////////////////////////////
0:                 log.error("error dispatching message: ",e);
0:                 connection.onAsyncException(e);
author:David Jencks
-------------------------------------------------------------------------------
commit:ab438f6
/////////////////////////////////////////////////////////////////////////
1:     public static final int MAX_ACK_CONSTANT = INDIVIDUAL_ACKNOWLEDGE;
commit:2387612
/////////////////////////////////////////////////////////////////////////
1:     public static final int INDIVIDUAL_ACKNOWLEDGE = 4;
/////////////////////////////////////////////////////////////////////////
1:     private volatile boolean synchronizationRegistered;
/////////////////////////////////////////////////////////////////////////
0:             if (getTransacted()) {
1:                 if (!synchronizationRegistered) {
1:                     synchronizationRegistered = true;
0:                     getTransactionContext().addSynchronization(new Synchronization() {
0: 
1:                                         public void afterCommit() throws Exception {
1:                                             doClose();
1:                                             synchronizationRegistered = false;
0:                                         }
0: 
0:                                         public void afterRollback() throws Exception {
1:                                             doClose();
1:                                             synchronizationRegistered = false;
0:                                         }
0:                                     });
0:                 }
0: 
0:             } else {
1:                 doClose();
0:             }
1:     private void doClose() throws JMSException {
0:         dispose();
0:         connection.asyncSendPacket(info.createRemoveCommand());
0:     }
0: 
commit:9e6f62b
/////////////////////////////////////////////////////////////////////////
0:             //Set the "JMS" header fields on the orriginal message, see 1.1 spec section 3.4.11
0:             message.setJMSDestination(destination);
0:             message.setJMSDeliveryMode(deliveryMode);
0:             long expiration = 0L;
0:             if (!producer.getDisableMessageTimestamp()) {
0:                 long timeStamp = System.currentTimeMillis();
0:                 message.setJMSTimestamp(timeStamp);
0:                 if (timeToLive > 0) {
0:                     expiration = timeToLive + timeStamp;
0:                 }
0:             }
0:             message.setJMSExpiration(expiration);
0:             message.setJMSPriority(priority);
0:             message.setJMSRedelivered(false);
0: 
/////////////////////////////////////////////////////////////////////////
author:James Strachan
-------------------------------------------------------------------------------
commit:5829d70
/////////////////////////////////////////////////////////////////////////
1:         if (LOG.isDebugEnabled()) {
0:             LOG.debug(getSessionId() + " Transaction Commit");
0:         }
/////////////////////////////////////////////////////////////////////////
1:         if (LOG.isDebugEnabled()) {
0:             LOG.debug(getSessionId() + " Transaction Rollback");
0:         }
/////////////////////////////////////////////////////////////////////////
0:                 LOG.debug(getSessionId() + " sending message: " + msg);
commit:fba0742
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.blob.BlobTransferPolicy;
0: import org.apache.activemq.blob.BlobUploader;
0: import org.apache.activemq.command.*;
0: import org.apache.activemq.management.JMSSessionStatsImpl;
0: import org.apache.activemq.management.StatsCapable;
0: import org.apache.activemq.management.StatsImpl;
0: import org.apache.activemq.thread.Scheduler;
0: import org.apache.activemq.transaction.Synchronization;
0: import org.apache.activemq.usage.MemoryUsage;
0: import org.apache.activemq.util.Callback;
0: import org.apache.activemq.util.LongSequenceGenerator;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: 
0: import javax.jms.*;
0: import javax.jms.IllegalStateException;
0: import javax.jms.Message;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return createConsumer(destination, (String) null);
/////////////////////////////////////////////////////////////////////////
1:         return createConsumer(destination, messageSelector, false);
1:      * Creates a <CODE>MessageConsumer</CODE> for the specified destination.
1:      * Since <CODE>Queue</CODE> and <CODE> Topic</CODE> both inherit from
1:      * <CODE>Destination</CODE>, they can be used in the destination
1:      * parameter to create a <CODE>MessageConsumer</CODE>.
0:      *
1:      * @param destination the <CODE>Destination</CODE> to access.
1:      * @param messageListener the listener to use for async consumption of messages
1:      * @return the MessageConsumer
1:      * @throws JMSException if the session fails to create a consumer due to
1:      *                 some internal error.
1:      * @throws InvalidDestinationException if an invalid destination is
1:      *                 specified.
1:      * @since 1.1
1:     public MessageConsumer createConsumer(Destination destination, MessageListener messageListener) throws JMSException {
1:         return createConsumer(destination, null, messageListener);
1:      * Creates a <CODE>MessageConsumer</CODE> for the specified destination,
1:      * using a message selector. Since <CODE> Queue</CODE> and
1:      * <CODE>Topic</CODE> both inherit from <CODE>Destination</CODE>, they
1:      * can be used in the destination parameter to create a
1:      * <CODE>MessageConsumer</CODE>.
1:      * <P>
1:      * A client uses a <CODE>MessageConsumer</CODE> object to receive messages
1:      * that have been sent to a destination.
0:      *
1:      * @param destination the <CODE>Destination</CODE> to access
1:      * @param messageSelector only messages with properties matching the message
1:      *                selector expression are delivered. A value of null or an
1:      *                empty string indicates that there is no message selector
1:      *                for the message consumer.
1:      * @param messageListener the listener to use for async consumption of messages
1:      * @return the MessageConsumer
1:      * @throws JMSException if the session fails to create a MessageConsumer due
1:      *                 to some internal error.
1:      * @throws InvalidDestinationException if an invalid destination is
1:      *                 specified.
1:      * @throws InvalidSelectorException if the message selector is invalid.
1:      * @since 1.1
1:     public MessageConsumer createConsumer(Destination destination, String messageSelector, MessageListener messageListener) throws JMSException {
1:         return createConsumer(destination, messageSelector, false, messageListener);
/////////////////////////////////////////////////////////////////////////
1:         return createConsumer(destination, messageSelector, noLocal, null);
0:     }
0: 
1:     /**
1:      * Creates <CODE>MessageConsumer</CODE> for the specified destination,
1:      * using a message selector. This method can specify whether messages
1:      * published by its own connection should be delivered to it, if the
1:      * destination is a topic.
1:      * <P>
1:      * Since <CODE>Queue</CODE> and <CODE>Topic</CODE> both inherit from
1:      * <CODE>Destination</CODE>, they can be used in the destination
1:      * parameter to create a <CODE>MessageConsumer</CODE>.
1:      * <P>
1:      * A client uses a <CODE>MessageConsumer</CODE> object to receive messages
1:      * that have been published to a destination.
1:      * <P>
1:      * In some cases, a connection may both publish and subscribe to a topic.
1:      * The consumer <CODE>NoLocal</CODE> attribute allows a consumer to
1:      * inhibit the delivery of messages published by its own connection. The
1:      * default value for this attribute is False. The <CODE>noLocal</CODE>
1:      * value must be supported by destinations that are topics.
0:      *
1:      * @param destination the <CODE>Destination</CODE> to access
1:      * @param messageSelector only messages with properties matching the message
1:      *                selector expression are delivered. A value of null or an
1:      *                empty string indicates that there is no message selector
1:      *                for the message consumer.
1:      * @param noLocal - if true, and the destination is a topic, inhibits the
1:      *                delivery of messages published by its own connection. The
1:      *                behavior for <CODE>NoLocal</CODE> is not specified if
1:      *                the destination is a queue.
1:      * @param messageListener the listener to use for async consumption of messages
1:      * @return the MessageConsumer
1:      * @throws JMSException if the session fails to create a MessageConsumer due
1:      *                 to some internal error.
1:      * @throws InvalidDestinationException if an invalid destination is
1:      *                 specified.
1:      * @throws InvalidSelectorException if the message selector is invalid.
1:      * @since 1.1
1:      */
1:     public MessageConsumer createConsumer(Destination destination, String messageSelector, boolean noLocal, MessageListener messageListener) throws JMSException {
/////////////////////////////////////////////////////////////////////////
0:         int prefetch = 0;
0:         if (destination instanceof Topic) {
1:             prefetch = prefetchPolicy.getTopicPrefetch();
0:         } else {
1:             prefetch = prefetchPolicy.getQueuePrefetch();
0:         }
1:         ActiveMQDestination activemqDestination = ActiveMQMessageTransformation.transformDestination(destination);
1:         return new ActiveMQMessageConsumer(this, getNextConsumerId(), activemqDestination, null, messageSelector,
0:                 prefetch, prefetchPolicy.getMaximumPendingMessageLimit(), noLocal, false, asyncDispatch, messageListener);
/////////////////////////////////////////////////////////////////////////
0:      * @return
1:      */
0:     protected ConsumerId getNextConsumerId() {
0:         return new ConsumerId(info.getSessionId(), consumerIdGenerator.getNextSequenceId());
0:     }
0: 
1:     /**
0:      * @return
1:      */
0:     protected ProducerId getNextProducerId() {
0:         return new ProducerId(info.getSessionId(), producerIdGenerator.getNextSequenceId());
0:     }
0: 
1:     /**
commit:677c22b
/////////////////////////////////////////////////////////////////////////
0:         if (destination instanceof CustomDestination)  {
0:             CustomDestination customDestination = (CustomDestination) destination;
1:             return customDestination.createProducer(this);
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:         if (destination instanceof CustomDestination)  {
0:             CustomDestination customDestination = (CustomDestination) destination;
0:             return customDestination.createConsumer(this, messageSelector);
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0:      * @param noLocal -
/////////////////////////////////////////////////////////////////////////
0:     public MessageConsumer createConsumer(Destination destination, String messageSelector, boolean noLocal)
0: 
0:         if (destination instanceof CustomDestination)  {
0:             CustomDestination customDestination = (CustomDestination) destination;
1:             return customDestination.createConsumer(this, messageSelector, noLocal);
0:         }
0: 
0: 
0:                 prefetchPolicy.getTopicPrefetch(), prefetchPolicy.getMaximumPendingMessageLimit(), noLocal, false, asyncDispatch);
/////////////////////////////////////////////////////////////////////////
0: 
0:         if (topic instanceof CustomDestination)  {
0:             CustomDestination customDestination = (CustomDestination) topic;
1:             return customDestination.createDurableSubscriber(this, name, messageSelector, noLocal);
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:         if (queue instanceof CustomDestination)  {
0:             CustomDestination customDestination = (CustomDestination) queue;
1:             return customDestination.createReceiver(this, messageSelector);
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0:         if (queue instanceof CustomDestination)  {
0:             CustomDestination customDestination = (CustomDestination) queue;
1:             return customDestination.createSender(this);
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:         if (topic instanceof CustomDestination)  {
0:             CustomDestination customDestination = (CustomDestination) topic;
1:             return customDestination.createSubscriber(this, messageSelector, noLocal);
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0:         
0:         if (topic instanceof CustomDestination)  {
0:             CustomDestination customDestination = (CustomDestination) topic;
1:             return customDestination.createPublisher(this);
0:         }
/////////////////////////////////////////////////////////////////////////
1:     public ActiveMQConnection getConnection() {
1:         return connection;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
commit:28e6453
/////////////////////////////////////////////////////////////////////////
0:             long sequenceNumber=producer.getMessageSequence();
0: 
0:             // transform to our own message format here
0: 
0:             // Set the message id.
/////////////////////////////////////////////////////////////////////////
0: 
0:             msg.setJMSDestination(destination);
0: 			msg.setJMSDeliveryMode(deliveryMode);
0: 			long expiration=0L;
0: 			if(!producer.getDisableMessageTimestamp()){
0: 				long timeStamp=System.currentTimeMillis();
0: 				msg.setJMSTimestamp(timeStamp);
0: 				if(timeToLive>0){
0: 					expiration=timeToLive+timeStamp;
0: 				}
0: 			}
0: 			msg.setJMSExpiration(expiration);
0: 			msg.setJMSPriority(priority);
0: 			msg.setJMSRedelivered(false);
0: 
0:             msg.setTransactionId(txid);
commit:0eae288
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.*;
/////////////////////////////////////////////////////////////////////////
1:         if (queueName.startsWith(ActiveMQDestination.TEMP_DESTINATION_NAME_PREFIX)) {
1:             return new ActiveMQTempQueue(queueName);
0:         }
/////////////////////////////////////////////////////////////////////////
1:         if (topicName.startsWith(ActiveMQDestination.TEMP_DESTINATION_NAME_PREFIX)) {
1:             return new ActiveMQTempTopic(topicName);
0:         }
commit:53bf323
/////////////////////////////////////////////////////////////////////////
1:         return createBlobMessage(url, false);
0:     }
0: 
0: 
1:     /**
0:      * Creates an initialized <CODE>BlobMessage</CODE> object. A <CODE>BlobMessage</CODE>
0:      * object is used to send a message containing a <CODE>URL</CODE> which points to some
0:      * network addressible BLOB.
0:      *
0:      * @param url
0:      *            the network addressable URL used to pass directly to the consumer
0:      * @param deletedByBroker
0:      *          indicates whether or not the resource is deleted by the broker when the message
0:      * is acknowledged
1:      * @return a BlobMessage
0:      * @throws JMSException
0:      *             if the JMS provider fails to create this message due to some
0:      *             internal error.
0:      */
1:     public BlobMessage createBlobMessage(URL url, boolean deletedByBroker) throws JMSException {
1:         message.setDeletedByBroker(deletedByBroker);
/////////////////////////////////////////////////////////////////////////
1:      * depending on the {@link #getBlobTransferPolicy()}.
0:      *            the file to be uploaded to some remote repo (or the broker) depending on the strategy
/////////////////////////////////////////////////////////////////////////
0:      * depending on the {@link #getBlobTransferPolicy()}.
0:      * @param in
0:      *            the stream to be uploaded to some remote repo (or the broker) depending on the strategy
commit:05a8cba
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.blob.BlobTransferPolicy;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private BlobTransferPolicy blobTransferPolicy;
/////////////////////////////////////////////////////////////////////////
1:         setBlobTransferPolicy(connection.getBlobTransferPolicy());
/////////////////////////////////////////////////////////////////////////
1:         message.setBlobUploader(new BlobUploader(getBlobTransferPolicy(), file));
1:         message.setName(file.getName());
/////////////////////////////////////////////////////////////////////////
1:         message.setBlobUploader(new BlobUploader(getBlobTransferPolicy(), in));
/////////////////////////////////////////////////////////////////////////
1:     public BlobTransferPolicy getBlobTransferPolicy() {
1:         return blobTransferPolicy;
0:     }
0: 
1:     /**
0:      * Sets the policy used to describe how out-of-band BLOBs (Binary Large OBjects)
0:      * are transferred from producers to brokers to consumers
0:      */
1:     public void setBlobTransferPolicy(BlobTransferPolicy blobTransferPolicy) {
1:         this.blobTransferPolicy = blobTransferPolicy;
0:     }
0: 
commit:8cf4795
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.*;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.blob.BlobUploader;
0: import org.apache.activemq.blob.BlobUploadStrategy;
0: import javax.jms.*;
0: import javax.jms.IllegalStateException;
0: import javax.jms.Message;
0: import java.io.Serializable;
0: import java.io.File;
0: import java.io.InputStream;
0: import java.net.URL;
0: import java.util.Collections;
0: import java.util.Iterator;
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0:     private BlobUploadStrategy blobUploadStrategy;
/////////////////////////////////////////////////////////////////////////
1:         configureMessage(message);
/////////////////////////////////////////////////////////////////////////
1:         configureMessage(message);
/////////////////////////////////////////////////////////////////////////
1:         configureMessage(message);
/////////////////////////////////////////////////////////////////////////
1:         configureMessage(message);
/////////////////////////////////////////////////////////////////////////
1:         configureMessage(message);
/////////////////////////////////////////////////////////////////////////
1:         configureMessage(message);
/////////////////////////////////////////////////////////////////////////
1:         configureMessage(message);
/////////////////////////////////////////////////////////////////////////
1:         configureMessage(message);
0:      * Creates an initialized <CODE>BlobMessage</CODE> object. A <CODE>BlobMessage</CODE>
0:      * object is used to send a message containing a <CODE>URL</CODE> which points to some
0:      * network addressible BLOB.
0:      *
0:      * @param url
0:      *            the network addressable URL used to pass directly to the consumer
1:      * @return a BlobMessage
0:      * @throws JMSException
0:      *             if the JMS provider fails to create this message due to some
0:      *             internal error.
0:      */
1:     public BlobMessage createBlobMessage(URL url) throws JMSException {
1:         ActiveMQBlobMessage message = new ActiveMQBlobMessage();
1:         configureMessage(message);
1:         message.setURL(url);
1:         return message;
0:     }
0: 
1:     /**
0:      * Creates an initialized <CODE>BlobMessage</CODE> object. A <CODE>BlobMessage</CODE>
0:      * object is used to send a message containing the <CODE>File</CODE> content. Before the
0:      * message is sent the file conent will be uploaded to the broker or some other remote repository
0:      * depending on the {@link #getBlobUploadStrategy()}.
0:      *
0:      * @param file
0:      *            the file to be uploaded to some remote repo (or the broker) depending on the
0:      *
1:      * @return a BlobMessage
0:      * @throws JMSException
0:      *             if the JMS provider fails to create this message due to some
0:      *             internal error.
0:      */
1:     public BlobMessage createBlobMessage(File file) throws JMSException {
1:         ActiveMQBlobMessage message = new ActiveMQBlobMessage();
1:         configureMessage(message);
0:         message.setBlobUploader(new BlobUploader(blobUploadStrategy, file));
1:         message.setDeletedByBroker(true);
1:         return message;
0:     }
0: 
0: 
1:     /**
0:      * Creates an initialized <CODE>BlobMessage</CODE> object. A <CODE>BlobMessage</CODE>
0:      * object is used to send a message containing the <CODE>File</CODE> content. Before the
0:      * message is sent the file conent will be uploaded to the broker or some other remote repository
0:      * depending on the {@link #getBlobUploadStrategy()}.
0:      *
0:      * @param file
0:      *            the file to be uploaded to some remote repo (or the broker) depending on the
0:      *
1:      * @return a BlobMessage
0:      * @throws JMSException
0:      *             if the JMS provider fails to create this message due to some
0:      *             internal error.
0:      */
1:     public BlobMessage createBlobMessage(InputStream in) throws JMSException {
1:         ActiveMQBlobMessage message = new ActiveMQBlobMessage();
1:         configureMessage(message);
0:         message.setBlobUploader(new BlobUploader(blobUploadStrategy, in));
1:         message.setDeletedByBroker(true);
1:         return message;
0:     }
0: 
0: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:      * Checks that the session is not closed then configures the message
0:      */
1:     protected void configureMessage(ActiveMQMessage message) throws IllegalStateException {
0:         checkClosed();
0:         message.setConnection(connection);
0:     }
0: 
0: 
0:     /**
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:     public BlobUploadStrategy getBlobUploadStrategy() {
0:         return blobUploadStrategy;
0:     }
0: 
0:     /**
0:      * Sets the upload strategy for BLOBs which are sent out-of-band by uploading them
0:      * to some remote repository or the broker
0:      */
0:     public void setBlobUploadStrategy(BlobUploadStrategy blobUploadStrategy) {
0:         this.blobUploadStrategy = blobUploadStrategy;
0:     }
0: 
commit:86faaef
/////////////////////////////////////////////////////////////////////////
0:     private MessageTransformer transformer;
0: 
/////////////////////////////////////////////////////////////////////////
1:         setTransformer(connection.getTransformer());
/////////////////////////////////////////////////////////////////////////
1:     public MessageTransformer getTransformer() {
1:         return transformer;
0:     }
0: 
0:     /**
0:      * Sets the transformer used to transform messages before they are sent on to the JMS bus
0:      * or when they are received from the bus but before they are delivered to the JMS client
0:      */
1:     public void setTransformer(MessageTransformer transformer) {
1:         this.transformer = transformer;
0:     }
0: 
0:     public List getUnconsumedMessages() {
commit:a8abf2e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
commit:7249191
/////////////////////////////////////////////////////////////////////////
0:                 executor.stop();
0: 
0:                 for (Iterator iter = consumers.iterator(); iter.hasNext();) {
0:                     ActiveMQMessageConsumer consumer = (ActiveMQMessageConsumer) iter.next();
0:                     consumer.dispose();
0:                 consumers.clear();
0: 
0:                 for (Iterator iter = producers.iterator(); iter.hasNext();) {
0:                     ActiveMQMessageProducer producer = (ActiveMQMessageProducer) iter.next();
0:                     producer.dispose();
0:                 }
0:                 producers.clear();
0: 
0:                 try {
0:                     if (getTransactionContext().isInLocalTransaction()) {
0:                         rollback();
0:                     }
0:                 }
0:                 catch (JMSException e) {
0:                 }
0: 
0: 
0:             finally {
0:                 connection.removeSession(this);
1:                 this.transactionContext = null;
0:                 closed = true;
0:             }
commit:4c4f86a
/////////////////////////////////////////////////////////////////////////
0:                                     redeliveryDelay = redeliveryPolicy.getRedeliveryDelay(redeliveryDelay);
commit:d9b9427
/////////////////////////////////////////////////////////////////////////
0:                             md.getMessage().onMessageRolledBack();
commit:bed10aa
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQPrefetchPolicy prefetchPolicy = connection.getPrefetchPolicy();
0:             prefetch = prefetchPolicy.getTopicPrefetch();
0:             prefetch = prefetchPolicy.getQueuePrefetch();
0:         return new ActiveMQMessageConsumer(this, getNextConsumerId(), 
0:                 ActiveMQMessageTransformation.transformDestination(destination), null, messageSelector, prefetch, 
0:                 prefetchPolicy.getMaximumPendingMessageLimit(), false, false, asyncDispatch);
/////////////////////////////////////////////////////////////////////////
0:         ActiveMQPrefetchPolicy prefetchPolicy = connection.getPrefetchPolicy();
0:         return new ActiveMQMessageConsumer(this, getNextConsumerId(), 
0:                 ActiveMQMessageTransformation.transformDestination(destination), null, messageSelector, 
0:                 prefetchPolicy.getTopicPrefetch(), prefetchPolicy.getMaximumPendingMessageLimit(), NoLocal, false, asyncDispatch);
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQPrefetchPolicy prefetchPolicy = this.connection.getPrefetchPolicy();
0:                 .transformDestination(topic), name, messageSelector, prefetchPolicy.getDurableTopicPrefetch(), 
0:                 prefetchPolicy.getMaximumPendingMessageLimit(), noLocal, false, asyncDispatch);
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQPrefetchPolicy prefetchPolicy = this.connection.getPrefetchPolicy();
0:                 .transformDestination(queue), messageSelector, prefetchPolicy.getQueuePrefetch(), 
0:                 prefetchPolicy.getMaximumPendingMessageLimit(), asyncDispatch);
/////////////////////////////////////////////////////////////////////////
0:         ActiveMQPrefetchPolicy prefetchPolicy = this.connection.getPrefetchPolicy();
0:                 .transformDestination(topic), null, messageSelector, prefetchPolicy.getTopicPrefetch(), 
0:                 prefetchPolicy.getMaximumPendingMessageLimit(), noLocal, false, asyncDispatch);
commit:c8d74e7
/////////////////////////////////////////////////////////////////////////
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:bd7d59c
/////////////////////////////////////////////////////////////////////////
0: 	public boolean isInUse(ActiveMQTempDestination destination) {
0:         for(Iterator iter=consumers.iterator();iter.hasNext();){
0:             ActiveMQMessageConsumer c=(ActiveMQMessageConsumer) iter.next();
0:             if( c.isInUse(destination) ) {
0:             	return true;
0:             }
0:         }
1:         return false;
0: 	}    
commit:979c5d5
/////////////////////////////////////////////////////////////////////////
0:                             if (redeliveryPolicy.getMaximumRedeliveries() != RedeliveryPolicy.NO_MAXIMUM_REDELIVERIES
0:                             		&& redeliveryCounter > redeliveryPolicy.getMaximumRedeliveries()) {
============================================================================