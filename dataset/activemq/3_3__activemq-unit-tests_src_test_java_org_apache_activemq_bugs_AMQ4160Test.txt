1:1942324: /**
1:1942324:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:1942324:  * contributor license agreements.  See the NOTICE file distributed with
1:1942324:  * this work for additional information regarding copyright ownership.
1:1942324:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:1942324:  * (the "License"); you may not use this file except in compliance with
1:1942324:  * the License.  You may obtain a copy of the License at
1:1942324:  *
1:1942324:  *      http://www.apache.org/licenses/LICENSE-2.0
1:1942324:  *
1:1942324:  * Unless required by applicable law or agreed to in writing, software
1:1942324:  * distributed under the License is distributed on an "AS IS" BASIS,
1:1942324:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:1942324:  * See the License for the specific language governing permissions and
1:1942324:  * limitations under the License.
1:1942324:  */
1:1942324: 
1:1942324: package org.apache.activemq.bugs;
1:1942324: 
1:1942324: import java.io.IOException;
1:1942324: import java.net.URI;
1:1942324: import java.util.concurrent.CountDownLatch;
1:1942324: import java.util.concurrent.TimeUnit;
1:1942324: 
1:1942324: import javax.management.ObjectName;
1:1942324: 
1:1942324: import org.apache.activemq.JmsMultipleBrokersTestSupport;
1:1942324: import org.apache.activemq.broker.Broker;
1:1942324: import org.apache.activemq.broker.BrokerFilter;
1:1942324: import org.apache.activemq.broker.BrokerPlugin;
1:1942324: import org.apache.activemq.broker.BrokerService;
1:1942324: import org.apache.activemq.broker.ConnectionContext;
1:1942324: import org.apache.activemq.command.ConnectionInfo;
1:1942324: import org.apache.activemq.command.DiscoveryEvent;
1:1942324: import org.apache.activemq.network.DiscoveryNetworkConnector;
1:1942324: import org.apache.activemq.network.NetworkBridge;
1:1942324: import org.apache.activemq.network.NetworkBridgeListener;
1:10c998b: import org.apache.activemq.network.NetworkBridgeStatistics;
1:dd0b16d: import org.apache.activemq.network.NetworkConnector;
1:1942324: import org.apache.activemq.thread.TaskRunnerFactory;
1:1942324: import org.apache.activemq.transport.Transport;
1:1942324: import org.apache.activemq.transport.discovery.DiscoveryAgent;
1:1942324: import org.apache.activemq.transport.discovery.DiscoveryListener;
1:1942324: import org.apache.activemq.transport.discovery.simple.SimpleDiscoveryAgent;
1:1942324: import org.junit.Assert;
1:1942324: 
1:1942324: /**
1:1942324:  * This test demonstrates a number of race conditions in
1:1942324:  * {@link DiscoveryNetworkConnector} that can result in an active bridge no
1:1942324:  * longer being reported as active and vice-versa, an inactive bridge still
1:1942324:  * being reported as active.
1:1942324:  */
1:1942324: public class AMQ4160Test extends JmsMultipleBrokersTestSupport {
1:dd0b16d:     final long MAX_TEST_TIME = TimeUnit.MINUTES.toMillis(2);
1:dd0b16d: 
1:dd0b16d:     /**
1:dd0b16d:      * Since these tests involve wait conditions, protect against indefinite
1:dd0b16d:      * waits (due to unanticipated issues).
1:dd0b16d:      */
1:10c998b:     @Override
1:dd0b16d:     public void setUp() throws Exception {
1:dd0b16d:         setAutoFail(true);
1:dd0b16d:         setMaxTestTime(MAX_TEST_TIME);
1:dd0b16d:         super.setUp();
1:dd0b16d:     }
1:dd0b16d: 
1:1942324:     /**
1:1942324:      * This test demonstrates how concurrent attempts to establish a bridge to
1:1942324:      * the same remote broker are allowed to occur. Connection uniqueness will
1:1942324:      * cause whichever bridge creation attempt is second to fail. However, this
1:1942324:      * failure erases the entry in
1:1942324:      * {@link DiscoveryNetworkConnector#activeBridges()} that represents the
1:1942324:      * successful first bridge creation attempt.
1:1942324:      */
1:dd0b16d:     public void testLostActiveBridge() throws Exception {
1:dd0b16d:         final long ATTEMPT_TO_CREATE_DELAY = TimeUnit.SECONDS.toMillis(15);
1:dd0b16d: 
1:1942324:         // Start two brokers with a bridge from broker1 to broker2.
1:1942324:         BrokerService broker1 = createBroker(new URI(
1:1942324:                 "broker:(vm://broker1)/broker1?persistent=false"));
1:1942324:         final BrokerService broker2 = createBroker(new URI(
1:1942324:                 "broker:(vm://broker2)/broker2?persistent=false"));
1:1942324: 
1:1942324:         // Allow the concurrent local bridge connections to be made even though
1:1942324:         // they are duplicated; this prevents both of the bridge attempts from
1:1942324:         // failing in the case that the local and remote bridges are established
1:1942324:         // out-of-order.
1:1942324:         BrokerPlugin ignoreAddConnectionPlugin = new BrokerPlugin() {
1:1942324:             @Override
1:1942324:             public Broker installPlugin(Broker broker) throws Exception {
1:1942324:                 return new BrokerFilter(broker) {
1:1942324:                     @Override
1:1942324:                     public void addConnection(ConnectionContext context,
1:1942324:                             ConnectionInfo info) throws Exception {
1:1942324:                         // ignore
1:1942324:                     }
1:1942324:                 };
1:1942324:             }
1:1942324:         };
1:1942324: 
1:1942324:         broker1.setPlugins(new BrokerPlugin[] { ignoreAddConnectionPlugin });
1:1942324: 
1:1942324:         startAllBrokers();
1:1942324: 
1:1942324:         // Start a bridge from broker1 to broker2. The discovery agent attempts
1:1942324:         // to create the bridge concurrently with two threads, and the
1:dd0b16d:         // synchronization in createBridge ensures that pre-patch both threads
1:dd0b16d:         // actually attempt to start bridges. Post-patch, only one thread is
1:dd0b16d:         // allowed to start the bridge.
1:dd0b16d:         final CountDownLatch attemptLatch = new CountDownLatch(2);
1:1942324:         final CountDownLatch createLatch = new CountDownLatch(2);
1:1942324: 
1:1942324:         DiscoveryNetworkConnector nc = new DiscoveryNetworkConnector() {
1:1942324:             @Override
1:dd0b16d:             public void onServiceAdd(DiscoveryEvent event) {
1:dd0b16d:                 // Pre-and-post patch, two threads attempt to establish a bridge
1:dd0b16d:                 // to the same remote broker.
1:dd0b16d:                 attemptLatch.countDown();
1:dd0b16d:                 super.onServiceAdd(event);
1:dd0b16d:             }
1:dd0b16d: 
1:dd0b16d:             @Override
1:1942324:             protected NetworkBridge createBridge(Transport localTransport,
1:1942324:                     Transport remoteTransport, final DiscoveryEvent event) {
1:dd0b16d:                 // Pre-patch, the two threads are allowed to create the bridge.
1:dd0b16d:                 // Post-patch, only the first thread is allowed. Wait a
1:dd0b16d:                 // reasonable delay once both attempts are detected to allow
1:dd0b16d:                 // the two bridge creations to occur concurrently (pre-patch).
1:dd0b16d:                 // Post-patch, the wait will timeout and allow the first (and
1:dd0b16d:                 // only) bridge creation to occur.
1:1942324:                 try {
1:dd0b16d:                     attemptLatch.await();
1:dd0b16d:                     createLatch.countDown();
1:dd0b16d:                     createLatch.await(ATTEMPT_TO_CREATE_DELAY,
1:dd0b16d:                             TimeUnit.MILLISECONDS);
1:dd0b16d:                     return super.createBridge(localTransport, remoteTransport,
1:dd0b16d:                             event);
1:1942324:                 } catch (InterruptedException e) {
1:dd0b16d:                     Thread.interrupted();
1:dd0b16d:                     return null;
1:1942324:                 }
1:1942324:             }
1:1942324:         };
1:1942324: 
1:1942324:         nc.setDiscoveryAgent(new DiscoveryAgent() {
1:1942324:             TaskRunnerFactory taskRunner = new TaskRunnerFactory();
1:1942324:             DiscoveryListener listener;
1:1942324: 
1:1942324:             @Override
1:1942324:             public void start() throws Exception {
1:1942324:                 taskRunner.init();
1:1942324:                 taskRunner.execute(new Runnable() {
1:1942324:                     @Override
1:1942324:                     public void run() {
1:1942324:                         listener.onServiceAdd(new DiscoveryEvent(broker2
1:1942324:                                 .getVmConnectorURI().toString()));
1:1942324:                     }
1:1942324:                 });
1:1942324:                 taskRunner.execute(new Runnable() {
1:1942324:                     @Override
1:1942324:                     public void run() {
1:1942324:                         listener.onServiceAdd(new DiscoveryEvent(broker2
1:1942324:                                 .getVmConnectorURI().toString()));
1:1942324:                     }
1:1942324:                 });
1:1942324:             }
1:1942324: 
1:1942324:             @Override
1:1942324:             public void stop() throws Exception {
1:1942324:                 taskRunner.shutdown();
1:1942324:             }
1:1942324: 
1:1942324:             @Override
1:1942324:             public void setDiscoveryListener(DiscoveryListener listener) {
1:1942324:                 this.listener = listener;
1:1942324:             }
1:1942324: 
1:1942324:             @Override
1:1942324:             public void registerService(String name) throws IOException {
1:1942324:             }
1:1942324: 
1:1942324:             @Override
1:1942324:             public void serviceFailed(DiscoveryEvent event) throws IOException {
1:1942324:                 listener.onServiceRemove(event);
1:1942324:             }
1:1942324:         });
1:1942324: 
1:1942324:         broker1.addNetworkConnector(nc);
1:1942324:         nc.start();
1:1942324: 
1:dd0b16d:         // Wait for the bridge to be formed by the first attempt.
1:dd0b16d:         waitForBridge(broker1.getBrokerName(), broker2.getBrokerName(),
1:dd0b16d:                 MAX_TEST_TIME, TimeUnit.MILLISECONDS);
1:1942324: 
1:dd0b16d:         // Pre-patch, the second bridge creation attempt fails and removes the
1:dd0b16d:         // first (successful) bridge creation attempt from the
1:dd0b16d:         // list of active bridges. Post-patch, the second bridge creation
1:dd0b16d:         // attempt is prevented, so the first bridge creation attempt
1:dd0b16d:         // remains "active". This assertion is expected to fail pre-patch and
1:dd0b16d:         // pass post-patch.
1:1942324:         Assert.assertFalse(nc.activeBridges().isEmpty());
1:1942324:     }
1:1942324: 
1:1942324:     /**
1:1942324:      * This test demonstrates a race condition where a failed bridge can be
1:1942324:      * removed from the list of active bridges in
1:1942324:      * {@link DiscoveryNetworkConnector} before it has been added. Eventually,
1:dd0b16d:      * the failed bridge is added, but never removed, which causes subsequent
1:1942324:      * bridge creation attempts to be ignored. The result is a network connector
1:1942324:      * that thinks it has an active bridge, when in fact it doesn't.
1:1942324:      */
1:1942324:     public void testInactiveBridgStillActive() throws Exception {
1:1942324:         // Start two brokers with a bridge from broker1 to broker2.
1:1942324:         BrokerService broker1 = createBroker(new URI(
1:1942324:                 "broker:(vm://broker1)/broker1?persistent=false"));
1:1942324:         final BrokerService broker2 = createBroker(new URI(
1:1942324:                 "broker:(vm://broker2)/broker2?persistent=false"));
1:1942324: 
1:1942324:         // Force bridge failure by having broker1 disallow connections.
1:1942324:         BrokerPlugin disallowAddConnectionPlugin = new BrokerPlugin() {
1:1942324:             @Override
1:1942324:             public Broker installPlugin(Broker broker) throws Exception {
1:1942324:                 return new BrokerFilter(broker) {
1:1942324:                     @Override
1:1942324:                     public void addConnection(ConnectionContext context,
1:1942324:                             ConnectionInfo info) throws Exception {
1:1942324:                         throw new Exception(
1:1942324:                                 "Test exception to force bridge failure");
1:1942324:                     }
1:1942324:                 };
1:1942324:             }
1:1942324:         };
1:1942324: 
1:1942324:         broker1.setPlugins(new BrokerPlugin[] { disallowAddConnectionPlugin });
1:1942324: 
1:1942324:         startAllBrokers();
1:1942324: 
1:1942324:         // Start a bridge from broker1 to broker2. The bridge delays returning
1:1942324:         // from start until after the bridge failure has been processed;
1:1942324:         // this leaves the first bridge creation attempt recorded as active,
1:1942324:         // even though it failed.
1:1942324:         final SimpleDiscoveryAgent da = new SimpleDiscoveryAgent();
1:1942324:         da.setServices(new URI[] { broker2.getVmConnectorURI() });
1:1942324: 
1:1942324:         final CountDownLatch attemptLatch = new CountDownLatch(3);
1:1942324:         final CountDownLatch removedLatch = new CountDownLatch(1);
1:1942324: 
1:1942324:         DiscoveryNetworkConnector nc = new DiscoveryNetworkConnector() {
1:1942324:             @Override
1:1942324:             public void onServiceAdd(DiscoveryEvent event) {
1:1942324:                 attemptLatch.countDown();
1:1942324:                 super.onServiceAdd(event);
1:1942324:             }
1:1942324: 
1:1942324:             @Override
1:1942324:             public void onServiceRemove(DiscoveryEvent event) {
1:1942324:                 super.onServiceRemove(event);
1:1942324:                 removedLatch.countDown();
1:1942324:             }
1:1942324: 
1:1942324:             @Override
1:1942324:             protected NetworkBridge createBridge(Transport localTransport,
1:1942324:                     Transport remoteTransport, final DiscoveryEvent event) {
1:1942324:                 final NetworkBridge next = super.createBridge(localTransport,
1:1942324:                         remoteTransport, event);
1:1942324:                 return new NetworkBridge() {
1:1942324: 
1:1942324:                     @Override
1:1942324:                     public void start() throws Exception {
1:1942324:                         next.start();
1:1942324:                         // Delay returning until the failed service has been
1:1942324:                         // removed.
1:1942324:                         removedLatch.await();
1:1942324:                     }
1:1942324: 
1:1942324:                     @Override
1:1942324:                     public void stop() throws Exception {
1:1942324:                         next.stop();
1:1942324:                     }
1:1942324: 
1:1942324:                     @Override
1:1942324:                     public void serviceRemoteException(Throwable error) {
1:1942324:                         next.serviceRemoteException(error);
1:1942324:                     }
1:1942324: 
1:1942324:                     @Override
1:1942324:                     public void serviceLocalException(Throwable error) {
1:1942324:                         next.serviceLocalException(error);
1:1942324:                     }
1:1942324: 
1:1942324:                     @Override
1:1942324:                     public void setNetworkBridgeListener(
1:1942324:                             NetworkBridgeListener listener) {
1:1942324:                         next.setNetworkBridgeListener(listener);
1:1942324:                     }
1:1942324: 
1:1942324:                     @Override
1:1942324:                     public String getRemoteAddress() {
1:1942324:                         return next.getRemoteAddress();
1:1942324:                     }
1:1942324: 
1:1942324:                     @Override
1:1942324:                     public String getRemoteBrokerName() {
1:1942324:                         return next.getRemoteBrokerName();
1:1942324:                     }
1:1942324: 
1:1942324:                     @Override
1:71e4585:                     public String getRemoteBrokerId() {
1:71e4585:                         return next.getRemoteBrokerId();
1:71e4585:                     }
1:71e4585: 
1:71e4585:                     @Override
1:1942324:                     public String getLocalAddress() {
1:1942324:                         return next.getLocalAddress();
1:1942324:                     }
1:1942324: 
1:1942324:                     @Override
1:1942324:                     public String getLocalBrokerName() {
1:1942324:                         return next.getLocalBrokerName();
1:1942324:                     }
1:1942324: 
1:1942324:                     @Override
1:1942324:                     public long getEnqueueCounter() {
1:1942324:                         return next.getEnqueueCounter();
1:1942324:                     }
1:1942324: 
1:1942324:                     @Override
1:1942324:                     public long getDequeueCounter() {
1:1942324:                         return next.getDequeueCounter();
1:1942324:                     }
1:1942324: 
1:1942324:                     @Override
1:10c998b:                     public NetworkBridgeStatistics getNetworkBridgeStatistics() {
1:10c998b:                         return next.getNetworkBridgeStatistics();
1:10c998b:                     }
1:10c998b: 
1:10c998b:                     @Override
1:1942324:                     public void setMbeanObjectName(ObjectName objectName) {
1:1942324:                         next.setMbeanObjectName(objectName);
1:1942324:                     }
1:1942324: 
1:1942324:                     @Override
1:1942324:                     public ObjectName getMbeanObjectName() {
1:1942324:                         return next.getMbeanObjectName();
1:1942324:                     }
1:374cab9: 
1:10c998b:                     @Override
1:374cab9:                     public void resetStats(){
1:374cab9:                         next.resetStats();
1:374cab9:                     }
1:1942324:                 };
1:1942324:             }
1:1942324:         };
1:1942324:         nc.setDiscoveryAgent(da);
1:1942324: 
1:1942324:         broker1.addNetworkConnector(nc);
1:1942324:         nc.start();
1:1942324: 
1:1942324:         // All bridge attempts should fail, so the attempt latch should get
1:1942324:         // triggered. However, because of the race condition, the first attempt
1:1942324:         // is considered successful and causes further attempts to stop.
1:1942324:         // Therefore, this wait will time out and cause the test to fail.
1:1942324:         Assert.assertTrue(attemptLatch.await(30, TimeUnit.SECONDS));
1:1942324:     }
1:dd0b16d: 
1:dd0b16d:     /**
1:dd0b16d:      * This test verifies that when a network connector is restarted, any
1:dd0b16d:      * bridges that were active at the time of the stop are allowed to be
1:dd0b16d:      * re-established (i.e., the "active events" data structure in
1:dd0b16d:      * {@link DiscoveryNetworkConnector} is reset.
1:dd0b16d:      */
1:dd0b16d:     public void testAllowAttemptsAfterRestart() throws Exception {
1:dd0b16d:         final long STOP_DELAY = TimeUnit.SECONDS.toMillis(10);
1:dd0b16d: 
1:dd0b16d:         // Start two brokers with a bridge from broker1 to broker2.
1:dd0b16d:         BrokerService broker1 = createBroker(new URI(
1:dd0b16d:                 "broker:(vm://broker1)/broker1?persistent=false"));
1:dd0b16d:         final BrokerService broker2 = createBroker(new URI(
1:dd0b16d:                 "broker:(vm://broker2)/broker2?persistent=false"));
1:dd0b16d: 
1:dd0b16d:         startAllBrokers();
1:dd0b16d: 
1:dd0b16d:         // Start a bridge from broker1 to broker2.
1:dd0b16d:         NetworkConnector nc = bridgeBrokers(broker1.getBrokerName(),
1:dd0b16d:                 broker2.getBrokerName());
1:dd0b16d:         nc.start();
1:dd0b16d: 
1:dd0b16d:         waitForBridge(broker1.getBrokerName(), broker2.getBrokerName(),
1:dd0b16d:                 MAX_TEST_TIME, TimeUnit.MILLISECONDS);
1:dd0b16d: 
1:dd0b16d:         // Restart the network connector and verify that the bridge is
1:dd0b16d:         // re-established. The pause between start/stop is to account for the
1:dd0b16d:         // asynchronous closure.
1:dd0b16d:         nc.stop();
1:dd0b16d:         Thread.sleep(STOP_DELAY);
1:dd0b16d:         nc.start();
1:dd0b16d: 
1:dd0b16d:         waitForBridge(broker1.getBrokerName(), broker2.getBrokerName(),
1:dd0b16d:                 MAX_TEST_TIME, TimeUnit.MILLISECONDS);
1:dd0b16d:     }
1:1942324: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:10c998b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.network.NetworkBridgeStatistics;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                     public NetworkBridgeStatistics getNetworkBridgeStatistics() {
1:                         return next.getNetworkBridgeStatistics();
1:                     }
1: 
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:                     @Override
author:rajdavies
-------------------------------------------------------------------------------
commit:71e4585
/////////////////////////////////////////////////////////////////////////
1:                     public String getRemoteBrokerId() {
1:                         return next.getRemoteBrokerId();
1:                     }
1: 
1:                     @Override
commit:374cab9
/////////////////////////////////////////////////////////////////////////
1: 
1:                     public void resetStats(){
1:                         next.resetStats();
1:                     }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
commit:dd0b16d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.network.NetworkConnector;
/////////////////////////////////////////////////////////////////////////
1:     final long MAX_TEST_TIME = TimeUnit.MINUTES.toMillis(2);
1: 
1:     /**
1:      * Since these tests involve wait conditions, protect against indefinite
1:      * waits (due to unanticipated issues).
1:      */
1:     public void setUp() throws Exception {
1:         setAutoFail(true);
1:         setMaxTestTime(MAX_TEST_TIME);
1:         super.setUp();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void testLostActiveBridge() throws Exception {
1:         final long ATTEMPT_TO_CREATE_DELAY = TimeUnit.SECONDS.toMillis(15);
1: 
/////////////////////////////////////////////////////////////////////////
1:         // synchronization in createBridge ensures that pre-patch both threads
1:         // actually attempt to start bridges. Post-patch, only one thread is
1:         // allowed to start the bridge.
1:         final CountDownLatch attemptLatch = new CountDownLatch(2);
1:             public void onServiceAdd(DiscoveryEvent event) {
1:                 // Pre-and-post patch, two threads attempt to establish a bridge
1:                 // to the same remote broker.
1:                 attemptLatch.countDown();
1:                 super.onServiceAdd(event);
1:             }
1: 
1:             @Override
1:                 // Pre-patch, the two threads are allowed to create the bridge.
1:                 // Post-patch, only the first thread is allowed. Wait a
1:                 // reasonable delay once both attempts are detected to allow
1:                 // the two bridge creations to occur concurrently (pre-patch).
1:                 // Post-patch, the wait will timeout and allow the first (and
1:                 // only) bridge creation to occur.
1:                     attemptLatch.await();
1:                     createLatch.countDown();
1:                     createLatch.await(ATTEMPT_TO_CREATE_DELAY,
1:                             TimeUnit.MILLISECONDS);
1:                     return super.createBridge(localTransport, remoteTransport,
1:                             event);
1:                     Thread.interrupted();
1:                     return null;
/////////////////////////////////////////////////////////////////////////
1:         // Wait for the bridge to be formed by the first attempt.
1:         waitForBridge(broker1.getBrokerName(), broker2.getBrokerName(),
1:                 MAX_TEST_TIME, TimeUnit.MILLISECONDS);
1:         // Pre-patch, the second bridge creation attempt fails and removes the
1:         // first (successful) bridge creation attempt from the
1:         // list of active bridges. Post-patch, the second bridge creation
1:         // attempt is prevented, so the first bridge creation attempt
1:         // remains "active". This assertion is expected to fail pre-patch and
1:         // pass post-patch.
/////////////////////////////////////////////////////////////////////////
1:      * the failed bridge is added, but never removed, which causes subsequent
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * This test verifies that when a network connector is restarted, any
1:      * bridges that were active at the time of the stop are allowed to be
1:      * re-established (i.e., the "active events" data structure in
1:      * {@link DiscoveryNetworkConnector} is reset.
1:      */
1:     public void testAllowAttemptsAfterRestart() throws Exception {
1:         final long STOP_DELAY = TimeUnit.SECONDS.toMillis(10);
1: 
1:         // Start two brokers with a bridge from broker1 to broker2.
1:         BrokerService broker1 = createBroker(new URI(
1:                 "broker:(vm://broker1)/broker1?persistent=false"));
1:         final BrokerService broker2 = createBroker(new URI(
1:                 "broker:(vm://broker2)/broker2?persistent=false"));
1: 
1:         startAllBrokers();
1: 
1:         // Start a bridge from broker1 to broker2.
1:         NetworkConnector nc = bridgeBrokers(broker1.getBrokerName(),
1:                 broker2.getBrokerName());
1:         nc.start();
1: 
1:         waitForBridge(broker1.getBrokerName(), broker2.getBrokerName(),
1:                 MAX_TEST_TIME, TimeUnit.MILLISECONDS);
1: 
1:         // Restart the network connector and verify that the bridge is
1:         // re-established. The pause between start/stop is to account for the
1:         // asynchronous closure.
1:         nc.stop();
1:         Thread.sleep(STOP_DELAY);
1:         nc.start();
1: 
1:         waitForBridge(broker1.getBrokerName(), broker2.getBrokerName(),
1:                 MAX_TEST_TIME, TimeUnit.MILLISECONDS);
1:     }
commit:7f346a8
/////////////////////////////////////////////////////////////////////////
0:     public void x_testLostActiveBridge() throws Exception {
commit:1942324
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.activemq.bugs;
1: 
1: import java.io.IOException;
1: import java.net.URI;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.TimeUnit;
1: 
1: import javax.management.ObjectName;
1: 
1: import org.apache.activemq.JmsMultipleBrokersTestSupport;
1: import org.apache.activemq.broker.Broker;
1: import org.apache.activemq.broker.BrokerFilter;
1: import org.apache.activemq.broker.BrokerPlugin;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.command.ConnectionInfo;
1: import org.apache.activemq.command.DiscoveryEvent;
1: import org.apache.activemq.network.DiscoveryNetworkConnector;
1: import org.apache.activemq.network.NetworkBridge;
1: import org.apache.activemq.network.NetworkBridgeListener;
1: import org.apache.activemq.thread.TaskRunnerFactory;
1: import org.apache.activemq.transport.Transport;
1: import org.apache.activemq.transport.discovery.DiscoveryAgent;
1: import org.apache.activemq.transport.discovery.DiscoveryListener;
1: import org.apache.activemq.transport.discovery.simple.SimpleDiscoveryAgent;
1: import org.junit.Assert;
1: 
1: /**
1:  * This test demonstrates a number of race conditions in
1:  * {@link DiscoveryNetworkConnector} that can result in an active bridge no
1:  * longer being reported as active and vice-versa, an inactive bridge still
1:  * being reported as active.
1:  */
1: public class AMQ4160Test extends JmsMultipleBrokersTestSupport {
1:     /**
1:      * This test demonstrates how concurrent attempts to establish a bridge to
1:      * the same remote broker are allowed to occur. Connection uniqueness will
1:      * cause whichever bridge creation attempt is second to fail. However, this
1:      * failure erases the entry in
1:      * {@link DiscoveryNetworkConnector#activeBridges()} that represents the
1:      * successful first bridge creation attempt.
1:      */
0:     public void testLostActiveBridge() throws Exception {
1:         // Start two brokers with a bridge from broker1 to broker2.
1:         BrokerService broker1 = createBroker(new URI(
1:                 "broker:(vm://broker1)/broker1?persistent=false"));
1:         final BrokerService broker2 = createBroker(new URI(
1:                 "broker:(vm://broker2)/broker2?persistent=false"));
1: 
1:         // Allow the concurrent local bridge connections to be made even though
1:         // they are duplicated; this prevents both of the bridge attempts from
1:         // failing in the case that the local and remote bridges are established
1:         // out-of-order.
1:         BrokerPlugin ignoreAddConnectionPlugin = new BrokerPlugin() {
1:             @Override
1:             public Broker installPlugin(Broker broker) throws Exception {
1:                 return new BrokerFilter(broker) {
1:                     @Override
1:                     public void addConnection(ConnectionContext context,
1:                             ConnectionInfo info) throws Exception {
1:                         // ignore
1:                     }
1:                 };
1:             }
1:         };
1: 
1:         broker1.setPlugins(new BrokerPlugin[] { ignoreAddConnectionPlugin });
1: 
1:         startAllBrokers();
1: 
1:         // Start a bridge from broker1 to broker2. The discovery agent attempts
1:         // to create the bridge concurrently with two threads, and the
0:         // synchronization in createBridge ensures that both threads actually
0:         // attempt to start bridges.
1:         final CountDownLatch createLatch = new CountDownLatch(2);
1: 
1:         DiscoveryNetworkConnector nc = new DiscoveryNetworkConnector() {
1:             @Override
1:             protected NetworkBridge createBridge(Transport localTransport,
1:                     Transport remoteTransport, final DiscoveryEvent event) {
0:                 createLatch.countDown();
1:                 try {
0:                     createLatch.await();
1:                 } catch (InterruptedException e) {
1:                 }
0:                 return super.createBridge(localTransport, remoteTransport,
0:                         event);
1:             }
1:         };
1: 
1:         nc.setDiscoveryAgent(new DiscoveryAgent() {
1:             TaskRunnerFactory taskRunner = new TaskRunnerFactory();
1:             DiscoveryListener listener;
1: 
1:             @Override
1:             public void start() throws Exception {
1:                 taskRunner.init();
1:                 taskRunner.execute(new Runnable() {
1:                     @Override
1:                     public void run() {
1:                         listener.onServiceAdd(new DiscoveryEvent(broker2
1:                                 .getVmConnectorURI().toString()));
1:                     }
1:                 });
1:                 taskRunner.execute(new Runnable() {
1:                     @Override
1:                     public void run() {
1:                         listener.onServiceAdd(new DiscoveryEvent(broker2
1:                                 .getVmConnectorURI().toString()));
1:                     }
1:                 });
1:             }
1: 
1:             @Override
1:             public void stop() throws Exception {
1:                 taskRunner.shutdown();
1:             }
1: 
1:             @Override
1:             public void setDiscoveryListener(DiscoveryListener listener) {
1:                 this.listener = listener;
1:             }
1: 
1:             @Override
1:             public void registerService(String name) throws IOException {
1:             }
1: 
1:             @Override
1:             public void serviceFailed(DiscoveryEvent event) throws IOException {
1:                 listener.onServiceRemove(event);
1:             }
1:         });
1: 
1:         broker1.addNetworkConnector(nc);
1:         nc.start();
1: 
0:         // The bridge should be formed by the second creation attempt, but the
0:         // wait will time out because the active bridge entry from the second
0:         // (successful) bridge creation attempt is removed by the first
0:         // (unsuccessful) bridge creation attempt.
0:         waitForBridgeFormation();
1: 
1:         Assert.assertFalse(nc.activeBridges().isEmpty());
1:     }
1: 
1:     /**
1:      * This test demonstrates a race condition where a failed bridge can be
1:      * removed from the list of active bridges in
1:      * {@link DiscoveryNetworkConnector} before it has been added. Eventually,
0:      * the failed bridge is added, but never removed, which prevents subsequent
1:      * bridge creation attempts to be ignored. The result is a network connector
1:      * that thinks it has an active bridge, when in fact it doesn't.
1:      */
1:     public void testInactiveBridgStillActive() throws Exception {
1:         // Start two brokers with a bridge from broker1 to broker2.
1:         BrokerService broker1 = createBroker(new URI(
1:                 "broker:(vm://broker1)/broker1?persistent=false"));
1:         final BrokerService broker2 = createBroker(new URI(
1:                 "broker:(vm://broker2)/broker2?persistent=false"));
1: 
1:         // Force bridge failure by having broker1 disallow connections.
1:         BrokerPlugin disallowAddConnectionPlugin = new BrokerPlugin() {
1:             @Override
1:             public Broker installPlugin(Broker broker) throws Exception {
1:                 return new BrokerFilter(broker) {
1:                     @Override
1:                     public void addConnection(ConnectionContext context,
1:                             ConnectionInfo info) throws Exception {
1:                         throw new Exception(
1:                                 "Test exception to force bridge failure");
1:                     }
1:                 };
1:             }
1:         };
1: 
1:         broker1.setPlugins(new BrokerPlugin[] { disallowAddConnectionPlugin });
1: 
1:         startAllBrokers();
1: 
1:         // Start a bridge from broker1 to broker2. The bridge delays returning
1:         // from start until after the bridge failure has been processed;
1:         // this leaves the first bridge creation attempt recorded as active,
1:         // even though it failed.
1:         final SimpleDiscoveryAgent da = new SimpleDiscoveryAgent();
1:         da.setServices(new URI[] { broker2.getVmConnectorURI() });
1: 
1:         final CountDownLatch attemptLatch = new CountDownLatch(3);
1:         final CountDownLatch removedLatch = new CountDownLatch(1);
1: 
1:         DiscoveryNetworkConnector nc = new DiscoveryNetworkConnector() {
1:             @Override
1:             public void onServiceAdd(DiscoveryEvent event) {
1:                 attemptLatch.countDown();
1:                 super.onServiceAdd(event);
1:             }
1: 
1:             @Override
1:             public void onServiceRemove(DiscoveryEvent event) {
1:                 super.onServiceRemove(event);
1:                 removedLatch.countDown();
1:             }
1: 
1:             @Override
1:             protected NetworkBridge createBridge(Transport localTransport,
1:                     Transport remoteTransport, final DiscoveryEvent event) {
1:                 final NetworkBridge next = super.createBridge(localTransport,
1:                         remoteTransport, event);
1:                 return new NetworkBridge() {
1: 
1:                     @Override
1:                     public void start() throws Exception {
1:                         next.start();
1:                         // Delay returning until the failed service has been
1:                         // removed.
1:                         removedLatch.await();
1:                     }
1: 
1:                     @Override
1:                     public void stop() throws Exception {
1:                         next.stop();
1:                     }
1: 
1:                     @Override
1:                     public void serviceRemoteException(Throwable error) {
1:                         next.serviceRemoteException(error);
1:                     }
1: 
1:                     @Override
1:                     public void serviceLocalException(Throwable error) {
1:                         next.serviceLocalException(error);
1:                     }
1: 
1:                     @Override
1:                     public void setNetworkBridgeListener(
1:                             NetworkBridgeListener listener) {
1:                         next.setNetworkBridgeListener(listener);
1:                     }
1: 
1:                     @Override
1:                     public String getRemoteAddress() {
1:                         return next.getRemoteAddress();
1:                     }
1: 
1:                     @Override
1:                     public String getRemoteBrokerName() {
1:                         return next.getRemoteBrokerName();
1:                     }
1: 
1:                     @Override
1:                     public String getLocalAddress() {
1:                         return next.getLocalAddress();
1:                     }
1: 
1:                     @Override
1:                     public String getLocalBrokerName() {
1:                         return next.getLocalBrokerName();
1:                     }
1: 
1:                     @Override
1:                     public long getEnqueueCounter() {
1:                         return next.getEnqueueCounter();
1:                     }
1: 
1:                     @Override
1:                     public long getDequeueCounter() {
1:                         return next.getDequeueCounter();
1:                     }
1: 
1:                     @Override
1:                     public void setMbeanObjectName(ObjectName objectName) {
1:                         next.setMbeanObjectName(objectName);
1:                     }
1: 
1:                     @Override
1:                     public ObjectName getMbeanObjectName() {
1:                         return next.getMbeanObjectName();
1:                     }
1:                 };
1:             }
1:         };
1:         nc.setDiscoveryAgent(da);
1: 
1:         broker1.addNetworkConnector(nc);
1:         nc.start();
1: 
1:         // All bridge attempts should fail, so the attempt latch should get
1:         // triggered. However, because of the race condition, the first attempt
1:         // is considered successful and causes further attempts to stop.
1:         // Therefore, this wait will time out and cause the test to fail.
1:         Assert.assertTrue(attemptLatch.await(30, TimeUnit.SECONDS));
1:     }
1: }
============================================================================