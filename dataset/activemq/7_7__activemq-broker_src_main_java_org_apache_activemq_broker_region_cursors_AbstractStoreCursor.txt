1:071b4b1: /**
1:071b4b1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:071b4b1:  * contributor license agreements.  See the NOTICE file distributed with
1:071b4b1:  * this work for additional information regarding copyright ownership.
1:071b4b1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:071b4b1:  * (the "License"); you may not use this file except in compliance with
1:071b4b1:  * the License.  You may obtain a copy of the License at
1:071b4b1:  *
1:071b4b1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:071b4b1:  *
1:071b4b1:  * Unless required by applicable law or agreed to in writing, software
1:071b4b1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:071b4b1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:071b4b1:  * See the License for the specific language governing permissions and
1:071b4b1:  * limitations under the License.
1:ac0462a:  */
1:071b4b1: package org.apache.activemq.broker.region.cursors;
1:b40dc4c: 
1:071b4b1: import java.util.Iterator;
1:f92d45b: import java.util.LinkedList;
1:97c127d: import java.util.ListIterator;
1:4705f95: import java.util.concurrent.CancellationException;
1:83514ef: import java.util.concurrent.ExecutionException;
1:54e2e3b: import java.util.concurrent.Future;
1:9c2b1d2: import java.util.concurrent.TimeUnit;
1:9c2b1d2: import java.util.concurrent.TimeoutException;
1:734fb7d: 
1:071b4b1: import org.apache.activemq.broker.region.Destination;
1:071b4b1: import org.apache.activemq.broker.region.MessageReference;
1:f92d45b: import org.apache.activemq.broker.region.Subscription;
1:071b4b1: import org.apache.activemq.command.Message;
1:071b4b1: import org.apache.activemq.command.MessageId;
1:071b4b1: import org.apache.activemq.store.MessageRecoveryListener;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:3ddb71c: 
1:071b4b1: /**
1:071b4b1:  *  Store based cursor
1:071b4b1:  *
2:071b4b1:  */
1:08aecbe: public abstract class AbstractStoreCursor extends AbstractPendingMessageCursor implements MessageRecoveryListener {
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(AbstractStoreCursor.class);
1:071b4b1:     protected final Destination regionDestination;
1:fe31092:     protected final PendingList batchList;
1:00879cf:     private Iterator<MessageReference> iterator = null;
1:99be769:     protected boolean batchResetNeeded = false;
1:071b4b1:     protected int size;
1:cc6213e:     private final LinkedList<MessageId> pendingCachedIds = new LinkedList<>();
1:97c127d:     private static int SYNC_ADD = 0;
1:97c127d:     private static int ASYNC_ADD = 1;
1:97c127d:     final MessageId[] lastCachedIds = new MessageId[2];
1:13ec994:     protected boolean hadSpace = false;
1:13ec994: 
1:734fb7d: 
1:734fb7d: 
1:071b4b1:     protected AbstractStoreCursor(Destination destination) {
1:00879cf:         super((destination != null ? destination.isPrioritizedMessages():false));
1:071b4b1:         this.regionDestination=destination;
1:00879cf:         if (this.prioritizedMessages) {
1:00879cf:             this.batchList= new PrioritizedPendingList();
1:140ce1b:         } else {
1:00879cf:             this.batchList = new OrderedPendingList();
1:54e2e3b:         }
1:27b3a7c:     }
1:54e2e3b: 
1:b40dc4c: 
1:cfe099d:     @Override
1:071b4b1:     public final synchronized void start() throws Exception{
1:071b4b1:         if (!isStarted()) {
1:99be769:             super.start();
1:6d0c552:             resetBatch();
1:cfe099d:             resetSize();
1:8b8f630:             setCacheEnabled(size==0&&useCache);
1:b40dc4c:         }
1:5170a8b:     }
1:b40dc4c: 
1:101e711:     protected void resetSize() {
1:eaac0d2:         this.size = getStoreSize();
1:d5813be:     }
1:b40dc4c: 
1:734fb7d:     @Override
1:cfe099d:     public void rebase() {
1:efaf9cd:         MessageId lastAdded = lastCachedIds[SYNC_ADD];
1:efaf9cd:         if (lastAdded != null) {
1:efaf9cd:             try {
1:efaf9cd:                 setBatch(lastAdded);
1:efaf9cd:             } catch (Exception e) {
1:efaf9cd:                 LOG.error("{} - Failed to set batch on rebase", this, e);
1:efaf9cd:                 throw new RuntimeException(e);
1:efaf9cd:             }
1:efaf9cd:         }
1:cfe099d:     }
1:cfe099d: 
1:734fb7d:     @Override
1:071b4b1:     public final synchronized void stop() throws Exception {
2:071b4b1:         resetBatch();
1:071b4b1:         super.stop();
1:5d93518:         gc();
1:101e711:     }
1:b40dc4c: 
1:b40dc4c: 
1:734fb7d:     @Override
1:071b4b1:     public final boolean recoverMessage(Message message) throws Exception {
1:071b4b1:         return recoverMessage(message,false);
1:aad7e73:     }
1:54e2e3b: 
1:132f662:     public synchronized boolean recoverMessage(Message message, boolean cached) throws Exception {
1:132f662:         boolean recovered = false;
1:88ec9da:         message.setRegionDestination(regionDestination);
1:c8e518b:         if (recordUniqueId(message.getMessageId())) {
1:071b4b1:             if (!cached) {
1:ce1d85d:                 if( message.getMemoryUsage()==null ) {
1:ce1d85d:                     message.setMemoryUsage(this.getSystemUsage().getMemoryUsage());
1:ce1d85d:                 }
1:aad7e73:             }
1:071b4b1:             message.incrementReferenceCount();
1:00879cf:             batchList.addMessageLast(message);
1:d261412:             clearIterator(true);
1:132f662:             recovered = true;
1:140ce1b:         } else if (!cached) {
1:140ce1b:             // a duplicate from the store (!cached) - needs to be removed/acked - otherwise it will get re dispatched on restart
1:511b9b6:             if (duplicateFromStoreExcepted(message)) {
1:9c2b1d2:                 if (LOG.isTraceEnabled()) {
1:9c2b1d2:                     LOG.trace("{} store replayed pending message due to concurrentStoreAndDispatchQueues {} seq: {}", this, message.getMessageId(), message.getMessageId().getFutureOrSequenceLong());
1:9c2b1d2:                 }
1:97c127d:             } else {
1:140ce1b:                 LOG.warn("{} - cursor got duplicate from store {} seq: {}", this, message.getMessageId(), message.getMessageId().getFutureOrSequenceLong());
1:140ce1b:                 duplicate(message);
1:140ce1b:             }
1:97c127d:         } else {
1:140ce1b:             LOG.warn("{} - cursor got duplicate send {} seq: {}", this, message.getMessageId(), message.getMessageId().getFutureOrSequenceLong());
1:2b1cda1:             if (gotToTheStore(message)) {
1:27b3a7c:                 duplicate(message);
1:27b3a7c:             }
1:5170a8b:         }
1:132f662:         return recovered;
1:acc3d4f:     }
1:f92d45b: 
1:511b9b6:     protected boolean duplicateFromStoreExcepted(Message message) {
1:511b9b6:         // expected for messages pending acks with kahadb.concurrentStoreAndDispatchQueues=true for
1:511b9b6:         // which this existing unused flag has been repurposed
1:511b9b6:         return message.isRecievedByDFBridge();
1:511b9b6:     }
1:511b9b6: 
1:2b1cda1:     public static boolean gotToTheStore(Message message) throws Exception {
1:2b1cda1:         if (message.isRecievedByDFBridge()) {
1:2b1cda1:             // concurrent store and dispatch - wait to see if the message gets to the store to see
1:2b1cda1:             // if the index suppressed it (original still present), or whether it was stored and needs to be removed
1:2b1cda1:             Object possibleFuture = message.getMessageId().getFutureOrSequenceLong();
1:2b1cda1:             if (possibleFuture instanceof Future) {
1:bdfa339:                 try {
1:bdfa339:                     ((Future) possibleFuture).get();
1:bdfa339:                 } catch (Exception okToErrorOrCancelStoreOp) {}
1:2b1cda1:             }
1:2b1cda1:             // need to access again after wait on future
1:2b1cda1:             Object sequence = message.getMessageId().getFutureOrSequenceLong();
1:2b1cda1:             return (sequence != null && sequence instanceof Long && Long.compare((Long) sequence, -1l) != 0);
1:2b1cda1:         }
1:2b1cda1:         return true;
1:2b1cda1:     }
1:2b1cda1: 
1:f92d45b:     // track for processing outside of store index lock so we can dlq
1:f92d45b:     final LinkedList<Message> duplicatesFromStore = new LinkedList<Message>();
1:f92d45b:     private void duplicate(Message message) {
1:f92d45b:         duplicatesFromStore.add(message);
1:54e2e3b:     }
1:f92d45b: 
1:f92d45b:     void dealWithDuplicates() {
1:f92d45b:         for (Message message : duplicatesFromStore) {
1:f92d45b:             regionDestination.duplicateFromStore(message, getSubscription());
1:f92d45b:         }
1:f92d45b:         duplicatesFromStore.clear();
1:f92d45b:     }
1:f92d45b: 
1:a0ba0bf:     @Override
1:fe31092:     public final synchronized void reset() {
1:071b4b1:         if (batchList.isEmpty()) {
1:97c127d:             try {
2:071b4b1:                 fillBatch();
2:071b4b1:             } catch (Exception e) {
1:e1bbde7:                 LOG.error("{} - Failed to fill batch", this, e);
1:071b4b1:                 throw new RuntimeException(e);
1:f92d45b:             }
1:acc3d4f:         }
1:d261412:         clearIterator(true);
1:81f0cc0:         size();
1:3ddb71c:     }
1:b40dc4c: 
1:b40dc4c: 
1:734fb7d:     @Override
1:d261412:     public synchronized void release() {
1:d261412:         clearIterator(false);
1:3432a75:     }
1:b40dc4c: 
1:d261412:     private synchronized void clearIterator(boolean ensureIterator) {
1:d261412:         boolean haveIterator = this.iterator != null;
1:47cfa55:         this.iterator=null;
1:d261412:         if(haveIterator&&ensureIterator) {
1:d261412:             ensureIterator();
1:eb983f7:         }
1:c8e518b:     }
1:b40dc4c: 
1:d261412:     private synchronized void ensureIterator() {
1:d261412:         if(this.iterator==null) {
1:00879cf:             this.iterator=this.batchList.iterator();
1:08aecbe:         }
1:d7f34d9:     }
1:101e711: 
1:101e711: 
1:47cfa55:     public final void finished() {
1:d7f34d9:     }
1:b40dc4c: 
1:b40dc4c: 
1:734fb7d:     @Override
1:47cfa55:     public final synchronized boolean hasNext() {
1:47cfa55:         if (batchList.isEmpty()) {
1:97c127d:             try {
1:47cfa55:                 fillBatch();
1:47cfa55:             } catch (Exception e) {
1:e1bbde7:                 LOG.error("{} - Failed to fill batch", this, e);
1:47cfa55:                 throw new RuntimeException(e);
1:00879cf:             }
1:d261412:         }
1:d261412:         ensureIterator();
1:47cfa55:         return this.iterator.hasNext();
1:d261412:     }
1:b40dc4c: 
1:b40dc4c: 
1:734fb7d:     @Override
1:071b4b1:     public final synchronized MessageReference next() {
1:9b260dc:         MessageReference result = null;
1:47cfa55:         if (!this.batchList.isEmpty()&&this.iterator.hasNext()) {
1:00879cf:             result = this.iterator.next();
1:d261412:         }
1:9b260dc:         last = result;
1:5619cd0:         if (result != null) {
1:5619cd0:             result.incrementReferenceCount();
1:5619cd0:         }
2:071b4b1:         return result;
1:d261412:     }
1:b40dc4c: 
1:734fb7d:     @Override
1:cc6213e:     public synchronized boolean tryAddMessageLast(MessageReference node, long wait) throws Exception {
1:6b4d077:         boolean disableCache = false;
1:acc3d4f:         if (hasSpace()) {
1:cb96783:             if (isCacheEnabled()) {
1:6b4d077:                 if (recoverMessage(node.getMessage(),true)) {
1:97c127d:                     trackLastCached(node);
1:97c127d:                 } else {
1:f92d45b:                     dealWithDuplicates();
1:54e2e3b:                     return false;
1:9c2b1d2:                 }
1:6b4d077:             }
1:97c127d:         } else {
2:6b4d077:             disableCache = true;
1:6b4d077:         }
1:6b4d077: 
1:6b4d077:         if (disableCache && isCacheEnabled()) {
1:9c2b1d2:             if (LOG.isTraceEnabled()) {
1:9c2b1d2:                 LOG.trace("{} - disabling cache on add {} {}", this, node.getMessageId(), node.getMessageId().getFutureOrSequenceLong());
1:9c2b1d2:             }
1:9c2b1d2:             syncWithStore(node.getMessage());
1:cb96783:             setCacheEnabled(false);
1:97c127d:         }
1:071b4b1:         size++;
1:54e2e3b:         return true;
1:97c127d:     }
1:54e2e3b: 
1:734fb7d:     @Override
1:a0ba0bf:     public synchronized boolean isCacheEnabled() {
1:a0ba0bf:         return super.isCacheEnabled() || enableCacheNow();
1:a0ba0bf:     }
1:a0ba0bf: 
1:a0ba0bf:     protected boolean enableCacheNow() {
1:a0ba0bf:         boolean result = false;
1:a0ba0bf:         if (canEnableCash()) {
1:a0ba0bf:             setCacheEnabled(true);
1:a0ba0bf:             result = true;
1:a0ba0bf:             if (LOG.isTraceEnabled()) {
1:a0ba0bf:                 LOG.trace("{} enabling cache on empty store", this);
1:a0ba0bf:             }
1:a0ba0bf:         }
1:a0ba0bf:         return result;
1:a0ba0bf:     }
1:a0ba0bf: 
1:a0ba0bf:     protected boolean canEnableCash() {
1:a0ba0bf:         return useCache && size==0 && hasSpace() && isStarted();
1:a0ba0bf:     }
1:a0ba0bf: 
1:9c2b1d2:     private void syncWithStore(Message currentAdd) throws Exception {
1:9c2b1d2:         pruneLastCached();
1:a0ba0bf:         for (ListIterator<MessageId> it = pendingCachedIds.listIterator(pendingCachedIds.size()); it.hasPrevious(); ) {
1:a0ba0bf:             MessageId lastPending = it.previous();
1:a0ba0bf:             Object futureOrLong = lastPending.getFutureOrSequenceLong();
1:a0ba0bf:             if (futureOrLong instanceof Future) {
1:a0ba0bf:                 Future future = (Future) futureOrLong;
1:a0ba0bf:                 if (future.isCancelled()) {
1:a0ba0bf:                     continue;
1:a0ba0bf:                 }
1:a0ba0bf:                 try {
1:a0ba0bf:                     future.get(5, TimeUnit.SECONDS);
2:9c2b1d2:                     setLastCachedId(ASYNC_ADD, lastPending);
1:a0ba0bf:                 } catch (CancellationException ok) {
1:a0ba0bf:                     continue;
1:a0ba0bf:                 } catch (TimeoutException potentialDeadlock) {
1:a0ba0bf:                     LOG.debug("{} timed out waiting for async add", this, potentialDeadlock);
1:a0ba0bf:                 } catch (Exception worstCaseWeReplay) {
1:a0ba0bf:                     LOG.debug("{} exception waiting for async add", this, worstCaseWeReplay);
1:4705f95:                 }
1:a0ba0bf:             } else {
1:a0ba0bf:                 setLastCachedId(ASYNC_ADD, lastPending);
1:97c127d:             }
1:a0ba0bf:             break;
1:a0ba0bf:         }
1:a0ba0bf: 
1:a0ba0bf:         MessageId candidate = lastCachedIds[ASYNC_ADD];
1:a0ba0bf:         if (candidate != null) {
1:a0ba0bf:             // ensure we don't skip current possibly sync add b/c we waited on the future
1:a0ba0bf:             if (!isAsync(currentAdd) && Long.compare(((Long) currentAdd.getMessageId().getFutureOrSequenceLong()), ((Long) lastCachedIds[ASYNC_ADD].getFutureOrSequenceLong())) < 0) {
1:a0ba0bf:                 if (LOG.isTraceEnabled()) {
1:a0ba0bf:                     LOG.trace("no set batch from async:" + candidate.getFutureOrSequenceLong() + " >= than current: " + currentAdd.getMessageId().getFutureOrSequenceLong() + ", " + this);
1:97c127d:                 }
1:a0ba0bf:                 candidate = null;
1:a0ba0bf:             }
1:97c127d:         }
1:a0ba0bf:         if (candidate == null) {
1:a0ba0bf:             candidate = lastCachedIds[SYNC_ADD];
1:a0ba0bf:         }
1:a0ba0bf:         if (candidate != null) {
1:a0ba0bf:             setBatch(candidate);
1:97c127d:         }
1:97c127d:         // cleanup
1:97c127d:         lastCachedIds[SYNC_ADD] = lastCachedIds[ASYNC_ADD] = null;
1:97c127d:         pendingCachedIds.clear();
1:97c127d:     }
1:97c127d: 
1:97c127d:     private void trackLastCached(MessageReference node) {
1:4705f95:         if (isAsync(node.getMessage())) {
1:97c127d:             pruneLastCached();
1:97c127d:             pendingCachedIds.add(node.getMessageId());
1:9c2b1d2:         } else {
1:97c127d:             setLastCachedId(SYNC_ADD, node.getMessageId());
1:54e2e3b:         }
1:54e2e3b:     }
1:54e2e3b: 
1:4705f95:     private static final boolean isAsync(Message message) {
1:4705f95:         return message.isRecievedByDFBridge() || message.getMessageId().getFutureOrSequenceLong() instanceof Future;
1:4705f95:     }
1:4705f95: 
1:54e2e3b:     private void pruneLastCached() {
1:97c127d:         for (Iterator<MessageId> it = pendingCachedIds.iterator(); it.hasNext(); ) {
1:97c127d:             MessageId candidate = it.next();
1:97c127d:             final Object futureOrLong = candidate.getFutureOrSequenceLong();
2:97c127d:             if (futureOrLong instanceof Future) {
2:97c127d:                 Future future = (Future) futureOrLong;
1:83514ef:                 if (future.isDone()) {
1:83514ef:                     if (future.isCancelled()) {
1:83514ef:                         it.remove();
1:83514ef:                     } else {
1:83514ef:                         // check for exception, we may be seeing old state
1:83514ef:                         try {
1:83514ef:                             future.get(0, TimeUnit.SECONDS);
1:83514ef:                             // stale; if we get a result next prune will see Long
1:83514ef:                         } catch (ExecutionException expected) {
1:83514ef:                             it.remove();
1:83514ef:                         } catch (Exception unexpected) {
1:83514ef:                             LOG.debug("{} unexpected exception verifying exception state of future", this, unexpected);
1:83514ef:                         }
1:83514ef:                     }
1:9c2b1d2:                 } else {
1:97c127d:                     // we don't want to wait for work to complete
1:9c2b1d2:                     break;
1:97c127d:                 }
1:97c127d:             } else {
1:97c127d:                 // complete
1:97c127d:                 setLastCachedId(ASYNC_ADD, candidate);
1:9c2b1d2: 
1:9c2b1d2:                 // keep lock step with sync adds while order is preserved
1:9c2b1d2:                 if (lastCachedIds[SYNC_ADD] != null) {
1:9c2b1d2:                     long next = 1 + (Long)lastCachedIds[SYNC_ADD].getFutureOrSequenceLong();
1:9c2b1d2:                     if (Long.compare((Long)futureOrLong, next) == 0) {
1:9c2b1d2:                         setLastCachedId(SYNC_ADD, candidate);
1:9c2b1d2:                     }
1:9c2b1d2:                 }
1:97c127d:                 it.remove();
1:9c2b1d2:             }
1:97c127d:         }
1:97c127d:     }
1:97c127d: 
1:97c127d:     private void setLastCachedId(final int index, MessageId candidate) {
1:b40dc4c:         MessageId lastCacheId = lastCachedIds[index];
1:b40dc4c:         if (lastCacheId == null) {
1:97c127d:             lastCachedIds[index] = candidate;
1:9c2b1d2:         } else {
1:b40dc4c:             Object lastCacheFutureOrSequenceLong = lastCacheId.getFutureOrSequenceLong();
1:b40dc4c:             Object candidateOrSequenceLong = candidate.getFutureOrSequenceLong();
1:b40dc4c:             if (lastCacheFutureOrSequenceLong == null) { // possibly null for topics
1:97c127d:                 lastCachedIds[index] = candidate;
1:b40dc4c:             } else if (candidateOrSequenceLong != null &&
1:b40dc4c:                     Long.compare(((Long) candidateOrSequenceLong), ((Long) lastCacheFutureOrSequenceLong)) > 0) {
2:b40dc4c:                 lastCachedIds[index] = candidate;
1:c1e7dbd:             } else if (LOG.isTraceEnabled()) {
1:a0ba0bf:                 LOG.trace("no set last cached[" + index + "] current:" + lastCacheFutureOrSequenceLong + " <= than candidate: " + candidateOrSequenceLong+ ", " + this);
1:97c127d:             }
1:97c127d:         }
1:97c127d:     }
1:54e2e3b: 
1:180b0ec:     protected void setBatch(MessageId messageId) throws Exception {
1:54e2e3b:     }
1:54e2e3b: 
1:b40dc4c: 
1:734fb7d:     @Override
1:a7533ba:     public synchronized void addMessageFirst(MessageReference node) throws Exception {
1:071b4b1:         size++;
1:54e2e3b:     }
1:b40dc4c: 
1:3ddb71c: 
1:734fb7d:     @Override
1:071b4b1:     public final synchronized void remove() {
2:071b4b1:         size--;
1:47cfa55:         if (iterator!=null) {
1:47cfa55:             iterator.remove();
1:54e2e3b:         }
1:9b260dc:         if (last != null) {
1:9b260dc:             last.decrementReferenceCount();
1:54e2e3b:         }
1:54e2e3b:     }
1:d7f34d9: 
1:00879cf: 
1:734fb7d:     @Override
1:071b4b1:     public final synchronized void remove(MessageReference node) {
1:9c9b856:         if (batchList.remove(node) != null) {
1:9c9b856:             size--;
1:9c9b856:             setCacheEnabled(false);
1:54e2e3b:         }
1:54e2e3b:     }
1:b40dc4c: 
1:b40dc4c: 
1:734fb7d:     @Override
1:071b4b1:     public final synchronized void clear() {
2:071b4b1:         gc();
1:54e2e3b:     }
1:b40dc4c: 
1:b40dc4c: 
1:734fb7d:     @Override
1:3ddb71c:     public synchronized void gc() {
1:54e2e3b:         for (MessageReference msg : batchList) {
1:071b4b1:             rollback(msg.getMessageId());
1:071b4b1:             msg.decrementReferenceCount();
1:b40dc4c:         }
1:071b4b1:         batchList.clear();
1:d261412:         clearIterator(false);
1:071b4b1:         batchResetNeeded = true;
1:cb96783:         setCacheEnabled(false);
1:9c9b856:     }
1:3ddb71c: 
1:734fb7d:     @Override
1:071b4b1:     protected final synchronized void fillBatch() {
1:9c2b1d2:         if (LOG.isTraceEnabled()) {
1:0cf7c0b:             LOG.trace("{} fillBatch", this);
1:0cf7c0b:         }
1:071b4b1:         if (batchResetNeeded) {
1:d41f40a:             resetSize();
1:d41f40a:             setMaxBatchSize(Math.min(regionDestination.getMaxPageSize(), size));
1:071b4b1:             resetBatch();
1:071b4b1:             this.batchResetNeeded = false;
1:9b260dc:         }
1:13ec994:         if (this.batchList.isEmpty() && this.size >0) {
1:9c2b1d2:             try {
1:071b4b1:                 doFillBatch();
1:071b4b1:             } catch (Exception e) {
1:e1bbde7:                 LOG.error("{} - Failed to fill batch", this, e);
1:071b4b1:                 throw new RuntimeException(e);
1:9c2b1d2:             }
1:c8e518b:         }
1:c8e518b:     }
1:00879cf: 
1:00879cf: 
1:734fb7d:     @Override
1:071b4b1:     public final synchronized boolean isEmpty() {
1:81f0cc0:         // negative means more messages added to store through queue.send since last reset
1:81f0cc0:         return size == 0;
1:5d93518:     }
1:b40dc4c: 
1:00879cf: 
1:734fb7d:     @Override
1:071b4b1:     public final synchronized boolean hasMessagesBufferedToDeliver() {
1:071b4b1:         return !batchList.isEmpty();
3:47cfa55:     }
1:cfe099d: 
1:00879cf: 
1:734fb7d:     @Override
1:071b4b1:     public final synchronized int size() {
1:81f0cc0:         if (size < 0) {
1:d5813be:             this.size = getStoreSize();
1:47cfa55:         }
2:071b4b1:         return size;
1:47cfa55:     }
1:cb96783: 
1:101e711:     @Override
1:734fb7d:     public final synchronized long messageSize() {
1:734fb7d:         return getStoreMessageSize();
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     @Override
1:cb96783:     public String toString() {
1:101e711:         return super.toString() + ":" + regionDestination.getActiveMQDestination().getPhysicalName() + ",batchResetNeeded=" + batchResetNeeded
1:09bf8f8:                     + ",size=" + this.size + ",cacheEnabled=" + cacheEnabled
1:97c127d:                     + ",maxBatchSize:" + maxBatchSize + ",hasSpace:" + hasSpace() + ",pendingCachedIds.size:" + pendingCachedIds.size()
1:97c127d:                     + ",lastSyncCachedId:" + lastCachedIds[SYNC_ADD] + ",lastSyncCachedId-seq:" + (lastCachedIds[SYNC_ADD] != null ? lastCachedIds[SYNC_ADD].getFutureOrSequenceLong() : "null")
1:97c127d:                     + ",lastAsyncCachedId:" + lastCachedIds[ASYNC_ADD] + ",lastAsyncCachedId-seq:" + (lastCachedIds[ASYNC_ADD] != null ? lastCachedIds[ASYNC_ADD].getFutureOrSequenceLong() : "null");
1:cb96783:     }
1:b40dc4c: 
1:071b4b1:     protected abstract void doFillBatch() throws Exception;
1:b40dc4c: 
1:071b4b1:     protected abstract void resetBatch();
1:cfe099d: 
1:071b4b1:     protected abstract int getStoreSize();
1:b40dc4c: 
1:734fb7d:     protected abstract long getStoreMessageSize();
1:734fb7d: 
1:affd91e:     protected abstract boolean isStoreEmpty();
1:f92d45b: 
1:f92d45b:     public Subscription getSubscription() {
1:f92d45b:         return null;
1:f92d45b:     }
1:47cfa55: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:bdfa339
/////////////////////////////////////////////////////////////////////////
1:                 try {
1:                     ((Future) possibleFuture).get();
1:                 } catch (Exception okToErrorOrCancelStoreOp) {}
commit:83514ef
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ExecutionException;
/////////////////////////////////////////////////////////////////////////
1:                 if (future.isDone()) {
1:                     if (future.isCancelled()) {
1:                         it.remove();
1:                     } else {
1:                         // check for exception, we may be seeing old state
1:                         try {
1:                             future.get(0, TimeUnit.SECONDS);
1:                             // stale; if we get a result next prune will see Long
1:                         } catch (ExecutionException expected) {
1:                             it.remove();
1:                         } catch (Exception unexpected) {
1:                             LOG.debug("{} unexpected exception verifying exception state of future", this, unexpected);
1:                         }
1:                     }
commit:09bf8f8
/////////////////////////////////////////////////////////////////////////
1:                     + ",size=" + this.size + ",cacheEnabled=" + cacheEnabled
commit:c1e7dbd
/////////////////////////////////////////////////////////////////////////
1:             } else if (LOG.isTraceEnabled()) {
commit:ea70e82
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:efaf9cd
/////////////////////////////////////////////////////////////////////////
1:         MessageId lastAdded = lastCachedIds[SYNC_ADD];
1:         if (lastAdded != null) {
1:             try {
1:                 setBatch(lastAdded);
1:             } catch (Exception e) {
1:                 LOG.error("{} - Failed to set batch on rebase", this, e);
1:                 throw new RuntimeException(e);
1:             }
1:         }
commit:a0ba0bf
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public synchronized boolean isCacheEnabled() {
1:         return super.isCacheEnabled() || enableCacheNow();
1:     }
1: 
1:     protected boolean enableCacheNow() {
1:         boolean result = false;
1:         if (canEnableCash()) {
1:             setCacheEnabled(true);
1:             result = true;
1:             if (LOG.isTraceEnabled()) {
1:                 LOG.trace("{} enabling cache on empty store", this);
1:             }
1:         }
1:         return result;
1:     }
1: 
1:     protected boolean canEnableCash() {
1:         return useCache && size==0 && hasSpace() && isStarted();
1:     }
1: 
1:         for (ListIterator<MessageId> it = pendingCachedIds.listIterator(pendingCachedIds.size()); it.hasPrevious(); ) {
1:             MessageId lastPending = it.previous();
1:             Object futureOrLong = lastPending.getFutureOrSequenceLong();
1:             if (futureOrLong instanceof Future) {
1:                 Future future = (Future) futureOrLong;
1:                 if (future.isCancelled()) {
1:                     continue;
1:                 }
1:                 try {
1:                     future.get(5, TimeUnit.SECONDS);
1:                 } catch (CancellationException ok) {
1:                     continue;
1:                 } catch (TimeoutException potentialDeadlock) {
1:                     LOG.debug("{} timed out waiting for async add", this, potentialDeadlock);
1:                 } catch (Exception worstCaseWeReplay) {
1:                     LOG.debug("{} exception waiting for async add", this, worstCaseWeReplay);
1:             } else {
1:                 setLastCachedId(ASYNC_ADD, lastPending);
1:             break;
1:         }
1: 
1:         MessageId candidate = lastCachedIds[ASYNC_ADD];
1:         if (candidate != null) {
1:             // ensure we don't skip current possibly sync add b/c we waited on the future
1:             if (!isAsync(currentAdd) && Long.compare(((Long) currentAdd.getMessageId().getFutureOrSequenceLong()), ((Long) lastCachedIds[ASYNC_ADD].getFutureOrSequenceLong())) < 0) {
1:                 if (LOG.isTraceEnabled()) {
1:                     LOG.trace("no set batch from async:" + candidate.getFutureOrSequenceLong() + " >= than current: " + currentAdd.getMessageId().getFutureOrSequenceLong() + ", " + this);
1:                 candidate = null;
1:         }
1:         if (candidate == null) {
1:             candidate = lastCachedIds[SYNC_ADD];
1:         }
1:         if (candidate != null) {
1:             setBatch(candidate);
/////////////////////////////////////////////////////////////////////////
0:             } if (LOG.isTraceEnabled()) {
1:                 LOG.trace("no set last cached[" + index + "] current:" + lastCacheFutureOrSequenceLong + " <= than candidate: " + candidateOrSequenceLong+ ", " + this);
commit:511b9b6
/////////////////////////////////////////////////////////////////////////
1:             if (duplicateFromStoreExcepted(message)) {
/////////////////////////////////////////////////////////////////////////
1:     protected boolean duplicateFromStoreExcepted(Message message) {
1:         // expected for messages pending acks with kahadb.concurrentStoreAndDispatchQueues=true for
1:         // which this existing unused flag has been repurposed
1:         return message.isRecievedByDFBridge();
1:     }
1: 
commit:2b1cda1
/////////////////////////////////////////////////////////////////////////
1:             if (gotToTheStore(message)) {
1:     public static boolean gotToTheStore(Message message) throws Exception {
1:         if (message.isRecievedByDFBridge()) {
1:             // concurrent store and dispatch - wait to see if the message gets to the store to see
1:             // if the index suppressed it (original still present), or whether it was stored and needs to be removed
1:             Object possibleFuture = message.getMessageId().getFutureOrSequenceLong();
1:             if (possibleFuture instanceof Future) {
0:                 ((Future) possibleFuture).get();
1:             }
1:             // need to access again after wait on future
1:             Object sequence = message.getMessageId().getFutureOrSequenceLong();
1:             return (sequence != null && sequence instanceof Long && Long.compare((Long) sequence, -1l) != 0);
1:         }
1:         return true;
1:     }
1: 
commit:13ec994
/////////////////////////////////////////////////////////////////////////
1:     protected boolean hadSpace = false;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (this.batchList.isEmpty() && this.size >0) {
commit:d8cf54b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         if (this.batchList.isEmpty() && this.size >0 && hasSpace()) {
commit:88ec9da
/////////////////////////////////////////////////////////////////////////
1:         message.setRegionDestination(regionDestination);
commit:8b8f630
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             setCacheEnabled(size==0&&useCache);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public synchronized boolean addMessageLast(MessageReference node) throws Exception {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         if (this.batchList.isEmpty() && this.size >0) {
/////////////////////////////////////////////////////////////////////////
0:                     + ",size=" + this.size + ",cacheEnabled=" + isCacheEnabled()
commit:1d39f08
/////////////////////////////////////////////////////////////////////////
commit:4705f95
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.CancellationException;
/////////////////////////////////////////////////////////////////////////
0:                     } catch (CancellationException ok) {
0:                         continue;
0:                         LOG.debug("{} timed out waiting for async add", this, potentialDeadlock);
0:                     } catch (Exception worstCaseWeReplay) {
0:                         LOG.debug("{} exception waiting for async add", this, worstCaseWeReplay);
1:                     }
/////////////////////////////////////////////////////////////////////////
0:                 if (isAsync(currentAdd) || Long.compare(((Long) currentAdd.getMessageId().getFutureOrSequenceLong()), ((Long) lastCachedIds[ASYNC_ADD].getFutureOrSequenceLong())) > 0) {
/////////////////////////////////////////////////////////////////////////
1:         if (isAsync(node.getMessage())) {
/////////////////////////////////////////////////////////////////////////
1:     private static final boolean isAsync(Message message) {
1:         return message.isRecievedByDFBridge() || message.getMessageId().getFutureOrSequenceLong() instanceof Future;
1:     }
1: 
commit:9c2b1d2
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.TimeoutException;
/////////////////////////////////////////////////////////////////////////
0:         storeHasMessages = true;
/////////////////////////////////////////////////////////////////////////
1:                 if (LOG.isTraceEnabled()) {
1:                     LOG.trace("{} store replayed pending message due to concurrentStoreAndDispatchQueues {} seq: {}", this, message.getMessageId(), message.getMessageId().getFutureOrSequenceLong());
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                 if (LOG.isTraceEnabled()) {
0:                     LOG.trace("{} - enabling cache for empty store {} {}", this, node.getMessageId(), node.getMessageId().getFutureOrSequenceLong());
1:                 }
/////////////////////////////////////////////////////////////////////////
1:             if (LOG.isTraceEnabled()) {
1:                 LOG.trace("{} - disabling cache on add {} {}", this, node.getMessageId(), node.getMessageId().getFutureOrSequenceLong());
1:             }
1:             syncWithStore(node.getMessage());
1:     private void syncWithStore(Message currentAdd) throws Exception {
1:         pruneLastCached();
0:             // possibly only async adds, lets wait on the potential last add and reset from there
0:                 MessageId lastPending = it.previous();
0:                 Object futureOrLong = lastPending.getFutureOrSequenceLong();
1:                     try {
0:                         future.get(5, TimeUnit.SECONDS);
1:                         setLastCachedId(ASYNC_ADD, lastPending);
0:                     } catch (TimeoutException potentialDeadlock) {
0:                         LOG.warn("{} timed out waiting for async add", this, potentialDeadlock);
0:                     } catch (Exception cancelledOrTimeOutOrErrorWorstCaseWeReplay) {cancelledOrTimeOutOrErrorWorstCaseWeReplay.printStackTrace();}
1:                 } else {
1:                     setLastCachedId(ASYNC_ADD, lastPending);
1:                 break;
0:                 // ensure we don't skip current possibly sync add b/c we waited on the future
0:                 if (currentAdd.isRecievedByDFBridge() || Long.compare(((Long) currentAdd.getMessageId().getFutureOrSequenceLong()), ((Long) lastCachedIds[ASYNC_ADD].getFutureOrSequenceLong())) > 0) {
0:                     setBatch(lastCachedIds[ASYNC_ADD]);
1:         } else {
0:             setBatch(lastCachedIds[SYNC_ADD]);
/////////////////////////////////////////////////////////////////////////
0:         if (node.getMessageId().getFutureOrSequenceLong() instanceof Future || node.getMessage().isRecievedByDFBridge()) {
/////////////////////////////////////////////////////////////////////////
1: 
1:                 // keep lock step with sync adds while order is preserved
1:                 if (lastCachedIds[SYNC_ADD] != null) {
1:                     long next = 1 + (Long)lastCachedIds[SYNC_ADD].getFutureOrSequenceLong();
1:                     if (Long.compare((Long)futureOrLong, next) == 0) {
1:                         setLastCachedId(SYNC_ADD, candidate);
1:                     } else {
0:                         // out of sequence, revert to sync state
0:                         if (LOG.isDebugEnabled()) {
0:                             LOG.debug("{} cursor order out of sync at seq {}, audit must suppress potential replay of {} messages from the store", this, next, pendingCachedIds.size());
1:                         }
1:                     }
1:                 }
/////////////////////////////////////////////////////////////////////////
0:             // avoid repeated  trips to the store if there is nothing of interest
0:             this.storeHasMessages = false;
0:             if (!this.storeHasMessages && (!this.batchList.isEmpty() || !hadSpace)) {
0:                 this.storeHasMessages = true;
1:             }
commit:0cf7c0b
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isTraceEnabled()) {
1:             LOG.trace("{} fillBatch", this);
1:         }
commit:97c127d
/////////////////////////////////////////////////////////////////////////
1: import java.util.ListIterator;
/////////////////////////////////////////////////////////////////////////
1:     private static int SYNC_ADD = 0;
1:     private static int ASYNC_ADD = 1;
1:     final MessageId[] lastCachedIds = new MessageId[2];
/////////////////////////////////////////////////////////////////////////
1:                     trackLastCached(node);
/////////////////////////////////////////////////////////////////////////
0:             LOG.trace("{} - disabling cache on add {} {}", this, node.getMessageId(), node.getMessageId().getFutureOrSequenceLong());
0:             syncWithStore();
0:     private void syncWithStore() throws Exception {
0:         if (lastCachedIds[SYNC_ADD] == null) {
0:             // only async adds, lets wait on the potential last add and reset from there
0:             for (ListIterator<MessageId> it = pendingCachedIds.listIterator(pendingCachedIds.size()); it.hasPrevious(); ) {
0:                 MessageId lastStored = it.previous();
0:                 Object futureOrLong = lastStored.getFutureOrSequenceLong();
1:                 if (futureOrLong instanceof Future) {
1:                     Future future = (Future) futureOrLong;
0:                     if (future.isCancelled()) {
0:                         continue;
1:                     } else {
1:                         try {
0:                             future.get();
0:                             setLastCachedId(ASYNC_ADD, lastStored);
0:                         } catch (Exception ignored) {}
1:                     }
1:                 }
1:             }
0:             if (lastCachedIds[ASYNC_ADD] != null) {
0:                 setBatch(lastCachedIds[ASYNC_ADD]);
1:             }
1:         } else {
0:             // mix of async and sync - async can exceed sync only if next in sequence
1:             for (Iterator<MessageId> it = pendingCachedIds.iterator(); it.hasNext(); ) {
1:                 MessageId candidate = it.next();
1:                 final Object futureOrLong = candidate.getFutureOrSequenceLong();
1:                 if (futureOrLong instanceof Future) {
1:                     Future future = (Future) futureOrLong;
0:                     if (future.isCancelled()) {
1:                         it.remove();
1:                     } else {
1:                         try {
0:                             future.get();
0:                             long next = 1 + (Long)lastCachedIds[SYNC_ADD].getFutureOrSequenceLong();
0:                             if (Long.compare(((Long) candidate.getFutureOrSequenceLong()), next) == 0) {
0:                                 setLastCachedId(SYNC_ADD, candidate);
1:                             } else {
0:                                 // out of sequence, revert to sync state
0:                                 LOG.trace("{} cursor order out of sync at seq {}, audit must suppress potential replay of {} messages from the store", this, next, pendingCachedIds.size());
0:                                 break;
1:                             }
0:                         } catch (Exception ignored) {}
1:                     }
1:                 }
1:             }
0:             if (lastCachedIds[SYNC_ADD] != null) {
0:                 setBatch(lastCachedIds[SYNC_ADD]);
1:             }
1: 
1:         }
1:         // cleanup
1:         lastCachedIds[SYNC_ADD] = lastCachedIds[ASYNC_ADD] = null;
1:         pendingCachedIds.clear();
1:     }
1: 
1:     private void trackLastCached(MessageReference node) {
0:         if (node.getMessageId().getFutureOrSequenceLong() instanceof Future) {
1:             pruneLastCached();
1:             pendingCachedIds.add(node.getMessageId());
1:         } else {
1:             setLastCachedId(SYNC_ADD, node.getMessageId());
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:                     // we don't want to wait for work to complete
1:                 // complete
1:                 setLastCachedId(ASYNC_ADD, candidate);
1:     private void setLastCachedId(final int index, MessageId candidate) {
0:         if (lastCachedIds[index] == null || lastCachedIds[index].getFutureOrSequenceLong() == null) {  // possibly null for topics
1:             lastCachedIds[index] = candidate;
0:         } else if (Long.compare(((Long) candidate.getFutureOrSequenceLong()), ((Long) lastCachedIds[index].getFutureOrSequenceLong())) > 0) {
1:             lastCachedIds[index] = candidate;
/////////////////////////////////////////////////////////////////////////
1:                     + ",maxBatchSize:" + maxBatchSize + ",hasSpace:" + hasSpace() + ",pendingCachedIds.size:" + pendingCachedIds.size()
1:                     + ",lastSyncCachedId:" + lastCachedIds[SYNC_ADD] + ",lastSyncCachedId-seq:" + (lastCachedIds[SYNC_ADD] != null ? lastCachedIds[SYNC_ADD].getFutureOrSequenceLong() : "null")
1:                     + ",lastAsyncCachedId:" + lastCachedIds[ASYNC_ADD] + ",lastAsyncCachedId-seq:" + (lastCachedIds[ASYNC_ADD] != null ? lastCachedIds[ASYNC_ADD].getFutureOrSequenceLong() : "null");
commit:140ce1b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         } else if (!cached) {
1:             // a duplicate from the store (!cached) - needs to be removed/acked - otherwise it will get re dispatched on restart
0:             if (message.isRecievedByDFBridge()) {
0:                 // expected for messages pending acks with kahadb.concurrentStoreAndDispatchQueues=true
0:                 LOG.trace("{} store replayed pending message due to concurrentStoreAndDispatchQueues {} seq: {}", this, message.getMessageId(), message.getMessageId().getFutureOrSequenceLong());
1:             } else {
1:                 LOG.warn("{} - cursor got duplicate from store {} seq: {}", this, message.getMessageId(), message.getMessageId().getFutureOrSequenceLong());
1:                 duplicate(message);
1:             }
1:             LOG.warn("{} - cursor got duplicate send {} seq: {}", this, message.getMessageId(), message.getMessageId().getFutureOrSequenceLong());
0:             if (message.getMessageId().getEntryLocator() instanceof Long) {
0:                 // JDBC will store a duplicate (with new sequence id) - it needs an ack  (AMQ4952Test)
/////////////////////////////////////////////////////////////////////////
0:                 pruneLastCached();
0:                     pendingCachedIds.clear();
/////////////////////////////////////////////////////////////////////////
0:                 } else {
0:                     break;
/////////////////////////////////////////////////////////////////////////
0:         if (lastCachedId == null || lastCachedId.getFutureOrSequenceLong() == null) {  // possibly null for topics
/////////////////////////////////////////////////////////////////////////
0:                     + ",maxBatchSize:" + maxBatchSize + ",hasSpace:" + hasSpace() + ",pendingCachedIds.size:" + pendingCachedIds.size() + ",lastCachedId:" + lastCachedId + ",lastCachedId-seq:" + (lastCachedId != null ? lastCachedId.getFutureOrSequenceLong() : "null");
commit:54e2e3b
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.CancellationException;
1: import java.util.concurrent.Future;
/////////////////////////////////////////////////////////////////////////
0:     private LinkedList<MessageId> pendingCachedIds = new LinkedList<>();
0:     MessageId lastCachedId = null;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:             LOG.warn("{} - cursor got duplicate {} seq: {}", this, message.getMessageId(), message.getMessageId().getFutureOrSequenceLong());
1: 
0:             // a duplicate from the store - needs to be removed/acked - otherwise it will get redispatched on restart
0:             // jdbc store will store duplicates and will set entry locator to sequence long.
0:             // REVISIT - this seems too hacky - see use case AMQ4952Test
0:             if (!cached || message.getMessageId().getEntryLocator() instanceof Long) {
/////////////////////////////////////////////////////////////////////////
0:     public final synchronized boolean addMessageLast(MessageReference node) throws Exception {
0:                 LOG.trace("{} - enabling cache for empty store {} {}", this, node.getMessageId(), node.getMessageId().getFutureOrSequenceLong());
0:                     if (node.getMessageId().getFutureOrSequenceLong() instanceof Future) {
0:                         pruneLastCached();
0:                         pendingCachedIds.add(node.getMessageId());
0:                     } else {
0:                         setLastCachedId(node.getMessageId());
1:                     }
1:                     return false;
/////////////////////////////////////////////////////////////////////////
0:             if (!pendingCachedIds.isEmpty() || lastCachedId != null) {
0:                 LOG.trace("{} - disabling cache. current Id: {} seq: {}, batchList size: {}",
0:                             new Object[]{this, node.getMessageId(), node.getMessageId().getFutureOrSequenceLong(), batchList.size()});
0:                 collapseLastCachedIds();
0:                 if (lastCachedId != null) {
0:                     setBatch(lastCachedId);
0:                     lastCachedId = null;
1:                 }
1:         return true;
1:     }
1: 
1: 
1:     private void pruneLastCached() {
0:         for (Iterator<MessageId> it = pendingCachedIds.iterator(); it.hasNext(); ) {
0:             MessageId candidate = it.next();
0:             final Object futureOrLong = candidate.getFutureOrSequenceLong();
0:             if (futureOrLong instanceof Future) {
0:                 Future future = (Future) futureOrLong;
0:                 if (future.isCancelled()) {
0:                     it.remove();
1:                 }
0:             } else {
0:                 // store complete - track via lastCachedId
0:                 setLastCachedId(candidate);
0:                 it.remove();
1:             }
1:         }
1:     }
1: 
0:     private void collapseLastCachedIds() throws Exception {
0:         for (MessageId candidate : pendingCachedIds) {
0:             final Object futureOrLong = candidate.getFutureOrSequenceLong();
0:             if (futureOrLong instanceof Future) {
0:                 Future future = (Future) futureOrLong;
0:                 try {
0:                     future.get();
0:                     // future should be replaced with sequence by this time
0:                 } catch (CancellationException ignored) {
0:                     continue;
1:                 }
1:             }
0:             setLastCachedId(candidate);
1:         }
0:         pendingCachedIds.clear();
1:     }
1: 
0:     private void setLastCachedId(MessageId candidate) {
0:         if (lastCachedId == null) {
0:             lastCachedId = candidate;
0:         } else if (Long.compare(((Long) candidate.getFutureOrSequenceLong()), ((Long) lastCachedId.getFutureOrSequenceLong())) > 0) {
0:             lastCachedId = candidate;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         for (MessageReference msg : batchList) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     + ",maxBatchSize:" + maxBatchSize + ",hasSpace:" + hasSpace() + ",pendingCachedIds.size:" + pendingCachedIds.size() + ",lastCachedId:" + lastCachedId;
commit:27b3a7c
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug(this + " - cursor got duplicate: " + message.getMessageId() + "," + message.getPriority() + ", cached=" + cached, new Throwable("duplicate message detected"));
0:             } else {
0:                 LOG.warn("{} - cursor got duplicate {}", regionDestination.getActiveMQDestination(), message.getMessageId());
1:             }
0:             if (!cached ||  message.getMessageId().getEntryLocator() != null) {
0:                 // came from the store or was added to the jdbc store
1:                 duplicate(message);
1:             }
/////////////////////////////////////////////////////////////////////////
0:                     return;
commit:cfe099d
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public void rebase() {
1:         resetSize();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
commit:f92d45b
/////////////////////////////////////////////////////////////////////////
1: import java.util.LinkedList;
1: import org.apache.activemq.broker.region.Subscription;
/////////////////////////////////////////////////////////////////////////
0:             LOG.warn("{} - cursor got duplicate: {}, {}", new Object[]{ this, message.getMessageId(), message.getPriority() });
0:             duplicate(message);
1: 
1:     // track for processing outside of store index lock so we can dlq
1:     final LinkedList<Message> duplicatesFromStore = new LinkedList<Message>();
1:     private void duplicate(Message message) {
1:         duplicatesFromStore.add(message);
1:     }
1: 
1:     void dealWithDuplicates() {
1:         for (Message message : duplicatesFromStore) {
1:             regionDestination.duplicateFromStore(message, getSubscription());
1:         }
1:         duplicatesFromStore.clear();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:                     LOG.debug(this + " duplicate add {}", node.getMessage(), new Throwable("duplicated detected"));
1:                     dealWithDuplicates();
/////////////////////////////////////////////////////////////////////////
0:         //LOG.trace("{} - fillBatch", this);
/////////////////////////////////////////////////////////////////////////
1: 
1:     public Subscription getSubscription() {
1:         return null;
1:     }
commit:511b60c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.TransactionId;
/////////////////////////////////////////////////////////////////////////
0:     private TransactionId lastTx;
/////////////////////////////////////////////////////////////////////////
0:                     lastTx = node.getMessage().getTransactionId();
/////////////////////////////////////////////////////////////////////////
0:                 LOG.debug("{} - disabling cache, lastCachedId: {} last-tx: {} current node Id: {} node-tx: {} batchList size: {}",
0:                         new Object[]{ this, lastCachedId, lastTx, node.getMessageId(), node.getMessage().getTransactionId(), batchList.size() });
0:                 lastTx = null;
/////////////////////////////////////////////////////////////////////////
0:                     + ",maxBatchSize:" + maxBatchSize + ",hasSpace:" + hasSpace();
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:cc6213e
/////////////////////////////////////////////////////////////////////////
1:     private final LinkedList<MessageId> pendingCachedIds = new LinkedList<>();
/////////////////////////////////////////////////////////////////////////
1:     public synchronized boolean tryAddMessageLast(MessageReference node, long wait) throws Exception {
commit:734fb7d
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     public final synchronized long messageSize() {
1:         return getStoreMessageSize();
1:     }
1: 
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     protected abstract long getStoreMessageSize();
1: 
commit:b40dc4c
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         MessageId lastCacheId = lastCachedIds[index];
1:         if (lastCacheId == null) {
0:         } else {
1:             Object lastCacheFutureOrSequenceLong = lastCacheId.getFutureOrSequenceLong();
1:             Object candidateOrSequenceLong = candidate.getFutureOrSequenceLong();
1:             if (lastCacheFutureOrSequenceLong == null) { // possibly null for topics
1:                 lastCachedIds[index] = candidate;
1:             } else if (candidateOrSequenceLong != null &&
1:                     Long.compare(((Long) candidateOrSequenceLong), ((Long) lastCacheFutureOrSequenceLong)) > 0) {
1:                 lastCachedIds[index] = candidate;
1:             }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
author:Timothy Bish
-------------------------------------------------------------------------------
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
0:             LOG.trace("{} - cursor got duplicate: {}, {}", new Object[]{ this, message.getMessageId(), message.getPriority() });
/////////////////////////////////////////////////////////////////////////
1:                 LOG.error("{} - Failed to fill batch", this, e);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.error("{} - Failed to fill batch", this, e);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.trace("{} - enabling cache for empty store {}", this, node.getMessageId());
/////////////////////////////////////////////////////////////////////////
0:                 LOG.trace(this + "{} - disabling cache, lastCachedId: {} current node Id: {} batchList size: {}", new Object[]{ this, lastCachedId, node.getMessageId(), batchList.size() });
/////////////////////////////////////////////////////////////////////////
0:         LOG.trace("{} - fillBatch", this);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.error("{} - Failed to fill batch", this, e);
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:a7533ba
/////////////////////////////////////////////////////////////////////////
1:     public synchronized void addMessageFirst(MessageReference node) throws Exception {
commit:7450a32
/////////////////////////////////////////////////////////////////////////
0:     protected boolean hadSpace = false;
/////////////////////////////////////////////////////////////////////////
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(AbstractStoreCursor.class);
commit:24a7626
/////////////////////////////////////////////////////////////////////////
0:                     LOG.debug(regionDestination.getActiveMQDestination().getPhysicalName() + " disabling cache on size:" + size
0:                             + ", lastCachedIdSeq: " + (lastCachedId == null ? -1 : lastCachedId.getBrokerSequenceId())
0:                             + " current node seqId: " + node.getMessageId().getBrokerSequenceId());
commit:50dc880
/////////////////////////////////////////////////////////////////////////
0:             LOG.error(regionDestination.getActiveMQDestination().getPhysicalName() + " cursor got duplicate: " + message);
/////////////////////////////////////////////////////////////////////////
commit:5170a8b
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug(regionDestination.getActiveMQDestination().getPhysicalName() + " cursor got duplicate: " + message);
1:             }
/////////////////////////////////////////////////////////////////////////
0:             if (lastCachedId != null && node.getMessageId().getBrokerSequenceId() < lastCachedId.getBrokerSequenceId()) {
0:                 lastCachedId = node.getMessageId();
0:                 setBatch(lastCachedId);
1:             }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
commit:180b0ec
/////////////////////////////////////////////////////////////////////////
1:     protected void setBatch(MessageId messageId) throws Exception {
commit:ce1d85d
/////////////////////////////////////////////////////////////////////////
1:                 if( message.getMemoryUsage()==null ) {
1:                     message.setMemoryUsage(this.getSystemUsage().getMemoryUsage());
1:                 }
commit:01ab56f
/////////////////////////////////////////////////////////////////////////
0:             result.decrementReferenceCount();
author:Gary Tully
-------------------------------------------------------------------------------
commit:eaac0d2
/////////////////////////////////////////////////////////////////////////
1:         this.size = getStoreSize();
commit:99be769
/////////////////////////////////////////////////////////////////////////
1:     protected boolean batchResetNeeded = false;
/////////////////////////////////////////////////////////////////////////
1:             super.start();
commit:d41f40a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             resetSize();
1:             setMaxBatchSize(Math.min(regionDestination.getMaxPageSize(), size));
/////////////////////////////////////////////////////////////////////////
0:                     + ",storeHasMessages=" + this.storeHasMessages + ",size=" + this.size + ",cacheEnabled=" + isCacheEnabled()
0:                     + ",maxBatchSize:" + maxBatchSize;
commit:6b4d077
/////////////////////////////////////////////////////////////////////////
1:         boolean disableCache = false;
/////////////////////////////////////////////////////////////////////////
1:                 if (recoverMessage(node.getMessage(),true)) {
0:                     lastCachedId = node.getMessageId();
0:                 } else {
0:                     // failed to recover, possible duplicate from concurrent dispatchPending,
0:                     // lets not recover further in case of out of order
1:                     disableCache = true;
1:                 }
0:         } else {
1:             disableCache = true;
1:         }
1: 
1:         if (disableCache && isCacheEnabled()) {
commit:53b29a2
/////////////////////////////////////////////////////////////////////////
0:         // wonder do we need to determine size here, it may change before restart
commit:9c9b856
/////////////////////////////////////////////////////////////////////////
1:         if (batchList.remove(node) != null) {
1:             size--;
1:             setCacheEnabled(false);
1:         }
commit:caca105
/////////////////////////////////////////////////////////////////////////
0:             this.storeHasMessages = !this.batchList.isEmpty() || !hadSpace;
commit:d5813be
/////////////////////////////////////////////////////////////////////////
0:         if (isStarted()) {
1:             this.size = getStoreSize();
1:         }
commit:101e711
/////////////////////////////////////////////////////////////////////////
0:             resetSize();
1: 
1:     protected void resetSize() {
0:         this.size = getStoreSize();
0:         this.storeHasMessages=this.size > 0;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         resetSize();
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:         return super.toString() + ":" + regionDestination.getActiveMQDestination().getPhysicalName() + ",batchResetNeeded=" + batchResetNeeded
commit:fe31092
/////////////////////////////////////////////////////////////////////////
1:     protected final PendingList batchList;
/////////////////////////////////////////////////////////////////////////
1:     public final synchronized void reset() {
/////////////////////////////////////////////////////////////////////////
0:                             + " current node Id: " + node.getMessageId() + " batchList size: " + batchList.size());
commit:cb96783
/////////////////////////////////////////////////////////////////////////
0:         } else {
/////////////////////////////////////////////////////////////////////////
0:             setCacheEnabled(!this.storeHasMessages&&useCache);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.trace(this + " - cursor got duplicate: " + message.getMessageId() + ", " + message.getPriority());
/////////////////////////////////////////////////////////////////////////
0:                 LOG.error(this + " - Failed to fill batch", e);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.error(this + " - Failed to fill batch", e);
/////////////////////////////////////////////////////////////////////////
0:             if (!isCacheEnabled() && size==0 && isStarted() && useCache) {
0:                     LOG.trace(this + " - enabling cache for empty store " + node.getMessageId());
0:                 setCacheEnabled(true);
1:             if (isCacheEnabled()) {
0:         } else if (isCacheEnabled()) {
1:             setCacheEnabled(false);
0:                     LOG.trace(this + " - disabling cache"
/////////////////////////////////////////////////////////////////////////
1:         setCacheEnabled(false);
/////////////////////////////////////////////////////////////////////////
0:         setCacheEnabled(false);
/////////////////////////////////////////////////////////////////////////
0:         setCacheEnabled(false);
/////////////////////////////////////////////////////////////////////////
0:             LOG.trace(this + " - fillBatch");
/////////////////////////////////////////////////////////////////////////
0:                 LOG.error(this + " - Failed to fill batch", e);
/////////////////////////////////////////////////////////////////////////
1: 
1:     public String toString() {
0:         return regionDestination.getActiveMQDestination().getPhysicalName() + ",batchResetNeeded=" + batchResetNeeded
0:                     + ",storeHasMessages=" + this.storeHasMessages + ",size=" + this.size + ",cacheEnabled=" + isCacheEnabled();
1:     }
commit:acc3d4f
/////////////////////////////////////////////////////////////////////////
1:         if (hasSpace()) {
0:             if (!cacheEnabled && size==0 && isStarted() && useCache) {
0:                     LOG.trace(regionDestination.getActiveMQDestination().getPhysicalName()
0:                             + " enabling cache for empty store " + node.getMessageId());
0:                 cacheEnabled=true;
1:             }
0:             if (cacheEnabled) {
0:                 recoverMessage(node.getMessage(),true);
0:                 lastCachedId = node.getMessageId();
1:             }
0:         } else if (cacheEnabled) {
0:             cacheEnabled=false;
0:             // sync with store on disabling the cache
0:             if (lastCachedId != null) {
0:                 if (LOG.isTraceEnabled()) {
0:                     LOG.trace(regionDestination.getActiveMQDestination().getPhysicalName()
0:                             + " disabling cache on size:" + size
0:                             + ", lastCachedId: " + lastCachedId
0:                             + " current node Id: " + node.getMessageId());
0:                 setBatch(lastCachedId);
0:                 lastCachedId = null;
commit:aad7e73
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             cacheEnabled = !this.storeHasMessages&&useCache;
/////////////////////////////////////////////////////////////////////////
0:         if (!cacheEnabled && size==0 && isStarted() && useCache && hasSpace()) {
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug(regionDestination.getActiveMQDestination().getPhysicalName() + " enabling cache on empty add");
1:             }
0:             cacheEnabled=true;
1:         }
/////////////////////////////////////////////////////////////////////////
commit:f7d6338
/////////////////////////////////////////////////////////////////////////
0:                     + ", hasMessages=" + this.storeHasMessages + ", size=" + this.size + ", cacheEnabled=" + this.cacheEnabled);
commit:3ddb71c
/////////////////////////////////////////////////////////////////////////
0:     private boolean storeHasMessages = false;
0:     private boolean hadSpace = false;
1: 
/////////////////////////////////////////////////////////////////////////
0:             storeHasMessages = true;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         this.storeHasMessages = true;
/////////////////////////////////////////////////////////////////////////
1:     public synchronized void gc() {
/////////////////////////////////////////////////////////////////////////
1: 
0:     @Override
0:     public boolean hasSpace() {
0:         hadSpace = super.hasSpace();
0:         return hadSpace;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         if (this.batchList.isEmpty() && this.storeHasMessages && this.size >0) {
/////////////////////////////////////////////////////////////////////////
0:             if (!this.batchList.isEmpty() || !hadSpace) {
commit:6519c3e
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isTraceEnabled()) {
0:                 LOG.trace(regionDestination.getActiveMQDestination().getPhysicalName()
0:                         + " cursor got duplicate: " + message.getMessageId() + ", " + message.getPriority());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 if (LOG.isTraceEnabled()) {
0:                     LOG.trace(regionDestination.getActiveMQDestination().getPhysicalName() + " disabling cache on size:" + size
/////////////////////////////////////////////////////////////////////////
commit:7d54942
/////////////////////////////////////////////////////////////////////////
0:     protected boolean cacheEnabled=false;
commit:3f0cf98
/////////////////////////////////////////////////////////////////////////
0:             super.start();      
commit:3432a75
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isTraceEnabled()) {
0:             LOG.trace("fillBatch - batchResetNeeded=" + batchResetNeeded
0:                     + ", hasMessages=" + this.storeHasMessages + ", size=" + this.size);
1:         }
commit:969e758
/////////////////////////////////////////////////////////////////////////
0:         if (size==0 && isStarted() && useCache && hasSpace() && isStoreEmpty()) {
commit:eb983f7
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug(regionDestination.getActiveMQDestination().getPhysicalName() + " cursor got duplicate: " + message);
1:             }
commit:5619cd0
/////////////////////////////////////////////////////////////////////////
1:         if (result != null) {
1:             result.incrementReferenceCount();
1:         }
commit:8732f70
/////////////////////////////////////////////////////////////////////////
0:             LOG.error(regionDestination.getActiveMQDestination().getPhysicalName() + " cursor got duplicate: " + message);
commit:9b260dc
/////////////////////////////////////////////////////////////////////////
0:         last = null;
/////////////////////////////////////////////////////////////////////////
1:         MessageReference result = null;
1:         last = result;
/////////////////////////////////////////////////////////////////////////
1:         if (last != null) {
1:             last.decrementReferenceCount();
1:         }
commit:c8e518b
/////////////////////////////////////////////////////////////////////////
0:     private boolean cacheEnabled=false;
/////////////////////////////////////////////////////////////////////////
1:         if (recordUniqueId(message.getMessageId())) {
/////////////////////////////////////////////////////////////////////////
0:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug(regionDestination.getActiveMQDestination().getPhysicalName() + " disabling cache on size:" + size);
1:                 }
/////////////////////////////////////////////////////////////////////////
0:         if (size==0 && isStarted() && useCache && hasSpace() && getStoreSize() == 0) {
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug(regionDestination.getActiveMQDestination().getPhysicalName() + " enabling cache on last remove");
1:             }
0:             cacheEnabled=true;
1:         }
commit:132f662
/////////////////////////////////////////////////////////////////////////
1:     public synchronized boolean recoverMessage(Message message, boolean cached) throws Exception {
1:         boolean recovered = false;
/////////////////////////////////////////////////////////////////////////
1:             recovered = true;
0:                 LOG.debug(regionDestination.getActiveMQDestination().getPhysicalName() + " cursor got duplicate: " + message);
1:         return recovered;
commit:08aecbe
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: public abstract class AbstractStoreCursor extends AbstractPendingMessageCursor implements MessageRecoveryListener {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 if (lastCachedId != null) {
0:                     setBatch(lastCachedId);
1:                 }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:9bb4682
/////////////////////////////////////////////////////////////////////////
0:                 cacheEnabled=false;
commit:d7f34d9
/////////////////////////////////////////////////////////////////////////
0:     private MessageId lastCachedId;
/////////////////////////////////////////////////////////////////////////
0:             lastCachedId = node.getMessageId();
0:         } else {
0:             if (cacheEnabled) {
0:                 // sync with store on disabling the cache
0:                 setBatch(lastCachedId);
1:             }
0:     protected void setBatch(MessageId messageId) {
1:     }
1: 
commit:81f0cc0
/////////////////////////////////////////////////////////////////////////
1:         size();
/////////////////////////////////////////////////////////////////////////
0:         if (size==0 && isStarted() && useCache) {
/////////////////////////////////////////////////////////////////////////
0:         batchList.remove(node.getMessageId());
/////////////////////////////////////////////////////////////////////////
1:         // negative means more messages added to store through queue.send since last reset
1:         return size == 0;
/////////////////////////////////////////////////////////////////////////
1:         if (size < 0) {
0:             this.size = getStoreSize();
commit:5d93518
/////////////////////////////////////////////////////////////////////////
1:         gc();
/////////////////////////////////////////////////////////////////////////
0:         if (isStarted()) { 
0:             size = getStoreSize();
0:         } else {
0:             size = 0;
1:         }
commit:6dbd5d1
/////////////////////////////////////////////////////////////////////////
0:         size = getStoreSize();
author:Robert Davies
-------------------------------------------------------------------------------
commit:d1b5029
/////////////////////////////////////////////////////////////////////////
0:         if (size==0 && isStarted() && useCache && hasSpace() ) {
commit:00879cf
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private final PendingList batchList;
1:     private Iterator<MessageReference> iterator = null;
/////////////////////////////////////////////////////////////////////////
1:         super((destination != null ? destination.isPrioritizedMessages():false));
1:         if (this.prioritizedMessages) {
1:             this.batchList= new PrioritizedPendingList();
0:         }else {
1:             this.batchList = new OrderedPendingList();
1:         }
1:     
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:             batchList.addMessageLast(message);
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:             this.iterator=this.batchList.iterator();
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
0:     
1:             result = this.iterator.next();
/////////////////////////////////////////////////////////////////////////
0:     
/////////////////////////////////////////////////////////////////////////
0:     
0:     
/////////////////////////////////////////////////////////////////////////
0:     
0:         batchList.remove(node);
0:     
0:     
0:         for (Iterator<MessageReference>i = batchList.iterator();i.hasNext();) {
0:             MessageReference msg = i.next();
/////////////////////////////////////////////////////////////////////////
0:     
/////////////////////////////////////////////////////////////////////////
0:     
0:     
0:     
commit:ac0462a
/////////////////////////////////////////////////////////////////////////
0:             /*
0:              * we should expect to get these - as the message is recorded as it before it goes into
0:              * the cache. If subsequently, we pull out that message from the store (before its deleted)
0:              * it will be a duplicate - but should be ignored
1:              */
0:             //LOG.error(regionDestination.getActiveMQDestination().getPhysicalName() + " cursor got duplicate: " + message);
commit:affd91e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
0:     @Override
/////////////////////////////////////////////////////////////////////////
0:         if (size==0 && isStarted() && useCache && hasSpace() && isStoreEmpty()) {
/////////////////////////////////////////////////////////////////////////
0:     @Override
0:     @Override
0:     @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
0:     @Override
0:     @Override
/////////////////////////////////////////////////////////////////////////
0:     
1:     protected abstract boolean isStoreEmpty();
commit:d261412
/////////////////////////////////////////////////////////////////////////
0:     private final LinkedHashMap<MessageId,Message> batchList = new LinkedHashMap<MessageId,Message> ();
0:     private Iterator<Entry<MessageId, Message>> iterator = null;
/////////////////////////////////////////////////////////////////////////
1:             clearIterator(true);
/////////////////////////////////////////////////////////////////////////
1:         clearIterator(true);
1:     public synchronized void release() {
1:         clearIterator(false);
1:     }
0:     
1:     private synchronized void clearIterator(boolean ensureIterator) {
1:         boolean haveIterator = this.iterator != null;
1:         if(haveIterator&&ensureIterator) {
1:             ensureIterator();
1:         }
1:     }
0:     
1:     private synchronized void ensureIterator() {
1:         if(this.iterator==null) {
0:             this.iterator=this.batchList.entrySet().iterator();
1:         }
/////////////////////////////////////////////////////////////////////////
1:         ensureIterator();
/////////////////////////////////////////////////////////////////////////
1:         clearIterator(false);
commit:b6115cf
/////////////////////////////////////////////////////////////////////////
0:         size=0;
commit:47cfa55
/////////////////////////////////////////////////////////////////////////
0:     protected Iterator<Entry<MessageId, Message>> iterator = null;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         this.iterator = this.batchList.entrySet().iterator();
1:     }
0:     
0:     public void release() {
1:         this.iterator=null;
1:     }
0: 
0: 
1:     public final void finished() {
1:     }
0:         
1:     public final synchronized boolean hasNext() {
1:         if (batchList.isEmpty()) {
0:             try {
1:                 fillBatch();
0:                 this.iterator = this.batchList.entrySet().iterator();
1:             } catch (Exception e) {
0:                 LOG.error("Failed to fill batch", e);
1:                 throw new RuntimeException(e);
1:             }
0:         }else {
0:             if (this.iterator==null) {
0:                 this.iterator=this.batchList.entrySet().iterator();
1:             }
1:         }
1:         return this.iterator.hasNext();
1:         if (!this.batchList.isEmpty()&&this.iterator.hasNext()) {
0:             result = this.iterator.next().getValue();
/////////////////////////////////////////////////////////////////////////
1:         if (iterator!=null) {
1:             iterator.remove();
0:         }
commit:6d0c552
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             super.start();
0:             clear();
1:             resetBatch();
0:         } 
/////////////////////////////////////////////////////////////////////////
0:         
0:         if( this.batchList.isEmpty() && (this.storeHasMessages ||this.size >0)) {
/////////////////////////////////////////////////////////////////////////
commit:149428b
/////////////////////////////////////////////////////////////////////////
0:     protected static final int MAX_FILL_ATTEMPTS=3;
/////////////////////////////////////////////////////////////////////////
0:         //we may have to move the store cursor past messages that have 
0:         //already been delivered - but we also don't want it to spin
0:         int fillAttempts=0;
0:         while (fillAttempts < MAX_FILL_ATTEMPTS && this.batchList.isEmpty() && (this.storeHasMessages ||this.size >0)) {
/////////////////////////////////////////////////////////////////////////
0:             fillAttempts++;
commit:071b4b1
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker.region.cursors;
0: 
0: import java.io.IOException;
1: import java.util.Iterator;
0: import java.util.LinkedHashMap;
0: import java.util.Map;
0: import java.util.Map.Entry;
0: 
1: import org.apache.activemq.broker.region.Destination;
1: import org.apache.activemq.broker.region.MessageReference;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.store.MessageRecoveryListener;
0: import org.apache.activemq.usage.Usage;
0: import org.apache.activemq.usage.UsageListener;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: 
1: /**
1:  *  Store based cursor
1:  *
1:  */
0: public abstract class AbstractStoreCursor extends AbstractPendingMessageCursor implements MessageRecoveryListener, UsageListener {
0:     private static final Log LOG = LogFactory.getLog(AbstractStoreCursor.class);
1:     protected final Destination regionDestination;
0:     protected final LinkedHashMap<MessageId,Message> batchList = new LinkedHashMap<MessageId,Message> ();
0:     protected boolean cacheEnabled=false;
0:     protected boolean batchResetNeeded = true;
0:     protected boolean storeHasMessages = false;
1:     protected int size;
0:     
1:     protected AbstractStoreCursor(Destination destination) {
1:         this.regionDestination=destination;
0:     }
0:     
1:     public final synchronized void start() throws Exception{
1:         if (!isStarted()) {
0:             this.size = getStoreSize();
0:             this.storeHasMessages=this.size > 0;
0:             if (!this.storeHasMessages&&useCache) {
0:                 cacheEnabled=true;
0:             }
0:         }
0:         super.start();
0:         clear();
1:         resetBatch();
0:         getSystemUsage().getMemoryUsage().addUsageListener(this);
0:     }
0:     
1:     public final synchronized void stop() throws Exception {
0:         getSystemUsage().getMemoryUsage().removeUsageListener(this);
1:         resetBatch();
1:         gc();
1:         super.stop();
0:     }
0: 
0:     
1:     public final boolean recoverMessage(Message message) throws Exception {
1:         return recoverMessage(message,false);
0:     }
0:     
0:     public synchronized boolean recoverMessage(Message message, boolean cached)throws Exception {
0:         if (!isDuplicate(message.getMessageId())) {
1:             if (!cached) {
0:                 message.setRegionDestination(regionDestination);
0:                 message.setMemoryUsage(this.getSystemUsage().getMemoryUsage());
0:             }
1:             message.incrementReferenceCount();
0:             batchList.put(message.getMessageId(), message);
0:         } else {
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("Ignoring batched duplicated from store: " + message);
0:             }
0:             storeHasMessages = true;
0:         }
0:         return true;
0:     }
0:     
0:     public final void reset() {
0:     }
0: 
0:     public final void finished() {
0:     }
0:         
0:     public final synchronized boolean hasNext() {
1:         if (batchList.isEmpty()) {
0:             try {
1:                 fillBatch();
1:             } catch (Exception e) {
0:                 LOG.error("Failed to fill batch", e);
1:                 throw new RuntimeException(e);
0:             }
0:         }
0:         boolean result= !batchList.isEmpty();
1:         return result;
0:     }
0:     
1:     public final synchronized MessageReference next() {
0:         Message result = null;
0:         if (!this.batchList.isEmpty()) {
0:             Iterator<Entry<MessageId, Message>> i = this.batchList.entrySet().iterator();
0:             result = i.next().getValue();
0:             i.remove();
0:         }
1:         return result;
0:     }
0:     
0:     public final synchronized void addMessageLast(MessageReference node) throws Exception {
0:         if (cacheEnabled && hasSpace()) {
0:             recoverMessage(node.getMessage(),true);
0:         }else {
0:             cacheEnabled=false;
0:         }
1:         size++;
0:     }
0: 
0:     public final synchronized void addMessageFirst(MessageReference node) throws Exception {
0:         cacheEnabled=false;
1:         size++;
0:     }
0: 
1:     public final synchronized void remove() {
1:         size--;
0:         if (size==0 && isStarted() && cacheEnabled) {
0:             cacheEnabled=true;
0:         }
0:     }
0: 
1:     public final synchronized void remove(MessageReference node) {
1:         size--;
0:         cacheEnabled=false;
0:     }
0:     
0:            
0:     public final synchronized void onUsageChanged(Usage usage, int oldPercentUsage,
0:             int newPercentUsage) {
0:         if (oldPercentUsage > newPercentUsage && oldPercentUsage >= memoryUsageHighWaterMark) {
0:             storeHasMessages = true;
0:             try {
1:                 fillBatch();
1:             } catch (Exception e) {
0:                 LOG.error("Failed to fill batch ", e);
0:             }
0:         }
0:         
0:     }
0:     
1:     public final synchronized void clear() {
1:         gc();
0:     }
0:     
0:     public final synchronized void gc() {
0:         for (Message msg : batchList.values()) {
1:             rollback(msg.getMessageId());
1:             msg.decrementReferenceCount();
0:         }
1:         batchList.clear();
1:         batchResetNeeded = true;
0:         this.cacheEnabled=false;
0:     }
0:     
1:     protected final synchronized void fillBatch() {
1:         if (batchResetNeeded) {
1:             resetBatch();
1:             this.batchResetNeeded = false;
0:         }
0:         while (this.batchList.isEmpty() && (this.storeHasMessages || size > 0)) {
0:             this.storeHasMessages = false;
0:             try {
1:                 doFillBatch();
1:             } catch (Exception e) {
0:                 LOG.error("Failed to fill batch", e);
1:                 throw new RuntimeException(e);
0:             }
0:             if (!this.batchList.isEmpty()) {
0:                 this.storeHasMessages=true;
0:             }
0:         }
0:     }
0:     
1:     public final synchronized boolean isEmpty() {
0:         return size <= 0;
0:     }
0: 
1:     public final synchronized boolean hasMessagesBufferedToDeliver() {
1:         return !batchList.isEmpty();
0:     }
0: 
1:     public final synchronized int size() {
0:         if (isStarted()) {
1:             return size;
0:         }
0:         this.size = getStoreSize();
1:         return size;
0:         
0:     }
0:     
0:     
1:     protected abstract void doFillBatch() throws Exception;
0:     
1:     protected abstract void resetBatch();
0:     
1:     protected abstract int getStoreSize();
0: }
============================================================================