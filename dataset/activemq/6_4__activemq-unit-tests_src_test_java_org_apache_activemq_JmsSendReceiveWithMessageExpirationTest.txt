1:06a365f: /**
1:06a365f:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:06a365f:  * contributor license agreements.  See the NOTICE file distributed with
1:06a365f:  * this work for additional information regarding copyright ownership.
1:06a365f:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:06a365f:  * (the "License"); you may not use this file except in compliance with
1:06a365f:  * the License.  You may obtain a copy of the License at
6:06a365f:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:06a365f:  *
1:06a365f:  * Unless required by applicable law or agreed to in writing, software
1:06a365f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:06a365f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:06a365f:  * See the License for the specific language governing permissions and
1:06a365f:  * limitations under the License.
1:06a365f:  */
1:06a365f: package org.apache.activemq;
50:06a365f: 
1:06a365f: import java.util.Date;
1:a27eab4: import java.util.Vector;
1:a27eab4: import java.util.concurrent.TimeUnit;
1:06a365f: 
1:06a365f: import javax.jms.Connection;
1:06a365f: import javax.jms.DeliveryMode;
1:06a365f: import javax.jms.Destination;
1:06a365f: import javax.jms.JMSException;
1:06a365f: import javax.jms.Message;
1:06a365f: import javax.jms.MessageConsumer;
1:06a365f: import javax.jms.MessageProducer;
1:06a365f: import javax.jms.Session;
1:06a365f: import javax.jms.Topic;
1:933eb2f: 
1:26807cd: import org.apache.activemq.broker.BrokerRegistry;
1:26807cd: import org.apache.activemq.broker.region.DestinationStatistics;
1:26807cd: import org.apache.activemq.command.ActiveMQDestination;
1:26807cd: import org.apache.activemq.util.Wait;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:06a365f: 
1:06a365f: /**
1:06a365f:  *
1:06a365f:  */
1:06a365f: public class JmsSendReceiveWithMessageExpirationTest extends TestSupport {
1:230a86c: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(JmsSendReceiveWithMessageExpirationTest.class);
1:230a86c: 
1:230a86c:     protected int messageCount = 100;
1:06a365f:     protected String[] data;
1:06a365f:     protected Session session;
1:06a365f:     protected Destination consumerDestination;
1:06a365f:     protected Destination producerDestination;
1:230a86c:     protected boolean durable;
1:06a365f:     protected int deliveryMode = DeliveryMode.PERSISTENT;
1:06a365f:     protected long timeToLive = 5000;
1:230a86c:     protected boolean verbose;
1:230a86c: 
1:06a365f:     protected Connection connection;
1:230a86c: 
1:06a365f:     protected void setUp() throws Exception {
1:230a86c: 
1:230a86c:         super.setUp();
1:230a86c: 
1:06a365f:         data = new String[messageCount];
1:230a86c: 
1:06a365f:         for (int i = 0; i < messageCount; i++) {
1:06a365f:             data[i] = "Text for message: " + i + " at " + new Date();
1:06a365f:         }
1:230a86c: 
1:230a86c:         connectionFactory = createConnectionFactory();
1:06a365f:         connection = createConnection();
1:230a86c: 
1:06a365f:         if (durable) {
1:06a365f:             connection.setClientID(getClass().getName());
1:06a365f:         }
1:230a86c: 
1:06a365f:         session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:06a365f:     }
1:230a86c: 
1:06a365f:     /**
1:06a365f:      * Test consuming an expired queue.
1:230a86c:      * 
1:06a365f:      * @throws Exception
1:06a365f:      */
1:06a365f:     public void testConsumeExpiredQueue() throws Exception {
1:230a86c: 
1:230a86c:         MessageProducer producer = createProducer(timeToLive);
1:230a86c: 
1:06a365f:         consumerDestination = session.createQueue(getConsumerSubject());
1:06a365f:         producerDestination = session.createQueue(getProducerSubject());
1:230a86c: 
1:230a86c:         MessageConsumer consumer = createConsumer();
1:230a86c:         connection.start();
1:230a86c: 
1:230a86c:         for (int i = 0; i < data.length; i++) {
1:06a365f:             Message message = session.createTextMessage(data[i]);
1:230a86c:             message.setStringProperty("stringProperty", data[i]);
1:230a86c:             message.setIntProperty("intProperty", i);
1:230a86c: 
1:06a365f:             if (verbose) {
1:230a86c:                 if (LOG.isDebugEnabled()) {
1:230a86c:                     LOG.debug("About to send a queue message: " + message + " with text: " + data[i]);
1:06a365f:                 }
1:06a365f:             }
1:230a86c: 
1:06a365f:             producer.send(producerDestination, message);
1:06a365f:         }
1:230a86c: 
1:06a365f:         // sleeps a second longer than the expiration time.
1:230a86c:         // Basically waits till queue expires.
1:230a86c:         Thread.sleep(timeToLive + 1000);
1:230a86c: 
1:06a365f:         // message should have expired.
1:06a365f:         assertNull(consumer.receive(1000));
1:06a365f:     }
1:230a86c: 
1:a27eab4:      public void testConsumeExpiredQueueAndDlq() throws Exception {
1:a27eab4: 
1:a27eab4:          MessageProducer producerNormal = createProducer(0);
1:a27eab4:          MessageProducer producerExpire = createProducer(500);
1:a27eab4: 
1:a27eab4:          consumerDestination = session.createQueue("ActiveMQ.DLQ");
1:a27eab4:          MessageConsumer dlqConsumer = createConsumer();
1:a27eab4: 
1:a27eab4:          consumerDestination = session.createQueue(getConsumerSubject());
1:a27eab4:          producerDestination = session.createQueue(getProducerSubject());
1:a27eab4: 
1:a27eab4: 
1:a27eab4:          Connection consumerConnection = createConnection();
1:a27eab4:          ActiveMQPrefetchPolicy prefetchPolicy = new ActiveMQPrefetchPolicy();
1:a27eab4:          prefetchPolicy.setAll(10);
1:a27eab4:          ((ActiveMQConnection)consumerConnection).setPrefetchPolicy(prefetchPolicy);
1:a27eab4:          Session consumerSession = consumerConnection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:a27eab4:          MessageConsumer consumer = consumerSession.createConsumer(consumerDestination);
1:a27eab4:          consumerConnection.start();
1:a27eab4:          connection.start();
1:a27eab4: 
1:a27eab4:          String msgBody = new String(new byte[20*1024]);
1:a27eab4:          for (int i = 0; i < data.length; i++) {
1:a27eab4:              Message message = session.createTextMessage(msgBody);
1:a27eab4:              producerExpire.send(producerDestination, message);
1:a27eab4:          }
1:a27eab4: 
1:a27eab4:          for (int i = 0; i < data.length; i++) {
1:a27eab4:              Message message = session.createTextMessage(msgBody);
1:a27eab4:              producerNormal.send(producerDestination, message);
1:a27eab4:          }
1:a27eab4: 
1:a27eab4:          Vector<Message> messages = new Vector<Message>();
1:a27eab4:          Message received;
1:a27eab4:          while ((received = consumer.receive(1000)) != null) {
1:a27eab4:              messages.add(received);
1:a27eab4:              if (messages.size() == 1) {
1:a27eab4:                 TimeUnit.SECONDS.sleep(1);
1:a27eab4:              }
1:a27eab4:              received.acknowledge();
1:a27eab4:          };
1:a27eab4: 
1:26807cd:          assertEquals("got all (normal plus one with ttl) messages", messageCount + 1, messages.size());
1:a27eab4: 
1:a27eab4:          Vector<Message> dlqMessages = new Vector<Message>();
1:a27eab4:          while ((received = dlqConsumer.receive(1000)) != null) {
1:a27eab4:              dlqMessages.add(received);
1:a27eab4:          };
1:a27eab4: 
1:a27eab4:          assertEquals("got dlq messages", data.length - 1, dlqMessages.size());
1:26807cd: 
1:26807cd:          final DestinationStatistics view = getDestinationStatistics(BrokerRegistry.getInstance().findFirst(), ActiveMQDestination.transform(consumerDestination));
1:26807cd: 
1:26807cd:          // wait for all to inflight to expire
1:26807cd:          assertTrue("all inflight messages expired ", Wait.waitFor(new Wait.Condition() {
1:26807cd:              @Override
1:26807cd:              public boolean isSatisified() throws Exception {
1:26807cd:                  return view.getInflight().getCount() == 0;
1:26807cd:              }
1:26807cd:          }));
1:26807cd:          assertEquals("Wrong inFlightCount: ", 0, view.getInflight().getCount());
1:26807cd: 
1:26807cd:          LOG.info("Stats: received: "  + messages.size() + ", messages: " + view.getMessages().getCount() + ", enqueues: " + view.getEnqueues().getCount() + ", dequeues: " + view.getDequeues().getCount()
1:26807cd:                  + ", dispatched: " + view.getDispatched().getCount() + ", inflight: " + view.getInflight().getCount() + ", expired: " + view.getExpired().getCount());
1:26807cd: 
1:a27eab4:     }
1:a27eab4:     
1:06a365f:     /**
1:06a365f:      * Sends and consumes the messages to a queue destination.
1:230a86c:      * 
1:06a365f:      * @throws Exception
1:06a365f:      */
1:06a365f:     public void testConsumeQueue() throws Exception {
1:230a86c: 
1:230a86c:         MessageProducer producer = createProducer(0);
1:230a86c: 
1:06a365f:         consumerDestination = session.createQueue(getConsumerSubject());
1:06a365f:         producerDestination = session.createQueue(getProducerSubject());
1:230a86c: 
1:230a86c:         MessageConsumer consumer = createConsumer();
1:230a86c:         connection.start();
1:230a86c: 
1:230a86c:         for (int i = 0; i < data.length; i++) {
1:06a365f:             Message message = session.createTextMessage(data[i]);
1:230a86c:             message.setStringProperty("stringProperty", data[i]);
1:230a86c:             message.setIntProperty("intProperty", i);
1:230a86c: 
1:06a365f:             if (verbose) {
1:230a86c:                 if (LOG.isDebugEnabled()) {
1:230a86c:                     LOG.debug("About to send a queue message: " + message + " with text: " + data[i]);
1:06a365f:                 }
1:06a365f:             }
1:230a86c: 
1:06a365f:             producer.send(producerDestination, message);
1:06a365f:         }
1:230a86c: 
1:06a365f:         // should receive a queue since there is no expiration.
1:06a365f:         assertNotNull(consumer.receive(1000));
1:06a365f:     }
1:230a86c: 
1:06a365f:     /**
1:06a365f:      * Test consuming an expired topic.
1:230a86c:      * 
1:06a365f:      * @throws Exception
1:06a365f:      */
1:06a365f:     public void testConsumeExpiredTopic() throws Exception {
1:230a86c: 
1:230a86c:         MessageProducer producer = createProducer(timeToLive);
1:230a86c: 
1:06a365f:         consumerDestination = session.createTopic(getConsumerSubject());
1:06a365f:         producerDestination = session.createTopic(getProducerSubject());
1:230a86c: 
1:230a86c:         MessageConsumer consumer = createConsumer();
1:230a86c:         connection.start();
1:230a86c: 
1:230a86c:         for (int i = 0; i < data.length; i++) {
1:06a365f:             Message message = session.createTextMessage(data[i]);
1:230a86c:             message.setStringProperty("stringProperty", data[i]);
1:230a86c:             message.setIntProperty("intProperty", i);
1:230a86c: 
1:06a365f:             if (verbose) {
1:230a86c:                 if (LOG.isDebugEnabled()) {
1:230a86c:                     LOG.debug("About to send a topic message: " + message + " with text: " + data[i]);
1:06a365f:                 }
1:06a365f:             }
1:230a86c: 
1:06a365f:             producer.send(producerDestination, message);
1:06a365f:         }
1:230a86c: 
1:06a365f:         // sleeps a second longer than the expiration time.
1:230a86c:         // Basically waits till topic expires.
1:230a86c:         Thread.sleep(timeToLive + 1000);
1:230a86c: 
1:06a365f:         // message should have expired.
1:06a365f:         assertNull(consumer.receive(1000));
1:06a365f:     }
1:230a86c: 
1:06a365f:     /**
1:06a365f:      * Sends and consumes the messages to a topic destination.
1:230a86c:      * 
1:06a365f:      * @throws Exception
1:06a365f:      */
1:06a365f:     public void testConsumeTopic() throws Exception {
1:230a86c: 
1:230a86c:         MessageProducer producer = createProducer(0);
1:230a86c: 
1:06a365f:         consumerDestination = session.createTopic(getConsumerSubject());
1:06a365f:         producerDestination = session.createTopic(getProducerSubject());
1:230a86c: 
1:230a86c:         MessageConsumer consumer = createConsumer();
1:230a86c:         connection.start();
1:230a86c: 
1:230a86c:         for (int i = 0; i < data.length; i++) {
1:06a365f:             Message message = session.createTextMessage(data[i]);
1:230a86c:             message.setStringProperty("stringProperty", data[i]);
1:230a86c:             message.setIntProperty("intProperty", i);
1:230a86c: 
1:06a365f:             if (verbose) {
1:230a86c:                 if (LOG.isDebugEnabled()) {
1:230a86c:                     LOG.debug("About to send a topic message: " + message + " with text: " + data[i]);
1:06a365f:                 }
1:06a365f:             }
1:230a86c: 
1:06a365f:             producer.send(producerDestination, message);
1:06a365f:         }
1:06a365f: 
1:06a365f:         // should receive a topic since there is no expiration.
1:06a365f:         assertNotNull(consumer.receive(1000));
1:06a365f:     }
1:230a86c: 
1:06a365f:     protected MessageProducer createProducer(long timeToLive) throws JMSException {
1:230a86c:         MessageProducer producer = session.createProducer(null);
1:06a365f:         producer.setDeliveryMode(deliveryMode);
1:06a365f:         producer.setTimeToLive(timeToLive);
1:230a86c: 
1:230a86c:         return producer;
1:06a365f:     }
1:230a86c: 
1:06a365f:     protected MessageConsumer createConsumer() throws JMSException {
1:06a365f:         if (durable) {
1:230a86c:             LOG.info("Creating durable consumer");
1:230a86c:             return session.createDurableSubscriber((Topic)consumerDestination, getName());
1:06a365f:         }
1:06a365f:         return session.createConsumer(consumerDestination);
1:06a365f:     }
1:230a86c: 
1:06a365f:     protected void tearDown() throws Exception {
1:230a86c:         LOG.info("Dumping stats...");
1:230a86c:         LOG.info("Closing down connection");
1:06a365f: 
1:06a365f:         session.close();
1:06a365f:         connection.close();
1:06a365f:     }
1:06a365f: 
1:06a365f: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:26807cd
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.BrokerRegistry;
1: import org.apache.activemq.broker.region.DestinationStatistics;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.util.Wait;
/////////////////////////////////////////////////////////////////////////
1:          assertEquals("got all (normal plus one with ttl) messages", messageCount + 1, messages.size());
/////////////////////////////////////////////////////////////////////////
1: 
1:          final DestinationStatistics view = getDestinationStatistics(BrokerRegistry.getInstance().findFirst(), ActiveMQDestination.transform(consumerDestination));
1: 
1:          // wait for all to inflight to expire
1:          assertTrue("all inflight messages expired ", Wait.waitFor(new Wait.Condition() {
1:              @Override
1:              public boolean isSatisified() throws Exception {
1:                  return view.getInflight().getCount() == 0;
1:              }
1:          }));
1:          assertEquals("Wrong inFlightCount: ", 0, view.getInflight().getCount());
1: 
1:          LOG.info("Stats: received: "  + messages.size() + ", messages: " + view.getMessages().getCount() + ", enqueues: " + view.getEnqueues().getCount() + ", dequeues: " + view.getDequeues().getCount()
1:                  + ", dispatched: " + view.getDispatched().getCount() + ", inflight: " + view.getInflight().getCount() + ", expired: " + view.getExpired().getCount());
1: 
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(JmsSendReceiveWithMessageExpirationTest.class);
author:Gary Tully
-------------------------------------------------------------------------------
commit:a27eab4
/////////////////////////////////////////////////////////////////////////
1: import java.util.Vector;
1: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
1:      public void testConsumeExpiredQueueAndDlq() throws Exception {
1: 
1:          MessageProducer producerNormal = createProducer(0);
1:          MessageProducer producerExpire = createProducer(500);
1: 
1:          consumerDestination = session.createQueue("ActiveMQ.DLQ");
1:          MessageConsumer dlqConsumer = createConsumer();
1: 
1:          consumerDestination = session.createQueue(getConsumerSubject());
1:          producerDestination = session.createQueue(getProducerSubject());
1: 
1: 
1:          Connection consumerConnection = createConnection();
1:          ActiveMQPrefetchPolicy prefetchPolicy = new ActiveMQPrefetchPolicy();
1:          prefetchPolicy.setAll(10);
1:          ((ActiveMQConnection)consumerConnection).setPrefetchPolicy(prefetchPolicy);
1:          Session consumerSession = consumerConnection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:          MessageConsumer consumer = consumerSession.createConsumer(consumerDestination);
1:          consumerConnection.start();
1:          connection.start();
1: 
1:          String msgBody = new String(new byte[20*1024]);
1:          for (int i = 0; i < data.length; i++) {
1:              Message message = session.createTextMessage(msgBody);
1:              producerExpire.send(producerDestination, message);
1:          }
1: 
1:          for (int i = 0; i < data.length; i++) {
1:              Message message = session.createTextMessage(msgBody);
1:              producerNormal.send(producerDestination, message);
1:          }
1: 
1:          Vector<Message> messages = new Vector<Message>();
1:          Message received;
1:          while ((received = consumer.receive(1000)) != null) {
1:              messages.add(received);
1:              if (messages.size() == 1) {
1:                 TimeUnit.SECONDS.sleep(1);
1:              }
1:              received.acknowledge();
1:          };
1: 
0:          assertEquals("got messages", messageCount + 1, messages.size());
1: 
1:          Vector<Message> dlqMessages = new Vector<Message>();
1:          while ((received = dlqConsumer.receive(1000)) != null) {
1:              dlqMessages.add(received);
1:          };
1: 
1:          assertEquals("got dlq messages", data.length - 1, dlqMessages.size());
1:     }
1:     
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
0:     private static final Log LOG = LogFactory.getLog(JmsSendReceiveWithMessageExpirationTest.class);
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
1: 
0:     private static final org.apache.commons.logging.Log LOG = org.apache.commons.logging.LogFactory.getLog(JmsSendReceiveWithMessageExpirationTest.class);
1: 
1:     protected int messageCount = 100;
1:     protected boolean durable;
1:     protected boolean verbose;
1: 
1: 
1: 
1:         super.setUp();
1: 
1: 
1: 
1:         connectionFactory = createConnectionFactory();
1: 
1: 
1:      * 
1: 
1:         MessageProducer producer = createProducer(timeToLive);
1: 
1: 
1:         MessageConsumer consumer = createConsumer();
1:         connection.start();
1: 
1:         for (int i = 0; i < data.length; i++) {
1:             message.setStringProperty("stringProperty", data[i]);
1:             message.setIntProperty("intProperty", i);
1: 
1:                 if (LOG.isDebugEnabled()) {
1:                     LOG.debug("About to send a queue message: " + message + " with text: " + data[i]);
1: 
1: 
1:         // Basically waits till queue expires.
1:         Thread.sleep(timeToLive + 1000);
1: 
1: 
1:      * 
1: 
1:         MessageProducer producer = createProducer(0);
1: 
1: 
1:         MessageConsumer consumer = createConsumer();
1:         connection.start();
1: 
1:         for (int i = 0; i < data.length; i++) {
1:             message.setStringProperty("stringProperty", data[i]);
1:             message.setIntProperty("intProperty", i);
1: 
1:                 if (LOG.isDebugEnabled()) {
1:                     LOG.debug("About to send a queue message: " + message + " with text: " + data[i]);
1: 
1: 
1: 
1:      * 
1: 
1:         MessageProducer producer = createProducer(timeToLive);
1: 
1: 
1:         MessageConsumer consumer = createConsumer();
1:         connection.start();
1: 
1:         for (int i = 0; i < data.length; i++) {
1:             message.setStringProperty("stringProperty", data[i]);
1:             message.setIntProperty("intProperty", i);
1: 
1:                 if (LOG.isDebugEnabled()) {
1:                     LOG.debug("About to send a topic message: " + message + " with text: " + data[i]);
1: 
1: 
1:         // Basically waits till topic expires.
1:         Thread.sleep(timeToLive + 1000);
1: 
1: 
1:      * 
1: 
1:         MessageProducer producer = createProducer(0);
1: 
1: 
1:         MessageConsumer consumer = createConsumer();
1:         connection.start();
1: 
1:         for (int i = 0; i < data.length; i++) {
1:             message.setStringProperty("stringProperty", data[i]);
1:             message.setIntProperty("intProperty", i);
1: 
1:                 if (LOG.isDebugEnabled()) {
1:                     LOG.debug("About to send a topic message: " + message + " with text: " + data[i]);
1: 
1: 
1: 
1:         MessageProducer producer = session.createProducer(null);
1: 
1:         return producer;
1: 
1:             LOG.info("Creating durable consumer");
1:             return session.createDurableSubscriber((Topic)consumerDestination, getName());
1: 
1:         LOG.info("Dumping stats...");
1:         LOG.info("Closing down connection");
commit:06a365f
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq;
1: 
1: import java.util.Date;
1: 
1: import javax.jms.Connection;
1: import javax.jms.DeliveryMode;
1: import javax.jms.Destination;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: import javax.jms.Topic;
1: 
1: /**
1:  *
1:  */
1: public class JmsSendReceiveWithMessageExpirationTest extends TestSupport {
1: 	
0: 	private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory
0:            .getLog(JmsSendReceiveWithMessageExpirationTest.class);
1: 	
0: 	protected int messageCount = 100;
1:     protected String[] data;
1:     protected Session session;
1:     protected Destination consumerDestination;
1:     protected Destination producerDestination;
0:     protected boolean durable = false;
1:     protected int deliveryMode = DeliveryMode.PERSISTENT;
1:     protected long timeToLive = 5000;
0:     protected boolean verbose = false;
1:     
1:     protected Connection connection;
1:     
1:     protected void setUp() throws Exception {
1:         
0:     	super.setUp();
1:         
1:         data = new String[messageCount];
1:         
1:         for (int i = 0; i < messageCount; i++) {
1:             data[i] = "Text for message: " + i + " at " + new Date();
1:         }
1:         
0:         connectionFactory = createConnectionFactory();        
1:         connection = createConnection();
1:         
1:         if (durable) {
1:             connection.setClientID(getClass().getName());
1:         }
1: 
1:         session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:     }
1:     
1:     /**
1:      * Test consuming an expired queue.
1:      *
1:      * @throws Exception
1:      */
1:     public void testConsumeExpiredQueue() throws Exception {
1:         
0:     	MessageProducer producer = createProducer(timeToLive);
1:         
1:         consumerDestination = session.createQueue(getConsumerSubject());
1:         producerDestination = session.createQueue(getProducerSubject());
1:         
0:         MessageConsumer consumer = createConsumer();        
0:         connection.start();  
1:         
0:     	for (int i = 0; i < data.length; i++) {
1:             Message message = session.createTextMessage(data[i]);
0:             message.setStringProperty("stringProperty",data[i]);
0:             message.setIntProperty("intProperty",i);
1:         
1:             if (verbose) {
0:                 if (log.isDebugEnabled()) {
0:                     log.debug("About to send a queue message: " + message + " with text: " + data[i]);
1:                 }
1:             }
1:             
1:             producer.send(producerDestination, message);
1:         }
1:         
1:         // sleeps a second longer than the expiration time.
0: 		// Basically waits till queue expires.
0: 		Thread.sleep(timeToLive + 1000);
1:         
1:         // message should have expired.
1:         assertNull(consumer.receive(1000));
1:     }
1:     
1:     /**
1:      * Sends and consumes the messages to a queue destination.
1:      *
1:      * @throws Exception
1:      */
1:     public void testConsumeQueue() throws Exception {
1:         
0:     	MessageProducer producer = createProducer(0);
1:         
1:         consumerDestination = session.createQueue(getConsumerSubject());
1:         producerDestination = session.createQueue(getProducerSubject());
1:         
0:         MessageConsumer consumer = createConsumer();        
0:         connection.start();  
1:         
0:     	for (int i = 0; i < data.length; i++) {
1:             Message message = session.createTextMessage(data[i]);
0:             message.setStringProperty("stringProperty",data[i]);
0:             message.setIntProperty("intProperty",i);
1:         
1:             if (verbose) {
0:                 if (log.isDebugEnabled()) {
0:                     log.debug("About to send a queue message: " + message + " with text: " + data[i]);
1:                 }
1:             }
1:             
1:             producer.send(producerDestination, message);
1:         }
1:         
1:         // should receive a queue since there is no expiration.
1:         assertNotNull(consumer.receive(1000));
1:     }
1:     
1:     /**
1:      * Test consuming an expired topic.
1:      *
1:      * @throws Exception
1:      */
1:     public void testConsumeExpiredTopic() throws Exception {
1:     	
0:     	MessageProducer producer = createProducer(timeToLive);
1:         
1:         consumerDestination = session.createTopic(getConsumerSubject());
1:         producerDestination = session.createTopic(getProducerSubject());
1:         
0:         MessageConsumer consumer = createConsumer();        
0:         connection.start(); 
1:         
0:     	for (int i = 0; i < data.length; i++) {
1:             Message message = session.createTextMessage(data[i]);
0:             message.setStringProperty("stringProperty",data[i]);
0:             message.setIntProperty("intProperty",i);
1:         
1:             if (verbose) {
0:                 if (log.isDebugEnabled()) {
0:                     log.debug("About to send a topic message: " + message + " with text: " + data[i]);
1:                 }
1:             }
1:             
1:             producer.send(producerDestination, message);
1:         }
1:         
1:         // sleeps a second longer than the expiration time.
0: 		// Basically waits till topic expires.
0: 		Thread.sleep(timeToLive + 1000);
1:         
1:         // message should have expired.
1:         assertNull(consumer.receive(1000));
1:     }
1:     
1:     /**
1:      * Sends and consumes the messages to a topic destination.
1:      *
1:      * @throws Exception
1:      */
1:     public void testConsumeTopic() throws Exception {
1:     	
0:     	MessageProducer producer = createProducer(0);
1:         
1:         consumerDestination = session.createTopic(getConsumerSubject());
1:         producerDestination = session.createTopic(getProducerSubject());
1:         
0:         MessageConsumer consumer = createConsumer();        
0:         connection.start(); 
1:         
0:     	for (int i = 0; i < data.length; i++) {
1:             Message message = session.createTextMessage(data[i]);
0:             message.setStringProperty("stringProperty",data[i]);
0:             message.setIntProperty("intProperty",i);
1:         
1:             if (verbose) {
0:                 if (log.isDebugEnabled()) {
0:                     log.debug("About to send a topic message: " + message + " with text: " + data[i]);
1:                 }
1:             }
1:             
1:             producer.send(producerDestination, message);
1:         }
1:         
1:         // should receive a topic since there is no expiration.
1:         assertNotNull(consumer.receive(1000));
1:     }
1:     
1:     
1:     
1:     protected MessageProducer createProducer(long timeToLive) throws JMSException {
0:     	MessageProducer producer = session.createProducer(null);
1:         producer.setDeliveryMode(deliveryMode);
1:         producer.setTimeToLive(timeToLive);
1:         
0:         return producer;    	
1:     }
1:     
1:     protected MessageConsumer createConsumer() throws JMSException {
1:         if (durable) {
0:             log.info("Creating durable consumer");
0:             return session.createDurableSubscriber((Topic) consumerDestination, getName());
1:         }
1:         return session.createConsumer(consumerDestination);
1:     }
1:     
1:     protected void tearDown() throws Exception {
0:         log.info("Dumping stats...");    
0:         log.info("Closing down connection");
1: 
1:         session.close();
1:         connection.close();
1:     }
1: 
1: }
commit:dfddf69
/////////////////////////////////////////////////////////////////////////
0: /**
0:  *
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
0:  * contributor license agreements.  See the NOTICE file distributed with
0:  * this work for additional information regarding copyright ownership.
0:  * The ASF licenses this file to You under the Apache License, Version 2.0
0:  * (the "License"); you may not use this file except in compliance with
0:  * the License.  You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
/////////////////////////////////////////////////////////////////////////
0: /**
0:  *
0:  */
author:Frederick G. Oconer
-------------------------------------------------------------------------------
commit:4208134
/////////////////////////////////////////////////////////////////////////
0:      * Test consuming an expired queue.
/////////////////////////////////////////////////////////////////////////
0:         // sleeps a second longer than the expiration time.
0: 		// Basically waits till queue expires.
0: 		Thread.sleep(timeToLive + 1000);
/////////////////////////////////////////////////////////////////////////
0:         // should receive a queue since there is no expiration.
0:      * Test consuming an expired topic.
/////////////////////////////////////////////////////////////////////////
0:         // sleeps a second longer than the expiration time.
0: 		// Basically waits till topic expires.
0: 		Thread.sleep(timeToLive + 1000);
/////////////////////////////////////////////////////////////////////////
0:         // should receive a topic since there is no expiration.
/////////////////////////////////////////////////////////////////////////
0:         log.info("Dumping stats...");    
commit:aa532c1
/////////////////////////////////////////////////////////////////////////
0:            .getLog(JmsSendReceiveWithMessageExpirationTest.class);
commit:61308b8
/////////////////////////////////////////////////////////////////////////
0: public class JmsSendReceiveWithMessageExpirationTest extends TestSupport {
commit:e8bae06
/////////////////////////////////////////////////////////////////////////
0: package org.apache.activemq;
0: 
0: import java.util.Date;
0: 
0: import javax.jms.Connection;
0: import javax.jms.DeliveryMode;
0: import javax.jms.Destination;
0: import javax.jms.JMSException;
0: import javax.jms.Message;
0: import javax.jms.MessageConsumer;
0: import javax.jms.MessageProducer;
0: import javax.jms.Session;
0: import javax.jms.Topic;
0: 
0: public class JmsSendReceiveWithMessageExpiration extends TestSupport {
0: 	
0: 	private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory
0:            .getLog(JmsQueueSendReceiveWithMessageExpiration.class);
0: 	
0: 	protected int messageCount = 100;
0:     protected String[] data;
0:     protected Session session;
0:     protected Destination consumerDestination;
0:     protected Destination producerDestination;
0:     protected boolean durable = false;
0:     protected int deliveryMode = DeliveryMode.PERSISTENT;
0:     protected long timeToLive = 5000;
0:     protected boolean verbose = false;
0:     
0:     protected Connection connection;
0:     
0:     protected void setUp() throws Exception {
0:         
0:     	super.setUp();
0:         
0:         data = new String[messageCount];
0:         
0:         for (int i = 0; i < messageCount; i++) {
0:             data[i] = "Text for message: " + i + " at " + new Date();
0:         }
0:         
0:         connectionFactory = createConnectionFactory();        
0:         connection = createConnection();
0:         
0:         if (durable) {
0:             connection.setClientID(getClass().getName());
0:         }
0: 
0:         session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:     }
0:     
0:     /**
0:      * Sends and consumes the messages to a queue destination.
0:      *
0:      * @throws Exception
0:      */
0:     public void testConsumeExpiredQueue() throws Exception {
0:         
0:     	MessageProducer producer = createProducer(timeToLive);
0:         
0:         consumerDestination = session.createQueue(getConsumerSubject());
0:         producerDestination = session.createQueue(getProducerSubject());
0:         
0:         MessageConsumer consumer = createConsumer();        
0:         connection.start();  
0:         
0:     	for (int i = 0; i < data.length; i++) {
0:             Message message = session.createTextMessage(data[i]);
0:             message.setStringProperty("stringProperty",data[i]);
0:             message.setIntProperty("intProperty",i);
0:         
0:             if (verbose) {
0:                 if (log.isDebugEnabled()) {
0:                     log.debug("About to send a queue message: " + message + " with text: " + data[i]);
0:                 }
0:             }
0:             
0:             producer.send(producerDestination, message);
0:         }
0:         
0:         Thread.sleep(timeToLive + 1000);
0:         
0:         // message should have expired.
0:         assertNull(consumer.receive(1000));
0:     }
0:     
0:     /**
0:      * Sends and consumes the messages to a queue destination.
0:      *
0:      * @throws Exception
0:      */
0:     public void testConsumeQueue() throws Exception {
0:         
0:     	MessageProducer producer = createProducer(0);
0:         
0:         consumerDestination = session.createQueue(getConsumerSubject());
0:         producerDestination = session.createQueue(getProducerSubject());
0:         
0:         MessageConsumer consumer = createConsumer();        
0:         connection.start();  
0:         
0:     	for (int i = 0; i < data.length; i++) {
0:             Message message = session.createTextMessage(data[i]);
0:             message.setStringProperty("stringProperty",data[i]);
0:             message.setIntProperty("intProperty",i);
0:         
0:             if (verbose) {
0:                 if (log.isDebugEnabled()) {
0:                     log.debug("About to send a queue message: " + message + " with text: " + data[i]);
0:                 }
0:             }
0:             
0:             producer.send(producerDestination, message);
0:         }
0:         
0:         // message should have expired.
0:         assertNotNull(consumer.receive(1000));
0:     }
0:     
0:     /**
0:      * Sends and consumes the messages to a topic destination.
0:      *
0:      * @throws Exception
0:      */
0:     public void testConsumeExpiredTopic() throws Exception {
0:     	
0:     	MessageProducer producer = createProducer(timeToLive);
0:         
0:         consumerDestination = session.createTopic(getConsumerSubject());
0:         producerDestination = session.createTopic(getProducerSubject());
0:         
0:         MessageConsumer consumer = createConsumer();        
0:         connection.start(); 
0:         
0:     	for (int i = 0; i < data.length; i++) {
0:             Message message = session.createTextMessage(data[i]);
0:             message.setStringProperty("stringProperty",data[i]);
0:             message.setIntProperty("intProperty",i);
0:         
0:             if (verbose) {
0:                 if (log.isDebugEnabled()) {
0:                     log.debug("About to send a topic message: " + message + " with text: " + data[i]);
0:                 }
0:             }
0:             
0:             producer.send(producerDestination, message);
0:         }
0:         
0:         Thread.sleep(timeToLive + 1000);
0:         
0:         // message should have expired.
0:         assertNull(consumer.receive(1000));
0:     }
0:     
0:     /**
0:      * Sends and consumes the messages to a topic destination.
0:      *
0:      * @throws Exception
0:      */
0:     public void testConsumeTopic() throws Exception {
0:     	
0:     	MessageProducer producer = createProducer(0);
0:         
0:         consumerDestination = session.createTopic(getConsumerSubject());
0:         producerDestination = session.createTopic(getProducerSubject());
0:         
0:         MessageConsumer consumer = createConsumer();        
0:         connection.start(); 
0:         
0:     	for (int i = 0; i < data.length; i++) {
0:             Message message = session.createTextMessage(data[i]);
0:             message.setStringProperty("stringProperty",data[i]);
0:             message.setIntProperty("intProperty",i);
0:         
0:             if (verbose) {
0:                 if (log.isDebugEnabled()) {
0:                     log.debug("About to send a topic message: " + message + " with text: " + data[i]);
0:                 }
0:             }
0:             
0:             producer.send(producerDestination, message);
0:         }
0:         
0:         // message should have expired.
0:         assertNotNull(consumer.receive(1000));
0:     }
0:     
0:     
0:     
0:     protected MessageProducer createProducer(long timeToLive) throws JMSException {
0:     	MessageProducer producer = session.createProducer(null);
0:         producer.setDeliveryMode(deliveryMode);
0:         producer.setTimeToLive(timeToLive);
0:         
0:         return producer;    	
0:     }
0:     
0:     protected MessageConsumer createConsumer() throws JMSException {
0:         if (durable) {
0:             log.info("Creating durable consumer");
0:             return session.createDurableSubscriber((Topic) consumerDestination, getName());
0:         }
0:         return session.createConsumer(consumerDestination);
0:     }
0:     
0:     protected void tearDown() throws Exception {
0:         log.info("Dumping stats...");
0:     
0:         log.info("Closing down connection");
0: 
0:         /** TODO we should be able to shut down properly */
0:         session.close();
0:         connection.close();
0:     }
0: 
0: }
============================================================================