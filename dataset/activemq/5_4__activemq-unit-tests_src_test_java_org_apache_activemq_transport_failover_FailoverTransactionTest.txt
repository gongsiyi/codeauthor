1:b9e51d6: /**
1:b9e51d6:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:b9e51d6:  * contributor license agreements.  See the NOTICE file distributed with
1:b9e51d6:  * this work for additional information regarding copyright ownership.
1:b9e51d6:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:b9e51d6:  * (the "License"); you may not use this file except in compliance with
1:b9e51d6:  * the License.  You may obtain a copy of the License at
1:b9e51d6:  *
1:b9e51d6:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b9e51d6:  *
1:b9e51d6:  * Unless required by applicable law or agreed to in writing, software
1:b9e51d6:  * distributed under the License is distributed on an "AS IS" BASIS,
1:b9e51d6:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:b9e51d6:  * See the License for the specific language governing permissions and
1:b9e51d6:  * limitations under the License.
1:b9e51d6:  */
1:b9e51d6: package org.apache.activemq.transport.failover;
12:a6a6a70: 
1:f206a1b: import junit.framework.Test;
1:dc0291b: import org.apache.activemq.ActiveMQConnection;
1:f206a1b: import org.apache.activemq.ActiveMQConnectionFactory;
1:dc0291b: import org.apache.activemq.ActiveMQMessageConsumer;
1:f206a1b: import org.apache.activemq.AutoFailTestSupport;
1:f206a1b: import org.apache.activemq.TestSupport;
1:f206a1b: import org.apache.activemq.broker.BrokerPlugin;
1:f206a1b: import org.apache.activemq.broker.BrokerPluginSupport;
1:f206a1b: import org.apache.activemq.broker.BrokerService;
1:f206a1b: import org.apache.activemq.broker.ConnectionContext;
1:f206a1b: import org.apache.activemq.broker.ConsumerBrokerExchange;
1:f206a1b: import org.apache.activemq.broker.ProducerBrokerExchange;
1:f206a1b: import org.apache.activemq.broker.region.RegionBroker;
1:1de7e7e: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:1de7e7e: import org.apache.activemq.broker.region.policy.PolicyMap;
1:8311938: import org.apache.activemq.broker.util.DestinationPathSeparatorBroker;
1:8311938: import org.apache.activemq.command.ActiveMQDestination;
1:dc0291b: import org.apache.activemq.command.ConsumerInfo;
1:f206a1b: import org.apache.activemq.command.MessageAck;
1:f206a1b: import org.apache.activemq.command.TransactionId;
1:f206a1b: import org.apache.activemq.store.PersistenceAdapter;
1:f206a1b: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1:dc0291b: import org.apache.activemq.transport.TransportListener;
1:f206a1b: import org.apache.activemq.util.SocketProxy;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:a6a6a70: 
1:b9e51d6: import javax.jms.Connection;
1:0bc545b: import javax.jms.JMSException;
1:8732f70: import javax.jms.Message;
1:b9e51d6: import javax.jms.MessageConsumer;
1:b9e51d6: import javax.jms.MessageProducer;
1:b9e51d6: import javax.jms.Queue;
1:e771b88: import javax.jms.ServerSession;
1:e771b88: import javax.jms.ServerSessionPool;
1:b9e51d6: import javax.jms.Session;
1:b9e51d6: import javax.jms.TextMessage;
1:62daac4: import javax.jms.TransactionRolledBackException;
1:dc0291b: import java.io.IOException;
1:f206a1b: import java.net.URI;
1:dc0291b: import java.util.ArrayDeque;
1:dc0291b: import java.util.Deque;
1:dc0291b: import java.util.NoSuchElementException;
1:1de7e7e: import java.util.Random;
1:dc0291b: import java.util.Stack;
1:f206a1b: import java.util.Vector;
1:f206a1b: import java.util.concurrent.CountDownLatch;
1:dc0291b: import java.util.concurrent.ExecutorService;
1:f206a1b: import java.util.concurrent.Executors;
1:f206a1b: import java.util.concurrent.TimeUnit;
1:f206a1b: import java.util.concurrent.atomic.AtomicBoolean;
1:a6a6a70: 
1:b9e51d6: // see https://issues.apache.org/activemq/browse/AMQ-2473
1:f206a1b: 
1:b836af8: // https://issues.apache.org/activemq/browse/AMQ-2590
1:f206a1b: public class FailoverTransactionTest extends TestSupport {
1:f206a1b: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(FailoverTransactionTest.class);
1:8311938:     private static final String QUEUE_NAME = "Failover.WithTx";
1:883eed0:     private static final String TRANSPORT_URI = "tcp://localhost:0";
1:883eed0:     private String url;
1:f206a1b:     BrokerService broker;
1:1de7e7e:     final Random random = new Random();
1:f206a1b: 
1:f206a1b:     public static Test suite() {
1:f206a1b:         return suite(FailoverTransactionTest.class);
1:f206a1b:     }
1:f206a1b: 
1:80528f6:     public void setUp() throws Exception {
1:f7f294f:         super.setMaxTestTime(2 * 60 * 1000); // some boxes can be real slow
1:80528f6:         super.setAutoFail(true);
1:80528f6:         super.setUp();
1:80528f6:     }
1:80528f6: 
1:f206a1b:     public void tearDown() throws Exception {
1:92b6bd2:         super.tearDown();
1:f206a1b:         stopBroker();
1:f206a1b:     }
1:f206a1b: 
1:f206a1b:     public void stopBroker() throws Exception {
1:f206a1b:         if (broker != null) {
1:f206a1b:             broker.stop();
1:f206a1b:         }
1:f206a1b:     }
1:f206a1b: 
1:883eed0:     private void startCleanBroker() throws Exception {
1:f206a1b:         startBroker(true);
1:f206a1b:     }
1:f206a1b: 
1:f206a1b:     public void startBroker(boolean deleteAllMessagesOnStartup) throws Exception {
1:f206a1b:         broker = createBroker(deleteAllMessagesOnStartup);
1:8732f70:         broker.start();
1:f206a1b:     }
1:f206a1b: 
1:883eed0:     public void startBroker(boolean deleteAllMessagesOnStartup, String bindAddress) throws Exception {
1:883eed0:         broker = createBroker(deleteAllMessagesOnStartup, bindAddress);
1:8732f70:         broker.start();
8:0bc545b:     }
1:f206a1b: 
1:f206a1b:     public BrokerService createBroker(boolean deleteAllMessagesOnStartup) throws Exception {
1:883eed0:         return createBroker(deleteAllMessagesOnStartup, TRANSPORT_URI);
1:0bc545b:     }
1:f206a1b: 
1:883eed0:     public BrokerService createBroker(boolean deleteAllMessagesOnStartup, String bindAddress) throws Exception {
1:f206a1b:         broker = new BrokerService();
1:f206a1b:         broker.setUseJmx(false);
1:f206a1b:         broker.setAdvisorySupport(false);
1:883eed0:         broker.addConnector(bindAddress);
1:f206a1b:         broker.setDeleteAllMessagesOnStartup(deleteAllMessagesOnStartup);
1:a6a6a70: 
1:1de7e7e:         PolicyMap policyMap = new PolicyMap();
1:1de7e7e:         PolicyEntry defaultEntry = new PolicyEntry();
1:1de7e7e:         defaultEntry.setUsePrefetchExtension(false);
1:1de7e7e:         policyMap.setDefaultEntry(defaultEntry);
1:1de7e7e:         broker.setDestinationPolicy(policyMap);
1:1de7e7e: 
1:883eed0:         url = broker.getTransportConnectors().get(0).getConnectUri().toString();
1:a6a6a70: 
1:f206a1b:         return broker;
1:f206a1b:     }
1:a6a6a70: 
1:2030097:     public void configureConnectionFactory(ActiveMQConnectionFactory factory) {
1:2030097:         // nothing to do
1:2030097:     }
1:2030097: 
1:f206a1b:     public void testFailoverProducerCloseBeforeTransaction() throws Exception {
1:f206a1b:         startCleanBroker();
1:f206a1b:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:2030097:         configureConnectionFactory(cf);
1:f206a1b:         Connection connection = cf.createConnection();
1:f206a1b:         connection.start();
1:f206a1b:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:f206a1b:         Queue destination = session.createQueue(QUEUE_NAME);
1:a6a6a70: 
3:b9e51d6:         MessageConsumer consumer = session.createConsumer(destination);
1:f206a1b:         produceMessage(session, destination);
1:f206a1b: 
1:f206a1b:         // restart to force failover and connection state recovery before the commit
1:f206a1b:         broker.stop();
1:883eed0:         startBroker(false, url);
1:f206a1b: 
1:f206a1b:         session.commit();
1:f206a1b:         assertNotNull("we got the message", consumer.receive(20000));
1:f206a1b:         session.commit();
1:f206a1b:         connection.close();
1:a6a6a70:     }
1:f206a1b: 
1:f206a1b:     public void initCombosForTestFailoverCommitReplyLost() {
1:14b91d4:         String osName = System.getProperty("os.name");
1:14b91d4:         Object[] persistenceAdapters;
1:14b91d4:         if (!osName.equalsIgnoreCase("AIX") && !osName.equalsIgnoreCase("SunOS")) {
1:14b91d4:             persistenceAdapters = new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB, PersistenceAdapterChoice.JDBC};
1:fafaf7d:         } else {
1:14b91d4:             persistenceAdapters = new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.JDBC};
1:a6a6a70:         }
1:14b91d4:         addCombinationValues("defaultPersistenceAdapter",persistenceAdapters);
1:a6a6a70:     }
1:f206a1b: 
1:8311938:     @SuppressWarnings("unchecked")
1:f206a1b:     public void testFailoverCommitReplyLost() throws Exception {
1:f206a1b: 
1:a6a6a70:         broker = createBroker(true);
1:f206a1b:         setDefaultPersistenceAdapter(broker);
1:f206a1b: 
1:f206a1b:         broker.setPlugins(new BrokerPlugin[]{
1:a6a6a70:                 new BrokerPluginSupport() {
1:a6a6a70:                     @Override
1:0bc545b:                     public void commitTransaction(ConnectionContext context,
1:f206a1b:                                                   TransactionId xid, boolean onePhase) throws Exception {
1:0bc545b:                         super.commitTransaction(context, xid, onePhase);
1:0bc545b:                         // so commit will hang as if reply is lost
1:0bc545b:                         context.setDontSendReponse(true);
1:f206a1b:                         Executors.newSingleThreadExecutor().execute(new Runnable() {
1:0bc545b:                             public void run() {
1:0bc545b:                                 LOG.info("Stopping broker post commit...");
1:fe9d99e:                                 try {
4:0bc545b:                                     broker.stop();
2:0bc545b:                                 } catch (Exception e) {
2:0bc545b:                                     e.printStackTrace();
1:f206a1b:                                 }
1:0bc545b:                             }
1:0bc545b:                         });
1:f206a1b:                     }
1:a6a6a70:                 }
1:0bc545b:         });
1:0bc545b:         broker.start();
1:f206a1b: 
1:e771b88:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:2030097:         configureConnectionFactory(cf);
1:e771b88:         Connection connection = cf.createConnection();
1:e771b88:         connection.start();
1:1606c59:         final Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:1606c59:         Queue destination = session.createQueue(QUEUE_NAME);
1:8311938: 
1:1606c59:         MessageConsumer consumer = session.createConsumer(destination);
1:0bc545b:         produceMessage(session, destination);
1:f206a1b: 
1:0bc545b:         final CountDownLatch commitDoneLatch = new CountDownLatch(1);
1:1606c59:         // broker will die on commit reply so this will hang till restart
1:f206a1b:         Executors.newSingleThreadExecutor().execute(new Runnable() {
1:0bc545b:             public void run() {
1:1606c59:                 LOG.info("doing async commit...");
1:0bc545b:                 try {
1:fe9d99e:                     session.commit();
1:b836af8:                 } catch (JMSException e) {
1:b836af8:                     assertTrue(e instanceof TransactionRolledBackException);
1:b836af8:                     LOG.info("got commit exception: ", e);
1:a6a6a70:                 }
1:b836af8:                 commitDoneLatch.countDown();
1:b836af8:                 LOG.info("done async commit");
1:0bc545b:             }
1:0bc545b:         });
1:f206a1b: 
1:0bc545b:         // will be stopped by the plugin
1:0bc545b:         broker.waitUntilStopped();
1:883eed0:         broker = createBroker(false, url);
1:f206a1b:         setDefaultPersistenceAdapter(broker);
1:0bc545b:         broker.start();
1:f206a1b: 
1:c34851f:         assertTrue("tx committed through failover", commitDoneLatch.await(30, TimeUnit.SECONDS));
1:f206a1b: 
2:0bc545b:         // new transaction
2:0bc545b:         Message msg = consumer.receive(20000);
2:0bc545b:         LOG.info("Received: " + msg);
1:8732f70:         assertNotNull("we got the message", msg);
1:1606c59:         assertNull("we got just one message", consumer.receive(2000));
1:8732f70:         session.commit();
1:0bc545b:         consumer.close();
1:0bc545b:         connection.close();
1:f206a1b: 
1:0bc545b:         // ensure no dangling messages with fresh broker etc
1:f206a1b:         broker.stop();
1:0bc545b:         broker.waitUntilStopped();
1:f206a1b: 
1:0bc545b:         LOG.info("Checking for remaining/hung messages..");
1:883eed0:         broker = createBroker(false, url);
1:f206a1b:         setDefaultPersistenceAdapter(broker);
1:0bc545b:         broker.start();
1:f206a1b: 
1:0bc545b:         // after restart, ensure no dangling messages
1:0bc545b:         cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:2030097:         configureConnectionFactory(cf);
1:0bc545b:         connection = cf.createConnection();
1:0bc545b:         connection.start();
1:0bc545b:         Session session2 = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:8732f70:         consumer = session2.createConsumer(destination);
1:8732f70:         msg = consumer.receive(1000);
1:0bc545b:         LOG.info("Received: " + msg);
1:0bc545b:         assertNull("no messges left dangling but got: " + msg, msg);
1:0bc545b:         connection.close();
1:0bc545b:     }
1:f206a1b: 
1:7d8ce02:     @SuppressWarnings("unchecked")
1:8311938:     public void testFailoverCommitReplyLostWithDestinationPathSeparator() throws Exception {
1:8311938: 
1:8311938:         broker = createBroker(true);
1:8311938:         setDefaultPersistenceAdapter(broker);
1:8311938: 
1:8311938:         broker.setPlugins(new BrokerPlugin[]{
1:8311938:                 new DestinationPathSeparatorBroker(),
1:8311938:                 new BrokerPluginSupport() {
1:8311938:                     @Override
1:8311938:                     public void commitTransaction(ConnectionContext context,
1:8311938:                                                   TransactionId xid, boolean onePhase) throws Exception {
1:8311938:                         super.commitTransaction(context, xid, onePhase);
1:8311938:                         // so commit will hang as if reply is lost
1:8311938:                         context.setDontSendReponse(true);
1:8311938:                         Executors.newSingleThreadExecutor().execute(new Runnable() {
1:8311938:                             public void run() {
1:8311938:                                 LOG.info("Stopping broker post commit...");
1:8311938:                                 try {
1:8311938:                                     broker.stop();
1:8311938:                                 } catch (Exception e) {
1:8311938:                                     e.printStackTrace();
1:8311938:                                 }
1:8311938:                             }
1:8311938:                         });
1:8311938:                     }
1:8311938:                 }
1:8311938:         });
1:8311938:         broker.start();
1:8311938: 
1:8311938:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:8311938:         configureConnectionFactory(cf);
1:8311938:         Connection connection = cf.createConnection();
1:8311938:         connection.start();
1:8311938:         final Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:8311938:         Queue destination = session.createQueue(QUEUE_NAME.replace('.','/') + "?consumer.prefetchSize=0");
1:8311938: 
1:8311938:         MessageConsumer consumer = session.createConsumer(destination);
1:8311938:         produceMessage(session, destination);
1:8311938: 
1:8311938:         final CountDownLatch commitDoneLatch = new CountDownLatch(1);
1:8311938:         // broker will die on commit reply so this will hang till restart
1:8311938:         Executors.newSingleThreadExecutor().execute(new Runnable() {
1:8311938:             public void run() {
1:8311938:                 LOG.info("doing async commit...");
1:8311938:                 try {
1:8311938:                     session.commit();
1:8311938:                 } catch (JMSException e) {
1:8311938:                     assertTrue(e instanceof TransactionRolledBackException);
1:8311938:                     LOG.info("got commit exception: ", e);
1:8311938:                 }
1:8311938:                 commitDoneLatch.countDown();
1:8311938:                 LOG.info("done async commit");
1:8311938:             }
1:8311938:         });
1:f206a1b: 
1:8311938:         // will be stopped by the plugin
1:8311938:         broker.waitUntilStopped();
1:8311938:         broker = createBroker(false, url);
1:8311938:         setDefaultPersistenceAdapter(broker);
1:8311938:         broker.setPlugins(new BrokerPlugin[]{new DestinationPathSeparatorBroker()});
1:8311938:         broker.start();
1:8311938: 
1:8311938:         assertTrue("tx committed trough failover", commitDoneLatch.await(30, TimeUnit.SECONDS));
1:8311938: 
1:8311938:         // new transaction
1:8311938:         Message msg = consumer.receive(20000);
1:8311938:         LOG.info("Received: " + msg);
1:8311938:         assertNotNull("we got the message", msg);
1:8311938:         assertNull("we got just one message", consumer.receive(2000));
1:8311938:         session.commit();
1:8311938:         consumer.close();
1:8311938:         connection.close();
1:8311938: 
1:8311938:         // ensure no dangling messages with fresh broker etc
1:8311938:         broker.stop();
1:8311938:         broker.waitUntilStopped();
1:8311938: 
1:8311938:         LOG.info("Checking for remaining/hung messages..");
1:8311938:         broker = createBroker(false, url);
1:8311938:         setDefaultPersistenceAdapter(broker);
1:8311938:         broker.setPlugins(new BrokerPlugin[]{new DestinationPathSeparatorBroker()});
1:8311938:         broker.start();
1:8311938: 
1:8311938:         // after restart, ensure no dangling messages
1:8311938:         cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:8311938:         configureConnectionFactory(cf);
1:8311938:         connection = cf.createConnection();
1:8311938:         connection.start();
1:8311938:         Session session2 = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:8311938:         consumer = session2.createConsumer(destination);
1:8311938:         msg = consumer.receive(1000);
1:8311938:         LOG.info("Received: " + msg);
1:8311938:         assertNull("no messges left dangling but got: " + msg, msg);
1:8311938:         connection.close();
1:8311938: 
1:8311938:         ActiveMQDestination[] destinations = broker.getRegionBroker().getDestinations();
1:8311938:         for (ActiveMQDestination dest : destinations) {
1:8311938:             LOG.info("Destinations list: " + dest);
1:8311938:         }
1:8311938:         assertEquals("Only one destination", 1, broker.getRegionBroker().getDestinations().length);
1:8311938:     }
1:8311938: 
1:f206a1b:     public void initCombosForTestFailoverSendReplyLost() {
1:6d444d5:         addCombinationValues("defaultPersistenceAdapter",
1:bb03eed:             new Object[]{PersistenceAdapterChoice.KahaDB,
1:f206a1b:                     PersistenceAdapterChoice.JDBC
1:bb03eed:                     // not implemented for AMQ store or PersistenceAdapterChoice.LevelDB
1:f206a1b:             });
1:8311938:     }
1:f206a1b: 
1:7d8ce02:     @SuppressWarnings("unchecked")
1:f206a1b:     public void testFailoverSendReplyLost() throws Exception {
1:f206a1b: 
1:0bc545b:         broker = createBroker(true);
1:f206a1b:         setDefaultPersistenceAdapter(broker);
1:f206a1b: 
1:f206a1b:         broker.setPlugins(new BrokerPlugin[]{
1:0bc545b:                 new BrokerPluginSupport() {
1:0bc545b:                     @Override
1:a6a6a70:                     public void send(ProducerBrokerExchange producerExchange,
1:f206a1b:                                      org.apache.activemq.command.Message messageSend)
1:a6a6a70:                             throws Exception {
1:a6a6a70:                         // so send will hang as if reply is lost
1:a6a6a70:                         super.send(producerExchange, messageSend);
1:a6a6a70:                         producerExchange.getConnectionContext().setDontSendReponse(true);
1:f206a1b:                         Executors.newSingleThreadExecutor().execute(new Runnable() {
1:a6a6a70:                             public void run() {
1:a6a6a70:                                 LOG.info("Stopping broker post send...");
1:a6a6a70:                                 try {
1:a6a6a70:                                     broker.stop();
1:a6a6a70:                                 } catch (Exception e) {
1:a6a6a70:                                     e.printStackTrace();
1:a6a6a70:                                 }
1:a6a6a70:                             }
1:a6a6a70:                         });
1:a6a6a70:                     }
1:a6a6a70:                 }
1:a6a6a70:         });
1:a6a6a70:         broker.start();
1:f206a1b: 
1:a6a6a70:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")?jms.watchTopicAdvisories=false");
1:2030097:         configureConnectionFactory(cf);
1:a6a6a70:         Connection connection = cf.createConnection();
1:a6a6a70:         connection.start();
1:a6a6a70:         final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:a6a6a70:         final Queue destination = session.createQueue(QUEUE_NAME);
1:f206a1b: 
1:a6a6a70:         MessageConsumer consumer = session.createConsumer(destination);
1:a6a6a70:         final CountDownLatch sendDoneLatch = new CountDownLatch(1);
1:a6a6a70:         // broker will die on send reply so this will hang till restart
1:f206a1b:         Executors.newSingleThreadExecutor().execute(new Runnable() {
1:a6a6a70:             public void run() {
1:a6a6a70:                 LOG.info("doing async send...");
1:a6a6a70:                 try {
1:a6a6a70:                     produceMessage(session, destination);
1:a6a6a70:                 } catch (JMSException e) {
1:a6a6a70:                     //assertTrue(e instanceof TransactionRolledBackException);
1:a6a6a70:                     LOG.error("got send exception: ", e);
1:a6a6a70:                     fail("got unexpected send exception" + e);
1:a6a6a70:                 }
1:a6a6a70:                 sendDoneLatch.countDown();
1:a6a6a70:                 LOG.info("done async send");
1:a6a6a70:             }
1:a6a6a70:         });
1:f206a1b: 
1:a6a6a70:         // will be stopped by the plugin
1:a6a6a70:         broker.waitUntilStopped();
1:883eed0:         broker = createBroker(false, url);
1:f206a1b:         setDefaultPersistenceAdapter(broker);
1:a6a6a70:         LOG.info("restarting....");
1:a6a6a70:         broker.start();
1:f206a1b: 
1:a6a6a70:         assertTrue("message sent through failover", sendDoneLatch.await(30, TimeUnit.SECONDS));
1:f206a1b: 
1:a6a6a70:         // new transaction
1:a6a6a70:         Message msg = consumer.receive(20000);
1:a6a6a70:         LOG.info("Received: " + msg);
1:a6a6a70:         assertNotNull("we got the message", msg);
1:a6a6a70:         assertNull("we got just one message", consumer.receive(2000));
1:a6a6a70:         consumer.close();
1:a6a6a70:         connection.close();
1:f206a1b: 
1:a6a6a70:         // verify stats
1:f206a1b:         assertEquals("no newly queued messages", 0, ((RegionBroker) broker.getRegionBroker()).getDestinationStatistics().getEnqueues().getCount());
1:f206a1b:         assertEquals("1 dequeue", 1, ((RegionBroker) broker.getRegionBroker()).getDestinationStatistics().getDequeues().getCount());
1:f206a1b: 
1:a6a6a70:         // ensure no dangling messages with fresh broker etc
1:a6a6a70:         broker.stop();
1:a6a6a70:         broker.waitUntilStopped();
1:f206a1b: 
1:a6a6a70:         LOG.info("Checking for remaining/hung messages with second restart..");
1:883eed0:         broker = createBroker(false, url);
1:f206a1b:         setDefaultPersistenceAdapter(broker);
1:a6a6a70:         broker.start();
1:f206a1b: 
1:a6a6a70:         // after restart, ensure no dangling messages
1:a6a6a70:         cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:2030097:         configureConnectionFactory(cf);
1:a6a6a70:         connection = cf.createConnection();
1:a6a6a70:         connection.start();
1:a6a6a70:         Session session2 = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:a6a6a70:         consumer = session2.createConsumer(destination);
1:a6a6a70:         msg = consumer.receive(1000);
1:a6a6a70:         LOG.info("Received: " + msg);
1:a6a6a70:         assertNull("no messges left dangling but got: " + msg, msg);
1:a6a6a70:         connection.close();
1:a6a6a70:     }
1:f206a1b: 
1:f206a1b:     public void initCombosForTestFailoverConnectionSendReplyLost() {
1:f206a1b:         addCombinationValues("defaultPersistenceAdapter",
1:bb03eed:             new Object[]{PersistenceAdapterChoice.KahaDB,
1:f206a1b:                     PersistenceAdapterChoice.JDBC
1:f206a1b:                     // last producer message id store feature not implemented for AMQ store
1:bb03eed:                     // or PersistenceAdapterChoice.LevelDB
1:f206a1b:             });
1:a6a6a70:     }
1:f206a1b: 
1:7d8ce02:     @SuppressWarnings("unchecked")
1:f206a1b:     public void testFailoverConnectionSendReplyLost() throws Exception {
1:f206a1b: 
1:a6a6a70:         broker = createBroker(true);
1:f206a1b:         PersistenceAdapter store = setDefaultPersistenceAdapter(broker);
1:f206a1b:         if (store instanceof KahaDBPersistenceAdapter) {
1:f206a1b:             // duplicate checker not updated on canceled tasks, even it
1:f206a1b:             // it was, recovery of the audit would fail as the message is
1:f206a1b:             // not recorded in the store and the audit may not be up to date.
1:f206a1b:             // So if duplicate messages are a absolute no no after restarts,
1:f206a1b:             // ConcurrentStoreAndDispatchQueues must be disabled
1:f206a1b:             ((KahaDBPersistenceAdapter) store).setConcurrentStoreAndDispatchQueues(false);
1:f206a1b:         }
1:f206a1b: 
1:a6a6a70:         final SocketProxy proxy = new SocketProxy();
1:f206a1b: 
1:f206a1b:         broker.setPlugins(new BrokerPlugin[]{
1:a6a6a70:                 new BrokerPluginSupport() {
1:a6a6a70:                     private boolean firstSend = true;
1:f206a1b: 
1:a6a6a70:                     @Override
1:a6a6a70:                     public void send(ProducerBrokerExchange producerExchange,
1:f206a1b:                                      org.apache.activemq.command.Message messageSend)
1:a6a6a70:                             throws Exception {
1:a6a6a70:                         // so send will hang as if reply is lost
1:a6a6a70:                         super.send(producerExchange, messageSend);
1:a6a6a70:                         if (firstSend) {
1:a6a6a70:                             firstSend = false;
1:f206a1b: 
1:a6a6a70:                             producerExchange.getConnectionContext().setDontSendReponse(true);
1:f206a1b:                             Executors.newSingleThreadExecutor().execute(new Runnable() {
1:a6a6a70:                                 public void run() {
1:a6a6a70:                                     LOG.info("Stopping connection post send...");
1:a6a6a70:                                     try {
1:a6a6a70:                                         proxy.close();
1:a6a6a70:                                     } catch (Exception e) {
1:a6a6a70:                                         e.printStackTrace();
1:a6a6a70:                                     }
1:a6a6a70:                                 }
1:a6a6a70:                             });
1:a6a6a70:                         }
1:a6a6a70:                     }
1:a6a6a70:                 }
1:a6a6a70:         });
1:a6a6a70:         broker.start();
1:f206a1b: 
1:a6a6a70:         proxy.setTarget(new URI(url));
1:a6a6a70:         proxy.open();
1:f206a1b: 
1:a6a6a70:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + proxy.getUrl().toASCIIString() + ")?jms.watchTopicAdvisories=false");
1:2030097:         configureConnectionFactory(cf);
1:a6a6a70:         Connection connection = cf.createConnection();
1:a6a6a70:         connection.start();
1:a6a6a70:         final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:a6a6a70:         final Queue destination = session.createQueue(QUEUE_NAME);
1:f206a1b: 
1:a6a6a70:         MessageConsumer consumer = session.createConsumer(destination);
1:a6a6a70:         final CountDownLatch sendDoneLatch = new CountDownLatch(1);
1:a6a6a70:         // proxy connection will die on send reply so this will hang on failover reconnect till open
1:f206a1b:         Executors.newSingleThreadExecutor().execute(new Runnable() {
1:a6a6a70:             public void run() {
1:a6a6a70:                 LOG.info("doing async send...");
1:a6a6a70:                 try {
1:a6a6a70:                     produceMessage(session, destination);
1:a6a6a70:                 } catch (JMSException e) {
1:a6a6a70:                     //assertTrue(e instanceof TransactionRolledBackException);
1:a6a6a70:                     LOG.info("got send exception: ", e);
1:a6a6a70:                 }
1:a6a6a70:                 sendDoneLatch.countDown();
1:a6a6a70:                 LOG.info("done async send");
1:a6a6a70:             }
1:a6a6a70:         });
1:f206a1b: 
1:a6a6a70:         // will be closed by the plugin
1:a6a6a70:         assertTrue("proxy was closed", proxy.waitUntilClosed(30));
1:a6a6a70:         LOG.info("restarting proxy");
1:a6a6a70:         proxy.open();
1:f206a1b: 
1:a6a6a70:         assertTrue("message sent through failover", sendDoneLatch.await(30, TimeUnit.SECONDS));
1:f206a1b: 
1:a6a6a70:         Message msg = consumer.receive(20000);
1:a6a6a70:         LOG.info("Received: " + msg);
1:a6a6a70:         assertNotNull("we got the message", msg);
1:a6a6a70:         assertNull("we got just one message", consumer.receive(2000));
1:a6a6a70:         consumer.close();
1:a6a6a70:         connection.close();
1:f206a1b: 
1:a6a6a70:         // verify stats, connection dup suppression means dups don't get to broker
1:f206a1b:         assertEquals("one queued message", 1, ((RegionBroker) broker.getRegionBroker()).getDestinationStatistics().getEnqueues().getCount());
1:f206a1b: 
1:a6a6a70:         // ensure no dangling messages with fresh broker etc
1:a6a6a70:         broker.stop();
1:a6a6a70:         broker.waitUntilStopped();
1:f206a1b: 
1:a6a6a70:         LOG.info("Checking for remaining/hung messages with restart..");
1:883eed0:         broker = createBroker(false, url);
1:f206a1b:         setDefaultPersistenceAdapter(broker);
1:a6a6a70:         broker.start();
1:f206a1b: 
1:a6a6a70:         // after restart, ensure no dangling messages
1:a6a6a70:         cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:2030097:         configureConnectionFactory(cf);
1:a6a6a70:         connection = cf.createConnection();
1:a6a6a70:         connection.start();
1:a6a6a70:         Session session2 = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:a6a6a70:         consumer = session2.createConsumer(destination);
1:a6a6a70:         msg = consumer.receive(1000);
1:a6a6a70:         LOG.info("Received: " + msg);
1:0bc545b:         assertNull("no messges left dangling but got: " + msg, msg);
1:0bc545b:         connection.close();
1:a6a6a70:     }
1:f206a1b: 
1:f206a1b:     public void testFailoverProducerCloseBeforeTransactionFailWhenDisabled() throws Exception {
1:f206a1b:         startCleanBroker();
1:f206a1b:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")?trackTransactionProducers=false");
1:2030097:         configureConnectionFactory(cf);
1:f206a1b:         Connection connection = cf.createConnection();
1:f206a1b:         connection.start();
1:f206a1b:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:f206a1b:         Queue destination = session.createQueue(QUEUE_NAME);
1:f206a1b: 
1:f206a1b:         MessageConsumer consumer = session.createConsumer(destination);
1:f206a1b:         produceMessage(session, destination);
1:f206a1b: 
1:f206a1b:         // restart to force failover and connection state recovery before the commit
1:f206a1b:         broker.stop();
1:883eed0:         startBroker(false, url);
1:f206a1b: 
1:0bc545b:         try {
1:f206a1b:             session.commit();
1:fe9d99e:             fail("expect ex for rollback only on async exc");
1:fe9d99e:         } catch (JMSException expected) {
1:fe9d99e:         }
1:f206a1b: 
1:f206a1b:         // without tracking producers, message will not be replayed on recovery
1:f206a1b:         assertNull("we got the message", consumer.receive(5000));
1:f206a1b:         session.commit();
1:f206a1b:         connection.close();
1:62daac4:     }
1:f206a1b: 
1:f206a1b:     public void testFailoverMultipleProducerCloseBeforeTransaction() throws Exception {
1:f206a1b:         startCleanBroker();
1:0bc545b:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:2030097:         configureConnectionFactory(cf);
1:0bc545b:         Connection connection = cf.createConnection();
1:0bc545b:         connection.start();
1:f206a1b:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:f206a1b:         Queue destination = session.createQueue(QUEUE_NAME);
1:f206a1b: 
1:f206a1b:         MessageConsumer consumer = session.createConsumer(destination);
1:f206a1b:         MessageProducer producer;
1:f206a1b:         TextMessage message;
1:f206a1b:         final int count = 10;
1:f206a1b:         for (int i = 0; i < count; i++) {
1:f206a1b:             producer = session.createProducer(destination);
1:f206a1b:             message = session.createTextMessage("Test message: " + count);
1:f206a1b:             producer.send(message);
1:f206a1b:             producer.close();
1:f206a1b:         }
1:f206a1b: 
1:f206a1b:         // restart to force failover and connection state recovery before the commit
1:f206a1b:         broker.stop();
1:883eed0:         startBroker(false, url);
1:f206a1b: 
1:f206a1b:         session.commit();
1:f206a1b:         for (int i = 0; i < count; i++) {
1:f206a1b:             assertNotNull("we got all the message: " + count, consumer.receive(20000));
1:f206a1b:         }
1:f206a1b:         session.commit();
1:f206a1b:         connection.close();
1:f206a1b:     }
1:f206a1b: 
1:f206a1b:     // https://issues.apache.org/activemq/browse/AMQ-2772
1:f206a1b:     public void testFailoverWithConnectionConsumer() throws Exception {
1:f206a1b:         startCleanBroker();
1:f206a1b:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:2030097:         configureConnectionFactory(cf);
1:f206a1b:         Connection connection = cf.createConnection();
1:f206a1b:         connection.start();
1:f206a1b: 
1:e771b88:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:e771b88:         Queue destination = session.createQueue(QUEUE_NAME);
1:f206a1b: 
1:e771b88:         final CountDownLatch connectionConsumerGotOne = new CountDownLatch(1);
1:e771b88:         final Session poolSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:e771b88:         connection.createConnectionConsumer(destination, null, new ServerSessionPool() {
1:e771b88:             public ServerSession getServerSession() throws JMSException {
1:e771b88:                 return new ServerSession() {
1:e771b88:                     public Session getSession() throws JMSException {
1:e771b88:                         return poolSession;
1:e771b88:                     }
1:f206a1b: 
1:e771b88:                     public void start() throws JMSException {
1:e771b88:                         connectionConsumerGotOne.countDown();
1:e771b88:                         poolSession.run();
1:e771b88:                     }
1:e771b88:                 };
1:e771b88:             }
1:e771b88:         }, 1);
1:f206a1b: 
1:e771b88:         MessageConsumer consumer = session.createConsumer(destination);
1:e771b88:         MessageProducer producer;
1:e771b88:         TextMessage message;
1:e771b88:         final int count = 10;
1:f206a1b:         for (int i = 0; i < count; i++) {
1:f206a1b:             producer = session.createProducer(destination);
1:e771b88:             message = session.createTextMessage("Test message: " + count);
1:e771b88:             producer.send(message);
1:e771b88:             producer.close();
1:e771b88:         }
1:a6a6a70: 
1:e771b88:         // restart to force failover and connection state recovery before the commit
1:e771b88:         broker.stop();
1:883eed0:         startBroker(false, url);
1:a6a6a70: 
1:e771b88:         session.commit();
1:f206a1b:         for (int i = 0; i < count - 1; i++) {
1:06611d9:             assertNotNull("Failed to get message: " + count, consumer.receive(20000));
1:e771b88:         }
1:e771b88:         session.commit();
1:e771b88:         connection.close();
1:f206a1b: 
1:06611d9:         assertTrue("connectionconsumer did not get a message", connectionConsumerGotOne.await(10, TimeUnit.SECONDS));
1:e771b88:     }
1:f206a1b: 
1:0bc545b:     public void testFailoverConsumerAckLost() throws Exception {
1:39d0717:         // as failure depends on hash order of state tracker recovery, do a few times
1:f206a1b:         for (int i = 0; i < 3; i++) {
1:0bc545b:             try {
1:2030097:                 LOG.info("Iteration: " + i);
1:c32820d:                 doTestFailoverConsumerAckLost(i);
1:0bc545b:             } finally {
1:0bc545b:                 stopBroker();
1:0bc545b:             }
1:0bc545b:         }
1:0bc545b:     }
1:a6a6a70: 
1:7d8ce02:     @SuppressWarnings("unchecked")
1:c32820d:     public void doTestFailoverConsumerAckLost(final int pauseSeconds) throws Exception {
1:0bc545b:         broker = createBroker(true);
1:f206a1b:         setDefaultPersistenceAdapter(broker);
1:f206a1b: 
1:f206a1b:         broker.setPlugins(new BrokerPlugin[]{
1:0bc545b:                 new BrokerPluginSupport() {
1:a6a6a70: 
1:0bc545b:                     // broker is killed on delivered ack as prefetch is 1
1:0bc545b:                     @Override
1:0bc545b:                     public void acknowledge(
1:0bc545b:                             ConsumerBrokerExchange consumerExchange,
1:0bc545b:                             final MessageAck ack) throws Exception {
1:f206a1b: 
1:0bc545b:                         consumerExchange.getConnectionContext().setDontSendReponse(true);
1:f206a1b:                         Executors.newSingleThreadExecutor().execute(new Runnable() {
1:0bc545b:                             public void run() {
1:f206a1b:                                 LOG.info("Stopping broker on ack: " + ack);
1:0bc545b:                                 try {
1:b836af8:                                     broker.stop();
1:0bc545b:                                 } catch (Exception e) {
1:0bc545b:                                     e.printStackTrace();
1:0bc545b:                                 }
1:0bc545b:                             }
1:0bc545b:                         });
1:0bc545b:                     }
1:0bc545b:                 }
1:0bc545b:         });
1:0bc545b:         broker.start();
1:a6a6a70: 
1:0bc545b:         Vector<Connection> connections = new Vector<Connection>();
1:0bc545b:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:2030097:         configureConnectionFactory(cf);
1:0bc545b:         Connection connection = cf.createConnection();
1:0bc545b:         connection.start();
1:0bc545b:         connections.add(connection);
2:0bc545b:         final Session producerSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:0bc545b:         final Queue destination = producerSession.createQueue(QUEUE_NAME + "?consumer.prefetchSize=1");
1:f206a1b: 
1:0bc545b:         connection = cf.createConnection();
1:0bc545b:         connection.start();
1:0bc545b:         connections.add(connection);
1:1de7e7e:         final Session consumerSession1 = connection.createSession(true, Session.SESSION_TRANSACTED);
1:f206a1b: 
1:0bc545b:         connection = cf.createConnection();
1:0bc545b:         connection.start();
1:0bc545b:         connections.add(connection);
1:1de7e7e:         final Session consumerSession2 = connection.createSession(true, Session.SESSION_TRANSACTED);
1:f206a1b: 
1:0bc545b:         final MessageConsumer consumer1 = consumerSession1.createConsumer(destination);
1:0bc545b:         final MessageConsumer consumer2 = consumerSession2.createConsumer(destination);
1:f206a1b: 
2:0bc545b:         produceMessage(producerSession, destination);
1:0bc545b:         produceMessage(producerSession, destination);
1:f206a1b: 
2:0bc545b:         final Vector<Message> receivedMessages = new Vector<Message>();
1:0bc545b:         final CountDownLatch commitDoneLatch = new CountDownLatch(1);
1:c32820d:         final AtomicBoolean gotTransactionRolledBackException = new AtomicBoolean(false);
1:f206a1b:         Executors.newSingleThreadExecutor().execute(new Runnable() {
1:0bc545b:             public void run() {
2:0bc545b:                 LOG.info("doing async commit after consume...");
1:0bc545b:                 try {
1:0bc545b:                     Message msg = consumer1.receive(20000);
1:0bc545b:                     LOG.info("consumer1 first attempt got message: " + msg);
2:0bc545b:                     receivedMessages.add(msg);
1:f206a1b: 
1:c32820d:                     // give some variance to the runs
1:1de7e7e:                     TimeUnit.SECONDS.sleep(random.nextInt(5));
1:f206a1b: 
1:0bc545b:                     // should not get a second message as there are two messages and two consumers
1:c32820d:                     // and prefetch=1, but with failover and unordered connection restore it can get the second
1:c32820d:                     // message.
1:f206a1b: 
1:c32820d:                     // For the transaction to complete it needs to get the same one or two messages
1:c32820d:                     // again so that the acks line up.
1:c32820d:                     // If redelivery order is different, the commit should fail with an ex
1:c32820d:                     //
1:0bc545b:                     msg = consumer1.receive(5000);
1:0bc545b:                     LOG.info("consumer1 second attempt got message: " + msg);
1:0bc545b:                     if (msg != null) {
1:0bc545b:                         receivedMessages.add(msg);
1:0bc545b:                     }
1:f206a1b: 
1:0bc545b:                     LOG.info("committing consumer1 session: " + receivedMessages.size() + " messsage(s)");
1:62daac4:                     try {
1:62daac4:                         consumerSession1.commit();
1:2b1cda1:                     } catch (TransactionRolledBackException expected) {
1:2b1cda1:                         LOG.info("got exception ex on commit", expected);
1:2b1cda1:                         gotTransactionRolledBackException.set(true);
1:2b1cda1:                         // ok, message one was not replayed so we expect the rollback
1:62daac4:                     }
2:0bc545b:                     commitDoneLatch.countDown();
2:0bc545b:                     LOG.info("done async commit");
1:0bc545b:                 } catch (Exception e) {
1:0bc545b:                     e.printStackTrace();
1:62daac4:                 }
1:80f7e38:             }
1:0bc545b:         });
1:f206a1b: 
1:0bc545b:         // will be stopped by the plugin
1:0bc545b:         broker.waitUntilStopped();
1:883eed0:         broker = createBroker(false, url);
1:f206a1b:         setDefaultPersistenceAdapter(broker);
1:b836af8:         broker.start();
1:a6a6a70: 
1:cfe099d:         assertTrue("tx committed through failover", commitDoneLatch.await(30, TimeUnit.SECONDS));
1:a6a6a70: 
1:0bc545b:         LOG.info("received message count: " + receivedMessages.size());
1:f206a1b: 
1:2b1cda1:         // new transaction to get both messages from either consumer
1:2b1cda1:         for (int i=0; i<2; i++) {
1:2b1cda1:             Message msg = consumer1.receive(5000);
1:2b1cda1:             LOG.info("post: from consumer1 received: " + msg);
1:2b1cda1:             consumerSession1.commit();
1:2b1cda1:             if (msg == null) {
1:2b1cda1:                 msg = consumer2.receive(10000);
1:2b1cda1:                 LOG.info("post: from consumer2 received: " + msg);
1:2b1cda1:                 consumerSession2.commit();
1:2b1cda1:             }
1:2b1cda1:             assertNotNull("got message [" + i + "]", msg);
1:a6a6a70:         }
1:f206a1b: 
1:f206a1b:         for (Connection c : connections) {
1:0bc545b:             c.close();
1:a6a6a70:         }
1:f206a1b: 
1:0bc545b:         // ensure no dangling messages with fresh broker etc
1:b836af8:         broker.stop();
1:0bc545b:         broker.waitUntilStopped();
1:f206a1b: 
1:0bc545b:         LOG.info("Checking for remaining/hung messages..");
1:883eed0:         broker = createBroker(false, url);
1:f206a1b:         setDefaultPersistenceAdapter(broker);
1:0bc545b:         broker.start();
1:f206a1b: 
1:0bc545b:         // after restart, ensure no dangling messages
1:0bc545b:         cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:2030097:         configureConnectionFactory(cf);
1:0bc545b:         connection = cf.createConnection();
1:0bc545b:         connection.start();
1:0bc545b:         Session sweeperSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:0bc545b:         MessageConsumer sweeper = sweeperSession.createConsumer(destination);
1:2b1cda1:         Message msg = sweeper.receive(1000);
1:80f7e38:         LOG.info("Sweep received: " + msg);
1:a6a6a70:         assertNull("no messges left dangling but got: " + msg, msg);
1:a6a6a70:         connection.close();
1:c32820d:     }
1:a6a6a70: 
1:dc0291b:     public void testPoolingNConsumesAfterReconnect() throws Exception {
1:dc0291b:         broker = createBroker(true);
1:dc0291b:         setDefaultPersistenceAdapter(broker);
1:dc0291b: 
1:dc0291b:         broker.setPlugins(new BrokerPlugin[]{
1:dc0291b:                 new BrokerPluginSupport() {
1:dc0291b:                     int count = 0;
1:dc0291b: 
1:dc0291b:                     @Override
1:dc0291b:                     public void removeConsumer(ConnectionContext context, final ConsumerInfo info) throws Exception {
1:dc0291b:                         if (count++ == 1) {
1:dc0291b:                             Executors.newSingleThreadExecutor().execute(new Runnable() {
1:dc0291b:                                 public void run() {
1:dc0291b:                                     LOG.info("Stopping broker on removeConsumer: " + info);
1:dc0291b:                                     try {
1:dc0291b:                                         broker.stop();
1:dc0291b:                                     } catch (Exception e) {
1:dc0291b:                                         e.printStackTrace();
1:dc0291b:                                     }
1:dc0291b:                                 }
1:dc0291b:                             });
1:dc0291b:                         }
1:dc0291b:                     }
1:dc0291b:                 }
1:dc0291b:         });
1:dc0291b:         broker.start();
1:dc0291b: 
1:dc0291b:         Vector<Connection> connections = new Vector<Connection>();
1:dc0291b:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:dc0291b:         configureConnectionFactory(cf);
1:dc0291b:         Connection connection = cf.createConnection();
1:dc0291b:         connection.start();
1:dc0291b:         Session producerSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:dc0291b:         final Queue destination = producerSession.createQueue(QUEUE_NAME + "?consumer.prefetchSize=1");
1:dc0291b: 
1:dc0291b:         produceMessage(producerSession, destination);
1:dc0291b:         connection.close();
1:dc0291b: 
1:dc0291b:         connection = cf.createConnection();
1:dc0291b:         connection.start();
1:dc0291b:         connections.add(connection);
1:dc0291b:         final Session consumerSession = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:dc0291b: 
1:dc0291b:         final int sessionCount = 10;
1:dc0291b:         final Stack<Session> sessions = new Stack<Session>();
1:dc0291b:         for (int i = 0; i < sessionCount; i++) {
1:dc0291b:             sessions.push(connection.createSession(false, Session.AUTO_ACKNOWLEDGE));
1:dc0291b:         }
1:dc0291b: 
1:dc0291b:         final int consumerCount = 1000;
1:dc0291b:         final Deque<MessageConsumer> consumers = new ArrayDeque<MessageConsumer>();
1:dc0291b:         for (int i = 0; i < consumerCount; i++) {
1:dc0291b:             consumers.push(consumerSession.createConsumer(destination));
1:dc0291b:         }
1:dc0291b:         final ExecutorService executorService = Executors.newCachedThreadPool();
1:dc0291b: 
1:dc0291b:         final FailoverTransport failoverTransport = ((ActiveMQConnection) connection).getTransport().narrow(FailoverTransport.class);
1:dc0291b:         final TransportListener delegate = failoverTransport.getTransportListener();
1:dc0291b:         failoverTransport.setTransportListener(new TransportListener() {
1:dc0291b:             @Override
1:dc0291b:             public void onCommand(Object command) {
1:dc0291b:                 delegate.onCommand(command);
1:dc0291b:             }
1:dc0291b: 
1:dc0291b:             @Override
1:dc0291b:             public void onException(IOException error) {
1:dc0291b:                 delegate.onException(error);
1:dc0291b:             }
1:dc0291b: 
1:dc0291b:             @Override
1:dc0291b:             public void transportInterupted() {
1:dc0291b: 
1:dc0291b:                 LOG.error("Transport interrupted: " + failoverTransport, new RuntimeException("HERE"));
1:dc0291b:                 for (int i = 0; i < consumerCount && !consumers.isEmpty(); i++) {
1:dc0291b: 
1:dc0291b:                     executorService.execute(new Runnable() {
1:dc0291b:                         public void run() {
1:dc0291b:                             MessageConsumer localConsumer = null;
1:dc0291b:                             try {
1:dc0291b:                                 synchronized (delegate) {
1:dc0291b:                                     localConsumer = consumers.pop();
1:dc0291b:                                 }
1:dc0291b:                                 localConsumer.receive(1);
1:dc0291b: 
1:dc0291b:                                 LOG.info("calling close() " + ((ActiveMQMessageConsumer) localConsumer).getConsumerId());
1:dc0291b:                                 localConsumer.close();
1:dc0291b:                             } catch (NoSuchElementException nse) {
1:dc0291b:                             } catch (Exception ignored) {
1:dc0291b:                                 LOG.error("Ex on: " + ((ActiveMQMessageConsumer) localConsumer).getConsumerId(), ignored);
1:dc0291b:                             }
1:dc0291b:                         }
1:dc0291b:                     });
1:dc0291b:                 }
1:dc0291b: 
1:dc0291b:                 delegate.transportInterupted();
1:dc0291b:             }
1:dc0291b: 
1:dc0291b:             @Override
1:dc0291b:             public void transportResumed() {
1:dc0291b:                 delegate.transportResumed();
1:dc0291b:             }
1:dc0291b:         });
1:dc0291b: 
1:dc0291b: 
1:dc0291b:         MessageConsumer consumer = null;
1:dc0291b:         synchronized (delegate) {
1:dc0291b:             consumer = consumers.pop();
1:dc0291b:         }
1:dc0291b:         LOG.info("calling close to trigger broker stop " + ((ActiveMQMessageConsumer) consumer).getConsumerId());
1:dc0291b:         consumer.close();
1:dc0291b: 
1:dc0291b:         // will be stopped by the plugin
1:dc0291b:         broker.waitUntilStopped();
1:dc0291b:         broker = createBroker(false, url);
1:dc0291b:         setDefaultPersistenceAdapter(broker);
1:dc0291b:         broker.start();
1:dc0291b: 
1:dc0291b:         consumer = consumerSession.createConsumer(destination);
1:dc0291b:         LOG.info("finally consuming message: " + ((ActiveMQMessageConsumer) consumer).getConsumerId());
1:dc0291b: 
1:dc0291b:         Message msg = null;
1:dc0291b:         for (int i = 0; i < 4 && msg == null; i++) {
1:dc0291b:             msg = consumer.receive(1000);
1:dc0291b:         }
1:dc0291b:         LOG.info("post: from consumer1 received: " + msg);
1:dc0291b:         assertNotNull("got message after failover", msg);
1:dc0291b:         msg.acknowledge();
1:dc0291b: 
1:dc0291b:         for (Connection c : connections) {
1:dc0291b:             c.close();
1:dc0291b:         }
1:dc0291b:     }
1:dc0291b: 
1:b836af8:     public void testAutoRollbackWithMissingRedeliveries() throws Exception {
1:b836af8:         broker = createBroker(true);
1:b836af8:         broker.start();
1:b836af8:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:2030097:         configureConnectionFactory(cf);
1:b836af8:         Connection connection = cf.createConnection();
1:b836af8:         connection.start();
1:b836af8:         final Session producerSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:b836af8:         final Queue destination = producerSession.createQueue(QUEUE_NAME + "?consumer.prefetchSize=1");
1:b836af8:         final Session consumerSession = connection.createSession(true, Session.SESSION_TRANSACTED);
1:b836af8:         MessageConsumer consumer = consumerSession.createConsumer(destination);
1:f206a1b: 
1:b836af8:         produceMessage(producerSession, destination);
1:f206a1b: 
1:b836af8:         Message msg = consumer.receive(20000);
1:b836af8:         assertNotNull(msg);
1:f206a1b: 
1:b836af8:         broker.stop();
1:883eed0:         broker = createBroker(false, url);
1:39d0717:         // use empty jdbc store so that default wait(0) for redeliveries will timeout after failover
1:f206a1b:         setPersistenceAdapter(broker, PersistenceAdapterChoice.JDBC);
1:b836af8:         broker.start();
1:f206a1b: 
1:b836af8:         try {
1:39d0717:             consumerSession.commit();
1:39d0717:             fail("expected transaciton rolledback ex");
1:39d0717:         } catch (TransactionRolledBackException expected) {
1:b836af8:         }
1:f206a1b: 
1:f206a1b:         broker.stop();
1:883eed0:         broker = createBroker(false, url);
1:b836af8:         broker.start();
1:f206a1b: 
1:b836af8:         assertNotNull("should get rolledback message from original restarted broker", consumer.receive(20000));
1:b836af8:         connection.close();
1:b836af8:     }
1:f206a1b: 
1:b836af8:     public void testWaitForMissingRedeliveries() throws Exception {
1:39d0717:         LOG.info("testWaitForMissingRedeliveries()");
1:39d0717:         broker = createBroker(true);
1:39d0717:         broker.start();
1:b836af8:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")?jms.consumerFailoverRedeliveryWaitPeriod=30000");
1:2030097:         configureConnectionFactory(cf);
1:39d0717:         Connection connection = cf.createConnection();
1:39d0717:         connection.start();
1:39d0717:         final Session producerSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:b836af8:         final Queue destination = producerSession.createQueue(QUEUE_NAME);
1:39d0717:         final Session consumerSession = connection.createSession(true, Session.SESSION_TRANSACTED);
1:39d0717:         MessageConsumer consumer = consumerSession.createConsumer(destination);
1:f206a1b: 
1:39d0717:         produceMessage(producerSession, destination);
1:39d0717:         Message msg = consumer.receive(20000);
1:8311938:         if (msg == null) {
1:39d0717:             AutoFailTestSupport.dumpAllThreads("missing-");
1:39d0717:         }
1:39d0717:         assertNotNull("got message just produced", msg);
1:f206a1b: 
1:f206a1b:         broker.stop();
1:883eed0:         broker = createBroker(false, url);
1:b836af8:         // use empty jdbc store so that wait for re-deliveries occur when failover resumes
1:f206a1b:         setPersistenceAdapter(broker, PersistenceAdapterChoice.JDBC);
1:39d0717:         broker.start();
1:f206a1b: 
1:39d0717:         final CountDownLatch commitDone = new CountDownLatch(1);
1:8d98247:         final CountDownLatch gotException = new CountDownLatch(1);
1:39d0717:         // will block pending re-deliveries
1:f206a1b:         Executors.newSingleThreadExecutor().execute(new Runnable() {
1:b836af8:             public void run() {
1:b836af8:                 LOG.info("doing async commit...");
1:b836af8:                 try {
1:39d0717:                     consumerSession.commit();
1:39d0717:                 } catch (JMSException ignored) {
1:8d98247:                     ignored.printStackTrace();
1:8d98247:                     gotException.countDown();
1:8d98247:                 } finally {
1:8d98247:                     commitDone.countDown();
1:b836af8:                 }
1:8d98247: 
1:b836af8:             }
1:b836af8:         });
1:f206a1b: 
1:b836af8:         broker.stop();
1:883eed0:         broker = createBroker(false, url);
1:b836af8:         broker.start();
1:a6a6a70: 
1:f206a1b:         assertTrue("commit was successful", commitDone.await(30, TimeUnit.SECONDS));
1:8d98247:         assertTrue("got exception on commit", gotException.await(30, TimeUnit.SECONDS));
1:a6a6a70: 
1:8d98247:         assertNotNull("should get failed committed message", consumer.receive(5000));
1:b836af8:         connection.close();
1:b836af8:     }
1:a6a6a70: 
1:c34851f:     public void testReDeliveryWhilePending() throws Exception {
1:c34851f:         LOG.info("testReDeliveryWhilePending()");
1:b836af8:         broker = createBroker(true);
1:b836af8:         broker.start();
1:39d0717:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")?jms.consumerFailoverRedeliveryWaitPeriod=10000");
1:2030097:         configureConnectionFactory(cf);
1:b836af8:         Connection connection = cf.createConnection();
1:b836af8:         connection.start();
1:b836af8:         final Session producerSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:39d0717:         final Queue destination = producerSession.createQueue(QUEUE_NAME + "?consumer.prefetchSize=0");
1:b836af8:         final Session consumerSession = connection.createSession(true, Session.SESSION_TRANSACTED);
1:fc25535:         final Session secondConsumerSession = connection.createSession(true, Session.SESSION_TRANSACTED);
1:fc25535: 
1:b836af8:         MessageConsumer consumer = consumerSession.createConsumer(destination);
1:f206a1b: 
1:b836af8:         produceMessage(producerSession, destination);
1:b836af8:         Message msg = consumer.receive(20000);
2:a6a6a70:         if (msg == null) {
1:b836af8:             AutoFailTestSupport.dumpAllThreads("missing-");
1:39d0717:         }
1:b836af8:         assertNotNull("got message just produced", msg);
1:f206a1b: 
1:fafaf7d:         // add another consumer into the mix that may get the message after restart
1:fc25535:         MessageConsumer consumer2 = secondConsumerSession.createConsumer(consumerSession.createQueue(QUEUE_NAME + "?consumer.prefetchSize=1"));
1:fafaf7d: 
1:39d0717:         broker.stop();
1:883eed0:         broker = createBroker(false, url);
1:0bc545b:         broker.start();
1:a6a6a70: 
1:b836af8:         final CountDownLatch commitDone = new CountDownLatch(1);
1:fc25535:         final CountDownLatch gotRollback = new CountDownLatch(1);
1:a6a6a70: 
1:fafaf7d:         final Vector<Exception> exceptions = new Vector<Exception>();
1:a6a6a70: 
1:fc25535:         // commit will fail due to failover with outstanding ack
1:f206a1b:         Executors.newSingleThreadExecutor().execute(new Runnable() {
1:39d0717:             public void run() {
1:39d0717:                 LOG.info("doing async commit...");
1:39d0717:                 try {
1:fafaf7d:                     consumerSession.commit();
1:fc25535:                 } catch (TransactionRolledBackException ex) {
1:fc25535:                     gotRollback.countDown();
1:fafaf7d:                 } catch (JMSException ex) {
1:fafaf7d:                     exceptions.add(ex);
1:fafaf7d:                 } finally {
1:39d0717:                     commitDone.countDown();
1:39d0717:                 }
1:b836af8:             }
1:39d0717:         });
1:a6a6a70: 
1:a6a6a70: 
1:fafaf7d:         assertTrue("commit completed ", commitDone.await(15, TimeUnit.SECONDS));
1:fc25535:         assertTrue("got Rollback", gotRollback.await(15, TimeUnit.SECONDS));
1:a6a6a70: 
1:fc25535:         assertTrue("no other exceptions", exceptions.isEmpty());
1:a6a6a70: 
1:fafaf7d:         // consumer replay is hashmap order dependent on a failover connection state recover so need to deal with both cases
1:fc25535:         // consume message from one of the consumers
1:fc25535:         Message message = consumer2.receive(2000);
1:fc25535:         if (message == null) {
1:fc25535:             message = consumer.receive(2000);
1:fafaf7d:         }
1:fc25535:         consumerSession.commit();
1:fc25535:         secondConsumerSession.commit();
1:fc25535: 
1:fc25535:         assertNotNull("got message after rollback", message);
1:fc25535: 
1:fc25535:         // no message should be in dlq
1:fc25535:         MessageConsumer dlqConsumer = consumerSession.createConsumer(consumerSession.createQueue("ActiveMQ.DLQ"));
1:fc25535:         assertNull("nothing in the dlq", dlqConsumer.receive(2000));
1:39d0717:         connection.close();
1:39d0717:     }
1:a6a6a70: 
1:0bc545b:     private void produceMessage(final Session producerSession, Queue destination)
1:0bc545b:             throws JMSException {
1:f206a1b:         MessageProducer producer = producerSession.createProducer(destination);
1:0bc545b:         TextMessage message = producerSession.createTextMessage("Test message");
1:0bc545b:         producer.send(message);
1:0bc545b:         producer.close();
1:0bc545b:     }
1:f206a1b: 
1:0bc545b: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:2b1cda1
/////////////////////////////////////////////////////////////////////////
1:                     } catch (TransactionRolledBackException expected) {
1:                         LOG.info("got exception ex on commit", expected);
1:                         gotTransactionRolledBackException.set(true);
1:                         // ok, message one was not replayed so we expect the rollback
/////////////////////////////////////////////////////////////////////////
1:         // new transaction to get both messages from either consumer
1:         for (int i=0; i<2; i++) {
1:             Message msg = consumer1.receive(5000);
1:             LOG.info("post: from consumer1 received: " + msg);
1:             consumerSession1.commit();
1:             if (msg == null) {
1:                 msg = consumer2.receive(10000);
1:                 LOG.info("post: from consumer2 received: " + msg);
1:                 consumerSession2.commit();
1:             }
1:             assertNotNull("got message [" + i + "]", msg);
/////////////////////////////////////////////////////////////////////////
1:         Message msg = sweeper.receive(1000);
commit:fe9d99e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             session.commit();
1:             fail("expect ex for rollback only on async exc");
1:         } catch (JMSException expected) {
1:         }
/////////////////////////////////////////////////////////////////////////
commit:1de7e7e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
/////////////////////////////////////////////////////////////////////////
1: import java.util.Random;
/////////////////////////////////////////////////////////////////////////
1:     final Random random = new Random();
/////////////////////////////////////////////////////////////////////////
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry defaultEntry = new PolicyEntry();
1:         defaultEntry.setUsePrefetchExtension(false);
1:         policyMap.setDefaultEntry(defaultEntry);
1:         broker.setDestinationPolicy(policyMap);
1: 
/////////////////////////////////////////////////////////////////////////
1:         final Session consumerSession1 = connection.createSession(true, Session.SESSION_TRANSACTED);
1:         final Session consumerSession2 = connection.createSession(true, Session.SESSION_TRANSACTED);
/////////////////////////////////////////////////////////////////////////
1:                     TimeUnit.SECONDS.sleep(random.nextInt(5));
commit:fc25535
/////////////////////////////////////////////////////////////////////////
1:         final Session secondConsumerSession = connection.createSession(true, Session.SESSION_TRANSACTED);
1: 
/////////////////////////////////////////////////////////////////////////
1:         MessageConsumer consumer2 = secondConsumerSession.createConsumer(consumerSession.createQueue(QUEUE_NAME + "?consumer.prefetchSize=1"));
1:         final CountDownLatch gotRollback = new CountDownLatch(1);
1:         // commit will fail due to failover with outstanding ack
1:                 } catch (TransactionRolledBackException ex) {
1:                     gotRollback.countDown();
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("got Rollback", gotRollback.await(15, TimeUnit.SECONDS));
1:         assertTrue("no other exceptions", exceptions.isEmpty());
1:         // consume message from one of the consumers
1:         Message message = consumer2.receive(2000);
1:         if (message == null) {
1:             message = consumer.receive(2000);
1:         consumerSession.commit();
1:         secondConsumerSession.commit();
1: 
1:         assertNotNull("got message after rollback", message);
1: 
1:         // no message should be in dlq
1:         MessageConsumer dlqConsumer = consumerSession.createConsumer(consumerSession.createQueue("ActiveMQ.DLQ"));
1:         assertNull("nothing in the dlq", dlqConsumer.receive(2000));
commit:8d98247
/////////////////////////////////////////////////////////////////////////
1:         final CountDownLatch gotException = new CountDownLatch(1);
1:                     ignored.printStackTrace();
1:                     gotException.countDown();
1:                 } finally {
1:                     commitDone.countDown();
1: 
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("got exception on commit", gotException.await(30, TimeUnit.SECONDS));
1:         assertNotNull("should get failed committed message", consumer.receive(5000));
commit:c34851f
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("tx committed through failover", commitDoneLatch.await(30, TimeUnit.SECONDS));
/////////////////////////////////////////////////////////////////////////
0:             assertNull("should be nothing left for consumer as receive should have committed", msg);
/////////////////////////////////////////////////////////////////////////
1:     public void testReDeliveryWhilePending() throws Exception {
1:         LOG.info("testReDeliveryWhilePending()");
/////////////////////////////////////////////////////////////////////////
0:         // commit may fail if other consumer gets the message on restart
/////////////////////////////////////////////////////////////////////////
0:         // either message redelivered in existing tx or consumed by consumer2
0:         // should not be available again in any event
0:             LOG.info("commit succeeded, message was redelivered to the correct consumer after restart so commit was fine");
0:             assertNull("consumer2 not get a second message consumed by 1", consumer2.receive(2000));
0:             LOG.info("commit failed, consumer2 should get it", exceptions.get(0));
0:             assertNotNull("consumer2 got message", consumer2.receive(2000));
0:             // no message should be in dlq
0:             MessageConsumer dlqConsumer = consumerSession.createConsumer(consumerSession.createQueue("ActiveMQ.DLQ"));
0:             assertNull("nothing in the dlq", dlqConsumer.receive(5000));
commit:cfe099d
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("tx committed through failover", commitDoneLatch.await(30, TimeUnit.SECONDS));
commit:dc0291b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.ActiveMQMessageConsumer;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.transport.TransportListener;
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.util.ArrayDeque;
1: import java.util.Deque;
1: import java.util.NoSuchElementException;
1: import java.util.Stack;
1: import java.util.concurrent.ExecutorService;
/////////////////////////////////////////////////////////////////////////
1:     public void testPoolingNConsumesAfterReconnect() throws Exception {
1:         broker = createBroker(true);
1:         setDefaultPersistenceAdapter(broker);
1: 
1:         broker.setPlugins(new BrokerPlugin[]{
1:                 new BrokerPluginSupport() {
1:                     int count = 0;
1: 
1:                     @Override
1:                     public void removeConsumer(ConnectionContext context, final ConsumerInfo info) throws Exception {
1:                         if (count++ == 1) {
1:                             Executors.newSingleThreadExecutor().execute(new Runnable() {
1:                                 public void run() {
1:                                     LOG.info("Stopping broker on removeConsumer: " + info);
1:                                     try {
1:                                         broker.stop();
1:                                     } catch (Exception e) {
1:                                         e.printStackTrace();
1:                                     }
1:                                 }
1:                             });
1:                         }
1:                     }
1:                 }
1:         });
1:         broker.start();
1: 
1:         Vector<Connection> connections = new Vector<Connection>();
1:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:         configureConnectionFactory(cf);
1:         Connection connection = cf.createConnection();
1:         connection.start();
1:         Session producerSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         final Queue destination = producerSession.createQueue(QUEUE_NAME + "?consumer.prefetchSize=1");
1: 
1:         produceMessage(producerSession, destination);
1:         connection.close();
1: 
1:         connection = cf.createConnection();
1:         connection.start();
1:         connections.add(connection);
1:         final Session consumerSession = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1: 
1:         final int sessionCount = 10;
1:         final Stack<Session> sessions = new Stack<Session>();
1:         for (int i = 0; i < sessionCount; i++) {
1:             sessions.push(connection.createSession(false, Session.AUTO_ACKNOWLEDGE));
1:         }
1: 
1:         final int consumerCount = 1000;
1:         final Deque<MessageConsumer> consumers = new ArrayDeque<MessageConsumer>();
1:         for (int i = 0; i < consumerCount; i++) {
1:             consumers.push(consumerSession.createConsumer(destination));
1:         }
1:         final ExecutorService executorService = Executors.newCachedThreadPool();
1: 
1:         final FailoverTransport failoverTransport = ((ActiveMQConnection) connection).getTransport().narrow(FailoverTransport.class);
1:         final TransportListener delegate = failoverTransport.getTransportListener();
1:         failoverTransport.setTransportListener(new TransportListener() {
1:             @Override
1:             public void onCommand(Object command) {
1:                 delegate.onCommand(command);
1:             }
1: 
1:             @Override
1:             public void onException(IOException error) {
1:                 delegate.onException(error);
1:             }
1: 
1:             @Override
1:             public void transportInterupted() {
1: 
1:                 LOG.error("Transport interrupted: " + failoverTransport, new RuntimeException("HERE"));
1:                 for (int i = 0; i < consumerCount && !consumers.isEmpty(); i++) {
1: 
1:                     executorService.execute(new Runnable() {
1:                         public void run() {
1:                             MessageConsumer localConsumer = null;
1:                             try {
1:                                 synchronized (delegate) {
1:                                     localConsumer = consumers.pop();
1:                                 }
1:                                 localConsumer.receive(1);
1: 
1:                                 LOG.info("calling close() " + ((ActiveMQMessageConsumer) localConsumer).getConsumerId());
1:                                 localConsumer.close();
1:                             } catch (NoSuchElementException nse) {
1:                             } catch (Exception ignored) {
1:                                 LOG.error("Ex on: " + ((ActiveMQMessageConsumer) localConsumer).getConsumerId(), ignored);
1:                             }
1:                         }
1:                     });
1:                 }
1: 
1:                 delegate.transportInterupted();
1:             }
1: 
1:             @Override
1:             public void transportResumed() {
1:                 delegate.transportResumed();
1:             }
1:         });
1: 
1: 
1:         MessageConsumer consumer = null;
1:         synchronized (delegate) {
1:             consumer = consumers.pop();
1:         }
1:         LOG.info("calling close to trigger broker stop " + ((ActiveMQMessageConsumer) consumer).getConsumerId());
1:         consumer.close();
1: 
1:         // will be stopped by the plugin
1:         broker.waitUntilStopped();
1:         broker = createBroker(false, url);
1:         setDefaultPersistenceAdapter(broker);
1:         broker.start();
1: 
1:         consumer = consumerSession.createConsumer(destination);
1:         LOG.info("finally consuming message: " + ((ActiveMQMessageConsumer) consumer).getConsumerId());
1: 
1:         Message msg = null;
1:         for (int i = 0; i < 4 && msg == null; i++) {
1:             msg = consumer.receive(1000);
1:         }
1:         LOG.info("post: from consumer1 received: " + msg);
1:         assertNotNull("got message after failover", msg);
1:         msg.acknowledge();
1: 
1:         for (Connection c : connections) {
1:             c.close();
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         // commit may fail if other consumer gets the message on restart, it will be seen as a duplicate on the connection
0:         // but with no transaction and it pending on another consumer it will be poison
/////////////////////////////////////////////////////////////////////////
0:         assertNull("consumer should not get rolled back on non redelivered message or duplicate", consumer.receive(5000));
author:Gary Tully
-------------------------------------------------------------------------------
commit:92b6bd2
/////////////////////////////////////////////////////////////////////////
1:         super.tearDown();
commit:bb03eed
/////////////////////////////////////////////////////////////////////////
1:             new Object[]{PersistenceAdapterChoice.KahaDB,
1:                     // not implemented for AMQ store or PersistenceAdapterChoice.LevelDB
/////////////////////////////////////////////////////////////////////////
1:             new Object[]{PersistenceAdapterChoice.KahaDB,
1:                     // or PersistenceAdapterChoice.LevelDB
commit:8311938
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.util.DestinationPathSeparatorBroker;
1: import org.apache.activemq.command.ActiveMQDestination;
/////////////////////////////////////////////////////////////////////////
1:     private static final String QUEUE_NAME = "Failover.WithTx";
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("unchecked")
1:     public void testFailoverCommitReplyLostWithDestinationPathSeparator() throws Exception {
1: 
1:         broker = createBroker(true);
1:         setDefaultPersistenceAdapter(broker);
1: 
1:         broker.setPlugins(new BrokerPlugin[]{
1:                 new DestinationPathSeparatorBroker(),
1:                 new BrokerPluginSupport() {
1:                     @Override
1:                     public void commitTransaction(ConnectionContext context,
1:                                                   TransactionId xid, boolean onePhase) throws Exception {
1:                         super.commitTransaction(context, xid, onePhase);
1:                         // so commit will hang as if reply is lost
1:                         context.setDontSendReponse(true);
1:                         Executors.newSingleThreadExecutor().execute(new Runnable() {
1:                             public void run() {
1:                                 LOG.info("Stopping broker post commit...");
1:                                 try {
1:                                     broker.stop();
1:                                 } catch (Exception e) {
1:                                     e.printStackTrace();
1:                                 }
1:                             }
1:                         });
1:                     }
1:                 }
1:         });
1:         broker.start();
1: 
1:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:         configureConnectionFactory(cf);
1:         Connection connection = cf.createConnection();
1:         connection.start();
1:         final Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:         Queue destination = session.createQueue(QUEUE_NAME.replace('.','/') + "?consumer.prefetchSize=0");
1: 
1:         MessageConsumer consumer = session.createConsumer(destination);
1:         produceMessage(session, destination);
1: 
1:         final CountDownLatch commitDoneLatch = new CountDownLatch(1);
1:         // broker will die on commit reply so this will hang till restart
1:         Executors.newSingleThreadExecutor().execute(new Runnable() {
1:             public void run() {
1:                 LOG.info("doing async commit...");
1:                 try {
1:                     session.commit();
1:                 } catch (JMSException e) {
1:                     assertTrue(e instanceof TransactionRolledBackException);
1:                     LOG.info("got commit exception: ", e);
1:                 }
1:                 commitDoneLatch.countDown();
1:                 LOG.info("done async commit");
1:             }
1:         });
1: 
1:         // will be stopped by the plugin
1:         broker.waitUntilStopped();
1:         broker = createBroker(false, url);
1:         setDefaultPersistenceAdapter(broker);
1:         broker.setPlugins(new BrokerPlugin[]{new DestinationPathSeparatorBroker()});
1:         broker.start();
1: 
1:         assertTrue("tx committed trough failover", commitDoneLatch.await(30, TimeUnit.SECONDS));
1: 
1:         // new transaction
1:         Message msg = consumer.receive(20000);
1:         LOG.info("Received: " + msg);
1:         assertNotNull("we got the message", msg);
1:         assertNull("we got just one message", consumer.receive(2000));
1:         session.commit();
1:         consumer.close();
1:         connection.close();
1: 
1:         // ensure no dangling messages with fresh broker etc
1:         broker.stop();
1:         broker.waitUntilStopped();
1: 
1:         LOG.info("Checking for remaining/hung messages..");
1:         broker = createBroker(false, url);
1:         setDefaultPersistenceAdapter(broker);
1:         broker.setPlugins(new BrokerPlugin[]{new DestinationPathSeparatorBroker()});
1:         broker.start();
1: 
1:         // after restart, ensure no dangling messages
1:         cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:         configureConnectionFactory(cf);
1:         connection = cf.createConnection();
1:         connection.start();
1:         Session session2 = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         consumer = session2.createConsumer(destination);
1:         msg = consumer.receive(1000);
1:         if (msg == null) {
0:             msg = consumer.receive(5000);
1:         }
1:         LOG.info("Received: " + msg);
1:         assertNull("no messges left dangling but got: " + msg, msg);
1:         connection.close();
1: 
1:         ActiveMQDestination[] destinations = broker.getRegionBroker().getDestinations();
1:         for (ActiveMQDestination dest : destinations) {
1:             LOG.info("Destinations list: " + dest);
1:         }
1:         assertEquals("Only one destination", 1, broker.getRegionBroker().getDestinations().length);
1:     }
1: 
commit:2030097
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.ActiveMQConnection;
/////////////////////////////////////////////////////////////////////////
1:     public void configureConnectionFactory(ActiveMQConnectionFactory factory) {
1:         // nothing to do
1:     }
1: 
1:         configureConnectionFactory(cf);
/////////////////////////////////////////////////////////////////////////
1:         configureConnectionFactory(cf);
/////////////////////////////////////////////////////////////////////////
1:         configureConnectionFactory(cf);
/////////////////////////////////////////////////////////////////////////
1:         configureConnectionFactory(cf);
/////////////////////////////////////////////////////////////////////////
1:         configureConnectionFactory(cf);
/////////////////////////////////////////////////////////////////////////
1:         configureConnectionFactory(cf);
/////////////////////////////////////////////////////////////////////////
1:         configureConnectionFactory(cf);
/////////////////////////////////////////////////////////////////////////
1:         configureConnectionFactory(cf);
/////////////////////////////////////////////////////////////////////////
1:         configureConnectionFactory(cf);
/////////////////////////////////////////////////////////////////////////
1:         configureConnectionFactory(cf);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.info("Iteration: " + i);
/////////////////////////////////////////////////////////////////////////
1:         configureConnectionFactory(cf);
/////////////////////////////////////////////////////////////////////////
1:         configureConnectionFactory(cf);
/////////////////////////////////////////////////////////////////////////
1:         configureConnectionFactory(cf);
/////////////////////////////////////////////////////////////////////////
1:         configureConnectionFactory(cf);
/////////////////////////////////////////////////////////////////////////
1:         configureConnectionFactory(cf);
commit:6d444d5
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("defaultPersistenceAdapter",
0:                 new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.AMQ, PersistenceAdapterChoice.JDBC});
commit:80528f6
/////////////////////////////////////////////////////////////////////////
1:     public void setUp() throws Exception {
0:         super.setMaxTestTime(20 * 60 * 1000); // some boxes can be real slow
1:         super.setAutoFail(true);
1:         super.setUp();
1:     }
1: 
commit:fafaf7d
/////////////////////////////////////////////////////////////////////////
0:         LOG.info("testPoisonOnDeliveryWhilePending()");
/////////////////////////////////////////////////////////////////////////
1:         // add another consumer into the mix that may get the message after restart
0:         MessageConsumer consumer2 = consumerSession.createConsumer(consumerSession.createQueue(QUEUE_NAME + "?consumer.prefetchSize=1"));
1: 
1:         final Vector<Exception> exceptions = new Vector<Exception>();
0:         // commit may fail if other consumer gets the message on restart, it will be seen a a duplicate on teh connection
0:         // but with no transaciton and it pending on another consumer it will be posion
1:                 } catch (JMSException ex) {
1:                     exceptions.add(ex);                    
1:                 } finally {
0:         assertNull("consumer2 not get a message while pending to 1 or consumed by 1", consumer2.receive(2000));
1:         assertTrue("commit completed ", commitDone.await(15, TimeUnit.SECONDS));
0:         // either message consumed or sent to dlq via poison on redelivery to wrong consumer
0:         // message should not be available again in any event
0:         assertNull("consumer should not get rolledback on non redelivered message or duplicate", consumer.receive(5000));
1:         // consumer replay is hashmap order dependent on a failover connection state recover so need to deal with both cases
0:         if (exceptions.isEmpty()) {
0:             // commit succeeded, message was redelivered to the correct consumer after restart so commit was fine
1:         } else {
0:             // message should be in dlq
0:             MessageConsumer dlqConsumer = consumerSession.createConsumer(consumerSession.createQueue("ActiveMQ.DLQ"));
0:             TextMessage dlqMessage = (TextMessage) dlqConsumer.receive(5000);
0:             assertNotNull("found message in dlq", dlqMessage);
0:             assertEquals("text matches", "Test message", dlqMessage.getText());
1:             consumerSession.commit();
1:         }
commit:f206a1b
/////////////////////////////////////////////////////////////////////////
1: import junit.framework.Test;
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.AutoFailTestSupport;
1: import org.apache.activemq.TestSupport;
1: import org.apache.activemq.broker.BrokerPlugin;
1: import org.apache.activemq.broker.BrokerPluginSupport;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.broker.ConsumerBrokerExchange;
1: import org.apache.activemq.broker.ProducerBrokerExchange;
1: import org.apache.activemq.broker.region.RegionBroker;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.TransactionId;
1: import org.apache.activemq.store.PersistenceAdapter;
1: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1: import org.apache.activemq.util.SocketProxy;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
/////////////////////////////////////////////////////////////////////////
1: import java.net.URI;
1: import java.util.Vector;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: 
1: public class FailoverTransactionTest extends TestSupport {
1: 
0:     private static final String QUEUE_NAME = "FailoverWithTx";
0:     private String url = "tcp://localhost:61616";
1:     BrokerService broker;
1: 
1:     public static Test suite() {
1:         return suite(FailoverTransactionTest.class);
1:     }
1: 
0:     public void startCleanBroker() throws Exception {
1:         startBroker(true);
1:     }
1: 
1:     public void tearDown() throws Exception {
1:         stopBroker();
1:     }
1: 
1:     public void stopBroker() throws Exception {
1:         if (broker != null) {
1:             broker.stop();
1:         }
1:     }
1: 
1:     public void startBroker(boolean deleteAllMessagesOnStartup) throws Exception {
1:         broker = createBroker(deleteAllMessagesOnStartup);
1:     }
1:     public BrokerService createBroker(boolean deleteAllMessagesOnStartup) throws Exception {
1:         broker = new BrokerService();
1:         broker.setUseJmx(false);
1:         broker.setAdvisorySupport(false);
0:         broker.addConnector(url);
1:         broker.setDeleteAllMessagesOnStartup(deleteAllMessagesOnStartup);
1:         return broker;
1:     }
1:     public void testFailoverProducerCloseBeforeTransaction() throws Exception {
1:         startCleanBroker();
1:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:         Connection connection = cf.createConnection();
1:         connection.start();
1:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:         Queue destination = session.createQueue(QUEUE_NAME);
1:         produceMessage(session, destination);
1:         // restart to force failover and connection state recovery before the commit
1:         broker.stop();
0:         startBroker(false);
1: 
1:         session.commit();
1:         assertNotNull("we got the message", consumer.receive(20000));
1:         session.commit();
1:         connection.close();
1: 
1:     public void initCombosForTestFailoverCommitReplyLost() {
0:         addCombinationValues("defaultPersistenceAdapter", PersistenceAdapterChoice.values());
1: 
1:     public void testFailoverCommitReplyLost() throws Exception {
1: 
1:         setDefaultPersistenceAdapter(broker);
1: 
1:         broker.setPlugins(new BrokerPlugin[]{
1:                                                   TransactionId xid, boolean onePhase) throws Exception {
1:                         Executors.newSingleThreadExecutor().execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
1:                     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         Executors.newSingleThreadExecutor().execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
1: 
1:         setDefaultPersistenceAdapter(broker);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         setDefaultPersistenceAdapter(broker);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void initCombosForTestFailoverSendReplyLost() {
1:         addCombinationValues("defaultPersistenceAdapter",
0:                 new Object[]{PersistenceAdapterChoice.KahaDB,
1:                         PersistenceAdapterChoice.JDBC
0:                         // not implemented for AMQ store
1:                 });
1: 
1:     public void testFailoverSendReplyLost() throws Exception {
1: 
1:         setDefaultPersistenceAdapter(broker);
1: 
1:         broker.setPlugins(new BrokerPlugin[]{
1:                                      org.apache.activemq.command.Message messageSend)
1:                         Executors.newSingleThreadExecutor().execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         Executors.newSingleThreadExecutor().execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
1: 
1:         setDefaultPersistenceAdapter(broker);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         assertEquals("no newly queued messages", 0, ((RegionBroker) broker.getRegionBroker()).getDestinationStatistics().getEnqueues().getCount());
1:         assertEquals("1 dequeue", 1, ((RegionBroker) broker.getRegionBroker()).getDestinationStatistics().getDequeues().getCount());
1: 
1: 
1:         setDefaultPersistenceAdapter(broker);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void initCombosForTestFailoverConnectionSendReplyLost() {
0:         addCombinationValues("defaultPersistenceAdapter",
0:                 new Object[]{PersistenceAdapterChoice.KahaDB,
1:                         PersistenceAdapterChoice.JDBC
1:                         // last producer message id store feature not implemented for AMQ store
1:                 });
1: 
1:     public void testFailoverConnectionSendReplyLost() throws Exception {
1: 
1:         PersistenceAdapter store = setDefaultPersistenceAdapter(broker);
1:         if (store instanceof KahaDBPersistenceAdapter) {
1:             // duplicate checker not updated on canceled tasks, even it
1:             // it was, recovery of the audit would fail as the message is
1:             // not recorded in the store and the audit may not be up to date.
1:             // So if duplicate messages are a absolute no no after restarts,
1:             // ConcurrentStoreAndDispatchQueues must be disabled
1:             ((KahaDBPersistenceAdapter) store).setConcurrentStoreAndDispatchQueues(false);
1:         }
1: 
1:         broker.setPlugins(new BrokerPlugin[]{
1:                                      org.apache.activemq.command.Message messageSend)
1: 
1:                             Executors.newSingleThreadExecutor().execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
1:                                 }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:         Executors.newSingleThreadExecutor().execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1:         assertEquals("one queued message", 1, ((RegionBroker) broker.getRegionBroker()).getDestinationStatistics().getEnqueues().getCount());
1: 
1: 
1:         setDefaultPersistenceAdapter(broker);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void testFailoverProducerCloseBeforeTransactionFailWhenDisabled() throws Exception {
1:         startCleanBroker();
1:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")?trackTransactionProducers=false");
1:         Connection connection = cf.createConnection();
1:         connection.start();
1:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:         Queue destination = session.createQueue(QUEUE_NAME);
1: 
1:         MessageConsumer consumer = session.createConsumer(destination);
1:         produceMessage(session, destination);
1: 
1:         // restart to force failover and connection state recovery before the commit
1:         broker.stop();
0:         startBroker(false);
1: 
1:         session.commit();
1: 
1:         // without tracking producers, message will not be replayed on recovery
1:         assertNull("we got the message", consumer.receive(5000));
1:         session.commit();
1:         connection.close();
1:     public void testFailoverMultipleProducerCloseBeforeTransaction() throws Exception {
1:         startCleanBroker();
1:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:         Queue destination = session.createQueue(QUEUE_NAME);
1: 
1:         MessageConsumer consumer = session.createConsumer(destination);
1:         MessageProducer producer;
1:         TextMessage message;
1:         final int count = 10;
1:         for (int i = 0; i < count; i++) {
1:             producer = session.createProducer(destination);
1:             message = session.createTextMessage("Test message: " + count);
1:             producer.send(message);
1:             producer.close();
1:         }
1: 
1:         // restart to force failover and connection state recovery before the commit
1:         broker.stop();
0:         startBroker(false);
1: 
1:         session.commit();
1:         for (int i = 0; i < count; i++) {
1:             assertNotNull("we got all the message: " + count, consumer.receive(20000));
1:         }
1:         session.commit();
1:         connection.close();
1:     }
1: 
1:     // https://issues.apache.org/activemq/browse/AMQ-2772
1:     public void testFailoverWithConnectionConsumer() throws Exception {
1:         startCleanBroker();
1:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:         Connection connection = cf.createConnection();
1:         connection.start();
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < count; i++) {
1:             producer = session.createProducer(destination);
1: 
1: 
1:         for (int i = 0; i < count - 1; i++) {
1: 
1: 
1:         for (int i = 0; i < 3; i++) {
/////////////////////////////////////////////////////////////////////////
1: 
1:         setDefaultPersistenceAdapter(broker);
1: 
1:         broker.setPlugins(new BrokerPlugin[]{
/////////////////////////////////////////////////////////////////////////
1: 
1:                         Executors.newSingleThreadExecutor().execute(new Runnable() {
1:                                 LOG.info("Stopping broker on ack: " + ack);
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1:         Executors.newSingleThreadExecutor().execute(new Runnable() {
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         setDefaultPersistenceAdapter(broker);
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         for (Connection c : connections) {
1: 
1: 
1:         setDefaultPersistenceAdapter(broker);
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1:         setPersistenceAdapter(broker, PersistenceAdapterChoice.JDBC);
1: 
1: 
1:         broker.stop();
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         setPersistenceAdapter(broker, PersistenceAdapterChoice.JDBC);
1:         Executors.newSingleThreadExecutor().execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
1: 
1:         broker.stop();
1: 
1:         assertTrue("commit was successful", commitDone.await(30, TimeUnit.SECONDS));
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         broker.stop();
1: 
1:         Executors.newSingleThreadExecutor().execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1:         MessageProducer producer = producerSession.createProducer(destination);
1: 
commit:a6a6a70
/////////////////////////////////////////////////////////////////////////
0: import java.net.URI;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.ProducerBrokerExchange;
0: import org.apache.activemq.broker.region.RegionBroker;
0: import org.apache.activemq.store.amq.AMQPersistenceAdapter;
0: import org.apache.activemq.util.SocketProxy;
/////////////////////////////////////////////////////////////////////////
0: 	    broker.setAdvisorySupport(false);
/////////////////////////////////////////////////////////////////////////
0:     public void testFailoverCommitReplyLostAMQ() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     
0:     //@Test not implemented
0:     public void testFailoverSendReplyLostAMQ() throws Exception {
0:         doTestFailoverSendReplyLost(0);
1:     }  
1:     
0:     @Test
0:     public void testFailoverSendReplyLostJdbc() throws Exception {
0:         doTestFailoverSendReplyLost(1);
1:     }
1:     
0:     @Test
0:     public void testFailoverSendReplyLostKahaDB() throws Exception {
0:         doTestFailoverSendReplyLost(2);
1:     }
1:     
0:     public void doTestFailoverSendReplyLost(final int adapter) throws Exception {
1:         
1:         broker = createBroker(true);
0:         setPersistenceAdapter(adapter);
1:             
0:         broker.setPlugins(new BrokerPlugin[] {
1:                 new BrokerPluginSupport() {
1:                     @Override
1:                     public void send(ProducerBrokerExchange producerExchange,
0:                             org.apache.activemq.command.Message messageSend)
1:                             throws Exception {
1:                         // so send will hang as if reply is lost
1:                         super.send(producerExchange, messageSend);
1:                         producerExchange.getConnectionContext().setDontSendReponse(true);
0:                         Executors.newSingleThreadExecutor().execute(new Runnable() {   
1:                             public void run() {
1:                                 LOG.info("Stopping broker post send...");
1:                                 try {
1:                                     broker.stop();
1:                                 } catch (Exception e) {
1:                                     e.printStackTrace();
1:                                 }
1:                             }
1:                         });
1:                     }
1:                 }
1:         });
1:         broker.start();
1:         
1:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")?jms.watchTopicAdvisories=false");
1:         Connection connection = cf.createConnection();
1:         connection.start();
1:         final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         final Queue destination = session.createQueue(QUEUE_NAME);
1: 
1:         MessageConsumer consumer = session.createConsumer(destination);
1:         final CountDownLatch sendDoneLatch = new CountDownLatch(1);
1:         // broker will die on send reply so this will hang till restart
0:         Executors.newSingleThreadExecutor().execute(new Runnable() {   
1:             public void run() {
1:                 LOG.info("doing async send...");
1:                 try {
1:                     produceMessage(session, destination);
1:                 } catch (JMSException e) {
1:                     //assertTrue(e instanceof TransactionRolledBackException);
1:                     LOG.error("got send exception: ", e);
1:                     fail("got unexpected send exception" + e);
1:                 }
1:                 sendDoneLatch.countDown();
1:                 LOG.info("done async send");
1:             }
1:         });
1:        
1:         // will be stopped by the plugin
1:         broker.waitUntilStopped();
0:         broker = createBroker(false);
0:         setPersistenceAdapter(adapter);
1:         LOG.info("restarting....");
1:         broker.start();
1: 
1:         assertTrue("message sent through failover", sendDoneLatch.await(30, TimeUnit.SECONDS));
1:         
1:         // new transaction
1:         Message msg = consumer.receive(20000);
1:         LOG.info("Received: " + msg);
1:         assertNotNull("we got the message", msg);
1:         assertNull("we got just one message", consumer.receive(2000));
1:         consumer.close();
1:         connection.close();
1:         
1:         // verify stats
0:         assertEquals("no newly queued messages", 0, ((RegionBroker)broker.getRegionBroker()).getDestinationStatistics().getEnqueues().getCount());
0:         assertEquals("1 dequeue", 1, ((RegionBroker)broker.getRegionBroker()).getDestinationStatistics().getDequeues().getCount());
1:         
1:         // ensure no dangling messages with fresh broker etc
1:         broker.stop();
1:         broker.waitUntilStopped();
1:         
1:         LOG.info("Checking for remaining/hung messages with second restart..");
0:         broker = createBroker(false);
0:         setPersistenceAdapter(adapter);
1:         broker.start();
1:         
1:         // after restart, ensure no dangling messages
1:         cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:         connection = cf.createConnection();
1:         connection.start();
1:         Session session2 = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         consumer = session2.createConsumer(destination);
1:         msg = consumer.receive(1000);
1:         if (msg == null) {
0:             msg = consumer.receive(5000);
1:         }
1:         LOG.info("Received: " + msg);
1:         assertNull("no messges left dangling but got: " + msg, msg);
1:         connection.close();
1:     }
1: 
0:     // not implemented.. @Test
0:     public void testFailoverConnectionSendReplyLostAMQ() throws Exception {
0:         doTestFailoverConnectionSendReplyLost(0);
1:     }  
1:     
0:     @Test
0:     public void testFailoverConnectionSendReplyLostJdbc() throws Exception {
0:         doTestFailoverConnectionSendReplyLost(1);
1:     }
1:     
0:     @Test
0:     public void testFailoverConnectionSendReplyLostKahaDB() throws Exception {
0:         doTestFailoverConnectionSendReplyLost(2);
1:     }
1:     
0:     public void doTestFailoverConnectionSendReplyLost(final int adapter) throws Exception {
1:         
1:         broker = createBroker(true);
0:         setPersistenceAdapter(adapter);
1:         
1:         final SocketProxy proxy = new SocketProxy();
1: 
0:         broker.setPlugins(new BrokerPlugin[] {
1:                 new BrokerPluginSupport() {
1:                     private boolean firstSend = true;
1: 
1:                     @Override
1:                     public void send(ProducerBrokerExchange producerExchange,
0:                             org.apache.activemq.command.Message messageSend)
1:                             throws Exception {
1:                         // so send will hang as if reply is lost
1:                         super.send(producerExchange, messageSend);
1:                         if (firstSend) {
1:                             firstSend = false;
1:                         
1:                             producerExchange.getConnectionContext().setDontSendReponse(true);
0:                             Executors.newSingleThreadExecutor().execute(new Runnable() {   
1:                                 public void run() {
1:                                     LOG.info("Stopping connection post send...");
1:                                     try {
1:                                         proxy.close();
1:                                     } catch (Exception e) {
1:                                         e.printStackTrace();
1:                                     }
1:                                 }   
1:                             });
1:                         }
1:                     }
1:                 }
1:         });
1:         broker.start();
1:         
1:         proxy.setTarget(new URI(url));
1:         proxy.open();
1:         
1:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + proxy.getUrl().toASCIIString() + ")?jms.watchTopicAdvisories=false");
1:         Connection connection = cf.createConnection();
1:         connection.start();
1:         final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         final Queue destination = session.createQueue(QUEUE_NAME);
1: 
1:         MessageConsumer consumer = session.createConsumer(destination);
1:         final CountDownLatch sendDoneLatch = new CountDownLatch(1);
1:         // proxy connection will die on send reply so this will hang on failover reconnect till open
0:         Executors.newSingleThreadExecutor().execute(new Runnable() {   
1:             public void run() {
1:                 LOG.info("doing async send...");
1:                 try {
1:                     produceMessage(session, destination);
1:                 } catch (JMSException e) {
1:                     //assertTrue(e instanceof TransactionRolledBackException);
1:                     LOG.info("got send exception: ", e);
1:                 }
1:                 sendDoneLatch.countDown();
1:                 LOG.info("done async send");
1:             }
1:         });
1:        
1:         // will be closed by the plugin
1:         assertTrue("proxy was closed", proxy.waitUntilClosed(30));
1:         LOG.info("restarting proxy");
1:         proxy.open();
1: 
1:         assertTrue("message sent through failover", sendDoneLatch.await(30, TimeUnit.SECONDS));
1:         
1:         Message msg = consumer.receive(20000);
1:         LOG.info("Received: " + msg);
1:         assertNotNull("we got the message", msg);
1:         assertNull("we got just one message", consumer.receive(2000));
1:         consumer.close();
1:         connection.close();
1:         
1:         // verify stats, connection dup suppression means dups don't get to broker
0:         assertEquals("one queued message", 1, ((RegionBroker)broker.getRegionBroker()).getDestinationStatistics().getEnqueues().getCount());
1:         
1:         // ensure no dangling messages with fresh broker etc
1:         broker.stop();
1:         broker.waitUntilStopped();
1:         
1:         LOG.info("Checking for remaining/hung messages with restart..");
0:         broker = createBroker(false);
0:         setPersistenceAdapter(adapter);
1:         broker.start();
1:         
1:         // after restart, ensure no dangling messages
1:         cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:         connection = cf.createConnection();
1:         connection.start();
1:         Session session2 = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         consumer = session2.createConsumer(destination);
1:         msg = consumer.receive(1000);
1:         if (msg == null) {
0:             msg = consumer.receive(5000);
1:         }
1:         LOG.info("Received: " + msg);
1:         assertNull("no messges left dangling but got: " + msg, msg);
1:         connection.close();
1:     }
1:     
1:     
1:     
0:             broker.setPersistenceAdapter(new AMQPersistenceAdapter());
0:             // duplicate checker not updated on canceled tasks, even it
0:             // it was, reovery of the audit would fail as the message is
0:             // not recorded in the store and the audit may not be up to date.
0:             // So if duplicate are a nono (w.r.t stats), this must be disabled
0:             store.setConcurrentStoreAndDispatchQueues(false);
0:             store.setMaxFailoverProducersToTrack(10);
commit:e771b88
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.ServerSession;
1: import javax.jms.ServerSessionPool;
/////////////////////////////////////////////////////////////////////////
0: 	
0:     @Test
0:     // https://issues.apache.org/activemq/browse/AMQ-2772
0:     public void testFailoverWithConnectionConsumer() throws Exception {
0:         startCleanBroker();         
1:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:         Connection connection = cf.createConnection();
1:         connection.start();
0:         
1:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:         Queue destination = session.createQueue(QUEUE_NAME);
0: 
1:         final CountDownLatch connectionConsumerGotOne = new CountDownLatch(1);
1:         final Session poolSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         connection.createConnectionConsumer(destination, null, new ServerSessionPool() {
1:             public ServerSession getServerSession() throws JMSException {
1:                 return new ServerSession() {
1:                     public Session getSession() throws JMSException {
1:                         return poolSession;
1:                     }
1:                     public void start() throws JMSException {
1:                         connectionConsumerGotOne.countDown();
1:                         poolSession.run();
1:                     }
1:                 };
1:             }
1:         }, 1);
0: 
1:         MessageConsumer consumer = session.createConsumer(destination);
1:         MessageProducer producer;
1:         TextMessage message;
1:         final int count = 10;
0:         for (int i=0; i<count; i++) {
0:             producer = session.createProducer(destination);         
1:             message = session.createTextMessage("Test message: " + count);
1:             producer.send(message);
1:             producer.close();
1:         }
0:         
1:         // restart to force failover and connection state recovery before the commit
1:         broker.stop();
0:         startBroker(false);
0:         
1:         session.commit();
0:         for (int i=0; i<count-1; i++) {
0:             assertNotNull("we got all the message: " + count, consumer.receive(20000));
1:         }
1:         session.commit();
1:         connection.close();
0:         
0:         assertTrue("connectionconsumer got a message", connectionConsumerGotOne.await(10, TimeUnit.SECONDS));
1:     }
0: 	
commit:39d0717
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertEquals;
0: import static org.junit.Assert.fail;
/////////////////////////////////////////////////////////////////////////
1:         // as failure depends on hash order of state tracker recovery, do a few times
0:         for (int i=0; i<3; i++) {
/////////////////////////////////////////////////////////////////////////
1:         // use empty jdbc store so that default wait(0) for redeliveries will timeout after failover
1:             fail("expected transaciton rolledback ex");
1:         } catch (TransactionRolledBackException expected) {
/////////////////////////////////////////////////////////////////////////
0:     
0:     @Test
0:     public void testPoisonOnDeliveryWhilePending() throws Exception {
1:         LOG.info("testWaitForMissingRedeliveries()");
1:         broker = createBroker(true);
1:         broker.start();
1:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")?jms.consumerFailoverRedeliveryWaitPeriod=10000");
1:         Connection connection = cf.createConnection();
1:         connection.start();
1:         final Session producerSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         final Queue destination = producerSession.createQueue(QUEUE_NAME + "?consumer.prefetchSize=0");
1:         final Session consumerSession = connection.createSession(true, Session.SESSION_TRANSACTED);
1:         MessageConsumer consumer = consumerSession.createConsumer(destination);
0:         
1:         produceMessage(producerSession, destination);
1:         Message msg = consumer.receive(20000);
0:         if (msg == null) {
1:             AutoFailTestSupport.dumpAllThreads("missing-");
1:         }
1:         assertNotNull("got message just produced", msg);
0:         
1:         broker.stop(); 
0:         broker = createBroker(false);
1:         broker.start();
0: 
1:         final CountDownLatch commitDone = new CountDownLatch(1);
0:         
0: 
0:         // with prefetch=0, it will not get redelivered as there will not be another receive
0:         // for this consumer. so it will block till it timeout with an exception
1:         // will block pending re-deliveries
0:         Executors.newSingleThreadExecutor().execute(new Runnable() {   
1:             public void run() {
1:                 LOG.info("doing async commit...");
1:                 try {
1:                     consumerSession.commit();
1:                 } catch (JMSException ignored) {
1:                     commitDone.countDown();
1:                 }
1:             }
1:         });
0:         
0:         // pull the pending message to this consumer where it will be poison as it is a duplicate without a tx
0:         MessageConsumer consumer2 = consumerSession.createConsumer(consumerSession.createQueue(QUEUE_NAME + "?consumer.prefetchSize=1"));
0:         assertNull("consumer2 not get a message while pending to 1", consumer2.receive(2000));
0:         
0:         assertTrue("commit completed with ex", commitDone.await(15, TimeUnit.SECONDS));
0:         assertNull("consumer should not get rolledback and non redelivered message", consumer.receive(5000));
0:         
0:         // message should be in dlq
0:         MessageConsumer dlqConsumer = consumerSession.createConsumer(consumerSession.createQueue("ActiveMQ.DLQ"));
0:         TextMessage dlqMessage = (TextMessage) dlqConsumer.receive(5000);
0:         assertNotNull("found message in dlq", dlqMessage);
0:         assertEquals("text matches", "Test message", dlqMessage.getText());
1:         consumerSession.commit();
0:         
1:         connection.close();
1:     }
0: 
commit:b836af8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.AutoFailTestSupport;
/////////////////////////////////////////////////////////////////////////
1: // https://issues.apache.org/activemq/browse/AMQ-2590
/////////////////////////////////////////////////////////////////////////
1:                 } catch (JMSException e) {
1:                     assertTrue(e instanceof TransactionRolledBackException);
1:                     LOG.info("got commit exception: ", e);
1:                 commitDoneLatch.countDown();
1:                 LOG.info("done async commit");
/////////////////////////////////////////////////////////////////////////
0: 		
/////////////////////////////////////////////////////////////////////////
0:     @Test
1:     public void testAutoRollbackWithMissingRedeliveries() throws Exception {
1:         broker = createBroker(true);
1:         broker.start();
1:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:         Connection connection = cf.createConnection();
1:         connection.start();
1:         final Session producerSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         final Queue destination = producerSession.createQueue(QUEUE_NAME + "?consumer.prefetchSize=1");
1:         final Session consumerSession = connection.createSession(true, Session.SESSION_TRANSACTED);
1:         MessageConsumer consumer = consumerSession.createConsumer(destination);
0:         
1:         produceMessage(producerSession, destination);
0:         
1:         Message msg = consumer.receive(20000);
1:         assertNotNull(msg);
0:         
1:         broker.stop();
0:         broker = createBroker(false);
0:         // use empty jdbc store so that default wait for redeliveries will timeout after failover
0:         setPersistenceAdapter(1);
1:         broker.start();
0:         
1:         try {
0:             consumerSession.commit();
0:         } catch (JMSException expectedRolledback) {
0:             assertTrue(expectedRolledback instanceof TransactionRolledBackException);
1:         }
0:         
1:         broker.stop(); 
0:         broker = createBroker(false);
1:         broker.start();
0:         
1:         assertNotNull("should get rolledback message from original restarted broker", consumer.receive(20000));
1:         connection.close();
1:     }
0: 
0:  
0:     @Test
1:     public void testWaitForMissingRedeliveries() throws Exception {
0:         LOG.info("testWaitForMissingRedeliveries()");
1:         broker = createBroker(true);
1:         broker.start();
1:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")?jms.consumerFailoverRedeliveryWaitPeriod=30000");
1:         Connection connection = cf.createConnection();
1:         connection.start();
1:         final Session producerSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         final Queue destination = producerSession.createQueue(QUEUE_NAME);
1:         final Session consumerSession = connection.createSession(true, Session.SESSION_TRANSACTED);
1:         MessageConsumer consumer = consumerSession.createConsumer(destination);
0:         
1:         produceMessage(producerSession, destination);
1:         Message msg = consumer.receive(20000);
0:         if (msg == null) {
1:             AutoFailTestSupport.dumpAllThreads("missing-");
1:         }
1:         assertNotNull("got message just produced", msg);
0:         
1:         broker.stop();
0:         broker = createBroker(false);
1:         // use empty jdbc store so that wait for re-deliveries occur when failover resumes
0:         setPersistenceAdapter(1);
1:         broker.start();
0: 
1:         final CountDownLatch commitDone = new CountDownLatch(1);
0:         // will block pending re-deliveries
0:         Executors.newSingleThreadExecutor().execute(new Runnable() {   
1:             public void run() {
1:                 LOG.info("doing async commit...");
1:                 try {
0:                     consumerSession.commit();
0:                     commitDone.countDown();
0:                 } catch (JMSException ignored) {
1:                 }
1:             }
1:         });
0:         
1:         broker.stop(); 
0:         broker = createBroker(false);
1:         broker.start();
0:         
0:         assertTrue("commit was successfull", commitDone.await(30, TimeUnit.SECONDS));
0:         
0:         assertNull("should not get committed message", consumer.receive(5000));
1:         connection.close();
1:     }
0: 
commit:c32820d
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
0:         for (int i=0; i<4; i++) {
1:                 doTestFailoverConsumerAckLost(i);
1:     public void doTestFailoverConsumerAckLost(final int pauseSeconds) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         final AtomicBoolean gotTransactionRolledBackException = new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
1:                     // give some variance to the runs
0:                     TimeUnit.SECONDS.sleep(pauseSeconds * 2);
1:                     // and prefetch=1, but with failover and unordered connection restore it can get the second
1:                     // message.
0:                     
1:                     // For the transaction to complete it needs to get the same one or two messages
1:                     // again so that the acks line up.
1:                     // If redelivery order is different, the commit should fail with an ex
1:                     //
/////////////////////////////////////////////////////////////////////////
0:                         LOG.info("got exception ex on commit", expectedSometimes);
0:                         if (expectedSometimes instanceof TransactionRolledBackException) {
0:                             gotTransactionRolledBackException.set(true);
/////////////////////////////////////////////////////////////////////////
0:         Message msg = consumer1.receive(gotTransactionRolledBackException.get() ? 5000 : 20000);
0:         if (gotTransactionRolledBackException.get()) {
0:         } else {
0:             assertNull("should be nothing left for consumer as recieve should have committed", msg);
0:         if (gotTransactionRolledBackException.get() ||
0:                 !gotTransactionRolledBackException.get() && receivedMessages.size() == 1) {
0:             // just one message successfully consumed or none consumed
0:             // consumer2 should get other message
0:             msg = consumer2.receive(10000);
0:             LOG.info("post: from consumer2 received: " + msg);
0:             assertNotNull("got second message on consumer2", msg);
0:             consumerSession2.commit();
1:         }
commit:62daac4
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.TransactionRolledBackException;
/////////////////////////////////////////////////////////////////////////
0:                     // message which could create a problem for a pending ack and also invalidate
0:                     // the transaction in which the first was consumed and acked
/////////////////////////////////////////////////////////////////////////
1:                     try {
1:                         consumerSession1.commit();
0:                     } catch (JMSException expectedSometimes) {
0:                         LOG.info("got rollback ex on commit", expectedSometimes);
0:                         if (expectedSometimes instanceof TransactionRolledBackException && receivedMessages.size() == 2) {
0:                             // ok, message one was not replayed so we expect the rollback
0:                         } else {
0:                             throw expectedSometimes;
1:                         }
0:                         
1:                     }
/////////////////////////////////////////////////////////////////////////
0:         // getting 2 is indicative of orderiing issue. a problem if dangling message found after restart
0:         if (receivedMessages.size() == 1) {
0:             assertNull("should be nothing left for consumer as recieve should have committed", msg);
0:         } else {
0:             assertNotNull("should be available again after commit rollback ex", msg);
1:         }
0:         // consumer2 should get other message
0:         assertNotNull("got second message on consumer2", msg);
commit:862cd71
/////////////////////////////////////////////////////////////////////////
0:         for (int i=0; i<3; i++) {
commit:80f7e38
/////////////////////////////////////////////////////////////////////////
0:                     // but with failover and unordered connection restore it can get the second
0:                     // message which could create a problem for a pending ack
/////////////////////////////////////////////////////////////////////////
0:         // consumer2 should get other message provided consumer1 did not get 2
0:         if (receivedMessages.size() == 1) {
0:             assertNotNull("got second message on consumer2", msg);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("Sweep received: " + msg);
commit:0bc545b
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertEquals;
0: import java.util.Vector;
1: import javax.jms.JMSException;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.ConsumerBrokerExchange;
0: import org.apache.activemq.command.MessageAck;
/////////////////////////////////////////////////////////////////////////
0: 	private static final String QUEUE_NAME = "FailoverWithTx";
/////////////////////////////////////////////////////////////////////////
0: 	@Test
/////////////////////////////////////////////////////////////////////////
1: 		produceMessage(session, destination);
/////////////////////////////////////////////////////////////////////////
0:         produceMessage(session, destination);
/////////////////////////////////////////////////////////////////////////
0: 	    produceMessage(session, destination);
/////////////////////////////////////////////////////////////////////////
0: 	
0: 	@Test
0: 	public void testFailoverConsumerCommitLost() throws Exception {
0: 	    final int adapter = 0;
1: 	    broker = createBroker(true);
0: 	    setPersistenceAdapter(adapter);
0: 
0: 	    broker.setPlugins(new BrokerPlugin[] {
1: 	            new BrokerPluginSupport() {
0: 
1: 	                @Override
1: 	                public void commitTransaction(ConnectionContext context,
0: 	                        TransactionId xid, boolean onePhase) throws Exception {
1: 	                    super.commitTransaction(context, xid, onePhase);
1: 	                    // so commit will hang as if reply is lost
1: 	                    context.setDontSendReponse(true);
0: 	                    Executors.newSingleThreadExecutor().execute(new Runnable() {   
1: 	                        public void run() {
1: 	                            LOG.info("Stopping broker post commit...");
1: 	                            try {
1: 	                                broker.stop();
1: 	                            } catch (Exception e) {
1: 	                                e.printStackTrace();
1: 	                            }
1: 	                        }
1: 	                    });
1: 	                }   
1: 	            }
1: 	    });
1: 	    broker.start();
0: 
1: 	    ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1: 	    Connection connection = cf.createConnection();
1: 	    connection.start();
1: 	    final Session producerSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 	    final Session consumerSession = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
0: 	    Queue destination = producerSession.createQueue(QUEUE_NAME);
0: 
0: 	    final MessageConsumer consumer = consumerSession.createConsumer(destination);
0: 
1: 	    produceMessage(producerSession, destination);
0: 
1: 	    final Vector<Message> receivedMessages = new Vector<Message>();
1: 	    final CountDownLatch commitDoneLatch = new CountDownLatch(1);  
0: 	    Executors.newSingleThreadExecutor().execute(new Runnable() {   
1: 	        public void run() {
1: 	            LOG.info("doing async commit after consume...");
1: 	            try {
1: 	                Message msg = consumer.receive(20000);
0: 	                LOG.info("Got message: " + msg);
1: 	                receivedMessages.add(msg);
0: 	                consumerSession.commit();
1: 	                commitDoneLatch.countDown();
1: 	                LOG.info("done async commit");
1: 	            } catch (Exception e) {
1: 	                e.printStackTrace();
1: 	            }
1: 	        }
1: 	    });
0: 
0: 
1: 	    // will be stopped by the plugin
1: 	    broker.waitUntilStopped();
0: 	    broker = createBroker(false);
0: 	    setPersistenceAdapter(adapter);
1: 	    broker.start();
0: 
0: 	    assertTrue("tx committed trough failover", commitDoneLatch.await(30, TimeUnit.SECONDS));
0: 
0: 	    assertEquals("we got a message", 1, receivedMessages.size());
0: 
1: 	    // new transaction
1: 	    Message msg = consumer.receive(20000);
1: 	    LOG.info("Received: " + msg);
0: 	    assertNull("we did not get a duplicate message", msg);
0: 	    consumerSession.commit();
1: 	    consumer.close();
1: 	    connection.close();
0: 
1: 	    // ensure no dangling messages with fresh broker etc
1: 	    broker.stop();
1: 	    broker.waitUntilStopped();
0: 
1: 	    LOG.info("Checking for remaining/hung messages..");
0: 	    broker = createBroker(false);
0: 	    setPersistenceAdapter(adapter);
1: 	    broker.start();
0: 
1: 	    // after restart, ensure no dangling messages
1: 	    cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1: 	    connection = cf.createConnection();
1: 	    connection.start();
1: 	    Session session2 = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 	    MessageConsumer consumer2 = session2.createConsumer(destination);
0: 	    msg = consumer2.receive(1000);
0: 	    if (msg == null) {
0: 	        msg = consumer2.receive(5000);
1: 	    }
1: 	    LOG.info("Received: " + msg);
1: 	    assertNull("no messges left dangling but got: " + msg, msg);
1: 	    connection.close();
1: 	}
0: 	
0:     @Test
1:     public void testFailoverConsumerAckLost() throws Exception {
0:         // as failure depends on hash order, do a few times
0:         for (int i=0; i<4; i++) {
1:             try {
0:                 doTestFailoverConsumerAckLost();
1:             } finally {
1:                 stopBroker();
1:             }
1:         }
1:     }
0:     
0:     public void doTestFailoverConsumerAckLost() throws Exception {
0:         final int adapter = 0;
1:         broker = createBroker(true);
0:         setPersistenceAdapter(adapter);
0:             
0:         broker.setPlugins(new BrokerPlugin[] {
1:                 new BrokerPluginSupport() {
0: 
1:                     // broker is killed on delivered ack as prefetch is 1
1:                     @Override
1:                     public void acknowledge(
1:                             ConsumerBrokerExchange consumerExchange,
1:                             final MessageAck ack) throws Exception {
0:                         
1:                         consumerExchange.getConnectionContext().setDontSendReponse(true);
0:                         Executors.newSingleThreadExecutor().execute(new Runnable() {   
1:                             public void run() {
0:                                 LOG.info("Stopping broker on ack: "  + ack);
1:                                 try {
1:                                     broker.stop();
1:                                 } catch (Exception e) {
1:                                     e.printStackTrace();
1:                                 }
1:                             }
1:                         });
1:                     }
1:                 }
1:         });
1:         broker.start();
0:         
1:         Vector<Connection> connections = new Vector<Connection>();
1:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:         Connection connection = cf.createConnection();
1:         connection.start();
1:         connections.add(connection);
1:         final Session producerSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         final Queue destination = producerSession.createQueue(QUEUE_NAME + "?consumer.prefetchSize=1");
0:            
1:         connection = cf.createConnection();
1:         connection.start();
1:         connections.add(connection);
0:         final Session consumerSession1 = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
0:         
1:         connection = cf.createConnection();
1:         connection.start();
1:         connections.add(connection);
0:         final Session consumerSession2 = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
0:         
1:         final MessageConsumer consumer1 = consumerSession1.createConsumer(destination);
1:         final MessageConsumer consumer2 = consumerSession2.createConsumer(destination);
0:         
1:         produceMessage(producerSession, destination);
1:         produceMessage(producerSession, destination);
0:         
1:         final Vector<Message> receivedMessages = new Vector<Message>();
1:         final CountDownLatch commitDoneLatch = new CountDownLatch(1);
0:         
0:         Executors.newSingleThreadExecutor().execute(new Runnable() {   
1:             public void run() {
1:                 LOG.info("doing async commit after consume...");
1:                 try {
1:                     Message msg = consumer1.receive(20000);
1:                     LOG.info("consumer1 first attempt got message: " + msg);
1:                     receivedMessages.add(msg);
0:                     
0:                     TimeUnit.SECONDS.sleep(7);
0:                     
1:                     // should not get a second message as there are two messages and two consumers
0:                     // but with failover and unordered connection reinit it can get the second
0:                     // message which will have a problem for the ack
1:                     msg = consumer1.receive(5000);
1:                     LOG.info("consumer1 second attempt got message: " + msg);
1:                     if (msg != null) {
1:                         receivedMessages.add(msg);
1:                     }
0:                     
1:                     LOG.info("committing consumer1 session: " + receivedMessages.size() + " messsage(s)");
0:                     consumerSession1.commit();
1:                     commitDoneLatch.countDown();
1:                     LOG.info("done async commit");
1:                 } catch (Exception e) {
1:                     e.printStackTrace();
1:                 }
1:             }
1:         });
0:         
0:                
1:         // will be stopped by the plugin
1:         broker.waitUntilStopped();
0:         broker = createBroker(false);
0:         setPersistenceAdapter(adapter);
1:         broker.start();
0: 
0:         assertTrue("tx committed trough failover", commitDoneLatch.await(30, TimeUnit.SECONDS));
0:         
0:         // getting 2 is indicative of a problem - proven with dangling message found after restart
1:         LOG.info("received message count: " + receivedMessages.size());
0:         
1:         // new transaction
0:         Message msg = consumer1.receive(2000);
0:         LOG.info("post: from consumer1 received: " + msg);
0:         assertNull("should be nothing left for consumer1", msg);
0:         consumerSession1.commit();
0:         
0:         // consumer2 should get other message
0:         msg = consumer2.receive(5000);
0:         LOG.info("post: from consumer2 received: " + msg);
0:         assertNotNull("got message on consumer2", msg);
0:         consumerSession2.commit();
0:         
0:         for (Connection c: connections) {
1:             c.close();
1:         }
0:         
1:         // ensure no dangling messages with fresh broker etc
1:         broker.stop();
1:         broker.waitUntilStopped();
0:         
1:         LOG.info("Checking for remaining/hung messages..");
0:         broker = createBroker(false);
0:         setPersistenceAdapter(adapter);
1:         broker.start();
0:         
1:         // after restart, ensure no dangling messages
1:         cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:         connection = cf.createConnection();
1:         connection.start();
1:         Session sweeperSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageConsumer sweeper = sweeperSession.createConsumer(destination);
0:         msg = sweeper.receive(1000);
0:         if (msg == null) {
0:             msg = sweeper.receive(5000);
1:         }
1:         LOG.info("Received: " + msg);
1:         assertNull("no messges left dangling but got: " + msg, msg);
1:         connection.close();
1:     }
0: 
1:     private void produceMessage(final Session producerSession, Queue destination)
1:             throws JMSException {
0:         MessageProducer producer = producerSession.createProducer(destination);      
1:         TextMessage message = producerSession.createTextMessage("Test message");
1:         producer.send(message);
1:         producer.close();
1:     }
0: 	
commit:58e6532
/////////////////////////////////////////////////////////////////////////
0: import java.io.File;
0: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
/////////////////////////////////////////////////////////////////////////
0:         doTestFailoverCommitReplyLost(0);
0:         doTestFailoverCommitReplyLost(1);
0:     @Test
0:     public void testFailoverCommitReplyLostKahaDB() throws Exception {
0:         doTestFailoverCommitReplyLost(2);
0:     }
0:     
0:     public void doTestFailoverCommitReplyLost(final int adapter) throws Exception {
0:         setPersistenceAdapter(adapter);
0:             
/////////////////////////////////////////////////////////////////////////
0:         setPersistenceAdapter(adapter);
/////////////////////////////////////////////////////////////////////////
0:         setPersistenceAdapter(adapter);
/////////////////////////////////////////////////////////////////////////
0:     private void setPersistenceAdapter(int adapter) throws IOException {
0:         switch (adapter) {
0:         case 0:
0:             break;
0:         case 1:
0:             broker.setPersistenceAdapter(new JDBCPersistenceAdapter());
0:             break;
0:         case 2:
0:             KahaDBPersistenceAdapter store = new KahaDBPersistenceAdapter();
0:             store.setDirectory(new File("target/activemq-data/kahadb/FailoverTransactionTest"));
0:             broker.setPersistenceAdapter(store);
0:             break;
0:         }
0:     }
0: 
commit:8732f70
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertTrue;
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.TimeUnit;
1: import javax.jms.Message;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.jdbc.JDBCPersistenceAdapter;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	    broker.setDeleteAllMessagesOnStartup(deleteAllMessagesOnStartup);
0: 	//@Test
0: 	    startCleanBroker();
/////////////////////////////////////////////////////////////////////////
0:         doTestFailoverCommitReplyLost(false);
0:     }  
0:     
0:     @Test
0:     public void testFailoverCommitReplyLostJdbc() throws Exception {
0:         doTestFailoverCommitReplyLost(true);
0:     }
0:     
0:     public void doTestFailoverCommitReplyLost(boolean useJdbcPersistenceAdapter) throws Exception {
0:         if (useJdbcPersistenceAdapter) {
0:             broker.setPersistenceAdapter(new JDBCPersistenceAdapter());
0:         }
/////////////////////////////////////////////////////////////////////////
0:         
0:         final CountDownLatch commitDoneLatch = new CountDownLatch(1);
0:                     commitDoneLatch.countDown();
/////////////////////////////////////////////////////////////////////////
0:         // will be stopped by the plugin
0:         broker = createBroker(false);
0:         if (useJdbcPersistenceAdapter) {
0:             broker.setPersistenceAdapter(new JDBCPersistenceAdapter());
0:         }
1:         broker.start();
0:         assertTrue("tx committed trough failover", commitDoneLatch.await(30, TimeUnit.SECONDS));
0:         
0:         // new transaction
0:         Message msg = consumer.receive(20000);
0:         LOG.info("Received: " + msg);
1:         assertNotNull("we got the message", msg);
1:         session.commit();
0:         consumer.close();
0:         connection.close();
0:         
0:         // ensure no dangling messages with fresh broker etc
0:         broker.stop();
0:         broker.waitUntilStopped();
0:         
0:         LOG.info("Checking for remaining/hung messages..");
0:         broker = createBroker(false);
0:         if (useJdbcPersistenceAdapter) {
0:             broker.setPersistenceAdapter(new JDBCPersistenceAdapter());
0:         }
1:         broker.start();
0:         
0:         // after restart, ensure no dangling messages
0:         cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
0:         connection = cf.createConnection();
0:         connection.start();
0:         Session session2 = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         consumer = session2.createConsumer(destination);
1:         msg = consumer.receive(1000);
0:         if (msg == null) {
0:             msg = consumer.receive(5000);
0:         }
0:         LOG.info("Received: " + msg);
0:         assertNull("no messges left dangling but got: " + msg, msg);
0: 	    startCleanBroker();        
/////////////////////////////////////////////////////////////////////////
0: 	    // without tracking producers, message will not be replayed on recovery
0: 	    assertNull("we got the message", consumer.receive(5000));
0: 	    startCleanBroker();	        
commit:1606c59
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.Executors;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.BrokerPlugin;
0: import org.apache.activemq.broker.BrokerPluginSupport;
0: import org.apache.activemq.broker.ConnectionContext;
0: import org.apache.activemq.command.TransactionId;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(FailoverTransactionTest.class);
/////////////////////////////////////////////////////////////////////////
0: 	    broker = createBroker(deleteAllMessagesOnStartup);
0: 
0: 	public BrokerService createBroker(boolean deleteAllMessagesOnStartup) throws Exception {   
0: 	    broker = new BrokerService();
0: 	    broker.setUseJmx(false);
0: 	    broker.addConnector(url);
0: 	    broker.setDeleteAllMessagesOnStartup(true);
0: 	    return broker;
0: 	}
0: 
/////////////////////////////////////////////////////////////////////////
0:     @Test
0:     public void testFailoverCommitReplyLost() throws Exception {
0:         
0:         broker.stop();
0:         
0:         broker = createBroker(true);
0:         broker.setPlugins(new BrokerPlugin[] {
0:                 new BrokerPluginSupport() {
0:                     @Override
0:                     public void commitTransaction(ConnectionContext context,
0:                             TransactionId xid, boolean onePhase) throws Exception {
0:                         super.commitTransaction(context, xid, onePhase);
0:                         // so commit will hang as if reply is lost
0:                         context.setDontSendReponse(true);
0:                         Executors.newSingleThreadExecutor().execute(new Runnable() {   
0:                             public void run() {
0:                                 LOG.info("Stopping broker post commit...");
0:                                 try {
0:                                     broker.stop();
0:                                 } catch (Exception e) {
0:                                     e.printStackTrace();
0:                                 }
0:                             }
0:                         });
0:                    }   
0:                 }
0:         });
0:         broker.start();
0:         
0:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
0:         Connection connection = cf.createConnection();
0:         connection.start();
1:         final Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:         Queue destination = session.createQueue(QUEUE_NAME);
0: 
1:         MessageConsumer consumer = session.createConsumer(destination);
0:         MessageProducer producer = session.createProducer(destination);
0:         
0:         TextMessage message = session.createTextMessage("Test message");
0:         producer.send(message);
0: 
1:         // broker will die on commit reply so this will hang till restart
0:         Executors.newSingleThreadExecutor().execute(new Runnable() {   
0:             public void run() {
1:                 LOG.info("doing async commit...");
0:                 try {
0:                     session.commit();
0:                     LOG.info("done async commit");
0:                 } catch (Exception e) {
0:                     e.printStackTrace();
0:                 }
0:             }
0:         });
0:        
0:         broker.waitUntilStopped();
0:         startBroker(false);
0: 
0:         assertNotNull("we got the message", consumer.receive(20000));
1:         assertNull("we got just one message", consumer.receive(2000));
0:         session.commit();   
0:         connection.close();
0:     }
0: 
commit:b9e51d6
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport.failover;
0: 
0: import static org.junit.Assert.assertNotNull;
0: import static org.junit.Assert.assertNull;
0: 
0: 
1: import javax.jms.Connection;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Queue;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
0: 
0: import org.apache.activemq.ActiveMQConnectionFactory;
0: import org.apache.activemq.broker.BrokerService;
0: import org.junit.After;
0: import org.junit.Before;
0: import org.junit.Test;
0: 
1: // see https://issues.apache.org/activemq/browse/AMQ-2473
0: public class FailoverTransactionTest {
0: 	
0: 	private static final String QUEUE_NAME = "test.FailoverTransactionTest";
0: 	private String url = "tcp://localhost:61616";
0: 	BrokerService broker;
0: 	
0: 	@Before
0: 	public void startCleanBroker() throws Exception {
0: 	    startBroker(true);
0: 	}
0: 	
0: 	@After
0: 	public void stopBroker() throws Exception {
0: 	    if (broker != null) {
0: 	        broker.stop();
0: 	    }
0: 	}
0: 	
0: 	public void startBroker(boolean deleteAllMessagesOnStartup) throws Exception {
0: 	    broker = new BrokerService();
0:         broker.setUseJmx(false);
0:         broker.addConnector(url);
0:         broker.setDeleteAllMessagesOnStartup(true);
0:         broker.start();
0: 	}
0: 	
0: 	@Test
0: 	public void testFailoverProducerCloseBeforeTransaction() throws Exception {
0: 		
0: 		ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
0: 		Connection connection = cf.createConnection();
0: 		connection.start();
0: 		Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
0: 		Queue destination = session.createQueue(QUEUE_NAME);
0: 
1:         MessageConsumer consumer = session.createConsumer(destination);
0: 		MessageProducer producer = session.createProducer(destination);
0: 		
0: 		TextMessage message = session.createTextMessage("Test message");
0: 		producer.send(message);
0: 
0: 		// close producer before commit, emulate jmstemplate
0: 		producer.close();
0: 		
0: 		// restart to force failover and connection state recovery before the commit
0: 		broker.stop();
0: 		startBroker(false);
0: 
0: 		session.commit();
0: 		assertNotNull("we got the message", consumer.receive(20000));
0: 		session.commit();	
0: 		connection.close();
0: 	}
0: 	
0: 	@Test
0: 	public void testFailoverProducerCloseBeforeTransactionFailWhenDisabled() throws Exception {
0: 	        
0: 	    ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")?trackTransactionProducers=false");
0: 	    Connection connection = cf.createConnection();
0: 	    connection.start();
0: 	    Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
0: 	    Queue destination = session.createQueue(QUEUE_NAME);
0: 	    
1: 	    MessageConsumer consumer = session.createConsumer(destination);
0: 	    MessageProducer producer = session.createProducer(destination);
0: 	    
0: 	    TextMessage message = session.createTextMessage("Test message");
0: 	    producer.send(message);
0: 	    
0: 	    // close producer before commit, emulate jmstemplate
0: 	    producer.close();
0: 	    
0: 	    // restart to force failover and connection state recovery before the commit
0: 	    broker.stop();
0: 	    startBroker(false);
0: 	    
0: 	    session.commit();
0: 	    
0: 	    // withough tracking producers, message will not be replayed on recovery
0: 	    assertNull("we got the message", consumer.receive(2000));
0: 	    session.commit();   
0: 	    connection.close();
0: 	}
0: 	
0: 	@Test
0: 	public void testFailoverMultipleProducerCloseBeforeTransaction() throws Exception {
0: 	        
0: 	    ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
0: 	    Connection connection = cf.createConnection();
0: 	    connection.start();
0: 	    Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
0: 	    Queue destination = session.createQueue(QUEUE_NAME);
0: 	    
1: 	    MessageConsumer consumer = session.createConsumer(destination);
0: 	    MessageProducer producer;
0: 	    TextMessage message;
0: 	    final int count = 10;
0: 	    for (int i=0; i<count; i++) {
0: 	        producer = session.createProducer(destination);	        
0: 	        message = session.createTextMessage("Test message: " + count);
0: 	        producer.send(message);
0: 	        producer.close();
0: 	    }
0: 	    
0: 	    // restart to force failover and connection state recovery before the commit
0: 	    broker.stop();
0: 	    startBroker(false);
0: 	    
0: 	    session.commit();
0: 	    for (int i=0; i<count; i++) {
0: 	        assertNotNull("we got all the message: " + count, consumer.receive(20000));
0: 	    }
0: 	    session.commit();
0: 	    connection.close();
0: 	}  
0: }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:14b91d4
/////////////////////////////////////////////////////////////////////////
1:         String osName = System.getProperty("os.name");
1:         Object[] persistenceAdapters;
1:         if (!osName.equalsIgnoreCase("AIX") && !osName.equalsIgnoreCase("SunOS")) {
1:             persistenceAdapters = new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB, PersistenceAdapterChoice.JDBC};
0:         } else {
1:             persistenceAdapters = new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.JDBC};
0:         }
1:         addCombinationValues("defaultPersistenceAdapter",persistenceAdapters);
commit:f7f294f
/////////////////////////////////////////////////////////////////////////
1:         super.setMaxTestTime(2 * 60 * 1000); // some boxes can be real slow
commit:ef24cc9
commit:06611d9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             assertNotNull("Failed to get message: " + count, consumer.receive(20000));
1:         assertTrue("connectionconsumer did not get a message", connectionConsumerGotOne.await(10, TimeUnit.SECONDS));
commit:7d8ce02
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("unchecked")
/////////////////////////////////////////////////////////////////////////
0:             new Object[]{PersistenceAdapterChoice.KahaDB,
0:                     PersistenceAdapterChoice.JDBC
0:                     // not implemented for AMQ store
0:             });
1:     @SuppressWarnings("unchecked")
/////////////////////////////////////////////////////////////////////////
0:             new Object[]{PersistenceAdapterChoice.KahaDB,
0:                     PersistenceAdapterChoice.JDBC
0:                     // last producer message id store feature not implemented for AMQ store
0:             });
1:     @SuppressWarnings("unchecked")
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("unchecked")
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:883eed0
/////////////////////////////////////////////////////////////////////////
1:     private static final String TRANSPORT_URI = "tcp://localhost:0";
1:     private String url;
/////////////////////////////////////////////////////////////////////////
1:     private void startCleanBroker() throws Exception {
0:         startBroker(true);
0:     }
0: 
1:     public void startBroker(boolean deleteAllMessagesOnStartup, String bindAddress) throws Exception {
1:         broker = createBroker(deleteAllMessagesOnStartup, bindAddress);
0:         broker.start();
0:     }
0: 
1:         return createBroker(deleteAllMessagesOnStartup, TRANSPORT_URI);
0:     }
0: 
1:     public BrokerService createBroker(boolean deleteAllMessagesOnStartup, String bindAddress) throws Exception {
1:         broker.addConnector(bindAddress);
0: 
1:         url = broker.getTransportConnectors().get(0).getConnectUri().toString();
0: 
/////////////////////////////////////////////////////////////////////////
1:         startBroker(false, url);
/////////////////////////////////////////////////////////////////////////
1:         broker = createBroker(false, url);
/////////////////////////////////////////////////////////////////////////
1:         broker = createBroker(false, url);
/////////////////////////////////////////////////////////////////////////
1:         broker = createBroker(false, url);
/////////////////////////////////////////////////////////////////////////
1:         broker = createBroker(false, url);
/////////////////////////////////////////////////////////////////////////
1:         broker = createBroker(false, url);
/////////////////////////////////////////////////////////////////////////
1:         startBroker(false, url);
/////////////////////////////////////////////////////////////////////////
1:         startBroker(false, url);
/////////////////////////////////////////////////////////////////////////
1:         startBroker(false, url);
/////////////////////////////////////////////////////////////////////////
1:         broker = createBroker(false, url);
/////////////////////////////////////////////////////////////////////////
1:         broker = createBroker(false, url);
/////////////////////////////////////////////////////////////////////////
1:         broker = createBroker(false, url);
/////////////////////////////////////////////////////////////////////////
1:         broker = createBroker(false, url);
/////////////////////////////////////////////////////////////////////////
1:         broker = createBroker(false, url);
/////////////////////////////////////////////////////////////////////////
1:         broker = createBroker(false, url);
/////////////////////////////////////////////////////////////////////////
1:         broker = createBroker(false, url);
/////////////////////////////////////////////////////////////////////////
0:                     exceptions.add(ex);
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:77a679b
/////////////////////////////////////////////////////////////////////////
0:                 new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB, PersistenceAdapterChoice.JDBC});
/////////////////////////////////////////////////////////////////////////
0:             new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB,
/////////////////////////////////////////////////////////////////////////
0:             new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB,
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(FailoverTransactionTest.class);
============================================================================