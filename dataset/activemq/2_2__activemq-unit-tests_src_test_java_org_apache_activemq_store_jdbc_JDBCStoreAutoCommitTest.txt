1:8b64e13: /**
1:8b64e13:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:8b64e13:  * contributor license agreements.  See the NOTICE file distributed with
1:8b64e13:  * this work for additional information regarding copyright ownership.
1:8b64e13:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:8b64e13:  * (the "License"); you may not use this file except in compliance with
1:8b64e13:  * the License.  You may obtain a copy of the License at
1:8b64e13:  *
1:8b64e13:  *      http://www.apache.org/licenses/LICENSE-2.0
1:8b64e13:  *
1:8b64e13:  * Unless required by applicable law or agreed to in writing, software
1:8b64e13:  * distributed under the License is distributed on an "AS IS" BASIS,
1:8b64e13:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:8b64e13:  * See the License for the specific language governing permissions and
1:8b64e13:  * limitations under the License.
1:8b64e13:  */
1:8b64e13: package org.apache.activemq.store.jdbc;
3:8b64e13: 
1:8b64e13: import static org.junit.Assert.assertEquals;
1:8b64e13: 
1:8b64e13: import java.io.IOException;
1:8b64e13: import java.io.PrintWriter;
1:8b64e13: import java.net.URI;
1:8b64e13: import java.sql.Array;
1:8b64e13: import java.sql.Blob;
1:8b64e13: import java.sql.CallableStatement;
1:8b64e13: import java.sql.Clob;
1:8b64e13: import java.sql.Connection;
1:8b64e13: import java.sql.DatabaseMetaData;
1:8b64e13: import java.sql.NClob;
1:8b64e13: import java.sql.PreparedStatement;
1:8b64e13: import java.sql.SQLClientInfoException;
1:8b64e13: import java.sql.SQLException;
1:8b64e13: import java.sql.SQLFeatureNotSupportedException;
1:8b64e13: import java.sql.SQLWarning;
1:8b64e13: import java.sql.SQLXML;
1:8b64e13: import java.sql.Savepoint;
1:8b64e13: import java.sql.Statement;
1:8b64e13: import java.sql.Struct;
1:8b64e13: import java.util.Map;
1:8b64e13: import java.util.Properties;
1:8b64e13: import java.util.concurrent.Executor;
1:8b64e13: import java.util.logging.Logger;
1:8b64e13: 
1:8b64e13: import javax.jms.MessageConsumer;
1:8b64e13: import javax.jms.MessageProducer;
1:8b64e13: import javax.jms.Session;
1:8b64e13: import javax.jms.TextMessage;
1:8b64e13: 
1:165959e: import javax.sql.DataSource;
1:8b64e13: import org.apache.activemq.ActiveMQConnection;
1:8b64e13: import org.apache.activemq.ActiveMQConnectionFactory;
1:8b64e13: import org.apache.activemq.broker.BrokerService;
1:8b64e13: import org.apache.derby.jdbc.EmbeddedDataSource;
1:8b64e13: import org.junit.Test;
1:8b64e13: 
1:8b64e13: /**
1:8b64e13:  * to be compliant with JDBC spec; officially commit is not supposed to be
1:8b64e13:  * called on a connection that uses autocommit.The oracle v12 driver does a
1:8b64e13:  * check for autocommitSpecCompliance and it causes issues
1:8b64e13:  * <p/>
1:8b64e13:  * To test; wrap the datasource used by the broker and check for autocommit
1:8b64e13:  * before delegating to real datasource. If commit is called on connection with
1:8b64e13:  * autocommit, wrapper throws a SQLException.
1:8b64e13:  */
1:8b64e13: 
1:8b64e13: public class JDBCStoreAutoCommitTest {
1:8b64e13: 
1:8b64e13:     private static final String BROKER_NAME = "AutoCommitTest";
1:8b64e13:     private static final String TEST_DEST = "commitCheck";
1:8b64e13:     private static final String MSG_TEXT = "JDBCStoreAutoCommitTest TEST";
1:8b64e13: 
1:8b64e13:     /**
1:8b64e13:      * verify dropping and recreating tables
1:8b64e13:      *
1:8b64e13:      * @throws Exception
1:8b64e13:      */
1:8b64e13:     @Test
1:8b64e13:     public void testDeleteAllMessages() throws Exception {
1:8b64e13:         BrokerService broker = createBrokerService();
1:8b64e13:         broker.getPersistenceAdapter().deleteAllMessages();
1:8b64e13:         broker.setUseJmx(false);
1:8b64e13:         broker.start();
1:8b64e13:         broker.waitUntilStarted();
1:8b64e13:         broker.stop();
1:8b64e13:         broker.waitUntilStopped();
1:8b64e13:     }
1:8b64e13: 
1:8b64e13:     /**
1:8b64e13:      * Send message and consume message, JMS session is not transacted
1:8b64e13:      *
1:8b64e13:      * @throws Exception
1:8b64e13:      */
1:8b64e13:     @Test
1:8b64e13:     public void testSendConsume() throws Exception {
1:8b64e13:         this.doSendConsume(false);
1:8b64e13:     }
1:8b64e13: 
1:8b64e13:     /**
1:8b64e13:      * send message and consume message, JMS session is transacted
1:8b64e13:      *
1:8b64e13:      * @throws Exception
1:8b64e13:      */
1:8b64e13:     @Test
1:8b64e13:     public void testSendConsumeTransacted() throws Exception {
1:8b64e13:         this.doSendConsume(true);
1:8b64e13:     }
1:8b64e13: 
1:8b64e13:     private void doSendConsume(boolean transacted) throws Exception {
1:8b64e13: 
1:8b64e13:         BrokerService broker = createBrokerService();
1:8b64e13:         broker.setUseJmx(false);
1:8b64e13:         broker.start();
1:8b64e13:         broker.waitUntilStarted();
1:8b64e13: 
1:8b64e13:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory(new URI("vm:" + BROKER_NAME));
1:8b64e13:         ActiveMQConnection c1 = (ActiveMQConnection) cf.createConnection();
1:8b64e13:         c1.start();
1:8b64e13: 
1:8b64e13:         try {
1:8b64e13:             // message send
1:8b64e13:             Session session1 = c1.createSession(transacted, Session.AUTO_ACKNOWLEDGE);
1:8b64e13:             MessageProducer messageProducer = session1.createProducer(session1.createQueue(TEST_DEST));
1:8b64e13:             TextMessage textMessage = session1.createTextMessage(MSG_TEXT);
1:8b64e13:             messageProducer.send(textMessage);
1:8b64e13: 
1:8b64e13:             if (transacted) {
1:8b64e13:                 session1.commit();
1:8b64e13:             }
1:8b64e13: 
1:8b64e13:             // consume
1:8b64e13:             Session session2 = c1.createSession(transacted, Session.AUTO_ACKNOWLEDGE);
1:8b64e13:             MessageConsumer messageConsumer = session2.createConsumer(session2.createQueue(TEST_DEST));
1:8b64e13:             TextMessage messageReceived = (TextMessage) messageConsumer.receive(1000);
1:8b64e13: 
1:8b64e13:             assertEquals("check message received", MSG_TEXT, messageReceived.getText());
1:8b64e13:         } finally {
1:8b64e13:             c1.close();
1:8b64e13:             broker.stop();
1:8b64e13:             broker.waitUntilStopped();
1:165959e:             if (realDataSource != null) {
1:165959e:                 DataSourceServiceSupport.shutdownDefaultDataSource(realDataSource);
1:165959e:             }
1:8b64e13:         }
1:8b64e13:     }
1:8b64e13: 
1:165959e:     DataSource realDataSource;
1:8b64e13:     private BrokerService createBrokerService() throws IOException {
1:8b64e13:         BrokerService broker = new BrokerService();
1:8b64e13:         broker.setBrokerName(BROKER_NAME);
1:8b64e13:         broker.setUseJmx(false);
1:8b64e13: 
1:8b64e13:         JDBCPersistenceAdapter jdbc = new JDBCPersistenceAdapter();
1:165959e:         realDataSource = jdbc.getDataSource();
1:165959e:         jdbc.setDataSource(new TestDataSource(realDataSource));
1:8b64e13: 
1:8b64e13:         broker.setPersistenceAdapter(jdbc);
1:8b64e13:         return broker;
1:8b64e13:     }
1:8b64e13: 
1:8b64e13:     private class TestDataSource implements javax.sql.DataSource {
1:8b64e13: 
1:8b64e13:         private final javax.sql.DataSource realDataSource;
1:8b64e13: 
1:8b64e13:         public TestDataSource(javax.sql.DataSource dataSource) {
1:8b64e13:             realDataSource = dataSource;
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public Connection getConnection() throws SQLException {
1:8b64e13:             Connection autoCommitCheckConnection = new AutoCommitCheckConnection(realDataSource.getConnection());
1:8b64e13:             return autoCommitCheckConnection;
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public Connection getConnection(String username, String password) throws SQLException {
1:8b64e13:             Connection autoCommitCheckConnection = new AutoCommitCheckConnection(realDataSource.getConnection(username, password));
1:8b64e13: 
1:8b64e13:             return autoCommitCheckConnection;
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public PrintWriter getLogWriter() throws SQLException {
1:8b64e13:             return realDataSource.getLogWriter();
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public void setLogWriter(PrintWriter out) throws SQLException {
1:8b64e13:             realDataSource.setLogWriter(out);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public void setLoginTimeout(int seconds) throws SQLException {
1:8b64e13:             realDataSource.setLoginTimeout(seconds);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public int getLoginTimeout() throws SQLException {
1:8b64e13:             return realDataSource.getLoginTimeout();
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public Logger getParentLogger() throws SQLFeatureNotSupportedException {
1:8b64e13:             return realDataSource.getParentLogger();
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public <T> T unwrap(Class<T> iface) throws SQLException {
1:8b64e13:             return realDataSource.unwrap(iface);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public boolean isWrapperFor(Class<?> iface) throws SQLException {
1:8b64e13:             return realDataSource.isWrapperFor(iface);
1:8b64e13:         }
1:8b64e13:     }
1:8b64e13: 
1:8b64e13:     private class AutoCommitCheckConnection implements Connection {
1:8b64e13: 
1:8b64e13:         private final Connection realConnection;
1:8b64e13: 
1:8b64e13:         public AutoCommitCheckConnection(Connection connection) {
1:8b64e13:             this.realConnection = connection;
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         // verify commit is not called on an auto-commit connection
1:8b64e13:         @Override
1:8b64e13:         public void commit() throws SQLException {
1:8b64e13:             if (getAutoCommit() == true) {
1:8b64e13:                 throw new SQLException("AutoCommitCheckConnection: Called commit on autoCommit Connection");
1:8b64e13:             }
1:8b64e13:             realConnection.commit();
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         // Just plumbing for wrapper. Might have been better to do a Dynamic Proxy here.
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public Statement createStatement() throws SQLException {
1:8b64e13:             return realConnection.createStatement();
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public PreparedStatement prepareStatement(String sql) throws SQLException {
1:8b64e13:             return realConnection.prepareStatement(sql);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public CallableStatement prepareCall(String sql) throws SQLException {
1:8b64e13:             return realConnection.prepareCall(sql);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public String nativeSQL(String sql) throws SQLException {
1:8b64e13:             return realConnection.nativeSQL(sql);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public void setAutoCommit(boolean autoCommit) throws SQLException {
1:8b64e13:             realConnection.setAutoCommit(autoCommit);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public boolean getAutoCommit() throws SQLException {
1:8b64e13:             return realConnection.getAutoCommit();
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public void rollback() throws SQLException {
1:8b64e13:             realConnection.rollback();
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public void close() throws SQLException {
1:8b64e13:             realConnection.close();
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public boolean isClosed() throws SQLException {
1:8b64e13:             return realConnection.isClosed();
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public DatabaseMetaData getMetaData() throws SQLException {
1:8b64e13:             return realConnection.getMetaData();
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public void setReadOnly(boolean readOnly) throws SQLException {
1:8b64e13:             realConnection.setReadOnly(readOnly);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public boolean isReadOnly() throws SQLException {
1:8b64e13:             return realConnection.isReadOnly();
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public void setCatalog(String catalog) throws SQLException {
1:8b64e13:             realConnection.setCatalog(catalog);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public String getCatalog() throws SQLException {
1:8b64e13:             return realConnection.getCatalog();
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public void setTransactionIsolation(int level) throws SQLException {
1:8b64e13:             realConnection.setTransactionIsolation(level);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public int getTransactionIsolation() throws SQLException {
1:8b64e13:             return realConnection.getTransactionIsolation();
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public SQLWarning getWarnings() throws SQLException {
1:8b64e13:             return realConnection.getWarnings();
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public void clearWarnings() throws SQLException {
1:8b64e13:             realConnection.clearWarnings();
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
1:8b64e13:             return realConnection.createStatement(resultSetType, resultSetConcurrency);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
1:8b64e13:             return realConnection.prepareStatement(sql, resultSetType, resultSetConcurrency);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
1:8b64e13:             return realConnection.prepareCall(sql, resultSetType, resultSetConcurrency);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public Map<String, Class<?>> getTypeMap() throws SQLException {
1:8b64e13:             return realConnection.getTypeMap();
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public void setTypeMap(Map<String, Class<?>> map) throws SQLException {
1:8b64e13:             realConnection.setTypeMap(map);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public void setHoldability(int holdability) throws SQLException {
1:8b64e13:             realConnection.setHoldability(holdability);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public int getHoldability() throws SQLException {
1:8b64e13:             return realConnection.getHoldability();
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public Savepoint setSavepoint() throws SQLException {
1:8b64e13:             return realConnection.setSavepoint();
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public Savepoint setSavepoint(String name) throws SQLException {
1:8b64e13:             return realConnection.setSavepoint(name);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public void rollback(Savepoint savepoint) throws SQLException {
1:8b64e13:             realConnection.rollback();
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public void releaseSavepoint(Savepoint savepoint) throws SQLException {
1:8b64e13:             realConnection.releaseSavepoint(savepoint);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
1:8b64e13:             return realConnection.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
1:8b64e13:             return realConnection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
1:8b64e13:             return realConnection.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
1:8b64e13:             return realConnection.prepareStatement(sql, autoGeneratedKeys);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
1:8b64e13:             return realConnection.prepareStatement(sql, columnIndexes);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
1:8b64e13:             return realConnection.prepareStatement(sql, columnNames);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public Clob createClob() throws SQLException {
1:8b64e13:             return realConnection.createClob();
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public Blob createBlob() throws SQLException {
1:8b64e13:             return realConnection.createBlob();
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public NClob createNClob() throws SQLException {
1:8b64e13:             return realConnection.createNClob();
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public SQLXML createSQLXML() throws SQLException {
1:8b64e13:             return realConnection.createSQLXML();
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public boolean isValid(int timeout) throws SQLException {
1:8b64e13:             return realConnection.isValid(timeout);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public void setClientInfo(String name, String value) throws SQLClientInfoException {
1:8b64e13:             realConnection.setClientInfo(name, value);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public void setClientInfo(Properties properties) throws SQLClientInfoException {
1:8b64e13:             realConnection.setClientInfo(properties);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public String getClientInfo(String name) throws SQLException {
1:8b64e13:             return realConnection.getClientInfo(name);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public Properties getClientInfo() throws SQLException {
1:8b64e13:             return realConnection.getClientInfo();
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public Array createArrayOf(String typeName, Object[] elements) throws SQLException {
1:8b64e13:             return realConnection.createArrayOf(typeName, elements);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public Struct createStruct(String typeName, Object[] attributes) throws SQLException {
1:8b64e13:             return realConnection.createStruct(typeName, attributes);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public void setSchema(String schema) throws SQLException {
1:8b64e13:             realConnection.setSchema(schema);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public String getSchema() throws SQLException {
1:8b64e13:             return realConnection.getSchema();
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public void abort(Executor executor) throws SQLException {
1:8b64e13:             realConnection.abort(executor);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {
1:8b64e13:             realConnection.setNetworkTimeout(executor, milliseconds);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public int getNetworkTimeout() throws SQLException {
1:8b64e13:             return realConnection.getNetworkTimeout();
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public <T> T unwrap(Class<T> iface) throws SQLException {
1:8b64e13:             return realConnection.unwrap(iface);
1:8b64e13:         }
1:8b64e13: 
1:8b64e13:         @Override
1:8b64e13:         public boolean isWrapperFor(Class<?> iface) throws SQLException {
1:8b64e13:             return realConnection.isWrapperFor(iface);
1:8b64e13:         }
1:8b64e13:     }
1:8b64e13: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:165959e
/////////////////////////////////////////////////////////////////////////
1: import javax.sql.DataSource;
/////////////////////////////////////////////////////////////////////////
1:             if (realDataSource != null) {
1:                 DataSourceServiceSupport.shutdownDefaultDataSource(realDataSource);
1:             }
1:     DataSource realDataSource;
1:         realDataSource = jdbc.getDataSource();
1:         jdbc.setDataSource(new TestDataSource(realDataSource));
author:Timothy Bish
-------------------------------------------------------------------------------
commit:8b64e13
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.store.jdbc;
1: 
1: import static org.junit.Assert.assertEquals;
1: 
1: import java.io.IOException;
1: import java.io.PrintWriter;
1: import java.net.URI;
1: import java.sql.Array;
1: import java.sql.Blob;
1: import java.sql.CallableStatement;
1: import java.sql.Clob;
1: import java.sql.Connection;
1: import java.sql.DatabaseMetaData;
1: import java.sql.NClob;
1: import java.sql.PreparedStatement;
1: import java.sql.SQLClientInfoException;
1: import java.sql.SQLException;
1: import java.sql.SQLFeatureNotSupportedException;
1: import java.sql.SQLWarning;
1: import java.sql.SQLXML;
1: import java.sql.Savepoint;
1: import java.sql.Statement;
1: import java.sql.Struct;
1: import java.util.Map;
1: import java.util.Properties;
1: import java.util.concurrent.Executor;
1: import java.util.logging.Logger;
1: 
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
1: 
1: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.derby.jdbc.EmbeddedDataSource;
1: import org.junit.Test;
1: 
1: /**
1:  * to be compliant with JDBC spec; officially commit is not supposed to be
1:  * called on a connection that uses autocommit.The oracle v12 driver does a
1:  * check for autocommitSpecCompliance and it causes issues
1:  * <p/>
1:  * To test; wrap the datasource used by the broker and check for autocommit
1:  * before delegating to real datasource. If commit is called on connection with
1:  * autocommit, wrapper throws a SQLException.
1:  */
1: 
1: public class JDBCStoreAutoCommitTest {
1: 
1:     private static final String BROKER_NAME = "AutoCommitTest";
1:     private static final String TEST_DEST = "commitCheck";
1:     private static final String MSG_TEXT = "JDBCStoreAutoCommitTest TEST";
1: 
1:     /**
1:      * verify dropping and recreating tables
1:      *
1:      * @throws Exception
1:      */
1:     @Test
1:     public void testDeleteAllMessages() throws Exception {
1:         BrokerService broker = createBrokerService();
1:         broker.getPersistenceAdapter().deleteAllMessages();
1:         broker.setUseJmx(false);
1:         broker.start();
1:         broker.waitUntilStarted();
1:         broker.stop();
1:         broker.waitUntilStopped();
1:     }
1: 
1:     /**
1:      * Send message and consume message, JMS session is not transacted
1:      *
1:      * @throws Exception
1:      */
1:     @Test
1:     public void testSendConsume() throws Exception {
1:         this.doSendConsume(false);
1:     }
1: 
1:     /**
1:      * send message and consume message, JMS session is transacted
1:      *
1:      * @throws Exception
1:      */
1:     @Test
1:     public void testSendConsumeTransacted() throws Exception {
1:         this.doSendConsume(true);
1:     }
1: 
1:     private void doSendConsume(boolean transacted) throws Exception {
1: 
1:         BrokerService broker = createBrokerService();
1:         broker.setUseJmx(false);
1:         broker.start();
1:         broker.waitUntilStarted();
1: 
1:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory(new URI("vm:" + BROKER_NAME));
1:         ActiveMQConnection c1 = (ActiveMQConnection) cf.createConnection();
1:         c1.start();
1: 
1:         try {
1:             // message send
1:             Session session1 = c1.createSession(transacted, Session.AUTO_ACKNOWLEDGE);
1:             MessageProducer messageProducer = session1.createProducer(session1.createQueue(TEST_DEST));
1:             TextMessage textMessage = session1.createTextMessage(MSG_TEXT);
1:             messageProducer.send(textMessage);
1: 
1:             if (transacted) {
1:                 session1.commit();
1:             }
1: 
1:             // consume
1:             Session session2 = c1.createSession(transacted, Session.AUTO_ACKNOWLEDGE);
1:             MessageConsumer messageConsumer = session2.createConsumer(session2.createQueue(TEST_DEST));
1:             TextMessage messageReceived = (TextMessage) messageConsumer.receive(1000);
1: 
1:             assertEquals("check message received", MSG_TEXT, messageReceived.getText());
1:         } finally {
1:             c1.close();
1:             broker.stop();
1:             broker.waitUntilStopped();
1:         }
1:     }
1: 
1:     private BrokerService createBrokerService() throws IOException {
1:         BrokerService broker = new BrokerService();
1:         broker.setBrokerName(BROKER_NAME);
1:         broker.setUseJmx(false);
1: 
1:         JDBCPersistenceAdapter jdbc = new JDBCPersistenceAdapter();
0:         EmbeddedDataSource embeddedDataSource = new EmbeddedDataSource();
0:         embeddedDataSource.setDatabaseName("derbyDb");
0:         embeddedDataSource.setCreateDatabase("create");
1: 
0:         javax.sql.DataSource wrappedDataSource = new TestDataSource(embeddedDataSource);
1: 
0:         jdbc.setDataSource(wrappedDataSource);
1: 
1:         broker.setPersistenceAdapter(jdbc);
1:         return broker;
1:     }
1: 
1:     private class TestDataSource implements javax.sql.DataSource {
1: 
1:         private final javax.sql.DataSource realDataSource;
1: 
1:         public TestDataSource(javax.sql.DataSource dataSource) {
1:             realDataSource = dataSource;
1:         }
1: 
1:         @Override
1:         public Connection getConnection() throws SQLException {
1:             Connection autoCommitCheckConnection = new AutoCommitCheckConnection(realDataSource.getConnection());
1:             return autoCommitCheckConnection;
1:         }
1: 
1:         @Override
1:         public Connection getConnection(String username, String password) throws SQLException {
1:             Connection autoCommitCheckConnection = new AutoCommitCheckConnection(realDataSource.getConnection(username, password));
1: 
1:             return autoCommitCheckConnection;
1:         }
1: 
1:         @Override
1:         public PrintWriter getLogWriter() throws SQLException {
1:             return realDataSource.getLogWriter();
1:         }
1: 
1:         @Override
1:         public void setLogWriter(PrintWriter out) throws SQLException {
1:             realDataSource.setLogWriter(out);
1:         }
1: 
1:         @Override
1:         public void setLoginTimeout(int seconds) throws SQLException {
1:             realDataSource.setLoginTimeout(seconds);
1:         }
1: 
1:         @Override
1:         public int getLoginTimeout() throws SQLException {
1:             return realDataSource.getLoginTimeout();
1:         }
1: 
1:         @Override
1:         public Logger getParentLogger() throws SQLFeatureNotSupportedException {
1:             return realDataSource.getParentLogger();
1:         }
1: 
1:         @Override
1:         public <T> T unwrap(Class<T> iface) throws SQLException {
1:             return realDataSource.unwrap(iface);
1:         }
1: 
1:         @Override
1:         public boolean isWrapperFor(Class<?> iface) throws SQLException {
1:             return realDataSource.isWrapperFor(iface);
1:         }
1:     }
1: 
1:     private class AutoCommitCheckConnection implements Connection {
1: 
1:         private final Connection realConnection;
1: 
1:         public AutoCommitCheckConnection(Connection connection) {
1:             this.realConnection = connection;
1:         }
1: 
1:         // verify commit is not called on an auto-commit connection
1:         @Override
1:         public void commit() throws SQLException {
1:             if (getAutoCommit() == true) {
1:                 throw new SQLException("AutoCommitCheckConnection: Called commit on autoCommit Connection");
1:             }
1:             realConnection.commit();
1:         }
1: 
1:         // Just plumbing for wrapper. Might have been better to do a Dynamic Proxy here.
1: 
1:         @Override
1:         public Statement createStatement() throws SQLException {
1:             return realConnection.createStatement();
1:         }
1: 
1:         @Override
1:         public PreparedStatement prepareStatement(String sql) throws SQLException {
1:             return realConnection.prepareStatement(sql);
1:         }
1: 
1:         @Override
1:         public CallableStatement prepareCall(String sql) throws SQLException {
1:             return realConnection.prepareCall(sql);
1:         }
1: 
1:         @Override
1:         public String nativeSQL(String sql) throws SQLException {
1:             return realConnection.nativeSQL(sql);
1:         }
1: 
1:         @Override
1:         public void setAutoCommit(boolean autoCommit) throws SQLException {
1:             realConnection.setAutoCommit(autoCommit);
1:         }
1: 
1:         @Override
1:         public boolean getAutoCommit() throws SQLException {
1:             return realConnection.getAutoCommit();
1:         }
1: 
1:         @Override
1:         public void rollback() throws SQLException {
1:             realConnection.rollback();
1:         }
1: 
1:         @Override
1:         public void close() throws SQLException {
1:             realConnection.close();
1:         }
1: 
1:         @Override
1:         public boolean isClosed() throws SQLException {
1:             return realConnection.isClosed();
1:         }
1: 
1:         @Override
1:         public DatabaseMetaData getMetaData() throws SQLException {
1:             return realConnection.getMetaData();
1:         }
1: 
1:         @Override
1:         public void setReadOnly(boolean readOnly) throws SQLException {
1:             realConnection.setReadOnly(readOnly);
1:         }
1: 
1:         @Override
1:         public boolean isReadOnly() throws SQLException {
1:             return realConnection.isReadOnly();
1:         }
1: 
1:         @Override
1:         public void setCatalog(String catalog) throws SQLException {
1:             realConnection.setCatalog(catalog);
1:         }
1: 
1:         @Override
1:         public String getCatalog() throws SQLException {
1:             return realConnection.getCatalog();
1:         }
1: 
1:         @Override
1:         public void setTransactionIsolation(int level) throws SQLException {
1:             realConnection.setTransactionIsolation(level);
1:         }
1: 
1:         @Override
1:         public int getTransactionIsolation() throws SQLException {
1:             return realConnection.getTransactionIsolation();
1:         }
1: 
1:         @Override
1:         public SQLWarning getWarnings() throws SQLException {
1:             return realConnection.getWarnings();
1:         }
1: 
1:         @Override
1:         public void clearWarnings() throws SQLException {
1:             realConnection.clearWarnings();
1:         }
1: 
1:         @Override
1:         public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
1:             return realConnection.createStatement(resultSetType, resultSetConcurrency);
1:         }
1: 
1:         @Override
1:         public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
1:             return realConnection.prepareStatement(sql, resultSetType, resultSetConcurrency);
1:         }
1: 
1:         @Override
1:         public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
1:             return realConnection.prepareCall(sql, resultSetType, resultSetConcurrency);
1:         }
1: 
1:         @Override
1:         public Map<String, Class<?>> getTypeMap() throws SQLException {
1:             return realConnection.getTypeMap();
1:         }
1: 
1:         @Override
1:         public void setTypeMap(Map<String, Class<?>> map) throws SQLException {
1:             realConnection.setTypeMap(map);
1:         }
1: 
1:         @Override
1:         public void setHoldability(int holdability) throws SQLException {
1:             realConnection.setHoldability(holdability);
1:         }
1: 
1:         @Override
1:         public int getHoldability() throws SQLException {
1:             return realConnection.getHoldability();
1:         }
1: 
1:         @Override
1:         public Savepoint setSavepoint() throws SQLException {
1:             return realConnection.setSavepoint();
1:         }
1: 
1:         @Override
1:         public Savepoint setSavepoint(String name) throws SQLException {
1:             return realConnection.setSavepoint(name);
1:         }
1: 
1:         @Override
1:         public void rollback(Savepoint savepoint) throws SQLException {
1:             realConnection.rollback();
1:         }
1: 
1:         @Override
1:         public void releaseSavepoint(Savepoint savepoint) throws SQLException {
1:             realConnection.releaseSavepoint(savepoint);
1:         }
1: 
1:         @Override
1:         public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
1:             return realConnection.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
1:         }
1: 
1:         @Override
1:         public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
1:             return realConnection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
1:         }
1: 
1:         @Override
1:         public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
1:             return realConnection.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
1:         }
1: 
1:         @Override
1:         public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
1:             return realConnection.prepareStatement(sql, autoGeneratedKeys);
1:         }
1: 
1:         @Override
1:         public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
1:             return realConnection.prepareStatement(sql, columnIndexes);
1:         }
1: 
1:         @Override
1:         public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
1:             return realConnection.prepareStatement(sql, columnNames);
1:         }
1: 
1:         @Override
1:         public Clob createClob() throws SQLException {
1:             return realConnection.createClob();
1:         }
1: 
1:         @Override
1:         public Blob createBlob() throws SQLException {
1:             return realConnection.createBlob();
1:         }
1: 
1:         @Override
1:         public NClob createNClob() throws SQLException {
1:             return realConnection.createNClob();
1:         }
1: 
1:         @Override
1:         public SQLXML createSQLXML() throws SQLException {
1:             return realConnection.createSQLXML();
1:         }
1: 
1:         @Override
1:         public boolean isValid(int timeout) throws SQLException {
1:             return realConnection.isValid(timeout);
1:         }
1: 
1:         @Override
1:         public void setClientInfo(String name, String value) throws SQLClientInfoException {
1:             realConnection.setClientInfo(name, value);
1:         }
1: 
1:         @Override
1:         public void setClientInfo(Properties properties) throws SQLClientInfoException {
1:             realConnection.setClientInfo(properties);
1:         }
1: 
1:         @Override
1:         public String getClientInfo(String name) throws SQLException {
1:             return realConnection.getClientInfo(name);
1:         }
1: 
1:         @Override
1:         public Properties getClientInfo() throws SQLException {
1:             return realConnection.getClientInfo();
1:         }
1: 
1:         @Override
1:         public Array createArrayOf(String typeName, Object[] elements) throws SQLException {
1:             return realConnection.createArrayOf(typeName, elements);
1:         }
1: 
1:         @Override
1:         public Struct createStruct(String typeName, Object[] attributes) throws SQLException {
1:             return realConnection.createStruct(typeName, attributes);
1:         }
1: 
1:         @Override
1:         public void setSchema(String schema) throws SQLException {
1:             realConnection.setSchema(schema);
1:         }
1: 
1:         @Override
1:         public String getSchema() throws SQLException {
1:             return realConnection.getSchema();
1:         }
1: 
1:         @Override
1:         public void abort(Executor executor) throws SQLException {
1:             realConnection.abort(executor);
1:         }
1: 
1:         @Override
1:         public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {
1:             realConnection.setNetworkTimeout(executor, milliseconds);
1:         }
1: 
1:         @Override
1:         public int getNetworkTimeout() throws SQLException {
1:             return realConnection.getNetworkTimeout();
1:         }
1: 
1:         @Override
1:         public <T> T unwrap(Class<T> iface) throws SQLException {
1:             return realConnection.unwrap(iface);
1:         }
1: 
1:         @Override
1:         public boolean isWrapperFor(Class<?> iface) throws SQLException {
1:             return realConnection.isWrapperFor(iface);
1:         }
1:     }
1: }
============================================================================