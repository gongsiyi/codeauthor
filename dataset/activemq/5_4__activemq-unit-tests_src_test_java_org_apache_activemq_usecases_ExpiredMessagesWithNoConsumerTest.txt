1:6a121b3: /**
1:6a121b3:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:6a121b3:  * contributor license agreements.  See the NOTICE file distributed with
1:6a121b3:  * this work for additional information regarding copyright ownership.
1:6a121b3:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:6a121b3:  * (the "License"); you may not use this file except in compliance with
1:6a121b3:  * the License.  You may obtain a copy of the License at
1:6a121b3:  *
1:6a121b3:  *      http://www.apache.org/licenses/LICENSE-2.0
1:6a121b3:  *
1:6a121b3:  * Unless required by applicable law or agreed to in writing, software
1:6a121b3:  * distributed under the License is distributed on an "AS IS" BASIS,
1:6a121b3:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:6a121b3:  * See the License for the specific language governing permissions and
1:6a121b3:  * limitations under the License.
1:6a121b3:  */
1:6a121b3: package org.apache.activemq.usecases;
1:5619cd0: 
1:2d84bbd: import java.util.concurrent.CountDownLatch;
1:2d84bbd: import java.util.concurrent.TimeUnit;
1:2d84bbd: import java.util.concurrent.atomic.AtomicLong;
1:2d84bbd: 
1:2d84bbd: import javax.jms.Connection;
1:2d84bbd: import javax.jms.DeliveryMode;
1:2d84bbd: import javax.jms.Message;
1:2d84bbd: import javax.jms.MessageConsumer;
1:2d84bbd: import javax.jms.MessageListener;
1:2d84bbd: import javax.jms.MessageProducer;
1:2d84bbd: import javax.jms.Session;
1:2d84bbd: import javax.jms.Topic;
1:2d84bbd: import javax.jms.TopicSubscriber;
1:2d84bbd: import javax.management.ObjectName;
1:2d84bbd: 
1:3536b1e: import junit.framework.Test;
1:2d84bbd: 
1:6a121b3: import org.apache.activemq.ActiveMQConnectionFactory;
1:6a121b3: import org.apache.activemq.CombinationTestSupport;
1:6a121b3: import org.apache.activemq.broker.BrokerService;
1:6a121b3: import org.apache.activemq.broker.jmx.DestinationViewMBean;
1:5619cd0: import org.apache.activemq.broker.region.policy.FilePendingQueueMessageStoragePolicy;
1:5619cd0: import org.apache.activemq.broker.region.policy.PendingQueueMessageStoragePolicy;
1:6a121b3: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:6a121b3: import org.apache.activemq.broker.region.policy.PolicyMap;
1:5619cd0: import org.apache.activemq.broker.region.policy.VMPendingQueueMessageStoragePolicy;
1:6a121b3: import org.apache.activemq.command.ActiveMQDestination;
1:6a121b3: import org.apache.activemq.command.ActiveMQQueue;
1:ed3f61a: import org.apache.activemq.command.ActiveMQTopic;
1:ca242f4: import org.apache.activemq.util.Wait;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:3536b1e: 
1:6a121b3: public class ExpiredMessagesWithNoConsumerTest extends CombinationTestSupport {
1:3536b1e: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(ExpiredMessagesWithNoConsumerTest.class);
1:b0f9afa: 
1:d8b5e2d:     private final ActiveMQDestination destination = new ActiveMQQueue("test");
1:b0f9afa: 
1:d8b5e2d:     private boolean optimizedDispatch = true;
1:d8b5e2d:     private PendingQueueMessageStoragePolicy pendingQueuePolicy;
1:d8b5e2d: 
1:d8b5e2d:     private BrokerService broker;
1:d8b5e2d:     private String connectionUri;
1:d8b5e2d:     private Connection connection;
1:d8b5e2d:     private Session session;
1:d8b5e2d:     private MessageProducer producer;
1:3536b1e: 
1:6a121b3:     public static Test suite() {
1:6a121b3:         return suite(ExpiredMessagesWithNoConsumerTest.class);
1:7a59d28:     }
1:e6a9ae2: 
1:6a121b3:     public static void main(String[] args) {
1:6a121b3:         junit.textui.TestRunner.run(suite());
1:7a59d28:     }
1:b0f9afa: 
1:7a59d28:     protected void createBrokerWithMemoryLimit() throws Exception {
1:e6a9ae2:         createBrokerWithMemoryLimit(800);
1:e6a9ae2:     }
1:b0f9afa: 
1:e6a9ae2:     protected void createBrokerWithMemoryLimit(int expireMessagesPeriod) throws Exception {
1:e6a9ae2:         doCreateBroker(true, expireMessagesPeriod);
1:7a59d28:     }
1:ca66801: 
1:7a59d28:     protected void createBroker() throws Exception {
1:e6a9ae2:         doCreateBroker(false, 800);
1:7a59d28:     }
1:b0f9afa: 
1:e6a9ae2:     private void doCreateBroker(boolean memoryLimit, int expireMessagesPeriod) throws Exception {
1:7a59d28:         broker = new BrokerService();
1:7a59d28:         broker.setBrokerName("localhost");
1:7a59d28:         broker.setUseJmx(true);
1:7a59d28:         broker.setDeleteAllMessagesOnStartup(true);
1:d8b5e2d:         broker.addConnector("tcp://localhost:0");
1:ca66801: 
1:7a59d28:         PolicyMap policyMap = new PolicyMap();
1:7a59d28:         PolicyEntry defaultEntry = new PolicyEntry();
1:d8b5e2d:         defaultEntry.setOptimizedDispatch(optimizedDispatch);
1:e6a9ae2:         defaultEntry.setExpireMessagesPeriod(expireMessagesPeriod);
1:ca242f4:         defaultEntry.setMaxExpirePageSize(800);
1:b0f9afa: 
1:5619cd0:         defaultEntry.setPendingQueuePolicy(pendingQueuePolicy);
1:ca242f4: 
1:7a59d28:         if (memoryLimit) {
1:7a59d28:             // so memory is not consumed by DLQ turn if off
1:7a59d28:             defaultEntry.setDeadLetterStrategy(null);
1:7a59d28:             defaultEntry.setMemoryLimit(200 * 1000);
1:7a59d28:         }
1:7a59d28: 
1:7a59d28:         policyMap.setDefaultEntry(defaultEntry);
1:d8b5e2d: 
1:6a121b3:         broker.setDestinationPolicy(policyMap);
1:7a59d28:         broker.start();
1:7a59d28:         broker.waitUntilStarted();
1:d8b5e2d: 
1:d8b5e2d:         connectionUri = broker.getTransportConnectors().get(0).getPublishableConnectString();
1:f7804bd:     }
1:b0f9afa: 
1:e6a9ae2:     public void testExpiredNonPersistentMessagesWithNoConsumer() throws Exception {
1:e6a9ae2: 
1:e6a9ae2:         createBrokerWithMemoryLimit(2000);
1:e6a9ae2: 
1:e6a9ae2:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(connectionUri);
1:e6a9ae2:         connection = factory.createConnection();
1:e6a9ae2:         session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:e6a9ae2:         producer = session.createProducer(destination);
1:e6a9ae2:         producer.setTimeToLive(1000);
1:e6a9ae2:         producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:e6a9ae2:         connection.start();
1:e6a9ae2:         final long sendCount = 2000;
1:e6a9ae2: 
1:e6a9ae2:         final Thread producingThread = new Thread("Producing Thread") {
1:2d84bbd:             @Override
1:e6a9ae2:             public void run() {
1:e6a9ae2:                 try {
1:e6a9ae2:                     int i = 0;
1:e6a9ae2:                     long tStamp = System.currentTimeMillis();
1:e6a9ae2:                     while (i++ < sendCount) {
1:e6a9ae2:                         producer.send(session.createTextMessage("test"));
1:e6a9ae2:                         if (i%100 == 0) {
1:e6a9ae2:                             LOG.info("sent: " + i + " @ " + ((System.currentTimeMillis() - tStamp) / 100)  + "m/ms");
1:e6a9ae2:                             tStamp = System.currentTimeMillis() ;
1:e6a9ae2:                         }
1:e6a9ae2: 
1:e6a9ae2:                         if (135 == i) {
1:e6a9ae2:                             // allow pending messages to expire, before usage limit kicks in  to flush them
1:e6a9ae2:                             TimeUnit.SECONDS.sleep(5);
1:e6a9ae2:                         }
1:e6a9ae2:                     }
1:e6a9ae2:                 } catch (Throwable ex) {
1:e6a9ae2:                     ex.printStackTrace();
1:e6a9ae2:                 }
1:e6a9ae2:             }
1:e6a9ae2:         };
1:b0f9afa: 
1:e6a9ae2:         producingThread.start();
1:b0f9afa: 
1:b0f9afa:         assertTrue("producer failed to complete within allocated time", Wait.waitFor(new Wait.Condition() {
1:2d84bbd:             @Override
1:e6a9ae2:             public boolean isSatisified() throws Exception {
1:1e1b568:                 producingThread.join(TimeUnit.SECONDS.toMillis(3000));
1:e6a9ae2:                 return !producingThread.isAlive();
1:b0f9afa:             }
1:b0f9afa:         }));
1:2d84bbd: 
1:e6a9ae2:         TimeUnit.SECONDS.sleep(5);
1:2d84bbd: 
1:e6a9ae2:         final DestinationViewMBean view = createView(destination);
1:b0f9afa:         Wait.waitFor(new Wait.Condition() {
1:2d84bbd:             @Override
1:2d84bbd:             public boolean isSatisified() throws Exception {
1:e6a9ae2:                 try {
1:b0f9afa:                 LOG.info("enqueue=" + view.getEnqueueCount() + ", dequeue=" + view.getDequeueCount()
1:b0f9afa:                         + ", inflight=" + view.getInFlightCount() + ", expired= " + view.getExpiredCount()
1:b0f9afa:                         + ", size= " + view.getQueueSize());
1:e6a9ae2:                 return view.getDequeueCount() != 0
1:e6a9ae2:                         && view.getDequeueCount() == view.getExpiredCount()
1:e6a9ae2:                         && view.getDequeueCount() == view.getEnqueueCount()
1:e6a9ae2:                         && view.getQueueSize() == 0;
1:e6a9ae2:                 } catch (Exception ignored) {
1:e6a9ae2:                     LOG.info(ignored.toString());
1:2d84bbd:                 }
1:e6a9ae2:                 return false;
1:e6a9ae2:             }
1:e6a9ae2:         }, Wait.MAX_WAIT_MILLIS * 10);
1:e6a9ae2:         LOG.info("enqueue=" + view.getEnqueueCount() + ", dequeue=" + view.getDequeueCount()
1:e6a9ae2:                 + ", inflight=" + view.getInFlightCount() + ", expired= " + view.getExpiredCount()
1:e6a9ae2:                 + ", size= " + view.getQueueSize());
1:b0f9afa: 
1:e6a9ae2:         assertEquals("memory usage doesn't go to duck egg", 0, view.getMemoryPercentUsage());
1:e6a9ae2:         assertEquals("0 queue", 0, view.getQueueSize());
1:e6a9ae2:     }
1:b0f9afa: 
1:b0f9afa: 
1:f7804bd:     public void initCombosForTestExpiredMessagesWithNoConsumer() {
1:f7804bd:         addCombinationValues("optimizedDispatch", new Object[] {Boolean.TRUE, Boolean.FALSE});
1:5619cd0:         addCombinationValues("pendingQueuePolicy", new Object[] {null, new VMPendingQueueMessageStoragePolicy(), new FilePendingQueueMessageStoragePolicy()});
1:e6a9ae2:     }
1:b0f9afa: 
1:b0f9afa:     public void testExpiredMessagesWithNoConsumer() throws Exception {
1:b0f9afa: 
1:b0f9afa:         createBrokerWithMemoryLimit();
1:b0f9afa: 
1:d8b5e2d:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(connectionUri);
1:b0f9afa:         connection = factory.createConnection();
1:b0f9afa:         session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:b0f9afa:         producer = session.createProducer(destination);
1:b0f9afa:         producer.setTimeToLive(1000);
1:7a59d28:         connection.start();
1:b0f9afa:         final long sendCount = 2000;
1:b0f9afa: 
1:ca242f4:         final Thread producingThread = new Thread("Producing Thread") {
1:2d84bbd:             @Override
1:7a59d28:             public void run() {
2:7a59d28:                 try {
1:7a59d28:                     int i = 0;
1:7a59d28:                     long tStamp = System.currentTimeMillis();
1:7a59d28:                     while (i++ < sendCount) {
1:6a121b3:                         producer.send(session.createTextMessage("test"));
1:7a59d28:                         if (i%100 == 0) {
1:7a59d28:                             LOG.info("sent: " + i + " @ " + ((System.currentTimeMillis() - tStamp) / 100)  + "m/ms");
1:7a59d28:                             tStamp = System.currentTimeMillis() ;
1:e6a9ae2:                         }
1:ca242f4:                     }
1:7a59d28:                 } catch (Throwable ex) {
1:7a59d28:                     ex.printStackTrace();
1:ca242f4:                 }
1:ca242f4:             }
1:7a59d28:         };
1:e6a9ae2: 
1:7a59d28:         producingThread.start();
1:e6a9ae2: 
1:e6a9ae2:         assertTrue("producer failed to complete within allocated time", Wait.waitFor(new Wait.Condition() {
1:2d84bbd:             @Override
1:b0f9afa:             public boolean isSatisified() throws Exception {
1:e6a9ae2:                 producingThread.join(TimeUnit.SECONDS.toMillis(3000));
1:ca242f4:                 return !producingThread.isAlive();
1:7a59d28:             }
1:e6a9ae2:         }));
1:e6a9ae2: 
1:ca242f4:         final DestinationViewMBean view = createView(destination);
1:e6a9ae2:         Wait.waitFor(new Wait.Condition() {
1:2d84bbd:             @Override
1:e6a9ae2:             public boolean isSatisified() throws Exception {
1:e6a9ae2:                 LOG.info("enqueue=" + view.getEnqueueCount() + ", dequeue=" + view.getDequeueCount()
1:e6a9ae2:                         + ", inflight=" + view.getInFlightCount() + ", expired= " + view.getExpiredCount()
1:e6a9ae2:                         + ", size= " + view.getQueueSize());
1:b0f9afa:                 return sendCount == view.getExpiredCount();
1:b0f9afa:             }
1:b9b67d0:         }, Wait.MAX_WAIT_MILLIS * 10);
1:b0f9afa:         LOG.info("enqueue=" + view.getEnqueueCount() + ", dequeue=" + view.getDequeueCount()
1:b0f9afa:                 + ", inflight=" + view.getInFlightCount() + ", expired= " + view.getExpiredCount()
1:b0f9afa:                 + ", size= " + view.getQueueSize());
1:b0f9afa: 
1:d8b5e2d:         assertEquals("Not all sent messages have expired", sendCount, view.getExpiredCount());
1:d8b5e2d:         assertEquals("memory usage doesn't go to duck egg", 0, view.getMemoryPercentUsage());
1:b0f9afa:     }
1:b0f9afa: 
1:b0f9afa:     // first ack delivered after expiry
1:b0f9afa:     public void testExpiredMessagesWithVerySlowConsumer() throws Exception {
1:b0f9afa:         createBroker();
1:26807cd:         final long queuePrefetch = 5;
1:d8b5e2d:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(
1:d8b5e2d:                 connectionUri + "?jms.prefetchPolicy.queuePrefetch=" + queuePrefetch);
1:b0f9afa:         connection = factory.createConnection();
1:b0f9afa:         session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:b0f9afa:         producer = session.createProducer(destination);
1:b0f9afa:         final int ttl = 4000;
1:b0f9afa:         producer.setTimeToLive(ttl);
1:b0f9afa: 
1:26807cd:         final long sendCount = 10;
1:ca66801:         final CountDownLatch receivedOneCondition = new CountDownLatch(1);
1:ca66801:         final CountDownLatch waitCondition = new CountDownLatch(1);
1:b0f9afa: 
1:ca66801:         MessageConsumer consumer = session.createConsumer(destination);
1:ca66801:         consumer.setMessageListener(new MessageListener() {
1:b0f9afa: 
1:2d84bbd:             @Override
1:ca66801:             public void onMessage(Message message) {
1:b0f9afa:                 try {
1:b0f9afa:                     LOG.info("Got my message: " + message);
1:ca66801:                     receivedOneCondition.countDown();
1:d8b5e2d:                     waitCondition.await(6, TimeUnit.MINUTES);
1:b0f9afa:                     LOG.info("acking message: " + message);
1:ca66801:                     message.acknowledge();
1:ca66801:                 } catch (Exception e) {
1:ca66801:                     e.printStackTrace();
1:ca66801:                     fail(e.toString());
1:ca66801:                 }
1:ca66801:             }
1:b0f9afa:         });
1:b0f9afa: 
1:ca66801:         connection.start();
1:b0f9afa: 
1:ca66801:         final Thread producingThread = new Thread("Producing Thread") {
1:2d84bbd:             @Override
1:ca66801:             public void run() {
1:ca66801:                 try {
1:ca66801:                     int i = 0;
1:ca66801:                     long tStamp = System.currentTimeMillis();
1:ca66801:                     while (i++ < sendCount) {
1:ca66801:                         producer.send(session.createTextMessage("test"));
1:ca66801:                         if (i%100 == 0) {
1:ca66801:                             LOG.info("sent: " + i + " @ " + ((System.currentTimeMillis() - tStamp) / 100)  + "m/ms");
1:ca66801:                             tStamp = System.currentTimeMillis() ;
1:b0f9afa:                         }
1:b0f9afa:                     }
1:ca66801:                 } catch (Throwable ex) {
1:ca66801:                     ex.printStackTrace();
1:ca66801:                 }
1:ca66801:             }
1:ca66801:         };
1:e6a9ae2: 
1:ca66801:         producingThread.start();
1:ca66801:         assertTrue("got one message", receivedOneCondition.await(20, TimeUnit.SECONDS));
1:e6a9ae2: 
1:b0f9afa:         assertTrue("producer failed to complete within allocated time", Wait.waitFor(new Wait.Condition() {
1:2d84bbd:             @Override
1:ca66801:             public boolean isSatisified() throws Exception {
1:ca66801:                 producingThread.join(1000);
1:ca66801:                 return !producingThread.isAlive();
1:b0f9afa:             }
1:d8b5e2d:         }, Wait.MAX_WAIT_MILLIS * 10));
1:b0f9afa: 
1:ca66801:         final DestinationViewMBean view = createView(destination);
1:b0f9afa: 
1:ca66801:         assertTrue("all dispatched up to default prefetch ", Wait.waitFor(new Wait.Condition() {
1:2d84bbd:             @Override
1:ca242f4:             public boolean isSatisified() throws Exception {
1:83df5ce:                 return queuePrefetch == view.getDispatchCount();
1:ca242f4:             }
1:b0f9afa:         }));
1:26807cd:         assertTrue("all non inflight have expired ", Wait.waitFor(new Wait.Condition() {
1:2d84bbd:             @Override
1:ca242f4:             public boolean isSatisified() throws Exception {
1:26807cd:                 LOG.info("enqueue=" + view.getEnqueueCount() + ", dequeue=" + view.getDequeueCount()
1:26807cd:                         + ", inflight=" + view.getInFlightCount() + ", expired= " + view.getExpiredCount()
1:26807cd:                         + ", size= " + view.getQueueSize());
1:26807cd: 
1:26807cd:                 return view.getExpiredCount() > 0 && (view.getEnqueueCount() - view.getInFlightCount()) == view.getExpiredCount();
1:ca242f4:             }
1:ca66801:         }));
1:26807cd: 
1:26807cd:         LOG.info("enqueue=" + view.getEnqueueCount() + ", dequeue=" + view.getDequeueCount()
1:26807cd:                 + ", inflight=" + view.getInFlightCount() + ", expired= " + view.getExpiredCount()
1:26807cd:                 + ", size= " + view.getQueueSize());
1:26807cd: 
1:7a59d28:         // let the ack happen
1:7a59d28:         waitCondition.countDown();
1:b0f9afa: 
1:ca242f4:         Wait.waitFor(new Wait.Condition() {
1:2d84bbd:             @Override
4:ca242f4:             public boolean isSatisified() throws Exception {
1:a8a7693:                 return 0 == view.getInFlightCount();
1:ca242f4:             }
1:ca66801:         });
1:3536b1e:         LOG.info("enqueue=" + view.getEnqueueCount() + ", dequeue=" + view.getDequeueCount()
1:3536b1e:                 + ", inflight=" + view.getInFlightCount() + ", expired= " + view.getExpiredCount()
1:3536b1e:                 + ", size= " + view.getQueueSize());
1:e6a9ae2: 
1:a8a7693:         assertEquals("inflight reduced to duck",
1:a8a7693:                      0, view.getInFlightCount());
1:d8b5e2d:         assertEquals("size didn't get back to 0 ", 0, view.getQueueSize());
1:d8b5e2d:         assertEquals("dequeues didn't match sent/expired ", sendCount, view.getDequeueCount());
1:ca66801: 
1:7a59d28:         consumer.close();
1:b0f9afa: 
1:83df5ce:         Wait.waitFor(new Wait.Condition() {
1:2d84bbd:             @Override
1:83df5ce:             public boolean isSatisified() throws Exception {
1:a8a7693:                 return 0 == view.getInFlightCount();
1:83df5ce:             }
1:83df5ce:         });
1:a8a7693:         assertEquals("inflight goes to zero on close", 0, view.getInFlightCount());
1:b0f9afa: 
1:7a59d28:         LOG.info("done: " + getName());
1:ca66801:     }
1:ca66801: 
1:ca66801:     public void testExpiredMessagesWithVerySlowConsumerCanContinue() throws Exception {
1:ca66801:         createBroker();
1:b0f9afa:         final long queuePrefetch = 600;
1:d8b5e2d:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(
1:d8b5e2d:                 connectionUri + "?jms.prefetchPolicy.queuePrefetch=" + queuePrefetch);
1:ca66801:         connection = factory.createConnection();
1:ca66801:         session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:ca66801:         producer = session.createProducer(destination);
1:ca66801:         final int ttl = 4000;
1:ca66801:         producer.setTimeToLive(ttl);
1:ca66801: 
1:b0f9afa:         final long sendCount = 1500;
1:b0f9afa:         final CountDownLatch receivedOneCondition = new CountDownLatch(1);
1:b0f9afa:         final CountDownLatch waitCondition = new CountDownLatch(1);
1:ca66801:         final AtomicLong received = new AtomicLong();
1:b0f9afa:         MessageConsumer consumer = session.createConsumer(destination);
1:b0f9afa:         consumer.setMessageListener(new MessageListener() {
1:b0f9afa: 
1:2d84bbd:             @Override
1:b0f9afa:             public void onMessage(Message message) {
1:b0f9afa:                 try {
1:d8b5e2d:                     if(LOG.isDebugEnabled()) {
1:d8b5e2d:                         LOG.debug("Got my message: " + message);
1:d8b5e2d:                     }
1:b0f9afa:                     receivedOneCondition.countDown();
1:ca66801:                     received.incrementAndGet();
1:d8b5e2d:                     waitCondition.await(5, TimeUnit.MINUTES);
1:d8b5e2d:                     if(LOG.isDebugEnabled()) {
1:d8b5e2d:                         LOG.debug("acking message: " + message);
1:d8b5e2d:                     }
1:b0f9afa:                     message.acknowledge();
1:b0f9afa:                 } catch (Exception e) {
1:b0f9afa:                     e.printStackTrace();
1:b0f9afa:                     fail(e.toString());
1:b0f9afa:                 }
1:b0f9afa:             }
1:b0f9afa:         });
1:b0f9afa: 
1:b0f9afa:         connection.start();
1:b0f9afa: 
1:b0f9afa:         final Thread producingThread = new Thread("Producing Thread") {
1:2d84bbd:             @Override
1:b0f9afa:             public void run() {
1:ca66801:                 try {
1:b0f9afa:                     int i = 0;
1:b0f9afa:                     long tStamp = System.currentTimeMillis();
1:b0f9afa:                     while (i++ < sendCount) {
1:b0f9afa:                         producer.send(session.createTextMessage("test"));
1:b0f9afa:                         if (i%100 == 0) {
1:b0f9afa:                             LOG.info("sent: " + i + " @ " + ((System.currentTimeMillis() - tStamp) / 100)  + "m/ms");
1:b0f9afa:                             tStamp = System.currentTimeMillis() ;
1:b0f9afa:                         }
1:b0f9afa:                     }
1:b0f9afa:                 } catch (Throwable ex) {
1:b0f9afa:                     ex.printStackTrace();
1:ca66801:                 }
1:ca66801:             }
1:b0f9afa:         };
1:b0f9afa: 
1:b0f9afa:         producingThread.start();
1:b0f9afa:         assertTrue("got one message", receivedOneCondition.await(20, TimeUnit.SECONDS));
1:b0f9afa: 
1:b0f9afa:         assertTrue("producer failed to complete within allocated time", Wait.waitFor(new Wait.Condition() {
1:2d84bbd:             @Override
1:b0f9afa:             public boolean isSatisified() throws Exception {
1:b0f9afa:                 producingThread.join(1000);
1:b0f9afa:                 return !producingThread.isAlive();
1:ca66801:             }
1:d8b5e2d:         }, Wait.MAX_WAIT_MILLIS * 10));
1:ca66801: 
1:b0f9afa:         final DestinationViewMBean view = createView(destination);
1:ca66801: 
1:d8b5e2d:         assertTrue("Not all dispatched up to default prefetch ", Wait.waitFor(new Wait.Condition() {
1:2d84bbd:             @Override
1:ca66801:             public boolean isSatisified() throws Exception {
1:ca66801:                 return queuePrefetch == view.getDispatchCount();
1:ca66801:             }
1:ca66801:         }));
1:ca66801: 
1:26807cd:         assertTrue("all non inflight have expired ", Wait.waitFor(new Wait.Condition() {
1:2d84bbd:             @Override
1:ca66801:             public boolean isSatisified() throws Exception {
1:ca66801:                 LOG.info("enqueue=" + view.getEnqueueCount() + ", dequeue=" + view.getDequeueCount()
1:ca66801:                         + ", inflight=" + view.getInFlightCount() + ", expired= " + view.getExpiredCount()
1:ca66801:                         + ", size= " + view.getQueueSize());
1:ca66801: 
1:26807cd:                 return view.getExpiredCount() > 0 && (view.getEnqueueCount() - view.getInFlightCount()) == view.getExpiredCount();
1:ca66801:             }
1:ca66801:         }));
1:ca66801: 
1:ca66801:         LOG.info("enqueue=" + view.getEnqueueCount() + ", dequeue=" + view.getDequeueCount()
1:ca66801:                 + ", inflight=" + view.getInFlightCount() + ", expired= " + view.getExpiredCount()
1:ca66801:                 + ", size= " + view.getQueueSize());
1:ca66801: 
1:ca66801:         // let the ack happen
1:ca66801:         waitCondition.countDown();
1:ca66801: 
1:ca66801:         Wait.waitFor(new Wait.Condition() {
1:2d84bbd:             @Override
1:ca66801:             public boolean isSatisified() throws Exception {
1:83df5ce:                 return 0 == view.getInFlightCount();
1:7a59d28:             }
1:ca66801:         });
1:ca242f4:         LOG.info("enqueue=" + view.getEnqueueCount() + ", dequeue=" + view.getDequeueCount()
1:ca242f4:                 + ", inflight=" + view.getInFlightCount() + ", expired= " + view.getExpiredCount()
1:ca242f4:                 + ", size= " + view.getQueueSize());
1:ca66801: 
1:a8a7693:         assertEquals("inflight didn't reduce to duck",
1:a8a7693:                      0, view.getInFlightCount());
1:d8b5e2d:         assertEquals("size doesn't get back to 0 ", 0, view.getQueueSize());
1:d8b5e2d:         assertEquals("dequeues don't match sent/expired ", sendCount, view.getDequeueCount());
1:ca66801: 
1:ca66801:         // produce some more
1:ca66801:         producer.setTimeToLive(0);
1:d8b5e2d:         long tStamp = System.currentTimeMillis();
1:ca66801:         for (int i=0; i<sendCount; i++) {
1:ca66801:             producer.send(session.createTextMessage("test-" + i));
1:d8b5e2d:             if (i%100 == 0) {
1:d8b5e2d:                 LOG.info("sent: " + i + " @ " + ((System.currentTimeMillis() - tStamp) / 100)  + "m/ms");
1:d8b5e2d:                 tStamp = System.currentTimeMillis() ;
1:d8b5e2d:             }
1:ca66801:         }
1:ca66801: 
1:ca66801:         Wait.waitFor(new Wait.Condition() {
1:2d84bbd:              @Override
1:ca66801:             public boolean isSatisified() throws Exception {
1:ca66801:                  return received.get() >= sendCount;
1:ca66801:              }
1:ca66801:          });
1:ca66801: 
1:ca66801:         consumer.close();
1:ca66801: 
1:ca66801:         Wait.waitFor(new Wait.Condition() {
1:2d84bbd:             @Override
1:ca66801:             public boolean isSatisified() throws Exception {
1:ca66801:                 return 0 == view.getInFlightCount();
1:ca66801:             }
1:ca66801:         });
1:a8a7693:         assertEquals("inflight did not go to zero on close", 0, view.getInFlightCount());
1:ca66801: 
1:ca66801:         LOG.info("done: " + getName());
1:ca66801:     }
1:ca66801: 
1:ed3f61a:     public void testExpireMessagesForDurableSubscriber() throws Exception {
1:7a59d28:         createBroker();
1:d8b5e2d:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(connectionUri);
1:7a59d28:         connection = factory.createConnection();
1:ed3f61a:         connection.setClientID("myConnection");
1:7a59d28:         session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:6a121b3:         connection.start();
1:ed3f61a:         Topic destination = session.createTopic("test");
1:7a59d28:         producer = session.createProducer(destination);
1:47c392b:         final int ttl = 1000;
1:7a59d28:         producer.setTimeToLive(ttl);
1:ca66801: 
1:ed3f61a:         final long sendCount = 10;
1:ca66801: 
1:ed3f61a:         TopicSubscriber sub = session.createDurableSubscriber(destination, "mySub");
1:ed3f61a:         sub.close();
1:ca66801: 
1:ed3f61a:         for (int i=0; i < sendCount; i++) {
1:7a59d28:             producer.send(session.createTextMessage("test"));
1:7a59d28:         }
1:ca66801: 
1:ed3f61a:         DestinationViewMBean view = createView((ActiveMQTopic)destination);
1:83df5ce: 
1:ed3f61a:         LOG.info("messages sent");
1:ed3f61a:         LOG.info("expired=" + view.getExpiredCount() + " " +  view.getEnqueueCount());
1:ed3f61a:         assertEquals(0, view.getExpiredCount());
1:ed3f61a:         assertEquals(10, view.getEnqueueCount());
1:83df5ce: 
1:47c392b:         Thread.sleep(5000);
1:83df5ce: 
1:ed3f61a:         LOG.info("expired=" + view.getExpiredCount() + " " +  view.getEnqueueCount());
1:ed3f61a:         assertEquals(10, view.getExpiredCount());
1:649876b:         assertEquals(10, view.getEnqueueCount());
1:83df5ce: 
1:ed3f61a:         final AtomicLong received = new AtomicLong();
1:ed3f61a:         sub = session.createDurableSubscriber(destination, "mySub");
1:ed3f61a:         sub.setMessageListener(new MessageListener() {
1:ed3f61a:             @Override
1:7a59d28:             public void onMessage(Message message) {
1:ed3f61a:                 received.incrementAndGet();
1:7a59d28:             }
1:ca242f4:         });
1:3536b1e: 
1:ed3f61a:         LOG.info("Waiting for messages to arrive");
1:f7804bd: 
1:ca242f4:         Wait.waitFor(new Wait.Condition() {
1:2d84bbd:              @Override
1:2d84bbd:             public boolean isSatisified() throws Exception {
1:ed3f61a:                  return received.get() >= sendCount;
1:7a59d28:              }
1:ed3f61a:          }, 1000);
4:7a59d28: 
1:ed3f61a:         LOG.info("received=" + received.get());
1:ed3f61a:         LOG.info("expired=" + view.getExpiredCount() + " " +  view.getEnqueueCount());
1:7a59d28: 
1:ed3f61a:         assertEquals(0, received.get());
1:ed3f61a:         assertEquals(10, view.getExpiredCount());
1:0c08d62:         assertEquals(10, view.getEnqueueCount());
1:7a59d28:     }
1:7a59d28: 
1:b0f9afa:     protected DestinationViewMBean createView(ActiveMQDestination destination) throws Exception {
1:6a121b3:         String domain = "org.apache.activemq";
1:6a121b3:         ObjectName name;
1:6a121b3:         if (destination.isQueue()) {
1:2d84bbd:             name = new ObjectName(domain + ":type=Broker,brokerName=localhost,destinationType=Queue,destinationName=test");
1:6a121b3:         } else {
1:2d84bbd:             name = new ObjectName(domain + ":type=Broker,brokerName=localhost,destinationType=Topic,destinationName=test");
1:7a59d28:         }
1:2d84bbd: 
1:2d84bbd:         return (DestinationViewMBean) broker.getManagementContext().newProxyInstance(name, DestinationViewMBean.class, true);
12:6a121b3:     }
1:2d84bbd: 
1:2d84bbd:     @Override
1:b0f9afa:     protected void tearDown() throws Exception {
1:b0f9afa:         connection.stop();
1:b0f9afa:         broker.stop();
1:b0f9afa:         broker.waitUntilStopped();
1:b0f9afa:     }
1:b0f9afa: 
1:d8b5e2d:     public boolean getOptimizedDispatch() {
1:d8b5e2d:         return this.optimizedDispatch;
1:d8b5e2d:     }
1:b0f9afa: 
1:d8b5e2d:     public void setOptimizedDispatch(boolean option) {
1:d8b5e2d:         this.optimizedDispatch = option;
1:d8b5e2d:     }
1:7a59d28: 
1:d8b5e2d:     public PendingQueueMessageStoragePolicy getPendingQueuePolicy() {
1:d8b5e2d:         return this.pendingQueuePolicy;
1:d8b5e2d:     }
1:7a59d28: 
1:d8b5e2d:     public void setPendingQueuePolicy(PendingQueueMessageStoragePolicy policy) {
1:d8b5e2d:         this.pendingQueuePolicy = policy;
1:d8b5e2d:     }
1:6a121b3: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:26807cd
/////////////////////////////////////////////////////////////////////////
1:         final long queuePrefetch = 5;
/////////////////////////////////////////////////////////////////////////
1:         final long sendCount = 10;
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("all non inflight have expired ", Wait.waitFor(new Wait.Condition() {
1:                 LOG.info("enqueue=" + view.getEnqueueCount() + ", dequeue=" + view.getDequeueCount()
1:                         + ", inflight=" + view.getInFlightCount() + ", expired= " + view.getExpiredCount()
1:                         + ", size= " + view.getQueueSize());
1: 
1:                 return view.getExpiredCount() > 0 && (view.getEnqueueCount() - view.getInFlightCount()) == view.getExpiredCount();
/////////////////////////////////////////////////////////////////////////
1: 
1:         assertTrue("all non inflight have expired ", Wait.waitFor(new Wait.Condition() {
1:                 LOG.info("enqueue=" + view.getEnqueueCount() + ", dequeue=" + view.getDequeueCount()
1:                         + ", inflight=" + view.getInFlightCount() + ", expired= " + view.getExpiredCount()
1:                         + ", size= " + view.getQueueSize());
1: 
1:                 return view.getExpiredCount() > 0 && (view.getEnqueueCount() - view.getInFlightCount()) == view.getExpiredCount();
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:0c08d62
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(10, view.getEnqueueCount());
commit:649876b
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(10, view.getEnqueueCount());
commit:ef24cc9
commit:19bf943
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:2d84bbd
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicLong;
1: 
1: import javax.jms.Connection;
1: import javax.jms.DeliveryMode;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageListener;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: import javax.jms.Topic;
1: import javax.jms.TopicSubscriber;
1: import javax.management.ObjectName;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1: 
0:         for (ObjectName name : broker.getAdminView().getQueues()) {
0:             LOG.info("Broker Queue: {}", name);
1:         }
1: 
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:              @Override
1:             public boolean isSatisified() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:              @Override
1:             public boolean isSatisified() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:             name = new ObjectName(domain + ":type=Broker,brokerName=localhost,destinationType=Queue,destinationName=test");
1:             name = new ObjectName(domain + ":type=Broker,brokerName=localhost,destinationType=Topic,destinationName=test");
1: 
0:         LOG.info("Attempting to find Queue named: {}", name);
1: 
1:         return (DestinationViewMBean) broker.getManagementContext().newProxyInstance(name, DestinationViewMBean.class, true);
1:     @Override
commit:b9b67d0
/////////////////////////////////////////////////////////////////////////
1:         }, Wait.MAX_WAIT_MILLIS * 10);
commit:1e1b568
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.Connection;
0: import javax.jms.Message;
0: import javax.jms.MessageConsumer;
0: import javax.jms.MessageListener;
0: import javax.jms.MessageProducer;
0: import javax.jms.Session;
0: import javax.jms.Topic;
0: import javax.jms.TopicSubscriber;
/////////////////////////////////////////////////////////////////////////
1:                 producingThread.join(TimeUnit.SECONDS.toMillis(3000));
/////////////////////////////////////////////////////////////////////////
0:         }, Wait.MAX_WAIT_MILLIS * 5);
commit:d8b5e2d
/////////////////////////////////////////////////////////////////////////
1:     private final ActiveMQDestination destination = new ActiveMQQueue("test");
1:     private boolean optimizedDispatch = true;
1:     private PendingQueueMessageStoragePolicy pendingQueuePolicy;
1: 
1:     private BrokerService broker;
1:     private String connectionUri;
1:     private Connection connection;
1:     private Session session;
1:     private MessageProducer producer;
/////////////////////////////////////////////////////////////////////////
1:         broker.addConnector("tcp://localhost:0");
1:         defaultEntry.setOptimizedDispatch(optimizedDispatch);
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         connectionUri = broker.getTransportConnectors().get(0).getPublishableConnectString();
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(connectionUri);
/////////////////////////////////////////////////////////////////////////
0:                 producingThread.join(TimeUnit.SECONDS.toMillis(1000));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("Not all sent messages have expired", sendCount, view.getExpiredCount());
1:         assertEquals("memory usage doesn't go to duck egg", 0, view.getMemoryPercentUsage());
1:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(
1:                 connectionUri + "?jms.prefetchPolicy.queuePrefetch=" + queuePrefetch);
/////////////////////////////////////////////////////////////////////////
1:                     waitCondition.await(6, TimeUnit.MINUTES);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         }, Wait.MAX_WAIT_MILLIS * 10));
/////////////////////////////////////////////////////////////////////////
0:         assertTrue("Not all sent have expired ", Wait.waitFor(new Wait.Condition() {
/////////////////////////////////////////////////////////////////////////
0:         assertEquals("inflight didn't reduce to half prefetch minus single delivered message",
0:                      (queuePrefetch/2) -1, view.getInFlightCount());
1:         assertEquals("size didn't get back to 0 ", 0, view.getQueueSize());
1:         assertEquals("dequeues didn't match sent/expired ", sendCount, view.getDequeueCount());
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(
1:                 connectionUri + "?jms.prefetchPolicy.queuePrefetch=" + queuePrefetch);
/////////////////////////////////////////////////////////////////////////
1:                     if(LOG.isDebugEnabled()) {
1:                         LOG.debug("Got my message: " + message);
1:                     }
1:                     waitCondition.await(5, TimeUnit.MINUTES);
1:                     if(LOG.isDebugEnabled()) {
1:                         LOG.debug("acking message: " + message);
1:                     }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         }, Wait.MAX_WAIT_MILLIS * 10));
1:         assertTrue("Not all dispatched up to default prefetch ", Wait.waitFor(new Wait.Condition() {
0:         assertTrue("All have not sent have expired ", Wait.waitFor(new Wait.Condition() {
/////////////////////////////////////////////////////////////////////////
0:         assertEquals("inflight didn't reduce to half prefetch minus single delivered message",
0:                      (queuePrefetch/2) -1, view.getInFlightCount());
1:         assertEquals("size doesn't get back to 0 ", 0, view.getQueueSize());
1:         assertEquals("dequeues don't match sent/expired ", sendCount, view.getDequeueCount());
1:         long tStamp = System.currentTimeMillis();
1:             if (i%100 == 0) {
1:                 LOG.info("sent: " + i + " @ " + ((System.currentTimeMillis() - tStamp) / 100)  + "m/ms");
1:                 tStamp = System.currentTimeMillis() ;
1:             }
/////////////////////////////////////////////////////////////////////////
0:         assertEquals("inflight did not go to zeor on close", 0, view.getInFlightCount());
1:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(connectionUri);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public boolean getOptimizedDispatch() {
1:         return this.optimizedDispatch;
1:     }
1:     public void setOptimizedDispatch(boolean option) {
1:         this.optimizedDispatch = option;
1:     }
1:     public PendingQueueMessageStoragePolicy getPendingQueuePolicy() {
1:         return this.pendingQueuePolicy;
1:     }
1:     public void setPendingQueuePolicy(PendingQueueMessageStoragePolicy policy) {
1:         this.pendingQueuePolicy = policy;
1:     }
commit:b0f9afa
/////////////////////////////////////////////////////////////////////////
1: 
0:     BrokerService broker;
0:     Connection connection;
0:     Session session;
0:     MessageProducer producer;
0:     public ActiveMQDestination destination = new ActiveMQQueue("test");
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void testExpiredMessagesWithNoConsumer() throws Exception {
1: 
1:         createBrokerWithMemoryLimit();
1: 
0:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616");
1:         connection = factory.createConnection();
1:         session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         producer = session.createProducer(destination);
1:         producer.setTimeToLive(1000);
1:         final long sendCount = 2000;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         assertTrue("producer failed to complete within allocated time", Wait.waitFor(new Wait.Condition() {
1:             }
1:         }));
1: 
1:         Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 LOG.info("enqueue=" + view.getEnqueueCount() + ", dequeue=" + view.getDequeueCount()
1:                         + ", inflight=" + view.getInFlightCount() + ", expired= " + view.getExpiredCount()
1:                         + ", size= " + view.getQueueSize());
1:                 return sendCount == view.getExpiredCount();
1:             }
1:         });
1:         LOG.info("enqueue=" + view.getEnqueueCount() + ", dequeue=" + view.getDequeueCount()
1:                 + ", inflight=" + view.getInFlightCount() + ", expired= " + view.getExpiredCount()
1:                 + ", size= " + view.getQueueSize());
1: 
0:         assertEquals("All sent have expired", sendCount, view.getExpiredCount());
0:         assertEquals("memory usage goes to duck egg", 0, view.getMemoryPercentUsage());
1:     }
1: 
1:     // first ack delivered after expiry
1:     public void testExpiredMessagesWithVerySlowConsumer() throws Exception {
1:         createBroker();
1:         final long queuePrefetch = 600;
0:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616?jms.prefetchPolicy.queuePrefetch=" + queuePrefetch);
1:         connection = factory.createConnection();
1:         session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:         producer = session.createProducer(destination);
1:         final int ttl = 4000;
1:         producer.setTimeToLive(ttl);
1: 
1:         final long sendCount = 1500;
1:         final CountDownLatch receivedOneCondition = new CountDownLatch(1);
1:         final CountDownLatch waitCondition = new CountDownLatch(1);
1: 
1:         MessageConsumer consumer = session.createConsumer(destination);
1:         consumer.setMessageListener(new MessageListener() {
1: 
1:             public void onMessage(Message message) {
1:                 try {
1:                     LOG.info("Got my message: " + message);
1:                     receivedOneCondition.countDown();
0:                     waitCondition.await(60, TimeUnit.SECONDS);
1:                     LOG.info("acking message: " + message);
1:                     message.acknowledge();
1:                 } catch (Exception e) {
1:                     e.printStackTrace();
1:                     fail(e.toString());
1:                 }
1:             }
1:         });
1: 
1:         connection.start();
1: 
1: 
1:         final Thread producingThread = new Thread("Producing Thread") {
1:             public void run() {
1:                 try {
1:                     int i = 0;
1:                     long tStamp = System.currentTimeMillis();
1:                     while (i++ < sendCount) {
1:                         producer.send(session.createTextMessage("test"));
1:                         if (i%100 == 0) {
1:                             LOG.info("sent: " + i + " @ " + ((System.currentTimeMillis() - tStamp) / 100)  + "m/ms");
1:                             tStamp = System.currentTimeMillis() ;
1:                         }
1:                     }
1:                 } catch (Throwable ex) {
1:                     ex.printStackTrace();
1:                 }
1:             }
1:         };
1: 
1:         producingThread.start();
1:         assertTrue("got one message", receivedOneCondition.await(20, TimeUnit.SECONDS));
1: 
1:         assertTrue("producer failed to complete within allocated time", Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 producingThread.join(1000);
1:                 return !producingThread.isAlive();
1:             }
0:         }, Wait.MAX_WAIT_MILLIS * 2));
1: 
1:         final DestinationViewMBean view = createView(destination);
1: 
/////////////////////////////////////////////////////////////////////////
1:         }));
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("producer failed to complete within allocated time", Wait.waitFor(new Wait.Condition() {
/////////////////////////////////////////////////////////////////////////
1:     protected DestinationViewMBean createView(ActiveMQDestination destination) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     protected void tearDown() throws Exception {
1:         connection.stop();
1:         broker.stop();
1:         broker.waitUntilStopped();
1:     }
1: 
1: 
author:Gary Tully
-------------------------------------------------------------------------------
commit:a8a7693
/////////////////////////////////////////////////////////////////////////
1:                 return 0 == view.getInFlightCount();
1:         assertEquals("inflight reduced to duck",
1:                      0, view.getInFlightCount());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("inflight goes to zero on close", 0, view.getInFlightCount());
/////////////////////////////////////////////////////////////////////////
1:                 return 0 == view.getInFlightCount();
1:         assertEquals("inflight didn't reduce to duck",
1:                      0, view.getInFlightCount());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("inflight did not go to zero on close", 0, view.getInFlightCount());
commit:e6a9ae2
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.DeliveryMode;
/////////////////////////////////////////////////////////////////////////
1:         createBrokerWithMemoryLimit(800);
1:     }
1: 
1:     protected void createBrokerWithMemoryLimit(int expireMessagesPeriod) throws Exception {
1:         doCreateBroker(true, expireMessagesPeriod);
1:         doCreateBroker(false, 800);
1:     private void doCreateBroker(boolean memoryLimit, int expireMessagesPeriod) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         defaultEntry.setExpireMessagesPeriod(expireMessagesPeriod);
/////////////////////////////////////////////////////////////////////////
1:     public void testExpiredNonPersistentMessagesWithNoConsumer() throws Exception {
1: 
1:         createBrokerWithMemoryLimit(2000);
1: 
1:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(connectionUri);
1:         connection = factory.createConnection();
1:         session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         producer = session.createProducer(destination);
1:         producer.setTimeToLive(1000);
1:         producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:         connection.start();
1:         final long sendCount = 2000;
1: 
1:         final Thread producingThread = new Thread("Producing Thread") {
1:             public void run() {
1:                 try {
1:                     int i = 0;
1:                     long tStamp = System.currentTimeMillis();
1:                     while (i++ < sendCount) {
1:                         producer.send(session.createTextMessage("test"));
1:                         if (i%100 == 0) {
1:                             LOG.info("sent: " + i + " @ " + ((System.currentTimeMillis() - tStamp) / 100)  + "m/ms");
1:                             tStamp = System.currentTimeMillis() ;
1:                         }
1: 
1:                         if (135 == i) {
1:                             // allow pending messages to expire, before usage limit kicks in  to flush them
1:                             TimeUnit.SECONDS.sleep(5);
1:                         }
1:                     }
1:                 } catch (Throwable ex) {
1:                     ex.printStackTrace();
1:                 }
1:             }
1:         };
1: 
1:         producingThread.start();
1: 
1:         assertTrue("producer failed to complete within allocated time", Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 producingThread.join(TimeUnit.SECONDS.toMillis(3000));
1:                 return !producingThread.isAlive();
1:             }
1:         }));
1: 
1:         TimeUnit.SECONDS.sleep(5);
1:         final DestinationViewMBean view = createView(destination);
1:         Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 try {
1:                 LOG.info("enqueue=" + view.getEnqueueCount() + ", dequeue=" + view.getDequeueCount()
1:                         + ", inflight=" + view.getInFlightCount() + ", expired= " + view.getExpiredCount()
1:                         + ", size= " + view.getQueueSize());
1:                 return view.getDequeueCount() != 0
1:                         && view.getDequeueCount() == view.getExpiredCount()
1:                         && view.getDequeueCount() == view.getEnqueueCount()
1:                         && view.getQueueSize() == 0;
1:                 } catch (Exception ignored) {
1:                     LOG.info(ignored.toString());
1:                 }
1:                 return false;
1:             }
1:         }, Wait.MAX_WAIT_MILLIS * 10);
1:         LOG.info("enqueue=" + view.getEnqueueCount() + ", dequeue=" + view.getDequeueCount()
1:                 + ", inflight=" + view.getInFlightCount() + ", expired= " + view.getExpiredCount()
1:                 + ", size= " + view.getQueueSize());
1: 
1:         assertEquals("memory usage doesn't go to duck egg", 0, view.getMemoryPercentUsage());
1:         assertEquals("0 queue", 0, view.getQueueSize());
1:     }
1: 
1: 
commit:4298a41
/////////////////////////////////////////////////////////////////////////
0:         }, Wait.MAX_WAIT_MILLIS * 2));
commit:ca66801
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicLong;
/////////////////////////////////////////////////////////////////////////
1:     public void testExpiredMessagesWithVerySlowConsumerCanContinue() throws Exception {
1:         createBroker();
0:         final long queuePrefetch = 600;
0:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616?jms.prefetchPolicy.queuePrefetch=" + queuePrefetch);
1:         connection = factory.createConnection();
1:         session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:         producer = session.createProducer(destination);
1:         final int ttl = 4000;
1:         producer.setTimeToLive(ttl);
1: 
0:         final long sendCount = 1500;
1:         final CountDownLatch receivedOneCondition = new CountDownLatch(1);
1:         final CountDownLatch waitCondition = new CountDownLatch(1);
1:         final AtomicLong received = new AtomicLong();
1:         MessageConsumer consumer = session.createConsumer(destination);
1:         consumer.setMessageListener(new MessageListener() {
1: 
1:             public void onMessage(Message message) {
1:                 try {
0:                     LOG.info("Got my message: " + message);
1:                     receivedOneCondition.countDown();
1:                     received.incrementAndGet();
0:                     waitCondition.await(60, TimeUnit.SECONDS);
0:                     LOG.info("acking message: " + message);
1:                     message.acknowledge();
1:                 } catch (Exception e) {
1:                     e.printStackTrace();
1:                     fail(e.toString());
1:                 }
1:             }
1:         });
1: 
1:         connection.start();
1: 
1: 
1:         final Thread producingThread = new Thread("Producing Thread") {
1:             public void run() {
1:                 try {
1:                     int i = 0;
1:                     long tStamp = System.currentTimeMillis();
1:                     while (i++ < sendCount) {
1:                         producer.send(session.createTextMessage("test"));
1:                         if (i%100 == 0) {
1:                             LOG.info("sent: " + i + " @ " + ((System.currentTimeMillis() - tStamp) / 100)  + "m/ms");
1:                             tStamp = System.currentTimeMillis() ;
1:                         }
1:                     }
1:                 } catch (Throwable ex) {
1:                     ex.printStackTrace();
1:                 }
1:             }
1:         };
1: 
1:         producingThread.start();
1:         assertTrue("got one message", receivedOneCondition.await(20, TimeUnit.SECONDS));
1: 
0:         assertTrue("producer completed within time ", Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 producingThread.join(1000);
1:                 return !producingThread.isAlive();
1:             }
1:         }));
1: 
1:         final DestinationViewMBean view = createView(destination);
1: 
1:         assertTrue("all dispatched up to default prefetch ", Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 return queuePrefetch == view.getDispatchCount();
1:             }
1:         }));
0:         assertTrue("All sent have expired ", Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
0:                 return sendCount == view.getExpiredCount();
1:             }
1:         }));
1: 
1:         LOG.info("enqueue=" + view.getEnqueueCount() + ", dequeue=" + view.getDequeueCount()
1:                 + ", inflight=" + view.getInFlightCount() + ", expired= " + view.getExpiredCount()
1:                 + ", size= " + view.getQueueSize());
1: 
1:         // let the ack happen
1:         waitCondition.countDown();
1: 
1:         Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
0:                 // consumer ackLater(delivery ack for expired messages) is based on half the prefetch value
0:                 // which will leave half of the prefetch pending till consumer close
0:                 return (queuePrefetch/2) -1 == view.getInFlightCount();
1:             }
1:         });
1:         LOG.info("enqueue=" + view.getEnqueueCount() + ", dequeue=" + view.getDequeueCount()
1:                 + ", inflight=" + view.getInFlightCount() + ", expired= " + view.getExpiredCount()
1:                 + ", size= " + view.getQueueSize());
1: 
1: 
0:         assertEquals("inflight reduces to half prefetch minus single delivered message", (queuePrefetch/2) -1, view.getInFlightCount());
0:         assertEquals("size gets back to 0 ", 0, view.getQueueSize());
0:         assertEquals("dequeues match sent/expired ", sendCount, view.getDequeueCount());
1: 
1: 
1:         // produce some more
1:         producer.setTimeToLive(0);
1:         for (int i=0; i<sendCount; i++) {
1:             producer.send(session.createTextMessage("test-" + i));
1:         }
1: 
1:         Wait.waitFor(new Wait.Condition() {
1:              public boolean isSatisified() throws Exception {
1:                  return received.get() >= sendCount;
1:              }
1:          });
1: 
1:         consumer.close();
1: 
1:         Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 return 0 == view.getInFlightCount();
1:             }
1:         });
0:         assertEquals("inflight goes to zeor on close", 0, view.getInFlightCount());
1: 
1:         LOG.info("done: " + getName());
1:     }
1: 
1: 
1: 
commit:5619cd0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.policy.FilePendingQueueMessageStoragePolicy;
1: import org.apache.activemq.broker.region.policy.PendingQueueMessageStoragePolicy;
1: import org.apache.activemq.broker.region.policy.VMPendingQueueMessageStoragePolicy;
/////////////////////////////////////////////////////////////////////////
0:     public PendingQueueMessageStoragePolicy pendingQueuePolicy;
/////////////////////////////////////////////////////////////////////////
1:         
1:         defaultEntry.setPendingQueuePolicy(pendingQueuePolicy);
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("pendingQueuePolicy", new Object[] {null, new VMPendingQueueMessageStoragePolicy(), new FilePendingQueueMessageStoragePolicy()});
/////////////////////////////////////////////////////////////////////////
0: 		final long sendCount = 2000;
/////////////////////////////////////////////////////////////////////////
0:         assertEquals("memory usage goes to duck egg", 0, view.getMemoryPercentUsage());
commit:83df5ce
/////////////////////////////////////////////////////////////////////////
0:         final long queuePrefetch = 600;
0:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616?jms.prefetchPolicy.queuePrefetch=" + queuePrefetch);
/////////////////////////////////////////////////////////////////////////
1:                 return queuePrefetch == view.getDispatchCount();
/////////////////////////////////////////////////////////////////////////
0:                 // consumer ackLater(delivery ack for expired messages) is based on half the prefetch value
0:                 // which will leave half of the prefetch pending till consumer close
0:                 return (queuePrefetch/2) -1 == view.getInFlightCount();
1:         
1:         
0:         assertEquals("inflight reduces to half prefetch minus single delivered message", (queuePrefetch/2) -1, view.getInFlightCount());
1:         
1:         Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 return 0 == view.getInFlightCount();
1:             }
1:         });
0:         assertEquals("inflight goes to zeor on close", 0, view.getInFlightCount());
1:       
commit:3536b1e
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.TimeUnit;
1: 
0: import javax.jms.Connection;
0: import javax.jms.Message;
0: import javax.jms.MessageConsumer;
0: import javax.jms.MessageListener;
0: import javax.jms.MessageProducer;
0: import javax.jms.Session;
0: import javax.management.ObjectName;
1: 
1: import junit.framework.Test;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 LOG.info("enqueue=" + view.getEnqueueCount() + ", dequeue=" + view.getDequeueCount()
1:                         + ", inflight=" + view.getInFlightCount() + ", expired= " + view.getExpiredCount()
1:                         + ", size= " + view.getQueueSize());
1:         
commit:f7804bd
/////////////////////////////////////////////////////////////////////////
0:     public boolean optimizedDispatch = true;
/////////////////////////////////////////////////////////////////////////
0:         defaultEntry.setOptimizedDispatch(optimizedDispatch );
/////////////////////////////////////////////////////////////////////////
1:     public void initCombosForTestExpiredMessagesWithNoConsumer() {
1:         addCombinationValues("optimizedDispatch", new Object[] {Boolean.TRUE, Boolean.FALSE});
1:     }
1:     
commit:8d9f47a
/////////////////////////////////////////////////////////////////////////
0:         defaultEntry.setOptimizedDispatch(true);
commit:ca242f4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.Wait;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         defaultEntry.setExpireMessagesPeriod(100);
1:         defaultEntry.setMaxExpirePageSize(800);
/////////////////////////////////////////////////////////////////////////
0: 		producer.setTimeToLive(1000);
1: 		final Thread producingThread = new Thread("Producing Thread") {
/////////////////////////////////////////////////////////////////////////
0: 		assertTrue("producer completed within time", Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
0:                 producingThread.join(1000);
1:                 return !producingThread.isAlive();
1:             }
0: 		}));
1:         final DestinationViewMBean view = createView(destination);
1:         Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
0:                 return sendCount == view.getExpiredCount();
1:             }
1:         });
1:         LOG.info("enqueue=" + view.getEnqueueCount() + ", dequeue=" + view.getDequeueCount()
1:                 + ", inflight=" + view.getInFlightCount() + ", expired= " + view.getExpiredCount()
1:                 + ", size= " + view.getQueueSize());
0:         assertEquals("All sent have expired", sendCount, view.getExpiredCount());
0: 	// first ack delivered after expiry
0:     public void testExpiredMessagesWithVerySlowConsumer() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:         final long sendCount = 1500; 
/////////////////////////////////////////////////////////////////////////
0:                     LOG.info("acking message: " + message);
/////////////////////////////////////////////////////////////////////////
0:         final Thread producingThread = new Thread("Producing Thread") {
/////////////////////////////////////////////////////////////////////////
0:         assertTrue("got one message", receivedOneCondition.await(20, TimeUnit.SECONDS));
0:         assertTrue("producer completed within time ", Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
0:                 producingThread.join(1000);
0:                 return !producingThread.isAlive();
1:             }      
0:         }));
1:              
0:         final DestinationViewMBean view = createView(destination);
0:         assertTrue("all dispatched up to default prefetch ", Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
0:                 return 1000 == view.getDispatchCount();
1:             }
0:         }));
0:         assertTrue("All sent have expired ", Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
0:                 return sendCount == view.getExpiredCount();
1:             }
0:         }));     
0:         LOG.info("enqueue=" + view.getEnqueueCount() + ", dequeue=" + view.getDequeueCount()
0:                 + ", inflight=" + view.getInFlightCount() + ", expired= " + view.getExpiredCount()
0:                 + ", size= " + view.getQueueSize());
1:         Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
0:                 return 0 == view.getInFlightCount();
1:             }
0:         });
0:         LOG.info("enqueue=" + view.getEnqueueCount() + ", dequeue=" + view.getDequeueCount()
0:                 + ", inflight=" + view.getInFlightCount() + ", expired= " + view.getExpiredCount()
0:                 + ", size= " + view.getQueueSize());
0:         assertEquals("size gets back to 0 ", 0, view.getQueueSize());
0:         assertEquals("dequeues match sent/expired ", sendCount, view.getDequeueCount());
commit:dbe847e
/////////////////////////////////////////////////////////////////////////
0: 		Thread.sleep(3*expiryPeriod);
commit:7a59d28
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.TimeUnit;
1: 
0: import javax.jms.Message;
0: import javax.jms.MessageConsumer;
0: import javax.jms.MessageListener;
/////////////////////////////////////////////////////////////////////////
1:     protected void createBrokerWithMemoryLimit() throws Exception {
0:         doCreateBroker(true);
1:     }
1:     
1:     protected void createBroker() throws Exception {
0:         doCreateBroker(false);
1:     }
1:     
0:     private void doCreateBroker(boolean memoryLimit) throws Exception {
1:         broker = new BrokerService();
1:         broker.setBrokerName("localhost");
0:         broker.setDataDirectory("data/");
1:         broker.setUseJmx(true);
1:         broker.setDeleteAllMessagesOnStartup(true);
0:         broker.addConnector("tcp://localhost:61616");
1: 
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry defaultEntry = new PolicyEntry();
0:         defaultEntry.setExpireMessagesPeriod(expiryPeriod);
0:         defaultEntry.setMaxExpirePageSize(200);
1: 
1:         if (memoryLimit) {
1:             // so memory is not consumed by DLQ turn if off
1:             defaultEntry.setDeadLetterStrategy(null);
1:             defaultEntry.setMemoryLimit(200 * 1000);
1:         }
1: 
1:         policyMap.setDefaultEntry(defaultEntry);
1: 
1:         broker.start();
1: 
1:         broker.waitUntilStarted();
1:     }
0: 	public void testExpiredMessagesWithNoConsumer() throws Exception {
0: 	    createBrokerWithMemoryLimit();
1: 	    
/////////////////////////////////////////////////////////////////////////
0: 
0:     
0:     public void testExpiredMessagesWitVerySlowConsumer() throws Exception {
1:         createBroker();  
0:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616");
1:         connection = factory.createConnection();
1:         session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:         producer = session.createProducer(destination);
0:         final int ttl = 4000;
1:         producer.setTimeToLive(ttl);
0:         
0:         final long sendCount = 1001; 
0:         final CountDownLatch receivedOneCondition = new CountDownLatch(1);
0:         final CountDownLatch waitCondition = new CountDownLatch(1);
0:         
0:         MessageConsumer consumer = session.createConsumer(destination);
0:         consumer.setMessageListener(new MessageListener() {
0: 
1:             public void onMessage(Message message) {
1:                 try {
0:                     LOG.info("Got my message: " + message);
0:                     receivedOneCondition.countDown();
0:                     waitCondition.await(60, TimeUnit.SECONDS);
0:                     message.acknowledge();
0:                 } catch (Exception e) {
0:                     e.printStackTrace();
0:                     fail(e.toString());
1:                 }  
1:             }        
0:         });
0:         
1:         connection.start();
0:       
0:         
0:         Thread producingThread = new Thread("Producing Thread") {
1:             public void run() {
1:                 try {
1:                     int i = 0;
1:                     long tStamp = System.currentTimeMillis();
1:                     while (i++ < sendCount) {
1:                         producer.send(session.createTextMessage("test"));
1:                         if (i%100 == 0) {
1:                             LOG.info("sent: " + i + " @ " + ((System.currentTimeMillis() - tStamp) / 100)  + "m/ms");
1:                             tStamp = System.currentTimeMillis() ;
1:                         }
1:                     }
1:                 } catch (Throwable ex) {
1:                     ex.printStackTrace();
1:                 }
1:             }
1:         };
0:         
1:         producingThread.start();
0:         
0:         final long expiry = System.currentTimeMillis() + 20*1000;
0:         while (producingThread.isAlive() && expiry > System.currentTimeMillis()) {
0:             producingThread.join(1000);
1:         }
0:         
0:         assertTrue("got one message", receivedOneCondition.await(10, TimeUnit.SECONDS));
0:         assertTrue("producer completed within time ", !producingThread.isAlive());
0:         
0:         Thread.sleep(2 * Math.max(ttl, expiryPeriod));
0:         DestinationViewMBean view = createView(destination);
0:             
0:         assertEquals("all dispatched up to default prefetch ", 1000, view.getDispatchCount());
0:         assertEquals("All sent save one have expired ", sendCount, view.getExpiredCount());     
0:         
0:         
1:         // let the ack happen
1:         waitCondition.countDown();
0:      
0:         Thread.sleep(Math.max(ttl, expiryPeriod));
0:         
0:         assertEquals("all sent save one have expired ", sendCount, view.getExpiredCount());
0:         
0:         assertEquals("prefetch gets back to 0 ", 0, view.getInFlightCount());
0:         
1:         consumer.close();
1:         LOG.info("done: " + getName());
1:     }
0: 
commit:6a121b3
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.usecases;
0: 
0: import javax.jms.Connection;
0: import javax.jms.MessageProducer;
0: import javax.jms.Session;
0: import javax.management.MBeanServer;
0: import javax.management.MBeanServerInvocationHandler;
0: import javax.management.ObjectName;
0: 
0: import junit.framework.Test;
0: 
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.CombinationTestSupport;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.jmx.DestinationViewMBean;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQQueue;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: 
0: 
1: public class ExpiredMessagesWithNoConsumerTest extends CombinationTestSupport {
0: 
0:     private static final Log LOG = LogFactory.getLog(ExpiredMessagesWithNoConsumerTest.class);
0: 
0:     private static final int expiryPeriod = 1000;
0:     
0: 	BrokerService broker;
0: 	Connection connection;
0: 	Session session;
0: 	MessageProducer producer;
0: 	public ActiveMQDestination destination = new ActiveMQQueue("test");
0: 	
1:     public static Test suite() {
1:         return suite(ExpiredMessagesWithNoConsumerTest.class);
1:     }
0: 
1:     public static void main(String[] args) {
1:         junit.textui.TestRunner.run(suite());
1:     }
0: 	
0: 	protected void setUp() throws Exception {
0: 		broker = new BrokerService();
0: 		broker.setBrokerName("localhost");
0: 		broker.setDataDirectory("data/");
0: 		broker.setUseJmx(true);
0: 		broker.setDeleteAllMessagesOnStartup(true);
0: 		broker.addConnector("tcp://localhost:61616");
0: 			
0: 		PolicyMap policyMap = new PolicyMap();
0: 		PolicyEntry defaultEntry = new PolicyEntry();
0: 		defaultEntry.setExpireMessagesPeriod(expiryPeriod);
0: 		defaultEntry.setMaxExpirePageSize(200);
0: 		// so memory is not consumed by DLQ turn if off
0: 		defaultEntry.setDeadLetterStrategy(null);
0: 		defaultEntry.setMemoryLimit(200*1000);
0: 		policyMap.setDefaultEntry(defaultEntry);
1:         broker.setDestinationPolicy(policyMap);
0: 		
0: 		broker.start();
0: 		
0: 		broker.waitUntilStarted();
1: 	}
0: 		
0: 	public void testExpiredMessages() throws Exception {
0: 		
0: 		ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616");
0: 		connection = factory.createConnection();
0: 		session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 		producer = session.createProducer(destination);
0: 		producer.setTimeToLive(100);
1: 		connection.start();
0: 		final long sendCount = 2000;		
0: 		
0: 		Thread producingThread = new Thread("Producing Thread") {
0:             public void run() {
0:                 try {
0:                 	int i = 0;
0:                 	long tStamp = System.currentTimeMillis();
0:                 	while (i++ < sendCount) {
1:                 		producer.send(session.createTextMessage("test"));
0:                 		if (i%100 == 0) {
0:                 		    LOG.info("sent: " + i + " @ " + ((System.currentTimeMillis() - tStamp) / 100)  + "m/ms");
0:                 		    tStamp = System.currentTimeMillis() ;
1:                 		}
1:                 	}
0:                 } catch (Throwable ex) {
0:                     ex.printStackTrace();
1:                 }
1:             }
0: 		};
0: 		
0: 		producingThread.start();
0: 		
0: 		final long expiry = System.currentTimeMillis() + 20*1000;
0: 		while (producingThread.isAlive() && expiry > System.currentTimeMillis()) {
0: 		    producingThread.join(1000);
1: 		}
0:         
0: 		assertTrue("producer completed within time ", !producingThread.isAlive());
0: 		
0: 		Thread.sleep(2*expiryPeriod);
0:         DestinationViewMBean view = createView(destination);
0:         assertEquals("All sent have expired ", sendCount, view.getExpiredCount());
1: 	}
0: 	
0: 	protected DestinationViewMBean createView(ActiveMQDestination destination) throws Exception {
0: 		 MBeanServer mbeanServer = broker.getManagementContext().getMBeanServer();
1: 		 String domain = "org.apache.activemq";
1: 		 ObjectName name;
1: 		if (destination.isQueue()) {
0: 			name = new ObjectName(domain + ":BrokerName=localhost,Type=Queue,Destination=test");
1: 		} else {
0: 			name = new ObjectName(domain + ":BrokerName=localhost,Type=Topic,Destination=test");
1: 		}
0: 		return (DestinationViewMBean)MBeanServerInvocationHandler.newProxyInstance(mbeanServer, name, DestinationViewMBean.class, true);
1: 	}
0: 
0: 	protected void tearDown() throws Exception {
0: 		connection.stop();
0: 		broker.stop();
0: 		broker.waitUntilStopped();
1: 	}
0: 
0: 	
0: 
0: 	
1: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:47c392b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.Connection;
0: import javax.jms.DeliveryMode;
0: import javax.jms.Message;
0: import javax.jms.MessageConsumer;
0: import javax.jms.MessageListener;
0: import javax.jms.MessageProducer;
0: import javax.jms.Session;
0: import javax.jms.Topic;
0: import javax.jms.TopicSubscriber;
0: import javax.management.ObjectName;
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.TimeUnit;
0: import java.util.concurrent.atomic.AtomicLong;
0: 
/////////////////////////////////////////////////////////////////////////
1:         final int ttl = 1000;
/////////////////////////////////////////////////////////////////////////
1:         Thread.sleep(5000);
commit:ed3f61a
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.*;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQTopic;
/////////////////////////////////////////////////////////////////////////
1:     public void testExpireMessagesForDurableSubscriber() throws Exception {
0:         createBroker();
0:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616");
0:         connection = factory.createConnection();
1:         connection.setClientID("myConnection");
0:         session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
0:         connection.start();
1:         Topic destination = session.createTopic("test");
0:         producer = session.createProducer(destination);
0:         final int ttl = 300;
0:         producer.setTimeToLive(ttl);
0: 
1:         final long sendCount = 10;
0: 
1:         TopicSubscriber sub = session.createDurableSubscriber(destination, "mySub");
1:         sub.close();
0: 
1:         for (int i=0; i < sendCount; i++) {
0:             producer.send(session.createTextMessage("test"));
0:         }
0: 
1:         DestinationViewMBean view = createView((ActiveMQTopic)destination);
0: 
0: 
1:         LOG.info("messages sent");
1:         LOG.info("expired=" + view.getExpiredCount() + " " +  view.getEnqueueCount());
1:         assertEquals(0, view.getExpiredCount());
1:         assertEquals(10, view.getEnqueueCount());
0: 
0: 
0:         Thread.sleep(4000);
0: 
1:         LOG.info("expired=" + view.getExpiredCount() + " " +  view.getEnqueueCount());
1:         assertEquals(10, view.getExpiredCount());
0:         assertEquals(0, view.getEnqueueCount());
0: 
0: 
1:         final AtomicLong received = new AtomicLong();
1:         sub = session.createDurableSubscriber(destination, "mySub");
1:         sub.setMessageListener(new MessageListener() {
1:             @Override
0:             public void onMessage(Message message) {
1:                 received.incrementAndGet();
0:             }
0:         });
0: 
1:         LOG.info("Waiting for messages to arrive");
0: 
0: 
0:         Wait.waitFor(new Wait.Condition() {
0:              public boolean isSatisified() throws Exception {
1:                  return received.get() >= sendCount;
0:              }
1:          }, 1000);
0: 
1:         LOG.info("received=" + received.get());
1:         LOG.info("expired=" + view.getExpiredCount() + " " +  view.getEnqueueCount());
0: 
1:         assertEquals(0, received.get());
1:         assertEquals(10, view.getExpiredCount());
0:         assertEquals(0, view.getEnqueueCount());
0: 
0:     }
0: 
0: 
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(ExpiredMessagesWithNoConsumerTest.class);
commit:680ebe0
/////////////////////////////////////////////////////////////////////////
0:         defaultEntry.setExpireMessagesPeriod(800);
commit:0cdda14
/////////////////////////////////////////////////////////////////////////
0:         });
commit:5510065
/////////////////////////////////////////////////////////////////////////
0:         // TODO Optimize dispatch makes this test hang
0:         //defaultEntry.setOptimizedDispatch(true);
/////////////////////////////////////////////////////////////////////////
0:         }, 5*1000l);
author:Robert Davies
-------------------------------------------------------------------------------
commit:c459784
/////////////////////////////////////////////////////////////////////////
0:         defaultEntry.setOptimizedDispatch(true);
commit:1ec71bd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.TimeUnit;
0: import javax.jms.Connection;
0: import javax.jms.Message;
0: import javax.jms.MessageConsumer;
0: import javax.jms.MessageListener;
0: import javax.jms.MessageProducer;
0: import javax.jms.Session;
0: import javax.management.ObjectName;
0: import junit.framework.Test;
/////////////////////////////////////////////////////////////////////////
0:         String domain = "org.apache.activemq";
0:         ObjectName name;
0:         if (destination.isQueue()) {
0:             name = new ObjectName(domain + ":BrokerName=localhost,Type=Queue,Destination=test");
0:         } else {
0:             name = new ObjectName(domain + ":BrokerName=localhost,Type=Topic,Destination=test");
0:         }
0:         return (DestinationViewMBean) broker.getManagementContext().newProxyInstance(name, DestinationViewMBean.class,
0:                 true);
0:     }
============================================================================