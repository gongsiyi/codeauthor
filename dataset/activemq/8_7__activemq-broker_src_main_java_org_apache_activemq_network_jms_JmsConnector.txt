1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:d29ca2a:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b0c2a40:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.network.jms;
1:b2ad8fa: 
1:1b49374: import static org.apache.activemq.network.jms.ReconnectionPolicy.INFINITE;
1:1b49374: 
1:d29ca2a: import java.util.Iterator;
1:d29ca2a: import java.util.List;
1:d29ca2a: import java.util.Map;
1:74a7a8b: import java.util.concurrent.CopyOnWriteArrayList;
1:bc78238: import java.util.concurrent.LinkedBlockingQueue;
1:bc78238: import java.util.concurrent.ThreadFactory;
1:bc78238: import java.util.concurrent.ThreadPoolExecutor;
1:bc78238: import java.util.concurrent.TimeUnit;
1:74a7a8b: import java.util.concurrent.atomic.AtomicBoolean;
1:bc78238: import java.util.concurrent.atomic.AtomicReference;
1:ac66a09: 
1:49e8a80: import javax.jms.Connection;
1:49e8a80: import javax.jms.Destination;
1:ac66a09: 
1:d29ca2a: import org.apache.activemq.ActiveMQConnectionFactory;
1:d29ca2a: import org.apache.activemq.Service;
1:d29ca2a: import org.apache.activemq.broker.BrokerService;
1:d29ca2a: import org.apache.activemq.util.LRUCache;
1:6c1676b: import org.apache.activemq.util.ThreadPoolUtils;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:b2ad8fa: 
1:d29ca2a: /**
1:fbad105:  * This bridge joins the gap between foreign JMS providers and ActiveMQ As some
1:bc78238:  * JMS providers are still only in compliance with JMS v1.0.1 , this bridge itself
1:bc78238:  * aimed to be in compliance with the JMS 1.0.2 specification.
1:d29ca2a:  */
1:fbad105: public abstract class JmsConnector implements Service {
1:b2ad8fa: 
1:ecf89a6:     private static int nextId;
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(JmsConnector.class);
1:ecf89a6: 
1:c176fa8:     protected boolean preferJndiDestinationLookup = false;
1:7c9fec6:     protected JndiLookupFactory jndiLocalTemplate;
1:7c9fec6:     protected JndiLookupFactory jndiOutboundTemplate;
1:6ea186c:     protected JmsMesageConvertor inboundMessageConvertor;
1:6ea186c:     protected JmsMesageConvertor outboundMessageConvertor;
1:d29ca2a:     protected AtomicBoolean initialized = new AtomicBoolean(false);
1:bc78238:     protected AtomicBoolean localSideInitialized = new AtomicBoolean(false);
1:bc78238:     protected AtomicBoolean foreignSideInitialized = new AtomicBoolean(false);
1:d29ca2a:     protected AtomicBoolean started = new AtomicBoolean(false);
1:bc78238:     protected AtomicBoolean failed = new AtomicBoolean();
1:bc78238:     protected AtomicReference<Connection> foreignConnection = new AtomicReference<Connection>();
1:bc78238:     protected AtomicReference<Connection> localConnection = new AtomicReference<Connection>();
1:fbad105:     protected ActiveMQConnectionFactory embeddedConnectionFactory;
1:fbad105:     protected int replyToDestinationCacheSize = 10000;
1:b2ad8fa:     protected String outboundUsername;
1:49e8a80:     protected String outboundPassword;
1:49e8a80:     protected String localUsername;
1:b2ad8fa:     protected String localPassword;
1:4acbd59:     protected String outboundClientId;
1:4acbd59:     protected String localClientId;
1:bc78238:     protected LRUCache<Destination, DestinationBridge> replyToBridges = createLRUCache();
1:ecf89a6: 
1:bc78238:     private ReconnectionPolicy policy = new ReconnectionPolicy();
1:1b49374:     protected ThreadPoolExecutor connectionService;
1:ccf4b9f:     private final List<DestinationBridge> inboundBridges = new CopyOnWriteArrayList<DestinationBridge>();
1:ccf4b9f:     private final List<DestinationBridge> outboundBridges = new CopyOnWriteArrayList<DestinationBridge>();
1:b2ad8fa:     private String name;
1:74a7a8b: 
1:bc78238:     private static LRUCache<Destination, DestinationBridge> createLRUCache() {
1:bc78238:         return new LRUCache<Destination, DestinationBridge>() {
1:74a7a8b:             private static final long serialVersionUID = -7446792754185879286L;
1:74a7a8b: 
1:ccf4b9f:             @Override
1:bc78238:             protected boolean removeEldestEntry(Map.Entry<Destination, DestinationBridge> enty) {
1:74a7a8b:                 if (size() > maxCacheSize) {
1:bc78238:                     Iterator<Map.Entry<Destination, DestinationBridge>> iter = entrySet().iterator();
1:bc78238:                     Map.Entry<Destination, DestinationBridge> lru = iter.next();
1:74a7a8b:                     remove(lru.getKey());
1:ccf4b9f:                     DestinationBridge bridge = lru.getValue();
1:74a7a8b:                     try {
1:74a7a8b:                         bridge.stop();
1:e1bbde7:                         LOG.info("Expired bridge: {}", bridge);
1:74a7a8b:                     } catch (Exception e) {
1:59af747:                         LOG.warn("Stopping expired bridge {} caused an exception", bridge, e);
1:74a7a8b:                     }
1:74a7a8b:                 }
1:74a7a8b:                 return false;
1:74a7a8b:             }
1:74a7a8b:         };
1:86cbdfd:     }
1:b2ad8fa: 
1:fbad105:     public boolean init() {
1:fbad105:         boolean result = initialized.compareAndSet(false, true);
1:fbad105:         if (result) {
1:fbad105:             if (jndiLocalTemplate == null) {
1:7c9fec6:                 jndiLocalTemplate = new JndiLookupFactory();
1:ac66a09:             }
1:fbad105:             if (jndiOutboundTemplate == null) {
1:7c9fec6:                 jndiOutboundTemplate = new JndiLookupFactory();
1:ac66a09:             }
1:fbad105:             if (inboundMessageConvertor == null) {
1:fbad105:                 inboundMessageConvertor = new SimpleJmsMessageConvertor();
1:ac66a09:             }
1:fbad105:             if (outboundMessageConvertor == null) {
1:fbad105:                 outboundMessageConvertor = new SimpleJmsMessageConvertor();
1:ac66a09:             }
1:d29ca2a:             replyToBridges.setMaxCacheSize(getReplyToDestinationCacheSize());
1:b2ad8fa: 
1:1b49374:             connectionService = createExecutor();
1:d29ca2a: 
1:bc78238:             // Subclasses can override this to customize their own it.
1:bc78238:             result = doConnectorInit();
1:ac66a09:         }
1:d29ca2a:         return result;
1:d29ca2a:     }
1:d29ca2a: 
1:bc78238:     protected boolean doConnectorInit() {
1:d29ca2a: 
1:bc78238:         // We try to make a connection via a sync call first so that the
1:bc78238:         // JmsConnector is fully initialized before the start call returns
1:bc78238:         // in order to avoid missing any messages that are dispatched
1:bc78238:         // immediately after startup.  If either side fails we queue an
1:bc78238:         // asynchronous task to manage the reconnect attempts.
1:d29ca2a: 
1:ac66a09:         try {
1:bc78238:             initializeLocalConnection();
1:bc78238:             localSideInitialized.set(true);
1:bc78238:         } catch(Exception e) {
1:bc78238:             // Queue up the task to attempt the local connection.
1:bc78238:             scheduleAsyncLocalConnectionReconnect();
1:d29ca2a:         }
1:d29ca2a: 
1:bc78238:         try {
1:bc78238:             initializeForeignConnection();
1:bc78238:             foreignSideInitialized.set(true);
1:bc78238:         } catch(Exception e) {
1:bc78238:             // Queue up the task for the foreign connection now.
1:bc78238:             scheduleAsyncForeignConnectionReconnect();
1:d29ca2a:         }
1:bc78238: 
1:bc78238:         return true;
1:d29ca2a:     }
1:bc78238: 
1:ccf4b9f:     @Override
1:fbad105:     public void start() throws Exception {
1:fbad105:         if (started.compareAndSet(false, true)) {
1:d29ca2a:             init();
1:bc78238:             for (DestinationBridge bridge : inboundBridges) {
1:b2ad8fa:                 bridge.start();
1:b2ad8fa:             }
1:bc78238:             for (DestinationBridge bridge : outboundBridges) {
1:b2ad8fa:                 bridge.start();
1:b2ad8fa:             }
1:59af747:             LOG.info("JMS Connector {} started", getName());
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:ccf4b9f:     @Override
1:fbad105:     public void stop() throws Exception {
1:fbad105:         if (started.compareAndSet(true, false)) {
1:d29ca2a: 
1:1b49374:             ThreadPoolUtils.shutdown(connectionService);
1:1b49374:             connectionService = null;
1:bc78238: 
1:ccf4b9f:             if (foreignConnection.get() != null) {
1:ccf4b9f:                 try {
1:ccf4b9f:                     foreignConnection.get().close();
1:ccf4b9f:                 } catch (Exception e) {
1:ccf4b9f:                 }
1:ccf4b9f:             }
1:ccf4b9f: 
1:ccf4b9f:             if (localConnection.get() != null) {
1:ccf4b9f:                 try {
1:ccf4b9f:                     localConnection.get().close();
1:ccf4b9f:                 } catch (Exception e) {
1:ccf4b9f:                 }
1:ccf4b9f:             }
1:ccf4b9f: 
1:bc78238:             for (DestinationBridge bridge : inboundBridges) {
1:ac66a09:                 bridge.stop();
1:d29ca2a:             }
1:bc78238:             for (DestinationBridge bridge : outboundBridges) {
1:d29ca2a:                 bridge.stop();
1:d29ca2a:             }
1:59af747:             LOG.info("JMS Connector {} stopped", getName());
1:d29ca2a:         }
1:d29ca2a:     }
1:bc78238: 
1:eaea516:     public void clearBridges() {
1:eaea516:         inboundBridges.clear();
1:eaea516:         outboundBridges.clear();
1:bc78238:         replyToBridges.clear();
1:d29ca2a:     }
1:bc78238: 
1:49e8a80:     protected abstract Destination createReplyToBridge(Destination destination, Connection consumerConnection, Connection producerConnection);
1:bc78238: 
1:ac66a09:     /**
1:fbad105:      * One way to configure the local connection - this is called by The
1:fbad105:      * BrokerService when the Connector is embedded
1:b2ad8fa:      *
1:d29ca2a:      * @param service
1:ac66a09:      */
1:fbad105:     public void setBrokerService(BrokerService service) {
1:d29ca2a:         embeddedConnectionFactory = new ActiveMQConnectionFactory(service.getVmConnectorURI());
1:d29ca2a:     }
1:d29ca2a: 
1:bc78238:     public Connection getLocalConnection() {
1:bc78238:         return this.localConnection.get();
1:d29ca2a:     }
1:bc78238: 
1:bc78238:     public Connection getForeignConnection() {
1:bc78238:         return this.foreignConnection.get();
1:d29ca2a:     }
1:bc78238: 
1:b2ad8fa:     /**
1:d29ca2a:      * @return Returns the jndiTemplate.
1:b2ad8fa:      */
1:7c9fec6:     public JndiLookupFactory getJndiLocalTemplate() {
1:e1bc55d:         return jndiLocalTemplate;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:74a7a8b:      * @param jndiTemplate The jndiTemplate to set.
1:d29ca2a:      */
1:7c9fec6:     public void setJndiLocalTemplate(JndiLookupFactory jndiTemplate) {
1:fbad105:         this.jndiLocalTemplate = jndiTemplate;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:e1bc55d:      * @return Returns the jndiOutboundTemplate.
1:d29ca2a:      */
1:7c9fec6:     public JndiLookupFactory getJndiOutboundTemplate() {
1:e1bc55d:         return jndiOutboundTemplate;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:74a7a8b:      * @param jndiOutboundTemplate The jndiOutboundTemplate to set.
1:d29ca2a:      */
1:7c9fec6:     public void setJndiOutboundTemplate(JndiLookupFactory jndiOutboundTemplate) {
1:fbad105:         this.jndiOutboundTemplate = jndiOutboundTemplate;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:6ea186c:      * @return Returns the inboundMessageConvertor.
1:d29ca2a:      */
1:fbad105:     public JmsMesageConvertor getInboundMessageConvertor() {
1:6ea186c:         return inboundMessageConvertor;
1:d29ca2a:     }
1:bc78238: 
1:d29ca2a:     /**
1:5e05df1:      * @param jmsMessageConvertor The jmsMessageConvertor to set.
1:d29ca2a:      */
1:fbad105:     public void setInboundMessageConvertor(JmsMesageConvertor jmsMessageConvertor) {
1:fbad105:         this.inboundMessageConvertor = jmsMessageConvertor;
1:d29ca2a:     }
1:bc78238: 
1:d29ca2a:     /**
1:6ea186c:      * @return Returns the outboundMessageConvertor.
1:6ea186c:      */
1:fbad105:     public JmsMesageConvertor getOutboundMessageConvertor() {
1:6ea186c:         return outboundMessageConvertor;
1:bc78238:     }
1:bc78238: 
1:49e8a80:     /**
1:74a7a8b:      * @param outboundMessageConvertor The outboundMessageConvertor to set.
1:6ea186c:      */
1:fbad105:     public void setOutboundMessageConvertor(JmsMesageConvertor outboundMessageConvertor) {
1:fbad105:         this.outboundMessageConvertor = outboundMessageConvertor;
1:bc78238:     }
1:bc78238: 
1:6ea186c:     /**
1:d29ca2a:      * @return Returns the replyToDestinationCacheSize.
1:d29ca2a:      */
1:fbad105:     public int getReplyToDestinationCacheSize() {
1:d29ca2a:         return replyToDestinationCacheSize;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:bc78238:      * @param replyToDestinationCacheSize The replyToDestinationCacheSize to set.
1:d29ca2a:      */
1:fbad105:     public void setReplyToDestinationCacheSize(int replyToDestinationCacheSize) {
1:fbad105:         this.replyToDestinationCacheSize = replyToDestinationCacheSize;
1:d29ca2a:     }
1:d29ca2a: 
1:6ea186c:     /**
1:49e8a80:      * @return Returns the localPassword.
1:49e8a80:      */
1:fbad105:     public String getLocalPassword() {
1:49e8a80:         return localPassword;
1:d29ca2a:     }
1:d29ca2a: 
1:49e8a80:     /**
1:74a7a8b:      * @param localPassword The localPassword to set.
1:49e8a80:      */
1:fbad105:     public void setLocalPassword(String localPassword) {
1:fbad105:         this.localPassword = localPassword;
1:d29ca2a:     }
1:d29ca2a: 
1:49e8a80:     /**
1:49e8a80:      * @return Returns the localUsername.
1:49e8a80:      */
1:fbad105:     public String getLocalUsername() {
1:49e8a80:         return localUsername;
1:bc78238:     }
1:bc78238: 
1:49e8a80:     /**
1:74a7a8b:      * @param localUsername The localUsername to set.
1:49e8a80:      */
1:fbad105:     public void setLocalUsername(String localUsername) {
1:fbad105:         this.localUsername = localUsername;
1:bc78238:     }
1:eaea516: 
1:49e8a80:     /**
1:49e8a80:      * @return Returns the outboundPassword.
1:49e8a80:      */
1:fbad105:     public String getOutboundPassword() {
1:49e8a80:         return outboundPassword;
1:bc78238:     }
1:4acbd59: 
1:49e8a80:     /**
1:74a7a8b:      * @param outboundPassword The outboundPassword to set.
1:49e8a80:      */
1:fbad105:     public void setOutboundPassword(String outboundPassword) {
1:fbad105:         this.outboundPassword = outboundPassword;
1:eaea516:     }
1:49e8a80: 
1:49e8a80:     /**
1:49e8a80:      * @return Returns the outboundUsername.
1:49e8a80:      */
1:fbad105:     public String getOutboundUsername() {
1:49e8a80:         return outboundUsername;
6:49e8a80:     }
7:49e8a80: 
1:49e8a80:     /**
1:74a7a8b:      * @param outboundUsername The outboundUsername to set.
1:49e8a80:      */
1:fbad105:     public void setOutboundUsername(String outboundUsername) {
1:fbad105:         this.outboundUsername = outboundUsername;
1:49e8a80:     }
1:bc78238: 
1:4acbd59:     /**
1:4acbd59:      * @return the outboundClientId
1:4acbd59:      */
1:4acbd59:     public String getOutboundClientId() {
1:4acbd59:         return outboundClientId;
1:4acbd59:     }
1:49e8a80: 
1:4acbd59:     /**
1:4acbd59:      * @param outboundClientId the outboundClientId to set
1:4acbd59:      */
1:4acbd59:     public void setOutboundClientId(String outboundClientId) {
1:4acbd59:         this.outboundClientId = outboundClientId;
1:4acbd59:     }
1:4acbd59: 
1:4acbd59:     /**
1:4acbd59:      * @return the localClientId
1:4acbd59:      */
1:4acbd59:     public String getLocalClientId() {
1:4acbd59:         return localClientId;
1:4acbd59:     }
1:4acbd59: 
1:4acbd59:     /**
1:4acbd59:      * @param localClientId the localClientId to set
1:4acbd59:      */
1:4acbd59:     public void setLocalClientId(String localClientId) {
1:4acbd59:         this.localClientId = localClientId;
1:4acbd59:     }
1:bc78238: 
1:bc78238:     /**
1:bc78238:      * @return the currently configured reconnection policy.
1:bc78238:      */
1:bc78238:     public ReconnectionPolicy getReconnectionPolicy() {
1:bc78238:         return this.policy;
1:bc78238:     }
1:bc78238: 
1:bc78238:     /**
1:bc78238:      * @param policy The new reconnection policy this {@link JmsConnector} should use.
1:bc78238:      */
1:bc78238:     public void setReconnectionPolicy(ReconnectionPolicy policy) {
1:bc78238:         this.policy = policy;
1:bc78238:     }
1:bc78238: 
1:bc78238:     /**
1:c176fa8:      * @return the preferJndiDestinationLookup
1:c176fa8:      */
1:c176fa8:     public boolean isPreferJndiDestinationLookup() {
1:c176fa8:         return preferJndiDestinationLookup;
1:c176fa8:     }
1:c176fa8: 
1:c176fa8:     /**
1:c176fa8:      * Sets whether the connector should prefer to first try to find a destination in JNDI before
1:c176fa8:      * using JMS semantics to create a Destination.  By default the connector will first use JMS
1:c176fa8:      * semantics and then fall-back to JNDI lookup, setting this value to true will reverse that
1:c176fa8:      * ordering.
1:d29ca2a:      *
1:c176fa8:      * @param preferJndiDestinationLookup the preferJndiDestinationLookup to set
1:c176fa8:      */
1:c176fa8:     public void setPreferJndiDestinationLookup(boolean preferJndiDestinationLookup) {
1:c176fa8:         this.preferJndiDestinationLookup = preferJndiDestinationLookup;
1:c176fa8:     }
1:c176fa8: 
1:c176fa8:     /**
1:bc78238:      * @return returns true if the {@link JmsConnector} is connected to both brokers.
1:bc78238:      */
1:bc78238:     public boolean isConnected() {
1:bc78238:         return localConnection.get() != null && foreignConnection.get() != null;
1:bc78238:     }
1:bc78238: 
1:fbad105:     protected void addInboundBridge(DestinationBridge bridge) {
1:bc78238:         if (!inboundBridges.contains(bridge)) {
2:d29ca2a:             inboundBridges.add(bridge);
1:d29ca2a:         }
1:bc78238:     }
1:d29ca2a: 
1:fbad105:     protected void addOutboundBridge(DestinationBridge bridge) {
1:bc78238:         if (!outboundBridges.contains(bridge)) {
2:d29ca2a:             outboundBridges.add(bridge);
1:b2ad8fa:         }
1:d29ca2a:     }
1:b2ad8fa: 
1:fbad105:     protected void removeInboundBridge(DestinationBridge bridge) {
1:eaea516:         inboundBridges.remove(bridge);
1:d29ca2a:     }
1:b2ad8fa: 
1:fbad105:     protected void removeOutboundBridge(DestinationBridge bridge) {
1:eaea516:         outboundBridges.remove(bridge);
1:bc78238:     }
1:4acbd59: 
1:b2ad8fa:     public String getName() {
1:fbad105:         if (name == null) {
1:fbad105:             name = "Connector:" + getNextId();
1:b2ad8fa:         }
1:b2ad8fa:         return name;
1:b2ad8fa:     }
1:b2ad8fa: 
1:b2ad8fa:     public void setName(String name) {
1:b2ad8fa:         this.name = name;
1:b2ad8fa:     }
1:4acbd59: 
1:fc00993:     private static synchronized int getNextId() {
1:ea7dd79:         return nextId++;
1:bc78238:     }
1:bc78238: 
1:bc78238:     public boolean isFailed() {
1:bc78238:         return this.failed.get();
1:bc78238:     }
1:bc78238: 
1:bc78238:     /**
1:bc78238:      * Performs the work of connection to the local side of the Connection.
1:bc78238:      * <p>
1:bc78238:      * This creates the initial connection to the local end of the {@link JmsConnector}
1:bc78238:      * and then sets up all the destination bridges with the information needed to bridge
1:bc78238:      * on the local side of the connection.
1:d29ca2a:      *
1:bc78238:      * @throws Exception if the connection cannot be established for any reason.
1:bc78238:      */
1:bc78238:     protected abstract void initializeLocalConnection() throws Exception;
1:bc78238: 
1:bc78238:     /**
1:bc78238:      * Performs the work of connection to the foreign side of the Connection.
1:bc78238:      * <p>
1:bc78238:      * This creates the initial connection to the foreign end of the {@link JmsConnector}
1:bc78238:      * and then sets up all the destination bridges with the information needed to bridge
1:bc78238:      * on the foreign side of the connection.
1:d29ca2a:      *
1:bc78238:      * @throws Exception if the connection cannot be established for any reason.
1:bc78238:      */
1:bc78238:     protected abstract void initializeForeignConnection() throws Exception;
1:bc78238: 
1:bc78238:     /**
1:bc78238:      * Callback method that the Destination bridges can use to report an exception to occurs
1:bc78238:      * during normal bridging operations.
1:d29ca2a:      *
1:bc78238:      * @param connection
1:bc78238:      * 		The connection that was in use when the failure occured.
1:bc78238:      */
1:bc78238:     void handleConnectionFailure(Connection connection) {
1:bc78238: 
1:bc78238:         // Can happen if async exception listener kicks in at the same time.
1:bc78238:         if (connection == null || !this.started.get()) {
1:bc78238:             return;
1:bc78238:         }
1:bc78238: 
1:e1bbde7:         LOG.info("JmsConnector handling loss of connection [{}]", connection.toString());
1:bc78238: 
1:bc78238:         // TODO - How do we handle the re-wiring of replyToBridges in this case.
1:bc78238:         replyToBridges.clear();
1:bc78238: 
1:ccf4b9f:         if (this.foreignConnection.compareAndSet(connection, null)) {
1:bc78238: 
1:bc78238:             // Stop the inbound bridges when the foreign connection is dropped since
1:bc78238:             // the bridge has no consumer and needs to be restarted once a new connection
1:bc78238:             // to the foreign side is made.
1:bc78238:             for (DestinationBridge bridge : inboundBridges) {
1:bc78238:                 try {
1:d29ca2a:                     bridge.stop();
1:bc78238:                 } catch(Exception e) {
1:bc78238:                 }
1:bc78238:             }
1:bc78238: 
1:bc78238:             // We got here first and cleared the connection, now we queue a reconnect.
1:1b49374:             this.connectionService.execute(new Runnable() {
1:bc78238: 
1:bc78238:                 @Override
1:bc78238:                 public void run() {
2:bc78238:                     try {
1:bc78238:                         doInitializeConnection(false);
1:bc78238:                     } catch (Exception e) {
1:e1bbde7:                         LOG.error("Failed to initialize foreign connection for the JMSConnector", e);
1:bc78238:                     }
1:bc78238:                 }
1:bc78238:             });
1:bc78238: 
1:ccf4b9f:         } else if (this.localConnection.compareAndSet(connection, null)) {
1:bc78238: 
1:bc78238:             // Stop the outbound bridges when the local connection is dropped since
1:bc78238:             // the bridge has no consumer and needs to be restarted once a new connection
1:bc78238:             // to the local side is made.
1:bc78238:             for (DestinationBridge bridge : outboundBridges) {
1:bc78238:                 try {
1:d29ca2a:                     bridge.stop();
1:bc78238:                 } catch(Exception e) {
1:bc78238:                 }
1:bc78238:             }
1:bc78238: 
1:bc78238:             // We got here first and cleared the connection, now we queue a reconnect.
1:1b49374:             this.connectionService.execute(new Runnable() {
1:bc78238: 
1:bc78238:                 @Override
1:bc78238:                 public void run() {
1:bc78238:                     try {
1:bc78238:                         doInitializeConnection(true);
1:bc78238:                     } catch (Exception e) {
1:bc78238:                         LOG.error("Failed to initialize local connection for the JMSConnector", e);
1:bc78238:                     }
1:bc78238:                 }
1:bc78238:             });
1:bc78238:         }
1:bc78238:     }
1:bc78238: 
1:bc78238:     private void scheduleAsyncLocalConnectionReconnect() {
1:1b49374:         this.connectionService.execute(new Runnable() {
1:bc78238:             @Override
1:bc78238:             public void run() {
1:bc78238:                 try {
1:bc78238:                     doInitializeConnection(true);
1:bc78238:                 } catch (Exception e) {
1:bc78238:                     LOG.error("Failed to initialize local connection for the JMSConnector", e);
1:bc78238:                 }
1:bc78238:             }
1:bc78238:         });
1:bc78238:     }
1:bc78238: 
1:bc78238:     private void scheduleAsyncForeignConnectionReconnect() {
1:1b49374:         this.connectionService.execute(new Runnable() {
1:bc78238:             @Override
1:bc78238:             public void run() {
1:bc78238:                 try {
1:bc78238:                     doInitializeConnection(false);
1:bc78238:                 } catch (Exception e) {
1:e1bbde7:                     LOG.error("Failed to initialize foreign connection for the JMSConnector", e);
1:bc78238:                 }
1:bc78238:             }
1:bc78238:         });
1:bc78238:     }
1:bc78238: 
1:bc78238:     private void doInitializeConnection(boolean local) throws Exception {
1:bc78238: 
1:1b49374:         ThreadPoolExecutor connectionService = this.connectionService;
1:bc78238:         int attempt = 0;
1:bc78238: 
1:bc78238:         final int maxRetries;
1:bc78238:         if (local) {
1:bc78238:             maxRetries = !localSideInitialized.get() ? policy.getMaxInitialConnectAttempts() :
1:bc78238:                                                        policy.getMaxReconnectAttempts();
1:bc78238:         } else {
1:bc78238:             maxRetries = !foreignSideInitialized.get() ? policy.getMaxInitialConnectAttempts() :
1:bc78238:                                                          policy.getMaxReconnectAttempts();
1:bc78238:         }
1:bc78238: 
1:1b49374:         do {
1:bc78238:             if (attempt > 0) {
1:bc78238:                 try {
1:e05db7c:                     long nextDelay = policy.getNextDelay(attempt);
1:e05db7c:                     LOG.debug("Bridge reconnect attempt {} waiting {}ms before next attempt.", attempt, nextDelay);
1:e05db7c:                     Thread.sleep(nextDelay);
1:bc78238:                 } catch(InterruptedException e) {
1:bc78238:                 }
1:bc78238:             }
1:bc78238: 
1:1b49374:             if (connectionService.isTerminating()) {
1:bc78238:                 return;
1:bc78238:             }
1:bc78238: 
1:bc78238:             try {
1:bc78238: 
1:bc78238:                 if (local) {
1:bc78238:                     initializeLocalConnection();
1:bc78238:                     localSideInitialized.set(true);
1:bc78238:                 } else {
1:bc78238:                     initializeForeignConnection();
1:bc78238:                     foreignSideInitialized.set(true);
1:bc78238:                 }
1:bc78238: 
1:bc78238:                 // Once we are connected we ensure all the bridges are started.
1:bc78238:                 if (localConnection.get() != null && foreignConnection.get() != null) {
1:bc78238:                     for (DestinationBridge bridge : inboundBridges) {
1:d29ca2a:                         bridge.start();
1:bc78238:                     }
1:bc78238:                     for (DestinationBridge bridge : outboundBridges) {
1:d29ca2a:                         bridge.start();
1:bc78238:                     }
1:bc78238:                 }
1:bc78238: 
1:bc78238:                 return;
1:bc78238:             } catch(Exception e) {
1:e1bbde7:                 LOG.debug("Failed to establish initial {} connection for JmsConnector [{}]", new Object[]{ (local ? "local" : "foreign"), attempt }, e);
1:e05db7c:             } finally {
1:e05db7c:                 attempt++;
1:bc78238:             }
1:bc78238:         }
1:e05db7c:         while ((maxRetries == INFINITE || maxRetries > attempt) && !connectionService.isShutdown());
1:bc78238: 
1:bc78238:         this.failed.set(true);
1:bc78238:     }
1:bc78238: 
1:ccf4b9f:     private final ThreadFactory factory = new ThreadFactory() {
1:ccf4b9f:         @Override
1:bc78238:         public Thread newThread(Runnable runnable) {
1:bc78238:             Thread thread = new Thread(runnable, "JmsConnector Async Connection Task: ");
1:bc78238:             thread.setDaemon(true);
1:bc78238:             return thread;
1:bc78238:         }
1:ac66a09:     };
1:bc78238: 
1:bc78238:     private ThreadPoolExecutor createExecutor() {
1:bc78238:         ThreadPoolExecutor exec = new ThreadPoolExecutor(0, 2, 30, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), factory);
1:bc78238:         exec.allowCoreThreadTimeOut(true);
1:bc78238:         return exec;
1:bc78238:     }
1:49e8a80: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Timothy Bish
-------------------------------------------------------------------------------
commit:e05db7c
/////////////////////////////////////////////////////////////////////////
1:                     long nextDelay = policy.getNextDelay(attempt);
1:                     LOG.debug("Bridge reconnect attempt {} waiting {}ms before next attempt.", attempt, nextDelay);
1:                     Thread.sleep(nextDelay);
/////////////////////////////////////////////////////////////////////////
1:             } finally {
1:                 attempt++;
1:         while ((maxRetries == INFINITE || maxRetries > attempt) && !connectionService.isShutdown());
commit:5e05df1
/////////////////////////////////////////////////////////////////////////
1:      * @param jmsMessageConvertor The jmsMessageConvertor to set.
commit:1b49374
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.activemq.network.jms.ReconnectionPolicy.INFINITE;
1: 
/////////////////////////////////////////////////////////////////////////
1:     protected ThreadPoolExecutor connectionService;
/////////////////////////////////////////////////////////////////////////
1:             connectionService = createExecutor();
/////////////////////////////////////////////////////////////////////////
1:             ThreadPoolUtils.shutdown(connectionService);
1:             connectionService = null;
/////////////////////////////////////////////////////////////////////////
1:             this.connectionService.execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
1:             this.connectionService.execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
1:         this.connectionService.execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
1:         this.connectionService.execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
1:         ThreadPoolExecutor connectionService = this.connectionService;
/////////////////////////////////////////////////////////////////////////
1:         do {
/////////////////////////////////////////////////////////////////////////
1:             if (connectionService.isTerminating()) {
/////////////////////////////////////////////////////////////////////////
0:         while ((maxRetries == INFINITE || maxRetries > ++attempt) && !connectionService.isShutdown());
commit:ccf4b9f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final List<DestinationBridge> inboundBridges = new CopyOnWriteArrayList<DestinationBridge>();
1:     private final List<DestinationBridge> outboundBridges = new CopyOnWriteArrayList<DestinationBridge>();
1:             @Override
1:                     DestinationBridge bridge = lru.getValue();
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:             if (foreignConnection.get() != null) {
1:                 try {
1:                     foreignConnection.get().close();
1:                 } catch (Exception e) {
1:                 }
1:             }
1: 
1:             if (localConnection.get() != null) {
1:                 try {
1:                     localConnection.get().close();
1:                 } catch (Exception e) {
1:                 }
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (this.foreignConnection.compareAndSet(connection, null)) {
/////////////////////////////////////////////////////////////////////////
1:         } else if (this.localConnection.compareAndSet(connection, null)) {
/////////////////////////////////////////////////////////////////////////
1:     private final ThreadFactory factory = new ThreadFactory() {
1:         @Override
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
1:                         LOG.info("Expired bridge: {}", bridge);
0:                         LOG.warn("stopping expired bridge {} caused an exception", bridge, e);
/////////////////////////////////////////////////////////////////////////
0:             LOG.info("JMS Connector {} Started", getName());
/////////////////////////////////////////////////////////////////////////
0:             LOG.info("JMS Connector {} Stopped", getName());
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("JmsConnector handling loss of connection [{}]", connection.toString());
/////////////////////////////////////////////////////////////////////////
1:                         LOG.error("Failed to initialize foreign connection for the JMSConnector", e);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.error("Failed to initialize foreign connection for the JMSConnector", e);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Failed to establish initial {} connection for JmsConnector [{}]", new Object[]{ (local ? "local" : "foreign"), attempt }, e);
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:59af747
/////////////////////////////////////////////////////////////////////////
1:                         LOG.warn("Stopping expired bridge {} caused an exception", bridge, e);
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("JMS Connector {} started", getName());
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("JMS Connector {} stopped", getName());
commit:6c1676b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.ThreadPoolUtils;
/////////////////////////////////////////////////////////////////////////
0:             ThreadPoolUtils.shutdown(connectionSerivce);
0:             connectionSerivce = null;
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:7c9fec6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected JndiLookupFactory jndiLocalTemplate;
1:     protected JndiLookupFactory jndiOutboundTemplate;
/////////////////////////////////////////////////////////////////////////
1:                 jndiLocalTemplate = new JndiLookupFactory();
1:                 jndiOutboundTemplate = new JndiLookupFactory();
/////////////////////////////////////////////////////////////////////////
1:     public JndiLookupFactory getJndiLocalTemplate() {
1:     public void setJndiLocalTemplate(JndiLookupFactory jndiTemplate) {
1:     public JndiLookupFactory getJndiOutboundTemplate() {
1:     public void setJndiOutboundTemplate(JndiLookupFactory jndiOutboundTemplate) {
commit:58aca86
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
1:     private static int nextId;
1:     
/////////////////////////////////////////////////////////////////////////
0:     protected LRUCache replyToBridges = createLRUCache();
1: 
0:     private List<DestinationBridge> inboundBridges = new CopyOnWriteArrayList<DestinationBridge>();
0:     private List<DestinationBridge> outboundBridges = new CopyOnWriteArrayList<DestinationBridge>();
/////////////////////////////////////////////////////////////////////////
0:                 DestinationBridge bridge = inboundBridges.get(i);
0:                 DestinationBridge bridge = outboundBridges.get(i);
/////////////////////////////////////////////////////////////////////////
0:                 DestinationBridge bridge = inboundBridges.get(i);
0:                 DestinationBridge bridge = outboundBridges.get(i);
/////////////////////////////////////////////////////////////////////////
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(JmsConnector.class);
/////////////////////////////////////////////////////////////////////////
0:     private static LRUCache createLRUCache() {
/////////////////////////////////////////////////////////////////////////
0:                         LOG.info("Expired bridge: " + bridge);
0:                         LOG.warn("stopping expired bridge" + bridge + " caused an exception", e);
/////////////////////////////////////////////////////////////////////////
0:             LOG.info("JMS Connector " + getName() + " Started");
/////////////////////////////////////////////////////////////////////////
0:             LOG.info("JMS Connector " + getName() + " Stopped");
/////////////////////////////////////////////////////////////////////////
1:     private static synchronized int getNextId() {
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.CopyOnWriteArrayList;
1: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     protected LRUCache replyToBridges = createLRUCache();
1: 
0:     static private LRUCache createLRUCache() {
0:         return new LRUCache() {
1:             private static final long serialVersionUID = -7446792754185879286L;
1: 
0:             protected boolean removeEldestEntry(Map.Entry enty) {
1:                 if (size() > maxCacheSize) {
0:                     Iterator iter = entrySet().iterator();
0:                     Map.Entry lru = (Map.Entry)iter.next();
1:                     remove(lru.getKey());
0:                     DestinationBridge bridge = (DestinationBridge)lru.getValue();
1:                     try {
1:                         bridge.stop();
0:                         log.info("Expired bridge: " + bridge);
1:                     } catch (Exception e) {
0:                         log.warn("stopping expired bridge" + bridge + " caused an exception", e);
1:                     }
1:                 }
1:                 return false;
1:             }
1:         };
/////////////////////////////////////////////////////////////////////////
0:                 DestinationBridge bridge = (DestinationBridge)inboundBridges.get(i);
0:                 DestinationBridge bridge = (DestinationBridge)outboundBridges.get(i);
/////////////////////////////////////////////////////////////////////////
0:                 DestinationBridge bridge = (DestinationBridge)inboundBridges.get(i);
0:                 DestinationBridge bridge = (DestinationBridge)outboundBridges.get(i);
/////////////////////////////////////////////////////////////////////////
1:      * @param jndiTemplate The jndiTemplate to set.
/////////////////////////////////////////////////////////////////////////
1:      * @param jndiOutboundTemplate The jndiOutboundTemplate to set.
/////////////////////////////////////////////////////////////////////////
0:      * @param inboundMessageConvertor The inboundMessageConvertor to set.
/////////////////////////////////////////////////////////////////////////
1:      * @param outboundMessageConvertor The outboundMessageConvertor to set.
/////////////////////////////////////////////////////////////////////////
0:      * @param replyToDestinationCacheSize The replyToDestinationCacheSize to
0:      *                set.
/////////////////////////////////////////////////////////////////////////
1:      * @param localPassword The localPassword to set.
/////////////////////////////////////////////////////////////////////////
1:      * @param localUsername The localUsername to set.
/////////////////////////////////////////////////////////////////////////
1:      * @param outboundPassword The outboundPassword to set.
/////////////////////////////////////////////////////////////////////////
1:      * @param outboundUsername The outboundUsername to set.
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.CopyOnWriteArrayList;
0: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
1: }
commit:ac66a09
/////////////////////////////////////////////////////////////////////////
0:     protected LRUCache replyToBridges = createLRUCache(); 
1:     	
0:     static private LRUCache createLRUCache() { 
0:     	return new LRUCache() {
0: 	        private static final long serialVersionUID = -7446792754185879286L;
1: 	
0: 	        protected boolean removeEldestEntry(Map.Entry enty) {
0: 	            if (size() > maxCacheSize) {
0: 	                Iterator iter = entrySet().iterator();
0: 	                Map.Entry lru = (Map.Entry) iter.next();
0: 	                remove(lru.getKey());
0: 	                DestinationBridge bridge = (DestinationBridge) lru.getValue();
1: 	                try {
1: 	                    bridge.stop();
0: 	                    log.info("Expired bridge: " + bridge);
1: 	                }
0: 	                catch (Exception e) {
0: 	                    log.warn("stopping expired bridge" + bridge + " caused an exception", e);
1: 	                }
1: 	            }
0: 	            return false;
1: 	        }
1: 	    };
1:     }
1:     /**
1:      */
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:ea7dd79
/////////////////////////////////////////////////////////////////////////
1:         return nextId++;
commit:b2ad8fa
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:     protected String outboundUsername;
1:     protected String localPassword;
1:     private String name;
1:     
1:         /**
1:          * 
1:          */
0:         private static final long serialVersionUID = -7446792754185879286L;
1: 
/////////////////////////////////////////////////////////////////////////
0:             for(int i=0;i<inboundBridges.size();i++){
0:                 DestinationBridge bridge=(DestinationBridge) inboundBridges.get(i);
1:                 bridge.start();
1:             }
0:             for(int i=0;i<outboundBridges.size();i++){
0:                 DestinationBridge bridge=(DestinationBridge) outboundBridges.get(i);
1:                 bridge.start();
1:             }
0:             log.info("JMS Connector "+getName()+" Started");
/////////////////////////////////////////////////////////////////////////
0:             log.info("JMS Connector "+getName()+" Stopped");
/////////////////////////////////////////////////////////////////////////
1: 
1:     public String getName() {
0:         if( name == null ) {
0:             name = "Connector:"+getNextId();
1:         }
1:         return name;
1:     }
1:     
0:     static int nextId;
0:     static private synchronized int getNextId() {
0:         return nextId;
1:     }
1: 
1:     public void setName(String name) {
1:         this.name = name;
1:     }
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.network.jms;
1: 
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Map;
1: 
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.Service;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.util.LRUCache;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: import org.springframework.jndi.JndiTemplate;
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArrayList;
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean;
1: 
1: /**
0:  * This bridge joins the gap between foreign JMS providers and ActiveMQ As some JMS providers are still only 1.0.1
0:  * compliant, this bridge itself aimed to be JMS 1.0.2 compliant.
1:  * 
0:  * @version $Revision: 1.1.1.1 $
1:  */
0: public abstract class JmsConnector implements Service{
0:     private static final Log log=LogFactory.getLog(JmsConnector.class);
0:     protected JndiTemplate jndiTemplate;
0:     protected JmsMesageConvertor jmsMessageConvertor;
0:     private List inboundBridges = new CopyOnWriteArrayList();
0:     private List outboundBridges = new CopyOnWriteArrayList();
0:     protected int replyToDestinationCacheSize=10000;
1:     protected AtomicBoolean initialized = new AtomicBoolean(false);
1:     protected AtomicBoolean started = new AtomicBoolean(false);
0:     protected ActiveMQConnectionFactory  embeddedConnectionFactory;
0:     protected LRUCache replyToBridges=new LRUCache(){
0:         protected boolean removeEldestEntry(Map.Entry enty){
0:             if(size()>maxCacheSize){
0:                 Iterator iter=entrySet().iterator();
0:                 Map.Entry lru=(Map.Entry) iter.next();
0:                 remove(lru.getKey());
0:                 DestinationBridge bridge=(DestinationBridge) lru.getValue();
0:                 try{
1:                     bridge.stop();
0:                     log.info("Expired bridge: "+bridge);
0:                 }catch(Exception e){
0:                     log.warn("stopping expired bridge"+bridge+" caused an exception",e);
1:                 }
1:             }
0:             return false;
1:         }
0:     };
1: 
0:     public boolean init(){
0:         boolean result=initialized.compareAndSet(false,true);
0:         if(result){
0:             if(jndiTemplate==null){
0:                 jndiTemplate=new JndiTemplate();
1:             }
0:             if(jmsMessageConvertor==null){
0:                 jmsMessageConvertor=new SimpleJmsMessageConvertor();
1:             }
1:             replyToBridges.setMaxCacheSize(getReplyToDestinationCacheSize());
1:         }
1:         return result;
1:     }
1:     
0:     public void start() throws Exception{
1:         init();
0:         if (started.compareAndSet(false, true)){
0:         for(int i=0;i<inboundBridges.size();i++){
0:             DestinationBridge bridge=(DestinationBridge) inboundBridges.get(i);
1:             bridge.start();
1:         }
0:         for(int i=0;i<outboundBridges.size();i++){
0:             DestinationBridge bridge=(DestinationBridge) outboundBridges.get(i);
1:             bridge.start();
1:         }
1:         }
1:     }
1: 
0:     public void stop() throws Exception{
0:         if(started.compareAndSet(true,false)){
0:             for(int i=0;i<inboundBridges.size();i++){
0:                 DestinationBridge bridge=(DestinationBridge) inboundBridges.get(i);
1:                 bridge.stop();
1:             }
0:             for(int i=0;i<outboundBridges.size();i++){
0:                 DestinationBridge bridge=(DestinationBridge) outboundBridges.get(i);
1:                 bridge.stop();
1:             }
1:         }
1:     }
1:     
1:     /**
0:      * One way to configure the local connection - this is called by
0:      * The BrokerService when the Connector is embedded
1:      * @param service
1:      */
0:     public void setBrokerService(BrokerService service){
1:         embeddedConnectionFactory = new ActiveMQConnectionFactory(service.getVmConnectorURI());
1:     }
1: 
1:     /**
1:      * @return Returns the jndiTemplate.
1:      */
0:     public JndiTemplate getJndiTemplate(){
0:         return jndiTemplate;
1:     }
1: 
1:     /**
0:      * @param jndiTemplate
0:      *            The jndiTemplate to set.
1:      */
0:     public void setJndiTemplate(JndiTemplate jndiTemplate){
0:         this.jndiTemplate=jndiTemplate;
1:     }
1: 
1:     /**
0:      * @return Returns the jmsMessageConvertor.
1:      */
0:     public JmsMesageConvertor getJmsMessageConvertor(){
0:         return jmsMessageConvertor;
1:     }
1: 
1:     /**
0:      * @param jmsMessageConvertor
0:      *            The jmsMessageConvertor to set.
1:      */
0:     public void setJmsMessageConvertor(JmsMesageConvertor jmsMessageConvertor){
0:         this.jmsMessageConvertor=jmsMessageConvertor;
1:     }
1: 
1:     /**
1:      * @return Returns the replyToDestinationCacheSize.
1:      */
0:     public int getReplyToDestinationCacheSize(){
1:         return replyToDestinationCacheSize;
1:     }
1: 
1:     /**
0:      * @param replyToDestinationCacheSize
0:      *            The replyToDestinationCacheSize to set.
1:      */
0:     public void setReplyToDestinationCacheSize(int replyToDestinationCacheSize){
0:         this.replyToDestinationCacheSize=replyToDestinationCacheSize;
1:     }
1:     
1:     
0:     protected void addInboundBridge(DestinationBridge bridge){
1:         inboundBridges.add(bridge);
1:     }
1:     
0:     protected void addOutboundBridge(DestinationBridge bridge){
1:         outboundBridges.add(bridge);
1:     }
0:     protected void removeInboundBridge(DestinationBridge bridge){
1:         inboundBridges.add(bridge);
1:     }
1:     
0:     protected void removeOutboundBridge(DestinationBridge bridge){
1:         outboundBridges.add(bridge);
1:     }
1: }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:c176fa8
/////////////////////////////////////////////////////////////////////////
1:     protected boolean preferJndiDestinationLookup = false;
/////////////////////////////////////////////////////////////////////////
1:      * @return the preferJndiDestinationLookup
1:      */
1:     public boolean isPreferJndiDestinationLookup() {
1:         return preferJndiDestinationLookup;
1:     }
1: 
1:     /**
1:      * Sets whether the connector should prefer to first try to find a destination in JNDI before
1:      * using JMS semantics to create a Destination.  By default the connector will first use JMS
1:      * semantics and then fall-back to JNDI lookup, setting this value to true will reverse that
1:      * ordering.
0:      *
1:      * @param preferJndiDestinationLookup the preferJndiDestinationLookup to set
1:      */
1:     public void setPreferJndiDestinationLookup(boolean preferJndiDestinationLookup) {
1:         this.preferJndiDestinationLookup = preferJndiDestinationLookup;
1:     }
1: 
1:     /**
commit:bc78238
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.LinkedBlockingQueue;
1: import java.util.concurrent.ThreadFactory;
1: import java.util.concurrent.ThreadPoolExecutor;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicReference;
0: import javax.jms.QueueConnection;
/////////////////////////////////////////////////////////////////////////
1:  * JMS providers are still only in compliance with JMS v1.0.1 , this bridge itself
1:  * aimed to be in compliance with the JMS 1.0.2 specification.
1: 
1:     protected AtomicBoolean localSideInitialized = new AtomicBoolean(false);
1:     protected AtomicBoolean foreignSideInitialized = new AtomicBoolean(false);
1:     protected AtomicBoolean failed = new AtomicBoolean();
1:     protected AtomicReference<Connection> foreignConnection = new AtomicReference<Connection>();
1:     protected AtomicReference<Connection> localConnection = new AtomicReference<Connection>();
/////////////////////////////////////////////////////////////////////////
1:     protected LRUCache<Destination, DestinationBridge> replyToBridges = createLRUCache();
1:     private ReconnectionPolicy policy = new ReconnectionPolicy();
0:     protected ThreadPoolExecutor connectionSerivce;
1:     private static LRUCache<Destination, DestinationBridge> createLRUCache() {
1:         return new LRUCache<Destination, DestinationBridge>() {
1:             protected boolean removeEldestEntry(Map.Entry<Destination, DestinationBridge> enty) {
1:                     Iterator<Map.Entry<Destination, DestinationBridge>> iter = entrySet().iterator();
1:                     Map.Entry<Destination, DestinationBridge> lru = iter.next();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
0:             connectionSerivce = createExecutor();
1: 
1:             // Subclasses can override this to customize their own it.
1:             result = doConnectorInit();
1:     protected boolean doConnectorInit() {
1: 
1:         // We try to make a connection via a sync call first so that the
1:         // JmsConnector is fully initialized before the start call returns
1:         // in order to avoid missing any messages that are dispatched
1:         // immediately after startup.  If either side fails we queue an
1:         // asynchronous task to manage the reconnect attempts.
1: 
1:         try {
1:             initializeLocalConnection();
1:             localSideInitialized.set(true);
1:         } catch(Exception e) {
1:             // Queue up the task to attempt the local connection.
1:             scheduleAsyncLocalConnectionReconnect();
1:         }
1: 
1:         try {
1:             initializeForeignConnection();
1:             foreignSideInitialized.set(true);
1:         } catch(Exception e) {
1:             // Queue up the task for the foreign connection now.
1:             scheduleAsyncForeignConnectionReconnect();
1:         }
1: 
1:         return true;
1:     }
1: 
0:             init();
1:             for (DestinationBridge bridge : inboundBridges) {
1:             for (DestinationBridge bridge : outboundBridges) {
/////////////////////////////////////////////////////////////////////////
1: 
0:             this.connectionSerivce.shutdown();
1: 
1:             for (DestinationBridge bridge : inboundBridges) {
1:             for (DestinationBridge bridge : outboundBridges) {
1: 
1:         replyToBridges.clear();
/////////////////////////////////////////////////////////////////////////
0:      *
1:     public Connection getLocalConnection() {
1:         return this.localConnection.get();
1:     }
1: 
1:     public Connection getForeignConnection() {
1:         return this.foreignConnection.get();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:      * @param replyToDestinationCacheSize The replyToDestinationCacheSize to set.
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * @return the currently configured reconnection policy.
1:      */
1:     public ReconnectionPolicy getReconnectionPolicy() {
1:         return this.policy;
1:     }
1: 
1:     /**
1:      * @param policy The new reconnection policy this {@link JmsConnector} should use.
1:      */
1:     public void setReconnectionPolicy(ReconnectionPolicy policy) {
1:         this.policy = policy;
1:     }
1: 
1:     /**
1:      * @return returns true if the {@link JmsConnector} is connected to both brokers.
1:      */
1:     public boolean isConnected() {
1:         return localConnection.get() != null && foreignConnection.get() != null;
1:     }
1: 
1:         if (!inboundBridges.contains(bridge)) {
0:             inboundBridges.add(bridge);
1:         }
1:         if (!outboundBridges.contains(bridge)) {
0:             outboundBridges.add(bridge);
1:         }
/////////////////////////////////////////////////////////////////////////
0:     private static synchronized int getNextId() {
0:         return nextId++;
1:     }
1: 
1:     public boolean isFailed() {
1:         return this.failed.get();
1:     }
1: 
1:     /**
1:      * Performs the work of connection to the local side of the Connection.
1:      * <p>
1:      * This creates the initial connection to the local end of the {@link JmsConnector}
1:      * and then sets up all the destination bridges with the information needed to bridge
1:      * on the local side of the connection.
0:      *
1:      * @throws Exception if the connection cannot be established for any reason.
1:      */
1:     protected abstract void initializeLocalConnection() throws Exception;
1: 
1:     /**
1:      * Performs the work of connection to the foreign side of the Connection.
1:      * <p>
1:      * This creates the initial connection to the foreign end of the {@link JmsConnector}
1:      * and then sets up all the destination bridges with the information needed to bridge
1:      * on the foreign side of the connection.
0:      *
1:      * @throws Exception if the connection cannot be established for any reason.
1:      */
1:     protected abstract void initializeForeignConnection() throws Exception;
1: 
1:     /**
1:      * Callback method that the Destination bridges can use to report an exception to occurs
1:      * during normal bridging operations.
0:      *
1:      * @param connection
1:      * 		The connection that was in use when the failure occured.
1:      */
1:     void handleConnectionFailure(Connection connection) {
1: 
1:         // Can happen if async exception listener kicks in at the same time.
1:         if (connection == null || !this.started.get()) {
1:             return;
1:         }
1: 
0:         LOG.info("JmsConnector handling loss of connection [" + connection.toString() + "]");
1: 
1:         // TODO - How do we handle the re-wiring of replyToBridges in this case.
1:         replyToBridges.clear();
1: 
0:         if (this.foreignConnection.compareAndSet((QueueConnection)connection, null)) {
1: 
1:             // Stop the inbound bridges when the foreign connection is dropped since
1:             // the bridge has no consumer and needs to be restarted once a new connection
1:             // to the foreign side is made.
1:             for (DestinationBridge bridge : inboundBridges) {
1:                 try {
0:                     bridge.stop();
1:                 } catch(Exception e) {
1:                 }
1:             }
1: 
1:             // We got here first and cleared the connection, now we queue a reconnect.
0:             this.connectionSerivce.execute(new Runnable() {
1: 
1:                 @Override
1:                 public void run() {
1:                     try {
1:                         doInitializeConnection(false);
1:                     } catch (Exception e) {
0:                         LOG.error("Failed to initialize forgein connection for the JMSConnector", e);
1:                     }
1:                 }
1:             });
1: 
0:         } else if (this.localConnection.compareAndSet((QueueConnection)connection, null)) {
1: 
1:             // Stop the outbound bridges when the local connection is dropped since
1:             // the bridge has no consumer and needs to be restarted once a new connection
1:             // to the local side is made.
1:             for (DestinationBridge bridge : outboundBridges) {
1:                 try {
0:                     bridge.stop();
1:                 } catch(Exception e) {
1:                 }
1:             }
1: 
1:             // We got here first and cleared the connection, now we queue a reconnect.
0:             this.connectionSerivce.execute(new Runnable() {
1: 
1:                 @Override
1:                 public void run() {
1:                     try {
1:                         doInitializeConnection(true);
1:                     } catch (Exception e) {
1:                         LOG.error("Failed to initialize local connection for the JMSConnector", e);
1:                     }
1:                 }
1:             });
1:         }
1:     }
1: 
1:     private void scheduleAsyncLocalConnectionReconnect() {
0:         this.connectionSerivce.execute(new Runnable() {
1:             @Override
1:             public void run() {
1:                 try {
1:                     doInitializeConnection(true);
1:                 } catch (Exception e) {
1:                     LOG.error("Failed to initialize local connection for the JMSConnector", e);
1:                 }
1:             }
1:         });
1:     }
1: 
1:     private void scheduleAsyncForeignConnectionReconnect() {
0:         this.connectionSerivce.execute(new Runnable() {
1:             @Override
1:             public void run() {
1:                 try {
1:                     doInitializeConnection(false);
1:                 } catch (Exception e) {
0:                     LOG.error("Failed to initialize forgein connection for the JMSConnector", e);
1:                 }
1:             }
1:         });
1:     }
1: 
1:     private void doInitializeConnection(boolean local) throws Exception {
1: 
1:         int attempt = 0;
1: 
1:         final int maxRetries;
1:         if (local) {
1:             maxRetries = !localSideInitialized.get() ? policy.getMaxInitialConnectAttempts() :
1:                                                        policy.getMaxReconnectAttempts();
1:         } else {
1:             maxRetries = !foreignSideInitialized.get() ? policy.getMaxInitialConnectAttempts() :
1:                                                          policy.getMaxReconnectAttempts();
1:         }
1: 
0:         do
0:         {
1:             if (attempt > 0) {
1:                 try {
0:                     Thread.sleep(policy.getNextDelay(attempt));
1:                 } catch(InterruptedException e) {
1:                 }
1:             }
1: 
0:             if (connectionSerivce.isTerminating()) {
1:                 return;
1:             }
1: 
1:             try {
1: 
1:                 if (local) {
1:                     initializeLocalConnection();
1:                     localSideInitialized.set(true);
1:                 } else {
1:                     initializeForeignConnection();
1:                     foreignSideInitialized.set(true);
1:                 }
1: 
1:                 // Once we are connected we ensure all the bridges are started.
1:                 if (localConnection.get() != null && foreignConnection.get() != null) {
1:                     for (DestinationBridge bridge : inboundBridges) {
0:                         bridge.start();
1:                     }
1:                     for (DestinationBridge bridge : outboundBridges) {
0:                         bridge.start();
1:                     }
1:                 }
1: 
1:                 return;
1:             } catch(Exception e) {
0:                 LOG.debug("Failed to establish initial " + (local ? "local" : "foriegn") +
0:                           " connection for JmsConnector [" + attempt + "]: " + e.getMessage());
1:             }
1:         }
0:         while (maxRetries < ++attempt && !connectionSerivce.isTerminating());
1: 
1:         this.failed.set(true);
1:     }
1: 
0:     private ThreadFactory factory = new ThreadFactory() {
1:         public Thread newThread(Runnable runnable) {
1:             Thread thread = new Thread(runnable, "JmsConnector Async Connection Task: ");
1:             thread.setDaemon(true);
1:             return thread;
1:         }
0:     };
1: 
1:     private ThreadPoolExecutor createExecutor() {
1:         ThreadPoolExecutor exec = new ThreadPoolExecutor(0, 2, 30, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), factory);
1:         exec.allowCoreThreadTimeOut(true);
1:         return exec;
1:     }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(JmsConnector.class);
author:Robert Davies
-------------------------------------------------------------------------------
commit:eaea516
/////////////////////////////////////////////////////////////////////////
1:     
1:     public void clearBridges() {
1:         inboundBridges.clear();
1:         outboundBridges.clear();
1:     }
/////////////////////////////////////////////////////////////////////////
1:         inboundBridges.remove(bridge);
1:         outboundBridges.remove(bridge);
commit:4acbd59
/////////////////////////////////////////////////////////////////////////
1:     protected String outboundClientId;
1:     protected String localClientId;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * @return the outboundClientId
1:      */
1:     public String getOutboundClientId() {
1:         return outboundClientId;
1:     }
1:     /**
1:      * @param outboundClientId the outboundClientId to set
1:      */
1:     public void setOutboundClientId(String outboundClientId) {
1:         this.outboundClientId = outboundClientId;
1:     }
1: 
1:     /**
1:      * @return the localClientId
1:      */
1:     public String getLocalClientId() {
1:         return localClientId;
1:     }
1: 
1:     /**
1:      * @param localClientId the localClientId to set
1:      */
1:     public void setLocalClientId(String localClientId) {
1:         this.localClientId = localClientId;
1:     }
1:     
1:     
commit:49e8a80
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.Connection;
1: import javax.jms.Destination;
0: import javax.jms.Queue;
0: import javax.jms.QueueConnection;
/////////////////////////////////////////////////////////////////////////
0:     protected int replyToDestinationCacheSize=10000;
0:     protected  String outboundUsername;
1:     protected String outboundPassword;
1:     protected String localUsername;
0:     protected  String localPassword;
/////////////////////////////////////////////////////////////////////////
1:     protected abstract Destination createReplyToBridge(Destination destination, Connection consumerConnection, Connection producerConnection);
1:     
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @return Returns the localPassword.
1:      */
0:     public String getLocalPassword(){
1:         return localPassword;
1:     }
1: 
1:     /**
0:      * @param localPassword The localPassword to set.
1:      */
0:     public void setLocalPassword(String localPassword){
0:         this.localPassword=localPassword;
1:     }
1: 
1:     /**
1:      * @return Returns the localUsername.
1:      */
0:     public String getLocalUsername(){
1:         return localUsername;
1:     }
1: 
1:     /**
0:      * @param localUsername The localUsername to set.
1:      */
0:     public void setLocalUsername(String localUsername){
0:         this.localUsername=localUsername;
1:     }
1: 
1:     /**
1:      * @return Returns the outboundPassword.
1:      */
0:     public String getOutboundPassword(){
1:         return outboundPassword;
1:     }
1: 
1:     /**
0:      * @param outboundPassword The outboundPassword to set.
1:      */
0:     public void setOutboundPassword(String outboundPassword){
0:         this.outboundPassword=outboundPassword;
1:     }
1: 
1:     /**
1:      * @return Returns the outboundUsername.
1:      */
0:     public String getOutboundUsername(){
1:         return outboundUsername;
1:     }
1: 
1:     /**
0:      * @param outboundUsername The outboundUsername to set.
1:      */
0:     public void setOutboundUsername(String outboundUsername){
0:         this.outboundUsername=outboundUsername;
1:     }
1: 
commit:6ea186c
/////////////////////////////////////////////////////////////////////////
1:     protected JmsMesageConvertor inboundMessageConvertor;
1:     protected JmsMesageConvertor outboundMessageConvertor;
/////////////////////////////////////////////////////////////////////////
0:             if(inboundMessageConvertor==null){
0:                 inboundMessageConvertor=new SimpleJmsMessageConvertor();
0:             }
0:             if (outboundMessageConvertor==null){
0:                 outboundMessageConvertor=new SimpleJmsMessageConvertor();
/////////////////////////////////////////////////////////////////////////
1:      * @return Returns the inboundMessageConvertor.
0:     public JmsMesageConvertor getInboundMessageConvertor(){
1:         return inboundMessageConvertor;
0:      * @param inboundMessageConvertor
0:      *            The inboundMessageConvertor to set.
0:     public void setInboundMessageConvertor(JmsMesageConvertor jmsMessageConvertor){
0:         this.inboundMessageConvertor=jmsMessageConvertor;
0:     }
0: 
1:     /**
1:      * @return Returns the outboundMessageConvertor.
1:      */
0:     public JmsMesageConvertor getOutboundMessageConvertor(){
1:         return outboundMessageConvertor;
0:     }
0: 
1:     /**
0:      * @param outboundMessageConvertor The outboundMessageConvertor to set.
1:      */
0:     public void setOutboundMessageConvertor(JmsMesageConvertor outboundMessageConvertor){
0:         this.outboundMessageConvertor=outboundMessageConvertor;
commit:e1bc55d
/////////////////////////////////////////////////////////////////////////
0:     protected JndiTemplate jndiLocalTemplate;
0:     protected JndiTemplate jndiOutboundTemplate;
/////////////////////////////////////////////////////////////////////////
0:             if(jndiLocalTemplate==null){
0:                 jndiLocalTemplate=new JndiTemplate();
0:             }
0:             if(jndiOutboundTemplate==null){
0:                 jndiOutboundTemplate=new JndiTemplate();
/////////////////////////////////////////////////////////////////////////
0:     public JndiTemplate getJndiLocalTemplate(){
1:         return jndiLocalTemplate;
0:     public void setJndiLocalTemplate(JndiTemplate jndiTemplate){
0:         this.jndiLocalTemplate=jndiTemplate;
0:     }
0: 
0:     /**
1:      * @return Returns the jndiOutboundTemplate.
0:      */
0:     public JndiTemplate getJndiOutboundTemplate(){
1:         return jndiOutboundTemplate;
0:     }
0: 
0:     /**
0:      * @param jndiOutboundTemplate The jndiOutboundTemplate to set.
0:      */
0:     public void setJndiOutboundTemplate(JndiTemplate jndiOutboundTemplate){
0:         this.jndiOutboundTemplate=jndiOutboundTemplate;
author:James Strachan
-------------------------------------------------------------------------------
commit:fbad105
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.JMSException;
0: import javax.naming.NamingException;
/////////////////////////////////////////////////////////////////////////
1:  * This bridge joins the gap between foreign JMS providers and ActiveMQ As some
0:  * JMS providers are still only 1.0.1 compliant, this bridge itself aimed to be
0:  * JMS 1.0.2 compliant.
1: public abstract class JmsConnector implements Service {
0: 
0:     private static final Log log = LogFactory.getLog(JmsConnector.class);
/////////////////////////////////////////////////////////////////////////
1:     protected ActiveMQConnectionFactory embeddedConnectionFactory;
1:     protected int replyToDestinationCacheSize = 10000;
0: 
0:     protected LRUCache replyToBridges = new LRUCache() {
0:         protected boolean removeEldestEntry(Map.Entry enty) {
0:             if (size() > maxCacheSize) {
0:                 Iterator iter = entrySet().iterator();
0:                 Map.Entry lru = (Map.Entry) iter.next();
0:                 DestinationBridge bridge = (DestinationBridge) lru.getValue();
0:                 try {
0:                     log.info("Expired bridge: " + bridge);
0:                 }
0:                 catch (Exception e) {
0:                     log.warn("stopping expired bridge" + bridge + " caused an exception", e);
1:     public boolean init() {
1:         boolean result = initialized.compareAndSet(false, true);
1:         if (result) {
1:             if (jndiLocalTemplate == null) {
0:                 jndiLocalTemplate = new JndiTemplate();
1:             if (jndiOutboundTemplate == null) {
0:                 jndiOutboundTemplate = new JndiTemplate();
1:             if (inboundMessageConvertor == null) {
1:                 inboundMessageConvertor = new SimpleJmsMessageConvertor();
1:             if (outboundMessageConvertor == null) {
1:                 outboundMessageConvertor = new SimpleJmsMessageConvertor();
0: 
1:     public void start() throws Exception {
1:         if (started.compareAndSet(false, true)) {
0:             for (int i = 0; i < inboundBridges.size(); i++) {
0:                 DestinationBridge bridge = (DestinationBridge) inboundBridges.get(i);
0:             for (int i = 0; i < outboundBridges.size(); i++) {
0:                 DestinationBridge bridge = (DestinationBridge) outboundBridges.get(i);
0:             log.info("JMS Connector " + getName() + " Started");
1:     public void stop() throws Exception {
1:         if (started.compareAndSet(true, false)) {
0:             for (int i = 0; i < inboundBridges.size(); i++) {
0:                 DestinationBridge bridge = (DestinationBridge) inboundBridges.get(i);
0:             for (int i = 0; i < outboundBridges.size(); i++) {
0:                 DestinationBridge bridge = (DestinationBridge) outboundBridges.get(i);
0:             log.info("JMS Connector " + getName() + " Stopped");
0: 
0: 
1:      * One way to configure the local connection - this is called by The
1:      * BrokerService when the Connector is embedded
0:      * 
1:     public void setBrokerService(BrokerService service) {
0:     public JndiTemplate getJndiLocalTemplate() {
/////////////////////////////////////////////////////////////////////////
0:     public void setJndiLocalTemplate(JndiTemplate jndiTemplate) {
1:         this.jndiLocalTemplate = jndiTemplate;
0:     public JndiTemplate getJndiOutboundTemplate() {
0:      * @param jndiOutboundTemplate
0:      *            The jndiOutboundTemplate to set.
0:     public void setJndiOutboundTemplate(JndiTemplate jndiOutboundTemplate) {
1:         this.jndiOutboundTemplate = jndiOutboundTemplate;
1:     public JmsMesageConvertor getInboundMessageConvertor() {
/////////////////////////////////////////////////////////////////////////
1:     public void setInboundMessageConvertor(JmsMesageConvertor jmsMessageConvertor) {
1:         this.inboundMessageConvertor = jmsMessageConvertor;
1:     public JmsMesageConvertor getOutboundMessageConvertor() {
0:      * @param outboundMessageConvertor
0:      *            The outboundMessageConvertor to set.
1:     public void setOutboundMessageConvertor(JmsMesageConvertor outboundMessageConvertor) {
1:         this.outboundMessageConvertor = outboundMessageConvertor;
1:     public int getReplyToDestinationCacheSize() {
/////////////////////////////////////////////////////////////////////////
1:     public void setReplyToDestinationCacheSize(int replyToDestinationCacheSize) {
1:         this.replyToDestinationCacheSize = replyToDestinationCacheSize;
0: 
1:     public String getLocalPassword() {
0:      * @param localPassword
0:      *            The localPassword to set.
1:     public void setLocalPassword(String localPassword) {
1:         this.localPassword = localPassword;
1:     public String getLocalUsername() {
0:      * @param localUsername
0:      *            The localUsername to set.
1:     public void setLocalUsername(String localUsername) {
1:         this.localUsername = localUsername;
1:     public String getOutboundPassword() {
0:      * @param outboundPassword
0:      *            The outboundPassword to set.
1:     public void setOutboundPassword(String outboundPassword) {
1:         this.outboundPassword = outboundPassword;
1:     public String getOutboundUsername() {
0:      * @param outboundUsername
0:      *            The outboundUsername to set.
1:     public void setOutboundUsername(String outboundUsername) {
1:         this.outboundUsername = outboundUsername;
1:     protected void addInboundBridge(DestinationBridge bridge) {
0: 
1:     protected void addOutboundBridge(DestinationBridge bridge) {
0: 
1:     protected void removeInboundBridge(DestinationBridge bridge) {
0: 
1:     protected void removeOutboundBridge(DestinationBridge bridge) {
1:         if (name == null) {
1:             name = "Connector:" + getNextId();
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:     public abstract void restartProducerConnection() throws NamingException, JMSException;
============================================================================