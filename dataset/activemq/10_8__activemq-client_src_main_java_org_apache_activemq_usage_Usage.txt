1:6d8e2c5: /**
1:6d8e2c5:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:6d8e2c5:  * contributor license agreements.  See the NOTICE file distributed with
1:6d8e2c5:  * this work for additional information regarding copyright ownership.
1:6d8e2c5:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:6d8e2c5:  * (the "License"); you may not use this file except in compliance with
1:6d8e2c5:  * the License.  You may obtain a copy of the License at
1:8e388b8:  *
1:6d8e2c5:  *      http://www.apache.org/licenses/LICENSE-2.0
1:8e388b8:  *
1:6d8e2c5:  * Unless required by applicable law or agreed to in writing, software
1:6d8e2c5:  * distributed under the License is distributed on an "AS IS" BASIS,
1:6d8e2c5:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:6d8e2c5:  * See the License for the specific language governing permissions and
1:6d8e2c5:  * limitations under the License.
2:6d8e2c5:  */
1:6d8e2c5: package org.apache.activemq.usage;
21:6d8e2c5: 
1:6d8e2c5: import java.util.LinkedList;
1:6d8e2c5: import java.util.List;
1:6d8e2c5: import java.util.concurrent.CopyOnWriteArrayList;
1:2cb2119: import java.util.concurrent.ThreadPoolExecutor;
1:b820ac2: import java.util.concurrent.TimeUnit;
1:2cb2119: import java.util.concurrent.atomic.AtomicBoolean;
1:b820ac2: import java.util.concurrent.locks.Condition;
1:b820ac2: import java.util.concurrent.locks.ReentrantReadWriteLock;
1:b820ac2: 
1:6d8e2c5: import org.apache.activemq.Service;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:6d8e2c5: 
1:6d8e2c5: /**
1:b820ac2:  * Used to keep track of how much of something is being used so that a productive working set usage can be controlled.
1:b820ac2:  * Main use case is manage memory usage.
1:8e388b8:  *
1:6d8e2c5:  * @org.apache.xbean.XBean
1:8e388b8:  *
1:6d8e2c5:  */
1:2b0024c: public abstract class Usage<T extends Usage> implements Service {
1:6d8e2c5: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(Usage.class);
1:b820ac2: 
1:b820ac2:     protected final ReentrantReadWriteLock usageLock = new ReentrantReadWriteLock();
1:b820ac2:     protected final Condition waitForSpaceCondition = usageLock.writeLock().newCondition();
1:6d8e2c5:     protected int percentUsage;
1:2b0024c:     protected T parent;
1:b820ac2:     protected String name;
1:b820ac2: 
1:6d8e2c5:     private UsageCapacity limiter = new DefaultUsageCapacity();
1:2b0024c:     private int percentUsageMinDelta = 1;
1:2b0024c:     private final List<UsageListener> listeners = new CopyOnWriteArrayList<UsageListener>();
1:2b0024c:     private final boolean debug = LOG.isDebugEnabled();
1:2b0024c:     private float usagePortion = 1.0f;
1:1a5ad28:     private final List<T> children = new CopyOnWriteArrayList<T>();
1:2b0024c:     private final List<Runnable> callbacks = new LinkedList<Runnable>();
1:6d8e2c5:     private int pollingTime = 100;
1:b820ac2:     private final AtomicBoolean started = new AtomicBoolean();
1:1a5ad28:     private ThreadPoolExecutor executor;
1:b820ac2: 
1:2b0024c:     public Usage(T parent, String name, float portion) {
1:2b0024c:         this.parent = parent;
1:2b0024c:         this.usagePortion = portion;
1:2b0024c:         if (parent != null) {
1:839b154:             this.limiter.setLimit((long) (parent.getLimit() * (double)portion));
1:2b0024c:             name = parent.name + ":" + name;
1:c8e518b:         }
1:2b0024c:         this.name = name;
1:97e0fcc:     }
1:2b0024c: 
1:6d8e2c5:     protected abstract long retrieveUsage();
1:97e0fcc: 
1:6d8e2c5:     /**
1:6d8e2c5:      * @throws InterruptedException
1:6d8e2c5:      */
1:2b0024c:     public void waitForSpace() throws InterruptedException {
1:6d8e2c5:         waitForSpace(0);
1:20006a0:     }
1:a0d2282: 
1:2b0024c:     public boolean waitForSpace(long timeout) throws InterruptedException {
1:a0d2282:         return waitForSpace(timeout, 100);
1:a0d2282:     }
1:8e388b8: 
1:6d8e2c5:     /**
1:2b0024c:      * @param timeout
1:6d8e2c5:      * @throws InterruptedException
1:6d8e2c5:      * @return true if space
1:6d8e2c5:      */
1:a0d2282:     public boolean waitForSpace(long timeout, int highWaterMark) throws InterruptedException {
1:2b0024c:         if (parent != null) {
1:a0d2282:             if (!parent.waitForSpace(timeout, highWaterMark)) {
1:6d8e2c5:                 return false;
1:20006a0:             }
1:20006a0:         }
1:b820ac2:         usageLock.writeLock().lock();
1:b820ac2:         try {
1:b820ac2:             percentUsage = caclPercentUsage();
1:a0d2282:             if (percentUsage >= highWaterMark) {
1:2b0024c:                 long deadline = timeout > 0 ? System.currentTimeMillis() + timeout : Long.MAX_VALUE;
1:2b0024c:                 long timeleft = deadline;
1:2b0024c:                 while (timeleft > 0) {
1:b820ac2:                     percentUsage = caclPercentUsage();
1:a0d2282:                     if (percentUsage >= highWaterMark) {
1:b820ac2:                         waitForSpaceCondition.await(pollingTime, TimeUnit.MILLISECONDS);
1:2b0024c:                         timeleft = deadline - System.currentTimeMillis();
1:2b0024c:                     } else {
1:6d8e2c5:                         break;
1:2cb2119:                     }
1:2cb2119:                 }
15:6d8e2c5:             }
1:a0d2282:             return percentUsage < highWaterMark;
1:b820ac2:         } finally {
1:b820ac2:             usageLock.writeLock().unlock();
1:6d8e2c5:         }
1:6d8e2c5:     }
1:a0d2282: 
1:2b0024c:     public boolean isFull() {
1:a0d2282:         return isFull(100);
1:a0d2282:     }
1:8e388b8: 
1:a0d2282:     public boolean isFull(int highWaterMark) {
1:a0d2282:         if (parent != null && parent.isFull(highWaterMark)) {
1:6d8e2c5:             return true;
1:6d8e2c5:         }
1:b820ac2:         usageLock.writeLock().lock();
1:b820ac2:         try {
1:b820ac2:             percentUsage = caclPercentUsage();
1:a0d2282:             return percentUsage >= highWaterMark;
1:b820ac2:         } finally {
1:b820ac2:             usageLock.writeLock().unlock();
1:6d8e2c5:         }
1:6d8e2c5:     }
1:97e0fcc: 
1:2b0024c:     public void addUsageListener(UsageListener listener) {
1:6d8e2c5:         listeners.add(listener);
1:6d8e2c5:     }
1:97e0fcc: 
1:2b0024c:     public void removeUsageListener(UsageListener listener) {
1:6d8e2c5:         listeners.remove(listener);
1:6d8e2c5:     }
1:c8e518b: 
1:7a68ad5:     public int getNumUsageListeners() {
1:7a68ad5:         return listeners.size();
1:7a68ad5:     }
1:7a68ad5: 
1:2b0024c:     public long getLimit() {
1:b820ac2:         usageLock.readLock().lock();
1:b820ac2:         try {
1:6d8e2c5:             return limiter.getLimit();
1:b820ac2:         } finally {
1:b820ac2:             usageLock.readLock().unlock();
1:6d8e2c5:         }
1:6d8e2c5:     }
1:2cb2119: 
1:6d8e2c5:     /**
1:b820ac2:      * Sets the memory limit in bytes. Setting the limit in bytes will set the usagePortion to 0 since the UsageManager
1:b820ac2:      * is not going to be portion based off the parent. When set using Xbean, values of the form "20 Mb", "1024kb", and
1:b820ac2:      * "1g" can be used
1:b0c2a40:      *
1:6d8e2c5:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.MemoryPropertyEditor"
1:6d8e2c5:      */
1:2b0024c:     public void setLimit(long limit) {
1:2b0024c:         if (percentUsageMinDelta < 0) {
1:6d8e2c5:             throw new IllegalArgumentException("percentUsageMinDelta must be greater or equal to 0");
1:6d8e2c5:         }
1:b820ac2:         usageLock.writeLock().lock();
1:b820ac2:         try {
1:6d8e2c5:             this.limiter.setLimit(limit);
1:2b0024c:             this.usagePortion = 0;
1:b820ac2:         } finally {
1:b820ac2:             usageLock.writeLock().unlock();
1:6d8e2c5:         }
1:6d8e2c5:         onLimitChange();
1:6d8e2c5:     }
1:2cb2119: 
1:2b0024c:     protected void onLimitChange() {
1:6d8e2c5:         // We may need to calculate the limit
1:2b0024c:         if (usagePortion > 0 && parent != null) {
1:b820ac2:             usageLock.writeLock().lock();
1:b820ac2:             try {
1:839b154:                 this.limiter.setLimit((long) (parent.getLimit() * (double) usagePortion));
1:b820ac2:             } finally {
1:b820ac2:                 usageLock.writeLock().unlock();
1:6d8e2c5:             }
1:6d8e2c5:         }
1:6d8e2c5:         // Reset the percent currently being used.
1:b820ac2:         usageLock.writeLock().lock();
1:b820ac2:         try {
1:b820ac2:             setPercentUsage(caclPercentUsage());
1:b820ac2:         } finally {
1:b820ac2:             usageLock.writeLock().unlock();
1:6d8e2c5:         }
1:6d8e2c5:         // Let the children know that the limit has changed. They may need to
1:b820ac2:         // set their limits based on ours.
1:2b0024c:         for (T child : children) {
1:6d8e2c5:             child.onLimitChange();
1:6d8e2c5:         }
1:6d8e2c5:     }
1:6d8e2c5: 
1:2b0024c:     public float getUsagePortion() {
1:b820ac2:         usageLock.readLock().lock();
1:b820ac2:         try {
1:6d8e2c5:             return usagePortion;
1:b820ac2:         } finally {
1:b820ac2:             usageLock.readLock().unlock();
1:6d8e2c5:         }
1:6d8e2c5:     }
1:6d8e2c5: 
1:2b0024c:     public void setUsagePortion(float usagePortion) {
1:b820ac2:         usageLock.writeLock().lock();
1:b820ac2:         try {
1:2b0024c:             this.usagePortion = usagePortion;
1:b820ac2:         } finally {
1:b820ac2:             usageLock.writeLock().unlock();
1:6d8e2c5:         }
1:6d8e2c5:         onLimitChange();
1:6d8e2c5:     }
1:6d8e2c5: 
1:2b0024c:     public int getPercentUsage() {
1:b820ac2:         usageLock.readLock().lock();
1:b820ac2:         try {
1:6d8e2c5:             return percentUsage;
1:b820ac2:         } finally {
1:b820ac2:             usageLock.readLock().unlock();
1:6d8e2c5:         }
1:6d8e2c5:     }
1:6d8e2c5: 
1:2b0024c:     public int getPercentUsageMinDelta() {
1:b820ac2:         usageLock.readLock().lock();
1:b820ac2:         try {
1:6d8e2c5:             return percentUsageMinDelta;
1:b820ac2:         } finally {
1:b820ac2:             usageLock.readLock().unlock();
1:6d8e2c5:         }
1:6d8e2c5:     }
1:6d8e2c5: 
1:6d8e2c5:     /**
1:b820ac2:      * Sets the minimum number of percentage points the usage has to change before a UsageListener event is fired by the
1:b820ac2:      * manager.
9:6d8e2c5:      *
1:6d8e2c5:      * @param percentUsageMinDelta
1:77116d4:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.MemoryPropertyEditor"
1:6d8e2c5:      */
1:2b0024c:     public void setPercentUsageMinDelta(int percentUsageMinDelta) {
1:2b0024c:         if (percentUsageMinDelta < 1) {
1:6d8e2c5:             throw new IllegalArgumentException("percentUsageMinDelta must be greater than 0");
1:6d8e2c5:         }
1:b820ac2: 
1:b820ac2:         usageLock.writeLock().lock();
1:b820ac2:         try {
1:2b0024c:             this.percentUsageMinDelta = percentUsageMinDelta;
1:b820ac2:             setPercentUsage(caclPercentUsage());
1:b820ac2:         } finally {
1:b820ac2:             usageLock.writeLock().unlock();
1:6d8e2c5:         }
1:6d8e2c5:     }
1:6d8e2c5: 
1:2b0024c:     public long getUsage() {
1:b820ac2:         usageLock.readLock().lock();
1:b820ac2:         try {
1:6d8e2c5:             return retrieveUsage();
1:b820ac2:         } finally {
1:b820ac2:             usageLock.readLock().unlock();
1:6d8e2c5:         }
1:6d8e2c5:     }
1:6d8e2c5: 
1:2b0024c:     protected void setPercentUsage(int value) {
1:b820ac2:         usageLock.writeLock().lock();
1:b820ac2:         try {
1:2b0024c:             int oldValue = percentUsage;
1:2b0024c:             percentUsage = value;
1:2b0024c:             if (oldValue != value) {
1:2b0024c:                 fireEvent(oldValue, value);
1:6d8e2c5:             }
1:b820ac2:         } finally {
1:b820ac2:             usageLock.writeLock().unlock();
1:6d8e2c5:         }
1:6d8e2c5:     }
1:6d8e2c5: 
1:2b0024c:     protected int caclPercentUsage() {
1:2b0024c:         if (limiter.getLimit() == 0) {
1:6d8e2c5:             return 0;
1:6d8e2c5:         }
1:b820ac2:         return (int) ((((retrieveUsage() * 100) / limiter.getLimit()) / percentUsageMinDelta) * percentUsageMinDelta);
1:6d8e2c5:     }
1:6d8e2c5: 
1:b820ac2:     // Must be called with the usage lock's writeLock held.
1:2cb2119:     private void fireEvent(final int oldPercentUsage, final int newPercentUsage) {
1:2b0024c:         if (debug) {
1:b820ac2:             LOG.debug(getName() + ": usage change from: " + oldPercentUsage + "% of available memory, to: " + newPercentUsage + "% of available memory");
1:8e388b8:         }
1:132f662:         if (started.get()) {
1:2cb2119:             // Switching from being full to not being full..
1:2b0024c:             if (oldPercentUsage >= 100 && newPercentUsage < 100) {
1:b820ac2:                 waitForSpaceCondition.signalAll();
1:b820ac2:                 if (!callbacks.isEmpty()) {
1:b820ac2:                     for (Runnable callback : callbacks) {
1:b820ac2:                         getExecutor().execute(callback);
1:97e0fcc:                     }
1:b820ac2:                     callbacks.clear();
1:3d77a2f:                 }
1:3d77a2f:             }
1:97e0fcc:             if (!listeners.isEmpty()) {
1:97e0fcc:                 // Let the listeners know on a separate thread
1:97e0fcc:                 Runnable listenerNotifier = new Runnable() {
1:8e388b8:                     @Override
1:97e0fcc:                     public void run() {
1:b820ac2:                         for (UsageListener listener : listeners) {
1:b820ac2:                             listener.onUsageChanged(Usage.this, oldPercentUsage, newPercentUsage);
1:97e0fcc:                         }
1:6d8e2c5:                     }
1:97e0fcc:                 };
1:97e0fcc:                 if (started.get()) {
1:97e0fcc:                     getExecutor().execute(listenerNotifier);
1:97e0fcc:                 } else {
1:97e0fcc:                     LOG.warn("Not notifying memory usage change to listeners on shutdown");
1:132f662:                 }
1:6d8e2c5:             }
1:6d8e2c5:         }
1:6d8e2c5:     }
1:6d8e2c5: 
1:2b0024c:     public String getName() {
1:6d8e2c5:         return name;
1:6d8e2c5:     }
1:6d8e2c5: 
1:8e388b8:     @Override
1:2b0024c:     public String toString() {
1:b820ac2:         return "Usage(" + getName() + ") percentUsage=" + percentUsage + "%, usage=" + retrieveUsage() + ", limit=" + limiter.getLimit()
1:b820ac2:             + ", percentUsageMinDelta=" + percentUsageMinDelta + "%" + (parent != null ? ";Parent:" + parent.toString() : "");
1:6d8e2c5:     }
1:6d8e2c5: 
1:8e388b8:     @Override
1:2b0024c:     @SuppressWarnings("unchecked")
1:2b0024c:     public void start() {
1:b820ac2:         if (started.compareAndSet(false, true)) {
1:2b0024c:             if (parent != null) {
1:2cb2119:                 parent.addChild(this);
1:b820ac2:                 if (getLimit() > parent.getLimit()) {
1:b820ac2:                     LOG.info("Usage({}) limit={} should be smaller than its parent limit={}", new Object[] { getName(), getLimit(), parent.getLimit() });
1:2c3d947:                 }
1:2cb2119:             }
1:b820ac2:             for (T t : children) {
1:2cb2119:                 t.start();
1:2cb2119:             }
1:2cb2119:         }
1:2cb2119:     }
1:6d8e2c5: 
1:1a5ad28:     @Override
1:2b0024c:     @SuppressWarnings("unchecked")
1:2b0024c:     public void stop() {
1:b820ac2:         if (started.compareAndSet(true, false)) {
1:2b0024c:             if (parent != null) {
1:2cb2119:                 parent.removeChild(this);
1:2cb2119:             }
1:8e388b8: 
1:b820ac2:             // clear down any callbacks
1:b820ac2:             usageLock.writeLock().lock();
1:b820ac2:             try {
1:b820ac2:                 waitForSpaceCondition.signalAll();
1:b820ac2:                 for (Runnable callback : this.callbacks) {
1:2cb2119:                     callback.run();
1:2cb2119:                 }
1:2cb2119:                 this.callbacks.clear();
1:b820ac2:             } finally {
1:b820ac2:                 usageLock.writeLock().unlock();
1:2cb2119:             }
1:b820ac2: 
1:b820ac2:             for (T t : children) {
1:2cb2119:                 t.stop();
1:2cb2119:             }
1:2cb2119:         }
1:2cb2119:     }
1:97e0fcc: 
1:4798cea:     protected void addChild(T child) {
1:6d8e2c5:         children.add(child);
1:2cb2119:         if (started.get()) {
1:2cb2119:             child.start();
1:2cb2119:         }
1:6d8e2c5:     }
1:2cb2119: 
1:4798cea:     protected void removeChild(T child) {
1:6d8e2c5:         children.remove(child);
1:6d8e2c5:     }
1:2cb2119: 
1:6d8e2c5:     /**
1:6d8e2c5:      * @param callback
1:b820ac2:      * @return true if the UsageManager was full. The callback will only be called if this method returns true.
1:6d8e2c5:      */
1:2b0024c:     public boolean notifyCallbackWhenNotFull(final Runnable callback) {
1:2b0024c:         if (parent != null) {
1:2b0024c:             Runnable r = new Runnable() {
1:6d8e2c5: 
1:8e388b8:                 @Override
1:2b0024c:                 public void run() {
1:b820ac2:                     usageLock.writeLock().lock();
1:b820ac2:                     try {
1:2b0024c:                         if (percentUsage >= 100) {
1:6d8e2c5:                             callbacks.add(callback);
1:2b0024c:                         } else {
1:2cb2119:                             callback.run();
1:6d8e2c5:                         }
1:b820ac2:                     } finally {
1:b820ac2:                         usageLock.writeLock().unlock();
1:6d8e2c5:                     }
1:6d8e2c5:                 }
1:2cb2119:             };
1:2b0024c:             if (parent.notifyCallbackWhenNotFull(r)) {
1:6d8e2c5:                 return true;
1:6d8e2c5:             }
1:6d8e2c5:         }
1:b820ac2:         usageLock.writeLock().lock();
1:b820ac2:         try {
1:2b0024c:             if (percentUsage >= 100) {
1:6d8e2c5:                 callbacks.add(callback);
1:6d8e2c5:                 return true;
1:2b0024c:             } else {
1:6d8e2c5:                 return false;
1:6d8e2c5:             }
1:b820ac2:         } finally {
1:b820ac2:             usageLock.writeLock().unlock();
1:6d8e2c5:         }
1:6d8e2c5:     }
1:6d8e2c5: 
1:6d8e2c5:     /**
1:6d8e2c5:      * @return the limiter
1:6d8e2c5:      */
1:2b0024c:     public UsageCapacity getLimiter() {
1:6d8e2c5:         return this.limiter;
1:6d8e2c5:     }
1:6d8e2c5: 
1:6d8e2c5:     /**
1:b820ac2:      * @param limiter
1:b820ac2:      *            the limiter to set
1:6d8e2c5:      */
1:2b0024c:     public void setLimiter(UsageCapacity limiter) {
1:2b0024c:         this.limiter = limiter;
1:6d8e2c5:     }
1:6d8e2c5: 
1:6d8e2c5:     /**
1:6d8e2c5:      * @return the pollingTime
1:6d8e2c5:      */
1:2b0024c:     public int getPollingTime() {
1:6d8e2c5:         return this.pollingTime;
1:6d8e2c5:     }
1:6d8e2c5: 
1:6d8e2c5:     /**
1:b820ac2:      * @param pollingTime
1:b820ac2:      *            the pollingTime to set
1:6d8e2c5:      */
1:2b0024c:     public void setPollingTime(int pollingTime) {
1:2b0024c:         this.pollingTime = pollingTime;
1:2b0024c:     }
1:2b0024c: 
1:2b0024c:     public void setName(String name) {
1:2b0024c:         this.name = name;
1:2b0024c:     }
1:2b0024c: 
1:2b0024c:     public T getParent() {
1:2b0024c:         return parent;
1:2b0024c:     }
1:2b0024c: 
1:2b0024c:     public void setParent(T parent) {
1:2b0024c:         this.parent = parent;
1:2cb2119:     }
1:8e388b8: 
1:b820ac2:     public void setExecutor(ThreadPoolExecutor executor) {
1:1a5ad28:         this.executor = executor;
1:1a5ad28:     }
1:8e388b8: 
1:1a5ad28:     public ThreadPoolExecutor getExecutor() {
1:97e0fcc:         return executor;
1:97e0fcc:     }
1:8e388b8: 
1:8e388b8:     public boolean isStarted() {
1:8e388b8:         return started.get();
1:8e388b8:     }
1:6d8e2c5: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Timothy Bish
-------------------------------------------------------------------------------
commit:7a68ad5
/////////////////////////////////////////////////////////////////////////
1:     public int getNumUsageListeners() {
1:         return listeners.size();
1:     }
1: 
author:gtully
-------------------------------------------------------------------------------
commit:839b154
/////////////////////////////////////////////////////////////////////////
1:             this.limiter.setLimit((long) (parent.getLimit() * (double)portion));
/////////////////////////////////////////////////////////////////////////
1:                 this.limiter.setLimit((long) (parent.getLimit() * (double) usagePortion));
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:b820ac2
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.locks.Condition;
1: import java.util.concurrent.locks.ReentrantReadWriteLock;
1: 
1:  * Used to keep track of how much of something is being used so that a productive working set usage can be controlled.
1:  * Main use case is manage memory usage.
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected final ReentrantReadWriteLock usageLock = new ReentrantReadWriteLock();
1:     protected final Condition waitForSpaceCondition = usageLock.writeLock().newCondition();
1:     protected String name;
1: 
1:     private final AtomicBoolean started = new AtomicBoolean();
1: 
0:             this.limiter.setLimit((long) (parent.getLimit() * portion));
/////////////////////////////////////////////////////////////////////////
1:         usageLock.writeLock().lock();
1:         try {
1:             percentUsage = caclPercentUsage();
1:                     percentUsage = caclPercentUsage();
1:                         waitForSpaceCondition.await(pollingTime, TimeUnit.MILLISECONDS);
/////////////////////////////////////////////////////////////////////////
1:         } finally {
1:             usageLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:         usageLock.writeLock().lock();
1:         try {
1:             percentUsage = caclPercentUsage();
1:         } finally {
1:             usageLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:         usageLock.readLock().lock();
1:         try {
1:         } finally {
1:             usageLock.readLock().unlock();
1:      * Sets the memory limit in bytes. Setting the limit in bytes will set the usagePortion to 0 since the UsageManager
1:      * is not going to be portion based off the parent. When set using Xbean, values of the form "20 Mb", "1024kb", and
1:      * "1g" can be used
/////////////////////////////////////////////////////////////////////////
1:         usageLock.writeLock().lock();
1:         try {
1:         } finally {
1:             usageLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:             usageLock.writeLock().lock();
1:             try {
0:                 this.limiter.setLimit((long) (parent.getLimit() * usagePortion));
1:             } finally {
1:                 usageLock.writeLock().unlock();
1:         usageLock.writeLock().lock();
1:         try {
1:             setPercentUsage(caclPercentUsage());
1:         } finally {
1:             usageLock.writeLock().unlock();
1:         // set their limits based on ours.
1:         usageLock.readLock().lock();
1:         try {
1:         } finally {
1:             usageLock.readLock().unlock();
1:         usageLock.writeLock().lock();
1:         try {
1:         } finally {
1:             usageLock.writeLock().unlock();
1:         usageLock.readLock().lock();
1:         try {
1:         } finally {
1:             usageLock.readLock().unlock();
1:         usageLock.readLock().lock();
1:         try {
1:         } finally {
1:             usageLock.readLock().unlock();
1:      * Sets the minimum number of percentage points the usage has to change before a UsageListener event is fired by the
1:      * manager.
/////////////////////////////////////////////////////////////////////////
1: 
1:         usageLock.writeLock().lock();
1:         try {
1:             setPercentUsage(caclPercentUsage());
1:         } finally {
1:             usageLock.writeLock().unlock();
1:         usageLock.readLock().lock();
1:         try {
1:         } finally {
1:             usageLock.readLock().unlock();
1:         usageLock.writeLock().lock();
1:         try {
1:         } finally {
1:             usageLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:         return (int) ((((retrieveUsage() * 100) / limiter.getLimit()) / percentUsageMinDelta) * percentUsageMinDelta);
1:     // Must be called with the usage lock's writeLock held.
1:             LOG.debug(getName() + ": usage change from: " + oldPercentUsage + "% of available memory, to: " + newPercentUsage + "% of available memory");
1:                 waitForSpaceCondition.signalAll();
1:                 if (!callbacks.isEmpty()) {
1:                     for (Runnable callback : callbacks) {
1:                         getExecutor().execute(callback);
1:                     callbacks.clear();
/////////////////////////////////////////////////////////////////////////
1:                         for (UsageListener listener : listeners) {
1:                             listener.onUsageChanged(Usage.this, oldPercentUsage, newPercentUsage);
/////////////////////////////////////////////////////////////////////////
1:         return "Usage(" + getName() + ") percentUsage=" + percentUsage + "%, usage=" + retrieveUsage() + ", limit=" + limiter.getLimit()
1:             + ", percentUsageMinDelta=" + percentUsageMinDelta + "%" + (parent != null ? ";Parent:" + parent.toString() : "");
1:         if (started.compareAndSet(false, true)) {
1:                 if (getLimit() > parent.getLimit()) {
1:                     LOG.info("Usage({}) limit={} should be smaller than its parent limit={}", new Object[] { getName(), getLimit(), parent.getLimit() });
1:             for (T t : children) {
/////////////////////////////////////////////////////////////////////////
1:         if (started.compareAndSet(true, false)) {
1:             // clear down any callbacks
1:             usageLock.writeLock().lock();
1:             try {
1:                 waitForSpaceCondition.signalAll();
1:                 for (Runnable callback : this.callbacks) {
1:             } finally {
1:                 usageLock.writeLock().unlock();
1: 
1:             for (T t : children) {
/////////////////////////////////////////////////////////////////////////
1:      * @return true if the UsageManager was full. The callback will only be called if this method returns true.
/////////////////////////////////////////////////////////////////////////
1:                     usageLock.writeLock().lock();
1:                     try {
1:                     } finally {
1:                         usageLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:         usageLock.writeLock().lock();
1:         try {
1:         } finally {
1:             usageLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:      * @param limiter
1:      *            the limiter to set
/////////////////////////////////////////////////////////////////////////
1:      * @param pollingTime
1:      *            the pollingTime to set
/////////////////////////////////////////////////////////////////////////
1:     public void setExecutor(ThreadPoolExecutor executor) {
commit:8e388b8
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug(getName() + ": usage change from: " + oldPercentUsage + "% of available memory, to: "
1:         }
/////////////////////////////////////////////////////////////////////////
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
0:                     LOG.info("Usage({}) limit={} should be smaller than its parent limit={}",
0:                              new Object[]{getName(), getLimit(), parent.getLimit()});
/////////////////////////////////////////////////////////////////////////
1:     @Override
1: 
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1:     public boolean isStarted() {
1:         return started.get();
1:     }
author:Christian Posta
-------------------------------------------------------------------------------
commit:2c3d947
/////////////////////////////////////////////////////////////////////////
0:                 if(getLimit() > parent.getLimit()) {
0:                 	LOG.info("Usage({}) limit={} should be smaller than its parent limit={}", 
0:                 			 new Object[]{getName(), getLimit(), parent.getLimit()});
1:                 }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:9a8f6e4
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:2b0024c
/////////////////////////////////////////////////////////////////////////
0:  * productive working set usage can be controlled. Main use case is manage
0:  * memory usage.
1: public abstract class Usage<T extends Usage> implements Service {
0:     private static final Log LOG = LogFactory.getLog(Usage.class);
0:     protected final Object usageMutex = new Object();
1:     protected T parent;
1:     private int percentUsageMinDelta = 1;
1:     private final List<UsageListener> listeners = new CopyOnWriteArrayList<UsageListener>();
1:     private final boolean debug = LOG.isDebugEnabled();
0:     private String name;
1:     private float usagePortion = 1.0f;
0:     private List<T> children = new CopyOnWriteArrayList<T>();
1:     private final List<Runnable> callbacks = new LinkedList<Runnable>();
1: 
1:     public Usage(T parent, String name, float portion) {
1:         this.parent = parent;
1:         this.usagePortion = portion;
1:         if (parent != null) {
0:             this.limiter.setLimit((long)(parent.getLimit() * portion));
1:             name = parent.name + ":" + name;
1:         this.name = name;
/////////////////////////////////////////////////////////////////////////
1:     public void waitForSpace() throws InterruptedException {
1:      * @param timeout
1:     public boolean waitForSpace(long timeout) throws InterruptedException {
1:         if (parent != null) {
0:             if (!parent.waitForSpace(timeout)) {
0:         synchronized (usageMutex) {
1:             if (percentUsage >= 100) {
1:                 long deadline = timeout > 0 ? System.currentTimeMillis() + timeout : Long.MAX_VALUE;
1:                 long timeleft = deadline;
1:                 while (timeleft > 0) {
1:                     if (percentUsage >= 100) {
1:                         timeleft = deadline - System.currentTimeMillis();
1:                     } else {
0:             return percentUsage < 100;
1:     public boolean isFull() {
0:         if (parent != null && parent.isFull()) {
0:         synchronized (usageMutex) {
0:             return percentUsage >= 100;
1:     public void addUsageListener(UsageListener listener) {
1:     public void removeUsageListener(UsageListener listener) {
1:     public long getLimit() {
0:         synchronized (usageMutex) {
/////////////////////////////////////////////////////////////////////////
0:      * off the parent. When set using XBean, you can use values such as: "20
0:      * mb", "1024 kb", or "1 gb"
1:     public void setLimit(long limit) {
1:         if (percentUsageMinDelta < 0) {
0:         synchronized (usageMutex) {
1:             this.usagePortion = 0;
1:     protected void onLimitChange() {
1:         if (usagePortion > 0 && parent != null) {
0:             synchronized (usageMutex) {
0:                 this.limiter.setLimit((long)(parent.getLimit() * usagePortion));
0:         synchronized (usageMutex) {
0:             percentUsage = caclPercentUsage();
1:         for (T child : children) {
1:     public float getUsagePortion() {
0:         synchronized (usageMutex) {
1:     public void setUsagePortion(float usagePortion) {
0:         synchronized (usageMutex) {
1:             this.usagePortion = usagePortion;
/////////////////////////////////////////////////////////////////////////
1:     public int getPercentUsage() {
0:         synchronized (usageMutex) {
1:     public int getPercentUsageMinDelta() {
0:         synchronized (usageMutex) {
/////////////////////////////////////////////////////////////////////////
1:     public void setPercentUsageMinDelta(int percentUsageMinDelta) {
1:         if (percentUsageMinDelta < 1) {
0:         synchronized (usageMutex) {
1:             this.percentUsageMinDelta = percentUsageMinDelta;
0:             percentUsage = caclPercentUsage();
1:     public long getUsage() {
0:         synchronized (usageMutex) {
1:     protected void setPercentUsage(int value) {
0:         synchronized (usageMutex) {
1:             int oldValue = percentUsage;
1:             percentUsage = value;
1:             if (oldValue != value) {
1:                 fireEvent(oldValue, value);
1:     protected int caclPercentUsage() {
1:         if (limiter.getLimit() == 0) {
0:         return (int)((((retrieveUsage() * 100) / limiter.getLimit()) / percentUsageMinDelta) * percentUsageMinDelta);
0:     private void fireEvent(int oldPercentUsage, int newPercentUsage) {
1:         if (debug) {
0:             LOG.debug("Memory usage change.  from: " + oldPercentUsage + ", to: " + newPercentUsage);
1:         if (oldPercentUsage >= 100 && newPercentUsage < 100) {
0:             synchronized (usageMutex) {
0:                 for (Iterator<Runnable> iter = new ArrayList<Runnable>(callbacks).iterator(); iter.hasNext();) {
0:                     Runnable callback = iter.next();
0:         for (Iterator<UsageListener> iter = listeners.iterator(); iter.hasNext();) {
0:             UsageListener l = iter.next();
0:             l.onUsageChanged(this, oldPercentUsage, newPercentUsage);
1:     public String getName() {
1:     public String toString() {
0:         return "Usage(" + getName() + ") percentUsage=" + percentUsage + "%, usage=" + retrieveUsage() + " limit=" + limiter.getLimit() + " percentUsageMinDelta=" + percentUsageMinDelta + "%";
1:     @SuppressWarnings("unchecked")
1:     public void start() {
1:         if (parent != null) {
1:     @SuppressWarnings("unchecked")
1:     public void stop() {
1:         if (parent != null) {
0:     private void addChild(T child) {
0:     private void removeChild(T child) {
/////////////////////////////////////////////////////////////////////////
1:     public boolean notifyCallbackWhenNotFull(final Runnable callback) {
1:         if (parent != null) {
1:             Runnable r = new Runnable() {
1:                 public void run() {
0:                     synchronized (usageMutex) {
0:                         if (percentUsage >= 100) {
1:                         } else {
1:             if (parent.notifyCallbackWhenNotFull(r)) {
0:         synchronized (usageMutex) {
0:             if (percentUsage >= 100) {
1:             } else {
1:     public UsageCapacity getLimiter() {
1:     public void setLimiter(UsageCapacity limiter) {
1:         this.limiter = limiter;
1:     public int getPollingTime() {
1:     public void setPollingTime(int pollingTime) {
1:         this.pollingTime = pollingTime;
1:     }
1: 
1:     public void setName(String name) {
1:         this.name = name;
1:     }
1: 
1:     public T getParent() {
1:         return parent;
1:     }
1: 
1:     public void setParent(T parent) {
1:         this.parent = parent;
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:4798cea
/////////////////////////////////////////////////////////////////////////
0:     protected String name;
/////////////////////////////////////////////////////////////////////////
1:     protected void addChild(T child) {
1:     protected void removeChild(T child) {
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(Usage.class);
author:Gary Tully
-------------------------------------------------------------------------------
commit:2b10259
/////////////////////////////////////////////////////////////////////////
0:         return "Usage(" + getName() + ") percentUsage=" + percentUsage
0:                 + "%, usage=" + retrieveUsage() + ", limit=" + limiter.getLimit()
0:                 + ", percentUsageMinDelta=" + percentUsageMinDelta + "%"
0:                 + (parent != null ? ";Parent:" + parent.toString() : "");
commit:a0d2282
/////////////////////////////////////////////////////////////////////////
0:     public boolean waitForSpace(long timeout) throws InterruptedException {
1:         return waitForSpace(timeout, 100);
1:     }
1:     
1:     public boolean waitForSpace(long timeout, int highWaterMark) throws InterruptedException {
1:             if (!parent.waitForSpace(timeout, highWaterMark)) {
1:             if (percentUsage >= highWaterMark) {
1:                     if (percentUsage >= highWaterMark) {
/////////////////////////////////////////////////////////////////////////
1:             return percentUsage < highWaterMark;
1:         return isFull(100);
1:     }
1:     
1:     public boolean isFull(int highWaterMark) {
1:         if (parent != null && parent.isFull(highWaterMark)) {
1:             return percentUsage >= highWaterMark;
commit:77116d4
/////////////////////////////////////////////////////////////////////////
1:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.MemoryPropertyEditor"
commit:a2af47b
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug(getName() + ": usage change from: " + oldPercentUsage + "% of available memory, to: " 
commit:5619cd0
/////////////////////////////////////////////////////////////////////////
0:         executor = new ThreadPoolExecutor(1, 10, 30, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new ThreadFactory() {
commit:97e0fcc
/////////////////////////////////////////////////////////////////////////
0:     private static ThreadPoolExecutor executor;
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
0:                     if (!callbacks.isEmpty()) {
0:                         for (Iterator<Runnable> iter = new ArrayList<Runnable>(callbacks).iterator(); iter.hasNext();) {
0:                             Runnable callback = iter.next();
0:                             getExecutor().execute(callback);
1:                         }
0:                         callbacks.clear();
1:             if (!listeners.isEmpty()) {
1:                 // Let the listeners know on a separate thread
1:                 Runnable listenerNotifier = new Runnable() {
1:                     public void run() {
0:                         for (Iterator<UsageListener> iter = listeners.iterator(); iter.hasNext();) {
0:                             UsageListener l = iter.next();
0:                             l.onUsageChanged(Usage.this, oldPercentUsage, newPercentUsage);
1:                         }
1:                 };
1:                 if (started.get()) {
1:                     getExecutor().execute(listenerNotifier);
1:                 } else {
1:                     LOG.warn("Not notifying memory usage change to listeners on shutdown");
/////////////////////////////////////////////////////////////////////////
1:             
/////////////////////////////////////////////////////////////////////////
1:         return executor;
1:     
0:     static {
0:         executor = new ThreadPoolExecutor(10, Integer.MAX_VALUE, 10, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new ThreadFactory() {
0:             public Thread newThread(Runnable runnable) {
0:                 Thread thread = new Thread(runnable, "Usage Async Task");
0:                 thread.setDaemon(true);
0:                 return thread;
1:             }
0:         });
1:     }
1: 
commit:356c39d
/////////////////////////////////////////////////////////////////////////
0:      * off the parent.
0:      * When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used
commit:d5333d4
/////////////////////////////////////////////////////////////////////////
commit:c6a485f
/////////////////////////////////////////////////////////////////////////
0:         if (newPercentUsage >= 100) {
0:             LOG.warn("Memory usage is now at " + newPercentUsage  + "%");
commit:3d77a2f
/////////////////////////////////////////////////////////////////////////
1:         }   
0:         if (newPercentUsage >= 80) {
0:             LOG.warn("Memory usage is now over 80%!");
1:         }
commit:eab5a3a
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("Memory usage change.  from: " + oldPercentUsage + ", to: " + newPercentUsage);
commit:c8e518b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             LOG.info("Memory usage change.  from: " + oldPercentUsage + ", to: " + newPercentUsage);
1:         }    
1:              
commit:132f662
/////////////////////////////////////////////////////////////////////////
1:             if (started.get()) {
0:                 getExecutor().execute(listenerNotifier);
0:             } else {
0:                 LOG.warn("not notifying usage change to listeners on shutdown");
1:             }
commit:20006a0
/////////////////////////////////////////////////////////////////////////
0:     private volatile ThreadPoolExecutor executor;
/////////////////////////////////////////////////////////////////////////
0:     public void start() {
/////////////////////////////////////////////////////////////////////////
0:     public void stop() {
/////////////////////////////////////////////////////////////////////////
0:     protected Executor getExecutor() {
0:         	synchronized(usageMutex) {
0:         		if (this.executor == null) {
0: 		            this.executor = new ThreadPoolExecutor(1, 1, 0,
0: 		                    TimeUnit.NANOSECONDS,
0: 		                    new LinkedBlockingQueue<Runnable>(), new ThreadFactory() {
0: 		                        public Thread newThread(Runnable runnable) {
0: 		                            Thread thread = new Thread(runnable, getName()
0: 		                                    + " Usage Thread Pool");
0: 		                            thread.setDaemon(true);
0: 		                            return thread;
1: 		                        }
0: 		                    });
1:         		}
1:         	}
author:Robert Davies
-------------------------------------------------------------------------------
commit:1a5ad28
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final List<T> children = new CopyOnWriteArrayList<T>();
0:     private final AtomicBoolean started=new AtomicBoolean();
1:     private ThreadPoolExecutor executor;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:     public void setExecutor (ThreadPoolExecutor executor) {
1:         this.executor = executor;
1:     }
1:     public ThreadPoolExecutor getExecutor() {
commit:ce92559
/////////////////////////////////////////////////////////////////////////
0:             percentUsage=caclPercentUsage();
0:                     percentUsage=caclPercentUsage();
/////////////////////////////////////////////////////////////////////////
0:             percentUsage=caclPercentUsage();
commit:17e22cf
/////////////////////////////////////////////////////////////////////////
0:                         getExecutor().execute(callback);
commit:99966f5
/////////////////////////////////////////////////////////////////////////
0:             getExecutor().execute(listenerNotifier);
commit:2cb2119
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.Executor;
0: import java.util.concurrent.LinkedBlockingQueue;
0: import java.util.concurrent.ThreadFactory;
1: import java.util.concurrent.ThreadPoolExecutor;
0: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
0:     private ThreadPoolExecutor executor;
0:     private AtomicBoolean started=new AtomicBoolean();
/////////////////////////////////////////////////////////////////////////
1:     private void fireEvent(final int oldPercentUsage, final int newPercentUsage) {
1:         if (started.get()) {
1:             // Switching from being full to not being full..
0:             if (oldPercentUsage >= 100 && newPercentUsage < 100) {
0:                 synchronized (usageMutex) {
0:                     usageMutex.notifyAll();
0:                     for (Iterator<Runnable> iter = new ArrayList<Runnable>(callbacks).iterator(); iter.hasNext();) {
0:                         Runnable callback = iter.next();
1:                         callback.run();
1:                     }
0:                     callbacks.clear();
0:             // Let the listeners know on a separate thread
0:             Runnable listenerNotifier = new Runnable() {
1:             
0:                 public void run() {
0:                     for (Iterator<UsageListener> iter = listeners.iterator(); iter.hasNext();) {
0:                         UsageListener l = iter.next();
0:                         l.onUsageChanged(Usage.this, oldPercentUsage, newPercentUsage);
1:                     }
1:                 }
1:             
1:             };
0:             listenerNotifier.run();
0:            //getExecutor().execute(listenerNotifier);
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void start() {
0:         if (started.compareAndSet(false, true)){
0:             if (parent != null) {
1:                 parent.addChild(this);
1:             }
0:             for (T t:children) {
1:                 t.start();
1:             }
0:     public synchronized void stop() {
0:         if (started.compareAndSet(true, false)){
0:             if (parent != null) {
1:                 parent.removeChild(this);
1:             }
0:             if (this.executor != null){
0:                 this.executor.shutdownNow();
1:             }
0:             //clear down any callbacks
0:             synchronized (usageMutex) {
0:                 usageMutex.notifyAll();
0:                 for (Iterator<Runnable> iter = new ArrayList<Runnable>(this.callbacks).iterator(); iter.hasNext();) {
0:                     Runnable callback = iter.next();
1:                     callback.run();
1:                 }
1:                 this.callbacks.clear();
1:             }
0:             for (T t:children) {
1:                 t.stop();
1:             }
0:         if (started.get()) {
1:             child.start();
1:         }
/////////////////////////////////////////////////////////////////////////
1:     
0:     protected synchronized Executor getExecutor() {
0:         if (this.executor == null) {
0:             this.executor = new ThreadPoolExecutor(1, 1, 0,
0:                     TimeUnit.NANOSECONDS,
0:                     new LinkedBlockingQueue<Runnable>(), new ThreadFactory() {
0:                         public Thread newThread(Runnable runnable) {
0:                             Thread thread = new Thread(runnable, getName()
0:                                     + " Usage Thread Pool");
0:                             thread.setDaemon(true);
0:                             return thread;
1:                         }
0:                     });
1: 
1:         }
0:         return this.executor;
1:     }
commit:6d8e2c5
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.usage;
1: 
0: import java.util.ArrayList;
0: import java.util.Iterator;
1: import java.util.LinkedList;
1: import java.util.List;
1: import java.util.concurrent.CopyOnWriteArrayList;
1: 
1: import org.apache.activemq.Service;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
1: /**
0:  * Used to keep track of how much of something is being used so that a
0:  * productive working set usage can be controlled.
1:  * 
0:  * Main use case is manage memory usage.
1:  * 
1:  * @org.apache.xbean.XBean
1:  * 
0:  * @version $Revision: 1.3 $
1:  */
0: public abstract class Usage implements Service{
1: 
0:     private static final Log LOG=LogFactory.getLog(Usage.class);
0:     protected final Object usageMutex=new Object();
1:     protected int percentUsage;
0:     private final Usage parent;
1:     private UsageCapacity limiter = new DefaultUsageCapacity();
0:     private int percentUsageMinDelta=1;
0:     private final List<UsageListener> listeners=new CopyOnWriteArrayList<UsageListener>();
0:     private final boolean debug=LOG.isDebugEnabled();
0:     private String name="";
0:     private float usagePortion=1.0f;
0:     private List<Usage> children=new CopyOnWriteArrayList<Usage>();
0:     private final List<Runnable> callbacks=new LinkedList<Runnable>();
1:     private int pollingTime = 100;
1:    
0:     public Usage(Usage parent,String name,float portion){
0:         this.parent=parent;
0:         this.usagePortion=portion;
0:         if(parent!=null){
0:             this.limiter.setLimit((long)(parent.getLimit()*portion));
0:             this.name=parent.name+":";
1:         }
0:         this.name+=name;
1:     }
1: 
1:     protected abstract long retrieveUsage();
1: 
1:     /**
1:      * @throws InterruptedException
1:      */
0:     public void waitForSpace() throws InterruptedException{
1:         waitForSpace(0);
1:     }
1: 
1:     /**
0:      * @param timeout 
1:      * @throws InterruptedException
1:      * 
1:      * @return true if space
1:      */
0:     public boolean waitForSpace(long timeout) throws InterruptedException{
0:         if(parent!=null){
0:             if(!parent.waitForSpace(timeout)){
1:                 return false;
1:             }
1:         }
0:         synchronized(usageMutex){
0:             caclPercentUsage();
0:             if(percentUsage>=100){
0:                 long deadline=timeout>0?System.currentTimeMillis()+timeout:Long.MAX_VALUE;
0:                 long timeleft=deadline;
0:                 while(timeleft>0){
0:                     caclPercentUsage();
0:                     if(percentUsage>=100){
0:                         usageMutex.wait(pollingTime);
0:                         timeleft=deadline-System.currentTimeMillis();
0:                     }else{
1:                         break;
1:                     }
1:                 }
1:             }
0:             return percentUsage<100;
1:         }
1:     }
1: 
1:     
1: 
0:     public boolean isFull(){
0:         if(parent!=null&&parent.isFull()){
1:             return true;
1:         }
0:         synchronized(usageMutex){
0:             caclPercentUsage();
0:             return percentUsage>=100;
1:         }
1:     }
1: 
0:     public void addUsageListener(UsageListener listener){
1:         listeners.add(listener);
1:     }
1: 
0:     public void removeUsageListener(UsageListener listener){
1:         listeners.remove(listener);
1:     }
1: 
0:     public long getLimit(){
0:         synchronized(usageMutex){
1:             return limiter.getLimit();
1:         }
1:     }
1: 
1:     /**
0:      * Sets the memory limit in bytes. Setting the limit in bytes will set the
0:      * usagePortion to 0 since the UsageManager is not going to be portion based
0:      * off the parent.
1:      * 
0:      * When set using XBean, you can use values such as: "20 mb", "1024 kb", or
0:      * "1 gb"
1:      * 
1:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.MemoryPropertyEditor"
1:      */
0:     public void setLimit(long limit){
0:         if(percentUsageMinDelta<0){
1:             throw new IllegalArgumentException("percentUsageMinDelta must be greater or equal to 0");
1:         }
0:         synchronized(usageMutex){
1:             this.limiter.setLimit(limit);
0:             this.usagePortion=0;
1:         }
1:         onLimitChange();
1:     }
1: 
0:     private void onLimitChange(){
1:         // We may need to calculate the limit
0:         if(usagePortion>0&&parent!=null){
0:             synchronized(usageMutex){
0:                 this.limiter.setLimit((long)(parent.getLimit()*usagePortion));
1:             }
1:         }
1:         // Reset the percent currently being used.
0:         int percentUsage;
0:         synchronized(usageMutex){
0:             percentUsage=caclPercentUsage();
1:         }
0:         setPercentUsage(percentUsage);
1:         // Let the children know that the limit has changed. They may need to
0:         // set
0:         // their limits based on ours.
0:         for(Usage child:children){
1:             child.onLimitChange();
1:         }
1:     }
1: 
0:     public float getUsagePortion(){
0:         synchronized(usageMutex){
1:             return usagePortion;
1:         }
1:     }
1: 
0:     public void setUsagePortion(float usagePortion){
0:         synchronized(usageMutex){
0:             this.usagePortion=usagePortion;
1:         }
1:         onLimitChange();
1:     }
1: 
0:     /*
0:      * Sets the minimum number of percentage points the usage has to change
0:      * before a UsageListener event is fired by the manager.
1:      */
0:     public int getPercentUsage(){
0:         synchronized(usageMutex){
1:             return percentUsage;
1:         }
1:     }
1: 
0:     public int getPercentUsageMinDelta(){
0:         synchronized(usageMutex){
1:             return percentUsageMinDelta;
1:         }
1:     }
1: 
1:     /**
0:      * Sets the minimum number of percentage points the usage has to change
0:      * before a UsageListener event is fired by the manager.
1:      * 
1:      * @param percentUsageMinDelta
1:      */
0:     public void setPercentUsageMinDelta(int percentUsageMinDelta){
0:         if(percentUsageMinDelta<1){
1:             throw new IllegalArgumentException("percentUsageMinDelta must be greater than 0");
1:         }
0:         int percentUsage;
0:         synchronized(usageMutex){
0:             this.percentUsageMinDelta=percentUsageMinDelta;
0:             percentUsage=caclPercentUsage();
1:         }
0:         setPercentUsage(percentUsage);
1:     }
1: 
0:     public long getUsage(){
0:         synchronized(usageMutex){
1:             return retrieveUsage();
1:         }
1:     }
1: 
0:     protected void setPercentUsage(int value){
0:         synchronized(usageMutex){
0:             int oldValue=percentUsage;
0:             percentUsage=value;
0:             if(oldValue!=value){
0:                 fireEvent(oldValue,value);
1:             }
1:         }
1:     }
1: 
0:     protected int caclPercentUsage(){
0:         if(limiter.getLimit()==0){
1:             return 0;
1:         }
0:         return (int)((((retrieveUsage()*100)/limiter.getLimit())/percentUsageMinDelta)*percentUsageMinDelta);
1:     }
1: 
0:     private void fireEvent(int oldPercentUsage,int newPercentUsage){
0:         if(debug){
0:             LOG.debug("Memory usage change.  from: "+oldPercentUsage+", to: "+newPercentUsage);
1:         }
0:         // Switching from being full to not being full..
0:         if(oldPercentUsage>=100&&newPercentUsage<100){
0:             synchronized(usageMutex){
0:                 usageMutex.notifyAll();
0:                 for(Iterator<Runnable> iter=new ArrayList<Runnable>(callbacks).iterator();iter.hasNext();){
0:                     Runnable callback=iter.next();
0:                     callback.run();
1:                 }
0:                 callbacks.clear();
1:             }
1:         }
0:         // Let the listeners know
0:         for(Iterator<UsageListener> iter=listeners.iterator();iter.hasNext();){
0:             UsageListener l=iter.next();
0:             l.onUsageChanged(this,oldPercentUsage,newPercentUsage);
1:         }
1:     }
1: 
0:     public String getName(){
1:         return name;
1:     }
1: 
0:     public String toString(){
0:         return "Usage("+getName()+") percentUsage="+percentUsage+"%, usage="+retrieveUsage()+" limit="+limiter.getLimit()
0:                 +" percentUsageMinDelta="+percentUsageMinDelta+"%";
1:     }
1: 
0:     public void start(){
0:         if(parent!=null){
0:             parent.addChild(this);
1:         }
1:     }
1: 
0:     public void stop(){
0:         if(parent!=null){
0:             parent.removeChild(this);
1:         }
1:     }
1: 
0:     private void addChild(Usage child){
1:         children.add(child);
1:     }
1: 
0:     private void removeChild(Usage child){
1:         children.remove(child);
1:     }
1: 
1:     /**
1:      * @param callback
0:      * @return true if the UsageManager was full. The callback will only be
0:      *         called if this method returns true.
1:      */
0:     public boolean notifyCallbackWhenNotFull(final Runnable callback){
0:         if(parent!=null){
0:             Runnable r=new Runnable(){
1: 
0:                 public void run(){
0:                     synchronized(usageMutex){
0:                         if(percentUsage>=100){
1:                             callbacks.add(callback);
0:                         }else{
0:                             callback.run();
1:                         }
1:                     }
1:                 }
0:             };
0:             if(parent.notifyCallbackWhenNotFull(r)){
1:                 return true;
1:             }
1:         }
0:         synchronized(usageMutex){
0:             if(percentUsage>=100){
1:                 callbacks.add(callback);
1:                 return true;
0:             }else{
1:                 return false;
1:             }
1:         }
1:     }
1: 
1:     
1:     /**
1:      * @return the limiter
1:      */
0:     public UsageCapacity getLimiter(){
1:         return this.limiter;
1:     }
1: 
1:     
1:     /**
0:      * @param limiter the limiter to set
1:      */
0:     public void setLimiter(UsageCapacity limiter){
0:         this.limiter=limiter;
1:     }
1: 
1:     
1:     /**
1:      * @return the pollingTime
1:      */
0:     public int getPollingTime(){
1:         return this.pollingTime;
1:     }
1: 
1:     
1:     /**
0:      * @param pollingTime the pollingTime to set
1:      */
0:     public void setPollingTime(int pollingTime){
0:         this.pollingTime=pollingTime;
1:     }
1: }
author:Bruce Snyder
-------------------------------------------------------------------------------
commit:7cf4728
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("Memory usage change from: " + oldPercentUsage + "% of available memory, to: " 
0:                 + newPercentUsage + "% of available memory");
/////////////////////////////////////////////////////////////////////////
0:                 LOG.warn("Not notifying memory usage change to listeners on shutdown");
============================================================================