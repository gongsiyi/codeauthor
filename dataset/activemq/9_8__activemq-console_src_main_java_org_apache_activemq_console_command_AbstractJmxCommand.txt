1:a107823: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
3:a107823:  *
1:5f1adbe:  *      http://www.apache.org/licenses/LICENSE-2.0
1:a107823:  *
1:a107823:  * Unless required by applicable law or agreed to in writing, software
1:a107823:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a107823:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a107823:  * See the License for the specific language governing permissions and
1:a107823:  * limitations under the License.
1:a107823:  */
1:a107823: package org.apache.activemq.console.command;
1:04d27a7: 
1:04d27a7: import java.io.File;
1:5f1adbe: import java.io.IOException;
1:04d27a7: import java.lang.management.ManagementFactory;
1:04d27a7: import java.lang.reflect.Method;
1:73f9131: import java.net.ConnectException;
1:5f1adbe: import java.net.MalformedURLException;
1:04d27a7: import java.net.URL;
1:04d27a7: import java.net.URLClassLoader;
1:04d27a7: import java.util.HashMap;
1:5f1adbe: import java.util.List;
1:0dec0b6: import java.util.Map;
1:2cce056: import java.util.Properties;
1:3df7404: 
1:04d27a7: import javax.management.MBeanServerConnection;
1:a107823: import javax.management.remote.JMXConnector;
1:a107823: import javax.management.remote.JMXConnectorFactory;
1:5f1adbe: import javax.management.remote.JMXServiceURL;
1:04d27a7: 
1:a107823: public abstract class AbstractJmxCommand extends AbstractCommand {
1:3df7404:     public static String DEFAULT_JMX_URL;
1:3df7404:     private static String jmxUser;
1:3df7404:     private static String jmxPassword;
1:7dc70e0:     private static boolean jmxUseLocal;
1:2cce056:     private static final String CONNECTOR_ADDRESS =
1:2cce056:         "com.sun.management.jmxremote.localConnectorAddress";
1:2cce056: 
1:a107823:     private JMXServiceURL jmxServiceUrl;
1:0dec0b6:     private JMXConnector jmxConnector;
1:0dec0b6:     private MBeanServerConnection jmxConnection;
1:2cce056: 
1:3df7404:     static {
1:2cce056:         DEFAULT_JMX_URL = System.getProperty("activemq.jmx.url", "service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi");
1:2cce056:         jmxUser = System.getProperty("activemq.jmx.user");
1:2cce056:         jmxPassword = System.getProperty("activemq.jmx.password");
1:7dc70e0:         jmxUseLocal = Boolean.parseBoolean(System.getProperty("activemq.jmx.useLocal", "false"));
1:3df7404:     }
1:3df7404: 
1:a107823:     /**
1:a107823:      * Get the current specified JMX service url.
1:a107823:      * @return JMX service url
1:a107823:      */
1:a107823:     protected JMXServiceURL getJmxServiceUrl() {
1:a107823:         return jmxServiceUrl;
3:a107823:     }
1:04d27a7: 
1:2cce056:     public static String getJVM() {
1:2cce056:         return System.getProperty("java.vm.specification.vendor");
1:2cce056:     }
1:2cce056: 
1:2cce056:     public static boolean isSunJVM() {
1:f4c54db:         // need to check for Oracle as that is the name for Java7 onwards.
1:f4c54db:         return getJVM().equals("Sun Microsystems Inc.") || getJVM().startsWith("Oracle");
1:2cce056:     }
1:2cce056: 
1:2cce056:     /**
1:2cce056:      * Finds the JMX Url for a VM by its process id
1:2cce056:      *
1:2cce056:      * @param pid
1:2cce056:      * 		The process id value of the VM to search for.
1:2cce056:      *
1:2cce056:      * @return the JMX Url of the VM with the given pid or null if not found.
1:2cce056:      */
1:2cce056:     @SuppressWarnings({ "rawtypes", "unchecked" })
1:2cce056:     protected String findJMXUrlByProcessId(int pid) {
1:2cce056: 
1:2cce056:         if (isSunJVM()) {
1:2cce056:             try {
1:2cce056:                 // Classes are all dynamically loaded, since they are specific to Sun VM
1:2cce056:                 // if it fails for any reason default jmx url will be used
1:2cce056: 
1:2cce056:                 // tools.jar are not always included used by default class loader, so we
1:2cce056:                 // will try to use custom loader that will try to load tools.jar
1:2cce056: 
1:2cce056:                 String javaHome = System.getProperty("java.home");
1:2cce056:                 String tools = javaHome + File.separator +
1:2cce056:                         ".." + File.separator + "lib" + File.separator + "tools.jar";
1:2cce056:                 URLClassLoader loader = new URLClassLoader(new URL[]{new File(tools).toURI().toURL()});
1:2cce056: 
1:2cce056:                 Class virtualMachine = Class.forName("com.sun.tools.attach.VirtualMachine", true, loader);
1:2cce056:                 Class virtualMachineDescriptor = Class.forName("com.sun.tools.attach.VirtualMachineDescriptor", true, loader);
1:2cce056: 
1:2cce056:                 Method getVMList = virtualMachine.getMethod("list", (Class[])null);
1:2cce056:                 Method attachToVM = virtualMachine.getMethod("attach", String.class);
1:2cce056:                 Method getAgentProperties = virtualMachine.getMethod("getAgentProperties", (Class[])null);
1:2cce056:                 Method getVMId = virtualMachineDescriptor.getMethod("id",  (Class[])null);
1:2cce056: 
1:2cce056:                 List allVMs = (List)getVMList.invoke(null, (Object[])null);
1:2cce056: 
1:2cce056:                 for(Object vmInstance : allVMs) {
1:2cce056:                     String id = (String)getVMId.invoke(vmInstance, (Object[])null);
1:2cce056:                     if (id.equals(Integer.toString(pid))) {
1:2cce056: 
1:2cce056:                         Object vm = attachToVM.invoke(null, id);
1:2cce056: 
1:2cce056:                         Properties agentProperties = (Properties)getAgentProperties.invoke(vm, (Object[])null);
1:2cce056:                         String connectorAddress = agentProperties.getProperty(CONNECTOR_ADDRESS);
1:2cce056: 
1:2cce056:                         if (connectorAddress != null) {
1:2cce056:                             return connectorAddress;
1:2cce056:                         } else {
1:2cce056:                             break;
1:2cce056:                         }
1:2cce056:                     }
1:2cce056:                 }
1:2cce056:             } catch (Exception ignore) {
1:2cce056:             }
1:2cce056:         }
1:2cce056: 
1:2cce056:         return null;
1:04d27a7:     }
1:2cce056: 
1:a107823:     /**
1:a107823:      * Get the current JMX service url being used, or create a default one if no JMX service url has been specified.
1:a107823:      * @return JMX service url
1:a107823:      * @throws MalformedURLException
1:a107823:      */
1:2cce056:     @SuppressWarnings({ "rawtypes", "unchecked" })
1:a107823:     protected JMXServiceURL useJmxServiceUrl() throws MalformedURLException {
1:a107823:         if (getJmxServiceUrl() == null) {
1:04d27a7:             String jmxUrl = DEFAULT_JMX_URL;
1:04d27a7:             int connectingPid = -1;
1:04d27a7:             if (isSunJVM()) {
1:04d27a7:                 try {
1:04d27a7:                     // Classes are all dynamically loaded, since they are specific to Sun VM
1:04d27a7:                     // if it fails for any reason default jmx url will be used
1:2cce056: 
1:2cce056:                     // tools.jar are not always included used by default class loader, so we
1:2cce056:                     // will try to use custom loader that will try to load tools.jar
1:2cce056: 
1:04d27a7:                     String javaHome = System.getProperty("java.home");
1:04d27a7:                     String tools = javaHome + File.separator +
1:04d27a7:                             ".." + File.separator + "lib" + File.separator + "tools.jar";
1:04d27a7:                     URLClassLoader loader = new URLClassLoader(new URL[]{new File(tools).toURI().toURL()});
1:2cce056: 
1:2cce056:                     Class virtualMachine = Class.forName("com.sun.tools.attach.VirtualMachine", true, loader);
1:2cce056:                     Class virtualMachineDescriptor = Class.forName("com.sun.tools.attach.VirtualMachineDescriptor", true, loader);
1:04d27a7: 
1:2cce056:                     Method getVMList = virtualMachine.getMethod("list", (Class[])null);
1:2cce056:                     Method attachToVM = virtualMachine.getMethod("attach", String.class);
1:2cce056:                     Method getAgentProperties = virtualMachine.getMethod("getAgentProperties", (Class[])null);
1:2cce056:                     Method getVMDescriptor = virtualMachineDescriptor.getMethod("displayName",  (Class[])null);
1:2cce056:                     Method getVMId = virtualMachineDescriptor.getMethod("id",  (Class[])null);
1:2cce056: 
1:2cce056:                     List allVMs = (List)getVMList.invoke(null, (Object[])null);
1:2cce056: 
1:2cce056:                     for(Object vmInstance : allVMs) {
1:2cce056:                         String displayName = (String)getVMDescriptor.invoke(vmInstance, (Object[])null);
1:763f32a:                         if (displayName.contains("activemq.jar start")) {
1:2cce056:                             String id = (String)getVMId.invoke(vmInstance, (Object[])null);
1:2cce056: 
1:2cce056:                             Object vm = attachToVM.invoke(null, id);
1:2cce056: 
1:2cce056:                             Properties agentProperties = (Properties)getAgentProperties.invoke(vm, (Object[])null);
1:2cce056:                             String connectorAddress = agentProperties.getProperty(CONNECTOR_ADDRESS);
1:2cce056: 
1:2cce056:                             if (connectorAddress != null) {
1:2cce056:                                 jmxUrl = connectorAddress;
1:2cce056:                                 connectingPid = Integer.parseInt(id);
1:2cce056:                                 context.print("useJmxServiceUrl Found JMS Url: " + jmxUrl);
1:2cce056:                                 break;
1:2cce056:                             }
1:2cce056:                         }
1:04d27a7:                     }
1:2cce056:                 } catch (Exception ignore) {
1:04d27a7:                 }
1:04d27a7:             }
1:2cce056: 
1:04d27a7:             if (connectingPid != -1) {
1:2cce056:                 context.print("Connecting to pid: " + connectingPid);
1:04d27a7:             } else {
1:2cce056:                 context.print("Connecting to JMX URL: " + jmxUrl);
1:04d27a7:             }
1:04d27a7:             setJmxServiceUrl(jmxUrl);
1:04d27a7:         }
1:04d27a7: 
1:a107823:         return getJmxServiceUrl();
1:a107823:     }
1:04d27a7: 
1:a107823:     /**
1:a107823:      * Sets the JMX service url to use.
1:a107823:      * @param jmxServiceUrl - new JMX service url to use
1:a107823:      */
1:a107823:     protected void setJmxServiceUrl(JMXServiceURL jmxServiceUrl) {
1:a107823:         this.jmxServiceUrl = jmxServiceUrl;
1:a107823:     }
1:04d27a7: 
1:a107823:     /**
1:a107823:      * Sets the JMX service url to use.
1:a107823:      * @param jmxServiceUrl - new JMX service url to use
1:a107823:      * @throws MalformedURLException
1:a107823:      */
1:a107823:     protected void setJmxServiceUrl(String jmxServiceUrl) throws MalformedURLException {
1:a107823:         setJmxServiceUrl(new JMXServiceURL(jmxServiceUrl));
1:a107823:     }
1:04d27a7: 
1:a107823:     /**
1:0dec0b6:      * Get the JMX user name to be used when authenticating.
1:0dec0b6:      * @return the JMX user name
1:0dec0b6:      */
1:0dec0b6:     public String getJmxUser() {
1:0dec0b6:         return jmxUser;
1:0dec0b6:     }
1:0dec0b6: 
1:0dec0b6:     /**
1:0dec0b6:      * Sets the JMS user name to use
1:2cce056:      * @param jmxUser - the jmx
1:0dec0b6:      */
1:0dec0b6:     public void setJmxUser(String jmxUser) {
1:2cce056:         AbstractJmxCommand.jmxUser = jmxUser;
1:0dec0b6:     }
1:0dec0b6: 
1:0dec0b6:     /**
1:0dec0b6:      * Get the password used when authenticating
1:0dec0b6:      * @return the password used for JMX authentication
1:0dec0b6:      */
1:0dec0b6:     public String getJmxPassword() {
1:0dec0b6:         return jmxPassword;
1:0dec0b6:     }
1:0dec0b6: 
1:0dec0b6:     /**
1:0dec0b6:      * Sets the password to use when authenticating
1:0dec0b6:      * @param jmxPassword - the password used for JMX authentication
1:0dec0b6:      */
1:0dec0b6:     public void setJmxPassword(String jmxPassword) {
1:2cce056:         AbstractJmxCommand.jmxPassword = jmxPassword;
1:0dec0b6:     }
1:0dec0b6: 
1:0dec0b6:     /**
1:0dec0b6:      * Get whether the default mbean server for this JVM should be used instead of the jmx url
1:0dec0b6:      * @return <code>true</code> if the mbean server from this JVM should be used, <code>false<code> if the jmx url should be used
1:0dec0b6:      */
1:0dec0b6:     public boolean isJmxUseLocal() {
1:0dec0b6:         return jmxUseLocal;
1:0dec0b6:     }
1:0dec0b6: 
1:0dec0b6:     /**
1:0dec0b6:      * Sets whether the the default mbean server for this JVM should be used instead of the jmx url
1:0dec0b6:      * @param jmxUseLocal - <code>true</code> if the mbean server from this JVM should be used, <code>false<code> if the jmx url should be used
1:0dec0b6:      */
1:0dec0b6:     public void setJmxUseLocal(boolean jmxUseLocal) {
1:7dc70e0:         AbstractJmxCommand.jmxUseLocal = jmxUseLocal;
1:0dec0b6:     }
1:0dec0b6: 
1:0dec0b6:     /**
1:a107823:      * Create a JMX connector using the current specified JMX service url. If there is an existing connection,
1:a107823:      * it tries to reuse this connection.
1:a107823:      * @return created JMX connector
1:a107823:      * @throws IOException
1:a107823:      */
1:0dec0b6:     private JMXConnector createJmxConnector() throws IOException {
1:a107823:         // Reuse the previous connection
1:a107823:         if (jmxConnector != null) {
1:a107823:             jmxConnector.connect();
1:a107823:             return jmxConnector;
1:a107823:         }
1:5f1adbe: 
1:a107823:         // Create a new JMX connector
1:0dec0b6:         if (jmxUser != null && jmxPassword != null) {
1:0dec0b6:             Map<String,Object> props = new HashMap<String,Object>();
1:0dec0b6:             props.put(JMXConnector.CREDENTIALS, new String[] { jmxUser, jmxPassword });
1:0dec0b6:             jmxConnector = JMXConnectorFactory.connect(useJmxServiceUrl(), props);
1:0dec0b6:         } else {
1:0dec0b6:             jmxConnector = JMXConnectorFactory.connect(useJmxServiceUrl());
1:0dec0b6:         }
1:a107823:         return jmxConnector;
1:a107823:     }
12:a107823: 
1:a107823:     /**
1:a107823:      * Close the current JMX connector
1:a107823:      */
1:0dec0b6:     protected void closeJmxConnection() {
2:a107823:         try {
1:a107823:             if (jmxConnector != null) {
1:a107823:                 jmxConnector.close();
1:a107823:                 jmxConnector = null;
1:a107823:             }
1:a107823:         } catch (IOException e) {
1:a107823:         }
1:a107823:     }
1:a107823: 
1:0dec0b6:     protected MBeanServerConnection createJmxConnection() throws IOException {
1:0dec0b6:         if (jmxConnection == null) {
1:0dec0b6:             if (isJmxUseLocal()) {
1:0dec0b6:                 jmxConnection = ManagementFactory.getPlatformMBeanServer();
1:0dec0b6:             } else {
1:0dec0b6:                 jmxConnection = createJmxConnector().getMBeanServerConnection();
1:0dec0b6:             }
1:0dec0b6:         }
1:0dec0b6:         return jmxConnection;
1:0dec0b6:     }
1:0dec0b6: 
1:a107823:     /**
1:a107823:      * Handle the --jmxurl option.
1:a107823:      * @param token - option token to handle
1:a107823:      * @param tokens - succeeding command arguments
1:a107823:      * @throws Exception
1:a107823:      */
1:763f32a:     @Override
1:5f1adbe:     protected void handleOption(String token, List<String> tokens) throws Exception {
1:a107823:         // Try to handle the options first
1:a107823:         if (token.equals("--jmxurl")) {
1:a107823:             // If no jmx url specified, or next token is a new option
1:763f32a:             if (tokens.isEmpty() || tokens.get(0).startsWith("-")) {
1:54eb93e:                 context.printException(new IllegalArgumentException("JMX URL not specified."));
1:a107823:             }
1:a107823: 
1:87eba29:             // If jmx url already specified
1:87eba29:             if (getJmxServiceUrl() != null) {
1:54eb93e:                 context.printException(new IllegalArgumentException("Multiple JMX URL cannot be specified."));
1:87eba29:                 tokens.clear();
1:a107823:             }
1:a107823: 
1:763f32a:             String strJmxUrl = tokens.remove(0);
1:87eba29:             try {
1:a107823:                 this.setJmxServiceUrl(new JMXServiceURL(strJmxUrl));
1:87eba29:             } catch (MalformedURLException e) {
1:87eba29:                 context.printException(e);
1:87eba29:                 tokens.clear();
1:87eba29:             }
1:87eba29:         } else if(token.equals("--pid")) {
1:87eba29:            if (isSunJVM()) {
1:763f32a:                if (tokens.isEmpty() || tokens.get(0).startsWith("-")) {
1:87eba29:                    context.printException(new IllegalArgumentException("pid not specified"));
1:87eba29:                    return;
1:87eba29:                }
1:87eba29:                int pid = Integer.parseInt(tokens.remove(0));
1:87eba29:                context.print("Connecting to pid: " + pid);
1:87eba29: 
1:2cce056:                String jmxUrl = findJMXUrlByProcessId(pid);
1:8b2875e:                if (jmxUrl != null) {
1:8b2875e:                    // If jmx url already specified
1:8b2875e:                    if (getJmxServiceUrl() != null) {
1:8b2875e:                        context.printException(new IllegalArgumentException("JMX URL already specified."));
1:8b2875e:                        tokens.clear();
1:8b2875e:                    }
1:8b2875e:                    try {
1:8b2875e:                        this.setJmxServiceUrl(new JMXServiceURL(jmxUrl));
1:8b2875e:                    } catch (MalformedURLException e) {
1:8b2875e:                        context.printException(e);
1:8b2875e:                        tokens.clear();
1:8b2875e:                    }
1:8b2875e:                } else {
1:8b2875e:                    context.printInfo("failed to resolve jmxUrl for pid:" + pid + ", using default JMX url");
1:87eba29:                }
1:87eba29:            }  else {
1:87eba29:               context.printInfo("--pid option is not available for this VM, using default JMX url");
1:87eba29:            }
1:0dec0b6:         } else if (token.equals("--jmxuser")) {
1:0dec0b6:             // If no jmx user specified, or next token is a new option
1:763f32a:             if (tokens.isEmpty() || tokens.get(0).startsWith("-")) {
1:0dec0b6:                 context.printException(new IllegalArgumentException("JMX user not specified."));
1:0dec0b6:             }
1:763f32a:             this.setJmxUser(tokens.remove(0));
1:0dec0b6:         } else if (token.equals("--jmxpassword")) {
1:0dec0b6:             // If no jmx password specified, or next token is a new option
1:763f32a:             if (tokens.isEmpty() || tokens.get(0).startsWith("-")) {
1:0dec0b6:                 context.printException(new IllegalArgumentException("JMX password not specified."));
1:0dec0b6:             }
1:763f32a:             this.setJmxPassword(tokens.remove(0));
1:0dec0b6:         } else if (token.equals("--jmxlocal")) {
1:0dec0b6:             this.setJmxUseLocal(true);
1:a107823:         } else {
1:a107823:             // Let the super class handle the option
1:a107823:             super.handleOption(token, tokens);
1:a107823:         }
1:a107823:     }
1:0dec0b6: 
1:763f32a:     @Override
1:0dec0b6:     public void execute(List<String> tokens) throws Exception {
1:0dec0b6:         try {
1:0dec0b6:             super.execute(tokens);
1:32ca1f5:         } catch (Exception exception) {
1:73f9131:             handleException(exception, jmxServiceUrl.toString());
1:73f9131:             return;
1:73f9131:         }finally {
1:0dec0b6:             closeJmxConnection();
1:0dec0b6:         }
1:0dec0b6:     }
1:a107823: }
============================================================================
author:Benjamin Graf
-------------------------------------------------------------------------------
commit:7dc70e0
/////////////////////////////////////////////////////////////////////////
1:     private static boolean jmxUseLocal;
/////////////////////////////////////////////////////////////////////////
1:         jmxUseLocal = Boolean.parseBoolean(System.getProperty("activemq.jmx.useLocal", "false"));
/////////////////////////////////////////////////////////////////////////
1:         AbstractJmxCommand.jmxUseLocal = jmxUseLocal;
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:32ca1f5
/////////////////////////////////////////////////////////////////////////
1:         } catch (Exception exception) {
commit:73f9131
/////////////////////////////////////////////////////////////////////////
1: import java.net.ConnectException;
/////////////////////////////////////////////////////////////////////////
0:         } catch (Throwable exception) {
1:             handleException(exception, jmxServiceUrl.toString());
1:             return;
1:         }finally {
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:763f32a
/////////////////////////////////////////////////////////////////////////
1:                         if (displayName.contains("activemq.jar start")) {
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:             if (tokens.isEmpty() || tokens.get(0).startsWith("-")) {
/////////////////////////////////////////////////////////////////////////
1:             String strJmxUrl = tokens.remove(0);
/////////////////////////////////////////////////////////////////////////
1:                if (tokens.isEmpty() || tokens.get(0).startsWith("-")) {
/////////////////////////////////////////////////////////////////////////
1:             if (tokens.isEmpty() || tokens.get(0).startsWith("-")) {
1:             this.setJmxUser(tokens.remove(0));
1:             if (tokens.isEmpty() || tokens.get(0).startsWith("-")) {
1:             this.setJmxPassword(tokens.remove(0));
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:2cce056
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
1:     private static final String CONNECTOR_ADDRESS =
1:         "com.sun.management.jmxremote.localConnectorAddress";
1: 
1: 
1:         DEFAULT_JMX_URL = System.getProperty("activemq.jmx.url", "service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi");
1:         jmxUser = System.getProperty("activemq.jmx.user");
1:         jmxPassword = System.getProperty("activemq.jmx.password");
/////////////////////////////////////////////////////////////////////////
1:     public static String getJVM() {
1:         return System.getProperty("java.vm.specification.vendor");
1:     }
1: 
1:     public static boolean isSunJVM() {
0:         return getJVM().equals("Sun Microsystems Inc.");
1:     }
1: 
1:     /**
1:      * Finds the JMX Url for a VM by its process id
1:      *
1:      * @param pid
1:      * 		The process id value of the VM to search for.
1:      *
1:      * @return the JMX Url of the VM with the given pid or null if not found.
1:      */
1:     @SuppressWarnings({ "rawtypes", "unchecked" })
1:     protected String findJMXUrlByProcessId(int pid) {
1: 
1:         if (isSunJVM()) {
1:             try {
1:                 // Classes are all dynamically loaded, since they are specific to Sun VM
1:                 // if it fails for any reason default jmx url will be used
1: 
1:                 // tools.jar are not always included used by default class loader, so we
1:                 // will try to use custom loader that will try to load tools.jar
1: 
1:                 String javaHome = System.getProperty("java.home");
1:                 String tools = javaHome + File.separator +
1:                         ".." + File.separator + "lib" + File.separator + "tools.jar";
1:                 URLClassLoader loader = new URLClassLoader(new URL[]{new File(tools).toURI().toURL()});
1: 
1:                 Class virtualMachine = Class.forName("com.sun.tools.attach.VirtualMachine", true, loader);
1:                 Class virtualMachineDescriptor = Class.forName("com.sun.tools.attach.VirtualMachineDescriptor", true, loader);
1: 
1:                 Method getVMList = virtualMachine.getMethod("list", (Class[])null);
1:                 Method attachToVM = virtualMachine.getMethod("attach", String.class);
1:                 Method getAgentProperties = virtualMachine.getMethod("getAgentProperties", (Class[])null);
1:                 Method getVMId = virtualMachineDescriptor.getMethod("id",  (Class[])null);
1: 
1:                 List allVMs = (List)getVMList.invoke(null, (Object[])null);
1: 
1:                 for(Object vmInstance : allVMs) {
1:                     String id = (String)getVMId.invoke(vmInstance, (Object[])null);
1:                     if (id.equals(Integer.toString(pid))) {
1: 
1:                         Object vm = attachToVM.invoke(null, id);
1: 
1:                         Properties agentProperties = (Properties)getAgentProperties.invoke(vm, (Object[])null);
1:                         String connectorAddress = agentProperties.getProperty(CONNECTOR_ADDRESS);
1: 
1:                         if (connectorAddress != null) {
1:                             return connectorAddress;
1:                         } else {
1:                             break;
1:                         }
1:                     }
1:                 }
1:             } catch (Exception ignore) {
1:             }
1:         }
1: 
1:         return null;
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings({ "rawtypes", "unchecked" })
1: 
1:                     // tools.jar are not always included used by default class loader, so we
1:                     // will try to use custom loader that will try to load tools.jar
1: 
1: 
1:                     Class virtualMachine = Class.forName("com.sun.tools.attach.VirtualMachine", true, loader);
1:                     Class virtualMachineDescriptor = Class.forName("com.sun.tools.attach.VirtualMachineDescriptor", true, loader);
1: 
1:                     Method getVMList = virtualMachine.getMethod("list", (Class[])null);
1:                     Method attachToVM = virtualMachine.getMethod("attach", String.class);
1:                     Method getAgentProperties = virtualMachine.getMethod("getAgentProperties", (Class[])null);
1:                     Method getVMDescriptor = virtualMachineDescriptor.getMethod("displayName",  (Class[])null);
1:                     Method getVMId = virtualMachineDescriptor.getMethod("id",  (Class[])null);
1: 
1:                     List allVMs = (List)getVMList.invoke(null, (Object[])null);
1: 
1:                     for(Object vmInstance : allVMs) {
1:                         String displayName = (String)getVMDescriptor.invoke(vmInstance, (Object[])null);
0:                         if (displayName.contains("run.jar start")) {
1:                             String id = (String)getVMId.invoke(vmInstance, (Object[])null);
1: 
1:                             Object vm = attachToVM.invoke(null, id);
1: 
1:                             Properties agentProperties = (Properties)getAgentProperties.invoke(vm, (Object[])null);
1:                             String connectorAddress = agentProperties.getProperty(CONNECTOR_ADDRESS);
1: 
1:                             if (connectorAddress != null) {
1:                                 jmxUrl = connectorAddress;
1:                                 connectingPid = Integer.parseInt(id);
1:                                 context.print("useJmxServiceUrl Found JMS Url: " + jmxUrl);
1:                                 break;
1:                             }
1:                 } catch (Exception ignore) {
1:                 }
1: 
1:                 context.print("Connecting to pid: " + connectingPid);
1:                 context.print("Connecting to JMX URL: " + jmxUrl);
/////////////////////////////////////////////////////////////////////////
1:      * @param jmxUser - the jmx
1:         AbstractJmxCommand.jmxUser = jmxUser;
/////////////////////////////////////////////////////////////////////////
1:         AbstractJmxCommand.jmxPassword = jmxPassword;
/////////////////////////////////////////////////////////////////////////
1:                String jmxUrl = findJMXUrlByProcessId(pid);
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:f4c54db
/////////////////////////////////////////////////////////////////////////
1:         // need to check for Oracle as that is the name for Java7 onwards.
1:         return getJVM().equals("Sun Microsystems Inc.") || getJVM().startsWith("Oracle");
author:Gary Tully
-------------------------------------------------------------------------------
commit:8b2875e
/////////////////////////////////////////////////////////////////////////
1:                if (jmxUrl != null) {
1:                    // If jmx url already specified
1:                    if (getJmxServiceUrl() != null) {
1:                        context.printException(new IllegalArgumentException("JMX URL already specified."));
1:                        tokens.clear();
1:                    }
1:                    try {
1:                        this.setJmxServiceUrl(new JMXServiceURL(jmxUrl));
1:                    } catch (MalformedURLException e) {
1:                        context.printException(e);
1:                        tokens.clear();
1:                    }
1:                } else {
1:                    context.printInfo("failed to resolve jmxUrl for pid:" + pid + ", using default JMX url");
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:3df7404
/////////////////////////////////////////////////////////////////////////
1:     public static String DEFAULT_JMX_URL;
1:     private static String jmxUser;
1:     private static String jmxPassword;
1:     
1:     
1:     static {
0:     	DEFAULT_JMX_URL = System.getProperty("activemq.jmx.url", "service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi");
0:     	jmxUser = System.getProperty("activemq.jmx.user");
0:     	jmxPassword = System.getProperty("activemq.jmx.password");
1:     }
commit:87eba29
/////////////////////////////////////////////////////////////////////////
1:         } else if(token.equals("--pid")) {
1:            if (isSunJVM()) {
0:                if (tokens.isEmpty() || ((String) tokens.get(0)).startsWith("-")) {
1:                    context.printException(new IllegalArgumentException("pid not specified"));
1:                    return;
1:                }
1:                int pid = Integer.parseInt(tokens.remove(0));
1:                context.print("Connecting to pid: " + pid);
1: 
0:                String jmxUrl = ConnectorAddressLink.importFrom(pid);
1:                // If jmx url already specified
1:                if (getJmxServiceUrl() != null) {
0:                    context.printException(new IllegalArgumentException("JMX URL already specified."));
1:                    tokens.clear();
1:                }
1:                try {
0:                    this.setJmxServiceUrl(new JMXServiceURL(jmxUrl));
1:                } catch (MalformedURLException e) {
1:                    context.printException(e);
1:                    tokens.clear();
1:                }
1:            }  else {
1:               context.printInfo("--pid option is not available for this VM, using default JMX url");
1:            }
commit:04d27a7
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
1: import java.lang.management.ManagementFactory;
0: import java.lang.reflect.Constructor;
1: import java.lang.reflect.Method;
1: import java.net.URL;
1: import java.net.URLClassLoader;
1: import java.util.HashMap;
0: import java.util.Set;
1: import javax.management.MBeanServerConnection;
1: 
0: import sun.management.ConnectorAddressLink;
/////////////////////////////////////////////////////////////////////////
1:     
0:     public static String getJVM() { 
0:         return System.getProperty("java.vm.specification.vendor"); 
1:     } 
1: 
0:     public static boolean isSunJVM() { 
0:         return getJVM().equals("Sun Microsystems Inc."); 
1:     }
/////////////////////////////////////////////////////////////////////////
1:             String jmxUrl = DEFAULT_JMX_URL;
1:             int connectingPid = -1;
1:             if (isSunJVM()) {
1:                 try {
0:                     // Try to attach to the local process
1:                     // Classes are all dynamically loaded, since they are specific to Sun VM
1:                     // if it fails for any reason default jmx url will be used
1:                 	
1:                 	
0:                     // tools.jar are not always included used by default 
0:                     // class loader, so we will try to use custom loader that will
0:                     // try to load tools.jar
1:                     String javaHome = System.getProperty("java.home");
1:                     String tools = javaHome + File.separator +
1:                             ".." + File.separator + "lib" + File.separator + "tools.jar";
1:                     URLClassLoader loader = new URLClassLoader(new URL[]{new File(tools).toURI().toURL()});
1:                     
0:                     // load all classes dynamically so we can compile on non-Sun VMs
1:                     
0:                     //MonitoredHost host = MonitoredHost.getMonitoredHost(new HostIdentifier((String)null));
0:                 	Class monitoredHostClass = Class.forName("sun.jvmstat.monitor.MonitoredHost", true, loader);
0:                 	Method getMonitoredHostMethod = monitoredHostClass.getMethod("getMonitoredHost", String.class);
0:                 	Object host = getMonitoredHostMethod.invoke(null, (String)null);
0:                 	//Set vms = host.activeVms();
0:                 	Method activeVmsMethod = host.getClass().getMethod("activeVms", null);
0:                 	Set vms = (Set)activeVmsMethod.invoke(host, null);
0:                     for (Object vmid: vms) {
0:                         int pid = ((Integer) vmid).intValue();
0:                         //MonitoredVm mvm = host.getMonitoredVm(new VmIdentifier(vmid.toString()));
0:                         Class vmIdentifierClass = Class.forName("sun.jvmstat.monitor.VmIdentifier", true, loader);
0:                         Constructor vmIdentifierConstructor = vmIdentifierClass.getConstructor(String.class);
0:                         Object vmIdentifier = vmIdentifierConstructor.newInstance(vmid.toString());
0:                         Method getMonitoredVmMethod = host.getClass().getMethod("getMonitoredVm", vmIdentifierClass);
0:                         Object mvm = getMonitoredVmMethod.invoke(host, vmIdentifier);
0:                         //String name =  MonitoredVmUtil.commandLine(mvm);
0:                         Class monitoredVmUtilClass = Class.forName("sun.jvmstat.monitor.MonitoredVmUtil", true, loader);
0:                         Method commandLineMethod = monitoredVmUtilClass.getMethod("commandLine", Class.forName("sun.jvmstat.monitor.MonitoredVm", true, loader));
0:                         String name = (String)commandLineMethod.invoke(null, mvm);
0:                         if (name.contains("run.jar start")) {
0:                         	connectingPid = pid;
0:                             jmxUrl = ConnectorAddressLink.importFrom(pid);
0:                             break;
1:                         }
1:                     }
0:                 } catch (Exception ignore) {}
1:             }
1:             
1:             if (connectingPid != -1) {
0:             	context.print("Connecting to pid: " + connectingPid);
1:             } else {
0:             	context.print("Connecting to JMX URL: " + jmxUrl);
1:             }
1:             setJmxServiceUrl(jmxUrl);
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:0dec0b6
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map;
0: import java.util.HashMap;
0: import java.lang.management.ManagementFactory;
0: import javax.management.MBeanServerConnection;
0:     private String jmxUser;
0:     private String jmxPassword;
0:     private boolean jmxUseLocal;
1:     private JMXConnector jmxConnector;
1:     private MBeanServerConnection jmxConnection;
/////////////////////////////////////////////////////////////////////////
1:      * Get the JMX user name to be used when authenticating.
1:      * @return the JMX user name
1:      */
1:     public String getJmxUser() {
1:         return jmxUser;
1:     }
1: 
1:     /**
1:      * Sets the JMS user name to use
0:      * @param jmxUser - the jmx 
1:      */
1:     public void setJmxUser(String jmxUser) {
0:         this.jmxUser = jmxUser;
1:     }
1: 
1:     /**
1:      * Get the password used when authenticating
1:      * @return the password used for JMX authentication
1:      */
1:     public String getJmxPassword() {
1:         return jmxPassword;
1:     }
1: 
1:     /**
1:      * Sets the password to use when authenticating
1:      * @param jmxPassword - the password used for JMX authentication
1:      */
1:     public void setJmxPassword(String jmxPassword) {
0:         this.jmxPassword = jmxPassword;
1:     }
1: 
1:     /**
1:      * Get whether the default mbean server for this JVM should be used instead of the jmx url
1:      * @return <code>true</code> if the mbean server from this JVM should be used, <code>false<code> if the jmx url should be used
1:      */
1:     public boolean isJmxUseLocal() {
1:         return jmxUseLocal;
1:     }
1: 
1:     /**
1:      * Sets whether the the default mbean server for this JVM should be used instead of the jmx url
1:      * @param jmxUseLocal - <code>true</code> if the mbean server from this JVM should be used, <code>false<code> if the jmx url should be used
1:      */
1:     public void setJmxUseLocal(boolean jmxUseLocal) {
0:         this.jmxUseLocal = jmxUseLocal;
1:     }
1: 
1:     /**
1:     private JMXConnector createJmxConnector() throws IOException {
/////////////////////////////////////////////////////////////////////////
1:         if (jmxUser != null && jmxPassword != null) {
1:             Map<String,Object> props = new HashMap<String,Object>();
1:             props.put(JMXConnector.CREDENTIALS, new String[] { jmxUser, jmxPassword });
1:             jmxConnector = JMXConnectorFactory.connect(useJmxServiceUrl(), props);
1:         } else {
1:             jmxConnector = JMXConnectorFactory.connect(useJmxServiceUrl());
1:         }
1:     protected void closeJmxConnection() {
/////////////////////////////////////////////////////////////////////////
1:     protected MBeanServerConnection createJmxConnection() throws IOException {
1:         if (jmxConnection == null) {
1:             if (isJmxUseLocal()) {
1:                 jmxConnection = ManagementFactory.getPlatformMBeanServer();
1:             } else {
1:                 jmxConnection = createJmxConnector().getMBeanServerConnection();
1:             }
1:         }
1:         return jmxConnection;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         } else if (token.equals("--jmxuser")) {
1:             // If no jmx user specified, or next token is a new option
0:             if (tokens.isEmpty() || ((String)tokens.get(0)).startsWith("-")) {
1:                 context.printException(new IllegalArgumentException("JMX user not specified."));
1:             }
0:             this.setJmxUser((String) tokens.remove(0));
1:         } else if (token.equals("--jmxpassword")) {
1:             // If no jmx password specified, or next token is a new option
0:             if (tokens.isEmpty() || ((String)tokens.get(0)).startsWith("-")) {
1:                 context.printException(new IllegalArgumentException("JMX password not specified."));
1:             }
0:             this.setJmxPassword((String) tokens.remove(0));
1:         } else if (token.equals("--jmxlocal")) {
1:             this.setJmxUseLocal(true);
1: 
1:     public void execute(List<String> tokens) throws Exception {
1:         try {
1:             super.execute(tokens);
0:         } finally {
1:             closeJmxConnection();
1:         }
1:     }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:54eb93e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 context.printException(new IllegalArgumentException("JMX URL not specified."));
1:                 context.printException(new IllegalArgumentException("Multiple JMX URL cannot be specified."));
/////////////////////////////////////////////////////////////////////////
0:                 context.printException(e);
commit:5f1adbe
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.net.MalformedURLException;
1: import java.util.List;
1: import javax.management.remote.JMXServiceURL;
1: 
0: import org.apache.activemq.console.formatter.GlobalWriter;
/////////////////////////////////////////////////////////////////////////
1:     protected void handleOption(String token, List<String> tokens) throws Exception {
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:a107823
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.console.command;
1: 
0: import org.apache.activemq.console.formatter.GlobalWriter;
1: 
0: import javax.management.remote.JMXServiceURL;
1: import javax.management.remote.JMXConnector;
1: import javax.management.remote.JMXConnectorFactory;
0: import java.util.List;
0: import java.net.MalformedURLException;
0: import java.io.IOException;
1: 
1: public abstract class AbstractJmxCommand extends AbstractCommand {
0:     public static final String DEFAULT_JMX_URL    = "service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi";
1: 
1:     private JMXServiceURL jmxServiceUrl;
0:     private JMXConnector  jmxConnector;
1: 
1:     /**
1:      * Get the current specified JMX service url.
1:      * @return JMX service url
1:      */
1:     protected JMXServiceURL getJmxServiceUrl() {
1:         return jmxServiceUrl;
1:     }
1: 
1:     /**
1:      * Get the current JMX service url being used, or create a default one if no JMX service url has been specified.
1:      * @return JMX service url
1:      * @throws MalformedURLException
1:      */
1:     protected JMXServiceURL useJmxServiceUrl() throws MalformedURLException {
1:         if (getJmxServiceUrl() == null) {
0:             setJmxServiceUrl(DEFAULT_JMX_URL);
1:         }
1: 
1:         return getJmxServiceUrl();
1:     }
1: 
1:     /**
1:      * Sets the JMX service url to use.
1:      * @param jmxServiceUrl - new JMX service url to use
1:      */
1:     protected void setJmxServiceUrl(JMXServiceURL jmxServiceUrl) {
1:         this.jmxServiceUrl = jmxServiceUrl;
1:     }
1: 
1:     /**
1:      * Sets the JMX service url to use.
1:      * @param jmxServiceUrl - new JMX service url to use
1:      * @throws MalformedURLException
1:      */
1:     protected void setJmxServiceUrl(String jmxServiceUrl) throws MalformedURLException {
1:         setJmxServiceUrl(new JMXServiceURL(jmxServiceUrl));
1:     }
1: 
1:     /**
1:      * Create a JMX connector using the current specified JMX service url. If there is an existing connection,
1:      * it tries to reuse this connection.
1:      * @return created JMX connector
1:      * @throws IOException
1:      */
0:     protected JMXConnector createJmxConnector() throws IOException {
1:         // Reuse the previous connection
1:         if (jmxConnector != null) {
1:             jmxConnector.connect();
1:             return jmxConnector;
1:         }
1: 
1:         // Create a new JMX connector
0:         jmxConnector = JMXConnectorFactory.connect(useJmxServiceUrl());
1:         return jmxConnector;
1:     }
1: 
1:     /**
1:      * Close the current JMX connector
1:      */
0:     protected void closeJmxConnector() {
1:         try {
1:             if (jmxConnector != null) {
1:                 jmxConnector.close();
1:                 jmxConnector = null;
1:             }
1:         } catch (IOException e) {
1:         }
1:     }
1: 
1:     /**
1:      * Handle the --jmxurl option.
1:      * @param token - option token to handle
1:      * @param tokens - succeeding command arguments
1:      * @throws Exception
1:      */
0:     protected void handleOption(String token, List tokens) throws Exception {
1:         // Try to handle the options first
1:         if (token.equals("--jmxurl")) {
1:             // If no jmx url specified, or next token is a new option
0:             if (tokens.isEmpty() || ((String)tokens.get(0)).startsWith("-")) {
0:                 GlobalWriter.printException(new IllegalArgumentException("JMX URL not specified."));
1:             }
1: 
0:             // If jmx url already specified
0:             if (getJmxServiceUrl() != null) {
0:                 GlobalWriter.printException(new IllegalArgumentException("Multiple JMX URL cannot be specified."));
0:                 tokens.clear();
1:             }
1: 
0:             String strJmxUrl = (String)tokens.remove(0);
1:             try {
1:                 this.setJmxServiceUrl(new JMXServiceURL(strJmxUrl));
0:             } catch (MalformedURLException e) {
0:                 GlobalWriter.printException(e);
0:                 tokens.clear();
1:             }
1:         } else {
1:             // Let the super class handle the option
1:             super.handleOption(token, tokens);
1:         }
1:     }
1: }
commit:982a119
/////////////////////////////////////////////////////////////////////////
0: public abstract class AbstractJmxCommand extends AbstractCommand {
author:Adrian T. Co
-------------------------------------------------------------------------------
commit:7fa8660
/////////////////////////////////////////////////////////////////////////
0: package org.apache.activemq.console.command;
0: import org.apache.activemq.console.formatter.GlobalWriter;
commit:4b8822f
/////////////////////////////////////////////////////////////////////////
0: package org.apache.activemq.broker.console.command;
0: 
0: import org.apache.activemq.broker.console.formatter.GlobalWriter;
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Get the current specified JMX service url.
0:      * @return JMX service url
0:      */
0:     protected JMXServiceURL getJmxServiceUrl() {
0:     /**
0:      * Get the current JMX service url being used, or create a default one if no JMX service url has been specified.
0:      * @return JMX service url
0:      * @throws MalformedURLException
0:      */
0:     protected JMXServiceURL useJmxServiceUrl() throws MalformedURLException {
0:         if (getJmxServiceUrl() == null) {
0:             setJmxServiceUrl(DEFAULT_JMX_URL);
0:         }
0: 
0:         return getJmxServiceUrl();
0:     }
0: 
0:     /**
0:      * Sets the JMX service url to use.
0:      * @param jmxServiceUrl - new JMX service url to use
0:      */
0:     /**
0:      * Sets the JMX service url to use.
0:      * @param jmxServiceUrl - new JMX service url to use
0:      * @throws MalformedURLException
0:      */
0:     protected void setJmxServiceUrl(String jmxServiceUrl) throws MalformedURLException {
0:     /**
0:      * Create a JMX connector using the current specified JMX service url. If there is an existing connection,
0:      * it tries to reuse this connection.
0:      * @return created JMX connector
0:      * @throws IOException
0:      */
0:     protected JMXConnector createJmxConnector() throws IOException {
/////////////////////////////////////////////////////////////////////////
0:         jmxConnector = JMXConnectorFactory.connect(useJmxServiceUrl());
0:     /**
0:      * Close the current JMX connector
0:      */
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Handle the --jmxurl option.
0:      * @param token - option token to handle
0:      * @param tokens - succeeding command arguments
0:      * @throws Exception
0:      */
0:                 GlobalWriter.printException(new IllegalArgumentException("JMX URL not specified."));
0:                 GlobalWriter.printException(new IllegalArgumentException("Multiple JMX URL cannot be specified."));
/////////////////////////////////////////////////////////////////////////
0:                 GlobalWriter.printException(e);
commit:70c2d88
/////////////////////////////////////////////////////////////////////////
0: /**
0:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: package org.apache.activemq.broker.console;
0: 
0: import javax.management.remote.JMXServiceURL;
0: import javax.management.remote.JMXConnector;
0: import javax.management.remote.JMXConnectorFactory;
0: import java.util.List;
0: import java.net.MalformedURLException;
0: import java.io.IOException;
0: 
0: public abstract class AbstractJmxTask extends AbstractTask {
0:     public static final String DEFAULT_JMX_URL    = "service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi";
0: 
0:     private JMXServiceURL jmxServiceUrl;
0:     private JMXConnector  jmxConnector;
0: 
0:     protected JMXServiceURL getJmxServiceUrl() throws Exception {
0:         return jmxServiceUrl;
0:     }
0: 
0:     protected void setJmxServiceUrl(JMXServiceURL jmxServiceUrl) {
0:         this.jmxServiceUrl = jmxServiceUrl;
0:     }
0: 
0:     protected void setJmxServiceUrl(String jmxServiceUrl) throws Exception {
0:         setJmxServiceUrl(new JMXServiceURL(jmxServiceUrl));
0:     }
0: 
0:     protected JMXConnector createJmxConnector() throws Exception {
0:         // Reuse the previous connection
0:         if (jmxConnector != null) {
0:             jmxConnector.connect();
0:             return jmxConnector;
0:         }
0: 
0:         // Create a new JMX connector
0:         if (getJmxServiceUrl() == null) {
0:             setJmxServiceUrl(DEFAULT_JMX_URL);
0:         }
0:         jmxConnector = JMXConnectorFactory.connect(getJmxServiceUrl());
0:         return jmxConnector;
0:     }
0: 
0:     protected void closeJmxConnector() {
0:         try {
0:             if (jmxConnector != null) {
0:                 jmxConnector.close();
0:                 jmxConnector = null;
0:             }
0:         } catch (IOException e) {
0:         }
0:     }
0: 
0:     protected void handleOption(String token, List tokens) throws Exception {
0:         // Try to handle the options first
0:         if (token.equals("--jmxurl")) {
0:             // If no jmx url specified, or next token is a new option
0:             if (tokens.isEmpty() || ((String)tokens.get(0)).startsWith("-")) {
0:                 printError("JMX URL not specified.");
0:             }
0: 
0:             // If jmx url already specified
0:             if (getJmxServiceUrl() != null) {
0:                 printError("Multiple JMX URL cannot be specified.");
0:                 tokens.clear();
0:             }
0: 
0:             String strJmxUrl = (String)tokens.remove(0);
0:             try {
0:                 this.setJmxServiceUrl(new JMXServiceURL(strJmxUrl));
0:             } catch (MalformedURLException e) {
0:                 printError("Invalid JMX URL format: " + strJmxUrl);
0:                 tokens.clear();
0:             }
0:         } else {
0:             // Let the super class handle the option
0:             super.handleOption(token, tokens);
0:         }
0:     }
0: }
============================================================================