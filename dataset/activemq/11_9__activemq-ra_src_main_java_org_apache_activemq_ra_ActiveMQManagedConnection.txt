1:40a7d3b: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
7:40a7d3b:  *
1:5f1adbe:  *      http://www.apache.org/licenses/LICENSE-2.0
1:40a7d3b:  *
1:40a7d3b:  * Unless required by applicable law or agreed to in writing, software
1:40a7d3b:  * distributed under the License is distributed on an "AS IS" BASIS,
1:40a7d3b:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:40a7d3b:  * See the License for the specific language governing permissions and
1:40a7d3b:  * limitations under the License.
1:92a698f:  */
1:fd4bb60: package org.apache.activemq.ra;
20:40a7d3b: 
1:40a7d3b: import java.io.PrintWriter;
1:6db9a37: import java.util.List;
1:6db9a37: import java.util.concurrent.CopyOnWriteArrayList;
1:40a7d3b: import javax.jms.Connection;
1:40a7d3b: import javax.jms.ExceptionListener;
1:40a7d3b: import javax.jms.JMSException;
1:40a7d3b: import javax.resource.ResourceException;
1:40a7d3b: import javax.resource.spi.ConnectionEvent;
1:40a7d3b: import javax.resource.spi.ConnectionEventListener;
1:40a7d3b: import javax.resource.spi.ConnectionRequestInfo;
1:40a7d3b: import javax.resource.spi.LocalTransaction;
1:40a7d3b: import javax.resource.spi.ManagedConnection;
1:40a7d3b: import javax.resource.spi.ManagedConnectionMetaData;
1:40a7d3b: import javax.security.auth.Subject;
1:40a7d3b: import javax.transaction.xa.XAResource;
1:fd4bb60: import org.apache.activemq.ActiveMQConnection;
1:fd4bb60: import org.apache.activemq.LocalTransactionEventListener;
1:fd4bb60: import org.apache.activemq.TransactionContext;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:40a7d3b: 
1:40a7d3b: /**
1:540dd5c:  * ActiveMQManagedConnection maps to real physical connection to the server.
1:540dd5c:  * Since a ManagedConnection has to provide a transaction managment interface to
1:540dd5c:  * the physical connection, and sessions are the objects implement transaction
1:540dd5c:  * managment interfaces in the JMS API, this object also maps to a singe
1:540dd5c:  * physical JMS session. <p/> The side-effect is that JMS connection the
1:540dd5c:  * application gets will allways create the same session object. This is good if
1:540dd5c:  * running in an app server since the sessions are elisted in the context
1:540dd5c:  * transaction. This is bad if used outside of an app server since the user may
1:540dd5c:  * be trying to create 2 different sessions to coordinate 2 different uow.
1:b0c2a40:  * 
1:540dd5c:  * 
1:40a7d3b:  */
1:540dd5c: public class ActiveMQManagedConnection implements ManagedConnection, ExceptionListener { // TODO:
1:540dd5c:                                                                                             // ,
1:540dd5c:                                                                                             // DissociatableManagedConnection
1:540dd5c:                                                                                             // {
1:40a7d3b: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(ActiveMQManagedConnection.class);
1:40a7d3b: 
1:40a7d3b:     private PrintWriter logWriter;
1:40a7d3b: 
1:40a7d3b:     private final ActiveMQConnection physicalConnection;
1:40a7d3b:     private final TransactionContext transactionContext;
1:6db9a37:     private final List<ManagedConnectionProxy> proxyConnections = new CopyOnWriteArrayList<ManagedConnectionProxy>();
1:6db9a37:     private final List<ConnectionEventListener> listeners = new CopyOnWriteArrayList<ConnectionEventListener>();
1:40a7d3b:     private final LocalAndXATransaction localAndXATransaction;
1:540dd5c: 
1:40a7d3b:     private Subject subject;
1:40a7d3b:     private ActiveMQConnectionRequestInfo info;
1:bc72c54:     private boolean destroyed;
1:40a7d3b: 
1:40a7d3b:     public ActiveMQManagedConnection(Subject subject, ActiveMQConnection physicalConnection, ActiveMQConnectionRequestInfo info) throws ResourceException {
1:40a7d3b:         try {
1:40a7d3b:             this.subject = subject;
1:40a7d3b:             this.info = info;
1:40a7d3b:             this.physicalConnection = physicalConnection;
1:40a7d3b:             this.transactionContext = new TransactionContext(physicalConnection);
1:540dd5c: 
1:40a7d3b:             this.localAndXATransaction = new LocalAndXATransaction(transactionContext) {
1:40a7d3b:                 public void setInManagedTx(boolean inManagedTx) throws JMSException {
1:540dd5c:                     super.setInManagedTx(inManagedTx);
1:6db9a37:                     for (ManagedConnectionProxy proxy:proxyConnections) {
1:40a7d3b:                         proxy.setUseSharedTxContext(inManagedTx);
1:540dd5c:                     }
7:40a7d3b:                 }
1:40a7d3b:             };
1:540dd5c: 
1:540dd5c:             this.transactionContext.setLocalTransactionEventListener(new LocalTransactionEventListener() {
1:40a7d3b:                 public void beginEvent() {
1:40a7d3b:                     fireBeginEvent();
1:40a7d3b:                 }
1:540dd5c: 
1:40a7d3b:                 public void commitEvent() {
1:40a7d3b:                     fireCommitEvent();
1:40a7d3b:                 }
1:540dd5c: 
1:40a7d3b:                 public void rollbackEvent() {
1:40a7d3b:                     fireRollbackEvent();
1:40a7d3b:                 }
1:40a7d3b:             });
1:540dd5c: 
1:40a7d3b:             physicalConnection.setExceptionListener(this);
1:540dd5c:         } catch (JMSException e) {
1:540dd5c:             throw new ResourceException("Could not create a new connection: " + e.getMessage(), e);
1:540dd5c:         }
1:40a7d3b:     }
1:540dd5c: 
1:40a7d3b:     public boolean isInManagedTx() {
1:40a7d3b:         return localAndXATransaction.isInManagedTx();
1:40a7d3b:     }
1:540dd5c: 
1:540dd5c:     public static boolean matches(Object x, Object y) {
1:40a7d3b:         if (x == null ^ y == null) {
1:40a7d3b:             return false;
1:40a7d3b:         }
1:40a7d3b:         if (x != null && !x.equals(y)) {
1:40a7d3b:             return false;
1:40a7d3b:         }
1:40a7d3b:         return true;
1:40a7d3b:     }
1:40a7d3b: 
1:40a7d3b:     public void associate(Subject subject, ActiveMQConnectionRequestInfo info) throws JMSException {
1:40a7d3b: 
1:40a7d3b:         // Do we need to change the associated userid/password
1:540dd5c:         if (!matches(info.getUserName(), this.info.getUserName()) || !matches(info.getPassword(), this.info.getPassword())) {
1:bc72c54:             physicalConnection.changeUserInfo(info.getUserName(), info.getPassword());
1:40a7d3b:         }
1:540dd5c: 
1:40a7d3b:         // Do we need to set the clientId?
1:540dd5c:         if (info.getClientid() != null && info.getClientid().length() > 0) {
1:40a7d3b:             physicalConnection.setClientID(info.getClientid());
1:540dd5c:         }
1:40a7d3b: 
1:40a7d3b:         this.subject = subject;
1:40a7d3b:         this.info = info;
1:40a7d3b:     }
1:40a7d3b: 
1:40a7d3b:     public Connection getPhysicalConnection() {
1:40a7d3b:         return physicalConnection;
1:40a7d3b:     }
1:540dd5c: 
1:40a7d3b:     private void fireBeginEvent() {
1:540dd5c:         ConnectionEvent event = new ConnectionEvent(ActiveMQManagedConnection.this, ConnectionEvent.LOCAL_TRANSACTION_STARTED);
1:6db9a37:         for(ConnectionEventListener l:listeners) {
1:40a7d3b:             l.localTransactionStarted(event);
1:40a7d3b:         }
1:40a7d3b:     }
1:40a7d3b: 
1:40a7d3b:     private void fireCommitEvent() {
1:540dd5c:         ConnectionEvent event = new ConnectionEvent(ActiveMQManagedConnection.this, ConnectionEvent.LOCAL_TRANSACTION_COMMITTED);
1:6db9a37:         for(ConnectionEventListener l:listeners) {
1:40a7d3b:             l.localTransactionCommitted(event);
1:40a7d3b:         }
1:40a7d3b:     }
1:40a7d3b: 
1:40a7d3b:     private void fireRollbackEvent() {
1:540dd5c:         ConnectionEvent event = new ConnectionEvent(ActiveMQManagedConnection.this, ConnectionEvent.LOCAL_TRANSACTION_ROLLEDBACK);
1:6db9a37:         for(ConnectionEventListener l:listeners) {
1:40a7d3b:             l.localTransactionRolledback(event);
1:40a7d3b:         }
1:40a7d3b:     }
1:40a7d3b: 
1:40a7d3b:     private void fireCloseEvent(ManagedConnectionProxy proxy) {
1:540dd5c:         ConnectionEvent event = new ConnectionEvent(ActiveMQManagedConnection.this, ConnectionEvent.CONNECTION_CLOSED);
1:40a7d3b:         event.setConnectionHandle(proxy);
1:540dd5c: 
1:6db9a37:         for(ConnectionEventListener l:listeners) {
1:40a7d3b:             l.connectionClosed(event);
1:40a7d3b:         }
1:40a7d3b:     }
1:40a7d3b: 
1:40a7d3b:     private void fireErrorOccurredEvent(Exception error) {
1:540dd5c:         ConnectionEvent event = new ConnectionEvent(ActiveMQManagedConnection.this, ConnectionEvent.CONNECTION_ERROR_OCCURRED, error);
1:6db9a37:         for(ConnectionEventListener l:listeners) {
1:40a7d3b:             l.connectionErrorOccurred(event);
1:40a7d3b:         }
1:40a7d3b:     }
1:40a7d3b: 
1:40a7d3b:     /**
1:40a7d3b:      * @see javax.resource.spi.ManagedConnection#getConnection(javax.security.auth.Subject,
1:40a7d3b:      *      javax.resource.spi.ConnectionRequestInfo)
1:40a7d3b:      */
1:540dd5c:     public Object getConnection(Subject subject, ConnectionRequestInfo info) throws ResourceException {
1:9e13901:         ManagedConnectionProxy proxy = new ManagedConnectionProxy(this, info);
1:40a7d3b:         proxyConnections.add(proxy);
1:40a7d3b:         return proxy;
1:40a7d3b:     }
1:40a7d3b: 
1:40a7d3b:     private boolean isDestroyed() {
1:bc72c54:         return destroyed;
1:40a7d3b:     }
1:540dd5c: 
1:40a7d3b:     /**
1:40a7d3b:      * Close down the physical connection to the server.
1:540dd5c:      * 
1:40a7d3b:      * @see javax.resource.spi.ManagedConnection#destroy()
1:40a7d3b:      */
1:40a7d3b:     public void destroy() throws ResourceException {
1:de58386:         // Have we already been destroyed??
1:40a7d3b:         if (isDestroyed()) {
1:40a7d3b:             return;
1:40a7d3b:         }
1:40a7d3b: 
1:40a7d3b:         try {
1:e8818fa:             cleanup();
1:e8818fa:         } finally {
1:e8818fa:             try {
1:e8818fa:                 physicalConnection.close();
1:e8818fa:                 destroyed = true;
1:e8818fa:             } catch (JMSException e) {
1:e8818fa:                 LOG.trace("Error occurred during close of a JMS connection.", e);
1:e8818fa:             }
1:40a7d3b:         }
1:40a7d3b:     }
1:40a7d3b: 
1:40a7d3b:     /**
1:40a7d3b:      * Cleans up all proxy handles attached to this physical connection so that
1:40a7d3b:      * they cannot be used anymore.
1:40a7d3b:      * 
1:40a7d3b:      * @see javax.resource.spi.ManagedConnection#cleanup()
1:40a7d3b:      */
1:40a7d3b:     public void cleanup() throws ResourceException {
1:540dd5c: 
1:de58386:         // Have we already been destroyed??
1:40a7d3b:         if (isDestroyed()) {
1:40a7d3b:             return;
1:40a7d3b:         }
1:40a7d3b: 
1:6db9a37:         for (ManagedConnectionProxy proxy:proxyConnections) {
1:40a7d3b:             proxy.cleanup();
1:40a7d3b:         }
1:40a7d3b:         proxyConnections.clear();
1:40a7d3b: 
1:40a7d3b:         try {
1:2bd3379:             physicalConnection.doCleanup(physicalConnection.isUserSpecifiedClientID());
3:40a7d3b:         } catch (JMSException e) {
1:c705523:             throw new ResourceException("Could not cleanup the ActiveMQ connection: " + e, e);
1:e8818fa:         } finally {
1:e8818fa:             // defer transaction cleanup till after close so that close is aware of the current tx
1:e8818fa:             localAndXATransaction.cleanup();
1:40a7d3b:         }
1:40a7d3b:     }
1:540dd5c: 
1:40a7d3b:     /**
1:40a7d3b:      * @see javax.resource.spi.ManagedConnection#associateConnection(java.lang.Object)
1:40a7d3b:      */
1:40a7d3b:     public void associateConnection(Object connection) throws ResourceException {
1:e310c21:         if (connection instanceof ManagedConnectionProxy) {
1:540dd5c:             ManagedConnectionProxy proxy = (ManagedConnectionProxy)connection;
1:e310c21:             proxyConnections.add(proxy);
1:540dd5c:         } else {
1:e310c21:             throw new ResourceException("Not supported : associating connection instance of " + connection.getClass().getName());
1:e310c21:         }
1:e310c21:     }
1:540dd5c: 
1:40a7d3b:     /**
1:40a7d3b:      * @see javax.resource.spi.ManagedConnection#addConnectionEventListener(javax.resource.spi.ConnectionEventListener)
1:40a7d3b:      */
1:40a7d3b:     public void addConnectionEventListener(ConnectionEventListener listener) {
1:40a7d3b:         listeners.add(listener);
1:40a7d3b:     }
1:40a7d3b: 
1:40a7d3b:     /**
1:40a7d3b:      * @see javax.resource.spi.ManagedConnection#removeConnectionEventListener(javax.resource.spi.ConnectionEventListener)
1:40a7d3b:      */
1:40a7d3b:     public void removeConnectionEventListener(ConnectionEventListener listener) {
1:40a7d3b:         listeners.remove(listener);
1:40a7d3b:     }
1:40a7d3b: 
1:40a7d3b:     /**
1:40a7d3b:      * @see javax.resource.spi.ManagedConnection#getXAResource()
1:40a7d3b:      */
1:40a7d3b:     public XAResource getXAResource() throws ResourceException {
1:40a7d3b:         return localAndXATransaction;
1:40a7d3b:     }
1:40a7d3b: 
1:40a7d3b:     /**
1:40a7d3b:      * @see javax.resource.spi.ManagedConnection#getLocalTransaction()
1:40a7d3b:      */
1:40a7d3b:     public LocalTransaction getLocalTransaction() throws ResourceException {
1:40a7d3b:         return localAndXATransaction;
1:40a7d3b:     }
1:40a7d3b: 
1:40a7d3b:     /**
1:40a7d3b:      * @see javax.resource.spi.ManagedConnection#getMetaData()
1:40a7d3b:      */
1:40a7d3b:     public ManagedConnectionMetaData getMetaData() throws ResourceException {
1:40a7d3b:         return new ManagedConnectionMetaData() {
1:40a7d3b: 
1:40a7d3b:             public String getEISProductName() throws ResourceException {
1:40a7d3b:                 if (physicalConnection == null) {
1:40a7d3b:                     throw new ResourceException("Not connected.");
1:40a7d3b:                 }
1:40a7d3b:                 try {
1:40a7d3b:                     return physicalConnection.getMetaData().getJMSProviderName();
1:540dd5c:                 } catch (JMSException e) {
1:40a7d3b:                     throw new ResourceException("Error accessing provider.", e);
1:40a7d3b:                 }
1:40a7d3b:             }
1:40a7d3b: 
1:40a7d3b:             public String getEISProductVersion() throws ResourceException {
1:40a7d3b:                 if (physicalConnection == null) {
1:40a7d3b:                     throw new ResourceException("Not connected.");
1:40a7d3b:                 }
1:40a7d3b:                 try {
1:40a7d3b:                     return physicalConnection.getMetaData().getProviderVersion();
1:540dd5c:                 } catch (JMSException e) {
1:40a7d3b:                     throw new ResourceException("Error accessing provider.", e);
1:40a7d3b:                 }
1:40a7d3b:             }
1:40a7d3b: 
1:40a7d3b:             public int getMaxConnections() throws ResourceException {
1:40a7d3b:                 if (physicalConnection == null) {
1:40a7d3b:                     throw new ResourceException("Not connected.");
1:40a7d3b:                 }
1:40a7d3b:                 return Integer.MAX_VALUE;
1:40a7d3b:             }
1:40a7d3b: 
1:40a7d3b:             public String getUserName() throws ResourceException {
1:40a7d3b:                 if (physicalConnection == null) {
1:40a7d3b:                     throw new ResourceException("Not connected.");
1:40a7d3b:                 }
1:40a7d3b:                 try {
1:40a7d3b:                     return physicalConnection.getClientID();
1:540dd5c:                 } catch (JMSException e) {
1:40a7d3b:                     throw new ResourceException("Error accessing provider.", e);
1:40a7d3b:                 }
1:40a7d3b:             }
1:40a7d3b:         };
1:40a7d3b:     }
1:40a7d3b: 
1:40a7d3b:     /**
1:40a7d3b:      * @see javax.resource.spi.ManagedConnection#setLogWriter(java.io.PrintWriter)
1:40a7d3b:      */
1:40a7d3b:     public void setLogWriter(PrintWriter logWriter) throws ResourceException {
1:40a7d3b:         this.logWriter = logWriter;
1:40a7d3b:     }
1:40a7d3b: 
1:40a7d3b:     /**
1:40a7d3b:      * @see javax.resource.spi.ManagedConnection#getLogWriter()
1:40a7d3b:      */
1:40a7d3b:     public PrintWriter getLogWriter() throws ResourceException {
1:40a7d3b:         return logWriter;
1:40a7d3b:     }
1:40a7d3b: 
1:40a7d3b:     /**
1:bc72c54:      * @param subject subject to match
1:bc72c54:      * @param info cri to match
1:bc72c54:      * @return whether the subject and cri match sufficiently to allow using this connection under the new circumstances
1:40a7d3b:      */
1:40a7d3b:     public boolean matches(Subject subject, ConnectionRequestInfo info) {
1:40a7d3b:         // Check to see if it is our info class
1:40a7d3b:         if (info == null) {
1:40a7d3b:             return false;
1:40a7d3b:         }
1:40a7d3b:         if (info.getClass() != ActiveMQConnectionRequestInfo.class) {
1:40a7d3b:             return false;
1:40a7d3b:         }
1:40a7d3b: 
1:40a7d3b:         // Do the subjects match?
1:40a7d3b:         if (subject == null ^ this.subject == null) {
1:40a7d3b:             return false;
1:40a7d3b:         }
1:40a7d3b:         if (subject != null && !subject.equals(this.subject)) {
1:40a7d3b:             return false;
1:40a7d3b:         }
1:40a7d3b: 
1:40a7d3b:         // Does the info match?
1:40a7d3b:         return info.equals(this.info);
1:40a7d3b:     }
1:40a7d3b: 
1:40a7d3b:     /**
1:de58386:      * When a proxy is closed this cleans up the proxy and notifies the
1:40a7d3b:      * ConnectionEventListeners that a connection closed.
1:540dd5c:      * 
1:40a7d3b:      * @param proxy
1:40a7d3b:      */
1:40a7d3b:     public void proxyClosedEvent(ManagedConnectionProxy proxy) {
1:40a7d3b:         proxyConnections.remove(proxy);
1:40a7d3b:         proxy.cleanup();
1:40a7d3b:         fireCloseEvent(proxy);
1:40a7d3b:     }
1:40a7d3b: 
1:40a7d3b:     public void onException(JMSException e) {
1:540dd5c:         LOG.warn("Connection failed: " + e);
1:540dd5c:         LOG.debug("Cause: ", e);
1:540dd5c: 
1:6db9a37:         for (ManagedConnectionProxy proxy:proxyConnections) {
1:40a7d3b:             proxy.onException(e);
1:40a7d3b:         }
1:de58386:         // Let the container know that the error occurred.
1:40a7d3b:         fireErrorOccurredEvent(e);
1:40a7d3b:     }
1:40a7d3b: 
1:40a7d3b:     /**
1:40a7d3b:      * @return Returns the transactionContext.
1:40a7d3b:      */
1:40a7d3b:     public TransactionContext getTransactionContext() {
1:40a7d3b:         return transactionContext;
1:40a7d3b:     }
1:40a7d3b: 
1:e1cd19e:     @Override
1:e1cd19e:     public String toString() {
1:e1cd19e:         return "[" + super.toString() + "," + physicalConnection +"]";
1:e1cd19e:     }
1:e1cd19e: 
1:40a7d3b: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:2bd3379
/////////////////////////////////////////////////////////////////////////
1:             physicalConnection.doCleanup(physicalConnection.isUserSpecifiedClientID());
commit:5a27bdf
/////////////////////////////////////////////////////////////////////////
0:             physicalConnection.doCleanup(true);
commit:e1cd19e
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public String toString() {
1:         return "[" + super.toString() + "," + physicalConnection +"]";
1:     }
1: 
commit:9e13901
/////////////////////////////////////////////////////////////////////////
1:         ManagedConnectionProxy proxy = new ManagedConnectionProxy(this, info);
commit:e8818fa
/////////////////////////////////////////////////////////////////////////
1:             cleanup();
1:         } finally {
1:             try {
1:                 physicalConnection.close();
1:                 destroyed = true;
1:             } catch (JMSException e) {
1:                 LOG.trace("Error occurred during close of a JMS connection.", e);
1:             }
/////////////////////////////////////////////////////////////////////////
1:         } finally {
1:             // defer transaction cleanup till after close so that close is aware of the current tx
1:             localAndXATransaction.cleanup();
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:c705523
/////////////////////////////////////////////////////////////////////////
1:             throw new ResourceException("Could not cleanup the ActiveMQ connection: " + e, e);
author:Hiram Chirino
-------------------------------------------------------------------------------
commit:de58386
/////////////////////////////////////////////////////////////////////////
1:         // Have we already been destroyed??
/////////////////////////////////////////////////////////////////////////
0:             LOG.info("Error occurred during close of a JMS connection.", e);
/////////////////////////////////////////////////////////////////////////
1:         // Have we already been destroyed??
/////////////////////////////////////////////////////////////////////////
1:      * When a proxy is closed this cleans up the proxy and notifies the
/////////////////////////////////////////////////////////////////////////
1:         // Let the container know that the error occurred.
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:540dd5c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1:  * ActiveMQManagedConnection maps to real physical connection to the server.
1:  * Since a ManagedConnection has to provide a transaction managment interface to
1:  * the physical connection, and sessions are the objects implement transaction
1:  * managment interfaces in the JMS API, this object also maps to a singe
1:  * physical JMS session. <p/> The side-effect is that JMS connection the
1:  * application gets will allways create the same session object. This is good if
1:  * running in an app server since the sessions are elisted in the context
1:  * transaction. This is bad if used outside of an app server since the user may
1:  * be trying to create 2 different sessions to coordinate 2 different uow.
1:  * 
1: public class ActiveMQManagedConnection implements ManagedConnection, ExceptionListener { // TODO:
1:                                                                                             // ,
1:                                                                                             // DissociatableManagedConnection
1:                                                                                             // {
0:     private static final Log LOG = LogFactory.getLog(ActiveMQManagedConnection.class);
0:     private final ArrayList<ManagedConnectionProxy> proxyConnections = new ArrayList<ManagedConnectionProxy>();
0:     private final ArrayList<ConnectionEventListener> listeners = new ArrayList<ConnectionEventListener>();
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:                     super.setInManagedTx(inManagedTx);
0:                     Iterator<ManagedConnectionProxy> iterator = proxyConnections.iterator();
0:                         ManagedConnectionProxy proxy = iterator.next();
1:                     }
1: 
1:             this.transactionContext.setLocalTransactionEventListener(new LocalTransactionEventListener() {
1: 
1: 
1: 
1:         } catch (JMSException e) {
1:             throw new ResourceException("Could not create a new connection: " + e.getMessage(), e);
1:         }
1: 
1: 
1:     public static boolean matches(Object x, Object y) {
/////////////////////////////////////////////////////////////////////////
1:         if (!matches(info.getUserName(), this.info.getUserName()) || !matches(info.getPassword(), this.info.getPassword())) {
1: 
1:         if (info.getClientid() != null && info.getClientid().length() > 0) {
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:         ConnectionEvent event = new ConnectionEvent(ActiveMQManagedConnection.this, ConnectionEvent.LOCAL_TRANSACTION_STARTED);
0:         Iterator<ConnectionEventListener> iterator = listeners.iterator();
0:             ConnectionEventListener l = iterator.next();
1:         ConnectionEvent event = new ConnectionEvent(ActiveMQManagedConnection.this, ConnectionEvent.LOCAL_TRANSACTION_COMMITTED);
0:         Iterator<ConnectionEventListener> iterator = listeners.iterator();
0:             ConnectionEventListener l = iterator.next();
1:         ConnectionEvent event = new ConnectionEvent(ActiveMQManagedConnection.this, ConnectionEvent.LOCAL_TRANSACTION_ROLLEDBACK);
0:         Iterator<ConnectionEventListener> iterator = listeners.iterator();
0:             ConnectionEventListener l = iterator.next();
1:         ConnectionEvent event = new ConnectionEvent(ActiveMQManagedConnection.this, ConnectionEvent.CONNECTION_CLOSED);
1: 
0:         Iterator<ConnectionEventListener> iterator = listeners.iterator();
0:             ConnectionEventListener l = iterator.next();
1:         ConnectionEvent event = new ConnectionEvent(ActiveMQManagedConnection.this, ConnectionEvent.CONNECTION_ERROR_OCCURRED, error);
0:         Iterator<ConnectionEventListener> iterator = listeners.iterator();
0:             ConnectionEventListener l = iterator.next();
/////////////////////////////////////////////////////////////////////////
1:     public Object getConnection(Subject subject, ConnectionRequestInfo info) throws ResourceException {
/////////////////////////////////////////////////////////////////////////
1: 
1:      * 
/////////////////////////////////////////////////////////////////////////
0:             LOG.info("Error occured during close of a JMS connection.", e);
/////////////////////////////////////////////////////////////////////////
1: 
0:         Iterator<ManagedConnectionProxy> iterator = proxyConnections.iterator();
0:             ManagedConnectionProxy proxy = iterator.next();
1: 
0:             throw new ResourceException("Could cleanup the ActiveMQ connection: " + e, e);
1: 
/////////////////////////////////////////////////////////////////////////
1:             ManagedConnectionProxy proxy = (ManagedConnectionProxy)connection;
1:         } else {
/////////////////////////////////////////////////////////////////////////
1:                 } catch (JMSException e) {
/////////////////////////////////////////////////////////////////////////
1:                 } catch (JMSException e) {
/////////////////////////////////////////////////////////////////////////
1:                 } catch (JMSException e) {
/////////////////////////////////////////////////////////////////////////
1:      * 
/////////////////////////////////////////////////////////////////////////
1:         LOG.warn("Connection failed: " + e);
1:         LOG.debug("Cause: ", e);
1: 
0:         for (Iterator<ManagedConnectionProxy> iter = proxyConnections.iterator(); iter.hasNext();) {
0:             ManagedConnectionProxy proxy = iter.next();
commit:5f1adbe
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:fd4bb60
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.ra;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.LocalTransactionEventListener;
1: import org.apache.activemq.TransactionContext;
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(ActiveMQManagedConnection.class);
author:David Jencks
-------------------------------------------------------------------------------
commit:bc72c54
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private boolean destroyed;
/////////////////////////////////////////////////////////////////////////
1:             physicalConnection.changeUserInfo(info.getUserName(), info.getPassword());
/////////////////////////////////////////////////////////////////////////
1:         return destroyed;
/////////////////////////////////////////////////////////////////////////
0:             destroyed = true;
/////////////////////////////////////////////////////////////////////////
0:             physicalConnection.cleanup();
/////////////////////////////////////////////////////////////////////////
1:      * @param subject subject to match
1:      * @param info cri to match
1:      * @return whether the subject and cri match sufficiently to allow using this connection under the new circumstances
author:Gary Tully
-------------------------------------------------------------------------------
commit:3266019
/////////////////////////////////////////////////////////////////////////
0:         // defer transaction cleanup till after close so that close is aware of the current tx
0:         localAndXATransaction.cleanup();
author:Robert Davies
-------------------------------------------------------------------------------
commit:6db9a37
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
1: import java.util.concurrent.CopyOnWriteArrayList;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final List<ManagedConnectionProxy> proxyConnections = new CopyOnWriteArrayList<ManagedConnectionProxy>();
1:     private final List<ConnectionEventListener> listeners = new CopyOnWriteArrayList<ConnectionEventListener>();
/////////////////////////////////////////////////////////////////////////
1:                     for (ManagedConnectionProxy proxy:proxyConnections) {
/////////////////////////////////////////////////////////////////////////
1:         for(ConnectionEventListener l:listeners) {
1:         for(ConnectionEventListener l:listeners) {
1:         for(ConnectionEventListener l:listeners) {
/////////////////////////////////////////////////////////////////////////
1:         for(ConnectionEventListener l:listeners) {
1:         for(ConnectionEventListener l:listeners) {
/////////////////////////////////////////////////////////////////////////
1:         for (ManagedConnectionProxy proxy:proxyConnections) {
/////////////////////////////////////////////////////////////////////////
1:         for (ManagedConnectionProxy proxy:proxyConnections) {
author:James Strachan
-------------------------------------------------------------------------------
commit:e310c21
/////////////////////////////////////////////////////////////////////////
1:         if (connection instanceof ManagedConnectionProxy) {
0:             ManagedConnectionProxy proxy = (ManagedConnectionProxy) connection;
1:             proxyConnections.add(proxy);
1:         }
0:         else {
1:             throw new ResourceException("Not supported : associating connection instance of " + connection.getClass().getName());
1:         }
commit:40a7d3b
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 Hiram Chirino
0:  * Copyright 2005 LogicBlaze Inc.
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  *
0:  **/
0: package org.activemq.ra;
1: 
1: import java.io.PrintWriter;
0: import java.util.ArrayList;
0: import java.util.Iterator;
1: 
1: import javax.jms.Connection;
1: import javax.jms.ExceptionListener;
1: import javax.jms.JMSException;
1: import javax.resource.ResourceException;
1: import javax.resource.spi.ConnectionEvent;
1: import javax.resource.spi.ConnectionEventListener;
1: import javax.resource.spi.ConnectionRequestInfo;
1: import javax.resource.spi.LocalTransaction;
1: import javax.resource.spi.ManagedConnection;
1: import javax.resource.spi.ManagedConnectionMetaData;
1: import javax.security.auth.Subject;
1: import javax.transaction.xa.XAResource;
1: 
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: import org.activemq.ActiveMQConnection;
0: import org.activemq.LocalTransactionEventListener;
0: import org.activemq.TransactionContext;
1: 
1: /**
0:  * ActiveMQManagedConnection maps to real physical connection to the
0:  * server.  Since a ManagedConnection has to provide a transaction
0:  * managment interface to the physical connection, and sessions
0:  * are the objects implement transaction managment interfaces in
0:  * the JMS API, this object also maps to a singe physical JMS session.
0:  * <p/>
0:  * The side-effect is that JMS connection the application gets
0:  * will allways create the same session object.  This is good if
0:  * running in an app server since the sessions are elisted in the
0:  * context transaction.  This is bad if used outside of an app
0:  * server since the user may be trying to create 2 different
0:  * sessions to coordinate 2 different uow.
1:  *
0:  * @version $Revision$
1:  */
0: public class ActiveMQManagedConnection implements ManagedConnection, ExceptionListener { // TODO: , DissociatableManagedConnection {
1: 
0:     private static final Log log = LogFactory.getLog(ActiveMQManagedConnection.class);
1: 
1:     private PrintWriter logWriter;
1: 
1:     private final ActiveMQConnection physicalConnection;
1:     private final TransactionContext transactionContext;
0:     private final ArrayList proxyConnections = new ArrayList();
0:     private final ArrayList listeners = new ArrayList();
1:     private final LocalAndXATransaction localAndXATransaction;
1:     
1:     private Subject subject;
1:     private ActiveMQConnectionRequestInfo info;
0:     private boolean destoryed;
1: 
1:     public ActiveMQManagedConnection(Subject subject, ActiveMQConnection physicalConnection, ActiveMQConnectionRequestInfo info) throws ResourceException {
1:         try {
1:             this.subject = subject;
1:             this.info = info;
1:             this.physicalConnection = physicalConnection;
1:             this.transactionContext = new TransactionContext(physicalConnection);
1:             
1:             this.localAndXATransaction = new LocalAndXATransaction(transactionContext) {
1:                 public void setInManagedTx(boolean inManagedTx) throws JMSException {
0:                     super.setInManagedTx(inManagedTx);                    
0:                     Iterator iterator = proxyConnections.iterator();
0:                     while (iterator.hasNext()) {
0:                         ManagedConnectionProxy proxy = (ManagedConnectionProxy) iterator.next();
1:                         proxy.setUseSharedTxContext(inManagedTx);
1:                     }                    
1:                 }
1:             };
1:             
0:             this.transactionContext.setLocalTransactionEventListener( new LocalTransactionEventListener() {
1:                 public void beginEvent() {
1:                     fireBeginEvent();
1:                 }
1:                 public void commitEvent() {
1:                     fireCommitEvent();
1:                 }
1:                 public void rollbackEvent() {
1:                     fireRollbackEvent();
1:                 }
1:             });
1:                         
1:             physicalConnection.setExceptionListener(this);
1: 		} catch (JMSException e) {
0:             throw new ResourceException("Could not create a new connection: "+e.getMessage(), e);
1:         }    			
1:     }
1:     
1:     public boolean isInManagedTx() {
1:         return localAndXATransaction.isInManagedTx();
1:     }
1:     
0:     static public boolean matches(Object x, Object y) {
1:         if (x == null ^ y == null) {
1:             return false;
1:         }
1:         if (x != null && !x.equals(y)) {
1:             return false;
1:         }
1:         return true;
1:     }
1: 
1:     public void associate(Subject subject, ActiveMQConnectionRequestInfo info) throws JMSException {
1: 
1:         // Do we need to change the associated userid/password
0:         if( !matches(info.getUserName(), this.info.getUserName()) || !matches(info.getPassword(), this.info.getPassword()) ) {
0:             ((ActiveMQConnection)physicalConnection).changeUserInfo(info.getUserName(), info.getPassword());
1:         }
1:         
1:         // Do we need to set the clientId?
0:         if( info.getClientid()!=null && info.getClientid().length()>0 ) 
1:             physicalConnection.setClientID(info.getClientid());
1: 
1:         this.subject = subject;
1:         this.info = info;
1:     }
1: 
1:     public Connection getPhysicalConnection() {
1:         return physicalConnection;
1:     }
1:     
1:     private void fireBeginEvent() {
0:         ConnectionEvent event = new ConnectionEvent(ActiveMQManagedConnection.this,
0:                 ConnectionEvent.LOCAL_TRANSACTION_STARTED);
0:         Iterator iterator = listeners.iterator();
0:         while (iterator.hasNext()) {
0:             ConnectionEventListener l = (ConnectionEventListener) iterator.next();
1:             l.localTransactionStarted(event);
1:         }
1:     }
1: 
1:     private void fireCommitEvent() {
0:         ConnectionEvent event = new ConnectionEvent(ActiveMQManagedConnection.this,
0:                 ConnectionEvent.LOCAL_TRANSACTION_COMMITTED);
0:         Iterator iterator = listeners.iterator();
0:         while (iterator.hasNext()) {
0:             ConnectionEventListener l = (ConnectionEventListener) iterator.next();
1:             l.localTransactionCommitted(event);
1:         }
1:     }
1: 
1:     private void fireRollbackEvent() {
0:         ConnectionEvent event = new ConnectionEvent(ActiveMQManagedConnection.this,
0:                 ConnectionEvent.LOCAL_TRANSACTION_ROLLEDBACK);
0:         Iterator iterator = listeners.iterator();
0:         while (iterator.hasNext()) {
0:             ConnectionEventListener l = (ConnectionEventListener) iterator.next();
1:             l.localTransactionRolledback(event);
1:         }
1:     }
1: 
1:     private void fireCloseEvent(ManagedConnectionProxy proxy) {
0:         ConnectionEvent event = new ConnectionEvent(ActiveMQManagedConnection.this,
0:                 ConnectionEvent.CONNECTION_CLOSED);
1:         event.setConnectionHandle(proxy);
1:         
0:         Iterator iterator = listeners.iterator();
0:         while (iterator.hasNext()) {
0:             ConnectionEventListener l = (ConnectionEventListener) iterator.next();
1:             l.connectionClosed(event);
1:         }
1:     }
1: 
1:     private void fireErrorOccurredEvent(Exception error) {
0:         ConnectionEvent event = new ConnectionEvent(ActiveMQManagedConnection.this,
0:                 ConnectionEvent.CONNECTION_ERROR_OCCURRED, error);
0:         Iterator iterator = listeners.iterator();
0:         while (iterator.hasNext()) {
0:             ConnectionEventListener l = (ConnectionEventListener) iterator.next();
1:             l.connectionErrorOccurred(event);
1:         }
1:     }
1: 
1:     /**
1:      * @see javax.resource.spi.ManagedConnection#getConnection(javax.security.auth.Subject,
1:      *      javax.resource.spi.ConnectionRequestInfo)
1:      */
0:     public Object getConnection(Subject subject, ConnectionRequestInfo info)
0:             throws ResourceException {
0:         ManagedConnectionProxy proxy = new ManagedConnectionProxy(this);
1:         proxyConnections.add(proxy);
1:         return proxy;
1:     }
1: 
1:     private boolean isDestroyed() {
0:         return destoryed;
1:     }
1:     
1:     /**
1:      * Close down the physical connection to the server.
1:      *
1:      * @see javax.resource.spi.ManagedConnection#destroy()
1:      */
1:     public void destroy() throws ResourceException {
0:         // Have we allready been destroyed??
1:         if (isDestroyed()) {
1:             return;
1:         }
1: 
0:         cleanup();
1: 
1:         try {
0:             physicalConnection.close();
0:             destoryed = true;
1:         } catch (JMSException e) {
0:             log.info("Error occured during close of a JMS connection.", e);
1:         }
1:     }
1: 
1:     /**
1:      * Cleans up all proxy handles attached to this physical connection so that
1:      * they cannot be used anymore.
1:      * 
1:      * @see javax.resource.spi.ManagedConnection#cleanup()
1:      */
1:     public void cleanup() throws ResourceException {
1:     	
0:         // Have we allready been destroyed??
1:         if (isDestroyed()) {
1:             return;
1:         }
1: 
0:         Iterator iterator = proxyConnections.iterator();
0:         while (iterator.hasNext()) {
0:             ManagedConnectionProxy proxy = (ManagedConnectionProxy) iterator.next();
1:             proxy.cleanup();
1:         }
1:         proxyConnections.clear();
0:         localAndXATransaction.cleanup();
1:         
1:         try {
0:             ((ActiveMQConnection)physicalConnection).cleanup();
1:         } catch (JMSException e) {
0:             throw new ResourceException("Could cleanup the ActiveMQ connection: "+e, e);
1:         }
1:             
1:     }
1: 
1:     /**
1:      * @see javax.resource.spi.ManagedConnection#associateConnection(java.lang.Object)
1:      */
1:     public void associateConnection(Object connection) throws ResourceException {
0:         throw new ResourceException("Not supported.");
1:     }
1: 
1:     /**
1:      * @see javax.resource.spi.ManagedConnection#addConnectionEventListener(javax.resource.spi.ConnectionEventListener)
1:      */
1:     public void addConnectionEventListener(ConnectionEventListener listener) {
1:         listeners.add(listener);
1:     }
1: 
1:     /**
1:      * @see javax.resource.spi.ManagedConnection#removeConnectionEventListener(javax.resource.spi.ConnectionEventListener)
1:      */
1:     public void removeConnectionEventListener(ConnectionEventListener listener) {
1:         listeners.remove(listener);
1:     }
1: 
1:     /**
1:      * @see javax.resource.spi.ManagedConnection#getXAResource()
1:      */
1:     public XAResource getXAResource() throws ResourceException {
1:         return localAndXATransaction;
1:     }
1: 
1:     /**
1:      * @see javax.resource.spi.ManagedConnection#getLocalTransaction()
1:      */
1:     public LocalTransaction getLocalTransaction() throws ResourceException {
1:         return localAndXATransaction;
1:     }
1: 
1:     /**
1:      * @see javax.resource.spi.ManagedConnection#getMetaData()
1:      */
1:     public ManagedConnectionMetaData getMetaData() throws ResourceException {
1:         return new ManagedConnectionMetaData() {
1: 
1:             public String getEISProductName() throws ResourceException {
1:                 if (physicalConnection == null) {
1:                     throw new ResourceException("Not connected.");
1:                 }
1:                 try {
1:                     return physicalConnection.getMetaData().getJMSProviderName();
1:                 }
0:                 catch (JMSException e) {
1:                     throw new ResourceException("Error accessing provider.", e);
1:                 }
1:             }
1: 
1:             public String getEISProductVersion() throws ResourceException {
1:                 if (physicalConnection == null) {
1:                     throw new ResourceException("Not connected.");
1:                 }
1:                 try {
1:                     return physicalConnection.getMetaData().getProviderVersion();
1:                 }
0:                 catch (JMSException e) {
1:                     throw new ResourceException("Error accessing provider.", e);
1:                 }
1:             }
1: 
1:             public int getMaxConnections() throws ResourceException {
1:                 if (physicalConnection == null) {
1:                     throw new ResourceException("Not connected.");
1:                 }
1:                 return Integer.MAX_VALUE;
1:             }
1: 
1:             public String getUserName() throws ResourceException {
1:                 if (physicalConnection == null) {
1:                     throw new ResourceException("Not connected.");
1:                 }
1:                 try {
1:                     return physicalConnection.getClientID();
1:                 }
0:                 catch (JMSException e) {
1:                     throw new ResourceException("Error accessing provider.", e);
1:                 }
1:             }
1:         };
1:     }
1: 
1:     /**
1:      * @see javax.resource.spi.ManagedConnection#setLogWriter(java.io.PrintWriter)
1:      */
1:     public void setLogWriter(PrintWriter logWriter) throws ResourceException {
1:         this.logWriter = logWriter;
1:     }
1: 
1:     /**
1:      * @see javax.resource.spi.ManagedConnection#getLogWriter()
1:      */
1:     public PrintWriter getLogWriter() throws ResourceException {
1:         return logWriter;
1:     }
1: 
1:     /**
0:      * @param subject
0:      * @param info
0:      * @return
1:      */
1:     public boolean matches(Subject subject, ConnectionRequestInfo info) {
1: 
1:         // Check to see if it is our info class
1:         if (info == null) {
1:             return false;
1:         }
1:         if (info.getClass() != ActiveMQConnectionRequestInfo.class) {
1:             return false;
1:         }
1: 
1:         // Do the subjects match?
1:         if (subject == null ^ this.subject == null) {
1:             return false;
1:         }
1:         if (subject != null && !subject.equals(this.subject)) {
1:             return false;
1:         }
1: 
1:         // Does the info match?
1:         return info.equals(this.info);
1:     }
1: 
1:     /**
0:      * When a proxy is closed this cleans up the proxy and notifys the
1:      * ConnectionEventListeners that a connection closed.
1:      *
1:      * @param proxy
1:      */
1:     public void proxyClosedEvent(ManagedConnectionProxy proxy) {
1:         proxyConnections.remove(proxy);
1:         proxy.cleanup();
1:         fireCloseEvent(proxy);
1:     }
1: 
1:     public void onException(JMSException e) {
0:         log.warn("Connection failed: "+e);
0:         log.debug("Cause: ", e);
1:         
0:         // Let any active proxy connections know that exception occured.
0:         for (Iterator iter = proxyConnections.iterator(); iter.hasNext();) {
0:             ManagedConnectionProxy proxy = (ManagedConnectionProxy) iter.next();
1:             proxy.onException(e);
1:         }
0:         // Let the container know that the error occured.
1:         fireErrorOccurredEvent(e);
1:     }
1: 
1:     /**
1:      * @return Returns the transactionContext.
1:      */
1:     public TransactionContext getTransactionContext() {
1:         return transactionContext;
1:     }
1: 
1: }
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:92a698f
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2004 The Apache Software Foundation
/////////////////////////////////////////////////////////////////////////
1:  */
============================================================================