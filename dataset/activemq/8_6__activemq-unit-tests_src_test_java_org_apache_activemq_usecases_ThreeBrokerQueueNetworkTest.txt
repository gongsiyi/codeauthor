2:a677c21: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
3:a677c21:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:a677c21:  *
1:a677c21:  * Unless required by applicable law or agreed to in writing, software
1:a677c21:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a677c21:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a677c21:  * See the License for the specific language governing permissions and
1:a677c21:  * limitations under the License.
2:a677c21:  */
1:a677c21: package org.apache.activemq.usecases;
26:a677c21: 
1:74a7a8b: import java.net.URI;
1:5511217: import java.util.Collection;
1:b2148c5: import java.util.HashMap;
1:5511217: import java.util.Iterator;
1:3da1373: import java.util.concurrent.CountDownLatch;
1:3da1373: import java.util.concurrent.TimeUnit;
1:9670af1: import java.util.concurrent.atomic.AtomicInteger;
1:a677c21: import javax.jms.Destination;
1:a677c21: import javax.jms.MessageConsumer;
1:74a7a8b: import org.apache.activemq.JmsMultipleBrokersTestSupport;
1:9670af1: import org.apache.activemq.broker.Broker;
1:9670af1: import org.apache.activemq.broker.BrokerFilter;
1:9670af1: import org.apache.activemq.broker.BrokerPlugin;
1:5511217: import org.apache.activemq.broker.BrokerService;
1:5511217: import org.apache.activemq.broker.region.Queue;
1:5511217: import org.apache.activemq.broker.region.RegionBroker;
1:9670af1: import org.apache.activemq.broker.region.Subscription;
1:5511217: import org.apache.activemq.command.ActiveMQDestination;
1:9670af1: import org.apache.activemq.command.ConsumerInfo;
1:9670af1: import org.apache.activemq.command.MessageDispatch;
1:74a7a8b: import org.apache.activemq.util.MessageIdList;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:74a7a8b: 
1:a677c21: /**
1:b0c2a40:  * 
1:a677c21:  */
1:a677c21: public class ThreeBrokerQueueNetworkTest extends JmsMultipleBrokersTestSupport {
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(ThreeBrokerQueueNetworkTest.class);
1:a677c21:     protected static final int MESSAGE_COUNT = 100;
1:22422ac:     private static final long MAX_WAIT_MILLIS = 10000;
1:a677c21: 
1:7449545:     interface Condition {
1:7449545:         boolean isSatisified() throws Exception;
1:7449545:     }
1:11e407e:     
1:a677c21:     /**
1:a677c21:      * BrokerA -> BrokerB -> BrokerC
1:a677c21:      */
1:fc00993:     public void testABandBCbrokerNetwork() throws Exception {
1:a677c21:         // Setup broker networks
1:a677c21:         bridgeBrokers("BrokerA", "BrokerB");
3:a677c21:         bridgeBrokers("BrokerB", "BrokerC");
1:b2148c5: 
1:a677c21:         startAllBrokers();
1:7449545:         waitForBridgeFormation();
1:7449545:         
1:a677c21:         // Setup destination
1:a677c21:         Destination dest = createDestination("TEST.FOO", false);
1:4213e42: 
1:a677c21:         // Setup consumers
1:a677c21:         MessageConsumer clientC = createConsumer("BrokerC", dest);
1:4213e42: 
1:a677c21:         // Send messages
1:a677c21:         sendMessages("BrokerA", dest, MESSAGE_COUNT);
1:22422ac: 
1:a677c21:         // Let's try to wait for any messages. Should be none.
3:a677c21:         Thread.sleep(1000);
1:5511217: 
1:a677c21:         // Get message count
1:a677c21:         MessageIdList msgsC = getConsumerMessages("BrokerC", clientC);
1:a677c21:         assertEquals(0, msgsC.getMessageCount());
1:22422ac:     }
1:5511217: 
1:a677c21:     /**
1:a677c21:      * BrokerA <- BrokerB -> BrokerC
1:a677c21:      */
1:fc00993:     public void testBAandBCbrokerNetwork() throws Exception {
1:a677c21:         // Setup broker networks
1:b2148c5:         bridgeBrokers("BrokerB", "BrokerA");
1:b2148c5:         bridgeBrokers("BrokerB", "BrokerC");
1:5511217: 
1:a677c21:         startAllBrokers();
1:7449545:         waitForBridgeFormation();
1:5511217:         
1:a677c21:         // Setup destination
1:a677c21:         Destination dest = createDestination("TEST.FOO", false);
1:5511217: 
1:a677c21:         // Setup consumers
1:a677c21:         MessageConsumer clientA = createConsumer("BrokerA", dest);
1:a677c21:         MessageConsumer clientC = createConsumer("BrokerC", dest);
1:a677c21:         Thread.sleep(2000); //et subscriptions get propagated
1:a677c21:         // Send messages
1:a677c21:         sendMessages("BrokerB", dest, MESSAGE_COUNT);
1:b2148c5: 
1:a677c21:         // Let's try to wait for any messages.
1:a677c21:         Thread.sleep(1000);
1:a677c21: 
1:a677c21:         // Get message count
2:a677c21:         MessageIdList msgsA = getConsumerMessages("BrokerA", clientA);
1:a677c21:         MessageIdList msgsC = getConsumerMessages("BrokerC", clientC);
1:3da1373: 
1:a677c21:         // Total received should be 100
1:a677c21:         assertEquals(MESSAGE_COUNT, msgsA.getMessageCount() + msgsC.getMessageCount());
1:5511217:     }
1:b2148c5:     
1:b2148c5:     /**
1:b2148c5:      * BrokerA <- BrokerB -> BrokerC
1:b2148c5:      */
1:b2148c5:     public void testBAandBCbrokerNetworkWithSelectorsSendFirst() throws Exception {
1:b2148c5:     	// Setup broker networks
1:8b0bb33:         bridgeBrokers("BrokerB", "BrokerA", true, 1, false);
1:8b0bb33:         bridgeBrokers("BrokerB", "BrokerC", true, 1, false);
1:b2148c5: 
1:b2148c5:         startAllBrokers();
1:7449545:         waitForBridgeFormation();
1:b2148c5:         
1:b2148c5:         // Setup destination
1:b2148c5:         Destination dest = createDestination("TEST.FOO", false);
1:b2148c5: 
1:b2148c5:         
1:b2148c5:         // Send messages for broker A
1:b2148c5:         HashMap<String, Object> props = new HashMap<String, Object>();
1:b2148c5:         props.put("broker", "BROKER_A");
1:b2148c5:         sendMessages("BrokerB", dest, MESSAGE_COUNT, props);
1:b2148c5: 
1:b2148c5:         //Send messages for broker C
1:b2148c5:         props.clear();
1:b2148c5:         props.put("broker", "BROKER_C");
1:b2148c5:         sendMessages("BrokerB", dest, MESSAGE_COUNT, props);
1:b2148c5:         
1:b2148c5:         // Setup consumers
1:b2148c5:         MessageConsumer clientA = createConsumer("BrokerA", dest, "broker = 'BROKER_A'");
1:b2148c5:         MessageConsumer clientC = createConsumer("BrokerC", dest, "broker = 'BROKER_C'");
1:b2148c5:         Thread.sleep(2000); //et subscriptions get propagated
1:b2148c5:         
1:b2148c5:         // Let's try to wait for any messages.
1:b2148c5:         //Thread.sleep(1000);
1:b2148c5: 
1:b2148c5:         // Get message count
1:b2148c5:         MessageIdList msgsA = getConsumerMessages("BrokerA", clientA);
1:b2148c5:         MessageIdList msgsC = getConsumerMessages("BrokerC", clientC);
1:b2148c5:         
1:b2148c5:         // Total received should be 100
1:b2148c5:         assertEquals(MESSAGE_COUNT, msgsA.getMessageCount());
1:b2148c5:         assertEquals(MESSAGE_COUNT, msgsC.getMessageCount());
1:b2148c5:     }
1:b2148c5:     
1:b2148c5:     /**
1:b2148c5:      * BrokerA <- BrokerB -> BrokerC
1:b2148c5:      */
1:b2148c5:     public void testBAandBCbrokerNetworkWithSelectorsSubscribeFirst() throws Exception {
1:b2148c5:     	// Setup broker networks
1:8b0bb33:         bridgeBrokers("BrokerB", "BrokerA", true, 1, false);
1:8b0bb33:         bridgeBrokers("BrokerB", "BrokerC", true, 1, false);
1:b2148c5: 
1:b2148c5:         startAllBrokers();
1:7449545:         waitForBridgeFormation();
1:b2148c5:         
1:b2148c5:         // Setup destination
1:b2148c5:         Destination dest = createDestination("TEST.FOO", false);
1:b2148c5: 
1:b2148c5:         // Setup consumers
1:b2148c5:         MessageConsumer clientA = createConsumer("BrokerA", dest, "broker = 'BROKER_A'");
1:b2148c5:         MessageConsumer clientC = createConsumer("BrokerC", dest, "broker = 'BROKER_C'");
1:b2148c5:         Thread.sleep(2000); //et subscriptions get propagated
1:b2148c5:         
1:b2148c5:         
1:b2148c5:         // Send messages for broker A
1:b2148c5:         HashMap<String, Object> props = new HashMap<String, Object>();
1:b2148c5:         props.put("broker", "BROKER_A");
1:b2148c5:         sendMessages("BrokerB", dest, MESSAGE_COUNT, props);
1:b2148c5: 
1:b2148c5:         //Send messages for broker C
1:b2148c5:         props.clear();
1:b2148c5:         props.put("broker", "BROKER_C");
1:b2148c5:         sendMessages("BrokerB", dest, MESSAGE_COUNT, props);
1:b2148c5:         
1:b2148c5:         // Let's try to wait for any messages.
1:b2148c5:         Thread.sleep(1000);
1:4213e42: 
1:b2148c5:         // Get message count
1:b2148c5:         MessageIdList msgsA = getConsumerMessages("BrokerA", clientA);
1:b2148c5:         MessageIdList msgsC = getConsumerMessages("BrokerC", clientC);
1:4213e42:         
1:b2148c5:         // Total received should be 100
1:b2148c5:         assertEquals(MESSAGE_COUNT, msgsA.getMessageCount());
1:b2148c5:         assertEquals(MESSAGE_COUNT, msgsC.getMessageCount());
1:b2148c5:     }    
1:a677c21: 
1:a677c21:     /**
1:a677c21:      * BrokerA -> BrokerB <- BrokerC
1:a677c21:      */
1:fc00993:     public void testABandCBbrokerNetwork() throws Exception {
1:a677c21:         // Setup broker networks
1:a677c21:         bridgeBrokers("BrokerA", "BrokerB");
1:a677c21:         bridgeBrokers("BrokerC", "BrokerB");
1:4213e42: 
1:a677c21:         startAllBrokers();
1:7449545:         waitForBridgeFormation();
1:a677c21:         
1:a677c21:         // Setup destination
1:a677c21:         Destination dest = createDestination("TEST.FOO", false);
1:a677c21: 
1:a677c21:         // Setup consumers
1:a677c21:         MessageConsumer clientB = createConsumer("BrokerB", dest);
1:a677c21: 
1:a677c21:         // Send messages
1:a677c21:         sendMessages("BrokerA", dest, MESSAGE_COUNT);
1:a677c21:         sendMessages("BrokerC", dest, MESSAGE_COUNT);
1:a677c21: 
1:a677c21:         // Get message count
1:a677c21:         MessageIdList msgsB = getConsumerMessages("BrokerB", clientB);
1:a677c21: 
1:a677c21:         msgsB.waitForMessagesToArrive(MESSAGE_COUNT * 2);
1:a677c21: 
1:a677c21:         assertEquals(MESSAGE_COUNT * 2, msgsB.getMessageCount());
5:a677c21:     }
1:a677c21: 
1:a677c21:     /**
2:a677c21:      * BrokerA <-> BrokerB <-> BrokerC
1:a677c21:      */
1:a677c21:     public void testAllConnectedBrokerNetwork() throws Exception {
1:a677c21:         // Setup broker networks
1:a677c21:         bridgeBrokers("BrokerA", "BrokerB");
1:b2148c5:         bridgeBrokers("BrokerB", "BrokerA");
1:b2148c5:         bridgeBrokers("BrokerB", "BrokerC");
1:a677c21:         bridgeBrokers("BrokerC", "BrokerB");
1:a677c21:         bridgeBrokers("BrokerA", "BrokerC");
1:a677c21:         bridgeBrokers("BrokerC", "BrokerA");
1:4213e42: 
1:a677c21:         startAllBrokers();
1:7449545:         waitForBridgeFormation();
1:a677c21:         
1:a677c21:         // Setup destination
1:a677c21:         Destination dest = createDestination("TEST.FOO", false);
1:a677c21: 
1:a677c21:         // Setup consumers
1:a677c21:         MessageConsumer clientA = createConsumer("BrokerA", dest);
1:a677c21:         MessageConsumer clientB = createConsumer("BrokerB", dest);
1:a677c21:         MessageConsumer clientC = createConsumer("BrokerC", dest);
1:a677c21: 
1:a677c21:         // Send messages
1:a677c21:         sendMessages("BrokerA", dest, MESSAGE_COUNT);
1:a677c21:         sendMessages("BrokerB", dest, MESSAGE_COUNT);
1:a677c21:         sendMessages("BrokerC", dest, MESSAGE_COUNT);
1:a677c21: 
1:a677c21:         // Let's try to wait for any messages.
1:3da1373:         Thread.sleep(1000);
1:a677c21: 
1:a677c21:         // Get message count
1:a677c21:         MessageIdList msgsA = getConsumerMessages("BrokerA", clientA);
1:a677c21:         MessageIdList msgsB = getConsumerMessages("BrokerB", clientB);
1:a677c21:         MessageIdList msgsC = getConsumerMessages("BrokerC", clientC);
1:a677c21: 
1:a677c21:         assertEquals(MESSAGE_COUNT * 3, msgsA.getMessageCount() + msgsB.getMessageCount() + msgsC.getMessageCount());
1:3da1373:     }
1:3da1373: 
1:a677c21:     public void testAllConnectedUsingMulticast() throws Exception {
1:a677c21:         // Setup broker networks
1:a677c21:         bridgeAllBrokers();
1:4213e42: 
1:a677c21:         startAllBrokers();
1:7449545:         waitForBridgeFormation();
1:3da1373:         
1:a677c21:         // Setup destination
1:a677c21:         Destination dest = createDestination("TEST.FOO", false);
1:3da1373: 
1:a677c21:         // Setup consumers
1:a677c21:         MessageConsumer clientA = createConsumer("BrokerA", dest);
1:a677c21:         MessageConsumer clientB = createConsumer("BrokerB", dest);
1:a677c21:         MessageConsumer clientC = createConsumer("BrokerC", dest);
1:3da1373: 
1:a677c21:         // Send messages
1:a677c21:         sendMessages("BrokerA", dest, MESSAGE_COUNT);
1:a677c21:         sendMessages("BrokerB", dest, MESSAGE_COUNT);
1:a677c21:         sendMessages("BrokerC", dest, MESSAGE_COUNT);
1:3da1373: 
1:a677c21:         // Let's try to wait for any messages.
1:3da1373:         Thread.sleep(1000);
1:3da1373: 
1:a677c21:         // Get message count
1:22422ac:         final MessageIdList msgsA = getConsumerMessages("BrokerA", clientA);
1:a677c21:         MessageIdList msgsB = getConsumerMessages("BrokerB", clientB);
1:a677c21:         MessageIdList msgsC = getConsumerMessages("BrokerC", clientC);
1:22422ac: 
1:7449545:         waitFor(new Condition() {
1:22422ac:             public boolean isSatisified() {
1:22422ac:                 return msgsA.getMessageCount() == MESSAGE_COUNT;
1:22422ac:             } 
1:7449545:         });
1:7449545:         
1:a677c21:         assertEquals(MESSAGE_COUNT * 3, msgsA.getMessageCount() + msgsB.getMessageCount() + msgsC.getMessageCount());
1:3da1373:     }
1:4213e42: 
1:7449545:     // on slow machines some more waiting is required on account of slow advisories
1:7449545:     private void waitFor(Condition condition) throws Exception {
1:7449545:         final long expiry = System.currentTimeMillis() + MAX_WAIT_MILLIS;
1:7449545:         while (!condition.isSatisified() && System.currentTimeMillis() < expiry) {
1:7449545:             Thread.sleep(1000);
1:7449545:         }   
1:7449545:         if (System.currentTimeMillis() >= expiry) {
1:7449545:             LOG.error("expired while waiting for condition " + condition);
1:7449545:         }
1:7449545:         
1:7449545:     }
1:7449545: 
1:3da1373:     public void testAllConnectedUsingMulticastProducerConsumerOnA() throws Exception {
1:3da1373:         bridgeAllBrokers("default", 3, false);
1:3da1373:         startAllBrokers();
1:7449545:         waitForBridgeFormation();
1:4213e42:         
1:3da1373:         // Setup destination
1:3da1373:         Destination dest = createDestination("TEST.FOO", false);
1:4213e42: 
1:3da1373:         // Setup consumers
1:3da1373:         int messageCount = 2000;
1:3da1373:         CountDownLatch messagesReceived = new CountDownLatch(messageCount);
1:3da1373:         MessageConsumer clientA = createConsumer("BrokerA", dest, messagesReceived);
1:22422ac: 
1:3da1373:         // Let's try to wait for advisory percolation.
1:22422ac:         Thread.sleep(1000);
1:22422ac: 
1:3da1373:         // Send messages
1:3da1373:         sendMessages("BrokerA", dest, messageCount);
1:3da1373:      
3:3da1373:         assertTrue(messagesReceived.await(30, TimeUnit.SECONDS));
1:3da1373:         
1:3da1373:         // Get message count
1:3da1373:         MessageIdList msgsA = getConsumerMessages("BrokerA", clientA);
1:3da1373:         assertEquals(messageCount, msgsA.getMessageCount());
1:22422ac:     }
1:3da1373: 
1:3da1373:     public void testAllConnectedWithSpare() throws Exception {
1:3da1373:         bridgeAllBrokers("default", 3, false);
1:3da1373:         startAllBrokers();
1:7449545:         waitForBridgeFormation();
1:4213e42:         
1:3da1373:         // Setup destination
1:3da1373:         Destination dest = createDestination("TEST.FOO", false);
1:3da1373: 
1:3da1373:         // Setup consumers
1:3da1373:         int messageCount = 2000;
1:3da1373:         CountDownLatch messagesReceived = new CountDownLatch(messageCount);
1:3da1373:         MessageConsumer clientA = createConsumer("BrokerA", dest, messagesReceived);
1:3da1373: 
1:3da1373:         // ensure advisory percolation.
1:0470304:         Thread.sleep(2000);
1:3da1373: 
1:3da1373:         // Send messages
1:3da1373:         sendMessages("BrokerB", dest, messageCount);
1:3da1373: 
1:9670af1:         assertTrue("messaged received within time limit", messagesReceived.await(30, TimeUnit.SECONDS));
1:3da1373:         
1:3da1373:         // Get message count
1:3da1373:         MessageIdList msgsA = getConsumerMessages("BrokerA", clientA);
1:3da1373:         assertEquals(messageCount, msgsA.getMessageCount());
1:22422ac:     }
1:3da1373:     
1:8af25fd:     /*
1:8af25fd:      * This test is disabled - as it fails with a fix for 
1:8af25fd:      * http://issues.apache.org/activemq/browse/AMQ-2530 - which highlights that 
1:8af25fd:      * For a Conduit bridge - local subscription Ids weren't removed in a ConduitBridge
1:8af25fd:      * The test fails because on closing clientA - clientB correctly receives all the 
1:7449545:      * messages - ie. half dont get stuck on BrokerA - 
1:8af25fd:      */
1:8af25fd:     public void XtestMigrateConsumerStuckMessages() throws Exception {
1:7449545:         boolean suppressQueueDuplicateSubscriptions = false;
1:7449545:         bridgeAllBrokers("default", 3, suppressQueueDuplicateSubscriptions);
1:3da1373:         startAllBrokers();
1:7449545:         waitForBridgeFormation();
1:3da1373: 
1:3da1373:         // Setup destination
1:3da1373:         Destination dest = createDestination("TEST.FOO", false);    
1:3da1373:         
1:3da1373:         // Setup consumers
1:3da1373:         LOG.info("Consumer on A");
1:3da1373:         MessageConsumer clientA = createConsumer("BrokerA", dest);
1:3da1373:         
1:3da1373:         // ensure advisors have percolated
1:0470304:         Thread.sleep(2000);
1:3da1373:         
1:3da1373:         LOG.info("Consumer on B");
1:3da1373:         int messageCount = 2000;
1:3da1373:         
1:3da1373:         // will only get half of the messages
1:3da1373:         CountDownLatch messagesReceived = new CountDownLatch(messageCount/2);
1:3da1373:         MessageConsumer clientB = createConsumer("BrokerB", dest, messagesReceived);
1:3da1373:           
1:3da1373:         // ensure advisors have percolated
1:0470304:         Thread.sleep(2000);
1:3da1373: 
1:3da1373:         LOG.info("Close consumer on A");
1:3da1373:         clientA.close();
1:3da1373: 
1:3da1373:         // ensure advisors have percolated
1:0470304:         Thread.sleep(2000);
1:3da1373:        
1:3da1373:         LOG.info("Send to B"); 
1:3da1373:         sendMessages("BrokerB", dest, messageCount);
1:3da1373: 
1:3da1373:         // Let's try to wait for any messages.
1:3da1373:         assertTrue(messagesReceived.await(30, TimeUnit.SECONDS));
1:3da1373: 
1:3da1373:         // Get message count
1:3da1373:         MessageIdList msgs = getConsumerMessages("BrokerB", clientB);
1:3da1373:         
1:3da1373:         // see will any more arrive
7:3da1373:         Thread.sleep(500);        
1:3da1373:         assertEquals(messageCount/2, msgs.getMessageCount());
1:3da1373:         
1:3da1373:         // pick up the stuck messages
1:3da1373:         messagesReceived = new CountDownLatch(messageCount/2);
1:3da1373:         clientA = createConsumer("BrokerA", dest, messagesReceived);
1:3da1373:         // Let's try to wait for any messages.
1:3da1373:         assertTrue(messagesReceived.await(30, TimeUnit.SECONDS));
1:3da1373:         
1:3da1373:         msgs = getConsumerMessages("BrokerA", clientA);
1:3da1373:         assertEquals(messageCount/2, msgs.getMessageCount());
1:22422ac:     }
1:3da1373: 
1:3da1373:     // use case: for maintenance, migrate consumers and producers from one
1:3da1373:     // node in the network to another so node can be replaced/updated
1:3da1373:     public void testMigrateConsumer() throws Exception {
1:3da1373:         boolean suppressQueueDuplicateSubscriptions = true;
1:3da1373:         boolean decreaseNetworkConsumerPriority = true;
1:3da1373:         bridgeAllBrokers("default", 3, suppressQueueDuplicateSubscriptions, decreaseNetworkConsumerPriority);
1:3da1373:         startAllBrokers();
1:7449545:         waitForBridgeFormation();
1:4213e42:         
1:3da1373:         // Setup destination
1:3da1373:         Destination dest = createDestination("TEST.FOO", false);    
1:3da1373:         
1:3da1373:         // Setup consumers
1:3da1373:         LOG.info("Consumer on A");
1:3da1373:         MessageConsumer clientA = createConsumer("BrokerA", dest);
1:3da1373:         
1:3da1373:         // ensure advisors have percolated
1:0470304:         Thread.sleep(2000);
1:3da1373:         
1:3da1373:         LOG.info("Consumer on B");
1:3da1373:         int messageCount = 2000;
1:3da1373:         CountDownLatch messagesReceived = new CountDownLatch(messageCount);
1:3da1373:         MessageConsumer clientB = createConsumer("BrokerB", dest, messagesReceived);
1:3da1373:        
1:3da1373:         // make the consumer slow so that any network consumer has a chance, even
1:3da1373:         // if it has a lower priority
1:3da1373:         MessageIdList msgs = getConsumerMessages("BrokerB", clientB);
1:3da1373:         msgs.setProcessingDelay(10);
1:3da1373:         
1:3da1373:         // ensure advisors have percolated
1:0470304:         Thread.sleep(2000);
1:3da1373: 
1:3da1373:         LOG.info("Close consumer on A");
1:3da1373:         clientA.close();
1:3da1373: 
1:3da1373:         // ensure advisors have percolated
1:0470304:         Thread.sleep(2000);
1:3da1373:        
1:3da1373:         LOG.info("Send to B"); 
1:3da1373:         sendMessages("BrokerB", dest, messageCount);
1:3da1373: 
1:3da1373:         // Let's try to wait for any messages.
1:9670af1:         assertTrue("messages are received within limit", messagesReceived.await(60, TimeUnit.SECONDS));
1:3da1373:         assertEquals(messageCount, msgs.getMessageCount());      
1:3da1373:     }
1:3da1373: 
1:5511217:     public void testNoDuplicateQueueSubs() throws Exception {
1:5511217:         
1:5511217:         bridgeAllBrokers("default", 3, true);
1:7449545:         
1:5511217:         startAllBrokers();
1:7449545:         waitForBridgeFormation();
1:4213e42:         
1:5511217:         // Setup destination
1:5511217:         Destination dest = createDestination("TEST.FOO", false);
1:5511217: 
1:5511217:         // Setup consumers
1:5511217:         String brokerName = "BrokerA";
1:11e407e:         MessageConsumer consumer = createConsumer(brokerName, dest);
1:5511217:         
1:5511217:         // wait for advisories
1:5511217:         Thread.sleep(2000);
1:6c5732b:         
1:5511217:         // verify there is one consumer on each broker, no cycles
1:5511217:         Collection<BrokerItem> brokerList = brokers.values();
1:6c5732b:         for (Iterator<BrokerItem> i = brokerList.iterator(); i.hasNext();) {
1:6c5732b:             BrokerService broker = i.next().broker;
1:5511217:             verifyConsumerCount(broker, 1, dest);
1:3da1373:         }
1:11e407e:         
1:11e407e:         consumer.close();
1:11e407e:         
1:11e407e:         // wait for advisories
1:11e407e:         Thread.sleep(2000);
1:11e407e:         
1:11e407e:         // verify there is no more consumers
1:11e407e:         for (Iterator<BrokerItem> i = brokerList.iterator(); i.hasNext();) {
1:11e407e:             BrokerService broker = i.next().broker;
1:11e407e:             verifyConsumerCount(broker, 0, dest);
1:11e407e:         }
1:5511217:     }
1:9670af1:     
1:5511217: 
1:9670af1:     public void testNoDuplicateQueueSubsHasLowestPriority() throws Exception {
1:9670af1:         boolean suppressQueueDuplicateSubscriptions = true;
1:9670af1:         boolean decreaseNetworkConsumerPriority = true;
1:9670af1:         bridgeAllBrokers("default", 3, suppressQueueDuplicateSubscriptions, decreaseNetworkConsumerPriority);
1:9670af1: 
1:9670af1:         // Setup destination
1:9670af1:         final Destination dest = createDestination("TEST.FOO", false);
1:9670af1: 
1:9670af1:         // delay the advisory messages so that one can percolate fully (cyclicly) before the other
1:9670af1:         BrokerItem brokerB = brokers.get("BrokerA");
1:9670af1:         brokerB.broker.setPlugins(new BrokerPlugin[]{new BrokerPlugin() {
1:9670af1: 
1:9670af1:             public Broker installPlugin(Broker broker) throws Exception {          
1:9670af1:                 return new BrokerFilter(broker) {
1:9670af1: 
1:9670af1:                     final AtomicInteger count = new AtomicInteger();
1:9670af1:                     @Override
1:9670af1:                     public void preProcessDispatch(
1:9670af1:                             MessageDispatch messageDispatch) {
1:9670af1:                         if (messageDispatch.getDestination().getPhysicalName().contains("ActiveMQ.Advisory.Consumer")) {
1:9670af1:                             // lets delay the first advisory
1:9670af1:                             if (count.getAndIncrement() == 0) {
1:9670af1:                                 LOG.info("Sleeping on first advisory: " + messageDispatch);
1:9670af1:                                 try {
1:9670af1:                                     Thread.sleep(2000);
1:9670af1:                                 } catch (InterruptedException e) {
1:9670af1:                                     e.printStackTrace();
1:9670af1:                                 }
1:9670af1:                             }
1:9670af1:                         }
1:9670af1:                         super.postProcessDispatch(messageDispatch);
1:9670af1:                     }
1:9670af1:                     
1:9670af1:                 };
1:9670af1:             }}
1:22422ac:         });
1:9670af1:         
1:9670af1:         startAllBrokers();
1:7449545:         waitForBridgeFormation();
1:9670af1:         
1:9670af1:     
1:9670af1:         // Setup consumers
1:9670af1:         String brokerName = "BrokerA";
1:9670af1:         createConsumer(brokerName, dest);
1:9670af1:         
1:9670af1:         // wait for advisories
1:9670af1:         Thread.sleep(5000);
1:9670af1:         
1:9670af1:         // verify there is one consumer on each broker, no cycles
1:9670af1:         Collection<BrokerItem> brokerList = brokers.values();
1:9670af1:         for (Iterator<BrokerItem> i = brokerList.iterator(); i.hasNext();) {
1:9670af1:             BrokerService broker = i.next().broker;
1:9670af1:             verifyConsumerCount(broker, 1, dest);
1:6c5732b:             if (!brokerName.equals(broker.getBrokerName())) {
1:9670af1:                 verifyConsumePriority(broker, ConsumerInfo.NETWORK_CONSUMER_PRIORITY, dest);
1:9670af1:             }
1:9670af1:         }
1:9670af1:     }
1:9670af1: 
1:9670af1: 
1:5511217:     public void testDuplicateQueueSubs() throws Exception {
1:6c5732b: 
1:6c5732b:         configureBroker(createBroker("BrokerD"));
1:e5584e6:         
1:5511217:         bridgeAllBrokers("default", 3, false);
1:5511217:         startAllBrokers();
1:7449545:         waitForBridgeFormation();
1:5511217:         
1:5511217:         // Setup destination
1:5511217:         Destination dest = createDestination("TEST.FOO", false);
1:5511217: 
1:5511217:         // Setup consumers
1:5511217:         String brokerName = "BrokerA";
1:11e407e:         MessageConsumer consumer = createConsumer(brokerName, dest);
1:5511217:         
1:5511217:         // wait for advisories
1:5511217:         Thread.sleep(2000);
1:5511217:         
1:5511217:         verifyConsumerCount(brokers.get(brokerName).broker, 1, dest);
1:5511217:         
1:5511217:         // in a cyclic network, other brokers will get second order consumer
1:5511217:         // an alternative route to A via each other
1:5511217:         Collection<BrokerItem> brokerList = brokers.values();
1:5511217:         for (Iterator<BrokerItem> i = brokerList.iterator(); i.hasNext();) {
1:5511217:             BrokerService broker = i.next().broker;
1:9670af1:             if (!brokerName.equals(broker.getBrokerName())) {
1:6c5732b:                 verifyConsumerCount(broker, 5, dest);
1:9670af1:                 verifyConsumePriority(broker, ConsumerInfo.NORMAL_PRIORITY, dest);
1:11e407e:             }
1:5511217:         }
1:11e407e:         
1:11e407e:         consumer.close();
1:11e407e:         
1:11e407e:         // wait for advisories
1:11e407e:         Thread.sleep(2000);
1:5511217: 
1:11e407e:         for (Iterator<BrokerItem> i = brokerList.iterator(); i.hasNext();) {
1:11e407e:             BrokerService broker = i.next().broker;
1:5511217:             if (!brokerName.equals(broker.getBrokerName())) {
1:6c5732b:                 logConsumerCount(broker, 0, dest);
1:6c5732b:             }
1:6c5732b:         }
1:6c5732b: 
1:5511217:         for (Iterator<BrokerItem> i = brokerList.iterator(); i.hasNext();) {
1:5511217:             BrokerService broker = i.next().broker;
1:11e407e:             verifyConsumerCount(broker, 0, dest);
1:5511217:         }
1:5511217:     }
1:5511217: 
1:22422ac:     private void verifyConsumerCount(BrokerService broker, int count, final Destination dest) throws Exception {
1:22422ac:         final RegionBroker regionBroker = (RegionBroker) broker.getRegionBroker();
1:7449545:         waitFor(new Condition() {
1:22422ac:             public boolean isSatisified() throws Exception {
1:22422ac:                 return !regionBroker.getDestinations(ActiveMQDestination.transform(dest)).isEmpty();
1:22422ac:             }
1:7449545:         });
1:9670af1:         Queue internalQueue = (Queue) regionBroker.getDestinations(ActiveMQDestination.transform(dest)).iterator().next();
1:6c5732b:         LOG.info("Verify: consumer count on " + broker.getBrokerName() + " matches:" + count + ", val:" + internalQueue.getConsumers().size());
1:5511217:         assertEquals("consumer count on " + broker.getBrokerName() + " matches for q: " + internalQueue, count, internalQueue.getConsumers().size());      
1:5511217:     }
1:9670af1: 
1:6c5732b:     private void logConsumerCount(BrokerService broker, int count, final Destination dest) throws Exception {
1:6c5732b:         final RegionBroker regionBroker = (RegionBroker) broker.getRegionBroker();
1:6c5732b:         waitFor(new Condition() {
1:6c5732b:             public boolean isSatisified() throws Exception {
1:6c5732b:                 return !regionBroker.getDestinations(ActiveMQDestination.transform(dest)).isEmpty();
1:6c5732b:             }
1:6c5732b:         });
1:6c5732b:         Queue internalQueue = (Queue) regionBroker.getDestinations(ActiveMQDestination.transform(dest)).iterator().next();
1:6c5732b:         LOG.info("Verify: consumer count on " + broker.getBrokerName() + " matches:" + count + ", val:" + internalQueue.getConsumers().size());
1:6c5732b:     }
1:6c5732b: 
1:9670af1:     private void verifyConsumePriority(BrokerService broker, byte expectedPriority, Destination dest) throws Exception {
1:9670af1:         RegionBroker regionBroker = (RegionBroker) broker.getRegionBroker();
1:9670af1:         Queue internalQueue = (Queue) regionBroker.getDestinations(ActiveMQDestination.transform(dest)).iterator().next();
1:9670af1:         for (Subscription consumer : internalQueue.getConsumers()) {
1:9670af1:             assertEquals("consumer on " + broker.getBrokerName() + " matches priority: " + internalQueue, expectedPriority, consumer.getConsumerInfo().getPriority());      
1:9670af1:         }
1:9670af1:     }
1:6c5732b: 
1:6c5732b:     @Override
1:6c5732b:     public void configureBroker(BrokerService brokerService) {
1:6c5732b:         brokerService.setBrokerId(brokerService.getBrokerName());
1:6c5732b:     }
1:6c5732b: 
1:8af25fd:     @Override
1:a677c21:     public void setUp() throws Exception {
1:a677c21:         super.setAutoFail(true);
1:a677c21:         super.setUp();
1:a677c21:         createBroker(new URI("broker:(tcp://localhost:61616)/BrokerA?persistent=false&useJmx=false"));
1:a677c21:         createBroker(new URI("broker:(tcp://localhost:61617)/BrokerB?persistent=false&useJmx=false"));
1:a677c21:         createBroker(new URI("broker:(tcp://localhost:61618)/BrokerC?persistent=false&useJmx=false"));
1:a677c21:     }
1:a677c21: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:6c5732b
/////////////////////////////////////////////////////////////////////////
1: 
1:         configureBroker(createBroker("BrokerD"));
/////////////////////////////////////////////////////////////////////////
1:                 verifyConsumerCount(broker, 5, dest);
/////////////////////////////////////////////////////////////////////////
1: 
1:         for (Iterator<BrokerItem> i = brokerList.iterator(); i.hasNext();) {
1:             BrokerService broker = i.next().broker;
1:             if (!brokerName.equals(broker.getBrokerName())) {
1:                 logConsumerCount(broker, 0, dest);
1:             }
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("Verify: consumer count on " + broker.getBrokerName() + " matches:" + count + ", val:" + internalQueue.getConsumers().size());
1:     private void logConsumerCount(BrokerService broker, int count, final Destination dest) throws Exception {
1:         final RegionBroker regionBroker = (RegionBroker) broker.getRegionBroker();
1:         waitFor(new Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 return !regionBroker.getDestinations(ActiveMQDestination.transform(dest)).isEmpty();
1:             }
1:         });
1:         Queue internalQueue = (Queue) regionBroker.getDestinations(ActiveMQDestination.transform(dest)).iterator().next();
1:         LOG.info("Verify: consumer count on " + broker.getBrokerName() + " matches:" + count + ", val:" + internalQueue.getConsumers().size());
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     public void configureBroker(BrokerService brokerService) {
1:         brokerService.setBrokerId(brokerService.getBrokerName());
1:     }
1: 
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:     public void testABandBCbrokerNetwork() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testBAandBCbrokerNetwork() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testABandCBbrokerNetwork() throws Exception {
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
1: import java.net.URI;
1: 
1: import org.apache.activemq.JmsMultipleBrokersTestSupport;
1: import org.apache.activemq.util.MessageIdList;
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(ThreeBrokerQueueNetworkTest.class);
commit:e5584e6
/////////////////////////////////////////////////////////////////////////
1:     	
0:     	createBroker("BrokerD");
/////////////////////////////////////////////////////////////////////////
0:                 verifyConsumerCount(broker, 3, dest);
commit:11e407e
/////////////////////////////////////////////////////////////////////////
1:         MessageConsumer consumer = createConsumer(brokerName, dest);
/////////////////////////////////////////////////////////////////////////
1:         
1:         consumer.close();
1:         
1:         // wait for advisories
1:         Thread.sleep(2000);
1:         
1:         // verify there is no more consumers
1:         for (Iterator<BrokerItem> i = brokerList.iterator(); i.hasNext();) {
1:             BrokerService broker = i.next().broker;
1:             verifyConsumerCount(broker, 0, dest);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         MessageConsumer consumer = createConsumer(brokerName, dest);
/////////////////////////////////////////////////////////////////////////
1:         
1:         consumer.close();
1:         
1:         // wait for advisories
1:         Thread.sleep(2000);
1:         
1:         for (Iterator<BrokerItem> i = brokerList.iterator(); i.hasNext();) {
1:             BrokerService broker = i.next().broker;
1:             verifyConsumerCount(broker, 0, dest);
1:         }
commit:8b0bb33
/////////////////////////////////////////////////////////////////////////
1:         bridgeBrokers("BrokerB", "BrokerA", true, 1, false);
1:         bridgeBrokers("BrokerB", "BrokerC", true, 1, false);
/////////////////////////////////////////////////////////////////////////
1:         bridgeBrokers("BrokerB", "BrokerA", true, 1, false);
1:         bridgeBrokers("BrokerB", "BrokerC", true, 1, false);
commit:b2148c5
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * BrokerA <- BrokerB -> BrokerC
1:      */
1:     public void testBAandBCbrokerNetworkWithSelectorsSendFirst() throws Exception {
1:     	// Setup broker networks
1:         bridgeBrokers("BrokerB", "BrokerA");
1:         bridgeBrokers("BrokerB", "BrokerC");
1: 
1:         startAllBrokers();
1: 
1:         // Setup destination
1:         Destination dest = createDestination("TEST.FOO", false);
1: 
1:         
1:         // Send messages for broker A
1:         HashMap<String, Object> props = new HashMap<String, Object>();
1:         props.put("broker", "BROKER_A");
1:         sendMessages("BrokerB", dest, MESSAGE_COUNT, props);
1: 
1:         //Send messages for broker C
1:         props.clear();
1:         props.put("broker", "BROKER_C");
1:         sendMessages("BrokerB", dest, MESSAGE_COUNT, props);
1:         
1:         // Setup consumers
1:         MessageConsumer clientA = createConsumer("BrokerA", dest, "broker = 'BROKER_A'");
1:         MessageConsumer clientC = createConsumer("BrokerC", dest, "broker = 'BROKER_C'");
1:         Thread.sleep(2000); //et subscriptions get propagated
1:         
1:         // Let's try to wait for any messages.
1:         //Thread.sleep(1000);
1: 
1:         // Get message count
1:         MessageIdList msgsA = getConsumerMessages("BrokerA", clientA);
1:         MessageIdList msgsC = getConsumerMessages("BrokerC", clientC);
1:         
1:         // Total received should be 100
1:         assertEquals(MESSAGE_COUNT, msgsA.getMessageCount());
1:         assertEquals(MESSAGE_COUNT, msgsC.getMessageCount());
1:     }
1:     
1:     /**
1:      * BrokerA <- BrokerB -> BrokerC
1:      */
1:     public void testBAandBCbrokerNetworkWithSelectorsSubscribeFirst() throws Exception {
1:     	// Setup broker networks
1:         bridgeBrokers("BrokerB", "BrokerA");
1:         bridgeBrokers("BrokerB", "BrokerC");
1: 
1:         startAllBrokers();
1: 
1:         // Setup destination
1:         Destination dest = createDestination("TEST.FOO", false);
1: 
1:         // Setup consumers
1:         MessageConsumer clientA = createConsumer("BrokerA", dest, "broker = 'BROKER_A'");
1:         MessageConsumer clientC = createConsumer("BrokerC", dest, "broker = 'BROKER_C'");
1:         Thread.sleep(2000); //et subscriptions get propagated
1:         
1:         
1:         // Send messages for broker A
1:         HashMap<String, Object> props = new HashMap<String, Object>();
1:         props.put("broker", "BROKER_A");
1:         sendMessages("BrokerB", dest, MESSAGE_COUNT, props);
1: 
1:         //Send messages for broker C
1:         props.clear();
1:         props.put("broker", "BROKER_C");
1:         sendMessages("BrokerB", dest, MESSAGE_COUNT, props);
1:         
1:         // Let's try to wait for any messages.
1:         Thread.sleep(1000);
1: 
1:         // Get message count
1:         MessageIdList msgsA = getConsumerMessages("BrokerA", clientA);
1:         MessageIdList msgsC = getConsumerMessages("BrokerC", clientC);
1:         
1:         // Total received should be 100
1:         assertEquals(MESSAGE_COUNT, msgsA.getMessageCount());
1:         assertEquals(MESSAGE_COUNT, msgsC.getMessageCount());
1:     }    
author:Gary Tully
-------------------------------------------------------------------------------
commit:7449545
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     interface Condition {
1:         boolean isSatisified() throws Exception;
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:         waitForBridgeFormation();
/////////////////////////////////////////////////////////////////////////
1:         waitForBridgeFormation();
/////////////////////////////////////////////////////////////////////////
1:         waitForBridgeFormation();
/////////////////////////////////////////////////////////////////////////
1:         waitForBridgeFormation();
/////////////////////////////////////////////////////////////////////////
1:         waitForBridgeFormation();
/////////////////////////////////////////////////////////////////////////
1:         waitForBridgeFormation();
/////////////////////////////////////////////////////////////////////////
1:         waitForBridgeFormation();
/////////////////////////////////////////////////////////////////////////
1:         waitFor(new Condition() {
1:         });
1:     // on slow machines some more waiting is required on account of slow advisories
1:     private void waitFor(Condition condition) throws Exception {
1:         final long expiry = System.currentTimeMillis() + MAX_WAIT_MILLIS;
1:         while (!condition.isSatisified() && System.currentTimeMillis() < expiry) {
1:             Thread.sleep(1000);
1:         }   
1:         if (System.currentTimeMillis() >= expiry) {
1:             LOG.error("expired while waiting for condition " + condition);
1:         }
1:         
1:     }
1: 
1:         waitForBridgeFormation();
/////////////////////////////////////////////////////////////////////////
1:         waitForBridgeFormation();
/////////////////////////////////////////////////////////////////////////
1:      * messages - ie. half dont get stuck on BrokerA - 
1:         boolean suppressQueueDuplicateSubscriptions = false;
1:         bridgeAllBrokers("default", 3, suppressQueueDuplicateSubscriptions);
1:         waitForBridgeFormation();
/////////////////////////////////////////////////////////////////////////
1:         waitForBridgeFormation();
/////////////////////////////////////////////////////////////////////////
1:         
1:         waitForBridgeFormation();
/////////////////////////////////////////////////////////////////////////
1:         waitForBridgeFormation();
1:         
/////////////////////////////////////////////////////////////////////////
1:         waitForBridgeFormation();
/////////////////////////////////////////////////////////////////////////
1:         waitFor(new Condition() {
1:         });
commit:4213e42
/////////////////////////////////////////////////////////////////////////
0:         waitForBridgeFormation();
1:         
/////////////////////////////////////////////////////////////////////////
0:         waitForBridgeFormation();
1:         
/////////////////////////////////////////////////////////////////////////
0:         waitForBridgeFormation();
1:         
/////////////////////////////////////////////////////////////////////////
0:         waitForBridgeFormation();
1:         
/////////////////////////////////////////////////////////////////////////
0:         waitForBridgeFormation();
1:         
/////////////////////////////////////////////////////////////////////////
0:         waitForBridgeFormation();
1:         
/////////////////////////////////////////////////////////////////////////
0:         waitForBridgeFormation();
1:         
/////////////////////////////////////////////////////////////////////////
0:         waitForBridgeFormation();
1:         
/////////////////////////////////////////////////////////////////////////
0:         waitForBridgeFormation();
1:         
/////////////////////////////////////////////////////////////////////////
0:         waitForBridgeFormation();
/////////////////////////////////////////////////////////////////////////
0:         waitForBridgeFormation();
1:         
/////////////////////////////////////////////////////////////////////////
0:         waitForBridgeFormation();
1:         
/////////////////////////////////////////////////////////////////////////
0:         waitForBridgeFormation();
1:         
/////////////////////////////////////////////////////////////////////////
0:         waitForBridgeFormation();
1:         
commit:22422ac
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private static final long MAX_WAIT_MILLIS = 10000;
0:     interface Condition {
0:         boolean isSatisified() throws Exception;
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:         final MessageIdList msgsA = getConsumerMessages("BrokerA", clientA);
0:         waitFor(new Condition() {
1:             public boolean isSatisified() {
1:                 return msgsA.getMessageCount() == MESSAGE_COUNT;
1:             } 
1:         });
1:         
0:     // on slow machines some more waiting is required on account of slow advisories
0:     private void waitFor(Condition condition) throws Exception {
0:         final long expiry = System.currentTimeMillis() + MAX_WAIT_MILLIS;
0:         while (!condition.isSatisified() && System.currentTimeMillis() < expiry) {
1:             Thread.sleep(1000);
1:         }   
0:         if (System.currentTimeMillis() >= expiry) {
0:             LOG.error("expired while waiting for condition " + condition);
1:         }
1:         
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     private void verifyConsumerCount(BrokerService broker, int count, final Destination dest) throws Exception {
1:         final RegionBroker regionBroker = (RegionBroker) broker.getRegionBroker();
0:         waitFor(new Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 return !regionBroker.getDestinations(ActiveMQDestination.transform(dest)).isEmpty();
1:             }
0:         });
commit:9670af1
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicInteger;
0: import org.apache.activemq.JmsMultipleBrokersTestSupport.BrokerItem;
1: import org.apache.activemq.broker.Broker;
1: import org.apache.activemq.broker.BrokerFilter;
1: import org.apache.activemq.broker.BrokerPlugin;
0: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.broker.region.Subscription;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.command.MessageDispatch;
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("messaged received within time limit", messagesReceived.await(30, TimeUnit.SECONDS));
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("messages are received within limit", messagesReceived.await(60, TimeUnit.SECONDS));
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void testNoDuplicateQueueSubsHasLowestPriority() throws Exception {
1:         boolean suppressQueueDuplicateSubscriptions = true;
1:         boolean decreaseNetworkConsumerPriority = true;
1:         bridgeAllBrokers("default", 3, suppressQueueDuplicateSubscriptions, decreaseNetworkConsumerPriority);
1: 
1:         // Setup destination
1:         final Destination dest = createDestination("TEST.FOO", false);
1: 
1:         // delay the advisory messages so that one can percolate fully (cyclicly) before the other
1:         BrokerItem brokerB = brokers.get("BrokerA");
1:         brokerB.broker.setPlugins(new BrokerPlugin[]{new BrokerPlugin() {
1: 
1:             public Broker installPlugin(Broker broker) throws Exception {          
1:                 return new BrokerFilter(broker) {
1: 
1:                     final AtomicInteger count = new AtomicInteger();
1:                     @Override
1:                     public void preProcessDispatch(
1:                             MessageDispatch messageDispatch) {
1:                         if (messageDispatch.getDestination().getPhysicalName().contains("ActiveMQ.Advisory.Consumer")) {
1:                             // lets delay the first advisory
1:                             if (count.getAndIncrement() == 0) {
1:                                 LOG.info("Sleeping on first advisory: " + messageDispatch);
1:                                 try {
1:                                     Thread.sleep(2000);
1:                                 } catch (InterruptedException e) {
1:                                     e.printStackTrace();
1:                                 }
1:                             }
1:                         }
1:                         super.postProcessDispatch(messageDispatch);
1:                     }
1:                     
1:                 };
1:             }}
0:         });
1:         
1:         startAllBrokers();
1: 
1:     
1:         // Setup consumers
1:         String brokerName = "BrokerA";
1:         createConsumer(brokerName, dest);
1:         
1:         // wait for advisories
1:         Thread.sleep(5000);
1:         
1:         // verify there is one consumer on each broker, no cycles
1:         Collection<BrokerItem> brokerList = brokers.values();
1:         for (Iterator<BrokerItem> i = brokerList.iterator(); i.hasNext();) {
1:             BrokerService broker = i.next().broker;
1:             verifyConsumerCount(broker, 1, dest);
1:             if (!brokerName.equals(broker.getBrokerName())) {
1:                 verifyConsumePriority(broker, ConsumerInfo.NETWORK_CONSUMER_PRIORITY, dest);
1:             }
1:         }
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:                 verifyConsumePriority(broker, ConsumerInfo.NORMAL_PRIORITY, dest);
1:         Queue internalQueue = (Queue) regionBroker.getDestinations(ActiveMQDestination.transform(dest)).iterator().next();
1:     private void verifyConsumePriority(BrokerService broker, byte expectedPriority, Destination dest) throws Exception {
1:         RegionBroker regionBroker = (RegionBroker) broker.getRegionBroker();
1:         Queue internalQueue = (Queue) regionBroker.getDestinations(ActiveMQDestination.transform(dest)).iterator().next();
1:         for (Subscription consumer : internalQueue.getConsumers()) {
1:             assertEquals("consumer on " + broker.getBrokerName() + " matches priority: " + internalQueue, expectedPriority, consumer.getConsumerInfo().getPriority());      
1:         }
1:     }
1:     
commit:0470304
/////////////////////////////////////////////////////////////////////////
1:         Thread.sleep(2000);
/////////////////////////////////////////////////////////////////////////
1:         Thread.sleep(2000);
/////////////////////////////////////////////////////////////////////////
1:         Thread.sleep(2000);
1:         Thread.sleep(2000);
/////////////////////////////////////////////////////////////////////////
1:         Thread.sleep(2000);
/////////////////////////////////////////////////////////////////////////
1:         Thread.sleep(2000);
1:         Thread.sleep(2000);
0:         assertTrue(messagesReceived.await(60, TimeUnit.SECONDS));
commit:3da1373
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0:     private static final Log LOG = LogFactory.getLog(ThreeBrokerQueueNetworkTest.class);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     
1:     public void testAllConnectedUsingMulticastProducerConsumerOnA() throws Exception {
1:         bridgeAllBrokers("default", 3, false);
1:         startAllBrokers();
1: 
1:         // Setup destination
1:         Destination dest = createDestination("TEST.FOO", false);
1: 
1:         // Setup consumers
1:         int messageCount = 2000;
1:         CountDownLatch messagesReceived = new CountDownLatch(messageCount);
1:         MessageConsumer clientA = createConsumer("BrokerA", dest, messagesReceived);
1: 
1:         // Let's try to wait for advisory percolation.
1:         Thread.sleep(1000);
1: 
1:         // Send messages
1:         sendMessages("BrokerA", dest, messageCount);
1:      
1:         assertTrue(messagesReceived.await(30, TimeUnit.SECONDS));
1:         
1:         // Get message count
1:         MessageIdList msgsA = getConsumerMessages("BrokerA", clientA);
1:         assertEquals(messageCount, msgsA.getMessageCount());
1:     }
1: 
1:     public void testAllConnectedWithSpare() throws Exception {
1:         bridgeAllBrokers("default", 3, false);
1:         startAllBrokers();
1: 
1:         // Setup destination
1:         Destination dest = createDestination("TEST.FOO", false);
1: 
1:         // Setup consumers
1:         int messageCount = 2000;
1:         CountDownLatch messagesReceived = new CountDownLatch(messageCount);
1:         MessageConsumer clientA = createConsumer("BrokerA", dest, messagesReceived);
1: 
1:         // ensure advisory percolation.
1:         Thread.sleep(1000);
1: 
1:         // Send messages
1:         sendMessages("BrokerB", dest, messageCount);
1: 
1:         assertTrue(messagesReceived.await(30, TimeUnit.SECONDS));
1:         
1:         // Get message count
1:         MessageIdList msgsA = getConsumerMessages("BrokerA", clientA);
1:         assertEquals(messageCount, msgsA.getMessageCount());
1:     }
1:     
0:     public void testMigrateConsumerStuckMessages() throws Exception {
0:         boolean suppressQueueDuplicateSubscriptions = false;
0:         bridgeAllBrokers("default", 3, suppressQueueDuplicateSubscriptions);
1:         startAllBrokers();
1: 
1:         // Setup destination
1:         Destination dest = createDestination("TEST.FOO", false);    
1:         
1:         // Setup consumers
1:         LOG.info("Consumer on A");
1:         MessageConsumer clientA = createConsumer("BrokerA", dest);
1:         
1:         // ensure advisors have percolated
1:         Thread.sleep(500);
1:         
1:         LOG.info("Consumer on B");
1:         int messageCount = 2000;
1:         
1:         // will only get half of the messages
1:         CountDownLatch messagesReceived = new CountDownLatch(messageCount/2);
1:         MessageConsumer clientB = createConsumer("BrokerB", dest, messagesReceived);
1:           
1:         // ensure advisors have percolated
1:         Thread.sleep(500);
1: 
1:         LOG.info("Close consumer on A");
1:         clientA.close();
1: 
1:         // ensure advisors have percolated
1:         Thread.sleep(500);
1:        
1:         LOG.info("Send to B"); 
1:         sendMessages("BrokerB", dest, messageCount);
1: 
1:         // Let's try to wait for any messages.
1:         assertTrue(messagesReceived.await(30, TimeUnit.SECONDS));
1: 
1:         // Get message count
1:         MessageIdList msgs = getConsumerMessages("BrokerB", clientB);
1:         
1:         // see will any more arrive
1:         Thread.sleep(500);        
1:         assertEquals(messageCount/2, msgs.getMessageCount());
1:         
1:         // pick up the stuck messages
1:         messagesReceived = new CountDownLatch(messageCount/2);
1:         clientA = createConsumer("BrokerA", dest, messagesReceived);
1:         // Let's try to wait for any messages.
1:         assertTrue(messagesReceived.await(30, TimeUnit.SECONDS));
1:         
1:         msgs = getConsumerMessages("BrokerA", clientA);
1:         assertEquals(messageCount/2, msgs.getMessageCount());
1:     }
1: 
1:     // use case: for maintenance, migrate consumers and producers from one
1:     // node in the network to another so node can be replaced/updated
1:     public void testMigrateConsumer() throws Exception {
1:         boolean suppressQueueDuplicateSubscriptions = true;
1:         boolean decreaseNetworkConsumerPriority = true;
1:         bridgeAllBrokers("default", 3, suppressQueueDuplicateSubscriptions, decreaseNetworkConsumerPriority);
1:         startAllBrokers();
1: 
1:         // Setup destination
1:         Destination dest = createDestination("TEST.FOO", false);    
1:         
1:         // Setup consumers
1:         LOG.info("Consumer on A");
1:         MessageConsumer clientA = createConsumer("BrokerA", dest);
1:         
1:         // ensure advisors have percolated
1:         Thread.sleep(500);
1:         
1:         LOG.info("Consumer on B");
1:         int messageCount = 2000;
1:         CountDownLatch messagesReceived = new CountDownLatch(messageCount);
1:         MessageConsumer clientB = createConsumer("BrokerB", dest, messagesReceived);
1:        
1:         // make the consumer slow so that any network consumer has a chance, even
1:         // if it has a lower priority
1:         MessageIdList msgs = getConsumerMessages("BrokerB", clientB);
1:         msgs.setProcessingDelay(10);
1:         
1:         // ensure advisors have percolated
1:         Thread.sleep(500);
1: 
1:         LOG.info("Close consumer on A");
1:         clientA.close();
1: 
1:         // ensure advisors have percolated
1:         Thread.sleep(500);
1:        
1:         LOG.info("Send to B"); 
1:         sendMessages("BrokerB", dest, messageCount);
1: 
1:         // Let's try to wait for any messages.
1:         assertTrue(messagesReceived.await(30, TimeUnit.SECONDS));
1:         assertEquals(messageCount, msgs.getMessageCount());      
1:     }
1: 
commit:5511217
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collection;
1: import java.util.Iterator;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.region.Queue;
1: import org.apache.activemq.broker.region.RegionBroker;
1: import org.apache.activemq.command.ActiveMQDestination;
/////////////////////////////////////////////////////////////////////////
1:     public void testNoDuplicateQueueSubs() throws Exception {
1:         
1:         bridgeAllBrokers("default", 3, true);
1:         
1:         startAllBrokers();
1: 
1:         // Setup destination
1:         Destination dest = createDestination("TEST.FOO", false);
1: 
1:         // Setup consumers
1:         String brokerName = "BrokerA";
0:         createConsumer(brokerName, dest);
1:         
1:         // wait for advisories
1:         Thread.sleep(2000);
1:         
1:         // verify there is one consumer on each broker, no cycles
1:         Collection<BrokerItem> brokerList = brokers.values();
1:         for (Iterator<BrokerItem> i = brokerList.iterator(); i.hasNext();) {
1:             BrokerService broker = i.next().broker;
1:             verifyConsumerCount(broker, 1, dest);
1:         }
1:     }
1:     
1: 
1:     public void testDuplicateQueueSubs() throws Exception {
1:         
1:         bridgeAllBrokers("default", 3, false);
1:         startAllBrokers();
1: 
1:         // Setup destination
1:         Destination dest = createDestination("TEST.FOO", false);
1: 
1:         // Setup consumers
1:         String brokerName = "BrokerA";
0:         createConsumer(brokerName, dest);
1:         
1:         // wait for advisories
1:         Thread.sleep(2000);
1:         
1:         verifyConsumerCount(brokers.get(brokerName).broker, 1, dest);
1:         
1:         // in a cyclic network, other brokers will get second order consumer
1:         // an alternative route to A via each other
1:         Collection<BrokerItem> brokerList = brokers.values();
1:         for (Iterator<BrokerItem> i = brokerList.iterator(); i.hasNext();) {
1:             BrokerService broker = i.next().broker;
1:             if (!brokerName.equals(broker.getBrokerName())) {
0:                 verifyConsumerCount(broker, 2, dest);
1:             }
1:         }
1:     }
1: 
0:     private void verifyConsumerCount(BrokerService broker, int count, Destination dest) throws Exception {
0:         RegionBroker regionBroker = (RegionBroker) broker.getRegionBroker();
0:         Queue internalQueue = (Queue) regionBroker.getDestinations(ActiveMQDestination.transform(dest)).iterator().next(); 
1:         assertEquals("consumer count on " + broker.getBrokerName() + " matches for q: " + internalQueue, count, internalQueue.getConsumers().size());      
1:     }
1: 
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:8c4bb36
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.Wait;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         assertTrue("Bridge formation incomplete", waitForBridgeFormation());
/////////////////////////////////////////////////////////////////////////
0:         assertTrue("Bridge formation incomplete", waitForBridgeFormation());
/////////////////////////////////////////////////////////////////////////
0:         assertTrue("Bridge formation incomplete", waitForBridgeFormation());
/////////////////////////////////////////////////////////////////////////
0:         assertTrue("Bridge formation incomplete", waitForBridgeFormation());
/////////////////////////////////////////////////////////////////////////
0:         assertTrue("Bridge formation incomplete", waitForBridgeFormation());
/////////////////////////////////////////////////////////////////////////
0:         assertTrue("Bridge formation incomplete", waitForBridgeFormation());
/////////////////////////////////////////////////////////////////////////
0:         assertTrue("Bridge formation incomplete", waitForBridgeFormation());
/////////////////////////////////////////////////////////////////////////
0:         assertTrue("Messaged not received within time limit", Wait.waitFor(new Wait.Condition() {
0:         }, MAX_WAIT_MILLIS));
0:         assertTrue("Bridge formation incomplete", waitForBridgeFormation());
/////////////////////////////////////////////////////////////////////////
0:         assertTrue("Bridge formation incomplete", waitForBridgeFormation());
/////////////////////////////////////////////////////////////////////////
0:      * messages - ie. half don't get stuck on BrokerA - 
0:         bridgeAllBrokers("default", 3, false);
0:         assertTrue("Bridge formation incomplete", waitForBridgeFormation());
/////////////////////////////////////////////////////////////////////////
0:         assertTrue("Bridge formation incomplete", waitForBridgeFormation());
/////////////////////////////////////////////////////////////////////////
0:         assertTrue("Bridge formation incomplete", waitForBridgeFormation());
/////////////////////////////////////////////////////////////////////////
0:         assertTrue("Bridge formation incomplete", waitForBridgeFormation());
/////////////////////////////////////////////////////////////////////////
0:         assertTrue("Bridge formation incomplete", waitForBridgeFormation());
/////////////////////////////////////////////////////////////////////////
0:         assertTrue("RegionBroker should have at least one destination", Wait.waitFor(new Wait.Condition() {
0:         }, MAX_WAIT_MILLIS));
author:Robert Davies
-------------------------------------------------------------------------------
commit:8af25fd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /*
1:      * This test is disabled - as it fails with a fix for 
1:      * http://issues.apache.org/activemq/browse/AMQ-2530 - which highlights that 
1:      * For a Conduit bridge - local subscription Ids weren't removed in a ConduitBridge
1:      * The test fails because on closing clientA - clientB correctly receives all the 
0:      * messages - ie. half dont get stuck on BrokerA - 
1:      */
1:     public void XtestMigrateConsumerStuckMessages() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     @Override
author:James Strachan
-------------------------------------------------------------------------------
commit:a677c21
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.usecases;
1: 
0: import org.apache.activemq.JmsMultipleBrokersTestSupport;
0: import org.apache.activemq.util.MessageIdList;
1: 
1: import javax.jms.Destination;
1: import javax.jms.MessageConsumer;
0: import java.net.URI;
1: 
1: /**
0:  * @version $Revision: 1.1.1.1 $
1:  */
1: public class ThreeBrokerQueueNetworkTest extends JmsMultipleBrokersTestSupport {
1:     protected static final int MESSAGE_COUNT = 100;
1: 
1:     /**
1:      * BrokerA -> BrokerB -> BrokerC
1:      */
0:     public void test_AB_BC_BrokerNetwork() throws Exception {
1:         // Setup broker networks
1:         bridgeBrokers("BrokerA", "BrokerB");
1:         bridgeBrokers("BrokerB", "BrokerC");
1: 
1:         startAllBrokers();
1: 
1:         // Setup destination
1:         Destination dest = createDestination("TEST.FOO", false);
1: 
1:         // Setup consumers
1:         MessageConsumer clientC = createConsumer("BrokerC", dest);
1: 
1:         // Send messages
1:         sendMessages("BrokerA", dest, MESSAGE_COUNT);
1: 
1:         // Let's try to wait for any messages. Should be none.
1:         Thread.sleep(1000);
1: 
1:         // Get message count
1:         MessageIdList msgsC = getConsumerMessages("BrokerC", clientC);
1:         assertEquals(0, msgsC.getMessageCount());
1:     }
1: 
1:     /**
1:      * BrokerA <- BrokerB -> BrokerC
1:      */
0:     public void test_BA_BC_BrokerNetwork() throws Exception {
1:         // Setup broker networks
0:         bridgeBrokers("BrokerB", "BrokerA");
1:         bridgeBrokers("BrokerB", "BrokerC");
1: 
1:         startAllBrokers();
1: 
1:         // Setup destination
1:         Destination dest = createDestination("TEST.FOO", false);
1: 
1:         // Setup consumers
1:         MessageConsumer clientA = createConsumer("BrokerA", dest);
1:         MessageConsumer clientC = createConsumer("BrokerC", dest);
1:         Thread.sleep(2000); //et subscriptions get propagated
1:         // Send messages
1:         sendMessages("BrokerB", dest, MESSAGE_COUNT);
1: 
1:         // Let's try to wait for any messages.
1:         Thread.sleep(1000);
1: 
1:         // Get message count
1:         MessageIdList msgsA = getConsumerMessages("BrokerA", clientA);
1:         MessageIdList msgsC = getConsumerMessages("BrokerC", clientC);
1: 
1:         // Total received should be 100
1:         assertEquals(MESSAGE_COUNT, msgsA.getMessageCount() + msgsC.getMessageCount());
1:     }
1: 
1:     /**
1:      * BrokerA -> BrokerB <- BrokerC
1:      */
0:     public void test_AB_CB_BrokerNetwork() throws Exception {
1:         // Setup broker networks
1:         bridgeBrokers("BrokerA", "BrokerB");
1:         bridgeBrokers("BrokerC", "BrokerB");
1: 
1:         startAllBrokers();
1: 
1:         // Setup destination
1:         Destination dest = createDestination("TEST.FOO", false);
1: 
1:         // Setup consumers
1:         MessageConsumer clientB = createConsumer("BrokerB", dest);
1: 
1:         // Send messages
1:         sendMessages("BrokerA", dest, MESSAGE_COUNT);
1:         sendMessages("BrokerC", dest, MESSAGE_COUNT);
1: 
1:         // Get message count
1:         MessageIdList msgsB = getConsumerMessages("BrokerB", clientB);
1: 
1:         msgsB.waitForMessagesToArrive(MESSAGE_COUNT * 2);
1: 
1:         assertEquals(MESSAGE_COUNT * 2, msgsB.getMessageCount());
1:     }
1: 
1:     /**
1:      * BrokerA <-> BrokerB <-> BrokerC
1:      */
1:     public void testAllConnectedBrokerNetwork() throws Exception {
1:         // Setup broker networks
1:         bridgeBrokers("BrokerA", "BrokerB");
0:         bridgeBrokers("BrokerB", "BrokerA");
1:         bridgeBrokers("BrokerB", "BrokerC");
1:         bridgeBrokers("BrokerC", "BrokerB");
1:         bridgeBrokers("BrokerA", "BrokerC");
1:         bridgeBrokers("BrokerC", "BrokerA");
1: 
1:         startAllBrokers();
1: 
1:         // Setup destination
1:         Destination dest = createDestination("TEST.FOO", false);
1: 
1:         // Setup consumers
1:         MessageConsumer clientA = createConsumer("BrokerA", dest);
1:         MessageConsumer clientB = createConsumer("BrokerB", dest);
1:         MessageConsumer clientC = createConsumer("BrokerC", dest);
1: 
1:         // Send messages
1:         sendMessages("BrokerA", dest, MESSAGE_COUNT);
1:         sendMessages("BrokerB", dest, MESSAGE_COUNT);
1:         sendMessages("BrokerC", dest, MESSAGE_COUNT);
1: 
1:         // Let's try to wait for any messages.
1:         Thread.sleep(1000);
1: 
1:         // Get message count
1:         MessageIdList msgsA = getConsumerMessages("BrokerA", clientA);
1:         MessageIdList msgsB = getConsumerMessages("BrokerB", clientB);
1:         MessageIdList msgsC = getConsumerMessages("BrokerC", clientC);
1: 
1:         assertEquals(MESSAGE_COUNT * 3, msgsA.getMessageCount() + msgsB.getMessageCount() + msgsC.getMessageCount());
1:     }
1: 
1:     /**
1:      * BrokerA <-> BrokerB <-> BrokerC
1:      */
1:     public void testAllConnectedUsingMulticast() throws Exception {
1:         // Setup broker networks
1:         bridgeAllBrokers();
1: 
1:         startAllBrokers();
1: 
1:         // Setup destination
1:         Destination dest = createDestination("TEST.FOO", false);
1: 
1:         // Setup consumers
1:         MessageConsumer clientA = createConsumer("BrokerA", dest);
1:         MessageConsumer clientB = createConsumer("BrokerB", dest);
1:         MessageConsumer clientC = createConsumer("BrokerC", dest);
1: 
1:         // Send messages
1:         sendMessages("BrokerA", dest, MESSAGE_COUNT);
1:         sendMessages("BrokerB", dest, MESSAGE_COUNT);
1:         sendMessages("BrokerC", dest, MESSAGE_COUNT);
1: 
1:         // Let's try to wait for any messages.
1:         Thread.sleep(1000);
1: 
1:         // Get message count
1:         MessageIdList msgsA = getConsumerMessages("BrokerA", clientA);
1:         MessageIdList msgsB = getConsumerMessages("BrokerB", clientB);
1:         MessageIdList msgsC = getConsumerMessages("BrokerC", clientC);
1: 
1:         assertEquals(MESSAGE_COUNT * 3, msgsA.getMessageCount() + msgsB.getMessageCount() + msgsC.getMessageCount());
1:     }
1: 
1:     public void setUp() throws Exception {
1:         super.setAutoFail(true);
1:         super.setUp();
1:         createBroker(new URI("broker:(tcp://localhost:61616)/BrokerA?persistent=false&useJmx=false"));
1:         createBroker(new URI("broker:(tcp://localhost:61617)/BrokerB?persistent=false&useJmx=false"));
1:         createBroker(new URI("broker:(tcp://localhost:61618)/BrokerC?persistent=false&useJmx=false"));
1:     }
1: }
============================================================================