1:d29ca2a: /**
1:fc00993:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:fc00993:  * contributor license agreements.  See the NOTICE file distributed with
1:fc00993:  * this work for additional information regarding copyright ownership.
1:fc00993:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:fc00993:  * (the "License"); you may not use this file except in compliance with
1:fc00993:  * the License.  You may obtain a copy of the License at
2:fc00993:  *
1:fc00993:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b0c2a40:  *
1:fc00993:  * Unless required by applicable law or agreed to in writing, software
1:fc00993:  * distributed under the License is distributed on an "AS IS" BASIS,
1:fc00993:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:fc00993:  * See the License for the specific language governing permissions and
1:fc00993:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.broker.region.policy;
1:230a86c: 
1:a253ad3: import java.util.Set;
1:a253ad3: 
1:fc63a92: import org.apache.activemq.ActiveMQPrefetchPolicy;
1:0c0be94: import org.apache.activemq.broker.Broker;
1:cdc2fd3: import org.apache.activemq.broker.region.BaseDestination;
1:0d85869: import org.apache.activemq.broker.region.Destination;
1:0c0be94: import org.apache.activemq.broker.region.DurableTopicSubscription;
1:d29ca2a: import org.apache.activemq.broker.region.Queue;
1:fc63a92: import org.apache.activemq.broker.region.QueueBrowserSubscription;
1:fc63a92: import org.apache.activemq.broker.region.QueueSubscription;
1:bc45bf8: import org.apache.activemq.broker.region.Subscription;
1:d29ca2a: import org.apache.activemq.broker.region.Topic;
1:95d0dec: import org.apache.activemq.broker.region.TopicSubscription;
1:3a9299b: import org.apache.activemq.broker.region.cursors.PendingMessageCursor;
1:468e697: import org.apache.activemq.broker.region.group.GroupFactoryFinder;
1:e7e15b5: import org.apache.activemq.broker.region.group.MessageGroupMapFactory;
1:d29ca2a: import org.apache.activemq.filter.DestinationMapEntry;
1:af1b232: import org.apache.activemq.network.NetworkBridgeFilterFactory;
1:6d8e2c5: import org.apache.activemq.usage.SystemUsage;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:d29ca2a: 
1:d29ca2a: /**
1:230a86c:  * Represents an entry in a {@link PolicyMap} for assigning policies to a
1:230a86c:  * specific destination or a hierarchical wildcard area of destinations.
1:37ede54:  *
1:68d245f:  * @org.apache.xbean.XBean
1:37ede54:  *
1:d29ca2a:  */
1:230a86c: public class PolicyEntry extends DestinationMapEntry {
1:d29ca2a: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(PolicyEntry.class);
1:d29ca2a:     private DispatchPolicy dispatchPolicy;
1:d29ca2a:     private SubscriptionRecoveryPolicy subscriptionRecoveryPolicy;
1:27f7cab:     private boolean sendAdvisoryIfNoConsumers;
1:0d85869:     private DeadLetterStrategy deadLetterStrategy = Destination.DEFAULT_DEAD_LETTER_STRATEGY;
1:95d0dec:     private PendingMessageLimitStrategy pendingMessageLimitStrategy;
1:062dc56:     private MessageEvictionStrategy messageEvictionStrategy;
1:36722d8:     private long memoryLimit;
1:468e697:     private String messageGroupMapFactoryType = "cached";
1:e7e15b5:     private MessageGroupMapFactory messageGroupMapFactory;
1:0c0be94:     private PendingQueueMessageStoragePolicy pendingQueuePolicy;
1:0c0be94:     private PendingDurableSubscriberMessageStoragePolicy pendingDurableSubscriberPolicy;
1:0c0be94:     private PendingSubscriberMessageStoragePolicy pendingSubscriberPolicy;
1:3ddb71c:     private int maxProducersToAudit=BaseDestination.MAX_PRODUCERS_TO_AUDIT;
1:3ddb71c:     private int maxAuditDepth=BaseDestination.MAX_AUDIT_DEPTH;
1:3ddb71c:     private int maxQueueAuditDepth=BaseDestination.MAX_AUDIT_DEPTH;
1:1ee0017:     private boolean enableAudit=true;
1:785454a:     private boolean producerFlowControl = true;
1:fe63c29:     private boolean alwaysRetroactive = false;
1:48764be:     private long blockedProducerWarningInterval = Destination.DEFAULT_BLOCKED_PRODUCER_WARNING_INTERVAL;
1:9dd11cb:     private boolean optimizedDispatch=false;
1:c8bd57c:     private int maxPageSize=BaseDestination.MAX_PAGE_SIZE;
1:47cfa55:     private int maxBrowsePageSize=BaseDestination.MAX_BROWSE_PAGE_SIZE;
1:6d0c552:     private boolean useCache=true;
1:6d0c552:     private long minimumMessageSize=1024;
1:2a153b0:     private boolean useConsumerPriority=true;
1:2a153b0:     private boolean strictOrderDispatch=false;
1:9e13dc6:     private boolean lazyDispatch=false;
1:a321204:     private int timeBeforeDispatchStarts = 0;
1:a321204:     private int consumersBeforeDispatchStarts = 0;
1:cdc2fd3:     private boolean advisoryForSlowConsumers;
1:db1f6fe:     private boolean advisoryForFastProducers;
1:cdc2fd3:     private boolean advisoryForDiscardingMessages;
1:cdc2fd3:     private boolean advisoryWhenFull;
1:cdc2fd3:     private boolean advisoryForDelivery;
1:cdc2fd3:     private boolean advisoryForConsumed;
1:edacc2a:     private boolean includeBodyForAdvisory;
1:c6a485f:     private long expireMessagesPeriod = BaseDestination.EXPIRE_MESSAGE_PERIOD;
1:c6a485f:     private int maxExpirePageSize = BaseDestination.MAX_BROWSE_PAGE_SIZE;
1:fc63a92:     private int queuePrefetch=ActiveMQPrefetchPolicy.DEFAULT_QUEUE_PREFETCH;
1:fc63a92:     private int queueBrowserPrefetch=ActiveMQPrefetchPolicy.DEFAULT_QUEUE_BROWSER_PREFETCH;
1:fc63a92:     private int topicPrefetch=ActiveMQPrefetchPolicy.DEFAULT_TOPIC_PREFETCH;
1:fc63a92:     private int durableTopicPrefetch=ActiveMQPrefetchPolicy.DEFAULT_DURABLE_TOPIC_PREFETCH;
1:6a73c40:     private boolean usePrefetchExtension = true;
1:6a73c40:     private int cursorMemoryHighWaterMark = 70;
1:a0d2282:     private int storeUsageHighWaterMark = 100;
1:1b6d397:     private SlowConsumerStrategy slowConsumerStrategy;
1:00879cf:     private boolean prioritizedMessages;
1:42ee51f:     private boolean allConsumersExclusiveByDefault;
1:70314ea:     private boolean gcInactiveDestinations;
1:d55a392:     private boolean gcWithNetworkConsumers;
1:b9fd189:     private long inactiveTimeoutBeforeGC = BaseDestination.DEFAULT_INACTIVE_TIMEOUT_BEFORE_GC;
1:c1da3ac:     private boolean reduceMemoryFootprint;
1:af1b232:     private NetworkBridgeFilterFactory networkBridgeFilterFactory;
1:f4d4c3b:     private boolean doOptimzeMessageStorage = true;
1:886e2d4:     private int maxDestinations = -1;
1:65b0f2a:     private boolean useTopicSubscriptionInflightStats = true;
1:886e2d4: 
1:ca83305:     /*
1:ca83305:      * percentage of in-flight messages above which optimize message store is disabled
1:ca83305:      */
1:ca83305:     private int optimizeMessageStoreInFlightLimit = 10;
1:266d23e:     private boolean persistJMSRedelivered = false;
1:6da08b2:     private int sendFailIfNoSpace = -1;
1:6da08b2:     private long sendFailIfNoSpaceAfterTimeout = -1;
1:d55a392: 
1:d55a392: 
1:23cda2d:     public void configure(Broker broker,Queue queue) {
1:1a5ad28:         baseConfiguration(broker,queue);
1:230a86c:         if (dispatchPolicy != null) {
1:d29ca2a:             queue.setDispatchPolicy(dispatchPolicy);
1:95e6d60:         }
1:c6a485f:         queue.setDeadLetterStrategy(getDeadLetterStrategy());
1:e7e15b5:         queue.setMessageGroupMapFactory(getMessageGroupMapFactory());
1:e8ea6cd:         if (memoryLimit > 0) {
1:83c3dca:             queue.getMemoryUsage().setLimit(memoryLimit);
1:a2af47b:         }
1:230a86c:         if (pendingQueuePolicy != null) {
1:23cda2d:             PendingMessageCursor messages = pendingQueuePolicy.getQueuePendingMessageCursor(broker,queue);
1:3a9299b:             queue.setMessages(messages);
1:36722d8:         }
1:c1da3ac: 
1:e8ea6cd:         queue.setUseConsumerPriority(isUseConsumerPriority());
1:e8ea6cd:         queue.setStrictOrderDispatch(isStrictOrderDispatch());
1:e8ea6cd:         queue.setOptimizedDispatch(isOptimizedDispatch());
1:e8ea6cd:         queue.setLazyDispatch(isLazyDispatch());
1:e8ea6cd:         queue.setTimeBeforeDispatchStarts(getTimeBeforeDispatchStarts());
1:e8ea6cd:         queue.setConsumersBeforeDispatchStarts(getConsumersBeforeDispatchStarts());
1:e8ea6cd:         queue.setAllConsumersExclusiveByDefault(isAllConsumersExclusiveByDefault());
1:75eb814:         queue.setPersistJMSRedelivered(isPersistJMSRedelivered());
1:36722d8:     }
1:37ede54: 
1:e8ea6cd:     public void update(Queue queue) {
1:a253ad3:         update(queue, null);
1:a253ad3:     }
1:a253ad3: 
1:a253ad3:     /**
1:a253ad3:      * Update a queue with this policy.  Only apply properties that
1:a253ad3:      * match the includedProperties list.  Not all properties are eligible
1:a253ad3:      * to be updated.
1:a253ad3:      *
1:a253ad3:      * If includedProperties is null then all of the properties will be set as
1:a253ad3:      * isUpdate will return true
1:6da08b2:      * @param queue
1:a253ad3:      * @param includedProperties
1:a253ad3:      */
1:a253ad3:     public void update(Queue queue, Set<String> includedProperties) {
1:a253ad3:         baseUpdate(queue, includedProperties);
1:a253ad3:         if (isUpdate("memoryLimit", includedProperties) && memoryLimit > 0) {
1:e8ea6cd:             queue.getMemoryUsage().setLimit(memoryLimit);
1:e8ea6cd:         }
1:a253ad3:         if (isUpdate("useConsumerPriority", includedProperties)) {
1:a253ad3:             queue.setUseConsumerPriority(isUseConsumerPriority());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("strictOrderDispatch", includedProperties)) {
1:a253ad3:             queue.setStrictOrderDispatch(isStrictOrderDispatch());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("optimizedDispatch", includedProperties)) {
1:a253ad3:             queue.setOptimizedDispatch(isOptimizedDispatch());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("lazyDispatch", includedProperties)) {
1:a253ad3:             queue.setLazyDispatch(isLazyDispatch());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("timeBeforeDispatchStarts", includedProperties)) {
1:a253ad3:             queue.setTimeBeforeDispatchStarts(getTimeBeforeDispatchStarts());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("consumersBeforeDispatchStarts", includedProperties)) {
1:a253ad3:             queue.setConsumersBeforeDispatchStarts(getConsumersBeforeDispatchStarts());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("allConsumersExclusiveByDefault", includedProperties)) {
1:a253ad3:             queue.setAllConsumersExclusiveByDefault(isAllConsumersExclusiveByDefault());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("persistJMSRedelivered", includedProperties)) {
1:a253ad3:             queue.setPersistJMSRedelivered(isPersistJMSRedelivered());
1:a253ad3:         }
1:e8ea6cd:     }
1:e8ea6cd: 
1:1a5ad28:     public void configure(Broker broker,Topic topic) {
1:1a5ad28:         baseConfiguration(broker,topic);
1:230a86c:         if (dispatchPolicy != null) {
1:d29ca2a:             topic.setDispatchPolicy(dispatchPolicy);
1:d29ca2a:         }
1:c6a485f:         topic.setDeadLetterStrategy(getDeadLetterStrategy());
1:230a86c:         if (subscriptionRecoveryPolicy != null) {
1:1a5ad28:             SubscriptionRecoveryPolicy srp = subscriptionRecoveryPolicy.copy();
1:1a5ad28:             srp.setBroker(broker);
1:1a5ad28:             topic.setSubscriptionRecoveryPolicy(srp);
1:d29ca2a:         }
1:e8ea6cd:         if (memoryLimit > 0) {
1:83c3dca:             topic.getMemoryUsage().setLimit(memoryLimit);
1:d29ca2a:         }
1:e8ea6cd:         topic.setLazyDispatch(isLazyDispatch());
1:e8ea6cd:     }
1:e8ea6cd: 
1:e8ea6cd:     public void update(Topic topic) {
1:a253ad3:         update(topic, null);
1:a253ad3:     }
1:a253ad3: 
1:a253ad3:     //If includedProperties is null then all of the properties will be set as
1:a253ad3:     //isUpdate will return true
1:a253ad3:     public void update(Topic topic, Set<String> includedProperties) {
1:a253ad3:         baseUpdate(topic, includedProperties);
1:a253ad3:         if (isUpdate("memoryLimit", includedProperties) && memoryLimit > 0) {
1:e8ea6cd:             topic.getMemoryUsage().setLimit(memoryLimit);
1:a253ad3:         }
1:a253ad3:         if (isUpdate("lazyDispatch", includedProperties)) {
1:a253ad3:             topic.setLazyDispatch(isLazyDispatch());
1:e8ea6cd:         }
1:d29ca2a:     }
1:e8ea6cd: 
1:e8ea6cd:     // attributes that can change on the fly
1:e8ea6cd:     public void baseUpdate(BaseDestination destination) {
1:a253ad3:         baseUpdate(destination, null);
1:a253ad3:     }
1:e8ea6cd: 
1:a253ad3:     // attributes that can change on the fly
1:a253ad3:     //If includedProperties is null then all of the properties will be set as
1:a253ad3:     //isUpdate will return true
1:a253ad3:     public void baseUpdate(BaseDestination destination, Set<String> includedProperties) {
1:a253ad3:         if (isUpdate("producerFlowControl", includedProperties)) {
1:a253ad3:             destination.setProducerFlowControl(isProducerFlowControl());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("alwaysRetroactive", includedProperties)) {
1:a253ad3:             destination.setAlwaysRetroactive(isAlwaysRetroactive());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("blockedProducerWarningInterval", includedProperties)) {
1:a253ad3:             destination.setBlockedProducerWarningInterval(getBlockedProducerWarningInterval());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("maxPageSize", includedProperties)) {
1:a253ad3:             destination.setMaxPageSize(getMaxPageSize());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("maxBrowsePageSize", includedProperties)) {
1:a253ad3:             destination.setMaxBrowsePageSize(getMaxBrowsePageSize());
1:a253ad3:         }
1:e8ea6cd: 
1:a253ad3:         if (isUpdate("minimumMessageSize", includedProperties)) {
1:a253ad3:             destination.setMinimumMessageSize((int) getMinimumMessageSize());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("maxExpirePageSize", includedProperties)) {
1:a253ad3:             destination.setMaxExpirePageSize(getMaxExpirePageSize());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("cursorMemoryHighWaterMark", includedProperties)) {
1:a253ad3:             destination.setCursorMemoryHighWaterMark(getCursorMemoryHighWaterMark());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("storeUsageHighWaterMark", includedProperties)) {
1:a253ad3:             destination.setStoreUsageHighWaterMark(getStoreUsageHighWaterMark());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("gcInactiveDestinations", includedProperties)) {
1:a253ad3:             destination.setGcIfInactive(isGcInactiveDestinations());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("gcWithNetworkConsumers", includedProperties)) {
1:a253ad3:             destination.setGcWithNetworkConsumers(isGcWithNetworkConsumers());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("inactiveTimeoutBeforeGc", includedProperties)) {
1:a253ad3:             destination.setInactiveTimeoutBeforeGC(getInactiveTimeoutBeforeGC());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("reduceMemoryFootprint", includedProperties)) {
1:a253ad3:             destination.setReduceMemoryFootprint(isReduceMemoryFootprint());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("doOptimizeMessageStore", includedProperties)) {
1:a253ad3:             destination.setDoOptimzeMessageStorage(isDoOptimzeMessageStorage());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("optimizeMessageStoreInFlightLimit", includedProperties)) {
1:a253ad3:             destination.setOptimizeMessageStoreInFlightLimit(getOptimizeMessageStoreInFlightLimit());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("advisoryForConsumed", includedProperties)) {
1:a253ad3:             destination.setAdvisoryForConsumed(isAdvisoryForConsumed());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("advisoryForDelivery", includedProperties)) {
1:a253ad3:             destination.setAdvisoryForDelivery(isAdvisoryForDelivery());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("advisoryForDiscardingMessages", includedProperties)) {
1:a253ad3:             destination.setAdvisoryForDiscardingMessages(isAdvisoryForDiscardingMessages());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("advisoryForSlowConsumers", includedProperties)) {
1:a253ad3:             destination.setAdvisoryForSlowConsumers(isAdvisoryForSlowConsumers());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("advisoryForFastProducers", includedProperties)) {
1:a253ad3:             destination.setAdvisoryForFastProducers(isAdvisoryForFastProducers());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("advisoryWhenFull", includedProperties)) {
1:a253ad3:             destination.setAdvisoryWhenFull(isAdvisoryWhenFull());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("includeBodyForAdvisory", includedProperties)) {
1:a253ad3:             destination.setIncludeBodyForAdvisory(isIncludeBodyForAdvisory());
1:a253ad3:         }
1:a253ad3:         if (isUpdate("sendAdvisoryIfNoConsumers", includedProperties)) {
1:a253ad3:             destination.setSendAdvisoryIfNoConsumers(isSendAdvisoryIfNoConsumers());
1:a253ad3:         }
1:e8ea6cd:     }
1:e8ea6cd: 
1:e8ea6cd:     public void baseConfiguration(Broker broker, BaseDestination destination) {
1:e8ea6cd:         baseUpdate(destination);
1:e8ea6cd:         destination.setEnableAudit(isEnableAudit());
1:e8ea6cd:         destination.setMaxAuditDepth(getMaxQueueAuditDepth());
1:e8ea6cd:         destination.setMaxProducersToAudit(getMaxProducersToAudit());
1:e8ea6cd:         destination.setUseCache(isUseCache());
1:c6a485f:         destination.setExpireMessagesPeriod(getExpireMessagesPeriod());
1:1a5ad28:         SlowConsumerStrategy scs = getSlowConsumerStrategy();
1:1a5ad28:         if (scs != null) {
1:383d12e:             scs.setBrokerService(broker);
1:2b99f39:             scs.addDestination(destination);
1:d29ca2a:         }
1:1a5ad28:         destination.setSlowConsumerStrategy(scs);
1:00879cf:         destination.setPrioritizedMessages(isPrioritizedMessages());
1:6da08b2:         if (sendFailIfNoSpace != -1) {
1:6da08b2:             destination.getSystemUsage().setSendFailIfNoSpace(isSendFailIfNoSpace());
1:6da08b2:         }
1:8e576be:         if (sendFailIfNoSpaceAfterTimeout != -1) {
1:6da08b2:             destination.getSystemUsage().setSendFailIfNoSpaceAfterTimeout(getSendFailIfNoSpaceAfterTimeout());
1:6da08b2:         }
1:d29ca2a:     }
1:e8ea6cd: 
1:6d8e2c5:     public void configure(Broker broker, SystemUsage memoryManager, TopicSubscription subscription) {
1:bc45bf8:         configurePrefetch(subscription);
1:687badb:         subscription.setUsePrefetchExtension(isUsePrefetchExtension());
1:078f39f:         subscription.setCursorMemoryHighWaterMark(getCursorMemoryHighWaterMark());
1:65b0f2a:         subscription.setUseTopicSubscriptionInflightStats(isUseTopicSubscriptionInflightStats());
1:230a86c:         if (pendingMessageLimitStrategy != null) {
1:230a86c:             int value = pendingMessageLimitStrategy.getMaximumPendingMessageLimit(subscription);
1:230a86c:             int consumerLimit = subscription.getInfo().getMaximumPendingMessageLimit();
1:230a86c:             if (consumerLimit > 0) {
1:230a86c:                 if (value < 0 || consumerLimit < value) {
1:230a86c:                     value = consumerLimit;
1:1a5ad28:                 }
1:fc63a92:             }
1:230a86c:             if (value >= 0) {
1:e1bbde7:                 LOG.debug("Setting the maximumPendingMessages size to: {} for consumer: {}", value, subscription.getInfo().getConsumerId());
1:95d0dec:                 subscription.setMaximumPendingMessages(value);
1:fc63a92:             }
1:fc63a92:         }
1:230a86c:         if (messageEvictionStrategy != null) {
1:062dc56:             subscription.setMessageEvictionStrategy(messageEvictionStrategy);
1:47cfa55:         }
1:230a86c:         if (pendingSubscriberPolicy != null) {
1:0c0be94:             String name = subscription.getContext().getClientId() + "_" + subscription.getConsumerInfo().getConsumerId();
1:0c0be94:             int maxBatchSize = subscription.getConsumerInfo().getPrefetchSize();
1:00879cf:             subscription.setMatched(pendingSubscriberPolicy.getSubscriberPendingMessageCursor(broker,name, maxBatchSize,subscription));
1:fc63a92:         }
1:eb983f7:         if (enableAudit) {
1:eb983f7:             subscription.setEnableAudit(enableAudit);
1:eb983f7:             subscription.setMaxProducersToAudit(maxProducersToAudit);
1:eb983f7:             subscription.setMaxAuditDepth(maxAuditDepth);
1:eb983f7:         }
1:47cfa55:     }
1:37ede54: 
1:6d8e2c5:     public void configure(Broker broker, SystemUsage memoryManager, DurableTopicSubscription sub) {
1:23cda2d:         String clientId = sub.getSubscriptionKey().getClientId();
1:23cda2d:         String subName = sub.getSubscriptionKey().getSubscriptionName();
1:785454a:         sub.setCursorMemoryHighWaterMark(getCursorMemoryHighWaterMark());
1:bc45bf8:         configurePrefetch(sub);
1:230a86c:         if (pendingDurableSubscriberPolicy != null) {
1:6519c3e:             PendingMessageCursor cursor = pendingDurableSubscriberPolicy.getSubscriberPendingMessageCursor(broker,clientId, subName,sub.getPrefetchSize(),sub);
1:6d8e2c5:             cursor.setSystemUsage(memoryManager);
1:0c0be94:             sub.setPending(cursor);
1:cdc2fd3:         }
1:3ddb71c:         int auditDepth = getMaxAuditDepth();
1:3ddb71c:         if (auditDepth == BaseDestination.MAX_AUDIT_DEPTH && this.isPrioritizedMessages()) {
1:3ddb71c:             sub.setMaxAuditDepth(auditDepth * 10);
1:3ddb71c:         } else {
1:3ddb71c:             sub.setMaxAuditDepth(auditDepth);
1:3ddb71c:         }
1:37ede54:         sub.setMaxProducersToAudit(getMaxProducersToAudit());
1:6a73c40:         sub.setUsePrefetchExtension(isUsePrefetchExtension());
1:fc63a92:     }
1:1f5694e: 
1:fc63a92:     public void configure(Broker broker, SystemUsage memoryManager, QueueBrowserSubscription sub) {
1:bc45bf8:         configurePrefetch(sub);
1:785454a:         sub.setCursorMemoryHighWaterMark(getCursorMemoryHighWaterMark());
1:6a73c40:         sub.setUsePrefetchExtension(isUsePrefetchExtension());
1:37ede54: 
1:1f5694e:         // TODO
1:1f5694e:         // We currently need an infinite audit because of the way that browser dispatch
1:1f5694e:         // is done.  We should refactor the browsers to better handle message dispatch so
1:1f5694e:         // we can remove this and perform a more efficient dispatch.
1:1f5694e:         sub.setMaxProducersToAudit(Integer.MAX_VALUE);
1:d97f28c:         sub.setMaxAuditDepth(Short.MAX_VALUE);
1:85bc9ce: 
1:85bc9ce:         // part solution - dispatching to browsers needs to be restricted
1:85bc9ce:         sub.setMaxMessages(getMaxBrowsePageSize());
1:fc63a92:     }
1:37ede54: 
1:fc63a92:     public void configure(Broker broker, SystemUsage memoryManager, QueueSubscription sub) {
1:bc45bf8:         configurePrefetch(sub);
1:785454a:         sub.setCursorMemoryHighWaterMark(getCursorMemoryHighWaterMark());
1:6a73c40:         sub.setUsePrefetchExtension(isUsePrefetchExtension());
1:37ede54:         sub.setMaxProducersToAudit(getMaxProducersToAudit());
1:fc63a92:     }
1:37ede54: 
1:bc45bf8:     public void configurePrefetch(Subscription subscription) {
1:bc45bf8: 
1:bc45bf8:         final int currentPrefetch = subscription.getConsumerInfo().getPrefetchSize();
1:bc45bf8:         if (subscription instanceof QueueBrowserSubscription) {
1:bc45bf8:             if (currentPrefetch == ActiveMQPrefetchPolicy.DEFAULT_QUEUE_BROWSER_PREFETCH) {
1:bc45bf8:                 ((QueueBrowserSubscription) subscription).setPrefetchSize(getQueueBrowserPrefetch());
1:bc45bf8:             }
1:bc45bf8:         } else if (subscription instanceof QueueSubscription) {
1:bc45bf8:             if (currentPrefetch == ActiveMQPrefetchPolicy.DEFAULT_QUEUE_PREFETCH) {
1:bc45bf8:                 ((QueueSubscription) subscription).setPrefetchSize(getQueuePrefetch());
1:bc45bf8:             }
1:bc45bf8:         } else if (subscription instanceof DurableTopicSubscription) {
1:bc45bf8:             if (currentPrefetch == ActiveMQPrefetchPolicy.DEFAULT_DURABLE_TOPIC_PREFETCH ||
1:bc45bf8:                     subscription.getConsumerInfo().getPrefetchSize() == ActiveMQPrefetchPolicy.DEFAULT_OPTIMIZE_DURABLE_TOPIC_PREFETCH) {
1:bc45bf8:                 ((DurableTopicSubscription)subscription).setPrefetchSize(getDurableTopicPrefetch());
1:bc45bf8:             }
1:bc45bf8:         } else if (subscription instanceof TopicSubscription) {
1:bc45bf8:             if (currentPrefetch == ActiveMQPrefetchPolicy.DEFAULT_TOPIC_PREFETCH) {
1:bc45bf8:                 ((TopicSubscription) subscription).setPrefetchSize(getTopicPrefetch());
1:bc45bf8:             }
1:bc45bf8:         }
1:bc45bf8:         if (currentPrefetch != 0 && subscription.getPrefetchSize() == 0) {
1:bc45bf8:             // tell the sub so that it can issue a pull request
1:bc45bf8:             subscription.updateConsumerPrefetch(0);
1:bc45bf8:         }
1:bc45bf8:     }
1:bc45bf8: 
1:a253ad3:     private boolean isUpdate(String property, Set<String> includedProperties) {
1:a253ad3:         return includedProperties == null || includedProperties.contains(property);
1:a253ad3:     }
1:d29ca2a:     // Properties
1:d29ca2a:     // -------------------------------------------------------------------------
1:230a86c:     public DispatchPolicy getDispatchPolicy() {
1:d29ca2a:         return dispatchPolicy;
1:d29ca2a:     }
1:37ede54: 
1:230a86c:     public void setDispatchPolicy(DispatchPolicy policy) {
1:230a86c:         this.dispatchPolicy = policy;
1:d29ca2a:     }
1:37ede54: 
1:230a86c:     public SubscriptionRecoveryPolicy getSubscriptionRecoveryPolicy() {
1:d29ca2a:         return subscriptionRecoveryPolicy;
1:d29ca2a:     }
1:37ede54: 
1:230a86c:     public void setSubscriptionRecoveryPolicy(SubscriptionRecoveryPolicy subscriptionRecoveryPolicy) {
1:230a86c:         this.subscriptionRecoveryPolicy = subscriptionRecoveryPolicy;
1:d29ca2a:     }
1:37ede54: 
1:230a86c:     public boolean isSendAdvisoryIfNoConsumers() {
1:c2408b8:         return sendAdvisoryIfNoConsumers;
1:d29ca2a:     }
1:37ede54: 
1:6d0c552:     /**
1:230a86c:      * Sends an advisory message if a non-persistent message is sent and there
1:230a86c:      * are no active consumers
1:3a9299b:      */
1:230a86c:     public void setSendAdvisoryIfNoConsumers(boolean sendAdvisoryIfNoConsumers) {
1:230a86c:         this.sendAdvisoryIfNoConsumers = sendAdvisoryIfNoConsumers;
1:d29ca2a:     }
1:d29ca2a: 
1:230a86c:     public DeadLetterStrategy getDeadLetterStrategy() {
1:88203ae:         return deadLetterStrategy;
1:0c0be94:     }
1:d29ca2a: 
1:3a9299b:     /**
1:230a86c:      * Sets the policy used to determine which dead letter queue destination
1:230a86c:      * should be used
1:3a9299b:      */
1:230a86c:     public void setDeadLetterStrategy(DeadLetterStrategy deadLetterStrategy) {
1:230a86c:         this.deadLetterStrategy = deadLetterStrategy;
1:0c0be94:     }
1:d29ca2a: 
1:230a86c:     public PendingMessageLimitStrategy getPendingMessageLimitStrategy() {
1:95d0dec:         return pendingMessageLimitStrategy;
1:0c0be94:     }
1:d29ca2a: 
1:3a9299b:     /**
1:230a86c:      * Sets the strategy to calculate the maximum number of messages that are
1:230a86c:      * allowed to be pending on consumers (in addition to their prefetch sizes).
1:230a86c:      * Once the limit is reached, non-durable topics can then start discarding
1:230a86c:      * old messages. This allows us to keep dispatching messages to slow
1:230a86c:      * consumers while not blocking fast consumers and discarding the messages
1:230a86c:      * oldest first.
1:95d0dec:      */
1:230a86c:     public void setPendingMessageLimitStrategy(PendingMessageLimitStrategy pendingMessageLimitStrategy) {
1:230a86c:         this.pendingMessageLimitStrategy = pendingMessageLimitStrategy;
1:3a9299b:     }
1:d29ca2a: 
1:230a86c:     public MessageEvictionStrategy getMessageEvictionStrategy() {
1:062dc56:         return messageEvictionStrategy;
1:3a9299b:     }
1:d29ca2a: 
1:062dc56:     /**
1:230a86c:      * Sets the eviction strategy used to decide which message to evict when the
1:230a86c:      * slow consumer needs to discard messages
1:062dc56:      */
1:230a86c:     public void setMessageEvictionStrategy(MessageEvictionStrategy messageEvictionStrategy) {
1:230a86c:         this.messageEvictionStrategy = messageEvictionStrategy;
1:3a9299b:     }
1:d29ca2a: 
1:230a86c:     public long getMemoryLimit() {
1:36722d8:         return memoryLimit;
1:36722d8:     }
1:36722d8: 
1:ac66a09:     /**
1:356c39d:      * When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used
1:ac66a09:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.MemoryPropertyEditor"
1:ac66a09:      */
1:230a86c:     public void setMemoryLimit(long memoryLimit) {
1:230a86c:         this.memoryLimit = memoryLimit;
1:36722d8:     }
1:36722d8: 
1:230a86c:     public MessageGroupMapFactory getMessageGroupMapFactory() {
1:230a86c:         if (messageGroupMapFactory == null) {
1:468e697:             try {
1:468e697:             messageGroupMapFactory = GroupFactoryFinder.createMessageGroupMapFactory(getMessageGroupMapFactoryType());
1:468e697:             }catch(Exception e){
1:468e697:                 LOG.error("Failed to create message group Factory ",e);
1:468e697:             }
1:a321204:         }
1:e7e15b5:         return messageGroupMapFactory;
1:a321204:     }
1:d29ca2a: 
1:e7e15b5:     /**
1:230a86c:      * Sets the factory used to create new instances of {MessageGroupMap} used
1:230a86c:      * to implement the <a
1:230a86c:      * href="http://activemq.apache.org/message-groups.html">Message Groups</a>
1:230a86c:      * functionality.
1:6d0c552:      */
1:230a86c:     public void setMessageGroupMapFactory(MessageGroupMapFactory messageGroupMapFactory) {
1:230a86c:         this.messageGroupMapFactory = messageGroupMapFactory;
1:a321204:     }
1:468e697: 
1:d29ca2a: 
1:468e697:     public String getMessageGroupMapFactoryType() {
1:468e697:         return messageGroupMapFactoryType;
1:468e697:     }
1:468e697: 
1:468e697:     public void setMessageGroupMapFactoryType(String messageGroupMapFactoryType) {
1:468e697:         this.messageGroupMapFactoryType = messageGroupMapFactoryType;
1:468e697:     }
1:468e697: 
1:468e697: 
1:95d0dec:     /**
1:0c0be94:      * @return the pendingDurableSubscriberPolicy
1:e7e15b5:      */
1:230a86c:     public PendingDurableSubscriberMessageStoragePolicy getPendingDurableSubscriberPolicy() {
1:0c0be94:         return this.pendingDurableSubscriberPolicy;
2:e7e15b5:     }
1:d29ca2a: 
1:0c0be94:     /**
1:230a86c:      * @param pendingDurableSubscriberPolicy the pendingDurableSubscriberPolicy
1:230a86c:      *                to set
1:d7f9146:      */
1:230a86c:     public void setPendingDurableSubscriberPolicy(PendingDurableSubscriberMessageStoragePolicy pendingDurableSubscriberPolicy) {
1:230a86c:         this.pendingDurableSubscriberPolicy = pendingDurableSubscriberPolicy;
1:e7e15b5:     }
1:ca83305: 
1:d7f9146:     /**
1:0c0be94:      * @return the pendingQueuePolicy
1:0c0be94:      */
1:230a86c:     public PendingQueueMessageStoragePolicy getPendingQueuePolicy() {
1:0c0be94:         return this.pendingQueuePolicy;
1:0c0be94:     }
1:00879cf: 
1:0c0be94:     /**
1:0c0be94:      * @param pendingQueuePolicy the pendingQueuePolicy to set
1:0c0be94:      */
1:230a86c:     public void setPendingQueuePolicy(PendingQueueMessageStoragePolicy pendingQueuePolicy) {
1:230a86c:         this.pendingQueuePolicy = pendingQueuePolicy;
1:0c0be94:     }
1:00879cf: 
1:0c0be94:     /**
1:0c0be94:      * @return the pendingSubscriberPolicy
1:0c0be94:      */
1:230a86c:     public PendingSubscriberMessageStoragePolicy getPendingSubscriberPolicy() {
1:0c0be94:         return this.pendingSubscriberPolicy;
1:0c0be94:     }
1:785454a: 
1:0c0be94:     /**
1:0c0be94:      * @param pendingSubscriberPolicy the pendingSubscriberPolicy to set
1:0c0be94:      */
1:230a86c:     public void setPendingSubscriberPolicy(PendingSubscriberMessageStoragePolicy pendingSubscriberPolicy) {
1:230a86c:         this.pendingSubscriberPolicy = pendingSubscriberPolicy;
1:0c0be94:     }
1:fc63a92: 
1:1ee0017:     /**
1:1ee0017:      * @return true if producer flow control enabled
1:1ee0017:      */
1:0da68b4:     public boolean isProducerFlowControl() {
1:0da68b4:         return producerFlowControl;
1:0da68b4:     }
1:fc63a92: 
1:1ee0017:     /**
1:1ee0017:      * @param producerFlowControl
1:1ee0017:      */
1:0da68b4:     public void setProducerFlowControl(boolean producerFlowControl) {
1:0da68b4:         this.producerFlowControl = producerFlowControl;
1:0da68b4:     }
1:fc63a92: 
1:1ee0017:     /**
1:fe63c29:      * @return true if topic is always retroactive
1:fe63c29:      */
1:fe63c29:     public boolean isAlwaysRetroactive() {
1:fe63c29:         return alwaysRetroactive;
1:fe63c29:     }
1:fe63c29: 
1:fe63c29:     /**
1:fe63c29:      * @param alwaysRetroactive
1:fe63c29:      */
1:fe63c29:     public void setAlwaysRetroactive(boolean alwaysRetroactive) {
1:fe63c29:         this.alwaysRetroactive = alwaysRetroactive;
1:fe63c29:     }
1:fe63c29: 
1:fe63c29: 
1:fe63c29:     /**
1:48764be:      * Set's the interval at which warnings about producers being blocked by
1:48764be:      * resource usage will be triggered. Values of 0 or less will disable
1:48764be:      * warnings
1:37ede54:      *
1:48764be:      * @param blockedProducerWarningInterval the interval at which warning about
1:48764be:      *            blocked producers will be triggered.
1:48764be:      */
1:48764be:     public void setBlockedProducerWarningInterval(long blockedProducerWarningInterval) {
1:48764be:         this.blockedProducerWarningInterval = blockedProducerWarningInterval;
1:48764be:     }
1:fc63a92: 
1:48764be:     /**
1:37ede54:      *
1:48764be:      * @return the interval at which warning about blocked producers will be
1:48764be:      *         triggered.
1:48764be:      */
1:48764be:     public long getBlockedProducerWarningInterval() {
1:48764be:         return blockedProducerWarningInterval;
1:48764be:     }
1:37ede54: 
1:48764be:     /**
1:1ee0017:      * @return the maxProducersToAudit
1:1ee0017:      */
1:1ee0017:     public int getMaxProducersToAudit() {
1:1ee0017:         return maxProducersToAudit;
1:1ee0017:     }
1:fc63a92: 
1:1ee0017:     /**
1:1ee0017:      * @param maxProducersToAudit the maxProducersToAudit to set
1:1ee0017:      */
1:1ee0017:     public void setMaxProducersToAudit(int maxProducersToAudit) {
1:1ee0017:         this.maxProducersToAudit = maxProducersToAudit;
1:1ee0017:     }
1:fc63a92: 
1:1ee0017:     /**
1:1ee0017:      * @return the maxAuditDepth
1:1ee0017:      */
1:1ee0017:     public int getMaxAuditDepth() {
1:1ee0017:         return maxAuditDepth;
1:1ee0017:     }
1:fc63a92: 
1:1ee0017:     /**
1:1ee0017:      * @param maxAuditDepth the maxAuditDepth to set
1:1ee0017:      */
1:1ee0017:     public void setMaxAuditDepth(int maxAuditDepth) {
1:1ee0017:         this.maxAuditDepth = maxAuditDepth;
1:1ee0017:     }
1:fc63a92: 
1:1ee0017:     /**
1:1ee0017:      * @return the enableAudit
1:1ee0017:      */
1:1ee0017:     public boolean isEnableAudit() {
1:1ee0017:         return enableAudit;
1:1ee0017:     }
1:fc63a92: 
1:1ee0017:     /**
1:1ee0017:      * @param enableAudit the enableAudit to set
1:1ee0017:      */
1:1ee0017:     public void setEnableAudit(boolean enableAudit) {
1:1ee0017:         this.enableAudit = enableAudit;
1:1ee0017:     }
1:fc63a92: 
1:9dd11cb:     public int getMaxQueueAuditDepth() {
1:9dd11cb:         return maxQueueAuditDepth;
1:9dd11cb:     }
1:47cfa55: 
1:9dd11cb:     public void setMaxQueueAuditDepth(int maxQueueAuditDepth) {
1:9dd11cb:         this.maxQueueAuditDepth = maxQueueAuditDepth;
1:9dd11cb:     }
1:cdc2fd3: 
1:9dd11cb:     public boolean isOptimizedDispatch() {
1:9dd11cb:         return optimizedDispatch;
1:9dd11cb:     }
1:cdc2fd3: 
1:9dd11cb:     public void setOptimizedDispatch(boolean optimizedDispatch) {
1:9dd11cb:         this.optimizedDispatch = optimizedDispatch;
1:9dd11cb:     }
1:37ede54: 
1:d0f3d4d:     public int getMaxPageSize() {
1:d0f3d4d:         return maxPageSize;
1:d0f3d4d:     }
1:cdc2fd3: 
1:d0f3d4d:     public void setMaxPageSize(int maxPageSize) {
1:d0f3d4d:         this.maxPageSize = maxPageSize;
1:37ede54:     }
1:37ede54: 
1:47cfa55:     public int getMaxBrowsePageSize() {
1:47cfa55:         return maxBrowsePageSize;
1:47cfa55:     }
1:47cfa55: 
1:47cfa55:     public void setMaxBrowsePageSize(int maxPageSize) {
1:47cfa55:         this.maxBrowsePageSize = maxPageSize;
1:37ede54:     }
1:37ede54: 
1:6d0c552:     public boolean isUseCache() {
1:6d0c552:         return useCache;
1:6d0c552:     }
1:6d0c552: 
1:6d0c552:     public void setUseCache(boolean useCache) {
1:6d0c552:         this.useCache = useCache;
1:6d0c552:     }
1:6d0c552: 
1:6d0c552:     public long getMinimumMessageSize() {
1:6d0c552:         return minimumMessageSize;
1:2a153b0:     }
1:2a153b0: 
1:6d0c552:     public void setMinimumMessageSize(long minimumMessageSize) {
1:6d0c552:         this.minimumMessageSize = minimumMessageSize;
1:37ede54:     }
1:37ede54: 
1:2a153b0:     public boolean isUseConsumerPriority() {
1:2a153b0:         return useConsumerPriority;
1:2a153b0:     }
1:2a153b0: 
1:2a153b0:     public void setUseConsumerPriority(boolean useConsumerPriority) {
1:2a153b0:         this.useConsumerPriority = useConsumerPriority;
1:2a153b0:     }
1:2a153b0: 
1:2a153b0:     public boolean isStrictOrderDispatch() {
1:2a153b0:         return strictOrderDispatch;
1:2a153b0:     }
1:2a153b0: 
1:2a153b0:     public void setStrictOrderDispatch(boolean strictOrderDispatch) {
1:2a153b0:         this.strictOrderDispatch = strictOrderDispatch;
1:2a153b0:     }
1:6d0c552: 
1:044c07d:     public boolean isLazyDispatch() {
1:044c07d:         return lazyDispatch;
1:044c07d:     }
1:044c07d: 
1:044c07d:     public void setLazyDispatch(boolean lazyDispatch) {
1:044c07d:         this.lazyDispatch = lazyDispatch;
1:044c07d:     }
1:cdc2fd3: 
1:a321204:     public int getTimeBeforeDispatchStarts() {
1:a321204:         return timeBeforeDispatchStarts;
1:6d0c552:     }
1:044c07d: 
1:a321204:     public void setTimeBeforeDispatchStarts(int timeBeforeDispatchStarts) {
1:a321204:         this.timeBeforeDispatchStarts = timeBeforeDispatchStarts;
1:6d0c552:     }
1:6d0c552: 
1:a321204:     public int getConsumersBeforeDispatchStarts() {
1:a321204:         return consumersBeforeDispatchStarts;
1:d0f3d4d:     }
1:d0f3d4d: 
1:a321204:     public void setConsumersBeforeDispatchStarts(int consumersBeforeDispatchStarts) {
1:a321204:         this.consumersBeforeDispatchStarts = consumersBeforeDispatchStarts;
1:a321204:     }
1:d0f3d4d: 
1:cdc2fd3:     /**
1:cdc2fd3:      * @return the advisoryForSlowConsumers
1:cdc2fd3:      */
1:cdc2fd3:     public boolean isAdvisoryForSlowConsumers() {
1:cdc2fd3:         return advisoryForSlowConsumers;
1:cdc2fd3:     }
1:cdc2fd3: 
1:cdc2fd3:     /**
1:cdc2fd3:      * @param advisoryForSlowConsumers the advisoryForSlowConsumers to set
1:cdc2fd3:      */
1:cdc2fd3:     public void setAdvisoryForSlowConsumers(boolean advisoryForSlowConsumers) {
1:cdc2fd3:         this.advisoryForSlowConsumers = advisoryForSlowConsumers;
1:cdc2fd3:     }
1:cdc2fd3: 
1:cdc2fd3:     /**
1:cdc2fd3:      * @return the advisoryForDiscardingMessages
1:cdc2fd3:      */
1:cdc2fd3:     public boolean isAdvisoryForDiscardingMessages() {
1:cdc2fd3:         return advisoryForDiscardingMessages;
1:cdc2fd3:     }
1:cdc2fd3: 
1:cdc2fd3:     /**
1:cdc2fd3:      * @param advisoryForDiscardingMessages the advisoryForDiscardingMessages to set
1:cdc2fd3:      */
1:cdc2fd3:     public void setAdvisoryForDiscardingMessages(
1:cdc2fd3:             boolean advisoryForDiscardingMessages) {
1:cdc2fd3:         this.advisoryForDiscardingMessages = advisoryForDiscardingMessages;
1:cdc2fd3:     }
1:cdc2fd3: 
1:cdc2fd3:     /**
1:cdc2fd3:      * @return the advisoryWhenFull
1:cdc2fd3:      */
1:cdc2fd3:     public boolean isAdvisoryWhenFull() {
1:cdc2fd3:         return advisoryWhenFull;
1:cdc2fd3:     }
1:cdc2fd3: 
1:cdc2fd3:     /**
1:cdc2fd3:      * @param advisoryWhenFull the advisoryWhenFull to set
1:cdc2fd3:      */
1:cdc2fd3:     public void setAdvisoryWhenFull(boolean advisoryWhenFull) {
1:cdc2fd3:         this.advisoryWhenFull = advisoryWhenFull;
1:cdc2fd3:     }
1:cdc2fd3: 
1:cdc2fd3:     /**
1:cdc2fd3:      * @return the advisoryForDelivery
1:cdc2fd3:      */
1:cdc2fd3:     public boolean isAdvisoryForDelivery() {
1:cdc2fd3:         return advisoryForDelivery;
1:cdc2fd3:     }
1:cdc2fd3: 
1:cdc2fd3:     /**
1:cdc2fd3:      * @param advisoryForDelivery the advisoryForDelivery to set
1:cdc2fd3:      */
1:cdc2fd3:     public void setAdvisoryForDelivery(boolean advisoryForDelivery) {
1:cdc2fd3:         this.advisoryForDelivery = advisoryForDelivery;
1:cdc2fd3:     }
1:cdc2fd3: 
1:cdc2fd3:     /**
1:cdc2fd3:      * @return the advisoryForConsumed
1:cdc2fd3:      */
1:cdc2fd3:     public boolean isAdvisoryForConsumed() {
1:cdc2fd3:         return advisoryForConsumed;
1:cdc2fd3:     }
1:cdc2fd3: 
1:cdc2fd3:     /**
1:cdc2fd3:      * @param advisoryForConsumed the advisoryForConsumed to set
1:cdc2fd3:      */
1:cdc2fd3:     public void setAdvisoryForConsumed(boolean advisoryForConsumed) {
1:cdc2fd3:         this.advisoryForConsumed = advisoryForConsumed;
1:cdc2fd3:     }
1:37ede54: 
1:cdc2fd3:     /**
1:cdc2fd3:      * @return the advisdoryForFastProducers
1:cdc2fd3:      */
1:db1f6fe:     public boolean isAdvisoryForFastProducers() {
1:db1f6fe:         return advisoryForFastProducers;
1:cdc2fd3:     }
1:cdc2fd3: 
1:cdc2fd3:     /**
1:db1f6fe:      * @param advisoryForFastProducers the advisdoryForFastProducers to set
1:cdc2fd3:      */
1:db1f6fe:     public void setAdvisoryForFastProducers(boolean advisoryForFastProducers) {
1:db1f6fe:         this.advisoryForFastProducers = advisoryForFastProducers;
1:cdc2fd3:     }
1:cdc2fd3: 
1:edacc2a:     /**
1:edacc2a:      * Returns true if the original message body should be included when applicable
1:edacc2a:      * for advisory messages
1:edacc2a:      *
1:edacc2a:      * @return
1:edacc2a:      */
1:edacc2a:     public boolean isIncludeBodyForAdvisory() {
1:edacc2a:         return includeBodyForAdvisory;
1:edacc2a:     }
1:edacc2a: 
1:edacc2a:     /**
1:edacc2a:      * Sets if the original message body should be included when applicable
1:edacc2a:      * for advisory messages
1:edacc2a:      *
1:edacc2a:      * @param includeBodyForAdvisory
1:edacc2a:      */
1:edacc2a:     public void setIncludeBodyForAdvisory(boolean includeBodyForAdvisory) {
1:edacc2a:         this.includeBodyForAdvisory = includeBodyForAdvisory;
1:edacc2a:     }
1:edacc2a: 
1:c6a485f:     public void setMaxExpirePageSize(int maxExpirePageSize) {
1:c6a485f:         this.maxExpirePageSize = maxExpirePageSize;
1:c6a485f:     }
1:c6a485f: 
1:c6a485f:     public int getMaxExpirePageSize() {
1:c6a485f:         return maxExpirePageSize;
1:c6a485f:     }
1:c6a485f: 
1:c6a485f:     public void setExpireMessagesPeriod(long expireMessagesPeriod) {
1:c6a485f:         this.expireMessagesPeriod = expireMessagesPeriod;
1:c6a485f:     }
1:c6a485f: 
1:c6a485f:     public long getExpireMessagesPeriod() {
1:c6a485f:         return expireMessagesPeriod;
1:c6a485f:     }
1:c6a485f: 
1:fc63a92:     /**
1:fc63a92:      * Get the queuePrefetch
1:fc63a92:      * @return the queuePrefetch
1:fc63a92:      */
1:fc63a92:     public int getQueuePrefetch() {
1:fc63a92:         return this.queuePrefetch;
1:fc63a92:     }
1:c6a485f: 
1:fc63a92:     /**
1:fc63a92:      * Set the queuePrefetch
1:fc63a92:      * @param queuePrefetch the queuePrefetch to set
1:fc63a92:      */
1:fc63a92:     public void setQueuePrefetch(int queuePrefetch) {
1:fc63a92:         this.queuePrefetch = queuePrefetch;
1:fc63a92:     }
1:37ede54: 
1:fc63a92:     /**
1:fc63a92:      * Get the queueBrowserPrefetch
1:fc63a92:      * @return the queueBrowserPrefetch
1:fc63a92:      */
1:fc63a92:     public int getQueueBrowserPrefetch() {
1:fc63a92:         return this.queueBrowserPrefetch;
1:fc63a92:     }
1:fc63a92: 
1:fc63a92:     /**
1:fc63a92:      * Set the queueBrowserPrefetch
1:fc63a92:      * @param queueBrowserPrefetch the queueBrowserPrefetch to set
1:fc63a92:      */
1:fc63a92:     public void setQueueBrowserPrefetch(int queueBrowserPrefetch) {
1:fc63a92:         this.queueBrowserPrefetch = queueBrowserPrefetch;
1:fc63a92:     }
1:fc63a92: 
1:fc63a92:     /**
1:fc63a92:      * Get the topicPrefetch
1:fc63a92:      * @return the topicPrefetch
1:fc63a92:      */
1:fc63a92:     public int getTopicPrefetch() {
1:fc63a92:         return this.topicPrefetch;
1:fc63a92:     }
1:fc63a92: 
1:fc63a92:     /**
1:fc63a92:      * Set the topicPrefetch
1:fc63a92:      * @param topicPrefetch the topicPrefetch to set
1:fc63a92:      */
1:fc63a92:     public void setTopicPrefetch(int topicPrefetch) {
1:fc63a92:         this.topicPrefetch = topicPrefetch;
1:fc63a92:     }
1:fc63a92: 
1:fc63a92:     /**
1:fc63a92:      * Get the durableTopicPrefetch
1:fc63a92:      * @return the durableTopicPrefetch
1:fc63a92:      */
1:fc63a92:     public int getDurableTopicPrefetch() {
1:fc63a92:         return this.durableTopicPrefetch;
1:fc63a92:     }
1:fc63a92: 
1:fc63a92:     /**
1:fc63a92:      * Set the durableTopicPrefetch
1:fc63a92:      * @param durableTopicPrefetch the durableTopicPrefetch to set
1:fc63a92:      */
1:fc63a92:     public void setDurableTopicPrefetch(int durableTopicPrefetch) {
1:fc63a92:         this.durableTopicPrefetch = durableTopicPrefetch;
1:785454a:     }
1:37ede54: 
1:6a73c40:     public boolean isUsePrefetchExtension() {
1:6a73c40:         return this.usePrefetchExtension;
1:6a73c40:     }
1:785454a: 
1:6a73c40:     public void setUsePrefetchExtension(boolean usePrefetchExtension) {
1:6a73c40:         this.usePrefetchExtension = usePrefetchExtension;
1:6a73c40:     }
1:6a73c40: 
1:6a73c40:     public int getCursorMemoryHighWaterMark() {
1:6a73c40:         return this.cursorMemoryHighWaterMark;
1:6a73c40:     }
1:6a73c40: 
1:6a73c40:     public void setCursorMemoryHighWaterMark(int cursorMemoryHighWaterMark) {
1:6a73c40:         this.cursorMemoryHighWaterMark = cursorMemoryHighWaterMark;
1:37ede54:     }
1:785454a: 
1:a0d2282:     public void setStoreUsageHighWaterMark(int storeUsageHighWaterMark) {
1:a0d2282:         this.storeUsageHighWaterMark = storeUsageHighWaterMark;
1:a0d2282:     }
1:fc63a92: 
1:a0d2282:     public int getStoreUsageHighWaterMark() {
1:a0d2282:         return storeUsageHighWaterMark;
1:a0d2282:     }
1:fc63a92: 
1:1b6d397:     public void setSlowConsumerStrategy(SlowConsumerStrategy slowConsumerStrategy) {
1:1b6d397:         this.slowConsumerStrategy = slowConsumerStrategy;
1:1b6d397:     }
1:1b6d397: 
1:1b6d397:     public SlowConsumerStrategy getSlowConsumerStrategy() {
1:1b6d397:         return this.slowConsumerStrategy;
1:1b6d397:     }
1:1b6d397: 
1:37ede54: 
1:00879cf:     public boolean isPrioritizedMessages() {
1:00879cf:         return this.prioritizedMessages;
1:00879cf:     }
1:37ede54: 
1:00879cf:     public void setPrioritizedMessages(boolean prioritizedMessages) {
1:00879cf:         this.prioritizedMessages = prioritizedMessages;
1:00879cf:     }
1:00879cf: 
1:42ee51f:     public void setAllConsumersExclusiveByDefault(boolean allConsumersExclusiveByDefault) {
1:42ee51f:         this.allConsumersExclusiveByDefault = allConsumersExclusiveByDefault;
1:42ee51f:     }
1:42ee51f: 
1:42ee51f:     public boolean isAllConsumersExclusiveByDefault() {
1:42ee51f:         return allConsumersExclusiveByDefault;
1:42ee51f:     }
1:42ee51f: 
1:70314ea:     public boolean isGcInactiveDestinations() {
1:70314ea:         return this.gcInactiveDestinations;
1:70314ea:     }
1:70314ea: 
1:70314ea:     public void setGcInactiveDestinations(boolean gcInactiveDestinations) {
1:70314ea:         this.gcInactiveDestinations = gcInactiveDestinations;
1:70314ea:     }
1:70314ea: 
1:b9fd189:     /**
1:b9fd189:      * @return the amount of time spent inactive before GC of the destination kicks in.
1:b9fd189:      *
1:b9fd189:      * @deprecated use getInactiveTimeoutBeforeGC instead.
1:b9fd189:      */
1:b9fd189:     @Deprecated
1:70314ea:     public long getInactiveTimoutBeforeGC() {
1:b9fd189:         return getInactiveTimeoutBeforeGC();
1:70314ea:     }
1:70314ea: 
1:b9fd189:     /**
1:b9fd189:      * Sets the amount of time a destination is inactive before it is marked for GC
1:b9fd189:      *
1:b9fd189:      * @param inactiveTimoutBeforeGC
1:b9fd189:      *        time in milliseconds to configure as the inactive timeout.
1:b9fd189:      *
1:b9fd189:      * @deprecated use getInactiveTimeoutBeforeGC instead.
1:b9fd189:      */
1:b9fd189:     @Deprecated
1:70314ea:     public void setInactiveTimoutBeforeGC(long inactiveTimoutBeforeGC) {
1:b9fd189:         setInactiveTimeoutBeforeGC(inactiveTimoutBeforeGC);
1:b9fd189:     }
1:b9fd189: 
1:b9fd189:     /**
1:b9fd189:      * @return the amount of time spent inactive before GC of the destination kicks in.
1:b9fd189:      */
1:b9fd189:     public long getInactiveTimeoutBeforeGC() {
1:b9fd189:         return this.inactiveTimeoutBeforeGC;
1:b9fd189:     }
1:b9fd189: 
1:b9fd189:     /**
1:b9fd189:      * Sets the amount of time a destination is inactive before it is marked for GC
1:b9fd189:      *
1:b9fd189:      * @param inactiveTimoutBeforeGC
1:b9fd189:      *        time in milliseconds to configure as the inactive timeout.
1:b9fd189:      */
1:b9fd189:     public void setInactiveTimeoutBeforeGC(long inactiveTimeoutBeforeGC) {
1:b9fd189:         this.inactiveTimeoutBeforeGC = inactiveTimeoutBeforeGC;
1:70314ea:     }
1:d55a392: 
1:d55a392:     public void setGcWithNetworkConsumers(boolean gcWithNetworkConsumers) {
1:d55a392:         this.gcWithNetworkConsumers = gcWithNetworkConsumers;
1:d55a392:     }
1:d55a392: 
1:d55a392:     public boolean isGcWithNetworkConsumers() {
1:d55a392:         return gcWithNetworkConsumers;
1:d55a392:     }
1:d55a392: 
1:c1da3ac:     public boolean isReduceMemoryFootprint() {
1:c1da3ac:         return reduceMemoryFootprint;
1:c1da3ac:     }
1:70314ea: 
1:c1da3ac:     public void setReduceMemoryFootprint(boolean reduceMemoryFootprint) {
1:c1da3ac:         this.reduceMemoryFootprint = reduceMemoryFootprint;
1:c1da3ac:     }
1:af1b232: 
1:af1b232:     public void setNetworkBridgeFilterFactory(NetworkBridgeFilterFactory networkBridgeFilterFactory) {
1:af1b232:         this.networkBridgeFilterFactory = networkBridgeFilterFactory;
1:af1b232:     }
1:af1b232: 
1:af1b232:     public NetworkBridgeFilterFactory getNetworkBridgeFilterFactory() {
1:af1b232:         return networkBridgeFilterFactory;
1:af1b232:     }
1:f4d4c3b: 
1:f4d4c3b:     public boolean isDoOptimzeMessageStorage() {
1:f4d4c3b:         return doOptimzeMessageStorage;
1:f4d4c3b:     }
1:f4d4c3b: 
1:f4d4c3b:     public void setDoOptimzeMessageStorage(boolean doOptimzeMessageStorage) {
1:f4d4c3b:         this.doOptimzeMessageStorage = doOptimzeMessageStorage;
1:f4d4c3b:     }
1:ca83305: 
1:ca83305:     public int getOptimizeMessageStoreInFlightLimit() {
1:ca83305:         return optimizeMessageStoreInFlightLimit;
1:ca83305:     }
1:ca83305: 
1:ca83305:     public void setOptimizeMessageStoreInFlightLimit(int optimizeMessageStoreInFlightLimit) {
1:ca83305:         this.optimizeMessageStoreInFlightLimit = optimizeMessageStoreInFlightLimit;
1:ca83305:     }
1:e8ea6cd: 
1:266d23e:     public void setPersistJMSRedelivered(boolean val) {
1:266d23e:         this.persistJMSRedelivered = val;
1:266d23e:     }
1:266d23e: 
1:266d23e:     public boolean isPersistJMSRedelivered() {
1:266d23e:         return persistJMSRedelivered;
1:266d23e:     }
1:886e2d4: 
1:886e2d4:     public int getMaxDestinations() {
1:886e2d4:         return maxDestinations;
1:886e2d4:     }
1:886e2d4: 
1:886e2d4:     /**
1:886e2d4:      * Sets the maximum number of destinations that can be created
1:886e2d4:      *
1:886e2d4:      * @param maxDestinations
1:886e2d4:      *            maximum number of destinations
1:886e2d4:      */
1:886e2d4:     public void setMaxDestinations(int maxDestinations) {
1:886e2d4:         this.maxDestinations = maxDestinations;
1:886e2d4:     }
1:886e2d4: 
1:ee4672b:     @Override
1:ee4672b:     public String toString() {
1:ee4672b:         return "PolicyEntry [" + destination + "]";
1:ee4672b:     }
1:6da08b2: 
1:6da08b2:     public void setSendFailIfNoSpace(boolean val) {
1:6da08b2:         if (val) {
1:6da08b2:             this.sendFailIfNoSpace = 1;
1:6da08b2:         } else {
1:6da08b2:             this.sendFailIfNoSpace = 0;
1:6da08b2:         }
1:6da08b2:     }
1:6da08b2: 
1:6da08b2:     public boolean isSendFailIfNoSpace() {
1:6da08b2:         return sendFailIfNoSpace == 1;
1:6da08b2:     }
1:6da08b2: 
1:6da08b2:     public void setSendFailIfNoSpaceAfterTimeout(long sendFailIfNoSpaceAfterTimeout) {
1:6da08b2:         this.sendFailIfNoSpaceAfterTimeout = sendFailIfNoSpaceAfterTimeout;
1:6da08b2:     }
1:6da08b2: 
1:6da08b2:     public long getSendFailIfNoSpaceAfterTimeout() {
1:6da08b2:         return this.sendFailIfNoSpaceAfterTimeout;
1:6da08b2:     }
1:65b0f2a: 
1:65b0f2a:     public boolean isUseTopicSubscriptionInflightStats() {
1:65b0f2a:         return useTopicSubscriptionInflightStats;
1:65b0f2a:     }
1:65b0f2a: 
1:65b0f2a:     public void setUseTopicSubscriptionInflightStats(boolean useTopicSubscriptionInflightStats) {
1:65b0f2a:         this.useTopicSubscriptionInflightStats = useTopicSubscriptionInflightStats;
1:65b0f2a:     }
1:785454a: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:65b0f2a
/////////////////////////////////////////////////////////////////////////
1:     private boolean useTopicSubscriptionInflightStats = true;
/////////////////////////////////////////////////////////////////////////
1:         subscription.setUseTopicSubscriptionInflightStats(isUseTopicSubscriptionInflightStats());
/////////////////////////////////////////////////////////////////////////
1: 
1:     public boolean isUseTopicSubscriptionInflightStats() {
1:         return useTopicSubscriptionInflightStats;
1:     }
1: 
1:     public void setUseTopicSubscriptionInflightStats(boolean useTopicSubscriptionInflightStats) {
1:         this.useTopicSubscriptionInflightStats = useTopicSubscriptionInflightStats;
1:     }
commit:a253ad3
/////////////////////////////////////////////////////////////////////////
1: import java.util.Set;
1: 
/////////////////////////////////////////////////////////////////////////
1:         update(queue, null);
1:     }
1: 
1:     /**
1:      * Update a queue with this policy.  Only apply properties that
1:      * match the includedProperties list.  Not all properties are eligible
1:      * to be updated.
1:      *
1:      * If includedProperties is null then all of the properties will be set as
1:      * isUpdate will return true
0:      * @param baseDestination
1:      * @param includedProperties
1:      */
1:     public void update(Queue queue, Set<String> includedProperties) {
1:         baseUpdate(queue, includedProperties);
1:         if (isUpdate("memoryLimit", includedProperties) && memoryLimit > 0) {
1:         if (isUpdate("useConsumerPriority", includedProperties)) {
1:             queue.setUseConsumerPriority(isUseConsumerPriority());
1:         }
1:         if (isUpdate("strictOrderDispatch", includedProperties)) {
1:             queue.setStrictOrderDispatch(isStrictOrderDispatch());
1:         }
1:         if (isUpdate("optimizedDispatch", includedProperties)) {
1:             queue.setOptimizedDispatch(isOptimizedDispatch());
1:         }
1:         if (isUpdate("lazyDispatch", includedProperties)) {
1:             queue.setLazyDispatch(isLazyDispatch());
1:         }
1:         if (isUpdate("timeBeforeDispatchStarts", includedProperties)) {
1:             queue.setTimeBeforeDispatchStarts(getTimeBeforeDispatchStarts());
1:         }
1:         if (isUpdate("consumersBeforeDispatchStarts", includedProperties)) {
1:             queue.setConsumersBeforeDispatchStarts(getConsumersBeforeDispatchStarts());
1:         }
1:         if (isUpdate("allConsumersExclusiveByDefault", includedProperties)) {
1:             queue.setAllConsumersExclusiveByDefault(isAllConsumersExclusiveByDefault());
1:         }
1:         if (isUpdate("persistJMSRedelivered", includedProperties)) {
1:             queue.setPersistJMSRedelivered(isPersistJMSRedelivered());
1:         }
/////////////////////////////////////////////////////////////////////////
1:         update(topic, null);
1:     }
1: 
1:     //If includedProperties is null then all of the properties will be set as
1:     //isUpdate will return true
1:     public void update(Topic topic, Set<String> includedProperties) {
1:         baseUpdate(topic, includedProperties);
1:         if (isUpdate("memoryLimit", includedProperties) && memoryLimit > 0) {
1:         if (isUpdate("lazyDispatch", includedProperties)) {
1:             topic.setLazyDispatch(isLazyDispatch());
1:         }
1:         baseUpdate(destination, null);
1:     }
1:     // attributes that can change on the fly
1:     //If includedProperties is null then all of the properties will be set as
1:     //isUpdate will return true
1:     public void baseUpdate(BaseDestination destination, Set<String> includedProperties) {
1:         if (isUpdate("producerFlowControl", includedProperties)) {
1:             destination.setProducerFlowControl(isProducerFlowControl());
1:         }
1:         if (isUpdate("alwaysRetroactive", includedProperties)) {
1:             destination.setAlwaysRetroactive(isAlwaysRetroactive());
1:         }
1:         if (isUpdate("blockedProducerWarningInterval", includedProperties)) {
1:             destination.setBlockedProducerWarningInterval(getBlockedProducerWarningInterval());
1:         }
1:         if (isUpdate("maxPageSize", includedProperties)) {
1:             destination.setMaxPageSize(getMaxPageSize());
1:         }
1:         if (isUpdate("maxBrowsePageSize", includedProperties)) {
1:             destination.setMaxBrowsePageSize(getMaxBrowsePageSize());
1:         }
1:         if (isUpdate("minimumMessageSize", includedProperties)) {
1:             destination.setMinimumMessageSize((int) getMinimumMessageSize());
1:         }
1:         if (isUpdate("maxExpirePageSize", includedProperties)) {
1:             destination.setMaxExpirePageSize(getMaxExpirePageSize());
1:         }
1:         if (isUpdate("cursorMemoryHighWaterMark", includedProperties)) {
1:             destination.setCursorMemoryHighWaterMark(getCursorMemoryHighWaterMark());
1:         }
1:         if (isUpdate("storeUsageHighWaterMark", includedProperties)) {
1:             destination.setStoreUsageHighWaterMark(getStoreUsageHighWaterMark());
1:         }
1:         if (isUpdate("gcInactiveDestinations", includedProperties)) {
1:             destination.setGcIfInactive(isGcInactiveDestinations());
1:         }
1:         if (isUpdate("gcWithNetworkConsumers", includedProperties)) {
1:             destination.setGcWithNetworkConsumers(isGcWithNetworkConsumers());
1:         }
1:         if (isUpdate("inactiveTimeoutBeforeGc", includedProperties)) {
1:             destination.setInactiveTimeoutBeforeGC(getInactiveTimeoutBeforeGC());
1:         }
1:         if (isUpdate("reduceMemoryFootprint", includedProperties)) {
1:             destination.setReduceMemoryFootprint(isReduceMemoryFootprint());
1:         }
1:         if (isUpdate("doOptimizeMessageStore", includedProperties)) {
1:             destination.setDoOptimzeMessageStorage(isDoOptimzeMessageStorage());
1:         }
1:         if (isUpdate("optimizeMessageStoreInFlightLimit", includedProperties)) {
1:             destination.setOptimizeMessageStoreInFlightLimit(getOptimizeMessageStoreInFlightLimit());
1:         }
1:         if (isUpdate("advisoryForConsumed", includedProperties)) {
1:             destination.setAdvisoryForConsumed(isAdvisoryForConsumed());
1:         }
1:         if (isUpdate("advisoryForDelivery", includedProperties)) {
1:             destination.setAdvisoryForDelivery(isAdvisoryForDelivery());
1:         }
1:         if (isUpdate("advisoryForDiscardingMessages", includedProperties)) {
1:             destination.setAdvisoryForDiscardingMessages(isAdvisoryForDiscardingMessages());
1:         }
1:         if (isUpdate("advisoryForSlowConsumers", includedProperties)) {
1:             destination.setAdvisoryForSlowConsumers(isAdvisoryForSlowConsumers());
1:         }
1:         if (isUpdate("advisoryForFastProducers", includedProperties)) {
1:             destination.setAdvisoryForFastProducers(isAdvisoryForFastProducers());
1:         }
1:         if (isUpdate("advisoryWhenFull", includedProperties)) {
1:             destination.setAdvisoryWhenFull(isAdvisoryWhenFull());
1:         }
1:         if (isUpdate("includeBodyForAdvisory", includedProperties)) {
1:             destination.setIncludeBodyForAdvisory(isIncludeBodyForAdvisory());
1:         }
1:         if (isUpdate("sendAdvisoryIfNoConsumers", includedProperties)) {
1:             destination.setSendAdvisoryIfNoConsumers(isSendAdvisoryIfNoConsumers());
1:         }
/////////////////////////////////////////////////////////////////////////
1:     private boolean isUpdate(String property, Set<String> includedProperties) {
1:         return includedProperties == null || includedProperties.contains(property);
1:     }
commit:edacc2a
/////////////////////////////////////////////////////////////////////////
1:     private boolean includeBodyForAdvisory;
/////////////////////////////////////////////////////////////////////////
0:         destination.setIncludeBodyForAdvisory(isIncludeBodyForAdvisory());
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Returns true if the original message body should be included when applicable
1:      * for advisory messages
1:      *
1:      * @return
1:      */
1:     public boolean isIncludeBodyForAdvisory() {
1:         return includeBodyForAdvisory;
1:     }
1: 
1:     /**
1:      * Sets if the original message body should be included when applicable
1:      * for advisory messages
1:      *
1:      * @param includeBodyForAdvisory
1:      */
1:     public void setIncludeBodyForAdvisory(boolean includeBodyForAdvisory) {
1:         this.includeBodyForAdvisory = includeBodyForAdvisory;
1:     }
1: 
commit:886e2d4
/////////////////////////////////////////////////////////////////////////
1:     private int maxDestinations = -1;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public int getMaxDestinations() {
1:         return maxDestinations;
1:     }
1: 
1:     /**
1:      * Sets the maximum number of destinations that can be created
1:      *
1:      * @param maxDestinations
1:      *            maximum number of destinations
1:      */
1:     public void setMaxDestinations(int maxDestinations) {
1:         this.maxDestinations = maxDestinations;
1:     }
1: 
author:gtully
-------------------------------------------------------------------------------
commit:8e576be
/////////////////////////////////////////////////////////////////////////
1:         if (sendFailIfNoSpaceAfterTimeout != -1) {
commit:6da08b2
/////////////////////////////////////////////////////////////////////////
1:     private int sendFailIfNoSpace = -1;
1:     private long sendFailIfNoSpaceAfterTimeout = -1;
/////////////////////////////////////////////////////////////////////////
1:      * @param queue
/////////////////////////////////////////////////////////////////////////
1:         if (sendFailIfNoSpace != -1) {
1:             destination.getSystemUsage().setSendFailIfNoSpace(isSendFailIfNoSpace());
1:         }
0:         if (sendFailIfNoSpaceAfterTimeout != 0) {
1:             destination.getSystemUsage().setSendFailIfNoSpaceAfterTimeout(getSendFailIfNoSpaceAfterTimeout());
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void setSendFailIfNoSpace(boolean val) {
1:         if (val) {
1:             this.sendFailIfNoSpace = 1;
1:         } else {
1:             this.sendFailIfNoSpace = 0;
1:         }
1:     }
1: 
1:     public boolean isSendFailIfNoSpace() {
1:         return sendFailIfNoSpace == 1;
1:     }
1: 
1:     public void setSendFailIfNoSpaceAfterTimeout(long sendFailIfNoSpaceAfterTimeout) {
1:         this.sendFailIfNoSpaceAfterTimeout = sendFailIfNoSpaceAfterTimeout;
1:     }
1: 
1:     public long getSendFailIfNoSpaceAfterTimeout() {
1:         return this.sendFailIfNoSpaceAfterTimeout;
1:     }
commit:078f39f
/////////////////////////////////////////////////////////////////////////
1:         subscription.setCursorMemoryHighWaterMark(getCursorMemoryHighWaterMark());
commit:75eb814
/////////////////////////////////////////////////////////////////////////
1:         queue.setPersistJMSRedelivered(isPersistJMSRedelivered());
/////////////////////////////////////////////////////////////////////////
0:         queue.setPersistJMSRedelivered(isPersistJMSRedelivered());
/////////////////////////////////////////////////////////////////////////
commit:266d23e
/////////////////////////////////////////////////////////////////////////
1:     private boolean persistJMSRedelivered = false;
/////////////////////////////////////////////////////////////////////////
0:         destination.setPersistJMSRedelivered(isPersistJMSRedelivered());
/////////////////////////////////////////////////////////////////////////
1:     public void setPersistJMSRedelivered(boolean val) {
1:         this.persistJMSRedelivered = val;
1:     }
1: 
1:     public boolean isPersistJMSRedelivered() {
1:         return persistJMSRedelivered;
1:     }
commit:85bc9ce
/////////////////////////////////////////////////////////////////////////
1: 
1:         // part solution - dispatching to browsers needs to be restricted
1:         sub.setMaxMessages(getMaxBrowsePageSize());
author:Vasco Veloso
-------------------------------------------------------------------------------
commit:687badb
/////////////////////////////////////////////////////////////////////////
1:         subscription.setUsePrefetchExtension(isUsePrefetchExtension());
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:ee4672b
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public String toString() {
1:         return "PolicyEntry [" + destination + "]";
1:     }
author:Timothy Bish
-------------------------------------------------------------------------------
commit:b9fd189
/////////////////////////////////////////////////////////////////////////
1:     private long inactiveTimeoutBeforeGC = BaseDestination.DEFAULT_INACTIVE_TIMEOUT_BEFORE_GC;
/////////////////////////////////////////////////////////////////////////
0:         destination.setInactiveTimeoutBeforeGC(getInactiveTimeoutBeforeGC());
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @return the amount of time spent inactive before GC of the destination kicks in.
1:      *
1:      * @deprecated use getInactiveTimeoutBeforeGC instead.
1:      */
1:     @Deprecated
1:         return getInactiveTimeoutBeforeGC();
1:     /**
1:      * Sets the amount of time a destination is inactive before it is marked for GC
1:      *
1:      * @param inactiveTimoutBeforeGC
1:      *        time in milliseconds to configure as the inactive timeout.
1:      *
1:      * @deprecated use getInactiveTimeoutBeforeGC instead.
1:      */
1:     @Deprecated
1:         setInactiveTimeoutBeforeGC(inactiveTimoutBeforeGC);
1:     }
1: 
1:     /**
1:      * @return the amount of time spent inactive before GC of the destination kicks in.
1:      */
1:     public long getInactiveTimeoutBeforeGC() {
1:         return this.inactiveTimeoutBeforeGC;
1:     }
1: 
1:     /**
1:      * Sets the amount of time a destination is inactive before it is marked for GC
1:      *
1:      * @param inactiveTimoutBeforeGC
1:      *        time in milliseconds to configure as the inactive timeout.
1:      */
1:     public void setInactiveTimeoutBeforeGC(long inactiveTimeoutBeforeGC) {
1:         this.inactiveTimeoutBeforeGC = inactiveTimeoutBeforeGC;
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Setting the maximumPendingMessages size to: {} for consumer: {}", value, subscription.getInfo().getConsumerId());
author:rajdavies
-------------------------------------------------------------------------------
commit:468e697
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.group.GroupFactoryFinder;
/////////////////////////////////////////////////////////////////////////
1:     private String messageGroupMapFactoryType = "cached";
/////////////////////////////////////////////////////////////////////////
1:             try {
1:             messageGroupMapFactory = GroupFactoryFinder.createMessageGroupMapFactory(getMessageGroupMapFactoryType());
1:             }catch(Exception e){
1:                 LOG.error("Failed to create message group Factory ",e);
1:             }
/////////////////////////////////////////////////////////////////////////
1: 
1:     public String getMessageGroupMapFactoryType() {
1:         return messageGroupMapFactoryType;
1:     }
1: 
1:     public void setMessageGroupMapFactoryType(String messageGroupMapFactoryType) {
1:         this.messageGroupMapFactoryType = messageGroupMapFactoryType;
1:     }
1: 
1: 
author:Gary Tully
-------------------------------------------------------------------------------
commit:e8ea6cd
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.RegionBroker;
/////////////////////////////////////////////////////////////////////////
1:     public void update(Queue queue) {
0:         baseUpdate(queue);
1:         if (memoryLimit > 0) {
1:             queue.getMemoryUsage().setLimit(memoryLimit);
1:         }
1:         queue.setUseConsumerPriority(isUseConsumerPriority());
1:         queue.setStrictOrderDispatch(isStrictOrderDispatch());
1:         queue.setOptimizedDispatch(isOptimizedDispatch());
1:         queue.setLazyDispatch(isLazyDispatch());
1:         queue.setTimeBeforeDispatchStarts(getTimeBeforeDispatchStarts());
1:         queue.setConsumersBeforeDispatchStarts(getConsumersBeforeDispatchStarts());
1:         queue.setAllConsumersExclusiveByDefault(isAllConsumersExclusiveByDefault());
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void update(Topic topic) {
0:         baseUpdate(topic);
1:         if (memoryLimit > 0) {
1:             topic.getMemoryUsage().setLimit(memoryLimit);
1:         }
1:         topic.setLazyDispatch(isLazyDispatch());
1:     }
1: 
1:     // attributes that can change on the fly
1:     public void baseUpdate(BaseDestination destination) {
1: 
1: 
0:         destination.setMaxExpirePageSize(getMaxExpirePageSize());
0:         destination.setCursorMemoryHighWaterMark(getCursorMemoryHighWaterMark());
0:         destination.setStoreUsageHighWaterMark(getStoreUsageHighWaterMark());
1: 
0:         destination.setGcIfInactive(isGcInactiveDestinations());
0:         destination.setGcWithNetworkConsumers(isGcWithNetworkConsumers());
0:         destination.setInactiveTimoutBeforeGC(getInactiveTimoutBeforeGC());
0:         destination.setReduceMemoryFootprint(isReduceMemoryFootprint());
0:         destination.setDoOptimzeMessageStorage(isDoOptimzeMessageStorage());
0:         destination.setOptimizeMessageStoreInFlightLimit(getOptimizeMessageStoreInFlightLimit());
1: 
0:         destination.setSendAdvisoryIfNoConsumers(isSendAdvisoryIfNoConsumers());
1:     }
1: 
1:     public void baseConfiguration(Broker broker, BaseDestination destination) {
1:         baseUpdate(destination);
1:         destination.setEnableAudit(isEnableAudit());
1:         destination.setMaxAuditDepth(getMaxQueueAuditDepth());
1:         destination.setMaxProducersToAudit(getMaxProducersToAudit());
1:         destination.setUseCache(isUseCache());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
commit:bc45bf8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.Subscription;
/////////////////////////////////////////////////////////////////////////
1:         configurePrefetch(subscription);
/////////////////////////////////////////////////////////////////////////
1:         configurePrefetch(sub);
/////////////////////////////////////////////////////////////////////////
1:         configurePrefetch(sub);
1:         configurePrefetch(sub);
1:     public void configurePrefetch(Subscription subscription) {
1: 
1:         final int currentPrefetch = subscription.getConsumerInfo().getPrefetchSize();
1:         if (subscription instanceof QueueBrowserSubscription) {
1:             if (currentPrefetch == ActiveMQPrefetchPolicy.DEFAULT_QUEUE_BROWSER_PREFETCH) {
1:                 ((QueueBrowserSubscription) subscription).setPrefetchSize(getQueueBrowserPrefetch());
1:             }
1:         } else if (subscription instanceof QueueSubscription) {
1:             if (currentPrefetch == ActiveMQPrefetchPolicy.DEFAULT_QUEUE_PREFETCH) {
1:                 ((QueueSubscription) subscription).setPrefetchSize(getQueuePrefetch());
1:             }
1:         } else if (subscription instanceof DurableTopicSubscription) {
1:             if (currentPrefetch == ActiveMQPrefetchPolicy.DEFAULT_DURABLE_TOPIC_PREFETCH ||
1:                     subscription.getConsumerInfo().getPrefetchSize() == ActiveMQPrefetchPolicy.DEFAULT_OPTIMIZE_DURABLE_TOPIC_PREFETCH) {
1:                 ((DurableTopicSubscription)subscription).setPrefetchSize(getDurableTopicPrefetch());
1:             }
1:         } else if (subscription instanceof TopicSubscription) {
1:             if (currentPrefetch == ActiveMQPrefetchPolicy.DEFAULT_TOPIC_PREFETCH) {
1:                 ((TopicSubscription) subscription).setPrefetchSize(getTopicPrefetch());
1:             }
1:         }
1:         if (currentPrefetch != 0 && subscription.getPrefetchSize() == 0) {
1:             // tell the sub so that it can issue a pull request
1:             subscription.updateConsumerPrefetch(0);
1:         }
1:     }
1: 
commit:95e6d60
/////////////////////////////////////////////////////////////////////////
0:             if (sub.getPrefetchSize() == 0) {
0:                 // tell the sub so that it can issue a pull request
0:                 sub.updateConsumerPrefetch(0);
1:             }
commit:db1f6fe
/////////////////////////////////////////////////////////////////////////
1:     private boolean advisoryForFastProducers;
/////////////////////////////////////////////////////////////////////////
0:         destination.setAdvisoryForFastProducers(isAdvisoryForFastProducers());
/////////////////////////////////////////////////////////////////////////
1:     public boolean isAdvisoryForFastProducers() {
1:         return advisoryForFastProducers;
1:      * @param advisoryForFastProducers the advisdoryForFastProducers to set
1:     public void setAdvisoryForFastProducers(boolean advisoryForFastProducers) {
1:         this.advisoryForFastProducers = advisoryForFastProducers;
commit:fe63c29
/////////////////////////////////////////////////////////////////////////
1:     private boolean alwaysRetroactive = false;
/////////////////////////////////////////////////////////////////////////
0:         destination.setAlwaysRetroactive(isAlwaysRetroactive());
/////////////////////////////////////////////////////////////////////////
1:      * @return true if topic is always retroactive
1:      */
1:     public boolean isAlwaysRetroactive() {
1:         return alwaysRetroactive;
1:     }
1: 
1:     /**
1:      * @param alwaysRetroactive
1:      */
1:     public void setAlwaysRetroactive(boolean alwaysRetroactive) {
1:         this.alwaysRetroactive = alwaysRetroactive;
1:     }
1:     
1:     
1:     /**
commit:af1b232
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.network.NetworkBridgeFilterFactory;
/////////////////////////////////////////////////////////////////////////
1:     private NetworkBridgeFilterFactory networkBridgeFilterFactory;
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void setNetworkBridgeFilterFactory(NetworkBridgeFilterFactory networkBridgeFilterFactory) {
1:         this.networkBridgeFilterFactory = networkBridgeFilterFactory;
1:     }
1: 
1:     public NetworkBridgeFilterFactory getNetworkBridgeFilterFactory() {
1:         return networkBridgeFilterFactory;
1:     }
commit:d55a392
/////////////////////////////////////////////////////////////////////////
1:     private boolean gcWithNetworkConsumers;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:         destination.setGcWithNetworkConsumers(isGcWithNetworkConsumers());
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void setGcWithNetworkConsumers(boolean gcWithNetworkConsumers) {
1:         this.gcWithNetworkConsumers = gcWithNetworkConsumers;
1:     }
1: 
1:     public boolean isGcWithNetworkConsumers() {
1:         return gcWithNetworkConsumers;
1:     }
1: 
commit:e35519f
/////////////////////////////////////////////////////////////////////////
0:         if (prefetch == ActiveMQPrefetchPolicy.DEFAULT_DURABLE_TOPIC_PREFETCH || prefetch == ActiveMQPrefetchPolicy.DEFAULT_OPTIMIZE_DURABLE_TOPIC_PREFETCH){
commit:3ddb71c
/////////////////////////////////////////////////////////////////////////
1:     private int maxProducersToAudit=BaseDestination.MAX_PRODUCERS_TO_AUDIT;
1:     private int maxAuditDepth=BaseDestination.MAX_AUDIT_DEPTH;
1:     private int maxQueueAuditDepth=BaseDestination.MAX_AUDIT_DEPTH;
/////////////////////////////////////////////////////////////////////////
1:         int auditDepth = getMaxAuditDepth();
1:         if (auditDepth == BaseDestination.MAX_AUDIT_DEPTH && this.isPrioritizedMessages()) {
1:             sub.setMaxAuditDepth(auditDepth * 10);
1:         } else {
1:             sub.setMaxAuditDepth(auditDepth);
1:         }
commit:6519c3e
/////////////////////////////////////////////////////////////////////////
1:             PendingMessageCursor cursor = pendingDurableSubscriberPolicy.getSubscriberPendingMessageCursor(broker,clientId, subName,sub.getPrefetchSize(),sub);
commit:c1da3ac
/////////////////////////////////////////////////////////////////////////
1:     private boolean reduceMemoryFootprint;
/////////////////////////////////////////////////////////////////////////
0:         destination.setReduceMemoryFootprint(isReduceMemoryFootprint());
/////////////////////////////////////////////////////////////////////////
1:     
1:     public boolean isReduceMemoryFootprint() {
1:         return reduceMemoryFootprint;
1:     }
1:     public void setReduceMemoryFootprint(boolean reduceMemoryFootprint) {
1:         this.reduceMemoryFootprint = reduceMemoryFootprint;
1:     }
commit:383d12e
/////////////////////////////////////////////////////////////////////////
1:             scs.setBrokerService(broker);
commit:1b6d397
/////////////////////////////////////////////////////////////////////////
1:     private SlowConsumerStrategy slowConsumerStrategy;
/////////////////////////////////////////////////////////////////////////
0:         destination.setSlowConsumerStrategy(getSlowConsumerStrategy());
/////////////////////////////////////////////////////////////////////////
1:     public void setSlowConsumerStrategy(SlowConsumerStrategy slowConsumerStrategy) {
1:         this.slowConsumerStrategy = slowConsumerStrategy;
1:     }
1:     
1:     public SlowConsumerStrategy getSlowConsumerStrategy() {
1:         return this.slowConsumerStrategy;
1:     }
1: 
commit:eb983f7
/////////////////////////////////////////////////////////////////////////
1:         if (enableAudit) {
1:             subscription.setEnableAudit(enableAudit);
1:             subscription.setMaxProducersToAudit(maxProducersToAudit);
1:             subscription.setMaxAuditDepth(maxAuditDepth);
1:         }
commit:6a73c40
/////////////////////////////////////////////////////////////////////////
1:     private boolean usePrefetchExtension = true;
1:     private int cursorMemoryHighWaterMark = 70;
/////////////////////////////////////////////////////////////////////////
1:         sub.setUsePrefetchExtension(isUsePrefetchExtension());        
/////////////////////////////////////////////////////////////////////////
1:         sub.setUsePrefetchExtension(isUsePrefetchExtension());
/////////////////////////////////////////////////////////////////////////
1:         sub.setUsePrefetchExtension(isUsePrefetchExtension());
/////////////////////////////////////////////////////////////////////////
1:     public boolean isUsePrefetchExtension() {
1:         return this.usePrefetchExtension;
1:     }
1:     public void setUsePrefetchExtension(boolean usePrefetchExtension) {
1:         this.usePrefetchExtension = usePrefetchExtension;
1:     }
1:     
1:     public int getCursorMemoryHighWaterMark() {
1:         return this.cursorMemoryHighWaterMark;
1:     }
1: 
1:     public void setCursorMemoryHighWaterMark(int cursorMemoryHighWaterMark) {
1:         this.cursorMemoryHighWaterMark = cursorMemoryHighWaterMark;
commit:a0d2282
/////////////////////////////////////////////////////////////////////////
1:     private int storeUsageHighWaterMark = 100;
/////////////////////////////////////////////////////////////////////////
0:         destination.setStoreUsageHighWaterMark(getStoreUsageHighWaterMark());
/////////////////////////////////////////////////////////////////////////
1:     public void setStoreUsageHighWaterMark(int storeUsageHighWaterMark) {
1:         this.storeUsageHighWaterMark = storeUsageHighWaterMark;   
1:     }
1:     public int getStoreUsageHighWaterMark() {
1:         return storeUsageHighWaterMark;
1:     }
commit:a2af47b
/////////////////////////////////////////////////////////////////////////
0:         //override prefetch size if not set by the Consumer
0:         int prefetch=subscription.getConsumerInfo().getPrefetchSize();
0:         if (prefetch == ActiveMQPrefetchPolicy.DEFAULT_TOPIC_PREFETCH){
0:             subscription.getConsumerInfo().setPrefetchSize(getTopicPrefetch());
1:         }
/////////////////////////////////////////////////////////////////////////
commit:356c39d
/////////////////////////////////////////////////////////////////////////
1:      * When set using Xbean, values of the form "20 Mb", "1024kb", and "1g" can be used
commit:c6a485f
/////////////////////////////////////////////////////////////////////////
1:     private long expireMessagesPeriod = BaseDestination.EXPIRE_MESSAGE_PERIOD;
1:     private int maxExpirePageSize = BaseDestination.MAX_BROWSE_PAGE_SIZE;
1:         queue.setDeadLetterStrategy(getDeadLetterStrategy());
/////////////////////////////////////////////////////////////////////////
1:         topic.setDeadLetterStrategy(getDeadLetterStrategy());
/////////////////////////////////////////////////////////////////////////
1:         destination.setExpireMessagesPeriod(getExpireMessagesPeriod());
0:         destination.setMaxExpirePageSize(getMaxExpirePageSize());
/////////////////////////////////////////////////////////////////////////
1:     public void setMaxExpirePageSize(int maxExpirePageSize) {
1:         this.maxExpirePageSize = maxExpirePageSize;
1:     }
1:     
1:     public int getMaxExpirePageSize() {
1:         return maxExpirePageSize;
1:     }
1:     
1:     public void setExpireMessagesPeriod(long expireMessagesPeriod) {
1:         this.expireMessagesPeriod = expireMessagesPeriod;
1:     }
1:     
1:     public long getExpireMessagesPeriod() {
1:         return expireMessagesPeriod;
1:     }
1: 
1: 
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:2b99f39
/////////////////////////////////////////////////////////////////////////
0:     public void baseConfiguration(Broker broker, BaseDestination destination) {
/////////////////////////////////////////////////////////////////////////
1:             scs.addDestination(destination);
/////////////////////////////////////////////////////////////////////////
commit:d97f28c
/////////////////////////////////////////////////////////////////////////
1:         sub.setMaxAuditDepth(Short.MAX_VALUE);
commit:2d54420
/////////////////////////////////////////////////////////////////////////
commit:1f5694e
/////////////////////////////////////////////////////////////////////////
1: 
1:         // TODO
1:         // We currently need an infinite audit because of the way that browser dispatch
1:         // is done.  We should refactor the browsers to better handle message dispatch so
1:         // we can remove this and perform a more efficient dispatch.
1:         sub.setMaxProducersToAudit(Integer.MAX_VALUE);
0:         sub.setMaxAuditDepth(Integer.MAX_VALUE);
commit:37ede54
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:         sub.setUsePrefetchExtension(isUsePrefetchExtension());
1: 
1:         sub.setMaxProducersToAudit(getMaxProducersToAudit());
1: 
1:         sub.setMaxProducersToAudit(getMaxProducersToAudit());
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     }
1: 
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     }
0:         this.storeUsageHighWaterMark = storeUsageHighWaterMark;
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:9e13dc6
/////////////////////////////////////////////////////////////////////////
1:     private boolean lazyDispatch=false;
commit:53c4e12
/////////////////////////////////////////////////////////////////////////
0:             PendingMessageCursor cursor = pendingDurableSubscriberPolicy.getSubscriberPendingMessageCursor(clientId, subName, broker.getTempDataStore(), prefetch, sub);
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(PolicyEntry.class);
/////////////////////////////////////////////////////////////////////////
0:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug("Setting the maximumPendingMessages size to: " + value + " for consumer: " + subscription.getInfo().getConsumerId());
commit:230a86c
/////////////////////////////////////////////////////////////////////////
1:  * Represents an entry in a {@link PolicyMap} for assigning policies to a
1:  * specific destination or a hierarchical wildcard area of destinations.
1: public class PolicyEntry extends DestinationMapEntry {
0:     private static final Log log = LogFactory.getLog(PolicyEntry.class);
/////////////////////////////////////////////////////////////////////////
1: 
0:     public void configure(Queue queue, Store tmpStore) {
1:         if (dispatchPolicy != null) {
0:         if (deadLetterStrategy != null) {
0:         if (memoryLimit > 0) {
1:         if (pendingQueuePolicy != null) {
0:             PendingMessageCursor messages = pendingQueuePolicy.getQueuePendingMessageCursor(queue, tmpStore);
0:     public void configure(Topic topic) {
1:         if (dispatchPolicy != null) {
0:         if (deadLetterStrategy != null) {
1:         if (subscriptionRecoveryPolicy != null) {
0:         if (memoryLimit > 0) {
0:     public void configure(Broker broker, UsageManager memoryManager, TopicSubscription subscription) {
1:         if (pendingMessageLimitStrategy != null) {
1:             int value = pendingMessageLimitStrategy.getMaximumPendingMessageLimit(subscription);
1:             int consumerLimit = subscription.getInfo().getMaximumPendingMessageLimit();
1:             if (consumerLimit > 0) {
1:                 if (value < 0 || consumerLimit < value) {
1:                     value = consumerLimit;
1:             if (value >= 0) {
0:                 if (log.isDebugEnabled()) {
0:                     log.debug("Setting the maximumPendingMessages size to: " + value + " for consumer: " + subscription.getInfo().getConsumerId());
1:         if (messageEvictionStrategy != null) {
1:         if (pendingSubscriberPolicy != null) {
0:             subscription.setMatched(pendingSubscriberPolicy.getSubscriberPendingMessageCursor(name, broker.getTempDataStore(), maxBatchSize));
0:     public void configure(Broker broker, UsageManager memoryManager, DurableTopicSubscription sub) {
0:         String clientId = sub.getClientId();
0:         String subName = sub.getSubscriptionName();
0:         int prefetch = sub.getPrefetchSize();
1:         if (pendingDurableSubscriberPolicy != null) {
0:             PendingMessageCursor cursor = pendingDurableSubscriberPolicy.getSubscriberPendingMessageCursor(clientId, subName, broker.getTempDataStore(), prefetch);
/////////////////////////////////////////////////////////////////////////
1:     public DispatchPolicy getDispatchPolicy() {
1:     public void setDispatchPolicy(DispatchPolicy policy) {
1:         this.dispatchPolicy = policy;
1:     public SubscriptionRecoveryPolicy getSubscriptionRecoveryPolicy() {
1:     public void setSubscriptionRecoveryPolicy(SubscriptionRecoveryPolicy subscriptionRecoveryPolicy) {
1:         this.subscriptionRecoveryPolicy = subscriptionRecoveryPolicy;
1:     public boolean isSendAdvisoryIfNoConsumers() {
1:      * Sends an advisory message if a non-persistent message is sent and there
1:      * are no active consumers
1:     public void setSendAdvisoryIfNoConsumers(boolean sendAdvisoryIfNoConsumers) {
1:         this.sendAdvisoryIfNoConsumers = sendAdvisoryIfNoConsumers;
1:     public DeadLetterStrategy getDeadLetterStrategy() {
1:      * Sets the policy used to determine which dead letter queue destination
1:      * should be used
1:     public void setDeadLetterStrategy(DeadLetterStrategy deadLetterStrategy) {
1:         this.deadLetterStrategy = deadLetterStrategy;
1:     public PendingMessageLimitStrategy getPendingMessageLimitStrategy() {
1:      * Sets the strategy to calculate the maximum number of messages that are
1:      * allowed to be pending on consumers (in addition to their prefetch sizes).
1:      * Once the limit is reached, non-durable topics can then start discarding
1:      * old messages. This allows us to keep dispatching messages to slow
1:      * consumers while not blocking fast consumers and discarding the messages
1:      * oldest first.
1:     public void setPendingMessageLimitStrategy(PendingMessageLimitStrategy pendingMessageLimitStrategy) {
1:         this.pendingMessageLimitStrategy = pendingMessageLimitStrategy;
1:     public MessageEvictionStrategy getMessageEvictionStrategy() {
1:      * Sets the eviction strategy used to decide which message to evict when the
1:      * slow consumer needs to discard messages
1:     public void setMessageEvictionStrategy(MessageEvictionStrategy messageEvictionStrategy) {
1:         this.messageEvictionStrategy = messageEvictionStrategy;
1:     public long getMemoryLimit() {
1:     public void setMemoryLimit(long memoryLimit) {
1:         this.memoryLimit = memoryLimit;
1:     public MessageGroupMapFactory getMessageGroupMapFactory() {
1:         if (messageGroupMapFactory == null) {
0:             messageGroupMapFactory = new MessageGroupHashBucketFactory();
1:      * Sets the factory used to create new instances of {MessageGroupMap} used
1:      * to implement the <a
1:      * href="http://activemq.apache.org/message-groups.html">Message Groups</a>
1:      * functionality.
1:     public void setMessageGroupMapFactory(MessageGroupMapFactory messageGroupMapFactory) {
1:         this.messageGroupMapFactory = messageGroupMapFactory;
1:     public PendingDurableSubscriberMessageStoragePolicy getPendingDurableSubscriberPolicy() {
1:      * @param pendingDurableSubscriberPolicy the pendingDurableSubscriberPolicy
1:      *                to set
1:     public void setPendingDurableSubscriberPolicy(PendingDurableSubscriberMessageStoragePolicy pendingDurableSubscriberPolicy) {
1:         this.pendingDurableSubscriberPolicy = pendingDurableSubscriberPolicy;
1:     public PendingQueueMessageStoragePolicy getPendingQueuePolicy() {
1:     public void setPendingQueuePolicy(PendingQueueMessageStoragePolicy pendingQueuePolicy) {
1:         this.pendingQueuePolicy = pendingQueuePolicy;
1:     public PendingSubscriberMessageStoragePolicy getPendingSubscriberPolicy() {
1:     public void setPendingSubscriberPolicy(PendingSubscriberMessageStoragePolicy pendingSubscriberPolicy) {
1:         this.pendingSubscriberPolicy = pendingSubscriberPolicy;
commit:ac66a09
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * 
1:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.MemoryPropertyEditor"
1:      */
commit:57b4941
/////////////////////////////////////////////////////////////////////////
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
0:  * contributor license agreements.  See the NOTICE file distributed with
0:  * this work for additional information regarding copyright ownership.
0:  * The ASF licenses this file to You under the Apache License, Version 2.0
0:  * (the "License"); you may not use this file except in compliance with
0:  * the License.  You may obtain a copy of the License at
commit:c1a0cd6
/////////////////////////////////////////////////////////////////////////
0:             topic.setSubscriptionRecoveryPolicy(subscriptionRecoveryPolicy.copy());
commit:36722d8
/////////////////////////////////////////////////////////////////////////
1:     private long memoryLimit;
/////////////////////////////////////////////////////////////////////////
0:         if( memoryLimit>0 ) {
0:             queue.getUsageManager().setLimit(memoryLimit);
1:         }
/////////////////////////////////////////////////////////////////////////
0:         if( memoryLimit>0 ) {
0:             topic.getUsageManager().setLimit(memoryLimit);
1:         }
/////////////////////////////////////////////////////////////////////////
0:     public long getMemoryLimit() {
1:         return memoryLimit;
1:     }
1: 
0:     public void setMemoryLimit(long memoryLimit) {
0:         this.memoryLimit = memoryLimit;
1:     }
1: 
commit:68d245f
/////////////////////////////////////////////////////////////////////////
1:  * @org.apache.xbean.XBean
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker.region.policy;
1: 
1: import org.apache.activemq.broker.region.Queue;
1: import org.apache.activemq.broker.region.Topic;
0: import org.apache.activemq.command.RedeliveryPolicy;
1: import org.apache.activemq.filter.DestinationMapEntry;
1: 
1: /**
0:  * Represents an entry in a {@link PolicyMap} for assigning policies to a
0:  * specific destination or a hierarchial wildcard area of destinations.
0:  * 
0:  * @org.xbean.XBean
0:  * 
0:  * @version $Revision: 1.1 $
1:  */
0: public class PolicyEntry extends DestinationMapEntry {
1: 
1:     private DispatchPolicy dispatchPolicy;
1:     private SubscriptionRecoveryPolicy subscriptionRecoveryPolicy;
0:     private RedeliveryPolicy redeliveryPolicy;
1: 
0:     public void configure(Queue queue) {
0:         if (dispatchPolicy != null) {
1:             queue.setDispatchPolicy(dispatchPolicy);
1:         }
1:     }
1: 
0:     public void configure(Topic topic) {
0:         if (dispatchPolicy != null) {
1:             topic.setDispatchPolicy(dispatchPolicy);
1:         }
0:         if (subscriptionRecoveryPolicy != null) {
0:             topic.setSubscriptionRecoveryPolicy(subscriptionRecoveryPolicy);
1:         }
1:     }
1: 
1:     // Properties
1:     // -------------------------------------------------------------------------
0:     public DispatchPolicy getDispatchPolicy() {
1:         return dispatchPolicy;
1:     }
1: 
0:     public void setDispatchPolicy(DispatchPolicy policy) {
0:         this.dispatchPolicy = policy;
1:     }
1: 
0:     public RedeliveryPolicy getRedeliveryPolicy() {
0:         return redeliveryPolicy;
1:     }
1: 
0:     public void setRedeliveryPolicy(RedeliveryPolicy redeliveryPolicy) {
0:         this.redeliveryPolicy = redeliveryPolicy;
1:     }
1: 
0:     public SubscriptionRecoveryPolicy getSubscriptionRecoveryPolicy() {
1:         return subscriptionRecoveryPolicy;
1:     }
1: 
0:     public void setSubscriptionRecoveryPolicy(SubscriptionRecoveryPolicy subscriptionRecoveryPolicy) {
0:         this.subscriptionRecoveryPolicy = subscriptionRecoveryPolicy;
1:     }
1: 
1: }
author:Robert Davies
-------------------------------------------------------------------------------
commit:ca83305
/////////////////////////////////////////////////////////////////////////
1:     /*
1:      * percentage of in-flight messages above which optimize message store is disabled
1:      */
1:     private int optimizeMessageStoreInFlightLimit = 10;
/////////////////////////////////////////////////////////////////////////
0:         destination.setOptimizeMessageStoreInFlightLimit(getOptimizeMessageStoreInFlightLimit());
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public int getOptimizeMessageStoreInFlightLimit() {
1:         return optimizeMessageStoreInFlightLimit;
1:     }
1: 
1:     public void setOptimizeMessageStoreInFlightLimit(int optimizeMessageStoreInFlightLimit) {
1:         this.optimizeMessageStoreInFlightLimit = optimizeMessageStoreInFlightLimit;
1:     }
commit:f4d4c3b
/////////////////////////////////////////////////////////////////////////
1:     private boolean doOptimzeMessageStorage = true;
/////////////////////////////////////////////////////////////////////////
0:         destination.setDoOptimzeMessageStorage(isDoOptimzeMessageStorage());
/////////////////////////////////////////////////////////////////////////
1: 
1:     public boolean isDoOptimzeMessageStorage() {
1:         return doOptimzeMessageStorage;
1:     }
1: 
1:     public void setDoOptimzeMessageStorage(boolean doOptimzeMessageStorage) {
1:         this.doOptimzeMessageStorage = doOptimzeMessageStorage;
1:     }
commit:70314ea
/////////////////////////////////////////////////////////////////////////
1:     private boolean gcInactiveDestinations;
0:     private long inactiveTimoutBeforeGC = BaseDestination.DEFAULT_INACTIVE_TIMEOUT_BEFORE_GC;
/////////////////////////////////////////////////////////////////////////
0:         destination.setGcIfInactive(isGcInactiveDestinations());
0:         destination.setInactiveTimoutBeforeGC(getInactiveTimoutBeforeGC());
/////////////////////////////////////////////////////////////////////////
1:     public boolean isGcInactiveDestinations() {
1:         return this.gcInactiveDestinations;
1:     }
1: 
1:     public void setGcInactiveDestinations(boolean gcInactiveDestinations) {
1:         this.gcInactiveDestinations = gcInactiveDestinations;
1:     }
1: 
1:     public long getInactiveTimoutBeforeGC() {
0:         return this.inactiveTimoutBeforeGC;
1:     }
1: 
1:     public void setInactiveTimoutBeforeGC(long inactiveTimoutBeforeGC) {
0:         this.inactiveTimoutBeforeGC = inactiveTimoutBeforeGC;
1:     }
1: 
commit:42ee51f
/////////////////////////////////////////////////////////////////////////
1:     private boolean allConsumersExclusiveByDefault;
/////////////////////////////////////////////////////////////////////////
0:         queue.setAllConsumersExclusiveByDefault(isAllConsumersExclusiveByDefault());
/////////////////////////////////////////////////////////////////////////
1:     public void setAllConsumersExclusiveByDefault(boolean allConsumersExclusiveByDefault) {
1:         this.allConsumersExclusiveByDefault = allConsumersExclusiveByDefault;
1:     }
1: 
1:     public boolean isAllConsumersExclusiveByDefault() {
1:         return allConsumersExclusiveByDefault;
1:     }
1: 
commit:00879cf
/////////////////////////////////////////////////////////////////////////
1:     private boolean prioritizedMessages;
/////////////////////////////////////////////////////////////////////////
1:         destination.setPrioritizedMessages(isPrioritizedMessages());
/////////////////////////////////////////////////////////////////////////
1:             subscription.setMatched(pendingSubscriberPolicy.getSubscriberPendingMessageCursor(broker,name, maxBatchSize,subscription));
/////////////////////////////////////////////////////////////////////////
1:     
1:     
1:     public boolean isPrioritizedMessages() {
1:         return this.prioritizedMessages;
1:     }
1: 
1:     public void setPrioritizedMessages(boolean prioritizedMessages) {
1:         this.prioritizedMessages = prioritizedMessages;
1:     }
commit:1a5ad28
/////////////////////////////////////////////////////////////////////////
1:         baseConfiguration(broker,queue);
/////////////////////////////////////////////////////////////////////////
1:     public void configure(Broker broker,Topic topic) {
1:         baseConfiguration(broker,topic);
1:             SubscriptionRecoveryPolicy srp = subscriptionRecoveryPolicy.copy();
1:             srp.setBroker(broker);
1:             topic.setSubscriptionRecoveryPolicy(srp);
/////////////////////////////////////////////////////////////////////////
0:     public void baseConfiguration(Broker broker,BaseDestination destination) {
/////////////////////////////////////////////////////////////////////////
1:         SlowConsumerStrategy scs = getSlowConsumerStrategy();
1:         if (scs != null) {
0:             scs.setScheduler(broker.getScheduler());
1:         }
1:         destination.setSlowConsumerStrategy(scs);
commit:6e7c4a4
/////////////////////////////////////////////////////////////////////////
commit:785454a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.impl.sql.compile.GetCurrentConnectionNode;
/////////////////////////////////////////////////////////////////////////
1:     private boolean producerFlowControl = true;
/////////////////////////////////////////////////////////////////////////
0:     private int cursorMemoryHighWaterMark=70;
/////////////////////////////////////////////////////////////////////////
0:         destination.setCursorMemoryHighWaterMark(getCursorMemoryHighWaterMark());
/////////////////////////////////////////////////////////////////////////
1:         sub.setCursorMemoryHighWaterMark(getCursorMemoryHighWaterMark());
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
1:         sub.setCursorMemoryHighWaterMark(getCursorMemoryHighWaterMark());
/////////////////////////////////////////////////////////////////////////
1:         sub.setCursorMemoryHighWaterMark(getCursorMemoryHighWaterMark());
/////////////////////////////////////////////////////////////////////////
1:     
0:     public int getCursorMemoryHighWaterMark() {
0: 		return this.cursorMemoryHighWaterMark;
1: 	}
1: 
0: 	public void setCursorMemoryHighWaterMark(int cursorMemoryHighWaterMark) {
0: 		this.cursorMemoryHighWaterMark = cursorMemoryHighWaterMark;
1: 	}
commit:dd9c10d
/////////////////////////////////////////////////////////////////////////
0:     private boolean producerFlowControl = false;
commit:fc63a92
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.ActiveMQPrefetchPolicy;
1: import org.apache.activemq.broker.region.QueueBrowserSubscription;
1: import org.apache.activemq.broker.region.QueueSubscription;
/////////////////////////////////////////////////////////////////////////
1:     private int queuePrefetch=ActiveMQPrefetchPolicy.DEFAULT_QUEUE_PREFETCH;
1:     private int queueBrowserPrefetch=ActiveMQPrefetchPolicy.DEFAULT_QUEUE_BROWSER_PREFETCH;
1:     private int topicPrefetch=ActiveMQPrefetchPolicy.DEFAULT_TOPIC_PREFETCH;
1:     private int durableTopicPrefetch=ActiveMQPrefetchPolicy.DEFAULT_DURABLE_TOPIC_PREFETCH;
1:     
/////////////////////////////////////////////////////////////////////////
0:             //override prefetch size if not set by the Consumer
0:             int prefetch=subscription.getConsumerInfo().getPrefetchSize();
0:             if (prefetch == ActiveMQPrefetchPolicy.DEFAULT_TOPIC_PREFETCH){
0:                 subscription.getConsumerInfo().setPrefetchSize(getTopicPrefetch());
1:             }
/////////////////////////////////////////////////////////////////////////
0:         //override prefetch size if not set by the Consumer
1:         
0:         if (prefetch == ActiveMQPrefetchPolicy.DEFAULT_DURABLE_TOPIC_PREFETCH){
0:             sub.setPrefetchSize(getDurableTopicPrefetch());
1:         }
/////////////////////////////////////////////////////////////////////////
1:     
1:     public void configure(Broker broker, SystemUsage memoryManager, QueueBrowserSubscription sub) {
1:        
0:         int prefetch = sub.getPrefetchSize();
0:         //override prefetch size if not set by the Consumer
1:         
0:         if (prefetch == ActiveMQPrefetchPolicy.DEFAULT_QUEUE_BROWSER_PREFETCH){
0:             sub.setPrefetchSize(getQueueBrowserPrefetch());
1:         }
1:     }
1:     
1:     public void configure(Broker broker, SystemUsage memoryManager, QueueSubscription sub) {
1:         
0:         int prefetch = sub.getPrefetchSize();
0:         //override prefetch size if not set by the Consumer
1:         
0:         if (prefetch == ActiveMQPrefetchPolicy.DEFAULT_QUEUE_PREFETCH){
0:             sub.setPrefetchSize(getQueuePrefetch());
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get the queuePrefetch
1:      * @return the queuePrefetch
1:      */
1:     public int getQueuePrefetch() {
1:         return this.queuePrefetch;
1:     }
1: 
1:     /**
1:      * Set the queuePrefetch
1:      * @param queuePrefetch the queuePrefetch to set
1:      */
1:     public void setQueuePrefetch(int queuePrefetch) {
1:         this.queuePrefetch = queuePrefetch;
1:     }
1: 
1:     /**
1:      * Get the queueBrowserPrefetch
1:      * @return the queueBrowserPrefetch
1:      */
1:     public int getQueueBrowserPrefetch() {
1:         return this.queueBrowserPrefetch;
1:     }
1: 
1:     /**
1:      * Set the queueBrowserPrefetch
1:      * @param queueBrowserPrefetch the queueBrowserPrefetch to set
1:      */
1:     public void setQueueBrowserPrefetch(int queueBrowserPrefetch) {
1:         this.queueBrowserPrefetch = queueBrowserPrefetch;
1:     }
1: 
1:     /**
1:      * Get the topicPrefetch
1:      * @return the topicPrefetch
1:      */
1:     public int getTopicPrefetch() {
1:         return this.topicPrefetch;
1:     }
1: 
1:     /**
1:      * Set the topicPrefetch
1:      * @param topicPrefetch the topicPrefetch to set
1:      */
1:     public void setTopicPrefetch(int topicPrefetch) {
1:         this.topicPrefetch = topicPrefetch;
1:     }
1: 
1:     /**
1:      * Get the durableTopicPrefetch
1:      * @return the durableTopicPrefetch
1:      */
1:     public int getDurableTopicPrefetch() {
1:         return this.durableTopicPrefetch;
1:     }
1: 
1:     /**
1:      * Set the durableTopicPrefetch
1:      * @param durableTopicPrefetch the durableTopicPrefetch to set
1:      */
1:     public void setDurableTopicPrefetch(int durableTopicPrefetch) {
1:         this.durableTopicPrefetch = durableTopicPrefetch;
1:     }
1: 
1: 
commit:47cfa55
/////////////////////////////////////////////////////////////////////////
1:     private int maxBrowsePageSize=BaseDestination.MAX_BROWSE_PAGE_SIZE;
/////////////////////////////////////////////////////////////////////////
0:         destination.setMaxBrowsePageSize(getMaxBrowsePageSize());
/////////////////////////////////////////////////////////////////////////
1:     } 
1:     
1:     public int getMaxBrowsePageSize() {
1:         return maxBrowsePageSize;
1:     }
1: 
1:     public void setMaxBrowsePageSize(int maxPageSize) {
1:         this.maxBrowsePageSize = maxPageSize;
1:     } 
commit:c8bd57c
/////////////////////////////////////////////////////////////////////////
1:     private int maxPageSize=BaseDestination.MAX_PAGE_SIZE;
commit:0d85869
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.Destination;
/////////////////////////////////////////////////////////////////////////
1:     private DeadLetterStrategy deadLetterStrategy = Destination.DEFAULT_DEAD_LETTER_STRATEGY;
commit:cdc2fd3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.BaseDestination;
/////////////////////////////////////////////////////////////////////////
1:     private boolean advisoryForSlowConsumers;
0:     private boolean advisdoryForFastProducers;
1:     private boolean advisoryForDiscardingMessages;
1:     private boolean advisoryWhenFull;
1:     private boolean advisoryForDelivery;
1:     private boolean advisoryForConsumed;
0:         baseConfiguration(queue);
/////////////////////////////////////////////////////////////////////////
1:         
1:         
0:         baseConfiguration(topic);
/////////////////////////////////////////////////////////////////////////
1:     
0:     public void baseConfiguration(BaseDestination destination) {
0:         destination.setProducerFlowControl(isProducerFlowControl());
0:         destination.setEnableAudit(isEnableAudit());
0:         destination.setMaxAuditDepth(getMaxQueueAuditDepth());
0:         destination.setMaxProducersToAudit(getMaxProducersToAudit());
0:         destination.setMaxPageSize(getMaxPageSize());
0:         destination.setUseCache(isUseCache());
0:         destination.setMinimumMessageSize((int) getMinimumMessageSize());
0:         destination.setAdvisoryForConsumed(isAdvisoryForConsumed());
0:         destination.setAdvisoryForDelivery(isAdvisoryForDelivery());
0:         destination.setAdvisoryForDiscardingMessages(isAdvisoryForDiscardingMessages());
0:         destination.setAdvisoryForSlowConsumers(isAdvisoryForSlowConsumers());
0:         destination.setAdvisdoryForFastProducers(isAdvisdoryForFastProducers());
0:         destination.setAdvisoryWhenFull(isAdvisoryWhenFull());
1:     }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @return the advisoryForSlowConsumers
1:      */
1:     public boolean isAdvisoryForSlowConsumers() {
1:         return advisoryForSlowConsumers;
1:     }
1: 
1:     /**
1:      * @param advisoryForSlowConsumers the advisoryForSlowConsumers to set
1:      */
1:     public void setAdvisoryForSlowConsumers(boolean advisoryForSlowConsumers) {
1:         this.advisoryForSlowConsumers = advisoryForSlowConsumers;
1:     }
1: 
1:     /**
1:      * @return the advisoryForDiscardingMessages
1:      */
1:     public boolean isAdvisoryForDiscardingMessages() {
1:         return advisoryForDiscardingMessages;
1:     }
1: 
1:     /**
1:      * @param advisoryForDiscardingMessages the advisoryForDiscardingMessages to set
1:      */
1:     public void setAdvisoryForDiscardingMessages(
1:             boolean advisoryForDiscardingMessages) {
1:         this.advisoryForDiscardingMessages = advisoryForDiscardingMessages;
1:     }
1: 
1:     /**
1:      * @return the advisoryWhenFull
1:      */
1:     public boolean isAdvisoryWhenFull() {
1:         return advisoryWhenFull;
1:     }
1: 
1:     /**
1:      * @param advisoryWhenFull the advisoryWhenFull to set
1:      */
1:     public void setAdvisoryWhenFull(boolean advisoryWhenFull) {
1:         this.advisoryWhenFull = advisoryWhenFull;
1:     }
1: 
1:     /**
1:      * @return the advisoryForDelivery
1:      */
1:     public boolean isAdvisoryForDelivery() {
1:         return advisoryForDelivery;
1:     }
1: 
1:     /**
1:      * @param advisoryForDelivery the advisoryForDelivery to set
1:      */
1:     public void setAdvisoryForDelivery(boolean advisoryForDelivery) {
1:         this.advisoryForDelivery = advisoryForDelivery;
1:     }
1: 
1:     /**
1:      * @return the advisoryForConsumed
1:      */
1:     public boolean isAdvisoryForConsumed() {
1:         return advisoryForConsumed;
1:     }
1: 
1:     /**
1:      * @param advisoryForConsumed the advisoryForConsumed to set
1:      */
1:     public void setAdvisoryForConsumed(boolean advisoryForConsumed) {
1:         this.advisoryForConsumed = advisoryForConsumed;
1:     }
1:     
1:     /**
1:      * @return the advisdoryForFastProducers
1:      */
0:     public boolean isAdvisdoryForFastProducers() {
0:         return advisdoryForFastProducers;
1:     }
1: 
1:     /**
0:      * @param advisdoryForFastProducers the advisdoryForFastProducers to set
1:      */
0:     public void setAdvisdoryForFastProducers(boolean advisdoryForFastProducers) {
0:         this.advisdoryForFastProducers = advisdoryForFastProducers;
1:     }
1: 
commit:ff7033f
/////////////////////////////////////////////////////////////////////////
0:     private int maxPageSize=100;
commit:7d70fec
/////////////////////////////////////////////////////////////////////////
0:     private boolean lazyDispatch=true;
commit:044c07d
/////////////////////////////////////////////////////////////////////////
0:     private boolean lazyDispatch;
/////////////////////////////////////////////////////////////////////////
0:         queue.setLazyDispatch(isLazyDispatch());
/////////////////////////////////////////////////////////////////////////
0:         topic.setLazyDispatch(isLazyDispatch());
/////////////////////////////////////////////////////////////////////////
1:     public boolean isLazyDispatch() {
1:         return lazyDispatch;
1:     }
1: 
1:     public void setLazyDispatch(boolean lazyDispatch) {
1:         this.lazyDispatch = lazyDispatch;
1:     }
1: 
commit:3f9d6e2
/////////////////////////////////////////////////////////////////////////
0:         queue.setOptimizedDispatch(isOptimizedDispatch());
commit:2a153b0
/////////////////////////////////////////////////////////////////////////
1:     private boolean useConsumerPriority=true;
1:     private boolean strictOrderDispatch=false;
/////////////////////////////////////////////////////////////////////////
0:         queue.setUseConsumerPriority(isUseConsumerPriority());
0:         queue.setStrictOrderDispatch(isStrictOrderDispatch());
/////////////////////////////////////////////////////////////////////////
1:     }   
1:     
1:     public boolean isUseConsumerPriority() {
1:         return useConsumerPriority;
1:     }
1: 
1:     public void setUseConsumerPriority(boolean useConsumerPriority) {
1:         this.useConsumerPriority = useConsumerPriority;
1:     }
1: 
1:     public boolean isStrictOrderDispatch() {
1:         return strictOrderDispatch;
1:     }
1: 
1:     public void setStrictOrderDispatch(boolean strictOrderDispatch) {
1:         this.strictOrderDispatch = strictOrderDispatch;
1:     }
commit:6d0c552
/////////////////////////////////////////////////////////////////////////
0:     private int maxAuditDepth=2048;
0:     private int maxQueueAuditDepth=2048;
1:     private boolean useCache=true;
1:     private long minimumMessageSize=1024;
/////////////////////////////////////////////////////////////////////////
0:         queue.setUseCache(isUseCache());
0:         queue.setMinimumMessageSize((int) getMinimumMessageSize());
/////////////////////////////////////////////////////////////////////////
0:         topic.setUseCache(isUseCache());
0:         topic.setMinimumMessageSize((int) getMinimumMessageSize());
/////////////////////////////////////////////////////////////////////////
1:     
1:     public boolean isUseCache() {
1:         return useCache;
1:     }
1: 
1:     public void setUseCache(boolean useCache) {
1:         this.useCache = useCache;
1:     }
1: 
1:     public long getMinimumMessageSize() {
1:         return minimumMessageSize;
1:     }
1: 
1:     /**
0:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.MemoryPropertyEditor"
1:      */
1:     public void setMinimumMessageSize(long minimumMessageSize) {
1:         this.minimumMessageSize = minimumMessageSize;
1:     }      
commit:d0f3d4d
/////////////////////////////////////////////////////////////////////////
0:     private int maxPageSize=1000;
/////////////////////////////////////////////////////////////////////////
0:         queue.setMaxPageSize(getMaxPageSize());
/////////////////////////////////////////////////////////////////////////
0:         topic.setMaxPageSize(getMaxPageSize());
/////////////////////////////////////////////////////////////////////////
1:     
1:     public int getMaxPageSize() {
1:         return maxPageSize;
1:     }
1: 
1:     public void setMaxPageSize(int maxPageSize) {
1:         this.maxPageSize = maxPageSize;
1:     }    
commit:23cda2d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void configure(Broker broker,Queue queue) {
/////////////////////////////////////////////////////////////////////////
1:             PendingMessageCursor messages = pendingQueuePolicy.getQueuePendingMessageCursor(broker,queue);
/////////////////////////////////////////////////////////////////////////
0:             subscription.setMatched(pendingSubscriberPolicy.getSubscriberPendingMessageCursor(broker,name, maxBatchSize));
1:         String clientId = sub.getSubscriptionKey().getClientId();
1:         String subName = sub.getSubscriptionKey().getSubscriptionName();
0:             PendingMessageCursor cursor = pendingDurableSubscriberPolicy.getSubscriberPendingMessageCursor(broker,clientId, subName,prefetch,sub);
commit:83c3dca
/////////////////////////////////////////////////////////////////////////
1:             queue.getMemoryUsage().setLimit(memoryLimit);
/////////////////////////////////////////////////////////////////////////
1:             topic.getMemoryUsage().setLimit(memoryLimit);
commit:9dd11cb
/////////////////////////////////////////////////////////////////////////
0:     private int maxProducersToAudit=32;
0:     private int maxAuditDepth=1024;
0:     private int maxQueueAuditDepth=1;
1:     private boolean optimizedDispatch=false;
0:    
/////////////////////////////////////////////////////////////////////////
0:         queue.setMaxAuditDepth(getMaxQueueAuditDepth());
/////////////////////////////////////////////////////////////////////////
0:         sub.setMaxAuditDepth(getMaxAuditDepth());
0:         sub.setMaxProducersToAudit(getMaxProducersToAudit());
/////////////////////////////////////////////////////////////////////////
1:     public int getMaxQueueAuditDepth() {
1:         return maxQueueAuditDepth;
1:     }
0: 
1:     public void setMaxQueueAuditDepth(int maxQueueAuditDepth) {
1:         this.maxQueueAuditDepth = maxQueueAuditDepth;
1:     }
0: 
1:     public boolean isOptimizedDispatch() {
1:         return optimizedDispatch;
1:     }
0: 
1:     public void setOptimizedDispatch(boolean optimizedDispatch) {
1:         this.optimizedDispatch = optimizedDispatch;
1:     }
0: 
commit:1ee0017
/////////////////////////////////////////////////////////////////////////
0:     private int maxProducersToAudit=1024;
0:     private int maxAuditDepth=1;
1:     private boolean enableAudit=true;
/////////////////////////////////////////////////////////////////////////
0:         queue.setEnableAudit(isEnableAudit());
0:         queue.setMaxAuditDepth(getMaxAuditDepth());
0:         queue.setMaxProducersToAudit(getMaxProducersToAudit());
/////////////////////////////////////////////////////////////////////////
0:         topic.setEnableAudit(isEnableAudit());
0:         topic.setMaxAuditDepth(getMaxAuditDepth());
0:         topic.setMaxProducersToAudit(getMaxProducersToAudit());
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @return true if producer flow control enabled
1:      */
1:     /**
1:      * @param producerFlowControl
1:      */
1:     /**
1:      * @return the maxProducersToAudit
1:      */
1:     public int getMaxProducersToAudit() {
1:         return maxProducersToAudit;
1:     }
0: 
1:     /**
1:      * @param maxProducersToAudit the maxProducersToAudit to set
1:      */
1:     public void setMaxProducersToAudit(int maxProducersToAudit) {
1:         this.maxProducersToAudit = maxProducersToAudit;
1:     }
0: 
1:     /**
1:      * @return the maxAuditDepth
1:      */
1:     public int getMaxAuditDepth() {
1:         return maxAuditDepth;
1:     }
0: 
1:     /**
1:      * @param maxAuditDepth the maxAuditDepth to set
1:      */
1:     public void setMaxAuditDepth(int maxAuditDepth) {
1:         this.maxAuditDepth = maxAuditDepth;
1:     }
0: 
1:     /**
1:      * @return the enableAudit
1:      */
1:     public boolean isEnableAudit() {
1:         return enableAudit;
1:     }
0: 
1:     /**
1:      * @param enableAudit the enableAudit to set
1:      */
1:     public void setEnableAudit(boolean enableAudit) {
1:         this.enableAudit = enableAudit;
1:     }
0: 
commit:0da68b4
/////////////////////////////////////////////////////////////////////////
0:     private boolean producerFlowControl = true;
/////////////////////////////////////////////////////////////////////////
0:         queue.setProducerFlowControl(isProducerFlowControl());
/////////////////////////////////////////////////////////////////////////
0:         topic.setProducerFlowControl(isProducerFlowControl());
/////////////////////////////////////////////////////////////////////////
1:     public boolean isProducerFlowControl() {
1:         return producerFlowControl;
1:     }
0: 
1:     public void setProducerFlowControl(boolean producerFlowControl) {
1:         this.producerFlowControl = producerFlowControl;
1:     }
0: 
commit:6d8e2c5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.SystemUsage;
/////////////////////////////////////////////////////////////////////////
0:             queue.getBrokerMemoryUsage().setLimit(memoryLimit);
/////////////////////////////////////////////////////////////////////////
0:             topic.getBrokerMemoryUsage().setLimit(memoryLimit);
1:     public void configure(Broker broker, SystemUsage memoryManager, TopicSubscription subscription) {
/////////////////////////////////////////////////////////////////////////
1:     public void configure(Broker broker, SystemUsage memoryManager, DurableTopicSubscription sub) {
1:             cursor.setSystemUsage(memoryManager);
commit:0c0be94
/////////////////////////////////////////////////////////////////////////
0:  * 
0:  * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE
0:  * file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file
0:  * to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
0:  * License. You may obtain a copy of the License at
0:  * 
0:  * 
0:  * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
0:  * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
0:  * specific language governing permissions and limitations under the License.
0: 
1: import org.apache.activemq.broker.Broker;
1: import org.apache.activemq.broker.region.DurableTopicSubscription;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.memory.UsageManager;
0:  * Represents an entry in a {@link PolicyMap} for assigning policies to a specific destination or a hierarchical
0:  * wildcard area of destinations.
0: public class PolicyEntry extends DestinationMapEntry{
0:     private static final Log log=LogFactory.getLog(PolicyEntry.class);
/////////////////////////////////////////////////////////////////////////
1:     private PendingQueueMessageStoragePolicy pendingQueuePolicy;
1:     private PendingDurableSubscriberMessageStoragePolicy pendingDurableSubscriberPolicy;
1:     private PendingSubscriberMessageStoragePolicy pendingSubscriberPolicy;
0:     public void configure(Queue queue,Store tmpStore){
0:         if(dispatchPolicy!=null){
0:         if(deadLetterStrategy!=null){
0:         if(memoryLimit>0){
0:         if(pendingQueuePolicy!=null){
0:             PendingMessageCursor messages=pendingQueuePolicy.getQueuePendingMessageCursor(queue,tmpStore);
0:     public void configure(Topic topic){
0:         if(dispatchPolicy!=null){
0:         if(deadLetterStrategy!=null){
0:         if(subscriptionRecoveryPolicy!=null){
0:         if(memoryLimit>0){
0:     public void configure(Broker broker,UsageManager memoryManager,TopicSubscription subscription){
0:         if(pendingMessageLimitStrategy!=null){
0:             int value=pendingMessageLimitStrategy.getMaximumPendingMessageLimit(subscription);
0:             int consumerLimit=subscription.getInfo().getMaximumPendingMessageLimit();
0:             if(consumerLimit>0){
0:                 if(value<0||consumerLimit<value){
0:                     value=consumerLimit;
0:             if(value>=0){
0:                 if(log.isDebugEnabled()){
0:                     log.debug("Setting the maximumPendingMessages size to: "+value+" for consumer: "
0:                             +subscription.getInfo().getConsumerId());
0:         if(messageEvictionStrategy!=null){
0:         if (pendingSubscriberPolicy!=null) {
1:             String name = subscription.getContext().getClientId() + "_" + subscription.getConsumerInfo().getConsumerId();
1:             int maxBatchSize = subscription.getConsumerInfo().getPrefetchSize();
0:             subscription.setMatched(pendingSubscriberPolicy.getSubscriberPendingMessageCursor(name,broker.getTempDataStore(),maxBatchSize));
1:         }
1:     }
0: 
0:     public void configure(Broker broker,UsageManager memoryManager,DurableTopicSubscription sub){
0:         String clientId=sub.getClientId();
0:         String subName=sub.getSubscriptionName();
0:         int prefetch=sub.getPrefetchSize();
0:         if(pendingDurableSubscriberPolicy!=null){
0:             PendingMessageCursor cursor=pendingDurableSubscriberPolicy.getSubscriberPendingMessageCursor(clientId,
0:                     subName,broker.getTempDataStore(),prefetch);
0:             cursor.setUsageManager(memoryManager);
1:             sub.setPending(cursor);
1:         }
0:     public DispatchPolicy getDispatchPolicy(){
0:     public void setDispatchPolicy(DispatchPolicy policy){
0:         this.dispatchPolicy=policy;
0:     public SubscriptionRecoveryPolicy getSubscriptionRecoveryPolicy(){
0:     public void setSubscriptionRecoveryPolicy(SubscriptionRecoveryPolicy subscriptionRecoveryPolicy){
0:         this.subscriptionRecoveryPolicy=subscriptionRecoveryPolicy;
0:     public boolean isSendAdvisoryIfNoConsumers(){
0:      * Sends an advisory message if a non-persistent message is sent and there are no active consumers
0:     public void setSendAdvisoryIfNoConsumers(boolean sendAdvisoryIfNoConsumers){
0:         this.sendAdvisoryIfNoConsumers=sendAdvisoryIfNoConsumers;
0:     public DeadLetterStrategy getDeadLetterStrategy(){
0:      * Sets the policy used to determine which dead letter queue destination should be used
0:     public void setDeadLetterStrategy(DeadLetterStrategy deadLetterStrategy){
0:         this.deadLetterStrategy=deadLetterStrategy;
0:     public PendingMessageLimitStrategy getPendingMessageLimitStrategy(){
0:      * Sets the strategy to calculate the maximum number of messages that are allowed to be pending on consumers (in
0:      * addition to their prefetch sizes).
0:      * Once the limit is reached, non-durable topics can then start discarding old messages. This allows us to keep
0:      * dispatching messages to slow consumers while not blocking fast consumers and discarding the messages oldest
0:      * first.
0:     public void setPendingMessageLimitStrategy(PendingMessageLimitStrategy pendingMessageLimitStrategy){
0:         this.pendingMessageLimitStrategy=pendingMessageLimitStrategy;
0:     public MessageEvictionStrategy getMessageEvictionStrategy(){
0:      * Sets the eviction strategy used to decide which message to evict when the slow consumer needs to discard messages
0:     public void setMessageEvictionStrategy(MessageEvictionStrategy messageEvictionStrategy){
0:         this.messageEvictionStrategy=messageEvictionStrategy;
0:     public long getMemoryLimit(){
/////////////////////////////////////////////////////////////////////////
0:     public void setMemoryLimit(long memoryLimit){
0:         this.memoryLimit=memoryLimit;
0:     public MessageGroupMapFactory getMessageGroupMapFactory(){
0:         if(messageGroupMapFactory==null){
0:             messageGroupMapFactory=new MessageGroupHashBucketFactory();
0:      * Sets the factory used to create new instances of {MessageGroupMap} used to implement the <a
0:      * href="http://incubator.apache.org/activemq/message-groups.html">Message Groups</a> functionality.
0:     public void setMessageGroupMapFactory(MessageGroupMapFactory messageGroupMapFactory){
0:         this.messageGroupMapFactory=messageGroupMapFactory;
1:      * @return the pendingDurableSubscriberPolicy
0:     public PendingDurableSubscriberMessageStoragePolicy getPendingDurableSubscriberPolicy(){
1:         return this.pendingDurableSubscriberPolicy;
0:      * @param pendingDurableSubscriberPolicy the pendingDurableSubscriberPolicy to set
0:     public void setPendingDurableSubscriberPolicy(
0:             PendingDurableSubscriberMessageStoragePolicy pendingDurableSubscriberPolicy){
0:         this.pendingDurableSubscriberPolicy=pendingDurableSubscriberPolicy;
1:     /**
1:      * @return the pendingQueuePolicy
1:      */
0:     public PendingQueueMessageStoragePolicy getPendingQueuePolicy(){
1:         return this.pendingQueuePolicy;
1:     }
0: 
0:     
1:     /**
1:      * @param pendingQueuePolicy the pendingQueuePolicy to set
1:      */
0:     public void setPendingQueuePolicy(PendingQueueMessageStoragePolicy pendingQueuePolicy){
0:         this.pendingQueuePolicy=pendingQueuePolicy;
1:     }
0: 
0:     
1:     /**
1:      * @return the pendingSubscriberPolicy
1:      */
0:     public PendingSubscriberMessageStoragePolicy getPendingSubscriberPolicy(){
1:         return this.pendingSubscriberPolicy;
1:     }
0: 
0:     
1:     /**
1:      * @param pendingSubscriberPolicy the pendingSubscriberPolicy to set
1:      */
0:     public void setPendingSubscriberPolicy(PendingSubscriberMessageStoragePolicy pendingSubscriberPolicy){
0:         this.pendingSubscriberPolicy=pendingSubscriberPolicy;
1:     }
0: 
commit:e006780
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.kaha.Store;
/////////////////////////////////////////////////////////////////////////
0:     public void configure(Queue queue, Store tmpStore) {
/////////////////////////////////////////////////////////////////////////
0:             PendingMessageCursor messages = pendingQueueMessageStoragePolicy.getQueuePendingMessageCursor(queue,tmpStore);
commit:3a9299b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.cursors.PendingMessageCursor;
/////////////////////////////////////////////////////////////////////////
0:     private PendingQueueMessageStoragePolicy pendingQueueMessageStoragePolicy;
/////////////////////////////////////////////////////////////////////////
0:         if (pendingQueueMessageStoragePolicy != null) {
0:             PendingMessageCursor messages = pendingQueueMessageStoragePolicy.getQueuePendingMessageCursor();
1:             queue.setMessages(messages);
1:         }
/////////////////////////////////////////////////////////////////////////
0:         
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * @return the pendingQueueMessageStoragePolicy
1:      */
0:     public PendingQueueMessageStoragePolicy getPendingQueueMessageStoragePolicy(){
0:         return this.pendingQueueMessageStoragePolicy;
1:     }
0: 
0:     
1:     /**
0:      * @param pendingQueueMessageStoragePolicy the pendingQueueMessageStoragePolicy to set
1:      */
0:     public void setPendingQueueMessageStoragePolicy(PendingQueueMessageStoragePolicy pendingQueueMessageStoragePolicy){
0:         this.pendingQueueMessageStoragePolicy=pendingQueueMessageStoragePolicy;
1:     }
0: 
0:     
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(PolicyEntry.class);
commit:9ad6c08
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         destination.setSendAdvisoryIfNoConsumers(sendAdvisoryIfNoConsumers);
commit:a321204
/////////////////////////////////////////////////////////////////////////
1:     private int timeBeforeDispatchStarts = 0;
1:     private int consumersBeforeDispatchStarts = 0;
/////////////////////////////////////////////////////////////////////////
0:         queue.setTimeBeforeDispatchStarts(getTimeBeforeDispatchStarts());
0:         queue.setConsumersBeforeDispatchStarts(getConsumersBeforeDispatchStarts());
/////////////////////////////////////////////////////////////////////////
1:     public int getTimeBeforeDispatchStarts() {
1:         return timeBeforeDispatchStarts;
1:     }
0: 
1:     public void setTimeBeforeDispatchStarts(int timeBeforeDispatchStarts) {
1:         this.timeBeforeDispatchStarts = timeBeforeDispatchStarts;
1:     }
0: 
1:     public int getConsumersBeforeDispatchStarts() {
1:         return consumersBeforeDispatchStarts;
1:     }
0: 
1:     public void setConsumersBeforeDispatchStarts(int consumersBeforeDispatchStarts) {
1:         this.consumersBeforeDispatchStarts = consumersBeforeDispatchStarts;
1:     }
0: 
author:Colin W Macnaughton
-------------------------------------------------------------------------------
commit:48764be
/////////////////////////////////////////////////////////////////////////
1:     private long blockedProducerWarningInterval = Destination.DEFAULT_BLOCKED_PRODUCER_WARNING_INTERVAL;
/////////////////////////////////////////////////////////////////////////
0:         destination.setBlockedProducerWarningInterval(getBlockedProducerWarningInterval());
/////////////////////////////////////////////////////////////////////////
1:      * Set's the interval at which warnings about producers being blocked by
1:      * resource usage will be triggered. Values of 0 or less will disable
1:      * warnings
0:      * 
1:      * @param blockedProducerWarningInterval the interval at which warning about
1:      *            blocked producers will be triggered.
1:      */
1:     public void setBlockedProducerWarningInterval(long blockedProducerWarningInterval) {
1:         this.blockedProducerWarningInterval = blockedProducerWarningInterval;
1:     }
0: 
1:     /**
0:      * 
1:      * @return the interval at which warning about blocked producers will be
1:      *         triggered.
1:      */
1:     public long getBlockedProducerWarningInterval() {
1:         return blockedProducerWarningInterval;
1:     }
0:     
1:     /**
author:James Strachan
-------------------------------------------------------------------------------
commit:3013c20
/////////////////////////////////////////////////////////////////////////
0:      * href="http://activemq.apache.org/message-groups.html">Message Groups</a> functionality.
commit:e7e15b5
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.group.MessageGroupHashBucketFactory;
1: import org.apache.activemq.broker.region.group.MessageGroupMapFactory;
/////////////////////////////////////////////////////////////////////////
1:     private MessageGroupMapFactory messageGroupMapFactory;
0:     
/////////////////////////////////////////////////////////////////////////
1:         queue.setMessageGroupMapFactory(getMessageGroupMapFactory());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public MessageGroupMapFactory getMessageGroupMapFactory() {
0:         if (messageGroupMapFactory == null) {
0:             messageGroupMapFactory = new MessageGroupHashBucketFactory(); 
1:         }
1:         return messageGroupMapFactory;
1:     }
0: 
1:     /**
0:      * Sets the factory used to create new instances of {MessageGroupMap} used to implement the 
0:      * <a href="http://incubator.apache.org/activemq/message-groups.html">Message Groups</a> functionality.
1:      */
0:     public void setMessageGroupMapFactory(MessageGroupMapFactory messageGroupMapFactory) {
0:         this.messageGroupMapFactory = messageGroupMapFactory;
1:     }
0: 
0:     
commit:062dc56
/////////////////////////////////////////////////////////////////////////
1:     private MessageEvictionStrategy messageEvictionStrategy;
/////////////////////////////////////////////////////////////////////////
0:         if (messageEvictionStrategy != null) {
1:             subscription.setMessageEvictionStrategy(messageEvictionStrategy);
0:         }
/////////////////////////////////////////////////////////////////////////
0: 
0:     public MessageEvictionStrategy getMessageEvictionStrategy() {
1:         return messageEvictionStrategy;
0:     }
0: 
1:     /**
0:      * Sets the eviction strategy used to decide which message to evict when the
0:      * slow consumer needs to discard messages
1:      */
0:     public void setMessageEvictionStrategy(MessageEvictionStrategy messageEvictionStrategy) {
0:         this.messageEvictionStrategy = messageEvictionStrategy;
0:     }
0: 
commit:bed10aa
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
/////////////////////////////////////////////////////////////////////////
0:     private static final Log log = LogFactory.getLog(PolicyEntry.class);
0:     
/////////////////////////////////////////////////////////////////////////
0:             int consumerLimit = subscription.getInfo().getMaximumPendingMessageLimit();
0:             if (consumerLimit > 0) {
0:                 if (value < 0 || consumerLimit < value) {
0:                     value = consumerLimit;
0:                 }
0:             }
0:                 if (log.isDebugEnabled()) {
0:                     log.debug("Setting the maximumPendingMessages size to: " + value + " for consumer: " + subscription.getInfo().getConsumerId());
0:                 }
commit:95d0dec
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.TopicSubscription;
/////////////////////////////////////////////////////////////////////////
1:     private PendingMessageLimitStrategy pendingMessageLimitStrategy;
/////////////////////////////////////////////////////////////////////////
0:     public void configure(TopicSubscription subscription) {
0:         if (pendingMessageLimitStrategy != null) {
0:             int value = pendingMessageLimitStrategy.getMaximumPendingMessageLimit(subscription);
0:             if (value >= 0) {
1:                 subscription.setMaximumPendingMessages(value);
0:             }
0:         }
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:      * Sets the policy used to determine which dead letter queue destination
0:      * should be used
/////////////////////////////////////////////////////////////////////////
0:      * Sets the number of hash buckets to use for the message group
0:      * functionality. This is only applicable to using message groups to
0:      * parallelize processing of a queue while preserving order across an
0:      * individual JMSXGroupID header value. This value sets the number of hash
0:      * buckets that will be used (i.e. the maximum possible concurrency).
0: 
0:     public PendingMessageLimitStrategy getPendingMessageLimitStrategy() {
1:         return pendingMessageLimitStrategy;
0:     }
0: 
1:     /**
0:      * Sets the strategy to calculate the maximum number of messages that are
0:      * allowed to be pending on consumers (in addition to their prefetch sizes).
0:      * 
0:      * Once the limit is reached, non-durable topics can then start discarding
0:      * old messages. This allows us to keep dispatching messages to slow
0:      * consumers while not blocking fast consumers and discarding the messages
0:      * oldest first.
1:      */
0:     public void setPendingMessageLimitStrategy(PendingMessageLimitStrategy pendingMessageLimitStrategy) {
0:         this.pendingMessageLimitStrategy = pendingMessageLimitStrategy;
0:     }
commit:d7f9146
/////////////////////////////////////////////////////////////////////////
0:     private int messageGroupHashBucketCount = 1024;
/////////////////////////////////////////////////////////////////////////
0:         queue.setMessageGroupHashBucketCount(messageGroupHashBucketCount);
/////////////////////////////////////////////////////////////////////////
0: 
0:     public int getMessageGroupHashBucketCount() {
0:         return messageGroupHashBucketCount;
0:     }
0: 
1:     /**
0:      * Sets the number of hash buckets to use for the message group functionality. 
0:      * This is only applicable to using message groups to parallelize processing of a queue
0:      * while preserving order across an individual JMSXGroupID header value.
0:      * This value sets the number of hash buckets that will be used (i.e. the maximum possible concurrency).
1:      */
0:     public void setMessageGroupHashBucketCount(int messageGroupHashBucketCount) {
0:         this.messageGroupHashBucketCount = messageGroupHashBucketCount;
0:     }
commit:8f22cfa
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private DeadLetterStrategy deadLetterStrategy;
/////////////////////////////////////////////////////////////////////////
commit:10c6b29
/////////////////////////////////////////////////////////////////////////
0:         if (deadLetterStrategy != null) {
0:             queue.setDeadLetterStrategy(deadLetterStrategy);
0:         }
0:         if (deadLetterStrategy != null) {
0:             topic.setDeadLetterStrategy(deadLetterStrategy);
0:         }
commit:88203ae
/////////////////////////////////////////////////////////////////////////
0:     private DeadLetterStrategy deadLetterStrategy = new SharedDeadLetterStrategy();
/////////////////////////////////////////////////////////////////////////
0: 
0:     public DeadLetterStrategy getDeadLetterStrategy() {
1:         return deadLetterStrategy;
0:     }
0: 
0:     /**
0:      * Sets the policy used to determine which dead letter queue destination should be used
0:      */
0:     public void setDeadLetterStrategy(DeadLetterStrategy deadLetterStrategy) {
0:         this.deadLetterStrategy = deadLetterStrategy;
0:     }
0:     
0:     
commit:27f7cab
/////////////////////////////////////////////////////////////////////////
1:     private boolean sendAdvisoryIfNoConsumers;
commit:c2408b8
/////////////////////////////////////////////////////////////////////////
0:  * specific destination or a hierarchical wildcard area of destinations.
/////////////////////////////////////////////////////////////////////////
0:     private boolean sendAdvisoryIfNoConsumers = true;
/////////////////////////////////////////////////////////////////////////
0:         topic.setSendAdvisoryIfNoConsumers(sendAdvisoryIfNoConsumers);
/////////////////////////////////////////////////////////////////////////
0:     public boolean isSendAdvisoryIfNoConsumers() {
1:         return sendAdvisoryIfNoConsumers;
0:     }
0: 
0:     /**
0:      * Sends an advisory message if a non-persistent message is sent and there
0:      * are no active consumers
0:      */
0:     public void setSendAdvisoryIfNoConsumers(boolean sendAdvisoryIfNoConsumers) {
0:         this.sendAdvisoryIfNoConsumers = sendAdvisoryIfNoConsumers;
0:     }
============================================================================