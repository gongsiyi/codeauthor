1:43c3cae: /**
1:43c3cae:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:43c3cae:  * contributor license agreements.  See the NOTICE file distributed with
1:43c3cae:  * this work for additional information regarding copyright ownership.
1:43c3cae:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:43c3cae:  * (the "License"); you may not use this file except in compliance with
1:43c3cae:  * the License.  You may obtain a copy of the License at
1:43c3cae:  *
1:43c3cae:  *      http://www.apache.org/licenses/LICENSE-2.0
1:43c3cae:  *
1:43c3cae:  * Unless required by applicable law or agreed to in writing, software
1:43c3cae:  * distributed under the License is distributed on an "AS IS" BASIS,
1:43c3cae:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:43c3cae:  * See the License for the specific language governing permissions and
1:43c3cae:  * limitations under the License.
1:43c3cae:  */
1:43c3cae: package org.apache.activemq.java;
5:43c3cae: 
1:43c3cae: import static org.junit.Assert.assertEquals;
1:a253ad3: import static org.junit.Assert.assertFalse;
1:43c3cae: import static org.junit.Assert.assertTrue;
1:43c3cae: 
1:43c3cae: import java.util.Arrays;
1:a253ad3: import java.util.HashSet;
1:a253ad3: import java.util.Set;
1:43c3cae: import java.util.concurrent.TimeUnit;
1:43c3cae: 
1:43c3cae: import javax.jms.Session;
1:43c3cae: 
1:43c3cae: import org.apache.activemq.ActiveMQConnection;
1:43c3cae: import org.apache.activemq.ActiveMQConnectionFactory;
1:43c3cae: import org.apache.activemq.RuntimeConfigTestSupport;
1:43c3cae: import org.apache.activemq.broker.BrokerPlugin;
1:43c3cae: import org.apache.activemq.broker.BrokerService;
1:a253ad3: import org.apache.activemq.broker.region.BaseDestination;
1:a253ad3: import org.apache.activemq.broker.region.Queue;
1:a253ad3: import org.apache.activemq.broker.region.Topic;
1:43c3cae: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:43c3cae: import org.apache.activemq.broker.region.policy.PolicyMap;
1:43c3cae: import org.apache.activemq.command.ActiveMQQueue;
1:43c3cae: import org.apache.activemq.command.ActiveMQTopic;
1:43c3cae: import org.apache.activemq.plugin.java.JavaRuntimeConfigurationBroker;
1:43c3cae: import org.apache.activemq.plugin.java.JavaRuntimeConfigurationPlugin;
1:43c3cae: import org.junit.Test;
1:43c3cae: 
1:43c3cae: public class JavaPolicyEntryTest extends RuntimeConfigTestSupport {
1:43c3cae: 
1:43c3cae:     public static final int SLEEP = 2; // seconds
1:43c3cae:     private JavaRuntimeConfigurationBroker javaConfigBroker;
1:43c3cae: 
1:43c3cae:     public void startBroker(BrokerService brokerService) throws Exception {
1:43c3cae:         this.brokerService = brokerService;
1:43c3cae:         brokerService.setPlugins(new BrokerPlugin[]{new JavaRuntimeConfigurationPlugin()});
1:43c3cae:         brokerService.setPersistent(false);
1:43c3cae:         brokerService.start();
1:43c3cae:         brokerService.waitUntilStarted();
1:43c3cae: 
1:43c3cae:         javaConfigBroker =
1:43c3cae:                 (JavaRuntimeConfigurationBroker) brokerService.getBroker().getAdaptor(JavaRuntimeConfigurationBroker.class);
1:43c3cae:     }
1:43c3cae: 
1:a253ad3:     /**
1:a253ad3:      * Test modifying a policy
1:a253ad3:      *
1:a253ad3:      * @throws Exception
1:a253ad3:      */
1:43c3cae:     @Test
1:43c3cae:     public void testMod() throws Exception {
1:43c3cae:         BrokerService brokerService = new BrokerService();
1:43c3cae:         PolicyMap policyMap = new PolicyMap();
1:43c3cae:         PolicyEntry entry = new PolicyEntry();
1:43c3cae:         entry.setQueue(">");
1:43c3cae:         entry.setMemoryLimit(1024);
1:43c3cae:         policyMap.setPolicyEntries(Arrays.asList(entry));
1:43c3cae:         brokerService.setDestinationPolicy(policyMap);
1:43c3cae: 
1:43c3cae:         startBroker(brokerService);
1:43c3cae:         assertTrue("broker alive", brokerService.isStarted());
1:43c3cae:         verifyQueueLimit("Before", 1024);
1:43c3cae: 
1:43c3cae:         //Reapply new limit
1:43c3cae:         entry.setMemoryLimit(4194304);
1:43c3cae:         javaConfigBroker.modifyPolicyEntry(entry);
1:43c3cae:         TimeUnit.SECONDS.sleep(SLEEP);
1:43c3cae: 
1:43c3cae:         verifyQueueLimit("After", 4194304);
1:9e7fae0: 
1:43c3cae:       // change to existing dest
1:43c3cae:         verifyQueueLimit("Before", 4194304);
1:43c3cae:     }
1:9e7fae0: 
1:a253ad3:     /**
1:a253ad3:      * Test modifying a policy but only applying a subset o
1:a253ad3:      * properties retroactively to existing destinations
1:a253ad3:      *
1:a253ad3:      * @throws Exception
1:a253ad3:      */
1:a253ad3:     @Test
1:a253ad3:     public void testModFilterProperties() throws Exception {
1:a253ad3:         BrokerService brokerService = new BrokerService();
1:a253ad3:         PolicyMap policyMap = new PolicyMap();
1:a253ad3:         PolicyEntry entry = new PolicyEntry();
1:a253ad3:         entry.setQueue(">");
1:a253ad3:         entry.setMemoryLimit(1024);
1:a253ad3:         entry.setMaxPageSize(500);
1:a253ad3:         entry.setMaxBrowsePageSize(100);
1:a253ad3:         policyMap.setPolicyEntries(Arrays.asList(entry));
1:a253ad3:         brokerService.setDestinationPolicy(policyMap);
1:a253ad3: 
1:a253ad3:         startBroker(brokerService);
1:a253ad3:         assertTrue("broker alive", brokerService.isStarted());
1:a253ad3:         verifyQueueLimit("Before", 1024);
1:a253ad3:         assertEquals(500, getQueue("Before").getMaxPageSize());
1:a253ad3:         assertEquals(100, getQueue("Before").getMaxBrowsePageSize());
1:a253ad3: 
1:a253ad3:         //Reapply new limit, add the property to the list of included properties
1:a253ad3:         entry.setMemoryLimit(4194304);
1:a253ad3:         entry.setMaxPageSize(300);
1:a253ad3:         entry.setMaxBrowsePageSize(200);
1:a253ad3:         Set<String> properties = new HashSet<>();
1:a253ad3:         properties.add("memoryLimit");
1:a253ad3:         properties.add("maxPageSize");
1:a253ad3:         javaConfigBroker.modifyPolicyEntry(entry, false, properties);
1:a253ad3:         TimeUnit.SECONDS.sleep(SLEEP);
1:a253ad3: 
1:a253ad3:         verifyQueueLimit("After", 4194304);
1:a253ad3:         assertEquals(300, getQueue("After").getMaxPageSize());
1:a253ad3:         assertEquals(200, getQueue("After").getMaxBrowsePageSize());
1:a253ad3: 
1:a253ad3:        // change to existing dest, maxBrowsePageSize was not included
1:a253ad3:         //in the property list so it should not have changed
1:a253ad3:         verifyQueueLimit("Before", 4194304);
1:a253ad3:         assertEquals(300, getQueue("Before").getMaxPageSize());
1:a253ad3:         assertEquals(100, getQueue("Before").getMaxBrowsePageSize());
1:a253ad3:     }
1:a253ad3: 
1:a253ad3:     @Test
1:a253ad3:     public void testModQueueAndTopic() throws Exception {
1:a253ad3:         BrokerService brokerService = new BrokerService();
1:a253ad3:         PolicyMap policyMap = new PolicyMap();
1:a253ad3:         PolicyEntry qEntry = new PolicyEntry();
1:a253ad3:         qEntry.setQueue(">");
1:a253ad3:         qEntry.setPersistJMSRedelivered(true);
1:a253ad3:         PolicyEntry tEntry = new PolicyEntry();
1:a253ad3:         tEntry.setTopic(">");
1:a253ad3:         tEntry.setLazyDispatch(true);
1:a253ad3:         policyMap.setPolicyEntries(Arrays.asList(qEntry, tEntry));
1:a253ad3:         brokerService.setDestinationPolicy(policyMap);
1:a253ad3: 
1:a253ad3:         startBroker(brokerService);
1:a253ad3:         assertTrue("broker alive", brokerService.isStarted());
1:a253ad3:         assertEquals(true, getQueue("queueBefore").isPersistJMSRedelivered());
1:a253ad3:         assertEquals(true, getTopic("topicBefore").isLazyDispatch());
1:a253ad3: 
1:a253ad3:         //Reapply new limit, add the property to the list of included properties
1:a253ad3:         qEntry.setPersistJMSRedelivered(false);
1:a253ad3:         tEntry.setLazyDispatch(false);
1:a253ad3:         Set<String> queueProperties = new HashSet<>();
1:a253ad3:         queueProperties.add("persistJMSRedelivered");
1:a253ad3:         Set<String> topicProperties = new HashSet<>();
1:a253ad3:         topicProperties.add("lazyDispatch");
1:a253ad3:         javaConfigBroker.modifyPolicyEntry(qEntry, false, queueProperties);
1:a253ad3:         javaConfigBroker.modifyPolicyEntry(tEntry, false, topicProperties);
1:a253ad3:         TimeUnit.SECONDS.sleep(SLEEP);
1:a253ad3: 
1:a253ad3:         assertEquals(false, getQueue("queueBefore").isPersistJMSRedelivered());
1:a253ad3:         assertEquals(false, getTopic("topicBefore").isLazyDispatch());
1:a253ad3: 
1:a253ad3:         assertEquals(false, getQueue("queueAfter").isPersistJMSRedelivered());
1:a253ad3:         assertEquals(false, getTopic("topicAfter").isLazyDispatch());
1:a253ad3:     }
1:a253ad3: 
1:a253ad3:     /**
1:a253ad3:      * Test that a property that is not part of the update methods (can't be changed after creation)
1:a253ad3:      * will not be applied to existing destinations but will be applied to new destinations
1:a253ad3:      *
1:a253ad3:      * @throws Exception
1:a253ad3:      */
1:a253ad3:     @Test
1:a253ad3:     public void testModFilterExcludedProperty() throws Exception {
1:a253ad3:         BrokerService brokerService = new BrokerService();
1:a253ad3:         PolicyMap policyMap = new PolicyMap();
1:a253ad3:         PolicyEntry entry = new PolicyEntry();
1:a253ad3:         entry.setQueue(">");
1:a253ad3:         entry.setEnableAudit(true);
1:a253ad3:         policyMap.setPolicyEntries(Arrays.asList(entry));
1:a253ad3:         brokerService.setDestinationPolicy(policyMap);
1:a253ad3: 
1:a253ad3:         startBroker(brokerService);
1:a253ad3:         assertTrue("broker alive", brokerService.isStarted());
1:a253ad3:         assertTrue(getQueue("Before").isEnableAudit());
1:a253ad3: 
1:a253ad3:         //Reapply new limit, add the property to the list of included properties
1:a253ad3:         entry.setEnableAudit(false);
1:a253ad3:         Set<String> properties = new HashSet<>();
1:a253ad3:         properties.add("enableAudit");
1:a253ad3:         javaConfigBroker.modifyPolicyEntry(entry, false, properties);
1:a253ad3:         TimeUnit.SECONDS.sleep(SLEEP);
1:a253ad3: 
1:a253ad3:         //no change because enableAudit is excluded
1:a253ad3:         assertTrue(getQueue("Before").isEnableAudit());
1:a253ad3: 
1:a253ad3:         //A new destination should have the property changed
1:a253ad3:         assertFalse(getQueue("After").isEnableAudit());
1:a253ad3:     }
1:a253ad3: 
1:a253ad3:     @Test
1:a253ad3:     public void testModFilterPropertiesInvalid() throws Exception {
1:a253ad3:         BrokerService brokerService = new BrokerService();
1:a253ad3:         PolicyMap policyMap = new PolicyMap();
1:a253ad3:         PolicyEntry entry = new PolicyEntry();
1:a253ad3:         entry.setQueue(">");
1:a253ad3:         entry.setMemoryLimit(1024);
1:a253ad3:         policyMap.setPolicyEntries(Arrays.asList(entry));
1:a253ad3:         brokerService.setDestinationPolicy(policyMap);
1:a253ad3: 
1:a253ad3:         startBroker(brokerService);
1:a253ad3:         assertTrue("broker alive", brokerService.isStarted());
1:a253ad3:         verifyQueueLimit("Before", 1024);
1:a253ad3: 
1:a253ad3:         //use a property that doesn't exist, so nothing should be updated
1:a253ad3:         entry.setMemoryLimit(4194304);
1:a253ad3:         Set<String> properties = new HashSet<>();
1:a253ad3:         properties.add("invalid");
1:a253ad3:         javaConfigBroker.modifyPolicyEntry(entry, false, properties);
1:a253ad3:         TimeUnit.SECONDS.sleep(SLEEP);
1:a253ad3: 
1:a253ad3:         //This should be unchanged as the list of properties only
1:a253ad3:         //has an invalid property so nothing will be re-applied retrospectively
1:a253ad3:         verifyQueueLimit("Before", 1024);
1:a253ad3: 
1:a253ad3:         //A new destination should be updated because the policy was changed
1:a253ad3:         verifyQueueLimit("After", 4194304);
1:a253ad3:     }
1:a253ad3: 
1:43c3cae:     @Test
1:9e7fae0:     public void testModNewPolicyObject() throws Exception {
1:9e7fae0:         BrokerService brokerService = new BrokerService();
1:9e7fae0:         PolicyMap policyMap = new PolicyMap();
1:9e7fae0:         PolicyEntry entry = new PolicyEntry();
1:9e7fae0:         entry.setQueue(">");
1:9e7fae0:         entry.setMemoryLimit(1024);
1:9e7fae0:         policyMap.setPolicyEntries(Arrays.asList(entry));
1:9e7fae0:         brokerService.setDestinationPolicy(policyMap);
1:9e7fae0: 
1:9e7fae0: 
1:9e7fae0:         startBroker(brokerService);
1:9e7fae0:         assertTrue("broker alive", brokerService.isStarted());
1:9e7fae0: 
1:9e7fae0:         verifyQueueLimit("Before", 1024);
1:9e7fae0: 
1:9e7fae0:         //Reapply new limit with new object that matches
1:9e7fae0:         //the same destination, so it should still apply
1:9e7fae0:         PolicyEntry entry2 = new PolicyEntry();
1:9e7fae0:         entry2.setQueue(">");
1:9e7fae0:         entry2.setMemoryLimit(4194304);
1:9e7fae0:         javaConfigBroker.modifyPolicyEntry(entry2, true);
1:9e7fae0:         TimeUnit.SECONDS.sleep(SLEEP);
1:9e7fae0: 
1:9e7fae0:         // These should change because the policy entry passed in
1:9e7fae0:         //matched an existing entry but was not the same reference.
1:9e7fae0:         //Since createOrReplace is true, we replace the entry with
1:9e7fae0:         //this new entry and apply
1:9e7fae0:         verifyQueueLimit("Before", 4194304);
1:9e7fae0:         verifyQueueLimit("After", 4194304);
1:9e7fae0:     }
1:9e7fae0: 
1:9e7fae0:     /**
1:9e7fae0:      * Test that a new policy is added and applied
1:a253ad3:      * Test that a new policy will be added when setting createOrReplace to true
1:a253ad3:      * when calling modifyPolicyEntry
1:9e7fae0:      *
1:9e7fae0:      * @throws Exception
1:9e7fae0:      */
1:9e7fae0:     @Test
1:9e7fae0:     public void testCreate() throws Exception {
1:9e7fae0:         BrokerService brokerService = new BrokerService();
1:9e7fae0:         PolicyMap policyMap = new PolicyMap();
1:9e7fae0:         policyMap.setPolicyEntries(Arrays.asList());
1:9e7fae0:         brokerService.setDestinationPolicy(policyMap);
1:9e7fae0: 
1:9e7fae0:         startBroker(brokerService);
1:9e7fae0:         assertTrue("broker alive", brokerService.isStarted());
1:9e7fae0:         verifyQueueLimit("Before", (int)brokerService.getSystemUsage().getMemoryUsage().getLimit());
1:9e7fae0: 
1:9e7fae0:         PolicyEntry entry = new PolicyEntry();
1:9e7fae0:         entry.setQueue(">");
1:9e7fae0:         entry.setMemoryLimit(1024);
1:9e7fae0: 
1:9e7fae0:         //The true flag should add the new policy
1:9e7fae0:         javaConfigBroker.modifyPolicyEntry(entry, true);
1:9e7fae0:         TimeUnit.SECONDS.sleep(SLEEP);
1:9e7fae0: 
1:9e7fae0:         //Make sure the new policy is added and applied
1:9e7fae0:         verifyQueueLimit("Before", 1024);
1:9e7fae0:         verifyQueueLimit("After", 1024);
1:9e7fae0:     }
1:9e7fae0: 
1:9e7fae0:     /**
1:9e7fae0:      * Test that a new policy is not added
1:a253ad3:      * Pass a new policy to modifyPolicyEntry which should throw an exception
1:a253ad3:      * because the policy didn't already exist
1:a253ad3:      *
1:9e7fae0:      * @throws Exception
1:9e7fae0:      */
1:9e7fae0:     @Test
1:9e7fae0:     public void testCreateFalse() throws Exception {
1:9e7fae0:         BrokerService brokerService = new BrokerService();
1:9e7fae0:         PolicyMap policyMap = new PolicyMap();
1:9e7fae0:         policyMap.setPolicyEntries(Arrays.asList());
1:9e7fae0:         brokerService.setDestinationPolicy(policyMap);
1:9e7fae0: 
1:9e7fae0:         startBroker(brokerService);
1:9e7fae0:         assertTrue("broker alive", brokerService.isStarted());
1:9e7fae0:         verifyQueueLimit("Before", (int)brokerService.getSystemUsage().getMemoryUsage().getLimit());
1:9e7fae0: 
1:9e7fae0:         PolicyEntry entry = new PolicyEntry();
1:9e7fae0:         entry.setQueue(">");
1:9e7fae0:         entry.setMemoryLimit(1024);
1:9e7fae0:         //The default should NOT add this policy since it won't match an existing policy to modify
1:9e7fae0:         boolean caughtException = false;
1:9e7fae0:         try {
1:9e7fae0:             javaConfigBroker.modifyPolicyEntry(entry);
1:9e7fae0:         } catch (IllegalArgumentException e) {
1:9e7fae0:             caughtException = true;
1:9e7fae0:         }
1:9e7fae0:         assertTrue(caughtException);
1:9e7fae0:         TimeUnit.SECONDS.sleep(SLEEP);
1:9e7fae0: 
1:9e7fae0:         //Make sure there was no change
1:9e7fae0:         verifyQueueLimit("Before", (int)brokerService.getSystemUsage().getMemoryUsage().getLimit());
1:9e7fae0:         verifyQueueLimit("After", (int)brokerService.getSystemUsage().getMemoryUsage().getLimit());
1:9e7fae0:     }
1:9e7fae0: 
1:9e7fae0: 
1:9e7fae0:     @Test
1:9e7fae0:     public void testModNewPolicyObjectCreateOrReplaceFalse() throws Exception {
1:9e7fae0:         BrokerService brokerService = new BrokerService();
1:9e7fae0:         PolicyMap policyMap = new PolicyMap();
1:9e7fae0:         PolicyEntry entry = new PolicyEntry();
1:9e7fae0:         entry.setQueue(">");
1:9e7fae0:         entry.setMemoryLimit(1024);
1:9e7fae0:         policyMap.setPolicyEntries(Arrays.asList(entry));
1:9e7fae0:         brokerService.setDestinationPolicy(policyMap);
1:9e7fae0: 
1:9e7fae0:         startBroker(brokerService);
1:9e7fae0:         assertTrue("broker alive", brokerService.isStarted());
1:9e7fae0:         verifyQueueLimit("Before", 1024);
1:9e7fae0: 
1:9e7fae0:         //Reapply new limit with new object that matches
1:9e7fae0:         //the same destination, but createOrReplace is false
1:9e7fae0:         PolicyEntry entry2 = new PolicyEntry();
1:9e7fae0:         entry2.setQueue(">");
1:9e7fae0:         entry2.setMemoryLimit(4194304);
1:9e7fae0:         boolean caughtException = false;
1:9e7fae0:         try {
1:9e7fae0:             javaConfigBroker.modifyPolicyEntry(entry2, false);
1:9e7fae0:         } catch (IllegalArgumentException e) {
1:9e7fae0:             caughtException = true;
1:9e7fae0:         }
1:9e7fae0:         assertTrue(caughtException);
1:9e7fae0:         TimeUnit.SECONDS.sleep(SLEEP);
1:9e7fae0: 
1:9e7fae0:         // These should not change because the policy entry passed in
1:9e7fae0:         //matched an existing entry but was not the same reference.
1:9e7fae0:         //Since createOrReplace is false, it should noo be updated
1:9e7fae0:         verifyQueueLimit("Before", 1024);
1:9e7fae0:         verifyQueueLimit("After", 1024);
1:9e7fae0:     }
1:9e7fae0: 
1:9e7fae0:     @Test
1:9e7fae0:     public void testModWithChildPolicy() throws Exception {
1:9e7fae0:         BrokerService brokerService = new BrokerService();
1:9e7fae0:         PolicyMap policyMap = new PolicyMap();
1:9e7fae0:         PolicyEntry entry = new PolicyEntry();
1:9e7fae0:         entry.setQueue("queue.>");
1:9e7fae0:         entry.setMemoryLimit(1024);
1:9e7fae0:         PolicyEntry entry2 = new PolicyEntry();
1:9e7fae0:         entry2.setQueue("queue.child.>");
1:9e7fae0:         entry2.setMemoryLimit(2048);
1:9e7fae0:         policyMap.setPolicyEntries(Arrays.asList(entry, entry2));
1:9e7fae0:         brokerService.setDestinationPolicy(policyMap);
1:9e7fae0: 
1:9e7fae0:         startBroker(brokerService);
1:9e7fae0:         assertTrue("broker alive", brokerService.isStarted());
1:9e7fae0: 
1:9e7fae0:         brokerService.getBroker().addDestination(
1:9e7fae0:                 brokerService.getAdminConnectionContext(), new ActiveMQQueue("queue.test"), false);
1:9e7fae0:         brokerService.getBroker().addDestination(
1:9e7fae0:                 brokerService.getAdminConnectionContext(), new ActiveMQQueue("queue.child.test"), false);
1:9e7fae0: 
1:9e7fae0:         //check destinations before policy updates
1:9e7fae0:         verifyQueueLimit("queue.test", 1024);
1:9e7fae0:         verifyQueueLimit("queue.child.test", 2048);
1:9e7fae0: 
1:9e7fae0:         //Reapply new limit to policy 2
1:9e7fae0:         entry2.setMemoryLimit(4194304);
1:9e7fae0:         javaConfigBroker.modifyPolicyEntry(entry2);
1:9e7fae0:         TimeUnit.SECONDS.sleep(SLEEP);
1:9e7fae0: 
1:9e7fae0:         //verify new dest and existing are changed
1:9e7fae0:         verifyQueueLimit("queue.child.test", 4194304);
1:9e7fae0:         verifyQueueLimit("queue.child.test2", 4194304);
1:9e7fae0: 
1:9e7fae0:         //verify that destination at a higher level policy is not affected
1:9e7fae0:         verifyQueueLimit("queue.test", 1024);
1:9e7fae0:     }
1:9e7fae0: 
1:9e7fae0:     @Test
1:8e2176d:     public void testModWithMultipleChildPolicies() throws Exception {
1:8e2176d:         BrokerService brokerService = new BrokerService();
1:8e2176d:         PolicyMap policyMap = new PolicyMap();
1:8e2176d:         PolicyEntry entry = new PolicyEntry();
1:8e2176d:         entry.setQueue("queue.>");
1:8e2176d:         entry.setMemoryLimit(1024);
1:8e2176d:         PolicyEntry entry2 = new PolicyEntry();
1:8e2176d:         entry2.setQueue("queue.child.>");
1:8e2176d:         entry2.setMemoryLimit(2048);
1:8e2176d:         PolicyEntry entry3 = new PolicyEntry();
1:8e2176d:         entry3.setQueue("queue.child.test");
1:8e2176d:         entry3.setMemoryLimit(5000);
1:8e2176d:         PolicyEntry entry4 = new PolicyEntry();
1:8e2176d:         entry4.setQueue("queue.child.test.test");
1:8e2176d:         entry4.setMemoryLimit(5100);
1:8e2176d:         PolicyEntry entry5 = new PolicyEntry();
1:8e2176d:         entry5.setQueue("queue.child.a");
1:8e2176d:         entry5.setMemoryLimit(5200);
1:8e2176d:         policyMap.setPolicyEntries(Arrays.asList(entry, entry2, entry3, entry4, entry5));
1:8e2176d:         brokerService.setDestinationPolicy(policyMap);
1:8e2176d: 
1:8e2176d:         startBroker(brokerService);
1:8e2176d:         assertTrue("broker alive", brokerService.isStarted());
1:8e2176d: 
1:8e2176d:         brokerService.getBroker().addDestination(
1:8e2176d:                 brokerService.getAdminConnectionContext(), new ActiveMQQueue("queue.child.>"), false);
1:8e2176d:         brokerService.getBroker().addDestination(
1:8e2176d:                 brokerService.getAdminConnectionContext(), new ActiveMQQueue("queue.test"), false);
1:8e2176d:         brokerService.getBroker().addDestination(
1:8e2176d:                 brokerService.getAdminConnectionContext(), new ActiveMQQueue("queue.child.test2"), false);
1:8e2176d: 
1:8e2176d:         //check destinations before policy updates
1:8e2176d:         verifyQueueLimit("queue.test", 1024);
1:8e2176d:         verifyQueueLimit("queue.child.test2", 2048);
1:8e2176d: 
1:8e2176d:         //Reapply new limit to policy 2
1:8e2176d:         entry3.setMemoryLimit(4194304);
1:8e2176d:         javaConfigBroker.modifyPolicyEntry(entry);
1:8e2176d:         TimeUnit.SECONDS.sleep(SLEEP);
1:8e2176d: 
1:8e2176d:         //should be unchanged
1:8e2176d:         verifyQueueLimit("queue.child.>", 2048);
1:8e2176d: 
1:8e2176d:         //verify new dest and existing are changed
1:8e2176d:         verifyQueueLimit("queue.child.test", 4194304);
1:8e2176d: 
1:8e2176d:         //verify that destination at a higher level policy is not affected
1:8e2176d:         verifyQueueLimit("queue.test", 1024);
1:8e2176d:     }
1:8e2176d: 
1:8e2176d:     @Test
1:2ce1c13:     public void testModWithChildWildcardPolicies() throws Exception {
1:2ce1c13:         BrokerService brokerService = new BrokerService();
1:2ce1c13:         PolicyMap policyMap = new PolicyMap();
1:2ce1c13:         PolicyEntry entry = new PolicyEntry();
1:2ce1c13:         entry.setQueue(">");
1:2ce1c13:         entry.setMemoryLimit(1024);
1:2ce1c13:         PolicyEntry entry2 = new PolicyEntry();
1:2ce1c13:         entry2.setQueue("queue.child.>");
1:2ce1c13:         entry2.setMemoryLimit(2048);
1:2ce1c13:         PolicyEntry entry3 = new PolicyEntry();
1:2ce1c13:         entry3.setQueue("queue.child.one.>");
1:2ce1c13:         entry3.setMemoryLimit(4096);
1:2ce1c13: 
1:2ce1c13:         policyMap.setPolicyEntries(Arrays.asList(entry, entry2, entry3));
1:2ce1c13:         brokerService.setDestinationPolicy(policyMap);
1:2ce1c13: 
1:2ce1c13:         startBroker(brokerService);
1:2ce1c13:         assertTrue("broker alive", brokerService.isStarted());
1:2ce1c13: 
1:2ce1c13:         brokerService.getBroker().addDestination(
1:2ce1c13:                 brokerService.getAdminConnectionContext(), new ActiveMQQueue("queue.>"), false);
1:2ce1c13:         brokerService.getBroker().addDestination(
1:2ce1c13:                 brokerService.getAdminConnectionContext(), new ActiveMQQueue("queue.child.>"), false);
1:2ce1c13:         brokerService.getBroker().addDestination(
1:2ce1c13:                 brokerService.getAdminConnectionContext(), new ActiveMQQueue("queue.child.one.>"), false);
1:2ce1c13:         brokerService.getBroker().addDestination(
1:2ce1c13:                 brokerService.getAdminConnectionContext(), new ActiveMQQueue("queue.child.one"), false);
1:2ce1c13: 
1:2ce1c13:         //check destinations before policy updates
1:2ce1c13:         verifyQueueLimit("queue.>", 1024);
1:2ce1c13:         verifyQueueLimit("queue.child.>", 2048);
1:2ce1c13:         verifyQueueLimit("queue.child.one", 4096);
1:2ce1c13: 
1:2ce1c13:         //Reapply new limit to policy 2
1:2ce1c13:         entry2.setMemoryLimit(4194304);
1:2ce1c13:         javaConfigBroker.modifyPolicyEntry(entry2);
1:2ce1c13:         TimeUnit.SECONDS.sleep(SLEEP);
1:2ce1c13: 
1:2ce1c13:         //verify that destination at a higher level policy is not affected
1:2ce1c13:         verifyQueueLimit("queue.>", 1024);
1:2ce1c13: 
1:2ce1c13:         verifyQueueLimit("queue.child.>", 4194304);
1:2ce1c13: 
1:2ce1c13:         verifyQueueLimit("queue.child.one.>", 4096);
1:2ce1c13:         verifyQueueLimit("queue.child.one", 4096);
1:2ce1c13:     }
1:2ce1c13: 
1:2ce1c13:     @Test
1:9e7fae0:     public void testModParentPolicy() throws Exception {
1:9e7fae0:         BrokerService brokerService = new BrokerService();
1:9e7fae0:         PolicyMap policyMap = new PolicyMap();
1:9e7fae0: 
1:9e7fae0:         PolicyEntry entry = new PolicyEntry();
1:9e7fae0:         entry.setQueue("queue.>");
1:9e7fae0:         entry.setMemoryLimit(1024);
1:9e7fae0:         PolicyEntry entry2 = new PolicyEntry();
1:9e7fae0:         entry2.setQueue("queue.child.>");
1:9e7fae0:         entry2.setMemoryLimit(2048);
1:9e7fae0:         policyMap.setPolicyEntries(Arrays.asList(entry, entry2));
1:9e7fae0:         brokerService.setDestinationPolicy(policyMap);
1:9e7fae0: 
1:9e7fae0:         startBroker(brokerService);
1:9e7fae0:         assertTrue("broker alive", brokerService.isStarted());
1:9e7fae0: 
1:9e7fae0:         brokerService.getBroker().addDestination(
1:9e7fae0:                 brokerService.getAdminConnectionContext(), new ActiveMQQueue("queue.test"), false);
1:9e7fae0:         brokerService.getBroker().addDestination(
1:9e7fae0:                 brokerService.getAdminConnectionContext(), new ActiveMQQueue("queue.child.test"), false);
1:9e7fae0: 
1:9e7fae0:         //check destinations before policy updates
1:9e7fae0:         verifyQueueLimit("queue.test", 1024);
1:9e7fae0:         verifyQueueLimit("queue.child.test", 2048);
1:9e7fae0: 
1:9e7fae0:         //Reapply new limit to policy
1:9e7fae0:         entry.setMemoryLimit(4194304);
1:9e7fae0:         javaConfigBroker.modifyPolicyEntry(entry);
1:9e7fae0:         TimeUnit.SECONDS.sleep(SLEEP);
1:9e7fae0: 
1:9e7fae0:         //verify new dest and existing are not changed
1:9e7fae0:         verifyQueueLimit("queue.child.test", 2048);
1:9e7fae0:         verifyQueueLimit("queue.child.test2", 2048);
1:9e7fae0: 
1:9e7fae0:         //verify that destination at a higher level policy is changed
1:9e7fae0:         verifyQueueLimit("queue.test", 4194304);
1:9e7fae0:     }
1:9e7fae0: 
1:9e7fae0:     @Test
1:43c3cae:     public void testAddNdMod() throws Exception {
1:43c3cae:         BrokerService brokerService = new BrokerService();
1:43c3cae:         PolicyMap policyMap = new PolicyMap();
1:43c3cae:         PolicyEntry entry = new PolicyEntry();
1:43c3cae:         entry.setQueue(">");
1:43c3cae:         entry.setMemoryLimit(1024);
1:43c3cae:         policyMap.setPolicyEntries(Arrays.asList(entry));
1:43c3cae:         brokerService.setDestinationPolicy(policyMap);
1:43c3cae: 
1:43c3cae:         startBroker(brokerService);
1:43c3cae:         assertTrue("broker alive", brokerService.isStarted());
1:43c3cae: 
1:43c3cae:         verifyQueueLimit("Before", 1024);
1:43c3cae:         verifyTopicLimit("Before", brokerService.getSystemUsage().getMemoryUsage().getLimit());
1:43c3cae: 
1:43c3cae:         entry.setMemoryLimit(2048);
1:43c3cae:         javaConfigBroker.modifyPolicyEntry(entry);
1:43c3cae:         TimeUnit.SECONDS.sleep(SLEEP);
1:43c3cae: 
1:43c3cae:         PolicyEntry newEntry = new PolicyEntry();
1:43c3cae:         newEntry.setTopic(">");
1:43c3cae:         newEntry.setMemoryLimit(2048);
1:43c3cae:         javaConfigBroker.addNewPolicyEntry(newEntry);
1:43c3cae:         TimeUnit.SECONDS.sleep(SLEEP);
1:43c3cae: 
1:43c3cae:         verifyTopicLimit("After", 2048l);
1:43c3cae:         verifyQueueLimit("After", 2048);
1:43c3cae: 
1:43c3cae:         // change to existing dest
1:43c3cae:         verifyTopicLimit("Before", 2048l);
1:43c3cae:     }
1:9e7fae0: 
1:9e7fae0:     @Test
1:9e7fae0:     public void testAddNdModWithMultiplePolicies() throws Exception {
1:9e7fae0:         BrokerService brokerService = new BrokerService();
1:9e7fae0:         PolicyMap policyMap = new PolicyMap();
1:9e7fae0:         PolicyEntry entry = new PolicyEntry();
1:9e7fae0:         entry.setQueue(">");
1:9e7fae0:         entry.setMemoryLimit(1024);
1:9e7fae0:         policyMap.setPolicyEntries(Arrays.asList(entry));
1:9e7fae0:         brokerService.setDestinationPolicy(policyMap);
1:9e7fae0: 
1:9e7fae0:         startBroker(brokerService);
1:9e7fae0:         assertTrue("broker alive", brokerService.isStarted());
1:9e7fae0: 
1:9e7fae0:         verifyQueueLimit("Before", 1024);
1:9e7fae0:         verifyTopicLimit("Before", brokerService.getSystemUsage().getMemoryUsage().getLimit());
1:9e7fae0: 
1:9e7fae0:         entry.setMemoryLimit(2048);
1:9e7fae0:         javaConfigBroker.modifyPolicyEntry(entry);
1:9e7fae0:         TimeUnit.SECONDS.sleep(SLEEP);
1:9e7fae0: 
1:9e7fae0:         PolicyEntry newEntry = new PolicyEntry();
1:9e7fae0:         newEntry.setTopic("test2.>");
1:9e7fae0:         newEntry.setMemoryLimit(2048);
1:9e7fae0:         PolicyEntry newEntry2 = new PolicyEntry();
1:9e7fae0:         newEntry2.setTopic("test2.test.>");
1:9e7fae0:         newEntry2.setMemoryLimit(4000);
1:9e7fae0:         javaConfigBroker.addNewPolicyEntry(newEntry);
1:9e7fae0:         javaConfigBroker.addNewPolicyEntry(newEntry2);
1:9e7fae0:         TimeUnit.SECONDS.sleep(SLEEP);
1:9e7fae0: 
1:9e7fae0:         verifyTopicLimit("test2.after", 2048l);
1:9e7fae0:         verifyTopicLimit("test2.test.after", 4000l);
1:9e7fae0:         //check existing modified entry
1:9e7fae0:         verifyQueueLimit("After", 2048);
1:a253ad3: 
1:9e7fae0:         // change to existing dest
1:9e7fae0:         PolicyEntry newEntry3 = new PolicyEntry();
1:9e7fae0:         newEntry3.setTopic(">");
1:9e7fae0:         newEntry3.setMemoryLimit(5000);
1:9e7fae0:         javaConfigBroker.addNewPolicyEntry(newEntry3);
1:9e7fae0:         verifyTopicLimit("Before", 5000l);
1:9e7fae0: 
1:9e7fae0:         //reverify children
1:9e7fae0:         verifyTopicLimit("test2.after", 2048l);
1:9e7fae0:         verifyTopicLimit("test2.test.after", 4000l);
1:9e7fae0:     }
1:9e7fae0: 
1:a253ad3:     @Test
1:a253ad3:     public void testAllQueuePropertiesApplied() throws Exception {
1:a253ad3:         testAllQueuePropertiesAppliedFilter(null);
1:a253ad3:     }
1:a253ad3: 
1:a253ad3:     /**
1:a253ad3:      * Make sure all properties set on the filter Set are applied
1:a253ad3:      *
1:a253ad3:      * @throws Exception
1:a253ad3:      */
1:a253ad3:     @Test
1:a253ad3:     public void testAllQueuePropertiesAppliedFilter() throws Exception {
1:a253ad3:         testAllQueuePropertiesAppliedFilter(getQueuePropertySet());
1:a253ad3:     }
1:a253ad3: 
1:a253ad3:     /**
1:a253ad3:      * Make sure all properties set on the filter Set are applied
1:a253ad3:      *
1:a253ad3:      * @throws Exception
1:a253ad3:      */
1:a253ad3:     @Test
1:a253ad3:     public void testAllTopicPropertiesAppliedFilter() throws Exception {
1:a253ad3:         testAllTopicPropertiesAppliedFilter(getTopicPropertySet());
1:a253ad3:     }
1:a253ad3: 
1:a253ad3:     @Test
1:a253ad3:     public void testAllTopicPropertiesApplied() throws Exception {
1:a253ad3:         testAllTopicPropertiesAppliedFilter(null);
1:a253ad3:     }
1:a253ad3: 
1:a253ad3:     private void testAllQueuePropertiesAppliedFilter(Set<String> properties) throws Exception {
1:a253ad3:         BrokerService brokerService = new BrokerService();
1:a253ad3:         PolicyMap policyMap = new PolicyMap();
1:a253ad3:         PolicyEntry entry = new PolicyEntry();
1:a253ad3:         entry.setQueue(">");
1:a253ad3: 
1:a253ad3:         //initial config
1:a253ad3:         setAllDestPolicyProperties(entry, true, true, 10,
1:a253ad3:                 100, 200, 1000, 400, 40, 30, true, true, 1000, true, true,
1:a253ad3:                 30, true, true, true, true, true, true, true, true);
1:a253ad3:         setAllQueuePolicyProperties(entry, 10000, true, true, true, true, 100,
1:a253ad3:                 100, true, true);
1:a253ad3: 
1:a253ad3:         policyMap.setPolicyEntries(Arrays.asList(entry));
1:a253ad3:         brokerService.setDestinationPolicy(policyMap);
1:a253ad3: 
1:a253ad3:         startBroker(brokerService);
1:a253ad3:         assertTrue("broker alive", brokerService.isStarted());
1:a253ad3: 
1:a253ad3:         //validate config
1:a253ad3:         assertAllDestPolicyProperties(getQueue("Before"), true, true, 10,
1:a253ad3:                 100, 200, 1000, 400, 40, 30, true, true, 1000, true, true,
1:a253ad3:                 30, true, true, true, true, true, true, true, true);
1:a253ad3:         assertAllQueuePolicyProperties(getQueue("Before"), 10000, true, true, true, true, 100,
1:a253ad3:                 100, true, true);
1:a253ad3: 
1:a253ad3: 
1:a253ad3:         //change config
1:a253ad3:         setAllDestPolicyProperties(entry, false, false, 100,
1:a253ad3:                 1000, 2000, 10000, 4000, 400, 300, false, false, 1000, false, false,
1:a253ad3:                 300, false, false, false, false, false, false, false, false);
1:a253ad3:         setAllQueuePolicyProperties(entry, 100000, false, false, false, false, 1000,
1:a253ad3:                 1000, false, false);
1:a253ad3: 
1:a253ad3:         javaConfigBroker.modifyPolicyEntry(entry, false, properties);
1:a253ad3:         TimeUnit.SECONDS.sleep(SLEEP);
1:a253ad3: 
1:a253ad3:         assertAllDestPolicyProperties(getQueue("Before"), false, false, 100,
1:a253ad3:                 1000, 2000, 10000, 4000, 400, 300, false, false, 1000, false, false,
1:a253ad3:                 300, false, false, false, false, false, false, false, false);
1:a253ad3:         assertAllQueuePolicyProperties(getQueue("Before"), 100000, false, false, false, false, 1000,
1:a253ad3:                 1000, false, false);
1:a253ad3: 
1:a253ad3:         //check new dest
1:a253ad3:         assertAllDestPolicyProperties(getQueue("After"), false, false, 100,
1:a253ad3:                 1000, 2000, 10000, 4000, 400, 300, false, false, 1000, false, false,
1:a253ad3:                 300, false, false, false, false, false, false, false, false);
1:a253ad3:         assertAllQueuePolicyProperties(getQueue("After"), 100000, false, false, false, false, 1000,
1:a253ad3:                 1000, false, false);
1:a253ad3:     }
1:a253ad3: 
1:a253ad3:     private void testAllTopicPropertiesAppliedFilter(Set<String> properties) throws Exception {
1:a253ad3:         BrokerService brokerService = new BrokerService();
1:a253ad3:         PolicyMap policyMap = new PolicyMap();
1:a253ad3:         PolicyEntry entry = new PolicyEntry();
1:a253ad3:         entry.setTopic(">");
1:a253ad3: 
1:a253ad3:         //initial config
1:a253ad3:         setAllDestPolicyProperties(entry, true, true, 10,
1:a253ad3:                 100, 200, 1000, 400, 40, 30, true, true, 1000, true, true,
1:a253ad3:                 30, true, true, true, true, true, true, true, true);
1:a253ad3:         setAllTopicPolicyProperties(entry, 10000, true);
1:a253ad3: 
1:a253ad3:         policyMap.setPolicyEntries(Arrays.asList(entry));
1:a253ad3:         brokerService.setDestinationPolicy(policyMap);
1:a253ad3: 
1:a253ad3:         startBroker(brokerService);
1:a253ad3:         assertTrue("broker alive", brokerService.isStarted());
1:a253ad3: 
1:a253ad3:         //validate config
1:a253ad3:         assertAllDestPolicyProperties(getTopic("Before"), true, true, 10,
1:a253ad3:                 100, 200, 1000, 400, 40, 30, true, true, 1000, true, true,
1:a253ad3:                 30, true, true, true, true, true, true, true, true);
1:a253ad3:         assertAllTopicPolicyProperties(getTopic("Before"), 10000, true);
1:a253ad3: 
1:a253ad3: 
1:a253ad3:         //change config
1:a253ad3:         setAllDestPolicyProperties(entry, false, false, 100,
1:a253ad3:                 1000, 2000, 10000, 4000, 400, 300, false, false, 1000, false, false,
1:a253ad3:                 300, false, false, false, false, false, false, false, false);
1:a253ad3:         setAllTopicPolicyProperties(entry, 100000, false);
1:a253ad3: 
1:a253ad3:         javaConfigBroker.modifyPolicyEntry(entry, false, properties);
1:a253ad3:         TimeUnit.SECONDS.sleep(SLEEP);
1:43c3cae: 
1:a253ad3:         assertAllDestPolicyProperties(getTopic("Before"), false, false, 100,
1:a253ad3:                 1000, 2000, 10000, 4000, 400, 300, false, false, 1000, false, false,
1:a253ad3:                 300, false, false, false, false, false, false, false, false);
1:a253ad3:         assertAllTopicPolicyProperties(getTopic("Before"), 100000, false);
1:a253ad3: 
1:a253ad3:         //check new dest
1:a253ad3:         assertAllDestPolicyProperties(getTopic("After"), false, false, 100,
1:a253ad3:                 1000, 2000, 10000, 4000, 400, 300, false, false, 1000, false, false,
1:a253ad3:                 300, false, false, false, false, false, false, false, false);
1:a253ad3:         assertAllTopicPolicyProperties(getTopic("After"), 100000, false);
1:a253ad3:     }
1:a253ad3: 
1:43c3cae:     private void verifyQueueLimit(String dest, int memoryLimit) throws Exception {
1:43c3cae:         ActiveMQConnection connection = (ActiveMQConnection) new ActiveMQConnectionFactory("vm://localhost").createConnection();
1:43c3cae:         try {
1:43c3cae:             connection.start();
1:43c3cae:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:43c3cae:             session.createConsumer(session.createQueue(dest));
1:43c3cae: 
1:a253ad3:             assertEquals(memoryLimit, getQueue(dest).getMemoryUsage().getLimit());
1:43c3cae:         } finally {
1:43c3cae:             connection.close();
1:43c3cae:         }
1:43c3cae:     }
1:43c3cae: 
1:43c3cae:     private void verifyTopicLimit(String dest, long memoryLimit) throws Exception {
1:43c3cae:         ActiveMQConnection connection = (ActiveMQConnection) new ActiveMQConnectionFactory("vm://localhost").createConnection();
1:43c3cae:         try {
1:43c3cae:             connection.start();
1:43c3cae:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:43c3cae:             session.createConsumer(session.createTopic(dest));
1:43c3cae: 
1:a253ad3:             assertEquals(memoryLimit, getTopic(dest).getMemoryUsage().getLimit());
1:43c3cae:         } finally {
1:43c3cae:             connection.close();
1:43c3cae:         }
1:43c3cae:     }
1:a253ad3: 
1:a253ad3:     private Queue getQueue(String queue) throws Exception {
1:a253ad3:         return (Queue) brokerService.getRegionBroker().addDestination(
1:a253ad3:                 brokerService.getAdminConnectionContext(), new ActiveMQQueue(queue), false);
1:a253ad3:     }
1:a253ad3: 
1:a253ad3:     private Topic getTopic(String topic) throws Exception {
1:a253ad3:         return (Topic) brokerService.getRegionBroker().addDestination(
1:a253ad3:                 brokerService.getAdminConnectionContext(), new ActiveMQTopic(topic), false);
1:a253ad3:     }
1:a253ad3: 
1:a253ad3:     private Set<String> getQueuePropertySet() {
1:a253ad3:         Set<String> properties = new HashSet<>(getDestPropertySet());
1:a253ad3:         properties.add("memoryLimit");
1:a253ad3:         properties.add("useConsumerPriority");
1:a253ad3:         properties.add("strictOrderDispatch");
1:a253ad3:         properties.add("optimizedDispatch");
1:a253ad3:         properties.add("lazyDispatch");
1:a253ad3:         properties.add("timeBeforeDispatchStarts");
1:a253ad3:         properties.add("consumersBeforeDispatchStarts");
1:a253ad3:         properties.add("allConsumersExclusiveByDefault");
1:a253ad3:         properties.add("persistJMSRedelivered");
1:a253ad3:         return properties;
1:a253ad3:     }
1:a253ad3: 
1:a253ad3:     private Set<String> getTopicPropertySet() {
1:a253ad3:         Set<String> properties = new HashSet<>(getDestPropertySet());
1:a253ad3:         properties.add("memoryLimit");
1:a253ad3:         properties.add("lazyDispatch");
1:a253ad3:         return properties;
1:a253ad3:     }
1:a253ad3: 
1:a253ad3:     private Set<String> getDestPropertySet() {
1:a253ad3:         Set<String> properties = new HashSet<>();
1:a253ad3:         properties.add("producerFlowControl");
1:a253ad3:         properties.add("alwaysRetroactive");
1:a253ad3:         properties.add("blockedProducerWarningInterval");
1:a253ad3:         properties.add("maxPageSize");
1:a253ad3:         properties.add("maxBrowsePageSize");
1:a253ad3:         properties.add("minimumMessageSize");
1:a253ad3:         properties.add("maxExpirePageSize");
1:a253ad3:         properties.add("cursorMemoryHighWaterMark");
1:a253ad3:         properties.add("storeUsageHighWaterMark");
1:a253ad3:         properties.add("gcInactiveDestinations");
1:a253ad3:         properties.add("gcWithNetworkConsumers");
1:a253ad3:         properties.add("inactiveTimeoutBeforeGC");
1:a253ad3:         properties.add("reduceMemoryFootprint");
1:a253ad3:         properties.add("doOptimizeMessageStore");
1:a253ad3:         properties.add("optimizeMessageStoreInFlightLimit");
1:a253ad3:         properties.add("advisoryForConsumed");
1:a253ad3:         properties.add("advisoryForDelivery");
1:a253ad3:         properties.add("advisoryForDiscardingMessages");
1:a253ad3:         properties.add("advisoryForSlowConsumers");
1:a253ad3:         properties.add("advisoryForFastProducers");
1:a253ad3:         properties.add("advisoryWhenFull");
1:a253ad3:         properties.add("includeBodyForAdvisory");
1:a253ad3:         properties.add("sendAdvisoryIfNoConsumers");
1:a253ad3:         return properties;
1:a253ad3: 
1:a253ad3:     }
1:a253ad3: 
1:a253ad3:     private void setAllQueuePolicyProperties(PolicyEntry entry, long memoryLimit, boolean useConsumerPriority,
1:a253ad3:             boolean strictOrderDispatch, boolean optimizedDispatch, boolean lazyDispatch,
1:a253ad3:             int timeBeforeDispatchStarts, int consumersBeforeDispatchStarts, boolean allConsumersExclusiveByDefault,
1:a253ad3:             boolean persistJMSRedelivered) {
1:a253ad3: 
1:a253ad3:         entry.setMemoryLimit(memoryLimit);
1:a253ad3:         entry.setUseConsumerPriority(useConsumerPriority);
1:a253ad3:         entry.setStrictOrderDispatch(strictOrderDispatch);
1:a253ad3:         entry.setOptimizedDispatch(optimizedDispatch);
1:a253ad3:         entry.setLazyDispatch(lazyDispatch);
1:a253ad3:         entry.setTimeBeforeDispatchStarts(timeBeforeDispatchStarts);
1:a253ad3:         entry.setConsumersBeforeDispatchStarts(consumersBeforeDispatchStarts);
1:a253ad3:         entry.setAllConsumersExclusiveByDefault(allConsumersExclusiveByDefault);
1:a253ad3:         entry.setPersistJMSRedelivered(persistJMSRedelivered);
1:a253ad3:     }
1:a253ad3: 
1:a253ad3:     private void setAllTopicPolicyProperties(PolicyEntry entry, long memoryLimit, boolean lazyDispatch) {
1:a253ad3:         entry.setMemoryLimit(memoryLimit);
1:a253ad3:         entry.setLazyDispatch(lazyDispatch);
1:a253ad3:     }
1:a253ad3: 
1:a253ad3:     private void setAllDestPolicyProperties(PolicyEntry entry, boolean producerFlowControl,
1:a253ad3:             boolean alwaysRetroactive, long blockedProducerWarningInterval, int maxPageSize,
1:a253ad3:             int maxBrowsePageSize, long minimumMessageSize, int maxExpirePageSize, int cursorMemoryHighWaterMark,
1:a253ad3:             int storeUsageHighWaterMark, boolean gcInactiveDestinations, boolean gcWithNetworkConsumers,
1:a253ad3:             long inactiveTimeoutBeforeGC,boolean reduceMemoryFootprint, boolean doOptimizeMessageStore,
1:a253ad3:             int optimizeMessageStoreInFlightLimit, boolean advisoryForConsumed, boolean advisoryForDelivery,
1:a253ad3:             boolean advisoryForDiscardingMessages, boolean advisoryForSlowConsumers, boolean advisoryForFastProducers,
1:a253ad3:             boolean advisoryWhenFull, boolean includeBodyForAdvisory, boolean sendAdvisoryIfNoConsumers) {
1:a253ad3: 
1:a253ad3:         entry.setProducerFlowControl(producerFlowControl);
1:a253ad3:         entry.setAlwaysRetroactive(alwaysRetroactive);
1:a253ad3:         entry.setBlockedProducerWarningInterval(blockedProducerWarningInterval);
1:a253ad3:         entry.setMaxPageSize(maxPageSize);
1:a253ad3:         entry.setMaxBrowsePageSize(maxBrowsePageSize);
1:a253ad3:         entry.setMinimumMessageSize(minimumMessageSize);
1:a253ad3:         entry.setMaxExpirePageSize(maxExpirePageSize);
1:a253ad3:         entry.setCursorMemoryHighWaterMark(cursorMemoryHighWaterMark);
1:a253ad3:         entry.setStoreUsageHighWaterMark(storeUsageHighWaterMark);
1:a253ad3:         entry.setGcInactiveDestinations(gcInactiveDestinations);
1:a253ad3:         entry.setGcWithNetworkConsumers(gcWithNetworkConsumers);
1:a253ad3:         entry.setInactiveTimeoutBeforeGC(inactiveTimeoutBeforeGC);
1:a253ad3:         entry.setReduceMemoryFootprint(reduceMemoryFootprint);
1:a253ad3:         entry.setDoOptimzeMessageStorage(doOptimizeMessageStore);
1:a253ad3:         entry.setOptimizeMessageStoreInFlightLimit(optimizeMessageStoreInFlightLimit);
1:a253ad3:         entry.setAdvisoryForConsumed(advisoryForConsumed);
1:a253ad3:         entry.setAdvisoryForDelivery(advisoryForDelivery);
1:a253ad3:         entry.setAdvisoryForDiscardingMessages(advisoryForDiscardingMessages);
1:a253ad3:         entry.setAdvisoryForSlowConsumers(advisoryForSlowConsumers);
1:a253ad3:         entry.setAdvisoryForFastProducers(advisoryForFastProducers);
1:a253ad3:         entry.setAdvisoryWhenFull(advisoryWhenFull);
1:a253ad3:         entry.setIncludeBodyForAdvisory(includeBodyForAdvisory);
1:a253ad3:         entry.setSendAdvisoryIfNoConsumers(sendAdvisoryIfNoConsumers);
1:a253ad3:     }
1:a253ad3: 
1:a253ad3:     private void assertAllQueuePolicyProperties(Queue queue, long memoryLimit, boolean useConsumerPriority,
1:a253ad3:             boolean strictOrderDispatch, boolean optimizedDispatch, boolean lazyDispatch,
1:a253ad3:             int timeBeforeDispatchStarts, int consumersBeforeDispatchStarts, boolean allConsumersExclusiveByDefault,
1:a253ad3:             boolean persistJMSRedelivered) {
1:a253ad3: 
1:a253ad3:         assertEquals(memoryLimit, queue.getMemoryUsage().getLimit());
1:a253ad3:         assertEquals(useConsumerPriority, queue.isUseConsumerPriority());
1:a253ad3:         assertEquals(strictOrderDispatch, queue.isStrictOrderDispatch());
1:a253ad3:         assertEquals(optimizedDispatch, queue.isOptimizedDispatch());
1:a253ad3:         assertEquals(lazyDispatch, queue.isLazyDispatch());
1:a253ad3:         assertEquals(timeBeforeDispatchStarts, queue.getTimeBeforeDispatchStarts());
1:a253ad3:         assertEquals(consumersBeforeDispatchStarts, queue.getConsumersBeforeDispatchStarts());
1:a253ad3:         assertEquals(allConsumersExclusiveByDefault, queue.isAllConsumersExclusiveByDefault());
1:a253ad3:         assertEquals(persistJMSRedelivered, queue.isPersistJMSRedelivered());
1:a253ad3: 
1:a253ad3:     }
1:a253ad3: 
1:a253ad3:     private void assertAllTopicPolicyProperties(Topic topic, long memoryLimit, boolean lazyDispatch) {
1:a253ad3:         assertEquals(memoryLimit, topic.getMemoryUsage().getLimit());
1:a253ad3:         assertEquals(lazyDispatch, topic.isLazyDispatch());
1:a253ad3:     }
1:a253ad3: 
1:a253ad3:     private void assertAllDestPolicyProperties(BaseDestination dest, boolean producerFlowControl,
1:a253ad3:             boolean alwaysRetroactive, long blockedProducerWarningInterval, int maxPageSize,
1:a253ad3:             int maxBrowsePageSize, long minimumMessageSize, int maxExpirePageSize, int cursorMemoryHighWaterMark,
1:a253ad3:             int storeUsageHighWaterMark, boolean gcInactiveDestinations, boolean gcWithNetworkConsumers,
1:a253ad3:             long inactiveTimeoutBeforeGC,boolean reduceMemoryFootprint, boolean doOptimizeMessageStore,
1:a253ad3:             int optimizeMessageStoreInFlightLimit, boolean advisoryForConsumed, boolean advisoryForDelivery,
1:a253ad3:             boolean advisoryForDiscardingMessages, boolean advisoryForSlowConsumers, boolean advisoryForFastProducers,
1:a253ad3:             boolean advisoryWhenFull, boolean includeBodyForAdvisory, boolean sendAdvisoryIfNoConsumers) {
1:a253ad3: 
1:a253ad3: 
1:a253ad3:         assertEquals(producerFlowControl, dest.isProducerFlowControl());
1:a253ad3:         assertEquals(alwaysRetroactive, dest.isAlwaysRetroactive());
1:a253ad3:         assertEquals(blockedProducerWarningInterval, dest.getBlockedProducerWarningInterval());
1:a253ad3:         assertEquals(maxPageSize, dest.getMaxPageSize());
1:a253ad3:         assertEquals(maxBrowsePageSize, dest.getMaxBrowsePageSize());
1:a253ad3:         assertEquals(minimumMessageSize, dest.getMinimumMessageSize());
1:a253ad3:         assertEquals(maxExpirePageSize, dest.getMaxExpirePageSize());
1:a253ad3:         assertEquals(cursorMemoryHighWaterMark, dest.getCursorMemoryHighWaterMark());
1:a253ad3:         assertEquals(storeUsageHighWaterMark, dest.getStoreUsageHighWaterMark());
1:a253ad3:         assertEquals(gcInactiveDestinations, dest.isGcIfInactive());
1:a253ad3:         assertEquals(gcWithNetworkConsumers, dest.isGcWithNetworkConsumers());
1:a253ad3:         assertEquals(inactiveTimeoutBeforeGC, dest.getInactiveTimeoutBeforeGC());
1:a253ad3:         assertEquals(reduceMemoryFootprint, dest.isReduceMemoryFootprint());
1:a253ad3:         assertEquals(doOptimizeMessageStore, dest.isDoOptimzeMessageStorage());
1:a253ad3:         assertEquals(optimizeMessageStoreInFlightLimit, dest.getOptimizeMessageStoreInFlightLimit());
1:a253ad3:         assertEquals(advisoryForConsumed, dest.isAdvisoryForConsumed());
1:a253ad3:         assertEquals(advisoryForDelivery, dest.isAdvisoryForDelivery());
1:a253ad3:         assertEquals(advisoryForDiscardingMessages, dest.isAdvisoryForDiscardingMessages());
1:a253ad3:         assertEquals(advisoryForSlowConsumers, dest.isAdvisoryForSlowConsumers());
1:a253ad3:         assertEquals(advisoryForFastProducers, dest.isAdvisoryForFastProducers());
1:a253ad3:         assertEquals(advisoryWhenFull, dest.isAdvisoryWhenFull());
1:a253ad3:         assertEquals(includeBodyForAdvisory, dest.isIncludeBodyForAdvisory());
1:a253ad3:         assertEquals(sendAdvisoryIfNoConsumers, dest.isSendAdvisoryIfNoConsumers());
1:a253ad3: 
1:a253ad3:     }
1:43c3cae: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:2ce1c13
/////////////////////////////////////////////////////////////////////////
1:     public void testModWithChildWildcardPolicies() throws Exception {
1:         BrokerService brokerService = new BrokerService();
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry entry = new PolicyEntry();
1:         entry.setQueue(">");
1:         entry.setMemoryLimit(1024);
1:         PolicyEntry entry2 = new PolicyEntry();
1:         entry2.setQueue("queue.child.>");
1:         entry2.setMemoryLimit(2048);
1:         PolicyEntry entry3 = new PolicyEntry();
1:         entry3.setQueue("queue.child.one.>");
1:         entry3.setMemoryLimit(4096);
1: 
1:         policyMap.setPolicyEntries(Arrays.asList(entry, entry2, entry3));
1:         brokerService.setDestinationPolicy(policyMap);
1: 
1:         startBroker(brokerService);
1:         assertTrue("broker alive", brokerService.isStarted());
1: 
1:         brokerService.getBroker().addDestination(
1:                 brokerService.getAdminConnectionContext(), new ActiveMQQueue("queue.>"), false);
1:         brokerService.getBroker().addDestination(
1:                 brokerService.getAdminConnectionContext(), new ActiveMQQueue("queue.child.>"), false);
1:         brokerService.getBroker().addDestination(
1:                 brokerService.getAdminConnectionContext(), new ActiveMQQueue("queue.child.one.>"), false);
1:         brokerService.getBroker().addDestination(
1:                 brokerService.getAdminConnectionContext(), new ActiveMQQueue("queue.child.one"), false);
1: 
1:         //check destinations before policy updates
1:         verifyQueueLimit("queue.>", 1024);
1:         verifyQueueLimit("queue.child.>", 2048);
1:         verifyQueueLimit("queue.child.one", 4096);
1: 
1:         //Reapply new limit to policy 2
1:         entry2.setMemoryLimit(4194304);
1:         javaConfigBroker.modifyPolicyEntry(entry2);
1:         TimeUnit.SECONDS.sleep(SLEEP);
1: 
1:         //verify that destination at a higher level policy is not affected
1:         verifyQueueLimit("queue.>", 1024);
1: 
1:         verifyQueueLimit("queue.child.>", 4194304);
1: 
1:         verifyQueueLimit("queue.child.one.>", 4096);
1:         verifyQueueLimit("queue.child.one", 4096);
1:     }
1: 
1:     @Test
commit:8e2176d
/////////////////////////////////////////////////////////////////////////
1:     public void testModWithMultipleChildPolicies() throws Exception {
1:         BrokerService brokerService = new BrokerService();
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry entry = new PolicyEntry();
1:         entry.setQueue("queue.>");
1:         entry.setMemoryLimit(1024);
1:         PolicyEntry entry2 = new PolicyEntry();
1:         entry2.setQueue("queue.child.>");
1:         entry2.setMemoryLimit(2048);
1:         PolicyEntry entry3 = new PolicyEntry();
1:         entry3.setQueue("queue.child.test");
1:         entry3.setMemoryLimit(5000);
1:         PolicyEntry entry4 = new PolicyEntry();
1:         entry4.setQueue("queue.child.test.test");
1:         entry4.setMemoryLimit(5100);
1:         PolicyEntry entry5 = new PolicyEntry();
1:         entry5.setQueue("queue.child.a");
1:         entry5.setMemoryLimit(5200);
1:         policyMap.setPolicyEntries(Arrays.asList(entry, entry2, entry3, entry4, entry5));
1:         brokerService.setDestinationPolicy(policyMap);
1: 
1:         startBroker(brokerService);
1:         assertTrue("broker alive", brokerService.isStarted());
1: 
1:         brokerService.getBroker().addDestination(
1:                 brokerService.getAdminConnectionContext(), new ActiveMQQueue("queue.child.>"), false);
1:         brokerService.getBroker().addDestination(
1:                 brokerService.getAdminConnectionContext(), new ActiveMQQueue("queue.test"), false);
1:         brokerService.getBroker().addDestination(
1:                 brokerService.getAdminConnectionContext(), new ActiveMQQueue("queue.child.test2"), false);
1: 
1:         //check destinations before policy updates
1:         verifyQueueLimit("queue.test", 1024);
1:         verifyQueueLimit("queue.child.test2", 2048);
1: 
1:         //Reapply new limit to policy 2
1:         entry3.setMemoryLimit(4194304);
1:         javaConfigBroker.modifyPolicyEntry(entry);
1:         TimeUnit.SECONDS.sleep(SLEEP);
1: 
1:         //should be unchanged
1:         verifyQueueLimit("queue.child.>", 2048);
1: 
1:         //verify new dest and existing are changed
1:         verifyQueueLimit("queue.child.test", 4194304);
1: 
1:         //verify that destination at a higher level policy is not affected
1:         verifyQueueLimit("queue.test", 1024);
1:     }
1: 
1:     @Test
commit:a253ad3
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertFalse;
1: import java.util.HashSet;
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.BaseDestination;
1: import org.apache.activemq.broker.region.Queue;
1: import org.apache.activemq.broker.region.Topic;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test modifying a policy
1:      *
1:      * @throws Exception
1:      */
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test modifying a policy but only applying a subset o
1:      * properties retroactively to existing destinations
1:      *
1:      * @throws Exception
1:      */
1:     @Test
1:     public void testModFilterProperties() throws Exception {
1:         BrokerService brokerService = new BrokerService();
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry entry = new PolicyEntry();
1:         entry.setQueue(">");
1:         entry.setMemoryLimit(1024);
1:         entry.setMaxPageSize(500);
1:         entry.setMaxBrowsePageSize(100);
1:         policyMap.setPolicyEntries(Arrays.asList(entry));
1:         brokerService.setDestinationPolicy(policyMap);
1: 
1:         startBroker(brokerService);
1:         assertTrue("broker alive", brokerService.isStarted());
1:         verifyQueueLimit("Before", 1024);
1:         assertEquals(500, getQueue("Before").getMaxPageSize());
1:         assertEquals(100, getQueue("Before").getMaxBrowsePageSize());
1: 
1:         //Reapply new limit, add the property to the list of included properties
1:         entry.setMemoryLimit(4194304);
1:         entry.setMaxPageSize(300);
1:         entry.setMaxBrowsePageSize(200);
1:         Set<String> properties = new HashSet<>();
1:         properties.add("memoryLimit");
1:         properties.add("maxPageSize");
1:         javaConfigBroker.modifyPolicyEntry(entry, false, properties);
1:         TimeUnit.SECONDS.sleep(SLEEP);
1: 
1:         verifyQueueLimit("After", 4194304);
1:         assertEquals(300, getQueue("After").getMaxPageSize());
1:         assertEquals(200, getQueue("After").getMaxBrowsePageSize());
1: 
1:        // change to existing dest, maxBrowsePageSize was not included
1:         //in the property list so it should not have changed
1:         verifyQueueLimit("Before", 4194304);
1:         assertEquals(300, getQueue("Before").getMaxPageSize());
1:         assertEquals(100, getQueue("Before").getMaxBrowsePageSize());
1:     }
1: 
1:     @Test
1:     public void testModQueueAndTopic() throws Exception {
1:         BrokerService brokerService = new BrokerService();
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry qEntry = new PolicyEntry();
1:         qEntry.setQueue(">");
1:         qEntry.setPersistJMSRedelivered(true);
1:         PolicyEntry tEntry = new PolicyEntry();
1:         tEntry.setTopic(">");
1:         tEntry.setLazyDispatch(true);
1:         policyMap.setPolicyEntries(Arrays.asList(qEntry, tEntry));
1:         brokerService.setDestinationPolicy(policyMap);
1: 
1:         startBroker(brokerService);
1:         assertTrue("broker alive", brokerService.isStarted());
1:         assertEquals(true, getQueue("queueBefore").isPersistJMSRedelivered());
1:         assertEquals(true, getTopic("topicBefore").isLazyDispatch());
1: 
1:         //Reapply new limit, add the property to the list of included properties
1:         qEntry.setPersistJMSRedelivered(false);
1:         tEntry.setLazyDispatch(false);
1:         Set<String> queueProperties = new HashSet<>();
1:         queueProperties.add("persistJMSRedelivered");
1:         Set<String> topicProperties = new HashSet<>();
1:         topicProperties.add("lazyDispatch");
1:         javaConfigBroker.modifyPolicyEntry(qEntry, false, queueProperties);
1:         javaConfigBroker.modifyPolicyEntry(tEntry, false, topicProperties);
1:         TimeUnit.SECONDS.sleep(SLEEP);
1: 
1:         assertEquals(false, getQueue("queueBefore").isPersistJMSRedelivered());
1:         assertEquals(false, getTopic("topicBefore").isLazyDispatch());
1: 
1:         assertEquals(false, getQueue("queueAfter").isPersistJMSRedelivered());
1:         assertEquals(false, getTopic("topicAfter").isLazyDispatch());
1:     }
1: 
1:     /**
1:      * Test that a property that is not part of the update methods (can't be changed after creation)
1:      * will not be applied to existing destinations but will be applied to new destinations
1:      *
1:      * @throws Exception
1:      */
1:     @Test
1:     public void testModFilterExcludedProperty() throws Exception {
1:         BrokerService brokerService = new BrokerService();
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry entry = new PolicyEntry();
1:         entry.setQueue(">");
1:         entry.setEnableAudit(true);
1:         policyMap.setPolicyEntries(Arrays.asList(entry));
1:         brokerService.setDestinationPolicy(policyMap);
1: 
1:         startBroker(brokerService);
1:         assertTrue("broker alive", brokerService.isStarted());
1:         assertTrue(getQueue("Before").isEnableAudit());
1: 
1:         //Reapply new limit, add the property to the list of included properties
1:         entry.setEnableAudit(false);
1:         Set<String> properties = new HashSet<>();
1:         properties.add("enableAudit");
1:         javaConfigBroker.modifyPolicyEntry(entry, false, properties);
1:         TimeUnit.SECONDS.sleep(SLEEP);
1: 
1:         //no change because enableAudit is excluded
1:         assertTrue(getQueue("Before").isEnableAudit());
1: 
1:         //A new destination should have the property changed
1:         assertFalse(getQueue("After").isEnableAudit());
1:     }
1: 
1:     @Test
1:     public void testModFilterPropertiesInvalid() throws Exception {
1:         BrokerService brokerService = new BrokerService();
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry entry = new PolicyEntry();
1:         entry.setQueue(">");
1:         entry.setMemoryLimit(1024);
1:         policyMap.setPolicyEntries(Arrays.asList(entry));
1:         brokerService.setDestinationPolicy(policyMap);
1: 
1:         startBroker(brokerService);
1:         assertTrue("broker alive", brokerService.isStarted());
1:         verifyQueueLimit("Before", 1024);
1: 
1:         //use a property that doesn't exist, so nothing should be updated
1:         entry.setMemoryLimit(4194304);
1:         Set<String> properties = new HashSet<>();
1:         properties.add("invalid");
1:         javaConfigBroker.modifyPolicyEntry(entry, false, properties);
1:         TimeUnit.SECONDS.sleep(SLEEP);
1: 
1:         //This should be unchanged as the list of properties only
1:         //has an invalid property so nothing will be re-applied retrospectively
1:         verifyQueueLimit("Before", 1024);
1: 
1:         //A new destination should be updated because the policy was changed
1:         verifyQueueLimit("After", 4194304);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Test that a new policy will be added when setting createOrReplace to true
1:      * when calling modifyPolicyEntry
/////////////////////////////////////////////////////////////////////////
1:      * Pass a new policy to modifyPolicyEntry which should throw an exception
1:      * because the policy didn't already exist
1:      *
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void testAllQueuePropertiesApplied() throws Exception {
1:         testAllQueuePropertiesAppliedFilter(null);
1:     }
1: 
1:     /**
1:      * Make sure all properties set on the filter Set are applied
1:      *
1:      * @throws Exception
1:      */
1:     @Test
1:     public void testAllQueuePropertiesAppliedFilter() throws Exception {
1:         testAllQueuePropertiesAppliedFilter(getQueuePropertySet());
1:     }
1: 
1:     /**
1:      * Make sure all properties set on the filter Set are applied
1:      *
1:      * @throws Exception
1:      */
1:     @Test
1:     public void testAllTopicPropertiesAppliedFilter() throws Exception {
1:         testAllTopicPropertiesAppliedFilter(getTopicPropertySet());
1:     }
1: 
1:     @Test
1:     public void testAllTopicPropertiesApplied() throws Exception {
1:         testAllTopicPropertiesAppliedFilter(null);
1:     }
1: 
1:     private void testAllQueuePropertiesAppliedFilter(Set<String> properties) throws Exception {
1:         BrokerService brokerService = new BrokerService();
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry entry = new PolicyEntry();
1:         entry.setQueue(">");
1: 
1:         //initial config
1:         setAllDestPolicyProperties(entry, true, true, 10,
1:                 100, 200, 1000, 400, 40, 30, true, true, 1000, true, true,
1:                 30, true, true, true, true, true, true, true, true);
1:         setAllQueuePolicyProperties(entry, 10000, true, true, true, true, 100,
1:                 100, true, true);
1: 
1:         policyMap.setPolicyEntries(Arrays.asList(entry));
1:         brokerService.setDestinationPolicy(policyMap);
1: 
1:         startBroker(brokerService);
1:         assertTrue("broker alive", brokerService.isStarted());
1: 
1:         //validate config
1:         assertAllDestPolicyProperties(getQueue("Before"), true, true, 10,
1:                 100, 200, 1000, 400, 40, 30, true, true, 1000, true, true,
1:                 30, true, true, true, true, true, true, true, true);
1:         assertAllQueuePolicyProperties(getQueue("Before"), 10000, true, true, true, true, 100,
1:                 100, true, true);
1: 
1: 
1:         //change config
1:         setAllDestPolicyProperties(entry, false, false, 100,
1:                 1000, 2000, 10000, 4000, 400, 300, false, false, 1000, false, false,
1:                 300, false, false, false, false, false, false, false, false);
1:         setAllQueuePolicyProperties(entry, 100000, false, false, false, false, 1000,
1:                 1000, false, false);
1: 
1:         javaConfigBroker.modifyPolicyEntry(entry, false, properties);
1:         TimeUnit.SECONDS.sleep(SLEEP);
1: 
1:         assertAllDestPolicyProperties(getQueue("Before"), false, false, 100,
1:                 1000, 2000, 10000, 4000, 400, 300, false, false, 1000, false, false,
1:                 300, false, false, false, false, false, false, false, false);
1:         assertAllQueuePolicyProperties(getQueue("Before"), 100000, false, false, false, false, 1000,
1:                 1000, false, false);
1: 
1:         //check new dest
1:         assertAllDestPolicyProperties(getQueue("After"), false, false, 100,
1:                 1000, 2000, 10000, 4000, 400, 300, false, false, 1000, false, false,
1:                 300, false, false, false, false, false, false, false, false);
1:         assertAllQueuePolicyProperties(getQueue("After"), 100000, false, false, false, false, 1000,
1:                 1000, false, false);
1:     }
1: 
1:     private void testAllTopicPropertiesAppliedFilter(Set<String> properties) throws Exception {
1:         BrokerService brokerService = new BrokerService();
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry entry = new PolicyEntry();
1:         entry.setTopic(">");
1: 
1:         //initial config
1:         setAllDestPolicyProperties(entry, true, true, 10,
1:                 100, 200, 1000, 400, 40, 30, true, true, 1000, true, true,
1:                 30, true, true, true, true, true, true, true, true);
1:         setAllTopicPolicyProperties(entry, 10000, true);
1: 
1:         policyMap.setPolicyEntries(Arrays.asList(entry));
1:         brokerService.setDestinationPolicy(policyMap);
1: 
1:         startBroker(brokerService);
1:         assertTrue("broker alive", brokerService.isStarted());
1: 
1:         //validate config
1:         assertAllDestPolicyProperties(getTopic("Before"), true, true, 10,
1:                 100, 200, 1000, 400, 40, 30, true, true, 1000, true, true,
1:                 30, true, true, true, true, true, true, true, true);
1:         assertAllTopicPolicyProperties(getTopic("Before"), 10000, true);
1: 
1: 
1:         //change config
1:         setAllDestPolicyProperties(entry, false, false, 100,
1:                 1000, 2000, 10000, 4000, 400, 300, false, false, 1000, false, false,
1:                 300, false, false, false, false, false, false, false, false);
1:         setAllTopicPolicyProperties(entry, 100000, false);
1: 
1:         javaConfigBroker.modifyPolicyEntry(entry, false, properties);
1:         TimeUnit.SECONDS.sleep(SLEEP);
1: 
1:         assertAllDestPolicyProperties(getTopic("Before"), false, false, 100,
1:                 1000, 2000, 10000, 4000, 400, 300, false, false, 1000, false, false,
1:                 300, false, false, false, false, false, false, false, false);
1:         assertAllTopicPolicyProperties(getTopic("Before"), 100000, false);
1: 
1:         //check new dest
1:         assertAllDestPolicyProperties(getTopic("After"), false, false, 100,
1:                 1000, 2000, 10000, 4000, 400, 300, false, false, 1000, false, false,
1:                 300, false, false, false, false, false, false, false, false);
1:         assertAllTopicPolicyProperties(getTopic("After"), 100000, false);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             assertEquals(memoryLimit, getQueue(dest).getMemoryUsage().getLimit());
/////////////////////////////////////////////////////////////////////////
1:             assertEquals(memoryLimit, getTopic(dest).getMemoryUsage().getLimit());
1: 
1:     private Queue getQueue(String queue) throws Exception {
1:         return (Queue) brokerService.getRegionBroker().addDestination(
1:                 brokerService.getAdminConnectionContext(), new ActiveMQQueue(queue), false);
1:     }
1: 
1:     private Topic getTopic(String topic) throws Exception {
1:         return (Topic) brokerService.getRegionBroker().addDestination(
1:                 brokerService.getAdminConnectionContext(), new ActiveMQTopic(topic), false);
1:     }
1: 
1:     private Set<String> getQueuePropertySet() {
1:         Set<String> properties = new HashSet<>(getDestPropertySet());
1:         properties.add("memoryLimit");
1:         properties.add("useConsumerPriority");
1:         properties.add("strictOrderDispatch");
1:         properties.add("optimizedDispatch");
1:         properties.add("lazyDispatch");
1:         properties.add("timeBeforeDispatchStarts");
1:         properties.add("consumersBeforeDispatchStarts");
1:         properties.add("allConsumersExclusiveByDefault");
1:         properties.add("persistJMSRedelivered");
1:         return properties;
1:     }
1: 
1:     private Set<String> getTopicPropertySet() {
1:         Set<String> properties = new HashSet<>(getDestPropertySet());
1:         properties.add("memoryLimit");
1:         properties.add("lazyDispatch");
1:         return properties;
1:     }
1: 
1:     private Set<String> getDestPropertySet() {
1:         Set<String> properties = new HashSet<>();
1:         properties.add("producerFlowControl");
1:         properties.add("alwaysRetroactive");
1:         properties.add("blockedProducerWarningInterval");
1:         properties.add("maxPageSize");
1:         properties.add("maxBrowsePageSize");
1:         properties.add("minimumMessageSize");
1:         properties.add("maxExpirePageSize");
1:         properties.add("cursorMemoryHighWaterMark");
1:         properties.add("storeUsageHighWaterMark");
1:         properties.add("gcInactiveDestinations");
1:         properties.add("gcWithNetworkConsumers");
1:         properties.add("inactiveTimeoutBeforeGC");
1:         properties.add("reduceMemoryFootprint");
1:         properties.add("doOptimizeMessageStore");
1:         properties.add("optimizeMessageStoreInFlightLimit");
1:         properties.add("advisoryForConsumed");
1:         properties.add("advisoryForDelivery");
1:         properties.add("advisoryForDiscardingMessages");
1:         properties.add("advisoryForSlowConsumers");
1:         properties.add("advisoryForFastProducers");
1:         properties.add("advisoryWhenFull");
1:         properties.add("includeBodyForAdvisory");
1:         properties.add("sendAdvisoryIfNoConsumers");
1:         return properties;
1: 
1:     }
1: 
1:     private void setAllQueuePolicyProperties(PolicyEntry entry, long memoryLimit, boolean useConsumerPriority,
1:             boolean strictOrderDispatch, boolean optimizedDispatch, boolean lazyDispatch,
1:             int timeBeforeDispatchStarts, int consumersBeforeDispatchStarts, boolean allConsumersExclusiveByDefault,
1:             boolean persistJMSRedelivered) {
1: 
1:         entry.setMemoryLimit(memoryLimit);
1:         entry.setUseConsumerPriority(useConsumerPriority);
1:         entry.setStrictOrderDispatch(strictOrderDispatch);
1:         entry.setOptimizedDispatch(optimizedDispatch);
1:         entry.setLazyDispatch(lazyDispatch);
1:         entry.setTimeBeforeDispatchStarts(timeBeforeDispatchStarts);
1:         entry.setConsumersBeforeDispatchStarts(consumersBeforeDispatchStarts);
1:         entry.setAllConsumersExclusiveByDefault(allConsumersExclusiveByDefault);
1:         entry.setPersistJMSRedelivered(persistJMSRedelivered);
1:     }
1: 
1:     private void setAllTopicPolicyProperties(PolicyEntry entry, long memoryLimit, boolean lazyDispatch) {
1:         entry.setMemoryLimit(memoryLimit);
1:         entry.setLazyDispatch(lazyDispatch);
1:     }
1: 
1:     private void setAllDestPolicyProperties(PolicyEntry entry, boolean producerFlowControl,
1:             boolean alwaysRetroactive, long blockedProducerWarningInterval, int maxPageSize,
1:             int maxBrowsePageSize, long minimumMessageSize, int maxExpirePageSize, int cursorMemoryHighWaterMark,
1:             int storeUsageHighWaterMark, boolean gcInactiveDestinations, boolean gcWithNetworkConsumers,
1:             long inactiveTimeoutBeforeGC,boolean reduceMemoryFootprint, boolean doOptimizeMessageStore,
1:             int optimizeMessageStoreInFlightLimit, boolean advisoryForConsumed, boolean advisoryForDelivery,
1:             boolean advisoryForDiscardingMessages, boolean advisoryForSlowConsumers, boolean advisoryForFastProducers,
1:             boolean advisoryWhenFull, boolean includeBodyForAdvisory, boolean sendAdvisoryIfNoConsumers) {
1: 
1:         entry.setProducerFlowControl(producerFlowControl);
1:         entry.setAlwaysRetroactive(alwaysRetroactive);
1:         entry.setBlockedProducerWarningInterval(blockedProducerWarningInterval);
1:         entry.setMaxPageSize(maxPageSize);
1:         entry.setMaxBrowsePageSize(maxBrowsePageSize);
1:         entry.setMinimumMessageSize(minimumMessageSize);
1:         entry.setMaxExpirePageSize(maxExpirePageSize);
1:         entry.setCursorMemoryHighWaterMark(cursorMemoryHighWaterMark);
1:         entry.setStoreUsageHighWaterMark(storeUsageHighWaterMark);
1:         entry.setGcInactiveDestinations(gcInactiveDestinations);
1:         entry.setGcWithNetworkConsumers(gcWithNetworkConsumers);
1:         entry.setInactiveTimeoutBeforeGC(inactiveTimeoutBeforeGC);
1:         entry.setReduceMemoryFootprint(reduceMemoryFootprint);
1:         entry.setDoOptimzeMessageStorage(doOptimizeMessageStore);
1:         entry.setOptimizeMessageStoreInFlightLimit(optimizeMessageStoreInFlightLimit);
1:         entry.setAdvisoryForConsumed(advisoryForConsumed);
1:         entry.setAdvisoryForDelivery(advisoryForDelivery);
1:         entry.setAdvisoryForDiscardingMessages(advisoryForDiscardingMessages);
1:         entry.setAdvisoryForSlowConsumers(advisoryForSlowConsumers);
1:         entry.setAdvisoryForFastProducers(advisoryForFastProducers);
1:         entry.setAdvisoryWhenFull(advisoryWhenFull);
1:         entry.setIncludeBodyForAdvisory(includeBodyForAdvisory);
1:         entry.setSendAdvisoryIfNoConsumers(sendAdvisoryIfNoConsumers);
1:     }
1: 
1:     private void assertAllQueuePolicyProperties(Queue queue, long memoryLimit, boolean useConsumerPriority,
1:             boolean strictOrderDispatch, boolean optimizedDispatch, boolean lazyDispatch,
1:             int timeBeforeDispatchStarts, int consumersBeforeDispatchStarts, boolean allConsumersExclusiveByDefault,
1:             boolean persistJMSRedelivered) {
1: 
1:         assertEquals(memoryLimit, queue.getMemoryUsage().getLimit());
1:         assertEquals(useConsumerPriority, queue.isUseConsumerPriority());
1:         assertEquals(strictOrderDispatch, queue.isStrictOrderDispatch());
1:         assertEquals(optimizedDispatch, queue.isOptimizedDispatch());
1:         assertEquals(lazyDispatch, queue.isLazyDispatch());
1:         assertEquals(timeBeforeDispatchStarts, queue.getTimeBeforeDispatchStarts());
1:         assertEquals(consumersBeforeDispatchStarts, queue.getConsumersBeforeDispatchStarts());
1:         assertEquals(allConsumersExclusiveByDefault, queue.isAllConsumersExclusiveByDefault());
1:         assertEquals(persistJMSRedelivered, queue.isPersistJMSRedelivered());
1: 
1:     }
1: 
1:     private void assertAllTopicPolicyProperties(Topic topic, long memoryLimit, boolean lazyDispatch) {
1:         assertEquals(memoryLimit, topic.getMemoryUsage().getLimit());
1:         assertEquals(lazyDispatch, topic.isLazyDispatch());
1:     }
1: 
1:     private void assertAllDestPolicyProperties(BaseDestination dest, boolean producerFlowControl,
1:             boolean alwaysRetroactive, long blockedProducerWarningInterval, int maxPageSize,
1:             int maxBrowsePageSize, long minimumMessageSize, int maxExpirePageSize, int cursorMemoryHighWaterMark,
1:             int storeUsageHighWaterMark, boolean gcInactiveDestinations, boolean gcWithNetworkConsumers,
1:             long inactiveTimeoutBeforeGC,boolean reduceMemoryFootprint, boolean doOptimizeMessageStore,
1:             int optimizeMessageStoreInFlightLimit, boolean advisoryForConsumed, boolean advisoryForDelivery,
1:             boolean advisoryForDiscardingMessages, boolean advisoryForSlowConsumers, boolean advisoryForFastProducers,
1:             boolean advisoryWhenFull, boolean includeBodyForAdvisory, boolean sendAdvisoryIfNoConsumers) {
1: 
1: 
1:         assertEquals(producerFlowControl, dest.isProducerFlowControl());
1:         assertEquals(alwaysRetroactive, dest.isAlwaysRetroactive());
1:         assertEquals(blockedProducerWarningInterval, dest.getBlockedProducerWarningInterval());
1:         assertEquals(maxPageSize, dest.getMaxPageSize());
1:         assertEquals(maxBrowsePageSize, dest.getMaxBrowsePageSize());
1:         assertEquals(minimumMessageSize, dest.getMinimumMessageSize());
1:         assertEquals(maxExpirePageSize, dest.getMaxExpirePageSize());
1:         assertEquals(cursorMemoryHighWaterMark, dest.getCursorMemoryHighWaterMark());
1:         assertEquals(storeUsageHighWaterMark, dest.getStoreUsageHighWaterMark());
1:         assertEquals(gcInactiveDestinations, dest.isGcIfInactive());
1:         assertEquals(gcWithNetworkConsumers, dest.isGcWithNetworkConsumers());
1:         assertEquals(inactiveTimeoutBeforeGC, dest.getInactiveTimeoutBeforeGC());
1:         assertEquals(reduceMemoryFootprint, dest.isReduceMemoryFootprint());
1:         assertEquals(doOptimizeMessageStore, dest.isDoOptimzeMessageStorage());
1:         assertEquals(optimizeMessageStoreInFlightLimit, dest.getOptimizeMessageStoreInFlightLimit());
1:         assertEquals(advisoryForConsumed, dest.isAdvisoryForConsumed());
1:         assertEquals(advisoryForDelivery, dest.isAdvisoryForDelivery());
1:         assertEquals(advisoryForDiscardingMessages, dest.isAdvisoryForDiscardingMessages());
1:         assertEquals(advisoryForSlowConsumers, dest.isAdvisoryForSlowConsumers());
1:         assertEquals(advisoryForFastProducers, dest.isAdvisoryForFastProducers());
1:         assertEquals(advisoryWhenFull, dest.isAdvisoryWhenFull());
1:         assertEquals(includeBodyForAdvisory, dest.isIncludeBodyForAdvisory());
1:         assertEquals(sendAdvisoryIfNoConsumers, dest.isSendAdvisoryIfNoConsumers());
1: 
1:     }
commit:9e7fae0
/////////////////////////////////////////////////////////////////////////
1:     public void testModNewPolicyObject() throws Exception {
1:         BrokerService brokerService = new BrokerService();
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry entry = new PolicyEntry();
1:         entry.setQueue(">");
1:         entry.setMemoryLimit(1024);
1:         policyMap.setPolicyEntries(Arrays.asList(entry));
1:         brokerService.setDestinationPolicy(policyMap);
1: 
1: 
1:         startBroker(brokerService);
1:         assertTrue("broker alive", brokerService.isStarted());
1: 
1:         verifyQueueLimit("Before", 1024);
1: 
1:         //Reapply new limit with new object that matches
1:         //the same destination, so it should still apply
1:         PolicyEntry entry2 = new PolicyEntry();
1:         entry2.setQueue(">");
1:         entry2.setMemoryLimit(4194304);
1:         javaConfigBroker.modifyPolicyEntry(entry2, true);
1:         TimeUnit.SECONDS.sleep(SLEEP);
1: 
1:         // These should change because the policy entry passed in
1:         //matched an existing entry but was not the same reference.
1:         //Since createOrReplace is true, we replace the entry with
1:         //this new entry and apply
1:         verifyQueueLimit("Before", 4194304);
1:         verifyQueueLimit("After", 4194304);
1:     }
1: 
1:     /**
1:      * Test that a new policy is added and applied
1:      *
1:      * @throws Exception
1:      */
1:     @Test
1:     public void testCreate() throws Exception {
1:         BrokerService brokerService = new BrokerService();
1:         PolicyMap policyMap = new PolicyMap();
1:         policyMap.setPolicyEntries(Arrays.asList());
1:         brokerService.setDestinationPolicy(policyMap);
1: 
1:         startBroker(brokerService);
1:         assertTrue("broker alive", brokerService.isStarted());
1:         verifyQueueLimit("Before", (int)brokerService.getSystemUsage().getMemoryUsage().getLimit());
1: 
1:         PolicyEntry entry = new PolicyEntry();
1:         entry.setQueue(">");
1:         entry.setMemoryLimit(1024);
1: 
1:         //The true flag should add the new policy
1:         javaConfigBroker.modifyPolicyEntry(entry, true);
1:         TimeUnit.SECONDS.sleep(SLEEP);
1: 
1:         //Make sure the new policy is added and applied
1:         verifyQueueLimit("Before", 1024);
1:         verifyQueueLimit("After", 1024);
1:     }
1: 
1:     /**
1:      * Test that a new policy is not added
1:      * @throws Exception
1:      */
1:     @Test
1:     public void testCreateFalse() throws Exception {
1:         BrokerService brokerService = new BrokerService();
1:         PolicyMap policyMap = new PolicyMap();
1:         policyMap.setPolicyEntries(Arrays.asList());
1:         brokerService.setDestinationPolicy(policyMap);
1: 
1:         startBroker(brokerService);
1:         assertTrue("broker alive", brokerService.isStarted());
1:         verifyQueueLimit("Before", (int)brokerService.getSystemUsage().getMemoryUsage().getLimit());
1: 
1:         PolicyEntry entry = new PolicyEntry();
1:         entry.setQueue(">");
1:         entry.setMemoryLimit(1024);
1:         //The default should NOT add this policy since it won't match an existing policy to modify
1:         boolean caughtException = false;
1:         try {
1:             javaConfigBroker.modifyPolicyEntry(entry);
1:         } catch (IllegalArgumentException e) {
1:             caughtException = true;
1:         }
1:         assertTrue(caughtException);
1:         TimeUnit.SECONDS.sleep(SLEEP);
1: 
1:         //Make sure there was no change
1:         verifyQueueLimit("Before", (int)brokerService.getSystemUsage().getMemoryUsage().getLimit());
1:         verifyQueueLimit("After", (int)brokerService.getSystemUsage().getMemoryUsage().getLimit());
1:     }
1: 
1: 
1:     @Test
1:     public void testModNewPolicyObjectCreateOrReplaceFalse() throws Exception {
1:         BrokerService brokerService = new BrokerService();
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry entry = new PolicyEntry();
1:         entry.setQueue(">");
1:         entry.setMemoryLimit(1024);
1:         policyMap.setPolicyEntries(Arrays.asList(entry));
1:         brokerService.setDestinationPolicy(policyMap);
1: 
1: 
1:         startBroker(brokerService);
1:         assertTrue("broker alive", brokerService.isStarted());
1: 
1:         verifyQueueLimit("Before", 1024);
1: 
1:         //Reapply new limit with new object that matches
1:         //the same destination, but createOrReplace is false
1:         PolicyEntry entry2 = new PolicyEntry();
1:         entry2.setQueue(">");
1:         entry2.setMemoryLimit(4194304);
1:         boolean caughtException = false;
1:         try {
1:             javaConfigBroker.modifyPolicyEntry(entry2, false);
1:         } catch (IllegalArgumentException e) {
1:             caughtException = true;
1:         }
1:         assertTrue(caughtException);
1:         TimeUnit.SECONDS.sleep(SLEEP);
1: 
1:         // These should not change because the policy entry passed in
1:         //matched an existing entry but was not the same reference.
1:         //Since createOrReplace is false, it should noo be updated
1:         verifyQueueLimit("Before", 1024);
1:         verifyQueueLimit("After", 1024);
1:     }
1: 
1:     @Test
1:     public void testModWithChildPolicy() throws Exception {
1:         BrokerService brokerService = new BrokerService();
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry entry = new PolicyEntry();
1:         entry.setQueue("queue.>");
1:         entry.setMemoryLimit(1024);
1:         PolicyEntry entry2 = new PolicyEntry();
1:         entry2.setQueue("queue.child.>");
1:         entry2.setMemoryLimit(2048);
1:         policyMap.setPolicyEntries(Arrays.asList(entry, entry2));
1:         brokerService.setDestinationPolicy(policyMap);
1: 
1:         startBroker(brokerService);
1:         assertTrue("broker alive", brokerService.isStarted());
1: 
1:         brokerService.getBroker().addDestination(
1:                 brokerService.getAdminConnectionContext(), new ActiveMQQueue("queue.test"), false);
1:         brokerService.getBroker().addDestination(
1:                 brokerService.getAdminConnectionContext(), new ActiveMQQueue("queue.child.test"), false);
1: 
1:         //check destinations before policy updates
1:         verifyQueueLimit("queue.test", 1024);
1:         verifyQueueLimit("queue.child.test", 2048);
1: 
1:         //Reapply new limit to policy 2
1:         entry2.setMemoryLimit(4194304);
1:         javaConfigBroker.modifyPolicyEntry(entry2);
1:         TimeUnit.SECONDS.sleep(SLEEP);
1: 
1:         //verify new dest and existing are changed
1:         verifyQueueLimit("queue.child.test", 4194304);
1:         verifyQueueLimit("queue.child.test2", 4194304);
1: 
1:         //verify that destination at a higher level policy is not affected
1:         verifyQueueLimit("queue.test", 1024);
1:     }
1: 
1:     @Test
1:     public void testModParentPolicy() throws Exception {
1:         BrokerService brokerService = new BrokerService();
1:         PolicyMap policyMap = new PolicyMap();
1: 
1:         PolicyEntry entry = new PolicyEntry();
1:         entry.setQueue("queue.>");
1:         entry.setMemoryLimit(1024);
1:         PolicyEntry entry2 = new PolicyEntry();
1:         entry2.setQueue("queue.child.>");
1:         entry2.setMemoryLimit(2048);
1:         policyMap.setPolicyEntries(Arrays.asList(entry, entry2));
1:         brokerService.setDestinationPolicy(policyMap);
1: 
1:         startBroker(brokerService);
1:         assertTrue("broker alive", brokerService.isStarted());
1: 
1:         brokerService.getBroker().addDestination(
1:                 brokerService.getAdminConnectionContext(), new ActiveMQQueue("queue.test"), false);
1:         brokerService.getBroker().addDestination(
1:                 brokerService.getAdminConnectionContext(), new ActiveMQQueue("queue.child.test"), false);
1: 
1:         //check destinations before policy updates
1:         verifyQueueLimit("queue.test", 1024);
1:         verifyQueueLimit("queue.child.test", 2048);
1: 
1:         //Reapply new limit to policy
1:         entry.setMemoryLimit(4194304);
1:         javaConfigBroker.modifyPolicyEntry(entry);
1:         TimeUnit.SECONDS.sleep(SLEEP);
1: 
1:         //verify new dest and existing are not changed
1:         verifyQueueLimit("queue.child.test", 2048);
1:         verifyQueueLimit("queue.child.test2", 2048);
1: 
1:         //verify that destination at a higher level policy is changed
1:         verifyQueueLimit("queue.test", 4194304);
1:     }
1: 
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void testAddNdModWithMultiplePolicies() throws Exception {
1:         BrokerService brokerService = new BrokerService();
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry entry = new PolicyEntry();
1:         entry.setQueue(">");
1:         entry.setMemoryLimit(1024);
1:         policyMap.setPolicyEntries(Arrays.asList(entry));
1:         brokerService.setDestinationPolicy(policyMap);
1: 
1:         startBroker(brokerService);
1:         assertTrue("broker alive", brokerService.isStarted());
1: 
1:         verifyQueueLimit("Before", 1024);
1:         verifyTopicLimit("Before", brokerService.getSystemUsage().getMemoryUsage().getLimit());
1: 
1:         entry.setMemoryLimit(2048);
1:         javaConfigBroker.modifyPolicyEntry(entry);
1:         TimeUnit.SECONDS.sleep(SLEEP);
1: 
1:         PolicyEntry newEntry = new PolicyEntry();
1:         newEntry.setTopic("test2.>");
1:         newEntry.setMemoryLimit(2048);
1:         PolicyEntry newEntry2 = new PolicyEntry();
1:         newEntry2.setTopic("test2.test.>");
1:         newEntry2.setMemoryLimit(4000);
1:         javaConfigBroker.addNewPolicyEntry(newEntry);
1:         javaConfigBroker.addNewPolicyEntry(newEntry2);
1:         TimeUnit.SECONDS.sleep(SLEEP);
1: 
1:         verifyTopicLimit("test2.after", 2048l);
1:         verifyTopicLimit("test2.test.after", 4000l);
1:         //check existing modified entry
1:         verifyQueueLimit("After", 2048);
1: 
1:         // change to existing dest
1:         PolicyEntry newEntry3 = new PolicyEntry();
1:         newEntry3.setTopic(">");
1:         newEntry3.setMemoryLimit(5000);
1:         javaConfigBroker.addNewPolicyEntry(newEntry3);
1:         verifyTopicLimit("Before", 5000l);
1: 
1:         //reverify children
1:         verifyTopicLimit("test2.after", 2048l);
1:         verifyTopicLimit("test2.test.after", 4000l);
1:     }
1: 
commit:43c3cae
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.java;
1: 
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertTrue;
1: 
1: import java.util.Arrays;
1: import java.util.concurrent.TimeUnit;
1: 
1: import javax.jms.Session;
1: 
1: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.RuntimeConfigTestSupport;
1: import org.apache.activemq.broker.BrokerPlugin;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.plugin.java.JavaRuntimeConfigurationBroker;
1: import org.apache.activemq.plugin.java.JavaRuntimeConfigurationPlugin;
1: import org.junit.Test;
1: 
1: public class JavaPolicyEntryTest extends RuntimeConfigTestSupport {
1: 
1:     public static final int SLEEP = 2; // seconds
1:     private JavaRuntimeConfigurationBroker javaConfigBroker;
1: 
1:     public void startBroker(BrokerService brokerService) throws Exception {
1:         this.brokerService = brokerService;
1:         brokerService.setPlugins(new BrokerPlugin[]{new JavaRuntimeConfigurationPlugin()});
1:         brokerService.setPersistent(false);
1:         brokerService.start();
1:         brokerService.waitUntilStarted();
1: 
1:         javaConfigBroker =
1:                 (JavaRuntimeConfigurationBroker) brokerService.getBroker().getAdaptor(JavaRuntimeConfigurationBroker.class);
1:     }
1: 
1:     @Test
1:     public void testMod() throws Exception {
1:         BrokerService brokerService = new BrokerService();
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry entry = new PolicyEntry();
1:         entry.setQueue(">");
1:         entry.setMemoryLimit(1024);
1:         policyMap.setPolicyEntries(Arrays.asList(entry));
1:         brokerService.setDestinationPolicy(policyMap);
1: 
1: 
1:         startBroker(brokerService);
1:         assertTrue("broker alive", brokerService.isStarted());
1: 
1:         verifyQueueLimit("Before", 1024);
1: 
1:         //Reapply new limit
1:         entry.setMemoryLimit(4194304);
1:         javaConfigBroker.modifyPolicyEntry(entry);
1:         TimeUnit.SECONDS.sleep(SLEEP);
1: 
1:         verifyQueueLimit("After", 4194304);
1: 
1:       // change to existing dest
1:         verifyQueueLimit("Before", 4194304);
1:     }
1: 
1:     @Test
1:     public void testAddNdMod() throws Exception {
1:         BrokerService brokerService = new BrokerService();
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry entry = new PolicyEntry();
1:         entry.setQueue(">");
1:         entry.setMemoryLimit(1024);
1:         policyMap.setPolicyEntries(Arrays.asList(entry));
1:         brokerService.setDestinationPolicy(policyMap);
1: 
1:         startBroker(brokerService);
1:         assertTrue("broker alive", brokerService.isStarted());
1: 
1:         verifyQueueLimit("Before", 1024);
1:         verifyTopicLimit("Before", brokerService.getSystemUsage().getMemoryUsage().getLimit());
1: 
1:         entry.setMemoryLimit(2048);
1:         javaConfigBroker.modifyPolicyEntry(entry);
1:         TimeUnit.SECONDS.sleep(SLEEP);
1: 
1:         PolicyEntry newEntry = new PolicyEntry();
1:         newEntry.setTopic(">");
1:         newEntry.setMemoryLimit(2048);
1:         javaConfigBroker.addNewPolicyEntry(newEntry);
1:         TimeUnit.SECONDS.sleep(SLEEP);
1: 
1:         verifyTopicLimit("After", 2048l);
1:         verifyQueueLimit("After", 2048);
1: 
1:         // change to existing dest
1:         verifyTopicLimit("Before", 2048l);
1:     }
1: 
1:     private void verifyQueueLimit(String dest, int memoryLimit) throws Exception {
1:         ActiveMQConnection connection = (ActiveMQConnection) new ActiveMQConnectionFactory("vm://localhost").createConnection();
1:         try {
1:             connection.start();
1:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             session.createConsumer(session.createQueue(dest));
1: 
0:             assertEquals(memoryLimit, brokerService.getRegionBroker().getDestinationMap().get(new ActiveMQQueue(dest)).getMemoryUsage().getLimit());
1:         } finally {
1:             connection.close();
1:         }
1:     }
1: 
1:     private void verifyTopicLimit(String dest, long memoryLimit) throws Exception {
1:         ActiveMQConnection connection = (ActiveMQConnection) new ActiveMQConnectionFactory("vm://localhost").createConnection();
1:         try {
1:             connection.start();
1:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             session.createConsumer(session.createTopic(dest));
1: 
0:             assertEquals(memoryLimit, brokerService.getRegionBroker().getDestinationMap().get(new ActiveMQTopic(dest)).getMemoryUsage().getLimit());
1:         } finally {
1:             connection.close();
1:         }
1:     }
1: }
============================================================================