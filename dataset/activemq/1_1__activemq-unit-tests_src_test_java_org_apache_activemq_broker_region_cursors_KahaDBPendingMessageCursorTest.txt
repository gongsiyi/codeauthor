1:734fb7d: /**
1:734fb7d:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:734fb7d:  * contributor license agreements.  See the NOTICE file distributed with
1:734fb7d:  * this work for additional information regarding copyright ownership.
1:734fb7d:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:734fb7d:  * (the "License"); you may not use this file except in compliance with
1:734fb7d:  * the License.  You may obtain a copy of the License at
1:734fb7d:  *
1:734fb7d:  *      http://www.apache.org/licenses/LICENSE-2.0
1:734fb7d:  *
1:734fb7d:  * Unless required by applicable law or agreed to in writing, software
1:734fb7d:  * distributed under the License is distributed on an "AS IS" BASIS,
1:734fb7d:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:734fb7d:  * See the License for the specific language governing permissions and
1:734fb7d:  * limitations under the License.
1:734fb7d:  */
1:734fb7d: package org.apache.activemq.broker.region.cursors;
1:734fb7d: 
1:25ff569: import static org.junit.Assert.assertEquals;
1:cf3d419: import static org.junit.Assert.assertTrue;
1:25ff569: 
1:734fb7d: import java.io.File;
1:734fb7d: import java.io.IOException;
1:cf3d419: import java.util.Arrays;
1:cf3d419: import java.util.Collection;
1:734fb7d: import java.util.concurrent.atomic.AtomicLong;
1:734fb7d: 
1:734fb7d: import javax.jms.Connection;
1:734fb7d: import javax.jms.DeliveryMode;
1:cf3d419: import javax.jms.MessageProducer;
1:cf3d419: import javax.jms.Session;
1:cf3d419: import javax.jms.TopicSession;
1:cf3d419: import javax.jms.TopicSubscriber;
1:734fb7d: 
1:734fb7d: import org.apache.activemq.ActiveMQConnectionFactory;
1:734fb7d: import org.apache.activemq.broker.BrokerService;
1:cf3d419: import org.apache.activemq.broker.region.DurableTopicSubscription;
1:734fb7d: import org.apache.activemq.broker.region.Topic;
1:cf3d419: import org.apache.activemq.command.ActiveMQTextMessage;
1:cf3d419: import org.apache.activemq.command.ActiveMQTopic;
1:cf3d419: import org.apache.activemq.store.MessageStoreSubscriptionStatistics;
1:cf3d419: import org.apache.activemq.store.TopicMessageStore;
1:cf3d419: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1:734fb7d: import org.apache.activemq.util.SubscriptionKey;
1:cf3d419: import org.apache.activemq.util.Wait;
1:cf3d419: import org.apache.activemq.util.Wait.Condition;
1:734fb7d: import org.apache.commons.io.FileUtils;
1:734fb7d: import org.junit.Rule;
1:734fb7d: import org.junit.Test;
1:734fb7d: import org.junit.rules.TemporaryFolder;
1:485fcaf: import org.junit.runner.RunWith;
1:485fcaf: import org.junit.runners.Parameterized;
1:cf3d419: import org.junit.runners.Parameterized.Parameters;
1:734fb7d: import org.slf4j.Logger;
1:734fb7d: import org.slf4j.LoggerFactory;
1:734fb7d: 
1:734fb7d: /**
1:734fb7d:  * This test checks that pending message metrics work properly with KahaDB
1:734fb7d:  *
1:cf3d419:  * AMQ-5923, AMQ-6375
1:734fb7d:  *
1:734fb7d:  */
1:485fcaf: @RunWith(Parameterized.class)
1:734fb7d: public class KahaDBPendingMessageCursorTest extends
1:734fb7d:         AbstractPendingMessageCursorTest {
1:cf3d419: 
1:734fb7d:     protected static final Logger LOG = LoggerFactory
1:734fb7d:             .getLogger(KahaDBPendingMessageCursorTest.class);
1:734fb7d: 
1:cf3d419:     @Parameters(name = "prioritizedMessages={0},enableSubscriptionStatistics={1}")
1:cf3d419:     public static Collection<Object[]> data() {
1:cf3d419:         return Arrays.asList(new Object[][] {
1:cf3d419:                 // use priority messages
1:cf3d419:                 { true, true },
1:cf3d419:                 { true, false },
1:cf3d419:                 // don't use priority messages
1:cf3d419:                 { false, true },
1:cf3d419:                 { false, false }
1:cf3d419:         });
1:cf3d419:     }
1:cf3d419: 
1:2262225:     @Rule
1:2262225:     public TemporaryFolder dataFileDir = new TemporaryFolder(new File("target"));
1:734fb7d: 
1:485fcaf:     /**
1:485fcaf:      * @param prioritizedMessages
1:485fcaf:      */
1:cf3d419:     public KahaDBPendingMessageCursorTest(final boolean prioritizedMessages,
1:cf3d419:             final boolean enableSubscriptionStatistics) {
1:485fcaf:         super(prioritizedMessages);
1:cf3d419:         this.enableSubscriptionStatistics = enableSubscriptionStatistics;
1:485fcaf:     }
1:485fcaf: 
1:734fb7d:     @Override
1:734fb7d:     protected void setUpBroker(boolean clearDataDir) throws Exception {
1:2262225:         if (clearDataDir && dataFileDir.getRoot().exists())
1:2262225:             FileUtils.cleanDirectory(dataFileDir.getRoot());
1:734fb7d:         super.setUpBroker(clearDataDir);
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     @Override
1:734fb7d:     protected void initPersistence(BrokerService brokerService)
1:734fb7d:             throws IOException {
1:734fb7d:         broker.setPersistent(true);
1:cf3d419:         KahaDBPersistenceAdapter persistenceAdapter = new KahaDBPersistenceAdapter();
1:cf3d419:         persistenceAdapter.setDirectory(dataFileDir.getRoot());
1:cf3d419:         persistenceAdapter.setEnableSubscriptionStatistics(enableSubscriptionStatistics);
1:cf3d419:         broker.setPersistenceAdapter(persistenceAdapter);
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     /**
1:734fb7d:      * Test that the the counter restores size and works after restart and more
1:734fb7d:      * messages are published
1:734fb7d:      *
1:734fb7d:      * @throws Exception
1:734fb7d:      */
1:cf3d419:     @Test
1:734fb7d:     public void testDurableMessageSizeAfterRestartAndPublish() throws Exception {
1:734fb7d:         AtomicLong publishedMessageSize = new AtomicLong();
1:734fb7d: 
1:734fb7d:         Connection connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:734fb7d:         connection.setClientID("clientId");
1:734fb7d:         connection.start();
1:734fb7d:         Topic topic =  publishTestMessagesDurable(connection, new String[] {"sub1"}, 200,
1:734fb7d:                 publishedMessageSize, DeliveryMode.PERSISTENT);
1:734fb7d: 
1:734fb7d:         SubscriptionKey subKey = new SubscriptionKey("clientId", "sub1");
1:734fb7d: 
1:734fb7d:         // verify the count and size
1:734fb7d:         verifyPendingStats(topic, subKey, 200, publishedMessageSize.get());
1:734fb7d:         verifyStoreStats(topic, 200, publishedMessageSize.get());
1:734fb7d: 
1:25ff569:         //should be equal in this case
1:cf3d419:         long beforeRestartSize = topic.getDurableTopicSubs().get(subKey).getPendingMessageSize();
1:cf3d419:         assertEquals(beforeRestartSize,
1:25ff569:                 topic.getMessageStore().getMessageStoreStatistics().getMessageSize().getTotalSize());
1:25ff569: 
1:734fb7d:         // stop, restart broker and publish more messages
1:734fb7d:         stopBroker();
1:734fb7d:         this.setUpBroker(false);
1:734fb7d: 
1:cf3d419:         //verify that after restart the size is the same as before restart on recovery
1:cf3d419:         topic = (Topic) getBroker().getDestination(new ActiveMQTopic(defaultTopicName));
1:cf3d419:         assertEquals(beforeRestartSize, topic.getDurableTopicSubs().get(subKey).getPendingMessageSize());
1:cf3d419: 
1:734fb7d:         connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:734fb7d:         connection.setClientID("clientId");
1:734fb7d:         connection.start();
1:734fb7d: 
1:734fb7d:         topic = publishTestMessagesDurable(connection, new String[] {"sub1"}, 200,
1:734fb7d:                 publishedMessageSize, DeliveryMode.PERSISTENT);
1:734fb7d: 
1:734fb7d:         // verify the count and size
1:734fb7d:         verifyPendingStats(topic, subKey, 400, publishedMessageSize.get());
1:734fb7d:         verifyStoreStats(topic, 400, publishedMessageSize.get());
1:734fb7d: 
1:734fb7d:     }
1:734fb7d: 
1:cf3d419:     @Test
1:25ff569:     public void testMessageSizeTwoDurablesPartialConsumption() throws Exception {
1:25ff569:         AtomicLong publishedMessageSize = new AtomicLong();
1:25ff569: 
1:25ff569:         Connection connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:25ff569:         connection.setClientID("clientId");
1:25ff569:         connection.start();
1:25ff569: 
1:25ff569:         SubscriptionKey subKey = new SubscriptionKey("clientId", "sub1");
1:25ff569:         SubscriptionKey subKey2 = new SubscriptionKey("clientId", "sub2");
1:25ff569:         org.apache.activemq.broker.region.Topic dest = publishTestMessagesDurable(
1:25ff569:                 connection, new String[] {"sub1", "sub2"}, 200, publishedMessageSize, DeliveryMode.PERSISTENT);
1:25ff569: 
1:25ff569:         //verify the count and size - durable is offline so all 200 should be pending since none are in prefetch
1:25ff569:         verifyPendingStats(dest, subKey, 200, publishedMessageSize.get());
1:25ff569:         verifyStoreStats(dest, 200, publishedMessageSize.get());
1:25ff569: 
1:25ff569:         //consume all messages
1:25ff569:         consumeDurableTestMessages(connection, "sub1", 50, publishedMessageSize);
1:25ff569: 
1:25ff569:         //150 should be left
1:25ff569:         verifyPendingStats(dest, subKey, 150, publishedMessageSize.get());
1:25ff569: 
1:25ff569:         //200 should be left
1:25ff569:         verifyPendingStats(dest, subKey2, 200, publishedMessageSize.get());
1:25ff569:         verifyStoreStats(dest, 200, publishedMessageSize.get());
1:25ff569: 
1:25ff569:         connection.close();
1:25ff569:     }
1:25ff569: 
1:734fb7d:     /**
1:734fb7d:      * Test that the the counter restores size and works after restart and more
1:734fb7d:      * messages are published
1:734fb7d:      *
1:734fb7d:      * @throws Exception
1:734fb7d:      */
1:cf3d419:     @Test
1:734fb7d:     public void testNonPersistentDurableMessageSize() throws Exception {
1:734fb7d:         AtomicLong publishedMessageSize = new AtomicLong();
1:734fb7d: 
1:734fb7d:         Connection connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:734fb7d:         connection.setClientID("clientId");
1:734fb7d:         connection.start();
1:734fb7d:         Topic topic =  publishTestMessagesDurable(connection, new String[] {"sub1"}, 200,
1:734fb7d:                 publishedMessageSize, DeliveryMode.NON_PERSISTENT);
1:734fb7d: 
1:734fb7d:         SubscriptionKey subKey = new SubscriptionKey("clientId", "sub1");
1:734fb7d: 
1:734fb7d:         // verify the count and size
1:734fb7d:         verifyPendingStats(topic, subKey, 200, publishedMessageSize.get());
1:734fb7d:         verifyStoreStats(topic, 0, 0);
1:734fb7d:     }
1:485fcaf: 
1:cf3d419:     /**
1:cf3d419:      * Test that the subscription counters are properly set when enabled
1:cf3d419:      * and not set when disabled
1:cf3d419:      *
1:cf3d419:      * @throws Exception
1:cf3d419:      */
1:cf3d419:     @Test
1:cf3d419:     public void testEnabledSubscriptionStatistics() throws Exception {
1:cf3d419:         AtomicLong publishedMessageSize = new AtomicLong();
1:cf3d419: 
1:cf3d419:         Connection connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:cf3d419:         connection.setClientID("clientId");
1:cf3d419:         connection.start();
1:cf3d419: 
1:cf3d419:         SubscriptionKey subKey = new SubscriptionKey("clientId", "sub1");
1:cf3d419:         SubscriptionKey subKey2 = new SubscriptionKey("clientId", "sub2");
1:cf3d419:         org.apache.activemq.broker.region.Topic dest = publishTestMessagesDurable(
1:cf3d419:                 connection, new String[] {"sub1", "sub2"}, 200, publishedMessageSize, DeliveryMode.PERSISTENT);
1:cf3d419: 
1:cf3d419:         TopicMessageStore store = (TopicMessageStore) dest.getMessageStore();
1:cf3d419:         MessageStoreSubscriptionStatistics stats = store.getMessageStoreSubStatistics();
1:cf3d419:         if (enableSubscriptionStatistics) {
1:cf3d419:             assertTrue(stats.getMessageCount(subKey.toString()).getCount() == 200);
1:cf3d419:             assertTrue(stats.getMessageSize(subKey.toString()).getTotalSize() > 0);
1:cf3d419:             assertTrue(stats.getMessageCount(subKey2.toString()).getCount() == 200);
1:cf3d419:             assertTrue(stats.getMessageSize(subKey2.toString()).getTotalSize() > 0);
1:cf3d419:             assertEquals(stats.getMessageCount().getCount(),
1:cf3d419:                     stats.getMessageCount(subKey.toString()).getCount() +
1:cf3d419:                     stats.getMessageSize(subKey.toString()).getCount());
1:cf3d419:             assertEquals(stats.getMessageSize().getTotalSize(),
1:cf3d419:                     stats.getMessageSize(subKey.toString()).getTotalSize() +
1:cf3d419:                     stats.getMessageSize(subKey2.toString()).getTotalSize());
1:cf3d419: 
1:cf3d419:             //Delete second subscription and verify stats are updated accordingly
1:cf3d419:             store.deleteSubscription(subKey2.getClientId(), subKey2.getSubscriptionName());
1:cf3d419:             assertEquals(stats.getMessageCount().getCount(), stats.getMessageCount(subKey.toString()).getCount());
1:cf3d419:             assertEquals(stats.getMessageSize().getTotalSize(), stats.getMessageSize(subKey.toString()).getTotalSize());
1:cf3d419:             assertTrue(stats.getMessageCount(subKey2.toString()).getCount() == 0);
1:cf3d419:             assertTrue(stats.getMessageSize(subKey2.toString()).getTotalSize() == 0);
1:cf3d419: 
1:cf3d419:         } else {
1:cf3d419:             assertTrue(stats.getMessageCount(subKey.toString()).getCount() == 0);
1:cf3d419:             assertTrue(stats.getMessageSize(subKey.toString()).getTotalSize() == 0);
1:cf3d419:             assertTrue(stats.getMessageCount(subKey2.toString()).getCount() == 0);
1:cf3d419:             assertTrue(stats.getMessageSize(subKey2.toString()).getTotalSize() == 0);
1:cf3d419:             assertEquals(0, stats.getMessageCount().getCount());
1:cf3d419:             assertEquals(0, stats.getMessageSize().getTotalSize());
1:cf3d419:         }
1:cf3d419: 
1:cf3d419:     }
1:cf3d419: 
1:cf3d419:     @Test
1:cf3d419:     public void testUpdateMessageSubSize() throws Exception {
1:cf3d419:         Connection connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:cf3d419:         connection.setClientID("clientId");
1:cf3d419:         connection.start();
1:cf3d419:         Session session = connection.createSession(false, TopicSession.AUTO_ACKNOWLEDGE);
1:cf3d419:         javax.jms.Topic dest = session.createTopic(defaultTopicName);
1:cf3d419:         session.createDurableSubscriber(dest, "sub1");
1:cf3d419:         session.createDurableSubscriber(dest, "sub2");
1:cf3d419:         MessageProducer prod = session.createProducer(dest);
1:cf3d419: 
1:cf3d419:         ActiveMQTextMessage message = new ActiveMQTextMessage();
1:cf3d419:         message.setText("SmallMessage");
1:cf3d419:         prod.send(message);
1:cf3d419: 
1:cf3d419:         SubscriptionKey subKey = new SubscriptionKey("clientId", "sub1");
1:cf3d419:         SubscriptionKey subKey2 = new SubscriptionKey("clientId", "sub1");
1:cf3d419: 
1:cf3d419:         final Topic topic =  (Topic) getBroker().getDestination(new ActiveMQTopic(defaultTopicName));
1:cf3d419:         final DurableTopicSubscription sub = topic.getDurableTopicSubs().get(subKey);
1:cf3d419:         final DurableTopicSubscription sub2 = topic.getDurableTopicSubs().get(subKey2);
1:cf3d419:         long sizeBeforeUpdate = sub.getPendingMessageSize();
1:cf3d419: 
1:cf3d419:         message = (ActiveMQTextMessage) topic.getMessageStore().getMessage(message.getMessageId());
1:cf3d419:         message.setText("LargerMessageLargerMessage");
1:cf3d419: 
1:cf3d419:         //update the message
1:cf3d419:         topic.getMessageStore().updateMessage(message);
1:cf3d419: 
1:cf3d419:         //should be at least 10 bytes bigger and match the store size
1:cf3d419:         assertTrue(sub.getPendingMessageSize() > sizeBeforeUpdate + 10);
1:cf3d419:         assertEquals(sub.getPendingMessageSize(), topic.getMessageStore().getMessageSize());
1:cf3d419:         assertEquals(sub.getPendingMessageSize(), sub2.getPendingMessageSize());
1:cf3d419:     }
1:cf3d419: 
1:cf3d419:     @Test
1:cf3d419:     public void testUpdateMessageSubSizeAfterConsume() throws Exception {
1:cf3d419:         Connection connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:cf3d419:         connection.setClientID("clientId");
1:cf3d419:         connection.start();
1:cf3d419:         Session session = connection.createSession(false, TopicSession.AUTO_ACKNOWLEDGE);
1:cf3d419:         javax.jms.Topic dest = session.createTopic(defaultTopicName);
1:cf3d419:         session.createDurableSubscriber(dest, "sub1");
1:cf3d419:         TopicSubscriber subscriber2 = session.createDurableSubscriber(dest, "sub2");
1:cf3d419:         MessageProducer prod = session.createProducer(dest);
1:cf3d419: 
1:cf3d419:         ActiveMQTextMessage message = new ActiveMQTextMessage();
1:cf3d419:         message.setText("SmallMessage");
1:cf3d419:         ActiveMQTextMessage message2 = new ActiveMQTextMessage();
1:cf3d419:         message2.setText("SmallMessage2");
1:cf3d419:         prod.send(message);
1:cf3d419:         prod.send(message2);
1:cf3d419: 
1:cf3d419:         //Receive first message for sub 2 and wait for stats to update
1:cf3d419:         subscriber2.receive();
1:cf3d419: 
1:cf3d419:         SubscriptionKey subKey = new SubscriptionKey("clientId", "sub1");
1:cf3d419:         SubscriptionKey subKey2 = new SubscriptionKey("clientId", "sub2");
1:cf3d419:         final Topic topic =  (Topic) getBroker().getDestination(new ActiveMQTopic(defaultTopicName));
1:cf3d419:         final DurableTopicSubscription sub = topic.getDurableTopicSubs().get(subKey);
1:cf3d419:         final DurableTopicSubscription sub2 = topic.getDurableTopicSubs().get(subKey2);
1:cf3d419: 
1:cf3d419:         Wait.waitFor(new Condition() {
1:cf3d419: 
1:cf3d419:             @Override
1:cf3d419:             public boolean isSatisified() throws Exception {
1:cf3d419:                 return sub.getPendingMessageSize() > sub2.getPendingMessageSize();
1:cf3d419:             }
1:cf3d419:         });
1:cf3d419: 
1:cf3d419:         long sizeBeforeUpdate = sub.getPendingMessageSize();
1:cf3d419:         long sizeBeforeUpdate2 = sub2.getPendingMessageSize();
1:cf3d419: 
1:cf3d419:         //update message 2
1:cf3d419:         message = (ActiveMQTextMessage) topic.getMessageStore().getMessage(message.getMessageId());
1:cf3d419:         message.setText("LargerMessageLargerMessage");
1:cf3d419: 
1:cf3d419:         //update the message
1:cf3d419:         topic.getMessageStore().updateMessage(message);
1:cf3d419: 
1:cf3d419:         //should be at least 10 bytes bigger and match the store size
1:cf3d419:         assertTrue(sub.getPendingMessageSize() > sizeBeforeUpdate + 10);
1:cf3d419:         assertEquals(sub.getPendingMessageSize(), topic.getMessageStore().getMessageSize());
1:cf3d419: 
1:cf3d419:         //Sub2 only has 1 message so should be less than sub, verify that the update message
1:cf3d419:         //didn't update the stats of sub2 and sub1 should be over twice as large since the
1:cf3d419:         //updated message is bigger
1:cf3d419:         assertTrue(sub.getPendingMessageSize() > 2 * sub2.getPendingMessageSize());
1:cf3d419:         assertEquals(sizeBeforeUpdate2, sub2.getPendingMessageSize());
1:cf3d419: 
1:cf3d419:     }
1:cf3d419: 
1:734fb7d: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:cf3d419
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertTrue;
1: import java.util.Arrays;
1: import java.util.Collection;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: import javax.jms.TopicSession;
1: import javax.jms.TopicSubscriber;
1: import org.apache.activemq.broker.region.DurableTopicSubscription;
1: import org.apache.activemq.command.ActiveMQTextMessage;
1: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.store.MessageStoreSubscriptionStatistics;
1: import org.apache.activemq.store.TopicMessageStore;
1: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1: import org.apache.activemq.util.Wait;
1: import org.apache.activemq.util.Wait.Condition;
1: import org.junit.runners.Parameterized.Parameters;
1:  * AMQ-5923, AMQ-6375
1: 
1:     @Parameters(name = "prioritizedMessages={0},enableSubscriptionStatistics={1}")
1:     public static Collection<Object[]> data() {
1:         return Arrays.asList(new Object[][] {
1:                 // use priority messages
1:                 { true, true },
1:                 { true, false },
1:                 // don't use priority messages
1:                 { false, true },
1:                 { false, false }
1:         });
1:     }
1: 
1:     public KahaDBPendingMessageCursorTest(final boolean prioritizedMessages,
1:             final boolean enableSubscriptionStatistics) {
1:         this.enableSubscriptionStatistics = enableSubscriptionStatistics;
/////////////////////////////////////////////////////////////////////////
1:         KahaDBPersistenceAdapter persistenceAdapter = new KahaDBPersistenceAdapter();
1:         persistenceAdapter.setDirectory(dataFileDir.getRoot());
1:         persistenceAdapter.setEnableSubscriptionStatistics(enableSubscriptionStatistics);
1:         broker.setPersistenceAdapter(persistenceAdapter);
/////////////////////////////////////////////////////////////////////////
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:         long beforeRestartSize = topic.getDurableTopicSubs().get(subKey).getPendingMessageSize();
1:         assertEquals(beforeRestartSize,
1:         //verify that after restart the size is the same as before restart on recovery
1:         topic = (Topic) getBroker().getDestination(new ActiveMQTopic(defaultTopicName));
1:         assertEquals(beforeRestartSize, topic.getDurableTopicSubs().get(subKey).getPendingMessageSize());
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test that the subscription counters are properly set when enabled
1:      * and not set when disabled
1:      *
1:      * @throws Exception
1:      */
1:     @Test
1:     public void testEnabledSubscriptionStatistics() throws Exception {
1:         AtomicLong publishedMessageSize = new AtomicLong();
1: 
1:         Connection connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:         connection.setClientID("clientId");
1:         connection.start();
1: 
1:         SubscriptionKey subKey = new SubscriptionKey("clientId", "sub1");
1:         SubscriptionKey subKey2 = new SubscriptionKey("clientId", "sub2");
1:         org.apache.activemq.broker.region.Topic dest = publishTestMessagesDurable(
1:                 connection, new String[] {"sub1", "sub2"}, 200, publishedMessageSize, DeliveryMode.PERSISTENT);
1: 
1:         TopicMessageStore store = (TopicMessageStore) dest.getMessageStore();
1:         MessageStoreSubscriptionStatistics stats = store.getMessageStoreSubStatistics();
1:         if (enableSubscriptionStatistics) {
1:             assertTrue(stats.getMessageCount(subKey.toString()).getCount() == 200);
1:             assertTrue(stats.getMessageSize(subKey.toString()).getTotalSize() > 0);
1:             assertTrue(stats.getMessageCount(subKey2.toString()).getCount() == 200);
1:             assertTrue(stats.getMessageSize(subKey2.toString()).getTotalSize() > 0);
1:             assertEquals(stats.getMessageCount().getCount(),
1:                     stats.getMessageCount(subKey.toString()).getCount() +
1:                     stats.getMessageSize(subKey.toString()).getCount());
1:             assertEquals(stats.getMessageSize().getTotalSize(),
1:                     stats.getMessageSize(subKey.toString()).getTotalSize() +
1:                     stats.getMessageSize(subKey2.toString()).getTotalSize());
1: 
1:             //Delete second subscription and verify stats are updated accordingly
1:             store.deleteSubscription(subKey2.getClientId(), subKey2.getSubscriptionName());
1:             assertEquals(stats.getMessageCount().getCount(), stats.getMessageCount(subKey.toString()).getCount());
1:             assertEquals(stats.getMessageSize().getTotalSize(), stats.getMessageSize(subKey.toString()).getTotalSize());
1:             assertTrue(stats.getMessageCount(subKey2.toString()).getCount() == 0);
1:             assertTrue(stats.getMessageSize(subKey2.toString()).getTotalSize() == 0);
1: 
1:         } else {
1:             assertTrue(stats.getMessageCount(subKey.toString()).getCount() == 0);
1:             assertTrue(stats.getMessageSize(subKey.toString()).getTotalSize() == 0);
1:             assertTrue(stats.getMessageCount(subKey2.toString()).getCount() == 0);
1:             assertTrue(stats.getMessageSize(subKey2.toString()).getTotalSize() == 0);
1:             assertEquals(0, stats.getMessageCount().getCount());
1:             assertEquals(0, stats.getMessageSize().getTotalSize());
1:         }
1: 
1:     }
1: 
1:     @Test
1:     public void testUpdateMessageSubSize() throws Exception {
1:         Connection connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:         connection.setClientID("clientId");
1:         connection.start();
1:         Session session = connection.createSession(false, TopicSession.AUTO_ACKNOWLEDGE);
1:         javax.jms.Topic dest = session.createTopic(defaultTopicName);
1:         session.createDurableSubscriber(dest, "sub1");
1:         session.createDurableSubscriber(dest, "sub2");
1:         MessageProducer prod = session.createProducer(dest);
1: 
1:         ActiveMQTextMessage message = new ActiveMQTextMessage();
1:         message.setText("SmallMessage");
1:         prod.send(message);
1: 
1:         SubscriptionKey subKey = new SubscriptionKey("clientId", "sub1");
1:         SubscriptionKey subKey2 = new SubscriptionKey("clientId", "sub1");
1: 
1:         final Topic topic =  (Topic) getBroker().getDestination(new ActiveMQTopic(defaultTopicName));
1:         final DurableTopicSubscription sub = topic.getDurableTopicSubs().get(subKey);
1:         final DurableTopicSubscription sub2 = topic.getDurableTopicSubs().get(subKey2);
1:         long sizeBeforeUpdate = sub.getPendingMessageSize();
1: 
1:         message = (ActiveMQTextMessage) topic.getMessageStore().getMessage(message.getMessageId());
1:         message.setText("LargerMessageLargerMessage");
1: 
1:         //update the message
1:         topic.getMessageStore().updateMessage(message);
1: 
1:         //should be at least 10 bytes bigger and match the store size
1:         assertTrue(sub.getPendingMessageSize() > sizeBeforeUpdate + 10);
1:         assertEquals(sub.getPendingMessageSize(), topic.getMessageStore().getMessageSize());
1:         assertEquals(sub.getPendingMessageSize(), sub2.getPendingMessageSize());
1:     }
1: 
1:     @Test
1:     public void testUpdateMessageSubSizeAfterConsume() throws Exception {
1:         Connection connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:         connection.setClientID("clientId");
1:         connection.start();
1:         Session session = connection.createSession(false, TopicSession.AUTO_ACKNOWLEDGE);
1:         javax.jms.Topic dest = session.createTopic(defaultTopicName);
1:         session.createDurableSubscriber(dest, "sub1");
1:         TopicSubscriber subscriber2 = session.createDurableSubscriber(dest, "sub2");
1:         MessageProducer prod = session.createProducer(dest);
1: 
1:         ActiveMQTextMessage message = new ActiveMQTextMessage();
1:         message.setText("SmallMessage");
1:         ActiveMQTextMessage message2 = new ActiveMQTextMessage();
1:         message2.setText("SmallMessage2");
1:         prod.send(message);
1:         prod.send(message2);
1: 
1:         //Receive first message for sub 2 and wait for stats to update
1:         subscriber2.receive();
1: 
1:         SubscriptionKey subKey = new SubscriptionKey("clientId", "sub1");
1:         SubscriptionKey subKey2 = new SubscriptionKey("clientId", "sub2");
1:         final Topic topic =  (Topic) getBroker().getDestination(new ActiveMQTopic(defaultTopicName));
1:         final DurableTopicSubscription sub = topic.getDurableTopicSubs().get(subKey);
1:         final DurableTopicSubscription sub2 = topic.getDurableTopicSubs().get(subKey2);
1: 
1:         Wait.waitFor(new Condition() {
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return sub.getPendingMessageSize() > sub2.getPendingMessageSize();
1:             }
1:         });
1: 
1:         long sizeBeforeUpdate = sub.getPendingMessageSize();
1:         long sizeBeforeUpdate2 = sub2.getPendingMessageSize();
1: 
1:         //update message 2
1:         message = (ActiveMQTextMessage) topic.getMessageStore().getMessage(message.getMessageId());
1:         message.setText("LargerMessageLargerMessage");
1: 
1:         //update the message
1:         topic.getMessageStore().updateMessage(message);
1: 
1:         //should be at least 10 bytes bigger and match the store size
1:         assertTrue(sub.getPendingMessageSize() > sizeBeforeUpdate + 10);
1:         assertEquals(sub.getPendingMessageSize(), topic.getMessageStore().getMessageSize());
1: 
1:         //Sub2 only has 1 message so should be less than sub, verify that the update message
1:         //didn't update the stats of sub2 and sub1 should be over twice as large since the
1:         //updated message is bigger
1:         assertTrue(sub.getPendingMessageSize() > 2 * sub2.getPendingMessageSize());
1:         assertEquals(sizeBeforeUpdate2, sub2.getPendingMessageSize());
1: 
1:     }
1: 
commit:485fcaf
/////////////////////////////////////////////////////////////////////////
1: import org.junit.runner.RunWith;
1: import org.junit.runners.Parameterized;
/////////////////////////////////////////////////////////////////////////
1: @RunWith(Parameterized.class)
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @param prioritizedMessages
1:      */
0:     public KahaDBPendingMessageCursorTest(boolean prioritizedMessages) {
1:         super(prioritizedMessages);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
commit:25ff569
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertEquals;
1: 
/////////////////////////////////////////////////////////////////////////
1:         //should be equal in this case
0:         assertEquals(topic.getDurableTopicSubs().get(subKey).getPendingMessageSize(),
1:                 topic.getMessageStore().getMessageStoreStatistics().getMessageSize().getTotalSize());
1: 
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=60000)
1:     public void testMessageSizeTwoDurablesPartialConsumption() throws Exception {
1:         AtomicLong publishedMessageSize = new AtomicLong();
1: 
1:         Connection connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:         connection.setClientID("clientId");
1:         connection.start();
1: 
1:         SubscriptionKey subKey = new SubscriptionKey("clientId", "sub1");
1:         SubscriptionKey subKey2 = new SubscriptionKey("clientId", "sub2");
1:         org.apache.activemq.broker.region.Topic dest = publishTestMessagesDurable(
1:                 connection, new String[] {"sub1", "sub2"}, 200, publishedMessageSize, DeliveryMode.PERSISTENT);
1: 
1:         //verify the count and size - durable is offline so all 200 should be pending since none are in prefetch
1:         verifyPendingStats(dest, subKey, 200, publishedMessageSize.get());
1:         verifyStoreStats(dest, 200, publishedMessageSize.get());
1: 
1:         //consume all messages
1:         consumeDurableTestMessages(connection, "sub1", 50, publishedMessageSize);
1: 
1:         //150 should be left
1:         verifyPendingStats(dest, subKey, 150, publishedMessageSize.get());
1: 
1:         //200 should be left
1:         verifyPendingStats(dest, subKey2, 200, publishedMessageSize.get());
1:         verifyStoreStats(dest, 200, publishedMessageSize.get());
1: 
1:         connection.close();
1:     }
1: 
commit:d2bd152
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=60000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=60000)
commit:8a09b7e
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=30000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=30000)
commit:2262225
/////////////////////////////////////////////////////////////////////////
1:     @Rule
1:     public TemporaryFolder dataFileDir = new TemporaryFolder(new File("target"));
1:         if (clearDataDir && dataFileDir.getRoot().exists())
1:             FileUtils.cleanDirectory(dataFileDir.getRoot());
/////////////////////////////////////////////////////////////////////////
0:         broker.setDataDirectoryFile(dataFileDir.getRoot());
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=10000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=10000)
commit:d27b192
/////////////////////////////////////////////////////////////////////////
0:     File dataFileDir = new File("target/test-amq-5923/pending-datadb");
0:         if (clearDataDir && dataFileDir.exists())
0:             FileUtils.cleanDirectory(dataFileDir);
/////////////////////////////////////////////////////////////////////////
0:         broker.setDataDirectoryFile(dataFileDir);
commit:d1dface
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=20000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=20000)
commit:734fb7d
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker.region.cursors;
1: 
1: import java.io.File;
1: import java.io.IOException;
1: import java.util.concurrent.atomic.AtomicLong;
1: 
1: import javax.jms.Connection;
1: import javax.jms.DeliveryMode;
1: 
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.region.Topic;
1: import org.apache.activemq.util.SubscriptionKey;
1: import org.apache.commons.io.FileUtils;
1: import org.junit.Rule;
1: import org.junit.Test;
1: import org.junit.rules.TemporaryFolder;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * This test checks that pending message metrics work properly with KahaDB
1:  *
0:  * AMQ-5923
1:  *
1:  */
1: public class KahaDBPendingMessageCursorTest extends
1:         AbstractPendingMessageCursorTest {
1:     protected static final Logger LOG = LoggerFactory
1:             .getLogger(KahaDBPendingMessageCursorTest.class);
1: 
0:     @Rule
0:     public TemporaryFolder dataFileDir = new TemporaryFolder(new File("target"));
1: 
1:     @Override
1:     protected void setUpBroker(boolean clearDataDir) throws Exception {
0:         if (clearDataDir && dataFileDir.getRoot().exists())
0:             FileUtils.cleanDirectory(dataFileDir.getRoot());
1:         super.setUpBroker(clearDataDir);
1:     }
1: 
1:     @Override
1:     protected void initPersistence(BrokerService brokerService)
1:             throws IOException {
1:         broker.setPersistent(true);
0:         broker.setDataDirectoryFile(dataFileDir.getRoot());
1:     }
1: 
1:     /**
1:      * Test that the the counter restores size and works after restart and more
1:      * messages are published
1:      *
1:      * @throws Exception
1:      */
0:     @Test(timeout=10000)
1:     public void testDurableMessageSizeAfterRestartAndPublish() throws Exception {
1:         AtomicLong publishedMessageSize = new AtomicLong();
1: 
1:         Connection connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:         connection.setClientID("clientId");
1:         connection.start();
1:         Topic topic =  publishTestMessagesDurable(connection, new String[] {"sub1"}, 200,
1:                 publishedMessageSize, DeliveryMode.PERSISTENT);
1: 
1:         SubscriptionKey subKey = new SubscriptionKey("clientId", "sub1");
1: 
1:         // verify the count and size
1:         verifyPendingStats(topic, subKey, 200, publishedMessageSize.get());
1:         verifyStoreStats(topic, 200, publishedMessageSize.get());
1: 
1:         // stop, restart broker and publish more messages
1:         stopBroker();
1:         this.setUpBroker(false);
1: 
1:         connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:         connection.setClientID("clientId");
1:         connection.start();
1: 
1:         topic = publishTestMessagesDurable(connection, new String[] {"sub1"}, 200,
1:                 publishedMessageSize, DeliveryMode.PERSISTENT);
1: 
1:         // verify the count and size
1:         verifyPendingStats(topic, subKey, 400, publishedMessageSize.get());
1:         verifyStoreStats(topic, 400, publishedMessageSize.get());
1: 
1:     }
1: 
1:     /**
1:      * Test that the the counter restores size and works after restart and more
1:      * messages are published
1:      *
1:      * @throws Exception
1:      */
0:     @Test(timeout=10000)
1:     public void testNonPersistentDurableMessageSize() throws Exception {
1:         AtomicLong publishedMessageSize = new AtomicLong();
1: 
1:         Connection connection = new ActiveMQConnectionFactory(brokerConnectURI).createConnection();
1:         connection.setClientID("clientId");
1:         connection.start();
1:         Topic topic =  publishTestMessagesDurable(connection, new String[] {"sub1"}, 200,
1:                 publishedMessageSize, DeliveryMode.NON_PERSISTENT);
1: 
1:         SubscriptionKey subKey = new SubscriptionKey("clientId", "sub1");
1: 
1:         // verify the count and size
1:         verifyPendingStats(topic, subKey, 200, publishedMessageSize.get());
1:         verifyStoreStats(topic, 0, 0);
1:     }
1: }
============================================================================