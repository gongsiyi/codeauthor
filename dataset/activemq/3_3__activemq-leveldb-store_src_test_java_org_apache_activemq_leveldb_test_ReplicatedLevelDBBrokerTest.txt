1:3ed52ef: /**
1:3ed52ef:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:3ed52ef:  * contributor license agreements.  See the NOTICE file distributed with
1:3ed52ef:  * this work for additional information regarding copyright ownership.
1:3ed52ef:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:3ed52ef:  * (the "License"); you may not use this file except in compliance with
1:3ed52ef:  * the License.  You may obtain a copy of the License at
1:3ed52ef:  *
1:3ed52ef:  *      http://www.apache.org/licenses/LICENSE-2.0
1:3ed52ef:  *
1:3ed52ef:  * Unless required by applicable law or agreed to in writing, software
1:3ed52ef:  * distributed under the License is distributed on an "AS IS" BASIS,
1:3ed52ef:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:3ed52ef:  * See the License for the specific language governing permissions and
1:3ed52ef:  * limitations under the License.
1:3ed52ef:  */
1:3ed52ef: package org.apache.activemq.leveldb.test;
7:3ed52ef: 
1:3ed52ef: import org.apache.activemq.ActiveMQConnectionFactory;
1:3ed52ef: import org.apache.activemq.broker.BrokerService;
1:3ed52ef: import org.apache.activemq.broker.TransportConnector;
1:3ed52ef: import org.apache.activemq.leveldb.replicated.ElectingLevelDBStore;
1:3ed52ef: import org.junit.After;
1:24d5490: import org.junit.Before;
1:ed8e4ea: import org.junit.Ignore;
1:3ed52ef: import org.junit.Test;
1:3ed52ef: 
1:3ed52ef: import javax.jms.*;
1:24d5490: import javax.management.ObjectName;
1:24d5490: import javax.management.openmbean.CompositeData;
1:3ed52ef: import java.io.File;
1:24d5490: import java.io.IOException;
1:24d5490: import java.lang.management.ManagementFactory;
1:ed8e4ea: import java.net.ServerSocket;
1:ed8e4ea: import java.net.URI;
1:ed8e4ea: import java.net.URISyntaxException;
1:3ed52ef: import java.util.ArrayList;
1:3ed52ef: import java.util.Enumeration;
1:ed8e4ea: import java.util.concurrent.ArrayBlockingQueue;
1:3ed52ef: import java.util.concurrent.SynchronousQueue;
1:3ed52ef: import java.util.concurrent.TimeUnit;
1:ed8e4ea: import java.util.concurrent.atomic.AtomicBoolean;
1:ed8e4ea: import java.util.concurrent.atomic.AtomicLong;
1:ed8e4ea: 
1:24d5490: import org.apache.commons.io.FileUtils;
1:5ebe71c: import org.slf4j.Logger;
1:5ebe71c: import org.slf4j.LoggerFactory;
1:5ebe71c: 
1:3ed52ef: 
1:24d5490: import static org.junit.Assert.*;
1:3ed52ef: 
1:3ed52ef: /**
1:3ed52ef:  * Holds broker unit tests of the replicated leveldb store.
1:3ed52ef:  */
1:3ed52ef: public class ReplicatedLevelDBBrokerTest extends ZooKeeperTestSupport {
1:3ed52ef: 
1:5ebe71c:     protected static final Logger LOG = LoggerFactory.getLogger(ReplicatedLevelDBBrokerTest.class);
1:3ed52ef:     final SynchronousQueue<BrokerService> masterQueue = new SynchronousQueue<BrokerService>();
1:3ed52ef:     ArrayList<BrokerService> brokers = new ArrayList<BrokerService>();
1:3ed52ef: 
1:3ed52ef:     /**
1:3ed52ef:      * Tries to replicate the problem reported at:
1:3ed52ef:      * https://issues.apache.org/jira/browse/AMQ-4837
1:3ed52ef:      */
1:05f6cd6:     @Ignore("https://issues.apache.org/jira/browse/AMQ-5512")
1:3ed52ef:     @Test(timeout = 1000*60*10)
1:24d5490:     public void testAMQ4837viaJMS() throws Throwable {
1:24d5490:         testAMQ4837(false);
1:24d5490:     }
1:3ed52ef: 
1:24d5490:   /**
1:24d5490:      * Tries to replicate the problem reported at:
1:24d5490:      * https://issues.apache.org/jira/browse/AMQ-4837
1:24d5490:      */
1:05f6cd6:    @Ignore("https://issues.apache.org/jira/browse/AMQ-5512")
1:24d5490:     @Test(timeout = 1000*60*10)
1:24d5490:     public void testAMQ4837viaJMX() throws Throwable {
1:24d5490:         for (int i = 0; i < 2; i++) {
1:5ebe71c:             LOG.info("testAMQ4837viaJMX - Iteration: " + i);
1:24d5490:             resetDataDirs();
1:24d5490:             testAMQ4837(true);
1:24d5490:             stopBrokers();
1:24d5490:         }
1:24d5490:     }
1:24d5490: 
1:24d5490:     @Before
1:24d5490:     public void resetDataDirs() throws IOException {
1:24d5490:         deleteDirectory("node-1");
1:24d5490:         deleteDirectory("node-2");
1:24d5490:         deleteDirectory("node-3");
1:24d5490:     }
1:24d5490: 
1:ed8e4ea:     public interface Client{
1:ed8e4ea:         public void execute(Connection connection) throws Exception;
1:ed8e4ea:     }
1:ed8e4ea: 
1:ed8e4ea:     protected Thread startFailoverClient(String name, final Client client) throws IOException, URISyntaxException {
1:ed8e4ea:         String url = "failover://(tcp://localhost:"+port+")?maxReconnectDelay=500&nested.wireFormat.maxInactivityDuration=1000";
1:ed8e4ea:         final ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(url);
1:ed8e4ea:         Thread rc = new Thread(name) {
1:ed8e4ea:             @Override
1:ed8e4ea:             public void run() {
1:ed8e4ea:                 Connection connection = null;
1:ed8e4ea:                 try {
1:ed8e4ea:                     connection = factory.createConnection();
1:ed8e4ea:                     client.execute(connection);
1:ed8e4ea:                 } catch (Throwable e) {
1:ed8e4ea:                     e.printStackTrace();
1:ed8e4ea:                 } finally {
1:ed8e4ea:                     try {
1:ed8e4ea:                         connection.close();
1:ed8e4ea:                     } catch (JMSException e) {
1:ed8e4ea:                     }
1:ed8e4ea:                 }
1:ed8e4ea:             }
1:ed8e4ea:         };
1:ed8e4ea:         rc.start();
1:ed8e4ea:         return rc;
1:ed8e4ea:     }
1:ed8e4ea: 
1:ed8e4ea:     @Test
1:ed8e4ea:     @Ignore
1:ed8e4ea:     public void testReplicationQuorumLoss() throws Throwable {
1:ed8e4ea: 
1:ed8e4ea:         System.out.println("======================================");
1:ed8e4ea:         System.out.println(" Start 2 ActiveMQ nodes.");
1:ed8e4ea:         System.out.println("======================================");
1:ed8e4ea:         startBrokerAsync(createBrokerNode("node-1", port));
1:ed8e4ea:         startBrokerAsync(createBrokerNode("node-2", port));
1:ed8e4ea:         BrokerService master = waitForNextMaster();
1:ed8e4ea:         System.out.println("======================================");
1:ed8e4ea:         System.out.println(" Start the producer and consumer");
1:ed8e4ea:         System.out.println("======================================");
1:ed8e4ea: 
1:ed8e4ea:         final AtomicBoolean stopClients = new AtomicBoolean(false);
1:ed8e4ea:         final ArrayBlockingQueue<String> errors = new ArrayBlockingQueue<String>(100);
1:ed8e4ea:         final AtomicLong receivedCounter = new AtomicLong();
1:ed8e4ea:         final AtomicLong sentCounter = new AtomicLong();
1:ed8e4ea:         Thread producer = startFailoverClient("producer", new Client() {
1:ed8e4ea:             @Override
1:ed8e4ea:             public void execute(Connection connection) throws Exception {
1:ed8e4ea:                 Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:ed8e4ea:                 MessageProducer producer = session.createProducer(session.createQueue("test"));
1:ed8e4ea:                 long actual = 0;
1:ed8e4ea:                 while(!stopClients.get()) {
1:ed8e4ea:                     TextMessage msg = session.createTextMessage("Hello World");
1:ed8e4ea:                     msg.setLongProperty("id", actual++);
1:ed8e4ea:                     producer.send(msg);
1:ed8e4ea:                     sentCounter.incrementAndGet();
1:ed8e4ea:                 }
1:ed8e4ea:             }
1:ed8e4ea:         });
1:ed8e4ea: 
1:ed8e4ea:         Thread consumer = startFailoverClient("consumer", new Client() {
1:ed8e4ea:             @Override
1:ed8e4ea:             public void execute(Connection connection) throws Exception {
1:ed8e4ea:                 connection.start();
1:ed8e4ea:                 Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:ed8e4ea:                 MessageConsumer consumer = session.createConsumer(session.createQueue("test"));
1:ed8e4ea:                 long expected = 0;
1:ed8e4ea:                 while(!stopClients.get()) {
1:ed8e4ea:                     Message msg = consumer.receive(200);
1:ed8e4ea:                     if( msg!=null ) {
1:ed8e4ea:                         long actual = msg.getLongProperty("id");
1:ed8e4ea:                         if( actual != expected ) {
1:ed8e4ea:                             errors.offer("Received got unexpected msg id: "+actual+", expected: "+expected);
1:ed8e4ea:                         }
1:ed8e4ea:                         msg.acknowledge();
1:ed8e4ea:                         expected = actual+1;
1:ed8e4ea:                         receivedCounter.incrementAndGet();
1:ed8e4ea:                     }
1:ed8e4ea:                 }
1:ed8e4ea:             }
1:ed8e4ea:         });
1:ed8e4ea: 
1:ed8e4ea:         try {
1:ed8e4ea:             assertCounterMakesProgress(sentCounter, 10, TimeUnit.SECONDS);
1:ed8e4ea:             assertCounterMakesProgress(receivedCounter, 5, TimeUnit.SECONDS);
1:ed8e4ea:             assertNull(errors.poll());
1:ed8e4ea: 
1:ed8e4ea:             System.out.println("======================================");
1:ed8e4ea:             System.out.println(" Master should stop once the quorum is lost.");
1:ed8e4ea:             System.out.println("======================================");
1:ed8e4ea:             ArrayList<BrokerService> stopped = stopSlaves();// stopping the slaves should kill the quorum.
1:ed8e4ea:             assertStopsWithin(master, 10, TimeUnit.SECONDS);
1:ed8e4ea:             assertNull(errors.poll()); // clients should not see an error since they are failover clients.
1:ed8e4ea:             stopped.add(master);
1:ed8e4ea: 
1:ed8e4ea:             System.out.println("======================================");
1:ed8e4ea:             System.out.println(" Restart the slave. Clients should make progress again..");
1:ed8e4ea:             System.out.println("======================================");
1:ed8e4ea:             startBrokersAsync(createBrokerNodes(stopped));
1:ed8e4ea:             assertCounterMakesProgress(sentCounter, 10, TimeUnit.SECONDS);
1:ed8e4ea:             assertCounterMakesProgress(receivedCounter, 5, TimeUnit.SECONDS);
1:ed8e4ea:             assertNull(errors.poll());
1:ed8e4ea:         } catch (Throwable e) {
1:ed8e4ea:             e.printStackTrace();
1:ed8e4ea:             throw e;
1:ed8e4ea:         } finally {
1:ed8e4ea:             // Wait for the clients to stop..
1:ed8e4ea:             stopClients.set(true);
1:ed8e4ea:             producer.join();
1:ed8e4ea:             consumer.join();
1:ed8e4ea:         }
1:ed8e4ea:     }
1:ed8e4ea: 
1:ed8e4ea:     protected void startBrokersAsync(ArrayList<BrokerService> brokers) {
1:ed8e4ea:         for (BrokerService broker : brokers) {
1:ed8e4ea:             startBrokerAsync(broker);
1:ed8e4ea:         }
1:ed8e4ea:     }
1:ed8e4ea: 
1:ed8e4ea:     protected ArrayList<BrokerService> createBrokerNodes(ArrayList<BrokerService> brokers) throws Exception {
1:ed8e4ea:         ArrayList<BrokerService> rc = new ArrayList<BrokerService>();
1:ed8e4ea:         for (BrokerService b : brokers) {
1:ed8e4ea:             rc.add(createBrokerNode(b.getBrokerName(), connectPort(b)));
1:ed8e4ea:         }
1:ed8e4ea:         return rc;
1:ed8e4ea:     }
1:ed8e4ea: 
1:ed8e4ea:     protected ArrayList<BrokerService> stopSlaves() throws Exception {
1:ed8e4ea:         ArrayList<BrokerService> rc = new ArrayList<BrokerService>();
1:ed8e4ea:         for (BrokerService broker : brokers) {
1:ed8e4ea:             if( broker.isSlave() ) {
1:ed8e4ea:                 System.out.println("Stopping slave: "+broker.getBrokerName());
1:ed8e4ea:                 broker.stop();
1:ed8e4ea:                 broker.waitUntilStopped();
1:ed8e4ea:                 rc.add(broker);
1:ed8e4ea:             }
1:ed8e4ea:         }
1:ed8e4ea:         brokers.removeAll(rc);
1:ed8e4ea:         return rc;
1:ed8e4ea:     }
1:ed8e4ea: 
1:ed8e4ea:     protected void assertStopsWithin(final BrokerService master, int timeout, TimeUnit unit) throws InterruptedException {
1:ed8e4ea:         within(timeout, unit, new Task(){
1:ed8e4ea:             @Override
1:ed8e4ea:             public void run() throws Exception {
1:ed8e4ea:                 assertTrue(master.isStopped());
1:ed8e4ea:             }
1:ed8e4ea:         });
1:ed8e4ea:     }
1:ed8e4ea: 
1:ed8e4ea:     protected void assertCounterMakesProgress(final AtomicLong counter, int timeout, TimeUnit unit) throws InterruptedException {
1:ed8e4ea:         final long initial = counter.get();
1:ed8e4ea:         within(timeout, unit, new Task(){
1:ed8e4ea:             public void run() throws Exception {
1:ed8e4ea:                 assertTrue(initial < counter.get());
1:ed8e4ea:             }
1:ed8e4ea:         });
1:ed8e4ea:     }
1:24d5490: 
1:24d5490:     public void testAMQ4837(boolean jmx) throws Throwable {
1:24d5490: 
1:24d5490:         try {
1:24d5490:             System.out.println("======================================");
1:24d5490:             System.out.println("1.	Start 3 activemq nodes.");
1:24d5490:             System.out.println("======================================");
1:24d5490:             startBrokerAsync(createBrokerNode("node-1"));
1:24d5490:             startBrokerAsync(createBrokerNode("node-2"));
1:24d5490:             startBrokerAsync(createBrokerNode("node-3"));
1:24d5490: 
1:24d5490:             BrokerService master = waitForNextMaster();
1:24d5490:             System.out.println("======================================");
1:24d5490:             System.out.println("2.	Push a message to the master and browse the queue");
1:24d5490:             System.out.println("======================================");
1:24d5490:             sendMessage(master, pad("Hello World #1", 1024));
1:24d5490:             assertEquals(1, browseMessages(master, jmx).size());
1:24d5490: 
1:24d5490:             System.out.println("======================================");
1:24d5490:             System.out.println("3.	Stop master node");
1:24d5490:             System.out.println("======================================");
1:24d5490:             stop(master);
1:24d5490:             BrokerService prevMaster = master;
1:24d5490:             master = waitForNextMaster();
1:24d5490: 
1:24d5490:             System.out.println("======================================");
1:24d5490:             System.out.println("4.	Push a message to the new master and browse the queue. Message summary and queue content ok.");
1:24d5490:             System.out.println("======================================");
1:24d5490:             assertEquals(1, browseMessages(master, jmx).size());
1:24d5490:             sendMessage(master, pad("Hello World #2", 1024));
1:24d5490:             assertEquals(2, browseMessages(master, jmx).size());
1:24d5490: 
1:24d5490:             System.out.println("======================================");
1:24d5490:             System.out.println("5.	Restart the stopped node & 6. stop current master");
1:24d5490:             System.out.println("======================================");
1:5315389:             brokers.remove(prevMaster);
1:24d5490:             prevMaster = createBrokerNode(prevMaster.getBrokerName());
1:24d5490:             startBrokerAsync(prevMaster);
1:24d5490:             stop(master);
1:24d5490: 
1:24d5490:             master = waitForNextMaster();
1:24d5490:             System.out.println("======================================");
1:24d5490:             System.out.println("7.	Browse the queue on new master");
1:24d5490:             System.out.println("======================================");
1:24d5490:             assertEquals(2, browseMessages(master, jmx).size());
1:24d5490:         } catch (Throwable e) {
1:24d5490:             e.printStackTrace();
1:24d5490:             throw e;
1:24d5490:         }
1:24d5490: 
1:24d5490:     }
1:24d5490: 
1:24d5490:     private void stop(BrokerService master) throws Exception {
1:24d5490:         System.out.println("Stopping "+master.getBrokerName());
1:24d5490:         master.stop();
1:24d5490:         master.waitUntilStopped();
1:24d5490:     }
1:24d5490: 
1:24d5490:     private BrokerService waitForNextMaster() throws InterruptedException {
1:3ed52ef:         System.out.println("Wait for master to start up...");
1:3ed52ef:         BrokerService master = masterQueue.poll(60, TimeUnit.SECONDS);
3:3ed52ef:         assertNotNull("Master elected", master);
1:24d5490:         assertFalse(master.isSlave());
1:24d5490:         assertNull("Only one master elected at a time..", masterQueue.peek());
1:24d5490:         System.out.println("Master started: " + master.getBrokerName());
1:24d5490:         return master;
1:24d5490:     }
1:3ed52ef: 
1:24d5490:     private String pad(String value, int size) {
1:24d5490:         while( value.length() < size ) {
1:24d5490:             value += " ";
1:24d5490:         }
1:24d5490:         return value;
1:24d5490:     }
1:3ed52ef: 
1:3ed52ef:     private void startBrokerAsync(BrokerService b) {
1:3ed52ef:         final BrokerService broker = b;
1:3ed52ef:         new Thread("Starting broker node: "+b.getBrokerName()){
1:3ed52ef:             @Override
1:3ed52ef:             public void run() {
1:24d5490:                 try {
1:3ed52ef:                     broker.start();
1:3ed52ef:                     broker.waitUntilStarted();
1:3ed52ef:                     masterQueue.put(broker);
1:3ed52ef:                 } catch (Exception e) {
1:3ed52ef:                     e.printStackTrace();
1:24d5490:                 }
3:3ed52ef:             }
1:3ed52ef:         }.start();
1:3ed52ef:     }
1:3ed52ef: 
1:3ed52ef:     private void sendMessage(BrokerService brokerService, String body) throws Exception {
2:3ed52ef:         TransportConnector connector = brokerService.getTransportConnectors().get(0);
2:3ed52ef:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(connector.getConnectUri());
1:3ed52ef:         Connection connection = factory.createConnection();
2:3ed52ef:         try {
1:3ed52ef:             connection.start();
1:3ed52ef:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3ed52ef:             MessageProducer producer = session.createProducer(session.createQueue("FOO"));
1:3ed52ef:             producer.send(session.createTextMessage(body));
1:3ed52ef:         } finally {
1:3ed52ef:             connection.close();
1:3ed52ef:         }
1:3ed52ef:     }
1:24d5490:     private ArrayList<String> browseMessages(BrokerService brokerService, boolean jmx) throws Exception {
1:24d5490:         if( jmx ) {
1:24d5490:             return browseMessagesViaJMX(brokerService);
1:24d5490:         } else {
1:24d5490:             return browseMessagesViaJMS(brokerService);
1:24d5490:         }
1:24d5490:     }
1:3ed52ef: 
1:24d5490:     private ArrayList<String> browseMessagesViaJMX(BrokerService brokerService) throws Exception {
1:24d5490:         ArrayList<String> rc = new ArrayList<String>();
1:24d5490:         ObjectName on = new ObjectName("org.apache.activemq:type=Broker,brokerName="+brokerService.getBrokerName()+",destinationType=Queue,destinationName=FOO");
1:24d5490:         CompositeData[] browse = (CompositeData[]) ManagementFactory.getPlatformMBeanServer().invoke(on, "browse", null, null);
1:24d5490:         for (CompositeData cd : browse) {
1:24d5490:             rc.add(cd.get("Text").toString()) ;
1:24d5490:         }
1:24d5490:         return rc;
1:24d5490:     }
1:24d5490: 
1:24d5490:     private ArrayList<String> browseMessagesViaJMS(BrokerService brokerService) throws Exception {
1:3ed52ef:         ArrayList<String> rc = new ArrayList<String>();
1:ed8e4ea:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:"+ connectPort(brokerService));
1:3ed52ef:         Connection connection = factory.createConnection();
1:3ed52ef:         try {
1:3ed52ef:             connection.start();
1:3ed52ef:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3ed52ef:             QueueBrowser browser = session.createBrowser(session.createQueue("FOO"));
1:3ed52ef:             Enumeration enumeration = browser.getEnumeration();
1:3ed52ef:             while (enumeration.hasMoreElements()) {
1:3ed52ef:                 TextMessage textMessage = (TextMessage) enumeration.nextElement();
1:3ed52ef:                 rc.add(textMessage.getText());
1:3ed52ef:             }
1:3ed52ef:         } finally {
1:3ed52ef:             connection.close();
1:3ed52ef:         }
1:3ed52ef:         return rc;
1:3ed52ef:     }
1:3ed52ef: 
1:ed8e4ea:     private int connectPort(BrokerService brokerService) throws IOException, URISyntaxException {
1:ed8e4ea:         TransportConnector connector = brokerService.getTransportConnectors().get(0);
1:ed8e4ea:         return connector.getConnectUri().getPort();
1:ed8e4ea:     }
1:ed8e4ea: 
1:ed8e4ea:     int port;
1:ed8e4ea:     @Before
1:ed8e4ea:     public void findFreePort() throws Exception {
1:ed8e4ea:         ServerSocket socket = new ServerSocket(0);
1:ed8e4ea:         port = socket.getLocalPort();
1:ed8e4ea:         socket.close();
1:ed8e4ea:     }
1:ed8e4ea: 
1:3ed52ef:     @After
1:24d5490:     public void stopBrokers() throws Exception {
1:3ed52ef:         for (BrokerService broker : brokers) {
1:3ed52ef:             try {
1:24d5490:                 stop(broker);
1:3ed52ef:             } catch (Exception e) {
1:3ed52ef:             }
1:3ed52ef:         }
1:24d5490:         brokers.clear();
1:5315389:         resetDataDirs();
1:3ed52ef:     }
1:3ed52ef: 
1:3ed52ef:     private BrokerService createBrokerNode(String id) throws Exception {
1:ed8e4ea:         return createBrokerNode(id, 0);
1:ed8e4ea:     }
1:ed8e4ea: 
1:ed8e4ea:     private BrokerService createBrokerNode(String id, int port) throws Exception {
1:3ed52ef:         BrokerService bs = new BrokerService();
1:3ed52ef:         bs.getManagementContext().setCreateConnector(false);
1:3ed52ef:         brokers.add(bs);
1:3ed52ef:         bs.setBrokerName(id);
1:3ed52ef:         bs.setPersistenceAdapter(createStoreNode(id));
1:ed8e4ea:         TransportConnector connector = new TransportConnector();
1:ed8e4ea:         connector.setUri(new URI("tcp://0.0.0.0:" + port));
1:ed8e4ea:         bs.addConnector(connector);
1:3ed52ef:         return bs;
1:3ed52ef:     }
1:3ed52ef: 
1:3ed52ef: 
1:3ed52ef:     private ElectingLevelDBStore createStoreNode(String id) {
1:3ed52ef: 
1:3ed52ef:         // This little hack is in here because we give each of the 3 brokers
1:3ed52ef:         // different broker names so they can show up in JMX correctly,
1:3ed52ef:         // but the store needs to be configured with the same broker name
1:3ed52ef:         // so that they can find each other in ZK properly.
1:3ed52ef:         ElectingLevelDBStore store = new ElectingLevelDBStore() {
1:3ed52ef:             @Override
1:3ed52ef:             public void start() throws Exception {
1:3ed52ef:                 this.setBrokerName("localhost");
1:3ed52ef:                 super.start();
1:3ed52ef:             }
1:3ed52ef:         };
1:3ed52ef:         store.setDirectory(new File(data_dir(), id));
1:24d5490:         store.setContainer(id);
1:3ed52ef:         store.setReplicas(3);
1:5616d39:         store.setSync("quorum_disk");
1:3ed52ef:         store.setZkAddress("localhost:" + connector.getLocalPort());
1:4d8489b:         store.setZkSessionTimeout("15s");
1:3ed52ef:         store.setHostname("localhost");
1:3ed52ef:         store.setBind("tcp://0.0.0.0:0");
1:3ed52ef:         return store;
1:3ed52ef:     }
1:3ed52ef: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:05f6cd6
/////////////////////////////////////////////////////////////////////////
1:     @Ignore("https://issues.apache.org/jira/browse/AMQ-5512")
/////////////////////////////////////////////////////////////////////////
1:    @Ignore("https://issues.apache.org/jira/browse/AMQ-5512")
commit:5616d39
/////////////////////////////////////////////////////////////////////////
1:         store.setSync("quorum_disk");
commit:4d8489b
/////////////////////////////////////////////////////////////////////////
1:         store.setZkSessionTimeout("15s");
commit:5ebe71c
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
/////////////////////////////////////////////////////////////////////////
1:     protected static final Logger LOG = LoggerFactory.getLogger(ReplicatedLevelDBBrokerTest.class);
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("testAMQ4837viaJMX - Iteration: " + i);
/////////////////////////////////////////////////////////////////////////
0:         store.setZkSessionTmeout("15s");
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:5315389
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             brokers.remove(prevMaster);
/////////////////////////////////////////////////////////////////////////
1:         resetDataDirs();
author:Hiram Chirino
-------------------------------------------------------------------------------
commit:ed8e4ea
/////////////////////////////////////////////////////////////////////////
1: import org.junit.Ignore;
/////////////////////////////////////////////////////////////////////////
1: import java.net.ServerSocket;
1: import java.net.URI;
1: import java.net.URISyntaxException;
1: import java.util.concurrent.ArrayBlockingQueue;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: import java.util.concurrent.atomic.AtomicLong;
1: 
/////////////////////////////////////////////////////////////////////////
1:     public interface Client{
1:         public void execute(Connection connection) throws Exception;
1:     }
1: 
1:     protected Thread startFailoverClient(String name, final Client client) throws IOException, URISyntaxException {
1:         String url = "failover://(tcp://localhost:"+port+")?maxReconnectDelay=500&nested.wireFormat.maxInactivityDuration=1000";
1:         final ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(url);
1:         Thread rc = new Thread(name) {
1:             @Override
1:             public void run() {
1:                 Connection connection = null;
1:                 try {
1:                     connection = factory.createConnection();
1:                     client.execute(connection);
1:                 } catch (Throwable e) {
1:                     e.printStackTrace();
1:                 } finally {
1:                     try {
1:                         connection.close();
1:                     } catch (JMSException e) {
1:                     }
1:                 }
1:             }
1:         };
1:         rc.start();
1:         return rc;
1:     }
1: 
1:     @Test
1:     @Ignore
1:     public void testReplicationQuorumLoss() throws Throwable {
1: 
1:         System.out.println("======================================");
1:         System.out.println(" Start 2 ActiveMQ nodes.");
1:         System.out.println("======================================");
1:         startBrokerAsync(createBrokerNode("node-1", port));
1:         startBrokerAsync(createBrokerNode("node-2", port));
1:         BrokerService master = waitForNextMaster();
1:         System.out.println("======================================");
1:         System.out.println(" Start the producer and consumer");
1:         System.out.println("======================================");
1: 
1:         final AtomicBoolean stopClients = new AtomicBoolean(false);
1:         final ArrayBlockingQueue<String> errors = new ArrayBlockingQueue<String>(100);
1:         final AtomicLong receivedCounter = new AtomicLong();
1:         final AtomicLong sentCounter = new AtomicLong();
1:         Thread producer = startFailoverClient("producer", new Client() {
1:             @Override
1:             public void execute(Connection connection) throws Exception {
1:                 Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:                 MessageProducer producer = session.createProducer(session.createQueue("test"));
1:                 long actual = 0;
1:                 while(!stopClients.get()) {
1:                     TextMessage msg = session.createTextMessage("Hello World");
1:                     msg.setLongProperty("id", actual++);
1:                     producer.send(msg);
1:                     sentCounter.incrementAndGet();
1:                 }
1:             }
1:         });
1: 
1:         Thread consumer = startFailoverClient("consumer", new Client() {
1:             @Override
1:             public void execute(Connection connection) throws Exception {
1:                 connection.start();
1:                 Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:                 MessageConsumer consumer = session.createConsumer(session.createQueue("test"));
1:                 long expected = 0;
1:                 while(!stopClients.get()) {
1:                     Message msg = consumer.receive(200);
1:                     if( msg!=null ) {
1:                         long actual = msg.getLongProperty("id");
1:                         if( actual != expected ) {
1:                             errors.offer("Received got unexpected msg id: "+actual+", expected: "+expected);
1:                         }
1:                         msg.acknowledge();
1:                         expected = actual+1;
1:                         receivedCounter.incrementAndGet();
1:                     }
1:                 }
1:             }
1:         });
1: 
1:         try {
1:             assertCounterMakesProgress(sentCounter, 10, TimeUnit.SECONDS);
1:             assertCounterMakesProgress(receivedCounter, 5, TimeUnit.SECONDS);
1:             assertNull(errors.poll());
1: 
1:             System.out.println("======================================");
1:             System.out.println(" Master should stop once the quorum is lost.");
1:             System.out.println("======================================");
1:             ArrayList<BrokerService> stopped = stopSlaves();// stopping the slaves should kill the quorum.
1:             assertStopsWithin(master, 10, TimeUnit.SECONDS);
1:             assertNull(errors.poll()); // clients should not see an error since they are failover clients.
1:             stopped.add(master);
1: 
1:             System.out.println("======================================");
1:             System.out.println(" Restart the slave. Clients should make progress again..");
1:             System.out.println("======================================");
1:             startBrokersAsync(createBrokerNodes(stopped));
1:             assertCounterMakesProgress(sentCounter, 10, TimeUnit.SECONDS);
1:             assertCounterMakesProgress(receivedCounter, 5, TimeUnit.SECONDS);
1:             assertNull(errors.poll());
1:         } catch (Throwable e) {
1:             e.printStackTrace();
1:             throw e;
1:         } finally {
1:             // Wait for the clients to stop..
1:             stopClients.set(true);
1:             producer.join();
1:             consumer.join();
1:         }
1:     }
1: 
1:     protected void startBrokersAsync(ArrayList<BrokerService> brokers) {
1:         for (BrokerService broker : brokers) {
1:             startBrokerAsync(broker);
1:         }
1:     }
1: 
1:     protected ArrayList<BrokerService> createBrokerNodes(ArrayList<BrokerService> brokers) throws Exception {
1:         ArrayList<BrokerService> rc = new ArrayList<BrokerService>();
1:         for (BrokerService b : brokers) {
1:             rc.add(createBrokerNode(b.getBrokerName(), connectPort(b)));
1:         }
1:         return rc;
1:     }
1: 
1:     protected ArrayList<BrokerService> stopSlaves() throws Exception {
1:         ArrayList<BrokerService> rc = new ArrayList<BrokerService>();
1:         for (BrokerService broker : brokers) {
1:             if( broker.isSlave() ) {
1:                 System.out.println("Stopping slave: "+broker.getBrokerName());
1:                 broker.stop();
1:                 broker.waitUntilStopped();
1:                 rc.add(broker);
1:             }
1:         }
1:         brokers.removeAll(rc);
1:         return rc;
1:     }
1: 
1:     protected void assertStopsWithin(final BrokerService master, int timeout, TimeUnit unit) throws InterruptedException {
1:         within(timeout, unit, new Task(){
1:             @Override
1:             public void run() throws Exception {
1:                 assertTrue(master.isStopped());
1:             }
1:         });
1:     }
1: 
1:     protected void assertCounterMakesProgress(final AtomicLong counter, int timeout, TimeUnit unit) throws InterruptedException {
1:         final long initial = counter.get();
1:         within(timeout, unit, new Task(){
1:             public void run() throws Exception {
1:                 assertTrue(initial < counter.get());
1:             }
1:         });
1:     }
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:"+ connectPort(brokerService));
/////////////////////////////////////////////////////////////////////////
1:     private int connectPort(BrokerService brokerService) throws IOException, URISyntaxException {
1:         TransportConnector connector = brokerService.getTransportConnectors().get(0);
1:         return connector.getConnectUri().getPort();
1:     }
1: 
1:     int port;
1:     @Before
1:     public void findFreePort() throws Exception {
1:         ServerSocket socket = new ServerSocket(0);
1:         port = socket.getLocalPort();
1:         socket.close();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         return createBrokerNode(id, 0);
1:     }
1: 
1:     private BrokerService createBrokerNode(String id, int port) throws Exception {
1:         TransportConnector connector = new TransportConnector();
1:         connector.setUri(new URI("tcp://0.0.0.0:" + port));
1:         bs.addConnector(connector);
commit:24d5490
/////////////////////////////////////////////////////////////////////////
1: import org.junit.Before;
1: import javax.management.ObjectName;
1: import javax.management.openmbean.CompositeData;
1: import java.io.IOException;
1: import java.lang.management.ManagementFactory;
1: import org.apache.commons.io.FileUtils;
1: import static org.junit.Assert.*;
/////////////////////////////////////////////////////////////////////////
1:     public void testAMQ4837viaJMS() throws Throwable {
1:         testAMQ4837(false);
1:     }
1:   /**
1:      * Tries to replicate the problem reported at:
1:      * https://issues.apache.org/jira/browse/AMQ-4837
1:      */
1:     @Test(timeout = 1000*60*10)
1:     public void testAMQ4837viaJMX() throws Throwable {
1:         for (int i = 0; i < 2; i++) {
1:             resetDataDirs();
1:             testAMQ4837(true);
1:             stopBrokers();
1:         }
1:     }
1:     @Before
1:     public void resetDataDirs() throws IOException {
1:         deleteDirectory("node-1");
1:         deleteDirectory("node-2");
1:         deleteDirectory("node-3");
1:     }
1: 
0:     protected void deleteDirectory(String s) throws IOException {
1:         try {
0:             FileUtils.deleteDirectory(new File(data_dir(), s));
0:         } catch (IOException e) {
1:         }
1:     }
1: 
1: 
1:     public void testAMQ4837(boolean jmx) throws Throwable {
1: 
1:         try {
1:             System.out.println("======================================");
1:             System.out.println("1.	Start 3 activemq nodes.");
1:             System.out.println("======================================");
1:             startBrokerAsync(createBrokerNode("node-1"));
1:             startBrokerAsync(createBrokerNode("node-2"));
1:             startBrokerAsync(createBrokerNode("node-3"));
1: 
1:             BrokerService master = waitForNextMaster();
1:             System.out.println("======================================");
1:             System.out.println("2.	Push a message to the master and browse the queue");
1:             System.out.println("======================================");
1:             sendMessage(master, pad("Hello World #1", 1024));
1:             assertEquals(1, browseMessages(master, jmx).size());
1: 
1:             System.out.println("======================================");
1:             System.out.println("3.	Stop master node");
1:             System.out.println("======================================");
1:             stop(master);
1:             BrokerService prevMaster = master;
1:             master = waitForNextMaster();
1: 
1:             System.out.println("======================================");
1:             System.out.println("4.	Push a message to the new master and browse the queue. Message summary and queue content ok.");
1:             System.out.println("======================================");
1:             assertEquals(1, browseMessages(master, jmx).size());
1:             sendMessage(master, pad("Hello World #2", 1024));
1:             assertEquals(2, browseMessages(master, jmx).size());
1: 
1:             System.out.println("======================================");
1:             System.out.println("5.	Restart the stopped node & 6. stop current master");
1:             System.out.println("======================================");
1:             prevMaster = createBrokerNode(prevMaster.getBrokerName());
1:             startBrokerAsync(prevMaster);
1:             stop(master);
1: 
1:             master = waitForNextMaster();
1:             System.out.println("======================================");
1:             System.out.println("7.	Browse the queue on new master");
1:             System.out.println("======================================");
1:             assertEquals(2, browseMessages(master, jmx).size());
1:         } catch (Throwable e) {
1:             e.printStackTrace();
1:             throw e;
1:         }
1: 
1:     }
1: 
1:     private void stop(BrokerService master) throws Exception {
1:         System.out.println("Stopping "+master.getBrokerName());
1:         master.stop();
1:         master.waitUntilStopped();
1:     }
1: 
1:     private BrokerService waitForNextMaster() throws InterruptedException {
1:         assertFalse(master.isSlave());
1:         assertNull("Only one master elected at a time..", masterQueue.peek());
1:         System.out.println("Master started: " + master.getBrokerName());
1:         return master;
1:     }
1:     private String pad(String value, int size) {
1:         while( value.length() < size ) {
1:             value += " ";
1:         }
1:         return value;
/////////////////////////////////////////////////////////////////////////
1:     private ArrayList<String> browseMessages(BrokerService brokerService, boolean jmx) throws Exception {
1:         if( jmx ) {
1:             return browseMessagesViaJMX(brokerService);
1:         } else {
1:             return browseMessagesViaJMS(brokerService);
1:         }
1:     }
1:     private ArrayList<String> browseMessagesViaJMX(BrokerService brokerService) throws Exception {
1:         ArrayList<String> rc = new ArrayList<String>();
1:         ObjectName on = new ObjectName("org.apache.activemq:type=Broker,brokerName="+brokerService.getBrokerName()+",destinationType=Queue,destinationName=FOO");
1:         CompositeData[] browse = (CompositeData[]) ManagementFactory.getPlatformMBeanServer().invoke(on, "browse", null, null);
1:         for (CompositeData cd : browse) {
1:             rc.add(cd.get("Text").toString()) ;
1:         }
1:         return rc;
1:     }
1: 
1:     private ArrayList<String> browseMessagesViaJMS(BrokerService brokerService) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void stopBrokers() throws Exception {
1:                 stop(broker);
1:         brokers.clear();
/////////////////////////////////////////////////////////////////////////
1:         store.setContainer(id);
commit:3ed52ef
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.leveldb.test;
1: 
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.TransportConnector;
1: import org.apache.activemq.leveldb.replicated.ElectingLevelDBStore;
1: import org.junit.After;
1: import org.junit.Test;
1: 
1: import javax.jms.*;
1: import java.io.File;
1: import java.util.ArrayList;
1: import java.util.Enumeration;
1: import java.util.concurrent.SynchronousQueue;
1: import java.util.concurrent.TimeUnit;
1: 
0: import static org.junit.Assert.assertEquals;
0: import static org.junit.Assert.assertNotNull;
1: 
1: /**
1:  * Holds broker unit tests of the replicated leveldb store.
1:  */
1: public class ReplicatedLevelDBBrokerTest extends ZooKeeperTestSupport {
1: 
1:     final SynchronousQueue<BrokerService> masterQueue = new SynchronousQueue<BrokerService>();
1:     ArrayList<BrokerService> brokers = new ArrayList<BrokerService>();
1: 
1:     /**
1:      * Tries to replicate the problem reported at:
1:      * https://issues.apache.org/jira/browse/AMQ-4837
1:      */
1:     @Test(timeout = 1000*60*10)
0:     public void testAMQ4837() throws Exception {
1: 
0:         // 1.	Start 3 activemq nodes.
0:         startBrokerAsync(createBrokerNode("node-1"));
0:         startBrokerAsync(createBrokerNode("node-2"));
0:         startBrokerAsync(createBrokerNode("node-3"));
1: 
0:         // 2.	Push a message to the master and browse the queue
1:         System.out.println("Wait for master to start up...");
1:         BrokerService master = masterQueue.poll(60, TimeUnit.SECONDS);
1:         assertNotNull("Master elected", master);
0:         sendMessage(master, "Hello World #1");
0:         assertEquals(1, browseMessages(master).size());
1: 
0:         // 3.	Stop master node
0:         System.out.println("Stopping master...");
0:         master.stop();
0:         master.waitUntilStopped();
0:         BrokerService prevMaster = master;
1: 
0:         // 4.	Push a message to the new master (Node2) and browse the queue using the web UI. Message summary and queue content ok.
0:         System.out.println("Wait for new master to start up...");
0:         master = masterQueue.poll(60, TimeUnit.SECONDS);
1:         assertNotNull("Master elected", master);
0:         sendMessage(master, "Hello World #2");
0:         assertEquals(2, browseMessages(master).size());
1: 
0:         // 5.	Start Node1
0:         System.out.println("Starting previous master...");
0:         prevMaster = createBrokerNode(prevMaster.getBrokerName());
0:         startBrokerAsync(prevMaster);
1: 
0:         // 6.	Stop master node (Node2)
0:         System.out.println("Stopping master...");
0:         master.stop();
0:         master.waitUntilStopped();
1: 
0:         // 7.	Browse the queue using the web UI on new master (Node3). Message summary ok however when clicking on the queue, no message details.
0:         // An error (see below) is logged by the master, which attempts a restart.
0:         System.out.println("Wait for new master to start up...");
0:         master = masterQueue.poll(60, TimeUnit.SECONDS);
1:         assertNotNull("Master elected", master);
0:         assertEquals(2, browseMessages(master).size());
1: 
1:     }
1: 
1:     private void startBrokerAsync(BrokerService b) {
1:         final BrokerService broker = b;
1:         new Thread("Starting broker node: "+b.getBrokerName()){
1:             @Override
1:             public void run() {
1:                 try {
1:                     broker.start();
1:                     broker.waitUntilStarted();
1:                     masterQueue.put(broker);
1:                 } catch (Exception e) {
1:                     e.printStackTrace();
1:                 }
1:             }
1:         }.start();
1:     }
1: 
1:     private void sendMessage(BrokerService brokerService, String body) throws Exception {
1:         TransportConnector connector = brokerService.getTransportConnectors().get(0);
1:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(connector.getConnectUri());
1:         Connection connection = factory.createConnection();
1:         try {
1:             connection.start();
1:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             MessageProducer producer = session.createProducer(session.createQueue("FOO"));
1:             producer.send(session.createTextMessage(body));
1:         } finally {
1:             connection.close();
1:         }
1:     }
1: 
0:     private ArrayList<String> browseMessages(BrokerService brokerService) throws Exception {
1:         ArrayList<String> rc = new ArrayList<String>();
1:         TransportConnector connector = brokerService.getTransportConnectors().get(0);
1:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(connector.getConnectUri());
1:         Connection connection = factory.createConnection();
1:         try {
1:             connection.start();
1:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             QueueBrowser browser = session.createBrowser(session.createQueue("FOO"));
1:             Enumeration enumeration = browser.getEnumeration();
1:             while (enumeration.hasMoreElements()) {
1:                 TextMessage textMessage = (TextMessage) enumeration.nextElement();
1:                 rc.add(textMessage.getText());
1:             }
1:         } finally {
1:             connection.close();
1:         }
1:         return rc;
1:     }
1: 
1:     @After
0:     public void closeBrokers() throws Exception {
1:         for (BrokerService broker : brokers) {
1:             try {
0:                 broker.stop();
0:                 broker.waitUntilStopped();
1:             } catch (Exception e) {
1:             }
1:         }
1:     }
1: 
1:     private BrokerService createBrokerNode(String id) throws Exception {
1:         BrokerService bs = new BrokerService();
1:         bs.getManagementContext().setCreateConnector(false);
1:         brokers.add(bs);
1:         bs.setBrokerName(id);
1:         bs.setPersistenceAdapter(createStoreNode(id));
0:         bs.addConnector("tcp://0.0.0.0:0");
1:         return bs;
1:     }
1: 
1: 
1:     private ElectingLevelDBStore createStoreNode(String id) {
1: 
1:         // This little hack is in here because we give each of the 3 brokers
1:         // different broker names so they can show up in JMX correctly,
1:         // but the store needs to be configured with the same broker name
1:         // so that they can find each other in ZK properly.
1:         ElectingLevelDBStore store = new ElectingLevelDBStore() {
1:             @Override
1:             public void start() throws Exception {
1:                 this.setBrokerName("localhost");
1:                 super.start();
1:             }
1:         };
1:         store.setDirectory(new File(data_dir(), id));
1:         store.setReplicas(3);
1:         store.setZkAddress("localhost:" + connector.getLocalPort());
1:         store.setHostname("localhost");
1:         store.setBind("tcp://0.0.0.0:0");
1:         return store;
1:     }
1: }
============================================================================