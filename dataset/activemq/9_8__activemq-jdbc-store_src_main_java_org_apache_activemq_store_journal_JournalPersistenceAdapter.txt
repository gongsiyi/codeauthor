1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
9:d29ca2a:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:d29ca2a:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.store.journal;
23:d29ca2a: 
1:759fd28: import java.io.File;
1:d29ca2a: import java.io.IOException;
1:d29ca2a: import java.util.ArrayList;
1:b439024: import java.util.HashSet;
1:d29ca2a: import java.util.Iterator;
1:d29ca2a: import java.util.Set;
1:0afb7f9: import java.util.concurrent.Callable;
1:0afb7f9: import java.util.concurrent.ConcurrentHashMap;
1:9ef4259: import java.util.concurrent.ConcurrentMap;
1:0afb7f9: import java.util.concurrent.CountDownLatch;
1:0afb7f9: import java.util.concurrent.FutureTask;
1:0afb7f9: import java.util.concurrent.LinkedBlockingQueue;
1:0afb7f9: import java.util.concurrent.ThreadFactory;
1:0afb7f9: import java.util.concurrent.ThreadPoolExecutor;
1:0afb7f9: import java.util.concurrent.TimeUnit;
1:0afb7f9: import java.util.concurrent.atomic.AtomicBoolean;
1:74846bb: 
1:f451ad0: import org.apache.activeio.journal.InvalidRecordLocationException;
1:f451ad0: import org.apache.activeio.journal.Journal;
1:f451ad0: import org.apache.activeio.journal.JournalEventListener;
1:f451ad0: import org.apache.activeio.journal.RecordLocation;
1:88acb0e: import org.apache.activeio.packet.ByteArrayPacket;
1:f451ad0: import org.apache.activeio.packet.Packet;
1:b9797bc: import org.apache.activemq.broker.BrokerService;
1:b9797bc: import org.apache.activemq.broker.BrokerServiceAware;
1:d29ca2a: import org.apache.activemq.broker.ConnectionContext;
1:74846bb: import org.apache.activemq.broker.scheduler.JobSchedulerStore;
1:d29ca2a: import org.apache.activemq.command.ActiveMQDestination;
1:d29ca2a: import org.apache.activemq.command.ActiveMQQueue;
1:d29ca2a: import org.apache.activemq.command.ActiveMQTopic;
1:d29ca2a: import org.apache.activemq.command.DataStructure;
1:d29ca2a: import org.apache.activemq.command.JournalQueueAck;
1:d29ca2a: import org.apache.activemq.command.JournalTopicAck;
1:d29ca2a: import org.apache.activemq.command.JournalTrace;
1:d29ca2a: import org.apache.activemq.command.JournalTransaction;
1:d29ca2a: import org.apache.activemq.command.Message;
1:d29ca2a: import org.apache.activemq.command.MessageAck;
1:a6a6a70: import org.apache.activemq.command.ProducerId;
1:3b0afd6: import org.apache.activemq.filter.NonCachedMessageEvaluationContext;
1:d29ca2a: import org.apache.activemq.openwire.OpenWireFormat;
1:d29ca2a: import org.apache.activemq.store.MessageStore;
1:d29ca2a: import org.apache.activemq.store.PersistenceAdapter;
1:d29ca2a: import org.apache.activemq.store.TopicMessageStore;
1:d29ca2a: import org.apache.activemq.store.TransactionStore;
1:d29ca2a: import org.apache.activemq.store.jdbc.JDBCPersistenceAdapter;
1:d29ca2a: import org.apache.activemq.store.journal.JournalTransactionStore.Tx;
1:d29ca2a: import org.apache.activemq.store.journal.JournalTransactionStore.TxOperation;
1:d29ca2a: import org.apache.activemq.thread.Scheduler;
1:d29ca2a: import org.apache.activemq.thread.Task;
1:d29ca2a: import org.apache.activemq.thread.TaskRunner;
1:d29ca2a: import org.apache.activemq.thread.TaskRunnerFactory;
1:1a5ad28: import org.apache.activemq.usage.SystemUsage;
1:6d8e2c5: import org.apache.activemq.usage.Usage;
1:6d8e2c5: import org.apache.activemq.usage.UsageListener;
1:88acb0e: import org.apache.activemq.util.ByteSequence;
1:d29ca2a: import org.apache.activemq.util.IOExceptionSupport;
1:6c1676b: import org.apache.activemq.util.ThreadPoolUtils;
1:88acb0e: import org.apache.activemq.wireformat.WireFormat;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:f812e34: 
1:d29ca2a: /**
1:d29ca2a:  * An implementation of {@link PersistenceAdapter} designed for use with a
1:d29ca2a:  * {@link Journal} and then check pointing asynchronously on a timeout with some
1:d29ca2a:  * other long term persistent storage.
1:74846bb:  *
1:68d245f:  * @org.apache.xbean.XBean
1:74846bb:  *
1:d29ca2a:  */
1:b9797bc: public class JournalPersistenceAdapter implements PersistenceAdapter, JournalEventListener, UsageListener, BrokerServiceAware {
1:d29ca2a: 
1:27cbf7b:     private BrokerService brokerService;
1:74846bb: 
1:1a5ad28:     protected Scheduler scheduler;
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(JournalPersistenceAdapter.class);
1:d29ca2a: 
1:d3fb1aa:     private Journal journal;
1:d3fb1aa:     private PersistenceAdapter longTermPersistence;
1:d29ca2a: 
1:6583ef1:     private final WireFormat wireFormat = new OpenWireFormat();
1:d29ca2a: 
1:9ef4259:     private final ConcurrentMap<ActiveMQQueue, JournalMessageStore> queues = new ConcurrentHashMap<ActiveMQQueue, JournalMessageStore>();
1:9ef4259:     private final ConcurrentMap<ActiveMQTopic, JournalTopicMessageStore> topics = new ConcurrentHashMap<ActiveMQTopic, JournalTopicMessageStore>();
1:d29ca2a: 
1:6d8e2c5:     private SystemUsage usageManager;
1:d77014a:     private long checkpointInterval = 1000 * 60 * 5;
1:933eb2f:     private long lastCheckpointRequest = System.currentTimeMillis();
1:d29ca2a:     private long lastCleanup = System.currentTimeMillis();
1:d29ca2a:     private int maxCheckpointWorkers = 10;
1:f812e34:     private int maxCheckpointMessageAddSize = 1024 * 1024;
1:d29ca2a: 
1:1a5ad28:     private final JournalTransactionStore transactionStore = new JournalTransactionStore(this);
1:d29ca2a:     private ThreadPoolExecutor checkpointExecutor;
1:f812e34: 
1:d29ca2a:     private TaskRunner checkpointTask;
1:d29ca2a:     private CountDownLatch nextCheckpointCountDownLatch = new CountDownLatch(1);
1:d29ca2a:     private boolean fullCheckPoint;
1:f812e34: 
1:1a5ad28:     private final AtomicBoolean started = new AtomicBoolean(false);
1:d29ca2a: 
1:f812e34:     private final Runnable periodicCheckpointTask = createPeriodicCheckpointTask();
1:f812e34: 
1:d3fb1aa:     private TaskRunnerFactory taskRunnerFactory;
1:dbc661f:     private File directory;
1:ac66a09: 
1:74846bb:     public JournalPersistenceAdapter() {
9:d29ca2a:     }
1:74846bb: 
1:18d616c:     public JournalPersistenceAdapter(Journal journal, PersistenceAdapter longTermPersistence, TaskRunnerFactory taskRunnerFactory) throws IOException {
1:d3fb1aa:         setJournal(journal);
1:d3fb1aa:         setTaskRunnerFactory(taskRunnerFactory);
1:d3fb1aa:         setPersistenceAdapter(longTermPersistence);
1:d29ca2a:     }
1:88acb0e: 
1:d3fb1aa:     public void setTaskRunnerFactory(TaskRunnerFactory taskRunnerFactory) {
1:d3fb1aa:         this.taskRunnerFactory = taskRunnerFactory;
1:d29ca2a:     }
1:88acb0e: 
1:d3fb1aa:     public void setJournal(Journal journal) {
1:d29ca2a:         this.journal = journal;
1:d29ca2a:         journal.setJournalEventListener(this);
1:d29ca2a:     }
1:74846bb: 
1:d3fb1aa:     public void setPersistenceAdapter(PersistenceAdapter longTermPersistence) {
1:d29ca2a:         this.longTermPersistence = longTermPersistence;
1:18d616c:     }
1:74846bb: 
1:933eb2f:     final Runnable createPeriodicCheckpointTask() {
1:933eb2f:         return new Runnable() {
1:74846bb:             @Override
1:933eb2f:             public void run() {
1:933eb2f:                 long lastTime = 0;
1:933eb2f:                 synchronized (this) {
1:933eb2f:                     lastTime = lastCheckpointRequest;
1:933eb2f:                 }
1:933eb2f:                 if (System.currentTimeMillis() > lastTime + checkpointInterval) {
1:933eb2f:                     checkpoint(false, true);
1:933eb2f:                 }
1:933eb2f:             }
1:933eb2f:         };
1:933eb2f:     }
1:933eb2f: 
1:18d616c:     /**
1:f812e34:      * @param usageManager The UsageManager that is controlling the
1:f812e34:      *                destination's memory usage.
1:18d616c:      */
1:74846bb:     @Override
1:6d8e2c5:     public void setUsageManager(SystemUsage usageManager) {
1:18d616c:         this.usageManager = usageManager;
1:18d616c:         longTermPersistence.setUsageManager(usageManager);
1:f812e34:     }
1:f812e34: 
1:74846bb:     @Override
1:933eb2f:     public Set<ActiveMQDestination> getDestinations() {
1:933eb2f:         Set<ActiveMQDestination> destinations = new HashSet<ActiveMQDestination>(longTermPersistence.getDestinations());
1:d29ca2a:         destinations.addAll(queues.keySet());
1:d29ca2a:         destinations.addAll(topics.keySet());
1:d29ca2a:         return destinations;
1:f812e34:     }
1:f812e34: 
1:d29ca2a:     private MessageStore createMessageStore(ActiveMQDestination destination) throws IOException {
1:d29ca2a:         if (destination.isQueue()) {
1:f812e34:             return createQueueMessageStore((ActiveMQQueue)destination);
1:f812e34:         } else {
1:f812e34:             return createTopicMessageStore((ActiveMQTopic)destination);
1:ac66a09:         }
1:ac66a09:     }
1:d29ca2a: 
1:74846bb:     @Override
1:d29ca2a:     public MessageStore createQueueMessageStore(ActiveMQQueue destination) throws IOException {
1:933eb2f:         JournalMessageStore store = queues.get(destination);
1:d29ca2a:         if (store == null) {
1:d29ca2a:             MessageStore checkpointStore = longTermPersistence.createQueueMessageStore(destination);
1:d29ca2a:             store = new JournalMessageStore(this, checkpointStore, destination);
1:d29ca2a:             queues.put(destination, store);
1:ac66a09:         }
1:d29ca2a:         return store;
1:d29ca2a:     }
1:d29ca2a: 
1:74846bb:     @Override
1:d29ca2a:     public TopicMessageStore createTopicMessageStore(ActiveMQTopic destinationName) throws IOException {
1:933eb2f:         JournalTopicMessageStore store = topics.get(destinationName);
1:d29ca2a:         if (store == null) {
1:d29ca2a:             TopicMessageStore checkpointStore = longTermPersistence.createTopicMessageStore(destinationName);
1:d29ca2a:             store = new JournalTopicMessageStore(this, checkpointStore, destinationName);
1:d29ca2a:             topics.put(destinationName, store);
1:d29ca2a:         }
1:d29ca2a:         return store;
1:d29ca2a:     }
1:d29ca2a: 
1:07b6a38:     /**
1:07b6a38:      * Cleanup method to remove any state associated with the given destination
1:b0c2a40:      *
1:07b6a38:      * @param destination Destination to forget
1:07b6a38:      */
1:74846bb:     @Override
1:07b6a38:     public void removeQueueMessageStore(ActiveMQQueue destination) {
1:07b6a38:         queues.remove(destination);
1:d29ca2a:     }
1:d29ca2a: 
1:07b6a38:     /**
1:07b6a38:      * Cleanup method to remove any state associated with the given destination
1:f812e34:      *
1:07b6a38:      * @param destination Destination to forget
1:07b6a38:      */
1:74846bb:     @Override
1:07b6a38:     public void removeTopicMessageStore(ActiveMQTopic destination) {
1:07b6a38:         topics.remove(destination);
1:d29ca2a:     }
1:d29ca2a: 
1:74846bb:     @Override
1:d29ca2a:     public TransactionStore createTransactionStore() throws IOException {
1:d29ca2a:         return transactionStore;
1:d29ca2a:     }
1:d29ca2a: 
1:74846bb:     @Override
1:d29ca2a:     public long getLastMessageBrokerSequenceId() throws IOException {
1:d29ca2a:         return longTermPersistence.getLastMessageBrokerSequenceId();
1:d29ca2a:     }
1:d29ca2a: 
1:74846bb:     @Override
1:d29ca2a:     public void beginTransaction(ConnectionContext context) throws IOException {
1:d29ca2a:         longTermPersistence.beginTransaction(context);
1:d29ca2a:     }
1:d29ca2a: 
1:74846bb:     @Override
1:d29ca2a:     public void commitTransaction(ConnectionContext context) throws IOException {
1:d29ca2a:         longTermPersistence.commitTransaction(context);
1:d29ca2a:     }
1:d29ca2a: 
1:74846bb:     @Override
1:d29ca2a:     public void rollbackTransaction(ConnectionContext context) throws IOException {
1:d29ca2a:         longTermPersistence.rollbackTransaction(context);
1:d29ca2a:     }
1:d29ca2a: 
1:74846bb:     @Override
1:d29ca2a:     public synchronized void start() throws Exception {
1:f812e34:         if (!started.compareAndSet(false, true)) {
1:d29ca2a:             return;
1:f812e34:         }
1:f812e34: 
1:ec9975c:         if( brokerService!=null ) {
1:ec9975c:           wireFormat.setVersion(brokerService.getStoreOpenWireVersion());
1:ec9975c:         }
1:ec9975c: 
1:f812e34:         checkpointTask = taskRunnerFactory.createTaskRunner(new Task() {
1:74846bb:             @Override
1:d29ca2a:             public boolean iterate() {
1:d29ca2a:                 return doCheckpoint();
1:d29ca2a:             }
1:e2aad41:         }, "ActiveMQ Journal Checkpoint Worker");
1:d29ca2a: 
1:933eb2f:         checkpointExecutor = new ThreadPoolExecutor(maxCheckpointWorkers, maxCheckpointWorkers, 30, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new ThreadFactory() {
1:74846bb:             @Override
1:d29ca2a:             public Thread newThread(Runnable runable) {
1:d29ca2a:                 Thread t = new Thread(runable, "Journal checkpoint worker");
1:d29ca2a:                 t.setPriority(7);
1:d29ca2a:                 return t;
1:f812e34:             }
2:d29ca2a:         });
1:f812e34:         // checkpointExecutor.allowCoreThreadTimeOut(true);
1:f812e34: 
1:6d8e2c5:         this.usageManager.getMemoryUsage().addUsageListener(this);
1:18d616c: 
1:d29ca2a:         if (longTermPersistence instanceof JDBCPersistenceAdapter) {
1:d29ca2a:             // Disabled periodic clean up as it deadlocks with the checkpoint
1:d29ca2a:             // operations.
1:f812e34:             ((JDBCPersistenceAdapter)longTermPersistence).setCleanupPeriod(0);
1:d29ca2a:         }
1:d29ca2a: 
1:d29ca2a:         longTermPersistence.start();
1:d29ca2a:         createTransactionStore();
1:d29ca2a:         recover();
1:d29ca2a: 
1:d29ca2a:         // Do a checkpoint periodically.
1:1a5ad28:         this.scheduler = new Scheduler("Journal Scheduler");
1:1a5ad28:         this.scheduler.start();
1:1a5ad28:         this.scheduler.executePeriodically(periodicCheckpointTask, checkpointInterval / 10);
1:d29ca2a: 
1:d29ca2a:     }
1:d29ca2a: 
1:74846bb:     @Override
1:d29ca2a:     public void stop() throws Exception {
1:f812e34: 
1:6d8e2c5:         this.usageManager.getMemoryUsage().removeUsageListener(this);
1:fc00993:         if (!started.compareAndSet(true, false)) {
1:d29ca2a:             return;
1:fc00993:         }
1:f812e34: 
1:1a5ad28:         this.scheduler.cancel(periodicCheckpointTask);
1:1a5ad28:         this.scheduler.stop();
1:d29ca2a: 
1:d29ca2a:         // Take one final checkpoint and stop checkpoint processing.
1:6bdfbf3:         checkpoint(true, true);
1:f812e34:         checkpointTask.shutdown();
1:6c1676b:         ThreadPoolUtils.shutdown(checkpointExecutor);
1:6c1676b:         checkpointExecutor = null;
1:f812e34: 
1:d29ca2a:         queues.clear();
1:d29ca2a:         topics.clear();
1:d29ca2a: 
1:d29ca2a:         IOException firstException = null;
1:d29ca2a:         try {
1:d29ca2a:             journal.close();
1:d29ca2a:         } catch (Exception e) {
1:d29ca2a:             firstException = IOExceptionSupport.create("Failed to close journals: " + e, e);
1:d29ca2a:         }
1:d29ca2a:         longTermPersistence.stop();
1:f812e34: 
1:d29ca2a:         if (firstException != null) {
1:d29ca2a:             throw firstException;
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     // Properties
1:d29ca2a:     // -------------------------------------------------------------------------
1:d29ca2a:     public PersistenceAdapter getLongTermPersistence() {
1:d29ca2a:         return longTermPersistence;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the wireFormat.
1:d29ca2a:      */
1:d29ca2a:     public WireFormat getWireFormat() {
1:d29ca2a:         return wireFormat;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     // Implementation methods
1:d29ca2a:     // -------------------------------------------------------------------------
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * The Journal give us a call back so that we can move old data out of the
1:d29ca2a:      * journal. Taking a checkpoint does this for us.
1:74846bb:      *
1:d29ca2a:      * @see org.apache.activemq.journal.JournalEventListener#overflowNotification(org.apache.activemq.journal.RecordLocation)
1:d29ca2a:      */
1:74846bb:     @Override
1:d29ca2a:     public void overflowNotification(RecordLocation safeLocation) {
1:f812e34:         checkpoint(false, true);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * When we checkpoint we move all the journalled data to long term storage.
1:74846bb:      *
1:d29ca2a:      */
1:d29ca2a:     public void checkpoint(boolean sync, boolean fullCheckpoint) {
1:d29ca2a:         try {
1:fc00993:             if (journal == null) {
1:d29ca2a:                 throw new IllegalStateException("Journal is closed.");
1:fc00993:             }
1:f812e34: 
1:d29ca2a:             long now = System.currentTimeMillis();
1:d29ca2a:             CountDownLatch latch = null;
1:f812e34:             synchronized (this) {
1:d29ca2a:                 latch = nextCheckpointCountDownLatch;
1:d29ca2a:                 lastCheckpointRequest = now;
1:f812e34:                 if (fullCheckpoint) {
1:f812e34:                     this.fullCheckPoint = true;
1:d29ca2a:                 }
1:d29ca2a:             }
1:f812e34: 
1:d29ca2a:             checkpointTask.wakeup();
1:f812e34: 
1:d29ca2a:             if (sync) {
1:fc00993:                 LOG.debug("Waking for checkpoint to complete.");
1:d29ca2a:                 latch.await();
1:d29ca2a:             }
1:f812e34:         } catch (InterruptedException e) {
1:b75a6da:             Thread.currentThread().interrupt();
1:fc00993:             LOG.warn("Request to start checkpoint failed: " + e, e);
1:d29ca2a:         }
1:d29ca2a:     }
1:f812e34: 
1:74846bb:     @Override
1:759fd28:     public void checkpoint(boolean sync) {
1:f812e34:         checkpoint(sync, sync);
1:d29ca2a:     }
1:f812e34: 
1:d29ca2a:     /**
1:d29ca2a:      * This does the actual checkpoint.
1:74846bb:      *
1:f812e34:      * @return
1:d29ca2a:      */
1:d29ca2a:     public boolean doCheckpoint() {
1:d29ca2a:         CountDownLatch latch = null;
1:d29ca2a:         boolean fullCheckpoint;
1:f812e34:         synchronized (this) {
1:d29ca2a:             latch = nextCheckpointCountDownLatch;
1:d29ca2a:             nextCheckpointCountDownLatch = new CountDownLatch(1);
1:d29ca2a:             fullCheckpoint = this.fullCheckPoint;
1:f812e34:             this.fullCheckPoint = false;
1:f812e34:         }
1:d29ca2a:         try {
1:d29ca2a: 
1:fc00993:             LOG.debug("Checkpoint started.");
1:d29ca2a:             RecordLocation newMark = null;
1:f812e34: 
1:933eb2f:             ArrayList<FutureTask<RecordLocation>> futureTasks = new ArrayList<FutureTask<RecordLocation>>(queues.size() + topics.size());
1:d29ca2a: 
2:d29ca2a:             //
1:f812e34:             // We do many partial checkpoints (fullCheckpoint==false) to move
1:f812e34:             // topic messages
1:f812e34:             // to long term store as soon as possible.
1:74846bb:             //
1:f812e34:             // We want to avoid doing that for queue messages since removes the
1:f812e34:             // come in the same
1:f812e34:             // checkpoint cycle will nullify the previous message add.
1:f812e34:             // Therefore, we only
1:d29ca2a:             // checkpoint queues on the fullCheckpoint cycles.
1:d29ca2a:             //
1:f812e34:             if (fullCheckpoint) {
1:933eb2f:                 Iterator<JournalMessageStore> iterator = queues.values().iterator();
1:d29ca2a:                 while (iterator.hasNext()) {
1:d29ca2a:                     try {
1:933eb2f:                         final JournalMessageStore ms = iterator.next();
1:933eb2f:                         FutureTask<RecordLocation> task = new FutureTask<RecordLocation>(new Callable<RecordLocation>() {
1:74846bb:                             @Override
1:933eb2f:                             public RecordLocation call() throws Exception {
1:d29ca2a:                                 return ms.checkpoint();
1:f812e34:                             }
1:f812e34:                         });
1:d29ca2a:                         futureTasks.add(task);
1:f812e34:                         checkpointExecutor.execute(task);
1:f812e34:                     } catch (Exception e) {
1:fc00993:                         LOG.error("Failed to checkpoint a message store: " + e, e);
1:f812e34:                     }
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a: 
1:933eb2f:             Iterator<JournalTopicMessageStore> iterator = topics.values().iterator();
1:d29ca2a:             while (iterator.hasNext()) {
1:d29ca2a:                 try {
1:933eb2f:                     final JournalTopicMessageStore ms = iterator.next();
1:933eb2f:                     FutureTask<RecordLocation> task = new FutureTask<RecordLocation>(new Callable<RecordLocation>() {
1:74846bb:                         @Override
1:933eb2f:                         public RecordLocation call() throws Exception {
1:d29ca2a:                             return ms.checkpoint();
1:d29ca2a:                         }
1:f812e34:                     });
1:d29ca2a:                     futureTasks.add(task);
1:f812e34:                     checkpointExecutor.execute(task);
1:f812e34:                 } catch (Exception e) {
1:fc00993:                     LOG.error("Failed to checkpoint a message store: " + e, e);
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a: 
1:d29ca2a:             try {
1:933eb2f:                 for (Iterator<FutureTask<RecordLocation>> iter = futureTasks.iterator(); iter.hasNext();) {
1:933eb2f:                     FutureTask<RecordLocation> ft = iter.next();
1:933eb2f:                     RecordLocation mark = ft.get();
1:d29ca2a:                     // We only set a newMark on full checkpoints.
1:f812e34:                     if (fullCheckpoint) {
1:d29ca2a:                         if (mark != null && (newMark == null || newMark.compareTo(mark) < 0)) {
1:d29ca2a:                             newMark = mark;
1:d29ca2a:                         }
1:d29ca2a:                     }
1:d29ca2a:                 }
1:d29ca2a:             } catch (Throwable e) {
1:fc00993:                 LOG.error("Failed to checkpoint a message store: " + e, e);
1:d29ca2a:             }
1:d29ca2a: 
1:f812e34:             if (fullCheckpoint) {
1:d29ca2a:                 try {
1:d29ca2a:                     if (newMark != null) {
1:fc00993:                         LOG.debug("Marking journal at: " + newMark);
1:d29ca2a:                         journal.setMark(newMark, true);
1:d29ca2a:                     }
1:f812e34:                 } catch (Exception e) {
1:fc00993:                     LOG.error("Failed to mark the Journal: " + e, e);
1:d29ca2a:                 }
1:f812e34: 
1:d29ca2a:                 if (longTermPersistence instanceof JDBCPersistenceAdapter) {
1:f812e34:                     // We may be check pointing more often than the
1:f812e34:                     // checkpointInterval if under high use
1:d29ca2a:                     // But we don't want to clean up the db that often.
1:d29ca2a:                     long now = System.currentTimeMillis();
1:f812e34:                     if (now > lastCleanup + checkpointInterval) {
1:d29ca2a:                         lastCleanup = now;
1:f812e34:                         ((JDBCPersistenceAdapter)longTermPersistence).cleanup();
1:d29ca2a:                     }
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a: 
1:fc00993:             LOG.debug("Checkpoint done.");
1:f812e34:         } finally {
1:d29ca2a:             latch.countDown();
1:d29ca2a:         }
1:f812e34:         synchronized (this) {
1:d29ca2a:             return this.fullCheckPoint;
1:f812e34:         }
1:d29ca2a: 
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @param location
2:d29ca2a:      * @return
1:d29ca2a:      * @throws IOException
1:d29ca2a:      */
1:d29ca2a:     public DataStructure readCommand(RecordLocation location) throws IOException {
1:d29ca2a:         try {
1:f812e34:             Packet packet = journal.read(location);
1:f812e34:             return (DataStructure)wireFormat.unmarshal(toByteSequence(packet));
1:f812e34:         } catch (InvalidRecordLocationException e) {
1:d29ca2a:             throw createReadException(location, e);
1:f812e34:         } catch (IOException e) {
1:d29ca2a:             throw createReadException(location, e);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Move all the messages that were in the journal into long term storage. We
1:d29ca2a:      * just replay and do a checkpoint.
1:74846bb:      *
1:d29ca2a:      * @throws IOException
1:d29ca2a:      * @throws IOException
1:d29ca2a:      * @throws InvalidRecordLocationException
1:d29ca2a:      * @throws IllegalStateException
1:d29ca2a:      */
1:d29ca2a:     private void recover() throws IllegalStateException, InvalidRecordLocationException, IOException, IOException {
1:d29ca2a: 
1:d29ca2a:         RecordLocation pos = null;
1:d29ca2a:         int transactionCounter = 0;
1:d29ca2a: 
1:fc00993:         LOG.info("Journal Recovery Started from: " + journal);
1:3b0afd6:         ConnectionContext context = new ConnectionContext(new NonCachedMessageEvaluationContext());
1:d29ca2a: 
1:d29ca2a:         // While we have records in the journal.
1:d29ca2a:         while ((pos = journal.getNextRecordLocation(pos)) != null) {
1:f451ad0:             Packet data = journal.read(pos);
1:f812e34:             DataStructure c = (DataStructure)wireFormat.unmarshal(toByteSequence(data));
1:d29ca2a: 
1:f812e34:             if (c instanceof Message) {
1:f812e34:                 Message message = (Message)c;
1:f812e34:                 JournalMessageStore store = (JournalMessageStore)createMessageStore(message.getDestination());
1:f812e34:                 if (message.isInTransaction()) {
1:d29ca2a:                     transactionStore.addMessage(store, message, pos);
1:f812e34:                 } else {
1:d29ca2a:                     store.replayAddMessage(context, message);
1:d29ca2a:                     transactionCounter++;
1:d29ca2a:                 }
1:d29ca2a:             } else {
1:d29ca2a:                 switch (c.getDataStructureType()) {
1:f812e34:                 case JournalQueueAck.DATA_STRUCTURE_TYPE: {
1:f812e34:                     JournalQueueAck command = (JournalQueueAck)c;
1:f812e34:                     JournalMessageStore store = (JournalMessageStore)createMessageStore(command.getDestination());
1:d29ca2a:                     if (command.getMessageAck().isInTransaction()) {
1:d29ca2a:                         transactionStore.removeMessage(store, command.getMessageAck(), pos);
1:f812e34:                     } else {
1:d29ca2a:                         store.replayRemoveMessage(context, command.getMessageAck());
1:d29ca2a:                         transactionCounter++;
1:d29ca2a:                     }
1:d29ca2a:                 }
1:f812e34:                     break;
1:f812e34:                 case JournalTopicAck.DATA_STRUCTURE_TYPE: {
1:f812e34:                     JournalTopicAck command = (JournalTopicAck)c;
1:f812e34:                     JournalTopicMessageStore store = (JournalTopicMessageStore)createMessageStore(command.getDestination());
1:d29ca2a:                     if (command.getTransactionId() != null) {
1:d29ca2a:                         transactionStore.acknowledge(store, command, pos);
1:f812e34:                     } else {
1:d29ca2a:                         store.replayAcknowledge(context, command.getClientId(), command.getSubscritionName(), command.getMessageId());
1:d29ca2a:                         transactionCounter++;
1:d29ca2a:                     }
1:d29ca2a:                 }
1:f812e34:                     break;
1:f812e34:                 case JournalTransaction.DATA_STRUCTURE_TYPE: {
1:f812e34:                     JournalTransaction command = (JournalTransaction)c;
1:d29ca2a:                     try {
1:d29ca2a:                         // Try to replay the packet.
1:d29ca2a:                         switch (command.getType()) {
1:d29ca2a:                         case JournalTransaction.XA_PREPARE:
1:d29ca2a:                             transactionStore.replayPrepare(command.getTransactionId());
4:d29ca2a:                             break;
1:d29ca2a:                         case JournalTransaction.XA_COMMIT:
1:d29ca2a:                         case JournalTransaction.LOCAL_COMMIT:
1:d29ca2a:                             Tx tx = transactionStore.replayCommit(command.getTransactionId(), command.getWasPrepared());
1:fc00993:                             if (tx == null) {
1:f812e34:                                 break; // We may be trying to replay a commit
1:fc00993:                             }
1:f812e34:                             // that
1:f812e34:                             // was already committed.
1:d29ca2a: 
1:d29ca2a:                             // Replay the committed operations.
1:d29ca2a:                             tx.getOperations();
1:d29ca2a:                             for (Iterator iter = tx.getOperations().iterator(); iter.hasNext();) {
1:f812e34:                                 TxOperation op = (TxOperation)iter.next();
1:d29ca2a:                                 if (op.operationType == TxOperation.ADD_OPERATION_TYPE) {
1:f812e34:                                     op.store.replayAddMessage(context, (Message)op.data);
1:d29ca2a:                                 }
1:d29ca2a:                                 if (op.operationType == TxOperation.REMOVE_OPERATION_TYPE) {
1:f812e34:                                     op.store.replayRemoveMessage(context, (MessageAck)op.data);
1:d29ca2a:                                 }
1:d29ca2a:                                 if (op.operationType == TxOperation.ACK_OPERATION_TYPE) {
1:f812e34:                                     JournalTopicAck ack = (JournalTopicAck)op.data;
1:f812e34:                                     ((JournalTopicMessageStore)op.store).replayAcknowledge(context, ack.getClientId(), ack.getSubscritionName(), ack.getMessageId());
1:d29ca2a:                                 }
1:d29ca2a:                             }
1:d29ca2a:                             transactionCounter++;
1:d29ca2a:                             break;
1:d29ca2a:                         case JournalTransaction.LOCAL_ROLLBACK:
1:d29ca2a:                         case JournalTransaction.XA_ROLLBACK:
1:d29ca2a:                             transactionStore.replayRollback(command.getTransactionId());
1:f812e34:                             break;
1:74a7a8b:                         default:
1:74a7a8b:                             throw new IOException("Invalid journal command type: " + command.getType());
1:d29ca2a:                         }
1:f812e34:                     } catch (IOException e) {
1:fc00993:                         LOG.error("Recovery Failure: Could not replay: " + c + ", reason: " + e, e);
1:d29ca2a:                     }
1:d29ca2a:                 }
1:d29ca2a:                     break;
1:d29ca2a:                 case JournalTrace.DATA_STRUCTURE_TYPE:
1:f812e34:                     JournalTrace trace = (JournalTrace)c;
1:fc00993:                     LOG.debug("TRACE Entry: " + trace.getMessage());
1:d29ca2a:                     break;
1:d29ca2a:                 default:
1:fc00993:                     LOG.error("Unknown type of record in transaction log which will be discarded: " + c);
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a: 
1:d29ca2a:         RecordLocation location = writeTraceMessage("RECOVERED", true);
1:d29ca2a:         journal.setMark(location, true);
1:d29ca2a: 
1:fc00993:         LOG.info("Journal Recovered: " + transactionCounter + " message(s) in transactions recovered.");
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     private IOException createReadException(RecordLocation location, Exception e) {
1:d29ca2a:         return IOExceptionSupport.create("Failed to read to journal for: " + location + ". Reason: " + e, e);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     protected IOException createWriteException(DataStructure packet, Exception e) {
1:d29ca2a:         return IOExceptionSupport.create("Failed to write to journal for: " + packet + ". Reason: " + e, e);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     protected IOException createWriteException(String command, Exception e) {
1:d29ca2a:         return IOExceptionSupport.create("Failed to write to journal for command: " + command + ". Reason: " + e, e);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     protected IOException createRecoveryFailedException(Exception e) {
1:d29ca2a:         return IOExceptionSupport.create("Failed to recover from journal. Reason: " + e, e);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @param command
1:d29ca2a:      * @param sync
1:d29ca2a:      * @return
1:d29ca2a:      * @throws IOException
1:d29ca2a:      */
1:d29ca2a:     public RecordLocation writeCommand(DataStructure command, boolean sync) throws IOException {
1:fc00993:         if (started.get()) {
1:27cbf7b:             try {
1:74846bb:                 return journal.write(toPacket(wireFormat.marshal(command)), sync);
1:27cbf7b:             } catch (IOException ioe) {
1:74846bb:                 LOG.error("Cannot write to the journal", ioe);
1:74846bb:                 brokerService.handleIOException(ioe);
1:74846bb:                 throw ioe;
1:fc00993:             }
1:d29ca2a:         }
1:d29ca2a:         throw new IOException("closed");
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     private RecordLocation writeTraceMessage(String message, boolean sync) throws IOException {
1:d29ca2a:         JournalTrace trace = new JournalTrace();
1:d29ca2a:         trace.setMessage(message);
1:d29ca2a:         return writeCommand(trace, sync);
1:d29ca2a:     }
1:d29ca2a: 
1:74846bb:     @Override
1:6d8e2c5:     public void onUsageChanged(Usage usage, int oldPercentUsage, int newPercentUsage) {
1:74a7a8b:         newPercentUsage = (newPercentUsage / 10) * 10;
1:74a7a8b:         oldPercentUsage = (oldPercentUsage / 10) * 10;
1:4eef609:         if (newPercentUsage >= 70 && oldPercentUsage < newPercentUsage) {
1:4eef609:             boolean sync = newPercentUsage >= 90;
1:4eef609:             checkpoint(sync, true);
1:d29ca2a:         }
1:d29ca2a:     }
1:f812e34: 
1:d29ca2a:     public JournalTransactionStore getTransactionStore() {
1:d29ca2a:         return transactionStore;
1:d29ca2a:     }
1:d29ca2a: 
1:74846bb:     @Override
1:f812e34:     public void deleteAllMessages() throws IOException {
1:d29ca2a:         try {
1:d29ca2a:             JournalTrace trace = new JournalTrace();
1:d29ca2a:             trace.setMessage("DELETED");
1:88acb0e:             RecordLocation location = journal.write(toPacket(wireFormat.marshal(trace)), false);
1:d29ca2a:             journal.setMark(location, true);
1:fc00993:             LOG.info("Journal deleted: ");
1:d29ca2a:         } catch (IOException e) {
1:d29ca2a:             throw e;
1:d29ca2a:         } catch (Throwable e) {
1:d29ca2a:             throw IOExceptionSupport.create(e);
1:d29ca2a:         }
1:d29ca2a:         longTermPersistence.deleteAllMessages();
1:d29ca2a:     }
1:d29ca2a: 
1:6d8e2c5:     public SystemUsage getUsageManager() {
1:d29ca2a:         return usageManager;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public int getMaxCheckpointMessageAddSize() {
1:d29ca2a:         return maxCheckpointMessageAddSize;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public void setMaxCheckpointMessageAddSize(int maxCheckpointMessageAddSize) {
1:d29ca2a:         this.maxCheckpointMessageAddSize = maxCheckpointMessageAddSize;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public int getMaxCheckpointWorkers() {
1:d29ca2a:         return maxCheckpointWorkers;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public void setMaxCheckpointWorkers(int maxCheckpointWorkers) {
1:d29ca2a:         this.maxCheckpointWorkers = maxCheckpointWorkers;
1:d29ca2a:     }
1:d29ca2a: 
1:d77014a:     public long getCheckpointInterval() {
1:d77014a:         return checkpointInterval;
1:d77014a:     }
1:d77014a: 
1:d77014a:     public void setCheckpointInterval(long checkpointInterval) {
1:d77014a:         this.checkpointInterval = checkpointInterval;
1:d77014a:     }
1:d77014a: 
1:d29ca2a:     public boolean isUseExternalMessageReferences() {
1:d29ca2a:         return false;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public void setUseExternalMessageReferences(boolean enable) {
1:fc00993:         if (enable) {
1:d29ca2a:             throw new IllegalArgumentException("The journal does not support message references.");
1:fc00993:         }
1:d29ca2a:     }
1:f812e34: 
1:88acb0e:     public Packet toPacket(ByteSequence sequence) {
1:f812e34:         return new ByteArrayPacket(new org.apache.activeio.packet.ByteSequence(sequence.data, sequence.offset, sequence.length));
1:88acb0e:     }
1:f812e34: 
1:88acb0e:     public ByteSequence toByteSequence(Packet packet) {
1:f812e34:         org.apache.activeio.packet.ByteSequence sequence = packet.asByteSequence();
1:f812e34:         return new ByteSequence(sequence.getData(), sequence.getOffset(), sequence.getLength());
1:88acb0e:     }
1:f812e34: 
1:74846bb:     @Override
1:f812e34:     public void setBrokerName(String brokerName) {
1:759fd28:         longTermPersistence.setBrokerName(brokerName);
1:d29ca2a:     }
1:f812e34: 
1:74846bb:     @Override
1:f812e34:     public String toString() {
1:d77014a:         return "JournalPersistenceAdapter(" + longTermPersistence + ")";
1:d29ca2a:     }
1:d29ca2a: 
1:74846bb:     @Override
1:f812e34:     public void setDirectory(File dir) {
1:dbc661f:         this.directory=dir;
1:d29ca2a:     }
1:74846bb: 
1:74846bb:     @Override
1:dbc661f:     public File getDirectory(){
1:dbc661f:         return directory;
1:d29ca2a:     }
1:74846bb: 
1:74846bb:     @Override
1:6d8e2c5:     public long size(){
1:6d8e2c5:         return 0;
1:d29ca2a:     }
1:d29ca2a: 
1:74846bb:     @Override
1:b9797bc:     public void setBrokerService(BrokerService brokerService) {
1:27cbf7b:         this.brokerService = brokerService;
1:b9797bc:         PersistenceAdapter pa = getLongTermPersistence();
1:b9797bc:         if( pa instanceof BrokerServiceAware ) {
1:b9797bc:             ((BrokerServiceAware)pa).setBrokerService(brokerService);
1:b9797bc:         }
1:b9797bc:     }
1:b9797bc: 
1:1a5ad28:     @Override
1:a6a6a70:     public long getLastProducerSequenceId(ProducerId id) {
1:a6a6a70:         return -1;
1:d29ca2a:     }
1:d29ca2a: 
1:74846bb:     @Override
1:b07821a:     public void allowIOResumption() {
1:b07821a:         longTermPersistence.allowIOResumption();
1:b07821a:     }
1:b07821a: 
1:b07821a:     @Override
1:74846bb:     public JobSchedulerStore createJobSchedulerStore() throws IOException, UnsupportedOperationException {
1:74846bb:         return longTermPersistence.createJobSchedulerStore();
1:74846bb:     }
1:74846bb: 
1:d29ca2a: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:b07821a
/////////////////////////////////////////////////////////////////////////
1:     public void allowIOResumption() {
1:         longTermPersistence.allowIOResumption();
1:     }
1: 
1:     @Override
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Timothy Bish
-------------------------------------------------------------------------------
commit:9ef4259
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentMap;
/////////////////////////////////////////////////////////////////////////
1:     private final ConcurrentMap<ActiveMQQueue, JournalMessageStore> queues = new ConcurrentHashMap<ActiveMQQueue, JournalMessageStore>();
1:     private final ConcurrentMap<ActiveMQTopic, JournalTopicMessageStore> topics = new ConcurrentHashMap<ActiveMQTopic, JournalTopicMessageStore>();
commit:74846bb
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.scheduler.JobSchedulerStore;
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
1: 
/////////////////////////////////////////////////////////////////////////
1:     public JournalPersistenceAdapter() {
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:      *
1:     @Override
1:      *
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:      *
/////////////////////////////////////////////////////////////////////////
1:             //
/////////////////////////////////////////////////////////////////////////
1:                             @Override
/////////////////////////////////////////////////////////////////////////
1:                         @Override
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:                 return journal.write(toPacket(wireFormat.marshal(command)), sync);
1:                 LOG.error("Cannot write to the journal", ioe);
1:                 brokerService.handleIOException(ioe);
1:                 throw ioe;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1: 
1:     @Override
1: 
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     public JobSchedulerStore createJobSchedulerStore() throws IOException, UnsupportedOperationException {
1:         return longTermPersistence.createJobSchedulerStore();
1:     }
1: 
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:d77014a
/////////////////////////////////////////////////////////////////////////
1:     private long checkpointInterval = 1000 * 60 * 5;
/////////////////////////////////////////////////////////////////////////
1:     public long getCheckpointInterval() {
1:         return checkpointInterval;
1:     }
1: 
1:     public void setCheckpointInterval(long checkpointInterval) {
1:         this.checkpointInterval = checkpointInterval;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         return "JournalPersistenceAdapter(" + longTermPersistence + ")";
commit:6c1676b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.ThreadPoolUtils;
/////////////////////////////////////////////////////////////////////////
1:         ThreadPoolUtils.shutdown(checkpointExecutor);
1:         checkpointExecutor = null;
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:ec9975c
/////////////////////////////////////////////////////////////////////////
1:         if( brokerService!=null ) {
1:           wireFormat.setVersion(brokerService.getStoreOpenWireVersion());
1:         }
1: 
commit:c5cf038
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:b9797bc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.BrokerServiceAware;
/////////////////////////////////////////////////////////////////////////
1: public class JournalPersistenceAdapter implements PersistenceAdapter, JournalEventListener, UsageListener, BrokerServiceAware {
/////////////////////////////////////////////////////////////////////////
1:     public void setBrokerService(BrokerService brokerService) {
1:         PersistenceAdapter pa = getLongTermPersistence();
1:         if( pa instanceof BrokerServiceAware ) {
1:             ((BrokerServiceAware)pa).setBrokerService(brokerService);
1:         }
1:     }
1: 
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
0:     private final ConcurrentHashMap<ActiveMQQueue, JournalMessageStore> queues = new ConcurrentHashMap<ActiveMQQueue, JournalMessageStore>();
0:     private final ConcurrentHashMap<ActiveMQTopic, JournalTopicMessageStore> topics = new ConcurrentHashMap<ActiveMQTopic, JournalTopicMessageStore>();
0:     private long checkpointInterval = 1000 * 60 * 5;
1:     private long lastCheckpointRequest = System.currentTimeMillis();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     final Runnable createPeriodicCheckpointTask() {
1:         return new Runnable() {
1:             public void run() {
1:                 long lastTime = 0;
1:                 synchronized (this) {
1:                     lastTime = lastCheckpointRequest;
1:                 }
1:                 if (System.currentTimeMillis() > lastTime + checkpointInterval) {
1:                     checkpoint(false, true);
1:                 }
1:             }
1:         };
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public Set<ActiveMQDestination> getDestinations() {
1:         Set<ActiveMQDestination> destinations = new HashSet<ActiveMQDestination>(longTermPersistence.getDestinations());
/////////////////////////////////////////////////////////////////////////
1:         JournalMessageStore store = queues.get(destination);
/////////////////////////////////////////////////////////////////////////
1:         JournalTopicMessageStore store = topics.get(destinationName);
/////////////////////////////////////////////////////////////////////////
1:         checkpointExecutor = new ThreadPoolExecutor(maxCheckpointWorkers, maxCheckpointWorkers, 30, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new ThreadFactory() {
/////////////////////////////////////////////////////////////////////////
1:             ArrayList<FutureTask<RecordLocation>> futureTasks = new ArrayList<FutureTask<RecordLocation>>(queues.size() + topics.size());
/////////////////////////////////////////////////////////////////////////
1:                 Iterator<JournalMessageStore> iterator = queues.values().iterator();
1:                         final JournalMessageStore ms = iterator.next();
1:                         FutureTask<RecordLocation> task = new FutureTask<RecordLocation>(new Callable<RecordLocation>() {
1:                             public RecordLocation call() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:             Iterator<JournalTopicMessageStore> iterator = topics.values().iterator();
1:                     final JournalTopicMessageStore ms = iterator.next();
1:                     FutureTask<RecordLocation> task = new FutureTask<RecordLocation>(new Callable<RecordLocation>() {
1:                         public RecordLocation call() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:                 for (Iterator<FutureTask<RecordLocation>> iter = futureTasks.iterator(); iter.hasNext();) {
1:                     FutureTask<RecordLocation> ft = iter.next();
1:                     RecordLocation mark = ft.get();
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(JournalPersistenceAdapter.class);
/////////////////////////////////////////////////////////////////////////
1:         if (!started.compareAndSet(true, false)) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:             if (journal == null) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Waking for checkpoint to complete.");
1:             LOG.warn("Request to start checkpoint failed: " + e, e);
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug("Checkpoint started.");
/////////////////////////////////////////////////////////////////////////
1:                         LOG.error("Failed to checkpoint a message store: " + e, e);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.error("Failed to checkpoint a message store: " + e, e);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.error("Failed to checkpoint a message store: " + e, e);
1:                         LOG.debug("Marking journal at: " + newMark);
1:                     LOG.error("Failed to mark the Journal: " + e, e);
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug("Checkpoint done.");
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("Journal Recovery Started from: " + journal);
/////////////////////////////////////////////////////////////////////////
1:                             if (tx == null) {
1:                             }
/////////////////////////////////////////////////////////////////////////
1:                         LOG.error("Recovery Failure: Could not replay: " + c + ", reason: " + e, e);
1:                     LOG.debug("TRACE Entry: " + trace.getMessage());
1:                     LOG.error("Unknown type of record in transaction log which will be discarded: " + c);
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("Journal Recovered: " + transactionCounter + " message(s) in transactions recovered.");
/////////////////////////////////////////////////////////////////////////
1:         if (started.get()) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("Journal deleted: ");
/////////////////////////////////////////////////////////////////////////
1:         if (enable) {
1:         }
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
1:                         default:
1:                             throw new IOException("Invalid journal command type: " + command.getType());
/////////////////////////////////////////////////////////////////////////
1:         newPercentUsage = (newPercentUsage / 10) * 10;
1:         oldPercentUsage = (oldPercentUsage / 10) * 10;
commit:f812e34
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     private int maxCheckpointMessageAddSize = 1024 * 1024;
1: 
1: 
1:     private final Runnable periodicCheckpointTask = createPeriodicCheckpointTask();
1: 
0:         return new Runnable() {
0:             public void run() {
1:                 synchronized (this) {
0:                 if (System.currentTimeMillis() > lastTime + checkpointInterval) {
1:                     checkpoint(false, true);
1:                 }
1:             }
0:         };
1: 
1: 
1:         checkpointTask = taskRunnerFactory.createTaskRunner(new Task() {
/////////////////////////////////////////////////////////////////////////
1:      * @param usageManager The UsageManager that is controlling the
1:      *                destination's memory usage.
/////////////////////////////////////////////////////////////////////////
1:             return createQueueMessageStore((ActiveMQQueue)destination);
1:         } else {
1:             return createTopicMessageStore((ActiveMQTopic)destination);
0:         JournalMessageStore store = (JournalMessageStore)queues.get(destination);
/////////////////////////////////////////////////////////////////////////
0:         JournalTopicMessageStore store = (JournalTopicMessageStore)topics.get(destinationName);
/////////////////////////////////////////////////////////////////////////
1:         if (!started.compareAndSet(false, true)) {
1:         }
1: 
1:             }
1:         // checkpointExecutor.allowCoreThreadTimeOut(true);
1: 
1:             ((JDBCPersistenceAdapter)longTermPersistence).setCleanupPeriod(0);
/////////////////////////////////////////////////////////////////////////
0:         Scheduler.executePeriodically(periodicCheckpointTask, checkpointInterval / 10);
1: 
0:         if (!started.compareAndSet(true, false))
1: 
1:         checkpointTask.shutdown();
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:      * @param stopping
0:             if (journal == null)
1: 
1:             synchronized (this) {
1:                 if (fullCheckpoint) {
1:                     this.fullCheckPoint = true;
1: 
1: 
1:         } catch (InterruptedException e) {
1: 
1:         checkpoint(sync, sync);
1: 
1:      * 
1:      * @return
1:         synchronized (this) {
1:             this.fullCheckPoint = false;
1:         }
0:             ArrayList futureTasks = new ArrayList(queues.size() + topics.size());
1: 
1:             // We do many partial checkpoints (fullCheckpoint==false) to move
1:             // topic messages
1:             // to long term store as soon as possible.
1:             // We want to avoid doing that for queue messages since removes the
1:             // come in the same
1:             // checkpoint cycle will nullify the previous message add.
1:             // Therefore, we only
1:             if (fullCheckpoint) {
0:                         final JournalMessageStore ms = (JournalMessageStore)iterator.next();
1:                             }
1:                         });
1:                         checkpointExecutor.execute(task);
1:                     } catch (Exception e) {
/////////////////////////////////////////////////////////////////////////
0:                     final JournalTopicMessageStore ms = (JournalTopicMessageStore)iterator.next();
1:                         }
1:                     });
1:                     checkpointExecutor.execute(task);
1:                 } catch (Exception e) {
0:                     FutureTask ft = (FutureTask)iter.next();
0:                     RecordLocation mark = (RecordLocation)ft.get();
1:                     if (fullCheckpoint) {
/////////////////////////////////////////////////////////////////////////
1:             if (fullCheckpoint) {
1:                 } catch (Exception e) {
1: 
1:                     // We may be check pointing more often than the
1:                     // checkpointInterval if under high use
1:                     if (now > lastCleanup + checkpointInterval) {
1:                         ((JDBCPersistenceAdapter)longTermPersistence).cleanup();
1:         } finally {
0:         synchronized (this) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:             Packet packet = journal.read(location);
1:             return (DataStructure)wireFormat.unmarshal(toByteSequence(packet));
1:         } catch (InvalidRecordLocationException e) {
1:         } catch (IOException e) {
/////////////////////////////////////////////////////////////////////////
1:             DataStructure c = (DataStructure)wireFormat.unmarshal(toByteSequence(data));
1:             if (c instanceof Message) {
1:                 Message message = (Message)c;
1:                 JournalMessageStore store = (JournalMessageStore)createMessageStore(message.getDestination());
1:                 if (message.isInTransaction()) {
1:                 } else {
1:                 case JournalQueueAck.DATA_STRUCTURE_TYPE: {
1:                     JournalQueueAck command = (JournalQueueAck)c;
1:                     JournalMessageStore store = (JournalMessageStore)createMessageStore(command.getDestination());
1:                     } else {
1:                     break;
1:                 case JournalTopicAck.DATA_STRUCTURE_TYPE: {
1:                     JournalTopicAck command = (JournalTopicAck)c;
1:                     JournalTopicMessageStore store = (JournalTopicMessageStore)createMessageStore(command.getDestination());
1:                     } else {
1:                     break;
1:                 case JournalTransaction.DATA_STRUCTURE_TYPE: {
1:                     JournalTransaction command = (JournalTransaction)c;
/////////////////////////////////////////////////////////////////////////
1:                                 break; // We may be trying to replay a commit
1:                             // that
1:                             // was already committed.
1:                                 TxOperation op = (TxOperation)iter.next();
1:                                     op.store.replayAddMessage(context, (Message)op.data);
1:                                     op.store.replayRemoveMessage(context, (MessageAck)op.data);
1:                                     JournalTopicAck ack = (JournalTopicAck)op.data;
1:                                     ((JournalTopicMessageStore)op.store).replayAcknowledge(context, ack.getClientId(), ack.getSubscritionName(), ack.getMessageId());
/////////////////////////////////////////////////////////////////////////
1:                     } catch (IOException e) {
1:                     break;
1:                     JournalTrace trace = (JournalTrace)c;
/////////////////////////////////////////////////////////////////////////
0:         if (started.get())
/////////////////////////////////////////////////////////////////////////
0:         newPercentUsage = ((newPercentUsage) / 10) * 10;
0:         oldPercentUsage = ((oldPercentUsage) / 10) * 10;
1: 
1:     public void deleteAllMessages() throws IOException {
/////////////////////////////////////////////////////////////////////////
0:         if (enable)
1: 
1:         return new ByteArrayPacket(new org.apache.activeio.packet.ByteSequence(sequence.data, sequence.offset, sequence.length));
1: 
1:         org.apache.activeio.packet.ByteSequence sequence = packet.asByteSequence();
1:         return new ByteSequence(sequence.getData(), sequence.getOffset(), sequence.getLength());
1: 
1:     public void setBrokerName(String brokerName) {
1: 
1:     public String toString() {
1:     public void setDirectory(File dir) {
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:0afb7f9
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.Callable;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.FutureTask;
1: import java.util.concurrent.LinkedBlockingQueue;
1: import java.util.concurrent.ThreadFactory;
1: import java.util.concurrent.ThreadPoolExecutor;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.Callable;
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.FutureTask;
0: import java.util.concurrent.LinkedBlockingQueue;
0: import java.util.concurrent.ThreadFactory;
0: import java.util.concurrent.ThreadPoolExecutor;
0: import java.util.concurrent.TimeUnit;
0: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
0:         //checkpointExecutor.allowCoreThreadTimeOut(true);
commit:b75a6da
/////////////////////////////////////////////////////////////////////////
1:             Thread.currentThread().interrupt();
commit:ac66a09
/////////////////////////////////////////////////////////////////////////
0:     private final Runnable periodicCheckpointTask = createPeriodicCheckpointTask(); 
1:     	
0:     final Runnable createPeriodicCheckpointTask() {
0:     	return new Runnable() {
0: 	        public void run() {
0: 	            if( System.currentTimeMillis()>lastCheckpointRequest+checkpointInterval ) {
0: 	                checkpoint(false, true);
1: 	            }
1: 	        }
0: 	    };
1:     }
commit:88acb0e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activeio.packet.ByteArrayPacket;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.ByteSequence;
1: import org.apache.activemq.wireformat.WireFormat;
/////////////////////////////////////////////////////////////////////////
0:         	Packet packet = journal.read(location);
0:             return (DataStructure) wireFormat.unmarshal(toByteSequence(packet));
/////////////////////////////////////////////////////////////////////////
0:             DataStructure c = (DataStructure) wireFormat.unmarshal(toByteSequence(data));
/////////////////////////////////////////////////////////////////////////
0:             return journal.write(toPacket(wireFormat.marshal(command)), sync);
/////////////////////////////////////////////////////////////////////////
1:             RecordLocation location = journal.write(toPacket(wireFormat.marshal(trace)), false);
/////////////////////////////////////////////////////////////////////////
1:     
1:     public Packet toPacket(ByteSequence sequence) {
0:     	return new ByteArrayPacket(new org.apache.activeio.packet.ByteSequence(sequence.data, sequence.offset, sequence.length));
1:     }
1:     
1:     public ByteSequence toByteSequence(Packet packet) {
0:     	org.apache.activeio.packet.ByteSequence sequence = packet.asByteSequence();
0:     	return new ByteSequence(sequence.getData(), sequence.getOffset(), sequence.getLength());
1:     }
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:b439024
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
0:         Set destinations = new HashSet(longTermPersistence.getDestinations());
commit:e2aad41
/////////////////////////////////////////////////////////////////////////
1:         }, "ActiveMQ Journal Checkpoint Worker");
commit:18d616c
/////////////////////////////////////////////////////////////////////////
0:     private UsageManager usageManager;
/////////////////////////////////////////////////////////////////////////
1:     public JournalPersistenceAdapter(Journal journal, PersistenceAdapter longTermPersistence, TaskRunnerFactory taskRunnerFactory) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
1:     /**
0:      * @param usageManager The UsageManager that is controlling the destination's memory usage.
1:      */
0:     public void setUsageManager(UsageManager usageManager) {
1:         this.usageManager = usageManager;
1:         longTermPersistence.setUsageManager(usageManager);
/////////////////////////////////////////////////////////////////////////
0:         this.usageManager.removeUsageListener(this);
commit:f451ad0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activeio.command.WireFormat;
1: import org.apache.activeio.journal.InvalidRecordLocationException;
1: import org.apache.activeio.journal.Journal;
1: import org.apache.activeio.journal.JournalEventListener;
1: import org.apache.activeio.journal.RecordLocation;
1: import org.apache.activeio.packet.Packet;
/////////////////////////////////////////////////////////////////////////
0:             Packet data = journal.read(location);
/////////////////////////////////////////////////////////////////////////
1:             Packet data = journal.read(pos);
commit:6583ef1
/////////////////////////////////////////////////////////////////////////
1:     private final WireFormat wireFormat = new OpenWireFormat();
commit:68d245f
/////////////////////////////////////////////////////////////////////////
1:  * @org.apache.xbean.XBean
commit:6bdfbf3
/////////////////////////////////////////////////////////////////////////
1:         checkpoint(true, true);
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.store.journal;
1: 
1: import java.io.IOException;
1: import java.util.ArrayList;
1: import java.util.Iterator;
1: import java.util.Set;
1: 
0: import org.activeio.command.WireFormat;
0: import org.activeio.journal.InvalidRecordLocationException;
0: import org.activeio.journal.Journal;
0: import org.activeio.journal.JournalEventListener;
0: import org.activeio.journal.RecordLocation;
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.command.DataStructure;
1: import org.apache.activemq.command.JournalQueueAck;
1: import org.apache.activemq.command.JournalTopicAck;
1: import org.apache.activemq.command.JournalTrace;
1: import org.apache.activemq.command.JournalTransaction;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageAck;
0: import org.apache.activemq.memory.UsageListener;
0: import org.apache.activemq.memory.UsageManager;
1: import org.apache.activemq.openwire.OpenWireFormat;
1: import org.apache.activemq.store.MessageStore;
1: import org.apache.activemq.store.PersistenceAdapter;
1: import org.apache.activemq.store.TopicMessageStore;
1: import org.apache.activemq.store.TransactionStore;
1: import org.apache.activemq.store.jdbc.JDBCPersistenceAdapter;
1: import org.apache.activemq.store.journal.JournalTransactionStore.Tx;
1: import org.apache.activemq.store.journal.JournalTransactionStore.TxOperation;
1: import org.apache.activemq.thread.Scheduler;
1: import org.apache.activemq.thread.Task;
1: import org.apache.activemq.thread.TaskRunner;
1: import org.apache.activemq.thread.TaskRunnerFactory;
1: import org.apache.activemq.util.IOExceptionSupport;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.Callable;
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
0: import edu.emory.mathcs.backport.java.util.concurrent.CountDownLatch;
0: import edu.emory.mathcs.backport.java.util.concurrent.FutureTask;
0: import edu.emory.mathcs.backport.java.util.concurrent.LinkedBlockingQueue;
0: import edu.emory.mathcs.backport.java.util.concurrent.ThreadFactory;
0: import edu.emory.mathcs.backport.java.util.concurrent.ThreadPoolExecutor;
0: import edu.emory.mathcs.backport.java.util.concurrent.TimeUnit;
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean;
1: 
1: /**
1:  * An implementation of {@link PersistenceAdapter} designed for use with a
1:  * {@link Journal} and then check pointing asynchronously on a timeout with some
1:  * other long term persistent storage.
1:  * 
0:  * @org.xbean.XBean
1:  * 
0:  * @version $Revision: 1.17 $
1:  */
0: public class JournalPersistenceAdapter implements PersistenceAdapter, JournalEventListener, UsageListener {
1: 
0:     private static final Log log = LogFactory.getLog(JournalPersistenceAdapter.class);
1: 
0:     private final Journal journal;
0:     private final PersistenceAdapter longTermPersistence;
0:     final UsageManager usageManager;
1: 
0:     private final WireFormat wireFormat = new OpenWireFormat(false);
1: 
0:     private final ConcurrentHashMap queues = new ConcurrentHashMap();
0:     private final ConcurrentHashMap topics = new ConcurrentHashMap();
1:     
0:     private long checkpointInterval = 1000 * 60 * 5;
0:     private long lastCheckpointRequest = System.currentTimeMillis();
1:     private long lastCleanup = System.currentTimeMillis();
1:     private int maxCheckpointWorkers = 10;
0:     private int maxCheckpointMessageAddSize = 1024*1024;
1: 
0:     private JournalTransactionStore transactionStore = new JournalTransactionStore(this);
1:     private ThreadPoolExecutor checkpointExecutor;
1:     
1:     private TaskRunner checkpointTask;
1:     private CountDownLatch nextCheckpointCountDownLatch = new CountDownLatch(1);
1:     private boolean fullCheckPoint;
1:     
0:     private AtomicBoolean started = new AtomicBoolean(false);
1: 
0:     private final Runnable periodicCheckpointTask = new Runnable() {
0:         public void run() {
0:             if( System.currentTimeMillis()>lastCheckpointRequest+checkpointInterval ) {
0:                 checkpoint(false, true);
1:             }
1:         }
0:     };
1:     
0:     public JournalPersistenceAdapter(Journal journal, PersistenceAdapter longTermPersistence, UsageManager memManager, TaskRunnerFactory taskRunnerFactory) throws IOException {
1: 
1:         this.journal = journal;
1:         journal.setJournalEventListener(this);
1:         
0:         checkpointTask = taskRunnerFactory.createTaskRunner(new Task(){
1:             public boolean iterate() {
1:                 return doCheckpoint();
1:             }
1:         });
1: 
1:         this.longTermPersistence = longTermPersistence;
0:         this.usageManager = memManager;
1:     }
1: 
0:     public Set getDestinations() {
0:         Set destinations = longTermPersistence.getDestinations();
1:         destinations.addAll(queues.keySet());
1:         destinations.addAll(topics.keySet());
1:         return destinations;
1:     }
1: 
1:     private MessageStore createMessageStore(ActiveMQDestination destination) throws IOException {
1:         if (destination.isQueue()) {
0:             return createQueueMessageStore((ActiveMQQueue) destination);
1:         }
0:         else {
0:             return createTopicMessageStore((ActiveMQTopic) destination);
1:         }
1:     }
1: 
1:     public MessageStore createQueueMessageStore(ActiveMQQueue destination) throws IOException {
0:         JournalMessageStore store = (JournalMessageStore) queues.get(destination);
1:         if (store == null) {
1:             MessageStore checkpointStore = longTermPersistence.createQueueMessageStore(destination);
1:             store = new JournalMessageStore(this, checkpointStore, destination);
1:             queues.put(destination, store);
1:         }
1:         return store;
1:     }
1: 
1:     public TopicMessageStore createTopicMessageStore(ActiveMQTopic destinationName) throws IOException {
0:         JournalTopicMessageStore store = (JournalTopicMessageStore) topics.get(destinationName);
1:         if (store == null) {
1:             TopicMessageStore checkpointStore = longTermPersistence.createTopicMessageStore(destinationName);
1:             store = new JournalTopicMessageStore(this, checkpointStore, destinationName);
1:             topics.put(destinationName, store);
1:         }
1:         return store;
1:     }
1: 
1:     public TransactionStore createTransactionStore() throws IOException {
1:         return transactionStore;
1:     }
1: 
1:     public long getLastMessageBrokerSequenceId() throws IOException {
1:         return longTermPersistence.getLastMessageBrokerSequenceId();
1:     }
1: 
1:     public void beginTransaction(ConnectionContext context) throws IOException {
1:         longTermPersistence.beginTransaction(context);
1:     }
1: 
1:     public void commitTransaction(ConnectionContext context) throws IOException {
1:         longTermPersistence.commitTransaction(context);
1:     }
1: 
1:     public void rollbackTransaction(ConnectionContext context) throws IOException {
1:         longTermPersistence.rollbackTransaction(context);
1:     }
1: 
1:     public synchronized void start() throws Exception {
0:         if( !started.compareAndSet(false, true) )
1:             return;
1:         
0:         longTermPersistence.setUseExternalMessageReferences(false);
1: 
0:         checkpointExecutor = new ThreadPoolExecutor(maxCheckpointWorkers, maxCheckpointWorkers, 30, TimeUnit.SECONDS, new LinkedBlockingQueue(), new ThreadFactory() {
1:             public Thread newThread(Runnable runable) {
1:                 Thread t = new Thread(runable, "Journal checkpoint worker");
1:                 t.setPriority(7);
1:                 return t;
1:             }            
1:         });
0:         checkpointExecutor.allowCoreThreadTimeOut(true);
1:         
0:         this.usageManager.addUsageListener(this);
1: 
1:         if (longTermPersistence instanceof JDBCPersistenceAdapter) {
1:             // Disabled periodic clean up as it deadlocks with the checkpoint
1:             // operations.
0:             ((JDBCPersistenceAdapter) longTermPersistence).setCleanupPeriod(0);
1:         }
1: 
1:         longTermPersistence.start();
1:         createTransactionStore();
1:         recover();
1: 
1:         // Do a checkpoint periodically.
0:         Scheduler.executePeriodically(periodicCheckpointTask, checkpointInterval/10);
1: 
1:     }
1: 
1:     public void stop() throws Exception {
1:         
0:         if( !started.compareAndSet(true, false) )
1:             return;
1:         
0:         Scheduler.cancel(periodicCheckpointTask);
1: 
1:         // Take one final checkpoint and stop checkpoint processing.
0:         checkpoint(false, true);
0:         checkpointTask.shutdown();        
0:         checkpointExecutor.shutdown();
1:         
1:         queues.clear();
1:         topics.clear();
1: 
1:         IOException firstException = null;
1:         try {
1:             journal.close();
1:         } catch (Exception e) {
1:             firstException = IOExceptionSupport.create("Failed to close journals: " + e, e);
1:         }
1:         longTermPersistence.stop();
1:         
1:         if (firstException != null) {
1:             throw firstException;
1:         }
1:     }
1: 
1:     // Properties
1:     // -------------------------------------------------------------------------
1:     public PersistenceAdapter getLongTermPersistence() {
1:         return longTermPersistence;
1:     }
1: 
1:     /**
1:      * @return Returns the wireFormat.
1:      */
1:     public WireFormat getWireFormat() {
1:         return wireFormat;
1:     }
1: 
1:     // Implementation methods
1:     // -------------------------------------------------------------------------
1: 
1:     /**
1:      * The Journal give us a call back so that we can move old data out of the
1:      * journal. Taking a checkpoint does this for us.
1:      * 
1:      * @see org.apache.activemq.journal.JournalEventListener#overflowNotification(org.apache.activemq.journal.RecordLocation)
1:      */
1:     public void overflowNotification(RecordLocation safeLocation) {
0:         checkpoint(false, true);
1:     }
1: 
1:     /**
1:      * When we checkpoint we move all the journalled data to long term storage.
0:      * @param stopping 
1:      * 
0:      * @param b
1:      */
1:     public void checkpoint(boolean sync, boolean fullCheckpoint) {
1:         try {
0:             if (journal == null )
1:                 throw new IllegalStateException("Journal is closed.");
1:             
1:             long now = System.currentTimeMillis();
1:             CountDownLatch latch = null;
0:             synchronized(this) {
1:                 latch = nextCheckpointCountDownLatch;
1:                 lastCheckpointRequest = now;
0:                 if( fullCheckpoint ) {
0:                     this.fullCheckPoint = true; 
1:                 }
1:             }
1:             
1:             checkpointTask.wakeup();
1:             
1:             if (sync) {
0:                 log.debug("Waking for checkpoint to complete.");
1:                 latch.await();
1:             }
1:         }
0:         catch (InterruptedException e) {
0:             log.warn("Request to start checkpoint failed: " + e, e);
1:         }
1:     }
1:         
1:     /**
1:      * This does the actual checkpoint.
1:      * @return 
1:      */
1:     public boolean doCheckpoint() {
1:         CountDownLatch latch = null;
1:         boolean fullCheckpoint;
0:         synchronized(this) {                       
1:             latch = nextCheckpointCountDownLatch;
1:             nextCheckpointCountDownLatch = new CountDownLatch(1);
1:             fullCheckpoint = this.fullCheckPoint;
0:             this.fullCheckPoint=false;            
1:         }        
1:         try {
1: 
0:             log.debug("Checkpoint started.");
1:             RecordLocation newMark = null;
1: 
0:             ArrayList futureTasks = new ArrayList(queues.size()+topics.size());
1:             
1:             //
0:             // We do many partial checkpoints (fullCheckpoint==false) to move topic messages
0:             // to long term store as soon as possible.  
1:             // 
0:             // We want to avoid doing that for queue messages since removes the come in the same
0:             // checkpoint cycle will nullify the previous message add.  Therefore, we only
1:             // checkpoint queues on the fullCheckpoint cycles.
1:             //
0:             if( fullCheckpoint ) {                
0:                 Iterator iterator = queues.values().iterator();
1:                 while (iterator.hasNext()) {
1:                     try {
0:                         final JournalMessageStore ms = (JournalMessageStore) iterator.next();
0:                         FutureTask task = new FutureTask(new Callable() {
0:                             public Object call() throws Exception {
1:                                 return ms.checkpoint();
0:                             }});
1:                         futureTasks.add(task);
0:                         checkpointExecutor.execute(task);                        
1:                     }
0:                     catch (Exception e) {
0:                         log.error("Failed to checkpoint a message store: " + e, e);
1:                     }
1:                 }
1:             }
1: 
0:             Iterator iterator = topics.values().iterator();
1:             while (iterator.hasNext()) {
1:                 try {
0:                     final JournalTopicMessageStore ms = (JournalTopicMessageStore) iterator.next();
0:                     FutureTask task = new FutureTask(new Callable() {
0:                         public Object call() throws Exception {
1:                             return ms.checkpoint();
0:                         }});
1:                     futureTasks.add(task);
0:                     checkpointExecutor.execute(task);                        
1:                 }
0:                 catch (Exception e) {
0:                     log.error("Failed to checkpoint a message store: " + e, e);
1:                 }
1:             }
1: 
1:             try {
0:                 for (Iterator iter = futureTasks.iterator(); iter.hasNext();) {
0:                     FutureTask ft = (FutureTask) iter.next();
0:                     RecordLocation mark = (RecordLocation) ft.get();
1:                     // We only set a newMark on full checkpoints.
0:                     if( fullCheckpoint ) {
1:                         if (mark != null && (newMark == null || newMark.compareTo(mark) < 0)) {
1:                             newMark = mark;
1:                         }
1:                     }
1:                 }
1:             } catch (Throwable e) {
0:                 log.error("Failed to checkpoint a message store: " + e, e);
1:             }
1:             
1: 
0:             if( fullCheckpoint ) {
1:                 try {
1:                     if (newMark != null) {
0:                         log.debug("Marking journal at: " + newMark);
1:                         journal.setMark(newMark, true);
1:                     }
1:                 }
0:                 catch (Exception e) {
0:                     log.error("Failed to mark the Journal: " + e, e);
1:                 }
1:     
1:                 if (longTermPersistence instanceof JDBCPersistenceAdapter) {
0:                     // We may be check pointing more often than the checkpointInterval if under high use
1:                     // But we don't want to clean up the db that often.
1:                     long now = System.currentTimeMillis();
0:                     if( now > lastCleanup+checkpointInterval ) {
1:                         lastCleanup = now;
0:                         ((JDBCPersistenceAdapter) longTermPersistence).cleanup();
1:                     }
1:                 }
1:             }
1: 
0:             log.debug("Checkpoint done.");
1:         }
0:         finally {
1:             latch.countDown();
1:         }
0:         synchronized(this) {
1:             return this.fullCheckPoint;
1:         }        
1: 
1:     }
1: 
1:     /**
1:      * @param location
1:      * @return
1:      * @throws IOException
1:      */
1:     public DataStructure readCommand(RecordLocation location) throws IOException {
1:         try {
0:             org.activeio.Packet data = journal.read(location);
0:             return (DataStructure) wireFormat.unmarshal(data);
1:         }
0:         catch (InvalidRecordLocationException e) {
1:             throw createReadException(location, e);
1:         }
0:         catch (IOException e) {
1:             throw createReadException(location, e);
1:         }
1:     }
1: 
1:     /**
1:      * Move all the messages that were in the journal into long term storage. We
1:      * just replay and do a checkpoint.
1:      * 
1:      * @throws IOException
1:      * @throws IOException
1:      * @throws InvalidRecordLocationException
1:      * @throws IllegalStateException
1:      */
1:     private void recover() throws IllegalStateException, InvalidRecordLocationException, IOException, IOException {
1: 
1:         RecordLocation pos = null;
1:         int transactionCounter = 0;
1: 
0:         log.info("Journal Recovery Started from: " + journal);
0:         ConnectionContext context = new ConnectionContext();
1: 
1:         // While we have records in the journal.
1:         while ((pos = journal.getNextRecordLocation(pos)) != null) {
0:             org.activeio.Packet data = journal.read(pos);
0:             DataStructure c = (DataStructure) wireFormat.unmarshal(data);
1: 
0:             if (c instanceof Message ) {
0:                 Message message = (Message) c;
0:                 JournalMessageStore store = (JournalMessageStore) createMessageStore(message.getDestination());
0:                 if ( message.isInTransaction()) {
1:                     transactionStore.addMessage(store, message, pos);
1:                 }
0:                 else {
1:                     store.replayAddMessage(context, message);
1:                     transactionCounter++;
1:                 }
1:             } else {
1:                 switch (c.getDataStructureType()) {
0:                 case JournalQueueAck.DATA_STRUCTURE_TYPE:
0:                 {
0:                     JournalQueueAck command = (JournalQueueAck) c;
0:                     JournalMessageStore store = (JournalMessageStore) createMessageStore(command.getDestination());
1:                     if (command.getMessageAck().isInTransaction()) {
1:                         transactionStore.removeMessage(store, command.getMessageAck(), pos);
1:                     }
0:                     else {
1:                         store.replayRemoveMessage(context, command.getMessageAck());
1:                         transactionCounter++;
1:                     }
1:                 }
1:                 break;
0:                 case JournalTopicAck.DATA_STRUCTURE_TYPE: 
0:                 {
0:                     JournalTopicAck command = (JournalTopicAck) c;
0:                     JournalTopicMessageStore store = (JournalTopicMessageStore) createMessageStore(command.getDestination());
1:                     if (command.getTransactionId() != null) {
1:                         transactionStore.acknowledge(store, command, pos);
1:                     }
0:                     else {
1:                         store.replayAcknowledge(context, command.getClientId(), command.getSubscritionName(), command.getMessageId());
1:                         transactionCounter++;
1:                     }
1:                 }
1:                 break;
0:                 case JournalTransaction.DATA_STRUCTURE_TYPE:
0:                 {
0:                     JournalTransaction command = (JournalTransaction) c;
1:                     try {
1:                         // Try to replay the packet.
1:                         switch (command.getType()) {
1:                         case JournalTransaction.XA_PREPARE:
1:                             transactionStore.replayPrepare(command.getTransactionId());
1:                             break;
1:                         case JournalTransaction.XA_COMMIT:
1:                         case JournalTransaction.LOCAL_COMMIT:
1:                             Tx tx = transactionStore.replayCommit(command.getTransactionId(), command.getWasPrepared());
0:                             if (tx == null)
0:                                 break; // We may be trying to replay a commit that
0:                                         // was already committed.
1: 
1:                             // Replay the committed operations.
1:                             tx.getOperations();
1:                             for (Iterator iter = tx.getOperations().iterator(); iter.hasNext();) {
0:                                 TxOperation op = (TxOperation) iter.next();
1:                                 if (op.operationType == TxOperation.ADD_OPERATION_TYPE) {
0:                                     op.store.replayAddMessage(context, (Message) op.data);
1:                                 }
1:                                 if (op.operationType == TxOperation.REMOVE_OPERATION_TYPE) {
0:                                     op.store.replayRemoveMessage(context, (MessageAck) op.data);
1:                                 }
1:                                 if (op.operationType == TxOperation.ACK_OPERATION_TYPE) {
0:                                     JournalTopicAck ack = (JournalTopicAck) op.data;
0:                                     ((JournalTopicMessageStore) op.store).replayAcknowledge(context, ack.getClientId(), ack.getSubscritionName(), ack
0:                                             .getMessageId());
1:                                 }
1:                             }
1:                             transactionCounter++;
1:                             break;
1:                         case JournalTransaction.LOCAL_ROLLBACK:
1:                         case JournalTransaction.XA_ROLLBACK:
1:                             transactionStore.replayRollback(command.getTransactionId());
1:                             break;
1:                         }
1:                     }
0:                     catch (IOException e) {
0:                         log.error("Recovery Failure: Could not replay: " + c + ", reason: " + e, e);
1:                     }
1:                 }
1:                 break;
1:                 case JournalTrace.DATA_STRUCTURE_TYPE:
0:                     JournalTrace trace = (JournalTrace) c;
0:                     log.debug("TRACE Entry: " + trace.getMessage());
1:                     break;
1:                 default:
0:                     log.error("Unknown type of record in transaction log which will be discarded: " + c);
1:                 }
1:             }
1:         }
1: 
1:         RecordLocation location = writeTraceMessage("RECOVERED", true);
1:         journal.setMark(location, true);
1: 
0:         log.info("Journal Recovered: " + transactionCounter + " message(s) in transactions recovered.");
1:     }
1: 
1:     private IOException createReadException(RecordLocation location, Exception e) {
1:         return IOExceptionSupport.create("Failed to read to journal for: " + location + ". Reason: " + e, e);
1:     }
1: 
1:     protected IOException createWriteException(DataStructure packet, Exception e) {
1:         return IOExceptionSupport.create("Failed to write to journal for: " + packet + ". Reason: " + e, e);
1:     }
1: 
1:     protected IOException createWriteException(String command, Exception e) {
1:         return IOExceptionSupport.create("Failed to write to journal for command: " + command + ". Reason: " + e, e);
1:     }
1: 
1:     protected IOException createRecoveryFailedException(Exception e) {
1:         return IOExceptionSupport.create("Failed to recover from journal. Reason: " + e, e);
1:     }
1: 
1:     /**
1:      * 
1:      * @param command
1:      * @param sync
1:      * @return
1:      * @throws IOException
1:      */
1:     public RecordLocation writeCommand(DataStructure command, boolean sync) throws IOException {
0:         if( started.get() )
0:             return journal.write(wireFormat.marshal(command), sync);
1:         throw new IOException("closed");
1:     }
1: 
1:     private RecordLocation writeTraceMessage(String message, boolean sync) throws IOException {
1:         JournalTrace trace = new JournalTrace();
1:         trace.setMessage(message);
1:         return writeCommand(trace, sync);
1:     }
1: 
0:     public void onMemoryUseChanged(UsageManager memoryManager, int oldPercentUsage, int newPercentUsage) {
0:         if (newPercentUsage > 80 && oldPercentUsage < newPercentUsage) {
0:             checkpoint(false, true);
1:         }
1:     }
1: 
1:     public JournalTransactionStore getTransactionStore() {
1:         return transactionStore;
1:     }
1: 
0:     public void deleteAllMessages() throws IOException {        
1:         try {
1:             JournalTrace trace = new JournalTrace();
1:             trace.setMessage("DELETED");
0:             RecordLocation location = journal.write(wireFormat.marshal(trace), false);
1:             journal.setMark(location, true);
0:             log.info("Journal deleted: ");
1:         } catch (IOException e) {
1:             throw e;
1:         } catch (Throwable e) {
1:             throw IOExceptionSupport.create(e);
1:         }
0:         longTermPersistence.setUseExternalMessageReferences(false);
1:         longTermPersistence.deleteAllMessages();
1:     }
1: 
0:     public UsageManager getUsageManager() {
1:         return usageManager;
1:     }
1: 
1:     public int getMaxCheckpointMessageAddSize() {
1:         return maxCheckpointMessageAddSize;
1:     }
1: 
1:     public void setMaxCheckpointMessageAddSize(int maxCheckpointMessageAddSize) {
1:         this.maxCheckpointMessageAddSize = maxCheckpointMessageAddSize;
1:     }
1: 
1:     public int getMaxCheckpointWorkers() {
1:         return maxCheckpointWorkers;
1:     }
1: 
1:     public void setMaxCheckpointWorkers(int maxCheckpointWorkers) {
1:         this.maxCheckpointWorkers = maxCheckpointWorkers;
1:     }
1: 
1:     public boolean isUseExternalMessageReferences() {
1:         return false;
1:     }
1: 
1:     public void setUseExternalMessageReferences(boolean enable) {
0:         if( enable )
1:             throw new IllegalArgumentException("The journal does not support message references.");
1:     }
1: 
1: }
author:Robert Davies
-------------------------------------------------------------------------------
commit:dbc661f
/////////////////////////////////////////////////////////////////////////
1:     private File directory;
/////////////////////////////////////////////////////////////////////////
1:         this.directory=dir;
0:     }
0:     
1:     public File getDirectory(){
1:         return directory;
commit:1a5ad28
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.SystemUsage;
/////////////////////////////////////////////////////////////////////////
1:     protected Scheduler scheduler;
/////////////////////////////////////////////////////////////////////////
0:     private final long checkpointInterval = 1000 * 60 * 5;
1:     private final JournalTransactionStore transactionStore = new JournalTransactionStore(this);
1:     private final AtomicBoolean started = new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
1:         this.scheduler = new Scheduler("Journal Scheduler");
1:         this.scheduler.start();
1:         this.scheduler.executePeriodically(periodicCheckpointTask, checkpointInterval / 10);
/////////////////////////////////////////////////////////////////////////
1:         this.scheduler.cancel(periodicCheckpointTask);
1:         this.scheduler.stop();
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:3b0afd6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.filter.NonCachedMessageEvaluationContext;
/////////////////////////////////////////////////////////////////////////
1:         ConnectionContext context = new ConnectionContext(new NonCachedMessageEvaluationContext());
commit:6d8e2c5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.Usage;
1: import org.apache.activemq.usage.UsageListener;
0: import org.apache.activemq.usage.SystemUsage;
/////////////////////////////////////////////////////////////////////////
1:     private SystemUsage usageManager;
/////////////////////////////////////////////////////////////////////////
1:     public void setUsageManager(SystemUsage usageManager) {
/////////////////////////////////////////////////////////////////////////
1:         this.usageManager.getMemoryUsage().addUsageListener(this);
/////////////////////////////////////////////////////////////////////////
1:         this.usageManager.getMemoryUsage().removeUsageListener(this);
/////////////////////////////////////////////////////////////////////////
1:     public void onUsageChanged(Usage usage, int oldPercentUsage, int newPercentUsage) {
/////////////////////////////////////////////////////////////////////////
1:     public SystemUsage getUsageManager() {
/////////////////////////////////////////////////////////////////////////
0:     
1:     public long size(){
1:         return 0;
0:     }
commit:a3e3821
/////////////////////////////////////////////////////////////////////////
0:     long checkpointInterval = 1000 * 60 * 5;
0:     long lastCheckpointRequest = System.currentTimeMillis();
/////////////////////////////////////////////////////////////////////////
0:                 long lastTime = 0;
0:                 synchronized(this) {
0:                     lastTime = lastCheckpointRequest;
0:                 }
0: 	            if( System.currentTimeMillis()>lastTime+checkpointInterval ) {
commit:759fd28
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
/////////////////////////////////////////////////////////////////////////
0:     
1:     public void checkpoint(boolean sync) {
0:         checkpoint(sync,sync);
0:     }
/////////////////////////////////////////////////////////////////////////
0:     public void setBrokerName(String brokerName){
1:         longTermPersistence.setBrokerName(brokerName);
0:     }
0:     
0:     public void setDirectory(File dir){        
0:     }
0: 
commit:415d46c
/////////////////////////////////////////////////////////////////////////
0:     
0:     public String toString(){
0:         return "JournalPersistenceAdapator(" + longTermPersistence + ")";
0:     }
commit:4eef609
/////////////////////////////////////////////////////////////////////////
0:         newPercentUsage = ((newPercentUsage)/10)*10;
0:         oldPercentUsage = ((oldPercentUsage)/10)*10;
1:         if (newPercentUsage >= 70 && oldPercentUsage < newPercentUsage) {
1:             boolean sync = newPercentUsage >= 90;
1:             checkpoint(sync, true);
0:     
author:Gary Tully
-------------------------------------------------------------------------------
commit:c42d8de
/////////////////////////////////////////////////////////////////////////
commit:a6a6a70
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ProducerId;
/////////////////////////////////////////////////////////////////////////
1:     public long getLastProducerSequenceId(ProducerId id) {
1:         return -1;
0:     }
0: 
commit:77116d4
/////////////////////////////////////////////////////////////////////////
0:     public JournalPersistenceAdapter() {        
0:     }
0:     
commit:d3fb1aa
/////////////////////////////////////////////////////////////////////////
1:     private Journal journal;
1:     private PersistenceAdapter longTermPersistence;
/////////////////////////////////////////////////////////////////////////
1:     private TaskRunnerFactory taskRunnerFactory;
0: 
1:         setJournal(journal);
1:         setTaskRunnerFactory(taskRunnerFactory);
1:         setPersistenceAdapter(longTermPersistence);
1:     public void setTaskRunnerFactory(TaskRunnerFactory taskRunnerFactory) {
1:         this.taskRunnerFactory = taskRunnerFactory;
0:     }
0: 
1:     public void setJournal(Journal journal) {
0:         this.journal = journal;
0:         journal.setJournalEventListener(this);
0:     }
0:     
1:     public void setPersistenceAdapter(PersistenceAdapter longTermPersistence) {
0:         this.longTermPersistence = longTermPersistence;
0:     }
0:     
/////////////////////////////////////////////////////////////////////////
0:         checkpointTask = taskRunnerFactory.createTaskRunner(new Task() {
0:             public boolean iterate() {
0:                 return doCheckpoint();
0:             }
0:         }, "ActiveMQ Journal Checkpoint Worker");
0: 
commit:2b2b35e
/////////////////////////////////////////////////////////////////////////
0:     protected static final Scheduler scheduler = Scheduler.getInstance();
/////////////////////////////////////////////////////////////////////////
0:         scheduler.executePeriodically(periodicCheckpointTask, checkpointInterval / 10);
/////////////////////////////////////////////////////////////////////////
0:         scheduler.cancel(periodicCheckpointTask);
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(JournalPersistenceAdapter.class);
commit:e8a641c
/////////////////////////////////////////////////////////////////////////
0:         	    brokerService.handleIOException(ioe);
/////////////////////////////////////////////////////////////////////////
commit:b1a9130
/////////////////////////////////////////////////////////////////////////
0:     	            LOG.warn("Failure occured while stopping broker", e);
commit:27cbf7b
/////////////////////////////////////////////////////////////////////////
1:     private BrokerService brokerService;
0: 	
/////////////////////////////////////////////////////////////////////////
1:             try {
0:         	    return journal.write(toPacket(wireFormat.marshal(command)), sync);
1:             } catch (IOException ioe) {
0:         	    LOG.error("Cannot write to the journal", ioe);
0:         	    stopBroker();
0:         	    throw ioe;
0:             }
/////////////////////////////////////////////////////////////////////////
1:         this.brokerService = brokerService;
0:     
0:     protected void stopBroker() {
0:         new Thread() {
0:            public void run() {
0:         	   try {
0:     	            brokerService.stop();
0:     	        } catch (Exception e) {
0:     	            LOG.warn("Failure occured while stopping broker");
0:     	        }    			
0:     		}
0:     	}.start();
0:     }
author:David Jencks
-------------------------------------------------------------------------------
commit:07b6a38
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Cleanup method to remove any state associated with the given destination
0:      *
1:      * @param destination Destination to forget
1:      */
1:     public void removeQueueMessageStore(ActiveMQQueue destination) {
1:         queues.remove(destination);
0:     }
0: 
1:     /**
1:      * Cleanup method to remove any state associated with the given destination
0:      *
1:      * @param destination Destination to forget
1:      */
1:     public void removeTopicMessageStore(ActiveMQTopic destination) {
1:         topics.remove(destination);
0:     }
0: 
============================================================================