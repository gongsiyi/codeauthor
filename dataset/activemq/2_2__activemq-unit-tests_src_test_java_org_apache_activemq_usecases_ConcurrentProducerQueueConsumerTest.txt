1:1638801: /**
1:1638801:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:1638801:  * contributor license agreements.  See the NOTICE file distributed with
1:1638801:  * this work for additional information regarding copyright ownership.
1:1638801:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:1638801:  * (the "License"); you may not use this file except in compliance with
1:1638801:  * the License.  You may obtain a copy of the License at
1:1638801:  *
1:1638801:  *      http://www.apache.org/licenses/LICENSE-2.0
1:1638801:  *
1:1638801:  * Unless required by applicable law or agreed to in writing, software
1:1638801:  * distributed under the License is distributed on an "AS IS" BASIS,
1:1638801:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:1638801:  * See the License for the specific language governing permissions and
1:1638801:  * limitations under the License.
1:1638801:  */
1:1638801: package org.apache.activemq.usecases;
1:1638801: 
1:1638801: import java.util.ArrayList;
1:1638801: import java.util.Arrays;
1:1638801: import java.util.Collections;
1:1638801: import java.util.HashMap;
1:1638801: import java.util.Iterator;
1:1638801: import java.util.List;
1:1638801: import java.util.Map;
1:1638801: import java.util.concurrent.ConcurrentHashMap;
1:1638801: import java.util.concurrent.CountDownLatch;
1:1638801: import java.util.concurrent.Executors;
1:1638801: import java.util.concurrent.ThreadFactory;
1:1638801: import java.util.concurrent.TimeUnit;
1:1638801: import java.util.concurrent.atomic.AtomicLong;
1:1638801: 
1:1638801: import javax.jms.Connection;
1:1638801: import javax.jms.ConnectionFactory;
1:1638801: import javax.jms.DeliveryMode;
1:1638801: import javax.jms.Destination;
1:1638801: import javax.jms.JMSException;
1:1638801: import javax.jms.Message;
1:1638801: import javax.jms.MessageConsumer;
1:1638801: import javax.jms.MessageListener;
1:1638801: import javax.jms.MessageProducer;
1:1638801: import javax.jms.Session;
1:1638801: import javax.jms.TextMessage;
1:1638801: 
1:1638801: import junit.framework.Test;
1:1638801: 
1:1638801: import org.apache.activemq.ActiveMQConnectionFactory;
1:1638801: import org.apache.activemq.ActiveMQPrefetchPolicy;
1:1638801: import org.apache.activemq.TestSupport;
1:1638801: import org.apache.activemq.broker.BrokerService;
1:1638801: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:1638801: import org.apache.activemq.broker.region.policy.PolicyMap;
1:1638801: import org.apache.activemq.util.MessageIdList;
1:1638801: import org.apache.activemq.util.Wait;
1:1638801: import org.slf4j.Logger;
1:1638801: import org.slf4j.LoggerFactory;
1:1638801: 
1:1638801: public class ConcurrentProducerQueueConsumerTest extends TestSupport
1:1638801: {
1:1638801:     private static final Logger LOG = LoggerFactory.getLogger(ConcurrentProducerQueueConsumerTest.class);
1:1638801: 
1:1638801:     protected List<Connection> connections = Collections.synchronizedList(new ArrayList<Connection>());
1:1638801:     protected Map<MessageConsumer, TimedMessageListener> consumers =
1:1638801:         new HashMap<MessageConsumer, TimedMessageListener>();
1:1638801:     protected MessageIdList allMessagesList = new MessageIdList();
1:1638801: 
1:1638801:     private BrokerService broker;
1:1638801:     private final int consumerCount = 5;
1:1638801:     private final int messageSize = 1024;
1:1638801:     private final int NUM_MESSAGES = 500;
1:1638801:     private final int ITERATIONS = 10;
1:1638801: 
1:1638801:     private int expectedQueueDeliveries = 0;
1:1638801: 
1:1638801:     public void initCombosForTestSendRateWithActivatingConsumers() throws Exception {
1:1638801:         addCombinationValues("defaultPersistenceAdapter",
1:77a679b:                 new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB,
1:1638801:                              /* too slow for hudson - PersistenceAdapterChoice.JDBC,*/
1:1638801:                              PersistenceAdapterChoice.MEM});
1:1638801:     }
1:1638801: 
1:1638801:     public void testSendRateWithActivatingConsumers() throws Exception {
1:1638801:         final Destination destination = createDestination();
1:1638801:         final ConnectionFactory factory = createConnectionFactory();
1:1638801: 
1:1638801:         Connection connection = factory.createConnection();
1:1638801:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:1638801:         MessageProducer producer = createMessageProducer(session, destination);
1:1638801: 
1:1638801:         // preload the queue before adding any consumers
1:1638801:         double[] noConsumerStats = produceMessages(destination, NUM_MESSAGES, ITERATIONS, session, producer, null);
1:1638801:         LOG.info("With no consumers: ave: " + noConsumerStats[1] + ", max: " +
1:1638801:                  noConsumerStats[0] + ", multiplier: " + (noConsumerStats[0]/noConsumerStats[1]));
1:1638801:         expectedQueueDeliveries = NUM_MESSAGES * ITERATIONS;
1:1638801: 
1:1638801:         // periodically start a queue consumer
1:1638801:         final int consumersToActivate = 5;
1:1638801:         final Object addConsumerSignal = new Object();
1:1638801:         Executors.newCachedThreadPool(new ThreadFactory() {
1:1638801:             @Override
1:1638801:             public Thread newThread(Runnable r) {
1:1638801:                 return new Thread(r, "ActivateConsumer" + this);
1:1638801:             }
1:1638801:         }).execute(new Runnable() {
1:1638801:             @Override
1:1638801:             public void run() {
1:1638801:                 try {
1:1638801:                     MessageConsumer consumer = null;
1:1638801:                     for (int i = 0; i < consumersToActivate; i++) {
1:1638801:                         LOG.info("Waiting for add signal from producer...");
1:1638801:                         synchronized (addConsumerSignal) {
1:1638801:                             addConsumerSignal.wait(30 * 60 * 1000);
1:1638801:                         }
1:1638801:                         TimedMessageListener listener = new TimedMessageListener();
1:1638801:                         consumer = createConsumer(factory.createConnection(), destination);
1:1638801:                         LOG.info("Created consumer " + consumer);
1:1638801:                         consumer.setMessageListener(listener);
1:1638801:                         consumers.put(consumer, listener);
1:1638801:                     }
1:1638801:                 } catch (Exception e) {
1:1638801:                     LOG.error("failed to start consumer", e);
1:1638801:                 }
1:1638801:             }
1:1638801:         });
1:1638801: 
1:1638801:         // Collect statistics when there are active consumers.
1:1638801:         double[] statsWithActive =
1:1638801:             produceMessages(destination, NUM_MESSAGES, ITERATIONS, session, producer, addConsumerSignal);
1:1638801:         expectedQueueDeliveries += NUM_MESSAGES * ITERATIONS;
1:1638801: 
1:1638801:         LOG.info(" with concurrent activate, ave: " + statsWithActive[1] + ", max: " +
1:1638801:                  statsWithActive[0] + ", multiplier: " + (statsWithActive[0]/ statsWithActive[1]));
1:1638801: 
1:1638801:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:1638801:             @Override
1:1638801:             public boolean isSatisified() throws Exception {
1:1638801:                 return consumers.size() == consumersToActivate;
1:1638801:             }
1:1638801:         }));
1:1638801: 
1:1638801:         long timeToFirstAccumulator = 0;
1:1638801:         for (TimedMessageListener listener : consumers.values()) {
1:1638801:             long time = listener.getFirstReceipt();
1:1638801:             timeToFirstAccumulator += time;
1:1638801:             LOG.info("Time to first " + time);
1:1638801:         }
1:1638801:         LOG.info("Ave time to first message =" + timeToFirstAccumulator/consumers.size());
1:1638801: 
1:1638801:         for (TimedMessageListener listener : consumers.values()) {
1:1638801:             LOG.info("Ave batch receipt time: " + listener.waitForReceivedLimit(expectedQueueDeliveries) +
1:1638801:                      " max receipt: " + listener.maxReceiptTime);
1:1638801:         }
1:1638801: 
1:1638801:         // compare no active to active
1:1638801:         LOG.info("Ave send time with active: " + statsWithActive[1]
1:1638801:                 + " as multiplier of ave with none active: " + noConsumerStats[1]
1:1638801:                 + ", multiplier=" + (statsWithActive[1]/noConsumerStats[1]));
1:1638801: 
1:1638801:         assertTrue("Ave send time with active: " + statsWithActive[1]
1:1638801:                 + " within reasonable multpler of ave with none active: " + noConsumerStats[1]
1:1638801:                 + ", multiplier " + (statsWithActive[1]/noConsumerStats[1]),
1:1638801:                 statsWithActive[1] < 15 * noConsumerStats[1]);
1:1638801:     }
1:1638801: 
1:1638801:     public void x_initCombosForTestSendWithInactiveAndActiveConsumers() throws Exception {
1:1638801:         addCombinationValues("defaultPersistenceAdapter",
1:77a679b:                 new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB,
1:1638801:                              /* too slow for hudson - PersistenceAdapterChoice.JDBC,*/
1:1638801:                              PersistenceAdapterChoice.MEM});
1:1638801:     }
1:1638801: 
1:1638801:     public void x_testSendWithInactiveAndActiveConsumers() throws Exception {
1:1638801:         Destination destination = createDestination();
1:1638801:         ConnectionFactory factory = createConnectionFactory();
1:1638801: 
1:1638801:         Connection connection = factory.createConnection();
1:1638801:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:1638801:         MessageProducer producer = session.createProducer(destination);
1:1638801:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:1638801: 
1:1638801:         final int toSend = 100;
1:1638801:         final int numIterations = 5;
1:1638801: 
1:1638801:         double[] noConsumerStats = produceMessages(destination, toSend, numIterations, session, producer, null);
1:1638801: 
1:1638801:         startConsumers(factory, destination);
1:1638801:         LOG.info("Activated consumer");
1:1638801: 
1:1638801:         double[] withConsumerStats = produceMessages(destination, toSend, numIterations, session, producer, null);
1:1638801: 
1:1638801:         LOG.info("With consumer: " + withConsumerStats[1] + " , with noConsumer: " + noConsumerStats[1]
1:1638801:                 + ", multiplier: " + (withConsumerStats[1]/noConsumerStats[1]));
1:1638801:         final int reasonableMultiplier = 15; // not so reasonable but improving
1:1638801:         assertTrue("max X times as slow with consumer: " + withConsumerStats[1] + ", with no Consumer: "
1:1638801:                 + noConsumerStats[1] + ", multiplier: " + (withConsumerStats[1]/noConsumerStats[1]),
1:1638801:                 withConsumerStats[1] < noConsumerStats[1] * reasonableMultiplier);
1:1638801: 
1:1638801:         final int toReceive = toSend * numIterations * consumerCount * 2;
1:1638801:         Wait.waitFor(new Wait.Condition() {
1:1638801:             public boolean isSatisified() throws Exception {
1:1638801:                 LOG.info("count: " + allMessagesList.getMessageCount());
1:1638801:                 return toReceive == allMessagesList.getMessageCount();
1:1638801:             }
1:1638801:         }, 60 * 1000);
1:1638801: 
1:1638801:         assertEquals("got all messages", toReceive, allMessagesList.getMessageCount());
1:1638801:     }
1:1638801: 
1:1638801:     private MessageProducer createMessageProducer(Session session, Destination destination) throws JMSException {
1:1638801:         MessageProducer producer = session.createProducer(destination);
1:1638801:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:1638801:         return producer;
1:1638801:     }
1:1638801: 
1:1638801:     protected void startConsumers(ConnectionFactory factory, Destination dest) throws Exception {
1:1638801:         MessageConsumer consumer;
1:1638801:         for (int i = 0; i < consumerCount; i++) {
1:1638801:             TimedMessageListener list = new TimedMessageListener();
1:1638801:             consumer = createConsumer(factory.createConnection(), dest);
1:1638801:             consumer.setMessageListener(list);
1:1638801:             consumers.put(consumer, list);
1:1638801:         }
1:1638801:     }
1:1638801: 
1:1638801:     protected MessageConsumer createConsumer(Connection conn, Destination dest) throws Exception {
1:1638801:         connections.add(conn);
1:1638801:         conn.start();
1:1638801: 
1:1638801:         Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:1638801:         final MessageConsumer consumer = sess.createConsumer(dest);
1:1638801: 
1:1638801:         return consumer;
1:1638801:     }
1:1638801: 
1:1638801:     /**
1:1638801:      * @return max and average send time
1:1638801:      * @throws Exception
1:1638801:      */
1:1638801:     private double[] produceMessages(Destination destination,
1:1638801:                                      final int toSend,
1:1638801:                                      final int numIterations,
1:1638801:                                      Session session,
1:1638801:                                      MessageProducer producer,
1:1638801:                                      Object addConsumerSignal) throws Exception {
1:1638801:         long start;
1:1638801:         long count = 0;
1:1638801:         double batchMax = 0, max = 0, sum = 0;
1:1638801: 
1:1638801:         for (int i=0; i<numIterations; i++) {
1:1638801:             start = System.currentTimeMillis();
1:1638801:             for (int j=0; j < toSend; j++) {
1:1638801:                 long singleSendstart = System.currentTimeMillis();
1:1638801:                 TextMessage msg = createTextMessage(session, "" + j);
1:1638801:                 // rotate
1:1638801:                 int priority = ((int)count%10);
1:1638801:                 producer.send(msg, DeliveryMode.PERSISTENT, priority, 0);
1:1638801:                 max = Math.max(max, (System.currentTimeMillis() - singleSendstart));
1:1638801:                 if (++count % 500 == 0) {
1:1638801:                     if (addConsumerSignal != null) {
1:1638801:                         synchronized (addConsumerSignal) {
1:1638801:                             addConsumerSignal.notifyAll();
1:1638801:                             LOG.info("Signalled add consumer");
1:1638801:                         }
1:1638801:                     }
1:1638801:                 }
1:1638801:                 ;
1:1638801:                 if (count % 5000 == 0) {
1:1638801:                     LOG.info("Sent " + count + ", singleSendMax:" + max);
1:1638801:                 }
1:1638801: 
1:1638801:             }
1:1638801:             long duration = System.currentTimeMillis() - start;
1:1638801:             batchMax = Math.max(batchMax, duration);
1:1638801:             sum += duration;
1:1638801:             LOG.info("Iteration " + i + ", sent " + toSend + ", time: "
1:1638801:                     + duration + ", batchMax:" + batchMax + ", singleSendMax:" + max);
1:1638801:         }
1:1638801: 
1:1638801:         LOG.info("Sent: " + toSend * numIterations + ", batchMax: " + batchMax + " singleSendMax: " + max);
1:1638801:         return new double[]{batchMax, sum/numIterations};
1:1638801:     }
1:1638801: 
1:1638801:     protected TextMessage createTextMessage(Session session, String initText) throws Exception {
1:1638801:         TextMessage msg = session.createTextMessage();
1:1638801: 
1:1638801:         // Pad message text
1:1638801:         if (initText.length() < messageSize) {
1:1638801:             char[] data = new char[messageSize - initText.length()];
1:1638801:             Arrays.fill(data, '*');
1:1638801:             String str = new String(data);
1:1638801:             msg.setText(initText + str);
1:1638801: 
1:1638801:             // Do not pad message text
1:1638801:         } else {
1:1638801:             msg.setText(initText);
1:1638801:         }
1:1638801: 
1:1638801:         return msg;
1:1638801:     }
1:1638801: 
1:1638801:     @Override
1:1638801:     protected void setUp() throws Exception {
1:1638801:         topic = false;
1:1638801:         super.setUp();
1:1638801:         broker = createBroker();
1:1638801:         broker.start();
1:1638801:     }
1:1638801: 
1:1638801:     @Override
1:1638801:     protected void tearDown() throws Exception {
1:1638801:         for (Iterator<Connection> iter = connections.iterator(); iter.hasNext();) {
1:1638801:             Connection conn = iter.next();
1:1638801:             try {
1:1638801:                 conn.close();
1:1638801:             } catch (Throwable e) {
1:1638801:             }
1:1638801:         }
1:1638801:         broker.stop();
1:1638801:         allMessagesList.flushMessages();
1:1638801:         consumers.clear();
1:1638801:         super.tearDown();
1:1638801:     }
1:1638801: 
1:1638801:     protected BrokerService createBroker() throws Exception {
1:1638801:         BrokerService brokerService = new BrokerService();
1:1638801:         brokerService.setEnableStatistics(false);
1:1638801:         brokerService.addConnector("tcp://0.0.0.0:0");
1:1638801:         brokerService.setDeleteAllMessagesOnStartup(true);
1:1638801: 
1:1638801:         PolicyEntry policy = new PolicyEntry();
1:1638801:         policy.setPrioritizedMessages(true);
1:1638801:         policy.setMaxPageSize(500);
1:1638801: 
1:1638801:         PolicyMap policyMap = new PolicyMap();
1:1638801:         policyMap.setDefaultEntry(policy);
1:1638801:         brokerService.setDestinationPolicy(policyMap);
1:1638801:         setDefaultPersistenceAdapter(brokerService);
1:1638801: 
1:1638801:         return brokerService;
1:1638801:     }
1:1638801: 
1:1638801:     protected ActiveMQConnectionFactory createConnectionFactory() throws Exception {
1:1638801:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(
1:1638801:             broker.getTransportConnectors().get(0).getPublishableConnectString());
1:1638801:         ActiveMQPrefetchPolicy prefetchPolicy = new ActiveMQPrefetchPolicy();
1:1638801:         prefetchPolicy.setAll(1);
1:1638801:         factory.setPrefetchPolicy(prefetchPolicy);
1:1638801: 
1:1638801:         factory.setDispatchAsync(true);
1:1638801:         return factory;
1:1638801:     }
1:1638801: 
1:1638801:     public static Test suite() {
1:1638801:         return suite(ConcurrentProducerQueueConsumerTest.class);
1:1638801:     }
1:1638801: 
1:1638801:     static class TimedMessageListener implements MessageListener {
1:1638801: 
1:1638801:         static final AtomicLong count = new AtomicLong(0);
1:1638801: 
1:1638801:         final int batchSize = 1000;
1:1638801:         final CountDownLatch firstReceiptLatch = new CountDownLatch(1);
1:1638801: 
1:1638801:         long mark = System.currentTimeMillis();
1:1638801:         long firstReceipt = 0l;
1:1638801:         long receiptAccumulator = 0;
1:1638801:         long batchReceiptAccumulator = 0;
1:1638801:         long maxReceiptTime = 0;
1:1638801: 
1:1638801:         final Map<Integer, MessageIdList> messageLists =
1:1638801:             new ConcurrentHashMap<Integer, MessageIdList>(new HashMap<Integer, MessageIdList>());
1:1638801: 
1:1638801:         @Override
1:1638801:         public void onMessage(Message message) {
1:1638801:             final long current = System.currentTimeMillis();
1:1638801:             final long duration = current - mark;
1:1638801:             receiptAccumulator += duration;
1:1638801:             int priority = 0;
1:1638801: 
1:1638801:             try {
1:1638801:                 priority = message.getJMSPriority();
1:1638801:             } catch (JMSException ignored) {}
1:1638801: 
1:1638801:             if (!messageLists.containsKey(priority)) {
1:1638801:                 messageLists.put(priority, new MessageIdList());
1:1638801:             }
1:1638801:             messageLists.get(priority).onMessage(message);
1:1638801: 
1:1638801:             if (count.incrementAndGet() == 1) {
1:1638801:                 firstReceipt = duration;
1:1638801:                 firstReceiptLatch.countDown();
1:1638801:                 LOG.info("First receipt in " + firstReceipt + "ms");
1:1638801:             } else if (count.get() % batchSize == 0) {
1:1638801:                 LOG.info("Consumed " + count.get() + " in " + batchReceiptAccumulator + "ms" + ", priority:" + priority);
1:1638801:                 batchReceiptAccumulator=0;
1:1638801:             }
1:1638801: 
1:1638801:             maxReceiptTime = Math.max(maxReceiptTime, duration);
1:1638801:             receiptAccumulator += duration;
1:1638801:             batchReceiptAccumulator += duration;
1:1638801:             mark = current;
1:1638801:         }
1:1638801: 
1:1638801:         long getMessageCount() {
1:1638801:             return count.get();
1:1638801:         }
1:1638801: 
1:1638801:         long getFirstReceipt() throws Exception {
1:1638801:             firstReceiptLatch.await(30, TimeUnit.SECONDS);
1:1638801:             return firstReceipt;
1:1638801:         }
1:1638801: 
1:1638801:         public long waitForReceivedLimit(long limit) throws Exception {
1:1638801:             final long expiry = System.currentTimeMillis() + 30*60*1000;
1:1638801:             while (count.get() < limit) {
1:1638801:                 if (System.currentTimeMillis() > expiry) {
1:1638801:                     throw new RuntimeException("Expired waiting for X messages, " + limit);
1:1638801:                 }
1:1638801:                 TimeUnit.SECONDS.sleep(2);
1:1638801:                 String missing = findFirstMissingMessage();
1:1638801:                 if (missing != null) {
1:1638801:                     LOG.info("first missing = " + missing);
1:1638801:                     throw new RuntimeException("We have a missing message. " + missing);
1:1638801:                 }
1:1638801: 
1:1638801:             }
1:1638801:             return receiptAccumulator/(limit/batchSize);
1:1638801:         }
1:1638801: 
1:1638801:         private String findFirstMissingMessage() {
1:1638801:             return null;
1:1638801:         }
1:1638801:     }
1:1638801: 
1:1638801: }
============================================================================
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
commit:1638801
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.usecases;
1: 
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Collections;
1: import java.util.HashMap;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.ThreadFactory;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicLong;
1: 
1: import javax.jms.Connection;
1: import javax.jms.ConnectionFactory;
1: import javax.jms.DeliveryMode;
1: import javax.jms.Destination;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageListener;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
1: 
1: import junit.framework.Test;
1: 
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.ActiveMQPrefetchPolicy;
1: import org.apache.activemq.TestSupport;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
1: import org.apache.activemq.util.MessageIdList;
1: import org.apache.activemq.util.Wait;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: public class ConcurrentProducerQueueConsumerTest extends TestSupport
1: {
1:     private static final Logger LOG = LoggerFactory.getLogger(ConcurrentProducerQueueConsumerTest.class);
1: 
1:     protected List<Connection> connections = Collections.synchronizedList(new ArrayList<Connection>());
1:     protected Map<MessageConsumer, TimedMessageListener> consumers =
1:         new HashMap<MessageConsumer, TimedMessageListener>();
1:     protected MessageIdList allMessagesList = new MessageIdList();
1: 
1:     private BrokerService broker;
1:     private final int consumerCount = 5;
1:     private final int messageSize = 1024;
1:     private final int NUM_MESSAGES = 500;
1:     private final int ITERATIONS = 10;
1: 
1:     private int expectedQueueDeliveries = 0;
1: 
1:     public void initCombosForTestSendRateWithActivatingConsumers() throws Exception {
1:         addCombinationValues("defaultPersistenceAdapter",
0:                 new Object[]{PersistenceAdapterChoice.KahaDB,
1:                              /* too slow for hudson - PersistenceAdapterChoice.JDBC,*/
1:                              PersistenceAdapterChoice.MEM});
1:     }
1: 
1:     public void testSendRateWithActivatingConsumers() throws Exception {
1:         final Destination destination = createDestination();
1:         final ConnectionFactory factory = createConnectionFactory();
1: 
1:         Connection connection = factory.createConnection();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageProducer producer = createMessageProducer(session, destination);
1: 
1:         // preload the queue before adding any consumers
1:         double[] noConsumerStats = produceMessages(destination, NUM_MESSAGES, ITERATIONS, session, producer, null);
1:         LOG.info("With no consumers: ave: " + noConsumerStats[1] + ", max: " +
1:                  noConsumerStats[0] + ", multiplier: " + (noConsumerStats[0]/noConsumerStats[1]));
1:         expectedQueueDeliveries = NUM_MESSAGES * ITERATIONS;
1: 
1:         // periodically start a queue consumer
1:         final int consumersToActivate = 5;
1:         final Object addConsumerSignal = new Object();
1:         Executors.newCachedThreadPool(new ThreadFactory() {
1:             @Override
1:             public Thread newThread(Runnable r) {
1:                 return new Thread(r, "ActivateConsumer" + this);
1:             }
1:         }).execute(new Runnable() {
1:             @Override
1:             public void run() {
1:                 try {
1:                     MessageConsumer consumer = null;
1:                     for (int i = 0; i < consumersToActivate; i++) {
1:                         LOG.info("Waiting for add signal from producer...");
1:                         synchronized (addConsumerSignal) {
1:                             addConsumerSignal.wait(30 * 60 * 1000);
1:                         }
1:                         TimedMessageListener listener = new TimedMessageListener();
1:                         consumer = createConsumer(factory.createConnection(), destination);
1:                         LOG.info("Created consumer " + consumer);
1:                         consumer.setMessageListener(listener);
1:                         consumers.put(consumer, listener);
1:                     }
1:                 } catch (Exception e) {
1:                     LOG.error("failed to start consumer", e);
1:                 }
1:             }
1:         });
1: 
1:         // Collect statistics when there are active consumers.
1:         double[] statsWithActive =
1:             produceMessages(destination, NUM_MESSAGES, ITERATIONS, session, producer, addConsumerSignal);
1:         expectedQueueDeliveries += NUM_MESSAGES * ITERATIONS;
1: 
1:         LOG.info(" with concurrent activate, ave: " + statsWithActive[1] + ", max: " +
1:                  statsWithActive[0] + ", multiplier: " + (statsWithActive[0]/ statsWithActive[1]));
1: 
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return consumers.size() == consumersToActivate;
1:             }
1:         }));
1: 
1:         long timeToFirstAccumulator = 0;
1:         for (TimedMessageListener listener : consumers.values()) {
1:             long time = listener.getFirstReceipt();
1:             timeToFirstAccumulator += time;
1:             LOG.info("Time to first " + time);
1:         }
1:         LOG.info("Ave time to first message =" + timeToFirstAccumulator/consumers.size());
1: 
1:         for (TimedMessageListener listener : consumers.values()) {
1:             LOG.info("Ave batch receipt time: " + listener.waitForReceivedLimit(expectedQueueDeliveries) +
1:                      " max receipt: " + listener.maxReceiptTime);
1:         }
1: 
1:         // compare no active to active
1:         LOG.info("Ave send time with active: " + statsWithActive[1]
1:                 + " as multiplier of ave with none active: " + noConsumerStats[1]
1:                 + ", multiplier=" + (statsWithActive[1]/noConsumerStats[1]));
1: 
1:         assertTrue("Ave send time with active: " + statsWithActive[1]
1:                 + " within reasonable multpler of ave with none active: " + noConsumerStats[1]
1:                 + ", multiplier " + (statsWithActive[1]/noConsumerStats[1]),
1:                 statsWithActive[1] < 15 * noConsumerStats[1]);
1:     }
1: 
1:     public void x_initCombosForTestSendWithInactiveAndActiveConsumers() throws Exception {
1:         addCombinationValues("defaultPersistenceAdapter",
0:                 new Object[]{PersistenceAdapterChoice.KahaDB,
1:                              /* too slow for hudson - PersistenceAdapterChoice.JDBC,*/
1:                              PersistenceAdapterChoice.MEM});
1:     }
1: 
1:     public void x_testSendWithInactiveAndActiveConsumers() throws Exception {
1:         Destination destination = createDestination();
1:         ConnectionFactory factory = createConnectionFactory();
1: 
1:         Connection connection = factory.createConnection();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageProducer producer = session.createProducer(destination);
1:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1: 
1:         final int toSend = 100;
1:         final int numIterations = 5;
1: 
1:         double[] noConsumerStats = produceMessages(destination, toSend, numIterations, session, producer, null);
1: 
1:         startConsumers(factory, destination);
1:         LOG.info("Activated consumer");
1: 
1:         double[] withConsumerStats = produceMessages(destination, toSend, numIterations, session, producer, null);
1: 
1:         LOG.info("With consumer: " + withConsumerStats[1] + " , with noConsumer: " + noConsumerStats[1]
1:                 + ", multiplier: " + (withConsumerStats[1]/noConsumerStats[1]));
1:         final int reasonableMultiplier = 15; // not so reasonable but improving
1:         assertTrue("max X times as slow with consumer: " + withConsumerStats[1] + ", with no Consumer: "
1:                 + noConsumerStats[1] + ", multiplier: " + (withConsumerStats[1]/noConsumerStats[1]),
1:                 withConsumerStats[1] < noConsumerStats[1] * reasonableMultiplier);
1: 
1:         final int toReceive = toSend * numIterations * consumerCount * 2;
1:         Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 LOG.info("count: " + allMessagesList.getMessageCount());
1:                 return toReceive == allMessagesList.getMessageCount();
1:             }
1:         }, 60 * 1000);
1: 
1:         assertEquals("got all messages", toReceive, allMessagesList.getMessageCount());
1:     }
1: 
1:     private MessageProducer createMessageProducer(Session session, Destination destination) throws JMSException {
1:         MessageProducer producer = session.createProducer(destination);
1:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:         return producer;
1:     }
1: 
1:     protected void startConsumers(ConnectionFactory factory, Destination dest) throws Exception {
1:         MessageConsumer consumer;
1:         for (int i = 0; i < consumerCount; i++) {
1:             TimedMessageListener list = new TimedMessageListener();
1:             consumer = createConsumer(factory.createConnection(), dest);
1:             consumer.setMessageListener(list);
1:             consumers.put(consumer, list);
1:         }
1:     }
1: 
1:     protected MessageConsumer createConsumer(Connection conn, Destination dest) throws Exception {
1:         connections.add(conn);
1:         conn.start();
1: 
1:         Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         final MessageConsumer consumer = sess.createConsumer(dest);
1: 
1:         return consumer;
1:     }
1: 
1:     /**
1:      * @return max and average send time
1:      * @throws Exception
1:      */
1:     private double[] produceMessages(Destination destination,
1:                                      final int toSend,
1:                                      final int numIterations,
1:                                      Session session,
1:                                      MessageProducer producer,
1:                                      Object addConsumerSignal) throws Exception {
1:         long start;
1:         long count = 0;
1:         double batchMax = 0, max = 0, sum = 0;
1: 
1:         for (int i=0; i<numIterations; i++) {
1:             start = System.currentTimeMillis();
1:             for (int j=0; j < toSend; j++) {
1:                 long singleSendstart = System.currentTimeMillis();
1:                 TextMessage msg = createTextMessage(session, "" + j);
1:                 // rotate
1:                 int priority = ((int)count%10);
1:                 producer.send(msg, DeliveryMode.PERSISTENT, priority, 0);
1:                 max = Math.max(max, (System.currentTimeMillis() - singleSendstart));
1:                 if (++count % 500 == 0) {
1:                     if (addConsumerSignal != null) {
1:                         synchronized (addConsumerSignal) {
1:                             addConsumerSignal.notifyAll();
1:                             LOG.info("Signalled add consumer");
1:                         }
1:                     }
1:                 }
1:                 ;
1:                 if (count % 5000 == 0) {
1:                     LOG.info("Sent " + count + ", singleSendMax:" + max);
1:                 }
1: 
1:             }
1:             long duration = System.currentTimeMillis() - start;
1:             batchMax = Math.max(batchMax, duration);
1:             sum += duration;
1:             LOG.info("Iteration " + i + ", sent " + toSend + ", time: "
1:                     + duration + ", batchMax:" + batchMax + ", singleSendMax:" + max);
1:         }
1: 
1:         LOG.info("Sent: " + toSend * numIterations + ", batchMax: " + batchMax + " singleSendMax: " + max);
1:         return new double[]{batchMax, sum/numIterations};
1:     }
1: 
1:     protected TextMessage createTextMessage(Session session, String initText) throws Exception {
1:         TextMessage msg = session.createTextMessage();
1: 
1:         // Pad message text
1:         if (initText.length() < messageSize) {
1:             char[] data = new char[messageSize - initText.length()];
1:             Arrays.fill(data, '*');
1:             String str = new String(data);
1:             msg.setText(initText + str);
1: 
1:             // Do not pad message text
1:         } else {
1:             msg.setText(initText);
1:         }
1: 
1:         return msg;
1:     }
1: 
1:     @Override
1:     protected void setUp() throws Exception {
1:         topic = false;
1:         super.setUp();
1:         broker = createBroker();
1:         broker.start();
1:     }
1: 
1:     @Override
1:     protected void tearDown() throws Exception {
1:         for (Iterator<Connection> iter = connections.iterator(); iter.hasNext();) {
1:             Connection conn = iter.next();
1:             try {
1:                 conn.close();
1:             } catch (Throwable e) {
1:             }
1:         }
1:         broker.stop();
1:         allMessagesList.flushMessages();
1:         consumers.clear();
1:         super.tearDown();
1:     }
1: 
1:     protected BrokerService createBroker() throws Exception {
1:         BrokerService brokerService = new BrokerService();
1:         brokerService.setEnableStatistics(false);
1:         brokerService.addConnector("tcp://0.0.0.0:0");
1:         brokerService.setDeleteAllMessagesOnStartup(true);
1: 
1:         PolicyEntry policy = new PolicyEntry();
1:         policy.setPrioritizedMessages(true);
1:         policy.setMaxPageSize(500);
1: 
1:         PolicyMap policyMap = new PolicyMap();
1:         policyMap.setDefaultEntry(policy);
1:         brokerService.setDestinationPolicy(policyMap);
1:         setDefaultPersistenceAdapter(brokerService);
1: 
1:         return brokerService;
1:     }
1: 
1:     protected ActiveMQConnectionFactory createConnectionFactory() throws Exception {
1:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(
1:             broker.getTransportConnectors().get(0).getPublishableConnectString());
1:         ActiveMQPrefetchPolicy prefetchPolicy = new ActiveMQPrefetchPolicy();
1:         prefetchPolicy.setAll(1);
1:         factory.setPrefetchPolicy(prefetchPolicy);
1: 
1:         factory.setDispatchAsync(true);
1:         return factory;
1:     }
1: 
1:     public static Test suite() {
1:         return suite(ConcurrentProducerQueueConsumerTest.class);
1:     }
1: 
1:     static class TimedMessageListener implements MessageListener {
1: 
1:         static final AtomicLong count = new AtomicLong(0);
1: 
1:         final int batchSize = 1000;
1:         final CountDownLatch firstReceiptLatch = new CountDownLatch(1);
1: 
1:         long mark = System.currentTimeMillis();
1:         long firstReceipt = 0l;
1:         long receiptAccumulator = 0;
1:         long batchReceiptAccumulator = 0;
1:         long maxReceiptTime = 0;
1: 
1:         final Map<Integer, MessageIdList> messageLists =
1:             new ConcurrentHashMap<Integer, MessageIdList>(new HashMap<Integer, MessageIdList>());
1: 
1:         @Override
1:         public void onMessage(Message message) {
1:             final long current = System.currentTimeMillis();
1:             final long duration = current - mark;
1:             receiptAccumulator += duration;
1:             int priority = 0;
1: 
1:             try {
1:                 priority = message.getJMSPriority();
1:             } catch (JMSException ignored) {}
1: 
1:             if (!messageLists.containsKey(priority)) {
1:                 messageLists.put(priority, new MessageIdList());
1:             }
1:             messageLists.get(priority).onMessage(message);
1: 
1:             if (count.incrementAndGet() == 1) {
1:                 firstReceipt = duration;
1:                 firstReceiptLatch.countDown();
1:                 LOG.info("First receipt in " + firstReceipt + "ms");
1:             } else if (count.get() % batchSize == 0) {
1:                 LOG.info("Consumed " + count.get() + " in " + batchReceiptAccumulator + "ms" + ", priority:" + priority);
1:                 batchReceiptAccumulator=0;
1:             }
1: 
1:             maxReceiptTime = Math.max(maxReceiptTime, duration);
1:             receiptAccumulator += duration;
1:             batchReceiptAccumulator += duration;
1:             mark = current;
1:         }
1: 
1:         long getMessageCount() {
1:             return count.get();
1:         }
1: 
1:         long getFirstReceipt() throws Exception {
1:             firstReceiptLatch.await(30, TimeUnit.SECONDS);
1:             return firstReceipt;
1:         }
1: 
1:         public long waitForReceivedLimit(long limit) throws Exception {
1:             final long expiry = System.currentTimeMillis() + 30*60*1000;
1:             while (count.get() < limit) {
1:                 if (System.currentTimeMillis() > expiry) {
1:                     throw new RuntimeException("Expired waiting for X messages, " + limit);
1:                 }
1:                 TimeUnit.SECONDS.sleep(2);
1:                 String missing = findFirstMissingMessage();
1:                 if (missing != null) {
1:                     LOG.info("first missing = " + missing);
1:                     throw new RuntimeException("We have a missing message. " + missing);
1:                 }
1: 
1:             }
1:             return receiptAccumulator/(limit/batchSize);
1:         }
1: 
1:         private String findFirstMissingMessage() {
1:             return null;
1:         }
1:     }
1: 
1: }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:77a679b
/////////////////////////////////////////////////////////////////////////
1:                 new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB,
/////////////////////////////////////////////////////////////////////////
1:                 new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB,
============================================================================