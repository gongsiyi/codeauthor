1:a88906f: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
3:a88906f:  *
1:5f1adbe:  *      http://www.apache.org/licenses/LICENSE-2.0
1:a88906f:  *
1:a88906f:  * Unless required by applicable law or agreed to in writing, software
1:a88906f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a88906f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a88906f:  * See the License for the specific language governing permissions and
1:a88906f:  * limitations under the License.
1:a88906f:  */
1:a88906f: package org.apache.activemq.tool;
4:a88906f: 
1:540dd5c: import java.util.concurrent.atomic.AtomicInteger;
1:a88906f: 
1:a88906f: import javax.jms.ConnectionFactory;
1:a88906f: import javax.jms.Destination;
1:540dd5c: import javax.jms.JMSException;
1:a88906f: import javax.jms.Message;
1:540dd5c: import javax.jms.MessageConsumer;
1:a88906f: import javax.jms.MessageListener;
1:a88906f: import javax.jms.Topic;
1:a88906f: 
1:6dd47bb: import org.apache.activemq.command.ActiveMQDestination;
1:540dd5c: import org.apache.activemq.tool.properties.JmsClientProperties;
1:540dd5c: import org.apache.activemq.tool.properties.JmsConsumerProperties;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:a88906f: 
1:a88906f: public class JmsConsumerClient extends AbstractJmsMeasurableClient {
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(JmsConsumerClient.class);
1:a88906f: 
1:a88906f:     protected MessageConsumer jmsConsumer;
1:a88906f:     protected JmsConsumerProperties client;
1:a88906f: 
1:a88906f:     public JmsConsumerClient(ConnectionFactory factory) {
1:a88906f:         this(new JmsConsumerProperties(), factory);
1:459be2d:     }
1:576230b: 
1:a88906f:     public JmsConsumerClient(JmsConsumerProperties clientProps, ConnectionFactory factory) {
1:a88906f:         super(factory);
1:a88906f:         client = clientProps;
1:a88906f:     }
1:459be2d: 
1:a88906f:     public void receiveMessages() throws JMSException {
1:a88906f:         if (client.isAsyncRecv()) {
1:a88906f:             if (client.getRecvType().equalsIgnoreCase(JmsConsumerProperties.TIME_BASED_RECEIVING)) {
1:a88906f:                 receiveAsyncTimeBasedMessages(client.getRecvDuration());
1:a88906f:             } else {
1:a88906f:                 receiveAsyncCountBasedMessages(client.getRecvCount());
1:a88906f:             }
1:a88906f:         } else {
1:a88906f:             if (client.getRecvType().equalsIgnoreCase(JmsConsumerProperties.TIME_BASED_RECEIVING)) {
1:a88906f:                 receiveSyncTimeBasedMessages(client.getRecvDuration());
1:a88906f:             } else {
1:a88906f:                 receiveSyncCountBasedMessages(client.getRecvCount());
1:a88906f:             }
1:a88906f:         }
1:a88906f:     }
1:a88906f: 
1:a88906f:     public void receiveMessages(int destCount) throws JMSException {
1:a88906f:         this.destCount = destCount;
1:a88906f:         receiveMessages();
1:a88906f:     }
1:a88906f: 
1:a88906f:     public void receiveMessages(int destIndex, int destCount) throws JMSException {
1:a88906f:         this.destIndex = destIndex;
1:a88906f:         receiveMessages(destCount);
1:a88906f:     }
1:a88906f: 
1:a88906f:     public void receiveSyncTimeBasedMessages(long duration) throws JMSException {
1:a88906f:         if (getJmsConsumer() == null) {
1:a88906f:             createJmsConsumer();
1:a88906f:         }
1:a88906f: 
1:576230b:         try {
1:a88906f:             getConnection().start();
1:a88906f: 
1:540dd5c:             LOG.info("Starting to synchronously receive messages for " + duration + " ms...");
1:a88906f:             long endTime = System.currentTimeMillis() + duration;
1:459be2d: 
1:5b1412d:             while (System.currentTimeMillis() - endTime < 0) {
1:a88906f:                 getJmsConsumer().receive();
1:a88906f:                 incThroughput();
1:576230b:                 sleep();
1:459be2d:                 commitTxIfNecessary();
1:a88906f:             }
1:a88906f:         } finally {
1:d1ff5ab:             if (client.isDurable() && client.isUnsubscribe()) {
1:540dd5c:                 LOG.info("Unsubscribing durable subscriber: " + getClientName());
1:4374277:                 getJmsConsumer().close();
1:d1ff5ab:                 getSession().unsubscribe(getClientName());
1:a88906f:             }
1:a88906f:             getConnection().close();
1:a88906f:         }
1:a88906f:     }
1:a88906f: 
1:a88906f:     public void receiveSyncCountBasedMessages(long count) throws JMSException {
1:a88906f:         if (getJmsConsumer() == null) {
1:a88906f:             createJmsConsumer();
1:a88906f:         }
1:a88906f: 
2:a88906f:         try {
1:a88906f:             getConnection().start();
1:540dd5c:             LOG.info("Starting to synchronously receive " + count + " messages...");
1:a88906f: 
1:a88906f:             int recvCount = 0;
1:a88906f:             while (recvCount < count) {
1:a88906f:                 getJmsConsumer().receive();
1:a88906f:                 incThroughput();
1:a88906f:                 recvCount++;
1:576230b:                 sleep();
1:459be2d:                 commitTxIfNecessary();
1:a88906f:             }
1:a88906f:         } finally {
1:d1ff5ab:             if (client.isDurable() && client.isUnsubscribe()) {
1:540dd5c:                 LOG.info("Unsubscribing durable subscriber: " + getClientName());
1:4374277:                 getJmsConsumer().close();
1:d1ff5ab:                 getSession().unsubscribe(getClientName());
1:a88906f:             }
1:a88906f:             getConnection().close();
1:a88906f:         }
1:d1ff5ab:     }
1:a88906f: 
1:a88906f:     public void receiveAsyncTimeBasedMessages(long duration) throws JMSException {
1:a88906f:         if (getJmsConsumer() == null) {
1:a88906f:             createJmsConsumer();
1:a88906f:         }
1:a88906f: 
1:a88906f:         getJmsConsumer().setMessageListener(new MessageListener() {
1:e47e0e0:             @Override
1:a88906f:             public void onMessage(Message msg) {
1:a88906f:                 incThroughput();
1:4cfb8dc:                 sleep();
1:459be2d:                 try {
1:e47e0e0:                     commitTxIfNecessary();
1:459be2d:                 } catch (JMSException ex) {
1:e47e0e0:                     LOG.error("Error committing transaction: " + ex.getMessage());
1:459be2d:                 }
1:a88906f:             }
1:a88906f:         });
1:4cfb8dc: 
1:a88906f:         try {
1:a88906f:             getConnection().start();
1:540dd5c:             LOG.info("Starting to asynchronously receive messages for " + duration + " ms...");
1:a88906f:             try {
1:a88906f:                 Thread.sleep(duration);
1:a88906f:             } catch (InterruptedException e) {
1:a88906f:                 throw new JMSException("JMS consumer thread sleep has been interrupted. Message: " + e.getMessage());
1:a88906f:             }
1:a88906f:         } finally {
1:d1ff5ab:             if (client.isDurable() && client.isUnsubscribe()) {
1:540dd5c:                 LOG.info("Unsubscribing durable subscriber: " + getClientName());
1:4374277:                 getJmsConsumer().close();
1:d1ff5ab:                 getSession().unsubscribe(getClientName());
1:a88906f:             }
1:a88906f:             getConnection().close();
1:a88906f:         }
1:d1ff5ab:     }
1:a88906f: 
1:a88906f:     public void receiveAsyncCountBasedMessages(long count) throws JMSException {
1:a88906f:         if (getJmsConsumer() == null) {
1:a88906f:             createJmsConsumer();
1:a88906f:         }
1:a88906f: 
1:a88906f:         final AtomicInteger recvCount = new AtomicInteger(0);
1:a88906f:         getJmsConsumer().setMessageListener(new MessageListener() {
1:e47e0e0:             @Override
1:a88906f:             public void onMessage(Message msg) {
1:a88906f:                 incThroughput();
1:576230b:                 sleep();
1:a88906f: 
1:a88906f:                 recvCount.incrementAndGet();
1:d245457:                 synchronized (recvCount) {
1:d245457:                     recvCount.notify();
1:e47e0e0:                 }
1:e47e0e0: 
1:459be2d:                 try {
1:e47e0e0:                     commitTxIfNecessary();
1:459be2d:                 } catch (JMSException ex) {
1:e47e0e0:                     LOG.error("Error committing transaction: " + ex.getMessage());
1:d245457:                 }
1:a88906f:             }
1:a88906f:         });
1:a88906f: 
1:a88906f:         try {
1:a88906f:             getConnection().start();
1:540dd5c:             LOG.info("Starting to asynchronously receive " + client.getRecvCount() + " messages...");
1:a88906f:             try {
1:a88906f:                 while (recvCount.get() < count) {
1:d245457:                     synchronized (recvCount) {
1:d245457:                         recvCount.wait();
1:d245457:                     }
1:a88906f:                 }
1:a88906f:             } catch (InterruptedException e) {
1:a88906f:                 throw new JMSException("JMS consumer thread wait has been interrupted. Message: " + e.getMessage());
1:a88906f:             }
1:a88906f:         } finally {
1:d1ff5ab:             if (client.isDurable() && client.isUnsubscribe()) {
1:540dd5c:                 LOG.info("Unsubscribing durable subscriber: " + getClientName());
1:4374277:                 getJmsConsumer().close();
1:d1ff5ab:                 getSession().unsubscribe(getClientName());
1:a88906f:             }
1:a88906f:             getConnection().close();
1:a88906f:         }
1:a88906f:     }
1:a88906f: 
1:a88906f:     public MessageConsumer createJmsConsumer() throws JMSException {
1:6dd47bb:         Destination[] dest = createDestinations(destCount);
1:e47e0e0: 
1:6dd47bb:         Destination consumedDestination = dest[0];
1:6dd47bb:         if (dest.length > 1) {
1:6dd47bb:             String destinationName = ((ActiveMQDestination) consumedDestination).getPhysicalName();
1:6dd47bb:             LOG.warn("Multiple destinations requested for consumer; using only first: {}", destinationName);
1:6dd47bb:         }
1:6dd47bb: 
1:6dd47bb:         if (this.client.getMessageSelector() == null) {
1:6dd47bb:             return createJmsConsumer(consumedDestination);
1:6dd47bb:         } else {
1:6dd47bb:             return createJmsConsumer(consumedDestination, this.client.getMessageSelector(), false);
1:6dd47bb:         }
1:a88906f:     }
1:a072126: 
1:a88906f:     public MessageConsumer createJmsConsumer(Destination dest) throws JMSException {
1:a88906f:         if (client.isDurable()) {
1:a88906f:             String clientName = getClientName();
1:a88906f:             if (clientName == null) {
1:a88906f:                 clientName = "JmsConsumer";
1:d1ff5ab:                 setClientName(clientName);
1:a88906f:             }
1:540dd5c:             LOG.info("Creating durable subscriber (" + clientName + ") to: " + dest.toString());
1:a88906f:             jmsConsumer = getSession().createDurableSubscriber((Topic) dest, clientName);
1:a88906f:         } else {
1:540dd5c:             LOG.info("Creating non-durable consumer to: " + dest.toString());
1:a88906f:             jmsConsumer = getSession().createConsumer(dest);
1:a88906f:         }
1:a88906f:         return jmsConsumer;
1:a88906f:     }
1:a88906f: 
1:a88906f:     public MessageConsumer createJmsConsumer(Destination dest, String selector, boolean noLocal) throws JMSException {
1:a88906f:         if (client.isDurable()) {
1:a88906f:             String clientName = getClientName();
1:a88906f:             if (clientName == null) {
1:a88906f:                 clientName = "JmsConsumer";
1:d1ff5ab:                 setClientName(clientName);
1:a88906f:             }
1:540dd5c:             LOG.info("Creating durable subscriber (" + clientName + ") to: " + dest.toString());
1:a88906f:             jmsConsumer = getSession().createDurableSubscriber((Topic) dest, clientName, selector, noLocal);
1:a88906f:         } else {
1:540dd5c:             LOG.info("Creating non-durable consumer to: " + dest.toString());
1:a88906f:             jmsConsumer = getSession().createConsumer(dest, selector, noLocal);
1:a88906f:         }
1:a88906f:         return jmsConsumer;
1:a88906f:     }
1:a88906f: 
1:a88906f:     public MessageConsumer getJmsConsumer() {
1:a88906f:         return jmsConsumer;
1:a88906f:     }
1:a88906f: 
1:e47e0e0:     @Override
1:a88906f:     public JmsClientProperties getClient() {
1:a88906f:         return client;
1:a88906f:     }
1:a88906f: 
1:e47e0e0:     @Override
1:a88906f:     public void setClient(JmsClientProperties clientProps) {
1:a88906f:         client = (JmsConsumerProperties)clientProps;
1:a88906f:     }
1:e47e0e0: 
1:459be2d:     /**
1:e47e0e0:      * A way to throttle the consumer. Time to sleep is
1:e47e0e0:      * configured via recvDelay property.
1:459be2d:      */
1:576230b:     protected void sleep() {
1:576230b:         if (client.getRecvDelay() > 0) {
1:e47e0e0:             try {
1:e47e0e0:                 LOG.trace("Sleeping for " + client.getRecvDelay() + " milliseconds");
1:e47e0e0:                 Thread.sleep(client.getRecvDelay());
1:e47e0e0:             } catch (java.lang.InterruptedException ex) {
1:e47e0e0:                 LOG.warn(ex.getMessage());
1:e47e0e0:             }
1:576230b:         }
1:576230b:     }
1:576230b: }
============================================================================
author:giliva
-------------------------------------------------------------------------------
commit:5b1412d
/////////////////////////////////////////////////////////////////////////
1:             while (System.currentTimeMillis() - endTime < 0) {
author:Jakub Korab
-------------------------------------------------------------------------------
commit:4cfb8dc
/////////////////////////////////////////////////////////////////////////
1:                 sleep();
1: 
author:Timothy Bish
-------------------------------------------------------------------------------
commit:6dd47bb
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQDestination;
/////////////////////////////////////////////////////////////////////////
1:         Destination[] dest = createDestinations(destCount);
1:         Destination consumedDestination = dest[0];
1:         if (dest.length > 1) {
1:             String destinationName = ((ActiveMQDestination) consumedDestination).getPhysicalName();
1:             LOG.warn("Multiple destinations requested for consumer; using only first: {}", destinationName);
1:         }
1: 
1:         if (this.client.getMessageSelector() == null) {
1:             return createJmsConsumer(consumedDestination);
1:         } else {
1:             return createJmsConsumer(consumedDestination, this.client.getMessageSelector(), false);
1:         }
commit:e47e0e0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:                     commitTxIfNecessary();
1:                     LOG.error("Error committing transaction: " + ex.getMessage());
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:                 }
1: 
1:                     commitTxIfNecessary();
1:                     LOG.error("Error committing transaction: " + ex.getMessage());
/////////////////////////////////////////////////////////////////////////
1: 
0:             return createJmsConsumer(dest[0]);
0:         else
0:             return createJmsConsumer(dest[0], this.client.getMessageSelector(), false);
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1: 
1:      * A way to throttle the consumer. Time to sleep is
1:      * configured via recvDelay property.
1:             try {
1:                 LOG.trace("Sleeping for " + client.getRecvDelay() + " milliseconds");
1:                 Thread.sleep(client.getRecvDelay());
1:             } catch (java.lang.InterruptedException ex) {
1:                 LOG.warn(ex.getMessage());
1:             }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:87e878b
commit:576230b
/////////////////////////////////////////////////////////////////////////
1:                 sleep();
/////////////////////////////////////////////////////////////////////////
1:                 sleep();
/////////////////////////////////////////////////////////////////////////
1:                 sleep();
/////////////////////////////////////////////////////////////////////////
1:     
1:     protected void sleep() {
1:         if (client.getRecvDelay() > 0) {
1:         	try {
0:         		LOG.trace("Sleeping for " + client.getRecvDelay() + " milliseconds");
0:         		Thread.sleep(client.getRecvDelay());
0:         	} catch (java.lang.InterruptedException ex) {
0:         		LOG.warn(ex.getMessage());
1:         	}
1:         }
1:     }
commit:d245457
/////////////////////////////////////////////////////////////////////////
1:                 synchronized (recvCount) {
1:                     recvCount.notify();
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                     synchronized (recvCount) {
1:                         recvCount.wait();
1:                     }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:459be2d
/////////////////////////////////////////////////////////////////////////
1: 
0:             int counter = 0;
0:                 counter++;
1:                 commitTxIfNecessary();
/////////////////////////////////////////////////////////////////////////
1:                 commitTxIfNecessary();
/////////////////////////////////////////////////////////////////////////
1:                 try {
0:                 	commitTxIfNecessary();
1:                 } catch (JMSException ex) {
0:                 	LOG.error("Error committing transaction: " + ex.getMessage());
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                 } 
1:                 
1:                 try {
0:                 	commitTxIfNecessary();
1:                 } catch (JMSException ex) {
0:                 	LOG.error("Error committing transaction: " + ex.getMessage());
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * A way to throttle the consumer. Time to sleep is 
0:      * configured via recvDelay property. 
1:      */
commit:a072126
/////////////////////////////////////////////////////////////////////////
1:         
0:         if (this.client.getMessageSelector() == null)
0:         	return createJmsConsumer(dest[0]);
0:         else 
0:         	return createJmsConsumer(dest[0], this.client.getMessageSelector(), false);
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(JmsConsumerClient.class);
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:540dd5c
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicInteger;
1: import javax.jms.JMSException;
1: import javax.jms.MessageConsumer;
1: import org.apache.activemq.tool.properties.JmsClientProperties;
1: import org.apache.activemq.tool.properties.JmsConsumerProperties;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0:     private static final Log LOG = LogFactory.getLog(JmsConsumerClient.class);
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("Starting to synchronously receive messages for " + duration + " ms...");
/////////////////////////////////////////////////////////////////////////
1:                 LOG.info("Unsubscribing durable subscriber: " + getClientName());
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("Starting to synchronously receive " + count + " messages...");
/////////////////////////////////////////////////////////////////////////
1:                 LOG.info("Unsubscribing durable subscriber: " + getClientName());
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("Starting to asynchronously receive messages for " + duration + " ms...");
/////////////////////////////////////////////////////////////////////////
1:                 LOG.info("Unsubscribing durable subscriber: " + getClientName());
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("Starting to asynchronously receive " + client.getRecvCount() + " messages...");
/////////////////////////////////////////////////////////////////////////
1:                 LOG.info("Unsubscribing durable subscriber: " + getClientName());
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("Creating durable subscriber (" + clientName + ") to: " + dest.toString());
1:             LOG.info("Creating non-durable consumer to: " + dest.toString());
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("Creating durable subscriber (" + clientName + ") to: " + dest.toString());
1:             LOG.info("Creating non-durable consumer to: " + dest.toString());
commit:5f1adbe
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicInteger;
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:a88906f
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.tool;
1: 
0: import org.apache.commons.logging.LogFactory;
0: import org.apache.commons.logging.Log;
0: import org.apache.activemq.tool.properties.JmsConsumerProperties;
0: import org.apache.activemq.tool.properties.JmsClientProperties;
1: 
0: import javax.jms.MessageConsumer;
0: import javax.jms.JMSException;
1: import javax.jms.ConnectionFactory;
0: import javax.jms.Connection;
1: import javax.jms.Destination;
1: import javax.jms.Message;
1: import javax.jms.MessageListener;
1: import javax.jms.Topic;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicInteger;
1: 
1: public class JmsConsumerClient extends AbstractJmsMeasurableClient {
0:     private static final Log log = LogFactory.getLog(JmsConsumerClient.class);
1: 
1:     protected MessageConsumer jmsConsumer;
1:     protected JmsConsumerProperties client;
1: 
1:     public JmsConsumerClient(ConnectionFactory factory) {
1:         this(new JmsConsumerProperties(), factory);
1:     }
1: 
1:     public JmsConsumerClient(JmsConsumerProperties clientProps, ConnectionFactory factory) {
1:         super(factory);
1:         client = clientProps;
1:     }
1: 
1:     public void receiveMessages() throws JMSException {
1:         if (client.isAsyncRecv()) {
1:             if (client.getRecvType().equalsIgnoreCase(JmsConsumerProperties.TIME_BASED_RECEIVING)) {
1:                 receiveAsyncTimeBasedMessages(client.getRecvDuration());
1:             } else {
1:                 receiveAsyncCountBasedMessages(client.getRecvCount());
1:             }
1:         } else {
1:             if (client.getRecvType().equalsIgnoreCase(JmsConsumerProperties.TIME_BASED_RECEIVING)) {
1:                 receiveSyncTimeBasedMessages(client.getRecvDuration());
1:             } else {
1:                 receiveSyncCountBasedMessages(client.getRecvCount());
1:             }
1:         }
1:     }
1: 
1:     public void receiveMessages(int destCount) throws JMSException {
1:         this.destCount = destCount;
1:         receiveMessages();
1:     }
1: 
1:     public void receiveMessages(int destIndex, int destCount) throws JMSException {
1:         this.destIndex = destIndex;
1:         receiveMessages(destCount);
1:     }
1: 
1:     public void receiveSyncTimeBasedMessages(long duration) throws JMSException {
1:         if (getJmsConsumer() == null) {
1:             createJmsConsumer();
1:         }
1: 
1:         try {
1:             getConnection().start();
1: 
0:             log.info("Starting to synchronously receive messages for " + duration + " ms...");
1:             long endTime = System.currentTimeMillis() + duration;
0:             while (System.currentTimeMillis() < endTime) {
1:                 getJmsConsumer().receive();
1:                 incThroughput();
1:             }
1:         } finally {
1:             getConnection().close();
1:         }
1:     }
1: 
1:     public void receiveSyncCountBasedMessages(long count) throws JMSException {
1:         if (getJmsConsumer() == null) {
1:             createJmsConsumer();
1:         }
1: 
1:         try {
1:             getConnection().start();
0:             log.info("Starting to synchronously receive " + count + " messages...");
1: 
1:             int recvCount = 0;
1:             while (recvCount < count) {
1:                 getJmsConsumer().receive();
1:                 incThroughput();
1:                 recvCount++;
1:             }
1:         } finally {
1:             getConnection().close();
1:         }
1:     }
1: 
1:     public void receiveAsyncTimeBasedMessages(long duration) throws JMSException {
1:         if (getJmsConsumer() == null) {
1:             createJmsConsumer();
1:         }
1: 
1:         getJmsConsumer().setMessageListener(new MessageListener() {
1:             public void onMessage(Message msg) {
1:                 incThroughput();
1:             }
1:         });
1: 
1:         try {
1:             getConnection().start();
0:             log.info("Starting to asynchronously receive messages for " + duration + " ms...");
1:             try {
1:                 Thread.sleep(duration);
1:             } catch (InterruptedException e) {
1:                 throw new JMSException("JMS consumer thread sleep has been interrupted. Message: " + e.getMessage());
1:             }
1:         } finally {
1:             getConnection().close();
1:         }
1:     }
1: 
1:     public void receiveAsyncCountBasedMessages(long count) throws JMSException {
1:         if (getJmsConsumer() == null) {
1:             createJmsConsumer();
1:         }
1: 
1:         final AtomicInteger recvCount = new AtomicInteger(0);
1:         getJmsConsumer().setMessageListener(new MessageListener() {
1:             public void onMessage(Message msg) {
1:                 incThroughput();
1:                 recvCount.incrementAndGet();
0:                 recvCount.notify();
1:             }
1:         });
1: 
1:         try {
1:             getConnection().start();
0:             log.info("Starting to asynchronously receive " + client.getRecvCount() + " messages...");
1:             try {
1:                 while (recvCount.get() < count) {
0:                     recvCount.wait();
1:                 }
1:             } catch (InterruptedException e) {
1:                 throw new JMSException("JMS consumer thread wait has been interrupted. Message: " + e.getMessage());
1:             }
1:         } finally {
1:             getConnection().close();
1:         }
1:     }
1: 
1:     public MessageConsumer createJmsConsumer() throws JMSException {
0:         Destination[] dest = createDestination(destIndex, destCount);
0:         return createJmsConsumer(dest[0]);
1:     }
1: 
1:     public MessageConsumer createJmsConsumer(Destination dest) throws JMSException {
1:         if (client.isDurable()) {
1:             String clientName = getClientName();
1:             if (clientName == null) {
1:                 clientName = "JmsConsumer";
1:             }
0:             log.info("Creating durable subscriber (" + getConnection().getClientID() + ") to: " + dest.toString());
1:             jmsConsumer = getSession().createDurableSubscriber((Topic) dest, clientName);
1:         } else {
0:             log.info("Creating non-durable consumer to: " + dest.toString());
1:             jmsConsumer = getSession().createConsumer(dest);
1:         }
1:         return jmsConsumer;
1:     }
1: 
1:     public MessageConsumer createJmsConsumer(Destination dest, String selector, boolean noLocal) throws JMSException {
1:         if (client.isDurable()) {
1:             String clientName = getClientName();
1:             if (clientName == null) {
1:                 clientName = "JmsConsumer";
1:             }
0:             log.info("Creating durable subscriber (" + getConnection().getClientID() + ") to: " + dest.toString());
1:             jmsConsumer = getSession().createDurableSubscriber((Topic) dest, clientName, selector, noLocal);
1:         } else {
0:             log.info("Creating non-durable consumer to: " + dest.toString());
1:             jmsConsumer = getSession().createConsumer(dest, selector, noLocal);
1:         }
1:         return jmsConsumer;
1:     }
1: 
1:     public MessageConsumer getJmsConsumer() {
1:         return jmsConsumer;
1:     }
1: 
1:     public JmsClientProperties getClient() {
1:         return client;
1:     }
1: 
1:     public void setClient(JmsClientProperties clientProps) {
1:         client = (JmsConsumerProperties)clientProps;
1:     }
1: }
author:James Strachan
-------------------------------------------------------------------------------
commit:dd55c21
author:Adrian T. Co
-------------------------------------------------------------------------------
commit:4374277
/////////////////////////////////////////////////////////////////////////
1:                 getJmsConsumer().close();
/////////////////////////////////////////////////////////////////////////
1:                 getJmsConsumer().close();
/////////////////////////////////////////////////////////////////////////
1:                 getJmsConsumer().close();
/////////////////////////////////////////////////////////////////////////
1:                 getJmsConsumer().close();
commit:d1ff5ab
/////////////////////////////////////////////////////////////////////////
1:             if (client.isDurable() && client.isUnsubscribe()) {
0:                 log.info("Unsubscribing durable subscriber: " + getClientName());
1:                 getSession().unsubscribe(getClientName());
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if (client.isDurable() && client.isUnsubscribe()) {
0:                 log.info("Unsubscribing durable subscriber: " + getClientName());
1:                 getSession().unsubscribe(getClientName());
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if (client.isDurable() && client.isUnsubscribe()) {
0:                 log.info("Unsubscribing durable subscriber: " + getClientName());
1:                 getSession().unsubscribe(getClientName());
0:             }
/////////////////////////////////////////////////////////////////////////
1:             if (client.isDurable() && client.isUnsubscribe()) {
0:                 log.info("Unsubscribing durable subscriber: " + getClientName());
1:                 getSession().unsubscribe(getClientName());
0:             }
/////////////////////////////////////////////////////////////////////////
1:                 setClientName(clientName);
0:             log.info("Creating durable subscriber (" + clientName + ") to: " + dest.toString());
/////////////////////////////////////////////////////////////////////////
1:                 setClientName(clientName);
0:             log.info("Creating durable subscriber (" + clientName + ") to: " + dest.toString());
commit:cf7ee97
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             log.info("Creating durable subscriber (" + getConnection().getClientID() + ") to: " + dest.toString());
/////////////////////////////////////////////////////////////////////////
0:             log.info("Creating durable subscriber (" + getConnection().getClientID() + ") to: " + dest.toString());
commit:f1c6e4c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.activemq.tool.properties.JmsConsumerProperties;
0: import org.apache.activemq.tool.properties.JmsClientProperties;
0: import javax.jms.MessageConsumer;
0: import javax.jms.JMSException;
0: import javax.jms.ConnectionFactory;
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicInteger;
0: 
0: public class JmsConsumerClient extends AbstractJmsMeasurableClient {
0:     protected JmsConsumerProperties client;
0:     public JmsConsumerClient(ConnectionFactory factory) {
0:         this(new JmsConsumerProperties(), factory);
0:     }
0:     public JmsConsumerClient(JmsConsumerProperties clientProps, ConnectionFactory factory) {
0:         super(factory);
0:         client = clientProps;
0:     }
0:         if (client.isAsyncRecv()) {
0:             if (client.getRecvType().equalsIgnoreCase(JmsConsumerProperties.TIME_BASED_RECEIVING)) {
0:                 receiveAsyncTimeBasedMessages(client.getRecvDuration());
0:             } else {
0:                 receiveAsyncCountBasedMessages(client.getRecvCount());
0:             }
0:             if (client.getRecvType().equalsIgnoreCase(JmsConsumerProperties.TIME_BASED_RECEIVING)) {
0:                 receiveSyncTimeBasedMessages(client.getRecvDuration());
0:             } else {
0:                 receiveSyncCountBasedMessages(client.getRecvCount());
0:             }
0:     public void receiveMessages(int destCount) throws JMSException {
0:         this.destCount = destCount;
0:         receiveMessages();
0:     }
0: 
0:     public void receiveMessages(int destIndex, int destCount) throws JMSException {
0:         this.destIndex = destIndex;
0:         receiveMessages(destCount);
0:     }
0: 
0:     public void receiveSyncTimeBasedMessages(long duration) throws JMSException {
0: 
0:             log.info("Starting to synchronously receive messages for " + duration + " ms...");
0:             long endTime = System.currentTimeMillis() + duration;
0:             while (System.currentTimeMillis() < endTime) {
0:                 getJmsConsumer().receive();
0:                 incThroughput();
0:     public void receiveSyncCountBasedMessages(long count) throws JMSException {
0:         try {
0:             getConnection().start();
0:             log.info("Starting to synchronously receive " + count + " messages...");
0:             int recvCount = 0;
0:             while (recvCount < count) {
0:                 getJmsConsumer().receive();
0:                 incThroughput();
0:                 recvCount++;
0:         } finally {
0:             getConnection().close();
0: 
0:     public void receiveAsyncTimeBasedMessages(long duration) throws JMSException {
0:         if (getJmsConsumer() == null) {
0:             createJmsConsumer();
0:         }
0: 
0:         getJmsConsumer().setMessageListener(new MessageListener() {
0:             public void onMessage(Message msg) {
0:                 incThroughput();
0:             }
0:         });
0: 
0:         try {
0:             getConnection().start();
0:             log.info("Starting to asynchronously receive messages for " + duration + " ms...");
0:             try {
0:                 Thread.sleep(duration);
0:             } catch (InterruptedException e) {
0:                 throw new JMSException("JMS consumer thread sleep has been interrupted. Message: " + e.getMessage());
0:             }
0:         } finally {
0:             getConnection().close();
0:         }
0: 
0:     public void receiveAsyncCountBasedMessages(long count) throws JMSException {
0:         if (getJmsConsumer() == null) {
0:             createJmsConsumer();
0:         }
0: 
0:         final AtomicInteger recvCount = new AtomicInteger(0);
0:         getJmsConsumer().setMessageListener(new MessageListener() {
0:             public void onMessage(Message msg) {
0:                 incThroughput();
0:                 recvCount.incrementAndGet();
0:                 recvCount.notify();
0:             }
0:         });
0: 
0:         try {
0:             getConnection().start();
0:             log.info("Starting to asynchronously receive " + client.getRecvCount() + " messages...");
0:             try {
0:                 while (recvCount.get() < count) {
0:                     recvCount.wait();
0:                 }
0:             } catch (InterruptedException e) {
0:                 throw new JMSException("JMS consumer thread wait has been interrupted. Message: " + e.getMessage());
0:             }
0:         } finally {
0:             getConnection().close();
0:         }
0:     }
0: 
0:     public Connection getConnection() throws JMSException {
0:         Connection c = super.getConnection();
0:         if (c.getClientID() == null && client.isDurable()) {
0:             c.setClientID(getClientName());
0:         }
0:         return c;
0:     }
0: 
0:         Destination[] dest = createDestination(destIndex, destCount);
0:         if (client.isDurable()) {
0:             log.info("Creating durable subscriber to: " + dest.toString());
0:             log.info("Creating non-durable consumer to: " + dest.toString());
0:         if (client.isDurable()) {
0:             log.info("Creating durable subscriber to: " + dest.toString());
0:             log.info("Creating non-durable consumer to: " + dest.toString());
/////////////////////////////////////////////////////////////////////////
0:     public JmsClientProperties getClient() {
0:         return client;
0:     public void setClient(JmsClientProperties clientProps) {
0:         client = (JmsConsumerProperties)clientProps;
commit:6355225
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.Connection;
0: import javax.jms.Destination;
0: import javax.jms.JMSException;
0: import javax.jms.Message;
0: import javax.jms.MessageConsumer;
0: import javax.jms.MessageListener;
0: import javax.jms.Topic;
0: 
/////////////////////////////////////////////////////////////////////////
0:     
0:     public Connection getConnection() throws JMSException {
0:     	Connection c = super.getConnection();
0:     	if (c.getClientID() == null && isDurable()) {
0:     		c.setClientID(getClientName());
0:     	}
0:     	return c;
0:     }
0:     
commit:e0efebe
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             String clientName = getClientName();
0:             if (clientName == null) {
0:                 clientName = "JmsConsumer";
0:             }
0:             jmsConsumer = getSession().createDurableSubscriber((Topic) dest, clientName);
/////////////////////////////////////////////////////////////////////////
0:             String clientName = getClientName();
0:             if (clientName == null) {
0:                 clientName = "JmsConsumer";
0:             }
0:             jmsConsumer = getSession().createDurableSubscriber((Topic) dest, clientName, selector, noLocal);
/////////////////////////////////////////////////////////////////////////
commit:fa37910
/////////////////////////////////////////////////////////////////////////
0: 
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicInteger;
commit:a38f71d
/////////////////////////////////////////////////////////////////////////
0:         String[] options = new String[21];
/////////////////////////////////////////////////////////////////////////
0:         options[16] = "-Dfactory.optimAck=true";
0:         options[17] = "-Dfactory.optimDispatch=true";
0:         options[18] = "-Dfactory.prefetchQueue=100";
0:         options[19] = "-Dfactory.prefetchTopic=32767";
0:         options[20] = "-Dfactory.useRetroactive=false";
commit:5f5bff6
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.LogFactory;
0: import org.apache.commons.logging.Log;
0: import javax.jms.MessageListener;
0: import javax.jms.MessageConsumer;
0: import javax.jms.JMSException;
0: import javax.jms.Destination;
0: import javax.jms.Topic;
0: import javax.jms.Message;
0: import java.util.Properties;
0: import java.util.concurrent.atomic.AtomicInteger;
0: public class JmsConsumerClient extends JmsPerformanceSupport {
0:     private static final Log log = LogFactory.getLog(JmsConsumerClient.class);
0:     private static final String PREFIX_CONFIG_CONSUMER = "consumer.";
0:     public  static final String TIME_BASED_RECEIVING  = "time";
0:     public  static final String COUNT_BASED_RECEIVING = "count";
0:     protected Properties      jmsConsumerSettings = new Properties();
0:     protected MessageConsumer jmsConsumer;
0:     protected boolean durable   = false;
0:     protected boolean asyncRecv = true;
0:     protected String  consumerName = "TestConsumerClient";
0:     protected long   recvCount    = 1000000;       // Receive a million messages by default
0:     protected long   recvDuration = 5 * 60 * 1000; // Receive for 5 mins by default
0:     protected String recvType     = TIME_BASED_RECEIVING;
0:     public void receiveMessages() throws JMSException {
0:         if (listener != null) {
0:             listener.onConfigEnd(this);
0:         }
0:         if (isAsyncRecv()) {
0:             receiveAsyncMessages();
0:             receiveSyncMessages();
0:         }
0:     }
0: 
0:     public void receiveSyncMessages() throws JMSException {
0:         if (getJmsConsumer() == null) {
0:             createJmsConsumer();
0:         try {
0:             if (listener != null) {
0:                 listener.onConsumeStart(this);
0:             }
0:             if (getRecvType().equalsIgnoreCase(TIME_BASED_RECEIVING)) {
0:                 long endTime = System.currentTimeMillis() + getRecvDuration();
0:                 while (System.currentTimeMillis() < endTime) {
0:                     getJmsConsumer().receive();
0:                     incThroughput();
0:                 }
0:             } else {
0:                 int count = 0;
0:                 while (count < getRecvCount()) {
0:                     getJmsConsumer().receive();
0:                     incThroughput();
0:                     count++;
0:                 }
0:             }
0:         } finally {
0:             if (listener != null) {
0:                 listener.onConsumeEnd(this);
0:             }
0:             getConnection().close();
0:         }
0:     }
0: 
0:     public void receiveAsyncMessages() throws JMSException {
0:         if (getJmsConsumer() == null) {
0:             createJmsConsumer();
0:         }
0: 
0:         if (getRecvType().equalsIgnoreCase(TIME_BASED_RECEIVING)) {
0:             getJmsConsumer().setMessageListener(new MessageListener() {
0:                 public void onMessage(Message msg) {
0:                     incThroughput();
0:                 }
0:             });
0:                 getConnection().start();
0:                 if (listener != null) {
0:                     listener.onConsumeStart(this);
0:                 }
0:                 try {
0:                     Thread.sleep(getRecvDuration());
0:                 } catch (InterruptedException e) {
0:                     throw new JMSException("JMS consumer thread sleep has been interrupted. Message: " + e.getMessage());
0:                 }
0:             } finally {
0:                 if (listener != null) {
0:                     listener.onConsumeEnd(this);
0:                 }
0:                 getConnection().close();
0:             final AtomicInteger count = new AtomicInteger(0);
0:             getJmsConsumer().setMessageListener(new MessageListener() {
0:                 public void onMessage(Message msg) {
0:                     incThroughput();
0:                     count.incrementAndGet();
0:                     count.notify();
0:                 }
0:             });
0:             try {
0:                 getConnection().start();
0:                 if (listener != null) {
0:                     listener.onConsumeStart(this);
0:                 }
0:                 try {
0:                     while (count.get() < getRecvCount()) {
0:                         count.wait();
0:                     }
0:                 } catch (InterruptedException e) {
0:                     throw new JMSException("JMS consumer thread wait has been interrupted. Message: " + e.getMessage());
0:                 }
0:             } finally {
0:                 if (listener != null) {
0:                     listener.onConsumeEnd(this);
0:                 }
0:                 getConnection().close();
0:             }
0:     public MessageConsumer createJmsConsumer() throws JMSException {
0:         Destination[] dest = createDestination();
0:         return createJmsConsumer(dest[0]);
0:     public MessageConsumer createJmsConsumer(Destination dest) throws JMSException {
0:         if (isDurable()) {
0:             jmsConsumer = getSession().createDurableSubscriber((Topic)dest, getConsumerName());
0:         } else {
0:             jmsConsumer = getSession().createConsumer(dest);
0:         }
0:         return jmsConsumer;
0:     public MessageConsumer createJmsConsumer(Destination dest, String selector, boolean noLocal) throws JMSException {
0:         if (isDurable()) {
0:             jmsConsumer = getSession().createDurableSubscriber((Topic)dest, getConsumerName(), selector, noLocal);
0:         } else {
0:             jmsConsumer = getSession().createConsumer(dest, selector, noLocal);
0:         }
0:         return jmsConsumer;
0:     }
0: 
0:     public MessageConsumer getJmsConsumer() {
0:         return jmsConsumer;
0:     }
0: 
0:     public Properties getJmsConsumerSettings() {
0:         return jmsConsumerSettings;
0:     }
0: 
0:     public void setJmsConsumerSettings(Properties jmsConsumerSettings) {
0:         this.jmsConsumerSettings = jmsConsumerSettings;
0:         ReflectionUtil.configureClass(this, jmsConsumerSettings);
0:     }
0:         return durable;
0:         this.durable = durable;
0:     public boolean isAsyncRecv() {
0:         return asyncRecv;
0:     public void setAsyncRecv(boolean asyncRecv) {
0:         this.asyncRecv = asyncRecv;
0:     public String getConsumerName() {
0:         return consumerName;
0:     public void setConsumerName(String consumerName) {
0:         this.consumerName = consumerName;
0:     public long getRecvCount() {
0:         return recvCount;
0:     public void setRecvCount(long recvCount) {
0:         this.recvCount = recvCount;
0:     public long getRecvDuration() {
0:         return recvDuration;
0:     }
0:     public void setRecvDuration(long recvDuration) {
0:         this.recvDuration = recvDuration;
0:     }
0: 
0:     public String getRecvType() {
0:         return recvType;
0:     }
0: 
0:     public void setRecvType(String recvType) {
0:         this.recvType = recvType;
0:     }
0: 
0:     public Properties getSettings() {
0:         Properties allSettings = new Properties(jmsConsumerSettings);
0:         allSettings.putAll(super.getSettings());
0:         return allSettings;
0:     }
0: 
0:     public void setSettings(Properties settings) {
0:         super.setSettings(settings);
0:         ReflectionUtil.configureClass(this, jmsConsumerSettings);
0:     }
0: 
0:     public void setProperty(String key, String value) {
0:         if (key.startsWith(PREFIX_CONFIG_CONSUMER)) {
0:             jmsConsumerSettings.setProperty(key, value);
0:             super.setProperty(key, value);
0: 
0:     public static void main(String[] args) throws JMSException {
0:         String[] options = new String[22];
0:         options[0] = "-Dsampler.duration=60000";     // 1 min
0:         options[1] = "-Dsampler.interval=5000";      // 5 secs
0:         options[2] = "-Dsampler.rampUpTime=10000";   // 10 secs
0:         options[3] = "-Dsampler.rampDownTime=10000"; // 10 secs
0: 
0:         options[4] = "-Dclient.spiClass=org.apache.activemq.tool.spi.ActiveMQPojoSPI";
0:         options[5] = "-Dclient.sessTransacted=false";
0:         options[6] = "-Dclient.sessAckMode=autoAck";
0:         options[7] = "-Dclient.destName=topic://FOO.BAR.TEST";
0:         options[8] = "-Dclient.destCount=1";
0:         options[9] = "-Dclient.destComposite=false";
0: 
0:         options[10] = "-Dconsumer.durable=false";
0:         options[11] = "-Dconsumer.asyncRecv=true";
0:         options[12] = "-Dconsumer.recvCount=1000";     // 1000 messages
0:         options[13] = "-Dconsumer.recvDuration=60000"; // 1 min
0:         options[14] = "-Dconsumer.recvType=time";
0: 
0:         options[15] = "-Dfactory.brokerUrl=tcp://localhost:61616";
0:         options[16] = "-Dfactory.clientID=consumerSampleClient";
0:         options[17] = "-Dfactory.optimAck=true";
0:         options[18] = "-Dfactory.optimDispatch=true";
0:         options[19] = "-Dfactory.prefetchQueue=100";
0:         options[20] = "-Dfactory.prefetchTopic=32767";
0:         options[21] = "-Dfactory.useRetroactive=false";
0: 
0:         args = options;
0: 
0:         Properties samplerSettings  = new Properties();
0:         Properties consumerSettings = new Properties();
0: 
0:         for (int i=0; i<args.length; i++) {
0:             // Get property define options only
0:             if (args[i].startsWith("-D")) {
0:                 String propDefine = args[i].substring("-D".length());
0:                 int  index = propDefine.indexOf("=");
0:                 String key = propDefine.substring(0, index);
0:                 String val = propDefine.substring(index+1);
0:                 if (key.startsWith("sampler.")) {
0:                     samplerSettings.setProperty(key, val);
0:                 } else {
0:                     consumerSettings.setProperty(key, val);
0:                 }
0:             }
0:         }
0: 
0:         JmsConsumerClient client = new JmsConsumerClient();
0:         client.setSettings(consumerSettings);
0: 
0:         PerfMeasurementTool sampler = new PerfMeasurementTool();
0:         sampler.setSamplerSettings(samplerSettings);
0:         sampler.registerClient(client);
0:         sampler.startSampler();
0: 
0:         client.setPerfEventListener(sampler);
0:         client.receiveMessages();
0:     }
author:Frederick G. Oconer
-------------------------------------------------------------------------------
commit:4fb36fe
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: 
0: import javax.jms.*;
0: import java.util.Properties;
0:     public static final String TIME_BASED_RECEIVING = "time";
0:     public static final String COUNT_BASED_RECEIVING = "count";
0:     protected Properties jmsConsumerSettings = new Properties();
0:     protected boolean durable = false;
0:     protected String consumerName = "TestConsumerClient";
0:     protected long recvCount = 1000000;       // Receive a million messages by default
0:     protected long recvDuration = 5 * 60 * 1000; // Receive for 5 mins by default
0:     protected String recvType = TIME_BASED_RECEIVING;
/////////////////////////////////////////////////////////////////////////
0:             jmsConsumer = getSession().createDurableSubscriber((Topic) dest, getConsumerName());
/////////////////////////////////////////////////////////////////////////
0:             jmsConsumer = getSession().createDurableSubscriber((Topic) dest, getConsumerName(), selector, noLocal);
/////////////////////////////////////////////////////////////////////////
0:         Properties samplerSettings = new Properties();
0:         for (int i = 0; i < args.length; i++) {
0:             int index = args[i].indexOf("=");
0:             String key = args[i].substring(0, index);
0:             String val = args[i].substring(index + 1);
0:             if (key.startsWith("sampler.")) {
0:                 samplerSettings.setProperty(key, val);
0:             } else {
0:                 consumerSettings.setProperty(key, val);
0: 
commit:264f0a3
/////////////////////////////////////////////////////////////////////////
0:         /*String[] options = new String[21];
/////////////////////////////////////////////////////////////////////////
0:         args = options;   */
commit:16439a4
/////////////////////////////////////////////////////////////////////////
0:     private boolean isAsync = true;
/////////////////////////////////////////////////////////////////////////
0:         if (isAsync) {
0:             getMessageConsumer().setMessageListener(this);
0:             getConnection().start();
0:             try {
0:                 Thread.sleep(duration);
0:             } catch (InterruptedException e) {
0:                 throw new JMSException("Error while consumer is sleeping " + e.getMessage());
0:             }
0:         } else {
0:             getConnection().start();
0:             consumeMessages(getMessageConsumer(), duration);
0:         close(); //close consumer, session, and connection.
0:     //Increments throughput
0:         System.out.println(message.toString());
0:         this.incThroughput();
0:     }
0:     protected void consumeMessages(MessageConsumer consumer, long duration) throws JMSException {
0: 
0:         long currentTime = System.currentTimeMillis();
0:         long endTime = currentTime + duration;
0: 
0:         while (System.currentTimeMillis() <= endTime) {
0:             Message message = consumer.receive();
0:             onMessage(message);
0:     protected void close() throws JMSException {
0:         getMessageConsumer().close();
0:         getSession().close();
0:         getConnection().close();
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     public boolean isDurable() {
0:         return isDurable;
0:     }
0: 
0:     public void setDurable(boolean durable) {
0:         isDurable = durable;
0:     }
0: 
0:     public boolean isAsync() {
0:         return isAsync;
0:     }
0: 
0:     public void setAsync(boolean async) {
0:         isAsync = async;
0:     }
0: 
commit:ef7ccea
/////////////////////////////////////////////////////////////////////////
0: /**
0:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: 
0: package org.apache.activemq.tool;
0: 
0: import javax.jms.*;
0: 
0: public class JmsConsumerClient extends JmsPerfClientSupport implements MessageListener {
0: 
0:     private ConnectionFactory factory = null;
0: 
0:     private String factoryClass = null;
0:     private String brokerUrl = null;
0:     private String destinationName = null;
0:     private Destination destination = null;
0: 
0:     private boolean isDurable = false;
0: 
0:     public JmsConsumerClient(ConnectionFactory factory) {
0:         this.factory = factory;
0:     }
0: 
0:     public JmsConsumerClient(ConnectionFactory factory, String destinationName) {
0:         this.factory = factory;
0:         this.setDestinationName(destinationName);
0:     }
0: 
0:     public JmsConsumerClient(String factoryClass, String brokerUrl, String destinationName) {
0:         this.factoryClass = factoryClass;
0:         this.brokerUrl = brokerUrl;
0:         this.destinationName = destinationName;
0:     }
0: 
0:     public JmsConsumerClient(String brokerUrl, String destinationName) {
0:         this.brokerUrl = brokerUrl;
0:         this.destinationName = destinationName;
0:     }
0: 
0:     public void createConsumer(long duration) throws JMSException {
0:         listener.onConfigEnd(this);
0: 
0:         // Create connection factory
0:         if (factory != null) {
0:             createConnectionFactory(factory);
0:         } else if (factoryClass != null) {
0:             createConnectionFactory(factoryClass, brokerUrl);
0:         } else {
0:             createConnectionFactory(brokerUrl);
0:         }
0: 
0:         if (getDestination() == null) {
0:             setDestination(getDestinationName());
0:         }
0: 
0:         System.out.println("Connecting to URL: " + brokerUrl);
0:         System.out.println("Consuming: " + destination);
0:         System.out.println("Using " + (isDurable ? "durable" : "non-durable") + " subscription");
0: 
0: 
0:         if (isDurable) {
0:             createDurableSubscriber((Topic) getDestination(), getClass().getName());
0:         } else {
0:             createMessageConsumer(getDestination());
0:         }
0: 
0:         getMessageConsumer().setMessageListener(this);
0:         getConnection().start();
0: 
0:         try {
0:             Thread.sleep(duration);
0:         } catch (InterruptedException e) {
0:             throw new JMSException("Error while consumer is sleeping " + e.getMessage());
0:         }
0: 
0:         getMessageConsumer().close();
0:         getConnection().close();
0: 
0:         System.out.println("Throughput : " + this.getThroughput());
0: 
0:         listener.onConfigEnd(this);
0:     }
0: 
0:     public void onMessage(Message message) {
0:         try {
0:             TextMessage textMessage = (TextMessage) message;
0: 
0:             // lets force the content to be deserialized
0:             String text = textMessage.getText();
0:             System.out.println("message: " + text + ":" + this.getThroughput());
0:             this.incThroughput();
0:         } catch (JMSException e) {
0:             // TODO Auto-generated catch block
0:             e.printStackTrace();
0:         }
0:     }
0: 
0:     public static void main(String[] args) throws Exception {
0:         JmsConsumerClient cons = new JmsConsumerClient("org.apache.activemq.ActiveMQConnectionFactory", "tcp://localhost:61616", "topic://TEST.FOO");
0:         cons.setPerfEventListener(new PerfEventAdapter());
0:         cons.createConsumer(20000);
0:     }
0: 
0:     // Helper Methods
0: 
0:     public String getDestinationName() {
0:         return this.destinationName;
0:     }
0: 
0:     public void setDestinationName(String destinationName) {
0:         this.destinationName = destinationName;
0:     }
0: 
0:     public Destination getDestination() {
0:         return this.destination;
0:     }
0: 
0:     public void setDestination(Destination dest) {
0:         this.destination = dest;
0:     }
0: 
0:     public void setDestination(String destinationName) throws JMSException {
0: 
0:         this.setDestinationName(destinationName);
0:         // Create destinations
0:         if (this.getDestinationName().startsWith("topic://")) {
0:             setDestination(createTopic(getDestinationName().substring("topic://".length())));
0:         } else if (getDestinationName().startsWith("queue://")) {
0:             setDestination(createQueue(getDestinationName().substring("queue://".length())));
0:         } else {
0:             setDestination(createQueue(getDestinationName()));
0:         }
0:     }
0: }
============================================================================