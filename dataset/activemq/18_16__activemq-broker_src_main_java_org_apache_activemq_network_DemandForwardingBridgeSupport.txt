26:687a45a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:7fbbcf3:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
2:633428c:  *
1:687a45a:  * Unless required by applicable law or agreed to in writing, software
1:687a45a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:687a45a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:687a45a:  * See the License for the specific language governing permissions and
1:687a45a:  * limitations under the License.
26:687a45a:  */
1:687a45a: package org.apache.activemq.network;
1:05f82a9: 
1:332c35c: import java.io.IOException;
1:332c35c: import java.security.GeneralSecurityException;
1:332c35c: import java.security.cert.X509Certificate;
1:2bbfbcf: import java.util.Arrays;
1:2bbfbcf: import java.util.Collection;
1:e73ab34: import java.util.Collections;
1:2bbfbcf: import java.util.Iterator;
1:2bbfbcf: import java.util.List;
1:2bbfbcf: import java.util.Properties;
1:e73ab34: import java.util.Set;
1:332c35c: import java.util.concurrent.ConcurrentHashMap;
1:9ef4259: import java.util.concurrent.ConcurrentMap;
1:332c35c: import java.util.concurrent.CountDownLatch;
1:f1eb92e: import java.util.concurrent.ExecutionException;
1:27440ae: import java.util.concurrent.ExecutorService;
1:27440ae: import java.util.concurrent.Executors;
1:f1eb92e: import java.util.concurrent.Future;
1:332c35c: import java.util.concurrent.TimeUnit;
1:f1eb92e: import java.util.concurrent.TimeoutException;
1:332c35c: import java.util.concurrent.atomic.AtomicBoolean;
1:3ca439c: import java.util.regex.Pattern;
1:41211c7: 
1:f793fbd: import javax.management.ObjectName;
1:a554c7c: 
1:8012f28: import org.apache.activemq.DestinationDoesNotExistException;
1:3221b16: import org.apache.activemq.Service;
1:8012f28: import org.apache.activemq.advisory.AdvisoryBroker;
1:3221b16: import org.apache.activemq.advisory.AdvisorySupport;
1:301203e: import org.apache.activemq.broker.BrokerService;
1:301203e: import org.apache.activemq.broker.BrokerServiceAware;
1:8012f28: import org.apache.activemq.broker.ConnectionContext;
1:3221b16: import org.apache.activemq.broker.TransportConnection;
1:301203e: import org.apache.activemq.broker.region.AbstractRegion;
1:f232cec: import org.apache.activemq.broker.region.DurableTopicSubscription;
1:7dc2c4e: import org.apache.activemq.broker.region.Region;
1:301203e: import org.apache.activemq.broker.region.RegionBroker;
1:301203e: import org.apache.activemq.broker.region.Subscription;
1:af1b232: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:a554c7c: import org.apache.activemq.command.ActiveMQDestination;
1:a554c7c: import org.apache.activemq.command.ActiveMQMessage;
1:a554c7c: import org.apache.activemq.command.ActiveMQTempDestination;
1:a554c7c: import org.apache.activemq.command.ActiveMQTopic;
1:a554c7c: import org.apache.activemq.command.BrokerId;
1:a554c7c: import org.apache.activemq.command.BrokerInfo;
1:3953b9a: import org.apache.activemq.command.BrokerSubscriptionInfo;
1:a554c7c: import org.apache.activemq.command.Command;
1:3953b9a: import org.apache.activemq.command.CommandTypes;
1:a554c7c: import org.apache.activemq.command.ConnectionError;
1:a554c7c: import org.apache.activemq.command.ConnectionId;
1:a554c7c: import org.apache.activemq.command.ConnectionInfo;
1:a554c7c: import org.apache.activemq.command.ConsumerId;
1:a554c7c: import org.apache.activemq.command.ConsumerInfo;
1:a554c7c: import org.apache.activemq.command.DataStructure;
1:a554c7c: import org.apache.activemq.command.DestinationInfo;
1:a554c7c: import org.apache.activemq.command.ExceptionResponse;
1:a554c7c: import org.apache.activemq.command.KeepAliveInfo;
1:a554c7c: import org.apache.activemq.command.Message;
1:a554c7c: import org.apache.activemq.command.MessageAck;
1:a554c7c: import org.apache.activemq.command.MessageDispatch;
1:a554c7c: import org.apache.activemq.command.MessageId;
1:a554c7c: import org.apache.activemq.command.NetworkBridgeFilter;
1:a554c7c: import org.apache.activemq.command.ProducerInfo;
1:a554c7c: import org.apache.activemq.command.RemoveInfo;
1:a554c7c: import org.apache.activemq.command.RemoveSubscriptionInfo;
1:a554c7c: import org.apache.activemq.command.Response;
1:a554c7c: import org.apache.activemq.command.SessionInfo;
1:a554c7c: import org.apache.activemq.command.ShutdownInfo;
1:a554c7c: import org.apache.activemq.command.SubscriptionInfo;
1:a554c7c: import org.apache.activemq.command.WireFormatInfo;
1:3221b16: import org.apache.activemq.filter.DestinationFilter;
1:50d27e7: import org.apache.activemq.filter.NonCachedMessageEvaluationContext;
1:8012f28: import org.apache.activemq.security.SecurityContext;
1:3221b16: import org.apache.activemq.transport.DefaultTransportListener;
1:3221b16: import org.apache.activemq.transport.FutureResponse;
1:3221b16: import org.apache.activemq.transport.ResponseCallback;
1:3221b16: import org.apache.activemq.transport.Transport;
1:3221b16: import org.apache.activemq.transport.TransportDisposedIOException;
1:8e42528: import org.apache.activemq.transport.TransportFilter;
1:63f0b7e: import org.apache.activemq.transport.failover.FailoverTransport;
1:9f9b0fb: import org.apache.activemq.transport.tcp.TcpTransport;
1:3221b16: import org.apache.activemq.util.IdGenerator;
1:3221b16: import org.apache.activemq.util.IntrospectionSupport;
1:3221b16: import org.apache.activemq.util.LongSequenceGenerator;
1:3221b16: import org.apache.activemq.util.MarshallingSupport;
1:d206621: import org.apache.activemq.util.NetworkBridgeUtils;
1:3221b16: import org.apache.activemq.util.ServiceStopper;
1:3221b16: import org.apache.activemq.util.ServiceSupport;
1:e73ab34: import org.apache.activemq.util.StringToListOfActiveMQDestinationConverter;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:332c35c: 
1:7fbbcf3: /**
1:687a45a:  * A useful base class for implementing demand forwarding bridges.
1:7fbbcf3:  */
1:301203e: public abstract class DemandForwardingBridgeSupport implements NetworkBridge, BrokerServiceAware {
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(DemandForwardingBridgeSupport.class);
1:05f82a9:     protected static final String DURABLE_SUB_PREFIX = "NC-DS_";
1:687a45a:     protected final Transport localBroker;
1:687a45a:     protected final Transport remoteBroker;
1:60bdfc0:     protected IdGenerator idGenerator = new IdGenerator();
1:ad2546f:     protected final LongSequenceGenerator consumerIdGenerator = new LongSequenceGenerator();
1:687a45a:     protected ConnectionInfo localConnectionInfo;
1:687a45a:     protected ConnectionInfo remoteConnectionInfo;
1:687a45a:     protected SessionInfo localSessionInfo;
1:687a45a:     protected ProducerInfo producerInfo;
1:ad2546f:     protected String remoteBrokerName = "Unknown";
1:687a45a:     protected String localClientId;
1:687a45a:     protected ConsumerInfo demandConsumerInfo;
1:687a45a:     protected int demandConsumerDispatched;
1:ad2546f:     protected final AtomicBoolean localBridgeStarted = new AtomicBoolean(false);
1:ad2546f:     protected final AtomicBoolean remoteBridgeStarted = new AtomicBoolean(false);
1:f1eb92e:     protected final AtomicBoolean bridgeFailed = new AtomicBoolean();
1:f1eb92e:     protected final AtomicBoolean disposed = new AtomicBoolean();
1:687a45a:     protected BrokerId localBrokerId;
1:687a45a:     protected ActiveMQDestination[] excludedDestinations;
1:687a45a:     protected ActiveMQDestination[] dynamicallyIncludedDestinations;
1:687a45a:     protected ActiveMQDestination[] staticallyIncludedDestinations;
1:687a45a:     protected ActiveMQDestination[] durableDestinations;
1:3953b9a:     protected final ConcurrentMap<ConsumerId, DemandSubscription> subscriptionMapByLocalId = new ConcurrentHashMap<>();
1:3953b9a:     protected final ConcurrentMap<ConsumerId, DemandSubscription> subscriptionMapByRemoteId = new ConcurrentHashMap<>();
1:e73ab34:     protected final Set<ConsumerId> forcedDurableRemoteId = Collections.newSetFromMap(new ConcurrentHashMap<ConsumerId, Boolean>());
1:2bbfbcf:     protected final BrokerId localBrokerPath[] = new BrokerId[]{null};
1:a80acbb:     protected final CountDownLatch startedLatch = new CountDownLatch(2);
1:a80acbb:     protected final CountDownLatch localStartedLatch = new CountDownLatch(1);
1:3953b9a:     protected final CountDownLatch staticDestinationsLatch = new CountDownLatch(1);
1:ad2546f:     protected final AtomicBoolean lastConnectSucceeded = new AtomicBoolean(false);
1:ae73f86:     protected NetworkBridgeConfiguration configuration;
1:90fcbc8:     protected final NetworkBridgeFilterFactory defaultFilterFactory = new DefaultNetworkBridgeFilterFactory();
1:f1eb92e: 
1:2bbfbcf:     protected final BrokerId remoteBrokerPath[] = new BrokerId[]{null};
1:174c405:     protected BrokerId remoteBrokerId;
1:174c405: 
1:10c998b:     protected final NetworkBridgeStatistics networkBridgeStatistics = new NetworkBridgeStatistics();
1:f1eb92e: 
1:ecf89a6:     private NetworkBridgeListener networkBridgeListener;
1:ecf89a6:     private boolean createdByDuplex;
1:ecf89a6:     private BrokerInfo localBrokerInfo;
1:ecf89a6:     private BrokerInfo remoteBrokerInfo;
1:f1eb92e: 
1:f1eb92e:     private final FutureBrokerInfo futureRemoteBrokerInfo = new FutureBrokerInfo(remoteBrokerInfo, disposed);
1:f1eb92e:     private final FutureBrokerInfo futureLocalBrokerInfo = new FutureBrokerInfo(localBrokerInfo, disposed);
1:f1eb92e: 
1:f392884:     private final AtomicBoolean started = new AtomicBoolean();
1:f4012c5:     private TransportConnection duplexInitiatingConnection;
1:50ec158:     private final AtomicBoolean duplexInitiatingConnectionInfoReceived = new AtomicBoolean();
1:620523a:     protected BrokerService brokerService = null;
1:f793fbd:     private ObjectName mbeanObjectName;
1:c518498:     private final ExecutorService serialExecutor = Executors.newSingleThreadExecutor();
1:b9cb02a:     //Use a new executor for processing BrokerSubscriptionInfo so we don't block other threads
1:b9cb02a:     private final ExecutorService syncExecutor = Executors.newSingleThreadExecutor();
1:8012f28:     private Transport duplexInboundLocalBroker = null;
1:8012f28:     private ProducerInfo duplexInboundLocalProducerInfo;
1:f1eb92e: 
1:ae73f86:     public DemandForwardingBridgeSupport(NetworkBridgeConfiguration configuration, Transport localBroker, Transport remoteBroker) {
1:230a86c:         this.configuration = configuration;
1:687a45a:         this.localBroker = localBroker;
1:687a45a:         this.remoteBroker = remoteBroker;
1:5b8a886:     }
1:05f82a9: 
1:f4012c5:     public void duplexStart(TransportConnection connection, BrokerInfo localBrokerInfo, BrokerInfo remoteBrokerInfo) throws Exception {
1:230a86c:         this.localBrokerInfo = localBrokerInfo;
1:230a86c:         this.remoteBrokerInfo = remoteBrokerInfo;
1:f4012c5:         this.duplexInitiatingConnection = connection;
1:35ba427:         start();
1:35ba427:         serviceRemoteCommand(remoteBrokerInfo);
1:174c405:     }
1:05f82a9: 
1:f1eb92e:     @Override
1:230a86c:     public void start() throws Exception {
1:230a86c:         if (started.compareAndSet(false, true)) {
1:8012f28: 
1:6c1676b:             if (brokerService == null) {
1:6c1676b:                 throw new IllegalArgumentException("BrokerService is null on " + this);
1:8012f28:             }
1:8012f28: 
1:10c998b:             networkBridgeStatistics.setEnabled(brokerService.isEnableStatistics());
1:10c998b: 
1:806ec21:             if (isDuplex()) {
1:d84a586:                 duplexInboundLocalBroker = NetworkBridgeFactory.createLocalAsyncTransport(brokerService.getBroker().getVmConnectorURI());
1:8012f28:                 duplexInboundLocalBroker.setTransportListener(new DefaultTransportListener() {
1:8012f28: 
1:8012f28:                     @Override
1:8012f28:                     public void onCommand(Object o) {
1:8012f28:                         Command command = (Command) o;
1:8012f28:                         serviceLocalCommand(command);
1:8012f28:                     }
1:8012f28: 
1:8012f28:                     @Override
1:8012f28:                     public void onException(IOException error) {
1:8012f28:                         serviceLocalException(error);
1:8012f28:                     }
1:f383ca1:                 });
1:8012f28:                 duplexInboundLocalBroker.start();
1:8012f28:             }
1:8012f28: 
1:230a86c:             localBroker.setTransportListener(new DefaultTransportListener() {
1:05f82a9: 
1:c518498:                 @Override
1:230a86c:                 public void onCommand(Object o) {
1:9ca56a0:                     Command command = (Command) o;
1:35ba427:                     serviceLocalCommand(command);
1:174c405:                 }
1:9670af1: 
1:c518498:                 @Override
1:230a86c:                 public void onException(IOException error) {
1:f1eb92e:                     if (!futureLocalBrokerInfo.isDone()) {
1:2537266:                         LOG.info("error with pending local brokerInfo on: " + localBroker, error);
1:f1eb92e:                         futureLocalBrokerInfo.cancel(true);
1:f1eb92e:                         return;
1:174c405:                     }
1:35ba427:                     serviceLocalException(error);
1:174c405:                 }
1:8012f28:             });
1:9670af1: 
1:4acd132:             remoteBroker.setTransportListener(new DefaultTransportListener() {
1:966658f: 
1:8012f28:                 @Override
1:230a86c:                 public void onCommand(Object o) {
1:9ca56a0:                     Command command = (Command) o;
1:35ba427:                     serviceRemoteCommand(command);
1:174c405:                 }
1:5511217: 
1:c518498:                 @Override
1:230a86c:                 public void onException(IOException error) {
1:f1eb92e:                     if (!futureRemoteBrokerInfo.isDone()) {
1:2537266:                         LOG.info("error with pending remote brokerInfo on: " + remoteBroker, error);
1:f1eb92e:                         futureRemoteBrokerInfo.cancel(true);
1:301203e:                         return;
1:174c405:                     }
1:8012f28:                     serviceRemoteException(error);
1:05f82a9:                 }
1:44e6f7d:             });
1:301203e: 
1:35ba427:             remoteBroker.start();
1:f1eb92e:             localBroker.start();
1:2bda17a: 
1:6b4509c:             if (!disposed.get()) {
1:88d85ae:                 try {
1:f1eb92e:                     triggerStartAsyncNetworkBridgeCreation();
1:6b4509c:                 } catch (IOException e) {
1:6b4509c:                     LOG.warn("Caught exception from remote start", e);
1:c372448:                 }
1:f383ca1:             } else {
1:5fc2535:                 LOG.warn("Bridge was disposed before the start() method was fully executed.");
1:6b4509c:                 throw new TransportDisposedIOException();
1:8012f28:             }
1:8012f28:         }
1:8012f28:     }
1:8e59e24: 
1:c518498:     @Override
1:f1eb92e:     public void stop() throws Exception {
1:f1eb92e:         if (started.compareAndSet(true, false)) {
1:5d42b72:             if (disposed.compareAndSet(false, true)) {
1:e1bbde7:                 LOG.debug(" stopping {} bridge to {}", configuration.getBrokerName(), remoteBrokerName);
1:2bda17a: 
1:f1eb92e:                 futureRemoteBrokerInfo.cancel(true);
1:f1eb92e:                 futureLocalBrokerInfo.cancel(true);
1:f1eb92e: 
1:489f929:                 NetworkBridgeListener l = this.networkBridgeListener;
1:6b4509c:                 if (l != null) {
1:f1eb92e:                     l.onStop(this);
1:489f929:                 }
1:8012f28:                 try {
1:c372448:                     // local start complete
1:c372448:                     if (startedLatch.getCount() < 2) {
1:e1bbde7:                         LOG.trace("{} unregister bridge ({}) to {}", new Object[]{
1:e1bbde7:                                 configuration.getBrokerName(), this, remoteBrokerName
1:e1bbde7:                         });
1:c372448:                         brokerService.getBroker().removeBroker(null, remoteBrokerInfo);
1:c372448:                         brokerService.getBroker().networkBridgeStopped(remoteBrokerInfo);
1:489f929:                     }
1:489f929: 
1:f1eb92e:                     remoteBridgeStarted.set(false);
1:f1eb92e:                     final CountDownLatch sendShutdown = new CountDownLatch(1);
1:489f929: 
1:f1eb92e:                     brokerService.getTaskRunnerFactory().execute(new Runnable() {
1:f1eb92e:                         @Override
1:f1eb92e:                         public void run() {
1:6b4509c:                             try {
1:27440ae:                                 serialExecutor.shutdown();
1:27440ae:                                 if (!serialExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
1:27440ae:                                     List<Runnable> pendingTasks = serialExecutor.shutdownNow();
1:e1bbde7:                                     LOG.info("pending tasks on stop {}", pendingTasks);
1:489f929:                                 }
1:b9cb02a:                                 //Shutdown the syncExecutor, call countDown to make sure a thread can
1:b9cb02a:                                 //terminate if it is waiting
1:b9cb02a:                                 staticDestinationsLatch.countDown();
1:b9cb02a:                                 syncExecutor.shutdown();
1:b9cb02a:                                 if (!syncExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
1:b9cb02a:                                     List<Runnable> pendingTasks = syncExecutor.shutdownNow();
1:b9cb02a:                                     LOG.info("pending tasks on stop {}", pendingTasks);
1:b9cb02a:                                 }
1:f1eb92e:                                 localBroker.oneway(new ShutdownInfo());
1:f1eb92e:                                 remoteBroker.oneway(new ShutdownInfo());
1:27d0ff4:                             } catch (Throwable e) {
1:e1bbde7:                                 LOG.debug("Caught exception sending shutdown", e);
1:05f82a9:                             } finally {
1:5d42b72:                                 sendShutdown.countDown();
1:489f929:                             }
1:c372448: 
1:c372448:                         }
1:f1eb92e:                     }, "ActiveMQ ForwardingBridge StopTask");
1:05f82a9: 
1:f1eb92e:                     if (!sendShutdown.await(10, TimeUnit.SECONDS)) {
1:b0e3570:                         LOG.info("Network Could not shutdown in a timely manner");
1:27440ae:                     }
1:8e59e24:                 } finally {
1:f1eb92e:                     ServiceStopper ss = new ServiceStopper();
1:63f0b7e:                     stopFailoverTransport(remoteBroker);
1:f1eb92e:                     ss.stop(remoteBroker);
1:5d42b72:                     ss.stop(localBroker);
1:8012f28:                     ss.stop(duplexInboundLocalBroker);
1:f1eb92e:                     // Release the started Latch since another thread could be
1:f1eb92e:                     // stuck waiting for it to start up.
1:f1eb92e:                     startedLatch.countDown();
1:f1eb92e:                     startedLatch.countDown();
1:f1eb92e:                     localStartedLatch.countDown();
1:3953b9a:                     staticDestinationsLatch.countDown();
1:f1eb92e: 
1:f1eb92e:                     ss.throwFirstException();
1:6b4509c:                 }
1:05f82a9:             }
1:f1eb92e: 
1:e1bbde7:             LOG.info("{} bridge to {} stopped", configuration.getBrokerName(), remoteBrokerName);
1:966658f:         }
1:5b8a886:     }
1:f1eb92e: 
1:63f0b7e:     private void stopFailoverTransport(Transport transport) {
1:63f0b7e:         FailoverTransport failoverTransport = transport.narrow(FailoverTransport.class);
1:63f0b7e:         if (failoverTransport != null) {
1:63f0b7e:             // may be blocked on write, in which case stop will block
1:63f0b7e:             try {
1:63f0b7e:                 failoverTransport.handleTransportFailure(new IOException("Bridge stopped"));
1:63f0b7e:             } catch (InterruptedException ignored) {}
1:63f0b7e:         }
1:63f0b7e:     }
1:63f0b7e: 
1:f1eb92e:     protected void triggerStartAsyncNetworkBridgeCreation() throws IOException {
1:6c1676b:         brokerService.getTaskRunnerFactory().execute(new Runnable() {
1:c518498:             @Override
1:230a86c:             public void run() {
1:543bc84:                 final String originalName = Thread.currentThread().getName();
1:f1eb92e:                 Thread.currentThread().setName("triggerStartAsyncNetworkBridgeCreation: " +
1:2bbfbcf:                         "remoteBroker=" + remoteBroker + ", localBroker= " + localBroker);
1:f1eb92e: 
1:d185430:                 try {
1:f1eb92e:                     // First we collect the info data from both the local and remote ends
1:f1eb92e:                     collectBrokerInfos();
1:f1eb92e: 
1:f1eb92e:                     // Once we have all required broker info we can attempt to start
1:f1eb92e:                     // the local and then remote sides of the bridge.
1:f1eb92e:                     doStartLocalAndRemoteBridges();
1:5d42b72:                 } finally {
1:543bc84:                     Thread.currentThread().setName(originalName);
1:5511217:                 }
1:301203e:             }
1:e1bbde7:         });
1:301203e:     }
1:f1eb92e: 
1:f1eb92e:     private void collectBrokerInfos() {
1:9f9b0fb:         int timeout = 30000;
1:9f9b0fb:         TcpTransport tcpTransport = remoteBroker.narrow(TcpTransport.class);
1:9f9b0fb:         if (tcpTransport != null) {
1:9f9b0fb:            timeout = tcpTransport.getConnectionTimeout();
1:9f9b0fb:         }
1:f1eb92e: 
1:f1eb92e:         // First wait for the remote to feed us its BrokerInfo, then we can check on
1:f1eb92e:         // the LocalBrokerInfo and decide is this is a loop.
1:f1eb92e:         try {
1:9f9b0fb:             remoteBrokerInfo = futureRemoteBrokerInfo.get(timeout, TimeUnit.MILLISECONDS);
1:f1eb92e:             if (remoteBrokerInfo == null) {
1:a3c8bee:                 serviceLocalException(new Throwable("remoteBrokerInfo is null"));
1:c391321:                 return;
1:301203e:             }
1:f1eb92e:         } catch (Exception e) {
1:f1eb92e:             serviceRemoteException(e);
1:f1eb92e:             return;
1:301203e:         }
1:f1eb92e: 
1:f1eb92e:         try {
1:9f9b0fb:             localBrokerInfo = futureLocalBrokerInfo.get(timeout, TimeUnit.MILLISECONDS);
1:f1eb92e:             if (localBrokerInfo == null) {
1:a3c8bee:                 serviceLocalException(new Throwable("localBrokerInfo is null"));
1:c391321:                 return;
1:8b34eac:             }
1:f1eb92e: 
1:f1eb92e:             // Before we try and build the bridge lets check if we are in a loop
1:f1eb92e:             // and if so just stop now before registering anything.
1:78bedd6:             remoteBrokerId = remoteBrokerInfo.getBrokerId();
1:174c405:             if (localBrokerId.equals(remoteBrokerId)) {
1:e1bbde7:                 LOG.trace("{} disconnecting remote loop back connector for: {}, with id: {}", new Object[]{
1:e1bbde7:                         configuration.getBrokerName(), remoteBrokerName, remoteBrokerId
1:e1bbde7:                 });
1:2bbfbcf:                 ServiceSupport.dispose(localBroker);
1:2bbfbcf:                 ServiceSupport.dispose(remoteBroker);
1:2bbfbcf:                 // the bridge is left in a bit of limbo, but it won't get retried
1:2bbfbcf:                 // in this state.
1:2bbfbcf:                 return;
1:543bc84:             }
1:f1eb92e: 
1:f1eb92e:             // Fill in the remote broker's information now.
1:174c405:             remoteBrokerPath[0] = remoteBrokerId;
1:174c405:             remoteBrokerName = remoteBrokerInfo.getBrokerName();
1:6c5732b:             if (configuration.isUseBrokerNamesAsIdSeed()) {
1:6c5732b:                 idGenerator = new IdGenerator(brokerService.getBrokerName() + "->" + remoteBrokerName);
1:6c5732b:             }
1:27d0ff4:         } catch (Throwable e) {
1:27d0ff4:             serviceLocalException(e);
1:174c405:         }
1:174c405:     }
1:f1eb92e: 
1:f1eb92e:     private void doStartLocalAndRemoteBridges() {
1:c372448: 
1:c372448:         if (disposed.get()) {
1:c372448:             return;
1:c372448:         }
1:c372448: 
1:c372448:         if (isCreatedByDuplex()) {
1:c372448:             // apply remote (propagated) configuration to local duplex bridge before start
1:c372448:             Properties props = null;
1:c372448:             try {
1:c372448:                 props = MarshallingSupport.stringToProperties(remoteBrokerInfo.getNetworkProperties());
1:c372448:                 IntrospectionSupport.getProperties(configuration, props, null);
1:c372448:                 if (configuration.getExcludedDestinations() != null) {
1:c372448:                     excludedDestinations = configuration.getExcludedDestinations().toArray(
1:c372448:                             new ActiveMQDestination[configuration.getExcludedDestinations().size()]);
1:c372448:                 }
1:c372448:                 if (configuration.getStaticallyIncludedDestinations() != null) {
1:c372448:                     staticallyIncludedDestinations = configuration.getStaticallyIncludedDestinations().toArray(
1:c372448:                             new ActiveMQDestination[configuration.getStaticallyIncludedDestinations().size()]);
1:c372448:                 }
1:c372448:                 if (configuration.getDynamicallyIncludedDestinations() != null) {
1:c372448:                     dynamicallyIncludedDestinations = configuration.getDynamicallyIncludedDestinations().toArray(
1:c372448:                             new ActiveMQDestination[configuration.getDynamicallyIncludedDestinations().size()]);
1:c372448:                 }
1:c372448:             } catch (Throwable t) {
1:e1bbde7:                 LOG.error("Error mapping remote configuration: {}", props, t);
1:c372448:             }
1:c372448:         }
1:c372448: 
1:f1eb92e:         try {
1:f1eb92e:             startLocalBridge();
1:f1eb92e:         } catch (Throwable e) {
1:f1eb92e:             serviceLocalException(e);
1:f1eb92e:             return;
1:174c405:         }
1:f1eb92e: 
1:f1eb92e:         try {
1:c372448:             startRemoteBridge();
1:f1eb92e:         } catch (Throwable e) {
1:ad2546f:             serviceRemoteException(e);
1:c1c82be:             return;
1:c1c82be:         }
1:c1c82be: 
1:c1c82be:         try {
1:c1c82be:             if (safeWaitUntilStarted()) {
1:c1c82be:                 setupStaticDestinations();
1:3953b9a:                 staticDestinationsLatch.countDown();
1:c1c82be:             }
1:c1c82be:         } catch (Throwable e) {
1:c1c82be:             serviceLocalException(e);
1:174c405:         }
1:8761189:     }
1:f1eb92e: 
1:174c405:     private void startLocalBridge() throws Throwable {
1:60bdfc0:         if (!bridgeFailed.get() && localBridgeStarted.compareAndSet(false, true)) {
1:230a86c:             synchronized (this) {
1:e1bbde7:                 LOG.trace("{} starting local Bridge, localBroker={}", configuration.getBrokerName(), localBroker);
1:174c405:                 if (!disposed.get()) {
1:60bdfc0: 
1:60bdfc0:                     if (idGenerator == null) {
1:60bdfc0:                         throw new IllegalStateException("Id Generator cannot be null");
1:60bdfc0:                     }
1:60bdfc0: 
1:6b4509c:                     localConnectionInfo = new ConnectionInfo();
1:6b4509c:                     localConnectionInfo.setConnectionId(new ConnectionId(idGenerator.generateId()));
1:3ca439c:                     localClientId = configuration.getName() + configuration.getClientIdToken() + remoteBrokerName + configuration.getClientIdToken() + "inbound" + configuration.getClientIdToken() + configuration.getBrokerName();
1:6b4509c:                     localConnectionInfo.setClientId(localClientId);
1:6b4509c:                     localConnectionInfo.setUserName(configuration.getUserName());
1:6b4509c:                     localConnectionInfo.setPassword(configuration.getPassword());
1:6b4509c:                     Transport originalTransport = remoteBroker;
1:6b4509c:                     while (originalTransport instanceof TransportFilter) {
1:6b4509c:                         originalTransport = ((TransportFilter) originalTransport).getNext();
1:6b4509c:                     }
1:57795ba:                     if (originalTransport instanceof TcpTransport) {
1:57795ba:                         X509Certificate[] peerCerts = originalTransport.getPeerCertificates();
1:6b4509c:                         localConnectionInfo.setTransportContext(peerCerts);
1:6b4509c:                     }
1:27d0ff4:                     // sync requests that may fail
1:27d0ff4:                     Object resp = localBroker.request(localConnectionInfo);
1:27d0ff4:                     if (resp instanceof ExceptionResponse) {
1:5fc2535:                         throw ((ExceptionResponse) resp).getException();
1:27d0ff4:                     }
1:6b4509c:                     localSessionInfo = new SessionInfo(localConnectionInfo, 1);
1:6b4509c:                     localBroker.oneway(localSessionInfo);
1:27d0ff4: 
1:8012f28:                     if (configuration.isDuplex()) {
1:c372448:                         // separate in-bound channel for forwards so we don't
1:5fc2535:                         // contend with out-bound dispatch on same connection
1:3100909:                         remoteBrokerInfo.setNetworkConnection(true);
1:3100909:                         duplexInboundLocalBroker.oneway(remoteBrokerInfo);
1:3100909: 
1:8012f28:                         ConnectionInfo duplexLocalConnectionInfo = new ConnectionInfo();
1:8012f28:                         duplexLocalConnectionInfo.setConnectionId(new ConnectionId(idGenerator.generateId()));
1:3ca439c:                         duplexLocalConnectionInfo.setClientId(configuration.getName() + configuration.getClientIdToken() + remoteBrokerName + configuration.getClientIdToken() + "inbound" + configuration.getClientIdToken() + "duplex"
1:3ca439c:                                 + configuration.getClientIdToken() + configuration.getBrokerName());
1:8012f28:                         duplexLocalConnectionInfo.setUserName(configuration.getUserName());
1:8012f28:                         duplexLocalConnectionInfo.setPassword(configuration.getPassword());
1:8012f28: 
1:57795ba:                         if (originalTransport instanceof TcpTransport) {
1:57795ba:                             X509Certificate[] peerCerts = originalTransport.getPeerCertificates();
1:8012f28:                             duplexLocalConnectionInfo.setTransportContext(peerCerts);
1:8012f28:                         }
1:8012f28:                         // sync requests that may fail
1:8012f28:                         resp = duplexInboundLocalBroker.request(duplexLocalConnectionInfo);
1:8012f28:                         if (resp instanceof ExceptionResponse) {
1:5fc2535:                             throw ((ExceptionResponse) resp).getException();
1:8012f28:                         }
1:8012f28:                         SessionInfo duplexInboundSession = new SessionInfo(duplexLocalConnectionInfo, 1);
1:8012f28:                         duplexInboundLocalProducerInfo = new ProducerInfo(duplexInboundSession, 1);
1:8012f28:                         duplexInboundLocalBroker.oneway(duplexInboundSession);
1:8012f28:                         duplexInboundLocalBroker.oneway(duplexInboundLocalProducerInfo);
1:8012f28:                     }
1:37384a1:                     brokerService.getBroker().networkBridgeStarted(remoteBrokerInfo, this.createdByDuplex, remoteBroker.toString());
1:489f929:                     NetworkBridgeListener l = this.networkBridgeListener;
1:c752230:                     if (l != null) {
1:c752230:                         l.onStart(this);
1:c752230:                     }
1:6b4509c: 
1:c372448:                     // Let the local broker know the remote broker's ID.
1:c372448:                     localBroker.oneway(remoteBrokerInfo);
1:c372448:                     // new peer broker (a consumer can work with remote broker also)
1:c372448:                     brokerService.getBroker().addBroker(null, remoteBrokerInfo);
1:c372448: 
1:e1bbde7:                     LOG.info("Network connection between {} and {} ({}) has been established.", new Object[]{
1:e1bbde7:                             localBroker, remoteBroker, remoteBrokerName
1:e1bbde7:                     });
1:e1bbde7:                     LOG.trace("{} register bridge ({}) to {}", new Object[]{
1:e1bbde7:                             configuration.getBrokerName(), this, remoteBrokerName
1:e1bbde7:                     });
1:6c5732b:                 } else {
1:5fc2535:                     LOG.warn("Bridge was disposed before the startLocalBridge() method was fully executed.");
1:c372448:                 }
1:230a86c:                 startedLatch.countDown();
1:a9119ec:                 localStartedLatch.countDown();
1:6b4509c:             }
1:6b4509c:         }
1:f49675b:     }
1:6b4509c: 
1:230a86c:     protected void startRemoteBridge() throws Exception {
1:60bdfc0:         if (!bridgeFailed.get() && remoteBridgeStarted.compareAndSet(false, true)) {
1:e1bbde7:             LOG.trace("{} starting remote Bridge, remoteBroker={}", configuration.getBrokerName(), remoteBroker);
1:230a86c:             synchronized (this) {
1:74a7a8b:                 if (!isCreatedByDuplex()) {
1:230a86c:                     BrokerInfo brokerInfo = new BrokerInfo();
1:35ba427:                     brokerInfo.setBrokerName(configuration.getBrokerName());
1:f392884:                     brokerInfo.setBrokerURL(configuration.getBrokerURL());
1:35ba427:                     brokerInfo.setNetworkConnection(true);
1:35ba427:                     brokerInfo.setDuplexConnection(configuration.isDuplex());
1:35ba427:                     // set our properties
1:230a86c:                     Properties props = new Properties();
1:d185430:                     IntrospectionSupport.getProperties(configuration, props, null);
1:e73ab34: 
1:e73ab34:                     String dynamicallyIncludedDestinationsKey = "dynamicallyIncludedDestinations";
1:e73ab34:                     String staticallyIncludedDestinationsKey = "staticallyIncludedDestinations";
1:e73ab34: 
1:e73ab34:                     if (!configuration.getDynamicallyIncludedDestinations().isEmpty()) {
1:e73ab34:                         props.put(dynamicallyIncludedDestinationsKey,
1:e73ab34:                                 StringToListOfActiveMQDestinationConverter.
1:e73ab34:                                 convertFromActiveMQDestination(configuration.getDynamicallyIncludedDestinations(), true));
1:e73ab34:                     }
1:e73ab34:                     if (!configuration.getStaticallyIncludedDestinations().isEmpty()) {
1:e73ab34:                         props.put(staticallyIncludedDestinationsKey,
1:e73ab34:                                 StringToListOfActiveMQDestinationConverter.
1:e73ab34:                                 convertFromActiveMQDestination(configuration.getStaticallyIncludedDestinations(), true));
1:e73ab34:                     }
1:e73ab34: 
1:a95c6db:                     props.remove("networkTTL");
1:230a86c:                     String str = MarshallingSupport.propertiesToString(props);
1:35ba427:                     brokerInfo.setNetworkProperties(str);
1:049ce28:                     brokerInfo.setBrokerId(this.localBrokerId);
1:ad2546f:                     remoteBroker.oneway(brokerInfo);
1:3953b9a:                     if (configuration.isSyncDurableSubs() &&
1:3953b9a:                             remoteBroker.getWireFormat().getVersion() >= CommandTypes.PROTOCOL_VERSION_DURABLE_SYNC) {
1:d206621:                         remoteBroker.oneway(NetworkBridgeUtils.getBrokerSubscriptionInfo(brokerService,
1:d206621:                                 configuration));
1:3953b9a:                     }
1:8e42528:                 }
1:230a86c:                 if (remoteConnectionInfo != null) {
1:ad2546f:                     remoteBroker.oneway(remoteConnectionInfo.createRemoveCommand());
1:8e42528:                 }
1:230a86c:                 remoteConnectionInfo = new ConnectionInfo();
1:ad2546f:                 remoteConnectionInfo.setConnectionId(new ConnectionId(idGenerator.generateId()));
1:3ca439c:                 remoteConnectionInfo.setClientId(configuration.getName() + configuration.getClientIdToken() + configuration.getBrokerName() + configuration.getClientIdToken() + "outbound");
1:ae73f86:                 remoteConnectionInfo.setUserName(configuration.getUserName());
1:ae73f86:                 remoteConnectionInfo.setPassword(configuration.getPassword());
1:ad2546f:                 remoteBroker.oneway(remoteConnectionInfo);
1:6b4509c: 
1:230a86c:                 SessionInfo remoteSessionInfo = new SessionInfo(remoteConnectionInfo, 1);
1:ad2546f:                 remoteBroker.oneway(remoteSessionInfo);
1:230a86c:                 producerInfo = new ProducerInfo(remoteSessionInfo, 1);
1:ad2546f:                 producerInfo.setResponseRequired(false);
1:ad2546f:                 remoteBroker.oneway(producerInfo);
1:5fc2535:                 // Listen to consumer advisory messages on the remote broker to determine demand.
1:4c8ab44:                 if (!configuration.isStaticBridge()) {
1:4c8ab44:                     demandConsumerInfo = new ConsumerInfo(remoteSessionInfo, 1);
1:5fc2535:                     // always dispatch advisory message asynchronously so that
1:5fc2535:                     // we never block the producer broker if we are slow
1:5c61d97:                     demandConsumerInfo.setDispatchAsync(true);
1:4c8ab44:                     String advisoryTopic = configuration.getDestinationFilter();
1:4c8ab44:                     if (configuration.isBridgeTempDestinations()) {
1:4c8ab44:                         advisoryTopic += "," + AdvisorySupport.TEMP_DESTINATION_COMPOSITE_ADVISORY_TOPIC;
1:4c8ab44:                     }
1:4c8ab44:                     demandConsumerInfo.setDestination(new ActiveMQTopic(advisoryTopic));
1:297eadf:                     configureConsumerPrefetch(demandConsumerInfo);
1:4c8ab44:                     remoteBroker.oneway(demandConsumerInfo);
1:d185430:                 }
2:76b2a3e:                 startedLatch.countDown();
1:39dd6b9:             }
1:f1eb92e:         }
1:f1eb92e:     }
1:f1eb92e: 
1:c518498:     @Override
1:230a86c:     public void serviceRemoteException(Throwable error) {
1:6b4509c:         if (!disposed.get()) {
1:230a86c:             if (error instanceof SecurityException || error instanceof GeneralSecurityException) {
1:e1bbde7:                 LOG.error("Network connection between {} and {} shutdown due to a remote error: {}", new Object[]{
1:e1bbde7:                         localBroker, remoteBroker, error
1:e1bbde7:                 });
1:96ce14b:             } else {
1:e1bbde7:                 LOG.warn("Network connection between {} and {} shutdown due to a remote error: {}", new Object[]{
1:e1bbde7:                         localBroker, remoteBroker, error
1:e1bbde7:                 });
1:f1eb92e:             }
1:e1bbde7:             LOG.debug("The remote Exception was: {}", error, error);
1:6c1676b:             brokerService.getTaskRunnerFactory().execute(new Runnable() {
1:c518498:                 @Override
1:230a86c:                 public void run() {
1:f4012c5:                     ServiceSupport.dispose(getControllingService());
1:f1eb92e:                 }
1:8012f28:             });
1:4ff5a3e:             fireBridgeFailed(error);
1:f1eb92e:         }
1:f1eb92e:     }
1:f1eb92e: 
1:96ce14b:     /**
1:96ce14b:      * Checks whether or not this consumer is a direct bridge network subscription
1:96ce14b:      * @param info
1:96ce14b:      * @return
1:96ce14b:      */
1:41211c7:     protected boolean isDirectBridgeConsumer(ConsumerInfo info) {
1:96ce14b:         return (info.getSubscriptionName() != null && info.getSubscriptionName().startsWith(DURABLE_SUB_PREFIX)) &&
1:96ce14b:                 (info.getClientId() == null || info.getClientId().startsWith(configuration.getName()));
1:96ce14b:     }
1:96ce14b: 
1:6013441:     protected boolean isProxyBridgeSubscription(String clientId, String subName) {
1:6013441:         if (subName != null && clientId != null) {
1:6013441:             if (subName.startsWith(DURABLE_SUB_PREFIX) && !clientId.startsWith(configuration.getName())) {
1:41211c7:                 return true;
1:41211c7:             }
1:41211c7:         }
1:41211c7:         return false;
1:41211c7:     }
1:3953b9a: 
1:6013441:     /**
1:6013441:      * This scenaior is primarily used for durable sync on broker restarts
1:6013441:      *
1:6013441:      * @param sub
1:6013441:      * @param clientId
1:6013441:      * @param subName
1:6013441:      */
1:6013441:     protected void addProxyNetworkSubscriptionClientId(final DemandSubscription sub, final String clientId, String subName) {
1:6013441:         if (clientId != null && sub != null && subName != null) {
1:6013441:                 String newClientId = getProxyBridgeClientId(clientId);
1:6013441:                 final SubscriptionInfo newSubInfo = new SubscriptionInfo(newClientId, subName);
1:6013441:                 sub.getDurableRemoteSubs().add(newSubInfo);
1:6013441:                 LOG.debug("Adding proxy network subscription {} to demand subscription", newSubInfo);
1:6013441: 
1:41211c7:         } else {
1:41211c7:             LOG.debug("Skipping addProxyNetworkSubscription");
1:41211c7:         }
1:41211c7:     }
1:41211c7: 
1:6013441:     /**
1:6013441:      * Add a durable remote proxy subscription when we can generate via the BrokerId path
1:6013441:      * This is the most common scenario
1:6013441:      *
1:6013441:      * @param sub
1:6013441:      * @param path
1:6013441:      * @param subName
1:6013441:      */
1:6013441:     protected void addProxyNetworkSubscriptionBrokerPath(final DemandSubscription sub, final BrokerId[] path, String subName) {
1:6013441:         if (sub != null && path.length > 1 && subName != null) {
1:6013441:             String b1 = path[path.length-1].toString();
1:6013441:             String b2 = path[path.length-2].toString();
1:6013441:             final SubscriptionInfo newSubInfo = new SubscriptionInfo(b2 + configuration.getClientIdToken() + "inbound" + configuration.getClientIdToken() + b1, subName);
1:6013441:             sub.getDurableRemoteSubs().add(newSubInfo);
1:6013441:         }
1:6013441:     }
1:6013441: 
1:6013441:     private String getProxyBridgeClientId(String clientId) {
1:6013441:         String newClientId = clientId;
1:3ca439c:         String[] clientIdTokens = newClientId != null ? newClientId.split(Pattern.quote(configuration.getClientIdToken())) : null;
1:3ca439c:         if (clientIdTokens != null && clientIdTokens.length > 2) {
1:3ca439c:             newClientId = clientIdTokens[clientIdTokens.length - 3] +  configuration.getClientIdToken() + "inbound"
1:3ca439c:                     + configuration.getClientIdToken() +  clientIdTokens[clientIdTokens.length -1];
1:41211c7:         }
1:41211c7:         return newClientId;
1:41211c7:     }
1:41211c7: 
1:6013441:     protected boolean isProxyNSConsumerBrokerPath(ConsumerInfo info) {
1:41211c7:         return info.getBrokerPath() != null && info.getBrokerPath().length > 1;
1:41211c7:     }
1:41211c7: 
1:6013441:     protected boolean isProxyNSConsumerClientId(String clientId) {
1:6013441:         return clientId != null && clientId.split(Pattern.quote(configuration.getClientIdToken())).length > 3;
1:6013441:     }
1:6013441: 
1:230a86c:     protected void serviceRemoteCommand(Command command) {
1:6b4509c:         if (!disposed.get()) {
1:f1eb92e:             try {
1:230a86c:                 if (command.isMessageDispatch()) {
1:3fa9275:                     safeWaitUntilStarted();
1:414a646:                     MessageDispatch md = (MessageDispatch) command;
1:687a45a:                     serviceRemoteConsumerAdvisory(md.getMessage().getDataStructure());
1:179d95e:                     ackAdvisory(md.getMessage());
1:230a86c:                 } else if (command.isBrokerInfo()) {
1:f1eb92e:                     futureRemoteBrokerInfo.set((BrokerInfo) command);
1:3953b9a:                 } else if (command instanceof BrokerSubscriptionInfo) {
1:b9cb02a:                     final BrokerSubscriptionInfo brokerSubscriptionInfo = (BrokerSubscriptionInfo) command;
1:3953b9a: 
1:b9cb02a:                     //Start in a new thread so we don't block the transport waiting for staticDestinations
1:b9cb02a:                     syncExecutor.execute(new Runnable() {
1:b9cb02a: 
1:b9cb02a:                         @Override
1:b9cb02a:                         public void run() {
1:b9cb02a:                             try {
1:b9cb02a:                                 staticDestinationsLatch.await();
1:b9cb02a:                                 //Make sure after the countDown of staticDestinationsLatch we aren't stopping
1:b9cb02a:                                 if (!disposed.get()) {
1:b9cb02a:                                     BrokerSubscriptionInfo subInfo = brokerSubscriptionInfo;
1:b9cb02a:                                     LOG.debug("Received Remote BrokerSubscriptionInfo on {} from {}",
1:b9cb02a:                                             brokerService.getBrokerName(), subInfo.getBrokerName());
1:b9cb02a: 
1:b9cb02a:                                     if (configuration.isSyncDurableSubs() && configuration.isConduitSubscriptions()
1:b9cb02a:                                             && !configuration.isDynamicOnly()) {
1:b9cb02a:                                         if (started.get()) {
1:b9cb02a:                                             if (subInfo.getSubscriptionInfos() != null) {
1:b9cb02a:                                                 for (ConsumerInfo info : subInfo.getSubscriptionInfos()) {
1:b9cb02a:                                                     //re-add any process any non-NC consumers that match the
1:b9cb02a:                                                     //dynamicallyIncludedDestinations list
1:96ce14b:                                                     //Also re-add network consumers that are not part of this direct
1:96ce14b:                                                     //bridge (proxy of proxy bridges)
1:41211c7:                                                     if((info.getSubscriptionName() == null || !isDirectBridgeConsumer(info)) &&
1:b9cb02a:                                                             NetworkBridgeUtils.matchesDestinations(dynamicallyIncludedDestinations, info.getDestination())) {
1:b9cb02a:                                                         serviceRemoteConsumerAdvisory(info);
1:b9cb02a:                                                     }
1:b9cb02a:                                                 }
1:b9cb02a:                                             }
1:b9cb02a: 
1:b9cb02a:                                             //After re-added, clean up any empty durables
1:b9cb02a:                                             for (Iterator<DemandSubscription> i = subscriptionMapByLocalId.values().iterator(); i.hasNext(); ) {
1:b9cb02a:                                                 DemandSubscription ds = i.next();
1:b9cb02a:                                                 if (NetworkBridgeUtils.matchesDestinations(dynamicallyIncludedDestinations, ds.getLocalInfo().getDestination())) {
1:b9cb02a:                                                     cleanupDurableSub(ds, i);
1:b9cb02a:                                                 }
1:b9cb02a:                                             }
1:b9cb02a:                                         }
1:a038655:                                     }
1:3953b9a:                                 }
1:b9cb02a:                             } catch (Exception e) {
1:b9cb02a:                                 LOG.warn("Error processing BrokerSubscriptionInfo: {}", e.getMessage(), e);
1:b9cb02a:                                 LOG.debug(e.getMessage(), e);
1:3953b9a:                             }
1:3953b9a:                         }
1:b9cb02a:                     });
1:b9cb02a: 
1:230a86c:                 } else if (command.getClass() == ConnectionError.class) {
1:16d403f:                     ConnectionError ce = (ConnectionError) command;
1:16d403f:                     serviceRemoteException(ce.getException());
1:6b4509c:                 } else {
1:8012f28:                     if (isDuplex()) {
1:e1bbde7:                         LOG.trace("{} duplex command type: {}", configuration.getBrokerName(), command.getDataStructureType());
1:230a86c:                         if (command.isMessage()) {
1:8012f28:                             final ActiveMQMessage message = (ActiveMQMessage) command;
1:002ade7:                             if (NetworkBridgeFilter.isAdvisoryInterpretedByNetworkBridge(message)) {
1:35ba427:                                 serviceRemoteConsumerAdvisory(message.getDataStructure());
1:179d95e:                                 ackAdvisory(message);
1:6b4509c:                             } else {
1:2bda17a:                                 if (!isPermissableDestination(message.getDestination(), true)) {
1:39dd6b9:                                     return;
1:3953b9a:                                 }
1:5fc2535:                                 // message being forwarded - we need to
1:5fc2535:                                 // propagate the response to our local send
1:2bbfbcf:                                 if (canDuplexDispatch(message)) {
1:2bbfbcf:                                     message.setProducerId(duplexInboundLocalProducerInfo.getProducerId());
1:2bbfbcf:                                     if (message.isResponseRequired() || configuration.isAlwaysSyncSend()) {
1:2bbfbcf:                                         duplexInboundLocalBroker.asyncRequest(message, new ResponseCallback() {
1:2bbfbcf:                                             final int correlationId = message.getCommandId();
1:3953b9a: 
1:2bbfbcf:                                             @Override
1:2bbfbcf:                                             public void onCompletion(FutureResponse resp) {
1:2bbfbcf:                                                 try {
1:2bbfbcf:                                                     Response reply = resp.getResult();
1:2bbfbcf:                                                     reply.setCorrelationId(correlationId);
1:2bbfbcf:                                                     remoteBroker.oneway(reply);
1:10c998b:                                                     //increment counter when messages are received in duplex mode
1:10c998b:                                                     networkBridgeStatistics.getReceivedCount().increment();
1:2bbfbcf:                                                 } catch (IOException error) {
1:e1bbde7:                                                     LOG.error("Exception: {} on duplex forward of: {}", error, message);
1:2bbfbcf:                                                     serviceRemoteException(error);
1:3953b9a:                                                 }
1:3953b9a:                                             }
1:2bbfbcf:                                         });
1:2bbfbcf:                                     } else {
1:2bbfbcf:                                         duplexInboundLocalBroker.oneway(message);
1:10c998b:                                         networkBridgeStatistics.getReceivedCount().increment();
1:41211c7:                                     }
1:2bbfbcf:                                     serviceInboundMessage(message);
1:6b4509c:                                 } else {
1:2bbfbcf:                                     if (message.isResponseRequired() || configuration.isAlwaysSyncSend()) {
1:2bbfbcf:                                         Response reply = new Response();
1:2bbfbcf:                                         reply.setCorrelationId(message.getCommandId());
1:2bbfbcf:                                         remoteBroker.oneway(reply);
1:41211c7:                                     }
1:2bbfbcf:                                 }
1:2bbfbcf:                             }
1:966658f:                         } else {
1:230a86c:                             switch (command.getDataStructureType()) {
1:8012f28:                                 case ConnectionInfo.DATA_STRUCTURE_TYPE:
1:50ec158:                                     if (duplexInitiatingConnection != null && duplexInitiatingConnectionInfoReceived.compareAndSet(false, true)) {
1:50ec158:                                         // end of initiating connection setup - propogate to initial connection to get mbean by clientid
1:50ec158:                                         duplexInitiatingConnection.processAddConnection((ConnectionInfo) command);
1:50ec158:                                     } else {
1:50ec158:                                         localBroker.oneway(command);
1:50ec158:                                     }
1:50ec158:                                     break;
1:8012f28:                                 case SessionInfo.DATA_STRUCTURE_TYPE:
1:8012f28:                                     localBroker.oneway(command);
1:8012f28:                                     break;
1:8012f28:                                 case ProducerInfo.DATA_STRUCTURE_TYPE:
1:8012f28:                                     // using duplexInboundLocalProducerInfo
1:8012f28:                                     break;
1:8012f28:                                 case MessageAck.DATA_STRUCTURE_TYPE:
1:8012f28:                                     MessageAck ack = (MessageAck) command;
1:8012f28:                                     DemandSubscription localSub = subscriptionMapByRemoteId.get(ack.getConsumerId());
1:8012f28:                                     if (localSub != null) {
1:8012f28:                                         ack.setConsumerId(localSub.getLocalInfo().getConsumerId());
1:8012f28:                                         localBroker.oneway(ack);
1:8012f28:                                     } else {
1:e1bbde7:                                         LOG.warn("Matching local subscription not found for ack: {}", ack);
1:2bbfbcf:                                     }
1:8012f28:                                     break;
1:8012f28:                                 case ConsumerInfo.DATA_STRUCTURE_TYPE:
1:8012f28:                                     localStartedLatch.await();
1:3953b9a:                                     if (started.get()) {
1:8e00c6c:                                         final ConsumerInfo consumerInfo = (ConsumerInfo) command;
1:8e00c6c:                                         if (isDuplicateSuppressionOff(consumerInfo)) {
1:8e00c6c:                                             addConsumerInfo(consumerInfo);
1:8e00c6c:                                         } else {
1:8e00c6c:                                             synchronized (brokerService.getVmConnectorURI()) {
1:8e00c6c:                                                 addConsumerInfo(consumerInfo);
1:8e00c6c:                                             }
1:8e00c6c:                                         }
1:8012f28:                                     } else {
1:8012f28:                                         // received a subscription whilst stopping
1:e1bbde7:                                         LOG.warn("Stopping - ignoring ConsumerInfo: {}", command);
1:8012f28:                                     }
1:8012f28:                                     break;
1:8012f28:                                 case ShutdownInfo.DATA_STRUCTURE_TYPE:
1:8012f28:                                     // initiator is shutting down, controlled case
1:8012f28:                                     // abortive close dealt with by inactivity monitor
1:8012f28:                                     LOG.info("Stopping network bridge on shutdown of remote broker");
1:8012f28:                                     serviceRemoteException(new IOException(command.toString()));
1:8012f28:                                     break;
1:8012f28:                                 default:
1:e1bbde7:                                     LOG.debug("Ignoring remote command: {}", command);
1:8012f28:                             }
1:8012f28:                         }
1:179d95e:                     } else {
1:230a86c:                         switch (command.getDataStructureType()) {
1:8012f28:                             case KeepAliveInfo.DATA_STRUCTURE_TYPE:
1:8012f28:                             case WireFormatInfo.DATA_STRUCTURE_TYPE:
1:8012f28:                             case ShutdownInfo.DATA_STRUCTURE_TYPE:
1:8012f28:                                 break;
1:8012f28:                             default:
1:e1bbde7:                                 LOG.warn("Unexpected remote command: {}", command);
1:8012f28:                         }
1:179d95e:                     }
1:301203e:                 }
1:f1eb92e:             } catch (Throwable e) {
1:e1bbde7:                 LOG.debug("Exception processing remote command: {}", command, e);
1:f1eb92e:                 serviceRemoteException(e);
1:301203e:             }
1:8761189:         }
1:f1eb92e:     }
1:41211c7: 
1:179d95e:     private void ackAdvisory(Message message) throws IOException {
1:179d95e:         demandConsumerDispatched++;
1:297eadf:         if (demandConsumerDispatched > (demandConsumerInfo.getPrefetchSize() *
1:297eadf:                 (configuration.getAdvisoryAckPercentage() / 100f))) {
1:d84a586:             final MessageAck ack = new MessageAck(message, MessageAck.STANDARD_ACK_TYPE, demandConsumerDispatched);
1:179d95e:             ack.setConsumerId(demandConsumerInfo.getConsumerId());
1:d84a586:             brokerService.getTaskRunnerFactory().execute(new Runnable() {
1:d84a586:                 @Override
1:d84a586:                 public void run() {
1:d84a586:                     try {
1:d84a586:                         remoteBroker.oneway(ack);
1:d84a586:                     } catch (IOException e) {
1:d84a586:                         LOG.warn("Failed to send advisory ack " + ack, e);
1:d84a586:                     }
1:d84a586:                 }
1:d84a586:             });
1:179d95e:             demandConsumerDispatched = 0;
1:179d95e:         }
1:179d95e:     }
1:179d95e: 
1:230a86c:     private void serviceRemoteConsumerAdvisory(DataStructure data) throws IOException {
1:a95c6db:         final int networkTTL = configuration.getConsumerTTL();
1:230a86c:         if (data.getClass() == ConsumerInfo.class) {
1:687a45a:             // Create a new local subscription
1:414a646:             ConsumerInfo info = (ConsumerInfo) data;
1:230a86c:             BrokerId[] path = info.getBrokerPath();
1:301203e: 
1:34f1929:             if (info.isBrowser()) {
1:a554c7c:                 LOG.debug("{} Ignoring sub from {}, browsers explicitly suppressed", configuration.getBrokerName(), remoteBrokerName);
1:34f1929:                 return;
1:34f1929:             }
1:2a558c8: 
1:a95c6db:             if (path != null && networkTTL > -1 && path.length >= networkTTL) {
1:e1bbde7:                 LOG.debug("{} Ignoring sub from {}, restricted to {} network hops only: {}", new Object[]{
1:e1bbde7:                         configuration.getBrokerName(), remoteBrokerName, networkTTL, info
1:e1bbde7:                 });
1:f1eb92e:                 return;
1:34f1929:             }
1:34f1929: 
1:301203e:             if (contains(path, localBrokerPath[0])) {
1:301203e:                 // Ignore this consumer as it's a consumer we locally sent to the broker.
1:e1bbde7:                 LOG.debug("{} Ignoring sub from {}, already routed through this broker once: {}", new Object[]{
1:e1bbde7:                         configuration.getBrokerName(), remoteBrokerName, info
1:e1bbde7:                 });
1:f1eb92e:                 return;
1:301203e:             }
1:f1eb92e: 
1:230a86c:             if (!isPermissableDestination(info.getDestination())) {
1:6d1f57b:                 // ignore if not in the permitted or in the excluded list
1:e1bbde7:                 LOG.debug("{} Ignoring sub from {}, destination {} is not permitted: {}", new Object[]{
1:e1bbde7:                         configuration.getBrokerName(), remoteBrokerName, info.getDestination(), info
1:e1bbde7:                 });
1:f1eb92e:                 return;
1:f1eb92e:             }
1:f1eb92e: 
1:301203e:             // in a cyclic network there can be multiple bridges per broker that can propagate
1:a80acbb:             // a network subscription so there is a need to synchronize on a shared entity
1:8e00c6c:             // if duplicate suppression is required
1:8e00c6c:             if (isDuplicateSuppressionOff(info)) {
1:a95c6db:                 addConsumerInfo(info);
1:8e00c6c:             } else {
1:8e00c6c:                 synchronized (brokerService.getVmConnectorURI()) {
1:8e00c6c:                     addConsumerInfo(info);
1:8e00c6c:                 }
1:301203e:             }
1:230a86c:         } else if (data.getClass() == DestinationInfo.class) {
1:a80acbb:             // It's a destination info - we want to pass up information about temporary destinations
1:27440ae:             final DestinationInfo destInfo = (DestinationInfo) data;
1:230a86c:             BrokerId[] path = destInfo.getBrokerPath();
1:a95c6db:             if (path != null && networkTTL > -1 && path.length >= networkTTL) {
1:e1bbde7:                 LOG.debug("{} Ignoring destination {} restricted to {} network hops only", new Object[]{
1:e1bbde7:                         configuration.getBrokerName(), destInfo, networkTTL
1:e1bbde7:                 });
1:7fbbcf3:                 return;
1:f1eb92e:             }
1:230a86c:             if (contains(destInfo.getBrokerPath(), localBrokerPath[0])) {
1:e1bbde7:                 LOG.debug("{} Ignoring destination {} already routed through this broker once", configuration.getBrokerName(), destInfo);
2:065c46f:                 return;
1:f1eb92e:             }
1:065c46f:             destInfo.setConnectionId(localConnectionInfo.getConnectionId());
1:230a86c:             if (destInfo.getDestination() instanceof ActiveMQTempDestination) {
1:35ba427:                 // re-set connection id so comes from here
1:065c46f:                 ActiveMQTempDestination tempDest = (ActiveMQTempDestination) destInfo.getDestination();
1:065c46f:                 tempDest.setConnectionId(localSessionInfo.getSessionId().getConnectionId());
1:5b8a886:             }
1:230a86c:             destInfo.setBrokerPath(appendToBrokerPath(destInfo.getBrokerPath(), getRemoteBrokerPath()));
1:e1bbde7:             LOG.trace("{} bridging {} destination on {} from {}, destination: {}", new Object[]{
1:e1bbde7:                     configuration.getBrokerName(), (destInfo.isAddOperation() ? "add" : "remove"), localBroker, remoteBrokerName, destInfo
1:e1bbde7:             });
1:27440ae:             if (destInfo.isRemoveOperation()) {
1:5fc2535:                 // Serialize with removeSub operations such that all removeSub advisories
1:5fc2535:                 // are generated
1:27440ae:                 serialExecutor.execute(new Runnable() {
1:c518498:                     @Override
1:27440ae:                     public void run() {
1:27440ae:                         try {
1:27440ae:                             localBroker.oneway(destInfo);
1:27440ae:                         } catch (IOException e) {
1:e1bbde7:                             LOG.warn("failed to deliver remove command for destination: {}", destInfo.getDestination(), e);
1:27440ae:                         }
1:27440ae:                     }
1:27440ae:                 });
1:27440ae:             } else {
1:27440ae:                 localBroker.oneway(destInfo);
1:27440ae:             }
1:230a86c:         } else if (data.getClass() == RemoveInfo.class) {
1:414a646:             ConsumerId id = (ConsumerId) ((RemoveInfo) data).getObjectId();
1:687a45a:             removeDemandSubscription(id);
1:e73ab34: 
1:e73ab34:             if (forcedDurableRemoteId.remove(id)) {
1:e73ab34:                 for (Iterator<DemandSubscription> i = subscriptionMapByLocalId.values().iterator(); i.hasNext(); ) {
1:e73ab34:                     DemandSubscription ds = i.next();
1:e73ab34:                     boolean removed = ds.removeForcedDurableConsumer(id);
1:e73ab34:                     if (removed) {
1:e73ab34:                         cleanupDurableSub(ds, i);
1:e73ab34:                     }
1:e73ab34:                 }
1:e73ab34:            }
1:e73ab34: 
1:b7c32d9:         } else if (data.getClass() == RemoveSubscriptionInfo.class) {
1:6013441:             final RemoveSubscriptionInfo info = ((RemoveSubscriptionInfo) data);
1:6013441:             final SubscriptionInfo subscriptionInfo = new SubscriptionInfo(info.getClientId(), info.getSubscriptionName());
1:6013441:             final boolean proxyBridgeSub = isProxyBridgeSubscription(subscriptionInfo.getClientId(),
1:6013441:                     subscriptionInfo.getSubscriptionName());
1:3953b9a:             for (Iterator<DemandSubscription> i = subscriptionMapByLocalId.values().iterator(); i.hasNext(); ) {
1:3953b9a:                 DemandSubscription ds = i.next();
1:620523a:                 boolean removed = ds.getDurableRemoteSubs().remove(subscriptionInfo);
1:41211c7: 
1:6013441:                 //If this is a proxy bridge subscription we need to try changing the clientId
1:6013441:                 if (!removed && proxyBridgeSub){
1:6013441:                     subscriptionInfo.setClientId(getProxyBridgeClientId(subscriptionInfo.getClientId()));
1:6013441:                     if (ds.getDurableRemoteSubs().contains(subscriptionInfo)) {
1:6013441:                         ds.getDurableRemoteSubs().remove(subscriptionInfo);
1:6013441:                         removed = true;
1:6013441:                     }
1:6013441:                 }
1:6013441: 
1:620523a:                 if (removed) {
1:3953b9a:                     cleanupDurableSub(ds, i);
1:41211c7:                 }
1:41211c7:             }
1:f1eb92e:         }
1:f1eb92e:     }
1:620523a: 
1:3953b9a:     private void cleanupDurableSub(final DemandSubscription ds,
1:3953b9a:             Iterator<DemandSubscription> i) throws IOException {
1:3953b9a: 
1:e73ab34:         if (ds != null && ds.getLocalDurableSubscriber() != null && ds.getDurableRemoteSubs().isEmpty()
1:e73ab34:                 && ds.getForcedDurableConsumersSize() == 0) {
1:3953b9a:             // deactivate subscriber
1:3953b9a:             RemoveInfo removeInfo = new RemoveInfo(ds.getLocalInfo().getConsumerId());
1:3953b9a:             localBroker.oneway(removeInfo);
1:3953b9a: 
1:3953b9a:             // remove subscriber
1:3953b9a:             RemoveSubscriptionInfo sending = new RemoveSubscriptionInfo();
1:3953b9a:             sending.setClientId(localClientId);
1:3953b9a:             sending.setSubscriptionName(ds.getLocalDurableSubscriber().getSubscriptionName());
1:3953b9a:             sending.setConnectionId(this.localConnectionInfo.getConnectionId());
1:3953b9a:             localBroker.oneway(sending);
1:3953b9a: 
1:3953b9a:             //remove subscriber from map
1:96ce14b:             i.remove();
1:96ce14b:         }
1:3953b9a:     }
1:3953b9a: 
1:c518498:     @Override
1:230a86c:     public void serviceLocalException(Throwable error) {
1:8012f28:         serviceLocalException(null, error);
1:3953b9a:     }
1:09054fc: 
1:8012f28:     public void serviceLocalException(MessageDispatch messageDispatch, Throwable error) {
1:c1c82be:         LOG.trace("serviceLocalException: disposed {} ex", disposed.get(), error);
1:5d42b72:         if (!disposed.get()) {
1:5fc2535:             if (error instanceof DestinationDoesNotExistException && ((DestinationDoesNotExistException) error).isTemporary()) {
1:5fc2535:                 // not a reason to terminate the bridge - temps can disappear with
1:5fc2535:                 // pending sends as the demand sub may outlive the remote dest
1:8012f28:                 if (messageDispatch != null) {
1:e1bbde7:                     LOG.warn("PoisonAck of {} on forwarding error: {}", messageDispatch.getMessage().getMessageId(), error);
1:8012f28:                     try {
1:8012f28:                         MessageAck poisonAck = new MessageAck(messageDispatch, MessageAck.POSION_ACK_TYPE, 1);
1:8012f28:                         poisonAck.setPoisonCause(error);
1:8012f28:                         localBroker.oneway(poisonAck);
1:8012f28:                     } catch (IOException ioe) {
1:e1bbde7:                         LOG.error("Failed to posion ack message following forward failure: ", ioe);
1:8012f28:                     }
1:8012f28:                     fireFailedForwardAdvisory(messageDispatch, error);
1:8012f28:                 } else {
1:e1bbde7:                     LOG.warn("Ignoring exception on forwarding to non existent temp dest: ", error);
1:8012f28:                 }
1:8012f28:                 return;
1:8012f28:             }
1:620523a: 
1:2bbfbcf:             LOG.info("Network connection between {} and {} shutdown due to a local error: {}", new Object[]{localBroker, remoteBroker, error});
1:e1bbde7:             LOG.debug("The local Exception was: {}", error, error);
1:f1eb92e: 
1:6c1676b:             brokerService.getTaskRunnerFactory().execute(new Runnable() {
1:c518498:                 @Override
1:230a86c:                 public void run() {
1:f4012c5:                     ServiceSupport.dispose(getControllingService());
1:620523a:                 }
1:44e6f7d:             });
1:4ff5a3e:             fireBridgeFailed(error);
1:620523a:         }
1:620523a:     }
1:a5dd237: 
1:8012f28:     private void fireFailedForwardAdvisory(MessageDispatch messageDispatch, Throwable error) {
1:8012f28:         if (configuration.isAdvisoryForFailedForward()) {
1:8012f28:             AdvisoryBroker advisoryBroker = null;
1:8012f28:             try {
1:8012f28:                 advisoryBroker = (AdvisoryBroker) brokerService.getBroker().getAdaptor(AdvisoryBroker.class);
1:8012f28: 
1:8012f28:                 if (advisoryBroker != null) {
1:8012f28:                     ConnectionContext context = new ConnectionContext();
1:8012f28:                     context.setSecurityContext(SecurityContext.BROKER_SECURITY_CONTEXT);
1:8012f28:                     context.setBroker(brokerService.getBroker());
1:8012f28: 
1:8012f28:                     ActiveMQMessage advisoryMessage = new ActiveMQMessage();
1:8012f28:                     advisoryMessage.setStringProperty("cause", error.getLocalizedMessage());
1:5fc2535:                     advisoryBroker.fireAdvisory(context, AdvisorySupport.getNetworkBridgeForwardFailureAdvisoryTopic(), messageDispatch.getMessage(), null,
1:2bbfbcf:                             advisoryMessage);
1:8012f28: 
1:8012f28:                 }
1:8012f28:             } catch (Exception e) {
1:e1bbde7:                 LOG.warn("failed to fire forward failure advisory, cause: {}", e);
1:e1bbde7:                 LOG.debug("detail", e);
1:8012f28:             }
1:8012f28:         }
1:8012f28:     }
1:8012f28: 
1:f4012c5:     protected Service getControllingService() {
1:f4012c5:         return duplexInitiatingConnection != null ? duplexInitiatingConnection : DemandForwardingBridgeSupport.this;
1:8012f28:     }
1:a5dd237: 
1:687a45a:     protected void addSubscription(DemandSubscription sub) throws IOException {
1:230a86c:         if (sub != null) {
1:d84a586:             localBroker.oneway(sub.getLocalInfo());
1:806ec21:         }
1:3da1373:     }
1:a5dd237: 
1:8e59e24:     protected void removeSubscription(final DemandSubscription sub) throws IOException {
1:230a86c:         if (sub != null) {
1:2bbfbcf:             LOG.trace("{} remove local subscription: {} for remote {}", new Object[]{configuration.getBrokerName(), sub.getLocalInfo().getConsumerId(), sub.getRemoteInfo().getConsumerId()});
1:8e59e24: 
1:bf78756:             // ensure not available for conduit subs pending removal
1:bf78756:             subscriptionMapByLocalId.remove(sub.getLocalInfo().getConsumerId());
1:bf78756:             subscriptionMapByRemoteId.remove(sub.getRemoteInfo().getConsumerId());
1:bf78756: 
1:96ce14b:             // continue removal in separate thread to free up tshis thread for outstanding responses
1:5fc2535:             // Serialize with removeDestination operations so that removeSubs are serialized with
1:5fc2535:             // removeDestinations such that all removeSub advisories are generated
1:27440ae:             serialExecutor.execute(new Runnable() {
1:c518498:                 @Override
1:8e59e24:                 public void run() {
1:8e59e24:                     sub.waitForCompletion();
1:8e59e24:                     try {
1:96ce14b:                         localBroker.oneway(sub.getLocalInfo().createRemoveCommand());
1:8e59e24:                     } catch (IOException e) {
1:e1bbde7:                         LOG.warn("failed to deliver remove command for local subscription, for remote {}", sub.getRemoteInfo().getConsumerId(), e);
1:96ce14b:                     }
1:8e59e24:                 }
1:8e59e24:             });
1:8e59e24:         }
1:f1eb92e:     }
1:5fc2535: 
1:41c9366:     protected Message configureMessage(MessageDispatch md) throws IOException {
1:230a86c:         Message message = md.getMessage().copy();
2:687a45a:         // Update the packet to show where it came from.
1:230a86c:         message.setBrokerPath(appendToBrokerPath(message.getBrokerPath(), localBrokerPath));
1:687a45a:         message.setProducerId(producerInfo.getProducerId());
1:687a45a:         message.setDestination(md.getDestination());
1:972176e:         message.setMemoryUsage(null);
1:ecf89a6:         if (message.getOriginalTransactionId() == null) {
1:687a45a:             message.setOriginalTransactionId(message.getTransactionId());
1:f1eb92e:         }
1:687a45a:         message.setTransactionId(null);
1:41c9366:         if (configuration.isUseCompression()) {
1:41c9366:             message.compress();
1:f1eb92e:         }
1:687a45a:         return message;
1:f1eb92e:     }
1:5fc2535: 
1:687a45a:     protected void serviceLocalCommand(Command command) {
1:5d42b72:         if (!disposed.get()) {
1:f1eb92e:             try {
1:230a86c:                 if (command.isMessageDispatch()) {
1:3fa9275:                     safeWaitUntilStarted();
1:10c998b:                     networkBridgeStatistics.getEnqueues().increment();
1:414a646:                     final MessageDispatch md = (MessageDispatch) command;
1:8e59e24:                     final DemandSubscription sub = subscriptionMapByLocalId.get(md.getConsumerId());
1:414a646:                     if (sub != null && md.getMessage() != null && sub.incrementOutstandingResponses()) {
1:05f82a9: 
1:eb983f7:                         if (suppressMessageDispatch(md, sub)) {
1:e1bbde7:                             LOG.debug("{} message not forwarded to {} because message came from there or fails TTL, brokerPath: {}, message: {}", new Object[]{
1:e1bbde7:                                     configuration.getBrokerName(), remoteBrokerName, Arrays.toString(md.getMessage().getBrokerPath()), md.getMessage()
1:e1bbde7:                             });
1:05f82a9:                             // still ack as it may be durable
1:05f82a9:                             try {
1:f383ca1:                                 localBroker.oneway(new MessageAck(md, MessageAck.INDIVIDUAL_ACK_TYPE, 1));
1:8012f28:                             } finally {
1:f383ca1:                                 sub.decrementOutstandingResponses();
1:05f82a9:                             }
1:05f82a9:                             return;
1:05f82a9:                         }
1:88d85ae: 
1:230a86c:                         Message message = configureMessage(md);
1:61da1fa:                         LOG.debug("bridging ({} -> {}), consumer: {}, destination: {}, brokerPath: {}, message: {}", new Object[]{
1:1f9b139:                                 configuration.getBrokerName(), remoteBrokerName, md.getConsumerId(), message.getDestination(), Arrays.toString(message.getBrokerPath()), (LOG.isTraceEnabled() ? message : message.getMessageId())
1:e1bbde7:                         });
1:002ade7:                         if (isDuplex() && NetworkBridgeFilter.isAdvisoryInterpretedByNetworkBridge(message)) {
1:f383ca1:                             try {
1:3953b9a:                                 // never request b/c they are eventually                     acked async
1:88d85ae:                                 remoteBroker.oneway(message);
1:88d85ae:                             } finally {
1:88d85ae:                                 sub.decrementOutstandingResponses();
1:88d85ae:                             }
1:88d85ae:                             return;
1:88d85ae:                         }
1:1faa4af:                         if (isPermissableDestination(md.getDestination())) {
1:1faa4af:                            if (message.isPersistent() || configuration.isAlwaysSyncSend()) {
1:05f82a9: 
1:1faa4af:                               // The message was not sent using async send, so we should only
1:1faa4af:                               // ack the local broker when we get confirmation that the remote
1:1faa4af:                               // broker has received the message.
1:1faa4af:                               remoteBroker.asyncRequest(message, new ResponseCallback() {
1:1faa4af:                                  @Override
1:1faa4af:                                  public void onCompletion(FutureResponse future) {
1:f1eb92e:                                     try {
1:1faa4af:                                        Response response = future.getResult();
1:1faa4af:                                        if (response.isException()) {
1:1faa4af:                                           ExceptionResponse er = (ExceptionResponse) response;
1:1faa4af:                                           serviceLocalException(md, er.getException());
1:1faa4af:                                        } else {
1:1faa4af:                                           localBroker.oneway(new MessageAck(md, MessageAck.INDIVIDUAL_ACK_TYPE, 1));
1:10c998b:                                           networkBridgeStatistics.getDequeues().increment();
1:1faa4af:                                        }
1:230a86c:                                     } catch (IOException e) {
1:1faa4af:                                        serviceLocalException(md, e);
1:f383ca1:                                     } finally {
1:1faa4af:                                        sub.decrementOutstandingResponses();
1:1faa4af:                                     }
1:05f82a9:                                  }
1:1faa4af:                               });
1:05f82a9: 
1:1faa4af:                            } else {
1:1faa4af:                               // If the message was originally sent using async send, we will
1:1faa4af:                               // preserve that QOS by bridging it using an async send (small chance
1:1faa4af:                               // of message loss).
1:1faa4af:                               try {
1:1faa4af:                                  remoteBroker.oneway(message);
1:1faa4af:                                  localBroker.oneway(new MessageAck(md, MessageAck.INDIVIDUAL_ACK_TYPE, 1));
1:10c998b:                                  networkBridgeStatistics.getDequeues().increment();
1:1faa4af:                               } finally {
1:1faa4af:                                  sub.decrementOutstandingResponses();
1:1faa4af:                               }
1:1faa4af:                            }
1:1faa4af:                            serviceOutbound(message);
1:f383ca1:                         }
1:806ec21:                     } else {
1:e1bbde7:                         LOG.debug("No subscription registered with this network bridge for consumerId: {} for message: {}", md.getConsumerId(), md.getMessage());
1:f1eb92e:                     }
1:230a86c:                 } else if (command.isBrokerInfo()) {
1:f1eb92e:                     futureLocalBrokerInfo.set((BrokerInfo) command);
1:230a86c:                 } else if (command.isShutdownInfo()) {
1:17f4f34:                     LOG.info("{} Shutting down {}", configuration.getBrokerName(), configuration.getName());
1:4acd132:                     stop();
1:230a86c:                 } else if (command.getClass() == ConnectionError.class) {
1:16d403f:                     ConnectionError ce = (ConnectionError) command;
1:230a86c:                     serviceLocalException(ce.getException());
1:301203e:                 } else {
1:230a86c:                     switch (command.getDataStructureType()) {
1:5fc2535:                         case WireFormatInfo.DATA_STRUCTURE_TYPE:
1:179d95e:                             break;
1:3953b9a:                         case BrokerSubscriptionInfo.DATA_STRUCTURE_TYPE:
1:3953b9a:                             break;
1:5fc2535:                         default:
1:e1bbde7:                             LOG.warn("Unexpected local command: {}", command);
1:f1eb92e:                     }
1:f1eb92e:                 }
1:f1eb92e:             } catch (Throwable e) {
1:414a646:                 LOG.warn("Caught an exception processing local command", e);
1:f1eb92e:                 serviceLocalException(e);
1:f1eb92e:             }
1:f1eb92e:         }
1:f1eb92e:     }
1:05f82a9: 
1:eb983f7:     private boolean suppressMessageDispatch(MessageDispatch md, DemandSubscription sub) throws Exception {
1:eb983f7:         boolean suppress = false;
1:5fc2535:         // for durable subs, suppression via filter leaves dangling acks so we
1:5fc2535:         // need to check here and allow the ack irrespective
1:af1b232:         if (sub.getLocalInfo().isDurable()) {
1:50d27e7:             NonCachedMessageEvaluationContext messageEvalContext = new NonCachedMessageEvaluationContext();
1:05f82a9:             messageEvalContext.setMessageReference(md.getMessage());
1:af1b232:             messageEvalContext.setDestination(md.getDestination());
1:af1b232:             suppress = !sub.getNetworkBridgeFilter().matches(messageEvalContext);
1:af1b232:         }
1:eb983f7:         return suppress;
1:f232cec:     }
1:f232cec: 
1:687a45a:     public static boolean contains(BrokerId[] brokerPath, BrokerId brokerId) {
1:230a86c:         if (brokerPath != null) {
1:5fc2535:             for (BrokerId id : brokerPath) {
1:5fc2535:                 if (brokerId.equals(id)) {
1:f1eb92e:                     return true;
1:05f82a9:                 }
1:05f82a9:             }
1:f1eb92e:         }
1:230a86c:         return false;
1:f1eb92e:     }
1:05f82a9: 
1:687a45a:     protected BrokerId[] appendToBrokerPath(BrokerId[] brokerPath, BrokerId[] pathsToAppend) {
1:ecf89a6:         if (brokerPath == null || brokerPath.length == 0) {
1:687a45a:             return pathsToAppend;
1:f1eb92e:         }
1:687a45a:         BrokerId rc[] = new BrokerId[brokerPath.length + pathsToAppend.length];
1:687a45a:         System.arraycopy(brokerPath, 0, rc, 0, brokerPath.length);
1:687a45a:         System.arraycopy(pathsToAppend, 0, rc, brokerPath.length, pathsToAppend.length);
1:687a45a:         return rc;
1:f1eb92e:     }
1:05f82a9: 
1:687a45a:     protected BrokerId[] appendToBrokerPath(BrokerId[] brokerPath, BrokerId idToAppend) {
1:ecf89a6:         if (brokerPath == null || brokerPath.length == 0) {
1:2bbfbcf:             return new BrokerId[]{idToAppend};
1:f1eb92e:         }
1:687a45a:         BrokerId rc[] = new BrokerId[brokerPath.length + 1];
1:687a45a:         System.arraycopy(brokerPath, 0, rc, 0, brokerPath.length);
1:687a45a:         rc[brokerPath.length] = idToAppend;
1:687a45a:         return rc;
1:f1eb92e:     }
1:8e59e24: 
1:687a45a:     protected boolean isPermissableDestination(ActiveMQDestination destination) {
1:2bda17a:         return isPermissableDestination(destination, false);
1:2bda17a:     }
1:8e59e24: 
1:2bda17a:     protected boolean isPermissableDestination(ActiveMQDestination destination, boolean allowTemporary) {
1:a80acbb:         // Are we not bridging temporary destinations?
1:2bda17a:         if (destination.isTemporary()) {
1:2bda17a:             if (allowTemporary) {
1:2bda17a:                 return true;
1:8761189:             } else {
1:2bda17a:                 return configuration.isBridgeTempDestinations();
1:2bda17a:             }
1:2bda17a:         }
1:5fc2535: 
1:1faa4af:         ActiveMQDestination[] dests = excludedDestinations;
1:e73ab34:         if (dests != null && dests.length > 0) {
1:e73ab34:             for (ActiveMQDestination dest : dests) {
1:5fc2535:                 DestinationFilter exclusionFilter = DestinationFilter.parseFilter(dest);
1:5fc2535:                 if (dest != null && exclusionFilter.matches(destination) && dest.getDestinationType() == destination.getDestinationType()) {
1:3953b9a:                     return false;
1:3953b9a:                 }
1:3953b9a:             }
1:1faa4af:         }
1:3953b9a: 
1:1faa4af:         dests = staticallyIncludedDestinations;
1:1faa4af:         if (dests != null && dests.length > 0) {
1:1faa4af:             for (ActiveMQDestination dest : dests) {
1:e73ab34:                 DestinationFilter inclusionFilter = DestinationFilter.parseFilter(dest);
1:e73ab34:                 if (dest != null && inclusionFilter.matches(destination) && dest.getDestinationType() == destination.getDestinationType()) {
1:3953b9a:                     return true;
1:e73ab34:                 }
1:e73ab34:             }
1:e73ab34:         }
1:e73ab34: 
1:687a45a:         dests = dynamicallyIncludedDestinations;
1:3953b9a:         if (dests != null && dests.length > 0) {
1:e73ab34:             for (ActiveMQDestination dest : dests) {
1:e73ab34:                 DestinationFilter inclusionFilter = DestinationFilter.parseFilter(dest);
1:e73ab34:                 if (dest != null && inclusionFilter.matches(destination) && dest.getDestinationType() == destination.getDestinationType()) {
1:e73ab34:                     return true;
1:e73ab34:                 }
1:e73ab34:             }
1:e73ab34: 
1:e73ab34:             return false;
1:e73ab34:         }
1:e73ab34: 
1:1faa4af:         return true;
1:1faa4af:     }
1:3953b9a: 
1:5fc2535:     /**
1:301203e:      * Subscriptions for these destinations are always created
1:687a45a:      */
1:687a45a:     protected void setupStaticDestinations() {
1:4fcc1f7:         ActiveMQDestination[] dests = staticallyIncludedDestinations;
1:230a86c:         if (dests != null) {
1:5fc2535:             for (ActiveMQDestination dest : dests) {
1:1faa4af:                 if (isPermissableDestination(dest)) {
1:3953b9a:                     DemandSubscription sub = createDemandSubscription(dest, null);
1:96ce14b:                     if (sub != null) {
1:a80a185:                         sub.setStaticallyIncluded(true);
1:96ce14b:                         try {
1:96ce14b:                             addSubscription(sub);
1:96ce14b:                         } catch (IOException e) {
1:96ce14b:                             LOG.error("Failed to add static destination {}", dest, e);
1:96ce14b:                         }
1:96ce14b:                         LOG.trace("{}, bridging messages for static destination: {}", configuration.getBrokerName(), dest);
1:96ce14b:                     } else {
1:96ce14b:                         LOG.info("{}, static destination excluded: {}, demand already exists", configuration.getBrokerName(), dest);
1:1faa4af:                     }
1:1faa4af:                 } else {
1:1faa4af:                     LOG.info("{}, static destination excluded: {}", configuration.getBrokerName(), dest);
1:1faa4af:                 }
1:4fcc1f7:             }
1:4fcc1f7:         }
1:4fcc1f7:     }
1:1faa4af: 
1:a95c6db:     protected void addConsumerInfo(final ConsumerInfo consumerInfo) throws IOException {
1:230a86c:         ConsumerInfo info = consumerInfo.copy();
1:35ba427:         addRemoteBrokerToBrokerPath(info);
1:230a86c:         DemandSubscription sub = createDemandSubscription(info);
1:230a86c:         if (sub != null) {
1:414a646:             if (duplicateSuppressionIsRequired(sub)) {
1:9670af1:                 undoMapRegistration(sub);
1:9670af1:             } else {
1:620523a:                 if (consumerInfo.isDurable()) {
1:6013441:                     //Handle the demand generated by proxy network subscriptions
1:6013441:                     //The broker path is case is normal
1:08aa511:                     if (isProxyNSConsumerBrokerPath(sub.getRemoteInfo()) &&
1:08aa511:                             info.getSubscriptionName() != null && info.getSubscriptionName().startsWith(DURABLE_SUB_PREFIX)) {
1:6013441:                         final BrokerId[] path = info.getBrokerPath();
1:6013441:                         addProxyNetworkSubscriptionBrokerPath(sub, path, consumerInfo.getSubscriptionName());
1:6013441:                     //This is the durable sync case on broker restart
1:6013441:                     } else if (isProxyNSConsumerClientId(sub.getRemoteInfo().getClientId()) &&
1:6013441:                             isProxyBridgeSubscription(info.getClientId(), info.getSubscriptionName())) {
1:6013441:                 		addProxyNetworkSubscriptionClientId(sub, sub.getRemoteInfo().getClientId(), consumerInfo.getSubscriptionName());
1:41211c7:                 	} else {
1:41211c7:             			sub.getDurableRemoteSubs().add(new SubscriptionInfo(sub.getRemoteInfo().getClientId(), consumerInfo.getSubscriptionName()));
1:41211c7:             		}
1:9670af1:                 }
1:1faa4af:                 addSubscription(sub);
1:e1bbde7:                 LOG.debug("{} new demand subscription: {}", configuration.getBrokerName(), sub);
1:620523a:             }
1:f1eb92e:         }
1:a5dd237:     }
1:4fcc1f7: 
1:9670af1:     private void undoMapRegistration(DemandSubscription sub) {
1:8012f28:         subscriptionMapByLocalId.remove(sub.getLocalInfo().getConsumerId());
1:8012f28:         subscriptionMapByRemoteId.remove(sub.getRemoteInfo().getConsumerId());
1:9670af1:     }
1:9670af1: 
1:301203e:     /*
1:5fc2535:      * check our existing subs networkConsumerIds against the list of network
1:5fc2535:      * ids in this subscription A match means a duplicate which we suppress for
1:5fc2535:      * topics and maybe for queues
1:301203e:      */
1:9670af1:     private boolean duplicateSuppressionIsRequired(DemandSubscription candidate) {
1:9670af1:         final ConsumerInfo consumerInfo = candidate.getRemoteInfo();
1:9670af1:         boolean suppress = false;
1:5511217: 
1:8e00c6c:         if (isDuplicateSuppressionOff(consumerInfo)) {
1:9670af1:             return suppress;
1:5511217:         }
1:5511217: 
1:9670af1:         List<ConsumerId> candidateConsumers = consumerInfo.getNetworkConsumerIds();
1:5fc2535:         Collection<Subscription> currentSubs = getRegionSubscriptions(consumerInfo.getDestination());
1:5511217:         for (Subscription sub : currentSubs) {
1:414a646:             List<ConsumerId> networkConsumers = sub.getConsumerInfo().getNetworkConsumerIds();
1:5511217:             if (!networkConsumers.isEmpty()) {
1:5511217:                 if (matchFound(candidateConsumers, networkConsumers)) {
1:a6b85cc:                     if (isInActiveDurableSub(sub)) {
1:a6b85cc:                         suppress = false;
1:a6b85cc:                     } else {
1:a6b85cc:                         suppress = hasLowerPriority(sub, candidate.getLocalInfo());
1:a6b85cc:                     }
1:ee4c8ee:                     break;
1:9670af1:                 }
1:9670af1:             }
1:301203e:         }
1:9670af1:         return suppress;
1:301203e:     }
1:9670af1: 
1:8e00c6c:     private boolean isDuplicateSuppressionOff(final ConsumerInfo consumerInfo) {
1:8e00c6c:         return !configuration.isSuppressDuplicateQueueSubscriptions() && !configuration.isSuppressDuplicateTopicSubscriptions()
1:8e00c6c:                 || consumerInfo.getDestination().isQueue() && !configuration.isSuppressDuplicateQueueSubscriptions()
1:8e00c6c:                 || consumerInfo.getDestination().isTopic() && !configuration.isSuppressDuplicateTopicSubscriptions();
1:8e00c6c:     }
1:8e00c6c: 
1:a6b85cc:     private boolean isInActiveDurableSub(Subscription sub) {
1:5fc2535:         return (sub.getConsumerInfo().isDurable() && sub instanceof DurableTopicSubscription && !((DurableTopicSubscription) sub).isActive());
1:301203e:     }
1:9670af1: 
1:9670af1:     private boolean hasLowerPriority(Subscription existingSub, ConsumerInfo candidateInfo) {
1:9670af1:         boolean suppress = false;
1:9670af1: 
1:9670af1:         if (existingSub.getConsumerInfo().getPriority() >= candidateInfo.getPriority()) {
1:e1bbde7:             LOG.debug("{} Ignoring duplicate subscription from {}, sub: {} is duplicate by network subscription with equal or higher network priority: {}, networkConsumerIds: {}", new Object[]{
1:e1bbde7:                     configuration.getBrokerName(), remoteBrokerName, candidateInfo, existingSub, existingSub.getConsumerInfo().getNetworkConsumerIds()
1:e1bbde7:             });
1:9670af1:             suppress = true;
1:9670af1:         } else {
1:9670af1:             // remove the existing lower priority duplicate and allow this candidate
1:1faa4af:             try {
1:9670af1:                 removeDuplicateSubscription(existingSub);
1:9670af1: 
1:e1bbde7:                 LOG.debug("{} Replacing duplicate subscription {} with sub from {}, which has a higher priority, new sub: {}, networkConsumerIds: {}", new Object[]{
1:e1bbde7:                         configuration.getBrokerName(), existingSub.getConsumerInfo(), remoteBrokerName, candidateInfo, candidateInfo.getNetworkConsumerIds()
1:e1bbde7:                 });
1:1faa4af:             } catch (IOException e) {
1:e1bbde7:                 LOG.error("Failed to remove duplicated sub as a result of sub with higher priority, sub: {}", existingSub, e);
1:9670af1:             }
1:9670af1:         }
1:9670af1:         return suppress;
1:9670af1:     }
1:9670af1: 
1:9670af1:     private void removeDuplicateSubscription(Subscription existingSub) throws IOException {
1:414a646:         for (NetworkConnector connector : brokerService.getNetworkConnectors()) {
1:9670af1:             if (connector.removeDemandSubscription(existingSub.getConsumerInfo().getConsumerId())) {
1:9670af1:                 break;
1:9670af1:             }
1:9670af1:         }
1:9670af1:     }
1:301203e: 
1:301203e:     private boolean matchFound(List<ConsumerId> candidateConsumers, List<ConsumerId> networkConsumers) {
1:301203e:         boolean found = false;
1:301203e:         for (ConsumerId aliasConsumer : networkConsumers) {
1:301203e:             if (candidateConsumers.contains(aliasConsumer)) {
1:301203e:                 found = true;
1:5511217:                 break;
1:301203e:             }
1:301203e:         }
1:301203e:         return found;
1:301203e:     }
1:5511217: 
1:620523a:     protected final Collection<Subscription> getRegionSubscriptions(ActiveMQDestination dest) {
1:7dc2c4e:         RegionBroker region_broker = (RegionBroker) brokerService.getRegionBroker();
1:7dc2c4e:         Region region;
1:7dc2c4e:         Collection<Subscription> subs;
1:301203e: 
1:7dc2c4e:         region = null;
1:5fc2535:         switch (dest.getDestinationType()) {
1:7dc2c4e:             case ActiveMQDestination.QUEUE_TYPE:
1:7dc2c4e:                 region = region_broker.getQueueRegion();
1:301203e:                 break;
1:7dc2c4e:             case ActiveMQDestination.TOPIC_TYPE:
1:7dc2c4e:                 region = region_broker.getTopicRegion();
1:301203e:                 break;
1:7dc2c4e:             case ActiveMQDestination.TEMP_QUEUE_TYPE:
1:7dc2c4e:                 region = region_broker.getTempQueueRegion();
1:5fc2535:                 break;
1:7dc2c4e:             case ActiveMQDestination.TEMP_TOPIC_TYPE:
1:7dc2c4e:                 region = region_broker.getTempTopicRegion();
4:7dc2c4e:                 break;
1:301203e:         }
1:301203e: 
1:5fc2535:         if (region instanceof AbstractRegion) {
1:7dc2c4e:             subs = ((AbstractRegion) region).getSubscriptions().values();
1:8761189:         } else {
1:7dc2c4e:             subs = null;
1:f1eb92e:         }
1:2a558c8: 
1:7dc2c4e:         return subs;
1:a5dd237:     }
1:5fc2535: 
1:400b1fc:     protected DemandSubscription createDemandSubscription(ConsumerInfo info) throws IOException {
1:5fc2535:         // add our original id to ourselves
1:b32ff4d:         info.addNetworkConsumerId(info.getConsumerId());
1:400b1fc:         return doCreateDemandSubscription(info);
1:a5dd237:     }
1:5fc2535: 
1:400b1fc:     protected DemandSubscription doCreateDemandSubscription(ConsumerInfo info) throws IOException {
1:230a86c:         DemandSubscription result = new DemandSubscription(info);
1:230a86c:         result.getLocalInfo().setConsumerId(new ConsumerId(localSessionInfo.getSessionId(), consumerIdGenerator.getNextSequenceId()));
1:35ba427:         if (info.getDestination().isTemporary()) {
1:230a86c:             // reset the local connection Id
1:414a646:             ActiveMQTempDestination dest = (ActiveMQTempDestination) result.getLocalInfo().getDestination();
1:35ba427:             dest.setConnectionId(localConnectionInfo.getConnectionId().toString());
1:a5dd237:         }
1:a80acbb: 
1:230a86c:         if (configuration.isDecreaseNetworkConsumerPriority()) {
1:5b796cd:             byte priority = (byte) configuration.getConsumerPriorityBase();
1:9670af1:             if (info.getBrokerPath() != null && info.getBrokerPath().length > 1) {
1:9670af1:                 // The longer the path to the consumer, the less it's consumer priority.
1:9670af1:                 priority -= info.getBrokerPath().length + 1;
1:5b8a886:             }
1:687a45a:             result.getLocalInfo().setPriority(priority);
1:2bbfbcf:             LOG.debug("{} using priority: {} for subscription: {}", new Object[]{configuration.getBrokerName(), priority, info});
1:9670af1:         }
1:400b1fc:         configureDemandSubscription(info, result);
1:35ba427:         return result;
1:a5dd237:     }
1:7fbbcf3: 
1:3953b9a:     final protected DemandSubscription createDemandSubscription(ActiveMQDestination destination, final String subscriptionName) {
1:687a45a:         ConsumerInfo info = new ConsumerInfo();
1:8012f28:         info.setNetworkSubscription(true);
1:687a45a:         info.setDestination(destination);
1:7fbbcf3: 
1:3953b9a:         if (subscriptionName != null) {
1:3953b9a:             info.setSubscriptionName(subscriptionName);
1:3953b9a:         }
1:3953b9a: 
1:c518498:         // Indicate that this subscription is being made on behalf of the remote broker.
1:2bbfbcf:         info.setBrokerPath(new BrokerId[]{remoteBrokerId});
1:c518498: 
1:5fc2535:         // the remote info held by the DemandSubscription holds the original
1:5fc2535:         // consumerId, the local info get's overwritten
1:230a86c:         info.setConsumerId(new ConsumerId(localSessionInfo.getSessionId(), consumerIdGenerator.getNextSequenceId()));
1:2a153b0:         DemandSubscription result = null;
1:9670af1:         try {
1:2a153b0:             result = createDemandSubscription(info);
1:9670af1:         } catch (IOException e) {
1:414a646:             LOG.error("Failed to create DemandSubscription ", e);
1:a5dd237:         }
2:687a45a:         return result;
1:a5dd237:     }
1:7fbbcf3: 
1:400b1fc:     protected void configureDemandSubscription(ConsumerInfo info, DemandSubscription sub) throws IOException {
1:cc81680:         if (AdvisorySupport.isConsumerAdvisoryTopic(info.getDestination()) ||
1:cc81680:                 AdvisorySupport.isVirtualDestinationConsumerAdvisoryTopic(info.getDestination())) {
1:99c2b2e:             sub.getLocalInfo().setDispatchAsync(true);
1:f49675b:         } else {
1:99c2b2e:             sub.getLocalInfo().setDispatchAsync(configuration.isDispatchAsync());
1:5fc2535:         }
1:297eadf:         configureConsumerPrefetch(sub.getLocalInfo());
1:230a86c:         subscriptionMapByLocalId.put(sub.getLocalInfo().getConsumerId(), sub);
1:230a86c:         subscriptionMapByRemoteId.put(sub.getRemoteInfo().getConsumerId(), sub);
1:3221b16: 
1:af1b232:         sub.setNetworkBridgeFilter(createNetworkBridgeFilter(info));
1:05f82a9:         if (!info.isDurable()) {
1:05f82a9:             // This works for now since we use a VM connection to the local broker.
1:05f82a9:             // may need to change if we ever subscribe to a remote broker.
1:af1b232:             sub.getLocalInfo().setAdditionalPredicate(sub.getNetworkBridgeFilter());
1:2bda17a:         } else {
1:620523a:             sub.setLocalDurableSubscriber(new SubscriptionInfo(info.getClientId(), info.getSubscriptionName()));
1:05f82a9:         }
1:5fc2535:     }
1:3221b16: 
1:687a45a:     protected void removeDemandSubscription(ConsumerId id) throws IOException {
1:ecf89a6:         DemandSubscription sub = subscriptionMapByRemoteId.remove(id);
1:e1bbde7:         LOG.debug("{} remove request on {} from {}, consumer id: {}, matching sub: {}", new Object[]{
1:e1bbde7:                 configuration.getBrokerName(), localBroker, remoteBrokerName, id, sub
1:e1bbde7:         });
1:230a86c:         if (sub != null) {
1:687a45a:             removeSubscription(sub);
1:e1bbde7:             LOG.debug("{} removed sub on {} from {}: {}", new Object[]{
1:e1bbde7:                     configuration.getBrokerName(), localBroker, remoteBrokerName, sub.getRemoteInfo()
1:e1bbde7:             });
1:966658f:         }
1:5fc2535:     }
1:633428c: 
1:9670af1:     protected boolean removeDemandSubscriptionByLocalId(ConsumerId consumerId) {
1:9670af1:         boolean removeDone = false;
1:9670af1:         DemandSubscription sub = subscriptionMapByLocalId.get(consumerId);
1:9670af1:         if (sub != null) {
1:9670af1:             try {
1:9670af1:                 removeDemandSubscription(sub.getRemoteInfo().getConsumerId());
1:9670af1:                 removeDone = true;
1:9670af1:             } catch (IOException e) {
1:e1bbde7:                 LOG.debug("removeDemandSubscriptionByLocalId failed for localId: {}", consumerId, e);
1:9670af1:             }
1:9670af1:         }
1:9670af1:         return removeDone;
1:9670af1:     }
1:633428c: 
1:687a45a:     /**
1:5fc2535:      * Performs a timed wait on the started latch and then checks for disposed
1:5fc2535:      * before performing another wait each time the the started wait times out.
1:687a45a:      */
1:c1c82be:     protected boolean safeWaitUntilStarted() throws InterruptedException {
1:7fbbcf3:         while (!disposed.get()) {
1:7fbbcf3:             if (startedLatch.await(1, TimeUnit.SECONDS)) {
1:c1c82be:                 break;
1:5fc2535:             }
1:5fc2535:         }
1:c1c82be:         return !disposed.get();
1:5fc2535:     }
1:7fbbcf3: 
1:af1b232:     protected NetworkBridgeFilter createNetworkBridgeFilter(ConsumerInfo info) throws IOException {
1:90fcbc8:         NetworkBridgeFilterFactory filterFactory = defaultFilterFactory;
1:90fcbc8:         if (brokerService != null && brokerService.getDestinationPolicy() != null) {
1:90fcbc8:             PolicyEntry entry = brokerService.getDestinationPolicy().getEntryFor(info.getDestination());
1:90fcbc8:             if (entry != null && entry.getNetworkBridgeFilterFactory() != null) {
1:90fcbc8:                 filterFactory = entry.getNetworkBridgeFilterFactory();
1:af1b232:             }
1:af1b232:         }
1:a95c6db:         return filterFactory.create(info, getRemoteBrokerPath(), configuration.getMessageTTL(), configuration.getConsumerTTL());
1:af1b232:     }
1:633428c: 
1:174c405:     protected void addRemoteBrokerToBrokerPath(ConsumerInfo info) throws IOException {
1:174c405:         info.setBrokerPath(appendToBrokerPath(info.getBrokerPath(), getRemoteBrokerPath()));
1:174c405:     }
1:633428c: 
1:5fc2535:     protected BrokerId[] getRemoteBrokerPath() {
1:174c405:         return remoteBrokerPath;
1:174c405:     }
1:633428c: 
1:c518498:     @Override
1:230a86c:     public void setNetworkBridgeListener(NetworkBridgeListener listener) {
1:230a86c:         this.networkBridgeListener = listener;
1:174c405:     }
1:633428c: 
1:4ff5a3e:     private void fireBridgeFailed(Throwable reason) {
1:4ff5a3e:         LOG.trace("fire bridge failed, listener: {}", this.networkBridgeListener, reason);
1:c752230:         NetworkBridgeListener l = this.networkBridgeListener;
1:f1eb92e:         if (l != null && this.bridgeFailed.compareAndSet(false, true)) {
1:230a86c:             l.bridgeFailed();
1:af1b232:         }
1:af1b232:     }
1:633428c: 
1:687a45a:     /**
1:5fc2535:      * @return Returns the dynamicallyIncludedDestinations.
1:5fc2535:      */
1:5fc2535:     public ActiveMQDestination[] getDynamicallyIncludedDestinations() {
1:5fc2535:         return dynamicallyIncludedDestinations;
1:5fc2535:     }
1:5fc2535: 
1:5fc2535:     /**
1:5fc2535:      * @param dynamicallyIncludedDestinations
1:2bbfbcf:      *         The dynamicallyIncludedDestinations to set.
1:5fc2535:      */
1:5fc2535:     public void setDynamicallyIncludedDestinations(ActiveMQDestination[] dynamicallyIncludedDestinations) {
1:5fc2535:         this.dynamicallyIncludedDestinations = dynamicallyIncludedDestinations;
1:5fc2535:     }
1:5fc2535: 
1:5fc2535:     /**
1:5fc2535:      * @return Returns the excludedDestinations.
1:5fc2535:      */
1:5fc2535:     public ActiveMQDestination[] getExcludedDestinations() {
1:5fc2535:         return excludedDestinations;
1:5fc2535:     }
1:5fc2535: 
1:5fc2535:     /**
1:2bbfbcf:      * @param excludedDestinations The excludedDestinations to set.
1:5fc2535:      */
1:5fc2535:     public void setExcludedDestinations(ActiveMQDestination[] excludedDestinations) {
1:5fc2535:         this.excludedDestinations = excludedDestinations;
1:5fc2535:     }
1:5fc2535: 
1:5fc2535:     /**
1:5fc2535:      * @return Returns the staticallyIncludedDestinations.
1:5fc2535:      */
1:3973d8f:     public ActiveMQDestination[] getStaticallyIncludedDestinations() {
1:5fc2535:         return staticallyIncludedDestinations;
1:5fc2535:     }
1:5fc2535: 
1:5fc2535:     /**
1:2bbfbcf:      * @param staticallyIncludedDestinations The staticallyIncludedDestinations to set.
1:5fc2535:      */
1:5fc2535:     public void setStaticallyIncludedDestinations(ActiveMQDestination[] staticallyIncludedDestinations) {
1:5fc2535:         this.staticallyIncludedDestinations = staticallyIncludedDestinations;
1:5fc2535:     }
1:5fc2535: 
1:5fc2535:     /**
1:5fc2535:      * @return Returns the durableDestinations.
1:5fc2535:      */
1:5fc2535:     public ActiveMQDestination[] getDurableDestinations() {
1:5fc2535:         return durableDestinations;
1:5fc2535:     }
1:5fc2535: 
1:5fc2535:     /**
1:2bbfbcf:      * @param durableDestinations The durableDestinations to set.
1:5fc2535:      */
1:5fc2535:     public void setDurableDestinations(ActiveMQDestination[] durableDestinations) {
1:5fc2535:         this.durableDestinations = durableDestinations;
1:5fc2535:     }
1:5fc2535: 
1:5fc2535:     /**
1:5fc2535:      * @return Returns the localBroker.
1:5fc2535:      */
1:5fc2535:     public Transport getLocalBroker() {
1:5fc2535:         return localBroker;
1:5fc2535:     }
1:5fc2535: 
1:5fc2535:     /**
1:5fc2535:      * @return Returns the remoteBroker.
1:5fc2535:      */
1:5fc2535:     public Transport getRemoteBroker() {
1:5fc2535:         return remoteBroker;
1:5fc2535:     }
1:5fc2535: 
1:5fc2535:     /**
1:5fc2535:      * @return the createdByDuplex
1:5fc2535:      */
1:5fc2535:     public boolean isCreatedByDuplex() {
1:5fc2535:         return this.createdByDuplex;
1:5fc2535:     }
1:5fc2535: 
1:5fc2535:     /**
1:2bbfbcf:      * @param createdByDuplex the createdByDuplex to set
1:5fc2535:      */
1:5fc2535:     public void setCreatedByDuplex(boolean createdByDuplex) {
1:5fc2535:         this.createdByDuplex = createdByDuplex;
1:5fc2535:     }
1:5fc2535: 
1:c518498:     @Override
1:230a86c:     public String getRemoteAddress() {
1:230a86c:         return remoteBroker.getRemoteAddress();
1:5fc2535:     }
1:633428c: 
1:c518498:     @Override
1:230a86c:     public String getLocalAddress() {
1:230a86c:         return localBroker.getRemoteAddress();
1:5fc2535:     }
1:ecf89a6: 
1:c518498:     @Override
1:230a86c:     public String getRemoteBrokerName() {
1:230a86c:         return remoteBrokerInfo == null ? null : remoteBrokerInfo.getBrokerName();
1:5fc2535:     }
1:ecf89a6: 
1:c518498:     @Override
1:71e4585:     public String getRemoteBrokerId() {
1:2bbfbcf:         return (remoteBrokerInfo == null || remoteBrokerInfo.getBrokerId() == null) ? null : remoteBrokerInfo.getBrokerId().toString();
1:71e4585:     }
1:71e4585: 
1:71e4585:     @Override
1:230a86c:     public String getLocalBrokerName() {
1:230a86c:         return localBrokerInfo == null ? null : localBrokerInfo.getBrokerName();
1:5fc2535:     }
1:fc00993: 
1:c518498:     @Override
1:230a86c:     public long getDequeueCounter() {
1:10c998b:         return networkBridgeStatistics.getDequeues().getCount();
1:5fc2535:     }
1:fc00993: 
1:c518498:     @Override
1:230a86c:     public long getEnqueueCounter() {
1:10c998b:         return networkBridgeStatistics.getEnqueues().getCount();
1:10c998b:     }
1:10c998b: 
1:10c998b:     @Override
1:10c998b:     public NetworkBridgeStatistics getNetworkBridgeStatistics() {
1:10c998b:         return networkBridgeStatistics;
1:99c2b2e:     }
1:230a86c: 
1:a32832f:     protected boolean isDuplex() {
1:a32832f:         return configuration.isDuplex() || createdByDuplex;
1:a80acbb:     }
1:230a86c: 
1:9ef4259:     public ConcurrentMap<ConsumerId, DemandSubscription> getLocalSubscriptionMap() {
1:8d0cf31:         return subscriptionMapByRemoteId;
1:8d0cf31:     }
1:8d0cf31: 
1:c518498:     @Override
1:301203e:     public void setBrokerService(BrokerService brokerService) {
1:301203e:         this.brokerService = brokerService;
1:174c405:         this.localBrokerId = brokerService.getRegionBroker().getBrokerId();
1:174c405:         localBrokerPath[0] = localBrokerId;
1:301203e:     }
1:f793fbd: 
1:c518498:     @Override
1:f793fbd:     public void setMbeanObjectName(ObjectName objectName) {
1:f793fbd:         this.mbeanObjectName = objectName;
1:f793fbd:     }
1:f793fbd: 
1:c518498:     @Override
1:f793fbd:     public ObjectName getMbeanObjectName() {
1:f793fbd:         return mbeanObjectName;
1:374cab9:     }
1:374cab9: 
1:a554c7c:     @Override
1:2bbfbcf:     public void resetStats() {
1:10c998b:         networkBridgeStatistics.reset();
1:f793fbd:     }
1:301203e: 
1:f1eb92e:     /*
1:f1eb92e:      * Used to allow for async tasks to await receipt of the BrokerInfo from the local and
1:f1eb92e:      * remote sides of the network bridge.
1:f1eb92e:      */
1:f1eb92e:     private static class FutureBrokerInfo implements Future<BrokerInfo> {
1:f1eb92e: 
1:f1eb92e:         private final CountDownLatch slot = new CountDownLatch(1);
1:f1eb92e:         private final AtomicBoolean disposed;
1:4ff5a3e:         private volatile BrokerInfo info = null;
1:f1eb92e: 
1:f1eb92e:         public FutureBrokerInfo(BrokerInfo info, AtomicBoolean disposed) {
1:f1eb92e:             this.info = info;
1:f1eb92e:             this.disposed = disposed;
1:f1eb92e:         }
1:f1eb92e: 
1:f1eb92e:         @Override
1:f1eb92e:         public boolean cancel(boolean mayInterruptIfRunning) {
1:f1eb92e:             slot.countDown();
1:4fcc1f7:             return true;
1:f1eb92e:         }
1:f1eb92e: 
1:f1eb92e:         @Override
1:f1eb92e:         public boolean isCancelled() {
1:f1eb92e:             return slot.getCount() == 0 && info == null;
1:f1eb92e:         }
1:f1eb92e: 
1:f1eb92e:         @Override
1:f1eb92e:         public boolean isDone() {
1:f1eb92e:             return info != null;
1:f1eb92e:         }
1:f1eb92e: 
1:f1eb92e:         @Override
1:f1eb92e:         public BrokerInfo get() throws InterruptedException, ExecutionException {
1:f1eb92e:             try {
1:f1eb92e:                 if (info == null) {
1:f1eb92e:                     while (!disposed.get()) {
1:f1eb92e:                         if (slot.await(1, TimeUnit.SECONDS)) {
1:f1eb92e:                             break;
1:f1eb92e:                         }
1:f1eb92e:                     }
1:f1eb92e:                 }
1:f1eb92e:                 return info;
1:f1eb92e:             } catch (InterruptedException e) {
1:f1eb92e:                 Thread.currentThread().interrupt();
1:e1bbde7:                 LOG.debug("Operation interrupted: {}", e, e);
1:f1eb92e:                 throw new InterruptedException("Interrupted.");
1:f1eb92e:             }
1:f1eb92e:         }
1:f1eb92e: 
1:f1eb92e:         @Override
1:f1eb92e:         public BrokerInfo get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
1:f1eb92e:             try {
1:f1eb92e:                 if (info == null) {
1:f1eb92e:                     long deadline = System.currentTimeMillis() + unit.toMillis(timeout);
1:f1eb92e: 
1:5b1412d:                     while (!disposed.get() || System.currentTimeMillis() - deadline < 0) {
1:f1eb92e:                         if (slot.await(1, TimeUnit.MILLISECONDS)) {
1:f1eb92e:                             break;
1:f1eb92e:                         }
1:f1eb92e:                     }
1:f1eb92e:                     if (info == null) {
1:f1eb92e:                         throw new TimeoutException();
1:f1eb92e:                     }
1:f1eb92e:                 }
1:f1eb92e:                 return info;
1:f1eb92e:             } catch (InterruptedException e) {
1:f1eb92e:                 throw new InterruptedException("Interrupted.");
1:f1eb92e:             }
1:f1eb92e:         }
1:f1eb92e: 
1:f1eb92e:         public void set(BrokerInfo info) {
1:f1eb92e:             this.info = info;
1:f1eb92e:             this.slot.countDown();
1:f1eb92e:         }
1:f1eb92e:     }
1:f1eb92e: 
1:2bbfbcf:     protected void serviceOutbound(Message message) {
1:6b4509c:         NetworkBridgeListener l = this.networkBridgeListener;
1:2bbfbcf:         if (l != null) {
1:2bbfbcf:             l.onOutboundMessage(this, message);
1:41c9366:         }
1:7fbbcf3:     }
1:230a86c: 
1:2bbfbcf:     protected void serviceInboundMessage(Message message) {
1:f1eb92e:         NetworkBridgeListener l = this.networkBridgeListener;
1:2bbfbcf:         if (l != null) {
1:2bbfbcf:             l.onInboundMessage(this, message);
1:7fbbcf3:         }
1:7fbbcf3:     }
6:230a86c: 
1:2bbfbcf:     protected boolean canDuplexDispatch(Message message) {
1:2bbfbcf:         boolean result = true;
1:2bbfbcf:         if (configuration.isCheckDuplicateMessagesOnDuplex()){
1:2bbfbcf:             final long producerSequenceId = message.getMessageId().getProducerSequenceId();
1:2bbfbcf:             //  messages are multiplexed on this producer so we need to query the persistenceAdapter
1:2bbfbcf:             long lastStoredForMessageProducer = getStoredSequenceIdForMessage(message.getMessageId());
1:2bbfbcf:             if (producerSequenceId <= lastStoredForMessageProducer) {
1:2bbfbcf:                 result = false;
1:2bbfbcf:                 LOG.debug("suppressing duplicate message send [{}] from network producer with producerSequence [{}] less than last stored: {}", new Object[]{
1:2bbfbcf:                         (LOG.isTraceEnabled() ? message : message.getMessageId()), producerSequenceId, lastStoredForMessageProducer
1:2bbfbcf:                 });
1:2bbfbcf:             }
1:2bbfbcf:         }
1:2bbfbcf:         return result;
1:2bbfbcf:     }
1:2bbfbcf: 
1:2bbfbcf:     protected long getStoredSequenceIdForMessage(MessageId messageId) {
1:2bbfbcf:         try {
1:2bbfbcf:             return brokerService.getPersistenceAdapter().getLastProducerSequenceId(messageId.getProducerId());
1:2bbfbcf:         } catch (IOException ignored) {
1:2bbfbcf:             LOG.debug("Failed to determine last producer sequence id for: {}", messageId, ignored);
1:2bbfbcf:         }
1:2bbfbcf:         return -1;
1:2bbfbcf:     }
1:2bbfbcf: 
1:297eadf:     protected void configureConsumerPrefetch(ConsumerInfo consumerInfo) {
1:297eadf:         //If a consumer on an advisory topic and advisoryPrefetchSize has been explicitly
1:297eadf:         //set then use it, else default to the prefetchSize setting
1:297eadf:         if (AdvisorySupport.isAdvisoryTopic(consumerInfo.getDestination()) &&
1:297eadf:                 configuration.getAdvisoryPrefetchSize() > 0) {
1:297eadf:             consumerInfo.setPrefetchSize(configuration.getAdvisoryPrefetchSize());
1:297eadf:         } else {
1:297eadf:             consumerInfo.setPrefetchSize(configuration.getPrefetchSize());
1:297eadf:         }
1:297eadf:     }
1:297eadf: 
1:3221b16: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:50d27e7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.filter.NonCachedMessageEvaluationContext;
/////////////////////////////////////////////////////////////////////////
1:             NonCachedMessageEvaluationContext messageEvalContext = new NonCachedMessageEvaluationContext();
commit:63f0b7e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.failover.FailoverTransport;
/////////////////////////////////////////////////////////////////////////
1:                     stopFailoverTransport(remoteBroker);
/////////////////////////////////////////////////////////////////////////
1:     private void stopFailoverTransport(Transport transport) {
1:         FailoverTransport failoverTransport = transport.narrow(FailoverTransport.class);
1:         if (failoverTransport != null) {
1:             // may be blocked on write, in which case stop will block
1:             try {
1:                 failoverTransport.handleTransportFailure(new IOException("Bridge stopped"));
1:             } catch (InterruptedException ignored) {}
1:         }
1:     }
1: 
commit:57795ba
/////////////////////////////////////////////////////////////////////////
1:                     if (originalTransport instanceof TcpTransport) {
1:                         X509Certificate[] peerCerts = originalTransport.getPeerCertificates();
/////////////////////////////////////////////////////////////////////////
1:                         if (originalTransport instanceof TcpTransport) {
1:                             X509Certificate[] peerCerts = originalTransport.getPeerCertificates();
commit:d84a586
/////////////////////////////////////////////////////////////////////////
1:                 duplexInboundLocalBroker = NetworkBridgeFactory.createLocalAsyncTransport(brokerService.getBroker().getVmConnectorURI());
/////////////////////////////////////////////////////////////////////////
1:             final MessageAck ack = new MessageAck(message, MessageAck.STANDARD_ACK_TYPE, demandConsumerDispatched);
1:             brokerService.getTaskRunnerFactory().execute(new Runnable() {
1:                 @Override
1:                 public void run() {
1:                     try {
1:                         remoteBroker.oneway(ack);
1:                     } catch (IOException e) {
1:                         LOG.warn("Failed to send advisory ack " + ack, e);
1:                     }
1:                 }
1:             });
/////////////////////////////////////////////////////////////////////////
1:             localBroker.oneway(sub.getLocalInfo());
commit:8e00c6c
/////////////////////////////////////////////////////////////////////////
1:                                         final ConsumerInfo consumerInfo = (ConsumerInfo) command;
1:                                         if (isDuplicateSuppressionOff(consumerInfo)) {
1:                                             addConsumerInfo(consumerInfo);
1:                                         } else {
1:                                             synchronized (brokerService.getVmConnectorURI()) {
1:                                                 addConsumerInfo(consumerInfo);
1:                                             }
1:                                         }
/////////////////////////////////////////////////////////////////////////
1:             // if duplicate suppression is required
1:             if (isDuplicateSuppressionOff(info)) {
1:             } else {
1:                 synchronized (brokerService.getVmConnectorURI()) {
1:                     addConsumerInfo(info);
1:                 }
/////////////////////////////////////////////////////////////////////////
0:             if (isCreatedByDuplex() && !isDuplicateSuppressionOff(sub.getRemoteInfo())) {
0:                 // async vm transport on duplex end, need to wait for completion
/////////////////////////////////////////////////////////////////////////
1:         if (isDuplicateSuppressionOff(consumerInfo)) {
/////////////////////////////////////////////////////////////////////////
1:     private boolean isDuplicateSuppressionOff(final ConsumerInfo consumerInfo) {
1:         return !configuration.isSuppressDuplicateQueueSubscriptions() && !configuration.isSuppressDuplicateTopicSubscriptions()
1:                 || consumerInfo.getDestination().isQueue() && !configuration.isSuppressDuplicateQueueSubscriptions()
1:                 || consumerInfo.getDestination().isTopic() && !configuration.isSuppressDuplicateTopicSubscriptions();
1:     }
1: 
commit:2537266
/////////////////////////////////////////////////////////////////////////
1:                         LOG.info("error with pending local brokerInfo on: " + localBroker, error);
/////////////////////////////////////////////////////////////////////////
1:                         LOG.info("error with pending remote brokerInfo on: " + remoteBroker, error);
commit:1f9b139
/////////////////////////////////////////////////////////////////////////
1:                                 configuration.getBrokerName(), remoteBrokerName, md.getConsumerId(), message.getDestination(), Arrays.toString(message.getBrokerPath()), (LOG.isTraceEnabled() ? message : message.getMessageId())
commit:002ade7
/////////////////////////////////////////////////////////////////////////
1:                             if (NetworkBridgeFilter.isAdvisoryInterpretedByNetworkBridge(message)) {
/////////////////////////////////////////////////////////////////////////
1:                         if (isDuplex() && NetworkBridgeFilter.isAdvisoryInterpretedByNetworkBridge(message)) {
commit:3100909
/////////////////////////////////////////////////////////////////////////
1:                         remoteBrokerInfo.setNetworkConnection(true);
1:                         duplexInboundLocalBroker.oneway(remoteBrokerInfo);
1: 
commit:17f4f34
/////////////////////////////////////////////////////////////////////////
1:                     LOG.info("{} Shutting down {}", configuration.getBrokerName(), configuration.getName());
commit:c1c82be
/////////////////////////////////////////////////////////////////////////
1:             return;
1:         }
1: 
1:         try {
1:             if (safeWaitUntilStarted()) {
1:                 setupStaticDestinations();
1:             }
1:         } catch (Throwable e) {
1:             serviceLocalException(e);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         LOG.trace("serviceLocalException: disposed {} ex", disposed.get(), error);
/////////////////////////////////////////////////////////////////////////
1:     protected boolean safeWaitUntilStarted() throws InterruptedException {
1:                 break;
1:         return !disposed.get();
commit:4ff5a3e
/////////////////////////////////////////////////////////////////////////
0:                 fireBridgeFailed(new Throwable("remoteBrokerInfo is null"));
/////////////////////////////////////////////////////////////////////////
0:                 fireBridgeFailed(new Throwable("localBrokerInfo is null"));
/////////////////////////////////////////////////////////////////////////
1:             fireBridgeFailed(error);
/////////////////////////////////////////////////////////////////////////
1:             fireBridgeFailed(error);
/////////////////////////////////////////////////////////////////////////
1:     private void fireBridgeFailed(Throwable reason) {
1:         LOG.trace("fire bridge failed, listener: {}", this.networkBridgeListener, reason);
/////////////////////////////////////////////////////////////////////////
1:         private volatile BrokerInfo info = null;
commit:50ec158
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicBoolean duplexInitiatingConnectionInfoReceived = new AtomicBoolean();
/////////////////////////////////////////////////////////////////////////
1:                                     if (duplexInitiatingConnection != null && duplexInitiatingConnectionInfoReceived.compareAndSet(false, true)) {
1:                                         // end of initiating connection setup - propogate to initial connection to get mbean by clientid
1:                                         duplexInitiatingConnection.processAddConnection((ConnectionInfo) command);
1:                                     } else {
1:                                         localBroker.oneway(command);
1:                                     }
1:                                     break;
commit:a80a185
/////////////////////////////////////////////////////////////////////////
1:                 sub.setStaticallyIncluded(true);
commit:6c5732b
/////////////////////////////////////////////////////////////////////////
0:     protected IdGenerator idGenerator;
/////////////////////////////////////////////////////////////////////////
1:             if (configuration.isUseBrokerNamesAsIdSeed()) {
1:                 idGenerator = new IdGenerator(brokerService.getBrokerName() + "->" + remoteBrokerName);
1:             } else {
0:                 idGenerator = new IdGenerator();
1:             }
author:giliva
-------------------------------------------------------------------------------
commit:5b1412d
/////////////////////////////////////////////////////////////////////////
1:                     while (!disposed.get() || System.currentTimeMillis() - deadline < 0) {
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:08aa511
/////////////////////////////////////////////////////////////////////////
1:                     if (isProxyNSConsumerBrokerPath(sub.getRemoteInfo()) &&
1:                             info.getSubscriptionName() != null && info.getSubscriptionName().startsWith(DURABLE_SUB_PREFIX)) {
commit:6013441
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected boolean isProxyBridgeSubscription(String clientId, String subName) {
1:         if (subName != null && clientId != null) {
1:             if (subName.startsWith(DURABLE_SUB_PREFIX) && !clientId.startsWith(configuration.getName())) {
1:     /**
1:      * This scenaior is primarily used for durable sync on broker restarts
1:      *
1:      * @param sub
1:      * @param clientId
1:      * @param subName
1:      */
1:     protected void addProxyNetworkSubscriptionClientId(final DemandSubscription sub, final String clientId, String subName) {
1:         if (clientId != null && sub != null && subName != null) {
1:                 String newClientId = getProxyBridgeClientId(clientId);
1:                 final SubscriptionInfo newSubInfo = new SubscriptionInfo(newClientId, subName);
1:                 sub.getDurableRemoteSubs().add(newSubInfo);
1:                 LOG.debug("Adding proxy network subscription {} to demand subscription", newSubInfo);
1: 
1:     /**
1:      * Add a durable remote proxy subscription when we can generate via the BrokerId path
1:      * This is the most common scenario
1:      *
1:      * @param sub
1:      * @param path
1:      * @param subName
1:      */
1:     protected void addProxyNetworkSubscriptionBrokerPath(final DemandSubscription sub, final BrokerId[] path, String subName) {
1:         if (sub != null && path.length > 1 && subName != null) {
1:             String b1 = path[path.length-1].toString();
1:             String b2 = path[path.length-2].toString();
1:             final SubscriptionInfo newSubInfo = new SubscriptionInfo(b2 + configuration.getClientIdToken() + "inbound" + configuration.getClientIdToken() + b1, subName);
1:             sub.getDurableRemoteSubs().add(newSubInfo);
1:         }
1:     }
1: 
1:     private String getProxyBridgeClientId(String clientId) {
1:         String newClientId = clientId;
/////////////////////////////////////////////////////////////////////////
1:     protected boolean isProxyNSConsumerBrokerPath(ConsumerInfo info) {
1:     protected boolean isProxyNSConsumerClientId(String clientId) {
1:         return clientId != null && clientId.split(Pattern.quote(configuration.getClientIdToken())).length > 3;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             final RemoveSubscriptionInfo info = ((RemoveSubscriptionInfo) data);
1:             final SubscriptionInfo subscriptionInfo = new SubscriptionInfo(info.getClientId(), info.getSubscriptionName());
1:             final boolean proxyBridgeSub = isProxyBridgeSubscription(subscriptionInfo.getClientId(),
1:                     subscriptionInfo.getSubscriptionName());
1:                 //If this is a proxy bridge subscription we need to try changing the clientId
1:                 if (!removed && proxyBridgeSub){
1:                     subscriptionInfo.setClientId(getProxyBridgeClientId(subscriptionInfo.getClientId()));
1:                     if (ds.getDurableRemoteSubs().contains(subscriptionInfo)) {
1:                         ds.getDurableRemoteSubs().remove(subscriptionInfo);
1:                         removed = true;
1:                     }
1:                 }
1: 
/////////////////////////////////////////////////////////////////////////
1:                     //Handle the demand generated by proxy network subscriptions
1:                     //The broker path is case is normal
0:                     if (isProxyNSConsumerBrokerPath(sub.getRemoteInfo())) {
1:                         final BrokerId[] path = info.getBrokerPath();
1:                         addProxyNetworkSubscriptionBrokerPath(sub, path, consumerInfo.getSubscriptionName());
1:                     //This is the durable sync case on broker restart
1:                     } else if (isProxyNSConsumerClientId(sub.getRemoteInfo().getClientId()) &&
1:                             isProxyBridgeSubscription(info.getClientId(), info.getSubscriptionName())) {
1:                 		addProxyNetworkSubscriptionClientId(sub, sub.getRemoteInfo().getClientId(), consumerInfo.getSubscriptionName());
commit:3ca439c
/////////////////////////////////////////////////////////////////////////
1: import java.util.regex.Pattern;
/////////////////////////////////////////////////////////////////////////
1:                     localClientId = configuration.getName() + configuration.getClientIdToken() + remoteBrokerName + configuration.getClientIdToken() + "inbound" + configuration.getClientIdToken() + configuration.getBrokerName();
/////////////////////////////////////////////////////////////////////////
1:                         duplexLocalConnectionInfo.setClientId(configuration.getName() + configuration.getClientIdToken() + remoteBrokerName + configuration.getClientIdToken() + "inbound" + configuration.getClientIdToken() + "duplex"
1:                                 + configuration.getClientIdToken() + configuration.getBrokerName());
/////////////////////////////////////////////////////////////////////////
1:                 remoteConnectionInfo.setClientId(configuration.getName() + configuration.getClientIdToken() + configuration.getBrokerName() + configuration.getClientIdToken() + "outbound");
/////////////////////////////////////////////////////////////////////////
0:             final SubscriptionInfo newSubInfo = new SubscriptionInfo(b2 + configuration.getClientIdToken() + "inbound" + configuration.getClientIdToken() + b1, subName);
/////////////////////////////////////////////////////////////////////////
0:         String newClientId = info.getClientId();
1:         String[] clientIdTokens = newClientId != null ? newClientId.split(Pattern.quote(configuration.getClientIdToken())) : null;
1:         if (clientIdTokens != null && clientIdTokens.length > 2) {
1:             newClientId = clientIdTokens[clientIdTokens.length - 3] +  configuration.getClientIdToken() + "inbound"
1:                     + configuration.getClientIdToken() +  clientIdTokens[clientIdTokens.length -1];
commit:96ce14b
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Checks whether or not this consumer is a direct bridge network subscription
1:      * @param info
1:      * @return
1:      */
0:     protected boolean isBridgeNS(ConsumerInfo info) {
1:         return (info.getSubscriptionName() != null && info.getSubscriptionName().startsWith(DURABLE_SUB_PREFIX)) &&
1:                 (info.getClientId() == null || info.getClientId().startsWith(configuration.getName()));
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                                                     //Also re-add network consumers that are not part of this direct
1:                                                     //bridge (proxy of proxy bridges)
0:                                                     if((info.getSubscriptionName() == null || !isBridgeNS(info)) &&
/////////////////////////////////////////////////////////////////////////
0:             if (i != null) {
1:                 i.remove();
1:             }
/////////////////////////////////////////////////////////////////////////
1:             // continue removal in separate thread to free up tshis thread for outstanding responses
/////////////////////////////////////////////////////////////////////////
0:                         //If removing a network durable subscription that still has durable remote subs
0:                         //make sure we cleanup the durable subscription properly - necessary when using
0:                         //durable subscriptions and 3 or more brokers
0:                         if (configuration.isConduitSubscriptions() &&
0:                                 sub.getLocalInfo().getSubscriptionName() != null &&
0:                                 sub.getLocalInfo().getSubscriptionName().startsWith(DURABLE_SUB_PREFIX) &&
0:                                 sub.getDurableRemoteSubs().size() > 0) {
0:                             sub.getDurableRemoteSubs().clear();
0:                             cleanupDurableSub(sub, null);
1:                         } else {
1:                             localBroker.oneway(sub.getLocalInfo().createRemoveCommand());
1:                         }
/////////////////////////////////////////////////////////////////////////
1:                     if (sub != null) {
0:                         sub.setStaticallyIncluded(true);
1:                         try {
1:                             addSubscription(sub);
1:                         } catch (IOException e) {
1:                             LOG.error("Failed to add static destination {}", dest, e);
1:                         }
1:                         LOG.trace("{}, bridging messages for static destination: {}", configuration.getBrokerName(), dest);
1:                     } else {
1:                         LOG.info("{}, static destination excluded: {}, demand already exists", configuration.getBrokerName(), dest);
commit:b9cb02a
/////////////////////////////////////////////////////////////////////////
1:     //Use a new executor for processing BrokerSubscriptionInfo so we don't block other threads
1:     private final ExecutorService syncExecutor = Executors.newSingleThreadExecutor();
/////////////////////////////////////////////////////////////////////////
1:                                 //Shutdown the syncExecutor, call countDown to make sure a thread can
1:                                 //terminate if it is waiting
1:                                 staticDestinationsLatch.countDown();
1:                                 syncExecutor.shutdown();
1:                                 if (!syncExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
1:                                     List<Runnable> pendingTasks = syncExecutor.shutdownNow();
1:                                     LOG.info("pending tasks on stop {}", pendingTasks);
1:                                 }
/////////////////////////////////////////////////////////////////////////
1:                     final BrokerSubscriptionInfo brokerSubscriptionInfo = (BrokerSubscriptionInfo) command;
1:                     //Start in a new thread so we don't block the transport waiting for staticDestinations
1:                     syncExecutor.execute(new Runnable() {
1: 
1:                         @Override
1:                         public void run() {
1:                             try {
1:                                 staticDestinationsLatch.await();
1:                                 //Make sure after the countDown of staticDestinationsLatch we aren't stopping
1:                                 if (!disposed.get()) {
1:                                     BrokerSubscriptionInfo subInfo = brokerSubscriptionInfo;
1:                                     LOG.debug("Received Remote BrokerSubscriptionInfo on {} from {}",
1:                                             brokerService.getBrokerName(), subInfo.getBrokerName());
1: 
1:                                     if (configuration.isSyncDurableSubs() && configuration.isConduitSubscriptions()
1:                                             && !configuration.isDynamicOnly()) {
1:                                         if (started.get()) {
1:                                             if (subInfo.getSubscriptionInfos() != null) {
1:                                                 for (ConsumerInfo info : subInfo.getSubscriptionInfos()) {
1:                                                     //re-add any process any non-NC consumers that match the
1:                                                     //dynamicallyIncludedDestinations list
0:                                                     if((info.getSubscriptionName() == null || !info.getSubscriptionName().startsWith(DURABLE_SUB_PREFIX)) &&
1:                                                             NetworkBridgeUtils.matchesDestinations(dynamicallyIncludedDestinations, info.getDestination())) {
1:                                                         serviceRemoteConsumerAdvisory(info);
1:                                                     }
1:                                                 }
1:                                             }
1: 
1:                                             //After re-added, clean up any empty durables
1:                                             for (Iterator<DemandSubscription> i = subscriptionMapByLocalId.values().iterator(); i.hasNext(); ) {
1:                                                 DemandSubscription ds = i.next();
1:                                                 if (NetworkBridgeUtils.matchesDestinations(dynamicallyIncludedDestinations, ds.getLocalInfo().getDestination())) {
1:                                                     cleanupDurableSub(ds, i);
1:                                                 }
1:                                             }
1:                                         }
1:                             } catch (Exception e) {
1:                                 LOG.warn("Error processing BrokerSubscriptionInfo: {}", e.getMessage(), e);
1:                                 LOG.debug(e.getMessage(), e);
1:                     });
1: 
commit:d206621
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.NetworkBridgeUtils;
/////////////////////////////////////////////////////////////////////////
1:                         remoteBroker.oneway(NetworkBridgeUtils.getBrokerSubscriptionInfo(brokerService,
1:                                 configuration));
/////////////////////////////////////////////////////////////////////////
0:                                     //re-add any process any non-NC consumers that match the
0:                                     //dynamicallyIncludedDestinations list
0:                                     if((info.getSubscriptionName() == null || !info.getSubscriptionName().startsWith(DURABLE_SUB_PREFIX)) &&
0:                                             NetworkBridgeUtils.matchesDestinations(dynamicallyIncludedDestinations, info.getDestination())) {
/////////////////////////////////////////////////////////////////////////
0:                                 if (NetworkBridgeUtils.matchesDestinations(dynamicallyIncludedDestinations, ds.getLocalInfo().getDestination())) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:406a342
/////////////////////////////////////////////////////////////////////////
0:             //AMQ-6465 - Need to decrement the reference count after checking matches() as
0:             //the call above will increment the reference count by 1
0:             messageEvalContext.getMessageReference().decrementReferenceCount();
commit:a038655
/////////////////////////////////////////////////////////////////////////
0:                             && !configuration.isDynamicOnly()) {
0:                             if (subInfo.getSubscriptionInfos() != null) {
0:                                 for (ConsumerInfo info : subInfo.getSubscriptionInfos()) {
0:                                     if(!info.getSubscriptionName().startsWith(DURABLE_SUB_PREFIX) &&
0:                                             matchesDynamicallyIncludedDestinations(info.getDestination())) {
0:                                         serviceRemoteConsumerAdvisory(info);
1:                                     }
commit:e73ab34
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collections;
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.StringToListOfActiveMQDestinationConverter;
/////////////////////////////////////////////////////////////////////////
1:     protected final Set<ConsumerId> forcedDurableRemoteId = Collections.newSetFromMap(new ConcurrentHashMap<ConsumerId, Boolean>());
/////////////////////////////////////////////////////////////////////////
1: 
1:                     String dynamicallyIncludedDestinationsKey = "dynamicallyIncludedDestinations";
1:                     String staticallyIncludedDestinationsKey = "staticallyIncludedDestinations";
1: 
1:                     if (!configuration.getDynamicallyIncludedDestinations().isEmpty()) {
1:                         props.put(dynamicallyIncludedDestinationsKey,
1:                                 StringToListOfActiveMQDestinationConverter.
1:                                 convertFromActiveMQDestination(configuration.getDynamicallyIncludedDestinations(), true));
1:                     }
1:                     if (!configuration.getStaticallyIncludedDestinations().isEmpty()) {
1:                         props.put(staticallyIncludedDestinationsKey,
1:                                 StringToListOfActiveMQDestinationConverter.
1:                                 convertFromActiveMQDestination(configuration.getStaticallyIncludedDestinations(), true));
1:                     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:             if (forcedDurableRemoteId.remove(id)) {
1:                 for (Iterator<DemandSubscription> i = subscriptionMapByLocalId.values().iterator(); i.hasNext(); ) {
1:                     DemandSubscription ds = i.next();
1:                     boolean removed = ds.removeForcedDurableConsumer(id);
1:                     if (removed) {
1:                         cleanupDurableSub(ds, i);
1:                     }
1:                 }
1:            }
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (ds != null && ds.getLocalDurableSubscriber() != null && ds.getDurableRemoteSubs().isEmpty()
1:                 && ds.getForcedDurableConsumersSize() == 0) {
/////////////////////////////////////////////////////////////////////////
1:             for (ActiveMQDestination dest : dests) {
1:                 DestinationFilter inclusionFilter = DestinationFilter.parseFilter(dest);
1:                 if (dest != null && inclusionFilter.matches(destination) && dest.getDestinationType() == destination.getDestinationType()) {
1:                     return true;
1:                 }
1:             }
1: 
1:             return false;
/////////////////////////////////////////////////////////////////////////
0:     protected ActiveMQDestination findMatchingDestination(ActiveMQDestination[] dests, ActiveMQDestination destination) {
1:         if (dests != null && dests.length > 0) {
1:             for (ActiveMQDestination dest : dests) {
1:                 DestinationFilter inclusionFilter = DestinationFilter.parseFilter(dest);
1:                 if (dest != null && inclusionFilter.matches(destination) && dest.getDestinationType() == destination.getDestinationType()) {
0:                     return dest;
1:                 }
1:             }
1:         }
1: 
0:         return null;
1:     }
1: 
commit:3953b9a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.BrokerSubscriptionInfo;
1: import org.apache.activemq.command.CommandTypes;
/////////////////////////////////////////////////////////////////////////
1:     protected final ConcurrentMap<ConsumerId, DemandSubscription> subscriptionMapByLocalId = new ConcurrentHashMap<>();
1:     protected final ConcurrentMap<ConsumerId, DemandSubscription> subscriptionMapByRemoteId = new ConcurrentHashMap<>();
1:     protected final CountDownLatch staticDestinationsLatch = new CountDownLatch(1);
/////////////////////////////////////////////////////////////////////////
1:                     staticDestinationsLatch.countDown();
/////////////////////////////////////////////////////////////////////////
1:                 staticDestinationsLatch.countDown();
/////////////////////////////////////////////////////////////////////////
1:                     if (configuration.isSyncDurableSubs() &&
1:                             remoteBroker.getWireFormat().getVersion() >= CommandTypes.PROTOCOL_VERSION_DURABLE_SYNC) {
0:                         remoteBroker.oneway(TransportConnection.getBrokerSubscriptionInfo(brokerService));
1:                     }
/////////////////////////////////////////////////////////////////////////
1:                 } else if (command instanceof BrokerSubscriptionInfo) {
0:                     staticDestinationsLatch.await();
0:                     BrokerSubscriptionInfo subInfo = (BrokerSubscriptionInfo) command;
0:                     LOG.debug("Received Remote BrokerSubscriptionInfo on {} from {}",
0:                             this.brokerService.getBrokerName(), subInfo.getBrokerName());
1: 
0:                     if (configuration.isSyncDurableSubs() && configuration.isConduitSubscriptions()
0:                             && !configuration.isDynamicOnly() && subInfo.getSubscriptionInfos() != null) {
1:                         if (started.get()) {
0:                             for (ConsumerInfo info : subInfo.getSubscriptionInfos()) {
0:                                 if(!info.getSubscriptionName().startsWith(DURABLE_SUB_PREFIX) &&
0:                                         matchesDynamicallyIncludedDestinations(info.getDestination())) {
0:                                     serviceRemoteConsumerAdvisory(info);
1:                                 }
1:                             }
1: 
0:                             //After re-added, clean up any empty durables
1:                             for (Iterator<DemandSubscription> i = subscriptionMapByLocalId.values().iterator(); i.hasNext(); ) {
1:                                 DemandSubscription ds = i.next();
0:                                 if (matchesDynamicallyIncludedDestinations(ds.getLocalInfo().getDestination())) {
1:                                     cleanupDurableSub(ds, i);
1:                                 }
1:                             }
1:                         }
1:                     }
/////////////////////////////////////////////////////////////////////////
0:                     cleanupDurableSub(ds, i);
1:     private void cleanupDurableSub(final DemandSubscription ds,
1:             Iterator<DemandSubscription> i) throws IOException {
0:         if (ds != null && ds.getLocalDurableSubscriber() != null && ds.getDurableRemoteSubs().isEmpty()) {
1: 
1:             // deactivate subscriber
1:             RemoveInfo removeInfo = new RemoveInfo(ds.getLocalInfo().getConsumerId());
1:             localBroker.oneway(removeInfo);
1: 
1:             // remove subscriber
1:             RemoveSubscriptionInfo sending = new RemoveSubscriptionInfo();
1:             sending.setClientId(localClientId);
1:             sending.setSubscriptionName(ds.getLocalDurableSubscriber().getSubscriptionName());
1:             sending.setConnectionId(this.localConnectionInfo.getConnectionId());
1:             localBroker.oneway(sending);
1: 
1:             //remove subscriber from map
0:             i.remove();
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                                 // never request b/c they are eventually                     acked async
/////////////////////////////////////////////////////////////////////////
1:                         case BrokerSubscriptionInfo.DATA_STRUCTURE_TYPE:
1:                             break;
/////////////////////////////////////////////////////////////////////////
0:             return matchesDynamicallyIncludedDestinations(destination);
1:         }
1: 
1:         return true;
1:     }
1: 
0:     private boolean matchesDynamicallyIncludedDestinations(ActiveMQDestination destination) {
0:         ActiveMQDestination[] dests = dynamicallyIncludedDestinations;
1:         if (dests != null && dests.length > 0) {
1: 
1:         return false;
/////////////////////////////////////////////////////////////////////////
1:                     DemandSubscription sub = createDemandSubscription(dest, null);
/////////////////////////////////////////////////////////////////////////
1:     final protected DemandSubscription createDemandSubscription(ActiveMQDestination destination, final String subscriptionName) {
1:         if (subscriptionName != null) {
1:             info.setSubscriptionName(subscriptionName);
1:         }
1: 
commit:297eadf
/////////////////////////////////////////////////////////////////////////
1:                     configureConsumerPrefetch(demandConsumerInfo);
/////////////////////////////////////////////////////////////////////////
1:         if (demandConsumerDispatched > (demandConsumerInfo.getPrefetchSize() *
1:                 (configuration.getAdvisoryAckPercentage() / 100f))) {
/////////////////////////////////////////////////////////////////////////
1:         configureConsumerPrefetch(sub.getLocalInfo());
/////////////////////////////////////////////////////////////////////////
1:     protected void configureConsumerPrefetch(ConsumerInfo consumerInfo) {
1:         //If a consumer on an advisory topic and advisoryPrefetchSize has been explicitly
1:         //set then use it, else default to the prefetchSize setting
1:         if (AdvisorySupport.isAdvisoryTopic(consumerInfo.getDestination()) &&
1:                 configuration.getAdvisoryPrefetchSize() > 0) {
1:             consumerInfo.setPrefetchSize(configuration.getAdvisoryPrefetchSize());
1:         } else {
1:             consumerInfo.setPrefetchSize(configuration.getPrefetchSize());
1:         }
1:     }
1: 
commit:10c998b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected final NetworkBridgeStatistics networkBridgeStatistics = new NetworkBridgeStatistics();
/////////////////////////////////////////////////////////////////////////
1:             networkBridgeStatistics.setEnabled(brokerService.isEnableStatistics());
1: 
/////////////////////////////////////////////////////////////////////////
1:                                                     //increment counter when messages are received in duplex mode
1:                                                     networkBridgeStatistics.getReceivedCount().increment();
/////////////////////////////////////////////////////////////////////////
1:                                         networkBridgeStatistics.getReceivedCount().increment();
/////////////////////////////////////////////////////////////////////////
1:                     networkBridgeStatistics.getEnqueues().increment();
/////////////////////////////////////////////////////////////////////////
1:                                             networkBridgeStatistics.getDequeues().increment();
/////////////////////////////////////////////////////////////////////////
1:                                 networkBridgeStatistics.getDequeues().increment();
/////////////////////////////////////////////////////////////////////////
1:         return networkBridgeStatistics.getDequeues().getCount();
1:         return networkBridgeStatistics.getEnqueues().getCount();
1:     }
1: 
1:     @Override
1:     public NetworkBridgeStatistics getNetworkBridgeStatistics() {
1:         return networkBridgeStatistics;
/////////////////////////////////////////////////////////////////////////
1:         networkBridgeStatistics.reset();
commit:09054fc
/////////////////////////////////////////////////////////////////////////
1: 
0:                         //remove subscriber from map
0:                         i.remove();
commit:cc81680
/////////////////////////////////////////////////////////////////////////
1:         if (AdvisorySupport.isConsumerAdvisoryTopic(info.getDestination()) ||
1:                 AdvisorySupport.isVirtualDestinationConsumerAdvisoryTopic(info.getDestination())) {
author:Christopher L. Shannon
-------------------------------------------------------------------------------
commit:41211c7
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicInteger;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected boolean isDirectBridgeConsumer(ConsumerInfo info) {
0:     private boolean isProxyBridgeSubscription(SubscriptionInfo info) {
0:         if (info.getSubcriptionName() != null && info.getClientId() != null) {
0:             if (info.getSubscriptionName().startsWith(DURABLE_SUB_PREFIX)
0:                     && !info.getClientId().startsWith(configuration.getName())) {
1:                 return true;
1:             }
1:         }
1:         return false;
1:     }
1: 
0:     protected void addProxyNetworkSubscription(final DemandSubscription sub, final BrokerId[] path, String subName) {
0:         if (sub != null && path.length > 1 && subName != null) {
0:             String b1 = path[path.length-1].toString();
0:             String b2 = path[path.length-2].toString();
0:             final SubscriptionInfo newSubInfo = new SubscriptionInfo(b2 + "_inbound_" + b1, subName);
0:             sub.getDurableRemoteSubs().add(newSubInfo);
0:             sub.getNetworkDemandConsumerMap().computeIfAbsent(newSubInfo, v -> new AtomicInteger()).incrementAndGet();
0:             LOG.debug("Adding proxy network subscription {} to demand subscription", newSubInfo);
1:         } else {
1:             LOG.debug("Skipping addProxyNetworkSubscription");
1:         }
1:     }
1: 
0:     private String getProxyBridgeClientId(SubscriptionInfo info) {
0:         String[] clientIdTokens = info.getClientId().split("_");
0:         String newClientId = "";
0:         if (clientIdTokens.length > 2) {
0:             for (int j = clientIdTokens.length - 3; j < clientIdTokens.length; j++) {
0:                 newClientId += clientIdTokens[j];
0:                 if (j < clientIdTokens.length -1) {
0:                     newClientId += "_";
1:                 }
1:             }
1:         }
1:         return newClientId;
1:     }
1: 
0:     protected boolean isProxyNSConsumer(ConsumerInfo info) {
1:         return info.getBrokerPath() != null && info.getBrokerPath().length > 1;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                                                     if((info.getSubscriptionName() == null || !isDirectBridgeConsumer(info)) &&
/////////////////////////////////////////////////////////////////////////
1: 
0:                 //If this is a proxy bridge subscription we need to try changing the clientId
0:                 } else if (!removed && isProxyBridgeSubscription(subscriptionInfo)){
0:                     subscriptionInfo.setClientId(getProxyBridgeClientId(subscriptionInfo));
0:                     if (ds.getDurableRemoteSubs().contains(subscriptionInfo)) {
0:                         AtomicInteger count = ds.getNetworkDemandConsumerMap().computeIfAbsent(subscriptionInfo, v -> new AtomicInteger());
0:                         count.decrementAndGet();
0:                         //Only remove the durable remote sub if the count <= 0
0:                         if (count.get() <= 0) {
0:                             ds.getDurableRemoteSubs().remove(subscriptionInfo);
0:                             ds.getNetworkDemandConsumerMap().remove(subscriptionInfo);
0:                             cleanupDurableSub(ds, i);
1:                         }
1:                     }
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:             i.remove();
/////////////////////////////////////////////////////////////////////////
0:                         localBroker.oneway(sub.getLocalInfo().createRemoveCommand());
/////////////////////////////////////////////////////////////////////////
0:                 	if (isProxyNSConsumer(sub.getRemoteInfo())) {
0:                 		BrokerId[] path = sub.getRemoteInfo().getBrokerPath();
0:                 		addProxyNetworkSubscription(sub, path, consumerInfo.getSubscriptionName());
1:                 	} else {
1:             			sub.getDurableRemoteSubs().add(new SubscriptionInfo(sub.getRemoteInfo().getClientId(), consumerInfo.getSubscriptionName()));
1:             		}
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:1faa4af
/////////////////////////////////////////////////////////////////////////
1:                         if (isPermissableDestination(md.getDestination())) {
1:                            if (message.isPersistent() || configuration.isAlwaysSyncSend()) {
1:                               // The message was not sent using async send, so we should only
1:                               // ack the local broker when we get confirmation that the remote
1:                               // broker has received the message.
1:                               remoteBroker.asyncRequest(message, new ResponseCallback() {
1:                                  @Override
1:                                  public void onCompletion(FutureResponse future) {
1:                                        Response response = future.getResult();
1:                                        if (response.isException()) {
1:                                           ExceptionResponse er = (ExceptionResponse) response;
1:                                           serviceLocalException(md, er.getException());
1:                                        } else {
1:                                           localBroker.oneway(new MessageAck(md, MessageAck.INDIVIDUAL_ACK_TYPE, 1));
0:                                           networkBridgeStatistics.getDequeues().increment();
1:                                        }
1:                                        serviceLocalException(md, e);
1:                                        sub.decrementOutstandingResponses();
1:                                  }
1:                               });
1:                            } else {
1:                               // If the message was originally sent using async send, we will
1:                               // preserve that QOS by bridging it using an async send (small chance
1:                               // of message loss).
1:                               try {
1:                                  remoteBroker.oneway(message);
1:                                  localBroker.oneway(new MessageAck(md, MessageAck.INDIVIDUAL_ACK_TYPE, 1));
0:                                  networkBridgeStatistics.getDequeues().increment();
1:                               } finally {
1:                                  sub.decrementOutstandingResponses();
1:                               }
1:                            }
1:                            serviceOutbound(message);
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQDestination[] dests = excludedDestinations;
/////////////////////////////////////////////////////////////////////////
1:         dests = staticallyIncludedDestinations;
1:         if (dests != null && dests.length > 0) {
1:             for (ActiveMQDestination dest : dests) {
0:                 DestinationFilter inclusionFilter = DestinationFilter.parseFilter(dest);
0:                 if (dest != null && inclusionFilter.matches(destination) && dest.getDestinationType() == destination.getDestinationType()) {
1:                     return true;
1:                 }
1:             }
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 if (isPermissableDestination(dest)) {
0:                     DemandSubscription sub = createDemandSubscription(dest);
0:                     sub.setStaticallyIncluded(true);
1:                     try {
1:                         addSubscription(sub);
1:                     } catch (IOException e) {
0:                         LOG.error("Failed to add static destination {}", dest, e);
1:                     }
0:                     LOG.trace("{}, bridging messages for static destination: {}", configuration.getBrokerName(), dest);
1:                 } else {
1:                     LOG.info("{}, static destination excluded: {}", configuration.getBrokerName(), dest);
commit:9f9b0fb
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.tcp.TcpTransport;
/////////////////////////////////////////////////////////////////////////
1:         int timeout = 30000;
1:         TcpTransport tcpTransport = remoteBroker.narrow(TcpTransport.class);
1:         if (tcpTransport != null) {
1:            timeout = tcpTransport.getConnectionTimeout();
1:         }
1:             remoteBrokerInfo = futureRemoteBrokerInfo.get(timeout, TimeUnit.MILLISECONDS);
/////////////////////////////////////////////////////////////////////////
1:             localBrokerInfo = futureLocalBrokerInfo.get(timeout, TimeUnit.MILLISECONDS);
author:Timothy Bish
-------------------------------------------------------------------------------
commit:a3c8bee
/////////////////////////////////////////////////////////////////////////
1:                 serviceLocalException(new Throwable("remoteBrokerInfo is null"));
/////////////////////////////////////////////////////////////////////////
1:                 serviceLocalException(new Throwable("localBrokerInfo is null"));
commit:9ef4259
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentMap;
/////////////////////////////////////////////////////////////////////////
0:     protected final ConcurrentMap<ConsumerId, DemandSubscription> subscriptionMapByLocalId = new ConcurrentHashMap<ConsumerId, DemandSubscription>();
0:     protected final ConcurrentMap<ConsumerId, DemandSubscription> subscriptionMapByRemoteId = new ConcurrentHashMap<ConsumerId, DemandSubscription>();
/////////////////////////////////////////////////////////////////////////
1:     public ConcurrentMap<ConsumerId, DemandSubscription> getLocalSubscriptionMap() {
commit:60bdfc0
/////////////////////////////////////////////////////////////////////////
1:     protected IdGenerator idGenerator = new IdGenerator();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (!bridgeFailed.get() && localBridgeStarted.compareAndSet(false, true)) {
1: 
1:                     if (idGenerator == null) {
1:                         throw new IllegalStateException("Id Generator cannot be null");
1:                     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (!bridgeFailed.get() && remoteBridgeStarted.compareAndSet(false, true)) {
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator<DemandSubscription> i = subscriptionMapByLocalId.values().iterator(); i.hasNext(); ) {
0:                 DemandSubscription ds = i.next();
commit:c391321
/////////////////////////////////////////////////////////////////////////
1:                 return;
/////////////////////////////////////////////////////////////////////////
1:                 return;
commit:a554c7c
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQMessage;
1: import org.apache.activemq.command.ActiveMQTempDestination;
1: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.command.BrokerId;
1: import org.apache.activemq.command.BrokerInfo;
1: import org.apache.activemq.command.Command;
1: import org.apache.activemq.command.ConnectionError;
1: import org.apache.activemq.command.ConnectionId;
1: import org.apache.activemq.command.ConnectionInfo;
1: import org.apache.activemq.command.ConsumerId;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.command.DataStructure;
1: import org.apache.activemq.command.DestinationInfo;
1: import org.apache.activemq.command.ExceptionResponse;
1: import org.apache.activemq.command.KeepAliveInfo;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.MessageDispatch;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.command.NetworkBridgeFilter;
1: import org.apache.activemq.command.ProducerInfo;
1: import org.apache.activemq.command.RemoveInfo;
1: import org.apache.activemq.command.RemoveSubscriptionInfo;
1: import org.apache.activemq.command.Response;
1: import org.apache.activemq.command.SessionInfo;
1: import org.apache.activemq.command.ShutdownInfo;
1: import org.apache.activemq.command.SubscriptionInfo;
1: import org.apache.activemq.command.WireFormatInfo;
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("{} Ignoring sub from {}, browsers explicitly suppressed", configuration.getBrokerName(), remoteBrokerName);
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug(" stopping {} bridge to {}", configuration.getBrokerName(), remoteBrokerName);
/////////////////////////////////////////////////////////////////////////
1:                         LOG.trace("{} unregister bridge ({}) to {}", new Object[]{
1:                                 configuration.getBrokerName(), this, remoteBrokerName
1:                         });
/////////////////////////////////////////////////////////////////////////
1:                                         LOG.info("pending tasks on stop {}", pendingTasks);
1:                                 LOG.debug("Caught exception sending shutdown", e);
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("{} bridge to {} stopped", configuration.getBrokerName(), remoteBrokerName);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.trace("{} disconnecting remote loop back connector for: {}, with id: {}", new Object[]{
1:                         configuration.getBrokerName(), remoteBrokerName, remoteBrokerId
1:                 });
/////////////////////////////////////////////////////////////////////////
1:                 LOG.error("Error mapping remote configuration: {}", props, t);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.trace("{} starting local Bridge, localBroker={}", configuration.getBrokerName(), localBroker);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.info("Network connection between {} and {} ({}) has been established.", new Object[]{
1:                             localBroker, remoteBroker, remoteBrokerName
1:                     });
1:                     LOG.trace("{} register bridge ({}) to {}", new Object[]{
1:                             configuration.getBrokerName(), this, remoteBrokerName
1:                     });
/////////////////////////////////////////////////////////////////////////
0:                 LOG.warn("Network connection between {} and {} ({}) was interrupted during establishment.", new Object[]{
0:                         localBroker, remoteBroker, remoteBrokerName
1:                 });
1:             LOG.trace("{} starting remote Bridge, remoteBroker={}", configuration.getBrokerName(), remoteBroker);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.error("Network connection between {} and {} shutdown due to a remote error: {}", new Object[]{
1:                         localBroker, remoteBroker, error
1:                 });
1:                 LOG.warn("Network connection between {} and {} shutdown due to a remote error: {}", new Object[]{
1:                         localBroker, remoteBroker, error
1:                 });
1:             LOG.debug("The remote Exception was: {}", error, error);
/////////////////////////////////////////////////////////////////////////
1:                         LOG.trace("{} duplex command type: {}", configuration.getBrokerName(), command.getDataStructureType());
/////////////////////////////////////////////////////////////////////////
1:                                                 LOG.error("Exception: {} on duplex forward of: {}", error, message);
/////////////////////////////////////////////////////////////////////////
1:                                         LOG.warn("Matching local subscription not found for ack: {}", ack);
/////////////////////////////////////////////////////////////////////////
1:                                         LOG.warn("Stopping - ignoring ConsumerInfo: {}", command);
/////////////////////////////////////////////////////////////////////////
1:                                     LOG.debug("Ignoring remote command: {}", command);
/////////////////////////////////////////////////////////////////////////
1:                                 LOG.warn("Unexpected remote command: {}", command);
1:                 LOG.debug("Exception processing remote command: {}", command, e);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.info("{} Ignoring sub from {}, browsers explicitly suppressed", configuration.getBrokerName(), remoteBrokerName);
1:                 LOG.debug("{} Ignoring sub from {}, restricted to {} network hops only: {}", new Object[]{
1:                         configuration.getBrokerName(), remoteBrokerName, networkTTL, info
1:                 });
1:                 LOG.debug("{} Ignoring sub from {}, already routed through this broker once: {}", new Object[]{
1:                         configuration.getBrokerName(), remoteBrokerName, info
1:                 });
1:                 LOG.debug("{} Ignoring sub from {}, destination {} is not permitted: {}", new Object[]{
1:                         configuration.getBrokerName(), remoteBrokerName, info.getDestination(), info
1:                 });
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("{} Ignoring destination {} restricted to {} network hops only", new Object[]{
1:                         configuration.getBrokerName(), destInfo, networkTTL
1:                 });
1:                 LOG.debug("{} Ignoring destination {} already routed through this broker once", configuration.getBrokerName(), destInfo);
/////////////////////////////////////////////////////////////////////////
1:             LOG.trace("{} bridging {} destination on {} from {}, destination: {}", new Object[]{
1:                     configuration.getBrokerName(), (destInfo.isAddOperation() ? "add" : "remove"), localBroker, remoteBrokerName, destInfo
1:             });
/////////////////////////////////////////////////////////////////////////
1:                             LOG.warn("failed to deliver remove command for destination: {}", destInfo.getDestination(), e);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.warn("PoisonAck of {} on forwarding error: {}", messageDispatch.getMessage().getMessageId(), error);
1:                         LOG.error("Failed to posion ack message following forward failure: ", ioe);
1:                     LOG.warn("Ignoring exception on forwarding to non existent temp dest: ", error);
0:             LOG.info("Network connection between {} and {} shutdown due to a local error: {}", new Object[]{ localBroker, remoteBroker, error });
1:             LOG.debug("The local Exception was: {}", error, error);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.warn("failed to fire forward failure advisory, cause: {}", e);
1:                 LOG.debug("detail", e);
/////////////////////////////////////////////////////////////////////////
0:             LOG.trace("{} remove local subscription: {} for remote {}", new Object[]{ configuration.getBrokerName(), sub.getLocalInfo().getConsumerId(), sub.getRemoteInfo().getConsumerId() });
/////////////////////////////////////////////////////////////////////////
1:                         LOG.warn("failed to deliver remove command for local subscription, for remote {}", sub.getRemoteInfo().getConsumerId(), e);
/////////////////////////////////////////////////////////////////////////
1:                             LOG.debug("{} message not forwarded to {} because message came from there or fails TTL, brokerPath: {}, message: {}", new Object[]{
1:                                     configuration.getBrokerName(), remoteBrokerName, Arrays.toString(md.getMessage().getBrokerPath()), md.getMessage()
1:                             });
/////////////////////////////////////////////////////////////////////////
0:                         LOG.debug("bridging ({} -> {}), consumer: {}, destinaition: {}, brokerPath: {}, message: {}", new Object[]{
0:                                 configuration.getBrokerName(), remoteBrokerName, (LOG.isTraceEnabled() ? message : message.getMessageId()), md.getConsumerId(), message.getDestination(), Arrays.toString(message.getBrokerPath()), message
1:                         });
/////////////////////////////////////////////////////////////////////////
1:                         LOG.debug("No subscription registered with this network bridge for consumerId: {} for message: {}", md.getConsumerId(), md.getMessage());
0:                     LOG.info("{} Shutting down", configuration.getBrokerName());
/////////////////////////////////////////////////////////////////////////
1:                             LOG.warn("Unexpected local command: {}", command);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.error("Failed to add static destination {}", dest, e);
0:                 LOG.trace("{}, bridging messages for static destination: {}", configuration.getBrokerName(), dest);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("{} new demand subscription: {}", configuration.getBrokerName(), sub);
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug("{} Ignoring duplicate subscription from {}, sub: {} is duplicate by network subscription with equal or higher network priority: {}, networkConsumerIds: {}", new Object[]{
1:                     configuration.getBrokerName(), remoteBrokerName, candidateInfo, existingSub, existingSub.getConsumerInfo().getNetworkConsumerIds()
1:             });
1:                 LOG.debug("{} Replacing duplicate subscription {} with sub from {}, which has a higher priority, new sub: {}, networkConsumerIds: {}", new Object[]{
1:                         configuration.getBrokerName(), existingSub.getConsumerInfo(), remoteBrokerName, candidateInfo, candidateInfo.getNetworkConsumerIds()
1:                 });
1:                 LOG.error("Failed to remove duplicated sub as a result of sub with higher priority, sub: {}", existingSub, e);
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("{} using priority: {} for subscription: {}", new Object[]{ configuration.getBrokerName(), priority, info });
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("{} remove request on {} from {}, consumer id: {}, matching sub: {}", new Object[]{
1:                 configuration.getBrokerName(), localBroker, remoteBrokerName, id, sub
1:         });
1:             LOG.debug("{} removed sub on {} from {}: {}", new Object[]{
1:                     configuration.getBrokerName(), localBroker, remoteBrokerName, sub.getRemoteInfo()
1:             });
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("removeDemandSubscriptionByLocalId failed for localId: {}", consumerId, e);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Operation interrupted: {}", e, e);
author:Christian Posta
-------------------------------------------------------------------------------
commit:61da1fa
/////////////////////////////////////////////////////////////////////////
1:                         LOG.debug("bridging ({} -> {}), consumer: {}, destination: {}, brokerPath: {}, message: {}", new Object[]{
commit:b7c32d9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.*;
/////////////////////////////////////////////////////////////////////////
1:         } else if (data.getClass() == RemoveSubscriptionInfo.class) {
0:             RemoveSubscriptionInfo durableSub = (RemoveSubscriptionInfo)data;
0:             LOG.debug("Removing durable subscription: clientId: "  + durableSub.getClientId()
0:                     + ", durableName: " + durableSub.getSubcriptionName());
0:             localBroker.oneway(data);
author:rajdavies
-------------------------------------------------------------------------------
commit:2bbfbcf
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
1: import java.util.Collection;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Properties;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected final BrokerId localBrokerPath[] = new BrokerId[]{null};
1:     protected final BrokerId remoteBrokerPath[] = new BrokerId[]{null};
/////////////////////////////////////////////////////////////////////////
0:                                     LOG.info("pending tasks on stop {}", pendingTasks);
/////////////////////////////////////////////////////////////////////////
1:                         "remoteBroker=" + remoteBroker + ", localBroker= " + localBroker);
/////////////////////////////////////////////////////////////////////////
1:                 ServiceSupport.dispose(localBroker);
1:                 ServiceSupport.dispose(remoteBroker);
1:                 // the bridge is left in a bit of limbo, but it won't get retried
1:                 // in this state.
1:                 return;
/////////////////////////////////////////////////////////////////////////
0:                                 + configuration.getBrokerName());
/////////////////////////////////////////////////////////////////////////
0:                                     || AdvisorySupport.isDestinationAdvisoryTopic(message.getDestination())) {
/////////////////////////////////////////////////////////////////////////
1:                                 if (canDuplexDispatch(message)) {
1:                                     message.setProducerId(duplexInboundLocalProducerInfo.getProducerId());
1:                                     if (message.isResponseRequired() || configuration.isAlwaysSyncSend()) {
1:                                         duplexInboundLocalBroker.asyncRequest(message, new ResponseCallback() {
1:                                             final int correlationId = message.getCommandId();
1:                                             @Override
1:                                             public void onCompletion(FutureResponse resp) {
1:                                                 try {
1:                                                     Response reply = resp.getResult();
1:                                                     reply.setCorrelationId(correlationId);
1:                                                     remoteBroker.oneway(reply);
1:                                                 } catch (IOException error) {
0:                                                     LOG.error("Exception: {} on duplex forward of: {}", error, message);
1:                                                     serviceRemoteException(error);
1:                                                 }
1:                                         });
1:                                     } else {
1:                                         duplexInboundLocalBroker.oneway(message);
1:                                     }
1:                                     serviceInboundMessage(message);
1:                                     if (message.isResponseRequired() || configuration.isAlwaysSyncSend()) {
1:                                         Response reply = new Response();
1:                                         reply.setCorrelationId(message.getCommandId());
1:                                         remoteBroker.oneway(reply);
1:                                     }
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("Network connection between {} and {} shutdown due to a local error: {}", new Object[]{localBroker, remoteBroker, error});
/////////////////////////////////////////////////////////////////////////
1:                             advisoryMessage);
/////////////////////////////////////////////////////////////////////////
1:             LOG.trace("{} remove local subscription: {} for remote {}", new Object[]{configuration.getBrokerName(), sub.getLocalInfo().getConsumerId(), sub.getRemoteInfo().getConsumerId()});
/////////////////////////////////////////////////////////////////////////
1:             return new BrokerId[]{idToAppend};
/////////////////////////////////////////////////////////////////////////
0:                 && !configuration.isSuppressDuplicateTopicSubscriptions()) {
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug("{} using priority: {} for subscription: {}", new Object[]{configuration.getBrokerName(), priority, info});
/////////////////////////////////////////////////////////////////////////
1:         info.setBrokerPath(new BrokerId[]{remoteBrokerId});
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      *         The dynamicallyIncludedDestinations to set.
/////////////////////////////////////////////////////////////////////////
1:      * @param excludedDestinations The excludedDestinations to set.
/////////////////////////////////////////////////////////////////////////
1:      * @param staticallyIncludedDestinations The staticallyIncludedDestinations to set.
/////////////////////////////////////////////////////////////////////////
1:      * @param durableDestinations The durableDestinations to set.
/////////////////////////////////////////////////////////////////////////
1:      * @param createdByDuplex the createdByDuplex to set
/////////////////////////////////////////////////////////////////////////
1:         return (remoteBrokerInfo == null || remoteBrokerInfo.getBrokerId() == null) ? null : remoteBrokerInfo.getBrokerId().toString();
/////////////////////////////////////////////////////////////////////////
1:     public void resetStats() {
/////////////////////////////////////////////////////////////////////////
1:     protected void serviceOutbound(Message message) {
1:         if (l != null) {
1:             l.onOutboundMessage(this, message);
1:     protected void serviceInboundMessage(Message message) {
1:         if (l != null) {
1:             l.onInboundMessage(this, message);
1:     protected boolean canDuplexDispatch(Message message) {
1:         boolean result = true;
1:         if (configuration.isCheckDuplicateMessagesOnDuplex()){
1:             final long producerSequenceId = message.getMessageId().getProducerSequenceId();
1:             //  messages are multiplexed on this producer so we need to query the persistenceAdapter
1:             long lastStoredForMessageProducer = getStoredSequenceIdForMessage(message.getMessageId());
1:             if (producerSequenceId <= lastStoredForMessageProducer) {
1:                 result = false;
1:                 LOG.debug("suppressing duplicate message send [{}] from network producer with producerSequence [{}] less than last stored: {}", new Object[]{
1:                         (LOG.isTraceEnabled() ? message : message.getMessageId()), producerSequenceId, lastStoredForMessageProducer
1:                 });
1:             }
1:         }
1:         return result;
1:     }
1: 
1:     protected long getStoredSequenceIdForMessage(MessageId messageId) {
1:         try {
1:             return brokerService.getPersistenceAdapter().getLastProducerSequenceId(messageId.getProducerId());
1:         } catch (IOException ignored) {
1:             LOG.debug("Failed to determine last producer sequence id for: {}", messageId, ignored);
1:         }
1:         return -1;
1:     }
1: 
commit:71e4585
/////////////////////////////////////////////////////////////////////////
1:     public String getRemoteBrokerId() {
0:         return (remoteBrokerInfo == null || remoteBrokerInfo.getBrokerId() ==null)? null : remoteBrokerInfo.getBrokerId().toString();
1:     }
1: 
1:     @Override
commit:374cab9
/////////////////////////////////////////////////////////////////////////
0:     public void resetStats(){
0:         enqueueCounter.set(0);
0:         dequeueCounter.set(0);
1:     }
1: 
commit:489f929
/////////////////////////////////////////////////////////////////////////
0:                                 serviceInboundMessage(message);
/////////////////////////////////////////////////////////////////////////
0:                         serviceOutbound(message);
/////////////////////////////////////////////////////////////////////////
0:     protected void serviceOutbound(Message message){
1:         NetworkBridgeListener l = this.networkBridgeListener;
0:         if (l != null){
0:             l.onOutboundMessage(this,message);
1:         }
1:     }
1: 
0:     protected void serviceInboundMessage(Message message){
1:         NetworkBridgeListener l = this.networkBridgeListener;
0:         if (l != null){
0:             l.onInboundMessage(this,message);
1:         }
1:     }
1: 
author:Gary Tully
-------------------------------------------------------------------------------
commit:a95c6db
/////////////////////////////////////////////////////////////////////////
1:                     props.remove("networkTTL");
/////////////////////////////////////////////////////////////////////////
0:                                         addConsumerInfo((ConsumerInfo) command);
/////////////////////////////////////////////////////////////////////////
1:         final int networkTTL = configuration.getConsumerTTL();
/////////////////////////////////////////////////////////////////////////
1:             if (path != null && networkTTL > -1 && path.length >= networkTTL) {
/////////////////////////////////////////////////////////////////////////
1:                 addConsumerInfo(info);
1:             if (path != null && networkTTL > -1 && path.length >= networkTTL) {
/////////////////////////////////////////////////////////////////////////
0:                                     + " because message came from there or fails TTL, brokerPath: " + Arrays.toString(md.getMessage().getBrokerPath())
/////////////////////////////////////////////////////////////////////////
1:     protected void addConsumerInfo(final ConsumerInfo consumerInfo) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:                 LOG.debug(configuration.getBrokerName() + " new demand subscription: " + sub);
/////////////////////////////////////////////////////////////////////////
1:         return filterFactory.create(info, getRemoteBrokerPath(), configuration.getMessageTTL(), configuration.getConsumerTTL());
commit:78bedd6
/////////////////////////////////////////////////////////////////////////
1:             remoteBrokerId = remoteBrokerInfo.getBrokerId();
/////////////////////////////////////////////////////////////////////////
0:                  // the bridge is left in a bit of limbo, but it won't get retried
0:                  // in this state.
commit:806ec21
/////////////////////////////////////////////////////////////////////////
1:             if (isDuplex()) {
0:                 // async vm transport, need to wait for completion
0:                 localBroker.request(sub.getLocalInfo());
1:             } else {
0:                 localBroker.oneway(sub.getLocalInfo());
1:             }
commit:56cfa30
/////////////////////////////////////////////////////////////////////////
0:             localBroker.oneway(sub.getLocalInfo());
commit:def8c77
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQMessage;
0: import org.apache.activemq.command.ActiveMQTempDestination;
0: import org.apache.activemq.command.ActiveMQTopic;
0: import org.apache.activemq.command.BrokerId;
0: import org.apache.activemq.command.BrokerInfo;
0: import org.apache.activemq.command.Command;
0: import org.apache.activemq.command.ConnectionError;
0: import org.apache.activemq.command.ConnectionId;
0: import org.apache.activemq.command.ConnectionInfo;
0: import org.apache.activemq.command.ConsumerId;
0: import org.apache.activemq.command.ConsumerInfo;
0: import org.apache.activemq.command.DataStructure;
0: import org.apache.activemq.command.DestinationInfo;
0: import org.apache.activemq.command.ExceptionResponse;
0: import org.apache.activemq.command.KeepAliveInfo;
0: import org.apache.activemq.command.Message;
0: import org.apache.activemq.command.MessageAck;
0: import org.apache.activemq.command.MessageDispatch;
0: import org.apache.activemq.command.NetworkBridgeFilter;
0: import org.apache.activemq.command.ProducerInfo;
0: import org.apache.activemq.command.RemoveInfo;
0: import org.apache.activemq.command.Response;
0: import org.apache.activemq.command.SessionInfo;
0: import org.apache.activemq.command.ShutdownInfo;
0: import org.apache.activemq.command.WireFormatInfo;
/////////////////////////////////////////////////////////////////////////
commit:f4bed15
/////////////////////////////////////////////////////////////////////////
0:             localBroker.request(sub.getLocalInfo());
commit:88d85ae
/////////////////////////////////////////////////////////////////////////
0:                             LOG.trace(configuration.getBrokerName() + " duplex command type: " + command.getDataStructureType());
/////////////////////////////////////////////////////////////////////////
0:                         if (isDuplex() && AdvisorySupport.ADIVSORY_MESSAGE_TYPE.equals(message.getType())) {
1:                             try {
0:                                 // never request b/c they are eventually acked async
1:                                 remoteBroker.oneway(message);
1:                             } finally {
1:                                 sub.decrementOutstandingResponses();
1:                             }
1:                             return;
1:                         }
1: 
commit:a34970a
/////////////////////////////////////////////////////////////////////////
commit:c372448
/////////////////////////////////////////////////////////////////////////
1:                     // local start complete
1:                     if (startedLatch.getCount() < 2) {
0:                         if (LOG.isTraceEnabled()) {
0:                             LOG.trace(configuration.getBrokerName() + " unregister bridge (" + this + ") to " + remoteBrokerName);
1:                         }
1:                         brokerService.getBroker().removeBroker(null, remoteBrokerInfo);
1:                         brokerService.getBroker().networkBridgeStopped(remoteBrokerInfo);
1:                     }
1: 
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isInfoEnabled()) {
0:                 LOG.info(configuration.getBrokerName() + " bridge to " + remoteBrokerName + " stopped");
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (disposed.get()) {
1:             return;
1:         }
1: 
1:         if (isCreatedByDuplex()) {
1:             // apply remote (propagated) configuration to local duplex bridge before start
1:             Properties props = null;
1:             try {
1:                 props = MarshallingSupport.stringToProperties(remoteBrokerInfo.getNetworkProperties());
1:                 IntrospectionSupport.getProperties(configuration, props, null);
1:                 if (configuration.getExcludedDestinations() != null) {
1:                     excludedDestinations = configuration.getExcludedDestinations().toArray(
1:                             new ActiveMQDestination[configuration.getExcludedDestinations().size()]);
1:                 }
1:                 if (configuration.getStaticallyIncludedDestinations() != null) {
1:                     staticallyIncludedDestinations = configuration.getStaticallyIncludedDestinations().toArray(
1:                             new ActiveMQDestination[configuration.getStaticallyIncludedDestinations().size()]);
1:                 }
1:                 if (configuration.getDynamicallyIncludedDestinations() != null) {
1:                     dynamicallyIncludedDestinations = configuration.getDynamicallyIncludedDestinations().toArray(
1:                             new ActiveMQDestination[configuration.getDynamicallyIncludedDestinations().size()]);
1:                 }
1:             } catch (Throwable t) {
0:                 LOG.error("Error mapping remote configuration: " + props, t);
1:             }
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:             startRemoteBridge();
/////////////////////////////////////////////////////////////////////////
1:                         // separate in-bound channel for forwards so we don't
/////////////////////////////////////////////////////////////////////////
1:                     // Let the local broker know the remote broker's ID.
1:                     localBroker.oneway(remoteBrokerInfo);
1:                     // new peer broker (a consumer can work with remote broker also)
1:                     brokerService.getBroker().addBroker(null, remoteBrokerInfo);
1: 
0:                         if (LOG.isTraceEnabled()) {
0:                             LOG.trace(configuration.getBrokerName() + " register bridge (" + this + ") to " + remoteBrokerName);
1:                         }
/////////////////////////////////////////////////////////////////////////
0:                     LOG.trace(configuration.getBrokerName() + ", bridging messages for static destination: " + dest);
commit:f383ca1
/////////////////////////////////////////////////////////////////////////
0:                         if (message.isPersistent() || configuration.isAlwaysSyncSend()) {
0:                             remoteBroker.asyncRequest(message, new ResponseCallback() {
/////////////////////////////////////////////////////////////////////////
1:                             });
1:                         } else {
0:                             // If the message was originally sent using async send, we will
0:                             // preserve that QOS by bridging it using an async send (small chance
0:                             // of message loss).
1:                             try {
0:                                 remoteBroker.oneway(message);
1:                                 localBroker.oneway(new MessageAck(md, MessageAck.INDIVIDUAL_ACK_TYPE, 1));
0:                                 dequeueCounter.incrementAndGet();
1:                             } finally {
1:                                 sub.decrementOutstandingResponses();
1:                             }
commit:bf78756
/////////////////////////////////////////////////////////////////////////
1:             // ensure not available for conduit subs pending removal
1:             subscriptionMapByLocalId.remove(sub.getLocalInfo().getConsumerId());
1:             subscriptionMapByRemoteId.remove(sub.getRemoteInfo().getConsumerId());
1: 
/////////////////////////////////////////////////////////////////////////
commit:8012f28
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.advisory.AdvisoryBroker;
1: import org.apache.activemq.DestinationDoesNotExistException;
1: import org.apache.activemq.broker.ConnectionContext;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.security.SecurityContext;
0: import org.apache.activemq.transport.TransportFactory;
/////////////////////////////////////////////////////////////////////////
1:     private Transport duplexInboundLocalBroker = null;
1:     private ProducerInfo duplexInboundLocalProducerInfo;
/////////////////////////////////////////////////////////////////////////
1:             if (isDuplex()) {
0:                 duplexInboundLocalBroker = NetworkBridgeFactory.createLocalTransport(brokerService.getBroker());
1:                 duplexInboundLocalBroker.setTransportListener(new DefaultTransportListener() {
1: 
1:                     @Override
1:                     public void onCommand(Object o) {
1:                         Command command = (Command) o;
1:                         serviceLocalCommand(command);
1:                     }
1: 
1:                     @Override
1:                     public void onException(IOException error) {
1:                         serviceLocalException(error);
1:                     }
1:                 });
1:                 duplexInboundLocalBroker.start();
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:                     if (configuration.isDuplex()) {
0:                         // separate inbound chanel for forwards so we don't contend with outbound dispatch on same connection
1:                         ConnectionInfo duplexLocalConnectionInfo = new ConnectionInfo();
1:                         duplexLocalConnectionInfo.setConnectionId(new ConnectionId(idGenerator.generateId()));
0:                         duplexLocalConnectionInfo.setClientId(configuration.getName() + "_" + remoteBrokerName + "_inbound_duplex_" + configuration.getBrokerName());
1:                         duplexLocalConnectionInfo.setUserName(configuration.getUserName());
1:                         duplexLocalConnectionInfo.setPassword(configuration.getPassword());
1: 
0:                         if (originalTransport instanceof SslTransport) {
0:                             X509Certificate[] peerCerts = ((SslTransport) originalTransport).getPeerCertificates();
1:                             duplexLocalConnectionInfo.setTransportContext(peerCerts);
1:                         }
1:                         // sync requests that may fail
1:                         resp = duplexInboundLocalBroker.request(duplexLocalConnectionInfo);
1:                         if (resp instanceof ExceptionResponse) {
0:                             throw ((ExceptionResponse)resp).getException();
1:                         }
1:                         SessionInfo duplexInboundSession = new SessionInfo(duplexLocalConnectionInfo, 1);
1:                         duplexInboundLocalProducerInfo = new ProducerInfo(duplexInboundSession, 1);
1:                         duplexInboundLocalBroker.oneway(duplexInboundSession);
1:                         duplexInboundLocalBroker.oneway(duplexInboundLocalProducerInfo);
1:                     }
/////////////////////////////////////////////////////////////////////////
1:                     ss.stop(duplexInboundLocalBroker);
/////////////////////////////////////////////////////////////////////////
0:                         if (LOG.isTraceEnabled()) {
0:                             LOG.trace(configuration.getBrokerName() + " duplex command type: "+ command.getCommandId());
1:                         }
1:                             final ActiveMQMessage message = (ActiveMQMessage) command;
/////////////////////////////////////////////////////////////////////////
0:                                 // message being forwarded - we need to propagate the response to our local send
0:                                 message.setProducerId(duplexInboundLocalProducerInfo.getProducerId());
0:                                 if (message.isResponseRequired() || configuration.isAlwaysSyncSend()) {
0:                                     duplexInboundLocalBroker.asyncRequest(message, new ResponseCallback() {
0:                                         final int correlationId = message.getCommandId();
1:                                         @Override
0:                                         public void onCompletion(FutureResponse resp) {
1:                                             try {
0:                                                 Response reply = resp.getResult();
0:                                                 reply.setCorrelationId(correlationId);
0:                                                 remoteBroker.oneway(reply);
0:                                             } catch (IOException error) {
0:                                                 LOG.error("Exception: " + error + " on duplex forward of: " + message);
1:                                                 serviceRemoteException(error);
1:                                             }
1:                                         }
1:                                     });
0:                                     duplexInboundLocalBroker.oneway(message);
1:                                 case ConnectionInfo.DATA_STRUCTURE_TYPE:
1:                                 case SessionInfo.DATA_STRUCTURE_TYPE:
1:                                     localBroker.oneway(command);
1:                                     break;
1:                                 case ProducerInfo.DATA_STRUCTURE_TYPE:
1:                                     // using duplexInboundLocalProducerInfo
1:                                     break;
1:                                 case MessageAck.DATA_STRUCTURE_TYPE:
1:                                     MessageAck ack = (MessageAck) command;
1:                                     DemandSubscription localSub = subscriptionMapByRemoteId.get(ack.getConsumerId());
1:                                     if (localSub != null) {
1:                                         ack.setConsumerId(localSub.getLocalInfo().getConsumerId());
1:                                         localBroker.oneway(ack);
1:                                     } else {
0:                                         LOG.warn("Matching local subscription not found for ack: " + ack);
1:                                     }
1:                                     break;
1:                                 case ConsumerInfo.DATA_STRUCTURE_TYPE:
1:                                     localStartedLatch.await();
0:                                     if (started.get()) {
0:                                         if (!addConsumerInfo((ConsumerInfo) command)) {
0:                                             if (LOG.isDebugEnabled()) {
0:                                                 LOG.debug("Ignoring ConsumerInfo: " + command);
1:                                             }
1:                                         } else {
0:                                             if (LOG.isTraceEnabled()) {
0:                                                 LOG.trace("Adding ConsumerInfo: " + command);
1:                                             }
1:                                         // received a subscription whilst stopping
0:                                         LOG.warn("Stopping - ignoring ConsumerInfo: " + command);
1:                                     break;
1:                                 case ShutdownInfo.DATA_STRUCTURE_TYPE:
1:                                     // initiator is shutting down, controlled case
1:                                     // abortive close dealt with by inactivity monitor
1:                                     LOG.info("Stopping network bridge on shutdown of remote broker");
1:                                     serviceRemoteException(new IOException(command.toString()));
1:                                     break;
1:                                 default:
0:                                     if (LOG.isDebugEnabled()) {
0:                                         LOG.debug("Ignoring remote command: " + command);
1:                                     }
1:                             case KeepAliveInfo.DATA_STRUCTURE_TYPE:
1:                             case WireFormatInfo.DATA_STRUCTURE_TYPE:
1:                             case ShutdownInfo.DATA_STRUCTURE_TYPE:
1:                                 break;
1:                             default:
0:                                 LOG.warn("Unexpected remote command: " + command);
/////////////////////////////////////////////////////////////////////////
1:         serviceLocalException(null, error);
1:     }
1: 
1:     public void serviceLocalException(MessageDispatch messageDispatch, Throwable error) {
1: 
0:             if (error instanceof DestinationDoesNotExistException && ((DestinationDoesNotExistException)error).isTemporary() ) {
0:                 // not a reason to terminate the bridge - temps can disappear with pending sends as the demand sub may outlive the remote dest
1:                 if (messageDispatch != null) {
0:                     LOG.warn("PoisonAck of " + messageDispatch.getMessage().getMessageId() + " on forwarding error: " +  error);
1:                     try {
1:                         MessageAck poisonAck = new MessageAck(messageDispatch, MessageAck.POSION_ACK_TYPE, 1);
1:                         poisonAck.setPoisonCause(error);
1:                         localBroker.oneway(poisonAck);
1:                     } catch (IOException ioe) {
0:                         LOG.error("Failed to posion ack message following forward failure: " + ioe, ioe);
1:                     }
1:                     fireFailedForwardAdvisory(messageDispatch, error);
1:                 } else {
0:                     LOG.warn("Ignoring exception on forwarding to non existent temp dest: " +  error, error);
1:                 }
1:                 return;
1:             }
/////////////////////////////////////////////////////////////////////////
1:     private void fireFailedForwardAdvisory(MessageDispatch messageDispatch, Throwable error) {
1:         if (configuration.isAdvisoryForFailedForward()) {
1:             AdvisoryBroker advisoryBroker = null;
1:             try {
1:                 advisoryBroker = (AdvisoryBroker) brokerService.getBroker().getAdaptor(AdvisoryBroker.class);
1: 
1:                 if (advisoryBroker != null) {
1:                     ConnectionContext context = new ConnectionContext();
1:                     context.setSecurityContext(SecurityContext.BROKER_SECURITY_CONTEXT);
1:                     context.setBroker(brokerService.getBroker());
1: 
1:                     ActiveMQMessage advisoryMessage = new ActiveMQMessage();
1:                     advisoryMessage.setStringProperty("cause", error.getLocalizedMessage());
0:                     advisoryBroker.fireAdvisory(context,
0:                             AdvisorySupport.getNetworkBridgeForwardFailureAdvisoryTopic(),
0:                             messageDispatch.getMessage(), null, advisoryMessage);
1: 
1:                 }
1:             } catch (Exception e) {
0:                 LOG.warn("failed to fire forward failure advisory, cause: " + e);
0:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug("detail", e);
1:                 }
1:             }
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isTraceEnabled()) {
0:                 LOG.trace(configuration.getBrokerName() + " remove local subscription:"
0:                         + sub.getLocalInfo().getConsumerId()
0:                         + " for remote " + sub.getRemoteInfo().getConsumerId());
/////////////////////////////////////////////////////////////////////////
1:                     } finally {
1:                         subscriptionMapByLocalId.remove(sub.getLocalInfo().getConsumerId());
1:                         subscriptionMapByRemoteId.remove(sub.getRemoteInfo().getConsumerId());
/////////////////////////////////////////////////////////////////////////
0:                                             serviceLocalException(md, er.getException());
0:                                         serviceLocalException(md, e);
/////////////////////////////////////////////////////////////////////////
1:         info.setNetworkSubscription(true);
commit:27440ae
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.Executor;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
/////////////////////////////////////////////////////////////////////////
0:     private ExecutorService serialExecutor = Executors.newSingleThreadExecutor();
/////////////////////////////////////////////////////////////////////////
1:                                 serialExecutor.shutdown();
1:                                 if (!serialExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
1:                                     List<Runnable> pendingTasks = serialExecutor.shutdownNow();
0:                                     LOG.info("pending tasks on stop" + pendingTasks);
1:                                 }
/////////////////////////////////////////////////////////////////////////
1:             final DestinationInfo destInfo = (DestinationInfo) data;
/////////////////////////////////////////////////////////////////////////
1:             if (destInfo.isRemoveOperation()) {
0:                 // serialise with removeSub operations such that all removeSub advisories are generated
1:                 serialExecutor.execute(new Runnable() {
1:                     public void run() {
1:                         try {
1:                             localBroker.oneway(destInfo);
1:                         } catch (IOException e) {
0:                             LOG.warn("failed to deliver remove command for destination:" + destInfo.getDestination(), e);
1:                         }
1:                     }
1:                 });
1:             } else {
1:                 localBroker.oneway(destInfo);
1:             }
/////////////////////////////////////////////////////////////////////////
0:             // serialise with removeDestination operations so that removeSubs are serialised with removeDestinations
0:             // such that all removeSub advisories are generated
1:             serialExecutor.execute(new Runnable() {
commit:5c61d97
/////////////////////////////////////////////////////////////////////////
0:                     // always dispatch advisories async so that we never block the producer broker if we are slow
1:                     demandConsumerInfo.setDispatchAsync(true);
commit:3fa9275
/////////////////////////////////////////////////////////////////////////
1:                     safeWaitUntilStarted();
/////////////////////////////////////////////////////////////////////////
1:                     safeWaitUntilStarted();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     safeWaitUntilStarted();
commit:90fcbc8
/////////////////////////////////////////////////////////////////////////
1:     protected final NetworkBridgeFilterFactory defaultFilterFactory = new DefaultNetworkBridgeFilterFactory();
/////////////////////////////////////////////////////////////////////////
1:         NetworkBridgeFilterFactory filterFactory = defaultFilterFactory;
1:         if (brokerService != null && brokerService.getDestinationPolicy() != null) {
1:             PolicyEntry entry = brokerService.getDestinationPolicy().getEntryFor(info.getDestination());
1:             if (entry != null && entry.getNetworkBridgeFilterFactory() != null) {
1:                 filterFactory = entry.getNetworkBridgeFilterFactory();
0:         return filterFactory.create(info, getRemoteBrokerPath(), configuration.getNetworkTTL());
commit:2a87ad5
/////////////////////////////////////////////////////////////////////////
0:             subscriptionMapByRemoteId.remove(sub.getRemoteInfo().getConsumerId());
commit:179d95e
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.JMSException;
/////////////////////////////////////////////////////////////////////////
1:                     ackAdvisory(md.getMessage());
/////////////////////////////////////////////////////////////////////////
1:                                 ackAdvisory(message);
/////////////////////////////////////////////////////////////////////////
0:                             case MessageAck.DATA_STRUCTURE_TYPE:
0:                                 MessageAck ack = (MessageAck) command;
0:                                 DemandSubscription localSub = subscriptionMapByRemoteId.get(ack.getConsumerId());
0:                                 if (localSub != null) {
0:                                     ack.setConsumerId(localSub.getLocalInfo().getConsumerId());
0:                                     localBroker.oneway(ack);
1:                                 } else {
0:                                     LOG.warn("Matching local subscription not found for ack: " + ack);
1:                                 }
1:                                 break;
/////////////////////////////////////////////////////////////////////////
1:     private void ackAdvisory(Message message) throws IOException {
1:         demandConsumerDispatched++;
0:         if (demandConsumerDispatched > (demandConsumerInfo.getPrefetchSize() * .75)) {
0:             MessageAck ack = new MessageAck(message, MessageAck.STANDARD_ACK_TYPE, demandConsumerDispatched);
1:             ack.setConsumerId(demandConsumerInfo.getConsumerId());
0:             remoteBroker.oneway(ack);
1:             demandConsumerDispatched = 0;
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:                         LOG.debug(configuration.getBrokerName() + " bridged sub on " + localBroker + " from " + remoteBrokerName + " : " + info);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.trace(configuration.getBrokerName() + " bridging " + (destInfo.isAddOperation() ? "add" : "remove") + " destination on " + localBroker + " from " + remoteBrokerName + ", destination: " + destInfo);
commit:8d0cf31
/////////////////////////////////////////////////////////////////////////
0:     public ConcurrentHashMap<ConsumerId, DemandSubscription> getLocalSubscriptionMap() {
1:         return subscriptionMapByRemoteId;
1:     }
1: 
commit:d4ccc50
/////////////////////////////////////////////////////////////////////////
0:                 LOG.trace(configuration.getBrokerName() +" bridging destination control command: " + destInfo);
commit:49718ed
/////////////////////////////////////////////////////////////////////////
0:                             LOG.debug("bridging (" + configuration.getBrokerName() + " -> " + remoteBrokerName + ") " + (LOG.isTraceEnabled() ? message : message.getMessageId()) + ", consumer: " + md.getConsumerId() + ", destination " + message.getDestination() + ", brokerPath: " + Arrays.toString(message.getBrokerPath()) + ", message: " + message);
commit:5b796cd
/////////////////////////////////////////////////////////////////////////
1:             byte priority = (byte) configuration.getConsumerPriorityBase();
/////////////////////////////////////////////////////////////////////////
commit:6d077dc
/////////////////////////////////////////////////////////////////////////
0:                         if (!configuration.isAlwaysSyncSend() && !message.isPersistent()) {
commit:174c405
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     protected final BrokerId remoteBrokerPath[] = new BrokerId[] {null};
0:     protected Object brokerInfoMutex = new Object();
1:     protected BrokerId remoteBrokerId;
1: 
/////////////////////////////////////////////////////////////////////////
1:     private void startLocalBridge() throws Throwable {
/////////////////////////////////////////////////////////////////////////
0:                 LOG.trace(configuration.getBrokerName() + " starting remote Bridge, remoteBroker=" + remoteBroker);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     protected void serviceLocalBrokerInfo(Command command) throws InterruptedException {
0:         synchronized (brokerInfoMutex) {
0:             if (remoteBrokerId != null) {
0:                 if (remoteBrokerId.equals(localBrokerId)) {
0:                     if (LOG.isTraceEnabled()) {
0:                         LOG.trace(configuration.getBrokerName() + " disconnecting local loop back connection for: " + remoteBrokerName + ", with id:" + remoteBrokerId);
1:                     }
0:                     waitStarted();
0:                     ServiceSupport.dispose(this);
1:                 }
1:             }
1:         }
1:     }
1:     protected void addRemoteBrokerToBrokerPath(ConsumerInfo info) throws IOException {
1:         info.setBrokerPath(appendToBrokerPath(info.getBrokerPath(), getRemoteBrokerPath()));
1:     }
0:     protected void serviceRemoteBrokerInfo(Command command) throws IOException {
0:         synchronized (brokerInfoMutex) {
0:             BrokerInfo remoteBrokerInfo = (BrokerInfo)command;
0:             remoteBrokerId = remoteBrokerInfo.getBrokerId();
1:             remoteBrokerPath[0] = remoteBrokerId;
1:             remoteBrokerName = remoteBrokerInfo.getBrokerName();
0:             if (localBrokerId != null) {
1:                 if (localBrokerId.equals(remoteBrokerId)) {
0:                     if (LOG.isTraceEnabled()) {
0:                         LOG.trace(configuration.getBrokerName() + " disconnecting remote loop back connection for: " + remoteBrokerName + ", with id:" + remoteBrokerId);
1:                     }
0:                     ServiceSupport.dispose(this);
1:                 }
1:             }
1:             if (!disposed.get()) {
0:                 triggerLocalStartBridge();
1:             }
1:         }
1:     }
0:     protected  BrokerId[] getRemoteBrokerPath() {
1:         return remoteBrokerPath;
1:     }
/////////////////////////////////////////////////////////////////////////
1:         this.localBrokerId = brokerService.getRegionBroker().getBrokerId();
1:         localBrokerPath[0] = localBrokerId;
commit:4acd132
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             remoteBroker.setTransportListener(new DefaultTransportListener() {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 Thread.currentThread().setName("StartRemoteBridge: remoteBroker=" + remoteBroker);
/////////////////////////////////////////////////////////////////////////
1:                     stop();
commit:f793fbd
/////////////////////////////////////////////////////////////////////////
1: import javax.management.ObjectName;
/////////////////////////////////////////////////////////////////////////
1:     private ObjectName mbeanObjectName;
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void setMbeanObjectName(ObjectName objectName) {
1:         this.mbeanObjectName = objectName;
1:     }
1: 
1:     public ObjectName getMbeanObjectName() {
1:         return mbeanObjectName;
1:     }
commit:a6b85cc
/////////////////////////////////////////////////////////////////////////
1:                     if (isInActiveDurableSub(sub)) {
1:                         suppress = false;
1:                     } else {
1:                         suppress = hasLowerPriority(sub, candidate.getLocalInfo());
1:                     }
/////////////////////////////////////////////////////////////////////////
1:     private boolean isInActiveDurableSub(Subscription sub) {
0:         return  (sub.getConsumerInfo().isDurable() && sub instanceof DurableTopicSubscription && !((DurableTopicSubscription)sub).isActive());
/////////////////////////////////////////////////////////////////////////
0:                         + existingSub  + ", networkConsumerIds: " + existingSub.getConsumerInfo().getNetworkConsumerIds());
commit:f232cec
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.DurableTopicSubscription;
0: import org.apache.activemq.broker.region.TopicSubscription;
/////////////////////////////////////////////////////////////////////////
0:                     suppress = isActiveDurableSub(sub) && hasLowerPriority(sub, candidate.getLocalInfo());
/////////////////////////////////////////////////////////////////////////
0:     private boolean isActiveDurableSub(Subscription sub) {
0:         return  (sub.getConsumerInfo().isDurable() && sub instanceof DurableTopicSubscription && ((DurableTopicSubscription)sub).isActive());
1:     }
1: 
commit:af1b232
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     protected NetworkBridgeFilterFactory filterFactory;
/////////////////////////////////////////////////////////////////////////
0:                             LOG.debug("bridging (" + configuration.getBrokerName() + " -> " + remoteBrokerName + ") " + message.getMessageId() + ", consumer: " + md.getConsumerId() + ", destination " + message.getDestination() + ", brokerPath: " + Arrays.toString(message.getBrokerPath()) + ", message: " + message);
/////////////////////////////////////////////////////////////////////////
0:         // for durable subs, suppression via filter leaves dangling acks so we need to
1:         if (sub.getLocalInfo().isDurable()) {
1:             messageEvalContext.setDestination(md.getDestination());
1:             suppress = !sub.getNetworkBridgeFilter().matches(messageEvalContext);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         sub.setNetworkBridgeFilter(createNetworkBridgeFilter(info));
1:             sub.getLocalInfo().setAdditionalPredicate(sub.getNetworkBridgeFilter());
/////////////////////////////////////////////////////////////////////////
1:     protected NetworkBridgeFilter createNetworkBridgeFilter(ConsumerInfo info) throws IOException {
0:         if (filterFactory == null)  {
0:             if (brokerService != null && brokerService.getDestinationPolicy() != null) {
0:                 PolicyEntry entry = brokerService.getDestinationPolicy().getEntryFor(info.getDestination());
0:                 if (entry != null) {
0:                     filterFactory = entry.getNetworkBridgeFilterFactory();
1:                 }
1:             }
0:             if (filterFactory == null) {
0:                 filterFactory = new DefaultNetworkBridgeFilterFactory();
1:             }
1:         }
0:          return filterFactory.create(info, getRemoteBrokerPath(), configuration.getNetworkTTL() );
1:     }
commit:8a2892b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3973d8f
/////////////////////////////////////////////////////////////////////////
1:     public ActiveMQDestination[] getStaticallyIncludedDestinations() {
commit:27d0ff4
/////////////////////////////////////////////////////////////////////////
1:                         } catch (Throwable e) {
1:                             serviceLocalException(e);
/////////////////////////////////////////////////////////////////////////
1:                 } catch (Throwable e) {
/////////////////////////////////////////////////////////////////////////
0:     protected void startLocalBridge() throws Throwable {
/////////////////////////////////////////////////////////////////////////
0:                     localClientId = configuration.getName() + "_" + remoteBrokerName + "_inbound_" + configuration.getBrokerName();
/////////////////////////////////////////////////////////////////////////
1:                     // sync requests that may fail
1:                     Object resp = localBroker.request(localConnectionInfo);
1:                     if (resp instanceof ExceptionResponse) {
0:                         throw ((ExceptionResponse)resp).getException();
1:                     }
1: 
/////////////////////////////////////////////////////////////////////////
0:                 remoteConnectionInfo.setClientId(configuration.getName() + "_" + configuration.getBrokerName() + "_outbound");
/////////////////////////////////////////////////////////////////////////
0:     public ActiveMQDestination[] getStaticallyIncludedestinations() {
commit:c752230
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     NetworkBridgeListener l = this.networkBridgeListener;
1:                     if (l != null) {
1:                         l.onStart(this);
1:                     }
/////////////////////////////////////////////////////////////////////////
0:             brokerService.getBroker().removeBroker(null, remoteBrokerInfo);
/////////////////////////////////////////////////////////////////////////
0:                     // new peer broker (a consumer can work with remote broker also)
0:                     brokerService.getBroker().addBroker(null, remoteBrokerInfo);
commit:6348481
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.thread.DefaultThreadPools;
0: import org.apache.activemq.thread.TaskRunnerFactory;
/////////////////////////////////////////////////////////////////////////
0:     private final TaskRunnerFactory asyncTaskRunner = DefaultThreadPools.getDefaultTaskRunnerFactory();
/////////////////////////////////////////////////////////////////////////
0:         asyncTaskRunner.execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
0:         asyncTaskRunner.execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
0:                     asyncTaskRunner.execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
0:             asyncTaskRunner.execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
0:             asyncTaskRunner.execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
0:             asyncTaskRunner.execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
commit:ee4c8ee
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(DemandForwardingBridgeSupport.class);
/////////////////////////////////////////////////////////////////////////
0:                             case ShutdownInfo.DATA_STRUCTURE_TYPE:
0:                                 // initiator is shutting down, controlled case
0:                                 // abortive close dealt with by inactivity monitor
0:                                 LOG.info("Stopping network bridge on shutdown of remote broker");
0:                                 serviceRemoteException(new IOException(command.toString()));
1:                                 break;
commit:6b4509c
/////////////////////////////////////////////////////////////////////////
1:             if (!disposed.get()) {
1:                 try {
0:                     triggerRemoteStartBridge();
1:                 } catch (IOException e) {
1:                     LOG.warn("Caught exception from remote start", e);
1:                 }
1:                 NetworkBridgeListener l = this.networkBridgeListener;
1:                 if (l != null) {
0:                     l.onStart(this);
1:                 }
1:     	    } else {
0:                 LOG.warn ("Bridge was disposed before the start() method was fully executed.");
1:                 throw new TransportDisposedIOException();
/////////////////////////////////////////////////////////////////////////
1:                 if (!disposed.get()) {
1:                     localConnectionInfo = new ConnectionInfo();
1:                     localConnectionInfo.setConnectionId(new ConnectionId(idGenerator.generateId()));
0:                     localClientId = "NC_" + remoteBrokerName + "_inbound_" + configuration.getBrokerName();
1:                     localConnectionInfo.setClientId(localClientId);
1:                     localConnectionInfo.setUserName(configuration.getUserName());
1:                     localConnectionInfo.setPassword(configuration.getPassword());
1:                     Transport originalTransport = remoteBroker;
1:                     while (originalTransport instanceof TransportFilter) {
1:                         originalTransport = ((TransportFilter) originalTransport).getNext();
1:                     }
0:                     if (originalTransport instanceof SslTransport) {
0:                         X509Certificate[] peerCerts = ((SslTransport) originalTransport).getPeerCertificates();
1:                         localConnectionInfo.setTransportContext(peerCerts);
1:                     }
0:                     localBroker.oneway(localConnectionInfo);
1: 
1:                     localSessionInfo = new SessionInfo(localConnectionInfo, 1);
1:                     localBroker.oneway(localSessionInfo);
1: 
0:                     LOG.info("Network connection between " + localBroker + " and " + remoteBroker + "(" + remoteBrokerName + ") has been established.");
1: 
1:                 } else {
0:                     LOG.warn ("Bridge was disposed before the startLocalBridge() method was fully executed.");
1:                 if (!disposed.get()) {
0:                     setupStaticDestinations();
1:                 } else {
0:                     LOG.warn("Network connection between " + localBroker + " and " + remoteBroker + "(" + remoteBrokerName + ") was interrupted during establishment.");
1:                 }
/////////////////////////////////////////////////////////////////////////
0:             remoteBrokerNameKnownLatch.countDown();
commit:ecf068e
/////////////////////////////////////////////////////////////////////////
0:         if (consumerInfo.getDestination().isQueue() && !configuration.isSuppressDuplicateQueueSubscriptions() ||
0:                 consumerInfo.getDestination().isTopic() && !configuration.isSuppressDuplicateTopicSubscriptions()) {
commit:591e55f
/////////////////////////////////////////////////////////////////////////
0:                             LOG.debug("bridging " + configuration.getBrokerName() + " -> " + remoteBrokerName + ", consumer: " + md.getConsumerId() + ", brokerPath: " + Arrays.toString(message.getBrokerPath()) + ", message: " + message);
commit:eb983f7
/////////////////////////////////////////////////////////////////////////
0: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
1:                         if (suppressMessageDispatch(md, sub)) {
0:                                 LOG.debug(configuration.getBrokerName() + " message not forwarded to " + remoteBrokerName + " because message came from there or fails networkTTL, brokerPath: " + Arrays.toString(md.getMessage().getBrokerPath()) + ", message: " + md.getMessage());
/////////////////////////////////////////////////////////////////////////
0:                             LOG.debug("bridging " + configuration.getBrokerName() + " -> " + remoteBrokerName + ", brokerPath: " + Arrays.toString(message.getBrokerPath()) + ", message: " + message);
/////////////////////////////////////////////////////////////////////////
1:     private boolean suppressMessageDispatch(MessageDispatch md, DemandSubscription sub) throws Exception {
1:         boolean suppress = false;
0:             suppress = contains(((ConsumerInfo) consumerInfo).getBrokerPath(), remoteBrokerInfo.getBrokerId());
0:         if (!suppress && sub.getLocalInfo().isDurable()) {
0:             suppress = !createNetworkBridgeFilter(null).matches(messageEvalContext);
1:         return suppress;
/////////////////////////////////////////////////////////////////////////
0:             // we check before we send. see: suppressMessageDispatch()
commit:05f82a9
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.filter.MessageEvaluationContext;
/////////////////////////////////////////////////////////////////////////
1:     protected static final String DURABLE_SUB_PREFIX = "NC-DS_";
/////////////////////////////////////////////////////////////////////////
1:                         
0:                         if (originallyCameFromRemote(md, sub)) {
0:                             if (LOG.isDebugEnabled()) {
0:                                 LOG.debug(configuration.getBrokerName() + " message not forwarded to " + remoteBrokerName + " because message came from there or fails networkTTL: " + md.getMessage());
1:                             }
1:                             // still ack as it may be durable
1:                             try {
0:                                 localBroker.oneway(new MessageAck(md, MessageAck.INDIVIDUAL_ACK_TYPE, 1));
1:                             } finally {
0:                                 sub.decrementOutstandingResponses();
1:                             }
1:                             return;
1:                         }
1:                         
1:                         
1:                             
0:                                 remoteBroker.oneway(message);
1:                             
1:                             
/////////////////////////////////////////////////////////////////////////
1:                                         }   
/////////////////////////////////////////////////////////////////////////
1:                             
1:                             
/////////////////////////////////////////////////////////////////////////
0:     private boolean originallyCameFromRemote(MessageDispatch md, DemandSubscription sub) throws Exception {
0:         // See if this consumer's brokerPath tells us it came from the broker at the other end
0:         // of the bridge. I think we should be making this decision based on the message's
0:         // broker bread crumbs and not the consumer's? However, the message's broker bread
0:         // crumbs are null, which is another matter.   
0:         boolean cameFromRemote = false;
0:         Object consumerInfo = md.getMessage().getDataStructure();
0:         if (consumerInfo != null && (consumerInfo instanceof ConsumerInfo)) {
0:             cameFromRemote = contains(((ConsumerInfo) consumerInfo).getBrokerPath(), remoteBrokerInfo.getBrokerId());
1:         }
1:         
0:         // for durable subs, suppression via filter leaves dangling acks so we need to 
0:         // check here and allow the ack irrespective
0:         if (!cameFromRemote && sub.getLocalInfo().isDurable()) {
0:             MessageEvaluationContext messageEvalContext = new MessageEvaluationContext();
1:             messageEvalContext.setMessageReference(md.getMessage());
0:             cameFromRemote = !createNetworkBridgeFilter(null).matches(messageEvalContext);
1:         }  
0:         return cameFromRemote;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (!info.isDurable()) {
1:             // This works for now since we use a VM connection to the local broker.
1:             // may need to change if we ever subscribe to a remote broker.
0:             sub.getLocalInfo().setAdditionalPredicate(createNetworkBridgeFilter(info));
0:         } else  {
0:             // need to ack this message if it is ignored as it is durable so
0:             // we check before we send. see: originallyCameFromRemote()
1:         }
commit:8e59e24
/////////////////////////////////////////////////////////////////////////
1:     protected void removeSubscription(final DemandSubscription sub) throws IOException {
1:             
0:             // continue removal in separate thread to free up this thread for outstanding responses
0:             ASYNC_TASKS.execute(new Runnable() {
1:                 public void run() {
1:                     sub.waitForCompletion();
1:                     try {
0:                         localBroker.oneway(sub.getLocalInfo().createRemoveCommand());
1:                     } catch (IOException e) {
0:                         LOG.warn("failed to deliver remove command for local subscription, for remote " + sub.getRemoteInfo().getConsumerId(), e);
1:                     }
1:                 }
1:             });
/////////////////////////////////////////////////////////////////////////
1:                     final DemandSubscription sub = subscriptionMapByLocalId.get(md.getConsumerId());
/////////////////////////////////////////////////////////////////////////
0:                             dequeueCounter.incrementAndGet();
1:                             
/////////////////////////////////////////////////////////////////////////
1:                                            
1:                                     } finally {
0:                                         sub.decrementOutstandingResponses();
0:                             sub.incrementOutstandingResponses();
1:                         
commit:b0e3570
/////////////////////////////////////////////////////////////////////////
0:                     if( !sendShutdown.await(10, TimeUnit.SECONDS) ) {
1:                         LOG.info("Network Could not shutdown in a timely manner");
commit:5d42b72
/////////////////////////////////////////////////////////////////////////
0:     protected AtomicBoolean disposed = new AtomicBoolean();
/////////////////////////////////////////////////////////////////////////
0:                 localClientId = "NC_" + remoteBrokerName + "_inbound_" + configuration.getBrokerName();
/////////////////////////////////////////////////////////////////////////
1:                 if (!disposed.get()) {
/////////////////////////////////////////////////////////////////////////
1:             if (disposed.compareAndSet(false, true)) {
0:                 LOG.debug(" stopping " + configuration.getBrokerName() + " bridge to " + remoteBrokerName);
1:                                 sendShutdown.countDown();
1:                             } finally {
0:                     if( !sendShutdown.await(5, TimeUnit.SECONDS) ) {
1:                     ss.stop(localBroker);
/////////////////////////////////////////////////////////////////////////
0:             LOG.info(configuration.getBrokerName() + " bridge to " + remoteBrokerName + " stopped");
1:         if (!disposed.get()) {
/////////////////////////////////////////////////////////////////////////
0:         if (!disposed.get()) {
/////////////////////////////////////////////////////////////////////////
0:         if (!disposed.get()) {
/////////////////////////////////////////////////////////////////////////
0:         if (!disposed.get()) {
commit:9670af1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             subscriptionMapByLocalId.remove(sub.getLocalInfo().getConsumerId());
/////////////////////////////////////////////////////////////////////////
0:         boolean consumerAdded = false;
0:             if (duplicateSuppressionIsRequired(sub) ) {
1:                 undoMapRegistration(sub);
1:             } else {
0:                 addSubscription(sub);
0:                 consumerAdded = true;
1:             }
0:         return consumerAdded;
1:     private void undoMapRegistration(DemandSubscription sub) {
0:         subscriptionMapByLocalId.remove(sub.getLocalInfo().getConsumerId());
0:         subscriptionMapByRemoteId.remove(sub.getRemoteInfo().getConsumerId());    
1:     }
1: 
1:     private boolean duplicateSuppressionIsRequired(DemandSubscription candidate) {
1:         final ConsumerInfo consumerInfo = candidate.getRemoteInfo();
1:         boolean suppress = false;
1:             return suppress;
1:         List<ConsumerId> candidateConsumers = consumerInfo.getNetworkConsumerIds();        
0:                     suppress = hasLowerPriority(sub, candidate.getLocalInfo());
1:         return suppress;
1:     }
1: 
1:  
1:     private boolean hasLowerPriority(Subscription existingSub, ConsumerInfo candidateInfo) {
1:         boolean suppress = false;
1:         
1:         if (existingSub.getConsumerInfo().getPriority() >= candidateInfo.getPriority()) {
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug(configuration.getBrokerName() + " Ignoring duplicate subscription from " + remoteBrokerName
0:                         + ", sub: " + candidateInfo + " is duplicated by network subscription with equal or higher network priority: " 
0:                         + existingSub.getConsumerInfo()  + ", networkComsumerIds: " + existingSub.getConsumerInfo().getNetworkConsumerIds());
1:             }
1:             suppress = true;
1:         } else {
1:             // remove the existing lower priority duplicate and allow this candidate
1:             try {
1:                 removeDuplicateSubscription(existingSub);
1:                 
0:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug(configuration.getBrokerName() + " Replacing duplicate subscription " + existingSub.getConsumerInfo()
0:                             + " with sub from " + remoteBrokerName
0:                             + ", which has a higher priority, new sub: " + candidateInfo + ", networkComsumerIds: " 
0:                             + candidateInfo.getNetworkConsumerIds());
1:                 }
1:             } catch (IOException e) {
0:                 LOG.error("Failed to remove duplicated sub as a result of sub with higher priority, sub: "+ existingSub, e);
1:             }
1:         }
1:         return suppress;
1:     }
1: 
1:     private void removeDuplicateSubscription(Subscription existingSub) throws IOException {
0:         for (NetworkConnector connector: brokerService.getNetworkConnectors()) {
1:             if (connector.removeDemandSubscription(existingSub.getConsumerInfo().getConsumerId())) {
1:                 break;
1:             }
1:         }     
/////////////////////////////////////////////////////////////////////////
1:             if (info.getBrokerPath() != null && info.getBrokerPath().length > 1) {
1:                 // The longer the path to the consumer, the less it's consumer priority.
1:                 priority -= info.getBrokerPath().length + 1; 
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug(configuration.getBrokerName() + " using priority :" + priority + " for subscription: " + info);
1:             }
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:     
1:     protected boolean removeDemandSubscriptionByLocalId(ConsumerId consumerId) {
1:         boolean removeDone = false;
1:         DemandSubscription sub = subscriptionMapByLocalId.get(consumerId);
1:         if (sub != null) {
1:             try {
1:                 removeDemandSubscription(sub.getRemoteInfo().getConsumerId());
1:                 removeDone = true;   
1:             } catch (IOException e) {
0:                 LOG.debug("removeDemandSubscriptionByLocalId failed for localId: " + consumerId, e);
1:             }     
1:         }
1:         return removeDone;
1:     }
commit:0c89959
/////////////////////////////////////////////////////////////////////////
0:                     // trace in method
/////////////////////////////////////////////////////////////////////////
0:                         LOG.debug(configuration.getBrokerName() + " Ignoring duplicate subscription from " + remoteBrokerName
0:                                 + ", sub: " + consumerInfo + " is duplicated by network subscription: " 
commit:3da1373
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug(configuration.getBrokerName() + " remove local subscription for remote " + sub.getRemoteInfo().getConsumerId());
1:             }
commit:966658f
/////////////////////////////////////////////////////////////////////////
0:     protected CountDownLatch localBrokerIdKnownLatch = new CountDownLatch(1);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     final MessageDispatch md = (MessageDispatch)command;   
0:                         // See if this consumer's brokerPath tells us it came from the broker at the other end
0:                         // of the bridge. I think we should be making this decision based on the message's
0:                         // broker bread crumbs and not the consumer's? However, the message's broker bread
0:                         // crumbs are null, which is another matter.   
0:                         boolean cameFromRemote = false;
/////////////////////////////////////////////////////////////////////////
1:                         
/////////////////////////////////////////////////////////////////////////
1:                             } else {
0:                                 if (LOG.isDebugEnabled()) {
0:                                     LOG.debug("Message not forwarded on to remote, because message came from remote");                               
1:                                 }
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isDebugEnabled()) {
0:             LOG.debug(configuration.getBrokerName() + " remove request on " + localBroker + " from " + remoteBrokerName + " , consumer id: " + id + ", matching sub: " + sub);
1:         }
0:                 LOG.debug(configuration.getBrokerName() + " removed sub on " + localBroker + " from " + remoteBrokerName + " :  " + sub.getRemoteInfo());
0:         localBrokerIdKnownLatch.await();
commit:5b8a886
/////////////////////////////////////////////////////////////////////////
0:                 if (LOG.isTraceEnabled()) {
0:                     LOG.trace(configuration.getBrokerName() + " starting local Bridge, localBroker=" + localBroker);
1:                 }
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isTraceEnabled()) {
0:                 LOG.trace(configuration.getBrokerName() + " starting remote Bridge, localBroker=" + localBroker);
1:             }
/////////////////////////////////////////////////////////////////////////
0:                         LOG.debug(configuration.getBrokerName() + " bridging sub on " + localBroker + " from " + remoteBrokerName + " : " + info);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.debug(configuration.getBrokerName() + " Ignoring destination " + destInfo + " restricted to " + networkTTL + " network hops only");
/////////////////////////////////////////////////////////////////////////
0:                     LOG.debug(configuration.getBrokerName() + " Ignoring destination " + destInfo + " already routed through this broker once");
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isTraceEnabled()) {
0:                 LOG.trace("bridging destination control command: " + destInfo);
1:             }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                         if (LOG.isDebugEnabled()) {
0:                             LOG.debug("bridging " + configuration.getBrokerName() + " -> " + remoteBrokerName + ": " + message);
/////////////////////////////////////////////////////////////////////////
0:                         if (LOG.isDebugEnabled()) {
0:                             LOG.debug("No subscription registered with this network bridge for consumerId " + md.getConsumerId() + " for message: " + md.getMessage());
/////////////////////////////////////////////////////////////////////////
0:                     LOG.trace("bridging messages for static destination: " + dest);
/////////////////////////////////////////////////////////////////////////
0:                         LOG.debug(configuration.getBrokerName() + " subscription: " + consumerInfo + " is duplicated by network subscription: " 
/////////////////////////////////////////////////////////////////////////
0:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug(configuration.getBrokerName() + " using priority :" + priority + " for subscription: " + info);
1:                 }
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug(configuration.getBrokerName() + " removing sub on " + localBroker + " from " + remoteBrokerName + " :  " + sub.getRemoteInfo());
commit:5511217
/////////////////////////////////////////////////////////////////////////
0:      * A match means a duplicate which we suppress for topics and maybe for queues
1:         
0:         if (consumerInfo.getDestination().isQueue() && !configuration.isSuppressDuplicateQueueSubscriptions()) {
0:             return isDuplicate;
1:         }
1:         
0:         List<ConsumerId> candidateConsumers = consumerInfo.getNetworkConsumerIds();
0:         if (candidateConsumers.isEmpty()) {
0:             candidateConsumers.add(consumerInfo.getConsumerId());
1:         }
1:         
0:         Collection<Subscription> currentSubs = 
0:             getRegionSubscriptions(consumerInfo.getDestination().isTopic());
1:         for (Subscription sub : currentSubs) {
0:             List<ConsumerId> networkConsumers =  sub.getConsumerInfo().getNetworkConsumerIds();
1:             if (!networkConsumers.isEmpty()) {
1:                 if (matchFound(candidateConsumers, networkConsumers)) {
0:                     if (LOG.isDebugEnabled()) {
0:                         LOG.debug("subscription: " + consumerInfo + " is duplicated by network subscription: " 
0:                                 + sub.getConsumerInfo()  + ", networkComsumerIds: " + networkConsumers);
0:                     isDuplicate = true;
1:                     break;
/////////////////////////////////////////////////////////////////////////
0:     private final Collection<Subscription> getRegionSubscriptions(boolean isTopic) {
0:         AbstractRegion abstractRegion = (AbstractRegion) 
0:             (isTopic ? region.getTopicRegion() : region.getQueueRegion());
0:         return abstractRegion.getSubscriptions().values();
1:     
commit:21cd3e6
/////////////////////////////////////////////////////////////////////////
0:                     LOG.debug("Ignoring destination " + destInfo + " restricted to " + networkTTL + " network hops only");
/////////////////////////////////////////////////////////////////////////
0:                     LOG.debug("Ignoring destination " + destInfo + " already routed through this broker once");
commit:9f8777d
/////////////////////////////////////////////////////////////////////////
0:             synchronized(brokerService.getVmConnectorURI()) {
commit:301203e
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collection;
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.BrokerServiceAware;
1: import org.apache.activemq.broker.region.AbstractRegion;
1: import org.apache.activemq.broker.region.RegionBroker;
1: import org.apache.activemq.broker.region.Subscription;
/////////////////////////////////////////////////////////////////////////
1: public abstract class DemandForwardingBridgeSupport implements NetworkBridge, BrokerServiceAware {
/////////////////////////////////////////////////////////////////////////
0:     private BrokerService brokerService = null;
/////////////////////////////////////////////////////////////////////////
1:             
1:             if (contains(path, localBrokerPath[0])) {
1:                 // Ignore this consumer as it's a consumer we locally sent to the broker.
1:             }            
/////////////////////////////////////////////////////////////////////////
1:             
1:             // in a cyclic network there can be multiple bridges per broker that can propagate
0:             // a network subscription so there is a need to synchronise on a shared entity
0:             synchronized(brokerService) {
0:                 if (isDuplicateNetworkSubscription(info)) {
0:                     if (LOG.isDebugEnabled()) {
0:                         LOG.debug(configuration.getBrokerName() + " Ignoring sub from " + remoteBrokerName + ", destination " + info.getDestination() 
0:                                 + ", for " + info.getConsumerId() + " as a duplicate. Already subscribed via network subscription :"  + info);
1:                     }
1:                     return;
0:                 if (addConsumerInfo(info)) {
0:                     if (LOG.isDebugEnabled()) {
0:                         LOG.debug(configuration.getBrokerName() + " Forwarding sub on " + localBroker + " from " + remoteBrokerName + " : " + info);
1:                     }
1:                 } else {
0:                     if (LOG.isDebugEnabled()) {
0:                         LOG.debug(configuration.getBrokerName() + " Ignoring sub from " + remoteBrokerName + " as already subscribed to matching destination : " + info);
1:                     }
/////////////////////////////////////////////////////////////////////////
1:      * Subscriptions for these destinations are always created
/////////////////////////////////////////////////////////////////////////
1:     /*
0:      * check our existing subs networkConsumerIds against the list of network ids in this subscription
0:      * a match means a duplicate which we suppress for topics
1:      */
0:     private boolean isDuplicateNetworkSubscription(ConsumerInfo consumerInfo) {
0:         boolean isDuplicate = false;
0:         if (consumerInfo.getDestination().isTopic()) {
0:             List<ConsumerId> candidateConsumers = consumerInfo.getNetworkConsumerIds();
0:             if (candidateConsumers.isEmpty()) {
0:                 candidateConsumers.add(consumerInfo.getConsumerId());
1:             }
0:             Collection<Subscription> currentSubs = getTopicRegionSubscriptions();
0:             for (Subscription sub : currentSubs) {
0:                 List<ConsumerId> networkConsumers =  sub.getConsumerInfo().getNetworkConsumerIds();
0:                 if (!networkConsumers.isEmpty()) {
0:                     if (matchFound(candidateConsumers, networkConsumers)) {
0:                         if (LOG.isDebugEnabled()) {
0:                             LOG.debug("subscription: " + consumerInfo + " is duplicated by network subscription: " 
0:                                     + sub.getConsumerInfo()  + ", networkComsumerIds: " + networkConsumers);
1:                         }
0:                         isDuplicate = true;
1:                         break;
1:                     }
1:                 }
1:             }
1:         }
0:         return isDuplicate;
1:     }
1: 
1:     private boolean matchFound(List<ConsumerId> candidateConsumers, List<ConsumerId> networkConsumers) {
1:         boolean found = false;
1:         for (ConsumerId aliasConsumer : networkConsumers) {        
1:             if (candidateConsumers.contains(aliasConsumer)) {
1:                 found = true;
1:                 break;
1:             }
1:         }
1:         return found;
1:     }
1: 
0:     private final Collection<Subscription> getTopicRegionSubscriptions() {
0:         RegionBroker region = (RegionBroker) brokerService.getRegionBroker();
0:         AbstractRegion topicRegion = (AbstractRegion) region.getTopicRegion();
0:         return topicRegion.getSubscriptions().values();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void setBrokerService(BrokerService brokerService) {
1:         this.brokerService = brokerService;
1:     }
1:     
commit:6d1f57b
/////////////////////////////////////////////////////////////////////////
0:                     LOG.debug(configuration.getBrokerName() + " Ignoring sub  from " + remoteBrokerName + ", restricted to " + networkTTL + " network hops only : " + info);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.debug(configuration.getBrokerName() + " Ignoring sub from " + remoteBrokerName + ", already routed through this broker once : " + info);
1:                 // ignore if not in the permitted or in the excluded list
0:                     LOG.debug(configuration.getBrokerName() + " Ignoring sub from " + remoteBrokerName + ", destination " + info.getDestination() + " is not permiited :" + info);
0:                     LOG.debug(configuration.getBrokerName() + " Forwarding sub on " + localBroker + " from " + remoteBrokerName + " : " + info);
0:                     LOG.debug(configuration.getBrokerName() + " Ignoring sub from " + remoteBrokerName + " as already subscribed to matching destination : " + info);
commit:8b34eac
/////////////////////////////////////////////////////////////////////////
0:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug("Exception processing remote command: " + command, e);
1:                 }
commit:fdee6e8
/////////////////////////////////////////////////////////////////////////
0:                             localBroker.oneway(new MessageAck(md, MessageAck.INDIVIDUAL_ACK_TYPE, 1));
/////////////////////////////////////////////////////////////////////////
0:                                             localBroker.oneway(new MessageAck(md, MessageAck.INDIVIDUAL_ACK_TYPE, 1));
commit:543bc84
/////////////////////////////////////////////////////////////////////////
0:             if (configuration.isDuplex() && duplexInitiatingConnection == null) {
0:                 // initiator side of duplex network
0:                 remoteBrokerNameKnownLatch.await();
1:             }
/////////////////////////////////////////////////////////////////////////
1:                 final String originalName = Thread.currentThread().getName();
0:                 Thread.currentThread().setName("StartLocalBridge: localBroker=" + localBroker);
0:                 } finally {
1:                     Thread.currentThread().setName(originalName);
/////////////////////////////////////////////////////////////////////////
0:                 final String originalName = Thread.currentThread().getName();
0:                 Thread.currentThread().setName("StartRemotelBridge: localBroker=" + localBroker);
0:                 } finally {
0:                     Thread.currentThread().setName(originalName);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.debug("starting local Bridge, localBroker=" + localBroker);
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("starting remote Bridge, localBroker=" + localBroker);
/////////////////////////////////////////////////////////////////////////
0:                 Thread thread = new Thread(runnable, "NetworkBridge");
commit:8761189
/////////////////////////////////////////////////////////////////////////
0:                                 if (message.isResponseRequired()) {
0:                                     Response reply = new Response();
0:                                     reply.setCorrelationId(message.getCommandId());
0:                                     localBroker.oneway(message);
0:                                     remoteBroker.oneway(reply);
1:                                 } else {
0:                                     localBroker.oneway(message);
1:                                 }
/////////////////////////////////////////////////////////////////////////
1:                                     } else {
0:                                         if (LOG.isTraceEnabled()) {
0:                                             LOG.trace("Adding ConsumerInfo: "+ command);
1:                                         }
/////////////////////////////////////////////////////////////////////////
0:                             LOG.trace("cameFromRemote = "+cameFromRemote + ", repsonseRequired = " + message.isResponseRequired());    
0:                         if (!message.isResponseRequired()) {
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:620523a
/////////////////////////////////////////////////////////////////////////
0: import java.util.*;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.*;
/////////////////////////////////////////////////////////////////////////
1:     protected BrokerService brokerService = null;
/////////////////////////////////////////////////////////////////////////
0:         } else if (data.getClass() == RemoveSubscriptionInfo.class) {
0:             RemoveSubscriptionInfo info = ((RemoveSubscriptionInfo) data);
0:             SubscriptionInfo subscriptionInfo = new SubscriptionInfo(info.getClientId(), info.getSubscriptionName());
0:             for (Iterator i = subscriptionMapByLocalId.values().iterator(); i.hasNext(); ) {
0:                 DemandSubscription ds = (DemandSubscription) i.next();
1:                 boolean removed = ds.getDurableRemoteSubs().remove(subscriptionInfo);
1:                 if (removed) {
0:                     if (ds.getDurableRemoteSubs().isEmpty()) {
1: 
0:                         // deactivate subscriber
0:                         RemoveInfo removeInfo = new RemoveInfo(ds.getLocalInfo().getConsumerId());
0:                         localBroker.oneway(removeInfo);
1: 
0:                         // remove subscriber
0:                         RemoveSubscriptionInfo sending = new RemoveSubscriptionInfo();
0:                         sending.setClientId(localClientId);
0:                         sending.setSubscriptionName(ds.getLocalDurableSubscriber().getSubscriptionName());
0:                         sending.setConnectionId(this.localConnectionInfo.getConnectionId());
0:                         localBroker.oneway(sending);
1:                     }
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
1:                 if (consumerInfo.isDurable()) {
0:                     sub.getDurableRemoteSubs().add(new SubscriptionInfo(sub.getRemoteInfo().getClientId(), consumerInfo.getSubscriptionName()));
1:                 }
/////////////////////////////////////////////////////////////////////////
1:     protected final Collection<Subscription> getRegionSubscriptions(ActiveMQDestination dest) {
/////////////////////////////////////////////////////////////////////////
1:             sub.setLocalDurableSubscriber(new SubscriptionInfo(info.getClientId(), info.getSubscriptionName()));
commit:f49675b
/////////////////////////////////////////////////////////////////////////
1:             }
0:             safeWaitUntilStarted();
0:             if (!disposed.get()) {
0:                 setupStaticDestinations();
1:             } else {
0:                 LOG.warn("Network connection between " + localBroker + " and " + remoteBroker + "(" + remoteBrokerName + ") was interrupted during establishment.");
commit:4c8ab44
/////////////////////////////////////////////////////////////////////////
1:                 if (!configuration.isStaticBridge()) {
1:                     demandConsumerInfo = new ConsumerInfo(remoteSessionInfo, 1);
0:                     demandConsumerInfo.setDispatchAsync(configuration.isDispatchAsync());
1:                     String advisoryTopic = configuration.getDestinationFilter();
1:                     if (configuration.isBridgeTempDestinations()) {
1:                         advisoryTopic += "," + AdvisorySupport.TEMP_DESTINATION_COMPOSITE_ADVISORY_TOPIC;
1:                     }
1:                     demandConsumerInfo.setDestination(new ActiveMQTopic(advisoryTopic));
0:                     demandConsumerInfo.setPrefetchSize(configuration.getPrefetchSize());
1:                     remoteBroker.oneway(demandConsumerInfo);
commit:332c35c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.*;
0: import org.apache.activemq.transport.*;
0: import javax.management.ObjectName;
1: import java.io.IOException;
1: import java.security.GeneralSecurityException;
1: import java.security.cert.X509Certificate;
0: import java.util.Arrays;
0: import java.util.Collection;
0: import java.util.List;
0: import java.util.Properties;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicBoolean;
0: import java.util.concurrent.atomic.AtomicLong;
1: 
/////////////////////////////////////////////////////////////////////////
0:                 String advisoryTopic = configuration.getDestinationFilter();
commit:4fcc1f7
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQDestination[] dests = staticallyIncludedDestinations;
0:         if (dests != null && dests.length > 0) {
0:             for (int i = 0; i < dests.length; i++) {
0:                 ActiveMQDestination match = dests[i];
0:                 DestinationFilter inclusionFilter = DestinationFilter.parseFilter(match);
0:                 if (match != null && inclusionFilter.matches(destination) && dests[i].getDestinationType() == destination.getDestinationType()) {
1:                     return true;
1:                 }
1:             }
1:         }
1: 
0:         dests = excludedDestinations;
commit:37384a1
/////////////////////////////////////////////////////////////////////////
1:                     brokerService.getBroker().networkBridgeStarted(remoteBrokerInfo, this.createdByDuplex, remoteBroker.toString());
/////////////////////////////////////////////////////////////////////////
commit:861e26c
/////////////////////////////////////////////////////////////////////////
0:                 remoteConnectionInfo.setClientIp(remoteBroker.toString());
commit:fd6c731
/////////////////////////////////////////////////////////////////////////
0:                 remoteConnectionInfo.setClientIp(remoteBroker.getRemoteAddress());
commit:2a558c8
/////////////////////////////////////////////////////////////////////////
0:                 DestinationFilter exclusionFilter = DestinationFilter.parseFilter(match);
0:                 if (match != null && exclusionFilter.matches(destination) && dests[i].getDestinationType() == destination.getDestinationType()) {
1: 
0:                 DestinationFilter inclusionFilter = DestinationFilter.parseFilter(match);
0:                 if (match != null && inclusionFilter.matches(destination) && dests[i].getDestinationType() == destination.getDestinationType()) {
1: 
commit:f0429be
/////////////////////////////////////////////////////////////////////////
0: import java.util.*;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.*;
0: import org.slf4j.MDC;
/////////////////////////////////////////////////////////////////////////
0:         final Map context = MDCHelper.getCopyOfContextMap();
0:                 MDCHelper.setContextMap(context);
/////////////////////////////////////////////////////////////////////////
0:         final Map context = MDCHelper.getCopyOfContextMap();
0:                 MDCHelper.setContextMap(context);
/////////////////////////////////////////////////////////////////////////
0:                     final Map map = MDCHelper.getCopyOfContextMap();
0:                                 MDCHelper.setContextMap(map);
/////////////////////////////////////////////////////////////////////////
0:             final Map map = MDCHelper.getCopyOfContextMap();
0:                     MDCHelper.setContextMap(map);
/////////////////////////////////////////////////////////////////////////
0:             final Map map = MDCHelper.getCopyOfContextMap();
0:                     MDCHelper.setContextMap(map);
/////////////////////////////////////////////////////////////////////////
0:             final Map map = MDCHelper.getCopyOfContextMap();
0:                     MDCHelper.setContextMap(map);
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(DemandForwardingBridgeSupport.class);
commit:bd49b52
/////////////////////////////////////////////////////////////////////////
0:                     brokerService.getBroker().networkBridgeStarted(remoteBrokerInfo, this.createdByDuplex);
commit:3e15501
/////////////////////////////////////////////////////////////////////////
commit:2a2dcd5
/////////////////////////////////////////////////////////////////////////
0:         brokerService.getBroker().networkBridgeStarted(remoteBrokerInfo);
commit:663d5db
/////////////////////////////////////////////////////////////////////////
0:                     brokerService.getBroker().networkBridgeStarted(remoteBrokerInfo);
/////////////////////////////////////////////////////////////////////////
0:             brokerService.getBroker().networkBridgeStopped(remoteBrokerInfo);
commit:34f1929
/////////////////////////////////////////////////////////////////////////
1:             if (info.isBrowser()) {
0:                 if (LOG.isDebugEnabled()) {
0:                     LOG.info(configuration.getBrokerName() + " Ignoring sub from " + remoteBrokerName + ", browsers explicitly suppressed");
1:                 }
1:                 return;
1:             }
1: 
0:                     LOG.debug(configuration.getBrokerName() + " Ignoring sub from " + remoteBrokerName + ", restricted to " + networkTTL + " network hops only : " + info);
commit:7983abf
/////////////////////////////////////////////////////////////////////////
0:                             LOG.debug("bridging (" + configuration.getBrokerName() + " -> " + remoteBrokerName + ", consumer: " + md.getConsumerId() + ", destination " + message.getDestination() + ", brokerPath: " + Arrays.toString(message.getBrokerPath()) + ", message: " + message);
commit:4e81437
/////////////////////////////////////////////////////////////////////////
0:                             if (AdvisorySupport.isConsumerAdvisoryTopic(message.getDestination()) 
0:                                 || AdvisorySupport.isDestinationAdvisoryTopic(message.getDestination())) {
commit:8e42528
/////////////////////////////////////////////////////////////////////////
0: import java.security.cert.X509Certificate;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.TransportFilter;
0: import org.apache.activemq.transport.tcp.SslTransport;
/////////////////////////////////////////////////////////////////////////
0:                 Transport originalTransport = remoteBroker;
0:                 while (originalTransport instanceof TransportFilter) {
0:                     originalTransport = ((TransportFilter)originalTransport).getNext();
1:                 }
0:                 if (originalTransport instanceof SslTransport) {
0:                     X509Certificate[] peerCerts = ((SslTransport)originalTransport).getPeerCertificates();
0:                     localConnectionInfo.setTransportContext(peerCerts);
1:                 }
commit:d185430
/////////////////////////////////////////////////////////////////////////
0:                     Properties props = MarshallingSupport.stringToProperties(remoteBrokerInfo.getNetworkProperties());
1:                     try {
1:                     	IntrospectionSupport.getProperties(configuration, props, null);
0:                     	excludedDestinations = configuration.getExcludedDestinations().toArray(new ActiveMQDestination[configuration.getExcludedDestinations().size()]);
0:                     	staticallyIncludedDestinations = configuration.getStaticallyIncludedDestinations().toArray(new ActiveMQDestination[configuration.getStaticallyIncludedDestinations().size()]);
0:                     	dynamicallyIncludedDestinations = configuration.getDynamicallyIncludedDestinations().toArray(new ActiveMQDestination[configuration.getDynamicallyIncludedDestinations().size()]);
0:                     } catch (Throwable t) {
0:                     	LOG.error("Error mapping remote destinations", t);
1:                     }
commit:2bda17a
/////////////////////////////////////////////////////////////////////////
1:                             	if (!isPermissableDestination(message.getDestination(), true)) {
/////////////////////////////////////////////////////////////////////////
1:     
1:     	return isPermissableDestination(destination, false);
1:     }
1: 
1:     protected boolean isPermissableDestination(ActiveMQDestination destination, boolean allowTemporary) {
1:         if (destination.isTemporary()) {
1:         	if (allowTemporary) {
1:         		return true;
1:         	} else {
1:         		return configuration.isBridgeTempDestinations();
1:         	}
1:         } 
commit:39dd6b9
/////////////////////////////////////////////////////////////////////////
0:                             	if (!isPermissableDestination(message.getDestination())) {
1:                             		return;
1:                             	}
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:972176e
/////////////////////////////////////////////////////////////////////////
1:         message.setMemoryUsage(null);
commit:f1eb92e
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ExecutionException;
1: import java.util.concurrent.Future;
1: import java.util.concurrent.TimeoutException;
/////////////////////////////////////////////////////////////////////////
1:     protected final AtomicBoolean bridgeFailed = new AtomicBoolean();
1:     protected final AtomicBoolean disposed = new AtomicBoolean();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final FutureBrokerInfo futureRemoteBrokerInfo = new FutureBrokerInfo(remoteBrokerInfo, disposed);
1:     private final FutureBrokerInfo futureLocalBrokerInfo = new FutureBrokerInfo(localBrokerInfo, disposed);
1: 
/////////////////////////////////////////////////////////////////////////
1:                     if (!futureLocalBrokerInfo.isDone()) {
1:                         futureLocalBrokerInfo.cancel(true);
1:                         return;
1:                     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                     if (!futureRemoteBrokerInfo.isDone()) {
1:                         futureRemoteBrokerInfo.cancel(true);
1:                         return;
1:                     }
1:             localBroker.start();
1: 
1:                     triggerStartAsyncNetworkBridgeCreation();
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public void stop() throws Exception {
1:         if (started.compareAndSet(true, false)) {
0:             if (disposed.compareAndSet(false, true)) {
0:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug(" stopping " + configuration.getBrokerName() + " bridge to " + remoteBrokerName);
1:                 }
1: 
1:                 futureRemoteBrokerInfo.cancel(true);
1:                 futureLocalBrokerInfo.cancel(true);
1: 
1:                 NetworkBridgeListener l = this.networkBridgeListener;
0:                 if (l != null) {
1:                     l.onStop(this);
1:                 }
1:                 try {
1:                     remoteBridgeStarted.set(false);
1:                     final CountDownLatch sendShutdown = new CountDownLatch(1);
1: 
1:                     brokerService.getTaskRunnerFactory().execute(new Runnable() {
1:                         @Override
1:                         public void run() {
1:                             try {
0:                                 serialExecutor.shutdown();
0:                                 if (!serialExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
0:                                     List<Runnable> pendingTasks = serialExecutor.shutdownNow();
0:                                     if (LOG.isInfoEnabled()) {
0:                                         LOG.info("pending tasks on stop" + pendingTasks);
1:                                     }
1:                                 }
1:                                 localBroker.oneway(new ShutdownInfo());
1:                                 remoteBroker.oneway(new ShutdownInfo());
1:                             } catch (Throwable e) {
0:                                 if (LOG.isDebugEnabled()) {
0:                                     LOG.debug("Caught exception sending shutdown", e);
1:                                 }
0:                             } finally {
0:                                 sendShutdown.countDown();
1:                             }
1: 
1:                         }
1:                     }, "ActiveMQ ForwardingBridge StopTask");
1: 
1:                     if (!sendShutdown.await(10, TimeUnit.SECONDS)) {
0:                         LOG.info("Network Could not shutdown in a timely manner");
1:                     }
0:                 } finally {
1:                     ServiceStopper ss = new ServiceStopper();
1:                     ss.stop(remoteBroker);
0:                     ss.stop(localBroker);
0:                     ss.stop(duplexInboundLocalBroker);
1:                     // Release the started Latch since another thread could be
1:                     // stuck waiting for it to start up.
1:                     startedLatch.countDown();
1:                     startedLatch.countDown();
1:                     localStartedLatch.countDown();
1: 
1:                     ss.throwFirstException();
1:                 }
1:             }
1: 
0:             if (remoteBrokerInfo != null) {
0:                 brokerService.getBroker().removeBroker(null, remoteBrokerInfo);
0:                 brokerService.getBroker().networkBridgeStopped(remoteBrokerInfo);
0:                 if (LOG.isInfoEnabled()) {
0:                     LOG.info(configuration.getBrokerName() + " bridge to " + remoteBrokerName + " stopped");
1:                 }
1:             }
1:         }
1:     }
1: 
1:     protected void triggerStartAsyncNetworkBridgeCreation() throws IOException {
1:                 Thread.currentThread().setName("triggerStartAsyncNetworkBridgeCreation: " +
0:                     "remoteBroker=" + remoteBroker + ", localBroker= " + localBroker);
1: 
1:                     // First we collect the info data from both the local and remote ends
1:                     collectBrokerInfos();
1: 
1:                     // Once we have all required broker info we can attempt to start
1:                     // the local and then remote sides of the bridge.
1:                     doStartLocalAndRemoteBridges();
/////////////////////////////////////////////////////////////////////////
1:     private void collectBrokerInfos() {
1: 
1:         // First wait for the remote to feed us its BrokerInfo, then we can check on
1:         // the LocalBrokerInfo and decide is this is a loop.
1:         try {
0:             remoteBrokerInfo = futureRemoteBrokerInfo.get();
1:             if (remoteBrokerInfo == null) {
0:                 fireBridgeFailed();
1:         } catch (Exception e) {
1:             serviceRemoteException(e);
1:             return;
1:         }
1: 
1:         try {
0:             localBrokerInfo = futureLocalBrokerInfo.get();
1:             if (localBrokerInfo == null) {
0:                 fireBridgeFailed();
1:             }
1: 
1:             // Before we try and build the bridge lets check if we are in a loop
1:             // and if so just stop now before registering anything.
0:             if (localBrokerId.equals(remoteBrokerId)) {
0:                  if (LOG.isTraceEnabled()) {
0:                      LOG.trace(configuration.getBrokerName() +
0:                          " disconnecting remote loop back connection for: " +
0:                          remoteBrokerName + ", with id:" + remoteBrokerId);
1:                  }
0:                  ServiceSupport.dispose(localBroker);
0:                  ServiceSupport.dispose(remoteBroker);
1:                  return;
1:             }
1: 
1:             // Fill in the remote broker's information now.
0:             remoteBrokerId = remoteBrokerInfo.getBrokerId();
0:             remoteBrokerPath[0] = remoteBrokerId;
0:             remoteBrokerName = remoteBrokerInfo.getBrokerName();
1:         } catch (Throwable e) {
1:             serviceLocalException(e);
1:         }
1:     }
1: 
1:     private void doStartLocalAndRemoteBridges() {
1:         try {
1:             startLocalBridge();
1:         } catch (Throwable e) {
1:             serviceLocalException(e);
1:             return;
1:         }
1: 
1:         try {
1: 
0:             if (disposed.get()) {
1:                 return;
1:             }
1: 
0:             Properties props = MarshallingSupport.stringToProperties(remoteBrokerInfo.getNetworkProperties());
1:             try {
0:                 IntrospectionSupport.getProperties(configuration, props, null);
0:                 if (configuration.getExcludedDestinations() != null) {
0:                     excludedDestinations = configuration.getExcludedDestinations().toArray(
0:                         new ActiveMQDestination[configuration.getExcludedDestinations().size()]);
1:                 }
0:                 if (configuration.getStaticallyIncludedDestinations() != null) {
0:                     staticallyIncludedDestinations = configuration.getStaticallyIncludedDestinations().toArray(
0:                         new ActiveMQDestination[configuration.getStaticallyIncludedDestinations().size()]);
1:                 }
0:                 if (configuration.getDynamicallyIncludedDestinations() != null) {
0:                     dynamicallyIncludedDestinations = configuration.getDynamicallyIncludedDestinations().toArray(
0:                         new ActiveMQDestination[configuration.getDynamicallyIncludedDestinations().size()]);
1:                 }
0:             } catch (Throwable t) {
0:                 LOG.error("Error mapping remote destinations", t);
1:             }
1: 
0:             // Let the local broker know the remote broker's ID.
0:             localBroker.oneway(remoteBrokerInfo);
0:             // new peer broker (a consumer can work with remote broker also)
0:             brokerService.getBroker().addBroker(null, remoteBrokerInfo);
1: 
0:             startRemoteBridge();
1:         } catch (Throwable e) {
1:             serviceRemoteException(e);
1:         }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     futureRemoteBrokerInfo.set((BrokerInfo) command);
/////////////////////////////////////////////////////////////////////////
1:                     futureLocalBrokerInfo.set((BrokerInfo) command);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (l != null && this.bridgeFailed.compareAndSet(false, true)) {
/////////////////////////////////////////////////////////////////////////
1: 
1:     /*
1:      * Used to allow for async tasks to await receipt of the BrokerInfo from the local and
1:      * remote sides of the network bridge.
1:      */
1:     private static class FutureBrokerInfo implements Future<BrokerInfo> {
1: 
1:         private final CountDownLatch slot = new CountDownLatch(1);
1:         private final AtomicBoolean disposed;
0:         private BrokerInfo info = null;
1: 
1:         public FutureBrokerInfo(BrokerInfo info, AtomicBoolean disposed) {
1:             this.info = info;
1:             this.disposed = disposed;
1:         }
1: 
1:         @Override
1:         public boolean cancel(boolean mayInterruptIfRunning) {
1:             slot.countDown();
1:             return true;
1:         }
1: 
1:         @Override
1:         public boolean isCancelled() {
1:             return slot.getCount() == 0 && info == null;
1:         }
1: 
1:         @Override
1:         public boolean isDone() {
1:             return info != null;
1:         }
1: 
1:         @Override
1:         public BrokerInfo get() throws InterruptedException, ExecutionException {
1:             try {
1:                 if (info == null) {
1:                     while (!disposed.get()) {
1:                         if (slot.await(1, TimeUnit.SECONDS)) {
1:                             break;
1:                         }
1:                     }
1:                 }
1:                 return info;
1:             } catch (InterruptedException e) {
1:                 Thread.currentThread().interrupt();
0:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug("Operation interupted: " + e, e);
1:                 }
1:                 throw new InterruptedException("Interrupted.");
1:             }
1:         }
1: 
1:         @Override
1:         public BrokerInfo get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
1:             try {
1:                 if (info == null) {
1:                     long deadline = System.currentTimeMillis() + unit.toMillis(timeout);
1: 
0:                     while (!disposed.get() || System.currentTimeMillis() < deadline) {
1:                         if (slot.await(1, TimeUnit.MILLISECONDS)) {
1:                             break;
1:                         }
1:                     }
1:                     if (info == null) {
1:                         throw new TimeoutException();
1:                     }
1:                 }
1:                 return info;
1:             } catch (InterruptedException e) {
1:                 throw new InterruptedException("Interrupted.");
1:             }
1:         }
1: 
1:         public void set(BrokerInfo info) {
1:             this.info = info;
1:             this.slot.countDown();
1:         }
1:     }
1: 
commit:a5dd237
/////////////////////////////////////////////////////////////////////////
1: 
0:                     if (LOG.isInfoEnabled()) {
0:                         LOG.info("Network connection between " + localBroker + " and " + remoteBroker + "(" + remoteBrokerName + ") has been established.");
1:                     }
/////////////////////////////////////////////////////////////////////////
0:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug(" stopping " + configuration.getBrokerName() + " bridge to " + remoteBrokerName);
1:                 }
/////////////////////////////////////////////////////////////////////////
0:                                     if (LOG.isInfoEnabled()) {
0:                                         LOG.info("pending tasks on stop" + pendingTasks);
1:                                     }
0:                                 if (LOG.isDebugEnabled()) {
0:                                     LOG.debug("Caught exception sending shutdown", e);
1:                                 }
/////////////////////////////////////////////////////////////////////////
0:                 if (LOG.isInfoEnabled()) {
0:                     LOG.info(configuration.getBrokerName() + " bridge to " + remoteBrokerName + " stopped");
1:                 }
/////////////////////////////////////////////////////////////////////////
1: 
0:             if (LOG.isInfoEnabled()) {
0:                 LOG.info("Network connection between " + localBroker + " and " + remoteBroker + " shutdown due to a local error: " + error);
1:             }
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("The local Exception was:" + error, error);
1:             }
1: 
commit:5fc2535
/////////////////////////////////////////////////////////////////////////
0:     protected final BrokerId remoteBrokerPath[] = new BrokerId[] { null };
/////////////////////////////////////////////////////////////////////////
1:                 LOG.warn("Bridge was disposed before the start() method was fully executed.");
/////////////////////////////////////////////////////////////////////////
1:                         throw ((ExceptionResponse) resp).getException();
0:                         // separate in-bound chamnel for forwards so we don't
1:                         // contend with out-bound dispatch on same connection
0:                         duplexLocalConnectionInfo.setClientId(configuration.getName() + "_" + remoteBrokerName + "_inbound_duplex_"
0:                             + configuration.getBrokerName());
/////////////////////////////////////////////////////////////////////////
1:                             throw ((ExceptionResponse) resp).getException();
/////////////////////////////////////////////////////////////////////////
1:                     LOG.warn("Bridge was disposed before the startLocalBridge() method was fully executed.");
/////////////////////////////////////////////////////////////////////////
0:                 LOG.warn("Network connection between " + localBroker + " and " + remoteBroker + "(" + remoteBrokerName
0:                     + ") was interrupted during establishment.");
/////////////////////////////////////////////////////////////////////////
1:                 // Listen to consumer advisory messages on the remote broker to determine demand.
1:                     // always dispatch advisory message asynchronously so that
1:                     // we never block the producer broker if we are slow
/////////////////////////////////////////////////////////////////////////
0:                                 new ActiveMQDestination[configuration.getExcludedDestinations().size()]);
0:                                 new ActiveMQDestination[configuration.getStaticallyIncludedDestinations().size()]);
0:                             dynamicallyIncludedDestinations = configuration.getDynamicallyIncludedDestinations().toArray(
0:                                 new ActiveMQDestination[configuration.getDynamicallyIncludedDestinations().size()]);
/////////////////////////////////////////////////////////////////////////
0:                             LOG.trace(configuration.getBrokerName() + " duplex command type: " + command.getCommandId());
/////////////////////////////////////////////////////////////////////////
1:                                 // message being forwarded - we need to
1:                                 // propagate the response to our local send
1: 
/////////////////////////////////////////////////////////////////////////
0:                     LOG.debug(configuration.getBrokerName() + " Ignoring sub from " + remoteBrokerName + ", restricted to " + networkTTL
0:                         + " network hops only : " + info);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:                     LOG.debug(configuration.getBrokerName() + " Ignoring sub from " + remoteBrokerName + ", destination " + info.getDestination()
0:                         + " is not permiited :" + info);
/////////////////////////////////////////////////////////////////////////
0:                         LOG.debug(configuration.getBrokerName() + " Ignoring sub from " + remoteBrokerName
0:                             + " as already subscribed to matching destination : " + info);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.trace(configuration.getBrokerName() + " bridging " + (destInfo.isAddOperation() ? "add" : "remove") + " destination on " + localBroker
0:                     + " from " + remoteBrokerName + ", destination: " + destInfo);
1:                 // Serialize with removeSub operations such that all removeSub advisories
1:                 // are generated
/////////////////////////////////////////////////////////////////////////
1:             if (error instanceof DestinationDoesNotExistException && ((DestinationDoesNotExistException) error).isTemporary()) {
1:                 // not a reason to terminate the bridge - temps can disappear with
1:                 // pending sends as the demand sub may outlive the remote dest
0:                     LOG.warn("PoisonAck of " + messageDispatch.getMessage().getMessageId() + " on forwarding error: " + error);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.warn("Ignoring exception on forwarding to non existent temp dest: " + error, error);
/////////////////////////////////////////////////////////////////////////
1:                     advisoryBroker.fireAdvisory(context, AdvisorySupport.getNetworkBridgeForwardFailureAdvisoryTopic(), messageDispatch.getMessage(), null,
0:                         advisoryMessage);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.trace(configuration.getBrokerName() + " remove local subscription:" + sub.getLocalInfo().getConsumerId() + " for remote "
0:                     + sub.getRemoteInfo().getConsumerId());
/////////////////////////////////////////////////////////////////////////
1:             // Serialize with removeDestination operations so that removeSubs are serialized with
1:             // removeDestinations such that all removeSub advisories are generated
/////////////////////////////////////////////////////////////////////////
0:                                 LOG.debug(configuration.getBrokerName() + " message not forwarded to " + remoteBrokerName
0:                                     + " because message came from there or fails networkTTL, brokerPath: " + Arrays.toString(md.getMessage().getBrokerPath())
0:                                     + ", message: " + md.getMessage());
/////////////////////////////////////////////////////////////////////////
0:                             LOG.debug("bridging (" + configuration.getBrokerName() + " -> " + remoteBrokerName + ") "
0:                                 + (LOG.isTraceEnabled() ? message : message.getMessageId()) + ", consumer: " + md.getConsumerId() + ", destination "
0:                                 + message.getDestination() + ", brokerPath: " + Arrays.toString(message.getBrokerPath()) + ", message: " + message);
0:                             // If the message was originally sent using async send, we will
0:                             // preserve that QOS by bridging it using an async send (small chance
/////////////////////////////////////////////////////////////////////////
0:                             // The message was not sent using async send, so we should only
0:                             // ack the local broker when we get confirmation that the remote
/////////////////////////////////////////////////////////////////////////
0:                             LOG.debug("No subscription registered with this network bridge for consumerId " + md.getConsumerId() + " for message: "
0:                                 + md.getMessage());
/////////////////////////////////////////////////////////////////////////
1:                         case WireFormatInfo.DATA_STRUCTURE_TYPE:
1:                             break;
1:                         default:
0:                             LOG.warn("Unexpected local command: " + command);
/////////////////////////////////////////////////////////////////////////
0:     protected void serviceLocalBrokerInfo(Command command) throws InterruptedException {
0:         synchronized (brokerInfoMutex) {
0:             if (remoteBrokerId != null) {
0:                 if (remoteBrokerId.equals(localBrokerId)) {
0:                     if (LOG.isTraceEnabled()) {
0:                         LOG.trace(configuration.getBrokerName() + " disconnecting local loop back connection for: " + remoteBrokerName + ", with id:"
0:                             + remoteBrokerId);
1:                     }
0:                     safeWaitUntilStarted();
0:                     ServiceSupport.dispose(this);
1:                 }
1:             }
1:         }
1:     }
1: 
0:     protected void serviceRemoteBrokerInfo(Command command) throws IOException {
0:         synchronized (brokerInfoMutex) {
0:             BrokerInfo remoteBrokerInfo = (BrokerInfo) command;
0:             remoteBrokerId = remoteBrokerInfo.getBrokerId();
0:             remoteBrokerPath[0] = remoteBrokerId;
0:             remoteBrokerName = remoteBrokerInfo.getBrokerName();
0:             if (localBrokerId != null) {
0:                 if (localBrokerId.equals(remoteBrokerId)) {
0:                     if (LOG.isTraceEnabled()) {
0:                         LOG.trace(configuration.getBrokerName() + " disconnecting remote loop back connection for: " + remoteBrokerName + ", with id:"
0:                             + remoteBrokerId);
1:                     }
0:                     ServiceSupport.dispose(this);
1:                 }
1:             }
0:             if (!disposed.get()) {
0:                 triggerLocalStartBridge();
1:             }
1:         }
1:     }
1: 
1:         // for durable subs, suppression via filter leaves dangling acks so we
1:         // need to check here and allow the ack irrespective
/////////////////////////////////////////////////////////////////////////
1:             for (BrokerId id : brokerPath) {
1:                 if (brokerId.equals(id)) {
/////////////////////////////////////////////////////////////////////////
1:             for (ActiveMQDestination dest : dests) {
0:                 DestinationFilter inclusionFilter = DestinationFilter.parseFilter(dest);
0:                 if (dest != null && inclusionFilter.matches(destination) && dest.getDestinationType() == destination.getDestinationType()) {
/////////////////////////////////////////////////////////////////////////
0:             for (ActiveMQDestination dest : dests) {
1:                 DestinationFilter exclusionFilter = DestinationFilter.parseFilter(dest);
1:                 if (dest != null && exclusionFilter.matches(destination) && dest.getDestinationType() == destination.getDestinationType()) {
/////////////////////////////////////////////////////////////////////////
0:             for (ActiveMQDestination dest : dests) {
0:                 DestinationFilter inclusionFilter = DestinationFilter.parseFilter(dest);
0:                 if (dest != null && inclusionFilter.matches(destination) && dest.getDestinationType() == destination.getDestinationType()) {
/////////////////////////////////////////////////////////////////////////
0:             for (ActiveMQDestination dest : dests) {
/////////////////////////////////////////////////////////////////////////
1:      * check our existing subs networkConsumerIds against the list of network
1:      * ids in this subscription A match means a duplicate which we suppress for
1:      * topics and maybe for queues
0:         if (consumerInfo.getDestination().isQueue() && !configuration.isSuppressDuplicateQueueSubscriptions() || consumerInfo.getDestination().isTopic()
0:             && !configuration.isSuppressDuplicateTopicSubscriptions()) {
1:         Collection<Subscription> currentSubs = getRegionSubscriptions(consumerInfo.getDestination());
/////////////////////////////////////////////////////////////////////////
1:         return (sub.getConsumerInfo().isDurable() && sub instanceof DurableTopicSubscription && !((DurableTopicSubscription) sub).isActive());
/////////////////////////////////////////////////////////////////////////
0:                 LOG.debug(configuration.getBrokerName() + " Ignoring duplicate subscription from " + remoteBrokerName + ", sub: " + candidateInfo
0:                     + " is duplicated by network subscription with equal or higher network priority: " + existingSub + ", networkConsumerIds: "
0:                     + existingSub.getConsumerInfo().getNetworkConsumerIds());
/////////////////////////////////////////////////////////////////////////
0:                     LOG.debug(configuration.getBrokerName() + " Replacing duplicate subscription " + existingSub.getConsumerInfo() + " with sub from "
0:                         + remoteBrokerName + ", which has a higher priority, new sub: " + candidateInfo + ", networkComsumerIds: "
0:                         + candidateInfo.getNetworkConsumerIds());
/////////////////////////////////////////////////////////////////////////
1:         switch (dest.getDestinationType()) {
1:         if (region instanceof AbstractRegion) {
/////////////////////////////////////////////////////////////////////////
1:         // add our original id to ourselves
/////////////////////////////////////////////////////////////////////////
1:         // the remote info held by the DemandSubscription holds the original
1:         // consumerId, the local info get's overwritten
/////////////////////////////////////////////////////////////////////////
0:         if (AdvisorySupport.isConsumerAdvisoryTopic(info.getDestination())) {
/////////////////////////////////////////////////////////////////////////
0:         } else {
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug(configuration.getBrokerName() + " remove request on " + localBroker + " from " + remoteBrokerName + " , consumer id: " + id
0:                 + ", matching sub: " + sub);
/////////////////////////////////////////////////////////////////////////
1:      * Performs a timed wait on the started latch and then checks for disposed
1:      * before performing another wait each time the the started wait times out.
/////////////////////////////////////////////////////////////////////////
1:     protected BrokerId[] getRemoteBrokerPath() {
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @return Returns the dynamicallyIncludedDestinations.
1:      */
1:     public ActiveMQDestination[] getDynamicallyIncludedDestinations() {
1:         return dynamicallyIncludedDestinations;
1:     }
1: 
1:     /**
1:      * @param dynamicallyIncludedDestinations
0:      *            The dynamicallyIncludedDestinations to set.
1:      */
1:     public void setDynamicallyIncludedDestinations(ActiveMQDestination[] dynamicallyIncludedDestinations) {
1:         this.dynamicallyIncludedDestinations = dynamicallyIncludedDestinations;
1:     }
1: 
1:     /**
1:      * @return Returns the excludedDestinations.
1:      */
1:     public ActiveMQDestination[] getExcludedDestinations() {
1:         return excludedDestinations;
1:     }
1: 
1:     /**
0:      * @param excludedDestinations
0:      *            The excludedDestinations to set.
1:      */
1:     public void setExcludedDestinations(ActiveMQDestination[] excludedDestinations) {
1:         this.excludedDestinations = excludedDestinations;
1:     }
1: 
1:     /**
1:      * @return Returns the staticallyIncludedDestinations.
1:      */
0:     public ActiveMQDestination[] getStaticallyIncludedDestinations() {
1:         return staticallyIncludedDestinations;
1:     }
1: 
1:     /**
0:      * @param staticallyIncludedDestinations
0:      *            The staticallyIncludedDestinations to set.
1:      */
1:     public void setStaticallyIncludedDestinations(ActiveMQDestination[] staticallyIncludedDestinations) {
1:         this.staticallyIncludedDestinations = staticallyIncludedDestinations;
1:     }
1: 
1:     /**
1:      * @return Returns the durableDestinations.
1:      */
1:     public ActiveMQDestination[] getDurableDestinations() {
1:         return durableDestinations;
1:     }
1: 
1:     /**
0:      * @param durableDestinations
0:      *            The durableDestinations to set.
1:      */
1:     public void setDurableDestinations(ActiveMQDestination[] durableDestinations) {
1:         this.durableDestinations = durableDestinations;
1:     }
1: 
1:     /**
1:      * @return Returns the localBroker.
1:      */
1:     public Transport getLocalBroker() {
1:         return localBroker;
1:     }
1: 
1:     /**
1:      * @return Returns the remoteBroker.
1:      */
1:     public Transport getRemoteBroker() {
1:         return remoteBroker;
1:     }
1: 
1:     /**
1:      * @return the createdByDuplex
1:      */
1:     public boolean isCreatedByDuplex() {
1:         return this.createdByDuplex;
1:     }
1: 
1:     /**
0:      * @param createdByDuplex
0:      *            the createdByDuplex to set
1:      */
1:     public void setCreatedByDuplex(boolean createdByDuplex) {
1:         this.createdByDuplex = createdByDuplex;
1:     }
1: 
commit:e35c39b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.DestinationDoesNotExistException;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 // Serialize with removeSub operations such that all removeSub advisories are generated
/////////////////////////////////////////////////////////////////////////
0:             // Serialize with removeDestination operations so that removeSubs are serialised with removeDestinations
commit:99c2b2e
/////////////////////////////////////////////////////////////////////////
0:         if (AdvisorySupport.isConsumerAdvisoryTopic(info.getDestination())){
1:             sub.getLocalInfo().setDispatchAsync(true);
0:         } else {
1:             sub.getLocalInfo().setDispatchAsync(configuration.isDispatchAsync());
1:         }
commit:c518498
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final ExecutorService serialExecutor = Executors.newSingleThreadExecutor();
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                         @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:                                 @Override
/////////////////////////////////////////////////////////////////////////
1:         // Indicate that this subscription is being made on behalf of the remote broker.
0:         info.setBrokerPath(new BrokerId[] { remoteBrokerId });
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
0:     @Override
0:     @Override
commit:5c20b8e
/////////////////////////////////////////////////////////////////////////
commit:a80acbb
/////////////////////////////////////////////////////////////////////////
1:     protected final CountDownLatch startedLatch = new CountDownLatch(2);
1:     protected final CountDownLatch localStartedLatch = new CountDownLatch(1);
/////////////////////////////////////////////////////////////////////////
0:                     // always dispatch advisory message asynchronously so that we never block the producer
0:                     // broker if we are slow
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             // a network subscription so there is a need to synchronize on a shared entity
/////////////////////////////////////////////////////////////////////////
1:             // It's a destination info - we want to pass up information about temporary destinations
/////////////////////////////////////////////////////////////////////////
0:                 // Ignore this consumer as it's a consumer we locally sent to the broker.
/////////////////////////////////////////////////////////////////////////
1:         // Are we not bridging temporary destinations?
/////////////////////////////////////////////////////////////////////////
0:         if ( region instanceof AbstractRegion ) {
0:         } else {
1:         }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         // the remote info held by the DemandSubscription holds the original consumerId,
0:         // the local info get's overwritten
commit:41c9366
/////////////////////////////////////////////////////////////////////////
1:     protected Message configureMessage(MessageDispatch md) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:         if (configuration.isUseCompression()) {
1:             message.compress();
1:         }
commit:7fbbcf3
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQMessage;
0: import org.apache.activemq.command.ActiveMQTempDestination;
0: import org.apache.activemq.command.ActiveMQTopic;
0: import org.apache.activemq.command.BrokerId;
0: import org.apache.activemq.command.BrokerInfo;
0: import org.apache.activemq.command.Command;
0: import org.apache.activemq.command.ConnectionError;
0: import org.apache.activemq.command.ConnectionId;
0: import org.apache.activemq.command.ConnectionInfo;
0: import org.apache.activemq.command.ConsumerId;
0: import org.apache.activemq.command.ConsumerInfo;
0: import org.apache.activemq.command.DataStructure;
0: import org.apache.activemq.command.DestinationInfo;
0: import org.apache.activemq.command.ExceptionResponse;
0: import org.apache.activemq.command.KeepAliveInfo;
0: import org.apache.activemq.command.Message;
0: import org.apache.activemq.command.MessageAck;
0: import org.apache.activemq.command.MessageDispatch;
0: import org.apache.activemq.command.NetworkBridgeFilter;
0: import org.apache.activemq.command.ProducerInfo;
0: import org.apache.activemq.command.RemoveInfo;
0: import org.apache.activemq.command.Response;
0: import org.apache.activemq.command.SessionInfo;
0: import org.apache.activemq.command.ShutdownInfo;
0: import org.apache.activemq.command.WireFormatInfo;
/////////////////////////////////////////////////////////////////////////
1: 
0:                 safeWaitUntilStarted();
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Performs a timed wait on the started latch and then checks for disposed before performing
0:      * another wait each time the the started wait times out.
1:      *
0:      * @throws InterruptedException
1:      */
0:     protected void safeWaitUntilStarted() throws InterruptedException {
1:         while (!disposed.get()) {
1:             if (startedLatch.await(1, TimeUnit.SECONDS)) {
1:                 return;
1:             }
1:         }
1:     }
1: 
commit:3221b16
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import javax.management.ObjectName;
1: 
1: import org.apache.activemq.Service;
1: import org.apache.activemq.advisory.AdvisorySupport;
0: import org.apache.activemq.broker.BrokerService;
0: import org.apache.activemq.broker.BrokerServiceAware;
1: import org.apache.activemq.broker.TransportConnection;
0: import org.apache.activemq.broker.region.AbstractRegion;
0: import org.apache.activemq.broker.region.DurableTopicSubscription;
0: import org.apache.activemq.broker.region.RegionBroker;
0: import org.apache.activemq.broker.region.Subscription;
0: import org.apache.activemq.broker.region.policy.PolicyEntry;
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQMessage;
0: import org.apache.activemq.command.ActiveMQTempDestination;
0: import org.apache.activemq.command.ActiveMQTopic;
0: import org.apache.activemq.command.BrokerId;
0: import org.apache.activemq.command.BrokerInfo;
0: import org.apache.activemq.command.Command;
0: import org.apache.activemq.command.ConnectionError;
0: import org.apache.activemq.command.ConnectionId;
0: import org.apache.activemq.command.ConnectionInfo;
0: import org.apache.activemq.command.ConsumerId;
0: import org.apache.activemq.command.ConsumerInfo;
0: import org.apache.activemq.command.DataStructure;
0: import org.apache.activemq.command.DestinationInfo;
0: import org.apache.activemq.command.ExceptionResponse;
0: import org.apache.activemq.command.KeepAliveInfo;
0: import org.apache.activemq.command.Message;
0: import org.apache.activemq.command.MessageAck;
0: import org.apache.activemq.command.MessageDispatch;
0: import org.apache.activemq.command.NetworkBridgeFilter;
0: import org.apache.activemq.command.ProducerInfo;
0: import org.apache.activemq.command.RemoveInfo;
0: import org.apache.activemq.command.Response;
0: import org.apache.activemq.command.SessionInfo;
0: import org.apache.activemq.command.ShutdownInfo;
0: import org.apache.activemq.command.WireFormatInfo;
1: import org.apache.activemq.filter.DestinationFilter;
0: import org.apache.activemq.filter.MessageEvaluationContext;
0: import org.apache.activemq.thread.DefaultThreadPools;
0: import org.apache.activemq.thread.TaskRunnerFactory;
1: import org.apache.activemq.transport.DefaultTransportListener;
1: import org.apache.activemq.transport.FutureResponse;
1: import org.apache.activemq.transport.ResponseCallback;
1: import org.apache.activemq.transport.Transport;
1: import org.apache.activemq.transport.TransportDisposedIOException;
0: import org.apache.activemq.transport.TransportFilter;
0: import org.apache.activemq.transport.tcp.SslTransport;
1: import org.apache.activemq.util.IdGenerator;
1: import org.apache.activemq.util.IntrospectionSupport;
1: import org.apache.activemq.util.LongSequenceGenerator;
1: import org.apache.activemq.util.MarshallingSupport;
1: import org.apache.activemq.util.ServiceStopper;
1: import org.apache.activemq.util.ServiceSupport;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
1: 
/////////////////////////////////////////////////////////////////////////
0:             if (remoteBrokerInfo != null) {
0:                 brokerService.getBroker().removeBroker(null, remoteBrokerInfo);
0:                 brokerService.getBroker().networkBridgeStopped(remoteBrokerInfo);
0:                 LOG.info(configuration.getBrokerName() + " bridge to " + remoteBrokerName + " stopped");
1:             }
commit:633428c
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
/////////////////////////////////////////////////////////////////////////
0:             } else {
/////////////////////////////////////////////////////////////////////////
0:                     localBrokerIdKnownLatch.await();
/////////////////////////////////////////////////////////////////////////
0:                             if (AdvisorySupport.isConsumerAdvisoryTopic(message.getDestination())
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:                                         }
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:         Collection<Subscription> currentSubs =
/////////////////////////////////////////////////////////////////////////
0:                         + ", sub: " + candidateInfo + " is duplicated by network subscription with equal or higher network priority: "
/////////////////////////////////////////////////////////////////////////
0:                             + ", which has a higher priority, new sub: " + candidateInfo + ", networkComsumerIds: "
/////////////////////////////////////////////////////////////////////////
0:         AbstractRegion abstractRegion = (AbstractRegion)
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
commit:0bbc0ac
/////////////////////////////////////////////////////////////////////////
0:  * 
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
0:     protected final ConcurrentHashMap<ConsumerId, DemandSubscription> subscriptionMapByLocalId = new ConcurrentHashMap<ConsumerId, DemandSubscription>();
0:     protected final ConcurrentHashMap<ConsumerId, DemandSubscription> subscriptionMapByRemoteId = new ConcurrentHashMap<ConsumerId, DemandSubscription>();
1:     
1:     private NetworkBridgeListener networkBridgeListener;
1:     private boolean createdByDuplex;
1:     private BrokerInfo localBrokerInfo;
1:     private BrokerInfo remoteBrokerInfo;
1: 
/////////////////////////////////////////////////////////////////////////
0:                     remoteBrokerInfo = (BrokerInfo)command;
/////////////////////////////////////////////////////////////////////////
0:                                     if (LOG.isDebugEnabled()) {
0:                                     }
0:                                 if (LOG.isDebugEnabled()) {
0:                                 }
/////////////////////////////////////////////////////////////////////////
0:                 if (LOG.isDebugEnabled()) {
0:                 }
0:                 if (LOG.isDebugEnabled()) {
0:                 }
0:                 if (LOG.isDebugEnabled()) {
0:                 }
0:                 if (LOG.isDebugEnabled()) {
0:                 }
0:                 if (LOG.isDebugEnabled()) {
0:                 }
0:             // information about temporary destinations
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         return subscriptionMapByLocalId.get(md.getConsumerId());
/////////////////////////////////////////////////////////////////////////
1:         if (message.getOriginalTransactionId() == null) {
0:         }
/////////////////////////////////////////////////////////////////////////
0:                     DemandSubscription sub = subscriptionMapByLocalId.get(md.getConsumerId());
0:                         if (trace) {
0:                         }
/////////////////////////////////////////////////////////////////////////
0:                         if (trace) {
0:                         }
0:                     localBrokerInfo = (BrokerInfo)command;
/////////////////////////////////////////////////////////////////////////
0:                 if (brokerId.equals(brokerPath[i])) {
0:                 }
1:         if (brokerPath == null || brokerPath.length == 0) {
0:         }
/////////////////////////////////////////////////////////////////////////
1:         if (brokerPath == null || brokerPath.length == 0) {
0:         }
/////////////////////////////////////////////////////////////////////////
0:                 if (LOG.isTraceEnabled()) {
0:                 }
/////////////////////////////////////////////////////////////////////////
1:         DemandSubscription sub = subscriptionMapByRemoteId.remove(id);
0:             if (LOG.isTraceEnabled()) {
0:             }
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:     
0:     private static final Log LOG = LogFactory.getLog(DemandForwardingBridge.class);
1:     
/////////////////////////////////////////////////////////////////////////
0:                         LOG.info("Outbound transport to " + remoteBrokerName + " interrupted.");
0:                                     LOG.debug("local broker is now disposed", td);
0:                                     LOG.warn("Caught exception from local start", e);
/////////////////////////////////////////////////////////////////////////
0:                                 LOG.debug("Previous connection was never fully established. Sleeping for second to avoid busy loop.");
/////////////////////////////////////////////////////////////////////////
0:                             LOG.info("Outbound transport to " + remoteBrokerName + " resumed");
0:                             LOG.error("Caught exception  from local start in resume transport", e);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.warn("Caught exception from remote start", e);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.info("Network connection between " + localBroker + " and " + remoteBroker + "(" + remoteBrokerName + ") has been established.");
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug(" stopping " + configuration.getBrokerName() + " bridge to " + remoteBrokerName + " is disposed already ? " + disposed);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.debug("Caught exception stopping", e);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.debug(configuration.getBrokerName() + " bridge to " + remoteBrokerName + " stopped");
0:                 LOG.info(configuration.getBrokerName() + " bridge to " + remoteBrokerName + " stopped");
/////////////////////////////////////////////////////////////////////////
0:                 LOG.error("Network connection between " + localBroker + " and " + remoteBroker + " shutdown due to a remote error: " + error);
0:                 LOG.warn("Network connection between " + localBroker + " and " + remoteBroker + " shutdown due to a remote error: " + error);
0:             LOG.debug("The remote Exception was: " + error, error);
/////////////////////////////////////////////////////////////////////////
0:                                     if (LOG.isDebugEnabled())
0:                                         LOG.debug("Ignoring ConsumerInfo: " + command);
0:                                 if (LOG.isDebugEnabled())
0:                                     LOG.debug("Ignoring remote command: " + command);
/////////////////////////////////////////////////////////////////////////
0:                             LOG.warn("Unexpected remote command: " + command);
/////////////////////////////////////////////////////////////////////////
0:                 if (LOG.isDebugEnabled())
0:                     LOG.debug(configuration.getBrokerName() + " Ignoring Subscription " + info + " restricted to " + networkTTL + " network hops only");
0:                 if (LOG.isDebugEnabled())
0:                     LOG.debug(configuration.getBrokerName() + " Ignoring sub " + info + " already routed through this broker once");
0:                 if (LOG.isDebugEnabled())
0:                     LOG.debug(configuration.getBrokerName() + " Ignoring sub " + info + " destination " + info.getDestination() + " is not permiited");
0:                 if (LOG.isDebugEnabled())
0:                     LOG.debug(configuration.getBrokerName() + " Forwarding sub on " + localBroker + " from " + remoteBrokerName + " :  " + info);
0:                 if (LOG.isDebugEnabled())
0:                     LOG.debug(configuration.getBrokerName() + " Ignoring sub " + info + " already subscribed to matching destination");
/////////////////////////////////////////////////////////////////////////
0:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug("Ignoring Subscription " + destInfo + " restricted to " + networkTTL + " network hops only");
0:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug("Ignoring sub " + destInfo + " already routed through this broker once");
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("Replying destination control command: " + destInfo);
/////////////////////////////////////////////////////////////////////////
0:             LOG.info("Network connection between " + localBroker + " and " + remoteBroker + " shutdown due to a local error: " + error);
0:             LOG.debug("The local Exception was:" + error, error);
/////////////////////////////////////////////////////////////////////////
0:             final boolean trace = LOG.isTraceEnabled();
/////////////////////////////////////////////////////////////////////////
0:                             LOG.trace("bridging " + configuration.getBrokerName() + " -> " + remoteBrokerName + ": " + message);
/////////////////////////////////////////////////////////////////////////
0:                             LOG.trace("No subscription registered with this network bridge for consumerId " + md.getConsumerId() + " for message: " + md.getMessage());
0:                     LOG.info(configuration.getBrokerName() + " Shutting down");
/////////////////////////////////////////////////////////////////////////
0:                         LOG.warn("Unexpected local command: " + command);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.error("Failed to add static destination " + dest, e);
0:                 if (LOG.isTraceEnabled())
0:                     LOG.trace("Forwarding messages for static destination: " + dest);
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isTraceEnabled())
0:                 LOG.trace("removing sub on " + localBroker + " from " + remoteBrokerName + " :  " + sub.getRemoteInfo());
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
1:                 if (!isCreatedByDuplex()) {
/////////////////////////////////////////////////////////////////////////
0:             if (path != null && path.length >= networkTTL) {
/////////////////////////////////////////////////////////////////////////
0:             if (path != null && path.length >= networkTTL) {
0:                 if (log.isDebugEnabled()) {
0:                 }
0:                 if (log.isDebugEnabled()) {
0:                 }
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
0:     protected boolean disposed;
/////////////////////////////////////////////////////////////////////////
0:     protected final BrokerId localBrokerPath[] = new BrokerId[] {null};
/////////////////////////////////////////////////////////////////////////
1: 
1:         this.configuration = configuration;
1: 
0:     public void duplexStart(BrokerInfo localBrokerInfo, BrokerInfo remoteBrokerInfo) throws Exception {
1:         this.localBrokerInfo = localBrokerInfo;
1:         this.remoteBrokerInfo = remoteBrokerInfo;
1:     public void start() throws Exception {
1:         if (started.compareAndSet(false, true)) {
1:             localBroker.setTransportListener(new DefaultTransportListener() {
1:                 public void onCommand(Object o) {
0:                     Command command = (Command)o;
1:                 public void onException(IOException error) {
0:             remoteBroker.setTransportListener(new TransportListener() {
1:                 public void onCommand(Object o) {
0:                     Command command = (Command)o;
1:                 public void onException(IOException error) {
0:                 public void transportInterupted() {
0:                     // clear any subscriptions - to try and prevent the bridge
0:                     // from stalling the broker
0:                     if (remoteInterupted.compareAndSet(false, true)) {
0:                         log.info("Outbound transport to " + remoteBrokerName + " interrupted.");
0:                         if (localBridgeStarted.get()) {
0:                             synchronized (DemandForwardingBridgeSupport.this) {
0:                                 try {
0:                                 } catch (TransportDisposedIOException td) {
0:                                     log.debug("local broker is now disposed", td);
1:                                 } catch (IOException e) {
0:                                     log.warn("Caught exception from local start", e);
0:                         startedLatch = new CountDownLatch(2);
0:                 public void transportResumed() {
0:                     if (remoteInterupted.compareAndSet(true, false)) {
0:                         // We want to slow down false connects so that we don't
0:                         // get in a busy loop.
0:                         if (!lastConnectSucceeded.get()) {
0:                             try {
0:                                 log.debug("Previous connection was never fully established. Sleeping for second to avoid busy loop.");
0:                             } catch (InterruptedException e) {
0:                         try {
0:                             log.info("Outbound transport to " + remoteBrokerName + " resumed");
0:                         } catch (Exception e) {
0:                             log.error("Caught exception  from local start in resume transport", e);
/////////////////////////////////////////////////////////////////////////
0:             try {
0:             } catch (IOException e) {
0:                 log.warn("Caught exception from remote start", e);
0:             NetworkBridgeListener l = this.networkBridgeListener;
0:             if (l != null) {
1: 
0:         Thread thead = new Thread() {
1:             public void run() {
0:                 try {
0:                 } catch (Exception e) {
/////////////////////////////////////////////////////////////////////////
0:         Thread thead = new Thread() {
1:             public void run() {
0:                 try {
0:                 } catch (Exception e) {
/////////////////////////////////////////////////////////////////////////
0:         if (localBridgeStarted.compareAndSet(false, true)) {
1:             synchronized (this) {
0:                 remoteBrokerNameKnownLatch.await();
1: 
0:                 localConnectionInfo = new ConnectionInfo();
0:                 localConnectionInfo.setConnectionId(new ConnectionId(idGenerator.generateId()));
0:                 localClientId = "NC_" + remoteBrokerName + "_inbound" + configuration.getBrokerName();
0:                 localConnectionInfo.setClientId(localClientId);
0:                 localConnectionInfo.setUserName(configuration.getUserName());
0:                 localConnectionInfo.setPassword(configuration.getPassword());
0:                 localBroker.oneway(localConnectionInfo);
1: 
0:                 localSessionInfo = new SessionInfo(localConnectionInfo, 1);
0:                 localBroker.oneway(localSessionInfo);
1: 
0:                 log.info("Network connection between " + localBroker + " and " + remoteBroker + "(" + remoteBrokerName + ") has been established.");
1: 
1:                 startedLatch.countDown();
0:                 setupStaticDestinations();
1:     protected void startRemoteBridge() throws Exception {
0:         if (remoteBridgeStarted.compareAndSet(false, true)) {
1:             synchronized (this) {
0:                 if (isCreatedByDuplex() == false) {
1:                     BrokerInfo brokerInfo = new BrokerInfo();
1:                     Properties props = new Properties();
0:                     IntrospectionSupport.getProperties(this, props, null);
1:                     String str = MarshallingSupport.propertiesToString(props);
1:                 if (remoteConnectionInfo != null) {
1:                 remoteConnectionInfo = new ConnectionInfo();
0:                 remoteConnectionInfo.setClientId("NC_" + configuration.getBrokerName() + "_outbound");
1: 
1:                 SessionInfo remoteSessionInfo = new SessionInfo(remoteConnectionInfo, 1);
1:                 producerInfo = new ProducerInfo(remoteSessionInfo, 1);
0:                 // Listen to consumer advisory messages on the remote broker to
0:                 // determine demand.
0:                 demandConsumerInfo = new ConsumerInfo(remoteSessionInfo, 1);
0:                 String advisoryTopic = AdvisorySupport.CONSUMER_ADVISORY_TOPIC_PREFIX + configuration.getDestinationFilter();
0:                 if (configuration.isBridgeTempDestinations()) {
0:                     advisoryTopic += "," + AdvisorySupport.TEMP_DESTINATION_COMPOSITE_ADVISORY_TOPIC;
0:                 if (!disposed) {
0:     public void stop() throws Exception {
0:         if (started.compareAndSet(true, false)) {
0:             log.debug(" stopping " + configuration.getBrokerName() + " bridge to " + remoteBrokerName + " is disposed already ? " + disposed);
0:             boolean wasDisposedAlready = disposed;
0:             if (!disposed) {
0:                 NetworkBridgeListener l = this.networkBridgeListener;
0:                 if (l != null) {
0:                 try {
0:                     disposed = true;
0:                 } catch (IOException e) {
0:                     log.debug("Caught exception stopping", e);
0:                 } finally {
0:                     ServiceStopper ss = new ServiceStopper();
0:                     // Release the started Latch since another thread could be
0:                     // stuck waiting for it to start up.
0:             if (wasDisposedAlready) {
0:                 log.debug(configuration.getBrokerName() + " bridge to " + remoteBrokerName + " stopped");
0:             } else {
0:                 log.info(configuration.getBrokerName() + " bridge to " + remoteBrokerName + " stopped");
1:     public void serviceRemoteException(Throwable error) {
0:         if (!disposed) {
1:             if (error instanceof SecurityException || error instanceof GeneralSecurityException) {
0:                 log.error("Network connection between " + localBroker + " and " + remoteBroker + " shutdown due to a remote error: " + error);
0:             } else {
0:                 log.warn("Network connection between " + localBroker + " and " + remoteBroker + " shutdown due to a remote error: " + error);
0:             }
0:             log.debug("The remote Exception was: " + error, error);
0:             new Thread() {
1: 
1:                 public void run() {
/////////////////////////////////////////////////////////////////////////
1:     protected void serviceRemoteCommand(Command command) {
0:         if (!disposed) {
0:             try {
1:                 if (command.isMessageDispatch()) {
0:                     MessageDispatch md = (MessageDispatch)command;
0:                     if (demandConsumerDispatched > (demandConsumerInfo.getPrefetchSize() * .75)) {
0:                         remoteBroker.oneway(new MessageAck(md, MessageAck.STANDARD_ACK_TYPE, demandConsumerDispatched));
0:                         demandConsumerDispatched = 0;
1:                 } else if (command.isBrokerInfo()) {
0:                     remoteBrokerInfo = ((BrokerInfo)command);
1:                 } else if (command.getClass() == ConnectionError.class) {
0:                     ConnectionError ce = (ConnectionError)command;
0:                 } else {
0:                     if (configuration.isDuplex() || createdByDuplex) {
1:                         if (command.isMessage()) {
0:                             ActiveMQMessage message = (ActiveMQMessage)command;
0:                             if (AdvisorySupport.isConsumerAdvisoryTopic(message.getDestination())) {
0:                             } else {
0:                         } else {
1:                             switch (command.getDataStructureType()) {
0:                                 if (!addConsumerInfo((ConsumerInfo)command)) {
0:                                     if (log.isDebugEnabled())
0:                                         log.debug("Ignoring ConsumerInfo: " + command);
0:                                 if (log.isDebugEnabled())
0:                                     log.debug("Ignoring remote command: " + command);
0:                     } else {
1:                         switch (command.getDataStructureType()) {
0:                             log.warn("Unexpected remote command: " + command);
0:             } catch (Throwable e) {
1:     private void serviceRemoteConsumerAdvisory(DataStructure data) throws IOException {
0:         final int networkTTL = configuration.getNetworkTTL();
1:         if (data.getClass() == ConsumerInfo.class) {
0:             ConsumerInfo info = (ConsumerInfo)data;
1:             BrokerId[] path = info.getBrokerPath();
0:             if ((path != null && path.length >= networkTTL)) {
0:                 if (log.isDebugEnabled())
0:                     log.debug(configuration.getBrokerName() + " Ignoring Subscription " + info + " restricted to " + networkTTL + " network hops only");
0:             if (contains(info.getBrokerPath(), localBrokerPath[0])) {
0:                 // Ignore this consumer as it's a consumer we locally sent to
0:                 // the broker.
0:                 if (log.isDebugEnabled())
0:                     log.debug(configuration.getBrokerName() + " Ignoring sub " + info + " already routed through this broker once");
1:             if (!isPermissableDestination(info.getDestination())) {
0:                 if (log.isDebugEnabled())
0:                     log.debug(configuration.getBrokerName() + " Ignoring sub " + info + " destination " + info.getDestination() + " is not permiited");
0:             if (addConsumerInfo(info)) {
0:                 if (log.isDebugEnabled())
0:                     log.debug(configuration.getBrokerName() + " Forwarding sub on " + localBroker + " from " + remoteBrokerName + " :  " + info);
0:             } else {
0:                 if (log.isDebugEnabled())
0:                     log.debug(configuration.getBrokerName() + " Ignoring sub " + info + " already subscribed to matching destination");
1:         } else if (data.getClass() == DestinationInfo.class) {
0:             DestinationInfo destInfo = (DestinationInfo)data;
1:             BrokerId[] path = destInfo.getBrokerPath();
0:             if ((path != null && path.length >= networkTTL)) {
0:                 if (log.isDebugEnabled())
0:                     log.debug("Ignoring Subscription " + destInfo + " restricted to " + networkTTL + " network hops only");
1:             if (contains(destInfo.getBrokerPath(), localBrokerPath[0])) {
0:                 // Ignore this consumer as it's a consumer we locally sent to
0:                 // the broker.
0:                 if (log.isDebugEnabled())
0:                     log.debug("Ignoring sub " + destInfo + " already routed through this broker once");
1:             if (destInfo.getDestination() instanceof ActiveMQTempDestination) {
0:                 ActiveMQTempDestination tempDest = (ActiveMQTempDestination)destInfo.getDestination();
1:             destInfo.setBrokerPath(appendToBrokerPath(destInfo.getBrokerPath(), getRemoteBrokerPath()));
0:             log.debug("Replying destination control command: " + destInfo);
1:         } else if (data.getClass() == RemoveInfo.class) {
0:             ConsumerId id = (ConsumerId)((RemoveInfo)data).getObjectId();
1:     public void serviceLocalException(Throwable error) {
0:         if (!disposed) {
0:             log.info("Network connection between " + localBroker + " and " + remoteBroker + " shutdown due to a local error: " + error);
0:             log.debug("The local Exception was:" + error, error);
0:             new Thread() {
0:                 public void run() {
/////////////////////////////////////////////////////////////////////////
1:         if (sub != null) {
1:         if (sub != null) {
0:         return (DemandSubscription)subscriptionMapByLocalId.get(md.getConsumerId());
1:         Message message = md.getMessage().copy();
1:         message.setBrokerPath(appendToBrokerPath(message.getBrokerPath(), localBrokerPath));
0:         if (message.getOriginalTransactionId() == null)
0:         if (!disposed) {
0:             final boolean trace = log.isTraceEnabled();
0:             try {
1:                 if (command.isMessageDispatch()) {
0:                     enqueueCounter.incrementAndGet();
0:                     final MessageDispatch md = (MessageDispatch)command;
0:                     DemandSubscription sub = (DemandSubscription)subscriptionMapByLocalId.get(md.getConsumerId());
1:                     if (sub != null) {
1:                         Message message = configureMessage(md);
0:                         if (trace)
0:                             log.trace("bridging " + configuration.getBrokerName() + " -> " + remoteBrokerName + ": " + message);
0: 
0:                         if (!message.isResponseRequired()) {
0: 
0:                             // If the message was originally sent using async
0:                             // send, we will preserve that QOS
0:                             // by bridging it using an async send (small chance
0:                             // of message loss).
0:                             localBroker.oneway(new MessageAck(md, MessageAck.STANDARD_ACK_TYPE, 1));
0: 
0: 
0:                             // The message was not sent using async send, so we
0:                             // should only ack the local
0:                             // broker when we get confirmation that the remote
0:                             // broker has received the message.
0:                                         if (response.isException()) {
0:                                             ExceptionResponse er = (ExceptionResponse)response;
0:                                             localBroker.oneway(new MessageAck(md, MessageAck.STANDARD_ACK_TYPE, 1));
/////////////////////////////////////////////////////////////////////////
0: 
0:                     } else {
0:                         if (trace)
0:                             log.trace("No subscription registered with this network bridge for consumerId " + md.getConsumerId() + " for message: " + md.getMessage());
0:                     }
1:                 } else if (command.isBrokerInfo()) {
0:                     localBrokerInfo = ((BrokerInfo)command);
1:                 } else if (command.isShutdownInfo()) {
0:                     log.info(configuration.getBrokerName() + " Shutting down");
0:                     // Don't shut down the whole connector if the remote side
0:                     // was interrupted.
0:                     // the local transport is just shutting down temporarily
0:                     // until the remote side
0:                     if (!remoteInterupted.get()) {
1:                 } else if (command.getClass() == ConnectionError.class) {
0:                     ConnectionError ce = (ConnectionError)command;
1:                     serviceLocalException(ce.getException());
0:                 } else {
1:                     switch (command.getDataStructureType()) {
0:                         log.warn("Unexpected local command: " + command);
0:             } catch (Exception e) {
/////////////////////////////////////////////////////////////////////////
0:      * @param dynamicallyIncludedDestinations The
0:      *                dynamicallyIncludedDestinations to set.
0:         this.dynamicallyIncludedDestinations = dynamicallyIncludedDestinations;
/////////////////////////////////////////////////////////////////////////
0:         this.excludedDestinations = excludedDestinations;
/////////////////////////////////////////////////////////////////////////
0:      * @param staticallyIncludedDestinations The staticallyIncludedDestinations
0:      *                to set.
0:         this.staticallyIncludedDestinations = staticallyIncludedDestinations;
/////////////////////////////////////////////////////////////////////////
0:         this.durableDestinations = durableDestinations;
/////////////////////////////////////////////////////////////////////////
0: 
0:     public boolean isCreatedByDuplex() {
0: 
0:     public void setCreatedByDuplex(boolean createdByDuplex) {
0:         this.createdByDuplex = createdByDuplex;
0: 
1:         if (brokerPath != null) {
0:             for (int i = 0; i < brokerPath.length; i++) {
0:                 if (brokerId.equals(brokerPath[i]))
/////////////////////////////////////////////////////////////////////////
0:             return new BrokerId[] {idToAppend};
/////////////////////////////////////////////////////////////////////////
0:         // Are we not bridging temp destinations?
0:         if (destination.isTemporary() && !configuration.isBridgeTempDestinations()) {
1:             return false;
0: 
0:         DestinationFilter filter = DestinationFilter.parseFilter(destination);
0:         if (dests != null && dests.length > 0) {
0:             for (int i = 0; i < dests.length; i++) {
0:                 ActiveMQDestination match = dests[i];
0:                 if (match != null && filter.matches(match)) {
0:         if (dests != null && dests.length > 0) {
0:             for (int i = 0; i < dests.length; i++) {
0:                 ActiveMQDestination match = dests[i];
0:                 if (match != null && filter.matches(match)) {
0:         }
1:         if (dests != null) {
0:             for (int i = 0; i < dests.length; i++) {
0:                 ActiveMQDestination dest = dests[i];
0:                 try {
0:                 } catch (IOException e) {
0:                     log.error("Failed to add static destination " + dest, e);
0:                 if (log.isTraceEnabled())
0:             }
0: 
1:         ConsumerInfo info = consumerInfo.copy();
1:         DemandSubscription sub = createDemandSubscription(info);
1:         if (sub != null) {
/////////////////////////////////////////////////////////////////////////
1:         DemandSubscription result = new DemandSubscription(info);
1:         result.getLocalInfo().setConsumerId(new ConsumerId(localSessionInfo.getSessionId(), consumerIdGenerator.getNextSequenceId()));
1:             // reset the local connection Id
0: 
0: 
1:         if (configuration.isDecreaseNetworkConsumerPriority()) {
0:             byte priority = ConsumerInfo.NETWORK_CONSUMER_PRIORITY;
0:             if (priority > Byte.MIN_VALUE && info.getBrokerPath() != null && info.getBrokerPath().length > 1) {
0:                 // The longer the path to the consumer, the less it's consumer
0:                 // priority.
0:                 priority -= info.getBrokerPath().length + 1;
/////////////////////////////////////////////////////////////////////////
0:         // the remote info held by the DemandSubscription holds the original
0:         // consumerId,
0:         // the local info get's overwritten
1:         info.setConsumerId(new ConsumerId(localSessionInfo.getSessionId(), consumerIdGenerator.getNextSequenceId()));
0:         DemandSubscription result = new DemandSubscription(info);
/////////////////////////////////////////////////////////////////////////
1:         subscriptionMapByLocalId.put(sub.getLocalInfo().getConsumerId(), sub);
1:         subscriptionMapByRemoteId.put(sub.getRemoteInfo().getConsumerId(), sub);
0: 
0:         DemandSubscription sub = (DemandSubscription)subscriptionMapByRemoteId.remove(id);
0:         if (sub != null) {
0:             if (log.isTraceEnabled())
0:                 log.trace("removing sub on " + localBroker + " from " + remoteBrokerName + " :  " + sub.getRemoteInfo());
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:     public void setNetworkBridgeListener(NetworkBridgeListener listener) {
1:         this.networkBridgeListener = listener;
0:     }
0:     private void fireBridgeFailed() {
0:         NetworkBridgeListener l = this.networkBridgeListener;
0:         if (l != null) {
1:             l.bridgeFailed();
0:         }
0:     }
0: 
1:     public String getRemoteAddress() {
1:         return remoteBroker.getRemoteAddress();
0:     }
0: 
1:     public String getLocalAddress() {
1:         return localBroker.getRemoteAddress();
0:     }
0: 
1:     public String getRemoteBrokerName() {
1:         return remoteBrokerInfo == null ? null : remoteBrokerInfo.getBrokerName();
0:     }
0: 
1:     public String getLocalBrokerName() {
1:         return localBrokerInfo == null ? null : localBrokerInfo.getBrokerName();
0:     }
0: 
1:     public long getDequeueCounter() {
0:         return dequeueCounter.get();
0:     }
0: 
1:     public long getEnqueueCounter() {
0:         return enqueueCounter.get();
0:     }
commit:76b2a3e
/////////////////////////////////////////////////////////////////////////
0:                 
0: 				// Release the started Latch since another thread could be stuck waiting for it to start up.
1: 				startedLatch.countDown();
1: 				startedLatch.countDown();
0: 
commit:ec6e6a5
/////////////////////////////////////////////////////////////////////////
0: import java.security.GeneralSecurityException;
0: import java.util.Properties;
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.atomic.AtomicBoolean;
0: import java.util.concurrent.atomic.AtomicLong;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private NetworkBridgeListener networkBridgeListener;
0:     private BrokerInfo localBrokerInfo;
0:     private BrokerInfo remoteBrokerInfo;
0: 
0:     final AtomicLong enqueueCounter = new AtomicLong();
0:     final AtomicLong dequeueCounter = new AtomicLong();
/////////////////////////////////////////////////////////////////////////
0:         
0:         NetworkBridgeListener l = this.networkBridgeListener;
0:         if (l!=null) {
0:             l.onStart(this);
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0:             NetworkBridgeListener l = this.networkBridgeListener;
0:             if (l!=null) {
0:                 l.onStop(this);
0:             }
0: 
/////////////////////////////////////////////////////////////////////////
0:                         remoteBrokerInfo = ((BrokerInfo)command);
0: 
/////////////////////////////////////////////////////////////////////////
0:                 	enqueueCounter.incrementAndGet();
/////////////////////////////////////////////////////////////////////////
0:                             dequeueCounter.incrementAndGet();
/////////////////////////////////////////////////////////////////////////
0:                                             dequeueCounter.incrementAndGet();
/////////////////////////////////////////////////////////////////////////
0:                 	localBrokerInfo = ((BrokerInfo)command);
/////////////////////////////////////////////////////////////////////////
0:     public void setNetworkBridgeListener(NetworkBridgeListener listener){
0:         this.networkBridgeListener=listener;  
0:           NetworkBridgeListener l = this.networkBridgeListener;
0: 
0: 	public String getRemoteAddress() {
0:  		return remoteBroker.getRemoteAddress();
0:  	}
0:  
0:  	public String getLocalAddress() {
0:  		return localBroker.getRemoteAddress();
0:  	}
0:  
0:  	public String getRemoteBrokerName() {
0:  		return remoteBrokerInfo == null ? null : remoteBrokerInfo.getBrokerName();
0:  	}
0:  	
0: 	public String getLocalBrokerName() {
0:  		return localBrokerInfo == null ? null : localBrokerInfo.getBrokerName();
0: 	}
0: 
0:  	public long getDequeueCounter() {
0:  		return dequeueCounter.get();
0:  	}
0:  
0:  	public long getEnqueueCounter() {
0:  		return enqueueCounter.get();
0: 	}
0: 
commit:a0e92d7
/////////////////////////////////////////////////////////////////////////
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.atomic.AtomicBoolean;
commit:9ca56a0
/////////////////////////////////////////////////////////////////////////
0:             public void onCommand(Object o){
1:             	Command command = (Command) o;
/////////////////////////////////////////////////////////////////////////
0:             public void onCommand(Object o){
1:             	Command command = (Command) o;
commit:b75a6da
/////////////////////////////////////////////////////////////////////////
0:     protected boolean bridgeTempDestinations = true;
/////////////////////////////////////////////////////////////////////////
0:                 String advisoryTopic = AdvisorySupport.CONSUMER_ADVISORY_TOPIC_PREFIX+destinationFilter;
0:                 	advisoryTopic += ","+AdvisorySupport.TEMP_DESTINATION_COMPOSITE_ADVISORY_TOPIC;
0:                 demandConsumerInfo.setDestination(new ActiveMQTopic(advisoryTopic));
0:                 demandConsumerInfo.setPrefetchSize(prefetchSize);
0:                 remoteBroker.oneway(demandConsumerInfo);                
commit:6a12e9c
/////////////////////////////////////////////////////////////////////////
0:     protected boolean bridgeTempDestinations = false;
/////////////////////////////////////////////////////////////////////////
0:         		        		
/////////////////////////////////////////////////////////////////////////
0:                 
0:                 if( bridgeTempDestinations ) {
0: 	                //we want information about Destinations as well
0: 	                ConsumerInfo destinationInfo  = new ConsumerInfo(remoteSessionInfo,2);
0: 	                destinationInfo.setDestination(AdvisorySupport.TEMP_DESTINATION_COMPOSITE_ADVISORY_TOPIC);
0: 	                destinationInfo.setPrefetchSize(prefetchSize);
0: 	                destinationInfo.setDispatchAsync(dispatchAsync);
0: 	                remoteBroker.oneway(destinationInfo);
0:                 }
0:                 
/////////////////////////////////////////////////////////////////////////
0:     	
0:     	// Are we not bridging temp destinations?
0:     	if( destination.isTemporary() && !bridgeTempDestinations )
0:     		return false;
0:     	
/////////////////////////////////////////////////////////////////////////
0: 	public boolean isBridgeTempDestinations() {
0: 		return bridgeTempDestinations;
0: 	}
0: 
0: 	public void setBridgeTempDestinations(boolean bridgeTempDestinations) {
0: 		this.bridgeTempDestinations = bridgeTempDestinations;
0: 	}
0: 
commit:58d4605
/////////////////////////////////////////////////////////////////////////
0:     protected CountDownLatch remoteBrokerNameKnownLatch = new CountDownLatch(1);
/////////////////////////////////////////////////////////////////////////
0:             	
0:         		remoteBrokerNameKnownLatch.await();
0: 
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:ad2546f
/////////////////////////////////////////////////////////////////////////
0:     protected final IdGenerator idGenerator = new IdGenerator();
1:     protected final LongSequenceGenerator consumerIdGenerator = new LongSequenceGenerator();
0:     protected String localBrokerName = "Unknown";
1:     protected String remoteBrokerName = "Unknown";
/////////////////////////////////////////////////////////////////////////
1:     protected final AtomicBoolean localBridgeStarted = new AtomicBoolean(false);
1:     protected final AtomicBoolean remoteBridgeStarted = new AtomicBoolean(false);
0:     protected final ConcurrentHashMap subscriptionMapByLocalId = new ConcurrentHashMap();
0:     protected final ConcurrentHashMap subscriptionMapByRemoteId = new ConcurrentHashMap();
1:     protected final AtomicBoolean lastConnectSucceeded = new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             public void transportInterupted(){
0:                 	
0:                     log.debug("Outbound transport to " + remoteBrokerName + " interrupted.");                                        
0: 
0:                 	if( localBridgeStarted.get() ) {
0: 	                    clearDownSubscriptions();
0: 	                    synchronized( DemandForwardingBridgeSupport.this ) {
0: 		                    try{
0: 		                        localBroker.oneway(localConnectionInfo.createRemoveCommand());
0: 		                    }catch(IOException e){
0: 		                        log.warn("Caught exception from local start",e);
0: 		                    }
0: 	                    }
0:                 	}
0:                 	
/////////////////////////////////////////////////////////////////////////
0:             public void transportResumed(){                
0:                 	
0:                 	// We want to slow down false connects so that we don't get in a busy loop.
0:                 	// False connects can occurr if you using SSH tunnels.
0:                 	if( !lastConnectSucceeded.get() ) {
0:                 		try {
0:                             log.debug("Previous connection was never fully established. Sleeping for second to avoid busy loop.");                                        
0: 							Thread.sleep(1000);
0: 						} catch (InterruptedException e) {
0: 							Thread.currentThread().interrupt();
0: 						}
0:                 	}
0:                     lastConnectSucceeded.set(false);
0: 
0:                     log.debug("Outbound transport to " + remoteBrokerName + " resumed");                                        
0:         
0:         try{                    	
0:             triggerRemoteStartBridge();
0:         }catch(IOException e){
0:             log.warn("Caught exception from remote start",e);
0:         }
/////////////////////////////////////////////////////////////////////////
0:                     serviceLocalException(e);
/////////////////////////////////////////////////////////////////////////
1:                     serviceRemoteException(e);
/////////////////////////////////////////////////////////////////////////
0:             synchronized( this ) {
0: 	            localConnectionInfo=new ConnectionInfo();
0: 	            localConnectionInfo.setConnectionId(new ConnectionId(idGenerator.generateId()));
0: 	            localClientId="NC_"+remoteBrokerName+"_inbound"+name;
0: 	            localConnectionInfo.setClientId(localClientId);
0: 	            localConnectionInfo.setUserName(userName);
0: 	            localConnectionInfo.setPassword(password);
0: 	            localBroker.oneway(localConnectionInfo);
0: 	
0: 	            localSessionInfo=new SessionInfo(localConnectionInfo,1);
0: 	            localBroker.oneway(localSessionInfo);
0: 	            
0: 	            log.info("Network connection between "+localBroker+" and "+remoteBroker+"("+remoteBrokerName
0: 	                            +") has been established.");
0: 	            
0: 	            startedLatch.countDown();
0: 	            setupStaticDestinations();
0:             }
0:         if(remoteBridgeStarted.compareAndSet(false,true)) {
0:     
0:         	synchronized (this) {
0:         		
0:             	if( remoteConnectionInfo!=null ) {
1:             		remoteBroker.oneway(remoteConnectionInfo.createRemoveCommand());
0:             	}
0:             	
0:                 remoteConnectionInfo=new ConnectionInfo();
1:                 remoteConnectionInfo.setConnectionId(new ConnectionId(idGenerator.generateId()));
0:                 remoteConnectionInfo.setClientId("NC_"+localBrokerName+"_outbound"+name);
0:                 remoteConnectionInfo.setUserName(userName);
0:                 remoteConnectionInfo.setPassword(password);
1:                 remoteBroker.oneway(remoteConnectionInfo);
0:                 BrokerInfo brokerInfo=new BrokerInfo();
0:                 brokerInfo.setBrokerName(localBrokerName);
1:                 remoteBroker.oneway(brokerInfo);
0:                 SessionInfo remoteSessionInfo=new SessionInfo(remoteConnectionInfo,1);
1:                 remoteBroker.oneway(remoteSessionInfo);
0:                 producerInfo=new ProducerInfo(remoteSessionInfo,1);
1:                 producerInfo.setResponseRequired(false);
1:                 remoteBroker.oneway(producerInfo);
0:                 // Listen to consumer advisory messages on the remote broker to determine demand.
0:                 demandConsumerInfo=new ConsumerInfo(remoteSessionInfo,1);
0:                 demandConsumerInfo.setDispatchAsync(dispatchAsync);
0:                 demandConsumerInfo.setDestination(new ActiveMQTopic(AdvisorySupport.CONSUMER_ADVISORY_TOPIC_PREFIX
0:                                 +destinationFilter));
0:                 demandConsumerInfo.setPrefetchSize(prefetchSize);
0:                 remoteBroker.oneway(demandConsumerInfo);
0:                 //we want information about Destinations as well
0:                 ConsumerInfo destinationInfo  = new ConsumerInfo(remoteSessionInfo,2);
0:                 destinationInfo.setDestination(AdvisorySupport.TEMP_DESTINATION_COMPOSITE_ADVISORY_TOPIC);
0:                 destinationInfo.setPrefetchSize(prefetchSize);
0:                 remoteBroker.oneway(destinationInfo);
0:                 startedLatch.countDown();
0:                 
0:                 if (!disposed){
0:                     triggerLocalStartBridge();
0:                 }
0:         		
0:         	}
0:         if (!disposed) {
0: 			try {
0: 				disposed = true;
0: 
0: 				remoteBridgeStarted.set(false);
0: 				
0: 				localBroker.oneway(new ShutdownInfo());
0: 				remoteBroker.oneway(new ShutdownInfo());
0: 				
0: 			} catch (IOException e) {
0: 				log.debug("Caught exception stopping", e);
0: 			} finally {
0: 				ServiceStopper ss = new ServiceStopper();
0: 				ss.stop(localBroker);
0: 				ss.stop(remoteBroker);
0: 				ss.throwFirstException();
0: 			}
0: 		}
0:     	if( !disposed ) {
0: 	        log.info("Network connection between "+localBroker+" and "+remoteBroker+" shutdown due to a remote error: "+error);
0: 	        log.debug("The remote Exception was: "+error, error);
0: 	        new Thread() {
0: 	        	public void run() {
0: 	                ServiceSupport.dispose(DemandForwardingBridgeSupport.this);
0: 	        	}
0: 	        }.start();
0:     	}
/////////////////////////////////////////////////////////////////////////
0:                 	
0:                 	lastConnectSucceeded.set(true);
0:                 	serviceRemoteBrokerInfo(command);
0:                     
/////////////////////////////////////////////////////////////////////////
0:                     case ShutdownInfo.DATA_STRUCTURE_TYPE:
/////////////////////////////////////////////////////////////////////////
0:                         
0:             
0:             log.debug("Replying destination control command: "+destInfo);            
/////////////////////////////////////////////////////////////////////////
0:     	if( !disposed ) {
0: 	        log.info("Network connection between "+localBroker+" and "+remoteBroker+" shutdown due to a local error: "+error);
0: 	        log.debug("The local Exception was:"+error,error);
0: 	        new Thread() {
0: 	        	public void run() {
0: 	                ServiceSupport.dispose(DemandForwardingBridgeSupport.this);
0: 	        	}
0: 	        }.start();
0:     	}
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                         stop();
/////////////////////////////////////////////////////////////////////////
0:   
/////////////////////////////////////////////////////////////////////////
0:         subscriptionMapByLocalId.clear();
0:         subscriptionMapByRemoteId.clear();
commit:16d403f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ConnectionError;
/////////////////////////////////////////////////////////////////////////
0:     protected void serviceRemoteException(Throwable error) {
/////////////////////////////////////////////////////////////////////////
0:                 }else if(command.getClass() == ConnectionError.class ) {
1:                 	ConnectionError ce = (ConnectionError) command;
1:                 	serviceRemoteException(ce.getException());
/////////////////////////////////////////////////////////////////////////
0:                 }else if(command.getClass() == ConnectionError.class ) {
1:                 	ConnectionError ce = (ConnectionError) command;
0:                 	serviceLocalException(ce.getException());                    
commit:c2a5111
/////////////////////////////////////////////////////////////////////////
0:                 if(log.isDebugEnabled())
0:                     log.debug("Ignoring Subscription " + info + " restricted to " + networkTTL + " network hops only");
0:                 if(log.isDebugEnabled())
0:                     log.debug("Ignoring sub " + info + " already routed through this broker once");
0:                 if(log.isDebugEnabled())
0:                     log.debug("Ignoring sub " + info + " destination " + info.getDestination() + " is not permiited");
/////////////////////////////////////////////////////////////////////////
0:                 if(log.isDebugEnabled())
0:                     log.debug("Forwarding sub on "+localBroker+" from "+remoteBrokerName+" :  "+info);
0:                 if(log.isDebugEnabled())
0:                     log.debug("Ignoring sub " + info + " already subscribed to matching destination");
/////////////////////////////////////////////////////////////////////////
0:                 if(log.isDebugEnabled())
0:                     log.debug("Ignoring Subscription " + destInfo + " restricted to " + networkTTL + " network hops only");
0:                 if(log.isDebugEnabled())
0:                     log.debug("Ignoring sub " + destInfo + " already routed through this broker once");
commit:7dafbb5
/////////////////////////////////////////////////////////////////////////
0:                         localBroker.oneway(localConnectionInfo.createRemoveCommand());
commit:14fda24
/////////////////////////////////////////////////////////////////////////
0:     protected final AtomicBoolean remoteInterupted = new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
0:                 if( remoteInterupted.compareAndSet(false, true) ) {
0:                     log.warn("Outbound transport to " + remoteBrokerName +  " interrupted ...");
0:                     clearDownSubscriptions();
0:                     try{
0:                         localBroker.oneway(remoteConnectionInfo.createRemoveCommand());
0:                     }catch(IOException e){
0:                         log.warn("Caught exception from local start",e);
0:                     }
0:                     localBridgeStarted.set(false);
0:                     remoteBridgeStarted.set(false);
0:                     startedLatch = new CountDownLatch(2);
0:                 
0:                 if( remoteInterupted.compareAndSet(true, false) ) {
0:                     
0:                     //restart and static subscriptions - the consumer advisories will be replayed
0:                     log.info("Outbound transport to " + remoteBrokerName + " resumed");
0:                     
0: //                    try{
0: //                        triggerLocalStartBridge();
0: //                    }catch(IOException e){
0: //                        log.warn("Caught exception from local start",e);
0: //                    }
0:     
0:                     try{
0:                         // clear out the previous connection as it may have missed some consumer advisories.
0:                         remoteBroker.oneway(remoteConnectionInfo.createRemoveCommand());
0:                         triggerRemoteStartBridge();
0:                     }catch(IOException e){
0:                         log.warn("Caught exception from remote start",e);
0:                     }
0:                     
0:                 }
0: //        triggerLocalStartBridge();
/////////////////////////////////////////////////////////////////////////
0:                 }catch(Exception e){
/////////////////////////////////////////////////////////////////////////
0:                 }catch(Exception e){
/////////////////////////////////////////////////////////////////////////
0:     protected void startLocalBridge() throws Exception {
0:             
/////////////////////////////////////////////////////////////////////////
0:     protected void startRemoteBridge() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:             //we want information about Destinations as well
/////////////////////////////////////////////////////////////////////////
0:             localBridgeStarted.set(false);
/////////////////////////////////////////////////////////////////////////
0:                     // Don't shut down the whole connector if the remote side was interrupted.
0:                     // the local transport is just shutting down temporarily until the remote side
0:                     // is restored.
0:                     if( !remoteInterupted.get() ) { 
0:                         shutDown = true;
0:                         doStop();
0:                     }
commit:4009fda
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
0: import edu.emory.mathcs.backport.java.util.concurrent.CountDownLatch;
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean;
commit:84fd773
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transport.FutureResponse;
0: import org.apache.activemq.transport.ResponseCallback;
/////////////////////////////////////////////////////////////////////////
0:                     final MessageDispatch md=(MessageDispatch) command;
0:                         
0:                         
0:                         if( !message.isResponseRequired() ) {
0:                             
0:                             // If the message was originally sent using async send, we will preserve that QOS
0:                             // by bridging it using an async send (small chance of message loss).
0:                             localBroker.oneway(new MessageAck(md,MessageAck.STANDARD_ACK_TYPE,1));
0:                             
0:                         } else {
0:                             
0:                             // The message was not sent using async send, so we should only ack the local 
0:                             // broker when we get confirmation that the remote broker has received the message.
0:                             ResponseCallback callback = new ResponseCallback() {
0:                                 public void onCompletion(FutureResponse future) {
0:                                     try {
0:                                         Response response = future.getResult();
0:                                         if(response.isException()){
0:                                             ExceptionResponse er=(ExceptionResponse) response;
0:                                             serviceLocalException(er.getException());
0:                                         } else {
0:                                             localBroker.oneway(new MessageAck(md,MessageAck.STANDARD_ACK_TYPE,1));
0:                                         }
0:                                     } catch (IOException e) {
0:                                         serviceLocalException(e);
0:                                     }
0:                                 }
0:                             };
0: 
0:                             remoteBroker.asyncRequest(message, callback);
0:                        
commit:7ae0081
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.KeepAliveInfo;
/////////////////////////////////////////////////////////////////////////
0:                     case KeepAliveInfo.DATA_STRUCTURE_TYPE:
commit:6a89f08
/////////////////////////////////////////////////////////////////////////
0:                         
0:                       // Ack on every message since we don't know if the broker is blocked due to memory
0:                       // usage and is waiting for an Ack to un-block him. 
0:                       localBroker.oneway(new MessageAck(md,MessageAck.STANDARD_ACK_TYPE,1));
0: 
0:                       // Acking a range is more efficient, but also more prone to locking up a server
0:                       // Perhaps doing something like the following should be policy based.
0: //                        int dispatched = sub.incrementDispatched();
0: //                        if(dispatched>(sub.getLocalInfo().getPrefetchSize()*.75)){
0: //                            localBroker.oneway(new MessageAck(md,MessageAck.STANDARD_ACK_TYPE,dispatched));
0: //                            sub.setDispatched(0);
0: //                        }
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:6c1676b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
1:             if (brokerService == null) {
1:                 throw new IllegalArgumentException("BrokerService is null on " + this);
0:             }
/////////////////////////////////////////////////////////////////////////
1:         brokerService.getTaskRunnerFactory().execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
1:         brokerService.getTaskRunnerFactory().execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
0: 
1:                     brokerService.getTaskRunnerFactory().execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
0:                     }, "ActiveMQ ForwardingBridge StopTask");
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             brokerService.getTaskRunnerFactory().execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
0:             brokerService.getTaskRunnerFactory().execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
0:             brokerService.getTaskRunnerFactory().execute(new Runnable() {
commit:0b01996
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private TaskRunnerFactory asyncTaskRunner;
/////////////////////////////////////////////////////////////////////////
0:             asyncTaskRunner = new TaskRunnerFactory("ActiveMQ ForwardingBridge Task");
0:             asyncTaskRunner.init();
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:                     // stop task runner
0:                     asyncTaskRunner.shutdown();
0:                     asyncTaskRunner = null;
author:Robert Davies
-------------------------------------------------------------------------------
commit:7dc2c4e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.Region;
0: import org.apache.activemq.command.*;
/////////////////////////////////////////////////////////////////////////
0:             getRegionSubscriptions(consumerInfo.getDestination());
/////////////////////////////////////////////////////////////////////////
0:     private final Collection<Subscription> getRegionSubscriptions(ActiveMQDestination dest) {
1:         RegionBroker region_broker = (RegionBroker) brokerService.getRegionBroker();
1:         Region region;
1:         Collection<Subscription> subs;
0: 
1:         region = null;
0:         switch ( dest.getDestinationType() )
0:         {
1:             case ActiveMQDestination.QUEUE_TYPE:
1:                 region = region_broker.getQueueRegion();
1:                 break;
0: 
1:             case ActiveMQDestination.TOPIC_TYPE:
1:                 region = region_broker.getTopicRegion();
1:                 break;
0: 
1:             case ActiveMQDestination.TEMP_QUEUE_TYPE:
1:                 region = region_broker.getTempQueueRegion();
1:                 break;
0: 
1:             case ActiveMQDestination.TEMP_TOPIC_TYPE:
1:                 region = region_broker.getTempTopicRegion();
1:                 break;
0:         }
0: 
0:         if ( region instanceof AbstractRegion )
1:             subs = ((AbstractRegion) region).getSubscriptions().values();
0:         else
1:             subs = null;
0: 
1:         return subs;
commit:f392884
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicBoolean started = new AtomicBoolean();
/////////////////////////////////////////////////////////////////////////
0:                 @Override
0:                 @Override
/////////////////////////////////////////////////////////////////////////
1:                     brokerInfo.setBrokerURL(configuration.getBrokerURL());
commit:25b2165
/////////////////////////////////////////////////////////////////////////
0:                         IntrospectionSupport.getProperties(configuration, props, null);
0:                         if (configuration.getExcludedDestinations() != null) {
0:                             excludedDestinations = configuration.getExcludedDestinations().toArray(
0:                                     new ActiveMQDestination[configuration.getExcludedDestinations().size()]);
0:                         }
0:                         if (configuration.getStaticallyIncludedDestinations() != null) {
0:                             staticallyIncludedDestinations = configuration.getStaticallyIncludedDestinations().toArray(
0:                                     new ActiveMQDestination[configuration.getStaticallyIncludedDestinations().size()]);
0:                         }
0:                         if (configuration.getDynamicallyIncludedDestinations() != null) {
0:                             dynamicallyIncludedDestinations = configuration.getDynamicallyIncludedDestinations()
0:                                     .toArray(
0:                                             new ActiveMQDestination[configuration.getDynamicallyIncludedDestinations()
0:                                                     .size()]);
0:                         }
0:                         LOG.error("Error mapping remote destinations", t);
/////////////////////////////////////////////////////////////////////////
0:         final DestinationFilter filter = DestinationFilter.parseFilter(destination);
0:         
0:                 DestinationFilter exclusionFilter = filter;
0:                 if (exclusionFilter instanceof org.apache.activemq.filter.SimpleDestinationFilter) {
0:                         exclusionFilter = newFilter;
0:                 if (match != null && exclusionFilter.matches(match) && dests[i].getDestinationType() == destination.getDestinationType()) {
/////////////////////////////////////////////////////////////////////////
0:                 DestinationFilter inclusionFilter = filter;
0:                 if (inclusionFilter instanceof org.apache.activemq.filter.SimpleDestinationFilter) {
0:                         inclusionFilter = newFilter;
0:                 if (match != null && inclusionFilter.matches(match) && dests[i].getDestinationType() == destination.getDestinationType()) {
commit:9c12a0c
/////////////////////////////////////////////////////////////////////////
0:                                 if (started.get()) {
0:                                     if (!addConsumerInfo((ConsumerInfo) command)) {
0:                                         if (LOG.isDebugEnabled()) {
0:                                             LOG.debug("Ignoring ConsumerInfo: "+ command);
0:                                         }
0:                                 } else {
0:                                     // received a subscription whilst stopping
0:                                     LOG.warn("Stopping - ignoring ConsumerInfo: "+ command);
commit:f4012c5
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.Service;
0: import org.apache.activemq.broker.TransportConnection;
/////////////////////////////////////////////////////////////////////////
1:     private TransportConnection duplexInitiatingConnection;
/////////////////////////////////////////////////////////////////////////
1:     public void duplexStart(TransportConnection connection, BrokerInfo localBrokerInfo, BrokerInfo remoteBrokerInfo) throws Exception {
1:         this.duplexInitiatingConnection = connection;
/////////////////////////////////////////////////////////////////////////
1:                     ServiceSupport.dispose(getControllingService());
/////////////////////////////////////////////////////////////////////////
1:                     ServiceSupport.dispose(getControllingService());
1:     protected Service getControllingService() {
1:         return duplexInitiatingConnection != null ? duplexInitiatingConnection : DemandForwardingBridgeSupport.this;
0:     }
0: 
commit:cdd4efa
/////////////////////////////////////////////////////////////////////////
0:     protected void serviceRemoteCommand(Command command) {    	      	
/////////////////////////////////////////////////////////////////////////
0:                     	
0:                     	  // See if this consumer's brokerPath tells us it came from the broker at the other end
0:                     	  // of the bridge. I think we should be making this decision based on the message's
0:                     	  // broker bread crumbs and not the consumer's? However, the message's broker bread
0:                     	  // crumbs are null, which is another matter.   
0:                     	  boolean cameFromRemote = false;
0:                         Object consumerInfo = md.getMessage().getDataStructure(); 
0:                         if( consumerInfo != null && (consumerInfo instanceof ConsumerInfo) )                  	                   	  
0:                     	    cameFromRemote = contains( ((ConsumerInfo)consumerInfo).getBrokerPath(),remoteBrokerInfo.getBrokerId());                    	                           
0:                                             	                     	
0:                             LOG.trace("cameFromRemote = "+cameFromRemote);    
/////////////////////////////////////////////////////////////////////////
0:                             
0:                             // Don't send it off to the remote if it originally came from the remote. 
0:                             if( !cameFromRemote ) {
0:                                remoteBroker.oneway(message);
0:                               }
0:                             else{
0:                               LOG.info("Message not forwarded on to remote, because message came from remote");                               
0:                             }
0:                             dequeueCounter.incrementAndGet();                          
commit:049ce28
/////////////////////////////////////////////////////////////////////////
1:                     brokerInfo.setBrokerId(this.localBrokerId);
commit:8248314
/////////////////////////////////////////////////////////////////////////
0:                     IntrospectionSupport.getProperties(configuration, props, null);
commit:4ba4853
/////////////////////////////////////////////////////////////////////////
0:                 if (filter instanceof org.apache.activemq.filter.SimpleDestinationFilter) {
0:                     DestinationFilter newFilter = DestinationFilter.parseFilter(match);
0:                     if (!(newFilter instanceof org.apache.activemq.filter.SimpleDestinationFilter)) {
0:                         filter = newFilter;
0:                         match = destination;
0:                     }
0:                 }
/////////////////////////////////////////////////////////////////////////
0:                 if (filter instanceof org.apache.activemq.filter.SimpleDestinationFilter) {
0:                     DestinationFilter newFilter = DestinationFilter.parseFilter(match);
0:                     if (!(newFilter instanceof org.apache.activemq.filter.SimpleDestinationFilter)) {
0:                         filter = newFilter;
0:                         match = destination;
0:                     }
0:                 }
commit:44e6f7d
/////////////////////////////////////////////////////////////////////////
0:             ASYNC_TASKS.execute(new Runnable() {
1:             });
/////////////////////////////////////////////////////////////////////////
0:             ASYNC_TASKS.execute(new Runnable() {
1:             });
commit:ec15e1c
/////////////////////////////////////////////////////////////////////////
0:         ASYNC_TASKS.execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
0:         });
commit:859397c
/////////////////////////////////////////////////////////////////////////
0:     private static final ThreadPoolExecutor ASYNC_TASKS;
/////////////////////////////////////////////////////////////////////////
0:         ASYNC_TASKS.execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
0:         });
/////////////////////////////////////////////////////////////////////////
0:                     ASYNC_TASKS.execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
0:         ASYNC_TASKS =   new ThreadPoolExecutor(0, Integer.MAX_VALUE, 30, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), new ThreadFactory() {
commit:5e03394
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.SynchronousQueue;
0: import java.util.concurrent.ThreadFactory;
0: import java.util.concurrent.ThreadPoolExecutor;
0: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
0:     private static final ThreadPoolExecutor STOP_TASKS;
/////////////////////////////////////////////////////////////////////////
0:     
/////////////////////////////////////////////////////////////////////////
0:                     final CountDownLatch sendShutdown = new CountDownLatch(1);
0:                     STOP_TASKS.execute(new Runnable() {
0:                         public void run() {
0:                             try {
0:                                 localBroker.oneway(new ShutdownInfo());
0:                                 remoteBroker.oneway(new ShutdownInfo());
0:                             } catch (Throwable e) {
0:                                 LOG.debug("Caught exception sending shutdown", e);
0:                             }finally {
0:                                 sendShutdown.countDown();
0:                             }
0:                             
0:                         }
0:                     });
0:                     if( !sendShutdown.await(100, TimeUnit.MILLISECONDS) ) {
0:                         LOG.debug("Network Could not shutdown in a timely manner");
0:                     }
/////////////////////////////////////////////////////////////////////////
0:                 LOG.warn("Caught an exception processing local command",e);
/////////////////////////////////////////////////////////////////////////
0:     
0:     static {
0:         STOP_TASKS =   new ThreadPoolExecutor(0, Integer.MAX_VALUE, 10, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), new ThreadFactory() {
0:             public Thread newThread(Runnable runnable) {
0:                 Thread thread = new Thread(runnable, "NetworkBridge: "+runnable);
0:                 thread.setDaemon(true);
0:                 return thread;
0:             }
0:         });
0:     }
commit:b32ff4d
/////////////////////////////////////////////////////////////////////////
0:     
0:         //add our original id to ourselves
1:         info.addNetworkConsumerId(info.getConsumerId());
0:     
/////////////////////////////////////////////////////////////////////////
0:     
commit:a9ccf56
/////////////////////////////////////////////////////////////////////////
0:                     if (sub != null && md.getMessage()!=null) {
commit:2a153b0
/////////////////////////////////////////////////////////////////////////
0:     final protected DemandSubscription createDemandSubscription(ActiveMQDestination destination){
0:        
1:         DemandSubscription result = null;
0:         try {
1:             result = createDemandSubscription(info);
0:         } catch (IOException e) {
0:            LOG.error("Failed to create DemandSubscription ",e);
0:         }
0:         if (result != null) {
0:             result.getLocalInfo().setPriority(ConsumerInfo.NETWORK_CONSUMER_PRIORITY);
0:         }
commit:3163d48
/////////////////////////////////////////////////////////////////////////
0:                     props.setProperty("networkTTL", String.valueOf(configuration.getNetworkTTL()));
commit:a32832f
/////////////////////////////////////////////////////////////////////////
0:                     if (isDuplex()) {
/////////////////////////////////////////////////////////////////////////
0:                         if (!message.isResponseRequired() || isDuplex()) {
/////////////////////////////////////////////////////////////////////////
0:     
1:     protected boolean isDuplex() {
1:         return configuration.isDuplex() || createdByDuplex;
0:     }
commit:a9119ec
/////////////////////////////////////////////////////////////////////////
0:     protected CountDownLatch localStartedLatch = new CountDownLatch(1);
/////////////////////////////////////////////////////////////////////////
0:                         localStartedLatch = new CountDownLatch(1);
/////////////////////////////////////////////////////////////////////////
1:                 localStartedLatch.countDown();
/////////////////////////////////////////////////////////////////////////
0:                     localStartedLatch.countDown();
/////////////////////////////////////////////////////////////////////////
0:                             	localStartedLatch.await();
/////////////////////////////////////////////////////////////////////////
0:             	e.printStackTrace();
/////////////////////////////////////////////////////////////////////////
0:                     //localStartedLatch.await();
/////////////////////////////////////////////////////////////////////////
0:             } catch (Throwable e) {
0:             	e.printStackTrace();
commit:35ba427
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ActiveMQMessage;
/////////////////////////////////////////////////////////////////////////
0:     private AtomicBoolean started = new AtomicBoolean();
0:     public void duplexStart(BrokerInfo localBrokerInfo,BrokerInfo remoteBrokerInfo) throws Exception{
0:         this.localBrokerInfo=localBrokerInfo;
0:         this.remoteBrokerInfo=remoteBrokerInfo;
1:         start();
1:         serviceRemoteCommand(remoteBrokerInfo);
0:     public void start() throws Exception{
0:         if(started.compareAndSet(false,true)){
0:             localBroker.setTransportListener(new DefaultTransportListener(){
0: 
0:                 public void onCommand(Object o){
0:                     Command command=(Command)o;
1:                     serviceLocalCommand(command);
0:                 }
0: 
0:                 public void onException(IOException error){
1:                     serviceLocalException(error);
0:                 }
0:             });
0:             remoteBroker.setTransportListener(new TransportListener(){
0: 
0:                 public void onCommand(Object o){
0:                     Command command=(Command)o;
1:                     serviceRemoteCommand(command);
0:                 }
0: 
0:                 public void onException(IOException error){
0:                     serviceRemoteException(error);
0:                 }
0: 
0:                 public void transportInterupted(){
0:                     // clear any subscriptions - to try and prevent the bridge from stalling the broker
0:                     if(remoteInterupted.compareAndSet(false,true)){
0:                         log.info("Outbound transport to "+remoteBrokerName+" interrupted.");
0:                         if(localBridgeStarted.get()){
0:                             clearDownSubscriptions();
0:                             synchronized(DemandForwardingBridgeSupport.this){
0:                                 try{
0:                                     localBroker.oneway(localConnectionInfo.createRemoveCommand());
0:                                 }catch(TransportDisposedIOException td){
0:                                     log.debug("local broker is now disposed",td);
0:                                 }catch(IOException e){
0:                                     log.warn("Caught exception from local start",e);
0:                                 }
0:                             }
0:                         }
0:                         localBridgeStarted.set(false);
0:                         remoteBridgeStarted.set(false);
0:                         startedLatch=new CountDownLatch(2);
0:                     }
0:                 }
0: 
0:                 public void transportResumed(){
0:                     if(remoteInterupted.compareAndSet(true,false)){
0:                         // We want to slow down false connects so that we don't get in a busy loop.
0:                         // False connects can occurr if you using SSH tunnels.
0:                         if(!lastConnectSucceeded.get()){
0:                             try{
0:                                 log
0:                                         .debug("Previous connection was never fully established. Sleeping for second to avoid busy loop.");
0:                                 Thread.sleep(1000);
0:                             }catch(InterruptedException e){
0:                                 Thread.currentThread().interrupt();
0:                             }
0:                         }
0:                         lastConnectSucceeded.set(false);
0:                         try{
0:                             startLocalBridge();
0:                             remoteBridgeStarted.set(true);
0:                             startedLatch.countDown();
0:                             log.info("Outbound transport to "+remoteBrokerName+" resumed");
0:                         }catch(Exception e){
0:                             log.error("Caught exception  from local start in resume transport",e);
0:                         }
0:                     }
0:                 }
0:             });
0: 
0:             localBroker.start();
1:             remoteBroker.start();
0:             try{
0:                 triggerRemoteStartBridge();
0:             }catch(IOException e){
0:                 log.warn("Caught exception from remote start",e);
0:             }
0:             NetworkBridgeListener l=this.networkBridgeListener;
0:             if(l!=null){
0:                 l.onStart(this);
0:             }
0:         }
0:     }
0:     
/////////////////////////////////////////////////////////////////////////
0:     protected void startRemoteBridge() throws Exception{
0:         if(remoteBridgeStarted.compareAndSet(false,true)){
0:             synchronized(this){
0:                 if(isCreatedByDuplex()==false){
0:                     BrokerInfo brokerInfo=new BrokerInfo();
1:                     brokerInfo.setBrokerName(configuration.getBrokerName());
1:                     brokerInfo.setNetworkConnection(true);
1:                     brokerInfo.setDuplexConnection(configuration.isDuplex());
1:                     // set our properties
0:                     Properties props=new Properties();
0:                     IntrospectionSupport.getProperties(this,props,null);
0:                     String str=MarshallingSupport.propertiesToString(props);
1:                     brokerInfo.setNetworkProperties(str);
0:                     remoteBroker.oneway(brokerInfo);
0:                 }
0:                 if(remoteConnectionInfo!=null){
0:                     remoteBroker.oneway(remoteConnectionInfo.createRemoveCommand());
0:                 }
0:                 
0:                 String advisoryTopic=AdvisorySupport.CONSUMER_ADVISORY_TOPIC_PREFIX
0:                         +configuration.getDestinationFilter();
0:                 if(configuration.isBridgeTempDestinations()){
0:                     advisoryTopic+=","+AdvisorySupport.TEMP_DESTINATION_COMPOSITE_ADVISORY_TOPIC;
0:                 remoteBroker.oneway(demandConsumerInfo);
0:                 if(!disposed){
0:             }
0:         if(started.compareAndSet(true,false)){
0:             log.debug(" stopping "+configuration.getBrokerName()+" bridge to "+remoteBrokerName
0:                     +" is disposed already ? "+disposed);
0:             boolean wasDisposedAlready=disposed;
0:             if(!disposed){
0:                 NetworkBridgeListener l=this.networkBridgeListener;
0:                 if(l!=null){
0:                     l.onStop(this);
0:                 }
0:                 try{
0:                     disposed=true;
0:                     remoteBridgeStarted.set(false);
0:                     localBroker.oneway(new ShutdownInfo());
0:                     remoteBroker.oneway(new ShutdownInfo());
0:                 }catch(IOException e){
0:                     log.debug("Caught exception stopping",e);
0:                 }finally{
0:                     ServiceStopper ss=new ServiceStopper();
0:                     ss.stop(localBroker);
0:                     ss.stop(remoteBroker);
0:                     // Release the started Latch since another thread could be stuck waiting for it to start up.
0:                     startedLatch.countDown();
0:                     startedLatch.countDown();
0:                     ss.throwFirstException();
0:                 }
0:             if(wasDisposedAlready){
0:                 log.debug(configuration.getBrokerName()+" bridge to "+remoteBrokerName+" stopped");
0:             }else{
0:                 log.info(configuration.getBrokerName()+" bridge to "+remoteBrokerName+" stopped");
/////////////////////////////////////////////////////////////////////////
0:     protected void serviceRemoteCommand(Command command){
0:                     MessageDispatch md=(MessageDispatch)command;
/////////////////////////////////////////////////////////////////////////
0:                     lastConnectSucceeded.set(true);
0:                     remoteBrokerInfo=((BrokerInfo)command);
0:                     serviceRemoteBrokerInfo(command);
0:                     // Let the local broker know the remote broker's ID.
0:                     localBroker.oneway(command);
0:                 }else if(command.getClass()==ConnectionError.class){
0:                     ConnectionError ce=(ConnectionError)command;
0:                     serviceRemoteException(ce.getException());
0:                     if(configuration.isDuplex()||createdByDuplex){
0:                         if(command.isMessage()){
0:                             ActiveMQMessage message=(ActiveMQMessage)command;
0:                             if(AdvisorySupport.isConsumerAdvisoryTopic(message.getDestination())){
1:                                 serviceRemoteConsumerAdvisory(message.getDataStructure());
0:                             }else{
0:                                 localBroker.oneway(message);
0:                             }
0:                         }else{
0:                             switch(command.getDataStructureType()){
0:                             case ConnectionInfo.DATA_STRUCTURE_TYPE:
0:                             case SessionInfo.DATA_STRUCTURE_TYPE:
0:                             case ProducerInfo.DATA_STRUCTURE_TYPE:
0:                                 localBroker.oneway(command);
0:                                 break;
0:                             case ConsumerInfo.DATA_STRUCTURE_TYPE:
0:                                 if(!addConsumerInfo((ConsumerInfo)command)){
0:                                     if(log.isDebugEnabled())
0:                                         log.debug("Ignoring ConsumerInfo: "+command);
0:                                 }
0:                                 break;
0:                             default:
0:                                 if(log.isDebugEnabled())
0:                                     log.debug("Ignoring remote command: "+command);
0:                             }
0:                         }
0:                     }else{
0:                         switch(command.getDataStructureType()){
0:                         case KeepAliveInfo.DATA_STRUCTURE_TYPE:
0:                         case WireFormatInfo.DATA_STRUCTURE_TYPE:
0:                         case ShutdownInfo.DATA_STRUCTURE_TYPE:
0:                             break;
0:                         default:
0:                             log.warn("Unexpected remote command: "+command);
0:                         }
0:             }catch(Throwable e){
0:     private void serviceRemoteConsumerAdvisory(DataStructure data) throws IOException{
0:         final int networkTTL=configuration.getNetworkTTL();
0:             ConsumerInfo info=(ConsumerInfo)data;
0:             if((path!=null&&path.length>=networkTTL)){
0:                     log.debug(configuration.getBrokerName()+" Ignoring Subscription "+info+" restricted to "+networkTTL
0:                             +" network hops only");
0:                     log.debug(configuration.getBrokerName()+" Ignoring sub "+info
0:                             +" already routed through this broker once");
0:             if(!isPermissableDestination(info.getDestination())){
0:                 // ignore if not in the permited or in the excluded list
0:                     log.debug(configuration.getBrokerName()+" Ignoring sub "+info+" destination "+info.getDestination()
0:                             +" is not permiited");
0:             if(addConsumerInfo(info)){
0:                     log.debug(configuration.getBrokerName()+" Forwarding sub on "+localBroker+" from "+remoteBrokerName
0:                             +" :  "+info);
0:             }else{
0:                     log.debug(configuration.getBrokerName()+" Ignoring sub "+info
0:                             +" already subscribed to matching destination");
0:         }else if(data.getClass()==DestinationInfo.class){
0:             // It's a destination info - we want to pass up
0:             // infomation about temporary destinations
0:             DestinationInfo destInfo=(DestinationInfo)data;
0:             if((path!=null&&path.length>=networkTTL)){
0:                     log.debug("Ignoring Subscription "+destInfo+" restricted to "+networkTTL+" network hops only");
0:                     log.debug("Ignoring sub "+destInfo+" already routed through this broker once");
0:             if(destInfo.getDestination() instanceof ActiveMQTempDestination){
1:                 // re-set connection id so comes from here
0:                 ActiveMQTempDestination tempDest=(ActiveMQTempDestination)destInfo.getDestination();
0:             log.debug("Replying destination control command: "+destInfo);
0:         }else if(data.getClass()==RemoveInfo.class){
0:             ConsumerId id=(ConsumerId)((RemoveInfo)data).getObjectId();
0:     public void serviceLocalException(Throwable error){
0:         if(!disposed){
0:             log.info("Network connection between "+localBroker+" and "+remoteBroker+" shutdown due to a local error: "
0:                     +error);
0:             log.debug("The local Exception was:"+error,error);
0:             new Thread(){
0: 
0:                 public void run(){
0:                     ServiceSupport.dispose(DemandForwardingBridgeSupport.this);
0:                 }
0:             }.start();
0:         }
/////////////////////////////////////////////////////////////////////////
0:         } 
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected boolean addConsumerInfo(final ConsumerInfo consumerInfo) throws IOException {
0:         boolean result = false;
0:         ConsumerInfo info=consumerInfo.copy();
1:         addRemoteBrokerToBrokerPath(info);
0:         DemandSubscription sub=createDemandSubscription(info);
0:         if (sub != null){
0:             addSubscription(sub);
0:             result = true;
0:         }
1:         return result;
0:     }
/////////////////////////////////////////////////////////////////////////
1:         if (info.getDestination().isTemporary()) {
0:             //reset the local connection Id
0:           
0:             ActiveMQTempDestination dest = (ActiveMQTempDestination)result.getLocalInfo().getDestination();
1:             dest.setConnectionId(localConnectionInfo.getConnectionId().toString());
0:         }
0:                 
/////////////////////////////////////////////////////////////////////////
0:     
commit:54114cc
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private boolean createdByDuplex;
/////////////////////////////////////////////////////////////////////////
0: 	            localClientId="NC_"+remoteBrokerName+"_inbound"+configuration.getBrokerName();
/////////////////////////////////////////////////////////////////////////
0:                 remoteConnectionInfo.setClientId("NC_"+configuration.getBrokerName()+"_outbound");
0:                 if (isCreatedByDuplex()==false) {
0:                 brokerInfo.setBrokerName(configuration.getBrokerName());
0:               
0:                 brokerInfo.setNetworkProperties(str);                
0:                 }
/////////////////////////////////////////////////////////////////////////
0:         log.debug(" stopping "+configuration.getBrokerName()+" bridge to "+remoteBrokerName+" is disposed already ? "+disposed);
/////////////////////////////////////////////////////////////////////////
0:             log.debug(configuration.getBrokerName()+" bridge to "+remoteBrokerName+" stopped");
0:             log.info(configuration.getBrokerName()+" bridge to "+remoteBrokerName+" stopped");
/////////////////////////////////////////////////////////////////////////
0:        
/////////////////////////////////////////////////////////////////////////
0:                     log.debug(configuration.getBrokerName() + " Ignoring Subscription " + info + " restricted to " + networkTTL + " network hops only");
0:                     log.debug(configuration.getBrokerName()  + " Ignoring sub " + info + " already routed through this broker once");
0:                     log.debug(configuration.getBrokerName()  + " Ignoring sub " + info + " destination " + info.getDestination() + " is not permiited");
/////////////////////////////////////////////////////////////////////////
0:                     log.debug(configuration.getBrokerName() + " Forwarding sub on "+localBroker+" from "+remoteBrokerName+" :  "+info);
0:                     log.debug(configuration.getBrokerName()  + " Ignoring sub " + info + " already subscribed to matching destination");
/////////////////////////////////////////////////////////////////////////
0:                             log.trace("bridging "+configuration.getBrokerName()+" -> "+remoteBrokerName+": "+message);
/////////////////////////////////////////////////////////////////////////
0:                     log.info(configuration.getBrokerName()+" Shutting down");
/////////////////////////////////////////////////////////////////////////
0:     
0:      * @return the createdByDuplex
0:     public boolean isCreatedByDuplex(){
0:         return this.createdByDuplex;
0:     
0:      * @param createdByDuplex the createdByDuplex to set
0:     public void setCreatedByDuplex(boolean createdByDuplex){
0:         this.createdByDuplex=createdByDuplex;
/////////////////////////////////////////////////////////////////////////
0:     	if( destination.isTemporary() && !configuration.isBridgeTempDestinations() ) {
0:         }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:ae73f86
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.IntrospectionSupport;
0: import org.apache.activemq.util.MarshallingSupport;
0: import java.util.Properties;
/////////////////////////////////////////////////////////////////////////
0: public abstract class DemandForwardingBridgeSupport implements NetworkBridge {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected NetworkBridgeConfiguration configuration;
0:     private NetworkBridgeFailedListener bridgeFailedListener;
1:     public DemandForwardingBridgeSupport(NetworkBridgeConfiguration configuration, Transport localBroker, Transport remoteBroker) {
0:         this.configuration=configuration;
/////////////////////////////////////////////////////////////////////////
0: 	            localConnectionInfo.setUserName(configuration.getUserName());
0: 	            localConnectionInfo.setPassword(configuration.getPassword());
/////////////////////////////////////////////////////////////////////////
0:                 remoteConnectionInfo.setClientId("NC_"+configuration.getLocalBrokerName()+"_outbound"+name);
1:                 remoteConnectionInfo.setUserName(configuration.getUserName());
1:                 remoteConnectionInfo.setPassword(configuration.getPassword());
0:                 brokerInfo.setBrokerName(configuration.getLocalBrokerName());
0:                 brokerInfo.setDuplexConnection(configuration.isDuplex());
0:                 //set our properties
0:                 Properties props = new Properties();
0:                 IntrospectionSupport.getProperties(this,props,null); 
0:                 String str = MarshallingSupport.propertiesToString(props);
0:                 brokerInfo.setNetworkProperties(str);
/////////////////////////////////////////////////////////////////////////
0:                 demandConsumerInfo.setDispatchAsync(configuration.isDispatchAsync());
0:                 String advisoryTopic = AdvisorySupport.CONSUMER_ADVISORY_TOPIC_PREFIX+configuration.getDestinationFilter();
0:                 if( configuration.isBridgeTempDestinations() ) {
0:                 demandConsumerInfo.setPrefetchSize(configuration.getPrefetchSize());
/////////////////////////////////////////////////////////////////////////
0:         log.debug(" stopping "+configuration.getLocalBrokerName()+" bridge to "+remoteBrokerName+" is disposed already ? "+disposed);
/////////////////////////////////////////////////////////////////////////
0:             log.debug(configuration.getLocalBrokerName()+" bridge to "+remoteBrokerName+" stopped");
0:             log.info(configuration.getLocalBrokerName()+" bridge to "+remoteBrokerName+" stopped");
0:     public void serviceRemoteException(Throwable error){
/////////////////////////////////////////////////////////////////////////
0:             fireBridgeFailed();
/////////////////////////////////////////////////////////////////////////
0:         final int networkTTL = configuration.getNetworkTTL();
0:                     log.debug(configuration.getLocalBrokerName() + " Ignoring Subscription " + info + " restricted to " + networkTTL + " network hops only");
0:                     log.debug(configuration.getLocalBrokerName()  + " Ignoring sub " + info + " already routed through this broker once");
0:                     log.debug(configuration.getLocalBrokerName()  + " Ignoring sub " + info + " destination " + info.getDestination() + " is not permiited");
/////////////////////////////////////////////////////////////////////////
0:                     log.debug(configuration.getLocalBrokerName() + " Forwarding sub on "+localBroker+" from "+remoteBrokerName+" :  "+info);
0:                     log.debug(configuration.getLocalBrokerName()  + " Ignoring sub " + info + " already subscribed to matching destination");
/////////////////////////////////////////////////////////////////////////
0:     public void serviceLocalException(Throwable error) {
/////////////////////////////////////////////////////////////////////////
0:             fireBridgeFailed();
/////////////////////////////////////////////////////////////////////////
0:                             log.trace("bridging "+configuration.getLocalBrokerName()+" -> "+remoteBrokerName+": "+message);
/////////////////////////////////////////////////////////////////////////
0:                     log.info(configuration.getLocalBrokerName()+" Shutting down");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     	if( destination.isTemporary() && !configuration.isBridgeTempDestinations() )
/////////////////////////////////////////////////////////////////////////
0:         if( configuration.isDecreaseNetworkConsumerPriority() ) {
/////////////////////////////////////////////////////////////////////////
0:         sub.getLocalInfo().setDispatchAsync(configuration.isDispatchAsync());
0:         sub.getLocalInfo().setPrefetchSize(configuration.getPrefetchSize());
/////////////////////////////////////////////////////////////////////////
0:     
0:     public void setNetworkBridgeFailedListener(NetworkBridgeFailedListener listener){
0:         this.bridgeFailedListener=listener;  
0:       }
0:       
0:       private void fireBridgeFailed() {
0:           NetworkBridgeFailedListener l = this.bridgeFailedListener;
0:           if (l!=null) {
0:               l.bridgeFailed();
0:           }
0:       }
commit:9a79d34
/////////////////////////////////////////////////////////////////////////
0:     protected boolean duplex = false;
/////////////////////////////////////////////////////////////////////////
0:                 brokerInfo.setNetworkConnection(true);
0:                 brokerInfo.setDuplexConnection(isDuplex());
/////////////////////////////////////////////////////////////////////////
0:     public boolean isDuplex(){
0:         return this.duplex;
0:     }
0: 
0:     public void setDuplex(boolean duplex){
0:         this.duplex=duplex;
0:     }
0: 
commit:0552f4a
/////////////////////////////////////////////////////////////////////////
0:                 log.debug("Caught exception stopping",e);
commit:e349089
/////////////////////////////////////////////////////////////////////////
0: import java.security.GeneralSecurityException;
/////////////////////////////////////////////////////////////////////////
0:                     log.info("Outbound transport to " + remoteBrokerName + " interrupted.");                                        
/////////////////////////////////////////////////////////////////////////
0:                         log.info("Outbound transport to " + remoteBrokerName + " resumed");   
/////////////////////////////////////////////////////////////////////////
0:     public void stop() throws Exception{
0:         log.debug(" stopping "+localBrokerName+" bridge to "+remoteBrokerName+" is disposed already ? "+disposed);
0:         boolean wasDisposedAlready=disposed;
0:         if(!disposed){
0:             try{
0:                 disposed=true;
0:                 remoteBridgeStarted.set(false);
0:                 localBroker.oneway(new ShutdownInfo());
0:                 remoteBroker.oneway(new ShutdownInfo());
0:             }catch(IOException e){
0:                 log.info("Caught exception stopping",e);
0:             }finally{
0:                 ServiceStopper ss=new ServiceStopper();
0:                 ss.stop(localBroker);
0:                 ss.stop(remoteBroker);
0:                 ss.throwFirstException();
0:             }
0:         }
0:         if(wasDisposedAlready){
0:             log.debug(localBrokerName+" bridge to "+remoteBrokerName+" stopped");
0:         }else{
0:             log.info(localBrokerName+" bridge to "+remoteBrokerName+" stopped");
0:         }
0:     protected void serviceRemoteException(Throwable error){
0:         if(!disposed){
0:             if(error instanceof SecurityException||error instanceof GeneralSecurityException){
0:                 log.error("Network connection between "+localBroker+" and "+remoteBroker
0:                         +" shutdown due to a remote error: "+error);
0:             }else{
0:                 log.warn("Network connection between "+localBroker+" and "+remoteBroker
0:                         +" shutdown due to a remote error: "+error);
0:             }
0:             log.debug("The remote Exception was: "+error,error);
0:             new Thread(){
0: 
0:                 public void run(){
0:                     ServiceSupport.dispose(DemandForwardingBridgeSupport.this);
0:                 }
0:             }.start();
0:         }
commit:b91103a
/////////////////////////////////////////////////////////////////////////
0:                         log.error("Caught exception  from local start in resume transport",e );
commit:2a682e2
/////////////////////////////////////////////////////////////////////////
0:                     try {
0:                         startLocalBridge();
0:                         remoteBridgeStarted.set(true);
0:                         startedLatch.countDown();
0:                         log.debug("Outbound transport to " + remoteBrokerName + " resumed");   
0:                     }catch(Exception e) {
0:                         log.error("Caught exception  from local start ib resume transport",e );
0:                     }
0:                                                          
commit:f48b4eb
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transport.TransportDisposedIOException;
/////////////////////////////////////////////////////////////////////////
0: 		                    }catch(TransportDisposedIOException td){
0:                                 log.debug("local broker is now disposed",td);
0:                             }
0:                             catch(IOException e){
commit:fd96598
/////////////////////////////////////////////////////////////////////////
0:                     log.debug(localBrokerName + " Ignoring Subscription " + info + " restricted to " + networkTTL + " network hops only");
0:                     log.debug(localBrokerName  + " Ignoring sub " + info + " already routed through this broker once");
0:                     log.debug(localBrokerName  + " Ignoring sub " + info + " destination " + info.getDestination() + " is not permiited");
/////////////////////////////////////////////////////////////////////////
0:                     log.debug(localBrokerName + " Forwarding sub on "+localBroker+" from "+remoteBrokerName+" :  "+info);
0:                     log.debug(localBrokerName  + " Ignoring sub " + info + " already subscribed to matching destination");
/////////////////////////////////////////////////////////////////////////
0:                         
/////////////////////////////////////////////////////////////////////////
0:                     }else{
0:                         if (trace)log.trace("No subscription registered with this network bridge for consumerId " + md.getConsumerId() + " for message: " + md.getMessage());
0:                     } 
commit:4f131fd
/////////////////////////////////////////////////////////////////////////
0:                 destinationInfo.setDispatchAsync(dispatchAsync);
commit:a17b951
/////////////////////////////////////////////////////////////////////////
0: import com.sun.tools.javac.tree.Tree.DoLoop;
/////////////////////////////////////////////////////////////////////////
0:             public synchronized void transportInterupted(){
0:                 doStopLocal();
0:                 startedLatch = new CountDownLatch(2);
0:                 try{
0:                     triggerLocalStartBridge();
0:                 }catch(IOException e){
0:                     log.warn("Caught exception from local start",e);
0:                 }
0:             public synchronized void transportResumed(){
0:                 startedLatch.countDown();
/////////////////////////////////////////////////////////////////////////
0:                 
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected void doStopLocal(){
0:         try{
0:             if(!shutDown){
0:                 if(localConnectionInfo!=null){
0:                     localBroker.oneway(localConnectionInfo.createRemoveCommand());
0:                 }
0:                 localBroker.oneway(new ShutdownInfo());
0:             }
0:             localBroker.setTransportListener(null);
0:         }catch(IOException e){
0:             log.debug("Caught exception stopping",e);
0:         }finally{
0:             ServiceStopper ss=new ServiceStopper();
0:             ss.stop(localBroker);
0:         }
0:     }
commit:065c46f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ActiveMQTempDestination;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.DestinationInfo;
/////////////////////////////////////////////////////////////////////////
0:             //we want infomation about Destinations as well
0:             ConsumerInfo destinationInfo  = new ConsumerInfo(remoteSessionInfo,2);
0:             destinationInfo.setDestination(AdvisorySupport.TEMP_DESTINATION_COMPOSITE_ADVISORY_TOPIC);
0:             destinationInfo.setPrefetchSize(prefetchSize);
0:             remoteBroker.oneway(destinationInfo);
/////////////////////////////////////////////////////////////////////////
0:         else if (data.getClass()==DestinationInfo.class){
0: //          It's a destination info - we want to pass up
0:             //infomation about temporary destinations 
0:             DestinationInfo destInfo = (DestinationInfo) data;
0:             BrokerId[] path=destInfo.getBrokerPath();
0:             if((path!=null&&path.length>= networkTTL)){
0:                 if(log.isTraceEnabled())
0:                     log.trace("Ignoring Subscription " + destInfo + " restricted to " + networkTTL + " network hops only");
1:                 return;
0:             }
0:             if(contains(destInfo.getBrokerPath(),localBrokerPath[0])){
0:                 // Ignore this consumer as it's a consumer we locally sent to the broker.
0:                 if(log.isTraceEnabled())
0:                     log.trace("Ignoring sub " + destInfo + " already routed through this broker once");
1:                 return;
0:             }
0:             
1:             destInfo.setConnectionId(localConnectionInfo.getConnectionId());
0:             if (destInfo.getDestination() instanceof ActiveMQTempDestination){
0:                 //re-set connection id so comes from here
1:                 ActiveMQTempDestination tempDest = (ActiveMQTempDestination) destInfo.getDestination();
1:                 tempDest.setConnectionId(localSessionInfo.getSessionId().getConnectionId());
0:             }
0:             destInfo.setBrokerPath(appendToBrokerPath(destInfo.getBrokerPath(),getRemoteBrokerPath()));
0:             localBroker.oneway(destInfo);
0:             
0:         }
0:         else if(data.getClass()==RemoveInfo.class){
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected abstract BrokerId[] getRemoteBrokerPath();
commit:44ab524
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     protected String userName;
0:     protected String password;
/////////////////////////////////////////////////////////////////////////
0:             localConnectionInfo.setUserName(userName);
0:             localConnectionInfo.setPassword(password);
/////////////////////////////////////////////////////////////////////////
0:             remoteConnectionInfo.setUserName(userName);
0:             remoteConnectionInfo.setPassword(password);
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 	public String getPassword() {
0: 		return password;
0: 	}
0: 
0: 	public void setPassword(String password) {
0: 		this.password = password;
0: 	}
0: 
0: 	public String getUserName() {
0: 		return userName;
0: 	}
0: 
0: 	public void setUserName(String userName) {
0: 		this.userName = userName;
0: 	}
commit:a9c49a7
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ActiveMQTempDestination;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.DestinationInfo;
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.TemporaryTopic;
/////////////////////////////////////////////////////////////////////////
0:             
0:             //we want infomation about Destinations as well
0:             ConsumerInfo destinationInfo  = new ConsumerInfo(remoteSessionInfo,2);
0:             destinationInfo.setDestination(AdvisorySupport.TEMP_DESTINATION_COMPOSITE_ADVISORY_TOPIC);
0:             destinationInfo.setPrefetchSize(prefetchSize);
0:             remoteBroker.oneway(destinationInfo);
0:             
/////////////////////////////////////////////////////////////////////////
0:         }else if (data.getClass()==DestinationInfo.class){
0: //          It's a destination info - we want to pass up
0:             //infomation about temporary destinations 
0:             DestinationInfo destInfo = (DestinationInfo) data;
0:             BrokerId[] path=destInfo.getBrokerPath();
0:             if((path!=null&&path.length>= networkTTL)){
0:                 if(log.isTraceEnabled())
0:                     log.trace("Ignoring Subscription " + destInfo + " restricted to " + networkTTL + " network hops only");
0:                 return;
0:             }
0:             if(contains(destInfo.getBrokerPath(),localBrokerPath[0])){
0:                 // Ignore this consumer as it's a consumer we locally sent to the broker.
0:                 if(log.isTraceEnabled())
0:                     log.trace("Ignoring sub " + destInfo + " already routed through this broker once");
0:                 return;
0:             }
0:             
0:             destInfo.setConnectionId(localConnectionInfo.getConnectionId());
0:             if (destInfo.getDestination() instanceof ActiveMQTempDestination){
0:                 //re-set connection id so comes from here
0:                 ActiveMQTempDestination tempDest = (ActiveMQTempDestination) destInfo.getDestination();
0:                 tempDest.setConnectionId(localSessionInfo.getSessionId().getConnectionId());
0:             }
0:             destInfo.setBrokerPath(appendToBrokerPath(destInfo.getBrokerPath(),getRemoteBrokerPath()));
0:             localBroker.oneway(destInfo);
0:             
/////////////////////////////////////////////////////////////////////////
0:     
0:     
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected abstract BrokerId[] getRemoteBrokerPath();
author:Colin W Macnaughton
-------------------------------------------------------------------------------
commit:414a646
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:     protected final BrokerId localBrokerPath[] = new BrokerId[] { null };
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:                     Command command = (Command) o;
/////////////////////////////////////////////////////////////////////////
0:                     Command command = (Command) o;
/////////////////////////////////////////////////////////////////////////
0:                     originalTransport = ((TransportFilter) originalTransport).getNext();
0:                     X509Certificate[] peerCerts = ((SslTransport) originalTransport).getPeerCertificates();
/////////////////////////////////////////////////////////////////////////
0: 
0:                     if (!sendShutdown.await(10, TimeUnit.SECONDS)) {
/////////////////////////////////////////////////////////////////////////
0:     protected void serviceRemoteCommand(Command command) {
1:                     MessageDispatch md = (MessageDispatch) command;
/////////////////////////////////////////////////////////////////////////
0:                     remoteBrokerInfo = (BrokerInfo) command;
/////////////////////////////////////////////////////////////////////////
0:                     ConnectionError ce = (ConnectionError) command;
0:                             ActiveMQMessage message = (ActiveMQMessage) command;
0:                                 if (!isPermissableDestination(message.getDestination(), true)) {
0:                                     return;
0:                                 }
/////////////////////////////////////////////////////////////////////////
0:                                 localStartedLatch.await();
0:                                             LOG.debug("Ignoring ConsumerInfo: " + command);
0:                                             LOG.trace("Adding ConsumerInfo: " + command);
0:                                     LOG.warn("Stopping - ignoring ConsumerInfo: " + command);
/////////////////////////////////////////////////////////////////////////
1:             ConsumerInfo info = (ConsumerInfo) data;
0: 
/////////////////////////////////////////////////////////////////////////
0:             }
/////////////////////////////////////////////////////////////////////////
0: 
0:             synchronized (brokerService.getVmConnectorURI()) {
/////////////////////////////////////////////////////////////////////////
0:             DestinationInfo destInfo = (DestinationInfo) data;
/////////////////////////////////////////////////////////////////////////
0:                 ActiveMQTempDestination tempDest = (ActiveMQTempDestination) destInfo.getDestination();
/////////////////////////////////////////////////////////////////////////
1:             ConsumerId id = (ConsumerId) ((RemoveInfo) data).getObjectId();
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1:                     final MessageDispatch md = (MessageDispatch) command;
1:                     if (sub != null && md.getMessage() != null && sub.incrementOutstandingResponses()) {
0:                         Object consumerInfo = md.getMessage().getDataStructure();
0:                         if (consumerInfo != null && (consumerInfo instanceof ConsumerInfo))
0:                             cameFromRemote = contains(((ConsumerInfo) consumerInfo).getBrokerPath(), remoteBrokerInfo.getBrokerId());
0: 
0: 
0: 
0:                             try {
0:                                 // Don't send it off to the remote if it originally came from the remote. 
0:                                 if (!cameFromRemote) {
0:                                     remoteBroker.oneway(message);
0:                                 } else {
0:                                     if (LOG.isDebugEnabled()) {
0:                                         LOG.debug("Message not forwarded on to remote, because message came from remote");
0:                                     }
0: 
0:                                 localBroker.oneway(new MessageAck(md, MessageAck.INDIVIDUAL_ACK_TYPE, 1));
0:                                 dequeueCounter.incrementAndGet();
0:                             } finally {
0:                                 sub.decrementOutstandingResponses();
0: 
/////////////////////////////////////////////////////////////////////////
0:                                             ExceptionResponse er = (ExceptionResponse) response;
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:                     localBrokerInfo = (BrokerInfo) command;
/////////////////////////////////////////////////////////////////////////
0:                     ConnectionError ce = (ConnectionError) command;
/////////////////////////////////////////////////////////////////////////
1:                 LOG.warn("Caught an exception processing local command", e);
/////////////////////////////////////////////////////////////////////////
0:      *            dynamicallyIncludedDestinations to set.
/////////////////////////////////////////////////////////////////////////
0:      *            to set.
/////////////////////////////////////////////////////////////////////////
0:             return new BrokerId[] { idToAppend };
0: 
0:         return isPermissableDestination(destination, false);
0:             if (allowTemporary) {
0:                 return true;
0:             } else {
0:                 return configuration.isBridgeTempDestinations();
0:             }
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
1:             if (duplicateSuppressionIsRequired(sub)) {
/////////////////////////////////////////////////////////////////////////
0: 
0:         subscriptionMapByRemoteId.remove(sub.getRemoteInfo().getConsumerId());
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:         List<ConsumerId> candidateConsumers = consumerInfo.getNetworkConsumerIds();
1:             List<ConsumerId> networkConsumers = sub.getConsumerInfo().getNetworkConsumerIds();
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:                 LOG.error("Failed to remove duplicated sub as a result of sub with higher priority, sub: " + existingSub, e);
1:         for (NetworkConnector connector : brokerService.getNetworkConnectors()) {
0:         }
0:         for (ConsumerId aliasConsumer : networkConsumers) {
/////////////////////////////////////////////////////////////////////////
0: 
1:             ActiveMQTempDestination dest = (ActiveMQTempDestination) result.getLocalInfo().getDestination();
/////////////////////////////////////////////////////////////////////////
0:                 priority -= info.getBrokerPath().length + 1;
/////////////////////////////////////////////////////////////////////////
0:     final protected DemandSubscription createDemandSubscription(ActiveMQDestination destination) {
0: 
1:             LOG.error("Failed to create DemandSubscription ", e);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
0:                 removeDone = true;
0:             }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0:         ASYNC_TASKS = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 30, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), new ThreadFactory() {
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:bd7d59c
/////////////////////////////////////////////////////////////////////////
0:                 	// Let the local broker know the remote broker's ID.
0:                 	localBroker.oneway(command);
author:Adrian T. Co
-------------------------------------------------------------------------------
commit:9920d70
/////////////////////////////////////////////////////////////////////////
0: 
0:             
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:             BrokerInfo brokerInfo=new BrokerInfo();
0:             brokerInfo.setBrokerName(localBrokerName);
0:             remoteBroker.oneway(brokerInfo);
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
author:James Strachan
-------------------------------------------------------------------------------
commit:400b1fc
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected DemandSubscription createDemandSubscription(ConsumerInfo info) throws IOException {
1:         return doCreateDemandSubscription(info);
1:     protected DemandSubscription doCreateDemandSubscription(ConsumerInfo info) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:         configureDemandSubscription(info, result);
/////////////////////////////////////////////////////////////////////////
1:     protected void configureDemandSubscription(ConsumerInfo info, DemandSubscription sub) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:         sub.getLocalInfo().setAdditionalPredicate(createNetworkBridgeFilter(info));
/////////////////////////////////////////////////////////////////////////
0: 
0:     protected abstract NetworkBridgeFilter createNetworkBridgeFilter(ConsumerInfo info) throws IOException;
0: 
0:     protected abstract void serviceLocalBrokerInfo(Command command) throws InterruptedException;
0: 
0:     protected abstract void addRemoteBrokerToBrokerPath(ConsumerInfo info) throws IOException;
0: 
0:     protected abstract void serviceRemoteBrokerInfo(Command command) throws IOException;
commit:687a45a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.network;
0: 
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
0: import edu.emory.mathcs.backport.java.util.concurrent.CountDownLatch;
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean;
0: 
0: import org.apache.activemq.advisory.AdvisorySupport;
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQTopic;
0: import org.apache.activemq.command.BrokerId;
0: import org.apache.activemq.command.BrokerInfo;
0: import org.apache.activemq.command.Command;
0: import org.apache.activemq.command.ConnectionId;
0: import org.apache.activemq.command.ConnectionInfo;
0: import org.apache.activemq.command.ConsumerId;
0: import org.apache.activemq.command.ConsumerInfo;
0: import org.apache.activemq.command.DataStructure;
0: import org.apache.activemq.command.ExceptionResponse;
0: import org.apache.activemq.command.Message;
0: import org.apache.activemq.command.MessageAck;
0: import org.apache.activemq.command.MessageDispatch;
0: import org.apache.activemq.command.NetworkBridgeFilter;
0: import org.apache.activemq.command.ProducerInfo;
0: import org.apache.activemq.command.RemoveInfo;
0: import org.apache.activemq.command.Response;
0: import org.apache.activemq.command.SessionInfo;
0: import org.apache.activemq.command.ShutdownInfo;
0: import org.apache.activemq.command.WireFormatInfo;
0: import org.apache.activemq.filter.DestinationFilter;
0: import org.apache.activemq.transport.DefaultTransportListener;
0: import org.apache.activemq.transport.Transport;
0: import org.apache.activemq.transport.TransportListener;
0: import org.apache.activemq.util.IdGenerator;
0: import org.apache.activemq.util.LongSequenceGenerator;
0: import org.apache.activemq.util.ServiceStopper;
0: import org.apache.activemq.util.ServiceSupport;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: 
0: import java.io.IOException;
0: 
1: /**
1:  * A useful base class for implementing demand forwarding bridges.
0:  * 
0:  * @version $Revision$
1:  */
0: public abstract class DemandForwardingBridgeSupport implements Bridge {
0:     protected abstract NetworkBridgeFilter createNetworkBridgeFilter();
0: 
0:     protected abstract void serviceLocalBrokerInfo(Command command) throws InterruptedException;
0: 
0:     protected abstract void addRemoteBrokerToBrokerPath(ConsumerInfo info);
0: 
0:     protected abstract void serviceRemoteBrokerInfo(Command command) throws IOException;
0: 
0:     protected static final Log log = LogFactory.getLog(DemandForwardingBridge.class);
1:     protected final Transport localBroker;
1:     protected final Transport remoteBroker;
0:     protected IdGenerator idGenerator = new IdGenerator();
0:     protected LongSequenceGenerator consumerIdGenerator = new LongSequenceGenerator();
1:     protected ConnectionInfo localConnectionInfo;
1:     protected ConnectionInfo remoteConnectionInfo;
1:     protected SessionInfo localSessionInfo;
1:     protected ProducerInfo producerInfo;
0:     protected String localBrokerName;
0:     protected String remoteBrokerName;
1:     protected String localClientId;
0:     protected int prefetchSize = 1000;
0:     protected boolean dispatchAsync;
0:     protected String destinationFilter = ">";
0:     protected String name = "bridge";
1:     protected ConsumerInfo demandConsumerInfo;
1:     protected int demandConsumerDispatched;
0:     protected AtomicBoolean localBridgeStarted = new AtomicBoolean(false);
0:     protected AtomicBoolean remoteBridgeStarted = new AtomicBoolean(false);
0:     protected boolean disposed = false;
1:     protected BrokerId localBrokerId;
1:     protected ActiveMQDestination[] excludedDestinations;
1:     protected ActiveMQDestination[] dynamicallyIncludedDestinations;
1:     protected ActiveMQDestination[] staticallyIncludedDestinations;
1:     protected ActiveMQDestination[] durableDestinations;
0:     protected ConcurrentHashMap subscriptionMapByLocalId = new ConcurrentHashMap();
0:     protected ConcurrentHashMap subscriptionMapByRemoteId = new ConcurrentHashMap();
0:     protected final BrokerId localBrokerPath[] = new BrokerId[] { null };
0:     protected CountDownLatch startedLatch = new CountDownLatch(2);
0:     protected boolean decreaseNetworkConsumerPriority;
0:     protected boolean shutDown;
0:     protected int networkTTL = 1;
0: 
0:     
0:     public DemandForwardingBridgeSupport(final Transport localBroker, final Transport remoteBroker) {
1:         this.localBroker = localBroker;
1:         this.remoteBroker = remoteBroker;
0:     }
0: 
0:     public void start() throws Exception {
0:         log.info("Starting a network connection between "+localBroker+" and "+remoteBroker+" has been established.");
0:         localBroker.setTransportListener(new DefaultTransportListener(){
0:             public void onCommand(Command command){
0:                 serviceLocalCommand(command);
0:             }
0:     
0:             public void onException(IOException error){
0:                 serviceLocalException(error);
0:             }
0:         });
0:         remoteBroker.setTransportListener(new TransportListener(){
0:             public void onCommand(Command command){
0:                 serviceRemoteCommand(command);
0:             }
0:     
0:             public void onException(IOException error){
0:                 serviceRemoteException(error);
0:             }
0:     
0:             public void transportInterupted(){
0:                 //clear any subscriptions - to try and prevent the bridge from stalling the broker
0:                 log.warn("Outbound transport to " + remoteBrokerName +  " interrupted ...");
0:                 clearDownSubscriptions();
0:                 
0:             }
0:     
0:             public void transportResumed(){
0:                 //restart and static subscriptions - the consumer advisories will be replayed
0:                 log.info("Outbound transport to " + remoteBrokerName + " resumed");
0:                 setupStaticDestinations();
0:                 
0:             }
0:         });
0:         localBroker.start();
0:         remoteBroker.start();
0:         triggerRemoteStartBridge();
0:     }
0: 
0:     protected void triggerLocalStartBridge() throws IOException {
0:         Thread thead=new Thread(){
0:             public void run(){
0:                 try{
0:                     startLocalBridge();
0:                 }catch(IOException e){
0:                     log.error("Failed to start network bridge: "+e,e);
0:                 }
0:             }
0:         };
0:         thead.start();
0:     }
0: 
0:     protected void triggerRemoteStartBridge() throws IOException {
0:         Thread thead=new Thread(){
0:             public void run(){
0:                 try{
0:                     startRemoteBridge();
0:                 }catch(IOException e){
0:                     log.error("Failed to start network bridge: "+e,e);
0:                 }
0:             }
0:         };
0:         thead.start();
0:     }
0: 
0:     protected void startLocalBridge() throws IOException {
0:         if(localBridgeStarted.compareAndSet(false,true)){
0:             localConnectionInfo=new ConnectionInfo();
0:             localConnectionInfo.setConnectionId(new ConnectionId(idGenerator.generateId()));
0:             localClientId="NC_"+remoteBrokerName+"_inbound"+name;
0:             localConnectionInfo.setClientId(localClientId);
0:             localBroker.oneway(localConnectionInfo);
0:             localSessionInfo=new SessionInfo(localConnectionInfo,1);
0:             localBroker.oneway(localSessionInfo);
0:             log.info("Network connection between "+localBroker+" and "+remoteBroker+"("+remoteBrokerName
0:                             +") has been established.");
0:             startedLatch.countDown();
0:             setupStaticDestinations();
0:         }
0:     }
0: 
0:     protected void startRemoteBridge() throws IOException {
0:         if(remoteBridgeStarted.compareAndSet(false,true)){
0:             BrokerInfo brokerInfo=new BrokerInfo();
0:             brokerInfo.setBrokerName(localBrokerName);
0:             remoteBroker.oneway(brokerInfo);
0:             remoteConnectionInfo=new ConnectionInfo();
0:             remoteConnectionInfo.setConnectionId(new ConnectionId(idGenerator.generateId()));
0:             remoteConnectionInfo.setClientId("NC_"+localBrokerName+"_outbound"+name);
0:             remoteBroker.oneway(remoteConnectionInfo);
0:             SessionInfo remoteSessionInfo=new SessionInfo(remoteConnectionInfo,1);
0:             remoteBroker.oneway(remoteSessionInfo);
0:             producerInfo=new ProducerInfo(remoteSessionInfo,1);
0:             producerInfo.setResponseRequired(false);
0:             remoteBroker.oneway(producerInfo);
0:             // Listen to consumer advisory messages on the remote broker to determine demand.
0:             demandConsumerInfo=new ConsumerInfo(remoteSessionInfo,1);
0:             demandConsumerInfo.setDispatchAsync(dispatchAsync);
0:             demandConsumerInfo.setDestination(new ActiveMQTopic(AdvisorySupport.CONSUMER_ADVISORY_TOPIC_PREFIX
0:                             +destinationFilter));
0:             demandConsumerInfo.setPrefetchSize(prefetchSize);
0:             remoteBroker.oneway(demandConsumerInfo);
0:             startedLatch.countDown();
0:         }
0:     }
0: 
0:     public void stop() throws Exception {
0:         shutDown = true;
0:         doStop();
0:     }
0: 
1:     /**
0:      * stop the bridge
0:      * @throws Exception 
1:      */
0:     protected void doStop() throws Exception {
0:         log.debug(" stopping "+localBrokerName+ " bridge to " + remoteBrokerName + " is disposed already ? "+disposed);
0:         if(!disposed){
0:             try{
0:                 disposed=true;
0:                 localBridgeStarted.set(false);
0:                 remoteBridgeStarted.set(false);
0:                 if(!shutDown){
0:                    remoteBroker.oneway(new ShutdownInfo());
0:                     if(localConnectionInfo!=null){
0:                         localBroker.oneway(localConnectionInfo.createRemoveCommand());
0:                         remoteBroker.oneway(remoteConnectionInfo.createRemoveCommand());
0:                     }
0:                     localBroker.oneway(new ShutdownInfo());
0:                 }
0:                 localBroker.setTransportListener(null);
0:                 remoteBroker.setTransportListener(null);
0:             }catch(IOException e){
0:                 log.debug("Caught exception stopping",e);
0:             }finally{
0:                 ServiceStopper ss=new ServiceStopper();
0:                 ss.stop(localBroker);
0:                 ss.stop(remoteBroker);
0:                 ss.throwFirstException();
0:             }
0:         }
0:         log.debug(localBrokerName+ " bridge to " + remoteBrokerName + " stopped");
0:     }
0: 
0:     protected void serviceRemoteException(Exception error) {
0:         log.info("Network connection between "+localBroker+" and "+remoteBroker+" shutdown: "+error.getMessage(),error);
0:         ServiceSupport.dispose(this);
0:     }
0: 
0:     protected void serviceRemoteCommand(Command command) {
0:         if(!disposed){
0:             try{
0:                 if(command.isMessageDispatch()){
0:                     waitStarted();
0:                     MessageDispatch md=(MessageDispatch) command;
1:                     serviceRemoteConsumerAdvisory(md.getMessage().getDataStructure());
0:                     demandConsumerDispatched++;
0:                     if(demandConsumerDispatched>(demandConsumerInfo.getPrefetchSize()*.75)){
0:                         remoteBroker.oneway(new MessageAck(md,MessageAck.STANDARD_ACK_TYPE,demandConsumerDispatched));
0:                         demandConsumerDispatched=0;
0:                     }
0:                 }else if(command.isBrokerInfo()){
0:                     serviceRemoteBrokerInfo(command);
0:                 }else{
0:                     switch(command.getDataStructureType()){
0:                     case WireFormatInfo.DATA_STRUCTURE_TYPE:
0:                         break;
0:                     default:
0:                         log.warn("Unexpected remote command: "+command);
0:                     }
0:                 }
0:             }catch(Exception e){
0:                 serviceRemoteException(e);
0:             }
0:         }
0:     }
0: 
0:     private void serviceRemoteConsumerAdvisory(DataStructure data) throws IOException {
0:         if(data.getClass()==ConsumerInfo.class){
1:             // Create a new local subscription
0:             ConsumerInfo info=(ConsumerInfo) data;
0:             BrokerId[] path=info.getBrokerPath();
0:             if((path!=null&&path.length>= networkTTL)){
0:                 if(log.isTraceEnabled())
0:                     log.trace("Ignoring Subscription " + info + " restricted to " + networkTTL + " network hops only");
0:                 return;
0:             }
0:             if(contains(info.getBrokerPath(),localBrokerPath[0])){
0:                 // Ignore this consumer as it's a consumer we locally sent to the broker.
0:                 if(log.isTraceEnabled())
0:                     log.trace("Ignoring sub " + info + " already routed through this broker once");
0:                 return;
0:             }
0:             if (!isPermissableDestination(info.getDestination())){
0:                 //ignore if not in the permited or in the excluded list
0:                 if(log.isTraceEnabled())
0:                     log.trace("Ignoring sub " + info + " destination " + info.getDestination() + " is not permiited");
0:                 return;
0:             }
1:             // Update the packet to show where it came from.
0:             info=info.copy();
0:             addRemoteBrokerToBrokerPath(info);
0:             DemandSubscription sub=createDemandSubscription(info);
0:             if (sub != null){
0:                 addSubscription(sub);
0:                 if(log.isTraceEnabled())
0:                     log.trace("Forwarding sub on "+localBroker+" from "+remoteBrokerName+" :  "+info);
0:             }else {
0:                 if(log.isTraceEnabled())
0:                     log.trace("Ignoring sub " + info + " already subscribed to matching destination");
0:             }
0:         }
0:         if(data.getClass()==RemoveInfo.class){
0:             ConsumerId id=(ConsumerId) ((RemoveInfo) data).getObjectId();
1:             removeDemandSubscription(id);
0:         }
0:     }
0: 
0:     protected void serviceLocalException(Throwable error) {
0:         log.info("Network connection between "+localBroker+" and "+remoteBroker+" shutdown: "+error.getMessage(),error);
0:         ServiceSupport.dispose(this);
0:     }
0: 
1:     protected void addSubscription(DemandSubscription sub) throws IOException {
0:         if (sub != null){
0:             localBroker.oneway(sub.getLocalInfo());
0:         }
0:     }
0: 
0:     protected void removeSubscription(DemandSubscription sub) throws IOException {
0:         if(sub!=null){
0:             subscriptionMapByLocalId.remove(sub.getLocalInfo().getConsumerId());
0:             localBroker.oneway(sub.getLocalInfo().createRemoveCommand());
0:         }
0:     }
0: 
0:     protected DemandSubscription getDemandSubscription(MessageDispatch md) {
0:         return (DemandSubscription) subscriptionMapByLocalId.get(md.getConsumerId());
0:     }
0: 
0:     protected Message configureMessage(MessageDispatch md) {
0:         Message message=md.getMessage().copy();
1:         // Update the packet to show where it came from.
0:         message.setBrokerPath(appendToBrokerPath(message.getBrokerPath(),localBrokerPath));
1:         message.setProducerId(producerInfo.getProducerId());
1:         message.setDestination(md.getDestination());
0:         if(message.getOriginalTransactionId()==null)
1:             message.setOriginalTransactionId(message.getTransactionId());
1:         message.setTransactionId(null);
0:         message.evictMarshlledForm();
1:         return message;
0:     }
0: 
1:     protected void serviceLocalCommand(Command command) {
0:         if(!disposed){
0:             final boolean trace=log.isTraceEnabled();
0:             try{
0:                 if(command.isMessageDispatch()){
0:                     waitStarted();
0:                     MessageDispatch md=(MessageDispatch) command;
0:                     DemandSubscription sub=(DemandSubscription) subscriptionMapByLocalId.get(md.getConsumerId());
0:                     if(sub!=null){
0:                         Message message= configureMessage(md);
0:                         if(trace)
0:                             log.trace("bridging "+localBrokerName+" -> "+remoteBrokerName+": "+message);
0:                         if(!message.isPersistent()||!sub.getRemoteInfo().isDurable()){
0:                             remoteBroker.oneway(message);
0:                         }else{
0:                             Response response=remoteBroker.request(message);
0:                             if(response.isException()){
0:                                 ExceptionResponse er=(ExceptionResponse) response;
0:                                 serviceLocalException(er.getException());
0:                             }
0:                         }
0:                         int dispatched = sub.incrementDispatched();
0:                         if(dispatched>(sub.getLocalInfo().getPrefetchSize()*.75)){
0:                             localBroker.oneway(new MessageAck(md,MessageAck.STANDARD_ACK_TYPE,dispatched));
0:                             sub.setDispatched(0);
0:                         }
0:                     }
0:                 }else if(command.isBrokerInfo()){
0:                     serviceLocalBrokerInfo(command);
0:                 }else if(command.isShutdownInfo()){
0:                     log.info(localBrokerName+" Shutting down");
0:                     shutDown = true;
0:                     doStop();
0:                    
0:                     
0:                 }else{
0:                     switch(command.getDataStructureType()){
0:                     case WireFormatInfo.DATA_STRUCTURE_TYPE:
0:                         break;
0:                     default:
0:                         log.warn("Unexpected local command: "+command);
0:                     }
0:                 }
0:             }catch(Exception e){
0:                 serviceLocalException(e);
0:             }
0:         }
0:     }
0: 
1:     /**
0:      * @return prefetch size
1:      */
0:     public int getPrefetchSize() {
0:         return prefetchSize;
0:     }
0: 
1:     /**
0:      * @param prefetchSize
1:      */
0:     public void setPrefetchSize(int prefetchSize) {
0:         this.prefetchSize=prefetchSize;
0:     }
0: 
1:     /**
0:      * @return true if dispatch async
1:      */
0:     public boolean isDispatchAsync() {
0:         return dispatchAsync;
0:     }
0: 
1:     /**
0:      * @param dispatchAsync
1:      */
0:     public void setDispatchAsync(boolean dispatchAsync) {
0:         this.dispatchAsync=dispatchAsync;
0:     }
0: 
1:     /**
0:      * @return Returns the dynamicallyIncludedDestinations.
1:      */
0:     public ActiveMQDestination[] getDynamicallyIncludedDestinations() {
0:         return dynamicallyIncludedDestinations;
0:     }
0: 
1:     /**
0:      * @param dynamicallyIncludedDestinations The dynamicallyIncludedDestinations to set.
1:      */
0:     public void setDynamicallyIncludedDestinations(ActiveMQDestination[] dynamicallyIncludedDestinations) {
0:         this.dynamicallyIncludedDestinations=dynamicallyIncludedDestinations;
0:     }
0: 
1:     /**
0:      * @return Returns the excludedDestinations.
1:      */
0:     public ActiveMQDestination[] getExcludedDestinations() {
0:         return excludedDestinations;
0:     }
0: 
1:     /**
0:      * @param excludedDestinations The excludedDestinations to set.
1:      */
0:     public void setExcludedDestinations(ActiveMQDestination[] excludedDestinations) {
0:         this.excludedDestinations=excludedDestinations;
0:     }
0: 
1:     /**
0:      * @return Returns the staticallyIncludedDestinations.
1:      */
0:     public ActiveMQDestination[] getStaticallyIncludedDestinations() {
0:         return staticallyIncludedDestinations;
0:     }
0: 
1:     /**
0:      * @param staticallyIncludedDestinations The staticallyIncludedDestinations to set.
1:      */
0:     public void setStaticallyIncludedDestinations(ActiveMQDestination[] staticallyIncludedDestinations) {
0:         this.staticallyIncludedDestinations=staticallyIncludedDestinations;
0:     }
0: 
1:     /**
0:      * @return Returns the durableDestinations.
1:      */
0:     public ActiveMQDestination[] getDurableDestinations() {
0:         return durableDestinations;
0:     }
0: 
1:     /**
0:      * @param durableDestinations The durableDestinations to set.
1:      */
0:     public void setDurableDestinations(ActiveMQDestination[] durableDestinations) {
0:         this.durableDestinations=durableDestinations;
0:     }
0: 
1:     /**
0:      * @return Returns the localBrokerName.
1:      */
0:     public String getLocalBrokerName() {
0:         return localBrokerName;
0:     }
0: 
1:     /**
0:      * @param localBrokerName
0:      *            The localBrokerName to set.
1:      */
0:     public void setLocalBrokerName(String localBrokerName) {
0:         this.localBrokerName=localBrokerName;
0:     }
0: 
1:     /**
0:      * @return Returns the localBroker.
1:      */
0:     public Transport getLocalBroker() {
0:         return localBroker;
0:     }
0: 
1:     /**
0:      * @return Returns the remoteBroker.
1:      */
0:     public Transport getRemoteBroker() {
0:         return remoteBroker;
0:     }
0: 
1:     /**
0:      * @return Returns the name.
1:      */
0:     public String getName() {
0:         return name;
0:     }
0: 
1:     /**
0:      * @param name The name to set.
1:      */
0:     public void setName(String name) {
0:         this.name=name;
0:     }
0: 
1:     /**
0:      * @return Returns the decreaseNetworkConsumerPriority.
1:      */
0:     public boolean isDecreaseNetworkConsumerPriority() {
0:         return decreaseNetworkConsumerPriority;
0:     }
0: 
1:     /**
0:      * @param decreaseNetworkConsumerPriority The decreaseNetworkConsumerPriority to set.
1:      */
0:     public void setDecreaseNetworkConsumerPriority(boolean decreaseNetworkConsumerPriority) {
0:         this.decreaseNetworkConsumerPriority=decreaseNetworkConsumerPriority;
0:     }
0: 
1:     /**
0:      * @return Returns the networkTTL.
1:      */
0:     public int getNetworkTTL() {
0:         return networkTTL;
0:     }
0: 
1:     /**
0:      * @param networkTTL The networkTTL to set.
1:      */
0:     public void setNetworkTTL(int networkTTL) {
0:         this.networkTTL=networkTTL;
0:     }
0: 
1:     /**
0:      * @return Returns the shutDown.
1:      */
0:     public boolean isShutDown() {
0:         return shutDown;
0:     }
0: 
1:     /**
0:      * @param shutDown The shutDown to set.
1:      */
0:     public void setShutDown(boolean shutDown) {
0:         this.shutDown=shutDown;
0:     }
0: 
1:     public static boolean contains(BrokerId[] brokerPath, BrokerId brokerId) {
0:         if(brokerPath!=null){
0:             for(int i=0;i<brokerPath.length;i++){
0:                 if(brokerId.equals(brokerPath[i]))
0:                     return true;
0:             }
0:         }
0:         return false;
0:     }
0: 
1:     protected BrokerId[] appendToBrokerPath(BrokerId[] brokerPath, BrokerId[] pathsToAppend) {
0:         if (brokerPath == null || brokerPath.length == 0)
1:             return pathsToAppend;
1:         BrokerId rc[] = new BrokerId[brokerPath.length + pathsToAppend.length];
1:         System.arraycopy(brokerPath, 0, rc, 0, brokerPath.length);
1:         System.arraycopy(pathsToAppend, 0, rc, brokerPath.length, pathsToAppend.length);
1:         return rc;
0:     }
0: 
1:     protected BrokerId[] appendToBrokerPath(BrokerId[] brokerPath, BrokerId idToAppend) {
0:         if (brokerPath == null || brokerPath.length == 0)
0:             return new BrokerId[] { idToAppend };
1:         BrokerId rc[] = new BrokerId[brokerPath.length + 1];
1:         System.arraycopy(brokerPath, 0, rc, 0, brokerPath.length);
1:         rc[brokerPath.length] = idToAppend;
1:         return rc;
0:     }
0: 
1:     protected boolean isPermissableDestination(ActiveMQDestination destination) {
0:         DestinationFilter filter=DestinationFilter.parseFilter(destination);
0:         ActiveMQDestination[] dests = excludedDestinations;
0:         if(dests!=null&&dests.length>0){
0:             for(int i=0;i<dests.length;i++){
0:                 ActiveMQDestination match=dests[i];
0:                 if(match!=null&&filter.matches(match)){
0:                     return false;
0:                 }
0:             }
0:         }
1:         dests = dynamicallyIncludedDestinations;
0:         if(dests!=null&&dests.length>0){
0:             for(int i=0;i<dests.length;i++){
0:                 ActiveMQDestination match=dests[i];
0:                 if(match!=null&&filter.matches(match)){
0:                     return true;
0:                 }
0:             }
0:             return false;
0:         }
0:     
0:         return true;
0:     }
0: 
1:     /**
0:      * Subscriptions for these desitnations are always created
0:      *
1:      */
1:     protected void setupStaticDestinations() {
0:         ActiveMQDestination[] dests = staticallyIncludedDestinations;
0:         if (dests != null){
0:             for(int i=0;i<dests.length;i++){
0:                 ActiveMQDestination dest=dests[i];
0:                 DemandSubscription sub = createDemandSubscription(dest);
0:                 try{
0:                     addSubscription(sub);
0:                 }catch(IOException e){
0:                    log.error("Failed to add static destination " + dest,e);
0:                 }
0:                 if(log.isTraceEnabled())
0:                     log.trace("Forwarding messages for static destination: " + dest);
0:             } 
0:         }
0:     }
0: 
0:     protected DemandSubscription createDemandSubscription(ConsumerInfo info) {
0:      return doCreateDemandSubscription(info);
0:     }
0: 
0:     protected DemandSubscription doCreateDemandSubscription(ConsumerInfo info) {
0:         DemandSubscription result=new DemandSubscription(info);
0:         result.getLocalInfo().setConsumerId(new ConsumerId(localSessionInfo.getSessionId(),consumerIdGenerator
0:                         .getNextSequenceId()));
0:         
0:         if( decreaseNetworkConsumerPriority ) {
0:             byte priority=ConsumerInfo.NETWORK_CONSUMER_PRIORITY;
0:             if(priority>Byte.MIN_VALUE&&info.getBrokerPath()!=null&&info.getBrokerPath().length>1){
0:                 // The longer the path to the consumer, the less it's consumer priority.
0:                 priority-=info.getBrokerPath().length+1;
0:             }
1:             result.getLocalInfo().setPriority(priority);
0:         }
0:         configureDemandSubscription(result);
1:         return result;
0:     }
0: 
0:     protected DemandSubscription createDemandSubscription(ActiveMQDestination destination) {
1:         ConsumerInfo info = new ConsumerInfo();
1:         info.setDestination(destination);
0:         //the remote info held by the DemandSubscription holds the original consumerId,
0:         //the local info get's overwritten
0:         info.setConsumerId(new ConsumerId(localSessionInfo.getSessionId(),consumerIdGenerator
0:                         .getNextSequenceId()));
0:         DemandSubscription result=new DemandSubscription(info);
0:         result.getLocalInfo().setPriority(ConsumerInfo.NETWORK_CONSUMER_PRIORITY);
0:         
1:         return result;
0:     }
0: 
0:     protected void configureDemandSubscription(DemandSubscription sub) {
0:         sub.getLocalInfo().setDispatchAsync(dispatchAsync);
0:         sub.getLocalInfo().setPrefetchSize(prefetchSize);
0:         subscriptionMapByLocalId.put(sub.getLocalInfo().getConsumerId(),sub);
0:         subscriptionMapByRemoteId.put(sub.getRemoteInfo().getConsumerId(),sub);
0:     
0:         // This works for now since we use a VM connection to the local broker.
0:         // may need to change if we ever subscribe to a remote broker.
0:         sub.getLocalInfo().setAdditionalPredicate(createNetworkBridgeFilter());
0:     }
0: 
1:     protected void removeDemandSubscription(ConsumerId id) throws IOException {
0:         DemandSubscription sub=(DemandSubscription) subscriptionMapByRemoteId.remove(id);
0:         if (sub != null){
1:             removeSubscription(sub);
0:             if(log.isTraceEnabled())
0:                 log.trace("removing sub on "+localBroker+" from "+remoteBrokerName+" :  "+sub.getRemoteInfo());
0:         }
0:     }
0: 
0:     protected void waitStarted() throws InterruptedException {
0:         startedLatch.await();
0:     }
0: 
0:     protected void clearDownSubscriptions() {
0:         
0:     }
0:     
0: 
0: }
============================================================================