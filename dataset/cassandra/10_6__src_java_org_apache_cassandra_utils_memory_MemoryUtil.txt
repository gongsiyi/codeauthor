1:8541cca: /*
1:8541cca:  * Licensed to the Apache Software Foundation (ASF) under one
1:8541cca:  * or more contributor license agreements.  See the NOTICE file
1:8541cca:  * distributed with this work for additional information
1:8541cca:  * regarding copyright ownership.  The ASF licenses this file
1:8541cca:  * to you under the Apache License, Version 2.0 (the
1:8541cca:  * "License"); you may not use this file except in compliance
1:8541cca:  * with the License.  You may obtain a copy of the License at
1:8541cca:  *
1:8541cca:  *     http://www.apache.org/licenses/LICENSE-2.0
1:8541cca:  *
1:8541cca:  * Unless required by applicable law or agreed to in writing, software
1:8541cca:  * distributed under the License is distributed on an "AS IS" BASIS,
1:8541cca:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:8541cca:  * See the License for the specific language governing permissions and
1:8541cca:  * limitations under the License.
1:8541cca:  */
1:8541cca: package org.apache.cassandra.utils.memory;
1:8541cca: 
1:8541cca: import java.lang.reflect.Field;
1:8541cca: import java.nio.Buffer;
1:8541cca: import java.nio.ByteBuffer;
1:8541cca: import java.nio.ByteOrder;
1:8541cca: 
1:0d2ec11: import com.sun.jna.Native;
1:73b5cab: 
1:73b5cab: import org.apache.cassandra.utils.Architecture;
1:73b5cab: 
1:8541cca: import sun.misc.Unsafe;
1:0d2ec11: import sun.nio.ch.DirectBuffer;
1:8541cca: 
1:8541cca: public abstract class MemoryUtil
1:8541cca: {
1:8541cca:     private static final long UNSAFE_COPY_THRESHOLD = 1024 * 1024L; // copied from java.nio.Bits
1:8541cca: 
1:8541cca:     private static final Unsafe unsafe;
1:72790dc:     private static final Class<?> DIRECT_BYTE_BUFFER_CLASS, RO_DIRECT_BYTE_BUFFER_CLASS;
1:8541cca:     private static final long DIRECT_BYTE_BUFFER_ADDRESS_OFFSET;
1:8541cca:     private static final long DIRECT_BYTE_BUFFER_CAPACITY_OFFSET;
1:8541cca:     private static final long DIRECT_BYTE_BUFFER_LIMIT_OFFSET;
1:16499ca:     private static final long DIRECT_BYTE_BUFFER_POSITION_OFFSET;
1:17dd4cc:     private static final long DIRECT_BYTE_BUFFER_ATTACHMENT_OFFSET;
1:16499ca:     private static final Class<?> BYTE_BUFFER_CLASS;
1:16499ca:     private static final long BYTE_BUFFER_OFFSET_OFFSET;
1:16499ca:     private static final long BYTE_BUFFER_HB_OFFSET;
1:8541cca:     private static final long BYTE_ARRAY_BASE_OFFSET;
1:8541cca: 
1:8541cca:     private static final boolean BIG_ENDIAN = ByteOrder.nativeOrder().equals(ByteOrder.BIG_ENDIAN);
1:8541cca: 
1:73b5cab:     public static final boolean INVERTED_ORDER = Architecture.IS_UNALIGNED && !BIG_ENDIAN;
1:8541cca: 
1:8541cca:     static
1:8541cca:     {
1:8541cca:         try
1:8541cca:         {
1:8541cca:             Field field = sun.misc.Unsafe.class.getDeclaredField("theUnsafe");
1:8541cca:             field.setAccessible(true);
1:8541cca:             unsafe = (sun.misc.Unsafe) field.get(null);
1:8541cca:             Class<?> clazz = ByteBuffer.allocateDirect(0).getClass();
1:8541cca:             DIRECT_BYTE_BUFFER_ADDRESS_OFFSET = unsafe.objectFieldOffset(Buffer.class.getDeclaredField("address"));
1:8541cca:             DIRECT_BYTE_BUFFER_CAPACITY_OFFSET = unsafe.objectFieldOffset(Buffer.class.getDeclaredField("capacity"));
1:8541cca:             DIRECT_BYTE_BUFFER_LIMIT_OFFSET = unsafe.objectFieldOffset(Buffer.class.getDeclaredField("limit"));
1:16499ca:             DIRECT_BYTE_BUFFER_POSITION_OFFSET = unsafe.objectFieldOffset(Buffer.class.getDeclaredField("position"));
1:17dd4cc:             DIRECT_BYTE_BUFFER_ATTACHMENT_OFFSET = unsafe.objectFieldOffset(clazz.getDeclaredField("att"));
1:8541cca:             DIRECT_BYTE_BUFFER_CLASS = clazz;
1:72790dc:             RO_DIRECT_BYTE_BUFFER_CLASS = ByteBuffer.allocateDirect(0).asReadOnlyBuffer().getClass();
1:16499ca: 
1:16499ca:             clazz = ByteBuffer.allocate(0).getClass();
1:16499ca:             BYTE_BUFFER_OFFSET_OFFSET = unsafe.objectFieldOffset(ByteBuffer.class.getDeclaredField("offset"));
1:16499ca:             BYTE_BUFFER_HB_OFFSET = unsafe.objectFieldOffset(ByteBuffer.class.getDeclaredField("hb"));
1:16499ca:             BYTE_BUFFER_CLASS = clazz;
1:16499ca: 
1:8541cca:             BYTE_ARRAY_BASE_OFFSET = unsafe.arrayBaseOffset(byte[].class);
1:8541cca:         }
1:8541cca:         catch (Exception e)
1:8541cca:         {
1:8541cca:             throw new AssertionError(e);
1:8541cca:         }
1:8541cca:     }
1:8541cca: 
1:17dd4cc:     public static int pageSize()
1:17dd4cc:     {
1:17dd4cc:         return unsafe.pageSize();
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     public static long getAddress(ByteBuffer buffer)
1:17dd4cc:     {
1:17dd4cc:         assert buffer.getClass() == DIRECT_BYTE_BUFFER_CLASS;
1:17dd4cc:         return unsafe.getLong(buffer, DIRECT_BYTE_BUFFER_ADDRESS_OFFSET);
1:17dd4cc:     }
1:17dd4cc: 
1:0d2ec11:     public static long allocate(long size)
1:16499ca:     {
1:0d2ec11:         return Native.malloc(size);
1:16499ca:     }
1:16499ca: 
1:0d2ec11:     public static void free(long peer)
2:0d2ec11:     {
1:0d2ec11:         Native.free(peer);
1:16499ca:     }
2:0d2ec11: 
1:8541cca:     public static void setByte(long address, byte b)
1:8541cca:     {
1:8541cca:         unsafe.putByte(address, b);
1:8541cca:     }
1:8541cca: 
1:2f41243:     public static void setByte(long address, int count, byte b)
1:2f41243:     {
1:2f41243:         unsafe.setMemory(address, count, b);
1:2f41243:     }
1:2f41243: 
1:8541cca:     public static void setShort(long address, short s)
1:8541cca:     {
1:8541cca:         unsafe.putShort(address, s);
1:8541cca:     }
1:8541cca: 
1:8541cca:     public static void setInt(long address, int l)
1:8541cca:     {
1:73b5cab:         if (Architecture.IS_UNALIGNED)
1:8541cca:             unsafe.putInt(address, l);
1:8541cca:         else
1:8541cca:             putIntByByte(address, l);
1:8541cca:     }
1:8541cca: 
1:8541cca:     public static void setLong(long address, long l)
1:8541cca:     {
1:73b5cab:         if (Architecture.IS_UNALIGNED)
1:8541cca:             unsafe.putLong(address, l);
1:8541cca:         else
1:8541cca:             putLongByByte(address, l);
1:8541cca:     }
1:8541cca: 
1:8541cca:     public static byte getByte(long address)
1:8541cca:     {
1:8541cca:         return unsafe.getByte(address);
1:8541cca:     }
1:8541cca: 
1:8541cca:     public static int getShort(long address)
1:8541cca:     {
1:73b5cab:         return (Architecture.IS_UNALIGNED ? unsafe.getShort(address) : getShortByByte(address)) & 0xffff;
1:8541cca:     }
1:8541cca: 
1:8541cca:     public static int getInt(long address)
1:8541cca:     {
1:73b5cab:         return Architecture.IS_UNALIGNED ? unsafe.getInt(address) : getIntByByte(address);
1:8541cca:     }
1:8541cca: 
1:8541cca:     public static long getLong(long address)
1:8541cca:     {
1:73b5cab:         return Architecture.IS_UNALIGNED ? unsafe.getLong(address) : getLongByByte(address);
1:8541cca:     }
1:8541cca: 
1:8541cca:     public static ByteBuffer getByteBuffer(long address, int length)
1:8541cca:     {
1:2f41243:         return getByteBuffer(address, length, ByteOrder.nativeOrder());
1:2f41243:     }
1:2f41243: 
1:2f41243:     public static ByteBuffer getByteBuffer(long address, int length, ByteOrder order)
1:2f41243:     {
1:2f41243:         ByteBuffer instance = getHollowDirectByteBuffer(order);
1:bf9c503:         setByteBuffer(instance, address, length);
1:bf9c503:         return instance;
1:bf9c503:     }
1:bf9c503: 
1:bf9c503:     public static ByteBuffer getHollowDirectByteBuffer()
1:bf9c503:     {
1:2f41243:         return getHollowDirectByteBuffer(ByteOrder.nativeOrder());
1:2f41243:     }
1:2f41243: 
1:2f41243:     public static ByteBuffer getHollowDirectByteBuffer(ByteOrder order)
1:2f41243:     {
1:8541cca:         ByteBuffer instance;
1:8541cca:         try
1:8541cca:         {
1:8541cca:             instance = (ByteBuffer) unsafe.allocateInstance(DIRECT_BYTE_BUFFER_CLASS);
1:8541cca:         }
1:8541cca:         catch (InstantiationException e)
1:8541cca:         {
1:8541cca:             throw new AssertionError(e);
1:8541cca:         }
1:2f41243:         instance.order(order);
1:8541cca:         return instance;
2:0d2ec11:     }
1:8541cca: 
1:16499ca:     public static ByteBuffer getHollowByteBuffer()
1:16499ca:     {
1:16499ca:         ByteBuffer instance;
1:16499ca:         try
1:16499ca:         {
1:16499ca:             instance = (ByteBuffer) unsafe.allocateInstance(BYTE_BUFFER_CLASS);
1:16499ca:         }
1:16499ca:         catch (InstantiationException e)
1:16499ca:         {
1:16499ca:             throw new AssertionError(e);
1:16499ca:         }
1:bf9c503:         instance.order(ByteOrder.nativeOrder());
1:bf9c503:         return instance;
1:bf9c503:     }
1:16499ca: 
1:bf9c503:     public static void setByteBuffer(ByteBuffer instance, long address, int length)
1:bf9c503:     {
1:8541cca:         unsafe.putLong(instance, DIRECT_BYTE_BUFFER_ADDRESS_OFFSET, address);
1:8541cca:         unsafe.putInt(instance, DIRECT_BYTE_BUFFER_CAPACITY_OFFSET, length);
1:8541cca:         unsafe.putInt(instance, DIRECT_BYTE_BUFFER_LIMIT_OFFSET, length);
1:8541cca:     }
1:8541cca: 
1:17dd4cc:     public static Object getAttachment(ByteBuffer instance)
1:17dd4cc:     {
1:17dd4cc:         assert instance.getClass() == DIRECT_BYTE_BUFFER_CLASS;
1:17dd4cc:         return unsafe.getObject(instance, DIRECT_BYTE_BUFFER_ATTACHMENT_OFFSET);
1:17dd4cc:     }
1:17dd4cc: 
1:17dd4cc:     public static void setAttachment(ByteBuffer instance, Object next)
1:17dd4cc:     {
1:17dd4cc:         assert instance.getClass() == DIRECT_BYTE_BUFFER_CLASS;
1:17dd4cc:         unsafe.putObject(instance, DIRECT_BYTE_BUFFER_ATTACHMENT_OFFSET, next);
1:17dd4cc:     }
1:17dd4cc: 
1:16499ca:     public static ByteBuffer duplicateDirectByteBuffer(ByteBuffer source, ByteBuffer hollowBuffer)
1:16499ca:     {
1:72790dc:         assert source.getClass() == DIRECT_BYTE_BUFFER_CLASS || source.getClass() == RO_DIRECT_BYTE_BUFFER_CLASS;
1:16499ca:         unsafe.putLong(hollowBuffer, DIRECT_BYTE_BUFFER_ADDRESS_OFFSET, unsafe.getLong(source, DIRECT_BYTE_BUFFER_ADDRESS_OFFSET));
2:16499ca:         unsafe.putInt(hollowBuffer, DIRECT_BYTE_BUFFER_POSITION_OFFSET, unsafe.getInt(source, DIRECT_BYTE_BUFFER_POSITION_OFFSET));
2:16499ca:         unsafe.putInt(hollowBuffer, DIRECT_BYTE_BUFFER_LIMIT_OFFSET, unsafe.getInt(source, DIRECT_BYTE_BUFFER_LIMIT_OFFSET));
2:16499ca:         unsafe.putInt(hollowBuffer, DIRECT_BYTE_BUFFER_CAPACITY_OFFSET, unsafe.getInt(source, DIRECT_BYTE_BUFFER_CAPACITY_OFFSET));
2:16499ca:         return hollowBuffer;
1:16499ca:     }
1:16499ca: 
1:8541cca:     public static long getLongByByte(long address)
1:8541cca:     {
1:8541cca:         if (BIG_ENDIAN)
1:8541cca:         {
1:8541cca:             return  (((long) unsafe.getByte(address    )       ) << 56) |
1:8541cca:                     (((long) unsafe.getByte(address + 1) & 0xff) << 48) |
1:8541cca:                     (((long) unsafe.getByte(address + 2) & 0xff) << 40) |
1:8541cca:                     (((long) unsafe.getByte(address + 3) & 0xff) << 32) |
1:8541cca:                     (((long) unsafe.getByte(address + 4) & 0xff) << 24) |
1:8541cca:                     (((long) unsafe.getByte(address + 5) & 0xff) << 16) |
1:8541cca:                     (((long) unsafe.getByte(address + 6) & 0xff) <<  8) |
1:8541cca:                     (((long) unsafe.getByte(address + 7) & 0xff)      );
1:8541cca:         }
1:8541cca:         else
1:8541cca:         {
1:8541cca:             return  (((long) unsafe.getByte(address + 7)       ) << 56) |
1:8541cca:                     (((long) unsafe.getByte(address + 6) & 0xff) << 48) |
1:8541cca:                     (((long) unsafe.getByte(address + 5) & 0xff) << 40) |
1:8541cca:                     (((long) unsafe.getByte(address + 4) & 0xff) << 32) |
1:8541cca:                     (((long) unsafe.getByte(address + 3) & 0xff) << 24) |
1:8541cca:                     (((long) unsafe.getByte(address + 2) & 0xff) << 16) |
1:8541cca:                     (((long) unsafe.getByte(address + 1) & 0xff) <<  8) |
1:8541cca:                     (((long) unsafe.getByte(address    ) & 0xff)      );
1:8541cca:         }
1:8541cca:     }
1:8541cca: 
1:8541cca:     public static int getIntByByte(long address)
1:8541cca:     {
1:8541cca:         if (BIG_ENDIAN)
1:8541cca:         {
1:8541cca:             return  (((int) unsafe.getByte(address    )       ) << 24) |
1:8541cca:                     (((int) unsafe.getByte(address + 1) & 0xff) << 16) |
1:8541cca:                     (((int) unsafe.getByte(address + 2) & 0xff) << 8 ) |
1:8541cca:                     (((int) unsafe.getByte(address + 3) & 0xff)      );
1:8541cca:         }
1:8541cca:         else
1:8541cca:         {
1:8541cca:             return  (((int) unsafe.getByte(address + 3)       ) << 24) |
1:8541cca:                     (((int) unsafe.getByte(address + 2) & 0xff) << 16) |
1:8541cca:                     (((int) unsafe.getByte(address + 1) & 0xff) <<  8) |
1:8541cca:                     (((int) unsafe.getByte(address    ) & 0xff)      );
1:8541cca:         }
1:8541cca:     }
1:8541cca: 
1:8541cca: 
1:8541cca:     public static int getShortByByte(long address)
1:8541cca:     {
1:8541cca:         if (BIG_ENDIAN)
1:8541cca:         {
1:8541cca:             return  (((int) unsafe.getByte(address    )       ) << 8) |
1:8541cca:                     (((int) unsafe.getByte(address + 1) & 0xff)     );
1:8541cca:         }
1:8541cca:         else
1:8541cca:         {
1:8541cca:             return  (((int) unsafe.getByte(address + 1)       ) <<  8) |
1:8541cca:                     (((int) unsafe.getByte(address    ) & 0xff)      );
1:8541cca:         }
1:8541cca:     }
1:8541cca: 
1:8541cca:     public static void putLongByByte(long address, long value)
1:8541cca:     {
1:8541cca:         if (BIG_ENDIAN)
1:8541cca:         {
1:8541cca:             unsafe.putByte(address, (byte) (value >> 56));
1:8541cca:             unsafe.putByte(address + 1, (byte) (value >> 48));
1:8541cca:             unsafe.putByte(address + 2, (byte) (value >> 40));
1:8541cca:             unsafe.putByte(address + 3, (byte) (value >> 32));
1:8541cca:             unsafe.putByte(address + 4, (byte) (value >> 24));
1:8541cca:             unsafe.putByte(address + 5, (byte) (value >> 16));
1:8541cca:             unsafe.putByte(address + 6, (byte) (value >> 8));
1:8541cca:             unsafe.putByte(address + 7, (byte) (value));
1:8541cca:         }
1:8541cca:         else
1:8541cca:         {
1:8541cca:             unsafe.putByte(address + 7, (byte) (value >> 56));
1:8541cca:             unsafe.putByte(address + 6, (byte) (value >> 48));
1:8541cca:             unsafe.putByte(address + 5, (byte) (value >> 40));
1:8541cca:             unsafe.putByte(address + 4, (byte) (value >> 32));
1:8541cca:             unsafe.putByte(address + 3, (byte) (value >> 24));
1:8541cca:             unsafe.putByte(address + 2, (byte) (value >> 16));
1:8541cca:             unsafe.putByte(address + 1, (byte) (value >> 8));
1:8541cca:             unsafe.putByte(address, (byte) (value));
1:8541cca:         }
1:8541cca:     }
1:8541cca: 
1:8541cca:     public static void putIntByByte(long address, int value)
1:8541cca:     {
1:8541cca:         if (BIG_ENDIAN)
1:8541cca:         {
1:8541cca:             unsafe.putByte(address, (byte) (value >> 24));
1:8541cca:             unsafe.putByte(address + 1, (byte) (value >> 16));
1:8541cca:             unsafe.putByte(address + 2, (byte) (value >> 8));
1:8541cca:             unsafe.putByte(address + 3, (byte) (value));
1:8541cca:         }
1:8541cca:         else
1:8541cca:         {
1:8541cca:             unsafe.putByte(address + 3, (byte) (value >> 24));
1:8541cca:             unsafe.putByte(address + 2, (byte) (value >> 16));
1:8541cca:             unsafe.putByte(address + 1, (byte) (value >> 8));
1:8541cca:             unsafe.putByte(address, (byte) (value));
1:8541cca:         }
1:8541cca:     }
1:8541cca: 
1:8541cca:     public static void setBytes(long address, ByteBuffer buffer)
1:8541cca:     {
1:8541cca:         int start = buffer.position();
1:8541cca:         int count = buffer.limit() - start;
1:8541cca:         if (count == 0)
1:8541cca:             return;
1:8541cca: 
1:8541cca:         if (buffer.isDirect())
1:0d2ec11:             setBytes(((DirectBuffer)buffer).address() + start, address, count);
1:8541cca:         else
1:708b0ce:             setBytes(address, buffer.array(), buffer.arrayOffset() + start, count);
1:8541cca:     }
1:8541cca: 
1:8541cca:     /**
1:8541cca:      * Transfers count bytes from buffer to Memory
1:8541cca:      *
1:8541cca:      * @param address start offset in the memory
1:8541cca:      * @param buffer the data buffer
1:8541cca:      * @param bufferOffset start offset of the buffer
1:8541cca:      * @param count number of bytes to transfer
1:8541cca:      */
1:8541cca:     public static void setBytes(long address, byte[] buffer, int bufferOffset, int count)
1:8541cca:     {
1:8541cca:         assert buffer != null;
1:8541cca:         assert !(bufferOffset < 0 || count < 0 || bufferOffset + count > buffer.length);
1:8541cca:         setBytes(buffer, bufferOffset, address, count);
1:8541cca:     }
1:8541cca: 
1:8541cca:     public static void setBytes(long src, long trg, long count)
1:8541cca:     {
1:8541cca:         while (count > 0)
1:8541cca:         {
1:8541cca:             long size = (count> UNSAFE_COPY_THRESHOLD) ? UNSAFE_COPY_THRESHOLD : count;
1:8541cca:             unsafe.copyMemory(src, trg, size);
1:8541cca:             count -= size;
1:8541cca:             src += size;
1:8541cca:             trg+= size;
1:8541cca:         }
1:8541cca:     }
1:8541cca: 
1:8541cca:     public static void setBytes(byte[] src, int offset, long trg, long count)
1:8541cca:     {
1:8541cca:         while (count > 0)
1:8541cca:         {
1:8541cca:             long size = (count> UNSAFE_COPY_THRESHOLD) ? UNSAFE_COPY_THRESHOLD : count;
1:8541cca:             unsafe.copyMemory(src, BYTE_ARRAY_BASE_OFFSET + offset, null, trg, size);
1:8541cca:             count -= size;
1:8541cca:             offset += size;
1:8541cca:             trg += size;
1:8541cca:         }
1:8541cca:     }
1:8541cca: 
1:8541cca:     /**
1:8541cca:      * Transfers count bytes from Memory starting at memoryOffset to buffer starting at bufferOffset
1:8541cca:      *
1:8541cca:      * @param address start offset in the memory
1:8541cca:      * @param buffer the data buffer
1:8541cca:      * @param bufferOffset start offset of the buffer
1:8541cca:      * @param count number of bytes to transfer
1:8541cca:      */
1:8541cca:     public static void getBytes(long address, byte[] buffer, int bufferOffset, int count)
1:8541cca:     {
1:8541cca:         if (buffer == null)
1:8541cca:             throw new NullPointerException();
1:8541cca:         else if (bufferOffset < 0 || count < 0 || count > buffer.length - bufferOffset)
1:8541cca:             throw new IndexOutOfBoundsException();
1:8541cca:         else if (count == 0)
1:8541cca:             return;
1:8541cca: 
1:8541cca:         unsafe.copyMemory(null, address, buffer, BYTE_ARRAY_BASE_OFFSET + bufferOffset, count);
1:8541cca:     }
1:8541cca: }
============================================================================
author:Dave Brosius
-------------------------------------------------------------------------------
commit:73b5cab
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.cassandra.utils.Architecture;
1: 
/////////////////////////////////////////////////////////////////////////
1:     public static final boolean INVERTED_ORDER = Architecture.IS_UNALIGNED && !BIG_ENDIAN;
/////////////////////////////////////////////////////////////////////////
1:         if (Architecture.IS_UNALIGNED)
/////////////////////////////////////////////////////////////////////////
1:         if (Architecture.IS_UNALIGNED)
/////////////////////////////////////////////////////////////////////////
1:         return (Architecture.IS_UNALIGNED ? unsafe.getShort(address) : getShortByByte(address)) & 0xffff;
1:         return Architecture.IS_UNALIGNED ? unsafe.getInt(address) : getIntByByte(address);
1:         return Architecture.IS_UNALIGNED ? unsafe.getLong(address) : getLongByByte(address);
commit:3ca9576
/////////////////////////////////////////////////////////////////////////
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:c7547e0
commit:362e132
author:Rei Odaira
-------------------------------------------------------------------------------
commit:38ed061
/////////////////////////////////////////////////////////////////////////
0:         return (UNALIGNED ? unsafe.getShort(address) : getShortByByte(address)) & 0xffff;
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:1fce648
commit:8fc1b28
/////////////////////////////////////////////////////////////////////////
0:         // Note that s390x architecture are not officially supported and adding it here is only done out of convenience
0:         // for those that want to run C* on this architecture at their own risk (see #11214)
0:                 || arch.equals("amd64") || arch.equals("x86_64") || arch.equals("s390x");
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:2f41243
/////////////////////////////////////////////////////////////////////////
1:     public static void setByte(long address, int count, byte b)
1:     {
1:         unsafe.setMemory(address, count, b);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         return getByteBuffer(address, length, ByteOrder.nativeOrder());
1:     }
1: 
1:     public static ByteBuffer getByteBuffer(long address, int length, ByteOrder order)
1:     {
1:         ByteBuffer instance = getHollowDirectByteBuffer(order);
1:         return getHollowDirectByteBuffer(ByteOrder.nativeOrder());
1:     }
1: 
1:     public static ByteBuffer getHollowDirectByteBuffer(ByteOrder order)
1:     {
/////////////////////////////////////////////////////////////////////////
1:         instance.order(order);
commit:79f230f
commit:82aa796
commit:986a1a7
/////////////////////////////////////////////////////////////////////////
0:         return UNALIGNED ? unsafe.getShort(address) & 0xffff : getShortByByte(address);
commit:bf9c503
/////////////////////////////////////////////////////////////////////////
0:         ByteBuffer instance = getHollowDirectByteBuffer();
1:         setByteBuffer(instance, address, length);
1:         return instance;
1:     }
1: 
1:     public static ByteBuffer getHollowDirectByteBuffer()
1:     {
/////////////////////////////////////////////////////////////////////////
1:         instance.order(ByteOrder.nativeOrder());
1:         return instance;
1:     }
1:     public static void setByteBuffer(ByteBuffer instance, long address, int length)
1:     {
commit:5a17ec8
commit:708b0ce
/////////////////////////////////////////////////////////////////////////
1:             setBytes(address, buffer.array(), buffer.arrayOffset() + start, count);
commit:e77ea12
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.primitives.*;
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:72790dc
/////////////////////////////////////////////////////////////////////////
1:     private static final Class<?> DIRECT_BYTE_BUFFER_CLASS, RO_DIRECT_BYTE_BUFFER_CLASS;
/////////////////////////////////////////////////////////////////////////
1:             RO_DIRECT_BYTE_BUFFER_CLASS = ByteBuffer.allocateDirect(0).asReadOnlyBuffer().getClass();
/////////////////////////////////////////////////////////////////////////
1:         assert source.getClass() == DIRECT_BYTE_BUFFER_CLASS || source.getClass() == RO_DIRECT_BYTE_BUFFER_CLASS;
commit:8541cca
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.utils.memory;
1: 
1: import java.lang.reflect.Field;
1: import java.nio.Buffer;
1: import java.nio.ByteBuffer;
1: import java.nio.ByteOrder;
1: 
1: import sun.misc.Unsafe;
1: 
1: public abstract class MemoryUtil
1: {
1:     private static final long UNSAFE_COPY_THRESHOLD = 1024 * 1024L; // copied from java.nio.Bits
1: 
1:     private static final Unsafe unsafe;
0:     private static final Class<?> DIRECT_BYTE_BUFFER_CLASS;
1:     private static final long DIRECT_BYTE_BUFFER_ADDRESS_OFFSET;
1:     private static final long DIRECT_BYTE_BUFFER_CAPACITY_OFFSET;
1:     private static final long DIRECT_BYTE_BUFFER_LIMIT_OFFSET;
1:     private static final long BYTE_ARRAY_BASE_OFFSET;
1: 
1:     private static final boolean BIG_ENDIAN = ByteOrder.nativeOrder().equals(ByteOrder.BIG_ENDIAN);
1: 
0:     private static final boolean UNALIGNED;
0:     public static final boolean INVERTED_ORDER;
1: 
1:     static
1:     {
0:         String arch = System.getProperty("os.arch");
0:         UNALIGNED = arch.equals("i386") || arch.equals("x86")
0:                 || arch.equals("amd64") || arch.equals("x86_64");
0:         INVERTED_ORDER = UNALIGNED && !BIG_ENDIAN;
1:         try
1:         {
1:             Field field = sun.misc.Unsafe.class.getDeclaredField("theUnsafe");
1:             field.setAccessible(true);
1:             unsafe = (sun.misc.Unsafe) field.get(null);
1:             Class<?> clazz = ByteBuffer.allocateDirect(0).getClass();
1:             DIRECT_BYTE_BUFFER_ADDRESS_OFFSET = unsafe.objectFieldOffset(Buffer.class.getDeclaredField("address"));
1:             DIRECT_BYTE_BUFFER_CAPACITY_OFFSET = unsafe.objectFieldOffset(Buffer.class.getDeclaredField("capacity"));
1:             DIRECT_BYTE_BUFFER_LIMIT_OFFSET = unsafe.objectFieldOffset(Buffer.class.getDeclaredField("limit"));
1:             DIRECT_BYTE_BUFFER_CLASS = clazz;
1:             BYTE_ARRAY_BASE_OFFSET = unsafe.arrayBaseOffset(byte[].class);
1:         }
1:         catch (Exception e)
1:         {
1:             throw new AssertionError(e);
1:         }
1:     }
1: 
1:     public static void setByte(long address, byte b)
1:     {
1:         unsafe.putByte(address, b);
1:     }
1: 
1:     public static void setShort(long address, short s)
1:     {
1:         unsafe.putShort(address, s);
1:     }
1: 
1:     public static void setInt(long address, int l)
1:     {
0:         if (UNALIGNED)
1:             unsafe.putInt(address, l);
1:         else
1:             putIntByByte(address, l);
1:     }
1: 
1:     public static void setLong(long address, long l)
1:     {
0:         if (UNALIGNED)
1:             unsafe.putLong(address, l);
1:         else
1:             putLongByByte(address, l);
1:     }
1: 
1:     public static byte getByte(long address)
1:     {
1:         return unsafe.getByte(address);
1:     }
1: 
1:     public static int getShort(long address)
1:     {
0:         return UNALIGNED ? unsafe.getShort(address) : getShortByByte(address);
1:     }
1: 
1:     public static int getInt(long address)
1:     {
0:         return UNALIGNED ? unsafe.getInt(address) : getIntByByte(address);
1:     }
1: 
1:     public static long getLong(long address)
1:     {
0:         return UNALIGNED ? unsafe.getLong(address) : getLongByByte(address);
1:     }
1: 
1:     public static ByteBuffer getByteBuffer(long address, int length)
1:     {
1:         ByteBuffer instance;
1:         try
1:         {
1:             instance = (ByteBuffer) unsafe.allocateInstance(DIRECT_BYTE_BUFFER_CLASS);
1:         }
1:         catch (InstantiationException e)
1:         {
1:             throw new AssertionError(e);
1:         }
1: 
1:         unsafe.putLong(instance, DIRECT_BYTE_BUFFER_ADDRESS_OFFSET, address);
1:         unsafe.putInt(instance, DIRECT_BYTE_BUFFER_CAPACITY_OFFSET, length);
1:         unsafe.putInt(instance, DIRECT_BYTE_BUFFER_LIMIT_OFFSET, length);
1:         return instance;
1:     }
1: 
1:     public static long getLongByByte(long address)
1:     {
1:         if (BIG_ENDIAN)
1:         {
1:             return  (((long) unsafe.getByte(address    )       ) << 56) |
1:                     (((long) unsafe.getByte(address + 1) & 0xff) << 48) |
1:                     (((long) unsafe.getByte(address + 2) & 0xff) << 40) |
1:                     (((long) unsafe.getByte(address + 3) & 0xff) << 32) |
1:                     (((long) unsafe.getByte(address + 4) & 0xff) << 24) |
1:                     (((long) unsafe.getByte(address + 5) & 0xff) << 16) |
1:                     (((long) unsafe.getByte(address + 6) & 0xff) <<  8) |
1:                     (((long) unsafe.getByte(address + 7) & 0xff)      );
1:         }
1:         else
1:         {
1:             return  (((long) unsafe.getByte(address + 7)       ) << 56) |
1:                     (((long) unsafe.getByte(address + 6) & 0xff) << 48) |
1:                     (((long) unsafe.getByte(address + 5) & 0xff) << 40) |
1:                     (((long) unsafe.getByte(address + 4) & 0xff) << 32) |
1:                     (((long) unsafe.getByte(address + 3) & 0xff) << 24) |
1:                     (((long) unsafe.getByte(address + 2) & 0xff) << 16) |
1:                     (((long) unsafe.getByte(address + 1) & 0xff) <<  8) |
1:                     (((long) unsafe.getByte(address    ) & 0xff)      );
1:         }
1:     }
1: 
1:     public static int getIntByByte(long address)
1:     {
1:         if (BIG_ENDIAN)
1:         {
1:             return  (((int) unsafe.getByte(address    )       ) << 24) |
1:                     (((int) unsafe.getByte(address + 1) & 0xff) << 16) |
1:                     (((int) unsafe.getByte(address + 2) & 0xff) << 8 ) |
1:                     (((int) unsafe.getByte(address + 3) & 0xff)      );
1:         }
1:         else
1:         {
1:             return  (((int) unsafe.getByte(address + 3)       ) << 24) |
1:                     (((int) unsafe.getByte(address + 2) & 0xff) << 16) |
1:                     (((int) unsafe.getByte(address + 1) & 0xff) <<  8) |
1:                     (((int) unsafe.getByte(address    ) & 0xff)      );
1:         }
1:     }
1: 
1: 
1:     public static int getShortByByte(long address)
1:     {
1:         if (BIG_ENDIAN)
1:         {
1:             return  (((int) unsafe.getByte(address    )       ) << 8) |
1:                     (((int) unsafe.getByte(address + 1) & 0xff)     );
1:         }
1:         else
1:         {
1:             return  (((int) unsafe.getByte(address + 1)       ) <<  8) |
1:                     (((int) unsafe.getByte(address    ) & 0xff)      );
1:         }
1:     }
1: 
1:     public static void putLongByByte(long address, long value)
1:     {
1:         if (BIG_ENDIAN)
1:         {
1:             unsafe.putByte(address, (byte) (value >> 56));
1:             unsafe.putByte(address + 1, (byte) (value >> 48));
1:             unsafe.putByte(address + 2, (byte) (value >> 40));
1:             unsafe.putByte(address + 3, (byte) (value >> 32));
1:             unsafe.putByte(address + 4, (byte) (value >> 24));
1:             unsafe.putByte(address + 5, (byte) (value >> 16));
1:             unsafe.putByte(address + 6, (byte) (value >> 8));
1:             unsafe.putByte(address + 7, (byte) (value));
1:         }
1:         else
1:         {
1:             unsafe.putByte(address + 7, (byte) (value >> 56));
1:             unsafe.putByte(address + 6, (byte) (value >> 48));
1:             unsafe.putByte(address + 5, (byte) (value >> 40));
1:             unsafe.putByte(address + 4, (byte) (value >> 32));
1:             unsafe.putByte(address + 3, (byte) (value >> 24));
1:             unsafe.putByte(address + 2, (byte) (value >> 16));
1:             unsafe.putByte(address + 1, (byte) (value >> 8));
1:             unsafe.putByte(address, (byte) (value));
1:         }
1:     }
1: 
1:     public static void putIntByByte(long address, int value)
1:     {
1:         if (BIG_ENDIAN)
1:         {
1:             unsafe.putByte(address, (byte) (value >> 24));
1:             unsafe.putByte(address + 1, (byte) (value >> 16));
1:             unsafe.putByte(address + 2, (byte) (value >> 8));
1:             unsafe.putByte(address + 3, (byte) (value));
1:         }
1:         else
1:         {
1:             unsafe.putByte(address + 3, (byte) (value >> 24));
1:             unsafe.putByte(address + 2, (byte) (value >> 16));
1:             unsafe.putByte(address + 1, (byte) (value >> 8));
1:             unsafe.putByte(address, (byte) (value));
1:         }
1:     }
1: 
1:     public static void setBytes(long address, ByteBuffer buffer)
1:     {
1:         int start = buffer.position();
1:         int count = buffer.limit() - start;
1:         if (count == 0)
1:             return;
1: 
1:         if (buffer.isDirect())
0:             setBytes(unsafe.getLong(buffer, DIRECT_BYTE_BUFFER_ADDRESS_OFFSET) + start, address, count);
1:         else
0:             setBytes(address, buffer.array(), start, count);
1:     }
1: 
1:     /**
1:      * Transfers count bytes from buffer to Memory
1:      *
1:      * @param address start offset in the memory
1:      * @param buffer the data buffer
1:      * @param bufferOffset start offset of the buffer
1:      * @param count number of bytes to transfer
1:      */
1:     public static void setBytes(long address, byte[] buffer, int bufferOffset, int count)
1:     {
1:         assert buffer != null;
1:         assert !(bufferOffset < 0 || count < 0 || bufferOffset + count > buffer.length);
1:         setBytes(buffer, bufferOffset, address, count);
1:     }
1: 
1:     public static void setBytes(long src, long trg, long count)
1:     {
1:         while (count > 0)
1:         {
1:             long size = (count> UNSAFE_COPY_THRESHOLD) ? UNSAFE_COPY_THRESHOLD : count;
1:             unsafe.copyMemory(src, trg, size);
1:             count -= size;
1:             src += size;
1:             trg+= size;
1:         }
1:     }
1: 
1:     public static void setBytes(byte[] src, int offset, long trg, long count)
1:     {
1:         while (count > 0)
1:         {
1:             long size = (count> UNSAFE_COPY_THRESHOLD) ? UNSAFE_COPY_THRESHOLD : count;
1:             unsafe.copyMemory(src, BYTE_ARRAY_BASE_OFFSET + offset, null, trg, size);
1:             count -= size;
1:             offset += size;
1:             trg += size;
1:         }
1:     }
1: 
1:     /**
1:      * Transfers count bytes from Memory starting at memoryOffset to buffer starting at bufferOffset
1:      *
1:      * @param address start offset in the memory
1:      * @param buffer the data buffer
1:      * @param bufferOffset start offset of the buffer
1:      * @param count number of bytes to transfer
1:      */
1:     public static void getBytes(long address, byte[] buffer, int bufferOffset, int count)
1:     {
1:         if (buffer == null)
1:             throw new NullPointerException();
1:         else if (bufferOffset < 0 || count < 0 || count > buffer.length - bufferOffset)
1:             throw new IndexOutOfBoundsException();
1:         else if (count == 0)
1:             return;
1: 
1:         unsafe.copyMemory(null, address, buffer, BYTE_ARRAY_BASE_OFFSET + bufferOffset, count);
1:     }
1: }
author:stefania
-------------------------------------------------------------------------------
commit:17dd4cc
/////////////////////////////////////////////////////////////////////////
1:     private static final long DIRECT_BYTE_BUFFER_ATTACHMENT_OFFSET;
/////////////////////////////////////////////////////////////////////////
1:             DIRECT_BYTE_BUFFER_ATTACHMENT_OFFSET = unsafe.objectFieldOffset(clazz.getDeclaredField("att"));
/////////////////////////////////////////////////////////////////////////
1:     public static int pageSize()
1:     {
1:         return unsafe.pageSize();
1:     }
1: 
1:     public static long getAddress(ByteBuffer buffer)
1:     {
1:         assert buffer.getClass() == DIRECT_BYTE_BUFFER_CLASS;
1:         return unsafe.getLong(buffer, DIRECT_BYTE_BUFFER_ADDRESS_OFFSET);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public static Object getAttachment(ByteBuffer instance)
1:     {
1:         assert instance.getClass() == DIRECT_BYTE_BUFFER_CLASS;
1:         return unsafe.getObject(instance, DIRECT_BYTE_BUFFER_ATTACHMENT_OFFSET);
1:     }
1: 
1:     public static void setAttachment(ByteBuffer instance, Object next)
1:     {
1:         assert instance.getClass() == DIRECT_BYTE_BUFFER_CLASS;
1:         unsafe.putObject(instance, DIRECT_BYTE_BUFFER_ATTACHMENT_OFFSET, next);
1:     }
1: 
0:         assert source.getClass() == DIRECT_BYTE_BUFFER_CLASS;
/////////////////////////////////////////////////////////////////////////
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:16499ca
/////////////////////////////////////////////////////////////////////////
1:     private static final long DIRECT_BYTE_BUFFER_POSITION_OFFSET;
1:     private static final Class<?> BYTE_BUFFER_CLASS;
1:     private static final long BYTE_BUFFER_OFFSET_OFFSET;
1:     private static final long BYTE_BUFFER_HB_OFFSET;
/////////////////////////////////////////////////////////////////////////
1:             DIRECT_BYTE_BUFFER_POSITION_OFFSET = unsafe.objectFieldOffset(Buffer.class.getDeclaredField("position"));
1: 
1:             clazz = ByteBuffer.allocate(0).getClass();
1:             BYTE_BUFFER_OFFSET_OFFSET = unsafe.objectFieldOffset(ByteBuffer.class.getDeclaredField("offset"));
1:             BYTE_BUFFER_HB_OFFSET = unsafe.objectFieldOffset(ByteBuffer.class.getDeclaredField("hb"));
1:             BYTE_BUFFER_CLASS = clazz;
1: 
/////////////////////////////////////////////////////////////////////////
1:     public static ByteBuffer getHollowByteBuffer()
1:     {
1:         ByteBuffer instance;
1:         try
1:         {
1:             instance = (ByteBuffer) unsafe.allocateInstance(BYTE_BUFFER_CLASS);
1:         }
1:         catch (InstantiationException e)
1:         {
1:             throw new AssertionError(e);
1:         }
0:         instance.order(ByteOrder.nativeOrder());
0:         return instance;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public static ByteBuffer duplicateDirectByteBuffer(ByteBuffer source, ByteBuffer hollowBuffer)
1:     {
0:         assert(source.isDirect());
1:         unsafe.putLong(hollowBuffer, DIRECT_BYTE_BUFFER_ADDRESS_OFFSET, unsafe.getLong(source, DIRECT_BYTE_BUFFER_ADDRESS_OFFSET));
1:         unsafe.putInt(hollowBuffer, DIRECT_BYTE_BUFFER_POSITION_OFFSET, unsafe.getInt(source, DIRECT_BYTE_BUFFER_POSITION_OFFSET));
1:         unsafe.putInt(hollowBuffer, DIRECT_BYTE_BUFFER_LIMIT_OFFSET, unsafe.getInt(source, DIRECT_BYTE_BUFFER_LIMIT_OFFSET));
1:         unsafe.putInt(hollowBuffer, DIRECT_BYTE_BUFFER_CAPACITY_OFFSET, unsafe.getInt(source, DIRECT_BYTE_BUFFER_CAPACITY_OFFSET));
1:         return hollowBuffer;
1:     }
1: 
0:     public static ByteBuffer duplicateByteBuffer(ByteBuffer source, ByteBuffer hollowBuffer)
1:     {
0:         assert(!source.isDirect());
1:         unsafe.putInt(hollowBuffer, DIRECT_BYTE_BUFFER_POSITION_OFFSET, unsafe.getInt(source, DIRECT_BYTE_BUFFER_POSITION_OFFSET));
1:         unsafe.putInt(hollowBuffer, DIRECT_BYTE_BUFFER_LIMIT_OFFSET, unsafe.getInt(source, DIRECT_BYTE_BUFFER_LIMIT_OFFSET));
1:         unsafe.putInt(hollowBuffer, DIRECT_BYTE_BUFFER_CAPACITY_OFFSET, unsafe.getInt(source, DIRECT_BYTE_BUFFER_CAPACITY_OFFSET));
0:         unsafe.putInt(hollowBuffer, BYTE_BUFFER_OFFSET_OFFSET, unsafe.getInt(source, BYTE_BUFFER_OFFSET_OFFSET));
0:         unsafe.putObject(hollowBuffer, BYTE_BUFFER_HB_OFFSET, unsafe.getObject(source, BYTE_BUFFER_HB_OFFSET));
1:         return hollowBuffer;
1:     }
1: 
author:Robert Stupp
-------------------------------------------------------------------------------
commit:0d2ec11
/////////////////////////////////////////////////////////////////////////
1: import com.sun.jna.Native;
1: import sun.nio.ch.DirectBuffer;
/////////////////////////////////////////////////////////////////////////
1:     public static long allocate(long size)
1:     {
1:         return Native.malloc(size);
1:     }
1: 
1:     public static void free(long peer)
1:     {
1:         Native.free(peer);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             setBytes(((DirectBuffer)buffer).address() + start, address, count);
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:1ac72f6
/////////////////////////////////////////////////////////////////////////
0:         instance.order(ByteOrder.nativeOrder());
============================================================================