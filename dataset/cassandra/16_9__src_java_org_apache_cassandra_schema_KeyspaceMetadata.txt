1:07cf56f: /*
1:fbda616:  * Licensed to the Apache Software Foundation (ASF) under one
1:fbda616:  * or more contributor license agreements.  See the NOTICE file
1:fbda616:  * distributed with this work for additional information
1:fbda616:  * regarding copyright ownership.  The ASF licenses this file
1:fbda616:  * to you under the Apache License, Version 2.0 (the
1:fbda616:  * "License"); you may not use this file except in compliance
1:fbda616:  * with the License.  You may obtain a copy of the License at
7:37b0793:  *
1:fbda616:  *     http://www.apache.org/licenses/LICENSE-2.0
1:37b0793:  *
1:fbda616:  * Unless required by applicable law or agreed to in writing, software
1:fbda616:  * distributed under the License is distributed on an "AS IS" BASIS,
1:fbda616:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:fbda616:  * See the License for the specific language governing permissions and
1:fbda616:  * limitations under the License.
3:37b0793:  */
1:a89597d: package org.apache.cassandra.schema;
1:1adcd1c: 
1:06c130e: import java.util.HashSet;
1:06c130e: import java.util.Optional;
1:06c130e: import java.util.Set;
1:e98eb1c: 
1:fa800fc: import javax.annotation.Nullable;
1:ef25537: 
1:e8a0d0a: import com.google.common.base.MoreObjects;
1:a4ed367: import com.google.common.base.Objects;
1:a3a8dbc: import com.google.common.collect.Iterables;
1:916c810: 
1:a89597d: import org.apache.cassandra.config.CFMetaData;
1:9797511: import org.apache.cassandra.config.SchemaConstants;
1:a3a8dbc: import org.apache.cassandra.config.ViewDefinition;
1:3a2faf9: import org.apache.cassandra.exceptions.ConfigurationException;
1:06c130e: 
1:31e3f61: /**
1:31e3f61:  * An immutable representation of keyspace metadata (name, params, tables, types, and functions).
1:31e3f61:  */
1:a89597d: public final class KeyspaceMetadata
1:06c130e: {
1:fbda616:     public final String name;
1:31e3f61:     public final KeyspaceParams params;
1:6e1033b:     public final Tables tables;
1:a3a8dbc:     public final Views views;
1:2f2b58d:     public final Types types;
1:3566843:     public final Functions functions;
1:fa800fc: 
1:a3a8dbc:     private KeyspaceMetadata(String name, KeyspaceParams params, Tables tables, Views views, Types types, Functions functions)
1:a3a8dbc:     {
1:fbda616:         this.name = name;
1:31e3f61:         this.params = params;
1:6e1033b:         this.tables = tables;
1:a3a8dbc:         this.views = views;
1:2f2b58d:         this.types = types;
1:3566843:         this.functions = functions;
1:5c94432:     }
1:5c94432: 
1:a89597d:     public static KeyspaceMetadata create(String name, KeyspaceParams params)
1:5c94432:     {
1:a3a8dbc:         return new KeyspaceMetadata(name, params, Tables.none(), Views.none(), Types.none(), Functions.none());
1:ccb0028:     }
1:ccb0028: 
1:a89597d:     public static KeyspaceMetadata create(String name, KeyspaceParams params, Tables tables)
1:ccb0028:     {
1:a3a8dbc:         return new KeyspaceMetadata(name, params, tables, Views.none(), Types.none(), Functions.none());
1:ccb0028:     }
1:ccb0028: 
1:a3a8dbc:     public static KeyspaceMetadata create(String name, KeyspaceParams params, Tables tables, Views views, Types types, Functions functions)
1:ccb0028:     {
1:a3a8dbc:         return new KeyspaceMetadata(name, params, tables, views, types, functions);
1:8cc192f:     }
1:8cc192f: 
1:a89597d:     public KeyspaceMetadata withSwapped(KeyspaceParams params)
1:8cc192f:     {
1:a3a8dbc:         return new KeyspaceMetadata(name, params, tables, views, types, functions);
1:8cc192f:     }
1:8cc192f: 
1:a3a8dbc:     public KeyspaceMetadata withSwapped(Tables regular)
1:8cc192f:     {
1:a3a8dbc:         return new KeyspaceMetadata(name, params, regular, views, types, functions);
1:921f499:     }
1:8cc192f: 
1:a3a8dbc:     public KeyspaceMetadata withSwapped(Views views)
1:921f499:     {
1:a3a8dbc:         return new KeyspaceMetadata(name, params, tables, views, types, functions);
1:921f499:     }
1:8cc192f: 
1:a89597d:     public KeyspaceMetadata withSwapped(Types types)
1:921f499:     {
1:a3a8dbc:         return new KeyspaceMetadata(name, params, tables, views, types, functions);
1:1adcd1c:     }
1:8cc192f: 
1:a89597d:     public KeyspaceMetadata withSwapped(Functions functions)
1:1adcd1c:     {
1:a3a8dbc:         return new KeyspaceMetadata(name, params, tables, views, types, functions);
1:1adcd1c:     }
1:921f499: 
1:a3a8dbc:     public Iterable<CFMetaData> tablesAndViews()
1:1adcd1c:     {
1:a3a8dbc:         return Iterables.concat(tables, views.metadatas());
1:1adcd1c:     }
1:921f499: 
1:a3a8dbc:     @Nullable
1:a3a8dbc:     public CFMetaData getTableOrViewNullable(String tableOrViewName)
1:1adcd1c:     {
1:a3a8dbc:         ViewDefinition view = views.getNullable(tableOrViewName);
1:a3a8dbc:         return view == null
1:a3a8dbc:              ? tables.getNullable(tableOrViewName)
1:a3a8dbc:              : view.metadata;
1:8c7bc2f:     }
1:1adcd1c: 
1:06c130e:     public Set<String> existingIndexNames(String cfToExclude)
1:8c7bc2f:     {
1:06c130e:         Set<String> indexNames = new HashSet<>();
1:06c130e:         for (CFMetaData table : tables)
1:06c130e:             if (cfToExclude == null || !table.cfName.equals(cfToExclude))
1:06c130e:                 for (IndexMetadata index : table.getIndexes())
1:06c130e:                     indexNames.add(index.name);
1:06c130e:         return indexNames;
1:009bd2c:     }
1:1adcd1c: 
1:06c130e:     public Optional<CFMetaData> findIndexedTable(String indexName)
1:009bd2c:     {
1:a3a8dbc:         for (CFMetaData cfm : tablesAndViews())
1:06c130e:             if (cfm.getIndexes().has(indexName))
1:06c130e:                 return Optional.of(cfm);
1:8c7bc2f: 
1:06c130e:         return Optional.empty();
1:06c130e:     }
1:009bd2c: 
1:a4ed367:     @Override
1:e4e375b:     public int hashCode()
1:e4e375b:     {
1:a3a8dbc:         return Objects.hashCode(name, params, tables, views, functions, types);
1:e4e375b:     }
1:e4e375b: 
1:a4ed367:     @Override
1:a4ed367:     public boolean equals(Object o)
1:06c130e:     {
1:a4ed367:         if (this == o)
1:a4ed367:             return true;
1:06c130e: 
1:a89597d:         if (!(o instanceof KeyspaceMetadata))
4:fbda616:             return false;
1:06c130e: 
1:a89597d:         KeyspaceMetadata other = (KeyspaceMetadata) o;
1:06c130e: 
1:31e3f61:         return name.equals(other.name)
1:31e3f61:             && params.equals(other.params)
1:31e3f61:             && tables.equals(other.tables)
1:a3a8dbc:             && views.equals(other.views)
1:31e3f61:             && functions.equals(other.functions)
1:31e3f61:             && types.equals(other.types);
1:06c130e:     }
2:a3a8dbc: 
1:42d14c0:     @Override
1:42d14c0:     public String toString()
1:a3a8dbc:     {
1:e8a0d0a:         return MoreObjects.toStringHelper(this)
1:e8a0d0a:                           .add("name", name)
1:e8a0d0a:                           .add("params", params)
1:e8a0d0a:                           .add("tables", tables)
1:e8a0d0a:                           .add("views", views)
1:e8a0d0a:                           .add("functions", functions)
1:e8a0d0a:                           .add("types", types)
1:e8a0d0a:                           .toString();
1:a3a8dbc:     }
1:a3a8dbc: 
1:31e3f61:     public void validate()
1:a3a8dbc:     {
1:522730a:         if (!CFMetaData.isNameValid(name))
1:31e3f61:             throw new ConfigurationException(String.format("Keyspace name must not be empty, more than %s characters long, "
1:31e3f61:                                                            + "or contain non-alphanumeric-underscore characters (got \"%s\")",
1:9797511:                                                            SchemaConstants.NAME_LENGTH,
1:31e3f61:                                                            name));
1:c10ae57:         params.validate(name);
1:a3a8dbc:         tablesAndViews().forEach(CFMetaData::validate);
1:a3a8dbc:     }
1:a3a8dbc: }
============================================================================
author:Robert Stupp
-------------------------------------------------------------------------------
commit:9797511
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.SchemaConstants;
/////////////////////////////////////////////////////////////////////////
1:                                                            SchemaConstants.NAME_LENGTH,
commit:e2f35c7
/////////////////////////////////////////////////////////////////////////
0:         mutation.delete(SystemKeyspace.SCHEMA_AGGREGATES_TABLE, timestamp);
commit:b4d7f3b
/////////////////////////////////////////////////////////////////////////
0:         mutation.delete(SystemKeyspace.SCHEMA_FUNCTIONS_TABLE, timestamp);
commit:25411bf
/////////////////////////////////////////////////////////////////////////
0:                                                 CFMetaData.SchemaFunctionsCf,
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:e8a0d0a
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.base.MoreObjects;
/////////////////////////////////////////////////////////////////////////
1:         return MoreObjects.toStringHelper(this)
1:                           .add("name", name)
1:                           .add("params", params)
1:                           .add("tables", tables)
1:                           .add("views", views)
1:                           .add("functions", functions)
1:                           .add("types", types)
1:                           .toString();
commit:02d5ef3
commit:64890d8
/////////////////////////////////////////////////////////////////////////
0:         return new KSMetaData(Tracing.TRACE_KS, SimpleStrategy.class, ImmutableMap.of("replication_factor", "2"), true, cfDefs);
commit:c8915ce
/////////////////////////////////////////////////////////////////////////
0:                                                 CFMetaData.PaxosCf,
0:                                                 CFMetaData.SSTableActivityCF);
commit:7f2c3a8
/////////////////////////////////////////////////////////////////////////
0:                                                 CFMetaData.PaxosCf);
commit:8b0e186
/////////////////////////////////////////////////////////////////////////
0:                                                 CFMetaData.PaxosCf,
commit:f112f99
commit:aa90c88
/////////////////////////////////////////////////////////////////////////
0:                                                 CFMetaData.CompactionLogCF,
commit:5225ed9
/////////////////////////////////////////////////////////////////////////
0:                                                 CFMetaData.OldMigrationsCf,
0:                                                 CFMetaData.OldSchemaCf);
commit:7dee84c
commit:05a5ede
/////////////////////////////////////////////////////////////////////////
0:             throw new ConfigurationException(String.format("Keyspace name must not be empty, more than %s characters long, or contain non-alphanumeric-underscore characters (got \"%s\")", Schema.NAME_LENGTH, name));
commit:b38ca28
/////////////////////////////////////////////////////////////////////////
0:         List<CFMetaData> cfDefs = Arrays.asList(CFMetaData.BatchlogCF,
0:                                                 CFMetaData.LocalCf,
commit:5c94432
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.collect.ImmutableMap;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.tracing.Tracing;
/////////////////////////////////////////////////////////////////////////
0:         return new KSMetaData(Table.SYSTEM_KS, LocalStrategy.class, Collections.<String, String>emptyMap(), true, cfDefs);
1:     }
1: 
0:     public static KSMetaData traceKeyspace()
1:     {
0:         List<CFMetaData> cfDefs = Arrays.asList(CFMetaData.TraceSessionsCf, CFMetaData.TraceEventsCf);
0:         return new KSMetaData(Tracing.TRACE_KS, SimpleStrategy.class, ImmutableMap.of("replication_factor", "1"), true, cfDefs);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation(Table.SYSTEM_KS, SystemTable.getSchemaKSKey(name));
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation(Table.SYSTEM_KS, SystemTable.getSchemaKSKey(name));
commit:debb15e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public KSMetaData reloadAttributes()
0:             throw new RuntimeException(String.format("%s not found in the schema definitions table (%s).", name, SystemTable.SCHEMA_KEYSPACES_CF));
/////////////////////////////////////////////////////////////////////////
0:     public static KSMetaData fromSchema(Row row, Iterable<CFMetaData> cfms)
/////////////////////////////////////////////////////////////////////////
0:     public static KSMetaData fromSchema(Row serializedKs, Row serializedCFs)
commit:326312b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             return new KSMetaData(result.getString("keyspace_name"),
commit:8ea2d2a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         List<CFMetaData> cfDefs = Arrays.asList(CFMetaData.LocalCf,
0:                                                 CFMetaData.PeersCf,
0:                                                 CFMetaData.OldStatusCf,
0:                                                 CFMetaData.OldHintsCf,
0:                                                 CFMetaData.MigrationsCf,
0:                                                 CFMetaData.SchemaCf);
commit:c3e6a1c
commit:374fa2c
/////////////////////////////////////////////////////////////////////////
0:         return new KSMetaData(Table.SYSTEM_TABLE, LocalStrategy.class, Collections.<String, String>emptyMap(), true, cfDefs);
commit:ccb0028
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.cql3.QueryProcessor;
0: import org.apache.cassandra.cql3.UntypedResultSet;
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.cassandra.utils.FBUtilities.*;
/////////////////////////////////////////////////////////////////////////
0:     KSMetaData(String name, Class<? extends AbstractReplicationStrategy> strategyClass, Map<String, String> strategyOptions, boolean durableWrites, Iterable<CFMetaData> cfDefs)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public RowMutation diff(KSMetaData newState, long modificationTimestamp)
0:         return newState.toSchema(modificationTimestamp);
0:         if (ksDefRow.cf == null)
0:         return fromSchema(ksDefRow, Collections.<CFMetaData>emptyList());
0:     public RowMutation dropFromSchema(long timestamp)
0:         RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, SystemTable.getSchemaKSKey(name));
0:         rm.delete(new QueryPath(SystemTable.SCHEMA_KEYSPACES_CF), timestamp);
0:         rm.delete(new QueryPath(SystemTable.SCHEMA_COLUMNFAMILIES_CF), timestamp);
0:         rm.delete(new QueryPath(SystemTable.SCHEMA_COLUMNS_CF), timestamp);
0:         return rm;
1:     }
1: 
0:     public RowMutation toSchema(long timestamp)
1:     {
0:         RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, SystemTable.getSchemaKSKey(name));
0:         ColumnFamily cf = rm.addOrGet(SystemTable.SCHEMA_KEYSPACES_CF);
1: 
0:         cf.addColumn(Column.create(name, timestamp, "name"));
0:         cf.addColumn(Column.create(durableWrites, timestamp, "durable_writes"));
0:         cf.addColumn(Column.create(strategyClass.getName(), timestamp, "strategy_class"));
0:         cf.addColumn(Column.create(json(strategyOptions), timestamp, "strategy_options"));
0:             cfm.toSchema(rm, timestamp);
0:         return rm;
0:      * @param row Keyspace attributes in serialized form
0:     public static KSMetaData fromSchema(Row row, Iterable<CFMetaData> cfms) throws IOException
0:         UntypedResultSet.Row result = QueryProcessor.resultify("SELECT * FROM system.schema_keyspaces", row).one();
0:         try
0:             return new KSMetaData(result.getString("name"),
0:                                   AbstractReplicationStrategy.getClass(result.getString("strategy_class")),
0:                                   fromJsonMap(result.getString("strategy_options")),
0:                                   result.getBoolean("durable_writes"),
0:                                   cfms);
0:         catch (ConfigurationException e)
1:         {
0:             throw new RuntimeException(e);
1:         }
0:      * @param serializedKs Keyspace in serialized form
0:     public static KSMetaData fromSchema(Row serializedKs, Row serializedCFs) throws IOException
0:         Map<String, CFMetaData> cfs = deserializeColumnFamilies(serializedCFs);
0:         return fromSchema(serializedKs, cfs.values());
0:      * @param row
0:     public static Map<String, CFMetaData> deserializeColumnFamilies(Row row)
0:         if (row.cf == null)
0:             return Collections.emptyMap();
0:         Map<String, CFMetaData> cfms = new HashMap<String, CFMetaData>();
0:         UntypedResultSet results = QueryProcessor.resultify("SELECT * FROM system.schema_columnfamilies", row);
0:         for (UntypedResultSet.Row result : results)
0:             CFMetaData cfm = CFMetaData.fromSchema(result);
0:             cfms.put(cfm.cfName, cfm);
0:         for (CFMetaData cfm : cfms.values())
0:             Row columnRow = ColumnDefinition.readSchema(cfm.ksName, cfm.cfName);
0:             for (ColumnDefinition cd : ColumnDefinition.fromSchema(columnRow, cfm.comparator))
0:                 cfm.column_metadata.put(cd.name, cd);
0:         return cfms;
commit:38ee718
/////////////////////////////////////////////////////////////////////////
0:         List<CfDef> cfDefs = new ArrayList<CfDef>(cfMetaData.size());
/////////////////////////////////////////////////////////////////////////
0:         List<RowMutation> mutations = new ArrayList<RowMutation>(cfMetaData.size());
commit:f0ec9e4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                               ksd.strategy_options == null ? Collections.<String, String>emptyMap() : ksd.strategy_options,
/////////////////////////////////////////////////////////////////////////
commit:8cc192f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.lang.StringUtils;
0: import org.apache.cassandra.db.Table;
0: import org.apache.cassandra.locator.LocalStrategy;
0:     public final boolean durableWrites;
0:     private KSMetaData(String name, Class<? extends AbstractReplicationStrategy> strategyClass, Map<String, String> strategyOptions, boolean durableWrites, Iterable<CFMetaData> cfDefs)
/////////////////////////////////////////////////////////////////////////
0:         this.durableWrites = durableWrites;
1: 
0:     public static KSMetaData cloneWith(KSMetaData ksm, Iterable<CFMetaData> cfDefs)
0:         return new KSMetaData(ksm.name, ksm.strategyClass, ksm.strategyOptions, ksm.durableWrites, cfDefs);
1: 
0:     public static KSMetaData systemKeyspace()
0:         List<CFMetaData> cfDefs = Arrays.asList(CFMetaData.StatusCf,
0:                                                 CFMetaData.HintsCf,
0:                                                 CFMetaData.MigrationsCf,
0:                                                 CFMetaData.SchemaCf,
0:                                                 CFMetaData.IndexCf,
0:                                                 CFMetaData.NodeIdCf,
0:                                                 CFMetaData.VersionCf);
0:         return new KSMetaData(Table.SYSTEM_TABLE, LocalStrategy.class, optsWithRF(1), false, cfDefs);
1: 
0:     public static KSMetaData testMetadata(String name, Class<? extends AbstractReplicationStrategy> strategyClass, Map<String, String> strategyOptions, CFMetaData... cfDefs)
1:     {
0:         return new KSMetaData(name, strategyClass, strategyOptions, true, Arrays.asList(cfDefs));
1:     }
1: 
0:     public static KSMetaData testMetadataNotDurable(String name, Class<? extends AbstractReplicationStrategy> strategyClass, Map<String, String> strategyOptions, CFMetaData... cfDefs)
1:     {
0:         return new KSMetaData(name, strategyClass, strategyOptions, false, Arrays.asList(cfDefs));
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:                 && other.durableWrites == durableWrites;
/////////////////////////////////////////////////////////////////////////
0:         ks.durable_writes = durableWrites;
/////////////////////////////////////////////////////////////////////////
0:           .append(", durable_writes: ").append(durableWrites);
/////////////////////////////////////////////////////////////////////////
0:         List<CFMetaData> cfMetaData = new ArrayList<CFMetaData>(cfsz);
0:             cfMetaData.add(CFMetaData.fromAvro(cfiter.next()));
/////////////////////////////////////////////////////////////////////////
0:                               Arrays.asList(cfDefs));
/////////////////////////////////////////////////////////////////////////
0:         ksdef.setDurable_writes(durableWrites);
commit:0bbc22c
/////////////////////////////////////////////////////////////////////////
0:         Class<? extends AbstractReplicationStrategy> repStratClass;
/////////////////////////////////////////////////////////////////////////
0:                 String name = e.getKey().toString();
0:                 // Silently discard a replication_factor option to NTS.
0:                 // The history is, people were creating CFs with the default settings (which in the CLI is NTS) and then
0:                 // giving it a replication_factor option, which is nonsensical.  Initially our strategy was to silently
0:                 // ignore this option, but that turned out to confuse people more.  So in 0.8.2 we switched to throwing
0:                 // an exception in the NTS constructor, which would be turned into an InvalidRequestException for the
0:                 // client.  But, it also prevented startup for anyone upgrading without first cleaning that option out.
0:                 if (repStratClass == NetworkTopologyStrategy.class && name.trim().toLowerCase().equals("replication_factor"))
0:                     continue;
0:                 strategyOptions.put(name, e.getValue().toString());
commit:c3566e9
commit:f5f96c1
commit:98dfbfa
commit:921f499
/////////////////////////////////////////////////////////////////////////
0: import java.util.*;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.thrift.CfDef;
/////////////////////////////////////////////////////////////////////////
0:     public static Map<String, String> forwardsCompatibleOptions(KsDef ks_def)
/////////////////////////////////////////////////////////////////////////
1: 
0:     public static KSMetaData fromThrift(KsDef ksd, CFMetaData... cfDefs) throws ConfigurationException
1:     {
0:         return new KSMetaData(ksd.name,
0:                               AbstractReplicationStrategy.getClass(ksd.strategy_class),
0:                               forwardsCompatibleOptions(ksd),
0:                               cfDefs);
1:     }
1: 
0:     public static KsDef toThrift(KSMetaData ksm)
1:     {
0:         List<CfDef> cfDefs = new ArrayList<CfDef>();
0:         for (CFMetaData cfm : ksm.cfMetaData().values())
0:             cfDefs.add(CFMetaData.convertToThrift(cfm));
0:         KsDef ksdef = new KsDef(ksm.name, ksm.strategyClass.getName(), cfDefs);
0:         ksdef.setStrategy_options(ksm.strategyOptions);
0:         if (ksm.strategyOptions != null && ksm.strategyOptions.containsKey("replication_factor"))
0:             ksdef.setReplication_factor(Integer.parseInt(ksm.strategyOptions.get("replication_factor")));
0:         return ksdef;
1:     }
commit:1adcd1c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.thrift.KsDef;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:     public static Map<String, String> backwardsCompatibleOptions(KsDef ks_def)
1:     {
0:         Map<String, String> options;
0:         if (ks_def.isSetReplication_factor())
1:         {
0:             options = new HashMap<String, String>(ks_def.strategy_options == null ? Collections.<String, String>emptyMap() : ks_def.strategy_options);
0:             options.put("replication_factor", String.valueOf(ks_def.replication_factor));
1:         }
0:         else
1:         {
0:             options = ks_def.strategy_options;
1:         }
0:         return options;
1:     }
1: 
commit:8c7bc2f
/////////////////////////////////////////////////////////////////////////
0:     public KSMetaData(String name, Class<? extends AbstractReplicationStrategy> strategyClass, Map<String, String> strategyOptions, CFMetaData... cfDefs)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         return new KSMetaData(ks.name.toString(), repStratClass, strategyOptions, cfMetaData);
/////////////////////////////////////////////////////////////////////////
1: 
0:     public static Map<String,String> optsWithRF(final Integer rf)
1:     {
0:         Map<String, String> ret = new HashMap<String,String>();
0:         ret.put("replication_factor", rf.toString());
0:         return ret;
1:     }
commit:a51ab03
commit:71f0028
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.locator.NetworkTopologyStrategy;
/////////////////////////////////////////////////////////////////////////
0:         this.strategyClass = strategyClass == null ? NetworkTopologyStrategy.class : strategyClass;
commit:936b464
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.locator.SimpleStrategy;
/////////////////////////////////////////////////////////////////////////
0:         this.strategyClass = strategyClass == null ? SimpleStrategy.class : strategyClass;
commit:e98eb1c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.avro.util.Utf8;
0: import org.apache.cassandra.io.SerDeUtils;
0: import org.apache.cassandra.locator.AbstractReplicationStrategy;
0: import org.apache.cassandra.locator.SimpleStrategy;
1: 
commit:ef25537
/////////////////////////////////////////////////////////////////////////
0: import org.apache.avro.util.Utf8;
0: import org.apache.cassandra.io.SerDeUtils;
0: import org.apache.cassandra.locator.AbstractReplicationStrategy;
0: import org.apache.cassandra.locator.SimpleStrategy;
1: 
commit:e4e375b
/////////////////////////////////////////////////////////////////////////
1:     public int hashCode()
1:     {
0:         return name.hashCode();
1:     }
1: 
commit:406f4b3
/////////////////////////////////////////////////////////////////////////
0:                    .replace("RackAwareStrategy", "OldNetworkTopologyStrategy");
commit:009bd2c
/////////////////////////////////////////////////////////////////////////
0:             String strategyClassName = convertOldStrategyName(ks.strategy_class.toString());
0:             repStratClass = (Class<AbstractReplicationStrategy>)Class.forName(strategyClassName);
/////////////////////////////////////////////////////////////////////////
1: 
0:     public static String convertOldStrategyName(String name)
1:     {
0:         return name.replace("RackUnawareStrategy", "SimpleStrategy")
0:                    .replace("RackAwareStrategy", "OldNetworkTopologyStrategy")
0:                    .replace("DatacenterShardStrategy", "NetworkTopologyStrategy");
1:     }
commit:916c810
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.locator.SimpleStrategy;
1: 
/////////////////////////////////////////////////////////////////////////
0:         this.strategyClass = strategyClass == null ? SimpleStrategy.class : strategyClass;
commit:078c56c
/////////////////////////////////////////////////////////////////////////
0:         this.cfMetaData = Collections.unmodifiableMap(cfmap);
commit:242b717
/////////////////////////////////////////////////////////////////////////
0:             catch (ConfigurationException e)
0:                 throw new IOException(e);
commit:2e1b1a5
/////////////////////////////////////////////////////////////////////////
commit:79e9a80
/////////////////////////////////////////////////////////////////////////
0:     public KSMetaData(String name, Class<? extends AbstractReplicationStrategy> strategyClass, int replicationFactor, CFMetaData... cfDefs)
/////////////////////////////////////////////////////////////////////////
0:         return new KSMetaData(newName, ksm.strategyClass, ksm.replicationFactor, newCfs.toArray(new CFMetaData[newCfs.size()]));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         return new KSMetaData(name, repStratClass, replicationFactor, cfMetaData);
author:Sam Tunnicliffe
-------------------------------------------------------------------------------
commit:c10ae57
/////////////////////////////////////////////////////////////////////////
1:         params.validate(name);
commit:06c130e
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
1: import java.util.Optional;
1: import java.util.Set;
1: 
/////////////////////////////////////////////////////////////////////////
1:     public Set<String> existingIndexNames(String cfToExclude)
1:     {
1:         Set<String> indexNames = new HashSet<>();
1:         for (CFMetaData table : tables)
1:             if (cfToExclude == null || !table.cfName.equals(cfToExclude))
1:                 for (IndexMetadata index : table.getIndexes())
1:                     indexNames.add(index.name);
1:         return indexNames;
1:     }
1: 
1:     public Optional<CFMetaData> findIndexedTable(String indexName)
1:     {
0:         for (CFMetaData cfm : tables)
1:             if (cfm.getIndexes().has(indexName))
1:                 return Optional.of(cfm);
1: 
1:         return Optional.empty();
1:     }
1: 
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:fa800fc
/////////////////////////////////////////////////////////////////////////
1: import javax.annotation.Nullable;
1: 
commit:7ff2805
/////////////////////////////////////////////////////////////////////////
author:Carl Yeksigian
-------------------------------------------------------------------------------
commit:a3a8dbc
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.collect.Iterables;
0: import org.apache.avro.reflect.Nullable;
1: import org.apache.cassandra.config.ViewDefinition;
/////////////////////////////////////////////////////////////////////////
1:     public final Views views;
1:     private KeyspaceMetadata(String name, KeyspaceParams params, Tables tables, Views views, Types types, Functions functions)
1:         this.views = views;
1:         return new KeyspaceMetadata(name, params, Tables.none(), Views.none(), Types.none(), Functions.none());
1:         return new KeyspaceMetadata(name, params, tables, Views.none(), Types.none(), Functions.none());
1:     public static KeyspaceMetadata create(String name, KeyspaceParams params, Tables tables, Views views, Types types, Functions functions)
1:         return new KeyspaceMetadata(name, params, tables, views, types, functions);
1:         return new KeyspaceMetadata(name, params, tables, views, types, functions);
1:     public KeyspaceMetadata withSwapped(Tables regular)
1:         return new KeyspaceMetadata(name, params, regular, views, types, functions);
1:     }
1: 
1:     public KeyspaceMetadata withSwapped(Views views)
1:     {
1:         return new KeyspaceMetadata(name, params, tables, views, types, functions);
1:         return new KeyspaceMetadata(name, params, tables, views, types, functions);
1:         return new KeyspaceMetadata(name, params, tables, views, types, functions);
1:     }
1: 
1:     public Iterable<CFMetaData> tablesAndViews()
1:     {
1:         return Iterables.concat(tables, views.metadatas());
1:     }
1: 
1:     @Nullable
1:     public CFMetaData getTableOrViewNullable(String tableOrViewName)
1:     {
1:         ViewDefinition view = views.getNullable(tableOrViewName);
1:         return view == null
1:              ? tables.getNullable(tableOrViewName)
1:              : view.metadata;
/////////////////////////////////////////////////////////////////////////
1:         for (CFMetaData cfm : tablesAndViews())
/////////////////////////////////////////////////////////////////////////
1:         return Objects.hashCode(name, params, tables, views, functions, types);
/////////////////////////////////////////////////////////////////////////
1:             && views.equals(other.views)
/////////////////////////////////////////////////////////////////////////
0:                       .add("views", views)
/////////////////////////////////////////////////////////////////////////
1:         tablesAndViews().forEach(CFMetaData::validate);
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:a89597d
/////////////////////////////////////////////////////////////////////////
1: package org.apache.cassandra.schema;
1: import org.apache.cassandra.config.CFMetaData;
0: import org.apache.cassandra.config.Schema;
1: public final class KeyspaceMetadata
/////////////////////////////////////////////////////////////////////////
0:     private KeyspaceMetadata(String name, KeyspaceParams params, Tables tables, Types types, Functions functions)
/////////////////////////////////////////////////////////////////////////
1:     public static KeyspaceMetadata create(String name, KeyspaceParams params)
0:         return new KeyspaceMetadata(name, params, Tables.none(), Types.none(), Functions.none());
1:     public static KeyspaceMetadata create(String name, KeyspaceParams params, Tables tables)
0:         return new KeyspaceMetadata(name, params, tables, Types.none(), Functions.none());
0:     public static KeyspaceMetadata create(String name, KeyspaceParams params, Tables tables, Types types, Functions functions)
0:         return new KeyspaceMetadata(name, params, tables, types, functions);
1:     public KeyspaceMetadata withSwapped(KeyspaceParams params)
0:         return new KeyspaceMetadata(name, params, tables, types, functions);
0:     public KeyspaceMetadata withSwapped(Tables tables)
0:         return new KeyspaceMetadata(name, params, tables, types, functions);
1:     public KeyspaceMetadata withSwapped(Types types)
0:         return new KeyspaceMetadata(name, params, tables, types, functions);
1:     public KeyspaceMetadata withSwapped(Functions functions)
0:         return new KeyspaceMetadata(name, params, tables, types, functions);
/////////////////////////////////////////////////////////////////////////
1:         if (!(o instanceof KeyspaceMetadata))
1:         KeyspaceMetadata other = (KeyspaceMetadata) o;
commit:31e3f61
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.schema.*;
1: /**
1:  * An immutable representation of keyspace metadata (name, params, tables, types, and functions).
1:  */
1:     public final KeyspaceParams params;
0:     private KSMetaData(String name, KeyspaceParams params, Tables tables, Types types, Functions functions)
1:         this.params = params;
0:     public static KSMetaData create(String name, KeyspaceParams params)
0:         return new KSMetaData(name, params, Tables.none(), Types.none(), Functions.none());
0:     public static KSMetaData create(String name, KeyspaceParams params, Tables tables)
0:         return new KSMetaData(name, params, tables, Types.none(), Functions.none());
0:     public static KSMetaData create(String name, KeyspaceParams params, Tables tables, Types types, Functions functions)
0:         return new KSMetaData(name, params, tables, types, functions);
0:     public KSMetaData withSwapped(KeyspaceParams params)
0:         return new KSMetaData(name, params, tables, types, functions);
0:     public KSMetaData withSwapped(Tables tables)
0:         return new KSMetaData(name, params, tables, types, functions);
0:     public KSMetaData withSwapped(Types types)
0:         return new KSMetaData(name, params, tables, types, functions);
0:     public KSMetaData withSwapped(Functions functions)
0:         return new KSMetaData(name, params, tables, types, functions);
0:         return Objects.hashCode(name, params, tables, functions, types);
/////////////////////////////////////////////////////////////////////////
1:         return name.equals(other.name)
1:             && params.equals(other.params)
1:             && tables.equals(other.tables)
1:             && functions.equals(other.functions)
1:             && types.equals(other.types);
/////////////////////////////////////////////////////////////////////////
0:                       .add("params", params)
1:     public void validate()
1:             throw new ConfigurationException(String.format("Keyspace name must not be empty, more than %s characters long, "
1:                                                            + "or contain non-alphanumeric-underscore characters (got \"%s\")",
0:                                                            Schema.NAME_LENGTH,
1:                                                            name));
commit:6e1033b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.schema.Tables;
/////////////////////////////////////////////////////////////////////////
1:     public final Tables tables;
/////////////////////////////////////////////////////////////////////////
0:         this(name, strategyClass, strategyOptions, durableWrites, Tables.none(), Types.none(), Functions.none());
0:                       Tables tables)
0:         this(name, strategyClass, strategyOptions, durableWrites, tables, Types.none(), Functions.none());
0:                       Tables tables,
0:         this(name, strategyClass, strategyOptions, durableWrites, tables, Types.none(), functions);
0:                        Tables tables,
1:         this.tables = tables;
/////////////////////////////////////////////////////////////////////////
0:         return newKeyspace(name, cls, options, durableWrites, Tables.none());
0:         return new KSMetaData(name, strategyClass, options, durablesWrites, Tables.of(cfDefs), Types.none(), Functions.none());
0:     public KSMetaData cloneWith(Tables tables, Types types, Functions functions)
0:         return new KSMetaData(name, strategyClass, strategyOptions, durableWrites, tables, types, functions);
0:     public KSMetaData cloneWith(Tables tables)
0:         return new KSMetaData(name, strategyClass, strategyOptions, durableWrites, tables, types, functions);
0:         return new KSMetaData(name, strategyClass, strategyOptions, durableWrites, tables, types, functions);
0:         return new KSMetaData(name, strategyClass, strategyOptions, true, Tables.of(cfDefs));
0:         return new KSMetaData(name, strategyClass, strategyOptions, false, Tables.of(cfDefs));
0:         return Objects.hashCode(name, strategyClass, strategyOptions, durableWrites, tables, functions, types);
/////////////////////////////////////////////////////////////////////////
0:             && Objects.equal(tables, other.tables)
/////////////////////////////////////////////////////////////////////////
0:                       .add("tables", tables)
/////////////////////////////////////////////////////////////////////////
0:         tables.forEach(CFMetaData::validate);
commit:2f2b58d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.schema.Types;
/////////////////////////////////////////////////////////////////////////
1:     public final Types types;
/////////////////////////////////////////////////////////////////////////
0:         this(name, strategyClass, strategyOptions, durableWrites, Collections.<CFMetaData>emptyList(), Types.none(), Functions.none());
/////////////////////////////////////////////////////////////////////////
0:         this(name, strategyClass, strategyOptions, durableWrites, cfDefs, Types.none(), Functions.none());
/////////////////////////////////////////////////////////////////////////
0:         this(name, strategyClass, strategyOptions, durableWrites, cfDefs, Types.none(), functions);
/////////////////////////////////////////////////////////////////////////
0:                        Types types,
/////////////////////////////////////////////////////////////////////////
1:         this.types = types;
/////////////////////////////////////////////////////////////////////////
0:         return new KSMetaData(name, strategyClass, options, durablesWrites, cfDefs, Types.none(), Functions.none());
/////////////////////////////////////////////////////////////////////////
0:         return cloneWith(newTables, types, functions);
/////////////////////////////////////////////////////////////////////////
0:         return cloneWith(newTables, types, functions);
0:     public KSMetaData cloneWith(Iterable<CFMetaData> tables, Types types, Functions functions)
0:     public KSMetaData cloneWith(Types types)
0:     {
0:         return new KSMetaData(name, strategyClass, strategyOptions, durableWrites, cfMetaData.values(), types, functions);
0:     }
0: 
0:         return new KSMetaData(name, strategyClass, strategyOptions, durableWrites, cfMetaData.values(), types, functions);
/////////////////////////////////////////////////////////////////////////
0:         return Objects.hashCode(name, strategyClass, strategyOptions, cfMetaData, durableWrites, functions, types);
/////////////////////////////////////////////////////////////////////////
0:             && Objects.equal(types, other.types);
/////////////////////////////////////////////////////////////////////////
0:                       .add("types", types)
commit:3566843
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.schema.Functions;
/////////////////////////////////////////////////////////////////////////
1:     public final Functions functions;
0:         this(name, strategyClass, strategyOptions, durableWrites, Collections.<CFMetaData>emptyList(), new UTMetaData(), Functions.none());
/////////////////////////////////////////////////////////////////////////
0:         this(name, strategyClass, strategyOptions, durableWrites, cfDefs, new UTMetaData(), Functions.none());
0:     }
0: 
0:     public KSMetaData(String name,
0:                       Class<? extends AbstractReplicationStrategy> strategyClass,
0:                       Map<String, String> strategyOptions,
0:                       boolean durableWrites,
0:                       Iterable<CFMetaData> cfDefs,
0:                       Functions functions)
0:     {
0:         this(name, strategyClass, strategyOptions, durableWrites, cfDefs, new UTMetaData(), functions);
/////////////////////////////////////////////////////////////////////////
0:                        UTMetaData userTypes,
0:                        Functions functions)
/////////////////////////////////////////////////////////////////////////
1:         this.functions = functions;
/////////////////////////////////////////////////////////////////////////
0:         return new KSMetaData(name, strategyClass, options, durablesWrites, cfDefs, new UTMetaData(), Functions.none());
/////////////////////////////////////////////////////////////////////////
0:         return cloneWith(newTables, userTypes, functions);
/////////////////////////////////////////////////////////////////////////
0:         return cloneWith(newTables, userTypes, functions);
0:     public KSMetaData cloneWith(Iterable<CFMetaData> tables, UTMetaData types, Functions functions)
0:         return new KSMetaData(name, strategyClass, strategyOptions, durableWrites, tables, types, functions);
0:     }
0: 
0:     public KSMetaData cloneWith(Functions functions)
0:     {
0:         return new KSMetaData(name, strategyClass, strategyOptions, durableWrites, cfMetaData.values(), userTypes, functions);
/////////////////////////////////////////////////////////////////////////
0:         return Objects.hashCode(name, strategyClass, strategyOptions, cfMetaData, durableWrites, functions, userTypes);
/////////////////////////////////////////////////////////////////////////
0:             && Objects.equal(functions, other.functions)
/////////////////////////////////////////////////////////////////////////
0:                       .add("functions", functions)
/////////////////////////////////////////////////////////////////////////
0:         cfMetaData.values().forEach(CFMetaData::validate);
commit:3e9d345
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                       boolean durableWrites)
0:     {
0:         this(name, strategyClass, strategyOptions, durableWrites, Collections.<CFMetaData>emptyList(), new UTMetaData());
0:     }
0: 
0:     public KSMetaData(String name,
0:                       Class<? extends AbstractReplicationStrategy> strategyClass,
0:                       Map<String, String> strategyOptions,
0:     private KSMetaData(String name,
0:                        Class<? extends AbstractReplicationStrategy> strategyClass,
0:                        Map<String, String> strategyOptions,
0:                        boolean durableWrites,
0:                        Iterable<CFMetaData> cfDefs,
0:                        UTMetaData userTypes)
/////////////////////////////////////////////////////////////////////////
0:     public KSMetaData cloneWithTableRemoved(CFMetaData table)
0:         // clone ksm but do not include the new table
0:         List<CFMetaData> newTables = new ArrayList<>(cfMetaData().values());
0:         newTables.remove(table);
0:         assert newTables.size() == cfMetaData().size() - 1;
0:         return cloneWith(newTables, userTypes);
0:     }
0: 
0:     public KSMetaData cloneWithTableAdded(CFMetaData table)
0:     {
0:         // clone ksm but include the new table
0:         List<CFMetaData> newTables = new ArrayList<>(cfMetaData().values());
0:         newTables.add(table);
0:         assert newTables.size() == cfMetaData().size() + 1;
0:         return cloneWith(newTables, userTypes);
0:     }
0: 
0:     public KSMetaData cloneWith(Iterable<CFMetaData> tables, UTMetaData types)
0:     {
0:         return new KSMetaData(name, strategyClass, strategyOptions, durableWrites, tables, types);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:611d1ba
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         Row ksDefRow = SystemKeyspace.readSchemaRow(SystemKeyspace.SCHEMA_KEYSPACES_TABLE, name);
0:             throw new RuntimeException(String.format("%s not found in the schema definitions keyspaceName (%s).", name, SystemKeyspace.SCHEMA_KEYSPACES_TABLE));
0:         Mutation mutation = new Mutation(SystemKeyspace.NAME, SystemKeyspace.getSchemaKSKey(name));
0:         mutation.delete(SystemKeyspace.SCHEMA_KEYSPACES_TABLE, timestamp);
0:         mutation.delete(SystemKeyspace.SCHEMA_COLUMNFAMILIES_TABLE, timestamp);
0:         mutation.delete(SystemKeyspace.SCHEMA_COLUMNS_TABLE, timestamp);
0:         mutation.delete(SystemKeyspace.SCHEMA_TRIGGERS_TABLE, timestamp);
0:         mutation.delete(SystemKeyspace.SCHEMA_USER_TYPES_TABLE, timestamp);
0:         mutation.delete(SystemKeyspace.BUILT_INDEXES_TABLE, timestamp);
0:         Mutation mutation = new Mutation(SystemKeyspace.NAME, SystemKeyspace.getSchemaKSKey(name));
0:         ColumnFamily cf = mutation.addOrGet(SystemKeyspace.SchemaKeyspacesTable);
0:         CFRowAdder adder = new CFRowAdder(cf, SystemKeyspace.SchemaKeyspacesTable.comparator.builder().build(), timestamp);
commit:a94b173
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public KSMetaData(String name,
0:                       Class<? extends AbstractReplicationStrategy> strategyClass,
0:                       Map<String, String> strategyOptions,
0:                       boolean durableWrites,
0:                       Iterable<CFMetaData> cfDefs)
/////////////////////////////////////////////////////////////////////////
commit:9da949b
/////////////////////////////////////////////////////////////////////////
0:         Row ksDefRow = SystemKeyspace.readSchemaRow(SystemKeyspace.SCHEMA_KEYSPACES_CF, name);
commit:99594cd
/////////////////////////////////////////////////////////////////////////
commit:a4ed367
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.base.Objects;
/////////////////////////////////////////////////////////////////////////
0:         Map<String, CFMetaData> cfmap = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1:     @Override
0:         return Objects.hashCode(name, strategyClass, strategyOptions, cfMetaData, durableWrites, userTypes);
1:     @Override
1:     public boolean equals(Object o)
1:         if (this == o)
1:             return true;
0: 
0:         if (!(o instanceof KSMetaData))
0: 
0:         KSMetaData other = (KSMetaData) o;
0: 
0:         return Objects.equal(name, other.name)
0:             && Objects.equal(strategyClass, other.strategyClass)
0:             && Objects.equal(strategyOptions, other.strategyOptions)
0:             && Objects.equal(cfMetaData, other.cfMetaData)
0:             && Objects.equal(durableWrites, other.durableWrites)
0:             && Objects.equal(userTypes, other.userTypes);
/////////////////////////////////////////////////////////////////////////
0:         return Objects.toStringHelper(this)
0:                       .add("name", name)
0:                       .add("strategyClass", strategyClass.getSimpleName())
0:                       .add("strategyOptions", strategyOptions)
0:                       .add("cfMetaData", cfMetaData)
0:                       .add("durableWrites", durableWrites)
0:                       .add("userTypes", userTypes)
0:                       .toString();
0:         return Collections.singletonMap("replication_factor", rf.toString());
/////////////////////////////////////////////////////////////////////////
0:         List<CfDef> cfDefs = new ArrayList<>(cfMetaData.size());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         Map<String, CFMetaData> cfms = new HashMap<>();
commit:6bbb13b
/////////////////////////////////////////////////////////////////////////
0:     public Mutation toSchemaUpdate(KSMetaData newState, long modificationTimestamp)
/////////////////////////////////////////////////////////////////////////
0:     public Mutation dropFromSchema(long timestamp)
0:         Mutation mutation = new Mutation(Keyspace.SYSTEM_KS, SystemKeyspace.getSchemaKSKey(name));
0:         mutation.delete(SystemKeyspace.SCHEMA_KEYSPACES_CF, timestamp);
0:         mutation.delete(SystemKeyspace.SCHEMA_COLUMNFAMILIES_CF, timestamp);
0:         mutation.delete(SystemKeyspace.SCHEMA_COLUMNS_CF, timestamp);
0:         mutation.delete(SystemKeyspace.SCHEMA_TRIGGERS_CF, timestamp);
0: 
0:         return mutation;
0:     public Mutation toSchema(long timestamp)
0:         Mutation mutation = new Mutation(Keyspace.SYSTEM_KS, SystemKeyspace.getSchemaKSKey(name));
0:         ColumnFamily cf = mutation.addOrGet(CFMetaData.SchemaKeyspacesCf);
/////////////////////////////////////////////////////////////////////////
0:             cfm.toSchema(mutation, timestamp);
0:         return mutation;
commit:bffd9ea
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.lang3.ObjectUtils;
0: import org.apache.commons.lang3.StringUtils;
commit:a965977
/////////////////////////////////////////////////////////////////////////
0:             Row columnRow = SystemKeyspace.readSchemaRow(SystemKeyspace.SCHEMA_COLUMNS_CF, cfm.ksName, cfm.cfName);
0:             // This may replace some existing definition coming from the old key, column and
0:             // value aliases. But that's what we want (see CFMetaData.fromSchemaNoColumnsNoTriggers).
commit:40cf7b0
/////////////////////////////////////////////////////////////////////////
0:                                                 CFMetaData.SchemaTriggersCf,
commit:0e96e58
/////////////////////////////////////////////////////////////////////////
0:         return new KSMetaData(Keyspace.SYSTEM_KS, LocalStrategy.class, Collections.<String, String>emptyMap(), true, cfDefs);
/////////////////////////////////////////////////////////////////////////
0:         Row ksDefRow = SystemKeyspace.readSchemaRow(name);
0:             throw new RuntimeException(String.format("%s not found in the schema definitions keyspaceName (%s).", name, SystemKeyspace.SCHEMA_KEYSPACES_CF));
0:         RowMutation rm = new RowMutation(Keyspace.SYSTEM_KS, SystemKeyspace.getSchemaKSKey(name));
0:         rm.delete(SystemKeyspace.SCHEMA_KEYSPACES_CF, timestamp);
0:         rm.delete(SystemKeyspace.SCHEMA_COLUMNFAMILIES_CF, timestamp);
0:         rm.delete(SystemKeyspace.SCHEMA_COLUMNS_CF, timestamp);
0:         rm.delete(SystemKeyspace.SCHEMA_TRIGGERS_CF, timestamp);
0:         RowMutation rm = new RowMutation(Keyspace.SYSTEM_KS, SystemKeyspace.getSchemaKSKey(name));
0:         ColumnFamily cf = rm.addOrGet(SystemKeyspace.SCHEMA_KEYSPACES_CF);
commit:4271d19
/////////////////////////////////////////////////////////////////////////
0:                                                 CFMetaData.CompactionLogCf,
commit:4063bcc
commit:5a43c39
/////////////////////////////////////////////////////////////////////////
0:         List<CFMetaData> cfDefs = Arrays.asList(CFMetaData.BatchlogCf,
commit:c6204b5
commit:2659640
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:bddfa9e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.auth.Auth;
/////////////////////////////////////////////////////////////////////////
0:     public static KSMetaData authKeyspace()
0:     {
0:         List<CFMetaData> cfDefs = Arrays.asList(CFMetaData.AuthUsersCf);
0:         return new KSMetaData(Auth.AUTH_KS, SimpleStrategy.class, ImmutableMap.of("replication_factor", "1"), true, cfDefs);
0:     }
0: 
author:Dave Brosius
-------------------------------------------------------------------------------
commit:f096eb6
/////////////////////////////////////////////////////////////////////////
0:         Map<String, CFMetaData> cfms = new HashMap<>(results.size());
author:beobal
-------------------------------------------------------------------------------
commit:b69f5e3
/////////////////////////////////////////////////////////////////////////
0:         mutation.delete(SystemKeyspace.INDEX_CF, timestamp);
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:b1cb582
/////////////////////////////////////////////////////////////////////////
0:         if (!other.name.equals(name)) return false;
0:         if (!ObjectUtils.equals(other.strategyClass, strategyClass)) return false;
0:         if (!ObjectUtils.equals(other.strategyOptions, strategyOptions)) return false;
0:         if (!other.cfMetaData.equals(cfMetaData)) return false;
0:         if (other.durableWrites != durableWrites) return false;
0:         if (!ObjectUtils.equals(other.userTypes, userTypes)) return false;
0:         return true;
commit:d63d07b
/////////////////////////////////////////////////////////////////////////
0:     public final UTMetaData userTypes;
0: 
0:         this(name, strategyClass, strategyOptions, durableWrites, cfDefs, new UTMetaData());
0:     }
0: 
0:     KSMetaData(String name,
0:                Class<? extends AbstractReplicationStrategy> strategyClass,
0:                Map<String, String> strategyOptions,
0:                boolean durableWrites,
0:                Iterable<CFMetaData> cfDefs,
0:                UTMetaData userTypes)
0:     {
/////////////////////////////////////////////////////////////////////////
0:         this.userTypes = userTypes;
/////////////////////////////////////////////////////////////////////////
0:         return new KSMetaData(name, strategyClass, options, durablesWrites, cfDefs, new UTMetaData());
0:         return new KSMetaData(ksm.name, ksm.strategyClass, ksm.strategyOptions, ksm.durableWrites, cfDefs, ksm.userTypes);
/////////////////////////////////////////////////////////////////////////
0:                 && other.durableWrites == durableWrites
0:                 && ObjectUtils.equals(other.userTypes, userTypes);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         return fromSchema(ksDefRow, Collections.<CFMetaData>emptyList(), userTypes);
/////////////////////////////////////////////////////////////////////////
0:         mutation.delete(SystemKeyspace.SCHEMA_USER_TYPES_CF, timestamp);
/////////////////////////////////////////////////////////////////////////
0:         userTypes.toSchema(mutation, timestamp);
/////////////////////////////////////////////////////////////////////////
0:     public static KSMetaData fromSchema(Row row, Iterable<CFMetaData> cfms, UTMetaData userTypes)
/////////////////////////////////////////////////////////////////////////
0:                                   cfms,
0:                                   userTypes);
/////////////////////////////////////////////////////////////////////////
0:     public static KSMetaData fromSchema(Row serializedKs, Row serializedCFs, Row serializedUserTypes)
0:         UTMetaData userTypes = new UTMetaData(UTMetaData.fromSchema(serializedUserTypes));
0:         return fromSchema(serializedKs, cfs.values(), userTypes);
commit:362cc05
/////////////////////////////////////////////////////////////////////////
0:         CFRowAdder adder = new CFRowAdder(cf, CFMetaData.SchemaKeyspacesCf.comparator.builder().build(), timestamp);
0:         adder.add("durable_writes", durableWrites);
0:         adder.add("strategy_class", strategyClass.getName());
0:         adder.add("strategy_options", json(strategyOptions));
/////////////////////////////////////////////////////////////////////////
commit:a552b30
/////////////////////////////////////////////////////////////////////////
0:                                                 CFMetaData.SchemaTriggersCf,
0:                                                 CFMetaData.SchemaUserTypesCf,
commit:79fe644
commit:86a077a
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = rm.addOrGet(CFMetaData.SchemaKeyspacesCf);
commit:67435b5
/////////////////////////////////////////////////////////////////////////
0:             cfm.rebuild();
commit:a950b92
/////////////////////////////////////////////////////////////////////////
0:             if (cfm.isThriftCompatible())
/////////////////////////////////////////////////////////////////////////
0:             {
0:                 // This may replace some existing definition coming from the old key, column and
0:                 // value aliases. But that's what we want (see CFMetaData.fromSchemaNoColumns).
0:                 cfm.addOrReplaceColumnDefinition(cd);
0:             }
commit:3d93a3c
commit:c315745
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy.validateReplicationStrategyIgnoreUnexpected(name, strategyClass, tmd, eps, strategyOptions);
commit:3a005df
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         rm.delete(SystemTable.SCHEMA_KEYSPACES_CF, timestamp);
0:         rm.delete(SystemTable.SCHEMA_COLUMNFAMILIES_CF, timestamp);
0:         rm.delete(SystemTable.SCHEMA_COLUMNS_CF, timestamp);
commit:2ce7b9b
/////////////////////////////////////////////////////////////////////////
0:     public static KSMetaData newKeyspace(String name, String strategyName, Map<String, String> options, boolean durableWrites) throws ConfigurationException
0:         return newKeyspace(name, cls, options, durableWrites, Collections.<CFMetaData>emptyList());
0:     public static KSMetaData newKeyspace(String name, Class<? extends AbstractReplicationStrategy> strategyClass, Map<String, String> options, boolean durablesWrites, Iterable<CFMetaData> cfDefs)
0:         return new KSMetaData(name, strategyClass, options, durablesWrites, cfDefs);
commit:1e126da
/////////////////////////////////////////////////////////////////////////
0:     public static KSMetaData newKeyspace(String name, String strategyName, Map<String, String> options, boolean durableWrites) throws ConfigurationException
0:         return newKeyspace(name, cls, options, durableWrites, Collections.<CFMetaData>emptyList());
0:     public static KSMetaData newKeyspace(String name, Class<? extends AbstractReplicationStrategy> strategyClass, Map<String, String> options, boolean durablesWrites, Iterable<CFMetaData> cfDefs)
0:         return new KSMetaData(name, strategyClass, options, durablesWrites, cfDefs);
commit:3b13457
/////////////////////////////////////////////////////////////////////////
0:                                                 CFMetaData.CounterIdCf,
commit:73a4b46
/////////////////////////////////////////////////////////////////////////
0:         {
0:             // Don't expose CF that cannot be correctly handle by thrift; see CASSANDRA-4377 for further details
0:             if (!cfm.isThriftIncompatible())
0:                 cfDefs.add(cfm.toThrift());
0:         }
commit:3a2faf9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.exceptions.ConfigurationException;
commit:1ec8464
commit:3f09b79
commit:5b57673
/////////////////////////////////////////////////////////////////////////
0:             throw new ConfigurationException(String.format("Invalid keyspace name: shouldn't be empty nor more than %s characters long (got \"%s\")", Schema.NAME_LENGTH, name));
commit:b2cb52d
commit:1ea2a60
/////////////////////////////////////////////////////////////////////////
0:             for (ColumnDefinition cd : ColumnDefinition.fromSchema(columnRow, cfm))
commit:0d1d3bc
/////////////////////////////////////////////////////////////////////////
0:             for (ColumnDefinition cd : ColumnDefinition.fromSchema(columnRow, cfm))
commit:522730a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.locator.*;
0: import org.apache.cassandra.service.StorageService;
/////////////////////////////////////////////////////////////////////////
0:     // For new user created keyspaces (through CQL)
0:     public static KSMetaData newKeyspace(String name, String strategyName, Map<String, String> options) throws ConfigurationException
0:     {
0:         Class<? extends AbstractReplicationStrategy> cls = AbstractReplicationStrategy.getClass(strategyName);
0:         if (cls.equals(LocalStrategy.class))
0:             throw new ConfigurationException("Unable to use given strategy class: LocalStrategy is reserved for internal use.");
0: 
0:         return new KSMetaData(name, cls, options, true, Collections.<CFMetaData>emptyList());
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         Class<? extends AbstractReplicationStrategy> cls = AbstractReplicationStrategy.getClass(ksd.strategy_class);
0:         if (cls.equals(LocalStrategy.class))
0:             throw new ConfigurationException("Unable to use given strategy class: LocalStrategy is reserved for internal use.");
0: 
0:                               cls,
/////////////////////////////////////////////////////////////////////////
0:     public KSMetaData validate() throws ConfigurationException
0:     {
1:         if (!CFMetaData.isNameValid(name))
0:             throw new ConfigurationException(String.format("Invalid keyspace name: shouldn't be empty nor more than 32 character long (got \"%s\")", name));
0: 
0:         // Attempt to instantiate the ARS, which will throw a ConfigException if the strategy_options aren't fully formed
0:         TokenMetadata tmd = StorageService.instance.getTokenMetadata();
0:         IEndpointSnitch eps = DatabaseDescriptor.getEndpointSnitch();
0:         AbstractReplicationStrategy.createReplicationStrategy(name, strategyClass, tmd, eps, strategyOptions);
0: 
0:         for (CFMetaData cfm : cfMetaData.values())
0:             cfm.validate();
0: 
0:         return this;
0:     }
0: 
0: 
/////////////////////////////////////////////////////////////////////////
commit:ad4541e
commit:86f5eaa
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.locator.*;
0: import org.apache.cassandra.service.StorageService;
/////////////////////////////////////////////////////////////////////////
0:     // For new user created keyspaces (through CQL)
0:     public static KSMetaData newKeyspace(String name, String strategyName, Map<String, String> options) throws ConfigurationException
0:     {
0:         Class<? extends AbstractReplicationStrategy> cls = AbstractReplicationStrategy.getClass(strategyName);
0:         if (cls.equals(LocalStrategy.class))
0:             throw new ConfigurationException("Unable to use given strategy class: LocalStrategy is reserved for internal use.");
0: 
0:         return new KSMetaData(name, cls, options, true, Collections.<CFMetaData>emptyList());
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         Class<? extends AbstractReplicationStrategy> cls = AbstractReplicationStrategy.getClass(ksd.strategy_class);
0:         if (cls.equals(LocalStrategy.class))
0:             throw new ConfigurationException("Unable to use given strategy class: LocalStrategy is reserved for internal use.");
0: 
0:                               cls,
/////////////////////////////////////////////////////////////////////////
0:     public KSMetaData validate() throws ConfigurationException
0:     {
0:         if (!CFMetaData.isNameValid(name))
0:             throw new ConfigurationException(String.format("Invalid keyspace name: shouldn't be empty nor more than 32 character long (got \"%s\")", name));
0: 
0:         // Attempt to instantiate the ARS, which will throw a ConfigException if the strategy_options aren't fully formed
0:         TokenMetadata tmd = StorageService.instance.getTokenMetadata();
0:         IEndpointSnitch eps = DatabaseDescriptor.getEndpointSnitch();
0:         AbstractReplicationStrategy.createReplicationStrategy(name, strategyClass, tmd, eps, strategyOptions);
0: 
0:         for (CFMetaData cfm : cfMetaData.values())
0:             cfm.validate();
0: 
0:         return this;
0:     }
0: 
0: 
/////////////////////////////////////////////////////////////////////////
commit:15ae2f6
commit:fe98003
commit:438acfc
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public RowMutation toSchemaUpdate(KSMetaData newState, long modificationTimestamp)
/////////////////////////////////////////////////////////////////////////
0:             for (ColumnDefinition cd : ColumnDefinition.fromSchema(columnRow, cfm.getColumnDefinitionComparator()))
0: 
0:     public KSMetaData validate() throws ConfigurationException
0:     {
0:         return this;
0:     }
commit:bc577ba
commit:073038c
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
commit:86637d4
/////////////////////////////////////////////////////////////////////////
0:             for (ColumnDef columnDef : ColumnDefinition.fromSchema(ColumnDefinition.readSchema(cfDef.keyspace, cfDef.name)))
commit:052e9ff
/////////////////////////////////////////////////////////////////////////
0:         return new KSMetaData(Table.SYSTEM_TABLE, LocalStrategy.class, optsWithRF(1), true, cfDefs);
author:lantao yan
-------------------------------------------------------------------------------
commit:a2b1278
/////////////////////////////////////////////////////////////////////////
0:                                                 CFMetaData.CompactionHistoryCf,
author:Vijay Parthasarathy
-------------------------------------------------------------------------------
commit:8bf6e15
/////////////////////////////////////////////////////////////////////////
0:                                                 CFMetaData.SchemaTriggerCf,
/////////////////////////////////////////////////////////////////////////
0:         rm.delete(SystemTable.SCHEMA_TRIGGERS_CF, timestamp);
commit:f56f08c
commit:60acf0d
/////////////////////////////////////////////////////////////////////////
0:                                                 CFMetaData.PeerEventsCf,
author:Eric Evans
-------------------------------------------------------------------------------
commit:398b1d2
/////////////////////////////////////////////////////////////////////////
0:                                                 CFMetaData.RangeXfersCf,
commit:712ffeb
/////////////////////////////////////////////////////////////////////////
0:                                                 CFMetaData.SchemaColumnsCf,
0:                                                 CFMetaData.HostIdCf);
commit:1ed43c1
/////////////////////////////////////////////////////////////////////////
0:     public org.apache.cassandra.db.migration.avro.KsDef deflate()
0:         org.apache.cassandra.db.migration.avro.KsDef ks = new org.apache.cassandra.db.migration.avro.KsDef();
/////////////////////////////////////////////////////////////////////////
0:         ks.cf_defs = SerDeUtils.createArray(cfMetaData.size(), org.apache.cassandra.db.migration.avro.CfDef.SCHEMA$);
0:     public static KSMetaData inflate(org.apache.cassandra.db.migration.avro.KsDef ks)
/////////////////////////////////////////////////////////////////////////
0:         Iterator<org.apache.cassandra.db.migration.avro.CfDef> cfiter = ks.cf_defs.iterator();
commit:f93ebf4
/////////////////////////////////////////////////////////////////////////
0:             ks.strategy_options = new HashMap<CharSequence, CharSequence>();
/////////////////////////////////////////////////////////////////////////
0:             for (Map.Entry<CharSequence, CharSequence> e : ks.strategy_options.entrySet())
commit:df8a933
/////////////////////////////////////////////////////////////////////////
0:     public final Map<String, String> strategyOptions;
0:     public KSMetaData(String name, Class<? extends AbstractReplicationStrategy> strategyClass, Map<String, String> strategyOptions, int replicationFactor, CFMetaData... cfDefs)
0:         this.strategyOptions = strategyOptions;
/////////////////////////////////////////////////////////////////////////
0:                 && ObjectUtils.equals(other.strategyOptions, strategyOptions)
/////////////////////////////////////////////////////////////////////////
0:         if (strategyOptions != null)
0:         {
0:             ks.strategy_options = new HashMap<Utf8, Utf8>();
0:             for (Map.Entry<String, String> e : strategyOptions.entrySet())
0:             {
0:                 ks.strategy_options.put(new Utf8(e.getKey()), new Utf8(e.getValue()));
0:             }
0:         }
/////////////////////////////////////////////////////////////////////////
0:         Class<AbstractReplicationStrategy> repStratClass;
/////////////////////////////////////////////////////////////////////////
0:         Map<String, String> strategyOptions = null;
0:         if (ks.strategy_options != null)
0:         {
0:             strategyOptions = new HashMap<String, String>();
0:             for (Map.Entry<Utf8, Utf8> e : ks.strategy_options.entrySet())
0:             {
0:                 strategyOptions.put(e.getKey().toString(), e.getValue().toString());
0:             }
0:         }
0:         return new KSMetaData(ks.name.toString(), repStratClass, strategyOptions, ks.replication_factor, cfMetaData);
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:bcec7a5
/////////////////////////////////////////////////////////////////////////
0:         return newKeyspace(name, cls, options, Collections.<CFMetaData>emptyList());
0:     }
0: 
0:     public static KSMetaData newKeyspace(String name, Class<? extends AbstractReplicationStrategy> strategyClass, Map<String, String> options, Iterable<CFMetaData> cfDefs)
0:     {
0:         return new KSMetaData(name, strategyClass, options, true, cfDefs);
commit:aba5a37
/////////////////////////////////////////////////////////////////////////
0:         return newKeyspace(name, cls, options, Collections.<CFMetaData>emptyList());
0:     }
0: 
0:     public static KSMetaData newKeyspace(String name, Class<? extends AbstractReplicationStrategy> strategyClass, Map<String, String> options, Iterable<CFMetaData> cfDefs)
0:     {
0:         return new KSMetaData(name, strategyClass, options, true, cfDefs);
commit:17f6432
commit:de55757
/////////////////////////////////////////////////////////////////////////
0:           .append(", strategy_options: ")
0:           .append(strategyOptions.toString())
0:           .append(", durable_writes: ")
0:           .append(durableWrites);
commit:c971e4c
commit:e45bdb8
commit:b2b8a53
/////////////////////////////////////////////////////////////////////////
0: 
0:             // this means that given field was deprecated
0:             // but still exists in the serialized schema
0:             if (field == null)
0:                 continue;
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:             // this means that given field was deprecated
0:             // but still exists in the serialized schema
0:             if (field == null)
0:                 continue;
0: 
commit:37b0793
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import com.google.common.base.Objects;
0: import org.apache.cassandra.db.*;
0: import org.apache.cassandra.db.filter.QueryPath;
0: import org.apache.cassandra.db.marshal.AbstractType;
0: import org.apache.cassandra.db.marshal.AsciiType;
0: import org.apache.cassandra.thrift.ColumnDef;
0: 
0: import static org.apache.cassandra.db.migration.MigrationHelper.*;
/////////////////////////////////////////////////////////////////////////
0:                                                 CFMetaData.VersionCf,
0:                                                 CFMetaData.SchemaKeyspacesCf,
0:                                                 CFMetaData.SchemaColumnFamiliesCf,
0:                                                 CFMetaData.SchemaColumnsCf);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     @Deprecated
/////////////////////////////////////////////////////////////////////////
0: 
0:     public RowMutation diff(KsDef newState, long modificationTimestamp)
0:     {
0:         KsDef curState = toThrift();
0:         RowMutation m = new RowMutation(Table.SYSTEM_TABLE, SystemTable.getSchemaKSKey(name));
0: 
0:         for (KsDef._Fields field : KsDef._Fields.values())
0:         {
0:             if (field.equals(KsDef._Fields.CF_DEFS))
0:                 continue;
0: 
0:             Object curValue = curState.getFieldValue(field);
0:             Object newValue = newState.getFieldValue(field);
0: 
0:             if (Objects.equal(curValue, newValue))
0:                 continue;
0: 
0:             m.add(new QueryPath(SystemTable.SCHEMA_KEYSPACES_CF, null, AsciiType.instance.fromString(field.getFieldName())),
0:                   valueAsBytes(newValue),
0:                   modificationTimestamp);
0:         }
0: 
0:         return m;
0:     }
0: 
0:     public KSMetaData reloadAttributes() throws IOException
0:     {
0:         Row ksDefRow = SystemTable.readSchemaRow(name);
0: 
0:         if (ksDefRow.cf == null || ksDefRow.cf.isEmpty())
0:             throw new IOException(String.format("%s not found in the schema definitions table (%s).", name, SystemTable.SCHEMA_KEYSPACES_CF));
0: 
0:         return fromSchema(ksDefRow.cf, null);
0:     }
0: 
0:     public List<RowMutation> dropFromSchema(long timestamp)
0:     {
0:         List<RowMutation> mutations = new ArrayList<RowMutation>();
0: 
0:         RowMutation ksMutation = new RowMutation(Table.SYSTEM_TABLE, SystemTable.getSchemaKSKey(name));
0:         ksMutation.delete(new QueryPath(SystemTable.SCHEMA_KEYSPACES_CF), timestamp);
0:         mutations.add(ksMutation);
0: 
0:         for (CFMetaData cfm : cfMetaData.values())
0:             mutations.add(cfm.dropFromSchema(timestamp));
0: 
0:         return mutations;
0:     }
0: 
0:     public static RowMutation toSchema(KsDef ksDef, long timestamp) throws IOException
0:     {
0:         RowMutation mutation = new RowMutation(Table.SYSTEM_TABLE, SystemTable.getSchemaKSKey(ksDef.name));
0: 
0:         for (KsDef._Fields field : KsDef._Fields.values())
0:         {
0:             if (field.equals(KsDef._Fields.CF_DEFS))
0:                 continue;
0: 
0:             mutation.add(new QueryPath(SystemTable.SCHEMA_KEYSPACES_CF,
0:                                        null,
0:                                        AsciiType.instance.fromString(field.getFieldName())),
0:                          valueAsBytes(ksDef.getFieldValue(field)),
0:                          timestamp);
0:         }
0: 
0:         if (!ksDef.isSetCf_defs())
0:             return mutation;
0: 
0:         for (CfDef cf : ksDef.cf_defs)
0:         {
0:             try
0:             {
0:                 CFMetaData.toSchema(mutation, cf, timestamp);
0:             }
0:             catch (ConfigurationException e)
0:             {
0:                 throw new IOException(e);
0:             }
0:         }
0: 
0:         return mutation;
0:     }
0: 
0:     public RowMutation toSchema(long timestamp) throws IOException
0:     {
0:         return toSchema(toThrift(), timestamp);
0:     }
0: 
0:     /**
0:      * Deserialize only Keyspace attributes without nested ColumnFamilies
1:      *
0:      * @param serializedKsDef Keyspace attributes in serialized form
1:      *
0:      * @return deserialized keyspace without cf_defs
1:      *
0:      * @throws IOException if deserialization failed
1:      */
0:     public static KsDef fromSchema(ColumnFamily serializedKsDef) throws IOException
0:     {
0:         KsDef ksDef = new KsDef();
0: 
0:         AbstractType comparator = serializedKsDef.getComparator();
0: 
0:         for (IColumn ksAttr : serializedKsDef.getSortedColumns())
0:         {
0:             if (ksAttr == null || ksAttr.isMarkedForDelete())
0:                 continue;
0: 
0:             KsDef._Fields field = KsDef._Fields.findByName(comparator.getString(ksAttr.name()));
0:             ksDef.setFieldValue(field, deserializeValue(ksAttr.value(), getValueClass(KsDef.class, field.getFieldName())));
0:         }
0: 
0:         return ksDef.name == null ? null : ksDef;
0:     }
0: 
0:     /**
0:      * Deserialize Keyspace with nested ColumnFamilies
1:      *
0:      * @param serializedKsDef Keyspace in serialized form
0:      * @param serializedCFs Collection of the serialized ColumnFamilies
1:      *
0:      * @return deserialized keyspace with cf_defs
1:      *
0:      * @throws IOException if deserialization failed
1:      */
0:     public static KSMetaData fromSchema(ColumnFamily serializedKsDef, ColumnFamily serializedCFs) throws IOException
0:     {
0:         KsDef ksDef = fromSchema(serializedKsDef);
0: 
0:         assert ksDef != null;
0: 
0:         Map<String, CfDef> cfs = deserializeColumnFamilies(serializedCFs);
0: 
0:         try
0:         {
0:             CFMetaData[] cfms = new CFMetaData[cfs.size()];
0: 
0:             int index = 0;
0:             for (CfDef cfDef : cfs.values())
0:                 cfms[index++] = CFMetaData.fromThrift(cfDef);
0: 
0:             return fromThrift(ksDef, cfms);
0:         }
0:         catch (Exception e)
0:         {
0:             // this is critical because indicates that something is wrong with serialized schema
0:             throw new IOException(e);
0:         }
0:     }
0: 
0:     /**
0:      * Deserialize ColumnFamilies from low-level schema representation, all of them belong to the same keyspace
1:      *
0:      * @param serializedColumnFamilies ColumnFamilies in the serialized form
1:      *
0:      * @return map containing name of the ColumnFamily and it's metadata for faster lookup
1:      */
0:     public static Map<String, CfDef> deserializeColumnFamilies(ColumnFamily serializedColumnFamilies)
0:     {
0:         Map<String, CfDef> cfs = new HashMap<String, CfDef>();
0: 
0:         if (serializedColumnFamilies == null)
0:             return cfs;
0: 
0:         AbstractType<?> comparator = serializedColumnFamilies.getComparator();
0: 
0:         for (IColumn column : serializedColumnFamilies.getSortedColumns())
0:         {
0:             if (column == null || column.isMarkedForDelete())
0:                 continue;
0: 
0:             String[] attr = comparator.getString(column.name()).split(":");
0:             assert attr.length == 2;
0: 
0:             CfDef cfDef = cfs.get(attr[0]);
0: 
0:             if (cfDef == null)
0:             {
0:                 cfDef = new CfDef();
0:                 cfs.put(attr[0], cfDef);
0:             }
0: 
0:             CfDef._Fields field = CfDef._Fields.findByName(attr[1]);
0:             cfDef.setFieldValue(field, deserializeValue(column.value(), getValueClass(CfDef.class, field.getFieldName())));
0:         }
0: 
0:         for (CfDef cfDef : cfs.values())
0:         {
0:             for (ColumnDef columnDef : ColumnDefinition.fromSchema(cfDef.keyspace, cfDef.name))
0:                 cfDef.addToColumn_metadata(columnDef);
0:         }
0: 
0:         return cfs;
0:     }
commit:38e3e85
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public org.apache.cassandra.db.migration.avro.KsDef toAvro()
/////////////////////////////////////////////////////////////////////////
0:             ks.cf_defs.add(cfm.toAvro());
/////////////////////////////////////////////////////////////////////////
0:     public static KSMetaData fromAvro(org.apache.cassandra.db.migration.avro.KsDef ks)
/////////////////////////////////////////////////////////////////////////
0:             cfMetaData[i] = CFMetaData.fromAvro(cfiter.next());
/////////////////////////////////////////////////////////////////////////
0:     public KsDef toThrift()
0:         for (CFMetaData cfm : cfMetaData().values())
0:             cfDefs.add(cfm.toThrift());
0:         KsDef ksdef = new KsDef(name, strategyClass.getName(), cfDefs);
0:         ksdef.setStrategy_options(strategyOptions);
0:         if (strategyOptions != null && strategyOptions.containsKey("replication_factor"))
0:             ksdef.setReplication_factor(Integer.parseInt(strategyOptions.get("replication_factor")));
0:         ksdef.setDurable_writes(durable_writes);
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:ea6ec42
/////////////////////////////////////////////////////////////////////////
0:     private boolean durable_writes;
0:         this(name, strategyClass, strategyOptions, true, cfDefs);
0:     }
0: 
0:     public KSMetaData(String name, Class<? extends AbstractReplicationStrategy> strategyClass, Map<String, String> strategyOptions, boolean durable_writes, CFMetaData... cfDefs)
0:     {
/////////////////////////////////////////////////////////////////////////
0:         this.durable_writes = durable_writes;
0:     
0:     public void setDurableWrites(boolean durable_writes)
0:     {
0:         this.durable_writes = durable_writes;
0:     }
0:     
0:     public boolean isDurableWrites()
0:     {
0:         return durable_writes;
0:     }
0:     
/////////////////////////////////////////////////////////////////////////
0:                 && other.cfMetaData.equals(cfMetaData)
0:                 && other.durable_writes == durable_writes;
/////////////////////////////////////////////////////////////////////////
0:         
0:         ks.durable_writes = durable_writes;
0:         
/////////////////////////////////////////////////////////////////////////
0:           .append("}")
0:           .append("durable_writes: ").append(durable_writes);
/////////////////////////////////////////////////////////////////////////
0:         return new KSMetaData(ks.name.toString(), repStratClass, strategyOptions, ks.durable_writes, cfMetaData);
/////////////////////////////////////////////////////////////////////////
0:                               ksd.durable_writes,
/////////////////////////////////////////////////////////////////////////
0:         ksdef.durable_writes = ksm.durable_writes;
0:         
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:5ff7dee
/////////////////////////////////////////////////////////////////////////
0: 
0:         Map<String, String> strategyOptions = new HashMap<String, String>();
0:         if (ks.replication_factor != null)
0:             strategyOptions.put("replication_factor", ks.replication_factor.toString());
0: 
0:         int cfsz = ks.cf_defs.size();
commit:42d14c0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.lang.StringUtils;
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public String toString()
0:     {
0:         StringBuilder sb = new StringBuilder();
0:         sb.append(name)
0:           .append("rep factor:")
0:           .append(replicationFactor)
0:           .append("rep strategy:")
0:           .append(strategyClass.getSimpleName())
0:           .append("{")
0:           .append(StringUtils.join(cfMetaData.values(), ", "))
0:           .append("}");
0:         return sb.toString();
0:     }
0: 
commit:6704723
/////////////////////////////////////////////////////////////////////////
0:     public org.apache.cassandra.db.migration.avro.KsDef deflate()
0:         org.apache.cassandra.db.migration.avro.KsDef ks = new org.apache.cassandra.db.migration.avro.KsDef();
/////////////////////////////////////////////////////////////////////////
0:         ks.cf_defs = SerDeUtils.createArray(cfMetaData.size(), org.apache.cassandra.db.migration.avro.CfDef.SCHEMA$);
0:     public static KSMetaData inflate(org.apache.cassandra.db.migration.avro.KsDef ks)
/////////////////////////////////////////////////////////////////////////
0:         Iterator<org.apache.cassandra.db.migration.avro.CfDef> cfiter = ks.cf_defs.iterator();
commit:361a08d
/////////////////////////////////////////////////////////////////////////
0:     public org.apache.cassandra.avro.KsDef deflate()
0:         org.apache.cassandra.avro.KsDef ks = new org.apache.cassandra.avro.KsDef();
/////////////////////////////////////////////////////////////////////////
0:         ks.cf_defs = SerDeUtils.createArray(cfMetaData.size(), org.apache.cassandra.avro.CfDef.SCHEMA$);
0:     public static KSMetaData inflate(org.apache.cassandra.avro.KsDef ks)
/////////////////////////////////////////////////////////////////////////
0:         Iterator<org.apache.cassandra.avro.CfDef> cfiter = ks.cf_defs.iterator();
commit:f7f5877
/////////////////////////////////////////////////////////////////////////
0:     public org.apache.cassandra.avro.KsDef deflate()
0:         org.apache.cassandra.avro.KsDef ks = new org.apache.cassandra.avro.KsDef();
/////////////////////////////////////////////////////////////////////////
0:         ks.cf_defs = SerDeUtils.createArray(cfMetaData.size(), org.apache.cassandra.avro.CfDef.SCHEMA$);
0:     public static KSMetaData inflate(org.apache.cassandra.avro.KsDef ks)
/////////////////////////////////////////////////////////////////////////
0:         Iterator<org.apache.cassandra.avro.CfDef> cfiter = ks.cf_defs.iterator();
commit:25b8945
/////////////////////////////////////////////////////////////////////////
0:     public static KSMetaData inflate(org.apache.cassandra.config.avro.KsDef ks)
/////////////////////////////////////////////////////////////////////////
0:             throw new RuntimeException("Could not create ReplicationStrategy of type " + ks.strategy_class, ex);
commit:00c108a
/////////////////////////////////////////////////////////////////////////
0:     public org.apache.cassandra.config.avro.KsDef deflate()
0:         org.apache.cassandra.config.avro.KsDef ks = new org.apache.cassandra.config.avro.KsDef();
/////////////////////////////////////////////////////////////////////////
0:         ks.cf_defs = SerDeUtils.createArray(cfMetaData.size(), org.apache.cassandra.config.avro.CfDef.SCHEMA$);
0:     public static KSMetaData inflate(org.apache.cassandra.config.avro.KsDef ks) throws ConfigurationException
/////////////////////////////////////////////////////////////////////////
0:         Iterator<org.apache.cassandra.config.avro.CfDef> cfiter = ks.cf_defs.iterator();
commit:de5715e
/////////////////////////////////////////////////////////////////////////
0:     private final Map<String, CFMetaData> cfMetaData;
0:     public KSMetaData(String name, Class<? extends AbstractReplicationStrategy> strategyClass, int replicationFactor, CFMetaData... cfDefs)
/////////////////////////////////////////////////////////////////////////
0:     
/////////////////////////////////////////////////////////////////////////
0:         
/////////////////////////////////////////////////////////////////////////
0:         return new KSMetaData(ks.name.toString(), repStratClass, ks.replication_factor, cfMetaData);
commit:7b9f69a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.avro.AccessLevel;
0: 
0:     public final Map<String, CFMetaData> cfMetaData;
0:     public final Map<String, AccessLevel> usersAccess;
0:     public final Map<String, AccessLevel> groupsAccess;
0:     public KSMetaData(String name, Class<? extends AbstractReplicationStrategy> strategyClass, int replicationFactor, Map<String,AccessLevel> usersAccess, Map<String,AccessLevel> groupsAccess, CFMetaData... cfDefs)
/////////////////////////////////////////////////////////////////////////
0:         this.usersAccess = usersAccess == null ?
0:             Collections.<String, AccessLevel>emptyMap() : Collections.unmodifiableMap(usersAccess);
0:         this.groupsAccess = groupsAccess == null ?
0:             Collections.<String, AccessLevel>emptyMap() : Collections.unmodifiableMap(groupsAccess);
/////////////////////////////////////////////////////////////////////////
0:         return new KSMetaData(name, strategyClass, replicationFactor, usersAccess, groupsAccess, newCfs.toArray(new CFMetaData[newCfs.size()]));
/////////////////////////////////////////////////////////////////////////
0:         return new KSMetaData(name, strategyClass, replicationFactor, usersAccess, groupsAccess, newCfs.toArray(new CFMetaData[newCfs.size()]));
/////////////////////////////////////////////////////////////////////////
0:         return new KSMetaData(ksName, strategyClass, replicationFactor, usersAccess, groupsAccess, newCfs.toArray(new CFMetaData[newCfs.size()]));
/////////////////////////////////////////////////////////////////////////
0: 
0:         ks.users_access = SerDeUtils.toAvroMap(usersAccess);
0:         ks.groups_access = SerDeUtils.toAvroMap(groupsAccess);
/////////////////////////////////////////////////////////////////////////
0:         Map<String,AccessLevel> usersAccess = SerDeUtils.fromAvroMap(ks.users_access);
0:         Map<String,AccessLevel> groupsAccess = SerDeUtils.fromAvroMap(ks.groups_access);
0:         return new KSMetaData(ks.name.toString(), repStratClass, ks.replication_factor, usersAccess, groupsAccess, cfMetaData);
commit:4ee87ab
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
0:      * Copies this KSMetaData, adding an additional ColumnFamily.
0:      */
0:     public KSMetaData withColumnFamily(CFMetaData cfm)
0:     {
0:         List<CFMetaData> newCfs = new ArrayList<CFMetaData>(cfMetaData().values());
0:         newCfs.add(cfm);
0:         return new KSMetaData(name, strategyClass, replicationFactor, newCfs.toArray(new CFMetaData[newCfs.size()]));
0:     }
0: 
0:     /**
0:      * Copies this KSMetaData, removing the ColumnFamily with the given name (which must exist).
0:      */
0:     public KSMetaData withoutColumnFamily(String cfName)
0:     {
0:         CFMetaData cfm = cfMetaData().get(cfName);
0:         List<CFMetaData> newCfs = new ArrayList<CFMetaData>(cfMetaData().values());
0:         newCfs.remove(cfm);
0:         assert newCfs.size() == cfMetaData().size() - 1;
0:         return new KSMetaData(name, strategyClass, replicationFactor, newCfs.toArray(new CFMetaData[newCfs.size()]));
0:     }
0: 
0:     /**
0:      * Copies this KSMetaData, returning a renamed copy.
0:      */
0:     public KSMetaData withName(String ksName)
0:     {
0:         // cfs will need to have their tablenames reset, but their ids will not change
0:         List<CFMetaData> newCfs = new ArrayList<CFMetaData>(cfMetaData().size());
0:         for (CFMetaData oldCf : cfMetaData().values())
0:             newCfs.add(CFMetaData.renameTable(oldCf, ksName));
0:         return new KSMetaData(ksName, strategyClass, replicationFactor, newCfs.toArray(new CFMetaData[newCfs.size()]));
0:     }
0: 
commit:7405e8f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.locator.RackUnawareStrategy;
0: import org.apache.cassandra.io.SerDeUtils;
0: import java.util.Iterator;
0: import org.apache.avro.util.Utf8;
/////////////////////////////////////////////////////////////////////////
0:         this.strategyClass = strategyClass == null ? RackUnawareStrategy.class : strategyClass;
/////////////////////////////////////////////////////////////////////////
0:     public org.apache.cassandra.avro.KsDef deflate()
0:         org.apache.cassandra.avro.KsDef ks = new org.apache.cassandra.avro.KsDef();
0:         ks.name = new Utf8(name);
0:         ks.strategy_class = new Utf8(strategyClass.getName());
0:         ks.replication_factor = replicationFactor;
0:         ks.cf_defs = SerDeUtils.createArray(cfMetaData.size(), org.apache.cassandra.avro.CfDef.SCHEMA$);
0:         for (CFMetaData cfm : cfMetaData.values())
0:             ks.cf_defs.add(cfm.deflate());
0:         return ks;
0:     public static KSMetaData inflate(org.apache.cassandra.avro.KsDef ks) throws ConfigurationException
0:             repStratClass = (Class<AbstractReplicationStrategy>)Class.forName(ks.strategy_class.toString());
0:             throw new ConfigurationException("Could not create ReplicationStrategy of type " + ks.strategy_class, ex);
0:         int cfsz = (int)ks.cf_defs.size();
0:         Iterator<org.apache.cassandra.avro.CfDef> cfiter = ks.cf_defs.iterator();
0:             cfMetaData[i] = CFMetaData.inflate(cfiter.next());
0:         return new KSMetaData(ks.name.toString(), repStratClass, ks.replication_factor, cfMetaData);
commit:2ffd301
/////////////////////////////////////////////////////////////////////////
commit:a89fd2a
/////////////////////////////////////////////////////////////////////////
0:     public static KSMetaData rename(KSMetaData ksm, String newName, boolean purgeOldCfs)
0:         {
0:             if (purgeOldCfs)
0:                 CFMetaData.purge(oldCf);
0:         }
commit:3aaecf9
/////////////////////////////////////////////////////////////////////////
0:     public static KSMetaData rename(KSMetaData ksm, String newName)
0:     {
0:         // cfs will need to have their tablenames reset. CFMetaData are immutable, so new ones get created with the
0:         // same ids.
0:         List<CFMetaData> newCfs = new ArrayList<CFMetaData>(ksm.cfMetaData().size());
0:         for (CFMetaData oldCf : ksm.cfMetaData().values())
0:             newCfs.add(CFMetaData.renameTable(oldCf, newName));
0:         return new KSMetaData(newName, ksm.strategyClass, ksm.replicationFactor, ksm.snitch, newCfs.toArray(new CFMetaData[newCfs.size()]));
0:     }
0:     
commit:3395bd0
/////////////////////////////////////////////////////////////////////////
0:         
commit:e987966
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0:     public KSMetaData(String name, Class<? extends AbstractReplicationStrategy> strategyClass, int replicationFactor, IEndPointSnitch snitch, CFMetaData... cfDefs)
commit:af399a5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.lang.ObjectUtils;
0: 
/////////////////////////////////////////////////////////////////////////
0:                 && ObjectUtils.equals(other.strategyClass, strategyClass)
commit:317cb6e
/////////////////////////////////////////////////////////////////////////
0:     public final Class<? extends AbstractReplicationStrategy> strategyClass;
0:     public final IEndPointSnitch snitch;
0:     KSMetaData(String name, Class<? extends AbstractReplicationStrategy> strategyClass, int replicationFactor, IEndPointSnitch snitch, CFMetaData... cfDefs)
0:         this.strategyClass = strategyClass;
0:         this.snitch = snitch;
/////////////////////////////////////////////////////////////////////////
0:                 && FBUtilities.equals(other.strategyClass, strategyClass)
/////////////////////////////////////////////////////////////////////////
0:         if (a.snitch == null && b.snitch == null)
0:         else if (a.snitch == null && b.snitch != null)
0:         else if (a.snitch != null && b.snitch == null)
0:             return a.snitch.getClass().getName().equals(b.snitch.getClass().getName());
/////////////////////////////////////////////////////////////////////////
0:         dout.writeBoolean(ksm.strategyClass != null);
0:         if (ksm.strategyClass != null)
0:             dout.writeUTF(ksm.strategyClass.getName());
0:         dout.writeBoolean(ksm.snitch != null);
0:         if (ksm.snitch != null)
0:             dout.writeUTF(ksm.snitch.getClass().getName());
commit:7840986
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collections;
/////////////////////////////////////////////////////////////////////////
0:     private final Map<String, CFMetaData> cfMetaData;
0:     KSMetaData(String name, Class<? extends AbstractReplicationStrategy> repStratClass, int replicationFactor, IEndPointSnitch epSnitch, CFMetaData... cfDefs)
0:         Map<String, CFMetaData> cfmap = new HashMap<String, CFMetaData>();
0:         for (CFMetaData cfm : cfDefs)
0:             cfmap.put(cfm.cfName, cfm);
0:         this.cfMetaData = Collections.<String, CFMetaData>unmodifiableMap(cfmap);
/////////////////////////////////////////////////////////////////////////
0: 
0:     public Map<String, CFMetaData> cfMetaData()
0:     {
0:         return cfMetaData;
0:     }
/////////////////////////////////////////////////////////////////////////
0:         CFMetaData[] cfMetaData = new CFMetaData[cfsz];
0:                 cfMetaData[i] = CFMetaData.deserialize(din);
0:                 System.err.println(name);
0: 
0:         KSMetaData ksm = new KSMetaData(name, repStratClass, replicationFactor, epSnitch, cfMetaData);
commit:fbda616
/////////////////////////////////////////////////////////////////////////
0: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
0:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
0: 
0: package org.apache.cassandra.config;
0: 
0: import org.apache.cassandra.locator.AbstractReplicationStrategy;
0: import org.apache.cassandra.locator.IEndPointSnitch;
0: import org.apache.cassandra.utils.FBUtilities;
0: 
0: import java.io.ByteArrayOutputStream;
0: import java.io.DataInputStream;
0: import java.io.DataOutputStream;
0: import java.io.IOException;
0: import java.io.InputStream;
0: import java.util.HashMap;
0: import java.util.Map;
0: 
0: public final class KSMetaData
0: {
1:     public final String name;
0:     public final Class<? extends AbstractReplicationStrategy> repStratClass;
0:     public final int replicationFactor;
0:     public final IEndPointSnitch epSnitch;
0:     public final Map<String, CFMetaData> cfMetaData = new HashMap<String, CFMetaData>();
0: 
0:     KSMetaData(String name, Class<? extends AbstractReplicationStrategy> repStratClass, int replicationFactor, IEndPointSnitch epSnitch)
0:     {
1:         this.name = name;
0:         this.repStratClass = repStratClass;
0:         this.replicationFactor = replicationFactor;
0:         this.epSnitch = epSnitch;
0:     }
0:     
0:     public boolean equals(Object obj)
0:     {
0:         if (obj == null)
1:             return false;
0:         if (!(obj instanceof KSMetaData))
1:             return false;
0:         KSMetaData other = (KSMetaData)obj;
0:         return other.name.equals(name)
0:                 && FBUtilities.equals(other.repStratClass, repStratClass)
0:                 && other.replicationFactor == replicationFactor
0:                 && sameEpSnitch(other, this)
0:                 && other.cfMetaData.size() == cfMetaData.size()
0:                 && other.cfMetaData.equals(cfMetaData);
0:     }
0: 
0:     // epsnitches generally have no state, so comparing class names is sufficient.
0:     private static boolean sameEpSnitch(KSMetaData a, KSMetaData b)
0:     {
0:         if (a.epSnitch == null && b.epSnitch == null)
0:             return true;
0:         else if (a.epSnitch == null && b.epSnitch != null)
1:             return false;
0:         else if (a.epSnitch != null && b.epSnitch == null)
1:             return false;
0:         else
0:             return a.epSnitch.getClass().getName().equals(b.epSnitch.getClass().getName());
0:     }
0:     
0:     public static byte[] serialize(KSMetaData ksm) throws IOException
0:     {
0:         ByteArrayOutputStream bout = new ByteArrayOutputStream();
0:         DataOutputStream dout = new DataOutputStream(bout);
0:         dout.writeUTF(ksm.name);
0:         dout.writeBoolean(ksm.repStratClass != null);
0:         if (ksm.repStratClass != null)
0:             dout.writeUTF(ksm.repStratClass.getName());
0:         dout.writeInt(ksm.replicationFactor);
0:         dout.writeBoolean(ksm.epSnitch != null);
0:         if (ksm.epSnitch != null)
0:             dout.writeUTF(ksm.epSnitch.getClass().getName());
0:         dout.writeInt(ksm.cfMetaData.size());
0:         for (CFMetaData cfm : ksm.cfMetaData.values())
0:             dout.write(CFMetaData.serialize(cfm));
0:         dout.close();
0:         return bout.toByteArray();
0:     }
0: 
0:     public static KSMetaData deserialize(InputStream in) throws IOException
0:     {
0:         DataInputStream din = new DataInputStream(in);
0:         String name = din.readUTF();
0:         Class<AbstractReplicationStrategy> repStratClass = null;
0:         try
0:         {
0:             repStratClass = din.readBoolean() ? (Class<AbstractReplicationStrategy>)Class.forName(din.readUTF()) : null;
0:         }
0:         catch (Exception ex)
0:         {
0:             throw new IOException(ex);
0:         }
0:         int replicationFactor = din.readInt();
0:         IEndPointSnitch epSnitch = null;
0:         try
0:         {
0:             epSnitch = din.readBoolean() ? (IEndPointSnitch)Class.forName(din.readUTF()).newInstance() : null;
0:         }
0:         catch (Exception ex)
0:         {
0:             throw new IOException(ex);
0:         }
0:         int cfsz = din.readInt();
0:         KSMetaData ksm = new KSMetaData(name, repStratClass, replicationFactor, epSnitch);
0:         for (int i = 0; i < cfsz; i++)
0:         {
0:             try
0:             {
0:                 CFMetaData cfm = CFMetaData.deserialize(din);
0:                 ksm.cfMetaData.put(cfm.cfName, cfm);
0:             }
0:             catch (IOException ex)
0:             {
0:                 System.err.println(ksm.name);
0:                 throw ex;
0:             }
0:         }
0:         return ksm;
0:     }
0: }
author:Brandon Williams
-------------------------------------------------------------------------------
commit:8dffb10
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.locator.NetworkTopologyStrategy;
/////////////////////////////////////////////////////////////////////////
0:         this.strategyClass = strategyClass == null ? NetworkTopologyStrategy.class : strategyClass;
============================================================================