1:6d3a3ee: /*
1:6d3a3ee:  * Licensed to the Apache Software Foundation (ASF) under one
1:6d3a3ee:  * or more contributor license agreements.  See the NOTICE file
1:6d3a3ee:  * distributed with this work for additional information
1:6d3a3ee:  * regarding copyright ownership.  The ASF licenses this file
1:6d3a3ee:  * to you under the Apache License, Version 2.0 (the
1:6d3a3ee:  * "License"); you may not use this file except in compliance
1:6d3a3ee:  * with the License.  You may obtain a copy of the License at
2:6d3a3ee:  *
1:6d3a3ee:  *     http://www.apache.org/licenses/LICENSE-2.0
1:6d3a3ee:  *
1:6d3a3ee:  * Unless required by applicable law or agreed to in writing, software
1:6d3a3ee:  * distributed under the License is distributed on an "AS IS" BASIS,
1:6d3a3ee:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:6d3a3ee:  * See the License for the specific language governing permissions and
1:6d3a3ee:  * limitations under the License.
1:6d3a3ee:  */
1:6d3a3ee: package org.apache.cassandra.transport.messages;
7:6d3a3ee: 
1:39df31a: import java.net.InetAddress;
1:e3c0186: import java.util.List;
1:39df31a: import java.util.Map;
1:39df31a: import java.util.concurrent.ConcurrentHashMap;
1:e3c0186: 
1:cbf304e: import io.netty.buffer.ByteBuf;
1:f16507d: import io.netty.handler.codec.CodecException;
1:5654e73: import com.google.common.annotations.VisibleForTesting;
1:cbc705d: import com.google.common.base.Predicate;
1:3a2faf9: import org.slf4j.Logger;
1:3a2faf9: import org.slf4j.LoggerFactory;
1:6d3a3ee: 
1:e3c0186: import org.apache.cassandra.cql3.functions.FunctionName;
1:3a2faf9: import org.apache.cassandra.db.ConsistencyLevel;
1:ee5aafe: import org.apache.cassandra.db.WriteType;
1:3a2faf9: import org.apache.cassandra.exceptions.*;
1:c6525da: import org.apache.cassandra.transport.*;
1:ccca5f1: import org.apache.cassandra.utils.MD5Digest;
1:6d3a3ee: 
1:6d3a3ee: /**
1:6d3a3ee:  * Message to indicate an error to the client.
1:6d3a3ee:  */
1:6d3a3ee: public class ErrorMessage extends Message.Response
5:6d3a3ee: {
1:3a2faf9:     private static final Logger logger = LoggerFactory.getLogger(ErrorMessage.class);
1:3a2faf9: 
1:6d3a3ee:     public static final Message.Codec<ErrorMessage> codec = new Message.Codec<ErrorMessage>()
1:3a2faf9:     {
1:e0adc16:         public ErrorMessage decode(ByteBuf body, ProtocolVersion version)
1:3a2faf9:         {
1:3a2faf9:             ExceptionCode code = ExceptionCode.fromValue(body.readInt());
1:6d3a3ee:             String msg = CBUtil.readString(body);
1:3a2faf9: 
1:3a2faf9:             TransportException te = null;
1:3a2faf9:             switch (code)
1:3a2faf9:             {
1:3a2faf9:                 case SERVER_ERROR:
1:3a2faf9:                     te = new ServerError(msg);
1:3a2faf9:                     break;
1:3a2faf9:                 case PROTOCOL_ERROR:
1:3a2faf9:                     te = new ProtocolException(msg);
1:3a2faf9:                     break;
1:bddfa9e:                 case BAD_CREDENTIALS:
1:bddfa9e:                     te = new AuthenticationException(msg);
1:3a2faf9:                     break;
1:3a2faf9:                 case UNAVAILABLE:
1:ccca5f1:                     {
1:297f530:                         ConsistencyLevel cl = CBUtil.readConsistencyLevel(body);
1:3a2faf9:                         int required = body.readInt();
1:3a2faf9:                         int alive = body.readInt();
1:3a2faf9:                         te = new UnavailableException(cl, required, alive);
1:3a2faf9:                     }
1:3a2faf9:                     break;
1:3a2faf9:                 case OVERLOADED:
1:3a2faf9:                     te = new OverloadedException(msg);
1:3a2faf9:                     break;
1:3a2faf9:                 case IS_BOOTSTRAPPING:
1:3a2faf9:                     te = new IsBootstrappingException();
1:3a2faf9:                     break;
1:3a2faf9:                 case TRUNCATE_ERROR:
1:3a2faf9:                     te = new TruncateException(msg);
1:3a2faf9:                     break;
1:c059a56:                 case WRITE_FAILURE:
1:c6525da:                 case READ_FAILURE:
1:c6525da:                     {
1:c6525da:                         ConsistencyLevel cl = CBUtil.readConsistencyLevel(body);
1:c6525da:                         int received = body.readInt();
1:c6525da:                         int blockFor = body.readInt();
1:39df31a:                         // The number of failures is also present in protocol v5, but used instead to specify the size of the failure map
1:c6525da:                         int failure = body.readInt();
1:39df31a: 
1:39df31a:                         Map<InetAddress, RequestFailureReason> failureReasonByEndpoint = new ConcurrentHashMap<>();
1:e0adc16:                         if (version.isGreaterOrEqualTo(ProtocolVersion.V5))
1:39df31a:                         {
1:39df31a:                             for (int i = 0; i < failure; i++)
1:39df31a:                             {
1:39df31a:                                 InetAddress endpoint = CBUtil.readInetAddr(body);
1:39df31a:                                 RequestFailureReason failureReason = RequestFailureReason.fromCode(body.readUnsignedShort());
1:39df31a:                                 failureReasonByEndpoint.put(endpoint, failureReason);
1:39df31a:                             }
1:39df31a:                         }
1:39df31a: 
1:c059a56:                         if (code == ExceptionCode.WRITE_FAILURE)
1:c059a56:                         {
1:c059a56:                             WriteType writeType = Enum.valueOf(WriteType.class, CBUtil.readString(body));
1:39df31a:                             te = new WriteFailureException(cl, received, blockFor, writeType, failureReasonByEndpoint);
1:c059a56:                         }
1:c059a56:                         else
1:c059a56:                         {
1:c059a56:                             byte dataPresent = body.readByte();
1:39df31a:                             te = new ReadFailureException(cl, received, blockFor, dataPresent != 0, failureReasonByEndpoint);
1:c059a56:                         }
1:c6525da:                     }
1:c6525da:                     break;
1:3a2faf9:                 case WRITE_TIMEOUT:
1:3a2faf9:                 case READ_TIMEOUT:
1:e27a955:                     ConsistencyLevel cl = CBUtil.readConsistencyLevel(body);
1:ee5aafe:                     int received = body.readInt();
1:ee5aafe:                     int blockFor = body.readInt();
1:ee5aafe:                     if (code == ExceptionCode.WRITE_TIMEOUT)
1:ee5aafe:                     {
1:ee5aafe:                         WriteType writeType = Enum.valueOf(WriteType.class, CBUtil.readString(body));
1:ee5aafe:                         te = new WriteTimeoutException(writeType, cl, received, blockFor);
1:ee5aafe:                     }
1:ee5aafe:                     else
1:ee5aafe:                     {
1:c6525da:                         byte dataPresent = body.readByte();
1:3a2faf9:                         te = new ReadTimeoutException(cl, received, blockFor, dataPresent != 0);
1:ee5aafe:                     }
1:3a2faf9:                     break;
1:e3c0186:                 case FUNCTION_FAILURE:
1:e3c0186:                     String fKeyspace = CBUtil.readString(body);
1:e3c0186:                     String fName = CBUtil.readString(body);
1:e3c0186:                     List<String> argTypes = CBUtil.readStringList(body);
1:e3c0186:                     te = new FunctionExecutionException(new FunctionName(fKeyspace, fName), argTypes, msg);
1:e3c0186:                     break;
1:ccca5f1:                 case UNPREPARED:
1:ee5aafe:                     {
1:ccca5f1:                         MD5Digest id = MD5Digest.wrap(CBUtil.readBytes(body));
1:ccca5f1:                         te = new PreparedQueryNotFoundException(id);
1:ccca5f1:                     }
1:ccca5f1:                     break;
1:3a2faf9:                 case SYNTAX_ERROR:
1:3a2faf9:                     te = new SyntaxException(msg);
1:ccca5f1:                     break;
1:3a2faf9:                 case UNAUTHORIZED:
1:3a2faf9:                     te = new UnauthorizedException(msg);
1:3a2faf9:                     break;
1:3a2faf9:                 case INVALID:
1:3a2faf9:                     te = new InvalidRequestException(msg);
1:3a2faf9:                     break;
1:3a2faf9:                 case CONFIG_ERROR:
1:3a2faf9:                     te = new ConfigurationException(msg);
1:3a2faf9:                     break;
1:3a2faf9:                 case ALREADY_EXISTS:
1:3a2faf9:                     String ksName = CBUtil.readString(body);
1:3a2faf9:                     String cfName = CBUtil.readString(body);
1:fa56af1:                     if (cfName.isEmpty())
1:fa56af1:                         te = new AlreadyExistsException(ksName);
1:fa56af1:                     else
1:fa56af1:                         te = new AlreadyExistsException(ksName, cfName);
1:3a2faf9:                     break;
1:3a2faf9:             }
1:3a2faf9:             return new ErrorMessage(te);
1:3a2faf9:         }
1:ee5aafe: 
1:e0adc16:         public void encode(ErrorMessage msg, ByteBuf dest, ProtocolVersion version)
1:3a2faf9:         {
1:c6525da:             final TransportException err = getBackwardsCompatibleException(msg, version);
1:c6525da:             dest.writeInt(err.code().value);
1:5009594:             String errorString = err.getMessage() == null ? "" : err.getMessage();
1:5009594:             CBUtil.writeString(errorString, dest);
1:ee5aafe: 
1:c6525da:             switch (err.code())
1:3a2faf9:             {
1:3a2faf9:                 case UNAVAILABLE:
1:c6525da:                     UnavailableException ue = (UnavailableException)err;
1:f8be23a:                     CBUtil.writeConsistencyLevel(ue.consistency, dest);
1:f8be23a:                     dest.writeInt(ue.required);
1:f8be23a:                     dest.writeInt(ue.alive);
1:3a2faf9:                     break;
1:c059a56:                 case WRITE_FAILURE:
1:c6525da:                 case READ_FAILURE:
1:c6525da:                     {
1:c6525da:                         RequestFailureException rfe = (RequestFailureException)err;
1:c059a56:                         boolean isWrite = err.code() == ExceptionCode.WRITE_FAILURE;
1:c6525da: 
1:c6525da:                         CBUtil.writeConsistencyLevel(rfe.consistency, dest);
1:c6525da:                         dest.writeInt(rfe.received);
1:c6525da:                         dest.writeInt(rfe.blockFor);
1:39df31a:                         // The number of failures is also present in protocol v5, but used instead to specify the size of the failure map
1:39df31a:                         dest.writeInt(rfe.failureReasonByEndpoint.size());
1:c059a56: 
1:e0adc16:                         if (version.isGreaterOrEqualTo(ProtocolVersion.V5))
1:39df31a:                         {
1:39df31a:                             for (Map.Entry<InetAddress, RequestFailureReason> entry : rfe.failureReasonByEndpoint.entrySet())
1:39df31a:                             {
1:39df31a:                                 CBUtil.writeInetAddr(entry.getKey(), dest);
1:39df31a:                                 dest.writeShort(entry.getValue().code);
1:39df31a:                             }
1:39df31a:                         }
1:39df31a: 
1:c059a56:                         if (isWrite)
1:c059a56:                             CBUtil.writeString(((WriteFailureException)rfe).writeType.toString(), dest);
1:c059a56:                         else
1:c059a56:                             dest.writeByte((byte)(((ReadFailureException)rfe).dataPresent ? 1 : 0));
1:c6525da:                     }
1:c6525da:                     break;
1:3a2faf9:                 case WRITE_TIMEOUT:
1:3a2faf9:                 case READ_TIMEOUT:
1:c6525da:                     RequestTimeoutException rte = (RequestTimeoutException)err;
1:c6525da:                     boolean isWrite = err.code() == ExceptionCode.WRITE_TIMEOUT;
1:ee5aafe: 
1:f8be23a:                     CBUtil.writeConsistencyLevel(rte.consistency, dest);
1:f8be23a:                     dest.writeInt(rte.received);
1:f8be23a:                     dest.writeInt(rte.blockFor);
1:ee5aafe:                     if (isWrite)
1:f8be23a:                         CBUtil.writeString(((WriteTimeoutException)rte).writeType.toString(), dest);
1:ee5aafe:                     else
1:f8be23a:                         dest.writeByte((byte)(((ReadTimeoutException)rte).dataPresent ? 1 : 0));
1:3a2faf9:                     break;
1:e3c0186:                 case FUNCTION_FAILURE:
1:e3c0186:                     FunctionExecutionException fee = (FunctionExecutionException)msg.error;
1:e3c0186:                     CBUtil.writeString(fee.functionName.keyspace, dest);
1:e3c0186:                     CBUtil.writeString(fee.functionName.name, dest);
1:e3c0186:                     CBUtil.writeStringList(fee.argTypes, dest);
1:e3c0186:                     break;
1:ccca5f1:                 case UNPREPARED:
1:c6525da:                     PreparedQueryNotFoundException pqnfe = (PreparedQueryNotFoundException)err;
1:f8be23a:                     CBUtil.writeBytes(pqnfe.id.bytes, dest);
1:3a2faf9:                     break;
1:3a2faf9:                 case ALREADY_EXISTS:
1:c6525da:                     AlreadyExistsException aee = (AlreadyExistsException)err;
1:f8be23a:                     CBUtil.writeString(aee.ksName, dest);
1:f8be23a:                     CBUtil.writeString(aee.cfName, dest);
1:3a2faf9:                     break;
1:f8be23a:             }
1:ee5aafe:         }
1:f8be23a: 
1:e0adc16:         public int encodedSize(ErrorMessage msg, ProtocolVersion version)
1:f8be23a:         {
1:c6525da:             final TransportException err = getBackwardsCompatibleException(msg, version);
1:5009594:             String errorString = err.getMessage() == null ? "" : err.getMessage();
1:5009594:             int size = 4 + CBUtil.sizeOfString(errorString);
1:c6525da:             switch (err.code())
1:f8be23a:             {
1:f8be23a:                 case UNAVAILABLE:
1:c6525da:                     UnavailableException ue = (UnavailableException)err;
1:f8be23a:                     size += CBUtil.sizeOfConsistencyLevel(ue.consistency) + 8;
1:c6525da:                     break;
1:c059a56:                 case WRITE_FAILURE:
1:c6525da:                 case READ_FAILURE:
1:c6525da:                     {
1:c059a56:                         RequestFailureException rfe = (RequestFailureException)err;
1:c059a56:                         boolean isWrite = err.code() == ExceptionCode.WRITE_FAILURE;
1:c059a56:                         size += CBUtil.sizeOfConsistencyLevel(rfe.consistency) + 4 + 4 + 4;
1:c059a56:                         size += isWrite ? CBUtil.sizeOfString(((WriteFailureException)rfe).writeType.toString()) : 1;
1:39df31a: 
1:e0adc16:                         if (version.isGreaterOrEqualTo(ProtocolVersion.V5))
1:39df31a:                         {
1:39df31a:                             for (Map.Entry<InetAddress, RequestFailureReason> entry : rfe.failureReasonByEndpoint.entrySet())
1:39df31a:                             {
1:39df31a:                                 size += CBUtil.sizeOfInetAddr(entry.getKey());
1:39df31a:                                 size += 2; // RequestFailureReason code
1:39df31a:                             }
1:39df31a:                         }
1:c6525da:                     }
1:f8be23a:                     break;
1:f8be23a:                 case WRITE_TIMEOUT:
1:f8be23a:                 case READ_TIMEOUT:
1:c6525da:                     RequestTimeoutException rte = (RequestTimeoutException)err;
1:c6525da:                     boolean isWrite = err.code() == ExceptionCode.WRITE_TIMEOUT;
1:f8be23a:                     size += CBUtil.sizeOfConsistencyLevel(rte.consistency) + 8;
1:f8be23a:                     size += isWrite ? CBUtil.sizeOfString(((WriteTimeoutException)rte).writeType.toString()) : 1;
1:f8be23a:                     break;
1:e3c0186:                 case FUNCTION_FAILURE:
1:e3c0186:                     FunctionExecutionException fee = (FunctionExecutionException)msg.error;
1:e3c0186:                     size += CBUtil.sizeOfString(fee.functionName.keyspace);
1:e3c0186:                     size += CBUtil.sizeOfString(fee.functionName.name);
1:e3c0186:                     size += CBUtil.sizeOfStringList(fee.argTypes);
1:e3c0186:                     break;
1:f8be23a:                 case UNPREPARED:
1:c6525da:                     PreparedQueryNotFoundException pqnfe = (PreparedQueryNotFoundException)err;
1:f8be23a:                     size += CBUtil.sizeOfBytes(pqnfe.id.bytes);
1:f8be23a:                     break;
1:f8be23a:                 case ALREADY_EXISTS:
1:c6525da:                     AlreadyExistsException aee = (AlreadyExistsException)err;
1:f8be23a:                     size += CBUtil.sizeOfString(aee.ksName);
1:f8be23a:                     size += CBUtil.sizeOfString(aee.cfName);
1:f8be23a:                     break;
1:f8be23a:             }
1:f8be23a:             return size;
1:3a2faf9:         }
1:6d3a3ee:     };
1:3a2faf9: 
1:e0adc16:     private static TransportException getBackwardsCompatibleException(ErrorMessage msg, ProtocolVersion version)
1:c6525da:     {
1:e0adc16:         if (version.isSmallerThan(ProtocolVersion.V4))
1:c6525da:         {
1:e3c0186:             switch (msg.error.code())
1:e3c0186:             {
1:e3c0186:                 case READ_FAILURE:
1:e3c0186:                     ReadFailureException rfe = (ReadFailureException) msg.error;
1:e3c0186:                     return new ReadTimeoutException(rfe.consistency, rfe.received, rfe.blockFor, rfe.dataPresent);
1:c059a56:                 case WRITE_FAILURE:
1:c059a56:                     WriteFailureException wfe = (WriteFailureException) msg.error;
1:c059a56:                     return new WriteTimeoutException(wfe.writeType, wfe.consistency, wfe.received, wfe.blockFor);
1:e3c0186:                 case FUNCTION_FAILURE:
1:e3c0186:                     return new InvalidRequestException(msg.toString());
1:e3c0186:             }
1:c6525da:         }
1:c6525da: 
1:c6525da:         return msg.error;
1:c6525da:     }
1:c6525da: 
1:6d3a3ee:     // We need to figure error codes out (#3979)
1:3a2faf9:     public final TransportException error;
1:3a2faf9: 
1:3a2faf9:     private ErrorMessage(TransportException error)
1:6d3a3ee:     {
1:6d3a3ee:         super(Message.Type.ERROR);
1:3a2faf9:         this.error = error;
1:3a2faf9:     }
1:6d3a3ee: 
1:b14fc6d:     private ErrorMessage(TransportException error, int streamId)
1:b14fc6d:     {
1:b14fc6d:         this(error);
1:b14fc6d:         setStreamId(streamId);
1:b14fc6d:     }
1:b14fc6d: 
1:3a2faf9:     public static ErrorMessage fromException(Throwable e)
1:6d3a3ee:     {
1:cbc705d:         return fromException(e, null);
1:cbc705d:     }
1:cbc705d: 
1:cbc705d:     /**
1:cbc705d:      * @param e the exception
1:cbc705d:      * @param unexpectedExceptionHandler a callback for handling unexpected exceptions. If null, or if this
1:cbc705d:      *                                   returns false, the error is logged at ERROR level via sl4fj
1:cbc705d:      */
1:cbc705d:     public static ErrorMessage fromException(Throwable e, Predicate<Throwable> unexpectedExceptionHandler)
1:cbc705d:     {
1:b14fc6d:         int streamId = 0;
1:f16507d: 
1:f16507d:         // Netty will wrap exceptions during decoding in a CodecException. If the cause was one of our ProtocolExceptions
1:f16507d:         // or some other internal exception, extract that and use it.
1:f16507d:         if (e instanceof CodecException)
1:f16507d:         {
1:f16507d:             Throwable cause = e.getCause();
1:b3177f1:             if (cause != null)
1:f16507d:             {
1:b3177f1:                 if (cause instanceof WrappedException)
1:b3177f1:                 {
1:b3177f1:                     streamId = ((WrappedException) cause).streamId;
1:b3177f1:                     e = cause.getCause();
1:b3177f1:                 }
1:b3177f1:                 else if (cause instanceof TransportException)
1:b3177f1:                 {
1:b3177f1:                     e = cause;
1:b3177f1:                 }
1:f16507d:             }
1:f16507d:         }
1:f16507d:         else if (e instanceof WrappedException)
1:b14fc6d:         {
1:b14fc6d:             streamId = ((WrappedException)e).streamId;
1:b14fc6d:             e = e.getCause();
1:b14fc6d:         }
1:b14fc6d: 
1:3a2faf9:         if (e instanceof TransportException)
1:904137c:         {
1:904137c:             ErrorMessage message = new ErrorMessage((TransportException) e, streamId);
1:904137c:             if (e instanceof ProtocolException)
1:904137c:             {
1:e0adc16:                 // if the driver attempted to connect with a protocol version not supported then
1:e0adc16:                 // reply with the appropiate version, see ProtocolVersion.decode()
1:e0adc16:                 ProtocolVersion forcedProtocolVersion = ((ProtocolException) e).getForcedProtocolVersion();
1:e0adc16:                 if (forcedProtocolVersion != null)
1:e0adc16:                     message.forcedProtocolVersion = forcedProtocolVersion;
1:904137c:             }
1:904137c:             return message;
1:904137c:         }
1:6d3a3ee: 
1:3a2faf9:         // Unexpected exception
1:cbc705d:         if (unexpectedExceptionHandler == null || !unexpectedExceptionHandler.apply(e))
1:cbc705d:             logger.error("Unexpected exception during request", e);
1:cbc705d: 
1:b14fc6d:         return new ErrorMessage(new ServerError(e), streamId);
5:6d3a3ee:     }
1:6d3a3ee: 
1:6d3a3ee:     @Override
1:6d3a3ee:     public String toString()
1:6d3a3ee:     {
1:3a2faf9:         return "ERROR " + error.code() + ": " + error.getMessage();
1:6d3a3ee:     }
1:b14fc6d: 
1:b14fc6d:     public static RuntimeException wrap(Throwable t, int streamId)
1:b14fc6d:     {
1:b14fc6d:         return new WrappedException(t, streamId);
1:b14fc6d:     }
1:b14fc6d: 
1:5654e73:     public static class WrappedException extends RuntimeException
1:b14fc6d:     {
1:b14fc6d:         private final int streamId;
1:b14fc6d: 
1:b14fc6d:         public WrappedException(Throwable cause, int streamId)
1:b14fc6d:         {
1:b14fc6d:             super(cause);
1:b14fc6d:             this.streamId = streamId;
1:b14fc6d:         }
1:5654e73: 
1:5654e73:         @VisibleForTesting
1:5654e73:         public int getStreamId()
1:5654e73:         {
1:5654e73:             return this.streamId;
1:5654e73:         }
1:b14fc6d:     }
1:b14fc6d: 
1:6d3a3ee: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:e0adc16
/////////////////////////////////////////////////////////////////////////
1:         public ErrorMessage decode(ByteBuf body, ProtocolVersion version)
/////////////////////////////////////////////////////////////////////////
1:                         if (version.isGreaterOrEqualTo(ProtocolVersion.V5))
/////////////////////////////////////////////////////////////////////////
1:         public void encode(ErrorMessage msg, ByteBuf dest, ProtocolVersion version)
/////////////////////////////////////////////////////////////////////////
1:                         if (version.isGreaterOrEqualTo(ProtocolVersion.V5))
/////////////////////////////////////////////////////////////////////////
1:         public int encodedSize(ErrorMessage msg, ProtocolVersion version)
/////////////////////////////////////////////////////////////////////////
1:                         if (version.isGreaterOrEqualTo(ProtocolVersion.V5))
/////////////////////////////////////////////////////////////////////////
1:     private static TransportException getBackwardsCompatibleException(ErrorMessage msg, ProtocolVersion version)
1:         if (version.isSmallerThan(ProtocolVersion.V4))
/////////////////////////////////////////////////////////////////////////
1:                 // if the driver attempted to connect with a protocol version not supported then
1:                 // reply with the appropiate version, see ProtocolVersion.decode()
1:                 ProtocolVersion forcedProtocolVersion = ((ProtocolException) e).getForcedProtocolVersion();
1:                 if (forcedProtocolVersion != null)
1:                     message.forcedProtocolVersion = forcedProtocolVersion;
commit:c059a56
/////////////////////////////////////////////////////////////////////////
1:                 case WRITE_FAILURE: 
1:                         if (code == ExceptionCode.WRITE_FAILURE)
1:                         {
1:                             WriteType writeType = Enum.valueOf(WriteType.class, CBUtil.readString(body));
0:                             te = new WriteFailureException(cl, received, failure, blockFor, writeType);
1:                         }
1:                         else
1:                         {
1:                             byte dataPresent = body.readByte();
0:                             te = new ReadFailureException(cl, received, failure, blockFor, dataPresent != 0);   
1:                         }
/////////////////////////////////////////////////////////////////////////
1:                 case WRITE_FAILURE:
1:                         boolean isWrite = err.code() == ExceptionCode.WRITE_FAILURE;
1: 
1:                         if (isWrite)
1:                             CBUtil.writeString(((WriteFailureException)rfe).writeType.toString(), dest);
1:                         else
1:                             dest.writeByte((byte)(((ReadFailureException)rfe).dataPresent ? 1 : 0));
/////////////////////////////////////////////////////////////////////////
1:                 case WRITE_FAILURE:
1:                         RequestFailureException rfe = (RequestFailureException)err;
1:                         boolean isWrite = err.code() == ExceptionCode.WRITE_FAILURE;
1:                         size += CBUtil.sizeOfConsistencyLevel(rfe.consistency) + 4 + 4 + 4;
1:                         size += isWrite ? CBUtil.sizeOfString(((WriteFailureException)rfe).writeType.toString()) : 1;
/////////////////////////////////////////////////////////////////////////
1:                 case WRITE_FAILURE:
1:                     WriteFailureException wfe = (WriteFailureException) msg.error;
1:                     return new WriteTimeoutException(wfe.writeType, wfe.consistency, wfe.received, wfe.blockFor);
author:Geoffrey Yu
-------------------------------------------------------------------------------
commit:39df31a
/////////////////////////////////////////////////////////////////////////
1: import java.net.InetAddress;
1: import java.util.Map;
1: import java.util.concurrent.ConcurrentHashMap;
/////////////////////////////////////////////////////////////////////////
0:                 case WRITE_FAILURE:
1:                         // The number of failures is also present in protocol v5, but used instead to specify the size of the failure map
1: 
1:                         Map<InetAddress, RequestFailureReason> failureReasonByEndpoint = new ConcurrentHashMap<>();
0:                         if (version >= Server.VERSION_5)
1:                         {
1:                             for (int i = 0; i < failure; i++)
1:                             {
1:                                 InetAddress endpoint = CBUtil.readInetAddr(body);
1:                                 RequestFailureReason failureReason = RequestFailureReason.fromCode(body.readUnsignedShort());
1:                                 failureReasonByEndpoint.put(endpoint, failureReason);
1:                             }
1:                         }
1: 
1:                             te = new WriteFailureException(cl, received, blockFor, writeType, failureReasonByEndpoint);
1:                             te = new ReadFailureException(cl, received, blockFor, dataPresent != 0, failureReasonByEndpoint);
/////////////////////////////////////////////////////////////////////////
1:                         // The number of failures is also present in protocol v5, but used instead to specify the size of the failure map
1:                         dest.writeInt(rfe.failureReasonByEndpoint.size());
1: 
0:                         if (version >= Server.VERSION_5)
1:                         {
1:                             for (Map.Entry<InetAddress, RequestFailureReason> entry : rfe.failureReasonByEndpoint.entrySet())
1:                             {
1:                                 CBUtil.writeInetAddr(entry.getKey(), dest);
1:                                 dest.writeShort(entry.getValue().code);
1:                             }
1:                         }
/////////////////////////////////////////////////////////////////////////
1: 
0:                         if (version >= Server.VERSION_5)
1:                         {
1:                             for (Map.Entry<InetAddress, RequestFailureReason> entry : rfe.failureReasonByEndpoint.entrySet())
1:                             {
1:                                 size += CBUtil.sizeOfInetAddr(entry.getKey());
1:                                 size += 2; // RequestFailureReason code
1:                             }
1:                         }
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:904137c
/////////////////////////////////////////////////////////////////////////
1:         {
1:             ErrorMessage message = new ErrorMessage((TransportException) e, streamId);
1:             if (e instanceof ProtocolException)
1:             {
0:                 // if the driver attempted to connect with a protocol version lower than the minimum supported
0:                 // version, respond with a protocol error message with the correct frame header for that version
0:                 Integer attemptedLowProtocolVersion = ((ProtocolException) e).getAttemptedLowProtocolVersion();
0:                 if (attemptedLowProtocolVersion != null)
0:                     message.forcedProtocolVersion = attemptedLowProtocolVersion;
1:             }
1:             return message;
1:         }
commit:5009594
/////////////////////////////////////////////////////////////////////////
1:             String errorString = err.getMessage() == null ? "" : err.getMessage();
1:             CBUtil.writeString(errorString, dest);
/////////////////////////////////////////////////////////////////////////
1:             String errorString = err.getMessage() == null ? "" : err.getMessage();
1:             int size = 4 + CBUtil.sizeOfString(errorString);
commit:05253cc
commit:b3177f1
/////////////////////////////////////////////////////////////////////////
1:             if (cause != null)
1:                 if (cause instanceof WrappedException)
1:                 {
1:                     streamId = ((WrappedException) cause).streamId;
1:                     e = cause.getCause();
1:                 }
1:                 else if (cause instanceof TransportException)
1:                 {
1:                     e = cause;
1:                 }
commit:369ed3e
commit:e76ebce
commit:f16507d
/////////////////////////////////////////////////////////////////////////
1: import io.netty.handler.codec.CodecException;
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Netty will wrap exceptions during decoding in a CodecException. If the cause was one of our ProtocolExceptions
1:         // or some other internal exception, extract that and use it.
1:         if (e instanceof CodecException)
1:         {
1:             Throwable cause = e.getCause();
0:             if (cause != null && cause instanceof WrappedException)
1:             {
0:                 streamId = ((WrappedException)cause).streamId;
0:                 e = cause.getCause();
1:             }
1:         }
1:         else if (e instanceof WrappedException)
commit:3dd2f00
author:Chris Bannister
-------------------------------------------------------------------------------
commit:5654e73
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.annotations.VisibleForTesting;
/////////////////////////////////////////////////////////////////////////
1:     @VisibleForTesting
1:     public static class WrappedException extends RuntimeException
/////////////////////////////////////////////////////////////////////////
1: 
1:         public int getStreamId()
1:         {
1:             return this.streamId;
1:         }
author:Robert Stupp
-------------------------------------------------------------------------------
commit:e3c0186
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
1: 
1: import org.apache.cassandra.cql3.functions.FunctionName;
/////////////////////////////////////////////////////////////////////////
1:                 case FUNCTION_FAILURE:
1:                     String fKeyspace = CBUtil.readString(body);
1:                     String fName = CBUtil.readString(body);
1:                     List<String> argTypes = CBUtil.readStringList(body);
1:                     te = new FunctionExecutionException(new FunctionName(fKeyspace, fName), argTypes, msg);
1:                     break;
/////////////////////////////////////////////////////////////////////////
1:                 case FUNCTION_FAILURE:
1:                     FunctionExecutionException fee = (FunctionExecutionException)msg.error;
1:                     CBUtil.writeString(fee.functionName.keyspace, dest);
1:                     CBUtil.writeString(fee.functionName.name, dest);
1:                     CBUtil.writeStringList(fee.argTypes, dest);
1:                     break;
/////////////////////////////////////////////////////////////////////////
1:                 case FUNCTION_FAILURE:
1:                     FunctionExecutionException fee = (FunctionExecutionException)msg.error;
1:                     size += CBUtil.sizeOfString(fee.functionName.keyspace);
1:                     size += CBUtil.sizeOfString(fee.functionName.name);
1:                     size += CBUtil.sizeOfStringList(fee.argTypes);
1:                     break;
/////////////////////////////////////////////////////////////////////////
0:         if (version < Server.VERSION_4)
1:             switch (msg.error.code())
1:             {
1:                 case READ_FAILURE:
1:                     ReadFailureException rfe = (ReadFailureException) msg.error;
1:                     return new ReadTimeoutException(rfe.consistency, rfe.received, rfe.blockFor, rfe.dataPresent);
1:                 case FUNCTION_FAILURE:
1:                     return new InvalidRequestException(msg.toString());
1:             }
author:Christian Spriegel
-------------------------------------------------------------------------------
commit:c6525da
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.transport.*;
/////////////////////////////////////////////////////////////////////////
1:                 case READ_FAILURE:
1:                     {
1:                         ConsistencyLevel cl = CBUtil.readConsistencyLevel(body);
1:                         int received = body.readInt();
1:                         int blockFor = body.readInt();
1:                         int failure = body.readInt();
1:                         byte dataPresent = body.readByte();
0:                         te = new ReadFailureException(cl, received, failure, blockFor, dataPresent != 0);
1:                     }
1:                     break;
/////////////////////////////////////////////////////////////////////////
1:             final TransportException err = getBackwardsCompatibleException(msg, version);
1:             dest.writeInt(err.code().value);
0:             CBUtil.writeString(err.getMessage(), dest);
1:             switch (err.code())
1:                     UnavailableException ue = (UnavailableException)err;
1:                 case READ_FAILURE:
1:                     {
1:                         RequestFailureException rfe = (RequestFailureException)err;
1: 
1:                         CBUtil.writeConsistencyLevel(rfe.consistency, dest);
1:                         dest.writeInt(rfe.received);
1:                         dest.writeInt(rfe.blockFor);
0:                         dest.writeInt(rfe.failures);
0:                         dest.writeByte((byte)(((ReadFailureException)rfe).dataPresent ? 1 : 0));
1:                     }
1:                     break;
1:                     RequestTimeoutException rte = (RequestTimeoutException)err;
1:                     boolean isWrite = err.code() == ExceptionCode.WRITE_TIMEOUT;
/////////////////////////////////////////////////////////////////////////
1:                     PreparedQueryNotFoundException pqnfe = (PreparedQueryNotFoundException)err;
1:                     AlreadyExistsException aee = (AlreadyExistsException)err;
/////////////////////////////////////////////////////////////////////////
1:             final TransportException err = getBackwardsCompatibleException(msg, version);
0:             int size = 4 + CBUtil.sizeOfString(err.getMessage());
1:             switch (err.code())
1:                     UnavailableException ue = (UnavailableException)err;
1:                 case READ_FAILURE:
1:                     {
0:                         ReadFailureException rfe = (ReadFailureException)err;
0:                         size += CBUtil.sizeOfConsistencyLevel(rfe.consistency) + 4 + 4 + 4 + 1;
1:                     }
1:                     break;
1:                     RequestTimeoutException rte = (RequestTimeoutException)err;
1:                     boolean isWrite = err.code() == ExceptionCode.WRITE_TIMEOUT;
1:                     PreparedQueryNotFoundException pqnfe = (PreparedQueryNotFoundException)err;
1:                     AlreadyExistsException aee = (AlreadyExistsException)err;
/////////////////////////////////////////////////////////////////////////
0:     private static TransportException getBackwardsCompatibleException(ErrorMessage msg, int version)
1:     {
0:         if (msg.error.code() == ExceptionCode.READ_FAILURE && version < Server.VERSION_4)
1:         {
0:             ReadFailureException rfe = (ReadFailureException) msg.error;
0:             return new ReadTimeoutException(rfe.consistency, rfe.received, rfe.blockFor, rfe.dataPresent);
1:         }
1: 
1:         return msg.error;
1:     }
1: 
author:Graham Sanderson
-------------------------------------------------------------------------------
commit:cbc705d
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.base.Predicate;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return fromException(e, null);
1:     }
1: 
1:     /**
1:      * @param e the exception
1:      * @param unexpectedExceptionHandler a callback for handling unexpected exceptions. If null, or if this
1:      *                                   returns false, the error is logged at ERROR level via sl4fj
1:      */
1:     public static ErrorMessage fromException(Throwable e, Predicate<Throwable> unexpectedExceptionHandler)
1:     {
/////////////////////////////////////////////////////////////////////////
1:         if (unexpectedExceptionHandler == null || !unexpectedExceptionHandler.apply(e))
1:             logger.error("Unexpected exception during request", e);
1: 
author:belliottsmith
-------------------------------------------------------------------------------
commit:cbf304e
/////////////////////////////////////////////////////////////////////////
1: import io.netty.buffer.ByteBuf;
/////////////////////////////////////////////////////////////////////////
0:         public ErrorMessage decode(ByteBuf body, int version)
/////////////////////////////////////////////////////////////////////////
0:         public void encode(ErrorMessage msg, ByteBuf dest, int version)
author:Dave Brosius
-------------------------------------------------------------------------------
commit:02fb218
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:95f94a4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:f8be23a
/////////////////////////////////////////////////////////////////////////
0:         public void encode(ErrorMessage msg, ChannelBuffer dest, int version)
0:             dest.writeInt(msg.error.code().value);
0:             CBUtil.writeString(msg.error.getMessage(), dest);
1:                     CBUtil.writeConsistencyLevel(ue.consistency, dest);
1:                     dest.writeInt(ue.required);
1:                     dest.writeInt(ue.alive);
1:                     CBUtil.writeConsistencyLevel(rte.consistency, dest);
1:                     dest.writeInt(rte.received);
1:                     dest.writeInt(rte.blockFor);
1:                         CBUtil.writeString(((WriteTimeoutException)rte).writeType.toString(), dest);
1:                         dest.writeByte((byte)(((ReadTimeoutException)rte).dataPresent ? 1 : 0));
1:                     CBUtil.writeBytes(pqnfe.id.bytes, dest);
1:                     CBUtil.writeString(aee.ksName, dest);
1:                     CBUtil.writeString(aee.cfName, dest);
1:         }
1: 
0:         public int encodedSize(ErrorMessage msg, int version)
1:         {
0:             int size = 4 + CBUtil.sizeOfString(msg.error.getMessage());
0:             switch (msg.error.code())
1:             {
1:                 case UNAVAILABLE:
0:                     UnavailableException ue = (UnavailableException)msg.error;
1:                     size += CBUtil.sizeOfConsistencyLevel(ue.consistency) + 8;
1:                     break;
1:                 case WRITE_TIMEOUT:
1:                 case READ_TIMEOUT:
0:                     RequestTimeoutException rte = (RequestTimeoutException)msg.error;
0:                     boolean isWrite = msg.error.code() == ExceptionCode.WRITE_TIMEOUT;
1:                     size += CBUtil.sizeOfConsistencyLevel(rte.consistency) + 8;
1:                     size += isWrite ? CBUtil.sizeOfString(((WriteTimeoutException)rte).writeType.toString()) : 1;
1:                     break;
1:                 case UNPREPARED:
0:                     PreparedQueryNotFoundException pqnfe = (PreparedQueryNotFoundException)msg.error;
1:                     size += CBUtil.sizeOfBytes(pqnfe.id.bytes);
1:                     break;
1:                 case ALREADY_EXISTS:
0:                     AlreadyExistsException aee = (AlreadyExistsException)msg.error;
1:                     size += CBUtil.sizeOfString(aee.ksName);
1:                     size += CBUtil.sizeOfString(aee.cfName);
1:                     break;
1:             }
1:             return size;
/////////////////////////////////////////////////////////////////////////
commit:5a18e37
/////////////////////////////////////////////////////////////////////////
0:     public ChannelBuffer encode(int version)
0:         return codec.encode(this, version);
commit:e48ff29
/////////////////////////////////////////////////////////////////////////
0:         public ChannelBuffer encode(ErrorMessage msg, int version)
/////////////////////////////////////////////////////////////////////////
0:         return codec.encode(this, getVersion());
commit:b14fc6d
/////////////////////////////////////////////////////////////////////////
1:     private ErrorMessage(TransportException error, int streamId)
1:     {
1:         this(error);
1:         setStreamId(streamId);
1:     }
1: 
1:         int streamId = 0;
0:         if (e instanceof WrappedException)
1:         {
1:             streamId = ((WrappedException)e).streamId;
1:             e = e.getCause();
1:         }
1: 
0:             return new ErrorMessage((TransportException)e, streamId);
1:         return new ErrorMessage(new ServerError(e), streamId);
/////////////////////////////////////////////////////////////////////////
1: 
1:     public static RuntimeException wrap(Throwable t, int streamId)
1:     {
1:         return new WrappedException(t, streamId);
1:     }
1: 
0:     private static class WrappedException extends RuntimeException
1:     {
1:         private final int streamId;
1: 
1:         public WrappedException(Throwable cause, int streamId)
1:         {
1:             super(cause);
1:             this.streamId = streamId;
1:         }
1:     }
1: 
commit:9c5e5dc
/////////////////////////////////////////////////////////////////////////
0:                     acb = ChannelBuffers.buffer(rteCl.readableBytes() + 8 + extraSize);
commit:e27a955
/////////////////////////////////////////////////////////////////////////
1:                     ConsistencyLevel cl = CBUtil.readConsistencyLevel(body);
/////////////////////////////////////////////////////////////////////////
0:                     ChannelBuffer rteCl = CBUtil.consistencyLevelToCB(rte.consistency);
0:                     acb = ChannelBuffers.buffer(rteCl.writableBytes() + 8 + extraSize);
commit:297f530
/////////////////////////////////////////////////////////////////////////
1:                         ConsistencyLevel cl = CBUtil.readConsistencyLevel(body);
/////////////////////////////////////////////////////////////////////////
0:                     ChannelBuffer ueCl = CBUtil.consistencyLevelToCB(ue.consistency);
0:                     acb = ChannelBuffers.buffer(ueCl.readableBytes() + 8);
commit:fa56af1
/////////////////////////////////////////////////////////////////////////
1:                     if (cfName.isEmpty())
1:                         te = new AlreadyExistsException(ksName);
1:                     else
1:                         te = new AlreadyExistsException(ksName, cfName);
commit:ee5aafe
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.WriteType;
/////////////////////////////////////////////////////////////////////////
0:                     ConsistencyLevel cl = Enum.valueOf(ConsistencyLevel.class, CBUtil.readString(body));
1:                     int received = body.readInt();
1:                     int blockFor = body.readInt();
1:                     if (code == ExceptionCode.WRITE_TIMEOUT)
1:                         WriteType writeType = Enum.valueOf(WriteType.class, CBUtil.readString(body));
1:                         te = new WriteTimeoutException(writeType, cl, received, blockFor);
1:                     }
1:                     else
1:                     {
/////////////////////////////////////////////////////////////////////////
0:                     boolean isWrite = msg.error.code() == ExceptionCode.WRITE_TIMEOUT;
1: 
0:                     ByteBuffer writeType = isWrite
0:                                          ? ByteBufferUtil.bytes(((WriteTimeoutException)rte).writeType.toString())
0:                                          : null;
1: 
0:                     int extraSize = isWrite  ? 2 + writeType.remaining() : 1;
0:                     acb = ChannelBuffers.buffer(2 + rteCl.remaining() + 8 + extraSize);
1: 
1:                     if (isWrite)
1:                     {
0:                         acb.writeShort((short)writeType.remaining());
0:                         acb.writeBytes(writeType);
1:                     }
1:                     else
1:                     {
0:                         acb.writeByte((byte)(((ReadTimeoutException)rte).dataPresent ? 1 : 0));
1:                     }
commit:e232407
/////////////////////////////////////////////////////////////////////////
0:         logger.error("Unexpected exception during request", e);
commit:ccca5f1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.MD5Digest;
/////////////////////////////////////////////////////////////////////////
1:                 case UNPREPARED:
1:                     {
1:                         MD5Digest id = MD5Digest.wrap(CBUtil.readBytes(body));
1:                         te = new PreparedQueryNotFoundException(id);
1:                     }
1:                     break;
/////////////////////////////////////////////////////////////////////////
1:                 case UNPREPARED:
0:                     PreparedQueryNotFoundException pqnfe = (PreparedQueryNotFoundException)msg.error;
0:                     acb = CBUtil.bytesToCB(pqnfe.id.bytes);
1:                     break;
commit:3a2faf9
/////////////////////////////////////////////////////////////////////////
0: import java.nio.ByteBuffer;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: import org.apache.cassandra.db.ConsistencyLevel;
1: import org.apache.cassandra.exceptions.*;
0: import org.apache.cassandra.transport.ServerError;
0: import org.apache.cassandra.utils.ByteBufferUtil;
1:     private static final Logger logger = LoggerFactory.getLogger(ErrorMessage.class);
1: 
1:             ExceptionCode code = ExceptionCode.fromValue(body.readInt());
1: 
1:             TransportException te = null;
1:             switch (code)
1:             {
1:                 case SERVER_ERROR:
1:                     te = new ServerError(msg);
1:                     break;
1:                 case PROTOCOL_ERROR:
1:                     te = new ProtocolException(msg);
1:                     break;
1:                 case UNAVAILABLE:
1:                     {
0:                         ConsistencyLevel cl = Enum.valueOf(ConsistencyLevel.class, CBUtil.readString(body));
1:                         int required = body.readInt();
1:                         int alive = body.readInt();
1:                         te = new UnavailableException(cl, required, alive);
1:                     }
1:                     break;
1:                 case OVERLOADED:
1:                     te = new OverloadedException(msg);
1:                     break;
1:                 case IS_BOOTSTRAPPING:
1:                     te = new IsBootstrappingException();
1:                     break;
1:                 case TRUNCATE_ERROR:
1:                     te = new TruncateException(msg);
1:                     break;
1:                 case WRITE_TIMEOUT:
1:                     {
0:                         ConsistencyLevel cl = Enum.valueOf(ConsistencyLevel.class, CBUtil.readString(body));
0:                         int received = body.readInt();
0:                         int blockFor = body.readInt();
0:                         te = new WriteTimeoutException(cl, received, blockFor);
1:                     }
1:                     break;
1:                 case READ_TIMEOUT:
1:                     {
0:                         ConsistencyLevel cl = Enum.valueOf(ConsistencyLevel.class, CBUtil.readString(body));
0:                         int received = body.readInt();
0:                         int blockFor = body.readInt();
0:                         byte dataPresent = body.readByte();
1:                         te = new ReadTimeoutException(cl, received, blockFor, dataPresent != 0);
1:                     }
1:                     break;
1:                 case SYNTAX_ERROR:
1:                     te = new SyntaxException(msg);
1:                     break;
1:                 case UNAUTHORIZED:
1:                     te = new UnauthorizedException(msg);
1:                     break;
1:                 case INVALID:
1:                     te = new InvalidRequestException(msg);
1:                     break;
1:                 case CONFIG_ERROR:
1:                     te = new ConfigurationException(msg);
1:                     break;
1:                 case ALREADY_EXISTS:
1:                     String ksName = CBUtil.readString(body);
1:                     String cfName = CBUtil.readString(body);
0:                     te = new AlreadyExistsException(ksName, cfName);
1:                     break;
1:             }
1:             return new ErrorMessage(te);
0:             ChannelBuffer ccb = CBUtil.intToCB(msg.error.code().value);
0:             ChannelBuffer mcb = CBUtil.stringToCB(msg.error.getMessage());
1: 
0:             ChannelBuffer acb = ChannelBuffers.EMPTY_BUFFER;
0:             switch (msg.error.code())
1:             {
1:                 case UNAVAILABLE:
0:                     UnavailableException ue = (UnavailableException)msg.error;
0:                     ByteBuffer ueCl = ByteBufferUtil.bytes(ue.consistency.toString());
1: 
0:                     acb = ChannelBuffers.buffer(2 + ueCl.remaining() + 8);
0:                     acb.writeShort((short)ueCl.remaining());
0:                     acb.writeBytes(ueCl);
0:                     acb.writeInt(ue.required);
0:                     acb.writeInt(ue.alive);
1:                     break;
1:                 case WRITE_TIMEOUT:
1:                 case READ_TIMEOUT:
0:                     RequestTimeoutException rte = (RequestTimeoutException)msg.error;
0:                     ReadTimeoutException readEx = rte instanceof ReadTimeoutException
0:                                                 ? (ReadTimeoutException)rte
0:                                                 : null;
0:                     ByteBuffer rteCl = ByteBufferUtil.bytes(rte.consistency.toString());
0:                     acb = ChannelBuffers.buffer(2 + rteCl.remaining() + 8 + (readEx == null ? 0 : 1));
0:                     acb.writeShort((short)rteCl.remaining());
0:                     acb.writeBytes(rteCl);
0:                     acb.writeInt(rte.received);
0:                     acb.writeInt(rte.blockFor);
0:                     if (readEx != null)
0:                         acb.writeByte((byte)(readEx.dataPresent ? 1 : 0));
1:                     break;
1:                 case ALREADY_EXISTS:
0:                     AlreadyExistsException aee = (AlreadyExistsException)msg.error;
0:                     acb = ChannelBuffers.wrappedBuffer(CBUtil.stringToCB(aee.ksName),
0:                                                        CBUtil.stringToCB(aee.cfName));
1:                     break;
1:             }
0:             return ChannelBuffers.wrappedBuffer(ccb, mcb, acb);
1:     public final TransportException error;
1:     private ErrorMessage(TransportException error)
1:         this.error = error;
1:     public static ErrorMessage fromException(Throwable e)
1:         if (e instanceof TransportException)
0:             return new ErrorMessage((TransportException)e);
1:         // Unexpected exception
0:         logger.debug("Unexpected exception during request", e);
0:         return new ErrorMessage(new ServerError(e));
/////////////////////////////////////////////////////////////////////////
1:         return "ERROR " + error.code() + ": " + error.getMessage();
commit:6d3a3ee
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.transport.messages;
1: 
0: import java.util.concurrent.TimeoutException;
1: 
0: import org.jboss.netty.buffer.ChannelBuffer;
0: import org.jboss.netty.buffer.ChannelBuffers;
1: 
0: import org.apache.cassandra.transport.CBUtil;
0: import org.apache.cassandra.transport.Message;
0: import org.apache.cassandra.transport.ProtocolException;
0: import org.apache.cassandra.thrift.AuthenticationException;
0: import org.apache.cassandra.thrift.InvalidRequestException;
0: import org.apache.cassandra.thrift.SchemaDisagreementException;
0: import org.apache.cassandra.thrift.TimedOutException;
0: import org.apache.cassandra.thrift.UnavailableException;
1: 
1: /**
1:  * Message to indicate an error to the client.
1:  *
0:  * Error codes are:
0:  *   0x0000: Server error
0:  *   0x0001: Protocol error
0:  *   0x0002: Authentication error
0:  *   0x0100: Unavailable exception
0:  *   0x0101: Timeout exception
0:  *   0x0102: Schema disagreement exception
0:  *   0x0200: Request exception
1:  */
1: public class ErrorMessage extends Message.Response
1: {
1:     public static final Message.Codec<ErrorMessage> codec = new Message.Codec<ErrorMessage>()
1:     {
0:         public ErrorMessage decode(ChannelBuffer body)
1:         {
0:             int code = body.readInt();
1:             String msg = CBUtil.readString(body);
0:             return new ErrorMessage(code, msg);
1:         }
1: 
0:         public ChannelBuffer encode(ErrorMessage msg)
1:         {
0:             ChannelBuffer ccb = CBUtil.intToCB(msg.code);
0:             ChannelBuffer mcb = CBUtil.stringToCB(msg.errorMsg);
0:             return ChannelBuffers.wrappedBuffer(ccb, mcb);
1:         }
1:     };
1: 
1:     // We need to figure error codes out (#3979)
0:     public final int code;
0:     public final String errorMsg;
1: 
0:     public ErrorMessage(int code, String errorMsg)
1:     {
1:         super(Message.Type.ERROR);
0:         this.code = code;
0:         this.errorMsg = errorMsg;
1:     }
1: 
0:     public static ErrorMessage fromException(Throwable t)
1:     {
0:         String msg = t.getMessage() == null ? t.toString() : t.getMessage();
1: 
0:         if (t instanceof TimeoutException || t instanceof TimedOutException)
0:             return new ErrorMessage(0x0101, msg);
0:         else if (t instanceof UnavailableException)
0:             return new ErrorMessage(0x0100, msg);
0:         else if (t instanceof SchemaDisagreementException)
0:             return new ErrorMessage(0x0102, msg);
0:         else if (t instanceof InvalidRequestException)
0:             return new ErrorMessage(0x0200, msg);
0:         else if (t instanceof ProtocolException)
0:             return new ErrorMessage(0x0001, msg);
0:         else if (t instanceof AuthenticationException)
0:             return new ErrorMessage(0x0002, msg);
1: 
0:         logger.error("Unknown exception during request", t);
0:         return new ErrorMessage(0x0000, msg);
1:     }
1: 
0:     public ChannelBuffer encode()
1:     {
0:         return codec.encode(this);
1:     }
1: 
1:     @Override
1:     public String toString()
1:     {
0:         return "ERROR " + code + ": " + errorMsg;
1:     }
1: }
author:Marcus Eriksson
-------------------------------------------------------------------------------
commit:bf2ee04
/////////////////////////////////////////////////////////////////////////
0:         public ErrorMessage decode(ChannelBuffer body, int version)
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:bddfa9e
/////////////////////////////////////////////////////////////////////////
1:                 case BAD_CREDENTIALS:
1:                     te = new AuthenticationException(msg);
0:                     break;
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:b38ca28
/////////////////////////////////////////////////////////////////////////
0:                         te = new WriteTimeoutException(cl, received, blockFor, false);
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:71f5d91
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
============================================================================