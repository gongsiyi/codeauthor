1:a991b64: /*
1:a991b64:  * * Licensed to the Apache Software Foundation (ASF) under one
1:a991b64:  * * or more contributor license agreements.  See the NOTICE file
1:a991b64:  * * distributed with this work for additional information
1:a991b64:  * * regarding copyright ownership.  The ASF licenses this file
1:a991b64:  * * to you under the Apache License, Version 2.0 (the
1:a991b64:  * * "License"); you may not use this file except in compliance
1:a991b64:  * * with the License.  You may obtain a copy of the License at
1:a991b64:  * *
1:a991b64:  * *    http://www.apache.org/licenses/LICENSE-2.0
1:a991b64:  * *
1:a991b64:  * * Unless required by applicable law or agreed to in writing,
1:a991b64:  * * software distributed under the License is distributed on an
1:a991b64:  * * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:a991b64:  * * KIND, either express or implied.  See the License for the
1:a991b64:  * * specific language governing permissions and limitations
1:a991b64:  * * under the License.
1:a991b64:  * */
1:a991b64: package org.apache.cassandra.db.filter;
1:a991b64: 
1:a991b64: 
1:a991b64: import java.nio.ByteBuffer;
1:a991b64: import java.util.*;
1:a991b64: import java.util.List;
1:a991b64: 
1:a991b64: import org.apache.cassandra.db.*;
1:a991b64: import org.junit.Test;
1:a991b64: 
1:a991b64: import org.apache.cassandra.db.marshal.AbstractType;
1:a991b64: import org.apache.cassandra.db.marshal.Int32Type;
1:a991b64: import org.apache.cassandra.utils.ByteBufferUtil;
1:a991b64: 
1:a991b64: import static org.junit.Assert.*;
1:a991b64: 
1:a991b64: public class SliceTest
1:a991b64: {
1:a991b64:     @Test
1:a991b64:     public void testIntersectsSingleSlice()
1:a991b64:     {
1:a991b64:         List<AbstractType<?>> types = new ArrayList<>();
1:a991b64:         types.add(Int32Type.instance);
1:a991b64:         types.add(Int32Type.instance);
1:a991b64:         types.add(Int32Type.instance);
1:a991b64:         ClusteringComparator cc = new ClusteringComparator(types);
1:a991b64: 
1:a991b64:         ClusteringPrefix.Kind sk = ClusteringPrefix.Kind.INCL_START_BOUND;
1:a991b64:         ClusteringPrefix.Kind ek = ClusteringPrefix.Kind.INCL_END_BOUND;
1:a991b64: 
1:a991b64:         // filter falls entirely before sstable
1:a991b64:         Slice slice = Slice.make(makeBound(sk, 0, 0, 0), makeBound(ek, 1, 0, 0));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(2, 0, 0), columnNames(3, 0, 0)));
1:a991b64: 
1:a991b64:         // same case, but with empty start
1:a991b64:         slice = Slice.make(makeBound(sk), makeBound(ek, 1, 0, 0));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(2, 0, 0), columnNames(3, 0, 0)));
1:a991b64: 
1:a991b64:         // same case, but with missing components for start
1:a991b64:         slice = Slice.make(makeBound(sk, 0), makeBound(ek, 1, 0, 0));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(2, 0, 0), columnNames(3, 0, 0)));
1:a991b64: 
1:a991b64:         // same case, but with missing components for start and end
1:a991b64:         slice = Slice.make(makeBound(sk, 0), makeBound(ek, 1, 0));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(2, 0, 0), columnNames(3, 0, 0)));
1:a991b64: 
1:a991b64: 
1:a991b64:         // end of slice matches start of sstable for the first component, but not the second component
1:a991b64:         slice = Slice.make(makeBound(sk, 0, 0, 0), makeBound(ek, 1, 0, 0));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(1, 1, 0), columnNames(3, 0, 0)));
1:a991b64: 
1:a991b64:         // same case, but with missing components for start
1:a991b64:         slice = Slice.make(makeBound(sk, 0), makeBound(ek, 1, 0, 0));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(1, 1, 0), columnNames(3, 0, 0)));
1:a991b64: 
1:a991b64:         // same case, but with missing components for start and end
1:a991b64:         slice = Slice.make(makeBound(sk, 0), makeBound(ek, 1, 0));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(1, 1, 0), columnNames(3, 0, 0)));
1:a991b64: 
1:a991b64:         // first two components match, but not the last
1:a991b64:         slice = Slice.make(makeBound(sk, 0, 0, 0), makeBound(ek, 1, 1, 0));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(1, 1, 1), columnNames(3, 1, 1)));
1:a991b64: 
1:a991b64:         // all three components in slice end match the start of the sstable
1:a991b64:         slice = Slice.make(makeBound(sk, 0, 0, 0), makeBound(ek, 1, 1, 1));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 1, 1), columnNames(3, 1, 1)));
1:a991b64: 
1:a991b64: 
1:a991b64:         // filter falls entirely after sstable
1:a991b64:         slice = Slice.make(makeBound(sk, 4, 0, 0), makeBound(ek, 4, 0, 0));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(2, 0, 0), columnNames(3, 0, 0)));
1:a991b64: 
1:a991b64:         // same case, but with empty end
1:a991b64:         slice = Slice.make(makeBound(sk, 4, 0, 0), makeBound(ek));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(2, 0, 0), columnNames(3, 0, 0)));
1:a991b64: 
1:a991b64:         // same case, but with missing components for end
1:a991b64:         slice = Slice.make(makeBound(sk, 4, 0, 0), makeBound(ek, 1));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(2, 0, 0), columnNames(3, 0, 0)));
1:a991b64: 
1:a991b64:         // same case, but with missing components for start and end
1:a991b64:         slice = Slice.make(makeBound(sk, 4, 0), makeBound(ek, 1));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(2, 0, 0), columnNames(3, 0, 0)));
1:a991b64: 
1:a991b64: 
1:a991b64:         // start of slice matches end of sstable for the first component, but not the second component
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 1, 1), makeBound(ek, 2, 0, 0));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(0, 0, 0), columnNames(1, 0, 0)));
1:a991b64: 
1:a991b64:         // start of slice matches end of sstable for the first two components, but not the last component
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 1, 1), makeBound(ek, 2, 0, 0));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(0, 0, 0), columnNames(1, 1, 0)));
1:a991b64: 
1:a991b64:         // all three components in the slice start match the end of the sstable
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 1, 1), makeBound(ek, 2, 0, 0));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(0, 0, 0), columnNames(1, 1, 1)));
1:a991b64: 
1:a991b64: 
1:a991b64:         // slice covers entire sstable (with no matching edges)
1:a991b64:         slice = Slice.make(makeBound(sk, 0, 0, 0), makeBound(ek, 2, 0, 0));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(1, 1, 1)));
1:a991b64: 
1:a991b64:         // same case, but with empty ends
1:a991b64:         slice = Slice.make(makeBound(sk), makeBound(ek));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(1, 1, 1)));
1:a991b64: 
1:a991b64:         // same case, but with missing components
1:a991b64:         slice = Slice.make(makeBound(sk, 0), makeBound(ek, 2, 0));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(1, 1, 1)));
1:a991b64: 
1:a991b64:         // slice covers entire sstable (with matching start)
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 0, 0), makeBound(ek, 2, 0, 0));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(1, 1, 1)));
1:a991b64: 
1:a991b64:         // slice covers entire sstable (with matching end)
1:a991b64:         slice = Slice.make(makeBound(sk, 0, 0, 0), makeBound(ek, 1, 1, 1));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(1, 1, 1)));
1:a991b64: 
1:a991b64:         // slice covers entire sstable (with matching start and end)
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 0, 0), makeBound(ek, 1, 1, 1));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(1, 1, 1)));
1:a991b64: 
1:a991b64: 
1:a991b64:         // slice falls entirely within sstable (with matching start)
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 0, 0), makeBound(ek, 1, 1, 0));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(1, 1, 1)));
1:a991b64: 
1:a991b64:         // same case, but with a missing end component
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 0, 0), makeBound(ek, 1, 1));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(1, 1, 1)));
1:a991b64: 
1:a991b64:         // slice falls entirely within sstable (with matching end)
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 1, 0), makeBound(ek, 1, 1, 1));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(1, 1, 1)));
1:a991b64: 
1:a991b64:         // same case, but with a missing start component
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 1), makeBound(ek, 1, 1, 1));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(1, 1, 1)));
1:a991b64: 
1:a991b64: 
1:a991b64:         // slice falls entirely within sstable
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 1, 0), makeBound(ek, 1, 1, 1));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 2, 2)));
1:a991b64: 
1:a991b64:         // same case, but with a missing start component
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 1), makeBound(ek, 1, 1, 1));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 2, 2)));
1:a991b64: 
1:a991b64:         // same case, but with a missing start and end components
1:a991b64:         slice = Slice.make(makeBound(sk, 1), makeBound(ek, 1, 2));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 2, 2)));
1:a991b64: 
1:a991b64:         // same case, but with an equal first component and missing start and end components
1:a991b64:         slice = Slice.make(makeBound(sk, 1), makeBound(ek, 1));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 2, 2)));
1:a991b64: 
1:a991b64:         // slice falls entirely within sstable (slice start and end are the same)
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 1, 1), makeBound(ek, 1, 1, 1));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 2, 2)));
1:a991b64: 
1:a991b64: 
1:a991b64:         // slice starts within sstable, empty end
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 1, 1), makeBound(ek));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 0, 0)));
1:a991b64: 
1:a991b64:         // same case, but with missing end components
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 1, 1), makeBound(ek, 3));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 0, 0)));
1:a991b64: 
1:a991b64:         // slice starts within sstable (matching sstable start), empty end
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 0, 0), makeBound(ek));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 0, 0)));
1:a991b64: 
1:a991b64:         // same case, but with missing end components
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 0, 0), makeBound(ek, 3));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 0, 0)));
1:a991b64: 
1:a991b64:         // slice starts within sstable (matching sstable end), empty end
1:a991b64:         slice = Slice.make(makeBound(sk, 2, 0, 0), makeBound(ek));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 0, 0)));
1:a991b64: 
1:a991b64:         // same case, but with missing end components
1:a991b64:         slice = Slice.make(makeBound(sk, 2, 0, 0), makeBound(ek, 3));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 0, 0)));
1:a991b64: 
1:a991b64: 
1:a991b64:         // slice ends within sstable, empty end
1:a991b64:         slice = Slice.make(makeBound(sk), makeBound(ek, 1, 1, 1));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 0, 0)));
1:a991b64: 
1:a991b64:         // same case, but with missing start components
1:a991b64:         slice = Slice.make(makeBound(sk, 0), makeBound(ek, 1, 1, 1));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 0, 0)));
1:a991b64: 
1:a991b64:         // slice ends within sstable (matching sstable start), empty start
1:a991b64:         slice = Slice.make(makeBound(sk), makeBound(ek, 1, 0, 0));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 0, 0)));
1:a991b64: 
1:a991b64:         // same case, but with missing start components
1:a991b64:         slice = Slice.make(makeBound(sk, 0), makeBound(ek, 1, 0, 0));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 0, 0)));
1:a991b64: 
1:a991b64:         // slice ends within sstable (matching sstable end), empty start
1:a991b64:         slice = Slice.make(makeBound(sk), makeBound(ek, 2, 0, 0));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 0, 0)));
1:a991b64: 
1:a991b64:         // same case, but with missing start components
1:a991b64:         slice = Slice.make(makeBound(sk, 0), makeBound(ek, 2, 0, 0));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 0, 0)));
1:a991b64: 
1:a991b64:         // the slice technically falls within the sstable range, but since the first component is restricted to
1:a991b64:         // a single value, we can check that the second component does not fall within its min/max
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 2, 0), makeBound(ek, 1, 3, 0));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 1, 0)));
1:a991b64: 
1:a991b64:         // same case, but with a missing start component
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 2), makeBound(ek, 1, 3, 0));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 1, 0)));
1:a991b64: 
1:a991b64:         // same case, but with a missing end component
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 2, 0), makeBound(ek, 1, 3));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 1, 0)));
1:a991b64: 
1:a991b64:         // same case, but with a missing start and end components
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 2), makeBound(ek, 1, 3));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 1, 0)));
1:a991b64: 
1:a991b64:         // same case, but with missing start and end components and different lengths for start and end
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 2), makeBound(ek, 1));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 1, 0)));
1:a991b64: 
1:a991b64: 
1:a991b64:         // same as the previous set of tests, but the second component is equal in the slice start and end
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 2, 0), makeBound(ek, 1, 2, 0));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 1, 0)));
1:a991b64: 
1:a991b64:         // same case, but with a missing start component
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 2), makeBound(ek, 1, 2, 0));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 1, 0)));
1:a991b64: 
1:a991b64:         // same case, but with a missing end component
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 2, 0), makeBound(ek, 1, 2));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 1, 0)));
1:a991b64: 
1:a991b64:         // same case, but with a missing start and end components
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 2), makeBound(ek, 1, 2));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 1, 0)));
1:a991b64: 
1:a991b64:         // same as the previous tests, but it's the third component that doesn't fit in its range this time
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 1, 2), makeBound(ek, 1, 1, 3));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(1, 1, 0), columnNames(2, 2, 1)));
1:a991b64: 
1:a991b64:         // empty min/max column names
1:a991b64:         slice = Slice.make(makeBound(sk), makeBound(ek));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(), columnNames()));
1:a991b64: 
1:a991b64:         slice = Slice.make(makeBound(sk, 1), makeBound(ek));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(), columnNames()));
1:a991b64: 
1:a991b64:         slice = Slice.make(makeBound(sk), makeBound(ek, 1));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(), columnNames()));
1:a991b64: 
1:a991b64:         slice = Slice.make(makeBound(sk, 1), makeBound(ek, 1));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(), columnNames()));
1:a991b64: 
1:a991b64:         slice = Slice.make(makeBound(sk), makeBound(ek));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(), columnNames(1)));
1:a991b64: 
1:a991b64:         slice = Slice.make(makeBound(sk), makeBound(ek, 1));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(), columnNames(1)));
1:a991b64: 
1:a991b64:         slice = Slice.make(makeBound(sk), makeBound(ek, 1));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(), columnNames(2)));
1:a991b64: 
1:a991b64:         slice = Slice.make(makeBound(sk), makeBound(ek, 2));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(), columnNames(1)));
1:a991b64: 
1:a991b64:         slice = Slice.make(makeBound(sk, 2), makeBound(ek, 3));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(), columnNames(1)));
1:a991b64: 
1:a991b64:         // basic check on reversed slices
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 0, 0), makeBound(ek, 0, 0, 0));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(2, 0, 0), columnNames(3, 0, 0)));
1:a991b64: 
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 0, 0), makeBound(ek, 0, 0, 0));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(1, 1, 0), columnNames(3, 0, 0)));
1:a991b64: 
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 1, 1), makeBound(ek, 1, 1, 0));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 2, 2)));
1:a991b64:     }
1:a991b64: 
1:a991b64:     @Test
1:a991b64:     public void testDifferentMinMaxLengths()
1:a991b64:     {
1:a991b64:         List<AbstractType<?>> types = new ArrayList<>();
1:a991b64:         types.add(Int32Type.instance);
1:a991b64:         types.add(Int32Type.instance);
1:a991b64:         types.add(Int32Type.instance);
1:a991b64:         ClusteringComparator cc = new ClusteringComparator(types);
1:a991b64: 
1:a991b64:         ClusteringPrefix.Kind sk = ClusteringPrefix.Kind.INCL_START_BOUND;
1:a991b64:         ClusteringPrefix.Kind ek = ClusteringPrefix.Kind.INCL_END_BOUND;
1:a991b64: 
1:a991b64:         // slice does intersect
1:a991b64:         Slice slice = Slice.make(makeBound(sk), makeBound(ek));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(), columnNames(1)));
1:a991b64: 
1:a991b64:         slice = Slice.make(makeBound(sk), makeBound(ek));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(1), columnNames(1, 2)));
1:a991b64: 
1:a991b64:         slice = Slice.make(makeBound(sk), makeBound(ek, 1));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(), columnNames(1)));
1:a991b64: 
1:a991b64:         slice = Slice.make(makeBound(sk, 1), makeBound(ek));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(), columnNames(1)));
1:a991b64: 
1:a991b64:         slice = Slice.make(makeBound(sk, 1), makeBound(ek, 1));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(), columnNames(1)));
1:a991b64: 
1:a991b64:         slice = Slice.make(makeBound(sk, 0), makeBound(ek, 1, 2, 3));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(), columnNames(1)));
1:a991b64: 
1:a991b64:         slice = Slice.make(makeBound(sk, 1, 2, 3), makeBound(ek, 2));
1:a991b64:         assertTrue(slice.intersects(cc, columnNames(), columnNames(1)));
1:a991b64: 
1:a991b64:         // slice does not intersect
1:a991b64:         slice = Slice.make(makeBound(sk, 2), makeBound(ek, 3, 4, 5));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(), columnNames(1)));
1:a991b64: 
1:a991b64:         slice = Slice.make(makeBound(sk, 0), makeBound(ek, 0, 1, 2));
1:a991b64:         assertFalse(slice.intersects(cc, columnNames(1), columnNames(1, 2)));
1:a991b64:     }
1:a991b64: 
1:a991b64:     @Test
1:a991b64:     public void testSliceNormalization()
1:a991b64:     {
1:a991b64:         List<AbstractType<?>> types = new ArrayList<>();
1:a991b64:         types.add(Int32Type.instance);
1:a991b64:         types.add(Int32Type.instance);
1:a991b64:         types.add(Int32Type.instance);
1:a991b64:         ClusteringComparator cc = new ClusteringComparator(types);
1:a991b64: 
1:a991b64:         assertSlicesNormalization(cc, slices(s(0, 2), s(2, 4)), slices(s(0, 4)));
1:a991b64:         assertSlicesNormalization(cc, slices(s(0, 2), s(1, 4)), slices(s(0, 4)));
1:a991b64:         assertSlicesNormalization(cc, slices(s(0, 2), s(3, 4), s(3, 4)), slices(s(0, 2), s(3, 4)));
1:a991b64:         assertSlicesNormalization(cc, slices(s(-1, 3), s(-1, 4)), slices(s(-1, 4)));
1:a991b64:         assertSlicesNormalization(cc, slices(s(-1, 2), s(-1, 3), s(5, 9)), slices(s(-1, 3), s(5, 9)));
1:a991b64:     }
1:a991b64: 
1:2cc26eb:     private static ClusteringBound makeBound(ClusteringPrefix.Kind kind, Integer... components)
1:a991b64:     {
1:a991b64:         ByteBuffer[] values = new ByteBuffer[components.length];
1:a991b64:         for (int i = 0; i < components.length; i++)
1:a991b64:         {
1:a991b64:             values[i] = ByteBufferUtil.bytes(components[i]);
1:a991b64:         }
1:2cc26eb:         return ClusteringBound.create(kind, values);
1:a991b64:     }
1:a991b64: 
1:a991b64:     private static List<ByteBuffer> columnNames(Integer ... components)
1:a991b64:     {
1:a991b64:         List<ByteBuffer> names = new ArrayList<>(components.length);
1:a991b64:         for (int component : components)
1:a991b64:             names.add(ByteBufferUtil.bytes(component));
1:a991b64:         return names;
1:a991b64:     }
1:a991b64: 
1:a991b64:     private static Slice s(int start, int finish)
1:a991b64:     {
1:a991b64:         return Slice.make(makeBound(ClusteringPrefix.Kind.INCL_START_BOUND, start),
1:a991b64:                           makeBound(ClusteringPrefix.Kind.INCL_END_BOUND, finish));
1:a991b64:     }
1:a991b64: 
1:a991b64:     private Slice[] slices(Slice... slices)
1:a991b64:     {
1:a991b64:         return slices;
1:a991b64:     }
1:a991b64: 
1:a991b64:     private static void assertSlicesNormalization(ClusteringComparator cc, Slice[] original, Slice[] expected)
1:a991b64:     {
1:a991b64:         Slices.Builder builder = new Slices.Builder(cc);
1:a991b64:         for (Slice s : original)
1:a991b64:             builder.add(s);
1:a991b64:         Slices slices = builder.build();
1:a991b64:         assertEquals(expected.length, slices.size());
1:a991b64:         for (int i = 0; i < expected.length; i++)
1:a991b64:             assertEquals(expected[i], slices.get(i));
1:a991b64:     }
1:a991b64: }
============================================================================
author:Dave Brosius
-------------------------------------------------------------------------------
commit:087264f
/////////////////////////////////////////////////////////////////////////
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:2cc26eb
/////////////////////////////////////////////////////////////////////////
1:     private static ClusteringBound makeBound(ClusteringPrefix.Kind kind, Integer... components)
1:         return ClusteringBound.create(kind, values);
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * * Licensed to the Apache Software Foundation (ASF) under one
1:  * * or more contributor license agreements.  See the NOTICE file
1:  * * distributed with this work for additional information
1:  * * regarding copyright ownership.  The ASF licenses this file
1:  * * to you under the Apache License, Version 2.0 (the
1:  * * "License"); you may not use this file except in compliance
1:  * * with the License.  You may obtain a copy of the License at
1:  * *
1:  * *    http://www.apache.org/licenses/LICENSE-2.0
1:  * *
1:  * * Unless required by applicable law or agreed to in writing,
1:  * * software distributed under the License is distributed on an
1:  * * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * * KIND, either express or implied.  See the License for the
1:  * * specific language governing permissions and limitations
1:  * * under the License.
1:  * */
1: package org.apache.cassandra.db.filter;
1: 
1: 
0: import java.awt.*;
1: import java.nio.ByteBuffer;
1: import java.util.*;
1: import java.util.List;
1: 
0: import org.apache.cassandra.config.ColumnDefinition;
1: import org.apache.cassandra.db.*;
1: import org.junit.Test;
1: 
1: import org.apache.cassandra.db.marshal.AbstractType;
1: import org.apache.cassandra.db.marshal.Int32Type;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: 
1: import static org.junit.Assert.*;
1: 
1: public class SliceTest
1: {
1:     @Test
1:     public void testIntersectsSingleSlice()
1:     {
1:         List<AbstractType<?>> types = new ArrayList<>();
1:         types.add(Int32Type.instance);
1:         types.add(Int32Type.instance);
1:         types.add(Int32Type.instance);
1:         ClusteringComparator cc = new ClusteringComparator(types);
1: 
1:         ClusteringPrefix.Kind sk = ClusteringPrefix.Kind.INCL_START_BOUND;
1:         ClusteringPrefix.Kind ek = ClusteringPrefix.Kind.INCL_END_BOUND;
1: 
1:         // filter falls entirely before sstable
1:         Slice slice = Slice.make(makeBound(sk, 0, 0, 0), makeBound(ek, 1, 0, 0));
1:         assertFalse(slice.intersects(cc, columnNames(2, 0, 0), columnNames(3, 0, 0)));
1: 
1:         // same case, but with empty start
1:         slice = Slice.make(makeBound(sk), makeBound(ek, 1, 0, 0));
1:         assertFalse(slice.intersects(cc, columnNames(2, 0, 0), columnNames(3, 0, 0)));
1: 
1:         // same case, but with missing components for start
1:         slice = Slice.make(makeBound(sk, 0), makeBound(ek, 1, 0, 0));
1:         assertFalse(slice.intersects(cc, columnNames(2, 0, 0), columnNames(3, 0, 0)));
1: 
1:         // same case, but with missing components for start and end
1:         slice = Slice.make(makeBound(sk, 0), makeBound(ek, 1, 0));
1:         assertFalse(slice.intersects(cc, columnNames(2, 0, 0), columnNames(3, 0, 0)));
1: 
1: 
1:         // end of slice matches start of sstable for the first component, but not the second component
1:         slice = Slice.make(makeBound(sk, 0, 0, 0), makeBound(ek, 1, 0, 0));
1:         assertFalse(slice.intersects(cc, columnNames(1, 1, 0), columnNames(3, 0, 0)));
1: 
1:         // same case, but with missing components for start
1:         slice = Slice.make(makeBound(sk, 0), makeBound(ek, 1, 0, 0));
1:         assertFalse(slice.intersects(cc, columnNames(1, 1, 0), columnNames(3, 0, 0)));
1: 
1:         // same case, but with missing components for start and end
1:         slice = Slice.make(makeBound(sk, 0), makeBound(ek, 1, 0));
1:         assertFalse(slice.intersects(cc, columnNames(1, 1, 0), columnNames(3, 0, 0)));
1: 
1:         // first two components match, but not the last
1:         slice = Slice.make(makeBound(sk, 0, 0, 0), makeBound(ek, 1, 1, 0));
1:         assertFalse(slice.intersects(cc, columnNames(1, 1, 1), columnNames(3, 1, 1)));
1: 
1:         // all three components in slice end match the start of the sstable
1:         slice = Slice.make(makeBound(sk, 0, 0, 0), makeBound(ek, 1, 1, 1));
1:         assertTrue(slice.intersects(cc, columnNames(1, 1, 1), columnNames(3, 1, 1)));
1: 
1: 
1:         // filter falls entirely after sstable
1:         slice = Slice.make(makeBound(sk, 4, 0, 0), makeBound(ek, 4, 0, 0));
1:         assertFalse(slice.intersects(cc, columnNames(2, 0, 0), columnNames(3, 0, 0)));
1: 
1:         // same case, but with empty end
1:         slice = Slice.make(makeBound(sk, 4, 0, 0), makeBound(ek));
1:         assertFalse(slice.intersects(cc, columnNames(2, 0, 0), columnNames(3, 0, 0)));
1: 
1:         // same case, but with missing components for end
1:         slice = Slice.make(makeBound(sk, 4, 0, 0), makeBound(ek, 1));
1:         assertFalse(slice.intersects(cc, columnNames(2, 0, 0), columnNames(3, 0, 0)));
1: 
1:         // same case, but with missing components for start and end
1:         slice = Slice.make(makeBound(sk, 4, 0), makeBound(ek, 1));
1:         assertFalse(slice.intersects(cc, columnNames(2, 0, 0), columnNames(3, 0, 0)));
1: 
1: 
1:         // start of slice matches end of sstable for the first component, but not the second component
1:         slice = Slice.make(makeBound(sk, 1, 1, 1), makeBound(ek, 2, 0, 0));
1:         assertFalse(slice.intersects(cc, columnNames(0, 0, 0), columnNames(1, 0, 0)));
1: 
1:         // start of slice matches end of sstable for the first two components, but not the last component
1:         slice = Slice.make(makeBound(sk, 1, 1, 1), makeBound(ek, 2, 0, 0));
1:         assertFalse(slice.intersects(cc, columnNames(0, 0, 0), columnNames(1, 1, 0)));
1: 
1:         // all three components in the slice start match the end of the sstable
1:         slice = Slice.make(makeBound(sk, 1, 1, 1), makeBound(ek, 2, 0, 0));
1:         assertTrue(slice.intersects(cc, columnNames(0, 0, 0), columnNames(1, 1, 1)));
1: 
1: 
1:         // slice covers entire sstable (with no matching edges)
1:         slice = Slice.make(makeBound(sk, 0, 0, 0), makeBound(ek, 2, 0, 0));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(1, 1, 1)));
1: 
1:         // same case, but with empty ends
1:         slice = Slice.make(makeBound(sk), makeBound(ek));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(1, 1, 1)));
1: 
1:         // same case, but with missing components
1:         slice = Slice.make(makeBound(sk, 0), makeBound(ek, 2, 0));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(1, 1, 1)));
1: 
1:         // slice covers entire sstable (with matching start)
1:         slice = Slice.make(makeBound(sk, 1, 0, 0), makeBound(ek, 2, 0, 0));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(1, 1, 1)));
1: 
1:         // slice covers entire sstable (with matching end)
1:         slice = Slice.make(makeBound(sk, 0, 0, 0), makeBound(ek, 1, 1, 1));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(1, 1, 1)));
1: 
1:         // slice covers entire sstable (with matching start and end)
1:         slice = Slice.make(makeBound(sk, 1, 0, 0), makeBound(ek, 1, 1, 1));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(1, 1, 1)));
1: 
1: 
1:         // slice falls entirely within sstable (with matching start)
1:         slice = Slice.make(makeBound(sk, 1, 0, 0), makeBound(ek, 1, 1, 0));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(1, 1, 1)));
1: 
1:         // same case, but with a missing end component
1:         slice = Slice.make(makeBound(sk, 1, 0, 0), makeBound(ek, 1, 1));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(1, 1, 1)));
1: 
1:         // slice falls entirely within sstable (with matching end)
1:         slice = Slice.make(makeBound(sk, 1, 1, 0), makeBound(ek, 1, 1, 1));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(1, 1, 1)));
1: 
1:         // same case, but with a missing start component
1:         slice = Slice.make(makeBound(sk, 1, 1), makeBound(ek, 1, 1, 1));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(1, 1, 1)));
1: 
1: 
1:         // slice falls entirely within sstable
1:         slice = Slice.make(makeBound(sk, 1, 1, 0), makeBound(ek, 1, 1, 1));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 2, 2)));
1: 
1:         // same case, but with a missing start component
1:         slice = Slice.make(makeBound(sk, 1, 1), makeBound(ek, 1, 1, 1));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 2, 2)));
1: 
1:         // same case, but with a missing start and end components
1:         slice = Slice.make(makeBound(sk, 1), makeBound(ek, 1, 2));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 2, 2)));
1: 
1:         // same case, but with an equal first component and missing start and end components
1:         slice = Slice.make(makeBound(sk, 1), makeBound(ek, 1));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 2, 2)));
1: 
1:         // slice falls entirely within sstable (slice start and end are the same)
1:         slice = Slice.make(makeBound(sk, 1, 1, 1), makeBound(ek, 1, 1, 1));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 2, 2)));
1: 
1: 
1:         // slice starts within sstable, empty end
1:         slice = Slice.make(makeBound(sk, 1, 1, 1), makeBound(ek));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 0, 0)));
1: 
1:         // same case, but with missing end components
1:         slice = Slice.make(makeBound(sk, 1, 1, 1), makeBound(ek, 3));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 0, 0)));
1: 
1:         // slice starts within sstable (matching sstable start), empty end
1:         slice = Slice.make(makeBound(sk, 1, 0, 0), makeBound(ek));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 0, 0)));
1: 
1:         // same case, but with missing end components
1:         slice = Slice.make(makeBound(sk, 1, 0, 0), makeBound(ek, 3));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 0, 0)));
1: 
1:         // slice starts within sstable (matching sstable end), empty end
1:         slice = Slice.make(makeBound(sk, 2, 0, 0), makeBound(ek));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 0, 0)));
1: 
1:         // same case, but with missing end components
1:         slice = Slice.make(makeBound(sk, 2, 0, 0), makeBound(ek, 3));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 0, 0)));
1: 
1: 
1:         // slice ends within sstable, empty end
1:         slice = Slice.make(makeBound(sk), makeBound(ek, 1, 1, 1));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 0, 0)));
1: 
1:         // same case, but with missing start components
1:         slice = Slice.make(makeBound(sk, 0), makeBound(ek, 1, 1, 1));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 0, 0)));
1: 
1:         // slice ends within sstable (matching sstable start), empty start
1:         slice = Slice.make(makeBound(sk), makeBound(ek, 1, 0, 0));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 0, 0)));
1: 
1:         // same case, but with missing start components
1:         slice = Slice.make(makeBound(sk, 0), makeBound(ek, 1, 0, 0));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 0, 0)));
1: 
1:         // slice ends within sstable (matching sstable end), empty start
1:         slice = Slice.make(makeBound(sk), makeBound(ek, 2, 0, 0));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 0, 0)));
1: 
1:         // same case, but with missing start components
1:         slice = Slice.make(makeBound(sk, 0), makeBound(ek, 2, 0, 0));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 0, 0)));
1: 
1:         // the slice technically falls within the sstable range, but since the first component is restricted to
1:         // a single value, we can check that the second component does not fall within its min/max
1:         slice = Slice.make(makeBound(sk, 1, 2, 0), makeBound(ek, 1, 3, 0));
1:         assertFalse(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 1, 0)));
1: 
1:         // same case, but with a missing start component
1:         slice = Slice.make(makeBound(sk, 1, 2), makeBound(ek, 1, 3, 0));
1:         assertFalse(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 1, 0)));
1: 
1:         // same case, but with a missing end component
1:         slice = Slice.make(makeBound(sk, 1, 2, 0), makeBound(ek, 1, 3));
1:         assertFalse(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 1, 0)));
1: 
1:         // same case, but with a missing start and end components
1:         slice = Slice.make(makeBound(sk, 1, 2), makeBound(ek, 1, 3));
1:         assertFalse(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 1, 0)));
1: 
1:         // same case, but with missing start and end components and different lengths for start and end
1:         slice = Slice.make(makeBound(sk, 1, 2), makeBound(ek, 1));
1:         assertFalse(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 1, 0)));
1: 
1: 
1:         // same as the previous set of tests, but the second component is equal in the slice start and end
1:         slice = Slice.make(makeBound(sk, 1, 2, 0), makeBound(ek, 1, 2, 0));
1:         assertFalse(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 1, 0)));
1: 
1:         // same case, but with a missing start component
1:         slice = Slice.make(makeBound(sk, 1, 2), makeBound(ek, 1, 2, 0));
1:         assertFalse(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 1, 0)));
1: 
1:         // same case, but with a missing end component
1:         slice = Slice.make(makeBound(sk, 1, 2, 0), makeBound(ek, 1, 2));
1:         assertFalse(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 1, 0)));
1: 
1:         // same case, but with a missing start and end components
1:         slice = Slice.make(makeBound(sk, 1, 2), makeBound(ek, 1, 2));
1:         assertFalse(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 1, 0)));
1: 
1:         // same as the previous tests, but it's the third component that doesn't fit in its range this time
1:         slice = Slice.make(makeBound(sk, 1, 1, 2), makeBound(ek, 1, 1, 3));
1:         assertFalse(slice.intersects(cc, columnNames(1, 1, 0), columnNames(2, 2, 1)));
1: 
1:         // empty min/max column names
1:         slice = Slice.make(makeBound(sk), makeBound(ek));
1:         assertTrue(slice.intersects(cc, columnNames(), columnNames()));
1: 
1:         slice = Slice.make(makeBound(sk, 1), makeBound(ek));
1:         assertTrue(slice.intersects(cc, columnNames(), columnNames()));
1: 
1:         slice = Slice.make(makeBound(sk), makeBound(ek, 1));
1:         assertTrue(slice.intersects(cc, columnNames(), columnNames()));
1: 
1:         slice = Slice.make(makeBound(sk, 1), makeBound(ek, 1));
1:         assertTrue(slice.intersects(cc, columnNames(), columnNames()));
1: 
1:         slice = Slice.make(makeBound(sk), makeBound(ek));
1:         assertTrue(slice.intersects(cc, columnNames(), columnNames(1)));
1: 
1:         slice = Slice.make(makeBound(sk), makeBound(ek, 1));
1:         assertTrue(slice.intersects(cc, columnNames(), columnNames(1)));
1: 
1:         slice = Slice.make(makeBound(sk), makeBound(ek, 1));
1:         assertTrue(slice.intersects(cc, columnNames(), columnNames(2)));
1: 
1:         slice = Slice.make(makeBound(sk), makeBound(ek, 2));
1:         assertTrue(slice.intersects(cc, columnNames(), columnNames(1)));
1: 
1:         slice = Slice.make(makeBound(sk, 2), makeBound(ek, 3));
1:         assertFalse(slice.intersects(cc, columnNames(), columnNames(1)));
1: 
1:         // basic check on reversed slices
1:         slice = Slice.make(makeBound(sk, 1, 0, 0), makeBound(ek, 0, 0, 0));
1:         assertFalse(slice.intersects(cc, columnNames(2, 0, 0), columnNames(3, 0, 0)));
1: 
1:         slice = Slice.make(makeBound(sk, 1, 0, 0), makeBound(ek, 0, 0, 0));
1:         assertFalse(slice.intersects(cc, columnNames(1, 1, 0), columnNames(3, 0, 0)));
1: 
1:         slice = Slice.make(makeBound(sk, 1, 1, 1), makeBound(ek, 1, 1, 0));
1:         assertTrue(slice.intersects(cc, columnNames(1, 0, 0), columnNames(2, 2, 2)));
1:     }
1: 
1:     @Test
1:     public void testDifferentMinMaxLengths()
1:     {
1:         List<AbstractType<?>> types = new ArrayList<>();
1:         types.add(Int32Type.instance);
1:         types.add(Int32Type.instance);
1:         types.add(Int32Type.instance);
1:         ClusteringComparator cc = new ClusteringComparator(types);
1: 
1:         ClusteringPrefix.Kind sk = ClusteringPrefix.Kind.INCL_START_BOUND;
1:         ClusteringPrefix.Kind ek = ClusteringPrefix.Kind.INCL_END_BOUND;
1: 
1:         // slice does intersect
1:         Slice slice = Slice.make(makeBound(sk), makeBound(ek));
1:         assertTrue(slice.intersects(cc, columnNames(), columnNames(1)));
1: 
1:         slice = Slice.make(makeBound(sk), makeBound(ek));
1:         assertTrue(slice.intersects(cc, columnNames(1), columnNames(1, 2)));
1: 
1:         slice = Slice.make(makeBound(sk), makeBound(ek, 1));
1:         assertTrue(slice.intersects(cc, columnNames(), columnNames(1)));
1: 
1:         slice = Slice.make(makeBound(sk, 1), makeBound(ek));
1:         assertTrue(slice.intersects(cc, columnNames(), columnNames(1)));
1: 
1:         slice = Slice.make(makeBound(sk, 1), makeBound(ek, 1));
1:         assertTrue(slice.intersects(cc, columnNames(), columnNames(1)));
1: 
1:         slice = Slice.make(makeBound(sk, 0), makeBound(ek, 1, 2, 3));
1:         assertTrue(slice.intersects(cc, columnNames(), columnNames(1)));
1: 
1:         slice = Slice.make(makeBound(sk, 1, 2, 3), makeBound(ek, 2));
1:         assertTrue(slice.intersects(cc, columnNames(), columnNames(1)));
1: 
1:         // slice does not intersect
1:         slice = Slice.make(makeBound(sk, 2), makeBound(ek, 3, 4, 5));
1:         assertFalse(slice.intersects(cc, columnNames(), columnNames(1)));
1: 
1:         slice = Slice.make(makeBound(sk, 0), makeBound(ek, 0, 1, 2));
1:         assertFalse(slice.intersects(cc, columnNames(1), columnNames(1, 2)));
1:     }
1: 
1:     @Test
1:     public void testSliceNormalization()
1:     {
1:         List<AbstractType<?>> types = new ArrayList<>();
1:         types.add(Int32Type.instance);
1:         types.add(Int32Type.instance);
1:         types.add(Int32Type.instance);
1:         ClusteringComparator cc = new ClusteringComparator(types);
1: 
1:         assertSlicesNormalization(cc, slices(s(0, 2), s(2, 4)), slices(s(0, 4)));
1:         assertSlicesNormalization(cc, slices(s(0, 2), s(1, 4)), slices(s(0, 4)));
1:         assertSlicesNormalization(cc, slices(s(0, 2), s(3, 4), s(3, 4)), slices(s(0, 2), s(3, 4)));
1:         assertSlicesNormalization(cc, slices(s(-1, 3), s(-1, 4)), slices(s(-1, 4)));
1:         assertSlicesNormalization(cc, slices(s(-1, 2), s(-1, 3), s(5, 9)), slices(s(-1, 3), s(5, 9)));
1:     }
1: 
0:     private static Slice.Bound makeBound(ClusteringPrefix.Kind kind, Integer... components)
1:     {
1:         ByteBuffer[] values = new ByteBuffer[components.length];
1:         for (int i = 0; i < components.length; i++)
1:         {
1:             values[i] = ByteBufferUtil.bytes(components[i]);
1:         }
0:         return Slice.Bound.create(kind, values);
1:     }
1: 
1:     private static List<ByteBuffer> columnNames(Integer ... components)
1:     {
1:         List<ByteBuffer> names = new ArrayList<>(components.length);
1:         for (int component : components)
1:             names.add(ByteBufferUtil.bytes(component));
1:         return names;
1:     }
1: 
1:     private static Slice s(int start, int finish)
1:     {
1:         return Slice.make(makeBound(ClusteringPrefix.Kind.INCL_START_BOUND, start),
1:                           makeBound(ClusteringPrefix.Kind.INCL_END_BOUND, finish));
1:     }
1: 
1:     private Slice[] slices(Slice... slices)
1:     {
1:         return slices;
1:     }
1: 
1:     private static void assertSlicesNormalization(ClusteringComparator cc, Slice[] original, Slice[] expected)
1:     {
1:         Slices.Builder builder = new Slices.Builder(cc);
1:         for (Slice s : original)
1:             builder.add(s);
1:         Slices slices = builder.build();
1:         assertEquals(expected.length, slices.size());
1:         for (int i = 0; i < expected.length; i++)
1:             assertEquals(expected[i], slices.get(i));
1:     }
1: }
============================================================================