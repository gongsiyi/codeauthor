1:a991b64: /*
1:a991b64:  * Licensed to the Apache Software Foundation (ASF) under one
1:a991b64:  * or more contributor license agreements.  See the NOTICE file
1:a991b64:  * distributed with this work for additional information
1:a991b64:  * regarding copyright ownership.  The ASF licenses this file
1:a991b64:  * to you under the Apache License, Version 2.0 (the
1:a991b64:  * "License"); you may not use this file except in compliance
1:a991b64:  * with the License.  You may obtain a copy of the License at
1:a991b64:  *
1:a991b64:  *     http://www.apache.org/licenses/LICENSE-2.0
1:a991b64:  *
1:a991b64:  * Unless required by applicable law or agreed to in writing, software
1:a991b64:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a991b64:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a991b64:  * See the License for the specific language governing permissions and
1:a991b64:  * limitations under the License.
1:a991b64:  */
1:a991b64: package org.apache.cassandra.db.rows;
9:a991b64: 
1:a991b64: import java.io.IOException;
1:a991b64: import java.io.IOError;
1:a991b64: 
1:a991b64: import org.slf4j.Logger;
1:a991b64: import org.slf4j.LoggerFactory;
1:a991b64: 
1:a991b64: import org.apache.cassandra.config.CFMetaData;
1:a991b64: import org.apache.cassandra.db.*;
1:fe388d4: import org.apache.cassandra.db.filter.ColumnFilter;
1:6249a3b: import org.apache.cassandra.io.util.DataInputPlus;
1:a991b64: import org.apache.cassandra.io.util.DataOutputPlus;
1:a991b64: import org.apache.cassandra.utils.ByteBufferUtil;
1:a991b64: 
1:a991b64: /**
1:a991b64:  * Serialize/Deserialize an unfiltered row iterator.
1:a991b64:  *
1:a991b64:  * The serialization is composed of a header, follows by the rows and range tombstones of the iterator serialized
1:a991b64:  * until we read the end of the partition (see UnfilteredSerializer for details). The header itself
1:a991b64:  * is:
1:6b7db8a:  * {@code
1:2457599:  *     <cfid><key><flags><s_header>[<partition_deletion>][<static_row>][<row_estimate>]
1:a991b64:  * where:
1:a991b64:  *     <cfid> is the table cfid.
1:a991b64:  *     <key> is the partition key.
1:a991b64:  *     <flags> contains bit flags. Each flag is set if it's corresponding bit is set. From rightmost
1:a991b64:  *         bit to leftmost one, the flags are:
1:a991b64:  *         - is empty: whether the iterator is empty. If so, nothing follows the <flags>
1:a991b64:  *         - is reversed: whether the iterator is in reversed clustering order
1:a991b64:  *         - has partition deletion: whether or not there is a <partition_deletion> following
1:a991b64:  *         - has static row: whether or not there is a <static_row> following
1:a991b64:  *         - has row estimate: whether or not there is a <row_estimate> following
1:2457599:  *     <s_header> is the {@code SerializationHeader}. It contains in particular the columns contains in the serialized
1:2457599:  *         iterator as well as other information necessary to decoding the serialized rows
1:2457599:  *         (see {@code SerializationHeader.Serializer for details}).
1:a991b64:  *     <partition_deletion> is the deletion time for the partition (delta-encoded)
1:a991b64:  *     <static_row> is the static row for this partition as serialized by UnfilteredSerializer.
1:2457599:  *     <row_estimate> is the (potentially estimated) number of rows serialized. This is only used for
1:2457599:  *         the purpose of sizing on the receiving end and should not be relied upon too strongly.
1:6b7db8a:  * }
1:a991b64:  *
1:2457599:  * Please note that the format described above is the on-wire format. On-disk, the format is basically the
1:2457599:  * same, but the header is written once per sstable, not once per-partition. Further, the actual row and
1:2457599:  * range tombstones are not written using this class, but rather by {@link ColumnIndex}.
1:a991b64:  */
1:a991b64: public class UnfilteredRowIteratorSerializer
6:a991b64: {
1:a991b64:     protected static final Logger logger = LoggerFactory.getLogger(UnfilteredRowIteratorSerializer.class);
1:a991b64: 
1:a991b64:     private static final int IS_EMPTY               = 0x01;
1:a991b64:     private static final int IS_REVERSED            = 0x02;
1:a991b64:     private static final int HAS_PARTITION_DELETION = 0x04;
1:a991b64:     private static final int HAS_STATIC_ROW         = 0x08;
1:a991b64:     private static final int HAS_ROW_ESTIMATE       = 0x10;
1:a991b64: 
1:a991b64:     public static final UnfilteredRowIteratorSerializer serializer = new UnfilteredRowIteratorSerializer();
1:a991b64: 
1:2457599:     // Should only be used for the on-wire format.
1:fe388d4:     public void serialize(UnfilteredRowIterator iterator, ColumnFilter selection, DataOutputPlus out, int version) throws IOException
1:a991b64:     {
1:fe388d4:         serialize(iterator, selection, out, version, -1);
6:a991b64:     }
1:dc9ed46: 
1:2457599:     // Should only be used for the on-wire format.
1:a991b64: 
1:fe388d4:     public void serialize(UnfilteredRowIterator iterator, ColumnFilter selection, DataOutputPlus out, int version, int rowEstimate) throws IOException
1:a991b64:     {
1:dc9ed46: 
1:6584331:         SerializationHeader header = new SerializationHeader(false,
1:6584331:                                                              iterator.metadata(),
1:a991b64:                                                              iterator.columns(),
1:a991b64:                                                              iterator.stats());
1:dc9ed46: 
1:fe388d4:         serialize(iterator, header, selection, out, version, rowEstimate);
1:a991b64:     }
1:a991b64: 
1:2457599:     // Should only be used for the on-wire format.
1:fe388d4:     public void serialize(UnfilteredRowIterator iterator, SerializationHeader header, ColumnFilter selection, DataOutputPlus out, int version, int rowEstimate) throws IOException
1:a991b64:     {
1:6584331:         assert !header.isForSSTable();
1:6584331: 
1:a59be26:         ByteBufferUtil.writeWithVIntLength(iterator.partitionKey().getKey(), out);
1:a991b64: 
1:a991b64:         int flags = 0;
1:a991b64:         if (iterator.isReverseOrder())
1:a991b64:             flags |= IS_REVERSED;
1:a991b64: 
1:a991b64:         if (iterator.isEmpty())
1:a991b64:         {
1:a991b64:             out.writeByte((byte)(flags | IS_EMPTY));
1:a991b64:             return;
1:a991b64:         }
1:a991b64: 
1:a991b64:         DeletionTime partitionDeletion = iterator.partitionLevelDeletion();
1:a991b64:         if (!partitionDeletion.isLive())
1:a991b64:             flags |= HAS_PARTITION_DELETION;
1:a991b64:         Row staticRow = iterator.staticRow();
1:a991b64:         boolean hasStatic = staticRow != Rows.EMPTY_STATIC_ROW;
1:a991b64:         if (hasStatic)
1:a991b64:             flags |= HAS_STATIC_ROW;
1:a991b64: 
1:a991b64:         if (rowEstimate >= 0)
1:a991b64:             flags |= HAS_ROW_ESTIMATE;
1:a991b64: 
1:a991b64:         out.writeByte((byte)flags);
1:a991b64: 
1:fe388d4:         SerializationHeader.serializer.serializeForMessaging(header, selection, out, hasStatic);
1:a991b64: 
1:a991b64:         if (!partitionDeletion.isLive())
1:c055ab9:             header.writeDeletionTime(partitionDeletion, out);
1:a991b64: 
1:a991b64:         if (hasStatic)
1:a991b64:             UnfilteredSerializer.serializer.serialize(staticRow, header, out, version);
1:a991b64: 
1:a991b64:         if (rowEstimate >= 0)
1:649a106:             out.writeUnsignedVInt(rowEstimate);
1:a991b64: 
1:a991b64:         while (iterator.hasNext())
1:a991b64:             UnfilteredSerializer.serializer.serialize(iterator.next(), header, out, version);
1:a991b64:         UnfilteredSerializer.serializer.writeEndOfPartition(out);
1:a991b64:     }
1:a991b64: 
1:a991b64:     // Please note that this consume the iterator, and as such should not be called unless we have a simple way to
1:2457599:     // recreate an iterator for both serialize and serializedSize, which is mostly only PartitionUpdate/ArrayBackedCachedPartition.
1:fe388d4:     public long serializedSize(UnfilteredRowIterator iterator, ColumnFilter selection, int version, int rowEstimate)
1:a991b64:     {
1:6584331:         SerializationHeader header = new SerializationHeader(false,
1:6584331:                                                              iterator.metadata(),
1:a991b64:                                                              iterator.columns(),
1:a991b64:                                                              iterator.stats());
1:a991b64: 
1:a991b64:         assert rowEstimate >= 0;
1:a991b64: 
1:a59be26:         long size = ByteBufferUtil.serializedSizeWithVIntLength(iterator.partitionKey().getKey())
1:a991b64:                   + 1; // flags
1:a991b64: 
1:a991b64:         if (iterator.isEmpty())
1:a991b64:             return size;
1:a991b64: 
1:a991b64:         DeletionTime partitionDeletion = iterator.partitionLevelDeletion();
1:a991b64:         Row staticRow = iterator.staticRow();
1:a991b64:         boolean hasStatic = staticRow != Rows.EMPTY_STATIC_ROW;
1:a991b64: 
1:fe388d4:         size += SerializationHeader.serializer.serializedSizeForMessaging(header, selection, hasStatic);
1:a991b64: 
1:a991b64:         if (!partitionDeletion.isLive())
1:c055ab9:             size += header.deletionTimeSerializedSize(partitionDeletion);
1:a991b64: 
1:a991b64:         if (hasStatic)
1:03f72ac:             size += UnfilteredSerializer.serializer.serializedSize(staticRow, header, version);
1:a991b64: 
1:a991b64:         if (rowEstimate >= 0)
1:649a106:             size += TypeSizes.sizeofUnsignedVInt(rowEstimate);
1:a991b64: 
1:a991b64:         while (iterator.hasNext())
1:03f72ac:             size += UnfilteredSerializer.serializer.serializedSize(iterator.next(), header, version);
1:03f72ac:         size += UnfilteredSerializer.serializer.serializedSizeEndOfPartition();
1:a991b64: 
1:a991b64:         return size;
1:a991b64:     }
1:a991b64: 
1:fe388d4:     public Header deserializeHeader(CFMetaData metadata, ColumnFilter selection, DataInputPlus in, int version, SerializationHelper.Flag flag) throws IOException
1:a991b64:     {
1:0a08525:         DecoratedKey key = metadata.decorateKey(ByteBufferUtil.readWithVIntLength(in));
1:a991b64:         int flags = in.readUnsignedByte();
1:a991b64:         boolean isReversed = (flags & IS_REVERSED) != 0;
1:a991b64:         if ((flags & IS_EMPTY) != 0)
1:a991b64:         {
1:6584331:             SerializationHeader sh = new SerializationHeader(false, metadata, PartitionColumns.NONE, EncodingStats.NO_STATS);
1:8a97969:             return new Header(sh, key, isReversed, true, null, null, 0);
1:a991b64:         }
1:a991b64: 
1:a991b64:         boolean hasPartitionDeletion = (flags & HAS_PARTITION_DELETION) != 0;
1:a991b64:         boolean hasStatic = (flags & HAS_STATIC_ROW) != 0;
1:a991b64:         boolean hasRowEstimate = (flags & HAS_ROW_ESTIMATE) != 0;
1:a991b64: 
1:fe388d4:         SerializationHeader header = SerializationHeader.serializer.deserializeForMessaging(in, metadata, selection, hasStatic);
1:a991b64: 
1:c055ab9:         DeletionTime partitionDeletion = hasPartitionDeletion ? header.readDeletionTime(in) : DeletionTime.LIVE;
1:a991b64: 
1:a991b64:         Row staticRow = Rows.EMPTY_STATIC_ROW;
1:a991b64:         if (hasStatic)
1:2457599:             staticRow = UnfilteredSerializer.serializer.deserializeStaticRow(in, header, new SerializationHelper(metadata, version, flag));
1:a991b64: 
1:649a106:         int rowEstimate = hasRowEstimate ? (int)in.readUnsignedVInt() : -1;
1:8a97969:         return new Header(header, key, isReversed, false, partitionDeletion, staticRow, rowEstimate);
1:a991b64:     }
1:a991b64: 
1:8a97969:     public UnfilteredRowIterator deserialize(DataInputPlus in, int version, CFMetaData metadata, SerializationHelper.Flag flag, Header header) throws IOException
1:a991b64:     {
1:2457599:         if (header.isEmpty)
1:6094974:             return EmptyIterators.unfilteredRow(metadata, header.key, header.isReversed);
1:a991b64: 
1:8a97969:         final SerializationHelper helper = new SerializationHelper(metadata, version, flag);
1:2457599:         final SerializationHeader sHeader = header.sHeader;
1:8a97969:         return new AbstractUnfilteredRowIterator(metadata, header.key, header.partitionDeletion, sHeader.columns(), header.staticRow, header.isReversed, sHeader.stats())
1:a991b64:         {
1:aa57626:             private final Row.Builder builder = BTreeRow.sortedBuilder();
1:a991b64: 
1:a991b64:             protected Unfiltered computeNext()
1:a991b64:             {
1:a991b64:                 try
1:a991b64:                 {
1:2457599:                     Unfiltered unfiltered = UnfilteredSerializer.serializer.deserialize(in, sHeader, helper, builder);
1:2457599:                     return unfiltered == null ? endOfData() : unfiltered;
1:a991b64:                 }
1:a991b64:                 catch (IOException e)
1:a991b64:                 {
1:a991b64:                     throw new IOError(e);
1:a991b64:                 }
1:a991b64:             }
1:a991b64:         };
1:2457599:     }
1:2457599: 
1:fe388d4:     public UnfilteredRowIterator deserialize(DataInputPlus in, int version, CFMetaData metadata, ColumnFilter selection, SerializationHelper.Flag flag) throws IOException
1:2457599:     {
1:fe388d4:         return deserialize(in, version, metadata, flag, deserializeHeader(metadata, selection, in, version, flag));
1:a991b64:     }
1:a991b64: 
1:a991b64:     public static class Header
1:a991b64:     {
1:a991b64:         public final SerializationHeader sHeader;
1:a991b64:         public final DecoratedKey key;
1:a991b64:         public final boolean isReversed;
1:a991b64:         public final boolean isEmpty;
1:a991b64:         public final DeletionTime partitionDeletion;
1:a991b64:         public final Row staticRow;
1:a991b64:         public final int rowEstimate; // -1 if no estimate
1:a991b64: 
1:a991b64:         private Header(SerializationHeader sHeader,
1:a991b64:                        DecoratedKey key,
1:a991b64:                        boolean isReversed,
1:a991b64:                        boolean isEmpty,
1:a991b64:                        DeletionTime partitionDeletion,
1:a991b64:                        Row staticRow,
1:a991b64:                        int rowEstimate)
1:a991b64:         {
1:a991b64:             this.sHeader = sHeader;
1:a991b64:             this.key = key;
1:a991b64:             this.isReversed = isReversed;
1:a991b64:             this.isEmpty = isEmpty;
1:a991b64:             this.partitionDeletion = partitionDeletion;
1:a991b64:             this.staticRow = staticRow;
1:a991b64:             this.rowEstimate = rowEstimate;
1:a991b64:         }
1:a991b64: 
1:a991b64:         @Override
1:a991b64:         public String toString()
1:a991b64:         {
1:8a97969:             return String.format("{header=%s, key=%s, isReversed=%b, isEmpty=%b, del=%s, staticRow=%s, rowEstimate=%d}",
1:8a97969:                                  sHeader, key, isReversed, isEmpty, partitionDeletion, staticRow, rowEstimate);
1:a991b64:         }
1:a991b64:     }
1:a991b64: }
============================================================================
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:dc9ed46
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
author:Dave Brosius
-------------------------------------------------------------------------------
commit:6b7db8a
/////////////////////////////////////////////////////////////////////////
1:  * {@code
/////////////////////////////////////////////////////////////////////////
1:  * }
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:6094974
/////////////////////////////////////////////////////////////////////////
1:             return EmptyIterators.unfilteredRow(metadata, header.key, header.isReversed);
commit:649a106
/////////////////////////////////////////////////////////////////////////
1:             out.writeUnsignedVInt(rowEstimate);
/////////////////////////////////////////////////////////////////////////
1:             size += TypeSizes.sizeofUnsignedVInt(rowEstimate);
/////////////////////////////////////////////////////////////////////////
1:         int rowEstimate = hasRowEstimate ? (int)in.readUnsignedVInt() : -1;
commit:aa57626
/////////////////////////////////////////////////////////////////////////
1:             private final Row.Builder builder = BTreeRow.sortedBuilder();
commit:e51f83b
/////////////////////////////////////////////////////////////////////////
0:             private final Row.Builder builder = BTreeRow.sortedBuilder(sHeader.columns().regulars);
commit:fe388d4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.filter.ColumnFilter;
/////////////////////////////////////////////////////////////////////////
1:     public void serialize(UnfilteredRowIterator iterator, ColumnFilter selection, DataOutputPlus out, int version) throws IOException
1:         serialize(iterator, selection, out, version, -1);
1:     public void serialize(UnfilteredRowIterator iterator, ColumnFilter selection, DataOutputPlus out, int version, int rowEstimate) throws IOException
1:         serialize(iterator, header, selection, out, version, rowEstimate);
1:     public void serialize(UnfilteredRowIterator iterator, SerializationHeader header, ColumnFilter selection, DataOutputPlus out, int version, int rowEstimate) throws IOException
/////////////////////////////////////////////////////////////////////////
1:         SerializationHeader.serializer.serializeForMessaging(header, selection, out, hasStatic);
/////////////////////////////////////////////////////////////////////////
1:     public long serializedSize(UnfilteredRowIterator iterator, ColumnFilter selection, int version, int rowEstimate)
/////////////////////////////////////////////////////////////////////////
1:         size += SerializationHeader.serializer.serializedSizeForMessaging(header, selection, hasStatic);
/////////////////////////////////////////////////////////////////////////
1:     public Header deserializeHeader(CFMetaData metadata, ColumnFilter selection, DataInputPlus in, int version, SerializationHelper.Flag flag) throws IOException
/////////////////////////////////////////////////////////////////////////
1:         SerializationHeader header = SerializationHeader.serializer.deserializeForMessaging(in, metadata, selection, hasStatic);
/////////////////////////////////////////////////////////////////////////
1:     public UnfilteredRowIterator deserialize(DataInputPlus in, int version, CFMetaData metadata, ColumnFilter selection, SerializationHelper.Flag flag) throws IOException
1:         return deserialize(in, version, metadata, flag, deserializeHeader(metadata, selection, in, version, flag));
commit:639d4b2
/////////////////////////////////////////////////////////////////////////
0:             private final Row.Builder builder = BTreeBackedRow.sortedBuilder(sHeader.columns().regulars);
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:6584331
/////////////////////////////////////////////////////////////////////////
1:         SerializationHeader header = new SerializationHeader(false,
1:                                                              iterator.metadata(),
/////////////////////////////////////////////////////////////////////////
1:         assert !header.isForSSTable();
1: 
/////////////////////////////////////////////////////////////////////////
1:         SerializationHeader header = new SerializationHeader(false,
1:                                                              iterator.metadata(),
/////////////////////////////////////////////////////////////////////////
1:             SerializationHeader sh = new SerializationHeader(false, metadata, PartitionColumns.NONE, EncodingStats.NO_STATS);
commit:a59be26
/////////////////////////////////////////////////////////////////////////
1:         ByteBufferUtil.writeWithVIntLength(iterator.partitionKey().getKey(), out);
/////////////////////////////////////////////////////////////////////////
1:         long size = ByteBufferUtil.serializedSizeWithVIntLength(iterator.partitionKey().getKey())
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey key = StorageService.getPartitioner().decorateKey(ByteBufferUtil.readWithVIntLength(in));
commit:c055ab9
/////////////////////////////////////////////////////////////////////////
1:             header.writeDeletionTime(partitionDeletion, out);
/////////////////////////////////////////////////////////////////////////
1:             size += header.deletionTimeSerializedSize(partitionDeletion);
/////////////////////////////////////////////////////////////////////////
0:             SerializationHeader sh = new SerializationHeader(metadata, PartitionColumns.NONE, EncodingStats.NO_STATS);
/////////////////////////////////////////////////////////////////////////
1:         DeletionTime partitionDeletion = hasPartitionDeletion ? header.readDeletionTime(in) : DeletionTime.LIVE;
/////////////////////////////////////////////////////////////////////////
commit:8a97969
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         long size = TypeSizes.sizeofWithLength(iterator.partitionKey().getKey())
/////////////////////////////////////////////////////////////////////////
0:     public Header deserializeHeader(DataInputPlus in, int version, CFMetaData metadata, SerializationHelper.Flag flag) throws IOException
1:             return new Header(sh, key, isReversed, true, null, null, 0);
/////////////////////////////////////////////////////////////////////////
1:         return new Header(header, key, isReversed, false, partitionDeletion, staticRow, rowEstimate);
1:     public UnfilteredRowIterator deserialize(DataInputPlus in, int version, CFMetaData metadata, SerializationHelper.Flag flag, Header header) throws IOException
0:             return UnfilteredRowIterators.emptyIterator(metadata, header.key, header.isReversed);
1:         final SerializationHelper helper = new SerializationHelper(metadata, version, flag);
1:         return new AbstractUnfilteredRowIterator(metadata, header.key, header.partitionDeletion, sHeader.columns(), header.staticRow, header.isReversed, sHeader.stats())
/////////////////////////////////////////////////////////////////////////
0:     public UnfilteredRowIterator deserialize(DataInputPlus in, int version, CFMetaData metadata, SerializationHelper.Flag flag) throws IOException
0:         return deserialize(in, version, metadata, flag, deserializeHeader(in, version, metadata, flag));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             return String.format("{header=%s, key=%s, isReversed=%b, isEmpty=%b, del=%s, staticRow=%s, rowEstimate=%d}",
1:                                  sHeader, key, isReversed, isEmpty, partitionDeletion, staticRow, rowEstimate);
commit:2457599
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *     <cfid><key><flags><s_header>[<partition_deletion>][<static_row>][<row_estimate>]
/////////////////////////////////////////////////////////////////////////
1:  *     <s_header> is the {@code SerializationHeader}. It contains in particular the columns contains in the serialized
1:  *         iterator as well as other information necessary to decoding the serialized rows
1:  *         (see {@code SerializationHeader.Serializer for details}).
1:  *     <row_estimate> is the (potentially estimated) number of rows serialized. This is only used for
1:  *         the purpose of sizing on the receiving end and should not be relied upon too strongly.
1:  * Please note that the format described above is the on-wire format. On-disk, the format is basically the
1:  * same, but the header is written once per sstable, not once per-partition. Further, the actual row and
1:  * range tombstones are not written using this class, but rather by {@link ColumnIndex}.
/////////////////////////////////////////////////////////////////////////
1:     // Should only be used for the on-wire format.
1:     // Should only be used for the on-wire format.
/////////////////////////////////////////////////////////////////////////
1:     // Should only be used for the on-wire format.
/////////////////////////////////////////////////////////////////////////
0:             out.writeVInt(rowEstimate);
/////////////////////////////////////////////////////////////////////////
1:     // recreate an iterator for both serialize and serializedSize, which is mostly only PartitionUpdate/ArrayBackedCachedPartition.
/////////////////////////////////////////////////////////////////////////
0:             size += TypeSizes.sizeofVInt(rowEstimate);
/////////////////////////////////////////////////////////////////////////
1:             staticRow = UnfilteredSerializer.serializer.deserializeStaticRow(in, header, new SerializationHelper(metadata, version, flag));
0:         int rowEstimate = hasRowEstimate ? (int)in.readVInt() : -1;
0:     public UnfilteredRowIterator deserialize(DataInputPlus in, int version, SerializationHelper.Flag flag, Header header) throws IOException
1:         if (header.isEmpty)
0:             return UnfilteredRowIterators.emptyIterator(header.metadata, header.key, header.isReversed);
0:         final SerializationHelper helper = new SerializationHelper(header.metadata, version, flag);
1:         final SerializationHeader sHeader = header.sHeader;
0:         return new AbstractUnfilteredRowIterator(header.metadata, header.key, header.partitionDeletion, sHeader.columns(), header.staticRow, header.isReversed, sHeader.stats())
0:             private final Row.Builder builder = ArrayBackedRow.sortedBuilder(sHeader.columns().regulars);
1:                     Unfiltered unfiltered = UnfilteredSerializer.serializer.deserialize(in, sHeader, helper, builder);
1:                     return unfiltered == null ? endOfData() : unfiltered;
/////////////////////////////////////////////////////////////////////////
0:     public UnfilteredRowIterator deserialize(DataInputPlus in, int version, SerializationHelper.Flag flag) throws IOException
1:     {
0:         return deserialize(in, version, flag,  deserializeHeader(in, version, flag));
1:     }
1: 
0:         out.writeVInt(header.encodeTimestamp(dt.markedForDeleteAt()));
0:         out.writeVInt(header.encodeDeletionTime(dt.localDeletionTime()));
0:         return TypeSizes.sizeofVInt(header.encodeTimestamp(dt.markedForDeleteAt()))
0:              + TypeSizes.sizeofVInt(header.encodeDeletionTime(dt.localDeletionTime()));
0:     public static DeletionTime readDelTime(DataInputPlus in, SerializationHeader header) throws IOException
0:         long markedAt = header.decodeTimestamp(in.readVInt());
0:         int localDelTime = header.decodeDeletionTime((int)in.readVInt());
0:         return new DeletionTime(markedAt, localDelTime);
0:     public static void skipDelTime(DataInputPlus in, SerializationHeader header) throws IOException
0:         in.readVInt();
0:         in.readVInt();
commit:6249a3b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.DataInputPlus;
/////////////////////////////////////////////////////////////////////////
0:     public Header deserializeHeader(DataInputPlus in, int version, SerializationHelper.Flag flag) throws IOException
/////////////////////////////////////////////////////////////////////////
0:     public UnfilteredRowIterator deserialize(final DataInputPlus in, int version, SerializationHelper.Flag flag) throws IOException
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.db.rows;
1: 
0: import java.io.DataInput;
1: import java.io.IOException;
1: import java.io.IOError;
1: 
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: import org.apache.cassandra.config.CFMetaData;
1: import org.apache.cassandra.db.*;
1: import org.apache.cassandra.io.util.DataOutputPlus;
0: import org.apache.cassandra.service.StorageService;
1: import org.apache.cassandra.utils.ByteBufferUtil;
0: import org.apache.cassandra.utils.FBUtilities;
1: 
1: /**
1:  * Serialize/Deserialize an unfiltered row iterator.
1:  *
1:  * The serialization is composed of a header, follows by the rows and range tombstones of the iterator serialized
1:  * until we read the end of the partition (see UnfilteredSerializer for details). The header itself
1:  * is:
0:  *     <cfid><key><flags><s_header>[<partition_deletion>][<static_row>]
1:  * where:
1:  *     <cfid> is the table cfid.
1:  *     <key> is the partition key.
1:  *     <flags> contains bit flags. Each flag is set if it's corresponding bit is set. From rightmost
1:  *         bit to leftmost one, the flags are:
1:  *         - is empty: whether the iterator is empty. If so, nothing follows the <flags>
1:  *         - is reversed: whether the iterator is in reversed clustering order
1:  *         - has partition deletion: whether or not there is a <partition_deletion> following
1:  *         - has static row: whether or not there is a <static_row> following
1:  *         - has row estimate: whether or not there is a <row_estimate> following
0:  *     <s_header> is the SerializationHeader. More precisely it's
0:  *           <min_timetamp><min_localDelTime><min_ttl>[<static_columns>]<columns>
0:  *         where:
0:  *           - <min_timestamp> is the base timestamp used for delta-encoding timestamps
0:  *           - <min_localDelTime> is the base localDeletionTime used for delta-encoding local deletion times
0:  *           - <min_ttl> is the base localDeletionTime used for delta-encoding ttls
0:  *           - <static_columns> is the static columns if a static row is present. It's
0:  *             the number of columns as an unsigned short, followed by the column names.
0:  *           - <columns> is the columns of the rows of the iterator. It's serialized as <static_columns>.
1:  *     <partition_deletion> is the deletion time for the partition (delta-encoded)
1:  *     <static_row> is the static row for this partition as serialized by UnfilteredSerializer.
0:  *     <row_estimate> is the (potentially estimated) number of rows serialized. This is only use for
0:  *         the purpose of some sizing on the receiving end and should not be relied upon too strongly.
1:  *
0:  * !!! Please note that the serialized value depends on the schema and as such should not be used as is if
0:  *     it might be deserialized after the schema as changed !!!
0:  * TODO: we should add a flag to include the relevant metadata in the header for commit log etc.....
1:  */
1: public class UnfilteredRowIteratorSerializer
1: {
1:     protected static final Logger logger = LoggerFactory.getLogger(UnfilteredRowIteratorSerializer.class);
1: 
1:     private static final int IS_EMPTY               = 0x01;
1:     private static final int IS_REVERSED            = 0x02;
1:     private static final int HAS_PARTITION_DELETION = 0x04;
1:     private static final int HAS_STATIC_ROW         = 0x08;
1:     private static final int HAS_ROW_ESTIMATE       = 0x10;
1: 
1:     public static final UnfilteredRowIteratorSerializer serializer = new UnfilteredRowIteratorSerializer();
1: 
0:     public void serialize(UnfilteredRowIterator iterator, DataOutputPlus out, int version) throws IOException
1:     {
0:         serialize(iterator, out, version, -1);
1:     }
1: 
0:     public void serialize(UnfilteredRowIterator iterator, DataOutputPlus out, int version, int rowEstimate) throws IOException
1:     {
0:         SerializationHeader header = new SerializationHeader(iterator.metadata(),
1:                                                              iterator.columns(),
1:                                                              iterator.stats());
0:         serialize(iterator, out, header, version, rowEstimate);
1:     }
1: 
0:     public void serialize(UnfilteredRowIterator iterator, DataOutputPlus out, SerializationHeader header, int version, int rowEstimate) throws IOException
1:     {
0:         CFMetaData.serializer.serialize(iterator.metadata(), out, version);
0:         ByteBufferUtil.writeWithLength(iterator.partitionKey().getKey(), out);
1: 
1:         int flags = 0;
1:         if (iterator.isReverseOrder())
1:             flags |= IS_REVERSED;
1: 
1:         if (iterator.isEmpty())
1:         {
1:             out.writeByte((byte)(flags | IS_EMPTY));
1:             return;
1:         }
1: 
1:         DeletionTime partitionDeletion = iterator.partitionLevelDeletion();
1:         if (!partitionDeletion.isLive())
1:             flags |= HAS_PARTITION_DELETION;
1:         Row staticRow = iterator.staticRow();
1:         boolean hasStatic = staticRow != Rows.EMPTY_STATIC_ROW;
1:         if (hasStatic)
1:             flags |= HAS_STATIC_ROW;
1: 
1:         if (rowEstimate >= 0)
1:             flags |= HAS_ROW_ESTIMATE;
1: 
1:         out.writeByte((byte)flags);
1: 
0:         SerializationHeader.serializer.serializeForMessaging(header, out, hasStatic);
1: 
1:         if (!partitionDeletion.isLive())
0:             writeDelTime(partitionDeletion, header, out);
1: 
1:         if (hasStatic)
1:             UnfilteredSerializer.serializer.serialize(staticRow, header, out, version);
1: 
1:         if (rowEstimate >= 0)
0:             out.writeInt(rowEstimate);
1: 
1:         while (iterator.hasNext())
1:             UnfilteredSerializer.serializer.serialize(iterator.next(), header, out, version);
1:         UnfilteredSerializer.serializer.writeEndOfPartition(out);
1:     }
1: 
1:     // Please note that this consume the iterator, and as such should not be called unless we have a simple way to
0:     // recreate an iterator for both serialize and serializedSize, which is mostly only PartitionUpdate
0:     public long serializedSize(UnfilteredRowIterator iterator, int version, int rowEstimate, TypeSizes sizes)
1:     {
0:         SerializationHeader header = new SerializationHeader(iterator.metadata(),
1:                                                              iterator.columns(),
1:                                                              iterator.stats());
1: 
1:         assert rowEstimate >= 0;
1: 
0:         long size = CFMetaData.serializer.serializedSize(iterator.metadata(), version, sizes)
0:                   + sizes.sizeofWithLength(iterator.partitionKey().getKey())
1:                   + 1; // flags
1: 
1:         if (iterator.isEmpty())
1:             return size;
1: 
1:         DeletionTime partitionDeletion = iterator.partitionLevelDeletion();
1:         Row staticRow = iterator.staticRow();
1:         boolean hasStatic = staticRow != Rows.EMPTY_STATIC_ROW;
1: 
0:         size += SerializationHeader.serializer.serializedSizeForMessaging(header, sizes, hasStatic);
1: 
1:         if (!partitionDeletion.isLive())
0:             size += delTimeSerializedSize(partitionDeletion, header, sizes);
1: 
1:         if (hasStatic)
0:             size += UnfilteredSerializer.serializer.serializedSize(staticRow, header, version, sizes);
1: 
1:         if (rowEstimate >= 0)
0:             size += sizes.sizeof(rowEstimate);
1: 
1:         while (iterator.hasNext())
0:             size += UnfilteredSerializer.serializer.serializedSize(iterator.next(), header, version, sizes);
0:         size += UnfilteredSerializer.serializer.serializedSizeEndOfPartition(sizes);
1: 
1:         return size;
1:     }
1: 
0:     public Header deserializeHeader(DataInput in, int version, SerializationHelper.Flag flag) throws IOException
1:     {
0:         CFMetaData metadata = CFMetaData.serializer.deserialize(in, version);
0:         DecoratedKey key = StorageService.getPartitioner().decorateKey(ByteBufferUtil.readWithLength(in));
1:         int flags = in.readUnsignedByte();
1:         boolean isReversed = (flags & IS_REVERSED) != 0;
1:         if ((flags & IS_EMPTY) != 0)
1:         {
0:             SerializationHeader sh = new SerializationHeader(metadata, PartitionColumns.NONE, RowStats.NO_STATS);
0:             return new Header(sh, metadata, key, isReversed, true, null, null, 0);
1:         }
1: 
1:         boolean hasPartitionDeletion = (flags & HAS_PARTITION_DELETION) != 0;
1:         boolean hasStatic = (flags & HAS_STATIC_ROW) != 0;
1:         boolean hasRowEstimate = (flags & HAS_ROW_ESTIMATE) != 0;
1: 
0:         SerializationHeader header = SerializationHeader.serializer.deserializeForMessaging(in, metadata, hasStatic);
1: 
0:         DeletionTime partitionDeletion = hasPartitionDeletion ? readDelTime(in, header) : DeletionTime.LIVE;
1: 
1:         Row staticRow = Rows.EMPTY_STATIC_ROW;
1:         if (hasStatic)
0:             staticRow = UnfilteredSerializer.serializer.deserializeStaticRow(in, header, new SerializationHelper(version, flag));
1: 
0:         int rowEstimate = hasRowEstimate ? in.readInt() : -1;
0:         return new Header(header, metadata, key, isReversed, false, partitionDeletion, staticRow, rowEstimate);
1:     }
1: 
0:     public void deserialize(DataInput in, SerializationHelper helper, SerializationHeader header, Row.Writer rowWriter, RangeTombstoneMarker.Writer markerWriter) throws IOException
1:     {
0:         while (UnfilteredSerializer.serializer.deserialize(in, header, helper, rowWriter, markerWriter) != null);
1:     }
1: 
0:     public UnfilteredRowIterator deserialize(final DataInput in, int version, SerializationHelper.Flag flag) throws IOException
1:     {
0:         final Header h = deserializeHeader(in, version, flag);
1: 
0:         if (h.isEmpty)
0:             return UnfilteredRowIterators.emptyIterator(h.metadata, h.key, h.isReversed);
1: 
0:         final int clusteringSize = h.metadata.clusteringColumns().size();
0:         final SerializationHelper helper = new SerializationHelper(version, flag);
1: 
0:         return new AbstractUnfilteredRowIterator(h.metadata, h.key, h.partitionDeletion, h.sHeader.columns(), h.staticRow, h.isReversed, h.sHeader.stats())
1:         {
0:             private final ReusableRow row = new ReusableRow(clusteringSize, h.sHeader.columns().regulars, true, h.metadata.isCounter());
0:             private final RangeTombstoneMarker.Builder markerBuilder = new RangeTombstoneMarker.Builder(clusteringSize);
1: 
1:             protected Unfiltered computeNext()
1:             {
1:                 try
1:                 {
0:                     Unfiltered.Kind kind = UnfilteredSerializer.serializer.deserialize(in, h.sHeader, helper, row.writer(), markerBuilder.reset());
0:                     if (kind == null)
0:                         return endOfData();
1: 
0:                     return kind == Unfiltered.Kind.ROW ? row : markerBuilder.build();
1:                 }
1:                 catch (IOException e)
1:                 {
1:                     throw new IOError(e);
1:                 }
1:             }
1:         };
1:     }
1: 
0:     public static void writeDelTime(DeletionTime dt, SerializationHeader header, DataOutputPlus out) throws IOException
1:     {
0:         out.writeLong(header.encodeTimestamp(dt.markedForDeleteAt()));
0:         out.writeInt(header.encodeDeletionTime(dt.localDeletionTime()));
1:     }
1: 
0:     public static long delTimeSerializedSize(DeletionTime dt, SerializationHeader header, TypeSizes sizes)
1:     {
0:         return sizes.sizeof(header.encodeTimestamp(dt.markedForDeleteAt()))
0:              + sizes.sizeof(header.encodeDeletionTime(dt.localDeletionTime()));
1:     }
1: 
0:     public static DeletionTime readDelTime(DataInput in, SerializationHeader header) throws IOException
1:     {
0:         long markedAt = header.decodeTimestamp(in.readLong());
0:         int localDelTime = header.decodeDeletionTime(in.readInt());
0:         return new SimpleDeletionTime(markedAt, localDelTime);
1:     }
1: 
0:     public static void skipDelTime(DataInput in, SerializationHeader header) throws IOException
1:     {
0:         // Note that since we might use VINT, we shouldn't assume the size of a long or an int
0:         in.readLong();
0:         in.readInt();
1:     }
1: 
1:     public static class Header
1:     {
1:         public final SerializationHeader sHeader;
0:         public final CFMetaData metadata;
1:         public final DecoratedKey key;
1:         public final boolean isReversed;
1:         public final boolean isEmpty;
1:         public final DeletionTime partitionDeletion;
1:         public final Row staticRow;
1:         public final int rowEstimate; // -1 if no estimate
1: 
1:         private Header(SerializationHeader sHeader,
0:                        CFMetaData metadata,
1:                        DecoratedKey key,
1:                        boolean isReversed,
1:                        boolean isEmpty,
1:                        DeletionTime partitionDeletion,
1:                        Row staticRow,
1:                        int rowEstimate)
1:         {
1:             this.sHeader = sHeader;
0:             this.metadata = metadata;
1:             this.key = key;
1:             this.isReversed = isReversed;
1:             this.isEmpty = isEmpty;
1:             this.partitionDeletion = partitionDeletion;
1:             this.staticRow = staticRow;
1:             this.rowEstimate = rowEstimate;
1:         }
1: 
1:         @Override
1:         public String toString()
1:         {
0:             return String.format("{header=%s, table=%s.%s, key=%s, isReversed=%b, isEmpty=%b, del=%s, staticRow=%s, rowEstimate=%d}",
0:                                  sHeader, metadata.ksName, metadata.cfName, key, isReversed, isEmpty, partitionDeletion, staticRow.toString(metadata), rowEstimate);
1:         }
1:     }
1: }
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:0a08525
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         DecoratedKey key = metadata.decorateKey(ByteBufferUtil.readWithVIntLength(in));
commit:2fea59d
/////////////////////////////////////////////////////////////////////////
0:         ByteBufferUtil.writeWithVIntLength(iterator.partitionKey().getKey(), out);
/////////////////////////////////////////////////////////////////////////
0:         long size = ByteBufferUtil.serializedSizeWithVIntLength(iterator.partitionKey().getKey())
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey key = StorageService.getPartitioner().decorateKey(ByteBufferUtil.readWithVIntLength(in));
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:a22ce89
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.service.StorageService;
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey key = StorageService.getPartitioner().decorateKey(ByteBufferUtil.readWithVIntLength(in));
commit:59a2861
/////////////////////////////////////////////////////////////////////////
0:         ByteBufferUtil.writeWithLength(iterator.partitionKey().getKey(), out);
/////////////////////////////////////////////////////////////////////////
0:         long size = TypeSizes.sizeofWithLength(iterator.partitionKey().getKey())
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey key = StorageService.getPartitioner().decorateKey(ByteBufferUtil.readWithLength(in));
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:69f77cb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey key = metadata.decorateKey(ByteBufferUtil.readWithVIntLength(in));
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:03f72ac
/////////////////////////////////////////////////////////////////////////
0:     public long serializedSize(UnfilteredRowIterator iterator, int version, int rowEstimate)
/////////////////////////////////////////////////////////////////////////
0:         long size = CFMetaData.serializer.serializedSize(iterator.metadata(), version)
0:                   + TypeSizes.sizeofWithLength(iterator.partitionKey().getKey())
/////////////////////////////////////////////////////////////////////////
0:         size += SerializationHeader.serializer.serializedSizeForMessaging(header, hasStatic);
0:             size += delTimeSerializedSize(partitionDeletion, header);
1:             size += UnfilteredSerializer.serializer.serializedSize(staticRow, header, version);
0:             size += TypeSizes.sizeof(rowEstimate);
1:             size += UnfilteredSerializer.serializer.serializedSize(iterator.next(), header, version);
1:         size += UnfilteredSerializer.serializer.serializedSizeEndOfPartition();
/////////////////////////////////////////////////////////////////////////
0:     public static long delTimeSerializedSize(DeletionTime dt, SerializationHeader header)
0:         return TypeSizes.sizeof(header.encodeTimestamp(dt.markedForDeleteAt()))
0:              + TypeSizes.sizeof(header.encodeDeletionTime(dt.localDeletionTime()));
============================================================================