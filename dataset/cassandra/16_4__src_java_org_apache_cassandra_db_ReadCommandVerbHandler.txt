1:07cf56f: /*
1:066ef58:  * Licensed to the Apache Software Foundation (ASF) under one
1:066ef58:  * or more contributor license agreements.  See the NOTICE file
1:066ef58:  * distributed with this work for additional information
1:066ef58:  * regarding copyright ownership.  The ASF licenses this file
1:066ef58:  * to you under the Apache License, Version 2.0 (the
1:066ef58:  * "License"); you may not use this file except in compliance
1:066ef58:  * with the License.  You may obtain a copy of the License at
1:066ef58:  *
1:066ef58:  *     http://www.apache.org/licenses/LICENSE-2.0
1:066ef58:  *
1:066ef58:  * Unless required by applicable law or agreed to in writing, software
1:066ef58:  * distributed under the License is distributed on an "AS IS" BASIS,
1:066ef58:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:066ef58:  * See the License for the specific language governing permissions and
1:066ef58:  * limitations under the License.
2:066ef58:  */
1:066ef58: package org.apache.cassandra.db;
1:4826e8c: 
1:a991b64: import org.apache.cassandra.db.partitions.UnfilteredPartitionIterator;
1:8c64cef: import org.apache.cassandra.io.IVersionedSerializer;
1:066ef58: import org.apache.cassandra.net.IVerbHandler;
1:5d46a01: import org.apache.cassandra.net.MessageIn;
1:5a6f0b8: import org.apache.cassandra.net.MessageOut;
1:066ef58: import org.apache.cassandra.net.MessagingService;
1:066ef58: import org.apache.cassandra.service.StorageService;
1:10777f2: import org.apache.cassandra.tracing.Tracing;
1:37135cf: 
1:a991b64: public class ReadCommandVerbHandler implements IVerbHandler<ReadCommand>
1:dc7221f: {
1:8c64cef:     protected IVersionedSerializer<ReadResponse> serializer()
1:8c64cef:     {
1:8c64cef:         return ReadResponse.serializer;
1:8c64cef:     }
1:8c64cef: 
1:1936648:     public void doVerb(MessageIn<ReadCommand> message, int id)
1:dc7221f:     {
1:37135cf:         if (StorageService.instance.isBootstrapMode())
2:37135cf:         {
1:37135cf:             throw new RuntimeException("Cannot service reads while bootstrapping!");
1:dc7221f:         }
1:37135cf: 
1:a06be23:         ReadCommand command = message.payload;
1:9d9a1a1:         command.setMonitoringTime(message.constructionTime, message.isCrossNode(), message.getTimeout(), message.getSlowQueryTimeout());
1:557bbbc: 
1:a991b64:         ReadResponse response;
1:557bbbc:         try (ReadExecutionController executionController = command.executionController();
1:557bbbc:              UnfilteredPartitionIterator iterator = command.executeLocally(executionController))
1:a991b64:         {
1:3e37b4a:             response = command.createResponse(iterator);
1:a991b64:         }
1:a991b64: 
1:557bbbc:         if (!command.complete())
1:557bbbc:         {
1:557bbbc:             Tracing.trace("Discarding partial response to {} (timed out)", message.from);
1:9d9a1a1:             MessagingService.instance().incrementDroppedMessages(message, message.getLifetimeInMS());
1:557bbbc:             return;
1:557bbbc:         }
1:ef25537: 
1:d7ff10d:         Tracing.trace("Enqueuing response to {}", message.from);
1:8c64cef:         MessageOut<ReadResponse> reply = new MessageOut<>(MessagingService.Verb.REQUEST_RESPONSE, response, serializer());
1:a06be23:         MessagingService.instance().sendReply(reply, id, message.from);
1:dc7221f:     }
1:37135cf: }
============================================================================
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:9d9a1a1
/////////////////////////////////////////////////////////////////////////
1:         command.setMonitoringTime(message.constructionTime, message.isCrossNode(), message.getTimeout(), message.getSlowQueryTimeout());
/////////////////////////////////////////////////////////////////////////
1:             MessagingService.instance().incrementDroppedMessages(message, message.getLifetimeInMS());
commit:5956000
commit:3e37b4a
/////////////////////////////////////////////////////////////////////////
1:             response = command.createResponse(iterator);
commit:a991b64
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.CFMetaData;
1: import org.apache.cassandra.db.partitions.UnfilteredPartitionIterator;
/////////////////////////////////////////////////////////////////////////
1: public class ReadCommandVerbHandler implements IVerbHandler<ReadCommand>
/////////////////////////////////////////////////////////////////////////
1:         ReadResponse response;
0:         try (ReadOrderGroup opGroup = command.startOrderGroup(); UnfilteredPartitionIterator iterator = command.executeLocally(opGroup))
1:         {
0:             response = command.createResponse(iterator);
1:         }
0:         MessageOut<ReadResponse> reply = new MessageOut<>(MessagingService.Verb.REQUEST_RESPONSE, response, ReadResponse.serializer);
1: 
commit:d7ff10d
/////////////////////////////////////////////////////////////////////////
1:             Tracing.trace("Enqueuing response to {}", message.from);
commit:5a6e2b0
/////////////////////////////////////////////////////////////////////////
0:     private static final Logger logger = LoggerFactory.getLogger( ReadVerbHandler.class );
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
commit:910b663
/////////////////////////////////////////////////////////////////////////
0:     private static Logger logger = LoggerFactory.getLogger( ReadVerbHandler.class );
/////////////////////////////////////////////////////////////////////////
0:             if (logger.isDebugEnabled())
0:               logger.debug(String.format("Read key %s; sending response to %s@%s",
/////////////////////////////////////////////////////////////////////////
0:             if (logger.isDebugEnabled())
0:                 logger.debug("digest is " + ByteBufferUtil.bytesToHex(ColumnFamily.digest(row.cf)));
author:Shogo Hoshii
-------------------------------------------------------------------------------
commit:6966fcd
/////////////////////////////////////////////////////////////////////////
0:         command.setMonitoringTime(message.constructionTime, message.getTimeout(), message.getSlowQueryTimeout());
author:Sam Tunnicliffe
-------------------------------------------------------------------------------
commit:f70c353
author:anubhavkale
-------------------------------------------------------------------------------
commit:c9ef25f
/////////////////////////////////////////////////////////////////////////
0:             MessagingService.instance().incrementDroppedMessages(message, System.currentTimeMillis() - message.constructionTime.timestamp);
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:557bbbc
/////////////////////////////////////////////////////////////////////////
0:         command.setMonitoringTime(message.constructionTime, message.getTimeout());
1: 
1:         try (ReadExecutionController executionController = command.executionController();
1:              UnfilteredPartitionIterator iterator = command.executeLocally(executionController))
1:         if (!command.complete())
1:         {
1:             Tracing.trace("Discarding partial response to {} (timed out)", message.from);
0:             MessagingService.instance().incrementDroppedMessages(message);
1:             return;
1:         }
0:         MessageOut<ReadResponse> reply = new MessageOut<>(MessagingService.Verb.REQUEST_RESPONSE, response, ReadResponse.serializer);
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:fe388d4
/////////////////////////////////////////////////////////////////////////
0:             response = command.createResponse(iterator, command.columnFilter());
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:8c64cef
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.IVersionedSerializer;
/////////////////////////////////////////////////////////////////////////
1:     protected IVersionedSerializer<ReadResponse> serializer()
1:     {
1:         return ReadResponse.serializer;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         MessageOut<ReadResponse> reply = new MessageOut<>(MessagingService.Verb.REQUEST_RESPONSE, response, serializer());
author:Christian Spriegel
-------------------------------------------------------------------------------
commit:c6525da
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         Row row = command.getRow(keyspace);
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:dc7221f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.filter.TombstoneOverwhelmingException;
/////////////////////////////////////////////////////////////////////////
0:         Row row;
0:         try
1:         {
0:             row = command.getRow(keyspace);
1:         }
0:         catch (TombstoneOverwhelmingException e)
1:         {
0:             // error already logged.  Drop the request
0:             return;
1:         }
commit:5b0d43f
commit:0c81eae
/////////////////////////////////////////////////////////////////////////
commit:1936648
/////////////////////////////////////////////////////////////////////////
1:     public void doVerb(MessageIn<ReadCommand> message, int id)
commit:10777f2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.tracing.Tracing;
commit:6adf52c
/////////////////////////////////////////////////////////////////////////
0:             logger.debug("Enqueuing response to {}", message.from);
commit:36b40be
/////////////////////////////////////////////////////////////////////////
0:             logger.debug("Sending response to {}", message.from);
/////////////////////////////////////////////////////////////////////////
0:             if (logger.isTraceEnabled())
0:                 logger.trace("digest is " + ByteBufferUtil.bytesToHex(ColumnFamily.digest(row.cf)));
commit:a06be23
/////////////////////////////////////////////////////////////////////////
0: public class ReadVerbHandler implements IVerbHandler<ReadCommand>
0:     public void doVerb(MessageIn<ReadCommand> message, String id)
/////////////////////////////////////////////////////////////////////////
1:             ReadCommand command = message.payload;
/////////////////////////////////////////////////////////////////////////
0:                 logger.debug(String.format("Read key %s; sending response to %s@%s",
0:                                             ByteBufferUtil.bytesToHex(command.key), id, message.from));
1:             MessagingService.instance().sendReply(reply, id, message.from);
commit:021ec71
/////////////////////////////////////////////////////////////////////////
0:             MessageOut<ReadResponse> reply = new MessageOut<ReadResponse>(MessagingService.Verb.REQUEST_RESPONSE,
commit:5d46a01
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.net.MessageIn;
/////////////////////////////////////////////////////////////////////////
0:     public void doVerb(MessageIn message, String id)
commit:5a6f0b8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.net.MessageOut;
/////////////////////////////////////////////////////////////////////////
0:             MessageOut<ReadResponse> reply = new MessageOut<ReadResponse>(StorageService.Verb.REQUEST_RESPONSE,
0:                                                                           getResponse(command, row),
0:                                                                           ReadResponse.serializer());
commit:2bc0d4d
/////////////////////////////////////////////////////////////////////////
commit:787f9d6
/////////////////////////////////////////////////////////////////////////
0: import java.io.ByteArrayOutputStream;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             ReadResponse response = getResponse(command, row);
0:             byte[] bytes = FBUtilities.serialize(response, ReadResponse.serializer(), message.getVersion());
0:             Message reply = message.getReply(FBUtilities.getBroadcastAddress(), bytes, message.getVersion());
0:             MessagingService.instance().sendReply(reply, id, message.getFrom());
commit:39b4b93
/////////////////////////////////////////////////////////////////////////
0:             out.reset();
commit:37135cf
/////////////////////////////////////////////////////////////////////////
1: 
0:     // re-use output buffers between requests
0:     private static ThreadLocal<DataOutputBuffer> threadLocalOut = new ThreadLocal<DataOutputBuffer>()
1:     {
0:         @Override
0:         protected DataOutputBuffer initialValue()
1:         {
0:             return new DataOutputBuffer();
1:         }
0:     };
1:         if (StorageService.instance.isBootstrapMode())
1:             throw new RuntimeException("Cannot service reads while bootstrapping!");
0:             ByteArrayInputStream in = new ByteArrayInputStream(message.getMessageBody());
0:             ReadCommand command = ReadCommand.serializer().deserialize(new DataInputStream(in), message.getVersion());
0:             DataOutputBuffer out = threadLocalOut.get();
0:             ReadResponse.serializer().serialize(getResponse(command, row), out, message.getVersion());
0:             byte[] bytes = new byte[out.getLength()];
0:             System.arraycopy(out.getData(), 0, bytes, 0, bytes.length);
1: 
commit:c5ee059
/////////////////////////////////////////////////////////////////////////
0:     public void doVerb(Message message, String id)
/////////////////////////////////////////////////////////////////////////
0:                                           ByteBufferUtil.bytesToHex(command.key), id, message.getFrom()));
0:             MessagingService.instance().sendReply(response, id, message.getFrom());
commit:4826e8c
/////////////////////////////////////////////////////////////////////////
0:             ReadResponse readResponse = getResponse(command, row);
/////////////////////////////////////////////////////////////////////////
1: 
0:     public static ReadResponse getResponse(ReadCommand command, Row row)
0:     {
0:         if (command.isDigestQuery())
0:         {
0:             if (logger_.isDebugEnabled())
0:                 logger_.debug("digest is " + ByteBufferUtil.bytesToHex(ColumnFamily.digest(row.cf)));
0:             return new ReadResponse(ColumnFamily.digest(row.cf));
0:         }
0:         else
0:         {
0:             return new ReadResponse(row);
0:         }
0:     }
commit:6350c16
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.ByteBufferUtil;
/////////////////////////////////////////////////////////////////////////
0:                     logger_.debug("digest is " + ByteBufferUtil.bytesToHex(ColumnFamily.digest(row.cf)));
/////////////////////////////////////////////////////////////////////////
0:                                           ByteBufferUtil.bytesToHex(command.key), message.getMessageId(), message.getFrom()));
commit:37ec7d3
/////////////////////////////////////////////////////////////////////////
0:             MessagingService.instance().sendOneWay(response, message.getFrom());
commit:ef25537
/////////////////////////////////////////////////////////////////////////
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
1: 
commit:9d291b0
/////////////////////////////////////////////////////////////////////////
commit:9ebc400
/////////////////////////////////////////////////////////////////////////
commit:b186a5c
/////////////////////////////////////////////////////////////////////////
0:               logger_.debug(String.format("Read key %s; sending response to %s@%s",
0:                                           FBUtilities.bytesToHex(command.key), message.getMessageId(), message.getFrom()));
commit:e7a385a
/////////////////////////////////////////////////////////////////////////
0: import java.nio.ByteBuffer;
0: 
commit:bc2529f
/////////////////////////////////////////////////////////////////////////
0:                 if (endpoints.size() > 1)
commit:d5ae4c4
/////////////////////////////////////////////////////////////////////////
0:     /* We use this so that we can reuse readcontext objects */
/////////////////////////////////////////////////////////////////////////
0:                 if (endpoints.size() > 0)
commit:2126f60
/////////////////////////////////////////////////////////////////////////
0:             MessagingService.instance.sendOneWay(response, message.getFrom());
commit:a2e2c03
/////////////////////////////////////////////////////////////////////////
0:             if (StorageService.instance.isBootstrapMode())
/////////////////////////////////////////////////////////////////////////
0:                 List<InetAddress> endpoints = StorageService.instance.getLiveNaturalEndpoints(command.key);
0:                     StorageService.instance.doConsistencyCheck(row, endpoints, command);
commit:dc6e4fe
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.util.DataOutputBuffer;
commit:1cb0794
/////////////////////////////////////////////////////////////////////////
0: import java.io.ByteArrayInputStream;
0: import java.io.DataInputStream;
/////////////////////////////////////////////////////////////////////////
0:         protected ByteArrayInputStream bufIn_;
/////////////////////////////////////////////////////////////////////////
0:         readCtx.bufIn_ = new ByteArrayInputStream(body);
/////////////////////////////////////////////////////////////////////////
0:             ReadCommand command = ReadCommand.serializer().deserialize(new DataInputStream(readCtx.bufIn_));
commit:c9bbba1
/////////////////////////////////////////////////////////////////////////
0:                     logger_.debug("digest is " + FBUtilities.bytesToHex(ColumnFamily.digest(row.cf)));
0:                 readResponse = new ReadResponse(ColumnFamily.digest(row.cf));
commit:7c41664
/////////////////////////////////////////////////////////////////////////
0:             ReadCommand command = ReadCommand.serializer().deserialize(readCtx.bufIn_);
0:             Table table = Table.open(command.table);
0:             Row row = command.getRow(table);
0:             if (command.isDigestQuery())
/////////////////////////////////////////////////////////////////////////
0:             readResponse.setIsDigestQuery(command.isDigestQuery());
/////////////////////////////////////////////////////////////////////////
0:               logger_.debug("Read key " + command.key + "; sending response to " + message.getMessageId() + "@" + message.getFrom());
0:                 List<InetAddress> endpoints = StorageService.instance().getLiveNaturalEndpoints(command.key);
0:                 /* Remove the local storage endpoint from the list. */
0:                 endpoints.remove(FBUtilities.getLocalAddress());
0:                 if (endpoints.size() > 0 && DatabaseDescriptor.getConsistencyCheck())
0:                     StorageService.instance().doConsistencyCheck(row, endpoints, command);
/////////////////////////////////////////////////////////////////////////
commit:924c7e5
/////////////////////////////////////////////////////////////////////////
0:         List<InetAddress> endpoints = StorageService.instance().getLiveNaturalEndpoints(readCommand.key);
commit:b767bf7
/////////////////////////////////////////////////////////////////////////
0: import java.net.InetAddress;
/////////////////////////////////////////////////////////////////////////
0:             Message response = message.getReply(FBUtilities.getLocalAddress(), bytes);
/////////////////////////////////////////////////////////////////////////
0:         List<InetAddress> endpoints = StorageService.instance().getLiveReadStorageEndPoints(readCommand.key);
0:         /* Remove the local storage endpoint from the list. */
0:         endpoints.remove(FBUtilities.getLocalAddress());
commit:5e9b35c
/////////////////////////////////////////////////////////////////////////
0:             MessagingService.instance().sendOneWay(response, message.getFrom());
commit:ce27422
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.FBUtilities;
/////////////////////////////////////////////////////////////////////////
0:                 if (logger_.isDebugEnabled())
0:                     logger_.debug("digest is " + FBUtilities.bytesToHex(row.digest()));
commit:f48c5b6
/////////////////////////////////////////////////////////////////////////
0:             Row row = readCommand.getRow(table);
0:             ReadResponse readResponse;
commit:eb83251
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:         List<EndPoint> endpoints = StorageService.instance().getLiveReadStorageEndPoints(readCommand.key);
commit:d7e4924
/////////////////////////////////////////////////////////////////////////
commit:0c5cd14
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.service.UnavailableException;
/////////////////////////////////////////////////////////////////////////
0:             if (StorageService.instance().isBootstrapMode())
0:             {
0:                 /* Don't service reads! */
0:                 throw new RuntimeException("Cannot service reads while bootstrapping!");
0:             }
commit:066ef58
/////////////////////////////////////////////////////////////////////////
0: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: 
1: package org.apache.cassandra.db;
0: 
0: import java.io.IOException;
0: import java.util.List;
0: 
0: import org.apache.cassandra.config.DatabaseDescriptor;
0: import org.apache.cassandra.io.DataInputBuffer;
0: import org.apache.cassandra.io.DataOutputBuffer;
0: import org.apache.cassandra.net.EndPoint;
1: import org.apache.cassandra.net.IVerbHandler;
0: import org.apache.cassandra.net.Message;
1: import org.apache.cassandra.net.MessagingService;
1: import org.apache.cassandra.service.StorageService;
0: import org.apache.cassandra.utils.LogUtil;
0: import org.apache.log4j.Logger;
0: 
0: /**
0:  * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com )
1:  */
0: 
0: public class ReadVerbHandler implements IVerbHandler
0: {
0:     protected static class ReadContext
0:     {
0:         protected DataInputBuffer bufIn_ = new DataInputBuffer();
0:         protected DataOutputBuffer bufOut_ = new DataOutputBuffer();
0:     }
0: 
0:     private static Logger logger_ = Logger.getLogger( ReadVerbHandler.class );
0:     /* We use this so that we can reuse the same row mutation context for the mutation. */
0:     private static ThreadLocal<ReadVerbHandler.ReadContext> tls_ = new InheritableThreadLocal<ReadVerbHandler.ReadContext>();
0:     
0:     protected static ReadVerbHandler.ReadContext getCurrentReadContext()
0:     {
0:         return tls_.get();
0:     }
0:     
0:     protected static void setCurrentReadContext(ReadVerbHandler.ReadContext readContext)
0:     {
0:         tls_.set(readContext);
0:     }
0: 
0:     public void doVerb(Message message)
0:     {
0:         byte[] body = message.getMessageBody();
0:         /* Obtain a Read Context from TLS */
0:         ReadContext readCtx = tls_.get();
0:         if ( readCtx == null )
0:         {
0:             readCtx = new ReadContext();
0:             tls_.set(readCtx);
0:         }
0:         readCtx.bufIn_.reset(body, body.length);
0: 
0:         try
0:         {
0:             ReadCommand readCommand = ReadCommand.serializer().deserialize(readCtx.bufIn_);
0:             Table table = Table.open(readCommand.table);
0:             Row row = null;
0:             row = readCommand.getRow(table);
0:             ReadResponse readResponse = null;
0:             if (readCommand.isDigestQuery())
0:             {
0:                 readResponse = new ReadResponse(row.digest());
0:             }
0:             else
0:             {
0:                 readResponse = new ReadResponse(row);
0:             }
0:             readResponse.setIsDigestQuery(readCommand.isDigestQuery());
0:             /* serialize the ReadResponseMessage. */
0:             readCtx.bufOut_.reset();
0: 
0:             ReadResponse.serializer().serialize(readResponse, readCtx.bufOut_);
0: 
0:             byte[] bytes = new byte[readCtx.bufOut_.getLength()];
0:             System.arraycopy(readCtx.bufOut_.getData(), 0, bytes, 0, bytes.length);
0: 
0:             Message response = message.getReply(StorageService.getLocalStorageEndPoint(), bytes);
0:             if (logger_.isDebugEnabled())
0:               logger_.debug("Read key " + readCommand.key + "; sending response to " + message.getMessageId() + "@" + message.getFrom());
0:             MessagingService.getMessagingInstance().sendOneWay(response, message.getFrom());
0: 
0:             /* Do read repair if header of the message says so */
0:             if (message.getHeader(ReadCommand.DO_REPAIR) != null)
0:             {
0:                 doReadRepair(row, readCommand);
0:             }
0:         }
0:         catch (IOException ex)
0:         {
0:             throw new RuntimeException(ex);
0:         }
0:     }
0:     
0:     private void doReadRepair(Row row, ReadCommand readCommand)
0:     {
0:         List<EndPoint> endpoints = StorageService.instance().getNLiveStorageEndPoint(readCommand.key);
0:         /* Remove the local storage endpoint from the list. */ 
0:         endpoints.remove( StorageService.getLocalStorageEndPoint() );
0:             
0:         if (endpoints.size() > 0 && DatabaseDescriptor.getConsistencyCheck())
0:             StorageService.instance().doConsistencyCheck(row, endpoints, readCommand);
0:     }     
0: }
commit:0077af4
/////////////////////////////////////////////////////////////////////////
0:             if (logger_.isDebugEnabled())
0:               logger_.debug("Read key " + readCommand.key + "; sending response to " + message.getMessageId() + "@" + message.getFrom());
commit:509cbb8
/////////////////////////////////////////////////////////////////////////
0:                 readResponse = new ReadResponse(row.digest());
0:                 readResponse = new ReadResponse(row);
commit:c129b6d
/////////////////////////////////////////////////////////////////////////
0:             logger_.debug("Read key " + readCommand.key + "; sending response to " + message.getMessageId() + "@" + message.getFrom());
commit:fb347bd
/////////////////////////////////////////////////////////////////////////
0:             if (readCommand.isDigestQuery())
commit:c3f0d10
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             Message response = message.getReply(StorageService.getLocalStorageEndPoint(), bytes);
0:             logger_.debug("Read key " + readCommand.key + "; sending response to " + message.getFrom());
0: 
0:         catch (IOException ex)
0:             throw new RuntimeException(ex);
commit:49211d5
/////////////////////////////////////////////////////////////////////////
0:         byte[] body = message.getMessageBody();
/////////////////////////////////////////////////////////////////////////
0:             Message response = message.getReply( StorageService.getLocalStorageEndPoint(), bytes );
commit:71739ef
commit:1453a90
/////////////////////////////////////////////////////////////////////////
0:             if (message.getHeader(ReadCommand.DO_REPAIR) != null)
0:             {
0:             }
commit:e2a4ea7
/////////////////////////////////////////////////////////////////////////
0:         List<EndPoint> endpoints = StorageService.instance().getNLiveStorageEndPoint(readCommand.key);
0:         /* Remove the local storage endpoint from the list. */ 
0:         endpoints.remove( StorageService.getLocalStorageEndPoint() );
0:         if (endpoints.size() > 0 && DatabaseDescriptor.getConsistencyCheck())
0:             StorageService.instance().doConsistencyCheck(row, endpoints, readCommand);
commit:7b250fa
/////////////////////////////////////////////////////////////////////////
commit:478f0be
/////////////////////////////////////////////////////////////////////////
0:             row = readCommand.getRow(table);
commit:6578825
/////////////////////////////////////////////////////////////////////////
0:             ReadResponse readResponse = null;
0:                 readResponse = new ReadResponse(table.getTableName(), row.digest());
0:                 readResponse = new ReadResponse(table.getTableName(), row);
0:             readResponse.setIsDigestQuery(readCommand.isDigestQuery());
0:             ReadResponse.serializer().serialize(readResponse, readCtx.bufOut_);
commit:df95fb8
/////////////////////////////////////////////////////////////////////////
0:             Table table = Table.open(readCommand.table);
0:             if( readCommand.columnFamilyColumn == null )
0:             	row = table.get(readCommand.key);
0:             	if(readCommand.columnNames.size() == 0)
0: 	            	if(readCommand.count > 0 && readCommand.start >= 0)
0: 	            		row = table.getRow(readCommand.key, readCommand.columnFamilyColumn, readCommand.start, readCommand.count);
0: 	            		row = table.getRow(readCommand.key, readCommand.columnFamilyColumn);
0:             		row = table.getRow(readCommand.key, readCommand.columnFamilyColumn, readCommand.columnNames);
/////////////////////////////////////////////////////////////////////////
0:             String repair = new String( message.getHeader(ReadCommand.DO_REPAIR) );
0:             if ( repair.equals( ReadCommand.DO_REPAIR) )
/////////////////////////////////////////////////////////////////////////
0:             List<EndPoint> endpoints = StorageService.instance().getNLiveStorageEndPoint(readCommand.key);
0:             if(readCommand.columnNames.size() == 0)
0:                 if( readCommand.start >= 0 && readCommand.count < Integer.MAX_VALUE)
0:                     StorageService.instance().doConsistencyCheck(row, endpoints, readCommand.columnFamilyColumn, readCommand.start, readCommand.count);
0:                 if( readCommand.sinceTimestamp > 0)
0:                     StorageService.instance().doConsistencyCheck(row, endpoints, readCommand.columnFamilyColumn, readCommand.sinceTimestamp);
0:                 StorageService.instance().doConsistencyCheck(row, endpoints, readCommand.columnFamilyColumn, readCommand.columnNames);
commit:8e72ac4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             ReadCommand readCommand = ReadCommand.serializer().deserialize(readCtx.bufIn_);
0:             Table table = Table.open(readCommand.table());
0:             if( readCommand.columnFamily_column() == null )
0:             	row = table.get(readCommand.key());
0:             	if(readCommand.getColumnNames().size() == 0)
0: 	            	if(readCommand.count() > 0 && readCommand.start() >= 0)
0: 	            		row = table.getRow(readCommand.key(), readCommand.columnFamily_column(), readCommand.start(), readCommand.count());
0: 	            		row = table.getRow(readCommand.key(), readCommand.columnFamily_column());
0:             		row = table.getRow(readCommand.key(), readCommand.columnFamily_column(), readCommand.getColumnNames());
0:             if(readCommand.isDigestQuery())
/////////////////////////////////////////////////////////////////////////
0:             readResponseMessage.setIsDigestQuery(readCommand.isDigestQuery());
/////////////////////////////////////////////////////////////////////////
0:             String repair = new String( message.getHeader(ReadCommand.doRepair_) );
0:             if ( repair.equals( ReadCommand.doRepair_ ) )
0:                 doReadRepair(row, readCommand);
/////////////////////////////////////////////////////////////////////////
0:     private void doReadRepair(Row row, ReadCommand readCommand)
0:             List<EndPoint> endpoints = StorageService.instance().getNLiveStorageEndPoint(readCommand.key());
0:             if(readCommand.getColumnNames().size() == 0)
0:                 if( readCommand.start() >= 0 && readCommand.count() < Integer.MAX_VALUE)
0:                     StorageService.instance().doConsistencyCheck(row, endpoints, readCommand.columnFamily_column(), readCommand.start(), readCommand.count());
0:                 if( readCommand.sinceTimestamp() > 0)
0:                     StorageService.instance().doConsistencyCheck(row, endpoints, readCommand.columnFamily_column(), readCommand.sinceTimestamp());
0:                 StorageService.instance().doConsistencyCheck(row, endpoints, readCommand.columnFamily_column(), readCommand.getColumnNames());
author:Dave Brosius
-------------------------------------------------------------------------------
commit:6f217f7
/////////////////////////////////////////////////////////////////////////
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:0e96e58
/////////////////////////////////////////////////////////////////////////
0:         Keyspace keyspace = Keyspace.open(command.ksName);
0:         Row row = command.getRow(keyspace);
commit:2739248
commit:6a03b11
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         ReadCommand command = message.payload;
0:         Table table = Table.open(command.table);
0:         Row row = command.getRow(table);
0:         MessageOut<ReadResponse> reply = new MessageOut<ReadResponse>(MessagingService.Verb.REQUEST_RESPONSE,
0:                                                                       getResponse(command, row),
0:                                                                       ReadResponse.serializer);
0:         Tracing.trace("Enqueuing response to {}", message.from);
0:         MessagingService.instance().sendReply(reply, id, message.from);
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:587cb58
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                                                                           ReadResponse.serializer);
author:Brandon Williams
-------------------------------------------------------------------------------
commit:01883da
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.util.FastByteArrayInputStream;
/////////////////////////////////////////////////////////////////////////
0:             FastByteArrayInputStream in = new FastByteArrayInputStream(message.getMessageBody());
commit:127c028
/////////////////////////////////////////////////////////////////////////
0:             Message response = message.getReply(FBUtilities.getBroadcastAddress(), bytes, message.getVersion());
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:1ecdd7f
/////////////////////////////////////////////////////////////////////////
0:             ReadCommand command = ReadCommand.serializer().deserialize(new DataInputStream(readCtx.bufIn_), message.getVersion());
0:             ReadResponse.serializer().serialize(readResponse, readCtx.bufOut_, message.getVersion());
commit:6ab2b23
/////////////////////////////////////////////////////////////////////////
0:             Message response = message.getReply(FBUtilities.getLocalAddress(), bytes, message.getVersion());
commit:0095f0c
/////////////////////////////////////////////////////////////////////////
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
0:     private static Logger logger_ = LoggerFactory.getLogger( ReadVerbHandler.class );
commit:3577fd8
/////////////////////////////////////////////////////////////////////////
0:                 List<InetAddress> endpoints = StorageService.instance.getLiveNaturalEndpoints(command.table, command.key);
author:Avinash Lakshman
-------------------------------------------------------------------------------
commit:f5d1a12
/////////////////////////////////////////////////////////////////////////
0: import java.util.List;
0: import org.apache.cassandra.config.DatabaseDescriptor;
0: import org.apache.cassandra.net.EndPoint;
/////////////////////////////////////////////////////////////////////////
0:     protected static class ReadContext
/////////////////////////////////////////////////////////////////////////
0:     private static ThreadLocal<ReadVerbHandler.ReadContext> tls_ = new InheritableThreadLocal<ReadVerbHandler.ReadContext>();
0:     
0:     protected static ReadVerbHandler.ReadContext getCurrentReadContext()
0:     {
0:         return tls_.get();
0:     }
0:     
0:     protected static void setCurrentReadContext(ReadVerbHandler.ReadContext readContext)
0:     {
0:         tls_.set(readContext);
0:     }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             logger_.info("ReadVerbHandler  TIME 2: " + (System.currentTimeMillis() - start) + " ms.");
0:             
0:             /* Do read repair if header of the message says so */
0:             String repair = new String( message.getHeader(ReadMessage.doRepair_) );
0:             if ( repair.equals( ReadMessage.doRepair_ ) )
0:                 doReadRepair(row, readMessage);
/////////////////////////////////////////////////////////////////////////
0:     
0:     private void doReadRepair(Row row, ReadMessage readMessage)
0:     {
0:         if ( DatabaseDescriptor.getConsistencyCheck() )
0:         {
0:             List<EndPoint> endpoints = StorageService.instance().getNLiveStorageEndPoint(readMessage.key());
0:             /* Remove the local storage endpoint from the list. */ 
0:             endpoints.remove( StorageService.getLocalStorageEndPoint() );
0:             
0:             if(readMessage.getColumnNames().size() == 0)
0:             {
0:                 if( readMessage.start() >= 0 && readMessage.count() < Integer.MAX_VALUE)
0:                 {                
0:                     StorageService.instance().doConsistencyCheck(row, endpoints, readMessage.columnFamily_column(), readMessage.start(), readMessage.count());                    
0:                 }
0:                 
0:                 if( readMessage.sinceTimestamp() > 0)
0:                 {                    
0:                     StorageService.instance().doConsistencyCheck(row, endpoints, readMessage.columnFamily_column(), readMessage.sinceTimestamp());                    
0:                 }                
0:             }
0:             else
0:             {
0:                 StorageService.instance().doConsistencyCheck(row, endpoints, readMessage.columnFamily_column(), readMessage.getColumnNames());                                
0:             }
0:         }
0:     }     
author:Prashant Malik
-------------------------------------------------------------------------------
commit:1f91e99
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: 
0: package org.apache.cassandra.db;
0: 
0: import java.io.IOException;
0: import java.nio.ByteBuffer;
0: import java.util.Collection;
0: 
0: import org.apache.cassandra.continuations.Suspendable;
0: import org.apache.cassandra.io.DataInputBuffer;
0: import org.apache.cassandra.io.DataOutputBuffer;
0: import org.apache.cassandra.net.IVerbHandler;
0: import org.apache.cassandra.net.Message;
0: import org.apache.cassandra.net.MessagingService;
0: import org.apache.cassandra.service.StorageService;
0: import org.apache.cassandra.utils.LogUtil;
0: import org.apache.log4j.Logger;
0: import org.apache.cassandra.net.*;
0: import org.apache.cassandra.utils.*;
0: 
0: /**
0:  * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com )
0:  */
0: 
0: public class ReadVerbHandler implements IVerbHandler
0: {
0:     private static class ReadContext
0:     {
0:         protected DataInputBuffer bufIn_ = new DataInputBuffer();
0:         protected DataOutputBuffer bufOut_ = new DataOutputBuffer();
0:     }
0: 
0:     private static Logger logger_ = Logger.getLogger( ReadVerbHandler.class );
0:     /* We use this so that we can reuse the same row mutation context for the mutation. */
0:     private static ThreadLocal<ReadContext> tls_ = new InheritableThreadLocal<ReadContext>();
0: 
0:     public void doVerb(Message message)
0:     {
0:         byte[] body = (byte[])message.getMessageBody()[0];
0:         /* Obtain a Read Context from TLS */
0:         ReadContext readCtx = tls_.get();
0:         if ( readCtx == null )
0:         {
0:             readCtx = new ReadContext();
0:             tls_.set(readCtx);
0:         }
0:         readCtx.bufIn_.reset(body, body.length);
0: 
0:         try
0:         {
0:             ReadMessage readMessage = ReadMessage.serializer().deserialize(readCtx.bufIn_);
0:             Table table = Table.open(readMessage.table());
0:             Row row = null;
0:             long start = System.currentTimeMillis();
0:             if( readMessage.columnFamily_column() == null )
0:             	row = table.get(readMessage.key());
0:             else
0:             {
0:             	if(readMessage.getColumnNames().size() == 0)
0:             	{
0: 	            	if(readMessage.count() > 0 && readMessage.start() >= 0)
0: 	            		row = table.getRow(readMessage.key(), readMessage.columnFamily_column(), readMessage.start(), readMessage.count());
0: 	            	else
0: 	            		row = table.getRow(readMessage.key(), readMessage.columnFamily_column());
0:             	}
0:             	else
0:             	{
0:             		row = table.getRow(readMessage.key(), readMessage.columnFamily_column(), readMessage.getColumnNames());            		
0:             	}
0:             }              
0:             logger_.info("getRow()  TIME: " + (System.currentTimeMillis() - start) + " ms.");
0:             start = System.currentTimeMillis();
0:             ReadResponseMessage readResponseMessage = null;
0:             if(readMessage.isDigestQuery())
0:             {
0:                 readResponseMessage = new ReadResponseMessage(table.getTableName(), row.digest());
0: 
0:             }
0:             else
0:             {
0:                 readResponseMessage = new ReadResponseMessage(table.getTableName(), row);
0:             }
0:             readResponseMessage.setIsDigestQuery(readMessage.isDigestQuery());
0:             /* serialize the ReadResponseMessage. */
0:             readCtx.bufOut_.reset();
0: 
0:             start = System.currentTimeMillis();
0:             ReadResponseMessage.serializer().serialize(readResponseMessage, readCtx.bufOut_);
0:             logger_.info("serialize  TIME: " + (System.currentTimeMillis() - start) + " ms.");
0: 
0:             byte[] bytes = new byte[readCtx.bufOut_.getLength()];
0:             start = System.currentTimeMillis();
0:             System.arraycopy(readCtx.bufOut_.getData(), 0, bytes, 0, bytes.length);
0:             logger_.info("copy  TIME: " + (System.currentTimeMillis() - start) + " ms.");
0: 
0:             Message response = message.getReply( StorageService.getLocalStorageEndPoint(), new Object[]{bytes} );
0:             MessagingService.getMessagingInstance().sendOneWay(response, message.getFrom());
0:             logger_.info("ReadVerbHandler  TIME 2: " + (System.currentTimeMillis() - start)
0:                     + " ms.");
0:         }
0:         catch ( IOException ex)
0:         {
0:             logger_.info( LogUtil.throwableToString(ex) );
0:         }
0:         catch ( ColumnFamilyNotDefinedException ex)
0:         {
0:             logger_.info( LogUtil.throwableToString(ex) );
0:         }
0:     }
0: }
============================================================================