1:88edbed: /*
1:88edbed: * Licensed to the Apache Software Foundation (ASF) under one
1:88edbed: * or more contributor license agreements.  See the NOTICE file
1:88edbed: * distributed with this work for additional information
1:88edbed: * regarding copyright ownership.  The ASF licenses this file
1:88edbed: * to you under the Apache License, Version 2.0 (the
1:88edbed: * "License"); you may not use this file except in compliance
1:88edbed: * with the License.  You may obtain a copy of the License at
1:88edbed: *
1:88edbed: *    http://www.apache.org/licenses/LICENSE-2.0
1:88edbed: *
1:88edbed: * Unless required by applicable law or agreed to in writing,
1:88edbed: * software distributed under the License is distributed on an
1:88edbed: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:88edbed: * KIND, either express or implied.  See the License for the
1:88edbed: * specific language governing permissions and limitations
1:88edbed: * under the License.
1:88edbed: */
1:2ec1b06: package org.apache.cassandra.db;
1:a2e7435: 
1:a991b64: import java.io.IOException;
1:f6af142: import java.util.HashMap;
1:f6af142: import java.util.Map;
1:a2e7435: 
1:a991b64: import com.google.common.collect.ImmutableList;
1:a991b64: import org.junit.Before;
1:d2a3827: import org.junit.BeforeClass;
1:a2e7435: import org.junit.Test;
1:a2e7435: 
1:48e8dcc: import org.apache.cassandra.SchemaLoader;
1:a991b64: import org.apache.cassandra.Util;
1:a991b64: import org.apache.cassandra.config.CFMetaData;
1:a991b64: import org.apache.cassandra.config.ColumnDefinition;
1:9797511: import org.apache.cassandra.config.DatabaseDescriptor;
1:a991b64: import org.apache.cassandra.cql3.ColumnIdentifier;
1:a991b64: import org.apache.cassandra.db.rows.*;
1:a991b64: import org.apache.cassandra.db.marshal.AbstractType;
1:a991b64: import org.apache.cassandra.db.marshal.AsciiType;
1:a991b64: import org.apache.cassandra.db.marshal.BytesType;
1:a991b64: import org.apache.cassandra.db.partitions.PartitionUpdate;
1:d2a3827: import org.apache.cassandra.exceptions.ConfigurationException;
1:31e3f61: import org.apache.cassandra.schema.KeyspaceParams;
1:48e8dcc: import org.apache.cassandra.utils.ByteBufferUtil;
1:a991b64: import org.apache.cassandra.utils.FBUtilities;
1:48e8dcc: 
1:48e8dcc: import static org.junit.Assert.assertEquals;
1:4485e6d: import static org.junit.Assert.assertTrue;
1:48e8dcc: 
1:d2a3827: public class RowTest
4:2ec1b06: {
1:d2a3827:     private static final String KEYSPACE1 = "RowTest";
1:d2a3827:     private static final String CF_STANDARD1 = "Standard1";
1:d2a3827: 
1:a991b64:     private int nowInSeconds;
1:a991b64:     private DecoratedKey dk;
1:a991b64:     private ColumnFamilyStore cfs;
1:a991b64:     private CFMetaData cfm;
1:a991b64: 
1:d2a3827:     @BeforeClass
1:d2a3827:     public static void defineSchema() throws ConfigurationException
1:d2a3827:     {
1:9797511:         DatabaseDescriptor.daemonInitialization();
1:a991b64:         CFMetaData cfMetadata = CFMetaData.Builder.create(KEYSPACE1, CF_STANDARD1)
1:a991b64:                                                   .addPartitionKey("key", BytesType.instance)
1:a991b64:                                                   .addClusteringColumn("col1", AsciiType.instance)
1:a991b64:                                                   .addRegularColumn("a", AsciiType.instance)
1:a991b64:                                                   .addRegularColumn("b", AsciiType.instance)
1:a991b64:                                                   .build();
1:d2a3827:         SchemaLoader.prepareServer();
1:d2a3827:         SchemaLoader.createKeyspace(KEYSPACE1,
1:31e3f61:                                     KeyspaceParams.simple(1),
1:a991b64:                                     cfMetadata);
1:a991b64:     }
1:a991b64: 
1:a991b64:     @Before
1:a991b64:     public void setup()
1:a991b64:     {
1:a991b64:         nowInSeconds = FBUtilities.nowInSeconds();
1:a991b64:         dk = Util.dk("key0");
1:a991b64:         cfs = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF_STANDARD1);
1:a991b64:         cfm = cfs.metadata;
1:d2a3827:     }
1:d2a3827: 
1:cee4d20:     @Test
1:a991b64:     public void testMergeRangeTombstones() throws InterruptedException
1:cee4d20:     {
1:a991b64:         PartitionUpdate update1 = new PartitionUpdate(cfm, dk, cfm.partitionColumns(), 1);
1:a991b64:         writeRangeTombstone(update1, "1", "11", 123, 123);
1:a991b64:         writeRangeTombstone(update1, "2", "22", 123, 123);
1:a991b64:         writeRangeTombstone(update1, "3", "31", 123, 123);
1:a991b64:         writeRangeTombstone(update1, "4", "41", 123, 123);
1:a2e7435: 
1:a991b64:         PartitionUpdate update2 = new PartitionUpdate(cfm, dk, cfm.partitionColumns(), 1);
1:a991b64:         writeRangeTombstone(update2, "1", "11", 123, 123);
1:a991b64:         writeRangeTombstone(update2, "111", "112", 1230, 123);
1:a991b64:         writeRangeTombstone(update2, "2", "24", 123, 123);
1:a991b64:         writeRangeTombstone(update2, "3", "31", 1230, 123);
1:a991b64:         writeRangeTombstone(update2, "4", "41", 123, 1230);
1:a991b64:         writeRangeTombstone(update2, "5", "51", 123, 1230);
1:a2e7435: 
1:a991b64:         try (UnfilteredRowIterator merged = UnfilteredRowIterators.merge(ImmutableList.of(update1.unfilteredIterator(), update2.unfilteredIterator()), nowInSeconds))
1:a991b64:         {
1:a991b64:             Object[][] expected = new Object[][]{ { "1", "11", 123l, 123 },
1:a991b64:                                                   { "111", "112", 1230l, 123 },
1:a991b64:                                                   { "2", "24", 123l, 123 },
1:a991b64:                                                   { "3", "31", 1230l, 123 },
1:a991b64:                                                   { "4", "41", 123l, 1230 },
1:a991b64:                                                   { "5", "51", 123l, 1230 } };
1:a991b64:             int i = 0;
1:a991b64:             while (merged.hasNext())
1:a991b64:             {
1:a991b64:                 RangeTombstoneBoundMarker openMarker = (RangeTombstoneBoundMarker)merged.next();
1:2cc26eb:                 ClusteringBound openBound = openMarker.clustering();
1:2457599:                 DeletionTime openDeletion = new DeletionTime(openMarker.deletionTime().markedForDeleteAt(),
1:a991b64:                                                                    openMarker.deletionTime().localDeletionTime());
1:2effc40: 
1:a991b64:                 RangeTombstoneBoundMarker closeMarker = (RangeTombstoneBoundMarker)merged.next();
1:2cc26eb:                 ClusteringBound closeBound = closeMarker.clustering();
1:2457599:                 DeletionTime closeDeletion = new DeletionTime(closeMarker.deletionTime().markedForDeleteAt(),
1:a991b64:                                                                     closeMarker.deletionTime().localDeletionTime());
1:8358669: 
1:a991b64:                 assertEquals(openDeletion, closeDeletion);
1:a991b64:                 assertRangeTombstoneMarkers(openBound, closeBound, openDeletion, expected[i++]);
1:a991b64:             }
1:a991b64:         }
1:cee4d20:     }
1:cee4d20: 
2:2ec1b06:     @Test
1:994487d:     public void testResolve()
1:cee4d20:     {
1:a991b64:         ColumnDefinition defA = cfm.getColumnDefinition(new ColumnIdentifier("a", true));
1:a991b64:         ColumnDefinition defB = cfm.getColumnDefinition(new ColumnIdentifier("b", true));
1:cee4d20: 
1:aa57626:         Row.Builder builder = BTreeRow.unsortedBuilder(nowInSeconds);
1:2457599:         builder.newRow(cfm.comparator.make("c1"));
1:2457599:         writeSimpleCellValue(builder, cfm, defA, "a1", 0);
1:2457599:         writeSimpleCellValue(builder, cfm, defA, "a2", 1);
1:2457599:         writeSimpleCellValue(builder, cfm, defB, "b1", 1);
1:2457599:         Row row = builder.build();
1:2457599: 
1:2457599:         PartitionUpdate update = PartitionUpdate.singleRowUpdate(cfm, dk, row);
1:cee4d20: 
1:a991b64:         Unfiltered unfiltered = update.unfilteredIterator().next();
1:a991b64:         assertTrue(unfiltered.kind() == Unfiltered.Kind.ROW);
1:2457599:         row = (Row) unfiltered;
1:a991b64:         assertEquals("a2", defA.cellValueType().getString(row.getCell(defA).value()));
1:a991b64:         assertEquals("b1", defB.cellValueType().getString(row.getCell(defB).value()));
1:0d74c3e:         assertEquals(2, row.columns().size());
1:cee4d20:     }
1:97fc5cb: 
1:2ec1b06:     @Test
1:a991b64:     public void testExpiringColumnExpiration() throws IOException
1:cee4d20:     {
1:a991b64:         int ttl = 1;
1:a991b64:         ColumnDefinition def = cfm.getColumnDefinition(new ColumnIdentifier("a", true));
1:2457599: 
1:2457599:         Cell cell = BufferCell.expiring(def, 0, ttl, nowInSeconds, ((AbstractType) def.cellValueType()).decompose("a1"));
1:2457599: 
1:e51f83b:         PartitionUpdate update = PartitionUpdate.singleRowUpdate(cfm, dk, BTreeRow.singleCellRow(cfm.comparator.make("c1"), cell));
1:a991b64:         new Mutation(update).applyUnsafe();
10:2ec1b06: 
1:a991b64:         // when we read with a nowInSeconds before the cell has expired,
1:a991b64:         // the PartitionIterator includes the row we just wrote
1:a991b64:         Row row = Util.getOnlyRow(Util.cmd(cfs, dk).includeRow("c1").withNowInSeconds(nowInSeconds).build());
1:a991b64:         assertEquals("a1", ByteBufferUtil.string(row.getCell(def).value()));
1:2ec1b06: 
1:a991b64:         // when we read with a nowInSeconds after the cell has expired, the row is filtered
1:a991b64:         // so the PartitionIterator is empty
1:a991b64:         Util.assertEmpty(Util.cmd(cfs, dk).includeRow("c1").withNowInSeconds(nowInSeconds + ttl + 1).build());
1:a991b64:     }
1:a991b64: 
1:f6af142:     @Test
1:f6af142:     public void testHashCode()
1:f6af142:     {
1:f6af142:         ColumnDefinition defA = cfm.getColumnDefinition(new ColumnIdentifier("a", true));
1:f6af142:         ColumnDefinition defB = cfm.getColumnDefinition(new ColumnIdentifier("b", true));
1:f6af142: 
1:f6af142:         Row.Builder builder = BTreeRow.unsortedBuilder(nowInSeconds);
1:f6af142:         builder.newRow(cfm.comparator.make("c1"));
1:f6af142:         writeSimpleCellValue(builder, cfm, defA, "a1", 0);
1:f6af142:         writeSimpleCellValue(builder, cfm, defA, "a2", 1);
1:f6af142:         writeSimpleCellValue(builder, cfm, defB, "b1", 1);
1:f6af142:         Row row = builder.build();
1:f6af142: 
1:f6af142:         Map<Row, Integer> map = new HashMap<>();
1:f6af142:         map.put(row, 1);
1:f6af142:         assertEquals(Integer.valueOf(1), map.get(row));
1:f6af142:     }
1:f6af142: 
1:2cc26eb:     private void assertRangeTombstoneMarkers(ClusteringBound start, ClusteringBound end, DeletionTime deletionTime, Object[] expected)
1:a991b64:     {
1:a991b64:         AbstractType clusteringType = (AbstractType)cfm.comparator.subtype(0);
1:a991b64: 
1:a991b64:         assertEquals(1, start.size());
1:2cc26eb:         assertEquals(start.kind(), ClusteringPrefix.Kind.INCL_START_BOUND);
1:a991b64:         assertEquals(expected[0], clusteringType.getString(start.get(0)));
1:a991b64: 
1:a991b64:         assertEquals(1, end.size());
1:2cc26eb:         assertEquals(end.kind(), ClusteringPrefix.Kind.INCL_END_BOUND);
1:a991b64:         assertEquals(expected[1], clusteringType.getString(end.get(0)));
1:a991b64: 
1:a991b64:         assertEquals(expected[2], deletionTime.markedForDeleteAt());
1:a991b64:         assertEquals(expected[3], deletionTime.localDeletionTime());
1:a991b64:     }
1:a991b64: 
1:a991b64:     public void writeRangeTombstone(PartitionUpdate update, Object start, Object end, long markedForDeleteAt, int localDeletionTime)
1:a991b64:     {
1:a991b64:         ClusteringComparator comparator = cfs.getComparator();
1:2457599:         update.add(new RangeTombstone(Slice.make(comparator.make(start), comparator.make(end)), new DeletionTime(markedForDeleteAt, localDeletionTime)));
1:a991b64:     }
1:a991b64: 
1:2457599:     private void writeSimpleCellValue(Row.Builder builder,
1:a991b64:                                       CFMetaData cfm,
1:a991b64:                                       ColumnDefinition columnDefinition,
1:a991b64:                                       String value,
1:2457599:                                       long timestamp)
1:a991b64:     {
1:e017f94:        builder.addCell(BufferCell.live(columnDefinition, timestamp, ((AbstractType) columnDefinition.cellValueType()).decompose(value)));
1:cee4d20:     }
4:2ec1b06: }
============================================================================
author:Robert Stupp
-------------------------------------------------------------------------------
commit:9797511
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.DatabaseDescriptor;
/////////////////////////////////////////////////////////////////////////
1:         DatabaseDescriptor.daemonInitialization();
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:2cc26eb
/////////////////////////////////////////////////////////////////////////
1:                 ClusteringBound openBound = openMarker.clustering();
1:                 ClusteringBound closeBound = closeMarker.clustering();
/////////////////////////////////////////////////////////////////////////
1:     private void assertRangeTombstoneMarkers(ClusteringBound start, ClusteringBound end, DeletionTime deletionTime, Object[] expected)
1:         assertEquals(start.kind(), ClusteringPrefix.Kind.INCL_START_BOUND);
1:         assertEquals(end.kind(), ClusteringPrefix.Kind.INCL_END_BOUND);
commit:f6af142
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void testHashCode()
1:     {
1:         ColumnDefinition defA = cfm.getColumnDefinition(new ColumnIdentifier("a", true));
1:         ColumnDefinition defB = cfm.getColumnDefinition(new ColumnIdentifier("b", true));
1: 
1:         Row.Builder builder = BTreeRow.unsortedBuilder(nowInSeconds);
1:         builder.newRow(cfm.comparator.make("c1"));
1:         writeSimpleCellValue(builder, cfm, defA, "a1", 0);
1:         writeSimpleCellValue(builder, cfm, defA, "a2", 1);
1:         writeSimpleCellValue(builder, cfm, defB, "b1", 1);
1:         Row row = builder.build();
1: 
1:         Map<Row, Integer> map = new HashMap<>();
1:         map.put(row, 1);
1:         assertEquals(Integer.valueOf(1), map.get(row));
1:     }
1: 
author:Marcus Eriksson
-------------------------------------------------------------------------------
commit:9841cb7
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:e017f94
/////////////////////////////////////////////////////////////////////////
1:        builder.addCell(BufferCell.live(columnDefinition, timestamp, ((AbstractType) columnDefinition.cellValueType()).decompose(value)));
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:aa57626
/////////////////////////////////////////////////////////////////////////
1:         Row.Builder builder = BTreeRow.unsortedBuilder(nowInSeconds);
commit:0d74c3e
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(2, row.columns().size());
commit:e51f83b
/////////////////////////////////////////////////////////////////////////
0:         Row.Builder builder = BTreeRow.unsortedBuilder(cfm.partitionColumns().regulars, nowInSeconds);
/////////////////////////////////////////////////////////////////////////
1:         PartitionUpdate update = PartitionUpdate.singleRowUpdate(cfm, dk, BTreeRow.singleCellRow(cfm.comparator.make("c1"), cell));
commit:639d4b2
/////////////////////////////////////////////////////////////////////////
0:         Row.Builder builder = BTreeBackedRow.unsortedBuilder(cfm.partitionColumns().regulars, nowInSeconds);
/////////////////////////////////////////////////////////////////////////
0:         PartitionUpdate update = PartitionUpdate.singleRowUpdate(cfm, dk, BTreeBackedRow.singleCellRow(cfm.comparator.make("c1"), cell));
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:2457599
/////////////////////////////////////////////////////////////////////////
1:                 DeletionTime openDeletion = new DeletionTime(openMarker.deletionTime().markedForDeleteAt(),
1:                 DeletionTime closeDeletion = new DeletionTime(closeMarker.deletionTime().markedForDeleteAt(),
/////////////////////////////////////////////////////////////////////////
0:         Row.Builder builder = ArrayBackedRow.unsortedBuilder(cfm.partitionColumns().regulars, nowInSeconds);
1:         builder.newRow(cfm.comparator.make("c1"));
1:         writeSimpleCellValue(builder, cfm, defA, "a1", 0);
1:         writeSimpleCellValue(builder, cfm, defA, "a2", 1);
1:         writeSimpleCellValue(builder, cfm, defB, "b1", 1);
1:         Row row = builder.build();
1: 
1:         PartitionUpdate update = PartitionUpdate.singleRowUpdate(cfm, dk, row);
1:         row = (Row) unfiltered;
/////////////////////////////////////////////////////////////////////////
1: 
1:         Cell cell = BufferCell.expiring(def, 0, ttl, nowInSeconds, ((AbstractType) def.cellValueType()).decompose("a1"));
1: 
0:         PartitionUpdate update = PartitionUpdate.singleRowUpdate(cfm, dk, ArrayBackedRow.singleCellRow(cfm.comparator.make("c1"), cell));
/////////////////////////////////////////////////////////////////////////
1:         update.add(new RangeTombstone(Slice.make(comparator.make(start), comparator.make(end)), new DeletionTime(markedForDeleteAt, localDeletionTime)));
1:     private void writeSimpleCellValue(Row.Builder builder,
1:                                       long timestamp)
0:        builder.addCell(BufferCell.live(cfm, columnDefinition, timestamp, ((AbstractType) columnDefinition.cellValueType()).decompose(value)));
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import com.google.common.collect.ImmutableList;
1: import org.junit.Before;
1: import org.apache.cassandra.Util;
1: import org.apache.cassandra.config.CFMetaData;
1: import org.apache.cassandra.config.ColumnDefinition;
1: import org.apache.cassandra.cql3.ColumnIdentifier;
1: import org.apache.cassandra.db.rows.*;
1: import org.apache.cassandra.db.marshal.AbstractType;
1: import org.apache.cassandra.db.marshal.AsciiType;
1: import org.apache.cassandra.db.marshal.BytesType;
1: import org.apache.cassandra.db.partitions.PartitionUpdate;
1: import org.apache.cassandra.utils.FBUtilities;
/////////////////////////////////////////////////////////////////////////
1:     private int nowInSeconds;
1:     private DecoratedKey dk;
1:     private ColumnFamilyStore cfs;
1:     private CFMetaData cfm;
1: 
1:         CFMetaData cfMetadata = CFMetaData.Builder.create(KEYSPACE1, CF_STANDARD1)
1:                                                   .addPartitionKey("key", BytesType.instance)
1:                                                   .addClusteringColumn("col1", AsciiType.instance)
1:                                                   .addRegularColumn("a", AsciiType.instance)
1:                                                   .addRegularColumn("b", AsciiType.instance)
1:                                                   .build();
1:                                     cfMetadata);
1:     }
1: 
1:     @Before
1:     public void setup()
1:     {
1:         nowInSeconds = FBUtilities.nowInSeconds();
1:         dk = Util.dk("key0");
1:         cfs = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF_STANDARD1);
1:         cfm = cfs.metadata;
1:     public void testMergeRangeTombstones() throws InterruptedException
1:         PartitionUpdate update1 = new PartitionUpdate(cfm, dk, cfm.partitionColumns(), 1);
1:         writeRangeTombstone(update1, "1", "11", 123, 123);
1:         writeRangeTombstone(update1, "2", "22", 123, 123);
1:         writeRangeTombstone(update1, "3", "31", 123, 123);
1:         writeRangeTombstone(update1, "4", "41", 123, 123);
1:         PartitionUpdate update2 = new PartitionUpdate(cfm, dk, cfm.partitionColumns(), 1);
1:         writeRangeTombstone(update2, "1", "11", 123, 123);
1:         writeRangeTombstone(update2, "111", "112", 1230, 123);
1:         writeRangeTombstone(update2, "2", "24", 123, 123);
1:         writeRangeTombstone(update2, "3", "31", 1230, 123);
1:         writeRangeTombstone(update2, "4", "41", 123, 1230);
1:         writeRangeTombstone(update2, "5", "51", 123, 1230);
1:         try (UnfilteredRowIterator merged = UnfilteredRowIterators.merge(ImmutableList.of(update1.unfilteredIterator(), update2.unfilteredIterator()), nowInSeconds))
1:         {
1:             Object[][] expected = new Object[][]{ { "1", "11", 123l, 123 },
1:                                                   { "111", "112", 1230l, 123 },
1:                                                   { "2", "24", 123l, 123 },
1:                                                   { "3", "31", 1230l, 123 },
1:                                                   { "4", "41", 123l, 1230 },
1:                                                   { "5", "51", 123l, 1230 } };
1:             int i = 0;
1:             while (merged.hasNext())
1:             {
1:                 RangeTombstoneBoundMarker openMarker = (RangeTombstoneBoundMarker)merged.next();
0:                 Slice.Bound openBound = openMarker.clustering();
0:                 DeletionTime openDeletion = new SimpleDeletionTime(openMarker.deletionTime().markedForDeleteAt(),
1:                                                                    openMarker.deletionTime().localDeletionTime());
1:                 RangeTombstoneBoundMarker closeMarker = (RangeTombstoneBoundMarker)merged.next();
0:                 Slice.Bound closeBound = closeMarker.clustering();
0:                 DeletionTime closeDeletion = new SimpleDeletionTime(closeMarker.deletionTime().markedForDeleteAt(),
1:                                                                     closeMarker.deletionTime().localDeletionTime());
1:                 assertEquals(openDeletion, closeDeletion);
1:                 assertRangeTombstoneMarkers(openBound, closeBound, openDeletion, expected[i++]);
1:             }
1:         }
1:         ColumnDefinition defA = cfm.getColumnDefinition(new ColumnIdentifier("a", true));
1:         ColumnDefinition defB = cfm.getColumnDefinition(new ColumnIdentifier("b", true));
0:         PartitionUpdate update = new PartitionUpdate(cfm, dk, cfm.partitionColumns(), 1);
0:         Rows.writeClustering(update.metadata().comparator.make("c1"), update.writer());
0:         writeSimpleCellValue(update.writer(), cfm, defA, "a1", 0, nowInSeconds);
0:         writeSimpleCellValue(update.writer(), cfm, defA, "a2", 1, nowInSeconds);
0:         writeSimpleCellValue(update.writer(), cfm, defB, "b1", 1, nowInSeconds);
0:         update.writer().endOfRow();
1:         Unfiltered unfiltered = update.unfilteredIterator().next();
1:         assertTrue(unfiltered.kind() == Unfiltered.Kind.ROW);
0:         Row row = (Row) unfiltered;
1:         assertEquals("a2", defA.cellValueType().getString(row.getCell(defA).value()));
1:         assertEquals("b1", defB.cellValueType().getString(row.getCell(defB).value()));
0:         assertEquals(2, row.columns().columnCount());
1:     public void testExpiringColumnExpiration() throws IOException
1:         int ttl = 1;
1:         ColumnDefinition def = cfm.getColumnDefinition(new ColumnIdentifier("a", true));
0:         PartitionUpdate update = new PartitionUpdate(cfm, dk, cfm.partitionColumns(), 1);
0:         Rows.writeClustering(update.metadata().comparator.make("c1"), update.writer());
0:         update.writer().writeCell(def, false, ((AbstractType) def.cellValueType()).decompose("a1"),
0:                                   SimpleLivenessInfo.forUpdate(0, ttl, nowInSeconds, cfm),
0:                                   null);
0:         update.writer().endOfRow();
1:         new Mutation(update).applyUnsafe();
1:         // when we read with a nowInSeconds before the cell has expired,
1:         // the PartitionIterator includes the row we just wrote
1:         Row row = Util.getOnlyRow(Util.cmd(cfs, dk).includeRow("c1").withNowInSeconds(nowInSeconds).build());
1:         assertEquals("a1", ByteBufferUtil.string(row.getCell(def).value()));
1:         // when we read with a nowInSeconds after the cell has expired, the row is filtered
1:         // so the PartitionIterator is empty
1:         Util.assertEmpty(Util.cmd(cfs, dk).includeRow("c1").withNowInSeconds(nowInSeconds + ttl + 1).build());
1:     }
1: 
0:     private void assertRangeTombstoneMarkers(Slice.Bound start, Slice.Bound end, DeletionTime deletionTime, Object[] expected)
1:     {
1:         AbstractType clusteringType = (AbstractType)cfm.comparator.subtype(0);
1: 
1:         assertEquals(1, start.size());
0:         assertEquals(start.kind(), Slice.Bound.Kind.INCL_START_BOUND);
1:         assertEquals(expected[0], clusteringType.getString(start.get(0)));
1: 
1:         assertEquals(1, end.size());
0:         assertEquals(end.kind(), Slice.Bound.Kind.INCL_END_BOUND);
1:         assertEquals(expected[1], clusteringType.getString(end.get(0)));
1: 
1:         assertEquals(expected[2], deletionTime.markedForDeleteAt());
1:         assertEquals(expected[3], deletionTime.localDeletionTime());
1:     }
1: 
1:     public void writeRangeTombstone(PartitionUpdate update, Object start, Object end, long markedForDeleteAt, int localDeletionTime)
1:     {
1:         ClusteringComparator comparator = cfs.getComparator();
0:         update.addRangeTombstone(Slice.make(comparator.make(start), comparator.make(end)),
0:                                  new SimpleDeletionTime(markedForDeleteAt, localDeletionTime));
1:     }
1: 
0:     private void writeSimpleCellValue(Row.Writer writer,
1:                                       CFMetaData cfm,
1:                                       ColumnDefinition columnDefinition,
1:                                       String value,
0:                                       long timestamp,
0:                                       int nowInSeconds)
1:     {
0:         writer.writeCell(columnDefinition,
0:                          false,
0:                          ((AbstractType) columnDefinition.cellValueType()).decompose(value),
0:                          SimpleLivenessInfo.forUpdate(timestamp, LivenessInfo.NO_TTL, nowInSeconds, cfm),
0:                          null);
commit:e50d6af
/////////////////////////////////////////////////////////////////////////
0:         Cell c = new ExpiringCell(CellNames.simpleDense(ByteBufferUtil.bytes("one")), ByteBufferUtil.bytes("A"), 0, 1);
commit:362cc05
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.composites.*;
/////////////////////////////////////////////////////////////////////////
0:         assert Arrays.equals(cf1.getColumn(CellNames.simpleDense(ByteBufferUtil.bytes("one"))).value().array(), "B".getBytes());
0:         assert Arrays.equals(cf1.getColumn(CellNames.simpleDense(ByteBufferUtil.bytes("two"))).value().array(), "C".getBytes());
0:         Column c = new ExpiringColumn(CellNames.simpleDense(ByteBufferUtil.bytes("one")), ByteBufferUtil.bytes("A"), 0, 1);
commit:3a005df
/////////////////////////////////////////////////////////////////////////
commit:4d34917
/////////////////////////////////////////////////////////////////////////
0:         DeletionInfo delInfo = new DeletionInfo(0, 0);
0:         cf2.delete(delInfo);
0:         assertEquals(cfDiff.deletionInfo(), delInfo);
/////////////////////////////////////////////////////////////////////////
0:         DeletionInfo delInfo = new DeletionInfo(0, 0);
0:         sc2.delete(delInfo);
0:         assertEquals(scDiff.deletionInfo(), delInfo);
commit:a15c35b
/////////////////////////////////////////////////////////////////////////
commit:37f6a9f
/////////////////////////////////////////////////////////////////////////
commit:016068a
/////////////////////////////////////////////////////////////////////////
0:         assertEquals(cfDiff.getColumnCount(), 0);
commit:2c8d201
/////////////////////////////////////////////////////////////////////////
0:         sc2.delete(0, 0);
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:31e3f61
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.schema.KeyspaceParams;
/////////////////////////////////////////////////////////////////////////
1:                                     KeyspaceParams.simple(1),
commit:4485e6d
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertTrue;
/////////////////////////////////////////////////////////////////////////
0:         assertTrue(c.isLive());
0:         assert !c.isLive() && c.timestamp() == 0;
commit:48e8dcc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.SchemaLoader;
0: import org.apache.cassandra.db.composites.*;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: 
1: import static org.junit.Assert.assertEquals;
0: import static org.junit.Assert.assertFalse;
1: 
0: import static org.apache.cassandra.Util.column;
/////////////////////////////////////////////////////////////////////////
0:         assertFalse(cfDiff.hasColumns());
commit:79c6ecc
/////////////////////////////////////////////////////////////////////////
0:         cf1.addAll(cf2);
commit:5204575
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf1 = ArrayBackedSortedColumns.factory.create("Keyspace1", "Standard1");
0:         ColumnFamily cf2 = ArrayBackedSortedColumns.factory.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf1 = ArrayBackedSortedColumns.factory.create("Keyspace1", "Standard1");
0:         ColumnFamily cf2 = ArrayBackedSortedColumns.factory.create("Keyspace1", "Standard1");
commit:1f7628c
/////////////////////////////////////////////////////////////////////////
0:         assert !c.isMarkedForDelete(System.currentTimeMillis());
0:         assert c.isMarkedForDelete(System.currentTimeMillis()) && c.getMarkedForDeleteAt() == 0;
author:lyubent
-------------------------------------------------------------------------------
commit:d2a3827
/////////////////////////////////////////////////////////////////////////
1: import org.junit.BeforeClass;
0: import org.apache.cassandra.config.KSMetaData;
1: import org.apache.cassandra.exceptions.ConfigurationException;
0: import org.apache.cassandra.locator.SimpleStrategy;
/////////////////////////////////////////////////////////////////////////
1: public class RowTest
1:     private static final String KEYSPACE1 = "RowTest";
1:     private static final String CF_STANDARD1 = "Standard1";
1: 
1:     @BeforeClass
1:     public static void defineSchema() throws ConfigurationException
1:     {
1:         SchemaLoader.prepareServer();
1:         SchemaLoader.createKeyspace(KEYSPACE1,
0:                                     SimpleStrategy.class,
0:                                     KSMetaData.optsWithRF(1),
0:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD1));
1:     }
1: 
0:         ColumnFamily cf1 = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "Standard1");
0:         ColumnFamily cf2 = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf1 = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "Standard1");
0:         ColumnFamily cf2 = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "Standard1");
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:8541cca
/////////////////////////////////////////////////////////////////////////
0:         Cell c = new BufferExpiringCell(CellNames.simpleDense(ByteBufferUtil.bytes("one")), ByteBufferUtil.bytes("A"), 0, 1);
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:a2e7435
/////////////////////////////////////////////////////////////////////////
1: import org.junit.Test;
0: import org.apache.cassandra.db.composites.CellNames;
0: import static org.apache.cassandra.Util.column;
0: import static org.apache.cassandra.Util.tombstone;
/////////////////////////////////////////////////////////////////////////
1: 
0:         RangeTombstone tombstone1 = tombstone("1", "11", (long) 123, 123);
0:         RangeTombstone tombstone1_2 = tombstone("111", "112", (long) 1230, 123);
0:         RangeTombstone tombstone2_1 = tombstone("2", "22", (long) 123, 123);
0:         RangeTombstone tombstone2_2 = tombstone("2", "24", (long) 123, 123);
0:         RangeTombstone tombstone3_1 = tombstone("3", "31", (long) 123, 123);
0:         RangeTombstone tombstone3_2 = tombstone("3", "31", (long) 1230, 123);
0:         RangeTombstone tombstone4_1 = tombstone("4", "41", (long) 123, 123);
0:         RangeTombstone tombstone4_2 = tombstone("4", "41", (long) 123, 1230);
0:         RangeTombstone tombstone5_2 = tombstone("5", "51", (long) 123, 1230);
0:         cf1.delete(tombstone1);
0:         cf1.delete(tombstone2_1);
0:         cf1.delete(tombstone3_1);
0:         cf1.delete(tombstone4_1);
1: 
0:         cf2.delete(tombstone1);
0:         cf2.delete(tombstone1_2);
0:         cf2.delete(tombstone2_2);
0:         cf2.delete(tombstone3_2);
0:         cf2.delete(tombstone4_2);
0:         cf2.delete(tombstone5_2);
1: 
0:         cfDiff = cf1.diff(cf2);
0:         assertEquals(0, cfDiff.getColumnCount());
1: 
0:         // only tmbstones which differ in superset or have more recent timestamp to be in diff
0:         delInfo.add(tombstone1_2, cf1.getComparator());
0:         delInfo.add(tombstone2_2, cf1.getComparator());
0:         delInfo.add(tombstone3_2, cf1.getComparator());
0:         delInfo.add(tombstone5_2, cf1.getComparator());
1: 
0:         assertEquals(delInfo, cfDiff.deletionInfo());
commit:2effc40
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.TimeUnit;
0: import com.google.common.util.concurrent.Uninterruptibles;
1: 
/////////////////////////////////////////////////////////////////////////
0:         // Because we keep the local deletion time with a precision of a
0:         // second, we could have to wait 2 seconds in worst case scenario.
0:         Uninterruptibles.sleepUninterruptibly(2, TimeUnit.SECONDS);
commit:aa76394
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf1 = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
0:         ColumnFamily cf2 = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf1 = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
0:         ColumnFamily cf2 = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
commit:8358669
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.ByteBufferUtil;
1: 
/////////////////////////////////////////////////////////////////////////
0:         SuperColumn sc1 = new SuperColumn(ByteBufferUtil.bytes("one"), AsciiType.instance);
0:         SuperColumn sc2 = new SuperColumn(ByteBufferUtil.bytes("one"), AsciiType.instance);
/////////////////////////////////////////////////////////////////////////
0:         assert Arrays.equals(cf1.getColumn(ByteBufferUtil.bytes("one")).value().array(), "B".getBytes());
0:         assert Arrays.equals(cf1.getColumn(ByteBufferUtil.bytes("two")).value().array(), "C".getBytes());
0:         Column c = new ExpiringColumn(ByteBufferUtil.bytes("one"), ByteBufferUtil.bytes("A"), 0, 1);
commit:e7a385a
/////////////////////////////////////////////////////////////////////////
0: import java.nio.ByteBuffer;
/////////////////////////////////////////////////////////////////////////
0:         SuperColumn sc1 = new SuperColumn(ByteBuffer.wrap("one".getBytes()), AsciiType.instance);
0:         SuperColumn sc2 = new SuperColumn(ByteBuffer.wrap("one".getBytes()), AsciiType.instance);
/////////////////////////////////////////////////////////////////////////
0:         assert Arrays.equals(cf1.getColumn(ByteBuffer.wrap("one".getBytes())).value().array(), "B".getBytes());
0:         assert Arrays.equals(cf1.getColumn(ByteBuffer.wrap("two".getBytes())).value().array(), "C".getBytes());
0:         Column c = new ExpiringColumn(ByteBuffer.wrap("one".getBytes()), ByteBuffer.wrap("A".getBytes()), 0, 1);
commit:9d32382
/////////////////////////////////////////////////////////////////////////
0:         cf1.addColumn(column("one", "onev", 0));
0:         cf2.delete(0, 0);
0:         assertEquals(cfDiff.getMarkedForDeleteAt(), 0);
0:         SuperColumn sc1 = new SuperColumn("one".getBytes(), AsciiType.instance);
0:         sc1.addColumn(column("subcolumn", "A", 0));
0:         SuperColumn sc2 = new SuperColumn("one".getBytes(), AsciiType.instance);
0:         sc2.markForDeleteAt(0, 0);
0:         assertEquals(scDiff.getMarkedForDeleteAt(), 0);
0:         cf1.addColumn(column("one", "A", 0));
0:         cf2.addColumn(column("one", "B", 1));
0:         cf2.addColumn(column("two", "C", 1));
/////////////////////////////////////////////////////////////////////////
0:         Column c = new ExpiringColumn("one".getBytes(), "A".getBytes(), 0, 1);
/////////////////////////////////////////////////////////////////////////
0:         assert c.isMarkedForDelete() && c.getMarkedForDeleteAt() == 0;
commit:cee4d20
/////////////////////////////////////////////////////////////////////////
0: import static junit.framework.Assert.fail;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test
0:     public void testExpiringColumnExpiration()
1:     {
0:         Column c = new ExpiringColumn("one".getBytes(), "A".getBytes(), new TimestampClock(0), 1);
0:         assert !c.isMarkedForDelete();
1: 
0:         try
1:         {
0:             // Because we keep the local deletion time with a precision of a
0:             // second, we could have to wait 2 seconds in worst case scenario.
0:             Thread.sleep(2000);
1:         }
0:         catch (InterruptedException e)
1:         {
0:             fail("Cannot test column expiration if you wake me up too early");
1:         }
1: 
0:         assert c.isMarkedForDelete() && c.getMarkedForDeleteAt().equals(new TimestampClock(0));
1:     }
commit:242b717
/////////////////////////////////////////////////////////////////////////
0:         SuperColumn sc1 = new SuperColumn("one".getBytes(), AsciiType.instance, ClockType.Timestamp);
0:         SuperColumn sc2 = new SuperColumn("one".getBytes(), AsciiType.instance, ClockType.Timestamp);
commit:cba59a8
/////////////////////////////////////////////////////////////////////////
0:         cf1.addColumn(column("one", "onev", new TimestampClock(0)));
0:         cf2.delete(0, new TimestampClock(0));
0:         assertEquals(((TimestampClock) cfDiff.getMarkedForDeleteAt()).timestamp(), 0);
0:         SuperColumn sc1 = new SuperColumn("one".getBytes(), new AsciiType(), ClockType.Timestamp);
0:         sc1.addColumn(column("subcolumn", "A", new TimestampClock(0)));
0:         SuperColumn sc2 = new SuperColumn("one".getBytes(), new AsciiType(), ClockType.Timestamp);
0:         sc2.markForDeleteAt(0, new TimestampClock(0));
0:         assertEquals(((TimestampClock)scDiff.getMarkedForDeleteAt()).timestamp(), 0);
0:         cf1.addColumn(column("one", "A", new TimestampClock(0)));
0:         cf2.addColumn(column("one", "B", new TimestampClock(1)));
0:         cf2.addColumn(column("two", "C", new TimestampClock(1)));
commit:c9bbba1
/////////////////////////////////////////////////////////////////////////
0:         cf1.resolve(cf2);
commit:994487d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void testResolve()
0:         Row row1 = new Row("", cf1);
0:         Row row2 = new Row("", cf2);
0:         row1.resolve(row2);
0:         cf1 = row1.cf;
0:         assert Arrays.equals(cf1.getColumn("two".getBytes()).value(), "C".getBytes());
commit:7c41664
/////////////////////////////////////////////////////////////////////////
0:         Row row1 = new Row("");
0:         Row row2 = new Row("");
commit:d293b77
/////////////////////////////////////////////////////////////////////////
0:         Row row1 = new Row("", "");
0:         Row row2 = new Row("", "");
commit:572b5f8
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf1 = ColumnFamily.create("Keyspace1", "Standard1");
0:         ColumnFamily cf2 = ColumnFamily.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf1 = ColumnFamily.create("Keyspace1", "Standard1");
0:         ColumnFamily cf2 = ColumnFamily.create("Keyspace1", "Standard1");
0:         ColumnFamily cf3 = ColumnFamily.create("Keyspace2", "Standard3");
commit:b866f81
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.marshal.AsciiType;
/////////////////////////////////////////////////////////////////////////
0:         SuperColumn sc1 = new SuperColumn("one".getBytes(), new AsciiType());
0:         SuperColumn sc2 = new SuperColumn("one".getBytes(), new AsciiType());
commit:986cee6
/////////////////////////////////////////////////////////////////////////
0:         assertEquals(cfDiff.getColumnsMap().size(), 0);
0:         SuperColumn sc1 = new SuperColumn("one".getBytes());
0:         SuperColumn sc2 = new SuperColumn("one".getBytes());
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf3 = ColumnFamily.create("Table2", "Standard3");
0:         assert Arrays.equals(cf1.getColumn("one".getBytes()).value(), "B".getBytes());
0:         assert Arrays.equals(cf2.getColumn("two".getBytes()).value(), "C".getBytes());
0:         assert row1.getColumnFamily("Standard3") != null;
commit:7435fc8
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.cassandra.Util.column;
/////////////////////////////////////////////////////////////////////////
0:         cf1.addColumn(column("one", "onev", 0));
/////////////////////////////////////////////////////////////////////////
0:         sc1.addColumn(column("subcolumn", "A", 0));
/////////////////////////////////////////////////////////////////////////
0:         cf1.addColumn(column("one", "A", 0));
0:         cf2.addColumn(column("one", "B", 1));
0:         cf2.addColumn(column("two", "C", 1));
0:         cf3.addColumn(column("three", "D", 1));
commit:f2da00f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.filter.QueryPath;
/////////////////////////////////////////////////////////////////////////
0:         cf1.addColumn(QueryPath.column("one"), "onev".getBytes(), 0);
/////////////////////////////////////////////////////////////////////////
0:         cf1.addColumn(QueryPath.column("one"), "A".getBytes(), 0);
0:         cf2.addColumn(QueryPath.column("one"), "B".getBytes(), 1);
0:         cf2.addColumn(QueryPath.column("two"), "C".getBytes(), 1);
0:         cf3.addColumn(QueryPath.column("three"), "D".getBytes(), 1);
commit:9aeef94
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf1 = ColumnFamily.create("Table1", "Standard1");
0:         ColumnFamily cf2 = ColumnFamily.create("Table1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf1 = ColumnFamily.create("Table1", "Standard1");
0:         ColumnFamily cf2 = ColumnFamily.create("Table1", "Standard1");
0:         ColumnFamily cf3 = ColumnFamily.create("Table2", "Standard2");
commit:88edbed
/////////////////////////////////////////////////////////////////////////
1: /*
1: * Licensed to the Apache Software Foundation (ASF) under one
1: * or more contributor license agreements.  See the NOTICE file
1: * distributed with this work for additional information
1: * regarding copyright ownership.  The ASF licenses this file
1: * to you under the Apache License, Version 2.0 (the
1: * "License"); you may not use this file except in compliance
1: * with the License.  You may obtain a copy of the License at
1: *
1: *    http://www.apache.org/licenses/LICENSE-2.0
1: *
1: * Unless required by applicable law or agreed to in writing,
1: * software distributed under the License is distributed on an
1: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1: * KIND, either express or implied.  See the License for the
1: * specific language governing permissions and limitations
1: * under the License.
1: */
commit:97fc5cb
/////////////////////////////////////////////////////////////////////////
0: import org.junit.Test;
1: 
0: import static junit.framework.Assert.assertEquals;
commit:362f287
/////////////////////////////////////////////////////////////////////////
0:         sc1.addColumn(new Column("subcolumn", "A".getBytes(), 0));
commit:afd3c27
commit:2ec1b06
/////////////////////////////////////////////////////////////////////////
1: package org.apache.cassandra.db;
1: 
0: import java.util.Arrays;
1: 
0: import org.testng.annotations.Test;
0: import static org.testng.Assert.assertEquals;
1: 
0: public class RowTest
1: {
1:     @Test
0:     public void testDiffColumnFamily()
1:     {
0:         ColumnFamily cf1 = new ColumnFamily("Standard1", "Standard");
0:         cf1.addColumn("one", "onev".getBytes(), 0);
1: 
0:         ColumnFamily cf2 = new ColumnFamily("Standard1", "Standard");
0:         cf2.delete(0, 0);
1: 
0:         ColumnFamily cfDiff = cf1.diff(cf2);
0:         assertEquals(cfDiff.getColumns().size(), 0);
0:         assertEquals(cfDiff.getMarkedForDeleteAt(), 0);
1:     }
1: 
1:     @Test
0:     public void testDiffSuperColumn()
1:     {
0:         SuperColumn sc1 = new SuperColumn("one");
0:         sc1.addColumn("subcolumn", new Column("subcolumn", "A".getBytes(), 0));
1: 
0:         SuperColumn sc2 = new SuperColumn("one");
0:         sc2.markForDeleteAt(0, 0);
1: 
0:         SuperColumn scDiff = (SuperColumn)sc1.diff(sc2);
0:         assertEquals(scDiff.getSubColumns().size(), 0);
0:         assertEquals(scDiff.getMarkedForDeleteAt(), 0);
1:     }
1: 
1:     @Test
0:     public void testRepair()
1:     {
0:         Row row1 = new Row();
0:         ColumnFamily cf1 = new ColumnFamily("Standard1", "Standard");
0:         cf1.addColumn("one", "A".getBytes(), 0);
0:         row1.addColumnFamily(cf1);
1: 
0:         Row row2 = new Row();
0:         ColumnFamily cf2 = new ColumnFamily("Standard1", "Standard");
0:         cf2.addColumn("one", "B".getBytes(), 1);
0:         cf2.addColumn("two", "C".getBytes(), 1);
0:         ColumnFamily cf3 = new ColumnFamily("Standard2", "Standard");
0:         cf3.addColumn("three", "D".getBytes(), 1);
0:         row2.addColumnFamily(cf2);
0:         row2.addColumnFamily(cf3);
1: 
0:         row1.repair(row2);
0:         cf1 = row1.getColumnFamily("Standard1");
0:         assert Arrays.equals(cf1.getColumn("one").value(), "B".getBytes());
0:         assert Arrays.equals(cf2.getColumn("two").value(), "C".getBytes());
0:         assert row1.getColumnFamily("Standard2") != null;
1:     }
1: }
author:Dave Brosius
-------------------------------------------------------------------------------
commit:83a43f1
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertEquals;
author:Johan Oskarsson
-------------------------------------------------------------------------------
commit:7860b13
/////////////////////////////////////////////////////////////////////////
0:         SuperColumn sc1 = new SuperColumn("one".getBytes(), AsciiType.instance, ClockType.Timestamp, null);
0:         SuperColumn sc2 = new SuperColumn("one".getBytes(), AsciiType.instance, ClockType.Timestamp, null);
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:7a75b63
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.SchemaLoader;
0: public class RowTest extends SchemaLoader
============================================================================