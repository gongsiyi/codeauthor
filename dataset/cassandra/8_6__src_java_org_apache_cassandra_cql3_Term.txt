1:655ccc3: /*
1:655ccc3:  * Licensed to the Apache Software Foundation (ASF) under one
1:655ccc3:  * or more contributor license agreements.  See the NOTICE file
1:655ccc3:  * distributed with this work for additional information
1:655ccc3:  * regarding copyright ownership.  The ASF licenses this file
1:655ccc3:  * to you under the Apache License, Version 2.0 (the
1:655ccc3:  * "License"); you may not use this file except in compliance
1:655ccc3:  * with the License.  You may obtain a copy of the License at
3:655ccc3:  *
1:07cf56f:  *     http://www.apache.org/licenses/LICENSE-2.0
1:655ccc3:  *
1:07cf56f:  * Unless required by applicable law or agreed to in writing, software
1:07cf56f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:07cf56f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:07cf56f:  * See the License for the specific language governing permissions and
1:07cf56f:  * limitations under the License.
3:655ccc3:  */
1:655ccc3: package org.apache.cassandra.cql3;
1:91bdf7f: 
1:655ccc3: import java.nio.ByteBuffer;
1:655ccc3: import java.util.List;
1:b251e7a: 
1:cb5897f: import org.apache.cassandra.cql3.functions.Function;
1:4ed0060: import org.apache.cassandra.db.marshal.AbstractType;
1:3a2faf9: import org.apache.cassandra.exceptions.InvalidRequestException;
1:e0adc16: import org.apache.cassandra.transport.ProtocolVersion;
1:b251e7a: 
1:31e669a: /**
1:31e669a:  * A CQL3 term, i.e. a column value with or without bind variables.
1:31e669a:  *
1:31e669a:  * A Term can be either terminal or non terminal. A term object is one that is typed and is obtained
1:31e669a:  * from a raw term (Term.Raw) by poviding the actual receiver to which the term is supposed to be a
1:31e669a:  * value of.
1:31e669a:  */
1:31e669a: public interface Term
1:91bdf7f: {
1:31e669a:     /**
1:31e669a:      * Collects the column specification for the bind variables in this Term.
1:31e669a:      * This is obviously a no-op if the term is Terminal.
1:31e669a:      *
1:37e9bce:      * @param boundNames the variables specification where to collect the
1:31e669a:      * bind variables of this term in.
1:31e669a:      */
1:37e9bce:     public void collectMarkerSpecification(VariableSpecifications boundNames);
1:b251e7a: 
1:31e669a:     /**
1:31e669a:      * Bind the values in this term to the values contained in {@code values}.
1:31e669a:      * This is obviously a no-op if the term is Terminal.
1:31e669a:      *
1:bef913a:      * @param options the values to bind markers to.
1:31e669a:      * @return the result of binding all the variables of this NonTerminal (or
1:31e669a:      * 'this' if the term is terminal).
1:31e669a:      */
1:9872b74:     public Terminal bind(QueryOptions options) throws InvalidRequestException;
1:31e669a: 
1:31e669a:     /**
1:31e669a:      * A shorter for bind(values).get().
1:31e669a:      * We expose it mainly because for constants it can avoids allocating a temporary
1:31e669a:      * object between the bind and the get (note that we still want to be able
1:31e669a:      * to separate bind and get for collections).
1:31e669a:      */
1:9872b74:     public ByteBuffer bindAndGet(QueryOptions options) throws InvalidRequestException;
1:31e669a: 
1:31e669a:     /**
1:ce4e4b9:      * Whether or not that term contains at least one bind marker.
1:ce4e4b9:      *
1:ce4e4b9:      * Note that this is slightly different from being or not a NonTerminal,
1:ce4e4b9:      * because calls to non pure functions will be NonTerminal (see #5616)
1:ce4e4b9:      * even if they don't have bind markers.
1:ce4e4b9:      */
1:ce4e4b9:     public abstract boolean containsBindMarker();
1:ce4e4b9: 
1:89464ea:     public void addFunctionsTo(List<Function> functions);
1:a67f779: 
1:ce4e4b9:     /**
1:31e669a:      * A parsed, non prepared (thus untyped) term.
1:31e669a:      *
1:31e669a:      * This can be one of:
1:31e669a:      *   - a constant
1:31e669a:      *   - a collection literal
1:31e669a:      *   - a function call
1:31e669a:      *   - a marker
1:31e669a:      */
1:5a4253b:     public abstract class Raw implements AssignmentTestable
1:b251e7a:     {
1:31e669a:         /**
1:31e669a:          * This method validates this RawTerm is valid for provided column
1:31e669a:          * specification and "prepare" this RawTerm, returning the resulting
1:31e669a:          * prepared Term.
1:31e669a:          *
1:31e669a:          * @param receiver the "column" this RawTerm is supposed to be a value of. Note
1:31e669a:          * that the ColumnSpecification may not correspond to a real column in the
1:31e669a:          * case this RawTerm describe a list index or a map key, etc...
1:31e669a:          * @return the prepared term.
1:31e669a:          */
1:5a4253b:         public abstract Term prepare(String keyspace, ColumnSpecification receiver) throws InvalidRequestException;
1:91bdf7f: 
3:655ccc3:         /**
1:5a4253b:          * @return a String representation of the raw term that can be used when reconstructing a CQL query string.
1:655ccc3:          */
1:5a4253b:         public abstract String getText();
1:91bdf7f: 
1:4ed0060:         /**
1:4ed0060:          * The type of the {@code term} if it can be infered.
1:4ed0060:          *
1:4ed0060:          * @param keyspace the keyspace on which the statement containing this term is on.
1:4ed0060:          * @return the type of this {@code Term} if inferrable, or {@code null}
1:4ed0060:          * otherwise (for instance, the type isn't inferable for a bind marker. Even for
1:4ed0060:          * literals, the exact type is not inferrable since they are valid for many
1:4ed0060:          * different types and so this will return {@code null} too).
1:4ed0060:          */
1:4ed0060:         public abstract AbstractType<?> getExactTypeIfKnown(String keyspace);
1:4ed0060: 
3:655ccc3:         @Override
1:655ccc3:         public String toString()
1:b251e7a:         {
1:5a4253b:             return getText();
1:b251e7a:         }
1:b251e7a:     }
1:b251e7a: 
1:5a4253b:     public abstract class MultiColumnRaw extends Term.Raw
1:a67f779:     {
1:5a4253b:         public abstract Term prepare(String keyspace, List<? extends ColumnSpecification> receiver) throws InvalidRequestException;
1:a67f779:     }
1:a67f779: 
1:655ccc3:     /**
1:ce4e4b9:      * A terminal term, one that can be reduced to a byte buffer directly.
1:ce4e4b9:      *
1:ce4e4b9:      * This includes most terms that don't have a bind marker (an exception
1:ce4e4b9:      * being delayed call for non pure function that are NonTerminal even
1:ce4e4b9:      * if they don't have bind markers).
1:655ccc3:      *
1:31e669a:      * This can be only one of:
1:31e669a:      *   - a constant value
1:31e669a:      *   - a collection value
1:655ccc3:      *
1:31e669a:      * Note that a terminal term will always have been type checked, and thus
1:31e669a:      * consumer can (and should) assume so.
1:655ccc3:      */
1:31e669a:     public abstract class Terminal implements Term
1:a67f779:     {
1:37e9bce:         public void collectMarkerSpecification(VariableSpecifications boundNames) {}
1:9872b74:         public Terminal bind(QueryOptions options) { return this; }
1:a67f779: 
1:89464ea:         public void addFunctionsTo(List<Function> functions)
1:a67f779:         {
1:a67f779:         }
1:a67f779: 
1:ce4e4b9:         // While some NonTerminal may not have bind markers, no Term can be Terminal
1:ce4e4b9:         // with a bind marker
1:ce4e4b9:         public boolean containsBindMarker()
1:ce4e4b9:         {
1:ce4e4b9:             return false;
1:ce4e4b9:         }
1:ce4e4b9: 
1:31e669a:         /**
1:31e669a:          * @return the serialized value of this terminal.
1:c7b02d1:          * @param protocolVersion
1:31e669a:          */
1:e0adc16:         public abstract ByteBuffer get(ProtocolVersion protocolVersion) throws InvalidRequestException;
1:31e669a: 
1:9872b74:         public ByteBuffer bindAndGet(QueryOptions options) throws InvalidRequestException
1:a67f779:         {
1:c7b02d1:             return get(options.getProtocolVersion());
1:a67f779:         }
1:a67f779:     }
1:a67f779: 
1:4349638:     public abstract class MultiItemTerminal extends Terminal
1:91bdf7f:     {
1:4349638:         public abstract List<ByteBuffer> getElements();
1:91bdf7f:     }
1:91bdf7f: 
1:655ccc3:     /**
1:ce4e4b9:      * A non terminal term, i.e. a term that can only be reduce to a byte buffer
1:ce4e4b9:      * at execution time.
1:655ccc3:      *
1:ce4e4b9:      * We have the following type of NonTerminal:
1:31e669a:      *   - marker for a constant value
1:31e669a:      *   - marker for a collection value (list, set, map)
1:31e669a:      *   - a function having bind marker
1:ce4e4b9:      *   - a non pure function (even if it doesn't have bind marker - see #5616)
1:655ccc3:      */
1:31e669a:     public abstract class NonTerminal implements Term
1:91bdf7f:     {
1:9872b74:         public ByteBuffer bindAndGet(QueryOptions options) throws InvalidRequestException
1:8b81c8f:         {
1:9872b74:             Terminal t = bind(options);
1:c7b02d1:             return t == null ? null : t.get(options.getProtocolVersion());
1:31e669a:         }
1:91bdf7f:     }
1:91bdf7f: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:e0adc16
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.transport.ProtocolVersion;
/////////////////////////////////////////////////////////////////////////
1:         public abstract ByteBuffer get(ProtocolVersion protocolVersion) throws InvalidRequestException;
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:4ed0060
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.marshal.AbstractType;
/////////////////////////////////////////////////////////////////////////
1:         /**
1:          * The type of the {@code term} if it can be infered.
1:          *
1:          * @param keyspace the keyspace on which the statement containing this term is on.
1:          * @return the type of this {@code Term} if inferrable, or {@code null}
1:          * otherwise (for instance, the type isn't inferable for a bind marker. Even for
1:          * literals, the exact type is not inferrable since they are valid for many
1:          * different types and so this will return {@code null} too).
1:          */
1:         public abstract AbstractType<?> getExactTypeIfKnown(String keyspace);
1: 
commit:44fa12e
/////////////////////////////////////////////////////////////////////////
0:     public interface Raw extends AssignmentTestable
commit:9872b74
/////////////////////////////////////////////////////////////////////////
1:     public Terminal bind(QueryOptions options) throws InvalidRequestException;
/////////////////////////////////////////////////////////////////////////
1:     public ByteBuffer bindAndGet(QueryOptions options) throws InvalidRequestException;
/////////////////////////////////////////////////////////////////////////
1:         public Terminal bind(QueryOptions options) { return this; }
/////////////////////////////////////////////////////////////////////////
0:         public abstract ByteBuffer get(QueryOptions options);
1:         public ByteBuffer bindAndGet(QueryOptions options) throws InvalidRequestException
0:             return get(options);
/////////////////////////////////////////////////////////////////////////
1:         public ByteBuffer bindAndGet(QueryOptions options) throws InvalidRequestException
1:             Terminal t = bind(options);
0:             return t == null ? null : t.get(options);
commit:d63d07b
/////////////////////////////////////////////////////////////////////////
0:         public Term prepare(String keyspace, ColumnSpecification receiver) throws InvalidRequestException;
commit:37e9bce
/////////////////////////////////////////////////////////////////////////
1:      * @param boundNames the variables specification where to collect the
1:     public void collectMarkerSpecification(VariableSpecifications boundNames);
/////////////////////////////////////////////////////////////////////////
1:         public void collectMarkerSpecification(VariableSpecifications boundNames) {}
commit:ce4e4b9
/////////////////////////////////////////////////////////////////////////
1:      * Whether or not that term contains at least one bind marker.
1:      *
1:      * Note that this is slightly different from being or not a NonTerminal,
1:      * because calls to non pure functions will be NonTerminal (see #5616)
1:      * even if they don't have bind markers.
1:      */
1:     public abstract boolean containsBindMarker();
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:      * A terminal term, one that can be reduced to a byte buffer directly.
1:      *
1:      * This includes most terms that don't have a bind marker (an exception
1:      * being delayed call for non pure function that are NonTerminal even
1:      * if they don't have bind markers).
/////////////////////////////////////////////////////////////////////////
1:         // While some NonTerminal may not have bind markers, no Term can be Terminal
1:         // with a bind marker
1:         public boolean containsBindMarker()
1:         {
1:             return false;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:      * A non terminal term, i.e. a term that can only be reduce to a byte buffer
1:      * at execution time.
1:      * We have the following type of NonTerminal:
1:      *   - a non pure function (even if it doesn't have bind marker - see #5616)
commit:cf84ea7
/////////////////////////////////////////////////////////////////////////
0:             Terminal t = bind(values);
0:             return t == null ? null : t.get();
commit:31e669a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * A CQL3 term, i.e. a column value with or without bind variables.
1:  *
1:  * A Term can be either terminal or non terminal. A term object is one that is typed and is obtained
1:  * from a raw term (Term.Raw) by poviding the actual receiver to which the term is supposed to be a
1:  * value of.
1:  */
1: public interface Term
1:     /**
1:      * Collects the column specification for the bind variables in this Term.
1:      * This is obviously a no-op if the term is Terminal.
1:      *
0:      * @param boundNames the list of column specification where to collect the
1:      * bind variables of this term in.
1:      */
0:     public void collectMarkerSpecification(ColumnSpecification[] boundNames);
1:     /**
1:      * Bind the values in this term to the values contained in {@code values}.
1:      * This is obviously a no-op if the term is Terminal.
1:      *
0:      * @param values the values to bind markers to.
1:      * @return the result of binding all the variables of this NonTerminal (or
1:      * 'this' if the term is terminal).
1:      */
0:     public Terminal bind(List<ByteBuffer> values) throws InvalidRequestException;
1: 
1:     /**
1:      * A shorter for bind(values).get().
1:      * We expose it mainly because for constants it can avoids allocating a temporary
1:      * object between the bind and the get (note that we still want to be able
1:      * to separate bind and get for collections).
1:      */
0:     public ByteBuffer bindAndGet(List<ByteBuffer> values) throws InvalidRequestException;
1: 
1:     /**
1:      * A parsed, non prepared (thus untyped) term.
1:      *
1:      * This can be one of:
1:      *   - a constant
1:      *   - a collection literal
1:      *   - a function call
1:      *   - a marker
1:      */
0:     public interface Raw extends AssignementTestable
1:         /**
1:          * This method validates this RawTerm is valid for provided column
1:          * specification and "prepare" this RawTerm, returning the resulting
1:          * prepared Term.
1:          *
1:          * @param receiver the "column" this RawTerm is supposed to be a value of. Note
1:          * that the ColumnSpecification may not correspond to a real column in the
1:          * case this RawTerm describe a list index or a map key, etc...
1:          * @return the prepared term.
1:          */
0:         public Term prepare(ColumnSpecification receiver) throws InvalidRequestException;
0:      * A terminal term, i.e. one without any bind marker.
1:      * This can be only one of:
1:      *   - a constant value
1:      *   - a collection value
1:      * Note that a terminal term will always have been type checked, and thus
1:      * consumer can (and should) assume so.
1:     public abstract class Terminal implements Term
0:         public void collectMarkerSpecification(ColumnSpecification[] boundNames) {}
0:         public Terminal bind(List<ByteBuffer> values) { return this; }
1:         /**
1:          * @return the serialized value of this terminal.
1:          */
0:         public abstract ByteBuffer get();
1: 
0:         public ByteBuffer bindAndGet(List<ByteBuffer> values) throws InvalidRequestException
0:             return get();
0:      * A non terminal term, i.e. one that contains at least one bind marker.
0:      * We distinguish between the following type of NonTerminal:
1:      *   - marker for a constant value
1:      *   - marker for a collection value (list, set, map)
1:      *   - a function having bind marker
1:     public abstract class NonTerminal implements Term
0:         public ByteBuffer bindAndGet(List<ByteBuffer> values) throws InvalidRequestException
0:             return bind(values).get();
1:         }
commit:b251e7a
/////////////////////////////////////////////////////////////////////////
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
1: 
/////////////////////////////////////////////////////////////////////////
0:     private static final Logger logger = LoggerFactory.getLogger(Term.class);
1: 
/////////////////////////////////////////////////////////////////////////
0:     // For transition post-5198, see below
0:     private static volatile boolean stringAsBlobWarningLogged = false;
1: 
/////////////////////////////////////////////////////////////////////////
0:             // Blobs should now be inputed as hexadecimal constants. However, to allow people to upgrade, we still allow
0:             // blob-as-strings, even though it is deprecated (see #5198).
0:             if (type == Type.STRING && validator instanceof BytesType)
1:             {
0:                 if (!stringAsBlobWarningLogged)
1:                 {
0:                     stringAsBlobWarningLogged = true;
0:                     logger.warn("Inputing CLQ3 blobs as strings (like %s = '%s') is now deprecated and will be removed in a future version. "
0:                               + "You should convert client code to use a blob constant (%s = %s) instead (see http://cassandra.apache.org/doc/cql3/CQL.html changelog section for more info).",
0:                               identifier, text, identifier, "0x" + text);
1:                 }
0:                 return;
1:             }
1: 
commit:a67f779
/////////////////////////////////////////////////////////////////////////
0: import java.util.Set;
0: import org.apache.cassandra.db.marshal.BytesType;
/////////////////////////////////////////////////////////////////////////
0:         STRING, INTEGER, UUID, FLOAT, BOOLEAN, HEX, QMARK;
0:             if (type == CqlParser.STRING_LITERAL)
/////////////////////////////////////////////////////////////////////////
0:             else if (type == CqlParser.BOOLEAN)
0:             else if (type == CqlParser.HEXNUMBER)
0:                 return HEX;
0:             throw new AssertionError();
/////////////////////////////////////////////////////////////////////////
0:     // This is a hack for the timeuuid functions (minTimeuuid, maxTimeuuid, now) because instead of handling them as
0:     // true function we let the TimeUUID.fromString() method handle it. We should probably clean that up someday
0:     private final boolean skipTypeValidation;
1: 
0:     private Term(String text, Type type, int bindIndex, boolean isToken, boolean skipTypeValidation)
0:         this.text = text;
0:         this.skipTypeValidation = skipTypeValidation;
1:     }
1: 
0:     public Term(String text, Type type, boolean skipTypeValidation)
1:     {
0:         this(text, type, -1, false, skipTypeValidation);
0:         this(text, type, -1, false, false);
/////////////////////////////////////////////////////////////////////////
0:         this(text, Type.forInt(type), index, false, false);
0:         return new Term(t.text, t.type, t.bindIndex, true, false);
/////////////////////////////////////////////////////////////////////////
1:             {
0:                 // BytesType doesn't want it's input prefixed by '0x'.
0:                 if (type == Type.HEX && validator instanceof BytesType)
0:                     return validator.fromString(text.substring(2));
1:             }
/////////////////////////////////////////////////////////////////////////
0:     public void validateType(String identifier, AbstractType<?> validator) throws InvalidRequestException
1:     {
0:         if (skipTypeValidation)
0:             return;
1: 
0:         Set<Type> supported = validator.supportedCQL3Constants();
0:         // Treat null specially as this mean "I don't have a supportedCQL3Type method"
0:         if (supported == null)
0:             return;
1: 
0:         if (!supported.contains(type))
1:         {
0:             // TODO: Ideallly we'd keep the declared CQL3 type of columns and use that in the following message, instead of the AbstracType class name.
0:             throw new InvalidRequestException(String.format("Invalid %s constant for %s of type %s", type, identifier, validator.asCQL3Type()));
1:         }
1:     }
1: 
commit:ff817cf
/////////////////////////////////////////////////////////////////////////
0:         STRING, INTEGER, UUID, FLOAT, BOOLEAN, QMARK;
/////////////////////////////////////////////////////////////////////////
0:             else if (type == CqlParser.K_TRUE || type == CqlParser.K_FALSE)
0:                 return BOOLEAN;
commit:e232407
/////////////////////////////////////////////////////////////////////////
0:             // We don't yet support null values in prepared statements
0:             if (value == null)
0:                 throw new InvalidRequestException("Invalid null value for prepared variable " + bindIndex);
commit:3a2faf9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.exceptions.ConfigurationException;
1: import org.apache.cassandra.exceptions.InvalidRequestException;
commit:daac1ed
/////////////////////////////////////////////////////////////////////////
commit:2b62df2
/////////////////////////////////////////////////////////////////////////
0: public class Term
commit:91bdf7f
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collections;
0: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
0: public class Term implements Value
0:     public enum Type
1:     {
0:         STRING, INTEGER, UUID, FLOAT, QMARK;
1: 
0:         static Type forInt(int type)
1:         {
0:             if ((type == CqlParser.STRING_LITERAL) || (type == CqlParser.IDENT))
0:                 return STRING;
0:             else if (type == CqlParser.INTEGER)
0:                 return INTEGER;
0:             else if (type == CqlParser.UUID)
0:                 return UUID;
0:             else if (type == CqlParser.FLOAT)
0:                 return FLOAT;
0:             else if (type == CqlParser.QMARK)
0:                 return QMARK;
1: 
0:             // FIXME: handled scenario that should never occur.
0:             return null;
1:         }
1:     }
1: 
0:     private final Type type;
0:     private Term(String text, Type type, int bindIndex, boolean isToken)
/////////////////////////////////////////////////////////////////////////
0:     public Term(String text, Type type)
/////////////////////////////////////////////////////////////////////////
0:         this(text, Type.forInt(type));
0:     public Term(long value, Type type)
0:         this(text, Type.forInt(type), index, false);
/////////////////////////////////////////////////////////////////////////
0:         if (!(isToken || type == Type.STRING))
/////////////////////////////////////////////////////////////////////////
0:     public Type getType()
0:         return type == Type.QMARK;
1:     }
1: 
0:     public List<Term> asList()
1:     {
0:         return Collections.singletonList(this);
/////////////////////////////////////////////////////////////////////////
0:         if (type==Type.QMARK) return false; // markers are never equal
/////////////////////////////////////////////////////////////////////////
commit:8b81c8f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.ConfigurationException;
0: import org.apache.cassandra.dht.IPartitioner;
0: import org.apache.cassandra.dht.Token;
/////////////////////////////////////////////////////////////////////////
0:     public final boolean isToken;
0:     private Term(String text, TermType type, int bindIndex, boolean isToken)
0:         this.bindIndex = bindIndex;
0:         this.isToken = isToken;
0:     }
0: 
0:     public Term(String text, TermType type)
1:     {
0:         this(text, type, -1, false);
/////////////////////////////////////////////////////////////////////////
0:         this(text, TermType.forInt(type), index, false);
0:     }
0: 
0:     public static Term tokenOf(Term t)
0:     {
0:         return new Term(t.text, t.type, t.bindIndex, true);
/////////////////////////////////////////////////////////////////////////
0:         return isToken ? "token(" + text + ")" : text;
/////////////////////////////////////////////////////////////////////////
0:     public Token getAsToken(AbstractType<?> validator, List<ByteBuffer> variables, IPartitioner<?> p) throws InvalidRequestException
0:         if (!(isToken || type == TermType.STRING))
0:             throw new InvalidRequestException("Invalid value for token (use a string literal of the token value or the token() function)");
0:         try
0:         {
0:             if (isToken)
0:             {
0:                 ByteBuffer value = getByteBuffer(validator, variables);
0:                 return p.getToken(value);
0:             }
0:             else
0:             {
0:                 p.getTokenFactory().validate(text);
0:                 return p.getTokenFactory().fromString(text);
0:             }
0:         }
0:         catch (ConfigurationException e)
0:         {
0:             throw new InvalidRequestException(e.getMessage());
0:         }
/////////////////////////////////////////////////////////////////////////
0:         return String.format("Term(%s, type=%s%s)", getText(), type, isToken ? ", isToken" : "");
0:         int result = 1 + (isToken ? 1 : 0);
/////////////////////////////////////////////////////////////////////////
0:         if (isToken != other.isToken)
0:             return false;
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
commit:e10eb19
/////////////////////////////////////////////////////////////////////////
0:     public final int bindIndex;
0:         this.bindIndex = -1;
/////////////////////////////////////////////////////////////////////////
0:         this(text, TermType.forInt(type));
/////////////////////////////////////////////////////////////////////////
0:         this.text = text == null ? "" : text;
0:         this.type = TermType.forInt(type);
commit:655ccc3
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
1:  */
1: package org.apache.cassandra.cql3;
0: 
1: import java.nio.ByteBuffer;
1: import java.util.List;
0: 
0: import org.apache.cassandra.db.marshal.AbstractType;
0: import org.apache.cassandra.db.marshal.AsciiType;
0: import org.apache.cassandra.db.marshal.FloatType;
0: import org.apache.cassandra.db.marshal.IntegerType;
0: import org.apache.cassandra.db.marshal.LexicalUUIDType;
0: import org.apache.cassandra.db.marshal.MarshalException;
0: import org.apache.cassandra.thrift.InvalidRequestException;
0: 
0: /** A term parsed from a CQL statement. */
0: public class Term
0: {
0:     private final String text;
0:     private final TermType type;
0:     private int bindIndex = -1;
0: 
0:     public Term(String text, TermType type)
0:     {
0:         this.text = text == null ? "" : text;
0:         this.type = type;
0:     }
0: 
1:     /**
0:      * Create new Term instance from a string, and an integer that corresponds
0:      * with the token ID from CQLParser.
1:      *
0:      * @param text the text representation of the term.
0:      * @param type the term's type as an integer token ID.
1:      */
0:     public Term(String text, int type)
0:     {
0:         this(text == null ? "" : text, TermType.forInt(type));
0:     }
0: 
0:     public Term(long value, TermType type)
0:     {
0:         this(String.valueOf(value), type);
0:     }
0: 
0:     public Term(String text, int type, int index)
0:     {
0:         this(text, type);
0:         this.bindIndex = index;
0:     }
0: 
1:     /**
0:      * Returns the text parsed to create this term.
1:      *
0:      * @return the string term acquired from a CQL statement.
1:      */
0:     public String getText()
0:     {
0:         return text;
0:     }
0: 
1:     /**
0:      * Returns the typed value, serialized to a ByteBuffer according to a
0:      * comparator/validator.
1:      *
0:      * @return a ByteBuffer of the value.
0:      * @throws InvalidRequestException if unable to coerce the string to its type.
1:      */
0:     public ByteBuffer getByteBuffer(AbstractType<?> validator, List<ByteBuffer> variables) throws InvalidRequestException
0:     {
0:         try
0:         {
0:             if (!isBindMarker())
0:                 return validator.fromString(text);
0: 
0:             // must be a marker term so check for a CqlBindValue stored in the term
0:             if (bindIndex == -1)
0:                 throw new AssertionError("a marker Term was encountered with no index value");
0: 
0:             ByteBuffer value = variables.get(bindIndex);
0:             validator.validate(value);
0:             return value;
0:         }
0:         catch (MarshalException e)
0:         {
0:             throw new InvalidRequestException(e.getMessage());
0:         }
0:     }
0: 
1:     /**
0:      * Returns the typed value, serialized to a ByteBuffer.
1:      *
0:      * @return a ByteBuffer of the value.
0:      * @throws InvalidRequestException if unable to coerce the string to its type.
1:      */
0:     public ByteBuffer getByteBuffer() throws InvalidRequestException
0:     {
0:         switch (type)
0:         {
0:             case STRING:
0:                 return AsciiType.instance.fromString(text);
0:             case INTEGER:
0:                 return IntegerType.instance.fromString(text);
0:             case UUID:
0:                 // we specifically want the Lexical class here, not "UUIDType," because we're supposed to have
0:                 // a uuid-shaped string here, and UUIDType also accepts integer or date strings (and turns them into version 1 uuids).
0:                 return LexicalUUIDType.instance.fromString(text);
0:             case FLOAT:
0:               return FloatType.instance.fromString(text);
0:         }
0: 
0:         throw new IllegalStateException();
0:     }
0: 
1:     /**
0:      * Obtain the term's type.
1:      *
0:      * @return the type
1:      */
0:     public TermType getType()
0:     {
0:         return type;
0:     }
0: 
0:     public boolean isBindMarker()
0:     {
0:         return type == TermType.QMARK;
0:     }
0: 
1:     @Override
1:     public String toString()
0:     {
0:         return String.format("Term(%s, type=%s)", getText(), type);
0:     }
0: 
1:     @Override
0:     public int hashCode()
0:     {
0:         final int prime = 31;
0:         int result = 1;
0:         result = prime * result + ((text == null) ? 0 : text.hashCode());
0:         result = prime * result + ((type == null) ? 0 : type.hashCode());
0:         return result;
0:     }
0: 
1:     @Override
0:     public boolean equals(Object obj)
0:     {
0:         if (this == obj)
0:             return true;
0:         if (obj == null)
0:             return false;
0:         if (getClass() != obj.getClass())
0:             return false;
0:         Term other = (Term) obj;
0:         if (type==TermType.QMARK) return false; // markers are never equal
0:         if (text == null)
0:         {
0:             if (other.text != null)
0:                 return false;
0:         } else if (!text.equals(other.text))
0:             return false;
0:         if (type != other.type)
0:             return false;
0:         return true;
0:     }
0: }
0: 
0: enum TermType
0: {
0:     STRING, INTEGER, UUID, FLOAT, QMARK;
0: 
0:     static TermType forInt(int type)
0:     {
0:         if ((type == CqlParser.STRING_LITERAL) || (type == CqlParser.IDENT))
0:             return STRING;
0:         else if (type == CqlParser.INTEGER)
0:             return INTEGER;
0:         else if (type == CqlParser.UUID)
0:           return UUID;
0:         else if (type == CqlParser.FLOAT)
0:             return FLOAT;
0:         else if (type == CqlParser.QMARK)
0:             return QMARK;
0: 
0:         // FIXME: handled scenario that should never occur.
0:         return null;
0:     }
0: }
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:89464ea
/////////////////////////////////////////////////////////////////////////
1:     public void addFunctionsTo(List<Function> functions);
/////////////////////////////////////////////////////////////////////////
1:         public void addFunctionsTo(List<Function> functions)
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:5a4253b
/////////////////////////////////////////////////////////////////////////
1:     public abstract class Raw implements AssignmentTestable
/////////////////////////////////////////////////////////////////////////
1:         public abstract Term prepare(String keyspace, ColumnSpecification receiver) throws InvalidRequestException;
0: 
0:         /**
1:          * @return a String representation of the raw term that can be used when reconstructing a CQL query string.
0:          */
1:         public abstract String getText();
0: 
0:         @Override
0:         public String toString()
0:         {
1:             return getText();
0:         }
1:     public abstract class MultiColumnRaw extends Term.Raw
1:         public abstract Term prepare(String keyspace, List<? extends ColumnSpecification> receiver) throws InvalidRequestException;
commit:c7b02d1
/////////////////////////////////////////////////////////////////////////
1:          * @param protocolVersion
0:         public abstract ByteBuffer get(int protocolVersion) throws InvalidRequestException;
1:             return get(options.getProtocolVersion());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             return t == null ? null : t.get(options.getProtocolVersion());
commit:fb4356a
commit:ee55f36
/////////////////////////////////////////////////////////////////////////
0:     public interface CollectionTerminal
0:     {
0:         /** Gets the value of the collection when serialized with the given protocol version format */
0:         public ByteBuffer getWithProtocolVersion(int protocolVersion);
0:     }
0: 
commit:bf52190
commit:4349638
/////////////////////////////////////////////////////////////////////////
0:     public interface MultiColumnRaw extends Raw
0:     {
0:         public Term prepare(List<? extends ColumnSpecification> receiver) throws InvalidRequestException;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:     public abstract class MultiItemTerminal extends Terminal
0:     {
1:         public abstract List<ByteBuffer> getElements();
0:     }
0: 
author:Sam Tunnicliffe
-------------------------------------------------------------------------------
commit:d9836e0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:cb5897f
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collections;
0: import java.util.Set;
1: import org.apache.cassandra.cql3.functions.Function;
/////////////////////////////////////////////////////////////////////////
0:     Iterable<Function> getFunctions();
0: 
/////////////////////////////////////////////////////////////////////////
0:         public Set<Function> getFunctions()
0:         {
0:             return Collections.emptySet();
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0:         // TODO - this is not necessarily false, yet isn't overridden in concrete classes
0:         // representing collection literals
0:         // e,g "UPDATE table SET map_col = { key_function() : val_function() }) WHERE ....
author:Robert Stupp
-------------------------------------------------------------------------------
commit:b4d7f3b
/////////////////////////////////////////////////////////////////////////
0:     boolean usesFunction(String ksName, String functionName);
0: 
/////////////////////////////////////////////////////////////////////////
0:         public boolean usesFunction(String ksName, String functionName)
0:         {
0:             return false;
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0:         public boolean usesFunction(String ksName, String functionName)
0:         {
0:             return false;
0:         }
0: 
author:Dave Brosius
-------------------------------------------------------------------------------
commit:bef913a
/////////////////////////////////////////////////////////////////////////
1:      * @param options the values to bind markers to.
commit:56f35db
/////////////////////////////////////////////////////////////////////////
commit:95f94a4
/////////////////////////////////////////////////////////////////////////
commit:f650d3e
/////////////////////////////////////////////////////////////////////////
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:4357676
============================================================================