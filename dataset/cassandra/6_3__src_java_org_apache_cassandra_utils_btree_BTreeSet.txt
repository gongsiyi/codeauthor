1:9f14856: /*
1:9f14856:  * Licensed to the Apache Software Foundation (ASF) under one
1:9f14856:  * or more contributor license agreements.  See the NOTICE file
1:9f14856:  * distributed with this work for additional information
1:9f14856:  * regarding copyright ownership.  The ASF licenses this file
1:9f14856:  * to you under the Apache License, Version 2.0 (the
1:9f14856:  * "License"); you may not use this file except in compliance
1:9f14856:  * with the License.  You may obtain a copy of the License at
1:9f14856:  *
1:9f14856:  *   http://www.apache.org/licenses/LICENSE-2.0
1:9f14856:  *
1:9f14856:  * Unless required by applicable law or agreed to in writing,
1:9f14856:  * software distributed under the License is distributed on an
1:9f14856:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:9f14856:  * KIND, either express or implied.  See the License for the
1:9f14856:  * specific language governing permissions and limitations
1:9f14856:  * under the License.
1:9f14856:  */
1:5250d7f: package org.apache.cassandra.utils.btree;
1:5250d7f: 
1:5250d7f: import java.util.*;
1:5250d7f: 
1:5250d7f: import com.google.common.collect.ImmutableList;
1:5250d7f: import com.google.common.collect.Ordering;
1:5250d7f: 
1:639d4b2: import org.apache.cassandra.utils.btree.BTree.Dir;
1:639d4b2: 
1:5250d7f: import static org.apache.cassandra.utils.btree.BTree.findIndex;
1:5250d7f: 
1:5250d7f: public class BTreeSet<V> implements NavigableSet<V>, List<V>
1:5250d7f: {
1:5250d7f:     protected final Comparator<? super V> comparator;
1:5250d7f:     protected final Object[] tree;
1:5250d7f: 
1:5250d7f:     public BTreeSet(Object[] tree, Comparator<? super V> comparator)
1:5250d7f:     {
1:5250d7f:         this.tree = tree;
1:5250d7f:         this.comparator = comparator;
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     public BTreeSet<V> update(Collection<V> updateWith)
1:5250d7f:     {
1:5250d7f:         return new BTreeSet<>(BTree.update(tree, comparator, updateWith, UpdateFunction.<V>noOp()), comparator);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public Comparator<? super V> comparator()
1:5250d7f:     {
1:5250d7f:         return comparator;
1:5250d7f:     }
1:5250d7f: 
1:639d4b2:     protected BTreeSearchIterator<V, V> slice(Dir dir)
1:5250d7f:     {
1:639d4b2:         return BTree.slice(tree, comparator, dir);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     public Object[] tree()
1:5250d7f:     {
1:5250d7f:         return tree;
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     /**
1:5250d7f:      * The index of the item within the list, or its insertion point otherwise. i.e. binarySearch semantics
2:5250d7f:      */
1:5250d7f:     public int indexOf(Object item)
1:5250d7f:     {
1:5250d7f:         return findIndex(tree, comparator, (V) item);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     /**
1:5250d7f:      * The converse of indexOf: provided an index between 0 and size, returns the i'th item, in set order.
1:5250d7f:      */
1:5250d7f:     public V get(int index)
1:5250d7f:     {
1:5250d7f:         return BTree.<V>findByIndex(tree, index);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     public int lastIndexOf(Object o)
1:5250d7f:     {
1:5250d7f:         return indexOf(o);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     public BTreeSet<V> subList(int fromIndex, int toIndex)
1:5250d7f:     {
1:5250d7f:         return new BTreeRange<V>(tree, comparator, fromIndex, toIndex - 1);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public int size()
1:5250d7f:     {
1:5250d7f:         return BTree.size(tree);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public boolean isEmpty()
1:5250d7f:     {
1:5250d7f:         return BTree.isEmpty(tree);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public BTreeSearchIterator<V, V> iterator()
1:5250d7f:     {
1:639d4b2:         return slice(Dir.ASC);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public BTreeSearchIterator<V, V> descendingIterator()
1:5250d7f:     {
1:639d4b2:         return slice(Dir.DESC);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public Object[] toArray()
1:5250d7f:     {
1:5250d7f:         return toArray(new Object[0]);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public <T> T[] toArray(T[] a)
1:5250d7f:     {
1:5250d7f:         return toArray(a, 0);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     public <T> T[] toArray(T[] a, int offset)
1:5250d7f:     {
1:5250d7f:         int size = size();
1:5250d7f:         if (a.length < size + offset)
1:5250d7f:             a = Arrays.copyOf(a, size);
1:5250d7f:         BTree.toArray(tree, a, offset);
1:5250d7f:         return a;
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     public Spliterator<V> spliterator()
1:5250d7f:     {
1:5250d7f:         return Spliterators.spliterator(this, Spliterator.ORDERED | Spliterator.DISTINCT | Spliterator.IMMUTABLE | Spliterator.NONNULL | Spliterator.SIZED);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public BTreeSet<V> subSet(V fromElement, boolean fromInclusive, V toElement, boolean toInclusive)
1:5250d7f:     {
1:5250d7f:         return new BTreeRange<>(tree, comparator, fromElement, fromInclusive, toElement, toInclusive);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public BTreeSet<V> headSet(V toElement, boolean inclusive)
1:5250d7f:     {
1:5250d7f:         return new BTreeRange<>(tree, comparator, null, true, toElement, inclusive);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public BTreeSet<V> tailSet(V fromElement, boolean inclusive)
1:5250d7f:     {
1:5250d7f:         return new BTreeRange<>(tree, comparator, fromElement, inclusive, null, true);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public SortedSet<V> subSet(V fromElement, V toElement)
1:5250d7f:     {
1:5250d7f:         return subSet(fromElement, true, toElement, false);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public SortedSet<V> headSet(V toElement)
1:5250d7f:     {
1:5250d7f:         return headSet(toElement, false);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public SortedSet<V> tailSet(V fromElement)
1:5250d7f:     {
1:5250d7f:         return tailSet(fromElement, true);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public BTreeSet<V> descendingSet()
1:5250d7f:     {
1:c29001b:         return new BTreeRange<V>(this.tree, this.comparator).descendingSet();
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public V first()
1:5250d7f:     {
1:5250d7f:         return get(0);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public V last()
1:5250d7f:     {
1:5250d7f:         return get(size() - 1);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public V lower(V v)
1:5250d7f:     {
1:5250d7f:         return BTree.lower(tree, comparator, v);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public V floor(V v)
1:5250d7f:     {
1:5250d7f:         return BTree.floor(tree, comparator, v);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public V ceiling(V v)
1:5250d7f:     {
1:5250d7f:         return BTree.ceil(tree, comparator, v);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public V higher(V v)
1:5250d7f:     {
1:5250d7f:         return BTree.higher(tree, comparator, v);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public boolean contains(Object o)
1:5250d7f:     {
1:5250d7f:         return indexOf((V) o) >= 0;
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public boolean containsAll(Collection<?> c)
1:5250d7f:     {
1:5250d7f:         // TODO: if we ever use this method, it can be specialized quite easily for SortedSet arguments
1:5250d7f:         for (Object o : c)
1:5250d7f:             if (!contains(o))
1:5250d7f:                 return false;
1:5250d7f:         return true;
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     public int hashCode()
1:5250d7f:     {
1:5250d7f:         // we can't just delegate to Arrays.deepHashCode(),
1:5250d7f:         // because two equivalent sets may be represented by differently shaped trees
1:5250d7f:         int result = 1;
1:5250d7f:         for (V v : this)
1:5250d7f:             result = 31 * result + Objects.hashCode(v);
1:5250d7f:         return result;
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public boolean addAll(Collection<? extends V> c)
1:5250d7f:     {
1:5250d7f:         throw new UnsupportedOperationException();
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     public boolean addAll(int index, Collection<? extends V> c)
1:5250d7f:     {
1:5250d7f:         throw new UnsupportedOperationException();
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public boolean retainAll(Collection<?> c)
1:5250d7f:     {
1:5250d7f:         throw new UnsupportedOperationException();
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public boolean removeAll(Collection<?> c)
1:5250d7f:     {
1:5250d7f:         throw new UnsupportedOperationException();
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public void clear()
1:5250d7f:     {
1:5250d7f:         throw new UnsupportedOperationException();
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public V pollFirst()
1:5250d7f:     {
1:5250d7f:         throw new UnsupportedOperationException();
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public V pollLast()
1:5250d7f:     {
1:5250d7f:         throw new UnsupportedOperationException();
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public boolean add(V v)
1:5250d7f:     {
1:5250d7f:         throw new UnsupportedOperationException();
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Override
1:5250d7f:     public boolean remove(Object o)
1:5250d7f:     {
1:5250d7f:         throw new UnsupportedOperationException();
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     public V set(int index, V element)
1:5250d7f:     {
1:5250d7f:         throw new UnsupportedOperationException();
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     public void add(int index, V element)
1:5250d7f:     {
1:5250d7f:         throw new UnsupportedOperationException();
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     public V remove(int index)
1:5250d7f:     {
1:5250d7f:         throw new UnsupportedOperationException();
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     public ListIterator<V> listIterator()
1:5250d7f:     {
1:5250d7f:         throw new UnsupportedOperationException();
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     public ListIterator<V> listIterator(int index)
1:5250d7f:     {
1:5250d7f:         throw new UnsupportedOperationException();
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     public static class BTreeRange<V> extends BTreeSet<V>
1:5250d7f:     {
1:5250d7f:         // both inclusive
1:5250d7f:         protected final int lowerBound, upperBound;
1:5250d7f:         BTreeRange(Object[] tree, Comparator<? super V> comparator)
1:5250d7f:         {
1:5250d7f:             this(tree, comparator, null, true, null, true);
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         BTreeRange(BTreeRange<V> from)
1:5250d7f:         {
1:5250d7f:             super(from.tree, from.comparator);
1:5250d7f:             this.lowerBound = from.lowerBound;
1:5250d7f:             this.upperBound = from.upperBound;
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         BTreeRange(Object[] tree, Comparator<? super V> comparator, int lowerBound, int upperBound)
1:5250d7f:         {
1:5250d7f:             super(tree, comparator);
1:5250d7f:             if (upperBound < lowerBound - 1)
1:5250d7f:                 upperBound = lowerBound - 1;
1:5250d7f:             this.lowerBound = lowerBound;
1:5250d7f:             this.upperBound = upperBound;
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         BTreeRange(Object[] tree, Comparator<? super V> comparator, V lowerBound, boolean inclusiveLowerBound, V upperBound, boolean inclusiveUpperBound)
1:5250d7f:         {
1:5250d7f:             this(tree, comparator,
1:5250d7f:                  lowerBound == null ? 0 : inclusiveLowerBound ? BTree.ceilIndex(tree, comparator, lowerBound)
1:5250d7f:                                                               : BTree.higherIndex(tree, comparator, lowerBound),
1:5250d7f:                  upperBound == null ? BTree.size(tree) - 1 : inclusiveUpperBound ? BTree.floorIndex(tree, comparator, upperBound)
1:5250d7f:                                                                                  : BTree.lowerIndex(tree, comparator, upperBound));
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         // narrowing range constructor - makes this the intersection of the two ranges over the same tree b
1:5250d7f:         BTreeRange(BTreeRange<V> a, BTreeRange<V> b)
1:5250d7f:         {
1:5250d7f:             this(a.tree, a.comparator, Math.max(a.lowerBound, b.lowerBound), Math.min(a.upperBound, b.upperBound));
1:5250d7f:             assert a.tree == b.tree;
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         @Override
1:639d4b2:         protected BTreeSearchIterator<V, V> slice(Dir dir)
1:5250d7f:         {
1:639d4b2:             return new BTreeSearchIterator<>(tree, comparator, dir, lowerBound, upperBound);
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         @Override
1:5250d7f:         public boolean isEmpty()
1:5250d7f:         {
1:5250d7f:             return upperBound < lowerBound;
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         public int size()
1:5250d7f:         {
1:5250d7f:             return (upperBound - lowerBound) + 1;
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         boolean outOfBounds(int i)
1:5250d7f:         {
1:5250d7f:             return (i < lowerBound) | (i > upperBound);
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         public V get(int index)
1:5250d7f:         {
1:5250d7f:             index += lowerBound;
1:5250d7f:             if (outOfBounds(index))
1:5250d7f:                 throw new NoSuchElementException();
1:5250d7f:             return super.get(index);
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         public int indexOf(Object item)
1:5250d7f:         {
1:5250d7f:             int i = super.indexOf(item);
1:5250d7f:             boolean negate = i < 0;
1:5250d7f:             if (negate)
1:5250d7f:                 i = -1 - i;
1:5250d7f:             if (outOfBounds(i))
1:5250d7f:                 return i < lowerBound ? -1 : -1 - size();
1:5250d7f:             i = i - lowerBound;
1:5250d7f:             if (negate)
1:5250d7f:                 i = -1 -i;
1:5250d7f:             return i;
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         public V lower(V v)
1:5250d7f:         {
1:5250d7f:             return maybe(Math.min(upperBound, BTree.lowerIndex(tree, comparator, v)));
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         public V floor(V v)
1:5250d7f:         {
1:5250d7f:             return maybe(Math.min(upperBound, BTree.floorIndex(tree, comparator, v)));
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         public V ceiling(V v)
1:5250d7f:         {
1:5250d7f:             return maybe(Math.max(lowerBound, BTree.ceilIndex(tree, comparator, v)));
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         public V higher(V v)
1:5250d7f:         {
1:5250d7f:             return maybe(Math.max(lowerBound, BTree.higherIndex(tree, comparator, v)));
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         private V maybe(int i)
1:5250d7f:         {
1:5250d7f:             if (outOfBounds(i))
1:5250d7f:                 return null;
1:5250d7f:             return super.get(i);
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         @Override
1:5250d7f:         public BTreeSet<V> subSet(V fromElement, boolean fromInclusive, V toElement, boolean toInclusive)
1:5250d7f:         {
1:5250d7f:             return new BTreeRange<>(this, new BTreeRange<>(tree, comparator, fromElement, fromInclusive, toElement, toInclusive));
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         @Override
1:5250d7f:         public BTreeSet<V> headSet(V toElement, boolean inclusive)
1:5250d7f:         {
1:5250d7f:             return new BTreeRange<>(this, new BTreeRange<>(tree, comparator, null, true, toElement, inclusive));
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         @Override
1:5250d7f:         public BTreeSet<V> tailSet(V fromElement, boolean inclusive)
1:5250d7f:         {
1:5250d7f:             return new BTreeRange<>(this, new BTreeRange<>(tree, comparator, fromElement, inclusive, null, true));
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         @Override
1:5250d7f:         public BTreeSet<V> descendingSet()
1:5250d7f:         {
1:5250d7f:             return new BTreeDescRange<>(this);
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         public BTreeSet<V> subList(int fromIndex, int toIndex)
1:5250d7f:         {
1:5250d7f:             if (fromIndex < 0 || toIndex > size())
1:5250d7f:                 throw new IndexOutOfBoundsException();
1:5250d7f:             return new BTreeRange<V>(tree, comparator, lowerBound + fromIndex, lowerBound + toIndex - 1);
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         @Override
1:5250d7f:         public <T> T[] toArray(T[] a)
1:5250d7f:         {
1:5250d7f:             return toArray(a, 0);
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         public <T> T[] toArray(T[] a, int offset)
1:5250d7f:         {
1:5250d7f:             if (size() + offset < a.length)
1:5250d7f:                 a = Arrays.copyOf(a, size() + offset);
1:5250d7f: 
1:5250d7f:             BTree.toArray(tree, lowerBound, upperBound + 1, a, offset);
1:5250d7f:             return a;
1:5250d7f:         }
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     public static class BTreeDescRange<V> extends BTreeRange<V>
1:5250d7f:     {
1:5250d7f:         BTreeDescRange(BTreeRange<V> from)
1:5250d7f:         {
1:5250d7f:             super(from.tree, from.comparator, from.lowerBound, from.upperBound);
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         @Override
1:639d4b2:         protected BTreeSearchIterator<V, V> slice(Dir dir)
1:5250d7f:         {
1:639d4b2:             return super.slice(dir.invert());
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         /* Flip the methods we call for inequality searches */
1:5250d7f: 
1:5250d7f:         public V higher(V v)
1:5250d7f:         {
1:5250d7f:             return super.lower(v);
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         public V ceiling(V v)
1:5250d7f:         {
1:5250d7f:             return super.floor(v);
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         public V floor(V v)
1:5250d7f:         {
1:5250d7f:             return super.ceiling(v);
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         public V lower(V v)
1:5250d7f:         {
1:5250d7f:             return super.higher(v);
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         public V get(int index)
1:5250d7f:         {
1:5250d7f:             index = upperBound - index;
1:5250d7f:             if (outOfBounds(index))
1:5250d7f:                 throw new NoSuchElementException();
1:5250d7f:             return BTree.findByIndex(tree, index);
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         public int indexOf(Object item)
1:5250d7f:         {
1:5250d7f:             int i = super.indexOf(item);
1:5250d7f:             // i is in range [-1 - size()..size())
1:5250d7f:             // so we just need to invert by adding/subtracting from size
1:5250d7f:             return i < 0 ? -2 - size() - i  : size() - (i + 1);
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         public BTreeSet<V> subList(int fromIndex, int toIndex)
1:5250d7f:         {
1:5250d7f:             if (fromIndex < 0 || toIndex > size())
1:5250d7f:                 throw new IndexOutOfBoundsException();
1:5250d7f:             return new BTreeDescRange<V>(new BTreeRange<V>(tree, comparator, upperBound - (toIndex - 1), upperBound - fromIndex));
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         @Override
1:5250d7f:         public BTreeSet<V> subSet(V fromElement, boolean fromInclusive, V toElement, boolean toInclusive)
1:5250d7f:         {
1:5250d7f:             return super.subSet(toElement, toInclusive, fromElement, fromInclusive).descendingSet();
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         @Override
1:5250d7f:         public BTreeSet<V> headSet(V toElement, boolean inclusive)
1:5250d7f:         {
1:5250d7f:             return super.tailSet(toElement, inclusive).descendingSet();
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         @Override
1:5250d7f:         public BTreeSet<V> tailSet(V fromElement, boolean inclusive)
1:5250d7f:         {
1:5250d7f:             return super.headSet(fromElement, inclusive).descendingSet();
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         @Override
1:5250d7f:         public BTreeSet<V> descendingSet()
1:5250d7f:         {
1:5250d7f:             return new BTreeRange<>(this);
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         public Comparator<V> comparator()
1:5250d7f:         {
1:5250d7f:             return (a, b) -> comparator.compare(b, a);
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         public <T> T[] toArray(T[] a, int offset)
1:5250d7f:         {
1:5250d7f:             a = super.toArray(a, offset);
1:5250d7f:             int count = size();
1:5250d7f:             int flip = count / 2;
1:5250d7f:             for (int i = 0 ; i < flip ; i++)
1:5250d7f:             {
1:5250d7f:                 int j = count - (i + 1);
1:5250d7f:                 T t = a[i + offset];
1:5250d7f:                 a[i + offset] = a[j + offset];
1:5250d7f:                 a[j + offset] = t;
1:5250d7f:             }
1:5250d7f:             return a;
1:5250d7f:         }
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     public static class Builder<V>
1:5250d7f:     {
1:5250d7f:         final BTree.Builder<V> builder;
1:5250d7f:         protected Builder(Comparator<? super V> comparator)
1:5250d7f:         {
1:5250d7f:             builder= BTree.builder(comparator);
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         public Builder<V> add(V v)
1:5250d7f:         {
1:5250d7f:             builder.add(v);
1:5250d7f:             return this;
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         public Builder<V> addAll(Collection<V> iter)
1:5250d7f:         {
1:5250d7f:             builder.addAll(iter);
1:5250d7f:             return this;
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         public boolean isEmpty()
1:5250d7f:         {
1:5250d7f:             return builder.isEmpty();
1:5250d7f:         }
1:5250d7f:         public BTreeSet<V> build()
1:5250d7f:         {
1:5250d7f:             return new BTreeSet<>(builder.build(), builder.comparator);
1:5250d7f:         }
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     public static <V> Builder<V> builder(Comparator<? super V> comparator)
1:5250d7f:     {
1:5250d7f:         return new Builder<>(comparator);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     public static <V> BTreeSet<V> wrap(Object[] btree, Comparator<V> comparator)
1:5250d7f:     {
1:5250d7f:         return new BTreeSet<>(btree, comparator);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     public static <V extends Comparable<V>> BTreeSet<V> of(Collection<V> sortedValues)
1:5250d7f:     {
1:5250d7f:         return new BTreeSet<>(BTree.build(sortedValues, UpdateFunction.<V>noOp()), Ordering.<V>natural());
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     public static <V extends Comparable<V>> BTreeSet<V> of(V value)
1:5250d7f:     {
1:5250d7f:         return new BTreeSet<>(BTree.build(ImmutableList.of(value), UpdateFunction.<V>noOp()), Ordering.<V>natural());
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     public static <V> BTreeSet<V> empty(Comparator<? super V> comparator)
1:5250d7f:     {
1:5250d7f:         return new BTreeSet<>(BTree.empty(), comparator);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     public static <V> BTreeSet<V> of(Comparator<? super V> comparator, V value)
1:5250d7f:     {
1:958aa7c:         return new BTreeSet<>(BTree.singleton(value), comparator);
1:5250d7f:     }
1:5250d7f: }
============================================================================
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:1e92ce4
/////////////////////////////////////////////////////////////////////////
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:958aa7c
/////////////////////////////////////////////////////////////////////////
1:         return new BTreeSet<>(BTree.singleton(value), comparator);
commit:a991b64
/////////////////////////////////////////////////////////////////////////
commit:9f14856
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:639d4b2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.btree.BTree.Dir;
1: 
/////////////////////////////////////////////////////////////////////////
1:     protected BTreeSearchIterator<V, V> slice(Dir dir)
1:         return BTree.slice(tree, comparator, dir);
/////////////////////////////////////////////////////////////////////////
1:         return slice(Dir.ASC);
1:         return slice(Dir.DESC);
/////////////////////////////////////////////////////////////////////////
1:         protected BTreeSearchIterator<V, V> slice(Dir dir)
1:             return new BTreeSearchIterator<>(tree, comparator, dir, lowerBound, upperBound);
/////////////////////////////////////////////////////////////////////////
1:         protected BTreeSearchIterator<V, V> slice(Dir dir)
1:             return super.slice(dir.invert());
commit:5250d7f
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
1:  */
1: package org.apache.cassandra.utils.btree;
1: 
1: import java.util.*;
1: 
1: import com.google.common.collect.ImmutableList;
0: import com.google.common.collect.Iterables;
1: import com.google.common.collect.Ordering;
1: 
1: import static org.apache.cassandra.utils.btree.BTree.findIndex;
0: import static org.apache.cassandra.utils.btree.BTree.lower;
0: import static org.apache.cassandra.utils.btree.BTree.toArray;
1: 
1: public class BTreeSet<V> implements NavigableSet<V>, List<V>
1: {
1:     protected final Comparator<? super V> comparator;
1:     protected final Object[] tree;
1: 
1:     public BTreeSet(Object[] tree, Comparator<? super V> comparator)
1:     {
1:         this.tree = tree;
1:         this.comparator = comparator;
1:     }
1: 
1:     public BTreeSet<V> update(Collection<V> updateWith)
1:     {
1:         return new BTreeSet<>(BTree.update(tree, comparator, updateWith, UpdateFunction.<V>noOp()), comparator);
1:     }
1: 
1:     @Override
1:     public Comparator<? super V> comparator()
1:     {
1:         return comparator;
1:     }
1: 
0:     protected BTreeSearchIterator<V, V> slice(boolean forwards)
1:     {
0:         return BTree.slice(tree, comparator, forwards);
1:     }
1: 
1:     public Object[] tree()
1:     {
1:         return tree;
1:     }
1: 
1:     /**
1:      * The index of the item within the list, or its insertion point otherwise. i.e. binarySearch semantics
1:      */
1:     public int indexOf(Object item)
1:     {
1:         return findIndex(tree, comparator, (V) item);
1:     }
1: 
1:     /**
1:      * The converse of indexOf: provided an index between 0 and size, returns the i'th item, in set order.
1:      */
1:     public V get(int index)
1:     {
1:         return BTree.<V>findByIndex(tree, index);
1:     }
1: 
1:     public int lastIndexOf(Object o)
1:     {
1:         return indexOf(o);
1:     }
1: 
1:     public BTreeSet<V> subList(int fromIndex, int toIndex)
1:     {
1:         return new BTreeRange<V>(tree, comparator, fromIndex, toIndex - 1);
1:     }
1: 
1:     @Override
1:     public int size()
1:     {
1:         return BTree.size(tree);
1:     }
1: 
1:     @Override
1:     public boolean isEmpty()
1:     {
1:         return BTree.isEmpty(tree);
1:     }
1: 
1:     @Override
1:     public BTreeSearchIterator<V, V> iterator()
1:     {
0:         return slice(true);
1:     }
1: 
1:     @Override
1:     public BTreeSearchIterator<V, V> descendingIterator()
1:     {
0:         return slice(false);
1:     }
1: 
1:     @Override
1:     public Object[] toArray()
1:     {
1:         return toArray(new Object[0]);
1:     }
1: 
1:     @Override
1:     public <T> T[] toArray(T[] a)
1:     {
1:         return toArray(a, 0);
1:     }
1: 
1:     public <T> T[] toArray(T[] a, int offset)
1:     {
1:         int size = size();
1:         if (a.length < size + offset)
1:             a = Arrays.copyOf(a, size);
1:         BTree.toArray(tree, a, offset);
1:         return a;
1:     }
1: 
1:     public Spliterator<V> spliterator()
1:     {
1:         return Spliterators.spliterator(this, Spliterator.ORDERED | Spliterator.DISTINCT | Spliterator.IMMUTABLE | Spliterator.NONNULL | Spliterator.SIZED);
1:     }
1: 
1:     @Override
1:     public BTreeSet<V> subSet(V fromElement, boolean fromInclusive, V toElement, boolean toInclusive)
1:     {
1:         return new BTreeRange<>(tree, comparator, fromElement, fromInclusive, toElement, toInclusive);
1:     }
1: 
1:     @Override
1:     public BTreeSet<V> headSet(V toElement, boolean inclusive)
1:     {
1:         return new BTreeRange<>(tree, comparator, null, true, toElement, inclusive);
1:     }
1: 
1:     @Override
1:     public BTreeSet<V> tailSet(V fromElement, boolean inclusive)
1:     {
1:         return new BTreeRange<>(tree, comparator, fromElement, inclusive, null, true);
1:     }
1: 
1:     @Override
1:     public SortedSet<V> subSet(V fromElement, V toElement)
1:     {
1:         return subSet(fromElement, true, toElement, false);
1:     }
1: 
1:     @Override
1:     public SortedSet<V> headSet(V toElement)
1:     {
1:         return headSet(toElement, false);
1:     }
1: 
1:     @Override
1:     public SortedSet<V> tailSet(V fromElement)
1:     {
1:         return tailSet(fromElement, true);
1:     }
1: 
1:     @Override
1:     public BTreeSet<V> descendingSet()
1:     {
0:         return new BTreeRange<>(this.tree, this.comparator).descendingSet();
1:     }
1: 
1:     @Override
1:     public V first()
1:     {
1:         return get(0);
1:     }
1: 
1:     @Override
1:     public V last()
1:     {
1:         return get(size() - 1);
1:     }
1: 
1:     @Override
1:     public V lower(V v)
1:     {
1:         return BTree.lower(tree, comparator, v);
1:     }
1: 
1:     @Override
1:     public V floor(V v)
1:     {
1:         return BTree.floor(tree, comparator, v);
1:     }
1: 
1:     @Override
1:     public V ceiling(V v)
1:     {
1:         return BTree.ceil(tree, comparator, v);
1:     }
1: 
1:     @Override
1:     public V higher(V v)
1:     {
1:         return BTree.higher(tree, comparator, v);
1:     }
1: 
1:     @Override
1:     public boolean contains(Object o)
1:     {
1:         return indexOf((V) o) >= 0;
1:     }
1: 
1:     @Override
1:     public boolean containsAll(Collection<?> c)
1:     {
1:         // TODO: if we ever use this method, it can be specialized quite easily for SortedSet arguments
1:         for (Object o : c)
1:             if (!contains(o))
1:                 return false;
1:         return true;
1:     }
1: 
1:     public int hashCode()
1:     {
1:         // we can't just delegate to Arrays.deepHashCode(),
1:         // because two equivalent sets may be represented by differently shaped trees
1:         int result = 1;
1:         for (V v : this)
1:             result = 31 * result + Objects.hashCode(v);
1:         return result;
1:     }
1: 
1:     @Override
1:     public boolean addAll(Collection<? extends V> c)
1:     {
1:         throw new UnsupportedOperationException();
1:     }
1: 
1:     public boolean addAll(int index, Collection<? extends V> c)
1:     {
1:         throw new UnsupportedOperationException();
1:     }
1: 
1:     @Override
1:     public boolean retainAll(Collection<?> c)
1:     {
1:         throw new UnsupportedOperationException();
1:     }
1: 
1:     @Override
1:     public boolean removeAll(Collection<?> c)
1:     {
1:         throw new UnsupportedOperationException();
1:     }
1: 
1:     @Override
1:     public void clear()
1:     {
1:         throw new UnsupportedOperationException();
1:     }
1: 
1:     @Override
1:     public V pollFirst()
1:     {
1:         throw new UnsupportedOperationException();
1:     }
1: 
1:     @Override
1:     public V pollLast()
1:     {
1:         throw new UnsupportedOperationException();
1:     }
1: 
1:     @Override
1:     public boolean add(V v)
1:     {
1:         throw new UnsupportedOperationException();
1:     }
1: 
1:     @Override
1:     public boolean remove(Object o)
1:     {
1:         throw new UnsupportedOperationException();
1:     }
1: 
1:     public V set(int index, V element)
1:     {
1:         throw new UnsupportedOperationException();
1:     }
1: 
1:     public void add(int index, V element)
1:     {
1:         throw new UnsupportedOperationException();
1:     }
1: 
1:     public V remove(int index)
1:     {
1:         throw new UnsupportedOperationException();
1:     }
1: 
1:     public ListIterator<V> listIterator()
1:     {
1:         throw new UnsupportedOperationException();
1:     }
1: 
1:     public ListIterator<V> listIterator(int index)
1:     {
1:         throw new UnsupportedOperationException();
1:     }
1: 
1:     public static class BTreeRange<V> extends BTreeSet<V>
1:     {
1:         // both inclusive
1:         protected final int lowerBound, upperBound;
1:         BTreeRange(Object[] tree, Comparator<? super V> comparator)
1:         {
1:             this(tree, comparator, null, true, null, true);
1:         }
1: 
1:         BTreeRange(BTreeRange<V> from)
1:         {
1:             super(from.tree, from.comparator);
1:             this.lowerBound = from.lowerBound;
1:             this.upperBound = from.upperBound;
1:         }
1: 
1:         BTreeRange(Object[] tree, Comparator<? super V> comparator, int lowerBound, int upperBound)
1:         {
1:             super(tree, comparator);
1:             if (upperBound < lowerBound - 1)
1:                 upperBound = lowerBound - 1;
1:             this.lowerBound = lowerBound;
1:             this.upperBound = upperBound;
1:         }
1: 
1:         BTreeRange(Object[] tree, Comparator<? super V> comparator, V lowerBound, boolean inclusiveLowerBound, V upperBound, boolean inclusiveUpperBound)
1:         {
1:             this(tree, comparator,
1:                  lowerBound == null ? 0 : inclusiveLowerBound ? BTree.ceilIndex(tree, comparator, lowerBound)
1:                                                               : BTree.higherIndex(tree, comparator, lowerBound),
1:                  upperBound == null ? BTree.size(tree) - 1 : inclusiveUpperBound ? BTree.floorIndex(tree, comparator, upperBound)
1:                                                                                  : BTree.lowerIndex(tree, comparator, upperBound));
1:         }
1: 
1:         // narrowing range constructor - makes this the intersection of the two ranges over the same tree b
1:         BTreeRange(BTreeRange<V> a, BTreeRange<V> b)
1:         {
1:             this(a.tree, a.comparator, Math.max(a.lowerBound, b.lowerBound), Math.min(a.upperBound, b.upperBound));
1:             assert a.tree == b.tree;
1:         }
1: 
1:         @Override
0:         protected BTreeSearchIterator<V, V> slice(boolean forwards)
1:         {
0:             return new BTreeSearchIterator<>(tree, comparator, forwards, lowerBound, upperBound);
1:         }
1: 
1:         @Override
1:         public boolean isEmpty()
1:         {
1:             return upperBound < lowerBound;
1:         }
1: 
1:         public int size()
1:         {
1:             return (upperBound - lowerBound) + 1;
1:         }
1: 
1:         boolean outOfBounds(int i)
1:         {
1:             return (i < lowerBound) | (i > upperBound);
1:         }
1: 
1:         public V get(int index)
1:         {
1:             index += lowerBound;
1:             if (outOfBounds(index))
1:                 throw new NoSuchElementException();
1:             return super.get(index);
1:         }
1: 
1:         public int indexOf(Object item)
1:         {
1:             int i = super.indexOf(item);
1:             boolean negate = i < 0;
1:             if (negate)
1:                 i = -1 - i;
1:             if (outOfBounds(i))
1:                 return i < lowerBound ? -1 : -1 - size();
1:             i = i - lowerBound;
1:             if (negate)
1:                 i = -1 -i;
1:             return i;
1:         }
1: 
1:         public V lower(V v)
1:         {
1:             return maybe(Math.min(upperBound, BTree.lowerIndex(tree, comparator, v)));
1:         }
1: 
1:         public V floor(V v)
1:         {
1:             return maybe(Math.min(upperBound, BTree.floorIndex(tree, comparator, v)));
1:         }
1: 
1:         public V ceiling(V v)
1:         {
1:             return maybe(Math.max(lowerBound, BTree.ceilIndex(tree, comparator, v)));
1:         }
1: 
1:         public V higher(V v)
1:         {
1:             return maybe(Math.max(lowerBound, BTree.higherIndex(tree, comparator, v)));
1:         }
1: 
1:         private V maybe(int i)
1:         {
1:             if (outOfBounds(i))
1:                 return null;
1:             return super.get(i);
1:         }
1: 
1:         @Override
1:         public BTreeSet<V> subSet(V fromElement, boolean fromInclusive, V toElement, boolean toInclusive)
1:         {
1:             return new BTreeRange<>(this, new BTreeRange<>(tree, comparator, fromElement, fromInclusive, toElement, toInclusive));
1:         }
1: 
1:         @Override
1:         public BTreeSet<V> headSet(V toElement, boolean inclusive)
1:         {
1:             return new BTreeRange<>(this, new BTreeRange<>(tree, comparator, null, true, toElement, inclusive));
1:         }
1: 
1:         @Override
1:         public BTreeSet<V> tailSet(V fromElement, boolean inclusive)
1:         {
1:             return new BTreeRange<>(this, new BTreeRange<>(tree, comparator, fromElement, inclusive, null, true));
1:         }
1: 
1:         @Override
1:         public BTreeSet<V> descendingSet()
1:         {
1:             return new BTreeDescRange<>(this);
1:         }
1: 
1:         public BTreeSet<V> subList(int fromIndex, int toIndex)
1:         {
1:             if (fromIndex < 0 || toIndex > size())
1:                 throw new IndexOutOfBoundsException();
1:             return new BTreeRange<V>(tree, comparator, lowerBound + fromIndex, lowerBound + toIndex - 1);
1:         }
1: 
1:         @Override
1:         public <T> T[] toArray(T[] a)
1:         {
1:             return toArray(a, 0);
1:         }
1: 
1:         public <T> T[] toArray(T[] a, int offset)
1:         {
1:             if (size() + offset < a.length)
1:                 a = Arrays.copyOf(a, size() + offset);
1: 
1:             BTree.toArray(tree, lowerBound, upperBound + 1, a, offset);
1:             return a;
1:         }
1:     }
1: 
1:     public static class BTreeDescRange<V> extends BTreeRange<V>
1:     {
1:         BTreeDescRange(BTreeRange<V> from)
1:         {
1:             super(from.tree, from.comparator, from.lowerBound, from.upperBound);
1:         }
1: 
1:         @Override
0:         protected BTreeSearchIterator<V, V> slice(boolean forwards)
1:         {
0:             return super.slice(!forwards);
1:         }
1: 
1:         /* Flip the methods we call for inequality searches */
1: 
1:         public V higher(V v)
1:         {
1:             return super.lower(v);
1:         }
1: 
1:         public V ceiling(V v)
1:         {
1:             return super.floor(v);
1:         }
1: 
1:         public V floor(V v)
1:         {
1:             return super.ceiling(v);
1:         }
1: 
1:         public V lower(V v)
1:         {
1:             return super.higher(v);
1:         }
1: 
1:         public V get(int index)
1:         {
1:             index = upperBound - index;
1:             if (outOfBounds(index))
1:                 throw new NoSuchElementException();
1:             return BTree.findByIndex(tree, index);
1:         }
1: 
1:         public int indexOf(Object item)
1:         {
1:             int i = super.indexOf(item);
1:             // i is in range [-1 - size()..size())
1:             // so we just need to invert by adding/subtracting from size
1:             return i < 0 ? -2 - size() - i  : size() - (i + 1);
1:         }
1: 
1:         public BTreeSet<V> subList(int fromIndex, int toIndex)
1:         {
1:             if (fromIndex < 0 || toIndex > size())
1:                 throw new IndexOutOfBoundsException();
1:             return new BTreeDescRange<V>(new BTreeRange<V>(tree, comparator, upperBound - (toIndex - 1), upperBound - fromIndex));
1:         }
1: 
1:         @Override
1:         public BTreeSet<V> subSet(V fromElement, boolean fromInclusive, V toElement, boolean toInclusive)
1:         {
1:             return super.subSet(toElement, toInclusive, fromElement, fromInclusive).descendingSet();
1:         }
1: 
1:         @Override
1:         public BTreeSet<V> headSet(V toElement, boolean inclusive)
1:         {
1:             return super.tailSet(toElement, inclusive).descendingSet();
1:         }
1: 
1:         @Override
1:         public BTreeSet<V> tailSet(V fromElement, boolean inclusive)
1:         {
1:             return super.headSet(fromElement, inclusive).descendingSet();
1:         }
1: 
1:         @Override
1:         public BTreeSet<V> descendingSet()
1:         {
1:             return new BTreeRange<>(this);
1:         }
1: 
1:         public Comparator<V> comparator()
1:         {
1:             return (a, b) -> comparator.compare(b, a);
1:         }
1: 
1:         public <T> T[] toArray(T[] a, int offset)
1:         {
1:             a = super.toArray(a, offset);
1:             int count = size();
1:             int flip = count / 2;
1:             for (int i = 0 ; i < flip ; i++)
1:             {
1:                 int j = count - (i + 1);
1:                 T t = a[i + offset];
1:                 a[i + offset] = a[j + offset];
1:                 a[j + offset] = t;
1:             }
1:             return a;
1:         }
1:     }
1: 
1:     public static class Builder<V>
1:     {
1:         final BTree.Builder<V> builder;
1:         protected Builder(Comparator<? super V> comparator)
1:         {
1:             builder= BTree.builder(comparator);
1:         }
1: 
1:         public Builder<V> add(V v)
1:         {
1:             builder.add(v);
1:             return this;
1:         }
1: 
1:         public Builder<V> addAll(Collection<V> iter)
1:         {
1:             builder.addAll(iter);
1:             return this;
1:         }
1: 
1:         public boolean isEmpty()
1:         {
1:             return builder.isEmpty();
1:         }
1:         public BTreeSet<V> build()
1:         {
1:             return new BTreeSet<>(builder.build(), builder.comparator);
1:         }
1:     }
1: 
1:     public static <V> Builder<V> builder(Comparator<? super V> comparator)
1:     {
1:         return new Builder<>(comparator);
1:     }
1: 
1:     public static <V> BTreeSet<V> wrap(Object[] btree, Comparator<V> comparator)
1:     {
1:         return new BTreeSet<>(btree, comparator);
1:     }
1: 
1:     public static <V extends Comparable<V>> BTreeSet<V> of(Collection<V> sortedValues)
1:     {
1:         return new BTreeSet<>(BTree.build(sortedValues, UpdateFunction.<V>noOp()), Ordering.<V>natural());
1:     }
1: 
1:     public static <V extends Comparable<V>> BTreeSet<V> of(V value)
1:     {
1:         return new BTreeSet<>(BTree.build(ImmutableList.of(value), UpdateFunction.<V>noOp()), Ordering.<V>natural());
1:     }
1: 
1:     public static <V> BTreeSet<V> empty(Comparator<? super V> comparator)
1:     {
1:         return new BTreeSet<>(BTree.empty(), comparator);
1:     }
1: 
1:     public static <V> BTreeSet<V> of(Comparator<? super V> comparator, V value)
1:     {
0:         return new BTreeSet<>(BTree.build(ImmutableList.of(value), UpdateFunction.<V>noOp()), comparator);
1:     }
1: }
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:c29001b
/////////////////////////////////////////////////////////////////////////
1:         return new BTreeRange<V>(this.tree, this.comparator).descendingSet();
author:belliottsmith
-------------------------------------------------------------------------------
commit:9881ea6
/////////////////////////////////////////////////////////////////////////
0:     protected Cursor<V, V> slice(boolean forwards, boolean permitInversion)
0:         return BTree.slice(tree, forwards);
/////////////////////////////////////////////////////////////////////////
0:         protected Cursor<V, V> slice(boolean forwards, boolean permitInversion)
/////////////////////////////////////////////////////////////////////////
0:         protected Cursor<V, V> slice(boolean forwards, boolean permitInversion)
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:5f82aa3
/////////////////////////////////////////////////////////////////////////
0:         return new BTreeSet<>(BTree.update(tree, comparator, updateWith, isSorted, UpdateFunction.NoOp.<V>instance()), comparator);
commit:4b54b8a
/////////////////////////////////////////////////////////////////////////
0:         return new BTreeSet<>(BTree.update(tree, comparator, updateWith, isSorted, null), comparator);
commit:412b053
/////////////////////////////////////////////////////////////////////////
0: package org.apache.cassandra.utils.btree;
0: 
0: import java.util.Arrays;
0: import java.util.Collection;
0: import java.util.Comparator;
0: import java.util.Iterator;
0: import java.util.NavigableSet;
0: import java.util.SortedSet;
0: 
0: public class BTreeSet<V> implements NavigableSet<V>
0: {
0:     protected final Comparator<V> comparator;
0:     protected final Object[] tree;
0: 
0:     public BTreeSet(Object[] tree, Comparator<V> comparator)
0:     {
0:         this.tree = tree;
0:         this.comparator = comparator;
0:     }
0: 
0:     public BTreeSet<V> update(Collection<V> updateWith, boolean isSorted)
0:     {
0:         return new BTreeSet<>(BTree.update(tree, comparator, updateWith, isSorted, null, null), comparator);
0:     }
0: 
0:     @Override
0:     public Comparator<? super V> comparator()
0:     {
0:         return comparator;
0:     }
0: 
0:     protected Cursor<V> slice(boolean forwards, boolean permitInversion)
0:     {
0:         return BTree.<V>slice(tree, forwards);
0:     }
0: 
0:     @Override
0:     public int size()
0:     {
0:         return slice(true, false).count();
0:     }
0: 
0:     @Override
0:     public boolean isEmpty()
0:     {
0:         return slice(true, false).hasNext();
0:     }
0: 
0:     @Override
0:     public Iterator<V> iterator()
0:     {
0:         return slice(true, true);
0:     }
0: 
0:     @Override
0:     public Iterator<V> descendingIterator()
0:     {
0:         return slice(false, true);
0:     }
0: 
0:     @Override
0:     public Object[] toArray()
0:     {
0:         return toArray(new Object[0]);
0:     }
0: 
0:     @Override
0:     public <T> T[] toArray(T[] a)
0:     {
0:         int size = size();
0:         if (a.length < size)
0:             a = Arrays.copyOf(a, size);
0:         int i = 0;
0:         for (V v : this)
0:             a[i++] = (T) v;
0:         return a;
0:     }
0: 
0:     @Override
0:     public NavigableSet<V> subSet(V fromElement, boolean fromInclusive, V toElement, boolean toInclusive)
0:     {
0:         return new BTreeRange<>(tree, comparator, fromElement, fromInclusive, toElement, toInclusive);
0:     }
0: 
0:     @Override
0:     public NavigableSet<V> headSet(V toElement, boolean inclusive)
0:     {
0:         return new BTreeRange<>(tree, comparator, null, true, toElement, inclusive);
0:     }
0: 
0:     @Override
0:     public NavigableSet<V> tailSet(V fromElement, boolean inclusive)
0:     {
0:         return new BTreeRange<>(tree, comparator, fromElement, inclusive, null, true);
0:     }
0: 
0:     @Override
0:     public SortedSet<V> subSet(V fromElement, V toElement)
0:     {
0:         return subSet(fromElement, true, toElement, false);
0:     }
0: 
0:     @Override
0:     public SortedSet<V> headSet(V toElement)
0:     {
0:         return headSet(toElement, false);
0:     }
0: 
0:     @Override
0:     public SortedSet<V> tailSet(V fromElement)
0:     {
0:         return tailSet(fromElement, true);
0:     }
0: 
0:     @Override
0:     public V first()
0:     {
0:         throw new UnsupportedOperationException();
0:     }
0: 
0:     @Override
0:     public V last()
0:     {
0:         throw new UnsupportedOperationException();
0:     }
0: 
0:     @Override
0:     public boolean addAll(Collection<? extends V> c)
0:     {
0:         throw new UnsupportedOperationException();
0:     }
0: 
0:     @Override
0:     public boolean retainAll(Collection<?> c)
0:     {
0:         throw new UnsupportedOperationException();
0:     }
0: 
0:     @Override
0:     public boolean removeAll(Collection<?> c)
0:     {
0:         throw new UnsupportedOperationException();
0:     }
0: 
0:     @Override
0:     public void clear()
0:     {
0:         throw new UnsupportedOperationException();
0:     }
0: 
0:     @Override
0:     public V pollFirst()
0:     {
0:         throw new UnsupportedOperationException();
0:     }
0: 
0:     @Override
0:     public V pollLast()
0:     {
0:         throw new UnsupportedOperationException();
0:     }
0: 
0:     @Override
0:     public boolean add(V v)
0:     {
0:         throw new UnsupportedOperationException();
0:     }
0: 
0:     @Override
0:     public boolean remove(Object o)
0:     {
0:         throw new UnsupportedOperationException();
0:     }
0: 
0:     @Override
0:     public V lower(V v)
0:     {
0:         throw new UnsupportedOperationException();
0:     }
0: 
0:     @Override
0:     public V floor(V v)
0:     {
0:         throw new UnsupportedOperationException();
0:     }
0: 
0:     @Override
0:     public V ceiling(V v)
0:     {
0:         throw new UnsupportedOperationException();
0:     }
0: 
0:     @Override
0:     public V higher(V v)
0:     {
0:         throw new UnsupportedOperationException();
0:     }
0: 
0:     @Override
0:     public boolean contains(Object o)
0:     {
0:         throw new UnsupportedOperationException();
0:     }
0: 
0:     @Override
0:     public boolean containsAll(Collection<?> c)
0:     {
0:         throw new UnsupportedOperationException();
0:     }
0: 
0:     @Override
0:     public NavigableSet<V> descendingSet()
0:     {
0:         return new BTreeRange<>(this.tree, this.comparator).descendingSet();
0:     }
0: 
0:     public static class BTreeRange<V> extends BTreeSet<V> implements NavigableSet<V>
0:     {
0: 
0:         protected final V lowerBound, upperBound;
0:         protected final boolean inclusiveLowerBound, inclusiveUpperBound;
0: 
0:         BTreeRange(Object[] tree, Comparator<V> comparator)
0:         {
0:             this(tree, comparator, null, true, null, true);
0:         }
0: 
0:         BTreeRange(BTreeRange<V> from)
0:         {
0:             this(from.tree, from.comparator, from.lowerBound, from.inclusiveLowerBound, from.upperBound, from.inclusiveUpperBound);
0:         }
0: 
0:         BTreeRange(Object[] tree, Comparator<V> comparator, V lowerBound, boolean inclusiveLowerBound, V upperBound, boolean inclusiveUpperBound)
0:         {
0:             super(tree, comparator);
0:             this.lowerBound = lowerBound;
0:             this.upperBound = upperBound;
0:             this.inclusiveLowerBound = inclusiveLowerBound;
0:             this.inclusiveUpperBound = inclusiveUpperBound;
0:         }
0: 
0:         // narrowing range constructor - makes this the intersection of the two ranges over the same tree b
0:         BTreeRange(BTreeRange<V> a, BTreeRange<V> b)
0:         {
0:             super(a.tree, a.comparator);
0:             assert a.tree == b.tree;
0:             final BTreeRange<V> lb, ub;
0: 
0:             if (a.lowerBound == null)
0:             {
0:                 lb = b;
0:             }
0:             else if (b.lowerBound == null)
0:             {
0:                 lb = a;
0:             }
0:             else
0:             {
0:                 int c = comparator.compare(a.lowerBound, b.lowerBound);
0:                 if (c < 0)
0:                     lb = b;
0:                 else if (c > 0)
0:                     lb = a;
0:                 else if (!a.inclusiveLowerBound)
0:                     lb = a;
0:                 else
0:                     lb = b;
0:             }
0: 
0:             if (a.upperBound == null)
0:             {
0:                 ub = b;
0:             }
0:             else if (b.upperBound == null)
0:             {
0:                 ub = a;
0:             }
0:             else
0:             {
0:                 int c = comparator.compare(b.upperBound, a.upperBound);
0:                 if (c < 0)
0:                     ub = b;
0:                 else if (c > 0)
0:                     ub = a;
0:                 else if (!a.inclusiveUpperBound)
0:                     ub = a;
0:                 else
0:                     ub = b;
0:             }
0: 
0:             lowerBound = lb.lowerBound;
0:             inclusiveLowerBound = lb.inclusiveLowerBound;
0:             upperBound = ub.upperBound;
0:             inclusiveUpperBound = ub.inclusiveUpperBound;
0:         }
0: 
0:         @Override
0:         protected Cursor<V> slice(boolean forwards, boolean permitInversion)
0:         {
0:             return BTree.slice(tree, comparator, lowerBound, inclusiveLowerBound, upperBound, inclusiveUpperBound, forwards);
0:         }
0: 
0:         @Override
0:         public NavigableSet<V> subSet(V fromElement, boolean fromInclusive, V toElement, boolean toInclusive)
0:         {
0:             return new BTreeRange<>(this, new BTreeRange<>(tree, comparator, fromElement, fromInclusive, toElement, toInclusive));
0:         }
0: 
0:         @Override
0:         public NavigableSet<V> headSet(V toElement, boolean inclusive)
0:         {
0:             return new BTreeRange<>(this, new BTreeRange<>(tree, comparator, lowerBound, true, toElement, inclusive));
0:         }
0: 
0:         @Override
0:         public NavigableSet<V> tailSet(V fromElement, boolean inclusive)
0:         {
0:             return new BTreeRange<>(this, new BTreeRange<>(tree, comparator, fromElement, inclusive, null, true));
0:         }
0: 
0:         @Override
0:         public NavigableSet<V> descendingSet()
0:         {
0:             return new BTreeDescRange<>(this);
0:         }
0:     }
0: 
0:     public static class BTreeDescRange<V> extends BTreeRange<V>
0:     {
0:         BTreeDescRange(BTreeRange<V> from)
0:         {
0:             super(from.tree, from.comparator, from.lowerBound, from.inclusiveLowerBound, from.upperBound, from.inclusiveUpperBound);
0:         }
0: 
0:         @Override
0:         protected Cursor<V> slice(boolean forwards, boolean permitInversion)
0:         {
0:             return super.slice(permitInversion ? !forwards : forwards, false);
0:         }
0: 
0:         @Override
0:         public NavigableSet<V> subSet(V fromElement, boolean fromInclusive, V toElement, boolean toInclusive)
0:         {
0:             return super.subSet(toElement, toInclusive, fromElement, fromInclusive).descendingSet();
0:         }
0: 
0:         @Override
0:         public NavigableSet<V> headSet(V toElement, boolean inclusive)
0:         {
0:             return super.tailSet(toElement, inclusive).descendingSet();
0:         }
0: 
0:         @Override
0:         public NavigableSet<V> tailSet(V fromElement, boolean inclusive)
0:         {
0:             return super.headSet(fromElement, inclusive).descendingSet();
0:         }
0: 
0:         @Override
0:         public NavigableSet<V> descendingSet()
0:         {
0:             return new BTreeRange<>(this);
0:         }
0:     }
0: }
============================================================================