1:9f14856: /*
1:9f14856:  * Licensed to the Apache Software Foundation (ASF) under one
1:9f14856:  * or more contributor license agreements.  See the NOTICE file
1:9f14856:  * distributed with this work for additional information
1:9f14856:  * regarding copyright ownership.  The ASF licenses this file
1:9f14856:  * to you under the Apache License, Version 2.0 (the
1:9f14856:  * "License"); you may not use this file except in compliance
1:9f14856:  * with the License.  You may obtain a copy of the License at
1:9f14856:  *
1:9f14856:  *   http://www.apache.org/licenses/LICENSE-2.0
1:9f14856:  *
1:9f14856:  * Unless required by applicable law or agreed to in writing,
1:9f14856:  * software distributed under the License is distributed on an
1:9f14856:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:9f14856:  * KIND, either express or implied.  See the License for the
1:9f14856:  * specific language governing permissions and limitations
1:9f14856:  * under the License.
1:9f14856:  */
1:4b54b8a: package org.apache.cassandra.utils.concurrent;
1:4b54b8a: 
1:4b54b8a: import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
1:4b54b8a: 
1:4b54b8a: /**
1:4b54b8a:  * <p>A class for providing synchronization between producers and consumers that do not
1:4b54b8a:  * communicate directly with each other, but where the consumers need to process their
1:4b54b8a:  * work in contiguous batches. In particular this is useful for both CommitLog and Memtable
1:4b54b8a:  * where the producers (writing threads) are modifying a structure that the consumer
1:4b54b8a:  * (flush executor) only batch syncs, but needs to know what 'position' the work is at
1:4b54b8a:  * for co-ordination with other processes,
1:4b54b8a:  *
1:4b54b8a:  * <p>The typical usage is something like:
1:4b54b8a:  * <pre>
1:222ea95:  * {@code
1:4b54b8a:      public final class ExampleShared
2:4b54b8a:      {
1:4b54b8a:         final OpOrder order = new OpOrder();
1:4b54b8a:         volatile SharedState state;
1:4b54b8a: 
1:4b54b8a:         static class SharedState
1:4b54b8a:         {
1:4b54b8a:             volatile Barrier barrier;
1:4b54b8a: 
1:4b54b8a:             // ...
2:4b54b8a:         }
1:4b54b8a: 
1:4b54b8a:         public void consume()
1:4b54b8a:         {
1:4b54b8a:             SharedState state = this.state;
1:4b54b8a:             state.setReplacement(new State())
1:4b54b8a:             state.doSomethingToPrepareForBarrier();
1:4b54b8a: 
1:4b54b8a:             state.barrier = order.newBarrier();
1:4b54b8a:             // seal() MUST be called after newBarrier() else barrier.isAfter()
1:4b54b8a:             // will always return true, and barrier.await() will fail
1:4b54b8a:             state.barrier.issue();
1:4b54b8a: 
1:4b54b8a:             // wait for all producer work started prior to the barrier to complete
1:4b54b8a:             state.barrier.await();
1:4b54b8a: 
1:4b54b8a:             // change the shared state to its replacement, as the current state will no longer be used by producers
1:4b54b8a:             this.state = state.getReplacement();
1:4b54b8a: 
1:4b54b8a:             state.doSomethingWithExclusiveAccess();
1:4b54b8a:         }
1:4b54b8a: 
1:4b54b8a:         public void produce()
1:4b54b8a:         {
1:269f810:             try (Group opGroup = order.start())
1:4b54b8a:             {
1:4b54b8a:                 SharedState s = state;
1:4b54b8a:                 while (s.barrier != null && !s.barrier.isAfter(opGroup))
1:4b54b8a:                     s = s.getReplacement();
1:4b54b8a:                 s.doProduceWork();
1:4b54b8a:             }
1:4b54b8a:         }
1:4b54b8a:     }
1:222ea95:  * }
1:4b54b8a:  * </pre>
1:4b54b8a:  */
1:4b54b8a: public class OpOrder
1:4b54b8a: {
1:4b54b8a:     /**
1:4b54b8a:      * Constant that when an Ordered.running is equal to, indicates the Ordered is complete
1:4b54b8a:      */
1:4b54b8a:     private static final int FINISHED = -1;
1:4b54b8a: 
1:4b54b8a:     /**
1:4b54b8a:      * A linked list starting with the most recent Ordered object, i.e. the one we should start new operations from,
1:4b54b8a:      * with (prev) links to any incomplete Ordered instances, and (next) links to any potential future Ordered instances.
1:4b54b8a:      * Once all operations started against an Ordered instance and its ancestors have been finished the next instance
1:4b54b8a:      * will unlink this one
1:4b54b8a:      */
1:4b54b8a:     private volatile Group current = new Group();
1:4b54b8a: 
1:4b54b8a:     /**
1:4b54b8a:      * Start an operation against this OpOrder.
1:269f810:      * Once the operation is completed Ordered.close() MUST be called EXACTLY once for this operation.
1:4b54b8a:      *
1:4b54b8a:      * @return the Ordered instance that manages this OpOrder
1:4b54b8a:      */
1:4b54b8a:     public Group start()
1:4b54b8a:     {
1:4b54b8a:         while (true)
1:4b54b8a:         {
1:4b54b8a:             Group current = this.current;
1:4b54b8a:             if (current.register())
1:4b54b8a:                 return current;
1:4b54b8a:         }
1:4b54b8a:     }
1:4b54b8a: 
1:4b54b8a:     /**
1:4b54b8a:      * Creates a new barrier. The barrier is only a placeholder until barrier.issue() is called on it,
1:4b54b8a:      * after which all new operations will start against a new Group that will not be accepted
1:4b54b8a:      * by barrier.isAfter(), and barrier.await() will return only once all operations started prior to the issue
1:4b54b8a:      * have completed.
1:4b54b8a:      *
1:4b54b8a:      * @return
1:4b54b8a:      */
1:4b54b8a:     public Barrier newBarrier()
1:4b54b8a:     {
1:4b54b8a:         return new Barrier();
1:4b54b8a:     }
1:4b54b8a: 
1:4b54b8a:     public Group getCurrent()
1:4b54b8a:     {
1:4b54b8a:         return current;
1:4b54b8a:     }
1:4b54b8a: 
1:0e393c9:     public void awaitNewBarrier()
1:0e393c9:     {
1:0e393c9:         Barrier barrier = newBarrier();
1:0e393c9:         barrier.issue();
1:0e393c9:         barrier.await();
1:0e393c9:     }
1:0e393c9: 
1:4b54b8a:     /**
1:4b54b8a:      * Represents a group of identically ordered operations, i.e. all operations started in the interval between
1:269f810:      * two barrier issuances. For each register() call this is returned, close() must be called exactly once.
1:4b54b8a:      * It should be treated like taking a lock().
1:4b54b8a:      */
1:269f810:     public static final class Group implements Comparable<Group>, AutoCloseable
1:4b54b8a:     {
1:4b54b8a:         /**
1:4b54b8a:          * In general this class goes through the following stages:
1:269f810:          * 1) LIVE:      many calls to register() and close()
1:4b54b8a:          * 2) FINISHING: a call to expire() (after a barrier issue), means calls to register() will now fail,
1:4b54b8a:          *               and we are now 'in the past' (new operations will be started against a new Ordered)
1:269f810:          * 3) FINISHED:  once the last close() is called, this Ordered is done. We call unlink().
1:4b54b8a:          * 4) ZOMBIE:    all our operations are finished, but some operations against an earlier Ordered are still
1:4b54b8a:          *               running, or tidying up, so unlink() fails to remove us
1:4b54b8a:          * 5) COMPLETE:  all operations started on or before us are FINISHED (and COMPLETE), so we are unlinked
1:4b54b8a:          * <p/>
1:4b54b8a:          * Another parallel states is ISBLOCKING:
1:4b54b8a:          * <p/>
1:4b54b8a:          * isBlocking => a barrier that is waiting on us (either directly, or via a future Ordered) is blocking general
1:4b54b8a:          * progress. This state is entered by calling Barrier.markBlocking(). If the running operations are blocked
1:4b54b8a:          * on a Signal that is also registered with the isBlockingSignal (probably through isSafeBlockingSignal)
1:4b54b8a:          * then they will be notified that they are blocking forward progress, and may take action to avoid that.
1:4b54b8a:          */
1:4b54b8a: 
1:4b54b8a:         private volatile Group prev, next;
1:4b54b8a:         private final long id; // monotonically increasing id for compareTo()
1:4b54b8a:         private volatile int running = 0; // number of operations currently running.  < 0 means we're expired, and the count of tasks still running is -(running + 1)
1:4b54b8a:         private volatile boolean isBlocking; // indicates running operations are blocking future barriers
1:4b54b8a:         private final WaitQueue isBlockingSignal = new WaitQueue(); // signal to wait on to indicate isBlocking is true
1:4b54b8a:         private final WaitQueue waiting = new WaitQueue(); // signal to wait on for completion
1:4b54b8a: 
1:4b54b8a:         static final AtomicIntegerFieldUpdater<Group> runningUpdater = AtomicIntegerFieldUpdater.newUpdater(Group.class, "running");
1:4b54b8a: 
1:4b54b8a:         // constructs first instance only
1:4b54b8a:         private Group()
1:4b54b8a:         {
1:4b54b8a:             this.id = 0;
1:4b54b8a:         }
1:4b54b8a: 
1:4b54b8a:         private Group(Group prev)
1:4b54b8a:         {
1:4b54b8a:             this.id = prev.id + 1;
1:4b54b8a:             this.prev = prev;
1:4b54b8a:         }
1:4b54b8a: 
1:4b54b8a:         // prevents any further operations starting against this Ordered instance
1:269f810:         // if there are no running operations, calls unlink; otherwise, we let the last op to close call it.
1:4b54b8a:         // this means issue() won't have to block for ops to finish.
1:4b54b8a:         private void expire()
1:4b54b8a:         {
1:4b54b8a:             while (true)
1:4b54b8a:             {
1:4b54b8a:                 int current = running;
1:4b54b8a:                 if (current < 0)
1:4b54b8a:                     throw new IllegalStateException();
1:4b54b8a:                 if (runningUpdater.compareAndSet(this, current, -1 - current))
1:4b54b8a:                 {
1:4b54b8a:                     // if we're already finished (no running ops), unlink ourselves
1:4b54b8a:                     if (current == 0)
1:4b54b8a:                         unlink();
1:4b54b8a:                     return;
1:4b54b8a:                 }
1:4b54b8a:             }
1:4b54b8a:         }
1:4b54b8a: 
1:4b54b8a:         // attempts to start an operation against this Ordered instance, and returns true if successful.
1:4b54b8a:         private boolean register()
1:4b54b8a:         {
1:4b54b8a:             while (true)
1:4b54b8a:             {
1:4b54b8a:                 int current = running;
1:4b54b8a:                 if (current < 0)
1:4b54b8a:                     return false;
1:4b54b8a:                 if (runningUpdater.compareAndSet(this, current, current + 1))
1:4b54b8a:                     return true;
1:4b54b8a:             }
1:4b54b8a:         }
1:4b54b8a: 
1:4b54b8a:         /**
1:4b54b8a:          * To be called exactly once for each register() call this object is returned for, indicating the operation
1:4b54b8a:          * is complete
1:4b54b8a:          */
1:269f810:         public void close()
1:4b54b8a:         {
1:4b54b8a:             while (true)
1:4b54b8a:             {
1:4b54b8a:                 int current = running;
1:4b54b8a:                 if (current < 0)
1:4b54b8a:                 {
1:4b54b8a:                     if (runningUpdater.compareAndSet(this, current, current + 1))
1:4b54b8a:                     {
1:4b54b8a:                         if (current + 1 == FINISHED)
1:4b54b8a:                         {
1:4b54b8a:                             // if we're now finished, unlink ourselves
1:4b54b8a:                             unlink();
1:4b54b8a:                         }
1:4b54b8a:                         return;
1:4b54b8a:                     }
1:4b54b8a:                 }
1:4b54b8a:                 else if (runningUpdater.compareAndSet(this, current, current - 1))
1:4b54b8a:                 {
1:4b54b8a:                     return;
1:4b54b8a:                 }
1:4b54b8a:             }
1:4b54b8a:         }
1:4b54b8a: 
1:4b54b8a:         /**
1:4b54b8a:          * called once we know all operations started against this Ordered have completed,
1:4b54b8a:          * however we do not know if operations against its ancestors have completed, or
1:4b54b8a:          * if its descendants have completed ahead of it, so we attempt to create the longest
1:4b54b8a:          * chain from the oldest still linked Ordered. If we can't reach the oldest through
1:4b54b8a:          * an unbroken chain of completed Ordered, we abort, and leave the still completing
1:4b54b8a:          * ancestor to tidy up.
1:4b54b8a:          */
1:4b54b8a:         private void unlink()
1:4b54b8a:         {
1:4b54b8a:             // walk back in time to find the start of the list
1:4b54b8a:             Group start = this;
1:4b54b8a:             while (true)
1:4b54b8a:             {
1:4b54b8a:                 Group prev = start.prev;
1:4b54b8a:                 if (prev == null)
1:4b54b8a:                     break;
1:4b54b8a:                 // if we haven't finished this Ordered yet abort and let it clean up when it's done
1:4b54b8a:                 if (prev.running != FINISHED)
1:4b54b8a:                     return;
1:4b54b8a:                 start = prev;
1:4b54b8a:             }
1:4b54b8a: 
1:4b54b8a:             // now walk forwards in time, in case we finished up late
1:4b54b8a:             Group end = this.next;
1:4b54b8a:             while (end.running == FINISHED)
1:4b54b8a:                 end = end.next;
1:4b54b8a: 
1:4b54b8a:             // now walk from first to last, unlinking the prev pointer and waking up any blocking threads
1:4b54b8a:             while (start != end)
1:4b54b8a:             {
1:4b54b8a:                 Group next = start.next;
1:4b54b8a:                 next.prev = null;
1:4b54b8a:                 start.waiting.signalAll();
1:4b54b8a:                 start = next;
1:4b54b8a:             }
1:4b54b8a:         }
1:4b54b8a: 
1:4b54b8a:         /**
1:4b54b8a:          * @return true if a barrier we are behind is, or may be, blocking general progress,
1:4b54b8a:          * so we should try more aggressively to progress
1:4b54b8a:          */
1:4b54b8a:         public boolean isBlocking()
1:4b54b8a:         {
1:4b54b8a:             return isBlocking;
1:4b54b8a:         }
1:4b54b8a: 
1:4b54b8a:         /**
1:4b54b8a:          * register to be signalled when a barrier waiting on us is, or maybe, blocking general progress,
1:4b54b8a:          * so we should try more aggressively to progress
1:4b54b8a:          */
1:4b54b8a:         public WaitQueue.Signal isBlockingSignal()
1:4b54b8a:         {
1:4b54b8a:             return isBlockingSignal.register();
1:4b54b8a:         }
1:4b54b8a: 
1:4b54b8a:         /**
1:4b54b8a:          * wrap the provided signal to also be signalled if the operation gets marked blocking
1:4b54b8a:          */
1:4b54b8a:         public WaitQueue.Signal isBlockingSignal(WaitQueue.Signal signal)
1:4b54b8a:         {
1:4b54b8a:             return WaitQueue.any(signal, isBlockingSignal());
1:4b54b8a:         }
1:4b54b8a: 
1:4b54b8a:         public int compareTo(Group that)
1:4b54b8a:         {
1:4b54b8a:             // we deliberately use subtraction, as opposed to Long.compareTo() as we care about ordering
1:4b54b8a:             // not which is the smaller value, so this permits wrapping in the unlikely event we exhaust the long space
1:4b54b8a:             long c = this.id - that.id;
1:4b54b8a:             if (c > 0)
1:4b54b8a:                 return 1;
1:4b54b8a:             else if (c < 0)
1:4b54b8a:                 return -1;
1:4b54b8a:             else
1:4b54b8a:                 return 0;
1:4b54b8a:         }
1:4b54b8a:     }
1:4b54b8a: 
1:4b54b8a:     /**
1:4b54b8a:      * This class represents a synchronisation point providing ordering guarantees on operations started
1:4b54b8a:      * against the enclosing OpOrder.  When issue() is called upon it (may only happen once per Barrier), the
1:4b54b8a:      * Barrier atomically partitions new operations from those already running (by expiring the current Group),
1:4b54b8a:      * and activates its isAfter() method
1:4b54b8a:      * which indicates if an operation was started before or after this partition. It offers methods to
1:4b54b8a:      * determine, or block until, all prior operations have finished, and a means to indicate to those operations
1:4b54b8a:      * that they are blocking forward progress. See {@link OpOrder} for idiomatic usage.
1:4b54b8a:      */
1:4b54b8a:     public final class Barrier
1:4b54b8a:     {
1:4b54b8a:         // this Barrier was issued after all Group operations started against orderOnOrBefore
1:4b54b8a:         private volatile Group orderOnOrBefore;
1:4b54b8a: 
1:4b54b8a:         /**
1:4b54b8a:          * @return true if @param group was started prior to the issuing of the barrier.
1:4b54b8a:          *
1:4b54b8a:          * (Until issue is called, always returns true, but if you rely on this behavior you are probably
1:4b54b8a:          * Doing It Wrong.)
1:4b54b8a:          */
1:4b54b8a:         public boolean isAfter(Group group)
1:4b54b8a:         {
1:4b54b8a:             if (orderOnOrBefore == null)
1:4b54b8a:                 return true;
1:4b54b8a:             // we subtract to permit wrapping round the full range of Long - so we only need to ensure
1:4b54b8a:             // there are never Long.MAX_VALUE * 2 total Group objects in existence at any one timem which will
1:4b54b8a:             // take care of itself
1:4b54b8a:             return orderOnOrBefore.id - group.id >= 0;
1:4b54b8a:         }
1:4b54b8a: 
1:4b54b8a:         /**
1:4b54b8a:          * Issues (seals) the barrier, meaning no new operations may be issued against it, and expires the current
1:4b54b8a:          * Group.  Must be called before await() for isAfter() to be properly synchronised.
1:4b54b8a:          */
1:4b54b8a:         public void issue()
1:4b54b8a:         {
1:4b54b8a:             if (orderOnOrBefore != null)
1:4b54b8a:                 throw new IllegalStateException("Can only call issue() once on each Barrier");
1:4b54b8a: 
1:4b54b8a:             final Group current;
1:4b54b8a:             synchronized (OpOrder.this)
1:4b54b8a:             {
1:4b54b8a:                 current = OpOrder.this.current;
1:4b54b8a:                 orderOnOrBefore = current;
1:4b54b8a:                 OpOrder.this.current = current.next = new Group(current);
1:4b54b8a:             }
1:4b54b8a:             current.expire();
1:4b54b8a:         }
1:4b54b8a: 
1:4b54b8a:         /**
1:4b54b8a:          * Mark all prior operations as blocking, potentially signalling them to more aggressively make progress
1:4b54b8a:          */
1:4b54b8a:         public void markBlocking()
1:4b54b8a:         {
1:4b54b8a:             Group current = orderOnOrBefore;
1:4b54b8a:             while (current != null)
1:4b54b8a:             {
1:4b54b8a:                 current.isBlocking = true;
1:4b54b8a:                 current.isBlockingSignal.signalAll();
1:4b54b8a:                 current = current.prev;
1:4b54b8a:             }
1:4b54b8a:         }
1:4b54b8a: 
1:4b54b8a:         /**
1:4b54b8a:          * Register to be signalled once allPriorOpsAreFinished() or allPriorOpsAreFinishedOrSafe() may return true
1:4b54b8a:          */
1:4b54b8a:         public WaitQueue.Signal register()
1:4b54b8a:         {
1:4b54b8a:             return orderOnOrBefore.waiting.register();
1:4b54b8a:         }
1:4b54b8a: 
1:4b54b8a:         /**
1:4b54b8a:          * @return true if all operations started prior to barrier.issue() have completed
1:4b54b8a:          */
1:4b54b8a:         public boolean allPriorOpsAreFinished()
1:4b54b8a:         {
1:4b54b8a:             Group current = orderOnOrBefore;
1:4b54b8a:             if (current == null)
1:4b54b8a:                 throw new IllegalStateException("This barrier needs to have issue() called on it before prior operations can complete");
1:4b54b8a:             if (current.next.prev == null)
1:4b54b8a:                 return true;
1:4b54b8a:             return false;
1:4b54b8a:         }
1:4b54b8a: 
1:4b54b8a:         /**
1:4b54b8a:          * wait for all operations started prior to issuing the barrier to complete
1:4b54b8a:          */
1:4b54b8a:         public void await()
1:4b54b8a:         {
1:4b54b8a:             while (!allPriorOpsAreFinished())
1:4b54b8a:             {
1:4b54b8a:                 WaitQueue.Signal signal = register();
1:4b54b8a:                 if (allPriorOpsAreFinished())
1:4b54b8a:                 {
1:4b54b8a:                     signal.cancel();
1:4b54b8a:                     return;
1:4b54b8a:                 }
1:4b54b8a:                 else
1:4b54b8a:                     signal.awaitUninterruptibly();
1:4b54b8a:             }
1:4b54b8a:             assert orderOnOrBefore.running == FINISHED;
1:4b54b8a:         }
1:4b54b8a: 
1:4b54b8a:         /**
1:143a7d9:          * returns the Group we are waiting on - any Group with {@code .compareTo(getSyncPoint()) <= 0}
1:4b54b8a:          * must complete before await() returns
1:4b54b8a:          */
1:4b54b8a:         public Group getSyncPoint()
1:4b54b8a:         {
1:4b54b8a:             return orderOnOrBefore;
1:4b54b8a:         }
1:4b54b8a:     }
1:4b54b8a: }
============================================================================
author:Dave Brosius
-------------------------------------------------------------------------------
commit:143a7d9
/////////////////////////////////////////////////////////////////////////
1:          * returns the Group we are waiting on - any Group with {@code .compareTo(getSyncPoint()) <= 0}
commit:222ea95
/////////////////////////////////////////////////////////////////////////
1:  * {@code
/////////////////////////////////////////////////////////////////////////
1:  * }
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:0e393c9
/////////////////////////////////////////////////////////////////////////
1:     public void awaitNewBarrier()
1:     {
1:         Barrier barrier = newBarrier();
1:         barrier.issue();
1:         barrier.await();
1:     }
1: 
author:belliottsmith
-------------------------------------------------------------------------------
commit:269f810
/////////////////////////////////////////////////////////////////////////
1:             try (Group opGroup = order.start())
/////////////////////////////////////////////////////////////////////////
1:      * Once the operation is completed Ordered.close() MUST be called EXACTLY once for this operation.
/////////////////////////////////////////////////////////////////////////
1:      * two barrier issuances. For each register() call this is returned, close() must be called exactly once.
1:     public static final class Group implements Comparable<Group>, AutoCloseable
1:          * 1) LIVE:      many calls to register() and close()
1:          * 3) FINISHED:  once the last close() is called, this Ordered is done. We call unlink().
/////////////////////////////////////////////////////////////////////////
1:         // if there are no running operations, calls unlink; otherwise, we let the last op to close call it.
/////////////////////////////////////////////////////////////////////////
1:         public void close()
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:9f14856
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:4b54b8a
/////////////////////////////////////////////////////////////////////////
1: package org.apache.cassandra.utils.concurrent;
1: 
1: import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
1: 
1: /**
1:  * <p>A class for providing synchronization between producers and consumers that do not
1:  * communicate directly with each other, but where the consumers need to process their
1:  * work in contiguous batches. In particular this is useful for both CommitLog and Memtable
1:  * where the producers (writing threads) are modifying a structure that the consumer
1:  * (flush executor) only batch syncs, but needs to know what 'position' the work is at
1:  * for co-ordination with other processes,
1:  *
1:  * <p>The typical usage is something like:
1:  * <pre>
1:      public final class ExampleShared
1:      {
1:         final OpOrder order = new OpOrder();
1:         volatile SharedState state;
1: 
1:         static class SharedState
1:         {
1:             volatile Barrier barrier;
1: 
1:             // ...
1:         }
1: 
1:         public void consume()
1:         {
1:             SharedState state = this.state;
1:             state.setReplacement(new State())
1:             state.doSomethingToPrepareForBarrier();
1: 
1:             state.barrier = order.newBarrier();
1:             // seal() MUST be called after newBarrier() else barrier.isAfter()
1:             // will always return true, and barrier.await() will fail
1:             state.barrier.issue();
1: 
1:             // wait for all producer work started prior to the barrier to complete
1:             state.barrier.await();
1: 
1:             // change the shared state to its replacement, as the current state will no longer be used by producers
1:             this.state = state.getReplacement();
1: 
1:             state.doSomethingWithExclusiveAccess();
1:         }
1: 
1:         public void produce()
1:         {
0:             Group opGroup = order.start();
0:             try
1:             {
1:                 SharedState s = state;
1:                 while (s.barrier != null && !s.barrier.isAfter(opGroup))
1:                     s = s.getReplacement();
1:                 s.doProduceWork();
1:             }
0:             finally
1:             {
0:                 opGroup.finishOne();
1:             }
1:         }
1:     }
1:  * </pre>
1:  */
1: public class OpOrder
1: {
1:     /**
1:      * Constant that when an Ordered.running is equal to, indicates the Ordered is complete
1:      */
1:     private static final int FINISHED = -1;
1: 
1:     /**
1:      * A linked list starting with the most recent Ordered object, i.e. the one we should start new operations from,
1:      * with (prev) links to any incomplete Ordered instances, and (next) links to any potential future Ordered instances.
1:      * Once all operations started against an Ordered instance and its ancestors have been finished the next instance
1:      * will unlink this one
1:      */
1:     private volatile Group current = new Group();
1: 
1:     /**
1:      * Start an operation against this OpOrder.
0:      * Once the operation is completed Ordered.finishOne() MUST be called EXACTLY once for this operation.
1:      *
1:      * @return the Ordered instance that manages this OpOrder
1:      */
1:     public Group start()
1:     {
1:         while (true)
1:         {
1:             Group current = this.current;
1:             if (current.register())
1:                 return current;
1:         }
1:     }
1: 
1:     /**
1:      * Creates a new barrier. The barrier is only a placeholder until barrier.issue() is called on it,
1:      * after which all new operations will start against a new Group that will not be accepted
1:      * by barrier.isAfter(), and barrier.await() will return only once all operations started prior to the issue
1:      * have completed.
1:      *
1:      * @return
1:      */
1:     public Barrier newBarrier()
1:     {
1:         return new Barrier();
1:     }
1: 
1:     public Group getCurrent()
1:     {
1:         return current;
1:     }
1: 
1:     /**
1:      * Represents a group of identically ordered operations, i.e. all operations started in the interval between
0:      * two barrier issuances. For each register() call this is returned, finishOne() must be called exactly once.
1:      * It should be treated like taking a lock().
1:      */
0:     public static final class Group implements Comparable<Group>
1:     {
1:         /**
1:          * In general this class goes through the following stages:
0:          * 1) LIVE:      many calls to register() and finishOne()
1:          * 2) FINISHING: a call to expire() (after a barrier issue), means calls to register() will now fail,
1:          *               and we are now 'in the past' (new operations will be started against a new Ordered)
0:          * 3) FINISHED:  once the last finishOne() is called, this Ordered is done. We call unlink().
1:          * 4) ZOMBIE:    all our operations are finished, but some operations against an earlier Ordered are still
1:          *               running, or tidying up, so unlink() fails to remove us
1:          * 5) COMPLETE:  all operations started on or before us are FINISHED (and COMPLETE), so we are unlinked
1:          * <p/>
1:          * Another parallel states is ISBLOCKING:
1:          * <p/>
1:          * isBlocking => a barrier that is waiting on us (either directly, or via a future Ordered) is blocking general
1:          * progress. This state is entered by calling Barrier.markBlocking(). If the running operations are blocked
1:          * on a Signal that is also registered with the isBlockingSignal (probably through isSafeBlockingSignal)
1:          * then they will be notified that they are blocking forward progress, and may take action to avoid that.
1:          */
1: 
1:         private volatile Group prev, next;
1:         private final long id; // monotonically increasing id for compareTo()
1:         private volatile int running = 0; // number of operations currently running.  < 0 means we're expired, and the count of tasks still running is -(running + 1)
1:         private volatile boolean isBlocking; // indicates running operations are blocking future barriers
1:         private final WaitQueue isBlockingSignal = new WaitQueue(); // signal to wait on to indicate isBlocking is true
1:         private final WaitQueue waiting = new WaitQueue(); // signal to wait on for completion
1: 
1:         static final AtomicIntegerFieldUpdater<Group> runningUpdater = AtomicIntegerFieldUpdater.newUpdater(Group.class, "running");
1: 
1:         // constructs first instance only
1:         private Group()
1:         {
1:             this.id = 0;
1:         }
1: 
1:         private Group(Group prev)
1:         {
1:             this.id = prev.id + 1;
1:             this.prev = prev;
1:         }
1: 
1:         // prevents any further operations starting against this Ordered instance
0:         // if there are no running operations, calls unlink; otherwise, we let the last op to finishOne call it.
1:         // this means issue() won't have to block for ops to finish.
1:         private void expire()
1:         {
1:             while (true)
1:             {
1:                 int current = running;
1:                 if (current < 0)
1:                     throw new IllegalStateException();
1:                 if (runningUpdater.compareAndSet(this, current, -1 - current))
1:                 {
1:                     // if we're already finished (no running ops), unlink ourselves
1:                     if (current == 0)
1:                         unlink();
1:                     return;
1:                 }
1:             }
1:         }
1: 
1:         // attempts to start an operation against this Ordered instance, and returns true if successful.
1:         private boolean register()
1:         {
1:             while (true)
1:             {
1:                 int current = running;
1:                 if (current < 0)
1:                     return false;
1:                 if (runningUpdater.compareAndSet(this, current, current + 1))
1:                     return true;
1:             }
1:         }
1: 
1:         /**
1:          * To be called exactly once for each register() call this object is returned for, indicating the operation
1:          * is complete
1:          */
0:         public void finishOne()
1:         {
1:             while (true)
1:             {
1:                 int current = running;
1:                 if (current < 0)
1:                 {
1:                     if (runningUpdater.compareAndSet(this, current, current + 1))
1:                     {
1:                         if (current + 1 == FINISHED)
1:                         {
1:                             // if we're now finished, unlink ourselves
1:                             unlink();
1:                         }
1:                         return;
1:                     }
1:                 }
1:                 else if (runningUpdater.compareAndSet(this, current, current - 1))
1:                 {
1:                     return;
1:                 }
1:             }
1:         }
1: 
1:         /**
1:          * called once we know all operations started against this Ordered have completed,
1:          * however we do not know if operations against its ancestors have completed, or
1:          * if its descendants have completed ahead of it, so we attempt to create the longest
1:          * chain from the oldest still linked Ordered. If we can't reach the oldest through
1:          * an unbroken chain of completed Ordered, we abort, and leave the still completing
1:          * ancestor to tidy up.
1:          */
1:         private void unlink()
1:         {
1:             // walk back in time to find the start of the list
1:             Group start = this;
1:             while (true)
1:             {
1:                 Group prev = start.prev;
1:                 if (prev == null)
1:                     break;
1:                 // if we haven't finished this Ordered yet abort and let it clean up when it's done
1:                 if (prev.running != FINISHED)
1:                     return;
1:                 start = prev;
1:             }
1: 
1:             // now walk forwards in time, in case we finished up late
1:             Group end = this.next;
1:             while (end.running == FINISHED)
1:                 end = end.next;
1: 
1:             // now walk from first to last, unlinking the prev pointer and waking up any blocking threads
1:             while (start != end)
1:             {
1:                 Group next = start.next;
1:                 next.prev = null;
1:                 start.waiting.signalAll();
1:                 start = next;
1:             }
1:         }
1: 
1:         /**
1:          * @return true if a barrier we are behind is, or may be, blocking general progress,
1:          * so we should try more aggressively to progress
1:          */
1:         public boolean isBlocking()
1:         {
1:             return isBlocking;
1:         }
1: 
1:         /**
1:          * register to be signalled when a barrier waiting on us is, or maybe, blocking general progress,
1:          * so we should try more aggressively to progress
1:          */
1:         public WaitQueue.Signal isBlockingSignal()
1:         {
1:             return isBlockingSignal.register();
1:         }
1: 
1:         /**
1:          * wrap the provided signal to also be signalled if the operation gets marked blocking
1:          */
1:         public WaitQueue.Signal isBlockingSignal(WaitQueue.Signal signal)
1:         {
1:             return WaitQueue.any(signal, isBlockingSignal());
1:         }
1: 
1:         public int compareTo(Group that)
1:         {
1:             // we deliberately use subtraction, as opposed to Long.compareTo() as we care about ordering
1:             // not which is the smaller value, so this permits wrapping in the unlikely event we exhaust the long space
1:             long c = this.id - that.id;
1:             if (c > 0)
1:                 return 1;
1:             else if (c < 0)
1:                 return -1;
1:             else
1:                 return 0;
1:         }
1:     }
1: 
1:     /**
1:      * This class represents a synchronisation point providing ordering guarantees on operations started
1:      * against the enclosing OpOrder.  When issue() is called upon it (may only happen once per Barrier), the
1:      * Barrier atomically partitions new operations from those already running (by expiring the current Group),
1:      * and activates its isAfter() method
1:      * which indicates if an operation was started before or after this partition. It offers methods to
1:      * determine, or block until, all prior operations have finished, and a means to indicate to those operations
1:      * that they are blocking forward progress. See {@link OpOrder} for idiomatic usage.
1:      */
1:     public final class Barrier
1:     {
1:         // this Barrier was issued after all Group operations started against orderOnOrBefore
1:         private volatile Group orderOnOrBefore;
1: 
1:         /**
1:          * @return true if @param group was started prior to the issuing of the barrier.
1:          *
1:          * (Until issue is called, always returns true, but if you rely on this behavior you are probably
1:          * Doing It Wrong.)
1:          */
1:         public boolean isAfter(Group group)
1:         {
1:             if (orderOnOrBefore == null)
1:                 return true;
1:             // we subtract to permit wrapping round the full range of Long - so we only need to ensure
1:             // there are never Long.MAX_VALUE * 2 total Group objects in existence at any one timem which will
1:             // take care of itself
1:             return orderOnOrBefore.id - group.id >= 0;
1:         }
1: 
1:         /**
1:          * Issues (seals) the barrier, meaning no new operations may be issued against it, and expires the current
1:          * Group.  Must be called before await() for isAfter() to be properly synchronised.
1:          */
1:         public void issue()
1:         {
1:             if (orderOnOrBefore != null)
1:                 throw new IllegalStateException("Can only call issue() once on each Barrier");
1: 
1:             final Group current;
1:             synchronized (OpOrder.this)
1:             {
1:                 current = OpOrder.this.current;
1:                 orderOnOrBefore = current;
1:                 OpOrder.this.current = current.next = new Group(current);
1:             }
1:             current.expire();
1:         }
1: 
1:         /**
1:          * Mark all prior operations as blocking, potentially signalling them to more aggressively make progress
1:          */
1:         public void markBlocking()
1:         {
1:             Group current = orderOnOrBefore;
1:             while (current != null)
1:             {
1:                 current.isBlocking = true;
1:                 current.isBlockingSignal.signalAll();
1:                 current = current.prev;
1:             }
1:         }
1: 
1:         /**
1:          * Register to be signalled once allPriorOpsAreFinished() or allPriorOpsAreFinishedOrSafe() may return true
1:          */
1:         public WaitQueue.Signal register()
1:         {
1:             return orderOnOrBefore.waiting.register();
1:         }
1: 
1:         /**
1:          * @return true if all operations started prior to barrier.issue() have completed
1:          */
1:         public boolean allPriorOpsAreFinished()
1:         {
1:             Group current = orderOnOrBefore;
1:             if (current == null)
1:                 throw new IllegalStateException("This barrier needs to have issue() called on it before prior operations can complete");
1:             if (current.next.prev == null)
1:                 return true;
1:             return false;
1:         }
1: 
1:         /**
1:          * wait for all operations started prior to issuing the barrier to complete
1:          */
1:         public void await()
1:         {
1:             while (!allPriorOpsAreFinished())
1:             {
1:                 WaitQueue.Signal signal = register();
1:                 if (allPriorOpsAreFinished())
1:                 {
1:                     signal.cancel();
1:                     return;
1:                 }
1:                 else
1:                     signal.awaitUninterruptibly();
1:             }
1:             assert orderOnOrBefore.running == FINISHED;
1:         }
1: 
1:         /**
0:          * returns the Group we are waiting on - any Group with .compareTo(getSyncPoint()) <= 0
1:          * must complete before await() returns
1:          */
1:         public Group getSyncPoint()
1:         {
1:             return orderOnOrBefore;
1:         }
1:     }
1: }
============================================================================