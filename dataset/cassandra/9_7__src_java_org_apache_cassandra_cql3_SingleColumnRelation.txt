1:4349638: /*
1:4349638:  * Licensed to the Apache Software Foundation (ASF) under one
1:4349638:  * or more contributor license agreements.  See the NOTICE file
1:4349638:  * distributed with this work for additional information
1:4349638:  * regarding copyright ownership.  The ASF licenses this file
1:4349638:  * to you under the Apache License, Version 2.0 (the
1:4349638:  * "License"); you may not use this file except in compliance
1:4349638:  * with the License.  You may obtain a copy of the License at
1:4349638:  *
1:4349638:  *     http://www.apache.org/licenses/LICENSE-2.0
1:4349638:  *
1:4349638:  * Unless required by applicable law or agreed to in writing, software
1:4349638:  * distributed under the License is distributed on an "AS IS" BASIS,
1:4349638:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:4349638:  * See the License for the specific language governing permissions and
1:4349638:  * limitations under the License.
1:4349638:  */
1:4349638: package org.apache.cassandra.cql3;
1:4349638: 
1:65a7088: import java.util.Collections;
1:3f55c35: import java.util.ArrayList;
1:4349638: import java.util.List;
1:4349638: 
1:65a7088: import org.apache.cassandra.config.CFMetaData;
1:65a7088: import org.apache.cassandra.config.ColumnDefinition;
1:65a7088: import org.apache.cassandra.cql3.Term.Raw;
1:65a7088: import org.apache.cassandra.cql3.restrictions.Restriction;
1:65a7088: import org.apache.cassandra.cql3.restrictions.SingleColumnRestriction;
1:65a7088: import org.apache.cassandra.cql3.statements.Bound;
1:65a7088: import org.apache.cassandra.db.marshal.CollectionType;
1:bfd57d1: import org.apache.cassandra.db.marshal.DurationType;
1:3f55c35: import org.apache.cassandra.db.marshal.ListType;
1:65a7088: import org.apache.cassandra.db.marshal.MapType;
1:65a7088: import org.apache.cassandra.exceptions.InvalidRequestException;
1:65a7088: 
1:65a7088: import static org.apache.cassandra.cql3.statements.RequestValidations.checkFalse;
1:3f55c35: import static org.apache.cassandra.cql3.statements.RequestValidations.checkTrue;
1:3928665: import static org.apache.cassandra.cql3.statements.RequestValidations.invalidRequest;
1:65a7088: 
1:4349638: /**
1:4349638:  * Relations encapsulate the relationship between an entity of some kind, and
1:6b7db8a:  * a value (term). For example, {@code <key> > "start" or "colname1" = "somevalue"}.
1:4349638:  *
1:4349638:  */
1:65a7088: public final class SingleColumnRelation extends Relation
1:4349638: {
1:4ed0060:     private final ColumnDefinition.Raw entity;
1:3f55c35:     private final Term.Raw mapKey;
1:4349638:     private final Term.Raw value;
1:4349638:     private final List<Term.Raw> inValues;
1:4349638: 
1:4ed0060:     private SingleColumnRelation(ColumnDefinition.Raw entity, Term.Raw mapKey, Operator type, Term.Raw value, List<Term.Raw> inValues)
1:4349638:     {
1:4349638:         this.entity = entity;
1:3f55c35:         this.mapKey = mapKey;
1:4349638:         this.relationType = type;
1:4349638:         this.value = value;
1:4349638:         this.inValues = inValues;
1:5a4253b: 
1:5a4253b:         if (type == Operator.IS_NOT)
1:5a4253b:             assert value == Constants.NULL_LITERAL;
1:4349638:     }
1:4349638: 
1:4349638:     /**
1:4349638:      * Creates a new relation.
1:d06fd78:      *
1:4349638:      * @param entity the kind of relation this is; what the term is being compared to.
1:3f55c35:      * @param mapKey the key into the entity identifying the value the term is being compared to.
1:4349638:      * @param type the type that describes how this entity relates to the value.
1:4349638:      * @param value the value being compared.
1:4349638:      */
1:4ed0060:     public SingleColumnRelation(ColumnDefinition.Raw entity, Term.Raw mapKey, Operator type, Term.Raw value)
1:5a4253b:     {
1:3f55c35:         this(entity, mapKey, type, value, null);
1:4349638:     }
1:4349638: 
1:65a7088:     /**
1:3f55c35:      * Creates a new relation.
1:4349638:      *
1:3f55c35:      * @param entity the kind of relation this is; what the term is being compared to.
1:3f55c35:      * @param type the type that describes how this entity relates to the value.
1:3f55c35:      * @param value the value being compared.
1:65a7088:      */
1:4ed0060:     public SingleColumnRelation(ColumnDefinition.Raw entity, Operator type, Term.Raw value)
1:4349638:     {
1:3f55c35:         this(entity, null, type, value);
1:4349638:     }
1:4349638: 
1:5a4253b:     public Term.Raw getValue()
1:5a4253b:     {
1:5a4253b:         return value;
1:5a4253b:     }
1:5a4253b: 
1:5a4253b:     public List<? extends Term.Raw> getInValues()
1:5a4253b:     {
1:5a4253b:         return inValues;
1:5a4253b:     }
1:5a4253b: 
1:4ed0060:     public static SingleColumnRelation createInRelation(ColumnDefinition.Raw entity, List<Term.Raw> inValues)
1:4349638:     {
1:3f55c35:         return new SingleColumnRelation(entity, null, Operator.IN, null, inValues);
1:4349638:     }
1:4349638: 
1:4ed0060:     public ColumnDefinition.Raw getEntity()
1:4349638:     {
1:4349638:         return entity;
1:4349638:     }
1:4349638: 
1:3f55c35:     public Term.Raw getMapKey()
1:4349638:     {
1:3f55c35:         return mapKey;
1:4349638:     }
1:4349638: 
1:4349638:     @Override
1:65a7088:     protected Term toTerm(List<? extends ColumnSpecification> receivers,
1:65a7088:                           Raw raw,
1:65a7088:                           String keyspace,
1:65a7088:                           VariableSpecifications boundNames)
1:65a7088:                           throws InvalidRequestException
1:4349638:     {
1:65a7088:         assert receivers.size() == 1;
1:4349638: 
1:65a7088:         Term term = raw.prepare(keyspace, receivers.get(0));
1:65a7088:         term.collectMarkerSpecification(boundNames);
1:65a7088:         return term;
1:4349638:     }
1:4349638: 
1:79a4dd5:     public SingleColumnRelation withNonStrictOperator()
1:79a4dd5:     {
1:79a4dd5:         switch (relationType)
1:79a4dd5:         {
1:5117a5d:             case GT: return new SingleColumnRelation(entity, Operator.GTE, value);
1:3f55c35:             case LT: return new SingleColumnRelation(entity, Operator.LTE, value);
1:79a4dd5:             default: return this;
1:79a4dd5:         }
1:79a4dd5:     }
1:79a4dd5: 
1:4ed0060:     public Relation renameIdentifier(ColumnDefinition.Raw from, ColumnDefinition.Raw to)
1:4349638:     {
1:5a4253b:         return entity.equals(from)
1:5a4253b:                ? new SingleColumnRelation(to, mapKey, operator(), value, inValues)
1:5a4253b:                : this;
1:5a4253b:     }
1:5a4253b: 
1:65a7088:     @Override
1:4349638:     public String toString()
1:4349638:     {
1:3f55c35:         String entityAsString = entity.toString();
1:3f55c35:         if (mapKey != null)
1:3f55c35:             entityAsString = String.format("%s[%s]", entityAsString, mapKey);
1:65a7088: 
1:65a7088:         if (isIN())
1:3f55c35:             return String.format("%s IN %s", entityAsString, inValues);
1:3928665: 
1:3f55c35:         return String.format("%s %s %s", entityAsString, relationType, value);
1:4349638:     }
1:65a7088: 
1:65a7088:     @Override
1:65a7088:     protected Restriction newEQRestriction(CFMetaData cfm,
1:65a7088:                                            VariableSpecifications boundNames) throws InvalidRequestException
1:4349638:     {
1:4ed0060:         ColumnDefinition columnDef = entity.prepare(cfm);
1:3f55c35:         if (mapKey == null)
1:65a7088:         {
1:2c4b301:             Term term = toTerm(toReceivers(columnDef), value, cfm.ksName, boundNames);
1:a991b64:             return new SingleColumnRestriction.EQRestriction(columnDef, term);
1:4349638:         }
1:2c4b301:         List<? extends ColumnSpecification> receivers = toReceivers(columnDef);
1:3f55c35:         Term entryKey = toTerm(Collections.singletonList(receivers.get(0)), mapKey, cfm.ksName, boundNames);
1:3f55c35:         Term entryValue = toTerm(Collections.singletonList(receivers.get(1)), value, cfm.ksName, boundNames);
1:a991b64:         return new SingleColumnRestriction.ContainsRestriction(columnDef, entryKey, entryValue);
1:4349638:     }
1:65a7088: 
1:65a7088:     @Override
1:65a7088:     protected Restriction newINRestriction(CFMetaData cfm,
1:65a7088:                                            VariableSpecifications boundNames) throws InvalidRequestException
1:65a7088:     {
1:4ed0060:         ColumnDefinition columnDef = entity.prepare(cfm);
1:2c4b301:         List<? extends ColumnSpecification> receivers = toReceivers(columnDef);
1:65a7088:         List<Term> terms = toTerms(receivers, inValues, cfm.ksName, boundNames);
1:65a7088:         if (terms == null)
1:65a7088:         {
1:65a7088:             Term term = toTerm(receivers, value, cfm.ksName, boundNames);
1:a991b64:             return new SingleColumnRestriction.InRestrictionWithMarker(columnDef, (Lists.Marker) term);
1:65a7088:         }
1:4205011: 
1:4205011:         // An IN restrictions with only one element is the same than an EQ restriction
1:4205011:         if (terms.size() == 1)
1:4205011:             return new SingleColumnRestriction.EQRestriction(columnDef, terms.get(0));
1:4205011: 
1:a991b64:         return new SingleColumnRestriction.InRestrictionWithValues(columnDef, terms);
1:65a7088:     }
1:65a7088: 
1:65a7088:     @Override
1:65a7088:     protected Restriction newSliceRestriction(CFMetaData cfm,
1:65a7088:                                               VariableSpecifications boundNames,
1:65a7088:                                               Bound bound,
1:65a7088:                                               boolean inclusive) throws InvalidRequestException
1:65a7088:     {
1:4ed0060:         ColumnDefinition columnDef = entity.prepare(cfm);
1:bfd57d1:         checkFalse(columnDef.type instanceof DurationType, "Slice restriction are not supported on duration columns");
1:bfd57d1: 
1:2c4b301:         Term term = toTerm(toReceivers(columnDef), value, cfm.ksName, boundNames);
1:a991b64:         return new SingleColumnRestriction.SliceRestriction(columnDef, bound, inclusive, term);
1:65a7088:     }
1:65a7088: 
1:65a7088:     @Override
1:65a7088:     protected Restriction newContainsRestriction(CFMetaData cfm,
1:65a7088:                                                  VariableSpecifications boundNames,
1:65a7088:                                                  boolean isKey) throws InvalidRequestException
1:65a7088:     {
1:4ed0060:         ColumnDefinition columnDef = entity.prepare(cfm);
1:2c4b301:         Term term = toTerm(toReceivers(columnDef), value, cfm.ksName, boundNames);
1:a991b64:         return new SingleColumnRestriction.ContainsRestriction(columnDef, term, isKey);
1:65a7088:     }
1:65a7088: 
1:5a4253b:     @Override
1:5a4253b:     protected Restriction newIsNotRestriction(CFMetaData cfm,
1:5a4253b:                                               VariableSpecifications boundNames) throws InvalidRequestException
1:5a4253b:     {
1:4ed0060:         ColumnDefinition columnDef = entity.prepare(cfm);
1:5a4253b:         // currently enforced by the grammar
1:5a4253b:         assert value == Constants.NULL_LITERAL : "Expected null literal for IS NOT relation: " + this.toString();
1:5a4253b:         return new SingleColumnRestriction.IsNotNullRestriction(columnDef);
1:5a4253b:     }
1:5a4253b: 
1:3928665:     @Override
1:3928665:     protected Restriction newLikeRestriction(CFMetaData cfm, VariableSpecifications boundNames, Operator operator) throws InvalidRequestException
1:3928665:     {
1:3928665:         if (mapKey != null)
1:3928665:             throw invalidRequest("%s can't be used with collections.", operator());
1:3928665: 
1:4ed0060:         ColumnDefinition columnDef = entity.prepare(cfm);
1:2c4b301:         Term term = toTerm(toReceivers(columnDef), value, cfm.ksName, boundNames);
1:3928665: 
1:3928665:         return new SingleColumnRestriction.LikeRestriction(columnDef, operator, term);
1:3928665:     }
1:3928665: 
1:65a7088:     /**
1:65a7088:      * Returns the receivers for this relation.
1:65a7088:      * @param columnDef the column definition
1:65a7088:      * @return the receivers for the specified relation.
1:65a7088:      * @throws InvalidRequestException if the relation is invalid
1:65a7088:      */
1:2c4b301:     private List<? extends ColumnSpecification> toReceivers(ColumnDefinition columnDef) throws InvalidRequestException
1:65a7088:     {
1:65a7088:         ColumnSpecification receiver = columnDef;
1:65a7088: 
1:65a7088:         if (isIN())
1:65a7088:         {
1:65a7088:             // We only allow IN on the row key and the clustering key so far, never on non-PK columns, and this even if
1:65a7088:             // there's an index
1:65a7088:             // Note: for backward compatibility reason, we conside a IN of 1 value the same as a EQ, so we let that
1:65a7088:             // slide.
1:65a7088:             checkFalse(!columnDef.isPrimaryKeyColumn() && !canHaveOnlyOneValue(),
1:65a7088:                        "IN predicates on non-primary-key columns (%s) is not yet supported", columnDef.name);
1:65a7088:         }
1:65a7088: 
1:65a7088:         checkFalse(isContainsKey() && !(receiver.type instanceof MapType), "Cannot use CONTAINS KEY on non-map column %s", receiver.name);
1:2e3727e:         checkFalse(isContains() && !(receiver.type.isCollection()), "Cannot use CONTAINS on non-collection column %s", receiver.name);
1:65a7088: 
1:3f55c35:         if (mapKey != null)
1:65a7088:         {
1:3f55c35:             checkFalse(receiver.type instanceof ListType, "Indexes on list entries (%s[index] = value) are not currently supported.", receiver.name);
1:3f55c35:             checkTrue(receiver.type instanceof MapType, "Column %s cannot be used as a map", receiver.name);
1:3f55c35:             checkTrue(receiver.type.isMultiCell(), "Map-entry equality predicates on frozen map column %s are not supported", receiver.name);
1:3f55c35:             checkTrue(isEQ(), "Only EQ relations are supported on map entries");
1:65a7088:         }
1:65a7088: 
1:65a7088:         if (receiver.type.isCollection())
1:65a7088:         {
1:65a7088:             // We don't support relations against entire collections (unless they're frozen), like "numbers = {1, 2, 3}"
1:3f55c35:             checkFalse(receiver.type.isMultiCell() && !isLegalRelationForNonFrozenCollection(),
1:65a7088:                        "Collection column '%s' (%s) cannot be restricted by a '%s' relation",
1:65a7088:                        receiver.name,
1:65a7088:                        receiver.type.asCQL3Type(),
1:65a7088:                        operator());
1:65a7088: 
1:65a7088:             if (isContainsKey() || isContains())
1:3f55c35:             {
1:3f55c35:                 receiver = makeCollectionReceiver(receiver, isContainsKey());
1:65a7088:             }
1:3f55c35:             else if (receiver.type.isMultiCell() && mapKey != null && isEQ())
1:3f55c35:             {
1:3f55c35:                 List<ColumnSpecification> receivers = new ArrayList<>(2);
1:3f55c35:                 receivers.add(makeCollectionReceiver(receiver, true));
1:3f55c35:                 receivers.add(makeCollectionReceiver(receiver, false));
1:3f55c35:                 return receivers;
1:65a7088:             }
1:65a7088:         }
1:65a7088: 
1:65a7088:         return Collections.singletonList(receiver);
1:65a7088:     }
1:65a7088: 
1:2e4ad06:     private static ColumnSpecification makeCollectionReceiver(ColumnSpecification receiver, boolean forKey)
1:65a7088:     {
1:3f55c35:         return ((CollectionType<?>) receiver.type).makeCollectionReceiver(receiver, forKey);
1:65a7088:     }
1:65a7088: 
1:3f55c35:     private boolean isLegalRelationForNonFrozenCollection()
1:3f55c35:     {
1:3f55c35:         return isContainsKey() || isContains() || isMapEntryEquality();
1:3f55c35:     }
1:3f55c35: 
1:3f55c35:     private boolean isMapEntryEquality()
6:3f55c35:     {
1:3f55c35:         return mapKey != null && isEQ();
1:3f55c35:     }
1:3f55c35: 
1:65a7088:     private boolean canHaveOnlyOneValue()
1:65a7088:     {
1:3928665:         return isEQ() || isLIKE() || (isIN() && inValues != null && inValues.size() == 1);
1:3f55c35:     }
6:3f55c35: }
============================================================================
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:bfd57d1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.marshal.DurationType;
/////////////////////////////////////////////////////////////////////////
1:         checkFalse(columnDef.type instanceof DurationType, "Slice restriction are not supported on duration columns");
1: 
commit:4205011
/////////////////////////////////////////////////////////////////////////
1: 
1:         // An IN restrictions with only one element is the same than an EQ restriction
1:         if (terms.size() == 1)
1:             return new SingleColumnRestriction.EQRestriction(columnDef, terms.get(0));
1: 
commit:8c83c8e
commit:9c3855b
/////////////////////////////////////////////////////////////////////////
commit:2e4ad06
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private static ColumnSpecification makeCollectionReceiver(ColumnSpecification receiver, boolean forKey)
/////////////////////////////////////////////////////////////////////////
author:ZhaoYang
-------------------------------------------------------------------------------
commit:3f49c32
/////////////////////////////////////////////////////////////////////////
author:Dave Brosius
-------------------------------------------------------------------------------
commit:2c4b301
/////////////////////////////////////////////////////////////////////////
1:             Term term = toTerm(toReceivers(columnDef), value, cfm.ksName, boundNames);
1:         List<? extends ColumnSpecification> receivers = toReceivers(columnDef);
/////////////////////////////////////////////////////////////////////////
1:         List<? extends ColumnSpecification> receivers = toReceivers(columnDef);
/////////////////////////////////////////////////////////////////////////
1:         Term term = toTerm(toReceivers(columnDef), value, cfm.ksName, boundNames);
/////////////////////////////////////////////////////////////////////////
1:         Term term = toTerm(toReceivers(columnDef), value, cfm.ksName, boundNames);
/////////////////////////////////////////////////////////////////////////
1:         Term term = toTerm(toReceivers(columnDef), value, cfm.ksName, boundNames);
/////////////////////////////////////////////////////////////////////////
1:     private List<? extends ColumnSpecification> toReceivers(ColumnDefinition columnDef) throws InvalidRequestException
commit:6b7db8a
/////////////////////////////////////////////////////////////////////////
1:  * a value (term). For example, {@code <key> > "start" or "colname1" = "somevalue"}.
commit:d06fd78
/////////////////////////////////////////////////////////////////////////
0:             Term term = toTerm(toReceivers(columnDef), value, cfm.ksName, boundNames);
0:         List<? extends ColumnSpecification> receivers = toReceivers(columnDef);
/////////////////////////////////////////////////////////////////////////
0:         List<? extends ColumnSpecification> receivers = toReceivers(columnDef);
/////////////////////////////////////////////////////////////////////////
0:         Term term = toTerm(toReceivers(columnDef), value, cfm.ksName, boundNames);
/////////////////////////////////////////////////////////////////////////
0:         Term term = toTerm(toReceivers(columnDef), value, cfm.ksName, boundNames);
1:      *
0:     private List<? extends ColumnSpecification> toReceivers(ColumnDefinition columnDef) throws InvalidRequestException
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:4ed0060
/////////////////////////////////////////////////////////////////////////
1:     private final ColumnDefinition.Raw entity;
1:     private SingleColumnRelation(ColumnDefinition.Raw entity, Term.Raw mapKey, Operator type, Term.Raw value, List<Term.Raw> inValues)
/////////////////////////////////////////////////////////////////////////
1:     public SingleColumnRelation(ColumnDefinition.Raw entity, Term.Raw mapKey, Operator type, Term.Raw value)
/////////////////////////////////////////////////////////////////////////
1:     public SingleColumnRelation(ColumnDefinition.Raw entity, Operator type, Term.Raw value)
/////////////////////////////////////////////////////////////////////////
1:     public static SingleColumnRelation createInRelation(ColumnDefinition.Raw entity, List<Term.Raw> inValues)
1:     public ColumnDefinition.Raw getEntity()
/////////////////////////////////////////////////////////////////////////
1:     public Relation renameIdentifier(ColumnDefinition.Raw from, ColumnDefinition.Raw to)
/////////////////////////////////////////////////////////////////////////
1:         ColumnDefinition columnDef = entity.prepare(cfm);
/////////////////////////////////////////////////////////////////////////
1:         ColumnDefinition columnDef = entity.prepare(cfm);
/////////////////////////////////////////////////////////////////////////
1:         ColumnDefinition columnDef = entity.prepare(cfm);
/////////////////////////////////////////////////////////////////////////
1:         ColumnDefinition columnDef = entity.prepare(cfm);
/////////////////////////////////////////////////////////////////////////
1:         ColumnDefinition columnDef = entity.prepare(cfm);
/////////////////////////////////////////////////////////////////////////
1:         ColumnDefinition columnDef = entity.prepare(cfm);
commit:a991b64
/////////////////////////////////////////////////////////////////////////
0:             Term term = toTerm(toReceivers(columnDef, cfm.isDense()), value, cfm.ksName, boundNames);
1:             return new SingleColumnRestriction.EQRestriction(columnDef, term);
0:         List<? extends ColumnSpecification> receivers = toReceivers(columnDef, cfm.isDense());
1:         return new SingleColumnRestriction.ContainsRestriction(columnDef, entryKey, entryValue);
/////////////////////////////////////////////////////////////////////////
0:         List<? extends ColumnSpecification> receivers = toReceivers(columnDef, cfm.isDense());
1:             return new SingleColumnRestriction.InRestrictionWithMarker(columnDef, (Lists.Marker) term);
1:         return new SingleColumnRestriction.InRestrictionWithValues(columnDef, terms);
/////////////////////////////////////////////////////////////////////////
0:         Term term = toTerm(toReceivers(columnDef, cfm.isDense()), value, cfm.ksName, boundNames);
1:         return new SingleColumnRestriction.SliceRestriction(columnDef, bound, inclusive, term);
/////////////////////////////////////////////////////////////////////////
0:         Term term = toTerm(toReceivers(columnDef, cfm.isDense()), value, cfm.ksName, boundNames);
1:         return new SingleColumnRestriction.ContainsRestriction(columnDef, term, isKey);
0:      * @param isDense whether the table is a dense one
0:     private List<? extends ColumnSpecification> toReceivers(ColumnDefinition columnDef, boolean isDense) throws InvalidRequestException
0:         checkFalse(!columnDef.isPrimaryKeyColumn() && isDense,
commit:6cabd25
/////////////////////////////////////////////////////////////////////////
0:         else if (onToken)
0:             return String.format("token(%s) %s %s", entity, relationType, value);
commit:79a4dd5
/////////////////////////////////////////////////////////////////////////
1:     public SingleColumnRelation withNonStrictOperator()
1:     {
1:         switch (relationType)
1:         {
0:             case GT: return new SingleColumnRelation(entity, Type.GTE, value);
0:             case LT:  return new SingleColumnRelation(entity, Type.LTE, value);
1:             default: return this;
1:         }
1:     }
1: 
author:Sam Tunnicliffe
-------------------------------------------------------------------------------
commit:bdae452
/////////////////////////////////////////////////////////////////////////
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:3928665
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.cassandra.cql3.statements.RequestValidations.invalidRequest;
/////////////////////////////////////////////////////////////////////////
0:         if (isLIKE())
0:             return String.format("%s %s", entityAsString, relationType);
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     protected Restriction newLikeRestriction(CFMetaData cfm, VariableSpecifications boundNames, Operator operator) throws InvalidRequestException
1:     {
1:         if (mapKey != null)
1:             throw invalidRequest("%s can't be used with collections.", operator());
1: 
0:         ColumnDefinition columnDef = toColumnDefinition(cfm, entity);
0:         Term term = toTerm(toReceivers(columnDef, cfm.isDense()), value, cfm.ksName, boundNames);
1: 
1:         return new SingleColumnRestriction.LikeRestriction(columnDef, operator, term);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         return isEQ() || isLIKE() || (isIN() && inValues != null && inValues.size() == 1);
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:5a4253b
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (type == Operator.IS_NOT)
1:             assert value == Constants.NULL_LITERAL;
/////////////////////////////////////////////////////////////////////////
1:     public Term.Raw getValue()
1:     {
1:         return value;
1:     }
1: 
1:     public List<? extends Term.Raw> getInValues()
1:     {
1:         return inValues;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:     public Relation renameIdentifier(ColumnIdentifier.Raw from, ColumnIdentifier.Raw to)
1:     {
1:         return entity.equals(from)
1:                ? new SingleColumnRelation(to, mapKey, operator(), value, inValues)
1:                : this;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     protected Restriction newIsNotRestriction(CFMetaData cfm,
1:                                               VariableSpecifications boundNames) throws InvalidRequestException
1:     {
0:         ColumnDefinition columnDef = toColumnDefinition(cfm, entity);
1:         // currently enforced by the grammar
1:         assert value == Constants.NULL_LITERAL : "Expected null literal for IS NOT relation: " + this.toString();
1:         return new SingleColumnRestriction.IsNotNullRestriction(columnDef);
1:     }
1: 
commit:a446e80
commit:11e6571
/////////////////////////////////////////////////////////////////////////
0:     private final ColumnIdentifier.Raw entity;
0:     private SingleColumnRelation(ColumnIdentifier.Raw entity, Type type, Term.Raw value, List<Term.Raw> inValues, boolean onToken)
/////////////////////////////////////////////////////////////////////////
0:     public SingleColumnRelation(ColumnIdentifier.Raw entity, Type type, Term.Raw value)
0:     public SingleColumnRelation(ColumnIdentifier.Raw entity, Type type, Term.Raw value, boolean onToken)
0:     public static SingleColumnRelation createInRelation(ColumnIdentifier.Raw entity, List<Term.Raw> inValues)
0:     public ColumnIdentifier.Raw getEntity()
commit:4349638
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.cql3;
1: 
1: import java.util.List;
1: 
1: /**
1:  * Relations encapsulate the relationship between an entity of some kind, and
0:  * a value (term). For example, <key> > "start" or "colname1" = "somevalue".
1:  *
1:  */
0: public class SingleColumnRelation extends Relation
1: {
0:     private final ColumnIdentifier entity;
1:     private final Term.Raw value;
1:     private final List<Term.Raw> inValues;
0:     public final boolean onToken;
1: 
0:     private SingleColumnRelation(ColumnIdentifier entity, Type type, Term.Raw value, List<Term.Raw> inValues, boolean onToken)
1:     {
1:         this.entity = entity;
1:         this.relationType = type;
1:         this.value = value;
1:         this.inValues = inValues;
0:         this.onToken = onToken;
1:     }
1: 
1:     /**
1:      * Creates a new relation.
1:      *
1:      * @param entity the kind of relation this is; what the term is being compared to.
1:      * @param type the type that describes how this entity relates to the value.
1:      * @param value the value being compared.
1:      */
0:     public SingleColumnRelation(ColumnIdentifier entity, Type type, Term.Raw value)
1:     {
0:         this(entity, type, value, null, false);
1:     }
1: 
0:     public SingleColumnRelation(ColumnIdentifier entity, Type type, Term.Raw value, boolean onToken)
1:     {
0:         this(entity, type, value, null, onToken);
1:     }
1: 
0:     public static SingleColumnRelation createInRelation(ColumnIdentifier entity, List<Term.Raw> inValues)
1:     {
0:         return new SingleColumnRelation(entity, Type.IN, null, inValues, false);
1:     }
1: 
0:     public ColumnIdentifier getEntity()
1:     {
1:         return entity;
1:     }
1: 
0:     public Term.Raw getValue()
1:     {
0:         assert relationType != Type.IN || value == null || value instanceof AbstractMarker.INRaw;
0:         return value;
1:     }
1: 
0:     public List<Term.Raw> getInValues()
1:     {
0:         assert relationType == Type.IN;
0:         return inValues;
1:     }
1: 
0:     public boolean isMultiColumn()
1:     {
0:         return false;
1:     }
1: 
1:     @Override
1:     public String toString()
1:     {
0:         if (relationType == Type.IN)
0:             return String.format("%s IN %s", entity, inValues);
0:         else
0:             return String.format("%s %s %s", entity, relationType, value);
1:     }
1: }
author:blerer
-------------------------------------------------------------------------------
commit:2e3727e
/////////////////////////////////////////////////////////////////////////
1:         checkFalse(isContains() && !(receiver.type.isCollection()), "Cannot use CONTAINS on non-collection column %s", receiver.name);
commit:be2c26f
commit:62fc314
/////////////////////////////////////////////////////////////////////////
0:         ColumnDefinition columnDef = toColumnDefinition(cfm, entity);
commit:65a7088
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collections;
1: import org.apache.cassandra.config.CFMetaData;
1: import org.apache.cassandra.config.ColumnDefinition;
1: import org.apache.cassandra.cql3.Term.Raw;
1: import org.apache.cassandra.cql3.restrictions.Restriction;
1: import org.apache.cassandra.cql3.restrictions.SingleColumnRestriction;
1: import org.apache.cassandra.cql3.statements.Bound;
1: import org.apache.cassandra.db.marshal.CollectionType;
1: import org.apache.cassandra.db.marshal.MapType;
1: import org.apache.cassandra.exceptions.InvalidRequestException;
1: 
1: import static org.apache.cassandra.cql3.statements.RequestValidations.checkFalse;
1: 
1: public final class SingleColumnRelation extends Relation
0:     private SingleColumnRelation(ColumnIdentifier.Raw entity, Operator type, Term.Raw value, List<Term.Raw> inValues)
/////////////////////////////////////////////////////////////////////////
0:         this(entity, type, value, null);
0:         return new SingleColumnRelation(entity, Operator.IN, null, inValues);
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     protected Term toTerm(List<? extends ColumnSpecification> receivers,
1:                           Raw raw,
1:                           String keyspace,
1:                           VariableSpecifications boundNames)
1:                           throws InvalidRequestException
1:         assert receivers.size() == 1;
1:         Term term = raw.prepare(keyspace, receivers.get(0));
1:         term.collectMarkerSpecification(boundNames);
1:         return term;
/////////////////////////////////////////////////////////////////////////
1:         if (isIN())
1: 
0:         return String.format("%s %s %s", entity, relationType, value);
1:     }
1: 
1:     @Override
1:     protected Restriction newEQRestriction(CFMetaData cfm,
1:                                            VariableSpecifications boundNames) throws InvalidRequestException
1:     {
0:         ColumnDefinition columnDef = toColumnDefinition(cfm, entity);
0:         Term term = toTerm(toReceivers(cfm, columnDef), value, cfm.ksName, boundNames);
0:         return new SingleColumnRestriction.EQ(columnDef, term);
1:     }
1: 
1:     @Override
1:     protected Restriction newINRestriction(CFMetaData cfm,
1:                                            VariableSpecifications boundNames) throws InvalidRequestException
1:     {
0:         ColumnDefinition columnDef = cfm.getColumnDefinition(getEntity().prepare(cfm));
0:         List<? extends ColumnSpecification> receivers = toReceivers(cfm, columnDef);
1:         List<Term> terms = toTerms(receivers, inValues, cfm.ksName, boundNames);
1:         if (terms == null)
1:         {
1:             Term term = toTerm(receivers, value, cfm.ksName, boundNames);
0:             return new SingleColumnRestriction.InWithMarker(columnDef, (Lists.Marker) term);
1:         }
0:         return new SingleColumnRestriction.InWithValues(columnDef, terms);
1:     }
1: 
1:     @Override
1:     protected Restriction newSliceRestriction(CFMetaData cfm,
1:                                               VariableSpecifications boundNames,
1:                                               Bound bound,
1:                                               boolean inclusive) throws InvalidRequestException
1:     {
0:         ColumnDefinition columnDef = toColumnDefinition(cfm, entity);
0:         Term term = toTerm(toReceivers(cfm, columnDef), value, cfm.ksName, boundNames);
0:         return new SingleColumnRestriction.Slice(columnDef, bound, inclusive, term);
1:     }
1: 
1:     @Override
1:     protected Restriction newContainsRestriction(CFMetaData cfm,
1:                                                  VariableSpecifications boundNames,
1:                                                  boolean isKey) throws InvalidRequestException
1:     {
0:         ColumnDefinition columnDef = toColumnDefinition(cfm, entity);
0:         Term term = toTerm(toReceivers(cfm, columnDef), value, cfm.ksName, boundNames);
0:         return new SingleColumnRestriction.Contains(columnDef, term, isKey);
1:     }
1: 
1:     /**
1:      * Returns the receivers for this relation.
0:      *
0:      * @param cfm the Column Family meta data
1:      * @param columnDef the column definition
1:      * @return the receivers for the specified relation.
1:      * @throws InvalidRequestException if the relation is invalid
1:      */
0:     private List<? extends ColumnSpecification> toReceivers(CFMetaData cfm, ColumnDefinition columnDef) throws InvalidRequestException
1:     {
1:         ColumnSpecification receiver = columnDef;
1: 
0:         checkFalse(columnDef.isCompactValue(),
0:                    "Predicates on the non-primary-key column (%s) of a COMPACT table are not yet supported",
0:                    columnDef.name);
1: 
1:         if (isIN())
1:         {
0:             // For partition keys we only support IN for the last name so far
0:             checkFalse(columnDef.isPartitionKey() && !isLastPartitionKey(cfm, columnDef),
0:                       "Partition KEY part %s cannot be restricted by IN relation (only the last part of the partition key can)",
0:                       columnDef.name);
1: 
1:             // We only allow IN on the row key and the clustering key so far, never on non-PK columns, and this even if
1:             // there's an index
1:             // Note: for backward compatibility reason, we conside a IN of 1 value the same as a EQ, so we let that
1:             // slide.
1:             checkFalse(!columnDef.isPrimaryKeyColumn() && !canHaveOnlyOneValue(),
1:                        "IN predicates on non-primary-key columns (%s) is not yet supported", columnDef.name);
1:         }
0:         else if (isSlice())
1:         {
0:             // Non EQ relation is not supported without token(), even if we have a 2ndary index (since even those
0:             // are ordered by partitioner).
0:             // Note: In theory we could allow it for 2ndary index queries with ALLOW FILTERING, but that would
0:             // probably require some special casing
0:             // Note bis: This is also why we don't bother handling the 'tuple' notation of #4851 for keys. If we
0:             // lift the limitation for 2ndary
0:             // index with filtering, we'll need to handle it though.
0:             checkFalse(columnDef.isPartitionKey(), "Only EQ and IN relation are supported on the partition key (unless you use the token() function)");
1:         }
1: 
1:         checkFalse(isContainsKey() && !(receiver.type instanceof MapType), "Cannot use CONTAINS KEY on non-map column %s", receiver.name);
1: 
1:         if (receiver.type.isCollection())
1:         {
1:             // We don't support relations against entire collections (unless they're frozen), like "numbers = {1, 2, 3}"
0:             checkFalse(receiver.type.isMultiCell() && !(isContainsKey() || isContains()),
1:                        "Collection column '%s' (%s) cannot be restricted by a '%s' relation",
1:                        receiver.name,
1:                        receiver.type.asCQL3Type(),
1:                        operator());
1: 
1:             if (isContainsKey() || isContains())
0:                 receiver = ((CollectionType<?>) receiver.type).makeCollectionReceiver(receiver, isContainsKey());
1:         }
1:         return Collections.singletonList(receiver);
1:     }
1: 
1:     /**
0:      * Checks if the specified column is the last column of the partition key.
0:      *
0:      * @param cfm the column family meta data
0:      * @param columnDef the column to check
0:      * @return <code>true</code> if the specified column is the last column of the partition key, <code>false</code>
0:      * otherwise.
1:      */
0:     private static boolean isLastPartitionKey(CFMetaData cfm, ColumnDefinition columnDef)
1:     {
0:         return columnDef.position() == cfm.partitionKeyColumns().size() - 1;
1:     }
1: 
1:     private boolean canHaveOnlyOneValue()
1:     {
0:         return isEQ() || (isIN() && inValues != null && inValues.size() == 1);
commit:5117a5d
/////////////////////////////////////////////////////////////////////////
0:     private SingleColumnRelation(ColumnIdentifier entity, Operator type, Term.Raw value, List<Term.Raw> inValues, boolean onToken)
/////////////////////////////////////////////////////////////////////////
0:     public SingleColumnRelation(ColumnIdentifier entity, Operator type, Term.Raw value)
0:     public SingleColumnRelation(ColumnIdentifier entity, Operator type, Term.Raw value, boolean onToken)
0:         return new SingleColumnRelation(entity, Operator.IN, null, inValues, false);
/////////////////////////////////////////////////////////////////////////
0:         assert relationType != Operator.IN || value == null || value instanceof AbstractMarker.INRaw;
0:         assert relationType == Operator.IN;
/////////////////////////////////////////////////////////////////////////
1:             case GT: return new SingleColumnRelation(entity, Operator.GTE, value);
0:             case LT:  return new SingleColumnRelation(entity, Operator.LTE, value);
/////////////////////////////////////////////////////////////////////////
0:         if (relationType == Operator.IN)
author:Samuel Klock
-------------------------------------------------------------------------------
commit:3f55c35
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.marshal.ListType;
1: import static org.apache.cassandra.cql3.statements.RequestValidations.checkTrue;
/////////////////////////////////////////////////////////////////////////
1:     private final Term.Raw mapKey;
0:     private SingleColumnRelation(ColumnIdentifier.Raw entity, Term.Raw mapKey, Operator type, Term.Raw value, List<Term.Raw> inValues)
1:         this.mapKey = mapKey;
/////////////////////////////////////////////////////////////////////////
1:      * @param mapKey the key into the entity identifying the value the term is being compared to.
1:      * @param type the type that describes how this entity relates to the value.
1:      * @param value the value being compared.
0:      */
0:     public SingleColumnRelation(ColumnIdentifier.Raw entity, Term.Raw mapKey, Operator type, Term.Raw value)
1:     {
1:         this(entity, mapKey, type, value, null);
1:     }
1: 
0:     /**
1:      * Creates a new relation.
0:      *
1:      * @param entity the kind of relation this is; what the term is being compared to.
1:         this(entity, null, type, value);
1:         return new SingleColumnRelation(entity, null, Operator.IN, null, inValues);
/////////////////////////////////////////////////////////////////////////
1:     public Term.Raw getMapKey()
1:     {
1:         return mapKey;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             case LT: return new SingleColumnRelation(entity, Operator.LTE, value);
/////////////////////////////////////////////////////////////////////////
1:         String entityAsString = entity.toString();
1:         if (mapKey != null)
1:             entityAsString = String.format("%s[%s]", entityAsString, mapKey);
0:         if (isIN())
1:             return String.format("%s IN %s", entityAsString, inValues);
0: 
1:         return String.format("%s %s %s", entityAsString, relationType, value);
/////////////////////////////////////////////////////////////////////////
1:         if (mapKey == null)
1:         {
0:             Term term = toTerm(toReceivers(cfm, columnDef), value, cfm.ksName, boundNames);
0:             return new SingleColumnRestriction.EQ(columnDef, term);
1:         }
0:         List<? extends ColumnSpecification> receivers = toReceivers(cfm, columnDef);
1:         Term entryKey = toTerm(Collections.singletonList(receivers.get(0)), mapKey, cfm.ksName, boundNames);
1:         Term entryValue = toTerm(Collections.singletonList(receivers.get(1)), value, cfm.ksName, boundNames);
0:         return new SingleColumnRestriction.Contains(columnDef, entryKey, entryValue);
/////////////////////////////////////////////////////////////////////////
1:         if (mapKey != null)
1:         {
1:             checkFalse(receiver.type instanceof ListType, "Indexes on list entries (%s[index] = value) are not currently supported.", receiver.name);
1:             checkTrue(receiver.type instanceof MapType, "Column %s cannot be used as a map", receiver.name);
1:             checkTrue(receiver.type.isMultiCell(), "Map-entry equality predicates on frozen map column %s are not supported", receiver.name);
1:             checkTrue(isEQ(), "Only EQ relations are supported on map entries");
1:         }
0: 
1:             checkFalse(receiver.type.isMultiCell() && !isLegalRelationForNonFrozenCollection(),
1:             {
1:                 receiver = makeCollectionReceiver(receiver, isContainsKey());
1:             }
1:             else if (receiver.type.isMultiCell() && mapKey != null && isEQ())
1:             {
1:                 List<ColumnSpecification> receivers = new ArrayList<>(2);
1:                 receivers.add(makeCollectionReceiver(receiver, true));
1:                 receivers.add(makeCollectionReceiver(receiver, false));
1:                 return receivers;
1:             }
0: 
0:     private ColumnSpecification makeCollectionReceiver(ColumnSpecification receiver, boolean forKey)
1:     {
1:         return ((CollectionType<?>) receiver.type).makeCollectionReceiver(receiver, forKey);
1:     }
0: 
1:     private boolean isLegalRelationForNonFrozenCollection()
1:     {
1:         return isContainsKey() || isContains() || isMapEntryEquality();
1:     }
0: 
1:     private boolean isMapEntryEquality()
1:     {
1:         return mapKey != null && isEQ();
1:     }
0: 
============================================================================