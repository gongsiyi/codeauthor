1:9a3fa88: /*
1:9a3fa88:  * Licensed to the Apache Software Foundation (ASF) under one
1:9a3fa88:  * or more contributor license agreements.  See the NOTICE file
1:9a3fa88:  * distributed with this work for additional information
1:9a3fa88:  * regarding copyright ownership.  The ASF licenses this file
1:9a3fa88:  * to you under the Apache License, Version 2.0 (the
1:9a3fa88:  * "License"); you may not use this file except in compliance
1:9a3fa88:  * with the License.  You may obtain a copy of the License at
1:9a3fa88:  *
1:9a3fa88:  *     http://www.apache.org/licenses/LICENSE-2.0
1:9a3fa88:  *
1:9a3fa88:  * Unless required by applicable law or agreed to in writing, software
1:9a3fa88:  * distributed under the License is distributed on an "AS IS" BASIS,
1:9a3fa88:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:9a3fa88:  * See the License for the specific language governing permissions and
1:9a3fa88:  * limitations under the License.
4:9a3fa88:  */
1:9a3fa88: package org.apache.cassandra.dht.tokenallocator;
43:9a3fa88: 
1:9a3fa88: import java.util.*;
1:9a3fa88: 
1:9a3fa88: import com.google.common.collect.Iterables;
1:9a3fa88: import com.google.common.collect.Maps;
1:9a3fa88: import com.google.common.collect.Sets;
1:9a3fa88: 
1:d97695b: import org.apache.commons.math3.stat.descriptive.SummaryStatistics;
1:9a3fa88: 
1:c6ec31b: import org.junit.Assert;
1:c6ec31b: import org.junit.Ignore;
1:9a3fa88: 
1:c1a9a47: import org.apache.cassandra.dht.IPartitioner;
1:9a3fa88: import org.apache.cassandra.dht.Token;
1:9a3fa88: 
1:c6ec31b: /**
1:c6ec31b:  * Base class for {@link Murmur3ReplicationAwareTokenAllocatorTest} and {@link RandomReplicationAwareTokenAllocatorTest},
1:c6ec31b:  * we need to separate classes to avoid timeous in case flaky tests need to be repeated, see CASSANDRA-12784.
1:c6ec31b:  */
1:c6ec31b: @Ignore
1:e2a0d75: abstract class AbstractReplicationAwareTokenAllocatorTest extends TokenAllocatorTestBase
35:9a3fa88: {
1:9a3fa88:     static class SimpleReplicationStrategy implements TestReplicationStrategy
1:9a3fa88:     {
1:9a3fa88:         int replicas;
1:9a3fa88: 
1:9a3fa88:         public SimpleReplicationStrategy(int replicas)
1:9a3fa88:         {
1:9a3fa88:             super();
1:9a3fa88:             this.replicas = replicas;
1:a5cbb02:         }
1:c1a9a47: 
2:9a3fa88:         public List<Unit> getReplicas(Token token, NavigableMap<Token, Unit> sortedTokens)
1:c1a9a47:         {
1:9a3fa88:             List<Unit> endpoints = new ArrayList<Unit>(replicas);
1:c1a9a47: 
1:9a3fa88:             token = sortedTokens.ceilingKey(token);
1:9a3fa88:             if (token == null)
1:9a3fa88:                 token = sortedTokens.firstKey();
1:9a3fa88:             Iterator<Unit> iter = Iterables.concat(sortedTokens.tailMap(token, true).values(), sortedTokens.values()).iterator();
1:9a3fa88:             while (endpoints.size() < replicas)
1:c1a9a47:             {
1:9a3fa88:                 if (!iter.hasNext())
1:9a3fa88:                     return endpoints;
1:9a3fa88:                 Unit ep = iter.next();
1:9a3fa88:                 if (!endpoints.contains(ep))
1:9a3fa88:                     endpoints.add(ep);
1:c1a9a47:             }
1:9a3fa88:             return endpoints;
1:c1a9a47:         }
1:a5cbb02: 
2:9a3fa88:         public Token replicationStart(Token token, Unit unit, NavigableMap<Token, Unit> sortedTokens)
1:a5cbb02:         {
1:9a3fa88:             Set<Unit> seenUnits = Sets.newHashSet();
1:9a3fa88:             int unitsFound = 0;
1:9a3fa88: 
1:9a3fa88:             for (Map.Entry<Token, Unit> en : Iterables.concat(
1:9a3fa88:                                                              sortedTokens.headMap(token, false).descendingMap().entrySet(),
1:9a3fa88:                                                              sortedTokens.descendingMap().entrySet()))
1:9a3fa88:             {
1:9a3fa88:                 Unit n = en.getValue();
1:9a3fa88:                 // Same group as investigated unit is a break; anything that could replicate in it replicates there.
1:9a3fa88:                 if (n == unit)
1:9a3fa88:                     break;
1:9a3fa88: 
1:9a3fa88:                 if (seenUnits.add(n))
1:9a3fa88:                 {
1:9a3fa88:                     if (++unitsFound == replicas)
1:9a3fa88:                         break;
33:9a3fa88:                 }
1:9a3fa88:                 token = en.getKey();
1:9a3fa88:             }
1:9a3fa88:             return token;
1:9a3fa88:         }
1:9a3fa88: 
2:9a3fa88:         public void addUnit(Unit n)
1:9a3fa88:         {
1:9a3fa88:         }
1:9a3fa88: 
2:9a3fa88:         public void removeUnit(Unit n)
1:9a3fa88:         {
1:9a3fa88:         }
1:9a3fa88: 
4:9a3fa88:         public String toString()
1:9a3fa88:         {
1:9a3fa88:             return String.format("Simple %d replicas", replicas);
1:9a3fa88:         }
1:9a3fa88: 
2:9a3fa88:         public int replicas()
1:9a3fa88:         {
1:9a3fa88:             return replicas;
1:9a3fa88:         }
1:9a3fa88: 
2:9a3fa88:         public boolean sameGroup(Unit n1, Unit n2)
1:9a3fa88:         {
2:9a3fa88:             return false;
1:9a3fa88:         }
1:9a3fa88: 
1:9a3fa88:         public Unit getGroup(Unit unit)
1:9a3fa88:         {
1:9a3fa88:             // The unit is the group.
2:9a3fa88:             return unit;
1:9a3fa88:         }
1:9a3fa88: 
4:9a3fa88:         public double spreadExpectation()
1:9a3fa88:         {
3:9a3fa88:             return 1;
1:9a3fa88:         }
1:9a3fa88:     }
1:9a3fa88: 
1:9a3fa88:     static abstract class GroupReplicationStrategy implements TestReplicationStrategy
1:9a3fa88:     {
1:9a3fa88:         final int replicas;
1:9a3fa88:         final Map<Unit, Integer> groupMap;
1:9a3fa88: 
1:9a3fa88:         public GroupReplicationStrategy(int replicas)
1:9a3fa88:         {
1:9a3fa88:             this.replicas = replicas;
1:9a3fa88:             this.groupMap = Maps.newHashMap();
1:9a3fa88:         }
1:9a3fa88: 
1:9a3fa88:         public List<Unit> getReplicas(Token token, NavigableMap<Token, Unit> sortedTokens)
1:9a3fa88:         {
1:9a3fa88:             List<Unit> endpoints = new ArrayList<Unit>(replicas);
1:9a3fa88:             BitSet usedGroups = new BitSet();
1:9a3fa88: 
1:9a3fa88:             if (sortedTokens.isEmpty())
1:9a3fa88:                 return endpoints;
1:9a3fa88: 
1:9a3fa88:             token = sortedTokens.ceilingKey(token);
1:9a3fa88:             if (token == null)
1:9a3fa88:                 token = sortedTokens.firstKey();
1:9a3fa88:             Iterator<Unit> iter = Iterables.concat(sortedTokens.tailMap(token, true).values(), sortedTokens.values()).iterator();
1:9a3fa88:             while (endpoints.size() < replicas)
1:9a3fa88:             {
1:9a3fa88:                 // For simlicity assuming list can't be exhausted before finding all replicas.
1:9a3fa88:                 Unit ep = iter.next();
1:9a3fa88:                 int group = groupMap.get(ep);
1:9a3fa88:                 if (!usedGroups.get(group))
1:9a3fa88:                 {
1:9a3fa88:                     endpoints.add(ep);
1:9a3fa88:                     usedGroups.set(group);
1:9a3fa88:                 }
1:9a3fa88:             }
1:9a3fa88:             return endpoints;
1:9a3fa88:         }
1:9a3fa88: 
1:9a3fa88:         public Token lastReplicaToken(Token token, NavigableMap<Token, Unit> sortedTokens)
1:9a3fa88:         {
1:9a3fa88:             BitSet usedGroups = new BitSet();
1:9a3fa88:             int groupsFound = 0;
1:9a3fa88: 
1:9a3fa88:             token = sortedTokens.ceilingKey(token);
1:9a3fa88:             if (token == null)
1:9a3fa88:                 token = sortedTokens.firstKey();
1:9a3fa88:             for (Map.Entry<Token, Unit> en :
1:9a3fa88:             Iterables.concat(sortedTokens.tailMap(token, true).entrySet(),
1:9a3fa88:                              sortedTokens.entrySet()))
1:9a3fa88:             {
1:9a3fa88:                 Unit ep = en.getValue();
1:9a3fa88:                 int group = groupMap.get(ep);
1:9a3fa88:                 if (!usedGroups.get(group))
1:9a3fa88:                 {
1:9a3fa88:                     usedGroups.set(group);
1:9a3fa88:                     if (++groupsFound >= replicas)
1:9a3fa88:                         return en.getKey();
1:9a3fa88:                 }
1:9a3fa88:             }
1:9a3fa88:             return token;
1:9a3fa88:         }
1:9a3fa88: 
1:9a3fa88:         public Token replicationStart(Token token, Unit unit, NavigableMap<Token, Unit> sortedTokens)
1:9a3fa88:         {
1:9a3fa88:             // replicated ownership
1:9a3fa88:             int unitGroup = groupMap.get(unit);   // unit must be already added
1:9a3fa88:             BitSet seenGroups = new BitSet();
1:9a3fa88:             int groupsFound = 0;
1:9a3fa88: 
1:9a3fa88:             for (Map.Entry<Token, Unit> en : Iterables.concat(
1:9a3fa88:                                                              sortedTokens.headMap(token, false).descendingMap().entrySet(),
1:9a3fa88:                                                              sortedTokens.descendingMap().entrySet()))
1:9a3fa88:             {
1:9a3fa88:                 Unit n = en.getValue();
1:9a3fa88:                 int ngroup = groupMap.get(n);
1:9a3fa88:                 // Same group as investigated unit is a break; anything that could replicate in it replicates there.
1:9a3fa88:                 if (ngroup == unitGroup)
1:9a3fa88:                     break;
1:9a3fa88: 
1:9a3fa88:                 if (!seenGroups.get(ngroup))
1:9a3fa88:                 {
1:9a3fa88:                     if (++groupsFound == replicas)
1:9a3fa88:                         break;
1:9a3fa88:                     seenGroups.set(ngroup);
1:9a3fa88:                 }
1:9a3fa88:                 token = en.getKey();
1:9a3fa88:             }
1:9a3fa88:             return token;
1:9a3fa88:         }
1:9a3fa88: 
1:9a3fa88:         public String toString()
1:9a3fa88:         {
1:9a3fa88:             Map<Integer, Integer> idToSize = instanceToCount(groupMap);
1:9a3fa88:             Map<Integer, Integer> sizeToCount = Maps.newTreeMap();
1:9a3fa88:             sizeToCount.putAll(instanceToCount(idToSize));
1:9a3fa88:             return String.format("%s strategy, %d replicas, group size to count %s", getClass().getSimpleName(), replicas, sizeToCount);
1:9a3fa88:         }
1:9a3fa88: 
2:9a3fa88:         @Override
1:9a3fa88:         public int replicas()
1:9a3fa88:         {
1:9a3fa88:             return replicas;
1:9a3fa88:         }
1:9a3fa88: 
1:9a3fa88:         public boolean sameGroup(Unit n1, Unit n2)
1:9a3fa88:         {
1:9a3fa88:             return groupMap.get(n1).equals(groupMap.get(n2));
1:9a3fa88:         }
1:9a3fa88: 
1:9a3fa88:         public void removeUnit(Unit n)
1:9a3fa88:         {
1:9a3fa88:             groupMap.remove(n);
1:9a3fa88:         }
1:9a3fa88: 
1:9a3fa88:         public Integer getGroup(Unit unit)
1:9a3fa88:         {
1:9a3fa88:             return groupMap.get(unit);
1:9a3fa88:         }
1:9a3fa88: 
1:9a3fa88:         public double spreadExpectation()
1:9a3fa88:         {
1:9a3fa88:             return 1.5;   // Even balanced racks get disbalanced when they lose nodes.
1:9a3fa88:         }
1:9a3fa88:     }
1:9a3fa88: 
1:9a3fa88:     private static <T> Map<T, Integer> instanceToCount(Map<?, T> map)
1:9a3fa88:     {
1:9a3fa88:         Map<T, Integer> idToCount = Maps.newHashMap();
1:9a3fa88:         for (Map.Entry<?, T> en : map.entrySet())
1:9a3fa88:         {
1:9a3fa88:             Integer old = idToCount.get(en.getValue());
1:9a3fa88:             idToCount.put(en.getValue(), old != null ? old + 1 : 1);
1:9a3fa88:         }
1:9a3fa88:         return idToCount;
1:9a3fa88:     }
1:9a3fa88: 
4:9a3fa88:     /**
1:9a3fa88:      * Group strategy spreading units into a fixed number of groups.
1:9a3fa88:      */
1:9a3fa88:     static class FixedGroupCountReplicationStrategy extends GroupReplicationStrategy
1:9a3fa88:     {
1:9a3fa88:         int groupId;
1:9a3fa88:         int groupCount;
1:9a3fa88: 
1:9a3fa88:         public FixedGroupCountReplicationStrategy(int replicas, int groupCount)
1:9a3fa88:         {
1:9a3fa88:             super(replicas);
1:9a3fa88:             assert groupCount >= replicas;
1:9a3fa88:             groupId = 0;
1:9a3fa88:             this.groupCount = groupCount;
1:9a3fa88:         }
1:9a3fa88: 
1:9a3fa88:         public void addUnit(Unit n)
1:9a3fa88:         {
1:9a3fa88:             groupMap.put(n, groupId++ % groupCount);
1:9a3fa88:         }
1:9a3fa88:     }
1:9a3fa88: 
1:9a3fa88:     /**
1:9a3fa88:      * Group strategy with a fixed number of units per group.
1:9a3fa88:      */
1:9a3fa88:     static class BalancedGroupReplicationStrategy extends GroupReplicationStrategy
1:9a3fa88:     {
1:9a3fa88:         int groupId;
1:9a3fa88:         int groupSize;
1:9a3fa88: 
1:9a3fa88:         public BalancedGroupReplicationStrategy(int replicas, int groupSize)
1:9a3fa88:         {
1:9a3fa88:             super(replicas);
1:9a3fa88:             groupId = 0;
1:9a3fa88:             this.groupSize = groupSize;
1:9a3fa88:         }
1:9a3fa88: 
1:9a3fa88:         public void addUnit(Unit n)
1:9a3fa88:         {
1:9a3fa88:             groupMap.put(n, groupId++ / groupSize);
1:9a3fa88:         }
1:9a3fa88:     }
1:9a3fa88: 
1:9a3fa88:     static class UnbalancedGroupReplicationStrategy extends GroupReplicationStrategy
1:9a3fa88:     {
1:9a3fa88:         int groupId;
1:9a3fa88:         int nextSize;
1:9a3fa88:         int num;
1:9a3fa88:         int minGroupSize;
1:9a3fa88:         int maxGroupSize;
1:9a3fa88:         Random rand;
1:9a3fa88: 
1:9a3fa88:         public UnbalancedGroupReplicationStrategy(int replicas, int minGroupSize, int maxGroupSize, Random rand)
1:9a3fa88:         {
1:9a3fa88:             super(replicas);
1:9a3fa88:             groupId = -1;
1:9a3fa88:             nextSize = 0;
1:9a3fa88:             num = 0;
1:9a3fa88:             this.maxGroupSize = maxGroupSize;
1:9a3fa88:             this.minGroupSize = minGroupSize;
1:9a3fa88:             this.rand = rand;
1:9a3fa88:         }
1:9a3fa88: 
1:9a3fa88:         public void addUnit(Unit n)
1:9a3fa88:         {
1:9a3fa88:             if (++num > nextSize)
1:9a3fa88:             {
1:9a3fa88:                 nextSize = minGroupSize + rand.nextInt(maxGroupSize - minGroupSize + 1);
1:9a3fa88:                 ++groupId;
1:9a3fa88:                 num = 0;
1:9a3fa88:             }
1:9a3fa88:             groupMap.put(n, groupId);
1:9a3fa88:         }
1:9a3fa88: 
1:9a3fa88:         public double spreadExpectation()
1:9a3fa88:         {
1:9a3fa88:             return 2;
1:9a3fa88:         }
1:9a3fa88:     }
1:9a3fa88: 
1:9a3fa88:     static Map<Unit, Double> evaluateReplicatedOwnership(ReplicationAwareTokenAllocator<Unit> t)
1:9a3fa88:     {
1:9a3fa88:         Map<Unit, Double> ownership = Maps.newHashMap();
1:9a3fa88:         Iterator<Token> it = t.sortedTokens.keySet().iterator();
1:9a3fa88:         if (!it.hasNext())
1:9a3fa88:             return ownership;
1:9a3fa88: 
1:9a3fa88:         Token current = it.next();
1:9a3fa88:         while (it.hasNext())
1:9a3fa88:         {
1:9a3fa88:             Token next = it.next();
1:9a3fa88:             addOwnership(t, current, next, ownership);
1:9a3fa88:             current = next;
1:9a3fa88:         }
1:9a3fa88:         addOwnership(t, current, t.sortedTokens.firstKey(), ownership);
1:9a3fa88: 
1:9a3fa88:         return ownership;
1:9a3fa88:     }
1:9a3fa88: 
1:9a3fa88:     private static void addOwnership(ReplicationAwareTokenAllocator<Unit> t, Token current, Token next, Map<Unit, Double> ownership)
1:9a3fa88:     {
1:9a3fa88:         TestReplicationStrategy ts = (TestReplicationStrategy) t.strategy;
1:9a3fa88:         double size = current.size(next);
1:9a3fa88:         Token representative = t.partitioner.midpoint(current, next);
1:9a3fa88:         for (Unit n : ts.getReplicas(representative, t.sortedTokens))
1:9a3fa88:         {
1:9a3fa88:             Double v = ownership.get(n);
1:9a3fa88:             ownership.put(n, v != null ? v + size : size);
1:9a3fa88:         }
1:9a3fa88:     }
1:9a3fa88: 
1:9a3fa88:     private static double replicatedTokenOwnership(Token token, NavigableMap<Token, Unit> sortedTokens, ReplicationStrategy<Unit> strategy)
1:9a3fa88:     {
1:9a3fa88:         TestReplicationStrategy ts = (TestReplicationStrategy) strategy;
1:9a3fa88:         Token next = sortedTokens.higherKey(token);
1:9a3fa88:         if (next == null)
1:9a3fa88:             next = sortedTokens.firstKey();
1:9a3fa88:         return ts.replicationStart(token, sortedTokens.get(token), sortedTokens).size(next);
1:9a3fa88:     }
1:9a3fa88: 
1:c6ec31b:     protected void testExistingCluster(IPartitioner partitioner, int maxVNodeCount)
1:9a3fa88:     {
1:9a3fa88:         for (int rf = 1; rf <= 5; ++rf)
1:9a3fa88:         {
1:c6ec31b:             for (int perUnitCount = 1; perUnitCount <= maxVNodeCount; perUnitCount *= 4)
1:9a3fa88:             {
1:c1a9a47:                 testExistingCluster(perUnitCount, fixedTokenCount, new SimpleReplicationStrategy(rf), partitioner);
1:c1a9a47:                 testExistingCluster(perUnitCount, varyingTokenCount, new SimpleReplicationStrategy(rf), partitioner);
1:9a3fa88:                 if (rf == 1) continue;  // Replication strategy doesn't matter for RF = 1.
1:9a3fa88:                 for (int groupSize = 4; groupSize <= 64 && groupSize * rf * 4 < TARGET_CLUSTER_SIZE; groupSize *= 4)
1:9a3fa88:                 {
1:c1a9a47:                     testExistingCluster(perUnitCount, fixedTokenCount,
1:c1a9a47:                                         new BalancedGroupReplicationStrategy(rf, groupSize), partitioner);
1:c1a9a47:                     testExistingCluster(perUnitCount, varyingTokenCount,
1:c1a9a47:                                         new UnbalancedGroupReplicationStrategy(rf, groupSize / 2, groupSize * 2, seededRand),
1:c1a9a47:                                         partitioner);
1:9a3fa88:                 }
1:c1a9a47:                 testExistingCluster(perUnitCount, fixedTokenCount,
1:c1a9a47:                                     new FixedGroupCountReplicationStrategy(rf, rf * 2), partitioner);
1:9a3fa88:             }
1:9a3fa88:         }
1:9a3fa88:     }
1:9a3fa88: 
1:c6ec31b:     private void testExistingCluster(int perUnitCount, TokenCount tc, TestReplicationStrategy rs, IPartitioner partitioner)
1:9a3fa88:     {
1:9a3fa88:         System.out.println("Testing existing cluster, target " + perUnitCount + " vnodes, replication " + rs);
1:9a3fa88:         final int targetClusterSize = TARGET_CLUSTER_SIZE;
1:9a3fa88:         NavigableMap<Token, Unit> tokenMap = Maps.newTreeMap();
1:9a3fa88: 
1:c1a9a47:         random(tokenMap, rs, targetClusterSize / 2, tc, perUnitCount, partitioner);
1:9a3fa88: 
1:9a3fa88:         ReplicationAwareTokenAllocator<Unit> t = new ReplicationAwareTokenAllocator<>(tokenMap, rs, partitioner);
1:9a3fa88:         grow(t, targetClusterSize * 9 / 10, tc, perUnitCount, false);
1:9a3fa88:         grow(t, targetClusterSize, tc, perUnitCount, true);
1:c1a9a47:         loseAndReplace(t, targetClusterSize / 10, tc, perUnitCount, partitioner);
1:9a3fa88:         System.out.println();
1:c1a9a47:     }
1:c1a9a47: 
1:c6ec31b:     protected void testNewCluster(IPartitioner partitioner, int maxVNodeCount)
1:c1a9a47:     {
1:a5cbb02:         // This test is flaky because the selection of the tokens for the first RF nodes (which is random, with an
1:a5cbb02:         // uncontrolled seed) can sometimes cause a pathological situation where the algorithm will find a (close to)
1:a5cbb02:         // ideal distribution of tokens for some number of nodes, which in turn will inevitably cause it to go into a
1:a5cbb02:         // bad (unacceptable to the test criteria) distribution after adding one more node.
1:c1a9a47: 
1:a5cbb02:         // This should happen very rarely, unless something is broken in the token allocation code.
1:c1a9a47: 
1:9a3fa88:         for (int rf = 2; rf <= 5; ++rf)
1:c1a9a47:         {
1:c6ec31b:             for (int perUnitCount = 1; perUnitCount <= maxVNodeCount; perUnitCount *= 4)
1:c1a9a47:             {
1:c1a9a47:                 testNewCluster(perUnitCount, fixedTokenCount, new SimpleReplicationStrategy(rf), partitioner);
1:c1a9a47:                 testNewCluster(perUnitCount, varyingTokenCount, new SimpleReplicationStrategy(rf), partitioner);
1:9a3fa88:                 if (rf == 1) continue;  // Replication strategy doesn't matter for RF = 1.
1:9a3fa88:                 for (int groupSize = 4; groupSize <= 64 && groupSize * rf * 8 < TARGET_CLUSTER_SIZE; groupSize *= 4)
1:9a3fa88:                 {
1:c1a9a47:                     testNewCluster(perUnitCount, fixedTokenCount,
1:c1a9a47:                                    new BalancedGroupReplicationStrategy(rf, groupSize), partitioner);
1:c1a9a47:                     testNewCluster(perUnitCount, varyingTokenCount,
1:c1a9a47:                                    new UnbalancedGroupReplicationStrategy(rf, groupSize / 2, groupSize * 2, seededRand),
1:c1a9a47:                                    partitioner);
1:c1a9a47:                 }
1:c1a9a47:                 testNewCluster(perUnitCount, fixedTokenCount,
1:c1a9a47:                                new FixedGroupCountReplicationStrategy(rf, rf * 2), partitioner);
1:c1a9a47:             }
1:9a3fa88:         }
1:9a3fa88:     }
1:a5cbb02: 
1:c6ec31b:     private void testNewCluster(int perUnitCount, TokenCount tc, TestReplicationStrategy rs, IPartitioner partitioner)
1:9a3fa88:     {
1:9a3fa88:         System.out.println("Testing new cluster, target " + perUnitCount + " vnodes, replication " + rs);
1:9a3fa88:         final int targetClusterSize = TARGET_CLUSTER_SIZE;
1:9a3fa88:         NavigableMap<Token, Unit> tokenMap = Maps.newTreeMap();
1:a5cbb02: 
1:9a3fa88:         ReplicationAwareTokenAllocator<Unit> t = new ReplicationAwareTokenAllocator<>(tokenMap, rs, partitioner);
1:9a3fa88:         grow(t, targetClusterSize * 2 / 5, tc, perUnitCount, false);
1:9a3fa88:         grow(t, targetClusterSize, tc, perUnitCount, true);
1:c1a9a47:         loseAndReplace(t, targetClusterSize / 5, tc, perUnitCount, partitioner);
1:9a3fa88:         System.out.println();
1:9a3fa88:     }
1:9a3fa88: 
1:c1a9a47:     private void loseAndReplace(ReplicationAwareTokenAllocator<Unit> t, int howMany,
1:c1a9a47:                                 TokenCount tc, int perUnitCount, IPartitioner partitioner)
1:9a3fa88:     {
1:9a3fa88:         int fullCount = t.unitCount();
1:9a3fa88:         System.out.format("Losing %d units. ", howMany);
1:9a3fa88:         for (int i = 0; i < howMany; ++i)
1:9a3fa88:         {
1:9a3fa88:             Unit u = t.unitFor(partitioner.getRandomToken(seededRand));
1:9a3fa88:             t.removeUnit(u);
1:9a3fa88:             ((TestReplicationStrategy) t.strategy).removeUnit(u);
1:9a3fa88:         }
1:9a3fa88:         // Grow half without verifying.
1:9a3fa88:         grow(t, (t.unitCount() + fullCount * 3) / 4, tc, perUnitCount, false);
1:9a3fa88:         // Metrics should be back to normal by now. Check that they remain so.
1:9a3fa88:         grow(t, fullCount, tc, perUnitCount, true);
1:9a3fa88:     }
1:9a3fa88: 
1:9a3fa88:     public void grow(ReplicationAwareTokenAllocator<Unit> t, int targetClusterSize, TokenCount tc, int perUnitCount, boolean verifyMetrics)
1:9a3fa88:     {
1:9a3fa88:         int size = t.unitCount();
1:9a3fa88:         Summary su = new Summary();
1:9a3fa88:         Summary st = new Summary();
1:9a3fa88:         Random rand = new Random(targetClusterSize + perUnitCount);
1:9a3fa88:         TestReplicationStrategy strategy = (TestReplicationStrategy) t.strategy;
1:9a3fa88:         if (size < targetClusterSize)
1:9a3fa88:         {
1:9a3fa88:             System.out.format("Adding %d unit(s) using %s...", targetClusterSize - size, t.toString());
1:9a3fa88:             long time = System.currentTimeMillis();
1:9a3fa88:             while (size < targetClusterSize)
1:9a3fa88:             {
2:9a3fa88:                 int tokens = tc.tokenCount(perUnitCount, rand);
2:9a3fa88:                 Unit unit = new Unit();
1:9a3fa88:                 strategy.addUnit(unit);
1:9a3fa88:                 t.addUnit(unit, tokens);
1:9a3fa88:                 ++size;
1:9a3fa88:                 if (verifyMetrics)
1:9a3fa88:                     updateSummary(t, su, st, false);
1:9a3fa88:             }
1:9a3fa88:             System.out.format(" Done in %.3fs\n", (System.currentTimeMillis() - time) / 1000.0);
1:9a3fa88:             if (verifyMetrics)
1:9a3fa88:             {
1:9a3fa88:                 updateSummary(t, su, st, true);
1:9a3fa88:                 double maxExpected = 1.0 + tc.spreadExpectation() * strategy.spreadExpectation() / (perUnitCount * t.replicas);
1:9a3fa88:                 if (su.max > maxExpected)
1:9a3fa88:                 {
1:9a3fa88:                     Assert.fail(String.format("Expected max unit size below %.4f, was %.4f", maxExpected, su.max));
1:9a3fa88:                 }
1:9a3fa88:                 // We can't verify lower side range as small loads can't always be fixed.
1:9a3fa88:             }
1:9a3fa88:         }
1:9a3fa88:     }
1:9a3fa88: 
1:9a3fa88:     private void updateSummary(ReplicationAwareTokenAllocator<Unit> t, Summary su, Summary st, boolean print)
1:9a3fa88:     {
1:9a3fa88:         int size = t.sortedTokens.size();
1:9a3fa88:         double inverseAverage = 1.0 * size / t.strategy.replicas();
1:9a3fa88: 
1:9a3fa88:         Map<Unit, Double> ownership = evaluateReplicatedOwnership(t);
1:9a3fa88:         SummaryStatistics unitStat = new SummaryStatistics();
1:9a3fa88:         for (Map.Entry<Unit, Double> en : ownership.entrySet())
1:9a3fa88:             unitStat.addValue(en.getValue() * inverseAverage / t.unitToTokens.get(en.getKey()).size());
1:9a3fa88:         su.update(unitStat);
1:9a3fa88: 
1:9a3fa88:         SummaryStatistics tokenStat = new SummaryStatistics();
1:9a3fa88:         for (Token tok : t.sortedTokens.keySet())
1:9a3fa88:             tokenStat.addValue(replicatedTokenOwnership(tok, t.sortedTokens, t.strategy) * inverseAverage);
1:9a3fa88:         st.update(tokenStat);
1:9a3fa88: 
1:9a3fa88:         if (print)
1:9a3fa88:         {
1:9a3fa88:             System.out.format("Size %d(%d)   \tunit %s  token %s   %s\n",
1:9a3fa88:                               t.unitCount(), size,
1:9a3fa88:                               mms(unitStat),
1:9a3fa88:                               mms(tokenStat),
1:9a3fa88:                               t.strategy);
1:9a3fa88:             System.out.format("Worst intermediate unit\t%s  token %s\n", su, st);
1:9a3fa88:         }
1:9a3fa88:     }
1:9a3fa88: }
============================================================================
author:Dikang Gu
-------------------------------------------------------------------------------
commit:e2a0d75
/////////////////////////////////////////////////////////////////////////
1: abstract class AbstractReplicationAwareTokenAllocatorTest extends TokenAllocatorTestBase
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:c1a9a47
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.dht.IPartitioner;
0: import org.apache.cassandra.dht.RandomPartitioner;
/////////////////////////////////////////////////////////////////////////
0:     private void random(Map<Token, Unit> map, TestReplicationStrategy rs,
0:                         int unitCount, TokenCount tc, int perUnitCount, IPartitioner partitioner)
/////////////////////////////////////////////////////////////////////////
0:     public void testExistingClusterWithRandomPartitioner()
1:     {
0:         testExistingCluster(new RandomPartitioner());
1:     }
1: 
0:     @Test
0:     public void testExistingClusterWithMurmur3Partitioner()
1:     {
0:         testExistingCluster(new Murmur3Partitioner());
1:     }
1: 
0:     public void testExistingCluster(IPartitioner partitioner)
1:                 testExistingCluster(perUnitCount, fixedTokenCount, new SimpleReplicationStrategy(rf), partitioner);
1:                 testExistingCluster(perUnitCount, varyingTokenCount, new SimpleReplicationStrategy(rf), partitioner);
1:                     testExistingCluster(perUnitCount, fixedTokenCount,
1:                                         new BalancedGroupReplicationStrategy(rf, groupSize), partitioner);
1:                     testExistingCluster(perUnitCount, varyingTokenCount,
1:                                         new UnbalancedGroupReplicationStrategy(rf, groupSize / 2, groupSize * 2, seededRand),
1:                                         partitioner);
1:                 testExistingCluster(perUnitCount, fixedTokenCount,
1:                                     new FixedGroupCountReplicationStrategy(rf, rf * 2), partitioner);
0:     public void testExistingCluster(int perUnitCount, TokenCount tc, TestReplicationStrategy rs, IPartitioner partitioner)
1:         random(tokenMap, rs, targetClusterSize / 2, tc, perUnitCount, partitioner);
1:         loseAndReplace(t, targetClusterSize / 10, tc, perUnitCount, partitioner);
0:     public void testNewClusterWithRandomPartitioner()
0:         Util.flakyTest(this::flakyTestNewClusterWithRandomPartitioner,
0:     @Test
0:     public void testNewClusterWithMurmur3Partitioner()
1:     {
0:         Util.flakyTest(this::flakyTestNewClusterWithMurmur3Partitioner,
0:                        5,
0:                        "It tends to fail sometimes due to the random selection of the tokens in the first few nodes.");
1:     }
1: 
0:     public void flakyTestNewClusterWithRandomPartitioner()
1:     {
0:         flakyTestNewCluster(new RandomPartitioner());
1:     }
1: 
0:     public void flakyTestNewClusterWithMurmur3Partitioner()
1:     {
0:         flakyTestNewCluster(new Murmur3Partitioner());
1:     }
1: 
0:     public void flakyTestNewCluster(IPartitioner partitioner)
/////////////////////////////////////////////////////////////////////////
1:                 testNewCluster(perUnitCount, fixedTokenCount, new SimpleReplicationStrategy(rf), partitioner);
1:                 testNewCluster(perUnitCount, varyingTokenCount, new SimpleReplicationStrategy(rf), partitioner);
1:                     testNewCluster(perUnitCount, fixedTokenCount,
1:                                    new BalancedGroupReplicationStrategy(rf, groupSize), partitioner);
1:                     testNewCluster(perUnitCount, varyingTokenCount,
1:                                    new UnbalancedGroupReplicationStrategy(rf, groupSize / 2, groupSize * 2, seededRand),
1:                                    partitioner);
1:                 testNewCluster(perUnitCount, fixedTokenCount,
1:                                new FixedGroupCountReplicationStrategy(rf, rf * 2), partitioner);
0:     public void testNewCluster(int perUnitCount, TokenCount tc, TestReplicationStrategy rs, IPartitioner partitioner)
/////////////////////////////////////////////////////////////////////////
1:         loseAndReplace(t, targetClusterSize / 5, tc, perUnitCount, partitioner);
1:     private void loseAndReplace(ReplicationAwareTokenAllocator<Unit> t, int howMany,
1:                                 TokenCount tc, int perUnitCount, IPartitioner partitioner)
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:c6ec31b
/////////////////////////////////////////////////////////////////////////
1: import org.junit.Assert;
1: import org.junit.Ignore;
1: /**
1:  * Base class for {@link Murmur3ReplicationAwareTokenAllocatorTest} and {@link RandomReplicationAwareTokenAllocatorTest},
1:  * we need to separate classes to avoid timeous in case flaky tests need to be repeated, see CASSANDRA-12784.
1:  */
1: @Ignore
0: abstract class AbstractReplicationAwareTokenAllocatorTest
/////////////////////////////////////////////////////////////////////////
1:     protected void testExistingCluster(IPartitioner partitioner, int maxVNodeCount)
1:             for (int perUnitCount = 1; perUnitCount <= maxVNodeCount; perUnitCount *= 4)
/////////////////////////////////////////////////////////////////////////
1:     private void testExistingCluster(int perUnitCount, TokenCount tc, TestReplicationStrategy rs, IPartitioner partitioner)
/////////////////////////////////////////////////////////////////////////
1:     protected void testNewCluster(IPartitioner partitioner, int maxVNodeCount)
/////////////////////////////////////////////////////////////////////////
1:             for (int perUnitCount = 1; perUnitCount <= maxVNodeCount; perUnitCount *= 4)
/////////////////////////////////////////////////////////////////////////
1:     private void testNewCluster(int perUnitCount, TokenCount tc, TestReplicationStrategy rs, IPartitioner partitioner)
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:a5cbb02
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.Util;
/////////////////////////////////////////////////////////////////////////
0:         Util.flakyTest(this::flakyTestNewCluster,
0:                        5,
0:                        "It tends to fail sometimes due to the random selection of the tokens in the first few nodes.");
1:     }
1: 
0:     public void flakyTestNewCluster()
1:     {
1:         // This test is flaky because the selection of the tokens for the first RF nodes (which is random, with an
1:         // uncontrolled seed) can sometimes cause a pathological situation where the algorithm will find a (close to)
1:         // ideal distribution of tokens for some number of nodes, which in turn will inevitably cause it to go into a
1:         // bad (unacceptable to the test criteria) distribution after adding one more node.
1: 
1:         // This should happen very rarely, unless something is broken in the token allocation code.
1: 
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:d97695b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.commons.math3.stat.descriptive.SummaryStatistics;
author:branimir
-------------------------------------------------------------------------------
commit:9a3fa88
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.dht.tokenallocator;
1: 
1: import java.util.*;
1: 
0: import junit.framework.Assert;
1: 
1: import com.google.common.collect.Iterables;
1: import com.google.common.collect.Maps;
1: import com.google.common.collect.Sets;
1: 
0: import org.apache.commons.math.stat.descriptive.SummaryStatistics;
1: 
0: import org.junit.Test;
1: 
0: import org.apache.cassandra.dht.Murmur3Partitioner;
1: import org.apache.cassandra.dht.Token;
1: 
0: public class ReplicationAwareTokenAllocatorTest
1: {
0:     private static final int MAX_VNODE_COUNT = 64;
1: 
0:     private static final int TARGET_CLUSTER_SIZE = 250;
1: 
0:     interface TestReplicationStrategy extends ReplicationStrategy<Unit>
1:     {
0:         void addUnit(Unit n);
1: 
0:         void removeUnit(Unit n);
1: 
1:         /**
0:          * Returns a list of all replica units for given token.
1:          */
0:         List<Unit> getReplicas(Token token, NavigableMap<Token, Unit> sortedTokens);
1: 
1:         /**
0:          * Returns the start of the token span that is replicated in this token.
0:          * Note: Though this is not trivial to see, the replicated span is always contiguous. A token in the same
0:          * group acts as a barrier; if one is not found the token replicates everything up to the replica'th distinct
0:          * group seen in front of it.
1:          */
0:         Token replicationStart(Token token, Unit unit, NavigableMap<Token, Unit> sortedTokens);
1: 
1:         /**
0:          * Multiplier for the acceptable disbalance in the cluster. With some strategies it is harder to achieve good
0:          * results.
1:          */
0:         public double spreadExpectation();
1:     }
1: 
0:     static class NoReplicationStrategy implements TestReplicationStrategy
1:     {
1:         public List<Unit> getReplicas(Token token, NavigableMap<Token, Unit> sortedTokens)
1:         {
0:             return Collections.singletonList(sortedTokens.ceilingEntry(token).getValue());
1:         }
1: 
1:         public Token replicationStart(Token token, Unit unit, NavigableMap<Token, Unit> sortedTokens)
1:         {
0:             return sortedTokens.lowerKey(token);
1:         }
1: 
1:         public String toString()
1:         {
0:             return "No replication";
1:         }
1: 
1:         public void addUnit(Unit n)
1:         {
1:         }
1: 
1:         public void removeUnit(Unit n)
1:         {
1:         }
1: 
1:         public int replicas()
1:         {
1:             return 1;
1:         }
1: 
1:         public boolean sameGroup(Unit n1, Unit n2)
1:         {
1:             return false;
1:         }
1: 
0:         public Object getGroup(Unit unit)
1:         {
1:             return unit;
1:         }
1: 
1:         public double spreadExpectation()
1:         {
1:             return 1;
1:         }
1:     }
1: 
1:     static class SimpleReplicationStrategy implements TestReplicationStrategy
1:     {
1:         int replicas;
1: 
1:         public SimpleReplicationStrategy(int replicas)
1:         {
1:             super();
1:             this.replicas = replicas;
1:         }
1: 
1:         public List<Unit> getReplicas(Token token, NavigableMap<Token, Unit> sortedTokens)
1:         {
1:             List<Unit> endpoints = new ArrayList<Unit>(replicas);
1: 
1:             token = sortedTokens.ceilingKey(token);
1:             if (token == null)
1:                 token = sortedTokens.firstKey();
1:             Iterator<Unit> iter = Iterables.concat(sortedTokens.tailMap(token, true).values(), sortedTokens.values()).iterator();
1:             while (endpoints.size() < replicas)
1:             {
1:                 if (!iter.hasNext())
1:                     return endpoints;
1:                 Unit ep = iter.next();
1:                 if (!endpoints.contains(ep))
1:                     endpoints.add(ep);
1:             }
1:             return endpoints;
1:         }
1: 
1:         public Token replicationStart(Token token, Unit unit, NavigableMap<Token, Unit> sortedTokens)
1:         {
1:             Set<Unit> seenUnits = Sets.newHashSet();
1:             int unitsFound = 0;
1: 
1:             for (Map.Entry<Token, Unit> en : Iterables.concat(
1:                                                              sortedTokens.headMap(token, false).descendingMap().entrySet(),
1:                                                              sortedTokens.descendingMap().entrySet()))
1:             {
1:                 Unit n = en.getValue();
1:                 // Same group as investigated unit is a break; anything that could replicate in it replicates there.
1:                 if (n == unit)
1:                     break;
1: 
1:                 if (seenUnits.add(n))
1:                 {
1:                     if (++unitsFound == replicas)
1:                         break;
1:                 }
1:                 token = en.getKey();
1:             }
1:             return token;
1:         }
1: 
1:         public void addUnit(Unit n)
1:         {
1:         }
1: 
1:         public void removeUnit(Unit n)
1:         {
1:         }
1: 
1:         public String toString()
1:         {
1:             return String.format("Simple %d replicas", replicas);
1:         }
1: 
1:         public int replicas()
1:         {
1:             return replicas;
1:         }
1: 
1:         public boolean sameGroup(Unit n1, Unit n2)
1:         {
1:             return false;
1:         }
1: 
1:         public Unit getGroup(Unit unit)
1:         {
1:             // The unit is the group.
1:             return unit;
1:         }
1: 
1:         public double spreadExpectation()
1:         {
1:             return 1;
1:         }
1:     }
1: 
1:     static abstract class GroupReplicationStrategy implements TestReplicationStrategy
1:     {
1:         final int replicas;
1:         final Map<Unit, Integer> groupMap;
1: 
1:         public GroupReplicationStrategy(int replicas)
1:         {
1:             this.replicas = replicas;
1:             this.groupMap = Maps.newHashMap();
1:         }
1: 
1:         public List<Unit> getReplicas(Token token, NavigableMap<Token, Unit> sortedTokens)
1:         {
1:             List<Unit> endpoints = new ArrayList<Unit>(replicas);
1:             BitSet usedGroups = new BitSet();
1: 
1:             if (sortedTokens.isEmpty())
1:                 return endpoints;
1: 
1:             token = sortedTokens.ceilingKey(token);
1:             if (token == null)
1:                 token = sortedTokens.firstKey();
1:             Iterator<Unit> iter = Iterables.concat(sortedTokens.tailMap(token, true).values(), sortedTokens.values()).iterator();
1:             while (endpoints.size() < replicas)
1:             {
1:                 // For simlicity assuming list can't be exhausted before finding all replicas.
1:                 Unit ep = iter.next();
1:                 int group = groupMap.get(ep);
1:                 if (!usedGroups.get(group))
1:                 {
1:                     endpoints.add(ep);
1:                     usedGroups.set(group);
1:                 }
1:             }
1:             return endpoints;
1:         }
1: 
1:         public Token lastReplicaToken(Token token, NavigableMap<Token, Unit> sortedTokens)
1:         {
1:             BitSet usedGroups = new BitSet();
1:             int groupsFound = 0;
1: 
1:             token = sortedTokens.ceilingKey(token);
1:             if (token == null)
1:                 token = sortedTokens.firstKey();
1:             for (Map.Entry<Token, Unit> en :
1:             Iterables.concat(sortedTokens.tailMap(token, true).entrySet(),
1:                              sortedTokens.entrySet()))
1:             {
1:                 Unit ep = en.getValue();
1:                 int group = groupMap.get(ep);
1:                 if (!usedGroups.get(group))
1:                 {
1:                     usedGroups.set(group);
1:                     if (++groupsFound >= replicas)
1:                         return en.getKey();
1:                 }
1:             }
1:             return token;
1:         }
1: 
1:         public Token replicationStart(Token token, Unit unit, NavigableMap<Token, Unit> sortedTokens)
1:         {
1:             // replicated ownership
1:             int unitGroup = groupMap.get(unit);   // unit must be already added
1:             BitSet seenGroups = new BitSet();
1:             int groupsFound = 0;
1: 
1:             for (Map.Entry<Token, Unit> en : Iterables.concat(
1:                                                              sortedTokens.headMap(token, false).descendingMap().entrySet(),
1:                                                              sortedTokens.descendingMap().entrySet()))
1:             {
1:                 Unit n = en.getValue();
1:                 int ngroup = groupMap.get(n);
1:                 // Same group as investigated unit is a break; anything that could replicate in it replicates there.
1:                 if (ngroup == unitGroup)
1:                     break;
1: 
1:                 if (!seenGroups.get(ngroup))
1:                 {
1:                     if (++groupsFound == replicas)
1:                         break;
1:                     seenGroups.set(ngroup);
1:                 }
1:                 token = en.getKey();
1:             }
1:             return token;
1:         }
1: 
1:         public String toString()
1:         {
1:             Map<Integer, Integer> idToSize = instanceToCount(groupMap);
1:             Map<Integer, Integer> sizeToCount = Maps.newTreeMap();
1:             sizeToCount.putAll(instanceToCount(idToSize));
1:             return String.format("%s strategy, %d replicas, group size to count %s", getClass().getSimpleName(), replicas, sizeToCount);
1:         }
1: 
1:         @Override
1:         public int replicas()
1:         {
1:             return replicas;
1:         }
1: 
1:         public boolean sameGroup(Unit n1, Unit n2)
1:         {
1:             return groupMap.get(n1).equals(groupMap.get(n2));
1:         }
1: 
1:         public void removeUnit(Unit n)
1:         {
1:             groupMap.remove(n);
1:         }
1: 
1:         public Integer getGroup(Unit unit)
1:         {
1:             return groupMap.get(unit);
1:         }
1: 
1:         public double spreadExpectation()
1:         {
1:             return 1.5;   // Even balanced racks get disbalanced when they lose nodes.
1:         }
1:     }
1: 
1:     private static <T> Map<T, Integer> instanceToCount(Map<?, T> map)
1:     {
1:         Map<T, Integer> idToCount = Maps.newHashMap();
1:         for (Map.Entry<?, T> en : map.entrySet())
1:         {
1:             Integer old = idToCount.get(en.getValue());
1:             idToCount.put(en.getValue(), old != null ? old + 1 : 1);
1:         }
1:         return idToCount;
1:     }
1: 
1:     /**
1:      * Group strategy spreading units into a fixed number of groups.
1:      */
1:     static class FixedGroupCountReplicationStrategy extends GroupReplicationStrategy
1:     {
1:         int groupId;
1:         int groupCount;
1: 
1:         public FixedGroupCountReplicationStrategy(int replicas, int groupCount)
1:         {
1:             super(replicas);
1:             assert groupCount >= replicas;
1:             groupId = 0;
1:             this.groupCount = groupCount;
1:         }
1: 
1:         public void addUnit(Unit n)
1:         {
1:             groupMap.put(n, groupId++ % groupCount);
1:         }
1:     }
1: 
1:     /**
1:      * Group strategy with a fixed number of units per group.
1:      */
1:     static class BalancedGroupReplicationStrategy extends GroupReplicationStrategy
1:     {
1:         int groupId;
1:         int groupSize;
1: 
1:         public BalancedGroupReplicationStrategy(int replicas, int groupSize)
1:         {
1:             super(replicas);
1:             groupId = 0;
1:             this.groupSize = groupSize;
1:         }
1: 
1:         public void addUnit(Unit n)
1:         {
1:             groupMap.put(n, groupId++ / groupSize);
1:         }
1:     }
1: 
1:     static class UnbalancedGroupReplicationStrategy extends GroupReplicationStrategy
1:     {
1:         int groupId;
1:         int nextSize;
1:         int num;
1:         int minGroupSize;
1:         int maxGroupSize;
1:         Random rand;
1: 
1:         public UnbalancedGroupReplicationStrategy(int replicas, int minGroupSize, int maxGroupSize, Random rand)
1:         {
1:             super(replicas);
1:             groupId = -1;
1:             nextSize = 0;
1:             num = 0;
1:             this.maxGroupSize = maxGroupSize;
1:             this.minGroupSize = minGroupSize;
1:             this.rand = rand;
1:         }
1: 
1:         public void addUnit(Unit n)
1:         {
1:             if (++num > nextSize)
1:             {
1:                 nextSize = minGroupSize + rand.nextInt(maxGroupSize - minGroupSize + 1);
1:                 ++groupId;
1:                 num = 0;
1:             }
1:             groupMap.put(n, groupId);
1:         }
1: 
1:         public double spreadExpectation()
1:         {
1:             return 2;
1:         }
1:     }
1: 
1:     static Map<Unit, Double> evaluateReplicatedOwnership(ReplicationAwareTokenAllocator<Unit> t)
1:     {
1:         Map<Unit, Double> ownership = Maps.newHashMap();
1:         Iterator<Token> it = t.sortedTokens.keySet().iterator();
1:         if (!it.hasNext())
1:             return ownership;
1: 
1:         Token current = it.next();
1:         while (it.hasNext())
1:         {
1:             Token next = it.next();
1:             addOwnership(t, current, next, ownership);
1:             current = next;
1:         }
1:         addOwnership(t, current, t.sortedTokens.firstKey(), ownership);
1: 
1:         return ownership;
1:     }
1: 
1:     private static void addOwnership(ReplicationAwareTokenAllocator<Unit> t, Token current, Token next, Map<Unit, Double> ownership)
1:     {
1:         TestReplicationStrategy ts = (TestReplicationStrategy) t.strategy;
1:         double size = current.size(next);
1:         Token representative = t.partitioner.midpoint(current, next);
1:         for (Unit n : ts.getReplicas(representative, t.sortedTokens))
1:         {
1:             Double v = ownership.get(n);
1:             ownership.put(n, v != null ? v + size : size);
1:         }
1:     }
1: 
1:     private static double replicatedTokenOwnership(Token token, NavigableMap<Token, Unit> sortedTokens, ReplicationStrategy<Unit> strategy)
1:     {
1:         TestReplicationStrategy ts = (TestReplicationStrategy) strategy;
1:         Token next = sortedTokens.higherKey(token);
1:         if (next == null)
1:             next = sortedTokens.firstKey();
1:         return ts.replicationStart(token, sortedTokens.get(token), sortedTokens).size(next);
1:     }
1: 
0:     static interface TokenCount
1:     {
0:         int tokenCount(int perUnitCount, Random rand);
1: 
0:         double spreadExpectation();
1:     }
1: 
0:     static TokenCount fixedTokenCount = new TokenCount()
1:     {
0:         public int tokenCount(int perUnitCount, Random rand)
1:         {
0:             return perUnitCount;
1:         }
1: 
1:         public double spreadExpectation()
1:         {
0:             return 4;  // High tolerance to avoid flakiness.
1:         }
0:     };
1: 
0:     static TokenCount varyingTokenCount = new TokenCount()
1:     {
0:         public int tokenCount(int perUnitCount, Random rand)
1:         {
0:             if (perUnitCount == 1) return 1;
0:             // 25 to 175%
0:             return rand.nextInt(perUnitCount * 3 / 2) + (perUnitCount + 3) / 4;
1:         }
1: 
1:         public double spreadExpectation()
1:         {
0:             return 8;  // High tolerance to avoid flakiness.
1:         }
0:     };
1: 
0:     Murmur3Partitioner partitioner = new Murmur3Partitioner();
0:     Random seededRand = new Random(2);
1: 
0:     private void random(Map<Token, Unit> map, TestReplicationStrategy rs, int unitCount, TokenCount tc, int perUnitCount)
1:     {
0:         System.out.format("\nRandom generation of %d units with %d tokens each\n", unitCount, perUnitCount);
0:         Random rand = seededRand;
0:         for (int i = 0; i < unitCount; i++)
1:         {
1:             Unit unit = new Unit();
0:             rs.addUnit(unit);
1:             int tokens = tc.tokenCount(perUnitCount, rand);
0:             for (int j = 0; j < tokens; j++)
1:             {
0:                 map.put(partitioner.getRandomToken(rand), unit);
1:             }
1:         }
1:     }
1: 
0:     @Test
0:     public void testExistingCluster()
1:     {
1:         for (int rf = 1; rf <= 5; ++rf)
1:         {
0:             for (int perUnitCount = 1; perUnitCount <= MAX_VNODE_COUNT; perUnitCount *= 4)
1:             {
0:                 testExistingCluster(perUnitCount, fixedTokenCount, new SimpleReplicationStrategy(rf));
0:                 testExistingCluster(perUnitCount, varyingTokenCount, new SimpleReplicationStrategy(rf));
1:                 if (rf == 1) continue;  // Replication strategy doesn't matter for RF = 1.
1:                 for (int groupSize = 4; groupSize <= 64 && groupSize * rf * 4 < TARGET_CLUSTER_SIZE; groupSize *= 4)
1:                 {
0:                     testExistingCluster(perUnitCount, fixedTokenCount, new BalancedGroupReplicationStrategy(rf, groupSize));
0:                     testExistingCluster(perUnitCount, varyingTokenCount, new UnbalancedGroupReplicationStrategy(rf, groupSize / 2, groupSize * 2, seededRand));
1:                 }
0:                 testExistingCluster(perUnitCount, fixedTokenCount, new FixedGroupCountReplicationStrategy(rf, rf * 2));
1:             }
1:         }
1:     }
1: 
0:     public void testExistingCluster(int perUnitCount, TokenCount tc, TestReplicationStrategy rs)
1:     {
1:         System.out.println("Testing existing cluster, target " + perUnitCount + " vnodes, replication " + rs);
1:         final int targetClusterSize = TARGET_CLUSTER_SIZE;
1:         NavigableMap<Token, Unit> tokenMap = Maps.newTreeMap();
1: 
0:         random(tokenMap, rs, targetClusterSize / 2, tc, perUnitCount);
1: 
1:         ReplicationAwareTokenAllocator<Unit> t = new ReplicationAwareTokenAllocator<>(tokenMap, rs, partitioner);
1:         grow(t, targetClusterSize * 9 / 10, tc, perUnitCount, false);
1:         grow(t, targetClusterSize, tc, perUnitCount, true);
0:         loseAndReplace(t, targetClusterSize / 10, tc, perUnitCount);
1:         System.out.println();
1:     }
1: 
0:     @Test
0:     public void testNewCluster()
1:     {
1:         for (int rf = 2; rf <= 5; ++rf)
1:         {
0:             for (int perUnitCount = 1; perUnitCount <= MAX_VNODE_COUNT; perUnitCount *= 4)
1:             {
0:                 testNewCluster(perUnitCount, fixedTokenCount, new SimpleReplicationStrategy(rf));
0:                 testNewCluster(perUnitCount, varyingTokenCount, new SimpleReplicationStrategy(rf));
1:                 if (rf == 1) continue;  // Replication strategy doesn't matter for RF = 1.
1:                 for (int groupSize = 4; groupSize <= 64 && groupSize * rf * 8 < TARGET_CLUSTER_SIZE; groupSize *= 4)
1:                 {
0:                     testNewCluster(perUnitCount, fixedTokenCount, new BalancedGroupReplicationStrategy(rf, groupSize));
0:                     testNewCluster(perUnitCount, varyingTokenCount, new UnbalancedGroupReplicationStrategy(rf, groupSize / 2, groupSize * 2, seededRand));
1:                 }
0:                 testNewCluster(perUnitCount, fixedTokenCount, new FixedGroupCountReplicationStrategy(rf, rf * 2));
1:             }
1:         }
1:     }
1: 
0:     public void testNewCluster(int perUnitCount, TokenCount tc, TestReplicationStrategy rs)
1:     {
1:         System.out.println("Testing new cluster, target " + perUnitCount + " vnodes, replication " + rs);
1:         final int targetClusterSize = TARGET_CLUSTER_SIZE;
1:         NavigableMap<Token, Unit> tokenMap = Maps.newTreeMap();
1: 
1:         ReplicationAwareTokenAllocator<Unit> t = new ReplicationAwareTokenAllocator<>(tokenMap, rs, partitioner);
1:         grow(t, targetClusterSize * 2 / 5, tc, perUnitCount, false);
1:         grow(t, targetClusterSize, tc, perUnitCount, true);
0:         loseAndReplace(t, targetClusterSize / 5, tc, perUnitCount);
1:         System.out.println();
1:     }
1: 
0:     private void loseAndReplace(ReplicationAwareTokenAllocator<Unit> t, int howMany, TokenCount tc, int perUnitCount)
1:     {
1:         int fullCount = t.unitCount();
1:         System.out.format("Losing %d units. ", howMany);
1:         for (int i = 0; i < howMany; ++i)
1:         {
1:             Unit u = t.unitFor(partitioner.getRandomToken(seededRand));
1:             t.removeUnit(u);
1:             ((TestReplicationStrategy) t.strategy).removeUnit(u);
1:         }
1:         // Grow half without verifying.
1:         grow(t, (t.unitCount() + fullCount * 3) / 4, tc, perUnitCount, false);
1:         // Metrics should be back to normal by now. Check that they remain so.
1:         grow(t, fullCount, tc, perUnitCount, true);
1:     }
1: 
0:     static class Summary
1:     {
0:         double min = 1;
0:         double max = 1;
0:         double stddev = 0;
1: 
0:         void update(SummaryStatistics stat)
1:         {
0:             min = Math.min(min, stat.getMin());
0:             max = Math.max(max, stat.getMax());
0:             stddev = Math.max(stddev, stat.getStandardDeviation());
1:         }
1: 
1:         public String toString()
1:         {
0:             return String.format("max %.2f min %.2f stddev %.4f", max, min, stddev);
1:         }
1:     }
1: 
1:     public void grow(ReplicationAwareTokenAllocator<Unit> t, int targetClusterSize, TokenCount tc, int perUnitCount, boolean verifyMetrics)
1:     {
1:         int size = t.unitCount();
1:         Summary su = new Summary();
1:         Summary st = new Summary();
1:         Random rand = new Random(targetClusterSize + perUnitCount);
1:         TestReplicationStrategy strategy = (TestReplicationStrategy) t.strategy;
1:         if (size < targetClusterSize)
1:         {
1:             System.out.format("Adding %d unit(s) using %s...", targetClusterSize - size, t.toString());
1:             long time = System.currentTimeMillis();
1:             while (size < targetClusterSize)
1:             {
1:                 int tokens = tc.tokenCount(perUnitCount, rand);
1:                 Unit unit = new Unit();
1:                 strategy.addUnit(unit);
1:                 t.addUnit(unit, tokens);
1:                 ++size;
1:                 if (verifyMetrics)
1:                     updateSummary(t, su, st, false);
1:             }
1:             System.out.format(" Done in %.3fs\n", (System.currentTimeMillis() - time) / 1000.0);
1:             if (verifyMetrics)
1:             {
1:                 updateSummary(t, su, st, true);
1:                 double maxExpected = 1.0 + tc.spreadExpectation() * strategy.spreadExpectation() / (perUnitCount * t.replicas);
1:                 if (su.max > maxExpected)
1:                 {
1:                     Assert.fail(String.format("Expected max unit size below %.4f, was %.4f", maxExpected, su.max));
1:                 }
1:                 // We can't verify lower side range as small loads can't always be fixed.
1:             }
1:         }
1:     }
1: 
1: 
1:     private void updateSummary(ReplicationAwareTokenAllocator<Unit> t, Summary su, Summary st, boolean print)
1:     {
1:         int size = t.sortedTokens.size();
1:         double inverseAverage = 1.0 * size / t.strategy.replicas();
1: 
1:         Map<Unit, Double> ownership = evaluateReplicatedOwnership(t);
1:         SummaryStatistics unitStat = new SummaryStatistics();
1:         for (Map.Entry<Unit, Double> en : ownership.entrySet())
1:             unitStat.addValue(en.getValue() * inverseAverage / t.unitToTokens.get(en.getKey()).size());
1:         su.update(unitStat);
1: 
1:         SummaryStatistics tokenStat = new SummaryStatistics();
1:         for (Token tok : t.sortedTokens.keySet())
1:             tokenStat.addValue(replicatedTokenOwnership(tok, t.sortedTokens, t.strategy) * inverseAverage);
1:         st.update(tokenStat);
1: 
1:         if (print)
1:         {
1:             System.out.format("Size %d(%d)   \tunit %s  token %s   %s\n",
1:                               t.unitCount(), size,
1:                               mms(unitStat),
1:                               mms(tokenStat),
1:                               t.strategy);
1:             System.out.format("Worst intermediate unit\t%s  token %s\n", su, st);
1:         }
1:     }
1: 
1: 
0:     private static String mms(SummaryStatistics s)
1:     {
0:         return String.format("max %.2f min %.2f stddev %.4f", s.getMax(), s.getMin(), s.getStandardDeviation());
1:     }
1: 
1: 
0:     int nextUnitId = 0;
1: 
0:     final class Unit implements Comparable<Unit>
1:     {
0:         int unitId = nextUnitId++;
1: 
1:         public String toString()
1:         {
0:             return Integer.toString(unitId);
1:         }
1: 
1:         @Override
0:         public int compareTo(Unit o)
1:         {
0:             return Integer.compare(unitId, o.unitId);
1:         }
1:     }
1: }
============================================================================