1:9c278ff: /*
1:9c278ff:  * Licensed to the Apache Software Foundation (ASF) under one
1:9c278ff:  * or more contributor license agreements.  See the NOTICE file
1:9c278ff:  * distributed with this work for additional information
1:9c278ff:  * regarding copyright ownership.  The ASF licenses this file
1:9c278ff:  * to you under the Apache License, Version 2.0 (the
1:9c278ff:  * "License"); you may not use this file except in compliance
1:9c278ff:  * with the License.  You may obtain a copy of the License at
1:85d6ce6:  *
1:07cf56f:  *     http://www.apache.org/licenses/LICENSE-2.0
1:85d6ce6:  *
1:07cf56f:  * Unless required by applicable law or agreed to in writing, software
1:07cf56f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:07cf56f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:07cf56f:  * See the License for the specific language governing permissions and
1:07cf56f:  * limitations under the License.
1:85d6ce6:  */
1:9c278ff: package org.apache.cassandra.utils;
1:a56bc16: 
1:49c9c01: import java.io.File;
1:fc4502a: import java.io.FileDescriptor;
1:49c9c01: import java.io.FileInputStream;
1:75409a1: import java.io.IOException;
1:3991fba: import java.lang.reflect.Field;
1:2b4029a: import java.nio.channels.FileChannel;
1:cb06283: import java.util.concurrent.TimeUnit;
1:ffdf6c7: 
1:9c278ff: import org.slf4j.Logger;
1:9c278ff: import org.slf4j.LoggerFactory;
1:3991fba: 
1:4909415: import com.sun.jna.LastErrorException;
1:9c278ff: import com.sun.jna.Native;
1:cb06283: import com.sun.jna.Pointer;
1:ffdf6c7: import sun.nio.ch.FileChannelImpl;
1:3991fba: 
1:9c278ff: public final class CLibrary
1:4909415: {
1:5a6e2b0:     private static final Logger logger = LoggerFactory.getLogger(CLibrary.class);
1:e9f8fc7: 
1:a56bc16:     private static final int MCL_CURRENT;
1:a56bc16:     private static final int MCL_FUTURE;
1:3991fba: 
1:85d6ce6:     private static final int ENOMEM = 12;
1:3991fba: 
1:3991fba:     private static final int F_GETFL   = 3;  /* get file status flags */
1:3991fba:     private static final int F_SETFL   = 4;  /* set file status flags */
1:3991fba:     private static final int F_NOCACHE = 48; /* Mac OS X specific flag, turns cache on/off */
1:3991fba:     private static final int O_DIRECT  = 040000; /* fcntl.h */
1:be31393:     private static final int O_RDONLY  = 00000000; /* fcntl.h */
1:3991fba: 
1:3991fba:     private static final int POSIX_FADV_NORMAL     = 0; /* fadvise.h */
1:3991fba:     private static final int POSIX_FADV_RANDOM     = 1; /* fadvise.h */
1:3991fba:     private static final int POSIX_FADV_SEQUENTIAL = 2; /* fadvise.h */
1:3991fba:     private static final int POSIX_FADV_WILLNEED   = 3; /* fadvise.h */
1:3991fba:     private static final int POSIX_FADV_DONTNEED   = 4; /* fadvise.h */
1:3991fba:     private static final int POSIX_FADV_NOREUSE    = 5; /* fadvise.h */
1:11eb352: 
1:e9f8fc7:     static boolean jnaAvailable = true;
1:11eb352:     static boolean jnaLockable = false;
1:ffdf6c7:     private static boolean fsyncUnavailable = false;
1:880ce10: 
1:ffdf6c7:     private static final boolean OS_LINUX;
1:ffdf6c7:     private static final boolean OS_AIX;
1:ffdf6c7:     private static final boolean OS_MAC;
1:ffdf6c7: 
1:ffdf6c7:     private static final Field FILE_DESCRIPTOR_FD_FIELD;
1:ffdf6c7:     private static final Field FILE_CHANNEL_FD_FIELD;
1:e9f8fc7: 
1:9c278ff:     static
1:4909415:     {
1:ffdf6c7:         String os = System.getProperty("os.name").toLowerCase();
1:ffdf6c7:         OS_LINUX = os.contains("linux");
1:ffdf6c7:         OS_AIX = os.contains("aix");
1:ffdf6c7:         OS_MAC = os.contains("mac");
1:ffdf6c7: 
1:ffdf6c7:         FILE_DESCRIPTOR_FD_FIELD = FBUtilities.getProtectedField(FileDescriptor.class, "fd");
1:ffdf6c7:         FILE_CHANNEL_FD_FIELD = FBUtilities.getProtectedField(FileChannelImpl.class, "fd");
1:ffdf6c7: 
1:9c278ff:         try
1:4909415:         {
1:9c278ff:             Native.register("c");
1:85d6ce6:         }
1:9c278ff:         catch (NoClassDefFoundError e)
1:880ce10:         {
1:68baaed:             logger.warn("JNA not found. Native methods will be disabled.");
1:e9f8fc7:             jnaAvailable = false;
1:880ce10:         }
1:85d6ce6:         catch (UnsatisfiedLinkError e)
1:3991fba:         {
1:68baaed:             logger.warn("JNA link failure, one or more native method will be unavailable.");
1:4a849ef:             logger.trace("JNA link failure details: {}", e.getMessage());
1:3991fba:         }
1:c2bb26f:         catch (NoSuchMethodError e)
1:c2bb26f:         {
1:c2bb26f:             logger.warn("Obsolete version of JNA present; unable to register C library. Upgrade to JNA 3.2.7 or later");
1:e9f8fc7:             jnaAvailable = false;
1:c2bb26f:         }
1:880ce10: 
1:a56bc16:         if (System.getProperty("os.arch").toLowerCase().contains("ppc"))
1:a56bc16:         {
1:ffdf6c7:             if (OS_LINUX)
1:a56bc16:             {
1:a56bc16:                MCL_CURRENT = 0x2000;
1:a56bc16:                MCL_FUTURE = 0x4000;
1:a56bc16:             }
1:ffdf6c7:             else if (OS_AIX)
1:a56bc16:             {
1:a56bc16:                 MCL_CURRENT = 0x100;
1:a56bc16:                 MCL_FUTURE = 0x200;
1:a56bc16:             }
1:a56bc16:             else
1:a56bc16:             {
1:a56bc16:                 MCL_CURRENT = 1;
1:a56bc16:                 MCL_FUTURE = 2;
1:a56bc16:             }
1:a56bc16:         }
1:a56bc16:         else
1:a56bc16:         {
1:a56bc16:             MCL_CURRENT = 1;
1:a56bc16:             MCL_FUTURE = 2;
1:a56bc16:         }
1:85d6ce6:     }
1:2b4029a: 
1:fc4502a:     private static native int mlockall(int flags) throws LastErrorException;
1:fc4502a:     private static native int munlockall() throws LastErrorException;
1:e9f8fc7:     private static native int fcntl(int fd, int command, long flags) throws LastErrorException;
1:e9f8fc7:     private static native int posix_fadvise(int fd, long offset, int len, int flag) throws LastErrorException;
1:e9f8fc7:     private static native int open(String path, int flags) throws LastErrorException;
1:e9f8fc7:     private static native int fsync(int fd) throws LastErrorException;
1:e9f8fc7:     private static native int close(int fd) throws LastErrorException;
1:cb06283:     private static native Pointer strerror(int errnum) throws LastErrorException;
1:2b4029a: 
1:85d6ce6:     private static int errno(RuntimeException e)
1:85d6ce6:     {
1:b5d9ac6:         assert e instanceof LastErrorException;
1:4909415:         try
1:85d6ce6:         {
1:b5d9ac6:             return ((LastErrorException) e).getErrorCode();
1:4909415:         }
1:4909415:         catch (NoSuchMethodError x)
1:85d6ce6:         {
1:4909415:             logger.warn("Obsolete version of JNA present; unable to read errno. Upgrade to JNA 3.2.7 or later");
1:4909415:             return 0;
1:4909415:         }
1:4909415:     }
1:e9f8fc7: 
1:9c278ff:     private CLibrary() {}
1:11eb352: 
1:11eb352:     public static boolean jnaAvailable()
1:11eb352:     {
1:11eb352:         return jnaAvailable;
1:11eb352:     }
1:11eb352: 
1:11eb352:     public static boolean jnaMemoryLockable()
1:11eb352:     {
1:11eb352:         return jnaLockable;
1:11eb352:     }
1:880ce10: 
1:85d6ce6:     public static void tryMlockall()
1:880ce10:     {
1:85d6ce6:         try
1:85d6ce6:         {
1:4a65311:             mlockall(MCL_CURRENT);
1:11eb352:             jnaLockable = true;
1:29f7f06:             logger.info("JNA mlockall successful");
1:880ce10:         }
1:9c278ff:         catch (UnsatisfiedLinkError e)
1:85d6ce6:         {
1:85d6ce6:             // this will have already been logged by CLibrary, no need to repeat it
1:85d6ce6:         }
1:e9f8fc7:         catch (RuntimeException e)
1:e9f8fc7:         {
1:e9f8fc7:             if (!(e instanceof LastErrorException))
1:e9f8fc7:                 throw e;
1:e9f8fc7: 
1:ffdf6c7:             if (OS_LINUX && errno(e) == ENOMEM)
1:85d6ce6:             {
1:85d6ce6:                 logger.warn("Unable to lock JVM memory (ENOMEM)."
1:e9f8fc7:                         + " This can result in part of the JVM being swapped out, especially with mmapped I/O enabled."
1:e9f8fc7:                         + " Increase RLIMIT_MEMLOCK or run Cassandra as root.");
1:e9f8fc7:             }
1:ffdf6c7:             else if (!OS_MAC)
1:85d6ce6:             {
1:85d6ce6:                 // OS X allows mlockall to be called, but always returns an error
1:db9bc69:                 logger.warn("Unknown mlockall error {}", errno(e));
1:85d6ce6:             }
1:85d6ce6:         }
1:85d6ce6:     }
1:e9f8fc7: 
1:4e95953:     public static void trySkipCache(String path, long offset, long len)
1:4e95953:     {
1:49c9c01:         File f = new File(path);
1:49c9c01:         if (!f.exists())
1:49c9c01:             return;
1:49c9c01: 
1:49c9c01:         try (FileInputStream fis = new FileInputStream(f))
1:49c9c01:         {
1:49c9c01:             trySkipCache(getfd(fis.getChannel()), offset, len, path);
1:49c9c01:         }
1:49c9c01:         catch (IOException e)
1:49c9c01:         {
1:49c9c01:             logger.warn("Could not skip cache", e);
1:49c9c01:         }
1:4e95953:     }
1:4e95953: 
1:cb06283:     public static void trySkipCache(int fd, long offset, long len, String path)
1:4e95953:     {
1:4e95953:         if (len == 0)
1:cb06283:             trySkipCache(fd, 0, 0, path);
1:4e95953: 
1:4e95953:         while (len > 0)
1:4e95953:         {
1:4e95953:             int sublen = (int) Math.min(Integer.MAX_VALUE, len);
1:cb06283:             trySkipCache(fd, offset, sublen, path);
1:4e95953:             len -= sublen;
1:4e95953:             offset -= sublen;
1:4e95953:         }
1:4e95953:     }
1:4e95953: 
1:cb06283:     public static void trySkipCache(int fd, long offset, int len, String path)
1:3991fba:     {
1:fc4502a:         if (fd < 0)
1:3991fba:             return;
1:e9f8fc7: 
1:3991fba:         try
1:3991fba:         {
1:ffdf6c7:             if (OS_LINUX)
1:3991fba:             {
1:cb06283:                 int result = posix_fadvise(fd, offset, len, POSIX_FADV_DONTNEED);
1:cb06283:                 if (result != 0)
1:cb06283:                     NoSpamLogger.log(
1:cb06283:                             logger,
1:cb06283:                             NoSpamLogger.Level.WARN,
1:cb06283:                             10,
1:cb06283:                             TimeUnit.MINUTES,
1:cb06283:                             "Failed trySkipCache on file: {} Error: " + strerror(result).getString(0),
1:cb06283:                             path);
1:3991fba:             }
1:3991fba:         }
1:3991fba:         catch (UnsatisfiedLinkError e)
1:3991fba:         {
1:3991fba:             // if JNA is unavailable just skipping Direct I/O
1:3991fba:             // instance of this class will act like normal RandomAccessFile
1:e9f8fc7:         }
1:e9f8fc7:         catch (RuntimeException e)
1:e9f8fc7:         {
1:e9f8fc7:             if (!(e instanceof LastErrorException))
1:e9f8fc7:                 throw e;
1:e9f8fc7: 
1:2dc2bb8:             logger.warn("posix_fadvise({}, {}) failed, errno ({}).", fd, offset, errno(e));
1:3991fba:         }
1:3991fba:     }
1:fc4502a: 
1:3991fba:     public static int tryFcntl(int fd, int command, int flags)
1:3991fba:     {
1:4a65311:         // fcntl return value may or may not be useful, depending on the command
1:3991fba:         int result = -1;
1:3991fba: 
1:3991fba:         try
1:3991fba:         {
1:e9f8fc7:             result = fcntl(fd, command, flags);
1:e9f8fc7:         }
1:e9f8fc7:         catch (UnsatisfiedLinkError e)
1:e9f8fc7:         {
1:e9f8fc7:             // if JNA is unavailable just skipping
1:3991fba:         }
1:3991fba:         catch (RuntimeException e)
1:3991fba:         {
1:3991fba:             if (!(e instanceof LastErrorException))
1:3991fba:                 throw e;
1:3991fba: 
1:2dc2bb8:             logger.warn("fcntl({}, {}, {}) failed, errno ({}).", fd, command, flags, errno(e));
1:3991fba:         }
1:3991fba: 
1:3991fba:         return result;
1:3991fba:     }
1:3991fba: 
1:be31393:     public static int tryOpenDirectory(String path)
1:3991fba:     {
1:be31393:         int fd = -1;
1:3991fba: 
1:3991fba:         try
1:3991fba:         {
1:be31393:             return open(path, O_RDONLY);
1:3991fba:         }
1:85d6ce6:         catch (UnsatisfiedLinkError e)
1:85d6ce6:         {
1:be31393:             // JNA is unavailable just skipping Direct I/O
1:85d6ce6:         }
1:85d6ce6:         catch (RuntimeException e)
1:85d6ce6:         {
1:85d6ce6:             if (!(e instanceof LastErrorException))
1:85d6ce6:                 throw e;
1:3991fba: 
1:2dc2bb8:             logger.warn("open({}, O_RDONLY) failed, errno ({}).", path, errno(e));
1:85d6ce6:         }
1:3991fba: 
1:be31393:         return fd;
1:85d6ce6:     }
1:3991fba: 
1:be31393:     public static void trySync(int fd)
1:85d6ce6:     {
1:ffdf6c7:         if (fsyncUnavailable || fd == -1)
1:be31393:             return;
1:85d6ce6: 
1:85d6ce6:         try
1:85d6ce6:         {
1:be31393:             fsync(fd);
1:85d6ce6:         }
1:27ed655:         catch (UnsatisfiedLinkError e)
1:85d6ce6:         {
1:be31393:             // JNA is unavailable just skipping Direct I/O
1:ffdf6c7:             fsyncUnavailable = true;
1:85d6ce6:         }
1:85d6ce6:         catch (RuntimeException e)
1:85d6ce6:         {
1:85d6ce6:             if (!(e instanceof LastErrorException))
1:85d6ce6:                 throw e;
1:85d6ce6: 
1:351c7ca:             logger.warn(String.format("fsync(%d) failed, errno (%d) {}", fd, errno(e)), e);
1:85d6ce6:         }
1:85d6ce6:     }
1:85d6ce6: 
1:be31393:     public static void tryCloseFD(int fd)
1:85d6ce6:     {
2:be31393:         if (fd == -1)
1:be31393:             return;
1:85d6ce6: 
1:85d6ce6:         try
1:85d6ce6:         {
1:be31393:             close(fd);
1:85d6ce6:         }
3:be31393:         catch (UnsatisfiedLinkError e)
1:85d6ce6:         {
1:be31393:             // JNA is unavailable just skipping Direct I/O
1:85d6ce6:         }
3:be31393:         catch (RuntimeException e)
1:85d6ce6:         {
3:be31393:             if (!(e instanceof LastErrorException))
3:be31393:                 throw e;
1:4909415: 
1:2dc2bb8:             logger.warn("close({}) failed, errno ({}).", fd, errno(e));
1:85d6ce6:         }
1:85d6ce6:     }
1:0b68a77: 
1:2b4029a:     public static int getfd(FileChannel channel)
1:2b4029a:     {
1:2b4029a:         try
1:2b4029a:         {
1:ffdf6c7:             return getfd((FileDescriptor)FILE_CHANNEL_FD_FIELD.get(channel));
1:2b4029a:         }
1:2b4029a:         catch (IllegalArgumentException|IllegalAccessException e)
1:2b4029a:         {
1:2b4029a:             logger.warn("Unable to read fd field from FileChannel");
1:2b4029a:         }
1:2b4029a:         return -1;
1:2b4029a:     }
1:2b4029a: 
1:3991fba:     /**
1:3991fba:      * Get system file descriptor from FileDescriptor object.
1:3991fba:      * @param descriptor - FileDescriptor objec to get fd from
1:3991fba:      * @return file descriptor, -1 or error
1:3991fba:      */
1:3991fba:     public static int getfd(FileDescriptor descriptor)
1:4e95953:     {
1:4e95953:         try
1:4e95953:         {
1:ffdf6c7:             return FILE_DESCRIPTOR_FD_FIELD.getInt(descriptor);
1:4e95953:         }
1:3991fba:         catch (Exception e)
1:3991fba:         {
1:75409a1:             JVMStabilityInspector.inspectThrowable(e);
1:2b4029a:             logger.warn("Unable to read fd field from FileDescriptor");
1:4e95953:         }
1:3991fba: 
1:2b4029a:         return -1;
1:3991fba:     }
1:3991fba: }
============================================================================
author:Dave Brosius
-------------------------------------------------------------------------------
commit:2dc2bb8
/////////////////////////////////////////////////////////////////////////
1:             logger.warn("posix_fadvise({}, {}) failed, errno ({}).", fd, offset, errno(e));
/////////////////////////////////////////////////////////////////////////
1:             logger.warn("fcntl({}, {}, {}) failed, errno ({}).", fd, command, flags, errno(e));
/////////////////////////////////////////////////////////////////////////
1:             logger.warn("open({}, O_RDONLY) failed, errno ({}).", path, errno(e));
/////////////////////////////////////////////////////////////////////////
1:             logger.warn("close({}) failed, errno ({}).", fd, errno(e));
commit:087264f
/////////////////////////////////////////////////////////////////////////
commit:201004d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:1def02f
/////////////////////////////////////////////////////////////////////////
commit:68baaed
/////////////////////////////////////////////////////////////////////////
1:             logger.warn("JNA not found. Native methods will be disabled.");
1:             logger.warn("JNA link failure, one or more native method will be unavailable.");
commit:db9bc69
/////////////////////////////////////////////////////////////////////////
0:             logger.debug("JNA link failure details: {}", e.getMessage());
/////////////////////////////////////////////////////////////////////////
1:                 logger.warn("Unknown mlockall error {}", errno(e));
commit:11eb352
/////////////////////////////////////////////////////////////////////////
1:     
0:     static boolean jnaAvailable = false;
1:     static boolean jnaLockable = false;
0:             jnaAvailable = true;
/////////////////////////////////////////////////////////////////////////
1:     
1:     public static boolean jnaAvailable()
1:     {
1:         return jnaAvailable;
1:     }
1:     
1:     public static boolean jnaMemoryLockable()
1:     {
1:         return jnaLockable;
1:     }
1:             jnaLockable = true;
commit:880ce10
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     
0:     static boolean jnaAvailable = false;
0:     static boolean jnaLockable = false;
0:             jnaAvailable = true;
/////////////////////////////////////////////////////////////////////////
1:     
0:     public static boolean jnaAvailable()
1:     {
0:         return jnaAvailable;
1:     }
1:     
0:     public static boolean jnaMemoryLockable()
1:     {
0:         return jnaLockable;
1:     }
0:             jnaLockable = true;
author:Robert Stupp
-------------------------------------------------------------------------------
commit:ffdf6c7
/////////////////////////////////////////////////////////////////////////
1: import sun.nio.ch.FileChannelImpl;
/////////////////////////////////////////////////////////////////////////
1:     private static boolean fsyncUnavailable = false;
1: 
1:     private static final boolean OS_LINUX;
1:     private static final boolean OS_AIX;
1:     private static final boolean OS_MAC;
1: 
1:     private static final Field FILE_DESCRIPTOR_FD_FIELD;
1:     private static final Field FILE_CHANNEL_FD_FIELD;
1:         String os = System.getProperty("os.name").toLowerCase();
1:         OS_LINUX = os.contains("linux");
1:         OS_AIX = os.contains("aix");
1:         OS_MAC = os.contains("mac");
1: 
1:         FILE_DESCRIPTOR_FD_FIELD = FBUtilities.getProtectedField(FileDescriptor.class, "fd");
1:         FILE_CHANNEL_FD_FIELD = FBUtilities.getProtectedField(FileChannelImpl.class, "fd");
1: 
/////////////////////////////////////////////////////////////////////////
1:             if (OS_LINUX)
1:             else if (OS_AIX)
/////////////////////////////////////////////////////////////////////////
1:             if (OS_LINUX && errno(e) == ENOMEM)
1:             else if (!OS_MAC)
/////////////////////////////////////////////////////////////////////////
1:             if (OS_LINUX)
/////////////////////////////////////////////////////////////////////////
1:         if (fsyncUnavailable || fd == -1)
/////////////////////////////////////////////////////////////////////////
1:             fsyncUnavailable = true;
/////////////////////////////////////////////////////////////////////////
1:             return getfd((FileDescriptor)FILE_CHANNEL_FD_FIELD.get(channel));
/////////////////////////////////////////////////////////////////////////
1:             return FILE_DESCRIPTOR_FD_FIELD.getInt(descriptor);
author:Josh McKenzie
-------------------------------------------------------------------------------
commit:70115ff
commit:0d8e7b1
author:Rei Odaira
-------------------------------------------------------------------------------
commit:a56bc16
/////////////////////////////////////////////////////////////////////////
1:     private static final int MCL_CURRENT;
1:     private static final int MCL_FUTURE;
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (System.getProperty("os.arch").toLowerCase().contains("ppc"))
1:         {
0:             if (System.getProperty("os.name").toLowerCase().contains("linux"))
1:             {
1:                MCL_CURRENT = 0x2000;
1:                MCL_FUTURE = 0x4000;
1:             }
0:             else if (System.getProperty("os.name").toLowerCase().contains("aix"))
1:             {
1:                 MCL_CURRENT = 0x100;
1:                 MCL_FUTURE = 0x200;
1:             }
1:             else
1:             {
1:                 MCL_CURRENT = 1;
1:                 MCL_FUTURE = 2;
1:             }
1:         }
1:         else
1:         {
1:             MCL_CURRENT = 1;
1:             MCL_FUTURE = 2;
1:         }
author:Marcus Eriksson
-------------------------------------------------------------------------------
commit:49c9c01
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
1: import java.io.FileInputStream;
/////////////////////////////////////////////////////////////////////////
1:         File f = new File(path);
1:         if (!f.exists())
1:             return;
1: 
1:         try (FileInputStream fis = new FileInputStream(f))
1:         {
1:             trySkipCache(getfd(fis.getChannel()), offset, len, path);
1:         }
1:         catch (IOException e)
1:         {
1:             logger.warn("Could not skip cache", e);
1:         }
/////////////////////////////////////////////////////////////////////////
commit:8dfd75d
/////////////////////////////////////////////////////////////////////////
author:blerer
-------------------------------------------------------------------------------
commit:aa60cde
author:Paulo Motta
-------------------------------------------------------------------------------
commit:4a849ef
/////////////////////////////////////////////////////////////////////////
1:             logger.trace("JNA link failure details: {}", e.getMessage());
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:351c7ca
/////////////////////////////////////////////////////////////////////////
1:             logger.warn(String.format("fsync(%d) failed, errno (%d) {}", fd, errno(e)), e);
commit:75409a1
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
0: import java.nio.file.Paths;
0: import java.nio.file.StandardOpenOption;
/////////////////////////////////////////////////////////////////////////
0:         try(FileChannel channel = FileChannel.open(Paths.get(path), StandardOpenOption.READ))
0:             return getfd(channel);
0:         catch (IOException e)
1:             JVMStabilityInspector.inspectThrowable(e);
author:ariel
-------------------------------------------------------------------------------
commit:cb06283
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.TimeUnit;
1: import com.sun.jna.Pointer;
/////////////////////////////////////////////////////////////////////////
1:     private static native Pointer strerror(int errnum) throws LastErrorException;
/////////////////////////////////////////////////////////////////////////
0:         trySkipCache(getfd(path), offset, len, path);
1:     public static void trySkipCache(int fd, long offset, long len, String path)
1:             trySkipCache(fd, 0, 0, path);
1:             trySkipCache(fd, offset, sublen, path);
1:     public static void trySkipCache(int fd, long offset, int len, String path)
/////////////////////////////////////////////////////////////////////////
1:                 int result = posix_fadvise(fd, offset, len, POSIX_FADV_DONTNEED);
1:                 if (result != 0)
1:                     NoSpamLogger.log(
1:                             logger,
1:                             NoSpamLogger.Level.WARN,
1:                             10,
1:                             TimeUnit.MINUTES,
1:                             "Failed trySkipCache on file: {} Error: " + strerror(result).getString(0),
1:                             path);
author:Joshua McKenzie
-------------------------------------------------------------------------------
commit:2b4029a
/////////////////////////////////////////////////////////////////////////
1: import java.nio.channels.FileChannel;
/////////////////////////////////////////////////////////////////////////
1:     public static int getfd(FileChannel channel)
1:     {
0:         Field field = FBUtilities.getProtectedField(channel.getClass(), "fd");
1: 
0:         if (field == null)
1:             return -1;
1: 
1:         try
1:         {
0:             return getfd((FileDescriptor)field.get(channel));
1:         }
1:         catch (IllegalArgumentException|IllegalAccessException e)
1:         {
1:             logger.warn("Unable to read fd field from FileChannel");
1:         }
1:         return -1;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             logger.warn("Unable to read fd field from FileDescriptor");
commit:0705e8a
commit:f25da97
/////////////////////////////////////////////////////////////////////////
0:             JVMStabilityInspector.inspectThrowable(e);
commit:50734f2
commit:1452134
/////////////////////////////////////////////////////////////////////////
0:             JVMStabilityInspector.inspectThrowable(t);
author:belliottsmith
-------------------------------------------------------------------------------
commit:4e95953
/////////////////////////////////////////////////////////////////////////
0: import java.io.FileNotFoundException;
0: import java.io.IOException;
0: import java.io.RandomAccessFile;
/////////////////////////////////////////////////////////////////////////
1:     public static void trySkipCache(String path, long offset, long len)
1:     {
0:         trySkipCache(getfd(path), offset, len);
1:     }
1: 
0:     public static void trySkipCache(int fd, long offset, long len)
1:     {
1:         if (len == 0)
0:             trySkipCache(fd, 0, 0);
1: 
1:         while (len > 0)
1:         {
1:             int sublen = (int) Math.min(Integer.MAX_VALUE, len);
0:             trySkipCache(fd, offset, sublen);
1:             len -= sublen;
1:             offset -= sublen;
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:     public static int getfd(String path)
0:         RandomAccessFile file = null;
0:             file = new RandomAccessFile(path, "r");
0:             return getfd(file.getFD());
0:         catch (Throwable t)
0:             // ignore
0:             return -1;
0:         finally
1:             try
1:             {
0:                 if (file != null)
0:                     file.close();
1:             }
0:             catch (Throwable t)
1:             {
0:                 // ignore
1:             }
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:e9f8fc7
/////////////////////////////////////////////////////////////////////////
1: 
1:     static boolean jnaAvailable = true;
/////////////////////////////////////////////////////////////////////////
0:             logger.warn("JNA not found. Native methods will be disabled.");
1:             jnaAvailable = false;
0:             logger.warn("JNA link failure, one or more native method will be unavailable.");
1:             jnaAvailable = false;
1:     private static native int fcntl(int fd, int command, long flags) throws LastErrorException;
1:     private static native int posix_fadvise(int fd, long offset, int len, int flag) throws LastErrorException;
1:     private static native int open(String path, int flags) throws LastErrorException;
1:     private static native int fsync(int fd) throws LastErrorException;
1:     private static native int close(int fd) throws LastErrorException;
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:                         + " This can result in part of the JVM being swapped out, especially with mmapped I/O enabled."
1:                         + " Increase RLIMIT_MEMLOCK or run Cassandra as root.");
/////////////////////////////////////////////////////////////////////////
1:         catch (RuntimeException e)
1:         {
1:             if (!(e instanceof LastErrorException))
1:                 throw e;
1: 
0:             logger.warn(String.format("posix_fadvise(%d, %d) failed, errno (%d).", fd, offset, errno(e)));
1:         }
/////////////////////////////////////////////////////////////////////////
1:             result = fcntl(fd, command, flags);
1:         }
1:         catch (UnsatisfiedLinkError e)
1:         {
1:             // if JNA is unavailable just skipping
0:             logger.warn(String.format("fcntl(%d, %d, %d) failed, errno (%d).", fd, command, flags, errno(e)));
/////////////////////////////////////////////////////////////////////////
0:             logger.warn(String.format("open(%s, O_RDONLY) failed, errno (%d).", path, errno(e)));
/////////////////////////////////////////////////////////////////////////
0:             logger.warn(String.format("fsync(%d) failed, errno (%d).", fd, errno(e)));
/////////////////////////////////////////////////////////////////////////
0:             logger.warn(String.format("close(%d) failed, errno (%d).", fd, errno(e)));
/////////////////////////////////////////////////////////////////////////
0:             // JNA is unavailable just skipping
1:         catch (RuntimeException e)
1:         {
1:             if (!(e instanceof LastErrorException))
1:                 throw e;
1: 
0:             logger.warn(String.format("posix_fadvise(%d, %d) failed, errno (%d).", fd, position, errno(e)));
1:         }
1: 
0:         return -1;
commit:0254741
/////////////////////////////////////////////////////////////////////////
0:             logger.info("JNA not found. Native methods will be disabled.");
0:             logger.info("JNA link failure, one or more native method will be unavailable.");
commit:01bc564
/////////////////////////////////////////////////////////////////////////
commit:0388a33
/////////////////////////////////////////////////////////////////////////
0:             String st = osname.startsWith("Windows")
0:                       ? "Unable to create hard link.  This probably means your data directory path is too long.  Exception follows:"
0:                       : "Unable to create hard link with exec.  Suggest installing JNA to avoid the need to exec entirely.  Exception follows: ";
0:             logger.error(st, ex);
commit:e395307
/////////////////////////////////////////////////////////////////////////
0:             String st = osname.startsWith("Windows")
0:                       ? "Unable to create hard link.  This probably means your data directory path is too long.  Exception follows:"
0:                       : "Unable to create hard link with exec.  Suggest installing JNA to avoid the need to exec entirely.  Exception follows: ";
0:             logger.error(st, ex);
commit:347b577
commit:4778386
/////////////////////////////////////////////////////////////////////////
0:             logger.info("JNA link failure, one or more native method will be unavailable.");
0:             logger.debug("JNA link failure details: " + e.getMessage());
commit:64305dd
commit:5923d32
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             FBUtilities.exec(pb);
/////////////////////////////////////////////////////////////////////////
commit:6c5b1b6
commit:41314a2
commit:4a65311
/////////////////////////////////////////////////////////////////////////
1:             mlockall(MCL_CURRENT);
/////////////////////////////////////////////////////////////////////////
0:             link(sourceFile.getAbsolutePath(), destinationFile.getAbsolutePath());
/////////////////////////////////////////////////////////////////////////
1:         // fcntl return value may or may not be useful, depending on the command
commit:d389047
/////////////////////////////////////////////////////////////////////////
0:     public static native int posix_fadvise(int fd, long offset, int len, int flag) throws LastErrorException;
/////////////////////////////////////////////////////////////////////////
0:     public static void trySkipCache(int fd, long offset, int len)
/////////////////////////////////////////////////////////////////////////
commit:fc4502a
/////////////////////////////////////////////////////////////////////////
0: import java.io.File;
1: import java.io.FileDescriptor;
0: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private static native int mlockall(int flags) throws LastErrorException;
1:     private static native int munlockall() throws LastErrorException;
0:     private static native int link(String from, String to) throws LastErrorException;
0:     // fcntl - manipulate file descriptor, `man 2 fcntl`
0:     public static native int fcntl(int fd, int command, long flags) throws LastErrorException;
0:     // fadvice
0:     public static native int posix_fadvise(int fd, int offset, int len, int flag) throws LastErrorException;
1:         
/////////////////////////////////////////////////////////////////////////
0:     public static void trySkipCache(int fd, int offset, int len)
1:         if (fd < 0)
/////////////////////////////////////////////////////////////////////////
commit:c280e20
/////////////////////////////////////////////////////////////////////////
0:     public static void createHardLinkWithExec(File sourceFile, File destinationFile) throws IOException
commit:3991fba
/////////////////////////////////////////////////////////////////////////
0: import java.io.FileDescriptor;
1: import java.lang.reflect.Field;
/////////////////////////////////////////////////////////////////////////
1:     private static final int F_GETFL   = 3;  /* get file status flags */
1:     private static final int F_SETFL   = 4;  /* set file status flags */
1:     private static final int F_NOCACHE = 48; /* Mac OS X specific flag, turns cache on/off */
1:     private static final int O_DIRECT  = 040000; /* fcntl.h */
1: 
1:     private static final int POSIX_FADV_NORMAL     = 0; /* fadvise.h */
1:     private static final int POSIX_FADV_RANDOM     = 1; /* fadvise.h */
1:     private static final int POSIX_FADV_SEQUENTIAL = 2; /* fadvise.h */
1:     private static final int POSIX_FADV_WILLNEED   = 3; /* fadvise.h */
1:     private static final int POSIX_FADV_DONTNEED   = 4; /* fadvise.h */
1:     private static final int POSIX_FADV_NOREUSE    = 5; /* fadvise.h */
1: 
/////////////////////////////////////////////////////////////////////////
0:     // fcntl - manipulate file descriptor, `man 2 fcntl`
0:     public static native int fcntl(int fd, int command, long flags) throws LastErrorException;
1: 
0:     // fadvice
0:     public static native int posix_fadvise(int fd, int offset, int len, int flag) throws LastErrorException;
1:         
/////////////////////////////////////////////////////////////////////////
1: 
0:     public static void trySkipCache(int fd, int offset, int len)
1:     {
0:         if (fd < 0)
1:             return;
1: 
1:         try
1:         {
0:             if (System.getProperty("os.name").toLowerCase().contains("linux"))
1:             {
0:                 posix_fadvise(fd, offset, len, POSIX_FADV_DONTNEED);
1:             }
0:             else if (System.getProperty("os.name").toLowerCase().contains("mac"))
1:             {
0:                 tryFcntl(fd, F_NOCACHE, 1);
1:             }
1:         }
1:         catch (UnsatisfiedLinkError e)
1:         {
1:             // if JNA is unavailable just skipping Direct I/O
1:             // instance of this class will act like normal RandomAccessFile
1:         }
1:     }
1: 
1:     public static int tryFcntl(int fd, int command, int flags)
1:     {
1:         int result = -1;
1: 
1:         try
1:         {
0:             result = CLibrary.fcntl(fd, command, flags);
0:             assert result >= 0; // on error a value of -1 is returned and errno is set to indicate the error.
1:         }
1:         catch (RuntimeException e)
1:         {
1:             if (!(e instanceof LastErrorException))
1:                 throw e;
1: 
0:             logger.warn(String.format("fcntl(%d, %d, %d) failed, errno (%d).",
0:                                       fd, command, flags, CLibrary.errno(e)));
1:         }
1: 
1:         return result;
1:     }
1: 
1:     /**
1:      * Get system file descriptor from FileDescriptor object.
1:      * @param descriptor - FileDescriptor objec to get fd from
1:      * @return file descriptor, -1 or error
1:      */
1:     public static int getfd(FileDescriptor descriptor)
1:     {
0:         Field field = FBUtilities.getProtectedField(descriptor.getClass(), "fd");
1: 
0:         if (field == null)
0:             return -1;
1: 
1:         try
1:         {
0:             return field.getInt(descriptor);
1:         }
1:         catch (Exception e)
1:         {
0:             logger.warn("unable to read fd field from FileDescriptor");
1:         }
1: 
0:         return -1;
1:     }
commit:c2bb26f
/////////////////////////////////////////////////////////////////////////
1:         catch (NoSuchMethodError e)
1:         {
1:             logger.warn("Obsolete version of JNA present; unable to register C library. Upgrade to JNA 3.2.7 or later");
1:         }
commit:29f7f06
/////////////////////////////////////////////////////////////////////////
1:             logger.info("JNA mlockall successful");
commit:85d6ce6
/////////////////////////////////////////////////////////////////////////
0: import java.io.File;
0: import java.io.IOException;
1: 
/////////////////////////////////////////////////////////////////////////
0:     private static final int MCL_CURRENT = 1;
0:     private static final int MCL_FUTURE = 2;
1:     private static final int ENOMEM = 12;
/////////////////////////////////////////////////////////////////////////
0:     private static native int mlockall(int flags) throws LastErrorException;
0:     private static native int munlockall() throws LastErrorException;
0:     private static native int link(String from, String to) throws LastErrorException;
1:     private static int errno(RuntimeException e)
/////////////////////////////////////////////////////////////////////////
1: 
1:     public static void tryMlockall()
1:     {
1:         try
1:         {
0:             int result = mlockall(MCL_CURRENT);
0:             assert result == 0; // mlockall should always be zero on success
1:         }
1:         catch (UnsatisfiedLinkError e)
1:         {
1:             // this will have already been logged by CLibrary, no need to repeat it
1:         }
1:         catch (RuntimeException e)
1:         {
1:             if (!(e instanceof LastErrorException))
1:                 throw e;
0:             if (errno(e) == ENOMEM && System.getProperty("os.name").toLowerCase().contains("linux"))
1:             {
1:                 logger.warn("Unable to lock JVM memory (ENOMEM)."
0:                              + " This can result in part of the JVM being swapped out, especially with mmapped I/O enabled."
0:                              + " Increase RLIMIT_MEMLOCK or run Cassandra as root.");
1:             }
0:             else if (!System.getProperty("os.name").toLowerCase().contains("mac"))
1:             {
1:                 // OS X allows mlockall to be called, but always returns an error
0:                 logger.warn("Unknown mlockall error " + errno(e));
1:             }
1:         }
1:     }
1: 
0:     /**
0:      * Create a hard link for a given file.
1:      *
0:      * @param sourceFile      The name of the source file.
0:      * @param destinationFile The name of the destination file.
1:      *
0:      * @throws java.io.IOException if an error has occurred while creating the link.
1:      */
0:     public static void createHardLink(File sourceFile, File destinationFile) throws IOException
1:     {
1:         try
1:         {
0:             int result = link(sourceFile.getAbsolutePath(), destinationFile.getAbsolutePath());
0:             assert result == 0; // success is always zero
1:         }
1:         catch (UnsatisfiedLinkError e)
1:         {
0:             createHardLinkWithExec(sourceFile, destinationFile);
1:         }
1:         catch (RuntimeException e)
1:         {
1:             if (!(e instanceof LastErrorException))
1:                 throw e;
0:             // there are 17 different error codes listed on the man page.  punt until/unless we find which
0:             // ones actually turn up in practice.
0:             throw new IOException(String.format("Unable to create hard link from %s to %s (errno %d)",
0:                                                 sourceFile, destinationFile, errno(e)));
1:         }
1:     }
1: 
0:     private static void createHardLinkWithExec(File sourceFile, File destinationFile) throws IOException
1:     {
0:         String osname = System.getProperty("os.name");
0:         ProcessBuilder pb;
0:         if (osname.startsWith("Windows"))
1:         {
0:             float osversion = Float.parseFloat(System.getProperty("os.version"));
0:             if (osversion >= 6.0f)
1:             {
0:                 pb = new ProcessBuilder("cmd", "/c", "mklink", "/H", destinationFile.getAbsolutePath(), sourceFile.getAbsolutePath());
1:             }
0:             else
1:             {
0:                 pb = new ProcessBuilder("fsutil", "hardlink", "create", destinationFile.getAbsolutePath(), sourceFile.getAbsolutePath());
1:             }
1:         }
0:         else
1:         {
0:             pb = new ProcessBuilder("ln", sourceFile.getAbsolutePath(), destinationFile.getAbsolutePath());
0:             pb.redirectErrorStream(true);
1:         }
0:         Process p = pb.start();
1:         try
1:         {
0:             p.waitFor();
1:         }
0:         catch (InterruptedException e)
1:         {
0:             throw new RuntimeException(e);
1:         }
1:     }
commit:b5d9ac6
/////////////////////////////////////////////////////////////////////////
0:     public static int errno(RuntimeException e)
1:         assert e instanceof LastErrorException;
1:             return ((LastErrorException) e).getErrorCode();
commit:4909415
/////////////////////////////////////////////////////////////////////////
1: import com.sun.jna.LastErrorException;
/////////////////////////////////////////////////////////////////////////
0:     public static native int mlockall(int flags) throws LastErrorException;
0:     public static native int munlockall() throws LastErrorException;
0:     public static native int link(String from, String to) throws LastErrorException;
1: 
0:     public static int errno(LastErrorException e)
1:     {
1:         try
1:         {
0:             return e.getErrorCode();
1:         }
1:         catch (NoSuchMethodError x)
1:         {
1:             logger.warn("Obsolete version of JNA present; unable to read errno. Upgrade to JNA 3.2.7 or later");
1:             return 0;
1:         }
1:     }
commit:0b68a77
/////////////////////////////////////////////////////////////////////////
0:     public static native int link(String from, String to);
1: 
commit:9c278ff
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
0:  * 
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  * 
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
1: package org.apache.cassandra.utils;
0: 
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
0: 
1: import com.sun.jna.Native;
0: 
1: public final class CLibrary
0: {
0:     private static Logger logger = LoggerFactory.getLogger(CLibrary.class);
0: 
0:     public static final int MCL_CURRENT = 1;
0:     public static final int MCL_FUTURE = 2;
0:     
0:     public static final int ENOMEM = 12;
0: 
1:     static
0:     {
1:         try
0:         {
1:             Native.register("c");
0:         }
1:         catch (NoClassDefFoundError e)
0:         {
0:             logger.info("JNA not found. Native methods will be disabled.");
0:         }
1:         catch (UnsatisfiedLinkError e)
0:         {
0:             logger.info("Unable to link C library. Native methods will be disabled.");
0:         }
0:     }
0: 
0:     public static native int mlockall(int flags);
0: 
0:     public static native int munlockall();
0: 
1:     private CLibrary() {}
0: }
author:Jason Brown
-------------------------------------------------------------------------------
commit:01e79f5
/////////////////////////////////////////////////////////////////////////
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:27ed655
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
0:      * Suggest kernel to preheat one page for the given file.
0:      *
0:      * @param fd The file descriptor of file to preheat.
0:      * @param position The offset of the block.
0:      *
0:      * @return On success, zero is returned. On error, an error number is returned.
0:      */
0:     public static int preheatPage(int fd, long position)
0:     {
0:         try
0:         {
0:             // 4096 is good for SSD because they operate on "Pages" 4KB in size
0:             return posix_fadvise(fd, position, 4096, POSIX_FADV_WILLNEED);
0:         }
1:         catch (UnsatisfiedLinkError e)
0:         {
0:             return -1;
0:         }
0:     }
commit:04abad6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         
/////////////////////////////////////////////////////////////////////////
commit:be31393
/////////////////////////////////////////////////////////////////////////
1:     private static final int O_RDONLY  = 00000000; /* fcntl.h */
/////////////////////////////////////////////////////////////////////////
0: 
0:     public static native int open(String path, int flags) throws LastErrorException;
0:     public static native int fsync(int fd) throws LastErrorException;
0:     public static native int close(int fd) throws LastErrorException;
0: 
/////////////////////////////////////////////////////////////////////////
1:     public static int tryOpenDirectory(String path)
0:     {
1:         int fd = -1;
0: 
0:         try
0:         {
1:             return open(path, O_RDONLY);
0:         }
1:         catch (UnsatisfiedLinkError e)
0:         {
1:             // JNA is unavailable just skipping Direct I/O
0:         }
1:         catch (RuntimeException e)
0:         {
1:             if (!(e instanceof LastErrorException))
1:                 throw e;
0: 
0:             logger.warn(String.format("open(%s, O_RDONLY) failed, errno (%d).", path, CLibrary.errno(e)));
0:         }
0: 
1:         return fd;
0:     }
0: 
1:     public static void trySync(int fd)
0:     {
1:         if (fd == -1)
1:             return;
0: 
0:         try
0:         {
1:             fsync(fd);
0:         }
1:         catch (UnsatisfiedLinkError e)
0:         {
1:             // JNA is unavailable just skipping Direct I/O
0:         }
1:         catch (RuntimeException e)
0:         {
1:             if (!(e instanceof LastErrorException))
1:                 throw e;
0: 
0:             logger.warn(String.format("fsync(%d) failed, errno (%d).", fd, CLibrary.errno(e)));
0:         }
0:     }
0: 
1:     public static void tryCloseFD(int fd)
0:     {
1:         if (fd == -1)
1:             return;
0: 
0:         try
0:         {
1:             close(fd);
0:         }
1:         catch (UnsatisfiedLinkError e)
0:         {
1:             // JNA is unavailable just skipping Direct I/O
0:         }
1:         catch (RuntimeException e)
0:         {
1:             if (!(e instanceof LastErrorException))
1:                 throw e;
0: 
0:             logger.warn(String.format("close(%d) failed, errno (%d).", fd, CLibrary.errno(e)));
0:         }
0:     }
0: 
commit:1596ae9
/////////////////////////////////////////////////////////////////////////
0: import java.io.BufferedReader;
0: import java.io.InputStreamReader;
0: import org.apache.commons.lang.StringUtils;
0: 
/////////////////////////////////////////////////////////////////////////
0:             logger.error("Unable to create hard link", e);
/////////////////////////////////////////////////////////////////////////
0:         try
0:         {
0:             exec(pb);
0:         }
0:         catch (IOException ex)
0:         {
0:             logger.error("Unable to create hard link", ex);
0:             throw ex;
0:         }
0:     }
0: 
0:     private static void exec(ProcessBuilder pb) throws IOException
0:     {
0:             int errCode = p.waitFor();
0:             if (errCode != 0)
0:             {
0:                 BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()));
0:                 BufferedReader err = new BufferedReader(new InputStreamReader(p.getErrorStream()));
0:                 StringBuffer buff = new StringBuffer();
0:                 String str;
0:                 while ((str = in.readLine()) != null)
0:                     buff.append(str).append(System.getProperty("line.separator"));
0:                 while ((str = err.readLine()) != null)
0:                     buff.append(str).append(System.getProperty("line.separator"));
0:                 throw new IOException("Exception while executing the command: "+ StringUtils.join(pb.command(), " ") +
0:                                       ", command error Code: " + errCode +
0:                                       ", command output: "+ buff.toString());
0:             }
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:07cdfd0
/////////////////////////////////////////////////////////////////////////
0:  *
0:  *
/////////////////////////////////////////////////////////////////////////
0: 
commit:2fd3268
/////////////////////////////////////////////////////////////////////////
0: 
commit:5a6e2b0
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger logger = LoggerFactory.getLogger(CLibrary.class);
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
0:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:7ed395d
/////////////////////////////////////////////////////////////////////////
0: import java.io.*;
0: import java.nio.ByteBuffer;
0: import java.nio.channels.FileChannel.MapMode;
0: import java.util.ArrayList;
0: import java.util.List;
0: import java.util.concurrent.atomic.AtomicInteger;
0: import java.util.concurrent.atomic.AtomicLong;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.DatabaseDescriptor;
0: import org.apache.cassandra.io.util.BufferedRandomAccessFile;
0: import org.apache.cassandra.io.util.FileUtils;
0: 
/////////////////////////////////////////////////////////////////////////
0:     private static native int mlockall(int flags) throws LastErrorException;
0:     private static native int munlockall() throws LastErrorException;
0: 
0:     private static native int link(String from, String to) throws LastErrorException;
0: 
0:     // fcntl - manipulate file descriptor, `man 2 fcntl`
0:     public static native int fcntl(int fd, int command, long flags) throws LastErrorException;
0: 
0:     // fadvice
0:     public static native int posix_fadvise(int fd, long offset, long len, int flag) throws LastErrorException;
0: 
0:     public static native int mincore(ByteBuffer buf, int length, char[] vec) throws LastErrorException;
0: 
0:     private static native int getpagesize() throws LastErrorException;
0:     public  static Integer pageSize = null;
0: 
0:             pageSize = CLibrary.getPageSize();
/////////////////////////////////////////////////////////////////////////
0: 
0:     private static Integer getPageSize()
0:     {
0:         int ps = -1;
0:         if (!DatabaseDescriptor.isPageCaheMigrationEnabled())
0:             return null;
0:         try
0:         {
0:             ps = CLibrary.getpagesize();
0:             assert ps >= 0; // on error a value of -1 is returned and errno is set to indicate the error.
0:             logger.info("PageSize = " + ps);
0:         }
0:         catch (RuntimeException e)
0:         {
0:             if (!(e instanceof LastErrorException))
0:                 throw e;
0: 
0:             logger.warn(String.format("getpagesize failed, errno (%d).", CLibrary.errno(e)));
0:         }
0:         catch (UnsatisfiedLinkError e)
0:         {
0:             // this will have already been logged by CLibrary, no need to repeat it
0:         }
0: 
0:         return ps > 0 ? ps : null;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     public static void trySkipCache(int fd, long offset, long len)
0:         if (fd < 0 || !DatabaseDescriptor.isPageCaheMigrationEnabled())
/////////////////////////////////////////////////////////////////////////
0:     public static PageCacheMetrics getCachedPages(BufferedRandomAccessFile braf) throws IOException
0:     {
0:         if (pageSize == null || pageSize == 0 || !DatabaseDescriptor.isPageCaheMigrationEnabled())
0:             return null;
0: 
0:         long length = braf.length();
0: 
0:         PageCacheMetrics pageCacheMetrics = new PageCacheMetrics(pageSize, length);
0: 
0:         try
0:         {
0:             char[] pages = null;
0: 
0:             // MMap 2G chunks
0:             for (long offset = 0; offset < length; offset += Integer.MAX_VALUE)
0:             {
0:                 long limit = (offset + Integer.MAX_VALUE) > length ? (length - offset) : Integer.MAX_VALUE;
0: 
0:                 ByteBuffer buf = braf.getChannel().map(MapMode.READ_ONLY, offset, limit);
0: 
0:                 int numPages = (int) ((limit + pageSize - 1) / pageSize);
0: 
0:                 if (pages == null || pages.length < numPages)
0:                     pages = new char[numPages];
0: 
0:                 int rc = mincore(buf, (int) limit, pages);
0: 
0:                 if (rc != 0)
0:                 {
0:                     logger.warn(String.format("mincore failed, rc (%d).", rc));
0:                     break;
0:                 }
0: 
0:                 for (long i = 0, position = offset; position < limit; position += pageSize, i++)
0:                 {
0:                     if ((pages[(int) i] & 1) == 1)
0:                     {
0:                         pageCacheMetrics.setPage(position);
0:                     }
0:                 }
0:             }
0:         }
0:         catch (RuntimeException e)
0:         {
0:             if (!(e instanceof LastErrorException))
0:                 throw e;
0: 
0:             logger.warn(String.format("mincore failed, errno (%d).", CLibrary.errno(e)));
0:         }
0:         catch (UnsatisfiedLinkError e)
0:         {
0:             // this will have already been logged by CLibrary, no need to repeat it
0:         }
0: 
0:         return pageCacheMetrics;
0:     }
0: 
============================================================================