1:2f41243: /*
1:2f41243:  * Licensed to the Apache Software Foundation (ASF) under one
1:2f41243:  * or more contributor license agreements.  See the NOTICE file
1:2f41243:  * distributed with this work for additional information
1:2f41243:  * regarding copyright ownership.  The ASF licenses this file
1:2f41243:  * to you under the Apache License, Version 2.0 (the
1:2f41243:  * "License"); you may not use this file except in compliance
1:2f41243:  * with the License.  You may obtain a copy of the License at
1:2f41243:  *
1:2f41243:  *     http://www.apache.org/licenses/LICENSE-2.0
1:2f41243:  *
1:2f41243:  * Unless required by applicable law or agreed to in writing, software
1:2f41243:  * distributed under the License is distributed on an "AS IS" BASIS,
1:2f41243:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:2f41243:  * See the License for the specific language governing permissions and
1:2f41243:  * limitations under the License.
1:2f41243:  */
1:2f41243: package org.apache.cassandra.db;
1:2f41243: 
1:2f41243: import java.io.IOException;
1:2f41243: import java.nio.ByteBuffer;
1:2f41243: import java.util.Random;
1:2f41243: import java.util.UUID;
1:2f41243: 
1:2f41243: import org.junit.Assert;
1:2f41243: import org.junit.BeforeClass;
1:2f41243: import org.junit.Test;
1:2f41243: 
1:2f41243: import org.slf4j.Logger;
1:2f41243: import org.slf4j.LoggerFactory;
1:2f41243: 
1:2f41243: import org.apache.cassandra.config.ColumnDefinition;
1:2f41243: import org.apache.cassandra.cql3.ColumnIdentifier;
1:2f41243: import org.apache.cassandra.db.marshal.BytesType;
1:2f41243: import org.apache.cassandra.db.marshal.SetType;
1:2f41243: import org.apache.cassandra.db.marshal.UTF8Type;
1:2f41243: import org.apache.cassandra.db.rows.*;
1:2f41243: import org.apache.cassandra.utils.concurrent.OpOrder;
1:2f41243: import org.apache.cassandra.utils.memory.HeapAllocator;
1:2f41243: import org.apache.cassandra.utils.memory.NativeAllocator;
1:2f41243: import org.apache.cassandra.utils.memory.NativePool;
1:2f41243: 
1:2f41243: public class NativeCellTest
1:2f41243: {
1:2f41243: 
1:2f41243:     private static final Logger logger = LoggerFactory.getLogger(NativeCellTest.class);
1:2f41243:     private static final NativeAllocator nativeAllocator = new NativePool(Integer.MAX_VALUE, Integer.MAX_VALUE, 1f, null).newAllocator();
1:2f41243:     private static final OpOrder.Group group = new OpOrder().start();
1:2f41243:     private static Random rand;
1:2f41243: 
1:2f41243:     @BeforeClass
1:2f41243:     public static void setUp()
1:2f41243:     {
1:2f41243:         long seed = System.currentTimeMillis();
1:2f41243:         logger.info("Seed : {}", seed);
1:2f41243:         rand = new Random(seed);
1:2f41243:     }
1:2f41243: 
1:2f41243:     @Test
1:2f41243:     public void testCells() throws IOException
1:2f41243:     {
1:2f41243:         for (int run = 0 ; run < 1000 ; run++)
1:2f41243:         {
1:2f41243:             Row.Builder builder = BTreeRow.unsortedBuilder(1);
1:2f41243:             builder.newRow(rndclustering());
1:2f41243:             int count = 1 + rand.nextInt(10);
1:2f41243:             for (int i = 0 ; i < count ; i++)
1:2f41243:                 rndcd(builder);
1:2f41243:             test(builder.build());
1:2f41243:         }
1:2f41243:     }
1:2f41243: 
1:2f41243:     private static Clustering rndclustering()
1:2f41243:     {
1:2f41243:         int count = 1 + rand.nextInt(100);
1:2f41243:         ByteBuffer[] values = new ByteBuffer[count];
1:2f41243:         int size = rand.nextInt(65535);
1:2f41243:         for (int i = 0 ; i < count ; i++)
1:2f41243:         {
1:2f41243:             int twiceShare = 1 + (2 * size) / (count - i);
1:2f41243:             int nextSize = Math.min(size, rand.nextInt(twiceShare));
1:2f41243:             if (nextSize < 10 && rand.nextBoolean())
1:2f41243:                 continue;
1:2f41243: 
1:2f41243:             byte[] bytes = new byte[nextSize];
1:2f41243:             rand.nextBytes(bytes);
1:2f41243:             values[i] = ByteBuffer.wrap(bytes);
1:2f41243:             size -= nextSize;
1:2f41243:         }
1:2f41243:         return Clustering.make(values);
1:2f41243:     }
1:2f41243: 
1:2f41243:     private static void rndcd(Row.Builder builder)
1:2f41243:     {
1:2f41243:         ColumnDefinition col = rndcol();
1:2f41243:         if (!col.isComplex())
1:2f41243:         {
1:2f41243:             builder.addCell(rndcell(col));
1:2f41243:         }
1:2f41243:         else
1:2f41243:         {
1:2f41243:             int count = 1 + rand.nextInt(100);
1:2f41243:             for (int i = 0 ; i < count ; i++)
1:2f41243:                 builder.addCell(rndcell(col));
1:2f41243:         }
1:2f41243:     }
1:2f41243: 
1:2f41243:     private static ColumnDefinition rndcol()
1:2f41243:     {
1:2f41243:         UUID uuid = new UUID(rand.nextLong(), rand.nextLong());
1:2f41243:         boolean isComplex = rand.nextBoolean();
1:2f41243:         return new ColumnDefinition("",
1:2f41243:                                     "",
1:2f41243:                                     ColumnIdentifier.getInterned(uuid.toString(), false),
1:2f41243:                                     isComplex ? new SetType<>(BytesType.instance, true) : BytesType.instance,
1:2f41243:                                     -1,
1:2f41243:                                     ColumnDefinition.Kind.REGULAR);
1:2f41243:     }
1:2f41243: 
1:2f41243:     private static Cell rndcell(ColumnDefinition col)
1:2f41243:     {
1:2f41243:         long timestamp = rand.nextLong();
1:2f41243:         int ttl = rand.nextInt();
1:2f41243:         int localDeletionTime = rand.nextInt();
1:2f41243:         byte[] value = new byte[rand.nextInt(sanesize(expdecay()))];
1:2f41243:         rand.nextBytes(value);
1:2f41243:         CellPath path = null;
1:2f41243:         if (col.isComplex())
1:2f41243:         {
1:2f41243:             byte[] pathbytes = new byte[rand.nextInt(sanesize(expdecay()))];
1:2f41243:             rand.nextBytes(value);
1:2f41243:             path = CellPath.create(ByteBuffer.wrap(pathbytes));
1:2f41243:         }
1:2f41243: 
1:2f41243:         return new BufferCell(col, timestamp, ttl, localDeletionTime, ByteBuffer.wrap(value), path);
1:2f41243:     }
1:2f41243: 
1:2f41243:     private static int expdecay()
1:2f41243:     {
1:2f41243:         return 1 << Integer.numberOfTrailingZeros(Integer.lowestOneBit(rand.nextInt()));
1:2f41243:     }
1:2f41243: 
1:2f41243:     private static int sanesize(int randomsize)
1:2f41243:     {
1:2f41243:         return Math.min(Math.max(1, randomsize), 1 << 26);
1:2f41243:     }
1:2f41243: 
1:2f41243:     private static void test(Row row)
1:2f41243:     {
1:2f41243:         Row nrow = clone(row, nativeAllocator.rowBuilder(group));
1:2f41243:         Row brow = clone(row, HeapAllocator.instance.cloningBTreeRowBuilder());
1:2f41243:         Assert.assertEquals(row, nrow);
1:2f41243:         Assert.assertEquals(row, brow);
1:2f41243:         Assert.assertEquals(nrow, brow);
1:2f41243: 
1:2f41243:         Assert.assertEquals(row.clustering(), nrow.clustering());
1:2f41243:         Assert.assertEquals(row.clustering(), brow.clustering());
1:2f41243:         Assert.assertEquals(nrow.clustering(), brow.clustering());
1:2f41243: 
1:2f41243:         ClusteringComparator comparator = new ClusteringComparator(UTF8Type.instance);
1:2f41243:         Assert.assertTrue(comparator.compare(row.clustering(), nrow.clustering()) == 0);
1:2f41243:         Assert.assertTrue(comparator.compare(row.clustering(), brow.clustering()) == 0);
1:2f41243:         Assert.assertTrue(comparator.compare(nrow.clustering(), brow.clustering()) == 0);
1:2f41243:     }
1:2f41243: 
1:2f41243:     private static Row clone(Row row, Row.Builder builder)
1:2f41243:     {
1:2f41243:         return Rows.copy(row, builder).build();
1:2f41243:     }
1:2f41243: 
1:2f41243: }
============================================================================
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:2f41243
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.db;
1: 
1: import java.io.IOException;
1: import java.nio.ByteBuffer;
1: import java.util.Random;
1: import java.util.UUID;
1: 
1: import org.junit.Assert;
1: import org.junit.BeforeClass;
1: import org.junit.Test;
1: 
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: import org.apache.cassandra.config.ColumnDefinition;
1: import org.apache.cassandra.cql3.ColumnIdentifier;
1: import org.apache.cassandra.db.marshal.BytesType;
1: import org.apache.cassandra.db.marshal.SetType;
1: import org.apache.cassandra.db.marshal.UTF8Type;
1: import org.apache.cassandra.db.rows.*;
1: import org.apache.cassandra.utils.concurrent.OpOrder;
1: import org.apache.cassandra.utils.memory.HeapAllocator;
1: import org.apache.cassandra.utils.memory.NativeAllocator;
1: import org.apache.cassandra.utils.memory.NativePool;
1: 
1: public class NativeCellTest
1: {
1: 
1:     private static final Logger logger = LoggerFactory.getLogger(NativeCellTest.class);
1:     private static final NativeAllocator nativeAllocator = new NativePool(Integer.MAX_VALUE, Integer.MAX_VALUE, 1f, null).newAllocator();
1:     private static final OpOrder.Group group = new OpOrder().start();
1:     private static Random rand;
1: 
1:     @BeforeClass
1:     public static void setUp()
1:     {
1:         long seed = System.currentTimeMillis();
1:         logger.info("Seed : {}", seed);
1:         rand = new Random(seed);
1:     }
1: 
1:     @Test
1:     public void testCells() throws IOException
1:     {
1:         for (int run = 0 ; run < 1000 ; run++)
1:         {
1:             Row.Builder builder = BTreeRow.unsortedBuilder(1);
1:             builder.newRow(rndclustering());
1:             int count = 1 + rand.nextInt(10);
1:             for (int i = 0 ; i < count ; i++)
1:                 rndcd(builder);
1:             test(builder.build());
1:         }
1:     }
1: 
1:     private static Clustering rndclustering()
1:     {
1:         int count = 1 + rand.nextInt(100);
1:         ByteBuffer[] values = new ByteBuffer[count];
1:         int size = rand.nextInt(65535);
1:         for (int i = 0 ; i < count ; i++)
1:         {
1:             int twiceShare = 1 + (2 * size) / (count - i);
1:             int nextSize = Math.min(size, rand.nextInt(twiceShare));
1:             if (nextSize < 10 && rand.nextBoolean())
1:                 continue;
1: 
1:             byte[] bytes = new byte[nextSize];
1:             rand.nextBytes(bytes);
1:             values[i] = ByteBuffer.wrap(bytes);
1:             size -= nextSize;
1:         }
1:         return Clustering.make(values);
1:     }
1: 
1:     private static void rndcd(Row.Builder builder)
1:     {
1:         ColumnDefinition col = rndcol();
1:         if (!col.isComplex())
1:         {
1:             builder.addCell(rndcell(col));
1:         }
1:         else
1:         {
1:             int count = 1 + rand.nextInt(100);
1:             for (int i = 0 ; i < count ; i++)
1:                 builder.addCell(rndcell(col));
1:         }
1:     }
1: 
1:     private static ColumnDefinition rndcol()
1:     {
1:         UUID uuid = new UUID(rand.nextLong(), rand.nextLong());
1:         boolean isComplex = rand.nextBoolean();
1:         return new ColumnDefinition("",
1:                                     "",
1:                                     ColumnIdentifier.getInterned(uuid.toString(), false),
1:                                     isComplex ? new SetType<>(BytesType.instance, true) : BytesType.instance,
1:                                     -1,
1:                                     ColumnDefinition.Kind.REGULAR);
1:     }
1: 
1:     private static Cell rndcell(ColumnDefinition col)
1:     {
1:         long timestamp = rand.nextLong();
1:         int ttl = rand.nextInt();
1:         int localDeletionTime = rand.nextInt();
1:         byte[] value = new byte[rand.nextInt(sanesize(expdecay()))];
1:         rand.nextBytes(value);
1:         CellPath path = null;
1:         if (col.isComplex())
1:         {
1:             byte[] pathbytes = new byte[rand.nextInt(sanesize(expdecay()))];
1:             rand.nextBytes(value);
1:             path = CellPath.create(ByteBuffer.wrap(pathbytes));
1:         }
1: 
1:         return new BufferCell(col, timestamp, ttl, localDeletionTime, ByteBuffer.wrap(value), path);
1:     }
1: 
1:     private static int expdecay()
1:     {
1:         return 1 << Integer.numberOfTrailingZeros(Integer.lowestOneBit(rand.nextInt()));
1:     }
1: 
1:     private static int sanesize(int randomsize)
1:     {
1:         return Math.min(Math.max(1, randomsize), 1 << 26);
1:     }
1: 
1:     private static void test(Row row)
1:     {
1:         Row nrow = clone(row, nativeAllocator.rowBuilder(group));
1:         Row brow = clone(row, HeapAllocator.instance.cloningBTreeRowBuilder());
1:         Assert.assertEquals(row, nrow);
1:         Assert.assertEquals(row, brow);
1:         Assert.assertEquals(nrow, brow);
1: 
1:         Assert.assertEquals(row.clustering(), nrow.clustering());
1:         Assert.assertEquals(row.clustering(), brow.clustering());
1:         Assert.assertEquals(nrow.clustering(), brow.clustering());
1: 
1:         ClusteringComparator comparator = new ClusteringComparator(UTF8Type.instance);
1:         Assert.assertTrue(comparator.compare(row.clustering(), nrow.clustering()) == 0);
1:         Assert.assertTrue(comparator.compare(row.clustering(), brow.clustering()) == 0);
1:         Assert.assertTrue(comparator.compare(nrow.clustering(), brow.clustering()) == 0);
1:     }
1: 
1:     private static Row clone(Row row, Row.Builder builder)
1:     {
1:         return Rows.copy(row, builder).build();
1:     }
1: 
1: }
commit:fd59549
/////////////////////////////////////////////////////////////////////////
0: ///*
0: //* Licensed to the Apache Software Foundation (ASF) under one
0: //* or more contributor license agreements.  See the NOTICE file
0: //* distributed with this work for additional information
0: //* regarding copyright ownership.  The ASF licenses this file
0: //* to you under the Apache License, Version 2.0 (the
0: //* "License"); you may not use this file except in compliance
0: //* with the License.  You may obtain a copy of the License at
0: //*
0: //*     http://www.apache.org/licenses/LICENSE-2.0
0: //*
0: //* Unless required by applicable law or agreed to in writing, software
0: //* distributed under the License is distributed on an "AS IS" BASIS,
0: //* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0: //* See the License for the specific language governing permissions and
0: //* limitations under the License.
0: //*/
0: //package org.apache.cassandra.db;
0: //
0: //import java.io.ByteArrayInputStream;
0: //import java.io.DataInputStream;
0: //import java.io.IOException;
0: //import java.nio.ByteBuffer;
0: //import java.security.MessageDigest;
0: //import java.security.NoSuchAlgorithmException;
0: //import java.util.Arrays;
0: //import java.util.Random;
0: //import java.util.concurrent.ThreadLocalRandom;
0: //
0: //import org.junit.Assert;
0: //import org.junit.Test;
0: //
0: //import org.apache.cassandra.config.CFMetaData;
0: //import org.apache.cassandra.config.ColumnDefinition;
0: //import org.apache.cassandra.cql3.ColumnIdentifier;
0: //import org.apache.cassandra.db.context.CounterContext;
0: //import org.apache.cassandra.db.marshal.AbstractType;
0: //import org.apache.cassandra.db.marshal.UTF8Type;
0: //import org.apache.cassandra.db.rows.Cell;
0: //import org.apache.cassandra.exceptions.ConfigurationException;
0: //import org.apache.cassandra.io.util.DataOutputBuffer;
0: //import org.apache.cassandra.utils.concurrent.OpOrder;
0: //import org.apache.cassandra.utils.memory.NativeAllocator;
0: //import org.apache.cassandra.utils.memory.NativePool;
0: //
0: //import static org.apache.cassandra.utils.ByteBufferUtil.bytes;
0: //
0: //public class NativeCellTest
0: //{
0: //
0: //    private static final NativeAllocator nativeAllocator = new NativePool(Integer.MAX_VALUE, Integer.MAX_VALUE, 1f, null).newAllocator();
0: //    private static final OpOrder.Group group = new OpOrder().start();
0: //
0: //    static class Name
0: //    {
0: //        final CellName name;
0: //        final CellNameType type;
0: //        Name(CellName name, CellNameType type)
0: //        {
0: //            this.name = name;
0: //            this.type = type;
0: //        }
0: //    }
0: //
0: //    static ByteBuffer[] bytess(String ... strings)
0: //    {
0: //        ByteBuffer[] r = new ByteBuffer[strings.length];
0: //        for (int i = 0 ; i < r.length ; i++)
0: //            r[i] = bytes(strings[i]);
0: //        return r;
0: //    }
0: //
0: //    final static Name[] TESTS = new Name[]
0: //                          {
0: //                              new Name(simpleDense(bytes("a")), new SimpleDenseCellNameType(UTF8Type.instance)),
0: //                              new Name(simpleSparse(new ColumnIdentifier("a", true)), new SimpleSparseCellNameType(UTF8Type.instance)),
0: //                              new Name(compositeDense(bytes("a"), bytes("b")), new CompoundDenseCellNameType(Arrays.<AbstractType<?>>asList(UTF8Type.instance, UTF8Type.instance))),
0: //                              new Name(compositeSparse(bytess("b", "c"), new ColumnIdentifier("a", true), false), new CompoundSparseCellNameType(Arrays.<AbstractType<?>>asList(UTF8Type.instance, UTF8Type.instance))),
0: //                              new Name(compositeSparse(bytess("b", "c"), new ColumnIdentifier("a", true), true), new CompoundSparseCellNameType(Arrays.<AbstractType<?>>asList(UTF8Type.instance, UTF8Type.instance))),
0: //                              new Name(simpleDense(huge('a', 40000)), new SimpleDenseCellNameType(UTF8Type.instance)),
0: //                              new Name(simpleSparse(new ColumnIdentifier(hugestr('a', 40000), true)), new SimpleSparseCellNameType(UTF8Type.instance)),
0: //                              new Name(compositeDense(huge('a', 20000), huge('b', 20000)), new CompoundDenseCellNameType(Arrays.<AbstractType<?>>asList(UTF8Type.instance, UTF8Type.instance))),
0: //                              new Name(compositeSparse(huges(40000, 'b', 'c'), new ColumnIdentifier(hugestr('a', 10000), true), false), new CompoundSparseCellNameType(Arrays.<AbstractType<?>>asList(UTF8Type.instance, UTF8Type.instance))),
0: //                              new Name(compositeSparse(huges(40000, 'b', 'c'), new ColumnIdentifier(hugestr('a', 10000), true), true), new CompoundSparseCellNameType(Arrays.<AbstractType<?>>asList(UTF8Type.instance, UTF8Type.instance)))
0: //                          };
0: //
0: //    private static ByteBuffer huge(char ch, int count)
0: //    {
0: //        return bytes(hugestr(ch, count));
0: //    }
0: //
0: //    private static ByteBuffer[] huges(int count, char ... chs)
0: //    {
0: //        ByteBuffer[] r = new ByteBuffer[chs.length];
0: //        for (int i = 0 ; i < chs.length ; i++)
0: //            r[i] = huge(chs[i], count / chs.length);
0: //        return r;
0: //    }
0: //
0: //    private static String hugestr(char ch, int count)
0: //    {
0: //        ThreadLocalRandom random = ThreadLocalRandom.current();
0: //        byte[] bytes = new byte[count];
0: //        random.nextBytes(bytes);
0: //        bytes[0] = (byte) ch;
0: //        for (int i = 0 ; i < bytes.length ; i++)
0: //            bytes[i] &= 0x7f;
0: //        return new String(bytes);
0: //    }
0: //
0: //    private static final CFMetaData metadata = new CFMetaData("", "", ColumnFamilyType.Standard, null);
0: //    static
0: //    {
0: //        try
0: //        {
0: //            metadata.addColumnDefinition(new ColumnDefinition(null, null, new ColumnIdentifier("a", true), UTF8Type.instance, null, null, null, null, null));
0: //        }
0: //        catch (ConfigurationException e)
0: //        {
0: //            throw new AssertionError();
0: //        }
0: //    }
0: //
0: //    @Test
0: //    public void testCells() throws IOException
0: //    {
0: //        Random rand = ThreadLocalRandom.current();
0: //        for (Name test : TESTS)
0: //        {
0: //            byte[] bytes = new byte[16];
0: //            rand.nextBytes(bytes);
0: //
0: //            // test regular Cell
0: //            Cell buf, nat;
0: //            buf = new BufferCell(test.name, ByteBuffer.wrap(bytes), rand.nextLong());
0: //            nat = buf.localCopy(metadata, nativeAllocator, group);
0: //            test(test, buf, nat);
0: //
0: //            // test DeletedCell
0: //            buf = new BufferDeletedCell(test.name, rand.nextInt(100000), rand.nextLong());
0: //            nat = buf.localCopy(metadata, nativeAllocator, group);
0: //            test(test, buf, nat);
0: //
0: //            // test ExpiringCell
0: //            buf = new BufferExpiringCell(test.name, ByteBuffer.wrap(bytes), rand.nextLong(),  rand.nextInt(100000));
0: //            nat = buf.localCopy(metadata, nativeAllocator, group);
0: //            test(test, buf, nat);
0: //
0: //            // test CounterCell
0: //            buf = new BufferCounterCell(test.name, CounterContext.instance().createLocal(rand.nextLong()), rand.nextLong(),  rand.nextInt(100000));
0: //            nat = buf.localCopy(metadata, nativeAllocator, group);
0: //            test(test, buf, nat);
0: //        }
0: //    }
0: //
0: //
0: //    @Test
0: //    public void testComparator()
0: //    {
0: //
0: //        Random rand = ThreadLocalRandom.current();
0: //        for (Name test : TESTS)
0: //        {
0: //            byte[] bytes = new byte[7];
0: //            byte[] bytes2 = new byte[7];
0: //            rand.nextBytes(bytes);
0: //            rand.nextBytes(bytes2);
0: //
0: //            // test regular Cell
0: //            Cell buf, nat, buf2, nat2;
0: //            buf = new BufferCell(test.name, ByteBuffer.wrap(bytes), rand.nextLong());
0: //            nat = buf.localCopy(metadata, nativeAllocator, group);
0: //
0: //            buf2 = new BufferCell(test.name, ByteBuffer.wrap(bytes2), rand.nextLong());
0: //            nat2 = buf2.localCopy(metadata, nativeAllocator, group);
0: //
0: //            assert test.type.compare(buf.name(), nat.name()) == 0;
0: //            assert test.type.compare(buf2.name(), nat2.name()) == 0;
0: //
0: //            int val = test.type.compare(buf.name(), buf2.name());
0: //            assert test.type.compare(nat.name(), nat2.name()) == val;
0: //            assert test.type.compare(nat.name(), buf2.name()) == val;
0: //            assert test.type.compare(buf.name(), nat2.name()) == val;
0: //
0: //
0: //            // test DeletedCell
0: //            buf = new BufferDeletedCell(test.name, rand.nextInt(100000), rand.nextLong());
0: //            nat = buf.localCopy(metadata, nativeAllocator, group);
0: //            buf2 = new BufferDeletedCell(test.name, rand.nextInt(100000), rand.nextLong());
0: //            nat2 = buf2.localCopy(metadata, nativeAllocator, group);
0: //
0: //            assert test.type.compare(buf.name(), nat.name()) == 0;
0: //            assert test.type.compare(buf2.name(), nat2.name()) == 0;
0: //
0: //            val = test.type.compare(buf.name(), buf2.name());
0: //            assert test.type.compare(nat.name(), nat2.name()) == val;
0: //            assert test.type.compare(nat.name(), buf2.name()) == val;
0: //            assert test.type.compare(buf.name(), nat2.name()) == val;
0: //
0: //
0: //
0: //            // test ExpiringCell
0: //            buf = new BufferExpiringCell(test.name, ByteBuffer.wrap(bytes), rand.nextLong(),  rand.nextInt(100000));
0: //            nat = buf.localCopy(metadata, nativeAllocator, group);
0: //
0: //            buf2 = new BufferExpiringCell(test.name, ByteBuffer.wrap(bytes2), rand.nextLong(),  rand.nextInt(100000));
0: //            nat2 = buf2.localCopy(metadata, nativeAllocator, group);
0: //
0: //            assert test.type.compare(buf.name(), nat.name()) == 0;
0: //            assert test.type.compare(buf2.name(), nat2.name()) == 0;
0: //
0: //            val = test.type.compare(buf.name(), buf2.name());
0: //            assert test.type.compare(nat.name(), nat2.name()) == val;
0: //            assert test.type.compare(nat.name(), buf2.name()) == val;
0: //            assert test.type.compare(buf.name(), nat2.name()) == val;
0: //
0: //
0: //            // test CounterCell
0: //            buf = new BufferCounterCell(test.name, CounterContext.instance().createLocal(rand.nextLong()), rand.nextLong(),  rand.nextInt(100000));
0: //            nat = buf.localCopy(metadata, nativeAllocator, group);
0: //
0: //            buf2 = new BufferCounterCell(test.name, CounterContext.instance().createLocal(rand.nextLong()), rand.nextLong(),  rand.nextInt(100000));
0: //            nat2 = buf2.localCopy(metadata, nativeAllocator, group);
0: //
0: //            assert test.type.compare(buf.name(), nat.name()) == 0;
0: //            assert test.type.compare(buf2.name(), nat2.name()) == 0;
0: //
0: //            val = test.type.compare(buf.name(), buf2.name());
0: //            assert test.type.compare(nat.name(), nat2.name()) == val;
0: //            assert test.type.compare(nat.name(), buf2.name()) == val;
0: //            assert test.type.compare(buf.name(), nat2.name()) == val;
0: //
0: //        }
0: //    }
0: //
0: //    static void test(Name test, Cell buf, Cell nat) throws IOException
0: //    {
0: //        Assert.assertTrue(buf.equals(nat));
0: //        Assert.assertTrue(nat.equals(buf));
0: //        Assert.assertTrue(buf.equals(buf));
0: //        Assert.assertTrue(nat.equals(nat));
0: //
0: //        try
0: //        {
0: //            MessageDigest d1 = MessageDigest.getInstance("MD5");
0: //            MessageDigest d2 = MessageDigest.getInstance("MD5");
0: //            buf.updateDigest(d1);
0: //            nat.updateDigest(d2);
0: //            Assert.assertArrayEquals(d1.digest(), d2.digest());
0: //        }
0: //        catch (NoSuchAlgorithmException e)
0: //        {
0: //            throw new IllegalStateException(e);
0: //        }
0: //
0: //        byte[] serialized;
0: //        try (DataOutputBuffer bufOut = new DataOutputBuffer())
0: //        {
0: //            test.type.columnSerializer().serialize(nat, bufOut);
0: //            serialized = bufOut.getData();
0: //        }
0: //
0: //        ByteArrayInputStream bufIn = new ByteArrayInputStream(serialized, 0, serialized.length);
0: //        Cell deserialized = test.type.columnSerializer().deserialize(new DataInputStream(bufIn));
0: //        Assert.assertTrue(buf.equals(deserialized));
0: //
0: //    }
0: //
0: //
0: //
0: //}
commit:986a1a7
/////////////////////////////////////////////////////////////////////////
0:                               new Name(compositeSparse(bytess("b", "c"), new ColumnIdentifier("a", true), true), new CompoundSparseCellNameType(Arrays.<AbstractType<?>>asList(UTF8Type.instance, UTF8Type.instance))),
0:                               new Name(simpleDense(huge('a', 40000)), new SimpleDenseCellNameType(UTF8Type.instance)),
0:                               new Name(simpleSparse(new ColumnIdentifier(hugestr('a', 40000), true)), new SimpleSparseCellNameType(UTF8Type.instance)),
0:                               new Name(compositeDense(huge('a', 20000), huge('b', 20000)), new CompoundDenseCellNameType(Arrays.<AbstractType<?>>asList(UTF8Type.instance, UTF8Type.instance))),
0:                               new Name(compositeSparse(huges(40000, 'b', 'c'), new ColumnIdentifier(hugestr('a', 10000), true), false), new CompoundSparseCellNameType(Arrays.<AbstractType<?>>asList(UTF8Type.instance, UTF8Type.instance))),
0:                               new Name(compositeSparse(huges(40000, 'b', 'c'), new ColumnIdentifier(hugestr('a', 10000), true), true), new CompoundSparseCellNameType(Arrays.<AbstractType<?>>asList(UTF8Type.instance, UTF8Type.instance)))
0:     private static ByteBuffer huge(char ch, int count)
0:     {
0:         return bytes(hugestr(ch, count));
0:     }
0: 
0:     private static ByteBuffer[] huges(int count, char ... chs)
0:     {
0:         ByteBuffer[] r = new ByteBuffer[chs.length];
0:         for (int i = 0 ; i < chs.length ; i++)
0:             r[i] = huge(chs[i], count / chs.length);
0:         return r;
0:     }
0: 
0:     private static String hugestr(char ch, int count)
0:     {
0:         ThreadLocalRandom random = ThreadLocalRandom.current();
0:         byte[] bytes = new byte[count];
0:         random.nextBytes(bytes);
0:         bytes[0] = (byte) ch;
0:         for (int i = 0 ; i < bytes.length ; i++)
0:             bytes[i] &= 0x7f;
0:         return new String(bytes);
0:     }
0: 
commit:e77ea12
/////////////////////////////////////////////////////////////////////////
0: 
0:     @Test
0:     public void testComparator()
0:     {
0: 
0:         Random rand = ThreadLocalRandom.current();
0:         for (Name test : TESTS)
0:         {
0:             byte[] bytes = new byte[7];
0:             byte[] bytes2 = new byte[7];
0:             rand.nextBytes(bytes);
0:             rand.nextBytes(bytes2);
0: 
0:             // test regular Cell
0:             Cell buf, nat, buf2, nat2;
0:             buf = new BufferCell(test.name, ByteBuffer.wrap(bytes), rand.nextLong());
0:             nat = buf.localCopy(metadata, nativeAllocator, group);
0: 
0:             buf2 = new BufferCell(test.name, ByteBuffer.wrap(bytes2), rand.nextLong());
0:             nat2 = buf2.localCopy(metadata, nativeAllocator, group);
0: 
0:             assert test.type.compare(buf.name(), nat.name()) == 0;
0:             assert test.type.compare(buf2.name(), nat2.name()) == 0;
0: 
0:             int val = test.type.compare(buf.name(), buf2.name());
0:             assert test.type.compare(nat.name(), nat2.name()) == val;
0:             assert test.type.compare(nat.name(), buf2.name()) == val;
0:             assert test.type.compare(buf.name(), nat2.name()) == val;
0: 
0: 
0:             // test DeletedCell
0:             buf = new BufferDeletedCell(test.name, rand.nextInt(100000), rand.nextLong());
0:             nat = buf.localCopy(metadata, nativeAllocator, group);
0:             buf2 = new BufferDeletedCell(test.name, rand.nextInt(100000), rand.nextLong());
0:             nat2 = buf2.localCopy(metadata, nativeAllocator, group);
0: 
0:             assert test.type.compare(buf.name(), nat.name()) == 0;
0:             assert test.type.compare(buf2.name(), nat2.name()) == 0;
0: 
0:             val = test.type.compare(buf.name(), buf2.name());
0:             assert test.type.compare(nat.name(), nat2.name()) == val;
0:             assert test.type.compare(nat.name(), buf2.name()) == val;
0:             assert test.type.compare(buf.name(), nat2.name()) == val;
0: 
0: 
0: 
0:             // test ExpiringCell
0:             buf = new BufferExpiringCell(test.name, ByteBuffer.wrap(bytes), rand.nextLong(),  rand.nextInt(100000));
0:             nat = buf.localCopy(metadata, nativeAllocator, group);
0: 
0:             buf2 = new BufferExpiringCell(test.name, ByteBuffer.wrap(bytes2), rand.nextLong(),  rand.nextInt(100000));
0:             nat2 = buf2.localCopy(metadata, nativeAllocator, group);
0: 
0:             assert test.type.compare(buf.name(), nat.name()) == 0;
0:             assert test.type.compare(buf2.name(), nat2.name()) == 0;
0: 
0:             val = test.type.compare(buf.name(), buf2.name());
0:             assert test.type.compare(nat.name(), nat2.name()) == val;
0:             assert test.type.compare(nat.name(), buf2.name()) == val;
0:             assert test.type.compare(buf.name(), nat2.name()) == val;
0: 
0: 
0:             // test CounterCell
0:             buf = new BufferCounterCell(test.name, CounterContext.instance().createLocal(rand.nextLong()), rand.nextLong(),  rand.nextInt(100000));
0:             nat = buf.localCopy(metadata, nativeAllocator, group);
0: 
0:             buf2 = new BufferCounterCell(test.name, CounterContext.instance().createLocal(rand.nextLong()), rand.nextLong(),  rand.nextInt(100000));
0:             nat2 = buf2.localCopy(metadata, nativeAllocator, group);
0: 
0:             assert test.type.compare(buf.name(), nat.name()) == 0;
0:             assert test.type.compare(buf2.name(), nat2.name()) == 0;
0: 
0:             val = test.type.compare(buf.name(), buf2.name());
0:             assert test.type.compare(nat.name(), nat2.name()) == val;
0:             assert test.type.compare(nat.name(), buf2.name()) == val;
0:             assert test.type.compare(buf.name(), nat2.name()) == val;
0: 
0:         }
0:     }
0: 
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:c0c9555
/////////////////////////////////////////////////////////////////////////
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:8541cca
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: package org.apache.cassandra.db;
0: 
0: import java.io.ByteArrayInputStream;
0: import java.io.DataInputStream;
0: import java.io.IOException;
0: import java.nio.ByteBuffer;
0: import java.security.MessageDigest;
0: import java.security.NoSuchAlgorithmException;
0: import java.util.Arrays;
0: import java.util.Random;
0: import java.util.concurrent.ThreadLocalRandom;
0: 
0: import org.junit.Assert;
0: import org.junit.Test;
0: 
0: import org.apache.cassandra.config.CFMetaData;
0: import org.apache.cassandra.config.ColumnDefinition;
0: import org.apache.cassandra.cql3.ColumnIdentifier;
0: import org.apache.cassandra.db.composites.CellName;
0: import org.apache.cassandra.db.composites.CellNameType;
0: import org.apache.cassandra.db.composites.CompoundDenseCellNameType;
0: import org.apache.cassandra.db.composites.CompoundSparseCellNameType;
0: import org.apache.cassandra.db.composites.SimpleDenseCellNameType;
0: import org.apache.cassandra.db.composites.SimpleSparseCellNameType;
0: import org.apache.cassandra.db.context.CounterContext;
0: import org.apache.cassandra.db.marshal.AbstractType;
0: import org.apache.cassandra.db.marshal.UTF8Type;
0: import org.apache.cassandra.exceptions.ConfigurationException;
0: import org.apache.cassandra.io.util.DataOutputBuffer;
0: import org.apache.cassandra.utils.concurrent.OpOrder;
0: import org.apache.cassandra.utils.memory.NativeAllocator;
0: import org.apache.cassandra.utils.memory.NativePool;
0: 
0: import static org.apache.cassandra.db.composites.CellNames.compositeDense;
0: import static org.apache.cassandra.db.composites.CellNames.compositeSparse;
0: import static org.apache.cassandra.db.composites.CellNames.simpleDense;
0: import static org.apache.cassandra.db.composites.CellNames.simpleSparse;
0: import static org.apache.cassandra.utils.ByteBufferUtil.bytes;
0: 
0: public class NativeCellTest
0: {
0: 
0:     private static final NativeAllocator nativeAllocator = new NativePool(Integer.MAX_VALUE, Integer.MAX_VALUE, 1f, null).newAllocator();
0:     private static final OpOrder.Group group = new OpOrder().start();
0: 
0:     static class Name
0:     {
0:         final CellName name;
0:         final CellNameType type;
0:         Name(CellName name, CellNameType type)
0:         {
0:             this.name = name;
0:             this.type = type;
0:         }
0:     }
0: 
0:     static ByteBuffer[] bytess(String ... strings)
0:     {
0:         ByteBuffer[] r = new ByteBuffer[strings.length];
0:         for (int i = 0 ; i < r.length ; i++)
0:             r[i] = bytes(strings[i]);
0:         return r;
0:     }
0: 
0:     final static Name[] TESTS = new Name[]
0:                           {
0:                               new Name(simpleDense(bytes("a")), new SimpleDenseCellNameType(UTF8Type.instance)),
0:                               new Name(simpleSparse(new ColumnIdentifier("a", true)), new SimpleSparseCellNameType(UTF8Type.instance)),
0:                               new Name(compositeDense(bytes("a"), bytes("b")), new CompoundDenseCellNameType(Arrays.<AbstractType<?>>asList(UTF8Type.instance, UTF8Type.instance))),
0:                               new Name(compositeSparse(bytess("b", "c"), new ColumnIdentifier("a", true), false), new CompoundSparseCellNameType(Arrays.<AbstractType<?>>asList(UTF8Type.instance, UTF8Type.instance))),
0:                               new Name(compositeSparse(bytess("b", "c"), new ColumnIdentifier("a", true), true), new CompoundSparseCellNameType(Arrays.<AbstractType<?>>asList(UTF8Type.instance, UTF8Type.instance)))
0:                           };
0: 
0:     private static final CFMetaData metadata = new CFMetaData("", "", ColumnFamilyType.Standard, null);
0:     static
0:     {
0:         try
0:         {
0:             metadata.addColumnDefinition(new ColumnDefinition(null, null, new ColumnIdentifier("a", true), UTF8Type.instance, null, null, null, null, null));
0:         }
0:         catch (ConfigurationException e)
0:         {
0:             throw new AssertionError();
0:         }
0:     }
0: 
0:     @Test
0:     public void testCells() throws IOException
0:     {
0:         Random rand = ThreadLocalRandom.current();
0:         for (Name test : TESTS)
0:         {
0:             byte[] bytes = new byte[16];
0:             rand.nextBytes(bytes);
0: 
0:             // test regular Cell
0:             Cell buf, nat;
0:             buf = new BufferCell(test.name, ByteBuffer.wrap(bytes), rand.nextLong());
0:             nat = buf.localCopy(metadata, nativeAllocator, group);
0:             test(test, buf, nat);
0: 
0:             // test DeletedCell
0:             buf = new BufferDeletedCell(test.name, rand.nextInt(100000), rand.nextLong());
0:             nat = buf.localCopy(metadata, nativeAllocator, group);
0:             test(test, buf, nat);
0: 
0:             // test ExpiringCell
0:             buf = new BufferExpiringCell(test.name, ByteBuffer.wrap(bytes), rand.nextLong(),  rand.nextInt(100000));
0:             nat = buf.localCopy(metadata, nativeAllocator, group);
0:             test(test, buf, nat);
0: 
0:             // test CounterCell
0:             buf = new BufferCounterCell(test.name, CounterContext.instance().createLocal(rand.nextLong()), rand.nextLong(),  rand.nextInt(100000));
0:             nat = buf.localCopy(metadata, nativeAllocator, group);
0:             test(test, buf, nat);
0:         }
0:     }
0: 
0:     static void test(Name test, Cell buf, Cell nat) throws IOException
0:     {
0:         Assert.assertTrue(buf.equals(nat));
0:         Assert.assertTrue(nat.equals(buf));
0:         Assert.assertTrue(buf.equals(buf));
0:         Assert.assertTrue(nat.equals(nat));
0: 
0:         try
0:         {
0:             MessageDigest d1 = MessageDigest.getInstance("MD5");
0:             MessageDigest d2 = MessageDigest.getInstance("MD5");
0:             buf.updateDigest(d1);
0:             nat.updateDigest(d2);
0:             Assert.assertArrayEquals(d1.digest(), d2.digest());
0:         }
0:         catch (NoSuchAlgorithmException e)
0:         {
0:             throw new IllegalStateException(e);
0:         }
0: 
0:         byte[] serialized;
0:         try (DataOutputBuffer bufOut = new DataOutputBuffer())
0:         {
0:             test.type.columnSerializer().serialize(nat, bufOut);
0:             serialized = bufOut.getData();
0:         }
0: 
0:         ByteArrayInputStream bufIn = new ByteArrayInputStream(serialized, 0, serialized.length);
0:         Cell deserialized = test.type.columnSerializer().deserialize(new DataInputStream(bufIn));
0:         Assert.assertTrue(buf.equals(deserialized));
0: 
0:     }
0: 
0: 
0: 
0: }
============================================================================