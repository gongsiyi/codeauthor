1:7813dee: /*
1:7813dee:  * Licensed to the Apache Software Foundation (ASF) under one
1:7813dee:  * or more contributor license agreements.  See the NOTICE file
1:7813dee:  * distributed with this work for additional information
1:7813dee:  * regarding copyright ownership.  The ASF licenses this file
1:7813dee:  * to you under the Apache License, Version 2.0 (the
1:7813dee:  * "License"); you may not use this file except in compliance
1:7813dee:  * with the License.  You may obtain a copy of the License at
1:7813dee:  *
1:7813dee:  *     http://www.apache.org/licenses/LICENSE-2.0
1:7813dee:  *
1:7813dee:  * Unless required by applicable law or agreed to in writing, software
1:7813dee:  * distributed under the License is distributed on an "AS IS" BASIS,
1:7813dee:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7813dee:  * See the License for the specific language governing permissions and
1:7813dee:  * limitations under the License.
1:7813dee:  */
1:7813dee: package org.apache.cassandra.db.rows;
29:7813dee: 
1:7813dee: import java.nio.ByteBuffer;
1:7813dee: import java.util.*;
1:7813dee: import java.util.function.Function;
1:7813dee: import java.util.regex.Matcher;
1:7813dee: import java.util.regex.Pattern;
1:7813dee: import java.util.stream.Collectors;
1:7813dee: 
1:7813dee: import com.google.common.collect.ImmutableList;
1:7813dee: import com.google.common.collect.Iterators;
1:7813dee: 
1:7813dee: import org.junit.Assert;
1:7813dee: import org.junit.Test;
1:7813dee: 
1:7813dee: import org.apache.cassandra.Util;
1:7813dee: import org.apache.cassandra.config.CFMetaData;
1:9797511: import org.apache.cassandra.config.DatabaseDescriptor;
1:7813dee: import org.apache.cassandra.db.*;
1:7813dee: import org.apache.cassandra.db.marshal.AsciiType;
1:7813dee: import org.apache.cassandra.db.marshal.Int32Type;
1:7813dee: import org.apache.cassandra.db.rows.Unfiltered.Kind;
1:7813dee: import org.apache.cassandra.utils.FBUtilities;
1:7813dee: 
1:7813dee: public class UnfilteredRowIteratorsMergeTest
33:7813dee: {
1:9797511:     static
1:9797511:     {
1:9797511:         DatabaseDescriptor.daemonInitialization();
1:9797511:     }
1:7813dee:     static DecoratedKey partitionKey = Util.dk("key");
1:7813dee:     static DeletionTime partitionLevelDeletion = DeletionTime.LIVE;
1:7813dee:     static CFMetaData metadata = CFMetaData.Builder.create("UnfilteredRowIteratorsMergeTest", "Test").
1:7813dee:             addPartitionKey("key", AsciiType.instance).
1:7813dee:             addClusteringColumn("clustering", Int32Type.instance).
1:7813dee:             addRegularColumn("data", Int32Type.instance).
1:7813dee:             build();
1:7813dee:     static Comparator<Clusterable> comparator = new ClusteringComparator(Int32Type.instance);
1:7813dee:     static int nowInSec = FBUtilities.nowInSeconds();
1:7813dee: 
1:7813dee:     static final int RANGE = 3000;
1:7813dee:     static final int DEL_RANGE = 100;
1:7813dee:     static final int ITERATORS = 15;
1:7813dee:     static final int ITEMS = 300;
1:7813dee: 
1:7813dee:     boolean reversed;
1:7813dee: 
1:7813dee:     public UnfilteredRowIteratorsMergeTest()
1:7813dee:     {
30:7813dee:     }
1:7813dee: 
1:7813dee:     @Test
1:7813dee:     public void testTombstoneMerge()
1:7813dee:     {
1:7813dee:         testTombstoneMerge(false, false);
1:7813dee:     }
1:7813dee: 
1:7813dee:     @Test
1:7813dee:     public void testTombstoneMergeReversed()
1:7813dee:     {
1:7813dee:         testTombstoneMerge(true, false);
1:7813dee:     }
1:7813dee: 
1:7813dee:     @Test
1:7813dee:     public void testTombstoneMergeIterative()
1:7813dee:     {
1:7813dee:         testTombstoneMerge(false, true);
1:7813dee:     }
1:7813dee: 
1:7813dee:     @Test
1:7813dee:     public void testTombstoneMergeReversedIterative()
1:7813dee:     {
1:7813dee:         testTombstoneMerge(true, true);
1:7813dee:     }
1:7813dee: 
1:7813dee:     @Test
1:7813dee:     public void testDuplicateRangeCase()
1:7813dee:     {
1:7813dee:         testForInput("67<=[98] [98]<=67",
1:7813dee:                      "66<=[11] [11]<71",
1:7813dee:                      "66<[13] [13]<67");
1:7813dee:     }
1:7813dee: 
1:7813dee:     @SuppressWarnings("unused")
1:7813dee:     public void testTombstoneMerge(boolean reversed, boolean iterations)
1:7813dee:     {
1:d40ac78:         this.reversed = reversed;
1:d40ac78:         UnfilteredRowsGenerator generator = new UnfilteredRowsGenerator(comparator, reversed);
1:d40ac78: 
1:7813dee:         for (int seed = 1; seed <= 100; ++seed)
1:7813dee:         {
1:7813dee:             if (ITEMS <= 20)
1:7813dee:                 System.out.println("\nSeed " + seed);
1:7813dee: 
1:7813dee:             Random r = new Random(seed);
1:7813dee:             List<Function<Integer, Integer>> timeGenerators = ImmutableList.of(
1:7813dee:                     x -> -1,
1:7813dee:                     x -> DEL_RANGE,
1:7813dee:                     x -> r.nextInt(DEL_RANGE)
1:7813dee:                 );
1:7813dee:             List<List<Unfiltered>> sources = new ArrayList<>(ITERATORS);
1:7813dee:             if (ITEMS <= 20)
1:7813dee:                 System.out.println("Merging");
1:7813dee:             for (int i=0; i<ITERATORS; ++i)
1:d40ac78:                 sources.add(generator.generateSource(r, ITEMS, RANGE, DEL_RANGE, timeGenerators.get(r.nextInt(timeGenerators.size()))));
1:7813dee:             List<Unfiltered> merged = merge(sources, iterations);
1:7813dee:     
1:7813dee:             if (ITEMS <= 20)
1:7813dee:                 System.out.println("results in");
1:7813dee:             if (ITEMS <= 20)
1:d40ac78:                 generator.dumpList(merged);
1:d40ac78:             verifyEquivalent(sources, merged, generator);
1:d40ac78:             generator.verifyValid(merged);
1:7813dee:             if (reversed)
1:7813dee:             {
1:7813dee:                 Collections.reverse(merged);
1:d40ac78:                 generator.verifyValid(merged, false);
1:7813dee:             }
1:7813dee:         }
1:7813dee:     }
1:7813dee: 
1:7813dee:     private List<Unfiltered> merge(List<List<Unfiltered>> sources, boolean iterations)
1:7813dee:     {
1:d40ac78:         List<UnfilteredRowIterator> us = sources.
1:d40ac78:                 stream().
1:d40ac78:                 map(l -> new UnfilteredRowsGenerator.Source(l.iterator(), metadata, partitionKey, DeletionTime.LIVE, reversed)).
1:d40ac78:                 collect(Collectors.toList());
1:7813dee:         List<Unfiltered> merged = new ArrayList<>();
1:2457599:         Iterators.addAll(merged, mergeIterators(us, iterations));
1:7813dee:         return merged;
1:7813dee:     }
1:7813dee: 
1:7813dee:     public UnfilteredRowIterator mergeIterators(List<UnfilteredRowIterator> us, boolean iterations)
1:7813dee:     {
1:7813dee:         int now = FBUtilities.nowInSeconds();
1:7813dee:         if (iterations)
1:7813dee:         {
1:7813dee:             UnfilteredRowIterator mi = us.get(0);
1:7813dee:             int i;
1:7813dee:             for (i = 1; i + 2 <= ITERATORS; i += 2)
1:7813dee:                 mi = UnfilteredRowIterators.merge(ImmutableList.of(mi, us.get(i), us.get(i+1)), now);
1:7813dee:             if (i + 1 <= ITERATORS)
1:7813dee:                 mi = UnfilteredRowIterators.merge(ImmutableList.of(mi, us.get(i)), now);
1:7813dee:             return mi;
1:7813dee:         }
1:7813dee:         else
1:7813dee:         {
1:7813dee:             return UnfilteredRowIterators.merge(us, now);
1:7813dee:         }
1:7813dee:     }
1:7813dee: 
1:7813dee:     @SuppressWarnings("unused")
1:7813dee:     private List<Unfiltered> generateSource(Random r, Function<Integer, Integer> timeGenerator)
1:7813dee:     {
1:7813dee:         int[] positions = new int[ITEMS + 1];
1:7813dee:         for (int i=0; i<ITEMS; ++i)
1:7813dee:             positions[i] = r.nextInt(RANGE);
1:7813dee:         positions[ITEMS] = RANGE;
1:7813dee:         Arrays.sort(positions);
1:7813dee: 
1:7813dee:         List<Unfiltered> content = new ArrayList<>(ITEMS);
1:7813dee:         int prev = -1;
1:7813dee:         for (int i=0; i<ITEMS; ++i)
1:7813dee:         {
1:7813dee:             int pos = positions[i];
1:7813dee:             int sz = positions[i + 1] - pos;
1:7813dee:             if (sz == 0 && pos == prev)
1:7813dee:                 // Filter out more than two of the same position.
1:7813dee:                 continue;
1:7813dee:             if (r.nextBoolean() || pos == prev)
1:7813dee:             {
1:7813dee:                 int span;
1:7813dee:                 boolean includesStart;
1:7813dee:                 boolean includesEnd;
1:7813dee:                 if (pos > prev)
1:7813dee:                 {
1:7813dee:                     span = r.nextInt(sz + 1);
1:7813dee:                     includesStart = span > 0 ? r.nextBoolean() : true;
1:7813dee:                     includesEnd = span > 0 ? r.nextBoolean() : true;
1:7813dee:                 }
1:7813dee:                 else
1:7813dee:                 {
1:7813dee:                     span = 1 + r.nextInt(sz);
1:7813dee:                     includesStart = false;
1:7813dee:                     includesEnd = r.nextBoolean();
1:7813dee:                 }
1:7813dee:                 int deltime = r.nextInt(DEL_RANGE);
1:2457599:                 DeletionTime dt = new DeletionTime(deltime, deltime);
1:7813dee:                 content.add(new RangeTombstoneBoundMarker(boundFor(pos, true, includesStart), dt));
1:7813dee:                 content.add(new RangeTombstoneBoundMarker(boundFor(pos + span, false, includesEnd), dt));
1:7813dee:                 prev = pos + span - (includesEnd ? 0 : 1);
1:7813dee:             }
1:7813dee:             else
1:7813dee:             {
1:7813dee:                 content.add(emptyRowAt(pos, timeGenerator));
1:7813dee:                 prev = pos;
1:7813dee:             }
1:7813dee:         }
1:7813dee: 
1:7813dee:         attachBoundaries(content);
1:7813dee:         if (reversed)
1:7813dee:         {
1:7813dee:             Collections.reverse(content);
1:7813dee:         }
1:7813dee:         verifyValid(content);
1:7813dee:         if (ITEMS <= 20)
1:7813dee:             dumpList(content);
1:7813dee:         return content;
1:7813dee:     }
1:7813dee: 
1:7813dee:     static void attachBoundaries(List<Unfiltered> content)
1:7813dee:     {
1:7813dee:         int di = 0;
1:7813dee:         RangeTombstoneMarker prev = null;
1:7813dee:         for (int si = 0; si < content.size(); ++si)
1:7813dee:         {
1:7813dee:             Unfiltered currUnfiltered = content.get(si);
1:7813dee:             RangeTombstoneMarker curr = currUnfiltered.kind() == Kind.RANGE_TOMBSTONE_MARKER ?
1:7813dee:                                         (RangeTombstoneMarker) currUnfiltered :
1:7813dee:                                         null;
1:7813dee:             if (prev != null && curr != null && prev.isClose(false) && curr.isOpen(false) && prev.clustering().invert().equals(curr.clustering()))
1:7813dee:             {
1:7813dee:                 // Join. Prefer not to use merger to check its correctness.
1:2cc26eb:                 ClusteringBound b = ((RangeTombstoneBoundMarker) prev).clustering();
1:2cc26eb:                 ClusteringBoundary boundary = ClusteringBoundary.create(b.isInclusive()
1:2cc26eb:                                                                             ? ClusteringPrefix.Kind.INCL_END_EXCL_START_BOUNDARY
1:2cc26eb:                                                                             : ClusteringPrefix.Kind.EXCL_END_INCL_START_BOUNDARY,
1:2cc26eb:                                                                         b.getRawValues());
1:2cc26eb:                 prev = new RangeTombstoneBoundaryMarker(boundary, prev.closeDeletionTime(false), curr.openDeletionTime(false));
1:7813dee:                 currUnfiltered = prev;
1:7813dee:                 --di;
1:7813dee:             }
1:7813dee:             content.set(di++, currUnfiltered);
1:7813dee:             prev = curr;
1:7813dee:         }
1:7813dee:         for (int pos = content.size() - 1; pos >= di; --pos)
1:7813dee:             content.remove(pos);
1:7813dee:     }
1:7813dee: 
1:7813dee:     void verifyValid(List<Unfiltered> list)
1:7813dee:     {
1:7813dee:         int reversedAsMultiplier = reversed ? -1 : 1;
1:7813dee:         try {
1:7813dee:             RangeTombstoneMarker prev = null;
1:7813dee:             Unfiltered prevUnfiltered = null;
1:7813dee:             for (Unfiltered unfiltered : list)
1:7813dee:             {
1:7813dee:                 Assert.assertTrue("Order violation prev " + str(prevUnfiltered) + " curr " + str(unfiltered),
1:7813dee:                                   prevUnfiltered == null || comparator.compare(prevUnfiltered, unfiltered) * reversedAsMultiplier < 0);
1:7813dee:                 prevUnfiltered = unfiltered;
1:7813dee: 
1:7813dee:                 if (unfiltered.kind() == Kind.RANGE_TOMBSTONE_MARKER)
1:7813dee:                 {
1:7813dee:                     RangeTombstoneMarker curr = (RangeTombstoneMarker) unfiltered;
1:7813dee:                     if (prev != null)
1:7813dee:                     {
1:7813dee:                         if (curr.isClose(reversed))
1:7813dee:                         {
1:7813dee:                             Assert.assertTrue(str(unfiltered) + " follows another close marker " + str(prev), prev.isOpen(reversed));
1:7813dee:                             Assert.assertEquals("Deletion time mismatch for open " + str(prev) + " and close " + str(unfiltered),
1:7813dee:                                                 prev.openDeletionTime(reversed),
1:7813dee:                                                 curr.closeDeletionTime(reversed));
1:7813dee:                         }
1:7813dee:                         else
1:7813dee:                             Assert.assertFalse(str(curr) + " follows another open marker " + str(prev), prev.isOpen(reversed));
1:7813dee:                     }
1:7813dee: 
1:7813dee:                     prev = curr;
1:7813dee:                 }
1:7813dee:             }
1:7813dee:             Assert.assertFalse("Cannot end in open marker " + str(prev), prev != null && prev.isOpen(reversed));
1:7813dee: 
1:7813dee:         } catch (AssertionError e) {
1:7813dee:             System.out.println(e);
2:7813dee:             dumpList(list);
1:7813dee:             throw e;
1:7813dee:         }
1:7813dee:     }
1:7813dee: 
1:d40ac78:     void verifyEquivalent(List<List<Unfiltered>> sources, List<Unfiltered> merged, UnfilteredRowsGenerator generator)
1:7813dee:     {
1:7813dee:         try
1:7813dee:         {
1:7813dee:             for (int i=0; i<RANGE; ++i)
1:7813dee:             {
1:d40ac78:                 Clusterable c = UnfilteredRowsGenerator.clusteringFor(i);
1:7813dee:                 DeletionTime dt = DeletionTime.LIVE;
1:7813dee:                 for (List<Unfiltered> source : sources)
1:7813dee:                 {
1:7813dee:                     dt = deletionFor(c, source, dt);
1:7813dee:                 }
1:d40ac78:                 Assert.assertEquals("Deletion time mismatch for position " + i, dt, deletionFor(c, merged));
1:7813dee:                 if (dt == DeletionTime.LIVE)
1:7813dee:                 {
1:7813dee:                     Optional<Unfiltered> sourceOpt = sources.stream().map(source -> rowFor(c, source)).filter(x -> x != null).findAny();
1:7813dee:                     Unfiltered mergedRow = rowFor(c, merged);
1:d40ac78:                     Assert.assertEquals("Content mismatch for position " + i, clustering(sourceOpt.orElse(null)), clustering(mergedRow));
1:7813dee:                 }
1:7813dee:             }
1:7813dee:         }
1:7813dee:         catch (AssertionError e)
1:7813dee:         {
1:7813dee:             System.out.println(e);
1:7813dee:             for (List<Unfiltered> list : sources)
1:d40ac78:                 generator.dumpList(list);
1:7813dee:             System.out.println("merged");
1:d40ac78:             generator.dumpList(merged);
1:7813dee:             throw e;
1:7813dee:         }
1:7813dee:     }
1:7813dee: 
1:d40ac78:     String clustering(Clusterable curr)
1:d40ac78:     {
1:d40ac78:         if (curr == null)
1:d40ac78:             return "null";
1:d40ac78:         return Int32Type.instance.getString(curr.clustering().get(0));
1:d40ac78:     }
1:d40ac78: 
1:7813dee:     private Unfiltered rowFor(Clusterable pointer, List<Unfiltered> list)
1:7813dee:     {
1:7813dee:         int index = Collections.binarySearch(list, pointer, reversed ? comparator.reversed() : comparator);
1:7813dee:         return index >= 0 ? list.get(index) : null;
1:7813dee:     }
1:7813dee: 
1:7813dee:     DeletionTime deletionFor(Clusterable pointer, List<Unfiltered> list)
1:7813dee:     {
1:7813dee:         return deletionFor(pointer, list, DeletionTime.LIVE);
1:7813dee:     }
1:7813dee: 
1:7813dee:     DeletionTime deletionFor(Clusterable pointer, List<Unfiltered> list, DeletionTime def)
1:7813dee:     {
1:7813dee:         if (list.isEmpty())
1:7813dee:             return def;
1:7813dee: 
1:7813dee:         int index = Collections.binarySearch(list, pointer, reversed ? comparator.reversed() : comparator);
1:7813dee:         if (index < 0)
1:7813dee:             index = -1 - index;
1:7813dee:         else
1:7813dee:         {
1:7813dee:             Row row = (Row) list.get(index);
1:665f747:             if (row.deletion().supersedes(def))
1:665f747:                 def = row.deletion().time();
1:7813dee:         }
1:7813dee: 
1:7813dee:         if (index >= list.size())
1:7813dee:             return def;
1:7813dee: 
1:7813dee:         while (--index >= 0)
1:7813dee:         {
1:7813dee:             Unfiltered unfiltered = list.get(index);
1:7813dee:             if (unfiltered.kind() == Kind.ROW)
1:7813dee:                 continue;
1:7813dee:             RangeTombstoneMarker lower = (RangeTombstoneMarker) unfiltered;
1:7813dee:             if (!lower.isOpen(reversed))
1:7813dee:                 return def;
1:7813dee:             return lower.openDeletionTime(reversed).supersedes(def) ? lower.openDeletionTime(reversed) : def;
1:7813dee:         }
1:7813dee:         return def;
1:7813dee:     }
1:7813dee: 
1:2cc26eb:     private static ClusteringBound boundFor(int pos, boolean start, boolean inclusive)
1:7813dee:     {
1:2cc26eb:         return ClusteringBound.create(ClusteringBound.boundKind(start, inclusive), new ByteBuffer[] {Int32Type.instance.decompose(pos)});
1:7813dee:     }
1:7813dee: 
1:2457599:     private static Clustering clusteringFor(int i)
1:7813dee:     {
1:2f41243:         return Clustering.make(Int32Type.instance.decompose(i));
1:7813dee:     }
1:7813dee: 
1:7813dee:     static Row emptyRowAt(int pos, Function<Integer, Integer> timeGenerator)
1:7813dee:     {
1:7813dee:         final Clustering clustering = clusteringFor(pos);
1:e017f94:         final LivenessInfo live = LivenessInfo.create(timeGenerator.apply(pos), nowInSec);
1:e51f83b:         return BTreeRow.noCellLiveRow(clustering, live);
1:7813dee:     }
1:7813dee: 
1:7813dee:     private void dumpList(List<Unfiltered> list)
1:7813dee:     {
1:7813dee:         for (Unfiltered u : list)
1:7813dee:             System.out.print(str(u) + " ");
1:7813dee:         System.out.println();
1:7813dee:     }
1:7813dee: 
1:7813dee:     private String str(Clusterable curr)
1:7813dee:     {
1:7813dee:         if (curr == null)
1:7813dee:             return "null";
1:7813dee:         String val = Int32Type.instance.getString(curr.clustering().get(0));
1:7813dee:         if (curr instanceof RangeTombstoneMarker)
1:7813dee:         {
1:7813dee:             RangeTombstoneMarker marker = (RangeTombstoneMarker) curr;
1:7813dee:             if (marker.isClose(reversed))
1:7813dee:                 val = "[" + marker.closeDeletionTime(reversed).markedForDeleteAt() + "]" + (marker.closeIsInclusive(reversed) ? "<=" : "<") + val;
1:7813dee:             if (marker.isOpen(reversed)) 
1:7813dee:                 val = val + (marker.openIsInclusive(reversed) ? "<=" : "<") + "[" + marker.openDeletionTime(reversed).markedForDeleteAt() + "]";
1:7813dee:         }
1:7813dee:         return val;
1:7813dee:     }
1:7813dee: 
1:7813dee:     class Source extends AbstractUnfilteredRowIterator implements UnfilteredRowIterator
1:7813dee:     {
1:7813dee:         Iterator<Unfiltered> content;
1:7813dee: 
1:7813dee:         protected Source(Iterator<Unfiltered> content)
1:7813dee:         {
1:7813dee:             super(UnfilteredRowIteratorsMergeTest.metadata,
1:7813dee:                   UnfilteredRowIteratorsMergeTest.partitionKey,
1:7813dee:                   UnfilteredRowIteratorsMergeTest.partitionLevelDeletion,
1:7813dee:                   UnfilteredRowIteratorsMergeTest.metadata.partitionColumns(),
1:7813dee:                   null,
1:7813dee:                   reversed,
1:c055ab9:                   EncodingStats.NO_STATS);
1:7813dee:             this.content = content;
1:7813dee:         }
1:7813dee: 
24:7813dee:         @Override
1:7813dee:         protected Unfiltered computeNext()
1:7813dee:         {
1:7813dee:             return content.hasNext() ? content.next() : endOfData();
1:7813dee:         }
1:7813dee:     }
1:7813dee: 
1:7813dee:     public void testForInput(String... inputs)
1:7813dee:     {
1:d40ac78:         reversed = false;
1:d40ac78:         UnfilteredRowsGenerator generator = new UnfilteredRowsGenerator(comparator, false);
1:d40ac78: 
1:7813dee:         List<List<Unfiltered>> sources = new ArrayList<>();
1:7813dee:         for (String input : inputs)
1:7813dee:         {
1:d40ac78:             List<Unfiltered> source = generator.parse(input, DEL_RANGE);
1:d40ac78:             generator.dumpList(source);
1:d40ac78:             generator.verifyValid(source);
1:7813dee:             sources.add(source);
1:7813dee:         }
1:7813dee: 
1:7813dee:         List<Unfiltered> merged = merge(sources, false);
1:7813dee:         System.out.println("Merge to:");
1:d40ac78:         generator.dumpList(merged);
1:d40ac78:         verifyEquivalent(sources, merged, generator);
1:d40ac78:         generator.verifyValid(merged);
1:7813dee:         System.out.println();
1:7813dee:     }
1:7813dee: 
1:7813dee:     List<Unfiltered> parse(String input)
1:7813dee:     {
1:7813dee:         String[] split = input.split(" ");
1:7813dee:         Pattern open = Pattern.compile("(\\d+)<(=)?\\[(\\d+)\\]");
1:7813dee:         Pattern close = Pattern.compile("\\[(\\d+)\\]<(=)?(\\d+)");
1:7813dee:         Pattern row = Pattern.compile("(\\d+)(\\[(\\d+)\\])?");
1:7813dee:         List<Unfiltered> out = new ArrayList<>(split.length);
1:7813dee:         for (String s : split)
1:7813dee:         {
1:7813dee:             Matcher m = open.matcher(s);
1:7813dee:             if (m.matches())
1:7813dee:             {
1:7813dee:                 out.add(openMarker(Integer.parseInt(m.group(1)), Integer.parseInt(m.group(3)), m.group(2) != null));
1:7813dee:                 continue;
1:7813dee:             }
1:7813dee:             m = close.matcher(s);
1:7813dee:             if (m.matches())
1:7813dee:             {
1:7813dee:                 out.add(closeMarker(Integer.parseInt(m.group(3)), Integer.parseInt(m.group(1)), m.group(2) != null));
1:7813dee:                 continue;
1:7813dee:             }
1:7813dee:             m = row.matcher(s);
1:7813dee:             if (m.matches())
1:7813dee:             {
1:7813dee:                 int live = m.group(3) != null ? Integer.parseInt(m.group(3)) : DEL_RANGE;
1:7813dee:                 out.add(emptyRowAt(Integer.parseInt(m.group(1)), x -> live));
1:7813dee:                 continue;
1:7813dee:             }
1:7813dee:             Assert.fail("Can't parse " + s);
1:7813dee:         }
1:7813dee:         return out;
1:7813dee:     }
1:7813dee: 
1:7813dee:     private RangeTombstoneMarker openMarker(int pos, int delTime, boolean inclusive)
1:7813dee:     {
1:7813dee:         return marker(pos, delTime, true, inclusive);
1:7813dee:     }
1:7813dee: 
1:7813dee:     private RangeTombstoneMarker closeMarker(int pos, int delTime, boolean inclusive)
1:7813dee:     {
1:7813dee:         return marker(pos, delTime, false, inclusive);
1:7813dee:     }
1:7813dee: 
1:7813dee:     private RangeTombstoneMarker marker(int pos, int delTime, boolean isStart, boolean inclusive)
1:7813dee:     {
1:2cc26eb:         return new RangeTombstoneBoundMarker(ClusteringBound.create(ClusteringBound.boundKind(isStart, inclusive),
1:2cc26eb:                                                                     new ByteBuffer[] {clusteringFor(pos).get(0)}),
1:2457599:                                              new DeletionTime(delTime, delTime));
1:7813dee:     }
1:7813dee: }
============================================================================
author:Robert Stupp
-------------------------------------------------------------------------------
commit:9797511
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.DatabaseDescriptor;
/////////////////////////////////////////////////////////////////////////
1:     static
1:     {
1:         DatabaseDescriptor.daemonInitialization();
1:     }
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:d40ac78
/////////////////////////////////////////////////////////////////////////
1:         this.reversed = reversed;
1:         UnfilteredRowsGenerator generator = new UnfilteredRowsGenerator(comparator, reversed);
1: 
/////////////////////////////////////////////////////////////////////////
1:                 sources.add(generator.generateSource(r, ITEMS, RANGE, DEL_RANGE, timeGenerators.get(r.nextInt(timeGenerators.size()))));
1:                 generator.dumpList(merged);
1:             verifyEquivalent(sources, merged, generator);
1:             generator.verifyValid(merged);
1:                 generator.verifyValid(merged, false);
1:         List<UnfilteredRowIterator> us = sources.
1:                 stream().
1:                 map(l -> new UnfilteredRowsGenerator.Source(l.iterator(), metadata, partitionKey, DeletionTime.LIVE, reversed)).
1:                 collect(Collectors.toList());
/////////////////////////////////////////////////////////////////////////
1:     void verifyEquivalent(List<List<Unfiltered>> sources, List<Unfiltered> merged, UnfilteredRowsGenerator generator)
1:                 Clusterable c = UnfilteredRowsGenerator.clusteringFor(i);
1:                 Assert.assertEquals("Deletion time mismatch for position " + i, dt, deletionFor(c, merged));
1:                     Assert.assertEquals("Content mismatch for position " + i, clustering(sourceOpt.orElse(null)), clustering(mergedRow));
/////////////////////////////////////////////////////////////////////////
1:                 generator.dumpList(list);
1:             generator.dumpList(merged);
1:     String clustering(Clusterable curr)
1:     {
1:         if (curr == null)
1:             return "null";
1:         return Int32Type.instance.getString(curr.clustering().get(0));
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         reversed = false;
1:         UnfilteredRowsGenerator generator = new UnfilteredRowsGenerator(comparator, false);
1: 
1:             List<Unfiltered> source = generator.parse(input, DEL_RANGE);
1:             generator.dumpList(source);
1:             generator.verifyValid(source);
1:         generator.dumpList(merged);
1:         verifyEquivalent(sources, merged, generator);
1:         generator.verifyValid(merged);
commit:2cc26eb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 ClusteringBound b = ((RangeTombstoneBoundMarker) prev).clustering();
1:                 ClusteringBoundary boundary = ClusteringBoundary.create(b.isInclusive()
1:                                                                             ? ClusteringPrefix.Kind.INCL_END_EXCL_START_BOUNDARY
1:                                                                             : ClusteringPrefix.Kind.EXCL_END_INCL_START_BOUNDARY,
1:                                                                         b.getRawValues());
1:                 prev = new RangeTombstoneBoundaryMarker(boundary, prev.closeDeletionTime(false), curr.openDeletionTime(false));
/////////////////////////////////////////////////////////////////////////
1:     private static ClusteringBound boundFor(int pos, boolean start, boolean inclusive)
1:         return ClusteringBound.create(ClusteringBound.boundKind(start, inclusive), new ByteBuffer[] {Int32Type.instance.decompose(pos)});
/////////////////////////////////////////////////////////////////////////
1:         return new RangeTombstoneBoundMarker(ClusteringBound.create(ClusteringBound.boundKind(isStart, inclusive),
1:                                                                     new ByteBuffer[] {clusteringFor(pos).get(0)}),
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:e017f94
/////////////////////////////////////////////////////////////////////////
1:         final LivenessInfo live = LivenessInfo.create(timeGenerator.apply(pos), nowInSec);
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:2f41243
/////////////////////////////////////////////////////////////////////////
1:         return Clustering.make(Int32Type.instance.decompose(i));
commit:e51f83b
/////////////////////////////////////////////////////////////////////////
1:         return BTreeRow.noCellLiveRow(clustering, live);
commit:639d4b2
/////////////////////////////////////////////////////////////////////////
0:         return BTreeBackedRow.noCellLiveRow(clustering, live);
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:665f747
/////////////////////////////////////////////////////////////////////////
1:             if (row.deletion().supersedes(def))
1:                 def = row.deletion().time();
commit:c055ab9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                   EncodingStats.NO_STATS);
commit:2457599
/////////////////////////////////////////////////////////////////////////
1:         Iterators.addAll(merged, mergeIterators(us, iterations));
/////////////////////////////////////////////////////////////////////////
1:                 DeletionTime dt = new DeletionTime(deltime, deltime);
/////////////////////////////////////////////////////////////////////////
1:     private static Clustering clusteringFor(int i)
0:         return new Clustering(Int32Type.instance.decompose(i));
0:         final LivenessInfo live = LivenessInfo.create(metadata, timeGenerator.apply(pos), nowInSec);
0:         return ArrayBackedRow.noCellLiveRow(clustering, live);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                                              new DeletionTime(delTime, delTime));
commit:7813dee
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.db.rows;
1: 
1: import java.nio.ByteBuffer;
1: import java.util.*;
1: import java.util.function.Function;
1: import java.util.regex.Matcher;
1: import java.util.regex.Pattern;
1: import java.util.stream.Collectors;
1: 
1: import com.google.common.collect.ImmutableList;
1: import com.google.common.collect.Iterators;
1: 
1: import org.junit.Assert;
1: import org.junit.Test;
1: 
1: import org.apache.cassandra.Util;
1: import org.apache.cassandra.config.CFMetaData;
0: import org.apache.cassandra.config.ColumnDefinition;
0: import org.apache.cassandra.cql3.ColumnIdentifier;
1: import org.apache.cassandra.db.*;
0: import org.apache.cassandra.db.Slice.Bound;
1: import org.apache.cassandra.db.marshal.AsciiType;
1: import org.apache.cassandra.db.marshal.Int32Type;
1: import org.apache.cassandra.db.rows.Unfiltered.Kind;
1: import org.apache.cassandra.utils.FBUtilities;
0: import org.apache.cassandra.utils.SearchIterator;
1: 
1: public class UnfilteredRowIteratorsMergeTest
1: {
1:     static DecoratedKey partitionKey = Util.dk("key");
1:     static DeletionTime partitionLevelDeletion = DeletionTime.LIVE;
1:     static CFMetaData metadata = CFMetaData.Builder.create("UnfilteredRowIteratorsMergeTest", "Test").
1:             addPartitionKey("key", AsciiType.instance).
1:             addClusteringColumn("clustering", Int32Type.instance).
1:             addRegularColumn("data", Int32Type.instance).
1:             build();
1:     static Comparator<Clusterable> comparator = new ClusteringComparator(Int32Type.instance);
1:     static int nowInSec = FBUtilities.nowInSeconds();
1: 
1:     static final int RANGE = 3000;
1:     static final int DEL_RANGE = 100;
1:     static final int ITERATORS = 15;
1:     static final int ITEMS = 300;
1: 
1:     boolean reversed;
1: 
1:     public UnfilteredRowIteratorsMergeTest()
1:     {
1:     }
1: 
1:     @Test
1:     public void testTombstoneMerge()
1:     {
1:         testTombstoneMerge(false, false);
1:     }
1: 
1:     @Test
1:     public void testTombstoneMergeReversed()
1:     {
1:         testTombstoneMerge(true, false);
1:     }
1: 
1:     @Test
1:     public void testTombstoneMergeIterative()
1:     {
1:         testTombstoneMerge(false, true);
1:     }
1: 
1:     @Test
1:     public void testTombstoneMergeReversedIterative()
1:     {
1:         testTombstoneMerge(true, true);
1:     }
1: 
1:     @Test
1:     public void testDuplicateRangeCase()
1:     {
1:         testForInput("67<=[98] [98]<=67",
1:                      "66<=[11] [11]<71",
1:                      "66<[13] [13]<67");
1:     }
1: 
1:     @SuppressWarnings("unused")
1:     public void testTombstoneMerge(boolean reversed, boolean iterations)
1:     {
1:         for (int seed = 1; seed <= 100; ++seed)
1:         {
0:             this.reversed = reversed;
1:             if (ITEMS <= 20)
1:                 System.out.println("\nSeed " + seed);
1: 
1:             Random r = new Random(seed);
1:             List<Function<Integer, Integer>> timeGenerators = ImmutableList.of(
1:                     x -> -1,
1:                     x -> DEL_RANGE,
1:                     x -> r.nextInt(DEL_RANGE)
1:                 );
1:             List<List<Unfiltered>> sources = new ArrayList<>(ITERATORS);
1:             if (ITEMS <= 20)
1:                 System.out.println("Merging");
1:             for (int i=0; i<ITERATORS; ++i)
0:                 sources.add(generateSource(r, timeGenerators.get(r.nextInt(timeGenerators.size()))));
1:             List<Unfiltered> merged = merge(sources, iterations);
1:     
1:             if (ITEMS <= 20)
1:                 System.out.println("results in");
1:             if (ITEMS <= 20)
0:                 dumpList(merged);
0:             verifyEquivalent(sources, merged);
0:             verifyValid(merged);
1:             if (reversed)
1:             {
1:                 Collections.reverse(merged);
0:                 this.reversed = false;
0:                 verifyValid(merged);
1:             }
1:         }
1:     }
1: 
1:     private List<Unfiltered> merge(List<List<Unfiltered>> sources, boolean iterations)
1:     {
0:         List<UnfilteredRowIterator> us = sources.stream().map(l -> new Source(l.iterator())).collect(Collectors.toList());
1:         List<Unfiltered> merged = new ArrayList<>();
0:         Iterators.addAll(merged, safeIterator(mergeIterators(us, iterations)));
1:         return merged;
1:     }
1: 
1:     public UnfilteredRowIterator mergeIterators(List<UnfilteredRowIterator> us, boolean iterations)
1:     {
1:         int now = FBUtilities.nowInSeconds();
1:         if (iterations)
1:         {
1:             UnfilteredRowIterator mi = us.get(0);
1:             int i;
1:             for (i = 1; i + 2 <= ITERATORS; i += 2)
1:                 mi = UnfilteredRowIterators.merge(ImmutableList.of(mi, us.get(i), us.get(i+1)), now);
1:             if (i + 1 <= ITERATORS)
1:                 mi = UnfilteredRowIterators.merge(ImmutableList.of(mi, us.get(i)), now);
1:             return mi;
1:         }
1:         else
1:         {
1:             return UnfilteredRowIterators.merge(us, now);
1:         }
1:     }
1: 
1:     @SuppressWarnings("unused")
1:     private List<Unfiltered> generateSource(Random r, Function<Integer, Integer> timeGenerator)
1:     {
1:         int[] positions = new int[ITEMS + 1];
1:         for (int i=0; i<ITEMS; ++i)
1:             positions[i] = r.nextInt(RANGE);
1:         positions[ITEMS] = RANGE;
1:         Arrays.sort(positions);
1: 
1:         List<Unfiltered> content = new ArrayList<>(ITEMS);
1:         int prev = -1;
1:         for (int i=0; i<ITEMS; ++i)
1:         {
1:             int pos = positions[i];
1:             int sz = positions[i + 1] - pos;
1:             if (sz == 0 && pos == prev)
1:                 // Filter out more than two of the same position.
1:                 continue;
1:             if (r.nextBoolean() || pos == prev)
1:             {
1:                 int span;
1:                 boolean includesStart;
1:                 boolean includesEnd;
1:                 if (pos > prev)
1:                 {
1:                     span = r.nextInt(sz + 1);
1:                     includesStart = span > 0 ? r.nextBoolean() : true;
1:                     includesEnd = span > 0 ? r.nextBoolean() : true;
1:                 }
1:                 else
1:                 {
1:                     span = 1 + r.nextInt(sz);
1:                     includesStart = false;
1:                     includesEnd = r.nextBoolean();
1:                 }
1:                 int deltime = r.nextInt(DEL_RANGE);
0:                 DeletionTime dt = new SimpleDeletionTime(deltime, deltime);
1:                 content.add(new RangeTombstoneBoundMarker(boundFor(pos, true, includesStart), dt));
1:                 content.add(new RangeTombstoneBoundMarker(boundFor(pos + span, false, includesEnd), dt));
1:                 prev = pos + span - (includesEnd ? 0 : 1);
1:             }
1:             else
1:             {
1:                 content.add(emptyRowAt(pos, timeGenerator));
1:                 prev = pos;
1:             }
1:         }
1: 
1:         attachBoundaries(content);
1:         if (reversed)
1:         {
1:             Collections.reverse(content);
1:         }
1:         verifyValid(content);
1:         if (ITEMS <= 20)
1:             dumpList(content);
1:         return content;
1:     }
1: 
1:     static void attachBoundaries(List<Unfiltered> content)
1:     {
1:         int di = 0;
1:         RangeTombstoneMarker prev = null;
1:         for (int si = 0; si < content.size(); ++si)
1:         {
1:             Unfiltered currUnfiltered = content.get(si);
1:             RangeTombstoneMarker curr = currUnfiltered.kind() == Kind.RANGE_TOMBSTONE_MARKER ?
1:                                         (RangeTombstoneMarker) currUnfiltered :
1:                                         null;
1:             if (prev != null && curr != null && prev.isClose(false) && curr.isOpen(false) && prev.clustering().invert().equals(curr.clustering()))
1:             {
1:                 // Join. Prefer not to use merger to check its correctness.
0:                 RangeTombstone.Bound b = prev.clustering();
0:                 b = b.withNewKind(b.isInclusive() ? RangeTombstone.Bound.Kind.INCL_END_EXCL_START_BOUNDARY : RangeTombstone.Bound.Kind.EXCL_END_INCL_START_BOUNDARY);
0:                 prev = new RangeTombstoneBoundaryMarker(b, prev.closeDeletionTime(false), curr.openDeletionTime(false));
1:                 currUnfiltered = prev;
1:                 --di;
1:             }
1:             content.set(di++, currUnfiltered);
1:             prev = curr;
1:         }
1:         for (int pos = content.size() - 1; pos >= di; --pos)
1:             content.remove(pos);
1:     }
1: 
1:     void verifyValid(List<Unfiltered> list)
1:     {
1:         int reversedAsMultiplier = reversed ? -1 : 1;
1:         try {
1:             RangeTombstoneMarker prev = null;
1:             Unfiltered prevUnfiltered = null;
1:             for (Unfiltered unfiltered : list)
1:             {
1:                 Assert.assertTrue("Order violation prev " + str(prevUnfiltered) + " curr " + str(unfiltered),
1:                                   prevUnfiltered == null || comparator.compare(prevUnfiltered, unfiltered) * reversedAsMultiplier < 0);
1:                 prevUnfiltered = unfiltered;
1: 
1:                 if (unfiltered.kind() == Kind.RANGE_TOMBSTONE_MARKER)
1:                 {
1:                     RangeTombstoneMarker curr = (RangeTombstoneMarker) unfiltered;
1:                     if (prev != null)
1:                     {
1:                         if (curr.isClose(reversed))
1:                         {
1:                             Assert.assertTrue(str(unfiltered) + " follows another close marker " + str(prev), prev.isOpen(reversed));
1:                             Assert.assertEquals("Deletion time mismatch for open " + str(prev) + " and close " + str(unfiltered),
1:                                                 prev.openDeletionTime(reversed),
1:                                                 curr.closeDeletionTime(reversed));
1:                         }
1:                         else
1:                             Assert.assertFalse(str(curr) + " follows another open marker " + str(prev), prev.isOpen(reversed));
1:                     }
1: 
1:                     prev = curr;
1:                 }
1:             }
1:             Assert.assertFalse("Cannot end in open marker " + str(prev), prev != null && prev.isOpen(reversed));
1: 
1:         } catch (AssertionError e) {
1:             System.out.println(e);
1:             dumpList(list);
1:             throw e;
1:         }
1:     }
1: 
0:     void verifyEquivalent(List<List<Unfiltered>> sources, List<Unfiltered> merged)
1:     {
1:         try
1:         {
1:             for (int i=0; i<RANGE; ++i)
1:             {
0:                 Clusterable c = clusteringFor(i);
1:                 DeletionTime dt = DeletionTime.LIVE;
1:                 for (List<Unfiltered> source : sources)
1:                 {
1:                     dt = deletionFor(c, source, dt);
1:                 }
0:                 Assert.assertEquals("Deletion time mismatch for position " + str(c), dt, deletionFor(c, merged));
1:                 if (dt == DeletionTime.LIVE)
1:                 {
1:                     Optional<Unfiltered> sourceOpt = sources.stream().map(source -> rowFor(c, source)).filter(x -> x != null).findAny();
1:                     Unfiltered mergedRow = rowFor(c, merged);
0:                     Assert.assertEquals("Content mismatch for position " + str(c), str(sourceOpt.orElse(null)), str(mergedRow));
1:                 }
1:             }
1:         }
1:         catch (AssertionError e)
1:         {
1:             System.out.println(e);
1:             for (List<Unfiltered> list : sources)
1:                 dumpList(list);
1:             System.out.println("merged");
0:             dumpList(merged);
1:             throw e;
1:         }
1:     }
1: 
1:     private Unfiltered rowFor(Clusterable pointer, List<Unfiltered> list)
1:     {
1:         int index = Collections.binarySearch(list, pointer, reversed ? comparator.reversed() : comparator);
1:         return index >= 0 ? list.get(index) : null;
1:     }
1: 
1:     DeletionTime deletionFor(Clusterable pointer, List<Unfiltered> list)
1:     {
1:         return deletionFor(pointer, list, DeletionTime.LIVE);
1:     }
1: 
1:     DeletionTime deletionFor(Clusterable pointer, List<Unfiltered> list, DeletionTime def)
1:     {
1:         if (list.isEmpty())
1:             return def;
1: 
1:         int index = Collections.binarySearch(list, pointer, reversed ? comparator.reversed() : comparator);
1:         if (index < 0)
1:             index = -1 - index;
1:         else
1:         {
1:             Row row = (Row) list.get(index);
0:             if (row.deletion() != null && row.deletion().supersedes(def))
0:                 def = row.deletion();
1:         }
1: 
1:         if (index >= list.size())
1:             return def;
1: 
1:         while (--index >= 0)
1:         {
1:             Unfiltered unfiltered = list.get(index);
1:             if (unfiltered.kind() == Kind.ROW)
1:                 continue;
1:             RangeTombstoneMarker lower = (RangeTombstoneMarker) unfiltered;
1:             if (!lower.isOpen(reversed))
1:                 return def;
1:             return lower.openDeletionTime(reversed).supersedes(def) ? lower.openDeletionTime(reversed) : def;
1:         }
1:         return def;
1:     }
1: 
0:     private static Bound boundFor(int pos, boolean start, boolean inclusive)
1:     {
0:         return Bound.create(Bound.boundKind(start, inclusive), new ByteBuffer[] {Int32Type.instance.decompose(pos)});
1:     }
1: 
0:     private static SimpleClustering clusteringFor(int i)
1:     {
0:         return new SimpleClustering(Int32Type.instance.decompose(i));
1:     }
1: 
1:     static Row emptyRowAt(int pos, Function<Integer, Integer> timeGenerator)
1:     {
1:         final Clustering clustering = clusteringFor(pos);
0:         final LivenessInfo live = SimpleLivenessInfo.forUpdate(timeGenerator.apply(pos), 0, nowInSec, metadata);
0:         return emptyRowAt(clustering, live, DeletionTime.LIVE);
1:     }
1: 
0:     public static class TestCell extends AbstractCell
1:     {
0:         private final ColumnDefinition column;
0:         private final ByteBuffer value;
0:         private final LivenessInfo info;
1: 
0:         public TestCell(ColumnDefinition column, ByteBuffer value, LivenessInfo info)
1:         {
0:             this.column = column;
0:             this.value = value;
0:             this.info = info.takeAlias();
1:         }
1: 
1:         @Override
0:         public ColumnDefinition column()
1:         {
0:             return column;
1:         }
1: 
1:         @Override
0:         public boolean isCounterCell()
1:         {
0:             return false;
1:         }
1: 
1:         @Override
0:         public ByteBuffer value()
1:         {
0:             return value;
1:         }
1: 
1:         @Override
0:         public LivenessInfo livenessInfo()
1:         {
0:             return info;
1:         }
1: 
1:         @Override
0:         public CellPath path()
1:         {
0:             return null;
1:         }
1:     }
1: 
0:     static Row emptyRowAt(final Clustering clustering, final LivenessInfo live, final DeletionTime deletion)
1:     {
0:         final ColumnDefinition columnDef = metadata.getColumnDefinition(new ColumnIdentifier("data", true));
0:         final Cell cell = new TestCell(columnDef, clustering.get(0), live);
1: 
0:         return new AbstractRow()
1:         {
1:             @Override
0:             public Columns columns()
1:             {
0:                 return Columns.of(columnDef);
1:             }
1: 
1:             @Override
0:             public LivenessInfo primaryKeyLivenessInfo()
1:             {
0:                 return live;
1:             }
1: 
1:             @Override
0:             public DeletionTime deletion()
1:             {
0:                 return deletion;
1:             }
1: 
1:             @Override
0:             public boolean isEmpty()
1:             {
0:                 return true;
1:             }
1: 
1:             @Override
0:             public boolean hasComplexDeletion()
1:             {
0:                 return false;
1:             }
1: 
1:             @Override
0:             public Clustering clustering()
1:             {
0:                 return clustering;
1:             }
1: 
1:             @Override
0:             public Cell getCell(ColumnDefinition c)
1:             {
0:                 return c == columnDef ? cell : null;
1:             }
1: 
1:             @Override
0:             public Cell getCell(ColumnDefinition c, CellPath path)
1:             {
0:                 return null;
1:             }
1: 
1:             @Override
0:             public Iterator<Cell> getCells(ColumnDefinition c)
1:             {
0:                 return Iterators.singletonIterator(cell);
1:             }
1: 
1:             @Override
0:             public DeletionTime getDeletion(ColumnDefinition c)
1:             {
0:                 return DeletionTime.LIVE;
1:             }
1: 
1:             @Override
0:             public Iterator<Cell> iterator()
1:             {
0:                 return Iterators.<Cell>emptyIterator();
1:             }
1: 
1:             @Override
0:             public SearchIterator<ColumnDefinition, ColumnData> searchIterator()
1:             {
0:                 return new SearchIterator<ColumnDefinition, ColumnData>()
1:                 {
1:                     @Override
0:                     public boolean hasNext()
1:                     {
0:                         return false;
1:                     }
1: 
1:                     @Override
0:                     public ColumnData next(ColumnDefinition column)
1:                     {
0:                         return null;
1:                     }
0:                 };
1:             }
1: 
1:             @Override
0:             public Kind kind()
1:             {
0:                 return Unfiltered.Kind.ROW;
1:             }
1: 
1:             @Override
0:             public Row takeAlias()
1:             {
0:                 return this;
1:             }
1: 
1:             @Override
0:             public String toString()
1:             {
0:                 return Int32Type.instance.getString(clustering.get(0));
1:             }
0:         };
1: 
1:     }
1: 
1:     private void dumpList(List<Unfiltered> list)
1:     {
1:         for (Unfiltered u : list)
1:             System.out.print(str(u) + " ");
1:         System.out.println();
1:     }
1: 
1:     private String str(Clusterable curr)
1:     {
1:         if (curr == null)
1:             return "null";
1:         String val = Int32Type.instance.getString(curr.clustering().get(0));
1:         if (curr instanceof RangeTombstoneMarker)
1:         {
1:             RangeTombstoneMarker marker = (RangeTombstoneMarker) curr;
1:             if (marker.isClose(reversed))
1:                 val = "[" + marker.closeDeletionTime(reversed).markedForDeleteAt() + "]" + (marker.closeIsInclusive(reversed) ? "<=" : "<") + val;
1:             if (marker.isOpen(reversed)) 
1:                 val = val + (marker.openIsInclusive(reversed) ? "<=" : "<") + "[" + marker.openDeletionTime(reversed).markedForDeleteAt() + "]";
1:         }
1:         return val;
1:     }
1: 
1:     class Source extends AbstractUnfilteredRowIterator implements UnfilteredRowIterator
1:     {
1:         Iterator<Unfiltered> content;
1: 
1:         protected Source(Iterator<Unfiltered> content)
1:         {
1:             super(UnfilteredRowIteratorsMergeTest.metadata,
1:                   UnfilteredRowIteratorsMergeTest.partitionKey,
1:                   UnfilteredRowIteratorsMergeTest.partitionLevelDeletion,
1:                   UnfilteredRowIteratorsMergeTest.metadata.partitionColumns(),
1:                   null,
1:                   reversed,
0:                   RowStats.NO_STATS);
1:             this.content = content;
1:         }
1: 
1:         @Override
1:         protected Unfiltered computeNext()
1:         {
1:             return content.hasNext() ? content.next() : endOfData();
1:         }
1:     }
1: 
0:     static RangeTombstoneMarker safeMarker(RangeTombstoneMarker marker)
1:     {
0:         RangeTombstoneMarker.Builder writer = new RangeTombstoneMarker.Builder(1);
0:         marker.copyTo(writer);
0:         return writer.build();
1:     }
1: 
0:     private static Row safeRow(Row row)
1:     {
0:         return emptyRowAt(new SimpleClustering(row.clustering().get(0)), row.primaryKeyLivenessInfo(), row.deletion());
1:     }
1:     
0:     public static UnfilteredRowIterator safeIterator(UnfilteredRowIterator iterator)
1:     {
0:         return new WrappingUnfilteredRowIterator(iterator)
1:         {
1:             @Override
0:             public Unfiltered next()
1:             {
0:                 Unfiltered next = super.next();
0:                 return next.kind() == Unfiltered.Kind.ROW
0:                      ? safeRow((Row) next)
0:                      : safeMarker((RangeTombstoneMarker) next);
1:             }
0:         };
1:     }
1: 
1:     public void testForInput(String... inputs)
1:     {
1:         List<List<Unfiltered>> sources = new ArrayList<>();
1:         for (String input : inputs)
1:         {
0:             List<Unfiltered> source = parse(input);
0:             attachBoundaries(source);
0:             dumpList(source);
0:             verifyValid(source);
1:             sources.add(source);
1:         }
1: 
1:         List<Unfiltered> merged = merge(sources, false);
1:         System.out.println("Merge to:");
0:         dumpList(merged);
0:         verifyEquivalent(sources, merged);
0:         verifyValid(merged);
1:         System.out.println();
1:     }
1: 
1:     List<Unfiltered> parse(String input)
1:     {
1:         String[] split = input.split(" ");
1:         Pattern open = Pattern.compile("(\\d+)<(=)?\\[(\\d+)\\]");
1:         Pattern close = Pattern.compile("\\[(\\d+)\\]<(=)?(\\d+)");
1:         Pattern row = Pattern.compile("(\\d+)(\\[(\\d+)\\])?");
1:         List<Unfiltered> out = new ArrayList<>(split.length);
1:         for (String s : split)
1:         {
1:             Matcher m = open.matcher(s);
1:             if (m.matches())
1:             {
1:                 out.add(openMarker(Integer.parseInt(m.group(1)), Integer.parseInt(m.group(3)), m.group(2) != null));
1:                 continue;
1:             }
1:             m = close.matcher(s);
1:             if (m.matches())
1:             {
1:                 out.add(closeMarker(Integer.parseInt(m.group(3)), Integer.parseInt(m.group(1)), m.group(2) != null));
1:                 continue;
1:             }
1:             m = row.matcher(s);
1:             if (m.matches())
1:             {
1:                 int live = m.group(3) != null ? Integer.parseInt(m.group(3)) : DEL_RANGE;
1:                 out.add(emptyRowAt(Integer.parseInt(m.group(1)), x -> live));
1:                 continue;
1:             }
1:             Assert.fail("Can't parse " + s);
1:         }
1:         return out;
1:     }
1: 
1:     private RangeTombstoneMarker openMarker(int pos, int delTime, boolean inclusive)
1:     {
1:         return marker(pos, delTime, true, inclusive);
1:     }
1: 
1:     private RangeTombstoneMarker closeMarker(int pos, int delTime, boolean inclusive)
1:     {
1:         return marker(pos, delTime, false, inclusive);
1:     }
1: 
1:     private RangeTombstoneMarker marker(int pos, int delTime, boolean isStart, boolean inclusive)
1:     {
0:         return new RangeTombstoneBoundMarker(Bound.create(Bound.boundKind(isStart, inclusive),
0:                                                           new ByteBuffer[] {clusteringFor(pos).get(0)}),
0:                                              new SimpleDeletionTime(delTime, delTime));
1:     }
1: }
============================================================================