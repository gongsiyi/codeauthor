1:5d98581: /*
1:5d98581: * Licensed to the Apache Software Foundation (ASF) under one
1:5d98581: * or more contributor license agreements.  See the NOTICE file
1:5d98581: * distributed with this work for additional information
1:5d98581: * regarding copyright ownership.  The ASF licenses this file
1:5d98581: * to you under the Apache License, Version 2.0 (the
1:5d98581: * "License"); you may not use this file except in compliance
1:5d98581: * with the License.  You may obtain a copy of the License at
1:5d98581: *
1:5d98581: *    http://www.apache.org/licenses/LICENSE-2.0
1:5d98581: *
1:5d98581: * Unless required by applicable law or agreed to in writing,
1:5d98581: * software distributed under the License is distributed on an
1:5d98581: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:5d98581: * KIND, either express or implied.  See the License for the
1:5d98581: * specific language governing permissions and limitations
1:5d98581: * under the License.
1:5d98581: */
1:5d98581: package org.apache.cassandra.db.marshal;
2:5d98581: 
1:5d98581: import java.nio.ByteBuffer;
1:a991b64: import java.nio.charset.CharacterCodingException;
1:d2a3827: import java.util.*;
1:5d98581: 
1:d2a3827: import org.junit.BeforeClass;
1:5d98581: import org.junit.Test;
1:5d98581: import static org.junit.Assert.fail;
1:5d5207b: import static org.junit.Assert.assertEquals;
1:5d98581: 
1:438acfc: import org.apache.cassandra.SchemaLoader;
1:5d98581: import org.apache.cassandra.Util;
1:a991b64: import org.apache.cassandra.config.ColumnDefinition;
1:a991b64: import org.apache.cassandra.db.*;
1:a991b64: import org.apache.cassandra.db.rows.Cell;
1:a991b64: import org.apache.cassandra.db.rows.Row;
1:e51f83b: import org.apache.cassandra.db.partitions.ImmutableBTreePartition;
1:3a2faf9: import org.apache.cassandra.exceptions.ConfigurationException;
1:3a2faf9: import org.apache.cassandra.exceptions.SyntaxException;
1:31e3f61: import org.apache.cassandra.schema.KeyspaceParams;
1:fc8b76f: import org.apache.cassandra.serializers.MarshalException;
1:5d98581: import org.apache.cassandra.utils.*;
1:5d98581: 
1:d2a3827: public class CompositeTypeTest
3:5d98581: {
1:d2a3827:     private static final String KEYSPACE1 = "CompositeTypeTest";
1:d2a3827:     private static final String CF_STANDARDCOMPOSITE = "StandardComposite";
1:5d98581:     private static final CompositeType comparator;
1:5d98581:     static
1:5d98581:     {
1:e86469e:         List<AbstractType<?>> subComparators = new ArrayList<AbstractType<?>>();
1:5d98581:         subComparators.add(BytesType.instance);
1:5d98581:         subComparators.add(TimeUUIDType.instance);
1:5d98581:         subComparators.add(IntegerType.instance);
1:5d98581:         comparator = CompositeType.getInstance(subComparators);
3:5d98581:     }
1:5d98581: 
1:5d98581:     private static final int UUID_COUNT = 3;
1:5d98581:     private static final UUID[] uuids = new UUID[UUID_COUNT];
1:5d98581:     static
1:5d98581:     {
1:5d98581:         for (int i = 0; i < UUID_COUNT; ++i)
1:7442fc0:             uuids[i] = UUIDGen.getTimeUUID();
1:5d98581:     }
1:5d98581: 
1:d2a3827:     @BeforeClass
1:d2a3827:     public static void defineSchema() throws ConfigurationException
1:5d98581:     {
1:d2a3827:         AbstractType<?> composite = CompositeType.getInstance(Arrays.asList(new AbstractType<?>[]{BytesType.instance, TimeUUIDType.instance, IntegerType.instance}));
1:d2a3827:         SchemaLoader.prepareServer();
1:d2a3827:         SchemaLoader.createKeyspace(KEYSPACE1,
1:31e3f61:                                     KeyspaceParams.simple(1),
1:a991b64:                                     SchemaLoader.denseCFMD(KEYSPACE1, CF_STANDARDCOMPOSITE, composite));
1:5d98581:     }
1:5d98581: 
1:5d98581:     @Test
1:5d98581:     public void testEndOfComponent()
1:5d98581:     {
1:5d98581:         ByteBuffer[] cnames = {
1:5d98581:             createCompositeKey("test1", uuids[0], -1, false),
1:5d98581:             createCompositeKey("test1", uuids[1], 24, false),
1:5d98581:             createCompositeKey("test1", uuids[1], 42, false),
1:5d98581:             createCompositeKey("test1", uuids[1], 83, false),
1:5d98581:             createCompositeKey("test1", uuids[2], -1, false),
1:5d98581:             createCompositeKey("test1", uuids[2], 42, false),
1:5d98581:         };
1:5d98581: 
1:5d98581:         ByteBuffer start = createCompositeKey("test1", uuids[1], -1, false);
1:5d98581:         ByteBuffer stop = createCompositeKey("test1", uuids[1], -1, true);
1:5d98581: 
1:5d98581:         for (int i = 0; i < 1; ++i)
1:5d98581:         {
1:5d98581:             assert comparator.compare(start, cnames[i]) > 0;
1:5d98581:             assert comparator.compare(stop, cnames[i]) > 0;
1:5d98581:         }
1:5d98581:         for (int i = 1; i < 4; ++i)
1:5d98581:         {
1:5d98581:             assert comparator.compare(start, cnames[i]) < 0;
1:5d98581:             assert comparator.compare(stop, cnames[i]) > 0;
1:5d98581:         }
1:5d98581:         for (int i = 4; i < cnames.length; ++i)
1:5d98581:         {
1:5d98581:             assert comparator.compare(start, cnames[i]) < 0;
1:5d98581:             assert comparator.compare(stop, cnames[i]) < 0;
1:5d98581:         }
1:5d98581:     }
1:5d98581: 
1:5d98581:     @Test
1:5d98581:     public void testGetString()
1:5d98581:     {
1:5d98581:         String test1Hex = ByteBufferUtil.bytesToHex(ByteBufferUtil.bytes("test1"));
1:5d98581:         ByteBuffer key = createCompositeKey("test1", uuids[1], 42, false);
1:5d98581:         assert comparator.getString(key).equals(test1Hex + ":" + uuids[1] + ":42");
1:5d98581: 
1:5d98581:         key = createCompositeKey("test1", uuids[1], -1, true);
1:5d98581:         assert comparator.getString(key).equals(test1Hex + ":" + uuids[1] + ":!");
1:5d98581:     }
1:5d98581: 
1:5d98581:     @Test
1:5d98581:     public void testFromString()
1:5d98581:     {
1:5d98581:         String test1Hex = ByteBufferUtil.bytesToHex(ByteBufferUtil.bytes("test1"));
1:5d98581:         ByteBuffer key = createCompositeKey("test1", uuids[1], 42, false);
1:5d98581:         assert key.equals(comparator.fromString(test1Hex + ":" + uuids[1] + ":42"));
1:5d98581: 
1:5d98581:         key = createCompositeKey("test1", uuids[1], -1, true);
1:5d98581:         assert key.equals(comparator.fromString(test1Hex + ":" + uuids[1] + ":!"));
1:5d98581:     }
1:5d98581: 
1:5d98581:     @Test
1:5d98581:     public void testValidate()
1:5d98581:     {
1:5d98581:         ByteBuffer key = createCompositeKey("test1", uuids[1], 42, false);
1:5d98581:         comparator.validate(key);
1:5d98581: 
1:5d98581:         key = createCompositeKey("test1", null, -1, false);
1:5d98581:         comparator.validate(key);
1:5d98581: 
1:5d98581:         key = createCompositeKey("test1", uuids[2], -1, true);
1:5d98581:         comparator.validate(key);
1:5d98581: 
1:5d98581:         key.get(); // make sure we're not aligned anymore
2:5d98581:         try
1:5d98581:         {
1:5d98581:             comparator.validate(key);
1:5d98581:             fail("Should not validate");
1:5d98581:         }
1:5d98581:         catch (MarshalException e) {}
1:5d98581: 
1:5d98581:         key = ByteBuffer.allocate(3 + "test1".length() + 3 + 14);
1:5d98581:         key.putShort((short) "test1".length());
1:5d98581:         key.put(ByteBufferUtil.bytes("test1"));
1:5d98581:         key.put((byte) 0);
1:5d98581:         key.putShort((short) 14);
1:5d98581:         key.rewind();
1:5d98581:         try
1:5d98581:         {
1:5d98581:             comparator.validate(key);
1:5d98581:             fail("Should not validate");
1:5d98581:         }
1:5d98581:         catch (MarshalException e)
1:5d98581:         {
1:20c0baf:             assert e.toString().contains("should be 16 or 0 bytes");
1:5d98581:         }
1:5d98581: 
1:5d98581:         key = createCompositeKey("test1", UUID.randomUUID(), 42, false);
1:5d98581:         try
1:5d98581:         {
1:5d98581:             comparator.validate(key);
1:5d98581:             fail("Should not validate");
1:5d98581:         }
1:5d98581:         catch (MarshalException e)
1:5d98581:         {
1:5d98581:             assert e.toString().contains("Invalid version for TimeUUID type");
1:5d98581:         }
1:5d98581:     }
1:5d98581: 
1:5d98581:     @Test
1:5d98581:     public void testFullRound() throws Exception
1:5d98581:     {
1:d2a3827:         Keyspace keyspace = Keyspace.open(KEYSPACE1);
1:d2a3827:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(CF_STANDARDCOMPOSITE);
1:5d98581: 
1:5d98581:         ByteBuffer cname1 = createCompositeKey("test1", null, -1, false);
1:5d98581:         ByteBuffer cname2 = createCompositeKey("test1", uuids[0], 24, false);
1:5d98581:         ByteBuffer cname3 = createCompositeKey("test1", uuids[0], 42, false);
1:5d98581:         ByteBuffer cname4 = createCompositeKey("test2", uuids[0], -1, false);
1:5d98581:         ByteBuffer cname5 = createCompositeKey("test2", uuids[1], 42, false);
1:5d98581: 
1:5d98581:         ByteBuffer key = ByteBufferUtil.bytes("k");
1:5d98581: 
1:a991b64:         long ts = FBUtilities.timestampMicros();
1:a991b64:         new RowUpdateBuilder(cfs.metadata, ts, key).clustering(cname5).add("val", "cname5").build().applyUnsafe();
1:a991b64:         new RowUpdateBuilder(cfs.metadata, ts, key).clustering(cname1).add("val", "cname1").build().applyUnsafe();
1:a991b64:         new RowUpdateBuilder(cfs.metadata, ts, key).clustering(cname4).add("val", "cname4").build().applyUnsafe();
1:a991b64:         new RowUpdateBuilder(cfs.metadata, ts, key).clustering(cname2).add("val", "cname2").build().applyUnsafe();
1:a991b64:         new RowUpdateBuilder(cfs.metadata, ts, key).clustering(cname3).add("val", "cname3").build().applyUnsafe();
1:5d98581: 
1:a991b64:         ColumnDefinition cdef = cfs.metadata.getColumnDefinition(ByteBufferUtil.bytes("val"));
1:5d98581: 
1:e51f83b:         ImmutableBTreePartition readPartition = Util.getOnlyPartitionUnfiltered(Util.cmd(cfs, key).build());
1:a991b64:         Iterator<Row> iter = readPartition.iterator();
1:a991b64: 
1:a991b64:         compareValues(iter.next().getCell(cdef), "cname1");
1:a991b64:         compareValues(iter.next().getCell(cdef), "cname2");
1:a991b64:         compareValues(iter.next().getCell(cdef), "cname3");
1:a991b64:         compareValues(iter.next().getCell(cdef), "cname4");
1:a991b64:         compareValues(iter.next().getCell(cdef), "cname5");
1:a991b64:     }
1:a991b64:     private void compareValues(Cell c, String r) throws CharacterCodingException
1:a991b64:     {
1:a991b64:         assert ByteBufferUtil.string(c.value()).equals(r) : "Expected: {" + ByteBufferUtil.string(c.value()) + "} got: {" + r + "}";
1:5d98581:     }
1:5d98581: 
1:5d98581:     @Test
1:5d98581:     public void testEmptyParametersNotallowed()
1:5d98581:     {
1:5d98581:         try
1:5d98581:         {
1:5d98581:             TypeParser.parse("CompositeType");
1:5d98581:             fail("Shouldn't work");
1:5d98581:         }
1:a991b64:         catch (ConfigurationException e) {}
1:a991b64:         catch (SyntaxException e) {}
1:5d98581: 
1:5d98581:         try
1:5d98581:         {
1:5d98581:             TypeParser.parse("CompositeType()");
1:5d98581:             fail("Shouldn't work");
1:5d98581:         }
1:a991b64:         catch (ConfigurationException e) {}
1:a991b64:         catch (SyntaxException e) {}
1:5d98581:     }
1:5d98581: 
1:0fdab63:     @Test
1:0fdab63:     public void testCompatibility() throws Exception
1:0fdab63:     {
1:0fdab63:         assert TypeParser.parse("CompositeType(IntegerType, BytesType)").isCompatibleWith(TypeParser.parse("CompositeType(IntegerType)"));
1:0fdab63:         assert TypeParser.parse("CompositeType(IntegerType, BytesType)").isCompatibleWith(TypeParser.parse("CompositeType(IntegerType, BytesType)"));
1:0fdab63:         assert TypeParser.parse("CompositeType(BytesType, BytesType)").isCompatibleWith(TypeParser.parse("CompositeType(AsciiType, BytesType)"));
1:0fdab63: 
1:0fdab63:         assert !TypeParser.parse("CompositeType(IntegerType)").isCompatibleWith(TypeParser.parse("CompositeType(IntegerType, BytesType)"));
1:0fdab63:         assert !TypeParser.parse("CompositeType(IntegerType)").isCompatibleWith(TypeParser.parse("CompositeType(BytesType)"));
1:0fdab63:     }
1:5d98581: 
1:5d5207b:     @Test
1:5d5207b:     public void testEscapeUnescape()
1:5d5207b:     {
1:5d5207b:         List<AbstractType<?>> subComparators = new ArrayList<AbstractType<?>>(){{;
1:5d5207b:             add(UTF8Type.instance);
1:5d5207b:             add(UTF8Type.instance);
1:5d5207b:         }};
1:5d5207b:         CompositeType comp = CompositeType.getInstance(subComparators);
1:5d5207b: 
1:5d5207b:         String[][] inputs = new String[][]{
1:5d5207b:             new String[]{ "foo", "bar" },
1:5d5207b:             new String[]{ "", "" },
1:5d5207b:             new String[]{ "foo\\", "bar" },
1:5d5207b:             new String[]{ "foo\\:", "bar" },
1:5d5207b:             new String[]{ "foo:", "bar" },
1:5d5207b:             new String[]{ "foo", "b:ar" },
1:5d5207b:             new String[]{ "foo!", "b:ar" },
1:5d5207b:         };
1:5d5207b: 
1:5d5207b:         for (String[] input : inputs)
1:5d5207b:         {
1:5d5207b:             CompositeType.Builder builder = new CompositeType.Builder(comp);
1:5d5207b:             for (String part : input)
1:5d5207b:                 builder.add(UTF8Type.instance.fromString(part));
1:5d5207b: 
1:5d5207b:             ByteBuffer value = comp.fromString(comp.getString(builder.build()));
1:5d5207b:             ByteBuffer[] splitted = comp.split(value);
1:5d5207b:             for (int i = 0; i < splitted.length; i++)
1:5d5207b:                 assertEquals(input[i], UTF8Type.instance.getString(splitted[i]));
1:5d5207b:         }
1:5d5207b:     }
1:5d5207b: 
1:5d98581:     private ByteBuffer createCompositeKey(String s, UUID uuid, int i, boolean lastIsOne)
1:5d98581:     {
1:5d98581:         ByteBuffer bytes = ByteBufferUtil.bytes(s);
1:5d98581:         int totalSize = 0;
1:5d98581:         if (s != null)
1:5d98581:         {
1:5d98581:             totalSize += 2 + bytes.remaining() + 1;
1:5d98581:             if (uuid != null)
1:5d98581:             {
1:5d98581:                 totalSize += 2 + 16 + 1;
1:5d98581:                 if (i != -1)
1:5d98581:                 {
1:5d98581:                     totalSize += 2 + 1 + 1;
1:5d98581:                 }
1:5d98581:             }
1:5d98581:         }
1:5d98581: 
1:5d98581:         ByteBuffer bb = ByteBuffer.allocate(totalSize);
1:5d98581: 
1:5d98581:         if (s != null)
1:5d98581:         {
1:5d98581:             bb.putShort((short) bytes.remaining());
1:5d98581:             bb.put(bytes);
1:5d98581:             bb.put(uuid == null && lastIsOne ? (byte)1 : (byte)0);
1:5d98581:             if (uuid != null)
1:5d98581:             {
1:5d98581:                 bb.putShort((short) 16);
1:5d98581:                 bb.put(UUIDGen.decompose(uuid));
1:5d98581:                 bb.put(i == -1 && lastIsOne ? (byte)1 : (byte)0);
1:5d98581:                 if (i != -1)
1:5d98581:                 {
1:5d98581:                     // We are putting a byte only because our test use ints that fit in a byte *and* IntegerType.fromString() will
1:5d98581:                     // return something compatible (i.e, putting a full int here would break 'fromStringTest')
1:5d98581:                     bb.putShort((short) 1);
1:5d98581:                     bb.put((byte)i);
1:5d98581:                     bb.put(lastIsOne ? (byte)1 : (byte)0);
1:5d98581:                 }
1:5d98581:             }
1:5d98581:         }
1:5d98581:         bb.rewind();
1:5d98581:         return bb;
1:5d98581:     }
1:5d98581: }
============================================================================
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:e51f83b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.partitions.ImmutableBTreePartition;
/////////////////////////////////////////////////////////////////////////
1:         ImmutableBTreePartition readPartition = Util.getOnlyPartitionUnfiltered(Util.cmd(cfs, key).build());
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:31e3f61
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.schema.KeyspaceParams;
/////////////////////////////////////////////////////////////////////////
1:                                     KeyspaceParams.simple(1),
commit:6bbb13b
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation("Keyspace1", key);
/////////////////////////////////////////////////////////////////////////
0:     private void addColumn(Mutation rm, ByteBuffer cname)
commit:0e96e58
/////////////////////////////////////////////////////////////////////////
0:         Keyspace keyspace = Keyspace.open("Keyspace1");
0:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfName);
commit:1f7628c
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(Util.dk("k"), cfName, System.currentTimeMillis()));
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: import java.nio.charset.CharacterCodingException;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.ColumnDefinition;
1: import org.apache.cassandra.db.*;
1: import org.apache.cassandra.db.rows.Cell;
1: import org.apache.cassandra.db.rows.Row;
0: import org.apache.cassandra.db.partitions.ArrayBackedPartition;
0: import org.apache.cassandra.service.StorageService;
/////////////////////////////////////////////////////////////////////////
1:                                     SchemaLoader.denseCFMD(KEYSPACE1, CF_STANDARDCOMPOSITE, composite));
/////////////////////////////////////////////////////////////////////////
1:         long ts = FBUtilities.timestampMicros();
1:         new RowUpdateBuilder(cfs.metadata, ts, key).clustering(cname5).add("val", "cname5").build().applyUnsafe();
1:         new RowUpdateBuilder(cfs.metadata, ts, key).clustering(cname1).add("val", "cname1").build().applyUnsafe();
1:         new RowUpdateBuilder(cfs.metadata, ts, key).clustering(cname4).add("val", "cname4").build().applyUnsafe();
1:         new RowUpdateBuilder(cfs.metadata, ts, key).clustering(cname2).add("val", "cname2").build().applyUnsafe();
1:         new RowUpdateBuilder(cfs.metadata, ts, key).clustering(cname3).add("val", "cname3").build().applyUnsafe();
1:         ColumnDefinition cdef = cfs.metadata.getColumnDefinition(ByteBufferUtil.bytes("val"));
0:         ArrayBackedPartition readPartition = Util.getOnlyPartitionUnfiltered(Util.cmd(cfs, key).build());
1:         Iterator<Row> iter = readPartition.iterator();
1: 
1:         compareValues(iter.next().getCell(cdef), "cname1");
1:         compareValues(iter.next().getCell(cdef), "cname2");
1:         compareValues(iter.next().getCell(cdef), "cname3");
1:         compareValues(iter.next().getCell(cdef), "cname4");
1:         compareValues(iter.next().getCell(cdef), "cname5");
1:     }
1:     private void compareValues(Cell c, String r) throws CharacterCodingException
1:     {
1:         assert ByteBufferUtil.string(c.value()).equals(r) : "Expected: {" + ByteBufferUtil.string(c.value()) + "} got: {" + r + "}";
/////////////////////////////////////////////////////////////////////////
1:         catch (ConfigurationException e) {}
1:         catch (SyntaxException e) {}
1:         catch (ConfigurationException e) {}
1:         catch (SyntaxException e) {}
/////////////////////////////////////////////////////////////////////////
commit:e50d6af
/////////////////////////////////////////////////////////////////////////
0:         Iterator<Cell> iter = cf.getSortedColumns().iterator();
commit:362cc05
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.composites.CellNames;
/////////////////////////////////////////////////////////////////////////
0:         assert iter.next().name().toByteBuffer().equals(cname1);
0:         assert iter.next().name().toByteBuffer().equals(cname2);
0:         assert iter.next().name().toByteBuffer().equals(cname3);
0:         assert iter.next().name().toByteBuffer().equals(cname4);
0:         assert iter.next().name().toByteBuffer().equals(cname5);
/////////////////////////////////////////////////////////////////////////
0:         rm.add(cfName, CellNames.simpleDense(cname), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0);
commit:20c0baf
/////////////////////////////////////////////////////////////////////////
1:             assert e.toString().contains("should be 16 or 0 bytes");
commit:fc8b76f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.serializers.MarshalException;
/////////////////////////////////////////////////////////////////////////
commit:e9c6742
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.type.MarshalException;
commit:3a005df
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(Util.dk("k"), cfName));
0:         Iterator<Column> iter = cf.getSortedColumns().iterator();
/////////////////////////////////////////////////////////////////////////
0:         rm.add(cfName, cname, ByteBufferUtil.EMPTY_BYTE_BUFFER, 0);
commit:7442fc0
/////////////////////////////////////////////////////////////////////////
1:             uuids[i] = UUIDGen.getTimeUUID();
commit:c86a7f8
commit:5d5207b
/////////////////////////////////////////////////////////////////////////
0: import java.util.Arrays;
1: import static org.junit.Assert.assertEquals;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void testEscapeUnescape()
1:     {
1:         List<AbstractType<?>> subComparators = new ArrayList<AbstractType<?>>(){{;
1:             add(UTF8Type.instance);
1:             add(UTF8Type.instance);
1:         }};
1:         CompositeType comp = CompositeType.getInstance(subComparators);
1: 
1:         String[][] inputs = new String[][]{
1:             new String[]{ "foo", "bar" },
1:             new String[]{ "", "" },
1:             new String[]{ "foo\\", "bar" },
1:             new String[]{ "foo\\:", "bar" },
1:             new String[]{ "foo:", "bar" },
1:             new String[]{ "foo", "b:ar" },
1:             new String[]{ "foo!", "b:ar" },
1:         };
1: 
1:         for (String[] input : inputs)
1:         {
1:             CompositeType.Builder builder = new CompositeType.Builder(comp);
1:             for (String part : input)
1:                 builder.add(UTF8Type.instance.fromString(part));
1: 
1:             ByteBuffer value = comp.fromString(comp.getString(builder.build()));
1:             ByteBuffer[] splitted = comp.split(value);
1:             for (int i = 0; i < splitted.length; i++)
1:                 assertEquals(input[i], UTF8Type.instance.getString(splitted[i]));
1:         }
1:     }
1: 
commit:3a2faf9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.exceptions.ConfigurationException;
1: import org.apache.cassandra.exceptions.SyntaxException;
/////////////////////////////////////////////////////////////////////////
0:         catch (SyntaxException e) {}
/////////////////////////////////////////////////////////////////////////
0:         catch (SyntaxException e) {}
commit:438acfc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.SchemaLoader;
/////////////////////////////////////////////////////////////////////////
0: public class CompositeTypeTest extends SchemaLoader
commit:a15c35b
/////////////////////////////////////////////////////////////////////////
commit:0fdab63
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void testCompatibility() throws Exception
1:     {
1:         assert TypeParser.parse("CompositeType(IntegerType, BytesType)").isCompatibleWith(TypeParser.parse("CompositeType(IntegerType)"));
1:         assert TypeParser.parse("CompositeType(IntegerType, BytesType)").isCompatibleWith(TypeParser.parse("CompositeType(IntegerType, BytesType)"));
1:         assert TypeParser.parse("CompositeType(BytesType, BytesType)").isCompatibleWith(TypeParser.parse("CompositeType(AsciiType, BytesType)"));
1: 
1:         assert !TypeParser.parse("CompositeType(IntegerType)").isCompatibleWith(TypeParser.parse("CompositeType(IntegerType, BytesType)"));
1:         assert !TypeParser.parse("CompositeType(IntegerType)").isCompatibleWith(TypeParser.parse("CompositeType(BytesType)"));
1:     }
commit:5d98581
/////////////////////////////////////////////////////////////////////////
1: /*
1: * Licensed to the Apache Software Foundation (ASF) under one
1: * or more contributor license agreements.  See the NOTICE file
1: * distributed with this work for additional information
1: * regarding copyright ownership.  The ASF licenses this file
1: * to you under the Apache License, Version 2.0 (the
1: * "License"); you may not use this file except in compliance
1: * with the License.  You may obtain a copy of the License at
1: *
1: *    http://www.apache.org/licenses/LICENSE-2.0
1: *
1: * Unless required by applicable law or agreed to in writing,
1: * software distributed under the License is distributed on an
1: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1: * KIND, either express or implied.  See the License for the
1: * specific language governing permissions and limitations
1: * under the License.
1: */
1: package org.apache.cassandra.db.marshal;
1: 
1: import java.nio.ByteBuffer;
0: import java.util.ArrayList;
0: import java.util.Iterator;
0: import java.util.List;
0: import java.util.UUID;
1: 
1: import org.junit.Test;
1: import static org.junit.Assert.fail;
1: 
0: import org.apache.cassandra.CleanupHelper;
1: import org.apache.cassandra.Util;
0: import org.apache.cassandra.config.ConfigurationException;
0: import org.apache.cassandra.db.*;
0: import org.apache.cassandra.db.columniterator.IdentityQueryFilter;
0: import org.apache.cassandra.db.filter.QueryFilter;
0: import org.apache.cassandra.db.filter.QueryPath;
1: import org.apache.cassandra.utils.*;
1: 
0: public class CompositeTypeTest extends CleanupHelper
1: {
0:     private static final String cfName = "StandardComposite";
1:     private static final CompositeType comparator;
1:     static
1:     {
0:         List<AbstractType> subComparators = new ArrayList<AbstractType>();
1:         subComparators.add(BytesType.instance);
1:         subComparators.add(TimeUUIDType.instance);
1:         subComparators.add(IntegerType.instance);
1:         try
1:         {
1:             comparator = CompositeType.getInstance(subComparators);
1:         }
0:         catch (ConfigurationException e)
1:         {
0:             throw new RuntimeException(e);
1:         }
1: 
1:     }
1: 
1:     private static final int UUID_COUNT = 3;
1:     private static final UUID[] uuids = new UUID[UUID_COUNT];
1:     static
1:     {
1:         for (int i = 0; i < UUID_COUNT; ++i)
0:             uuids[i] = UUIDGen.makeType1UUIDFromHost(FBUtilities.getLocalAddress());
1:     }
1: 
1:     @Test
1:     public void testEndOfComponent()
1:     {
1:         ByteBuffer[] cnames = {
1:             createCompositeKey("test1", uuids[0], -1, false),
1:             createCompositeKey("test1", uuids[1], 24, false),
1:             createCompositeKey("test1", uuids[1], 42, false),
1:             createCompositeKey("test1", uuids[1], 83, false),
1:             createCompositeKey("test1", uuids[2], -1, false),
1:             createCompositeKey("test1", uuids[2], 42, false),
1:         };
1: 
1:         ByteBuffer start = createCompositeKey("test1", uuids[1], -1, false);
1:         ByteBuffer stop = createCompositeKey("test1", uuids[1], -1, true);
1: 
1:         for (int i = 0; i < 1; ++i)
1:         {
1:             assert comparator.compare(start, cnames[i]) > 0;
1:             assert comparator.compare(stop, cnames[i]) > 0;
1:         }
1:         for (int i = 1; i < 4; ++i)
1:         {
1:             assert comparator.compare(start, cnames[i]) < 0;
1:             assert comparator.compare(stop, cnames[i]) > 0;
1:         }
1:         for (int i = 4; i < cnames.length; ++i)
1:         {
1:             assert comparator.compare(start, cnames[i]) < 0;
1:             assert comparator.compare(stop, cnames[i]) < 0;
1:         }
1:     }
1: 
1:     @Test
1:     public void testGetString()
1:     {
1:         String test1Hex = ByteBufferUtil.bytesToHex(ByteBufferUtil.bytes("test1"));
1:         ByteBuffer key = createCompositeKey("test1", uuids[1], 42, false);
1:         assert comparator.getString(key).equals(test1Hex + ":" + uuids[1] + ":42");
1: 
1:         key = createCompositeKey("test1", uuids[1], -1, true);
1:         assert comparator.getString(key).equals(test1Hex + ":" + uuids[1] + ":!");
1:     }
1: 
1:     @Test
1:     public void testFromString()
1:     {
1:         String test1Hex = ByteBufferUtil.bytesToHex(ByteBufferUtil.bytes("test1"));
1:         ByteBuffer key = createCompositeKey("test1", uuids[1], 42, false);
1:         assert key.equals(comparator.fromString(test1Hex + ":" + uuids[1] + ":42"));
1: 
1:         key = createCompositeKey("test1", uuids[1], -1, true);
1:         assert key.equals(comparator.fromString(test1Hex + ":" + uuids[1] + ":!"));
1:     }
1: 
1:     @Test
1:     public void testValidate()
1:     {
1:         ByteBuffer key = createCompositeKey("test1", uuids[1], 42, false);
1:         comparator.validate(key);
1: 
1:         key = createCompositeKey("test1", null, -1, false);
1:         comparator.validate(key);
1: 
1:         key = createCompositeKey("test1", uuids[2], -1, true);
1:         comparator.validate(key);
1: 
1:         key.get(); // make sure we're not aligned anymore
1:         try
1:         {
1:             comparator.validate(key);
1:             fail("Should not validate");
1:         }
1:         catch (MarshalException e) {}
1: 
1:         key = ByteBuffer.allocate(3 + "test1".length() + 3 + 14);
1:         key.putShort((short) "test1".length());
1:         key.put(ByteBufferUtil.bytes("test1"));
1:         key.put((byte) 0);
1:         key.putShort((short) 14);
1:         key.rewind();
1:         try
1:         {
1:             comparator.validate(key);
1:             fail("Should not validate");
1:         }
1:         catch (MarshalException e)
1:         {
0:             assert e.toString().contains("TimeUUID should be 16 or 0 bytes");
1:         }
1: 
1:         key = createCompositeKey("test1", UUID.randomUUID(), 42, false);
1:         try
1:         {
1:             comparator.validate(key);
1:             fail("Should not validate");
1:         }
1:         catch (MarshalException e)
1:         {
1:             assert e.toString().contains("Invalid version for TimeUUID type");
1:         }
1:     }
1: 
1:     @Test
1:     public void testFullRound() throws Exception
1:     {
0:         Table table = Table.open("Keyspace1");
0:         ColumnFamilyStore cfs = table.getColumnFamilyStore(cfName);
1: 
1:         ByteBuffer cname1 = createCompositeKey("test1", null, -1, false);
1:         ByteBuffer cname2 = createCompositeKey("test1", uuids[0], 24, false);
1:         ByteBuffer cname3 = createCompositeKey("test1", uuids[0], 42, false);
1:         ByteBuffer cname4 = createCompositeKey("test2", uuids[0], -1, false);
1:         ByteBuffer cname5 = createCompositeKey("test2", uuids[1], 42, false);
1: 
1:         ByteBuffer key = ByteBufferUtil.bytes("k");
0:         RowMutation rm = new RowMutation("Keyspace1", key);
0:         addColumn(rm, cname5);
0:         addColumn(rm, cname1);
0:         addColumn(rm, cname4);
0:         addColumn(rm, cname2);
0:         addColumn(rm, cname3);
0:         rm.apply();
1: 
0:         ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(Util.dk("k"), new QueryPath(cfName, null, null)));
1: 
0:         Iterator<IColumn> iter = cf.getSortedColumns().iterator();
1: 
0:         assert iter.next().name().equals(cname1);
0:         assert iter.next().name().equals(cname2);
0:         assert iter.next().name().equals(cname3);
0:         assert iter.next().name().equals(cname4);
0:         assert iter.next().name().equals(cname5);
1:     }
1: 
1:     @Test
1:     public void testEmptyParametersNotallowed()
1:     {
1:         try
1:         {
1:             TypeParser.parse("CompositeType");
1:             fail("Shouldn't work");
1:         }
0:         catch (ConfigurationException e) {}
1: 
1:         try
1:         {
1:             TypeParser.parse("CompositeType()");
1:             fail("Shouldn't work");
1:         }
0:         catch (ConfigurationException e) {}
1:     }
1: 
1: 
0:     private void addColumn(RowMutation rm, ByteBuffer cname)
1:     {
0:         rm.add(new QueryPath(cfName, null , cname), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0);
1:     }
1: 
1:     private ByteBuffer createCompositeKey(String s, UUID uuid, int i, boolean lastIsOne)
1:     {
1:         ByteBuffer bytes = ByteBufferUtil.bytes(s);
1:         int totalSize = 0;
1:         if (s != null)
1:         {
1:             totalSize += 2 + bytes.remaining() + 1;
1:             if (uuid != null)
1:             {
1:                 totalSize += 2 + 16 + 1;
1:                 if (i != -1)
1:                 {
1:                     totalSize += 2 + 1 + 1;
1:                 }
1:             }
1:         }
1: 
1:         ByteBuffer bb = ByteBuffer.allocate(totalSize);
1: 
1:         if (s != null)
1:         {
1:             bb.putShort((short) bytes.remaining());
1:             bb.put(bytes);
1:             bb.put(uuid == null && lastIsOne ? (byte)1 : (byte)0);
1:             if (uuid != null)
1:             {
1:                 bb.putShort((short) 16);
1:                 bb.put(UUIDGen.decompose(uuid));
1:                 bb.put(i == -1 && lastIsOne ? (byte)1 : (byte)0);
1:                 if (i != -1)
1:                 {
1:                     // We are putting a byte only because our test use ints that fit in a byte *and* IntegerType.fromString() will
1:                     // return something compatible (i.e, putting a full int here would break 'fromStringTest')
1:                     bb.putShort((short) 1);
1:                     bb.put((byte)i);
1:                     bb.put(lastIsOne ? (byte)1 : (byte)0);
1:                 }
1:             }
1:         }
1:         bb.rewind();
1:         return bb;
1:     }
1: }
author:Dave Brosius
-------------------------------------------------------------------------------
commit:01880a4
/////////////////////////////////////////////////////////////////////////
0:         catch (ConfigurationException | SyntaxException e) {}
0:         catch (ConfigurationException | SyntaxException e) {}
commit:bc6b5f4
commit:56f35db
/////////////////////////////////////////////////////////////////////////
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:5de72e5
/////////////////////////////////////////////////////////////////////////
0:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARDCOMPOSITE, composite));
author:lyubent
-------------------------------------------------------------------------------
commit:b453f08
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe();
commit:d2a3827
/////////////////////////////////////////////////////////////////////////
1: import java.util.*;
1: import org.junit.BeforeClass;
0: import org.apache.cassandra.config.CFMetaData;
0: import org.apache.cassandra.config.KSMetaData;
0: import org.apache.cassandra.locator.SimpleStrategy;
0: import org.apache.cassandra.serializers.MarshalException;
1: public class CompositeTypeTest
1:     private static final String KEYSPACE1 = "CompositeTypeTest";
1:     private static final String CF_STANDARDCOMPOSITE = "StandardComposite";
/////////////////////////////////////////////////////////////////////////
1:     @BeforeClass
1:     public static void defineSchema() throws ConfigurationException
0:     {
1:         AbstractType<?> composite = CompositeType.getInstance(Arrays.asList(new AbstractType<?>[]{BytesType.instance, TimeUUIDType.instance, IntegerType.instance}));
1:         SchemaLoader.prepareServer();
1:         SchemaLoader.createKeyspace(KEYSPACE1,
0:                                     SimpleStrategy.class,
0:                                     KSMetaData.optsWithRF(1),
0:                                     CFMetaData.denseCFMetaData(KEYSPACE1, CF_STANDARDCOMPOSITE, composite));
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:         Keyspace keyspace = Keyspace.open(KEYSPACE1);
1:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(CF_STANDARDCOMPOSITE);
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation(KEYSPACE1, key);
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(Util.dk("k"), CF_STANDARDCOMPOSITE, System.currentTimeMillis()));
/////////////////////////////////////////////////////////////////////////
0:         rm.add(CF_STANDARDCOMPOSITE, CellNames.simpleDense(cname), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0);
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:0ad499e
/////////////////////////////////////////////////////////////////////////
0: import java.nio.charset.CharacterCodingException;
0: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.sstable.SSTableReader;
commit:96ecaff
/////////////////////////////////////////////////////////////////////////
0:         comparator = CompositeType.getInstance(subComparators);
author:Brandon Williams
-------------------------------------------------------------------------------
commit:e86469e
/////////////////////////////////////////////////////////////////////////
1:         List<AbstractType<?>> subComparators = new ArrayList<AbstractType<?>>();
commit:127c028
/////////////////////////////////////////////////////////////////////////
0:             uuids[i] = UUIDGen.makeType1UUIDFromHost(FBUtilities.getBroadcastAddress());
============================================================================