1:75508ec: /*
1:75508ec:  * Licensed to the Apache Software Foundation (ASF) under one
1:75508ec:  * or more contributor license agreements.  See the NOTICE file
1:75508ec:  * distributed with this work for additional information
1:75508ec:  * regarding copyright ownership.  The ASF licenses this file
1:75508ec:  * to you under the Apache License, Version 2.0 (the
1:75508ec:  * "License"); you may not use this file except in compliance
1:75508ec:  * with the License.  You may obtain a copy of the License at
1:75508ec:  *
1:75508ec:  *     http://www.apache.org/licenses/LICENSE-2.0
1:75508ec:  *
1:75508ec:  * Unless required by applicable law or agreed to in writing, software
1:75508ec:  * distributed under the License is distributed on an "AS IS" BASIS,
1:75508ec:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:75508ec:  * See the License for the specific language governing permissions and
1:75508ec:  * limitations under the License.
2:75508ec:  */
1:75508ec: package org.apache.cassandra.utils;
6:75508ec: 
1:75508ec: import java.lang.reflect.Field;
1:75508ec: import java.nio.Buffer;
1:75508ec: import java.nio.ByteBuffer;
1:75508ec: import java.nio.ByteOrder;
1:75508ec: import java.security.AccessController;
1:75508ec: import java.security.PrivilegedAction;
1:75508ec: 
1:e77ea12: import com.google.common.primitives.*;
1:75508ec: 
1:e77ea12: import net.nicoulaj.compilecommand.annotations.Inline;
1:75508ec: import sun.misc.Unsafe;
1:75508ec: 
2:75508ec: /**
1:75508ec:  * Utility code to do optimized byte-array comparison.
1:75508ec:  * This is borrowed and slightly modified from Guava's {@link UnsignedBytes}
1:75508ec:  * class to be able to compare arrays that start at non-zero offsets.
1:75508ec:  */
1:e77ea12: public class FastByteOperations
11:75508ec: {
1:75508ec: 
1:75508ec:     /**
1:75508ec:      * Lexicographically compare two byte arrays.
1:75508ec:      */
1:75508ec:     public static int compareUnsigned(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2)
1:75508ec:     {
1:75508ec:         return BestHolder.BEST.compare(b1, s1, l1, b2, s2, l2);
11:75508ec:     }
1:75508ec: 
1:75508ec:     public static int compareUnsigned(ByteBuffer b1, byte[] b2, int s2, int l2)
1:75508ec:     {
1:75508ec:         return BestHolder.BEST.compare(b1, b2, s2, l2);
1:75508ec:     }
1:75508ec: 
1:75508ec:     public static int compareUnsigned(byte[] b1, int s1, int l1, ByteBuffer b2)
1:75508ec:     {
1:75508ec:         return -BestHolder.BEST.compare(b2, b1, s1, l1);
1:75508ec:     }
1:75508ec: 
1:75508ec:     public static int compareUnsigned(ByteBuffer b1, ByteBuffer b2)
1:75508ec:     {
1:75508ec:         return BestHolder.BEST.compare(b1, b2);
1:75508ec:     }
1:75508ec: 
1:75508ec:     public static void copy(ByteBuffer src, int srcPosition, byte[] trg, int trgPosition, int length)
1:75508ec:     {
1:75508ec:         BestHolder.BEST.copy(src, srcPosition, trg, trgPosition, length);
1:75508ec:     }
1:75508ec: 
1:75508ec:     public static void copy(ByteBuffer src, int srcPosition, ByteBuffer trg, int trgPosition, int length)
1:75508ec:     {
1:75508ec:         BestHolder.BEST.copy(src, srcPosition, trg, trgPosition, length);
1:75508ec:     }
1:75508ec: 
1:75508ec:     public interface ByteOperations
1:75508ec:     {
1:75508ec:         abstract public int compare(byte[] buffer1, int offset1, int length1,
1:75508ec:                                     byte[] buffer2, int offset2, int length2);
1:75508ec: 
1:75508ec:         abstract public int compare(ByteBuffer buffer1, byte[] buffer2, int offset2, int length2);
1:75508ec: 
1:75508ec:         abstract public int compare(ByteBuffer buffer1, ByteBuffer buffer2);
1:75508ec: 
1:75508ec:         abstract public void copy(ByteBuffer src, int srcPosition, byte[] trg, int trgPosition, int length);
1:75508ec: 
1:75508ec:         abstract public void copy(ByteBuffer src, int srcPosition, ByteBuffer trg, int trgPosition, int length);
1:75508ec:     }
1:75508ec: 
1:75508ec:     /**
1:75508ec:      * Provides a lexicographical comparer implementation; either a Java
1:75508ec:      * implementation or a faster implementation based on {@link Unsafe}.
1:75508ec:      * <p/>
1:75508ec:      * <p>Uses reflection to gracefully fall back to the Java implementation if
1:75508ec:      * {@code Unsafe} isn't available.
1:75508ec:      */
1:75508ec:     private static class BestHolder
1:75508ec:     {
1:75508ec:         static final String UNSAFE_COMPARER_NAME = FastByteOperations.class.getName() + "$UnsafeOperations";
1:75508ec:         static final ByteOperations BEST = getBest();
1:75508ec: 
1:75508ec:         /**
1:75508ec:          * Returns the Unsafe-using Comparer, or falls back to the pure-Java
1:75508ec:          * implementation if unable to do so.
1:75508ec:          */
1:75508ec:         static ByteOperations getBest()
1:75508ec:         {
1:73b5cab:             if (!Architecture.IS_UNALIGNED)
1:75508ec:                 return new PureJavaOperations();
1:75508ec:             try
1:75508ec:             {
1:75508ec:                 Class<?> theClass = Class.forName(UNSAFE_COMPARER_NAME);
1:75508ec: 
1:75508ec:                 // yes, UnsafeComparer does implement Comparer<byte[]>
1:75508ec:                 @SuppressWarnings("unchecked")
1:75508ec:                 ByteOperations comparer = (ByteOperations) theClass.getConstructor().newInstance();
1:75508ec:                 return comparer;
1:75508ec:             }
1:75508ec:             catch (Throwable t)
1:1452134:             {
1:1452134:                 JVMStabilityInspector.inspectThrowable(t);
1:1452134:                 // ensure we really catch *everything*
1:75508ec:                 return new PureJavaOperations();
1:75508ec:             }
1:75508ec:         }
1:75508ec: 
1:75508ec:     }
1:75508ec: 
1:75508ec:     @SuppressWarnings("unused") // used via reflection
1:75508ec:     public static final class UnsafeOperations implements ByteOperations
1:75508ec:     {
1:75508ec:         static final Unsafe theUnsafe;
1:75508ec:         /**
1:75508ec:          * The offset to the first element in a byte array.
1:75508ec:          */
1:75508ec:         static final long BYTE_ARRAY_BASE_OFFSET;
1:75508ec:         static final long DIRECT_BUFFER_ADDRESS_OFFSET;
1:75508ec: 
1:75508ec:         static
1:75508ec:         {
1:75508ec:             theUnsafe = (Unsafe) AccessController.doPrivileged(
1:75508ec:                       new PrivilegedAction<Object>()
1:75508ec:                       {
1:75508ec:                           @Override
1:75508ec:                           public Object run()
1:75508ec:                           {
1:75508ec:                               try
1:75508ec:                               {
1:75508ec:                                   Field f = Unsafe.class.getDeclaredField("theUnsafe");
1:75508ec:                                   f.setAccessible(true);
1:75508ec:                                   return f.get(null);
1:75508ec:                               }
1:75508ec:                               catch (NoSuchFieldException e)
1:75508ec:                               {
1:75508ec:                                   // It doesn't matter what we throw;
1:75508ec:                                   // it's swallowed in getBest().
1:75508ec:                                   throw new Error();
1:75508ec:                               }
1:75508ec:                               catch (IllegalAccessException e)
1:75508ec:                               {
1:75508ec:                                   throw new Error();
1:75508ec:                               }
1:75508ec:                           }
1:75508ec:                       });
1:75508ec: 
1:75508ec:             try
1:75508ec:             {
1:75508ec:                 BYTE_ARRAY_BASE_OFFSET = theUnsafe.arrayBaseOffset(byte[].class);
1:75508ec:                 DIRECT_BUFFER_ADDRESS_OFFSET = theUnsafe.objectFieldOffset(Buffer.class.getDeclaredField("address"));
1:75508ec:             }
1:75508ec:             catch (Exception e)
1:75508ec:             {
1:75508ec:                 throw new AssertionError(e);
1:75508ec:             }
1:75508ec: 
1:75508ec:             // sanity check - this should never fail
1:75508ec:             if (theUnsafe.arrayIndexScale(byte[].class) != 1)
1:75508ec:             {
1:75508ec:                 throw new AssertionError();
1:75508ec:             }
1:75508ec:         }
1:75508ec: 
1:e77ea12:         static final boolean BIG_ENDIAN = ByteOrder.nativeOrder().equals(ByteOrder.BIG_ENDIAN);
1:75508ec: 
1:75508ec:         public int compare(byte[] buffer1, int offset1, int length1, byte[] buffer2, int offset2, int length2)
1:75508ec:         {
1:e77ea12:             return compareTo(buffer1, BYTE_ARRAY_BASE_OFFSET + offset1, length1,
1:e77ea12:                              buffer2, BYTE_ARRAY_BASE_OFFSET + offset2, length2);
1:75508ec:         }
1:75508ec: 
1:75508ec:         public int compare(ByteBuffer buffer1, byte[] buffer2, int offset2, int length2)
1:75508ec:         {
1:e77ea12:             Object obj1;
1:e77ea12:             long offset1;
2:75508ec:             if (buffer1.hasArray())
1:75508ec:             {
2:75508ec:                 obj1 = buffer1.array();
1:e77ea12:                 offset1 = BYTE_ARRAY_BASE_OFFSET + buffer1.arrayOffset();
1:75508ec:             }
5:75508ec:             else
1:75508ec:             {
2:75508ec:                 obj1 = null;
1:e77ea12:                 offset1 = theUnsafe.getLong(buffer1, DIRECT_BUFFER_ADDRESS_OFFSET);
1:e77ea12:             }
1:e77ea12:             int length1;
1:e77ea12:             {
1:e77ea12:                 int position = buffer1.position();
1:e77ea12:                 int limit = buffer1.limit();
1:e77ea12:                 length1 = limit - position;
1:e77ea12:                 offset1 += position;
1:75508ec:             }
1:75508ec:             return compareTo(obj1, offset1, length1, buffer2, BYTE_ARRAY_BASE_OFFSET + offset2, length2);
1:75508ec:         }
1:75508ec: 
1:75508ec:         public int compare(ByteBuffer buffer1, ByteBuffer buffer2)
1:75508ec:         {
1:e77ea12:             return compareTo(buffer1, buffer2);
1:75508ec:         }
1:75508ec: 
1:75508ec:         public void copy(ByteBuffer src, int srcPosition, byte[] trg, int trgPosition, int length)
1:75508ec:         {
1:75508ec:             if (src.hasArray())
1:75508ec:                 System.arraycopy(src.array(), src.arrayOffset() + srcPosition, trg, trgPosition, length);
1:e77ea12:             else
1:e77ea12:                 copy(null, srcPosition + theUnsafe.getLong(src, DIRECT_BUFFER_ADDRESS_OFFSET), trg, trgPosition, length);
1:75508ec:         }
1:75508ec: 
1:75508ec:         public void copy(ByteBuffer srcBuf, int srcPosition, ByteBuffer trgBuf, int trgPosition, int length)
1:75508ec:         {
1:e77ea12:             Object src;
1:e77ea12:             long srcOffset;
1:e77ea12:             if (srcBuf.hasArray())
1:75508ec:             {
1:75508ec:                 src = srcBuf.array();
1:e77ea12:                 srcOffset = BYTE_ARRAY_BASE_OFFSET + srcBuf.arrayOffset();
1:75508ec:             }
1:75508ec:             else
1:75508ec:             {
1:e77ea12:                 src = null;
1:e77ea12:                 srcOffset = theUnsafe.getLong(srcBuf, DIRECT_BUFFER_ADDRESS_OFFSET);
1:75508ec:             }
1:e77ea12:             copy(src, srcOffset + srcPosition, trgBuf, trgPosition, length);
1:e77ea12:         }
1:e77ea12: 
1:e77ea12:         public static void copy(Object src, long srcOffset, ByteBuffer trgBuf, int trgPosition, int length)
1:e77ea12:         {
1:e77ea12:             if (trgBuf.hasArray())
1:e77ea12:                 copy(src, srcOffset, trgBuf.array(), trgBuf.arrayOffset() + trgPosition, length);
1:e77ea12:             else
1:e77ea12:                 copy(src, srcOffset, null, trgPosition + theUnsafe.getLong(trgBuf, DIRECT_BUFFER_ADDRESS_OFFSET), length);
1:e77ea12:         }
1:e77ea12: 
1:e77ea12:         public static void copy(Object src, long srcOffset, byte[] trg, int trgPosition, int length)
1:e77ea12:         {
1:e77ea12:             if (length <= MIN_COPY_THRESHOLD)
1:e77ea12:             {
1:e77ea12:                 for (int i = 0 ; i < length ; i++)
1:e77ea12:                     trg[trgPosition + i] = theUnsafe.getByte(src, srcOffset + i);
1:e77ea12:             }
1:e77ea12:             else
1:e77ea12:             {
1:e77ea12:                 copy(src, srcOffset, trg, BYTE_ARRAY_BASE_OFFSET + trgPosition, length);
1:e77ea12:             }
1:75508ec:         }
1:75508ec: 
1:75508ec:         // 1M, copied from java.nio.Bits (unfortunately a package-private class)
1:75508ec:         private static final long UNSAFE_COPY_THRESHOLD = 1 << 20;
1:e77ea12:         private static final long MIN_COPY_THRESHOLD = 6;
1:75508ec: 
1:e77ea12:         public static void copy(Object src, long srcOffset, Object dst, long dstOffset, long length)
1:75508ec:         {
1:68d2526:             while (length > 0)
1:68d2526:             {
1:75508ec:                 long size = (length > UNSAFE_COPY_THRESHOLD) ? UNSAFE_COPY_THRESHOLD : length;
1:75508ec:                 // if src or dst are null, the offsets are absolute base addresses:
1:75508ec:                 theUnsafe.copyMemory(src, srcOffset, dst, dstOffset, size);
1:75508ec:                 length -= size;
1:75508ec:                 srcOffset += size;
1:75508ec:                 dstOffset += size;
1:75508ec:             }
1:75508ec:         }
1:75508ec: 
4:e77ea12:         @Inline
1:e77ea12:         public static int compareTo(ByteBuffer buffer1, ByteBuffer buffer2)
1:e77ea12:         {
1:e77ea12:             Object obj1;
1:e77ea12:             long offset1;
1:e77ea12:             int length1;
1:e77ea12:             if (buffer1.hasArray())
1:e77ea12:             {
1:e77ea12:                 obj1 = buffer1.array();
1:e77ea12:                 offset1 = BYTE_ARRAY_BASE_OFFSET + buffer1.arrayOffset();
1:e77ea12:             }
1:e77ea12:             else
1:e77ea12:             {
1:e77ea12:                 obj1 = null;
1:e77ea12:                 offset1 = theUnsafe.getLong(buffer1, DIRECT_BUFFER_ADDRESS_OFFSET);
1:e77ea12:             }
1:e77ea12:             offset1 += buffer1.position();
1:e77ea12:             length1 = buffer1.remaining();
1:e77ea12:             return compareTo(obj1, offset1, length1, buffer2);
1:e77ea12:         }
1:e77ea12: 
1:e77ea12:         @Inline
1:e77ea12:         public static int compareTo(Object buffer1, long offset1, int length1, ByteBuffer buffer)
1:e77ea12:         {
1:e77ea12:             Object obj2;
1:e77ea12:             long offset2;
1:e77ea12: 
1:e77ea12:             int position = buffer.position();
1:e77ea12:             int limit = buffer.limit();
1:e77ea12:             if (buffer.hasArray())
1:e77ea12:             {
1:e77ea12:                 obj2 = buffer.array();
1:e77ea12:                 offset2 = BYTE_ARRAY_BASE_OFFSET + buffer.arrayOffset();
1:e77ea12:             }
1:e77ea12:             else
1:e77ea12:             {
1:e77ea12:                 obj2 = null;
1:e77ea12:                 offset2 = theUnsafe.getLong(buffer, DIRECT_BUFFER_ADDRESS_OFFSET);
1:e77ea12:             }
1:e77ea12:             int length2 = limit - position;
1:e77ea12:             offset2 += position;
1:e77ea12: 
1:e77ea12:             return compareTo(buffer1, offset1, length1, obj2, offset2, length2);
1:e77ea12:         }
1:75508ec: 
1:75508ec:         /**
1:75508ec:          * Lexicographically compare two arrays.
1:75508ec:          *
1:75508ec:          * @param buffer1 left operand: a byte[] or null
1:75508ec:          * @param buffer2 right operand: a byte[] or null
1:75508ec:          * @param memoryOffset1 Where to start comparing in the left buffer (pure memory address if buffer1 is null, or relative otherwise)
1:75508ec:          * @param memoryOffset2 Where to start comparing in the right buffer (pure memory address if buffer1 is null, or relative otherwise)
1:75508ec:          * @param length1 How much to compare from the left buffer
1:75508ec:          * @param length2 How much to compare from the right buffer
1:6b7db8a:          * @return 0 if equal, {@code < 0} if left is less than right, etc.
1:75508ec:          */
1:e77ea12:         @Inline
1:e77ea12:         public static int compareTo(Object buffer1, long memoryOffset1, int length1,
1:75508ec:                              Object buffer2, long memoryOffset2, int length2)
1:75508ec:         {
1:75508ec:             int minLength = Math.min(length1, length2);
1:75508ec: 
1:75508ec:             /*
1:75508ec:              * Compare 8 bytes at a time. Benchmarking shows comparing 8 bytes at a
1:75508ec:              * time is no slower than comparing 4 bytes at a time even on 32-bit.
1:75508ec:              * On the other hand, it is substantially faster on 64-bit.
1:75508ec:              */
1:e77ea12:             int wordComparisons = minLength & ~7;
1:75508ec:             for (int i = 0; i < wordComparisons ; i += Longs.BYTES)
1:75508ec:             {
1:1fab7b7:                 long lw = theUnsafe.getLong(buffer1, memoryOffset1 + i);
1:1fab7b7:                 long rw = theUnsafe.getLong(buffer2, memoryOffset2 + i);
1:75508ec: 
1:e77ea12:                 if (lw != rw)
1:75508ec:                 {
1:e77ea12:                     if (BIG_ENDIAN)
1:e77ea12:                         return UnsignedLongs.compare(lw, rw);
1:75508ec: 
1:e77ea12:                     return UnsignedLongs.compare(Long.reverseBytes(lw), Long.reverseBytes(rw));
1:75508ec:                 }
1:75508ec:             }
1:75508ec: 
1:e77ea12:             for (int i = wordComparisons ; i < minLength ; i++)
1:75508ec:             {
1:e77ea12:                 int b1 = theUnsafe.getByte(buffer1, memoryOffset1 + i) & 0xFF;
1:e77ea12:                 int b2 = theUnsafe.getByte(buffer2, memoryOffset2 + i) & 0xFF;
1:e77ea12:                 if (b1 != b2)
1:e77ea12:                     return b1 - b2;
1:75508ec:             }
1:e77ea12: 
1:75508ec:             return length1 - length2;
1:75508ec:         }
1:75508ec: 
1:75508ec:     }
1:75508ec: 
1:75508ec:     @SuppressWarnings("unused")
1:75508ec:     public static final class PureJavaOperations implements ByteOperations
1:75508ec:     {
1:75508ec:         @Override
1:75508ec:         public int compare(byte[] buffer1, int offset1, int length1,
1:75508ec:                            byte[] buffer2, int offset2, int length2)
1:75508ec:         {
2:75508ec:             // Short circuit equal case
1:75508ec:             if (buffer1 == buffer2 && offset1 == offset2 && length1 == length2)
3:75508ec:                 return 0;
1:75508ec: 
1:75508ec:             int end1 = offset1 + length1;
1:75508ec:             int end2 = offset2 + length2;
1:75508ec:             for (int i = offset1, j = offset2; i < end1 && j < end2; i++, j++)
1:75508ec:             {
1:75508ec:                 int a = (buffer1[i] & 0xff);
1:75508ec:                 int b = (buffer2[j] & 0xff);
1:75508ec:                 if (a != b)
1:75508ec:                 {
1:75508ec:                     return a - b;
1:75508ec:                 }
1:75508ec:             }
1:75508ec:             return length1 - length2;
1:75508ec:         }
1:75508ec: 
1:75508ec:         public int compare(ByteBuffer buffer1, byte[] buffer2, int offset2, int length2)
1:75508ec:         {
1:75508ec:             if (buffer1.hasArray())
1:75508ec:                 return compare(buffer1.array(), buffer1.arrayOffset() + buffer1.position(), buffer1.remaining(),
1:75508ec:                                buffer2, offset2, length2);
1:75508ec:             return compare(buffer1, ByteBuffer.wrap(buffer2, offset2, length2));
1:75508ec:         }
1:75508ec: 
1:75508ec:         public int compare(ByteBuffer buffer1, ByteBuffer buffer2)
1:75508ec:         {
1:75508ec:             int end1 = buffer1.limit();
1:75508ec:             int end2 = buffer2.limit();
1:75508ec:             for (int i = buffer1.position(), j = buffer2.position(); i < end1 && j < end2; i++, j++)
1:75508ec:             {
1:75508ec:                 int a = (buffer1.get(i) & 0xff);
1:75508ec:                 int b = (buffer2.get(j) & 0xff);
1:75508ec:                 if (a != b)
1:75508ec:                 {
1:75508ec:                     return a - b;
1:75508ec:                 }
1:75508ec:             }
1:75508ec:             return buffer1.remaining() - buffer2.remaining();
1:75508ec:         }
1:75508ec: 
1:75508ec:         public void copy(ByteBuffer src, int srcPosition, byte[] trg, int trgPosition, int length)
1:75508ec:         {
1:75508ec:             if (src.hasArray())
1:75508ec:             {
1:75508ec:                 System.arraycopy(src.array(), src.arrayOffset() + srcPosition, trg, trgPosition, length);
3:75508ec:                 return;
1:75508ec:             }
1:75508ec:             src = src.duplicate();
1:75508ec:             src.position(srcPosition);
1:75508ec:             src.get(trg, trgPosition, length);
1:75508ec:         }
1:75508ec: 
1:75508ec:         public void copy(ByteBuffer src, int srcPosition, ByteBuffer trg, int trgPosition, int length)
1:75508ec:         {
1:75508ec:             if (src.hasArray() && trg.hasArray())
1:75508ec:             {
1:75508ec:                 System.arraycopy(src.array(), src.arrayOffset() + srcPosition, trg.array(), trg.arrayOffset() + trgPosition, length);
1:75508ec:                 return;
1:75508ec:             }
1:75508ec:             src = src.duplicate();
1:75508ec:             src.position(srcPosition).limit(srcPosition + length);
1:75508ec:             trg = trg.duplicate();
1:75508ec:             trg.position(trgPosition);
1:75508ec:             trg.put(src);
1:75508ec:         }
1:75508ec:     }
1:75508ec: }
============================================================================
author:Dave Brosius
-------------------------------------------------------------------------------
commit:68d2526
/////////////////////////////////////////////////////////////////////////
1:             while (length > 0)
1:             {
commit:73b5cab
/////////////////////////////////////////////////////////////////////////
1:             if (!Architecture.IS_UNALIGNED)
commit:6b7db8a
/////////////////////////////////////////////////////////////////////////
1:          * @return 0 if equal, {@code < 0} if left is less than right, etc.
commit:1fab7b7
/////////////////////////////////////////////////////////////////////////
1:                 long lw = theUnsafe.getLong(buffer1, memoryOffset1 + i);
1:                 long rw = theUnsafe.getLong(buffer2, memoryOffset2 + i);
author:Jason Brown
-------------------------------------------------------------------------------
commit:61c93e7
commit:4ac4335
/////////////////////////////////////////////////////////////////////////
0:                                 || arch.equals("amd64") || arch.equals("x86_64") || arch.equals("s390x");
author:Joshua McKenzie
-------------------------------------------------------------------------------
commit:1452134
/////////////////////////////////////////////////////////////////////////
1:             {
1:                 JVMStabilityInspector.inspectThrowable(t);
1:                 // ensure we really catch *everything*
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:1fc8899
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:e77ea12
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.primitives.*;
1: import net.nicoulaj.compilecommand.annotations.Inline;
/////////////////////////////////////////////////////////////////////////
1: public class FastByteOperations
1:     @Inline
1:     @Inline
1:     @Inline
1:     @Inline
1:     @Inline
1:     @Inline
/////////////////////////////////////////////////////////////////////////
1:         static final boolean BIG_ENDIAN = ByteOrder.nativeOrder().equals(ByteOrder.BIG_ENDIAN);
1:             return compareTo(buffer1, BYTE_ARRAY_BASE_OFFSET + offset1, length1,
1:                              buffer2, BYTE_ARRAY_BASE_OFFSET + offset2, length2);
1:             Object obj1;
1:             long offset1;
1:                 offset1 = BYTE_ARRAY_BASE_OFFSET + buffer1.arrayOffset();
1:                 offset1 = theUnsafe.getLong(buffer1, DIRECT_BUFFER_ADDRESS_OFFSET);
1:             }
1:             int length1;
1:             {
1:                 int position = buffer1.position();
1:                 int limit = buffer1.limit();
1:                 length1 = limit - position;
1:                 offset1 += position;
1:             return compareTo(buffer1, buffer2);
1:             else
1:                 copy(null, srcPosition + theUnsafe.getLong(src, DIRECT_BUFFER_ADDRESS_OFFSET), trg, trgPosition, length);
1:             Object src;
1:             long srcOffset;
1:             if (srcBuf.hasArray())
1:                 srcOffset = BYTE_ARRAY_BASE_OFFSET + srcBuf.arrayOffset();
1:                 src = null;
1:                 srcOffset = theUnsafe.getLong(srcBuf, DIRECT_BUFFER_ADDRESS_OFFSET);
1:             copy(src, srcOffset + srcPosition, trgBuf, trgPosition, length);
1:         }
1: 
0:         @Inline
1:         public static void copy(Object src, long srcOffset, ByteBuffer trgBuf, int trgPosition, int length)
1:         {
1:             if (trgBuf.hasArray())
1:                 copy(src, srcOffset, trgBuf.array(), trgBuf.arrayOffset() + trgPosition, length);
1:             else
1:                 copy(src, srcOffset, null, trgPosition + theUnsafe.getLong(trgBuf, DIRECT_BUFFER_ADDRESS_OFFSET), length);
1:         }
1: 
0:         @Inline
1:         public static void copy(Object src, long srcOffset, byte[] trg, int trgPosition, int length)
1:         {
1:             if (length <= MIN_COPY_THRESHOLD)
1:             {
1:                 for (int i = 0 ; i < length ; i++)
1:                     trg[trgPosition + i] = theUnsafe.getByte(src, srcOffset + i);
1:             }
1:             else
1:             {
1:                 copy(src, srcOffset, trg, BYTE_ARRAY_BASE_OFFSET + trgPosition, length);
1:             }
1:         private static final long MIN_COPY_THRESHOLD = 6;
0:         @Inline
1:         public static void copy(Object src, long srcOffset, Object dst, long dstOffset, long length)
/////////////////////////////////////////////////////////////////////////
0:         @Inline
1:         public static int compareTo(ByteBuffer buffer1, ByteBuffer buffer2)
1:         {
1:             Object obj1;
1:             long offset1;
1:             int length1;
1:             if (buffer1.hasArray())
1:             {
1:                 obj1 = buffer1.array();
1:                 offset1 = BYTE_ARRAY_BASE_OFFSET + buffer1.arrayOffset();
1:             }
1:             else
1:             {
1:                 obj1 = null;
1:                 offset1 = theUnsafe.getLong(buffer1, DIRECT_BUFFER_ADDRESS_OFFSET);
1:             }
1:             offset1 += buffer1.position();
1:             length1 = buffer1.remaining();
1:             return compareTo(obj1, offset1, length1, buffer2);
1:         }
1: 
0:         @Inline
1:         public static int compareTo(Object buffer1, long offset1, int length1, ByteBuffer buffer)
1:         {
1:             Object obj2;
1:             long offset2;
1: 
1:             int position = buffer.position();
1:             int limit = buffer.limit();
1:             if (buffer.hasArray())
1:             {
1:                 obj2 = buffer.array();
1:                 offset2 = BYTE_ARRAY_BASE_OFFSET + buffer.arrayOffset();
1:             }
1:             else
1:             {
1:                 obj2 = null;
1:                 offset2 = theUnsafe.getLong(buffer, DIRECT_BUFFER_ADDRESS_OFFSET);
1:             }
1:             int length2 = limit - position;
1:             offset2 += position;
1: 
1:             return compareTo(buffer1, offset1, length1, obj2, offset2, length2);
1:         }
/////////////////////////////////////////////////////////////////////////
0:         @Inline
1:         public static int compareTo(Object buffer1, long memoryOffset1, int length1,
1:             int wordComparisons = minLength & ~7;
1:                 if (lw != rw)
1:                     if (BIG_ENDIAN)
1:                         return UnsignedLongs.compare(lw, rw);
1:                     return UnsignedLongs.compare(Long.reverseBytes(lw), Long.reverseBytes(rw));
1:             for (int i = wordComparisons ; i < minLength ; i++)
1:                 int b1 = theUnsafe.getByte(buffer1, memoryOffset1 + i) & 0xFF;
1:                 int b2 = theUnsafe.getByte(buffer2, memoryOffset2 + i) & 0xFF;
1:                 if (b1 != b2)
1:                     return b1 - b2;
1: 
author:belliottsmith
-------------------------------------------------------------------------------
commit:75508ec
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.utils;
1: 
1: import java.lang.reflect.Field;
1: import java.nio.Buffer;
1: import java.nio.ByteBuffer;
1: import java.nio.ByteOrder;
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
1: 
0: import com.google.common.primitives.Longs;
0: import com.google.common.primitives.UnsignedBytes;
1: 
1: import sun.misc.Unsafe;
1: 
1: /**
1:  * Utility code to do optimized byte-array comparison.
1:  * This is borrowed and slightly modified from Guava's {@link UnsignedBytes}
1:  * class to be able to compare arrays that start at non-zero offsets.
1:  */
0: class FastByteOperations
1: {
1: 
1:     /**
1:      * Lexicographically compare two byte arrays.
1:      */
1:     public static int compareUnsigned(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2)
1:     {
1:         return BestHolder.BEST.compare(b1, s1, l1, b2, s2, l2);
1:     }
1: 
1:     public static int compareUnsigned(ByteBuffer b1, byte[] b2, int s2, int l2)
1:     {
1:         return BestHolder.BEST.compare(b1, b2, s2, l2);
1:     }
1: 
1:     public static int compareUnsigned(byte[] b1, int s1, int l1, ByteBuffer b2)
1:     {
1:         return -BestHolder.BEST.compare(b2, b1, s1, l1);
1:     }
1: 
1:     public static int compareUnsigned(ByteBuffer b1, ByteBuffer b2)
1:     {
0:         if (b1 == b2)
1:             return 0;
1:         return BestHolder.BEST.compare(b1, b2);
1:     }
1: 
1:     public static void copy(ByteBuffer src, int srcPosition, byte[] trg, int trgPosition, int length)
1:     {
1:         BestHolder.BEST.copy(src, srcPosition, trg, trgPosition, length);
1:     }
1: 
1:     public static void copy(ByteBuffer src, int srcPosition, ByteBuffer trg, int trgPosition, int length)
1:     {
1:         BestHolder.BEST.copy(src, srcPosition, trg, trgPosition, length);
1:     }
1: 
1:     public interface ByteOperations
1:     {
1:         abstract public int compare(byte[] buffer1, int offset1, int length1,
1:                                     byte[] buffer2, int offset2, int length2);
1: 
1:         abstract public int compare(ByteBuffer buffer1, byte[] buffer2, int offset2, int length2);
1: 
1:         abstract public int compare(ByteBuffer buffer1, ByteBuffer buffer2);
1: 
1:         abstract public void copy(ByteBuffer src, int srcPosition, byte[] trg, int trgPosition, int length);
1: 
1:         abstract public void copy(ByteBuffer src, int srcPosition, ByteBuffer trg, int trgPosition, int length);
1:     }
1: 
1:     /**
1:      * Provides a lexicographical comparer implementation; either a Java
1:      * implementation or a faster implementation based on {@link Unsafe}.
1:      * <p/>
1:      * <p>Uses reflection to gracefully fall back to the Java implementation if
1:      * {@code Unsafe} isn't available.
1:      */
1:     private static class BestHolder
1:     {
1:         static final String UNSAFE_COMPARER_NAME = FastByteOperations.class.getName() + "$UnsafeOperations";
1:         static final ByteOperations BEST = getBest();
1: 
1:         /**
1:          * Returns the Unsafe-using Comparer, or falls back to the pure-Java
1:          * implementation if unable to do so.
1:          */
1:         static ByteOperations getBest()
1:         {
0:             String arch = System.getProperty("os.arch");
0:             boolean unaligned = arch.equals("i386") || arch.equals("x86")
0:                                 || arch.equals("amd64") || arch.equals("x86_64");
0:             if (!unaligned)
1:                 return new PureJavaOperations();
1:             try
1:             {
1:                 Class<?> theClass = Class.forName(UNSAFE_COMPARER_NAME);
1: 
1:                 // yes, UnsafeComparer does implement Comparer<byte[]>
1:                 @SuppressWarnings("unchecked")
1:                 ByteOperations comparer = (ByteOperations) theClass.getConstructor().newInstance();
1:                 return comparer;
1:             }
1:             catch (Throwable t)
0:             { // ensure we really catch *everything*
1:                 return new PureJavaOperations();
1:             }
1:         }
1: 
1:     }
1: 
1:     @SuppressWarnings("unused") // used via reflection
1:     public static final class UnsafeOperations implements ByteOperations
1:     {
1:         static final Unsafe theUnsafe;
1:         /**
1:          * The offset to the first element in a byte array.
1:          */
1:         static final long BYTE_ARRAY_BASE_OFFSET;
1:         static final long DIRECT_BUFFER_ADDRESS_OFFSET;
1: 
1:         static
1:         {
1:             theUnsafe = (Unsafe) AccessController.doPrivileged(
1:                       new PrivilegedAction<Object>()
1:                       {
1:                           @Override
1:                           public Object run()
1:                           {
1:                               try
1:                               {
1:                                   Field f = Unsafe.class.getDeclaredField("theUnsafe");
1:                                   f.setAccessible(true);
1:                                   return f.get(null);
1:                               }
1:                               catch (NoSuchFieldException e)
1:                               {
1:                                   // It doesn't matter what we throw;
1:                                   // it's swallowed in getBest().
1:                                   throw new Error();
1:                               }
1:                               catch (IllegalAccessException e)
1:                               {
1:                                   throw new Error();
1:                               }
1:                           }
1:                       });
1: 
1:             try
1:             {
1:                 BYTE_ARRAY_BASE_OFFSET = theUnsafe.arrayBaseOffset(byte[].class);
1:                 DIRECT_BUFFER_ADDRESS_OFFSET = theUnsafe.objectFieldOffset(Buffer.class.getDeclaredField("address"));
1:             }
1:             catch (Exception e)
1:             {
1:                 throw new AssertionError(e);
1:             }
1: 
1:             // sanity check - this should never fail
1:             if (theUnsafe.arrayIndexScale(byte[].class) != 1)
1:             {
1:                 throw new AssertionError();
1:             }
1:         }
1: 
0:         static final boolean littleEndian =
0:             ByteOrder.nativeOrder().equals(ByteOrder.LITTLE_ENDIAN);
1: 
1:         /**
0:          * Returns true if x1 is less than x2, when both values are treated as
0:          * unsigned.
1:          */
0:         static boolean lessThanUnsigned(long x1, long x2)
1:         {
0:             return (x1 + Long.MIN_VALUE) < (x2 + Long.MIN_VALUE);
1:         }
1: 
1:         public int compare(byte[] buffer1, int offset1, int length1, byte[] buffer2, int offset2, int length2)
1:         {
0:             return compareTo(buffer1, BYTE_ARRAY_BASE_OFFSET + offset1, length1, buffer2, BYTE_ARRAY_BASE_OFFSET + offset2, length2);
1:         }
1: 
1:         public int compare(ByteBuffer buffer1, byte[] buffer2, int offset2, int length2)
1:         {
0:             final Object obj1;
0:             final long offset1;
0:             final int length1;
1:             if (buffer1.hasArray())
1:             {
1:                 obj1 = buffer1.array();
0:                 offset1 = BYTE_ARRAY_BASE_OFFSET + buffer1.arrayOffset() + buffer1.position();
0:                 length1 = buffer1.remaining();
1:             }
1:             else
1:             {
1:                 obj1 = null;
0:                 offset1 = theUnsafe.getLong(buffer1, DIRECT_BUFFER_ADDRESS_OFFSET) + buffer1.position();
0:                 length1 = buffer1.remaining();
1:             }
1:             return compareTo(obj1, offset1, length1, buffer2, BYTE_ARRAY_BASE_OFFSET + offset2, length2);
1:         }
1: 
1:         public int compare(ByteBuffer buffer1, ByteBuffer buffer2)
1:         {
0:             final Object obj1, obj2;
0:             final long offset1, offset2;
0:             final int length1, length2;
1:             if (buffer1.hasArray())
1:             {
1:                 obj1 = buffer1.array();
0:                 offset1 = BYTE_ARRAY_BASE_OFFSET + buffer1.arrayOffset() + buffer1.position();
0:                 length1 = buffer1.remaining();
1:             }
1:             else
1:             {
1:                 obj1 = null;
0:                 offset1 = theUnsafe.getLong(buffer1, DIRECT_BUFFER_ADDRESS_OFFSET) + buffer1.position();
0:                 length1 = buffer1.remaining();
1:             }
0:             if (buffer2.hasArray())
1:             {
0:                 obj2 = buffer2.array();
0:                 offset2 = BYTE_ARRAY_BASE_OFFSET + buffer2.arrayOffset() + buffer2.position();
0:                 length2 = buffer2.remaining();
1:             }
1:             else
1:             {
0:                 obj2 = null;
0:                 offset2 = theUnsafe.getLong(buffer2, DIRECT_BUFFER_ADDRESS_OFFSET) + buffer2.position();
0:                 length2 = buffer2.remaining();
1:             }
0:             return compareTo(obj1, offset1, length1, obj2, offset2, length2);
1:         }
1: 
1:         public void copy(ByteBuffer src, int srcPosition, byte[] trg, int trgPosition, int length)
1:         {
1:             if (src.hasArray())
1:             {
1:                 System.arraycopy(src.array(), src.arrayOffset() + srcPosition, trg, trgPosition, length);
1:                 return;
1:             }
0:             long srcOffset = srcPosition + theUnsafe.getLong(src, DIRECT_BUFFER_ADDRESS_OFFSET);
0:             copy(null, srcOffset, trg, BYTE_ARRAY_BASE_OFFSET + trgPosition, length);
1:         }
1: 
1:         public void copy(ByteBuffer srcBuf, int srcPosition, ByteBuffer trgBuf, int trgPosition, int length)
1:         {
0:             if (srcBuf.hasArray() && trgBuf.hasArray())
1:             {
0:                 System.arraycopy(srcBuf.array(), srcBuf.arrayOffset() + srcPosition, trgBuf.array(), trgBuf.arrayOffset() + trgPosition, length);
1:                 return;
1:             }
0:             Object src, trg;
0:             long srcOffset, trgOffset;
0:             if (srcBuf.isDirect())
1:             {
0:                 srcOffset = srcPosition + theUnsafe.getLong(srcBuf, DIRECT_BUFFER_ADDRESS_OFFSET);
0:                 src = null;
1:             }
1:             else
1:             {
1:                 src = srcBuf.array();
0:                 srcOffset = BYTE_ARRAY_BASE_OFFSET + srcBuf.arrayOffset() + srcPosition;
1:             }
0:             if (trgBuf.isDirect())
1:             {
0:                 trgOffset = trgPosition + theUnsafe.getLong(trgBuf, DIRECT_BUFFER_ADDRESS_OFFSET);
0:                 trg = null;
1:             }
1:             else
1:             {
0:                 trg = trgBuf.array();
0:                 trgOffset = BYTE_ARRAY_BASE_OFFSET + trgBuf.arrayOffset() + trgPosition;
1:             }
0:             copy(src, srcOffset, trg, trgOffset, length);
1:         }
1: 
1:         // 1M, copied from java.nio.Bits (unfortunately a package-private class)
1:         private static final long UNSAFE_COPY_THRESHOLD = 1 << 20;
1: 
0:         static void copy(Object src, long srcOffset, Object dst, long dstOffset, long length)
1:         {
0:             while (length > 0) {
1:                 long size = (length > UNSAFE_COPY_THRESHOLD) ? UNSAFE_COPY_THRESHOLD : length;
1:                 // if src or dst are null, the offsets are absolute base addresses:
1:                 theUnsafe.copyMemory(src, srcOffset, dst, dstOffset, size);
1:                 length -= size;
1:                 srcOffset += size;
1:                 dstOffset += size;
1:             }
1:         }
1: 
1: 
1:         /**
1:          * Lexicographically compare two arrays.
1:          *
1:          * @param buffer1 left operand: a byte[] or null
1:          * @param buffer2 right operand: a byte[] or null
1:          * @param memoryOffset1 Where to start comparing in the left buffer (pure memory address if buffer1 is null, or relative otherwise)
1:          * @param memoryOffset2 Where to start comparing in the right buffer (pure memory address if buffer1 is null, or relative otherwise)
1:          * @param length1 How much to compare from the left buffer
1:          * @param length2 How much to compare from the right buffer
0:          * @return 0 if equal, < 0 if left is less than right, etc.
1:          */
0:         public int compareTo(Object buffer1, long memoryOffset1, int length1,
1:                              Object buffer2, long memoryOffset2, int length2)
1:         {
1:             // Short circuit equal case
0:             if (buffer1 == buffer2 && memoryOffset1 == memoryOffset2 && length1 == length2)
1:                 return 0;
1: 
1:             int minLength = Math.min(length1, length2);
0:             int minWords = minLength / Longs.BYTES;
1: 
1:             /*
1:              * Compare 8 bytes at a time. Benchmarking shows comparing 8 bytes at a
1:              * time is no slower than comparing 4 bytes at a time even on 32-bit.
1:              * On the other hand, it is substantially faster on 64-bit.
1:              */
1: 
0:             int wordComparisons = minWords * Longs.BYTES;
1:             for (int i = 0; i < wordComparisons ; i += Longs.BYTES)
1:             {
0:                 long lw = theUnsafe.getLong(buffer1, memoryOffset1 + (long) i);
0:                 long rw = theUnsafe.getLong(buffer2, memoryOffset2 + (long) i);
0:                 long diff = lw ^ rw;
1: 
0:                 if (diff != 0)
1:                 {
0:                     if (!littleEndian)
0:                         return lessThanUnsigned(lw, rw) ? -1 : 1;
1: 
0:                     // Use binary search
0:                     int n = 0;
0:                     int y;
0:                     int x = (int) diff;
0:                     if (x == 0)
1:                     {
0:                         x = (int) (diff >>> 32);
0:                         n = 32;
1:                     }
1: 
0:                     y = x << 16;
0:                     if (y == 0)
0:                         n += 16;
1:                     else
0:                         x = y;
1: 
0:                     y = x << 8;
0:                     if (y == 0)
0:                         n += 8;
0:                     return (int) (((lw >>> n) & 0xFFL) - ((rw >>> n) & 0xFFL));
1:                 }
1:             }
1: 
0:             // The epilogue to cover the last (minLength % 8) elements.
0:             for (int i = minWords * Longs.BYTES; i < minLength; i++)
1:             {
0:                 int result = UnsignedBytes.compare(theUnsafe.getByte(buffer1, memoryOffset1 + i),
0:                                                    theUnsafe.getByte(buffer2, memoryOffset2 + i));
0:                 if (result != 0)
0:                     return result;
1:             }
1:             return length1 - length2;
1:         }
1: 
1:     }
1: 
1:     @SuppressWarnings("unused")
1:     public static final class PureJavaOperations implements ByteOperations
1:     {
1:         @Override
1:         public int compare(byte[] buffer1, int offset1, int length1,
1:                            byte[] buffer2, int offset2, int length2)
1:         {
1:             // Short circuit equal case
1:             if (buffer1 == buffer2 && offset1 == offset2 && length1 == length2)
1:                 return 0;
1: 
1:             int end1 = offset1 + length1;
1:             int end2 = offset2 + length2;
1:             for (int i = offset1, j = offset2; i < end1 && j < end2; i++, j++)
1:             {
1:                 int a = (buffer1[i] & 0xff);
1:                 int b = (buffer2[j] & 0xff);
1:                 if (a != b)
1:                 {
1:                     return a - b;
1:                 }
1:             }
1:             return length1 - length2;
1:         }
1: 
1:         public int compare(ByteBuffer buffer1, byte[] buffer2, int offset2, int length2)
1:         {
1:             if (buffer1.hasArray())
1:                 return compare(buffer1.array(), buffer1.arrayOffset() + buffer1.position(), buffer1.remaining(),
1:                                buffer2, offset2, length2);
1:             return compare(buffer1, ByteBuffer.wrap(buffer2, offset2, length2));
1:         }
1: 
1:         public int compare(ByteBuffer buffer1, ByteBuffer buffer2)
1:         {
1:             int end1 = buffer1.limit();
1:             int end2 = buffer2.limit();
1:             for (int i = buffer1.position(), j = buffer2.position(); i < end1 && j < end2; i++, j++)
1:             {
1:                 int a = (buffer1.get(i) & 0xff);
1:                 int b = (buffer2.get(j) & 0xff);
1:                 if (a != b)
1:                 {
1:                     return a - b;
1:                 }
1:             }
1:             return buffer1.remaining() - buffer2.remaining();
1:         }
1: 
1:         public void copy(ByteBuffer src, int srcPosition, byte[] trg, int trgPosition, int length)
1:         {
1:             if (src.hasArray())
1:             {
1:                 System.arraycopy(src.array(), src.arrayOffset() + srcPosition, trg, trgPosition, length);
1:                 return;
1:             }
1:             src = src.duplicate();
1:             src.position(srcPosition);
1:             src.get(trg, trgPosition, length);
1:         }
1: 
1:         public void copy(ByteBuffer src, int srcPosition, ByteBuffer trg, int trgPosition, int length)
1:         {
1:             if (src.hasArray() && trg.hasArray())
1:             {
1:                 System.arraycopy(src.array(), src.arrayOffset() + srcPosition, trg.array(), trg.arrayOffset() + trgPosition, length);
1:                 return;
1:             }
1:             src = src.duplicate();
1:             src.position(srcPosition).limit(srcPosition + length);
1:             trg = trg.duplicate();
1:             trg.position(trgPosition);
1:             trg.put(src);
1:         }
1:     }
1: }
============================================================================