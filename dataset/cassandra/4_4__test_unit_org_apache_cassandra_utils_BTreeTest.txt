1:0cb1e3d: /*
1:0cb1e3d:  * Licensed to the Apache Software Foundation (ASF) under one
1:0cb1e3d:  * or more contributor license agreements.  See the NOTICE file
1:0cb1e3d:  * distributed with this work for additional information
1:0cb1e3d:  * regarding copyright ownership.  The ASF licenses this file
1:0cb1e3d:  * to you under the Apache License, Version 2.0 (the
1:0cb1e3d:  * "License"); you may not use this file except in compliance
1:0cb1e3d:  * with the License.  You may obtain a copy of the License at
1:0cb1e3d:  *
1:0cb1e3d:  *     http://www.apache.org/licenses/LICENSE-2.0
1:0cb1e3d:  *
1:0cb1e3d:  * Unless required by applicable law or agreed to in writing, software
1:0cb1e3d:  * distributed under the License is distributed on an "AS IS" BASIS,
1:0cb1e3d:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:0cb1e3d:  * See the License for the specific language governing permissions and
1:0cb1e3d:  * limitations under the License.
1:0cb1e3d:  */
1:0cb1e3d: package org.apache.cassandra.utils;
5:0cb1e3d: 
1:5ab1d95: import java.util.*;
1:0cb1e3d: import java.util.concurrent.ThreadLocalRandom;
1:0cb1e3d: 
1:639d4b2: import com.google.common.collect.Iterables;
1:dc9ed46: import com.google.common.collect.Lists;
1:0cb1e3d: import org.junit.Test;
1:0cb1e3d: 
1:639d4b2: import junit.framework.Assert;
1:0cb1e3d: import org.apache.cassandra.utils.btree.BTree;
1:0cb1e3d: import org.apache.cassandra.utils.btree.UpdateFunction;
1:5ab1d95: 
1:a991b64: import static org.junit.Assert.*;
1:0cb1e3d: 
1:0cb1e3d: public class BTreeTest
8:0cb1e3d: {
1:0cb1e3d:     static Integer[] ints = new Integer[20];
1:0cb1e3d:     static
1:0cb1e3d:     {
1:0cb1e3d:         System.setProperty("cassandra.btree.fanfactor", "4");
1:0cb1e3d:         for (int i = 0 ; i < ints.length ; i++)
1:0cb1e3d:             ints[i] = new Integer(i);
7:0cb1e3d:     }
1:0cb1e3d: 
1:a991b64:     static final UpdateFunction<Integer, Integer> updateF = new UpdateFunction<Integer, Integer>()
1:e6e596d:     {
1:0cb1e3d:         public Integer apply(Integer replacing, Integer update)
1:e6e596d:         {
1:0cb1e3d:             return ints[update];
1:0cb1e3d:         }
1:0cb1e3d: 
1:0cb1e3d:         public boolean abortEarly()
1:0cb1e3d:         {
1:0cb1e3d:             return false;
1:0cb1e3d:         }
1:0cb1e3d: 
1:0cb1e3d:         public void allocated(long heapSize)
1:0cb1e3d:         {
1:0cb1e3d: 
1:0cb1e3d:         }
1:0cb1e3d: 
1:0cb1e3d:         public Integer apply(Integer integer)
1:0cb1e3d:         {
1:0cb1e3d:             return ints[integer];
1:0cb1e3d:         }
1:e6e596d:     };
1:0cb1e3d: 
1:a991b64:     private static final UpdateFunction<Integer, Integer> noOp = new UpdateFunction<Integer, Integer>()
1:a991b64:     {
1:a991b64:         public Integer apply(Integer replacing, Integer update)
1:a991b64:         {
1:a991b64:             return update;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public boolean abortEarly()
1:a991b64:         {
1:a991b64:             return false;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public void allocated(long heapSize)
1:a991b64:         {
1:a991b64:         }
1:a991b64: 
1:a991b64:         public Integer apply(Integer k)
1:a991b64:         {
1:a991b64:             return k;
1:a991b64:         }
1:a991b64:     };
1:a991b64: 
1:0cb1e3d:     private static List<Integer> seq(int count)
1:e6e596d:     {
1:0cb1e3d:         List<Integer> r = new ArrayList<>();
1:0cb1e3d:         for (int i = 0 ; i < count ; i++)
1:0cb1e3d:             r.add(i);
1:e6e596d:         return r;
1:e6e596d:     }
1:5ab1d95: 
1:0cb1e3d:     private static List<Integer> rand(int count)
1:e6e596d:     {
1:0cb1e3d:         Random rand = ThreadLocalRandom.current();
1:0cb1e3d:         List<Integer> r = seq(count);
1:0cb1e3d:         for (int i = 0 ; i < count - 1 ; i++)
1:e6e596d:         {
1:0cb1e3d:             int swap = i + rand.nextInt(count - i);
1:0cb1e3d:             Integer tmp = r.get(i);
1:0cb1e3d:             r.set(i, r.get(swap));
1:0cb1e3d:             r.set(swap, tmp);
1:e6e596d:         }
2:0cb1e3d:         return r;
1:0cb1e3d:     }
1:0cb1e3d: 
1:0cb1e3d:     private static final Comparator<Integer> CMP = new Comparator<Integer>()
1:0cb1e3d:     {
1:0cb1e3d:         public int compare(Integer o1, Integer o2)
1:0cb1e3d:         {
1:0cb1e3d:             return Integer.compare(o1, o2);
1:0cb1e3d:         }
2:0cb1e3d:     };
1:0cb1e3d: 
1:0cb1e3d:     @Test
1:0cb1e3d:     public void testBuilding_UpdateFunctionReplacement()
1:0cb1e3d:     {
1:0cb1e3d:         for (int i = 0; i < 20 ; i++)
1:a991b64:             checkResult(i, BTree.build(seq(i), updateF));
1:0cb1e3d:     }
1:5ab1d95: 
1:0cb1e3d:     @Test
1:0cb1e3d:     public void testUpdate_UpdateFunctionReplacement()
1:0cb1e3d:     {
1:0cb1e3d:         for (int i = 0; i < 20 ; i++)
1:a991b64:             checkResult(i, BTree.update(BTree.build(seq(i), noOp), CMP, seq(i), updateF));
1:0cb1e3d:     }
1:0cb1e3d: 
1:dc9ed46:     @Test
1:dc9ed46:     public void testApplyForwards()
1:dc9ed46:     {
1:dc9ed46:         List<Integer> input = seq(71);
1:dc9ed46:         Object[] btree = BTree.build(input, noOp);
1:dc9ed46: 
1:dc9ed46:         final List<Integer> result = new ArrayList<>();
1:dc9ed46:         BTree.<Integer>apply(btree, i -> result.add(i), false);
1:dc9ed46: 
1:dc9ed46:         org.junit.Assert.assertArrayEquals(input.toArray(),result.toArray());
1:dc9ed46:     }
1:dc9ed46: 
1:dc9ed46:     @Test
1:dc9ed46:     public void testApplyReverse()
1:dc9ed46:     {
1:dc9ed46:         List<Integer> input = seq(71);
1:dc9ed46:         Object[] btree = BTree.build(input, noOp);
1:dc9ed46: 
1:dc9ed46:         final List<Integer> result = new ArrayList<>();
1:dc9ed46:         BTree.<Integer>apply(btree, i -> result.add(i), true);
1:dc9ed46: 
1:dc9ed46:         org.junit.Assert.assertArrayEquals(Lists.reverse(input).toArray(),result.toArray());
1:dc9ed46:     }
1:dc9ed46: 
1:5ab1d95:     /**
1:5ab1d95:      * Tests that the apply method of the <code>UpdateFunction</code> is only called once with each key update.
1:5ab1d95:      * (see CASSANDRA-8018).
1:5ab1d95:      */
1:5ab1d95:     @Test
1:5ab1d95:     public void testUpdate_UpdateFunctionCallBack()
1:5ab1d95:     {
1:5250d7f:         Object[] btree = new Object[1];
1:5ab1d95:         CallsMonitor monitor = new CallsMonitor();
1:5ab1d95: 
1:a991b64:         btree = BTree.update(btree, CMP, Arrays.asList(1), monitor);
1:5250d7f:         assertArrayEquals(new Object[] {1}, btree);
1:5ab1d95:         assertEquals(1, monitor.getNumberOfCalls(1));
1:5ab1d95: 
1:5ab1d95:         monitor.clear();
1:a991b64:         btree = BTree.update(btree, CMP, Arrays.asList(2), monitor);
1:5250d7f:         assertArrayEquals(new Object[] {1, 2, null}, btree);
1:5ab1d95:         assertEquals(1, monitor.getNumberOfCalls(2));
1:5ab1d95: 
1:5ab1d95:         // with existing value
1:5ab1d95:         monitor.clear();
1:a991b64:         btree = BTree.update(btree, CMP, Arrays.asList(1), monitor);
1:5250d7f:         assertArrayEquals(new Object[] {1, 2, null}, btree);
1:5ab1d95:         assertEquals(1, monitor.getNumberOfCalls(1));
1:5ab1d95: 
1:5ab1d95:         // with two non-existing values
1:5ab1d95:         monitor.clear();
1:a991b64:         btree = BTree.update(btree, CMP, Arrays.asList(3, 4), monitor);
1:5250d7f:         assertArrayEquals(new Object[] {1, 2, 3, 4, null}, btree);
1:5ab1d95:         assertEquals(1, monitor.getNumberOfCalls(3));
1:5ab1d95:         assertEquals(1, monitor.getNumberOfCalls(4));
1:5ab1d95: 
1:a991b64:         // with one existing value and one non existing value
1:5ab1d95:         monitor.clear();
1:a991b64:         btree = BTree.update(btree, CMP, Arrays.asList(2, 5), monitor);
1:5250d7f:         assertArrayEquals(new Object[] {3, new Object[]{1, 2, null}, new Object[]{4, 5, null},  new int[]{2, 5}}, btree);
1:5ab1d95:         assertEquals(1, monitor.getNumberOfCalls(2));
1:5ab1d95:         assertEquals(1, monitor.getNumberOfCalls(5));
1:5ab1d95:     }
1:5ab1d95: 
1:639d4b2:     /**
1:639d4b2:      * Tests that the apply method of the <code>UpdateFunction</code> is only called once per value with each build call.
1:639d4b2:      */
1:639d4b2:     @Test
1:5ab1d95:     public void testBuilding_UpdateFunctionCallBack()
1:639d4b2:     {
1:5ab1d95:         CallsMonitor monitor = new CallsMonitor();
1:a991b64:         Object[] btree = BTree.build(Arrays.asList(1), monitor);
1:5250d7f:         assertArrayEquals(new Object[] {1}, btree);
1:5ab1d95:         assertEquals(1, monitor.getNumberOfCalls(1));
1:5ab1d95: 
1:5ab1d95:         monitor.clear();
1:a991b64:         btree = BTree.build(Arrays.asList(1, 2), monitor);
1:5250d7f:         assertArrayEquals(new Object[] {1, 2, null}, btree);
1:5ab1d95:         assertEquals(1, monitor.getNumberOfCalls(1));
1:5ab1d95:         assertEquals(1, monitor.getNumberOfCalls(2));
1:5ab1d95: 
1:5ab1d95:         monitor.clear();
1:a991b64:         btree = BTree.build(Arrays.asList(1, 2, 3), monitor);
1:5250d7f:         assertArrayEquals(new Object[] {1, 2, 3}, btree);
1:5ab1d95:         assertEquals(1, monitor.getNumberOfCalls(1));
1:5ab1d95:         assertEquals(1, monitor.getNumberOfCalls(2));
1:5ab1d95:         assertEquals(1, monitor.getNumberOfCalls(3));
1:5ab1d95:     }
1:5ab1d95: 
1:5ab1d95:     /**
1:e51f83b:      * Tests that the apply method of the <code>QuickResolver</code> is called exactly once per duplicate value
1:5ab1d95:      */
1:5ab1d95:     @Test
1:e51f83b:     public void testBuilder_QuickResolver()
1:e51f83b:     {
1:e51f83b:         // for numbers x in 1..N, we repeat x x times, and resolve values to their sum,
1:e51f83b:         // so that the resulting tree is of square numbers
1:e51f83b:         BTree.Builder.QuickResolver<Accumulator> resolver = (a, b) -> new Accumulator(a.base, a.sum + b.sum);
1:e51f83b: 
1:e51f83b:         for (int count = 0 ; count < 10 ; count ++)
1:e51f83b:         {
1:e51f83b:             BTree.Builder<Accumulator> builder;
1:e51f83b:             // first check we produce the right output for sorted input
1:e51f83b:             List<Accumulator> sorted = resolverInput(count, false);
1:e51f83b:             builder = BTree.builder(Comparator.naturalOrder());
1:e51f83b:             builder.setQuickResolver(resolver);
1:e51f83b:             for (Accumulator i : sorted)
1:e51f83b:                 builder.add(i);
1:e51f83b:             // for sorted input, check non-resolve path works before checking resolution path
1:e51f83b:             checkResolverOutput(count, builder.build(), BTree.Dir.ASC);
1:1e92ce4:             builder = BTree.builder(Comparator.naturalOrder());
1:1e92ce4:             builder.setQuickResolver(resolver);
1:e51f83b:             for (int i = 0 ; i < 10 ; i++)
1:e51f83b:             {
1:e51f83b:                 // now do a few runs of randomized inputs
1:e51f83b:                 for (Accumulator j : resolverInput(count, true))
1:e51f83b:                     builder.add(j);
1:e51f83b:                 checkResolverOutput(count, builder.build(), BTree.Dir.ASC);
1:1e92ce4:                 builder = BTree.builder(Comparator.naturalOrder());
1:1e92ce4:                 builder.setQuickResolver(resolver);
1:e51f83b:             }
1:e51f83b:             for (List<Accumulator> add : splitResolverInput(count))
1:e51f83b:             {
1:e51f83b:                 if (ThreadLocalRandom.current().nextBoolean())
1:e51f83b:                     builder.addAll(add);
1:e51f83b:                 else
1:e51f83b:                     builder.addAll(new TreeSet<>(add));
1:e51f83b:             }
1:e51f83b:             checkResolverOutput(count, builder.build(), BTree.Dir.ASC);
1:e51f83b:         }
1:e51f83b:     }
1:e51f83b: 
1:e51f83b:     private static class Accumulator extends Number implements Comparable<Accumulator>
1:e51f83b:     {
1:e51f83b:         final int base;
1:e51f83b:         final int sum;
1:e51f83b:         private Accumulator(int base, int sum)
1:e51f83b:         {
1:e51f83b:             this.base = base;
1:e51f83b:             this.sum = sum;
1:e51f83b:         }
1:e51f83b: 
1:e51f83b:         public int compareTo(Accumulator that) { return Integer.compare(base, that.base); }
1:e51f83b:         public int intValue() { return sum; }
1:e51f83b:         public long longValue() { return sum; }
1:e51f83b:         public float floatValue() { return sum; }
1:e51f83b:         public double doubleValue() { return sum; }
1:e51f83b:     }
1:e51f83b: 
1:e51f83b:     /**
1:e51f83b:      * Tests that the apply method of the <code>Resolver</code> is called exactly once per unique value
1:e51f83b:      */
1:e51f83b:     @Test
1:e51f83b:     public void testBuilder_ResolverAndReverse()
1:5ab1d95:     {
1:639d4b2:         // for numbers x in 1..N, we repeat x x times, and resolve values to their sum,
1:639d4b2:         // so that the resulting tree is of square numbers
1:639d4b2:         BTree.Builder.Resolver resolver = (array, lb, ub) -> {
1:639d4b2:             int sum = 0;
1:639d4b2:             for (int i = lb ; i < ub ; i++)
1:e51f83b:                 sum += ((Accumulator) array[i]).sum;
1:e51f83b:             return new Accumulator(((Accumulator) array[lb]).base, sum);
1:639d4b2:         };
1:639d4b2: 
1:639d4b2:         for (int count = 0 ; count < 10 ; count ++)
1:639d4b2:         {
1:e51f83b:             BTree.Builder<Accumulator> builder;
1:639d4b2:             // first check we produce the right output for sorted input
1:e51f83b:             List<Accumulator> sorted = resolverInput(count, false);
1:639d4b2:             builder = BTree.builder(Comparator.naturalOrder());
1:639d4b2:             builder.auto(false);
1:e51f83b:             for (Accumulator i : sorted)
1:639d4b2:                 builder.add(i);
1:639d4b2:             // for sorted input, check non-resolve path works before checking resolution path
1:639d4b2:             Assert.assertTrue(Iterables.elementsEqual(sorted, BTree.iterable(builder.build())));
1:1e92ce4: 
1:1e92ce4:             builder = BTree.builder(Comparator.naturalOrder());
1:1e92ce4:             builder.auto(false);
1:1e92ce4:             for (Accumulator i : sorted)
1:1e92ce4:                 builder.add(i);
1:1e92ce4:             // check resolution path
1:e51f83b:             checkResolverOutput(count, builder.resolve(resolver).build(), BTree.Dir.ASC);
1:1e92ce4: 
1:639d4b2:             builder = BTree.builder(Comparator.naturalOrder());
1:639d4b2:             builder.auto(false);
1:639d4b2:             for (int i = 0 ; i < 10 ; i++)
1:639d4b2:             {
1:639d4b2:                 // now do a few runs of randomized inputs
1:e51f83b:                 for (Accumulator j : resolverInput(count, true))
1:639d4b2:                     builder.add(j);
1:e51f83b:                 checkResolverOutput(count, builder.sort().resolve(resolver).build(), BTree.Dir.ASC);
1:1e92ce4:                 builder = BTree.builder(Comparator.naturalOrder());
1:1e92ce4:                 builder.auto(false);
1:e51f83b:                 for (Accumulator j : resolverInput(count, true))
1:e51f83b:                     builder.add(j);
1:e51f83b:                 checkResolverOutput(count, builder.sort().reverse().resolve(resolver).build(), BTree.Dir.DESC);
1:1e92ce4:                 builder = BTree.builder(Comparator.naturalOrder());
1:1e92ce4:                 builder.auto(false);
1:639d4b2:             }
1:639d4b2:         }
1:639d4b2:     }
1:639d4b2: 
1:e51f83b:     private static List<Accumulator> resolverInput(int count, boolean shuffled)
1:639d4b2:     {
1:e51f83b:         List<Accumulator> result = new ArrayList<>();
1:639d4b2:         for (int i = 1 ; i <= count ; i++)
1:639d4b2:             for (int j = 0 ; j < i ; j++)
1:e51f83b:                 result.add(new Accumulator(i, i));
1:639d4b2:         if (shuffled)
1:639d4b2:         {
1:639d4b2:             ThreadLocalRandom random = ThreadLocalRandom.current();
1:639d4b2:             for (int i = 0 ; i < result.size() ; i++)
1:639d4b2:             {
1:639d4b2:                 int swapWith = random.nextInt(i, result.size());
1:e51f83b:                 Accumulator t = result.get(swapWith);
1:639d4b2:                 result.set(swapWith, result.get(i));
1:639d4b2:                 result.set(i, t);
1:639d4b2:             }
1:639d4b2:         }
1:639d4b2:         return result;
1:639d4b2:     }
1:639d4b2: 
1:e51f83b:     private static List<List<Accumulator>> splitResolverInput(int count)
1:e51f83b:     {
1:e51f83b:         List<Accumulator> all = resolverInput(count, false);
1:e51f83b:         List<List<Accumulator>> result = new ArrayList<>();
1:e51f83b:         while (!all.isEmpty())
1:e51f83b:         {
1:e51f83b:             List<Accumulator> is = new ArrayList<>();
1:e51f83b:             int prev = -1;
1:e51f83b:             for (Accumulator i : new ArrayList<>(all))
1:e51f83b:             {
1:e51f83b:                 if (i.base == prev)
1:e51f83b:                     continue;
1:e51f83b:                 is.add(i);
1:e51f83b:                 all.remove(i);
1:e51f83b:                 prev = i.base;
1:e51f83b:             }
1:e51f83b:             result.add(is);
1:e51f83b:         }
1:e51f83b:         return result;
1:e51f83b:     }
1:e51f83b: 
1:e51f83b:     private static void checkResolverOutput(int count, Object[] btree, BTree.Dir dir)
1:639d4b2:     {
1:639d4b2:         int i = 1;
1:e51f83b:         for (Accumulator current : BTree.<Accumulator>iterable(btree, dir))
1:639d4b2:         {
1:e51f83b:             Assert.assertEquals(i * i, current.sum);
1:639d4b2:             i++;
1:639d4b2:         }
1:639d4b2:         Assert.assertEquals(i, count + 1);
1:639d4b2:     }
1:639d4b2: 
1:0cb1e3d:     private static void checkResult(int count, Object[] btree)
1:0cb1e3d:     {
1:639d4b2:         Iterator<Integer> iter = BTree.slice(btree, CMP, BTree.Dir.ASC);
1:0cb1e3d:         int i = 0;
1:a991b64:         while (iter.hasNext())
1:a991b64:             assertEquals(iter.next(), ints[i++]);
1:5250d7f:         assertEquals(count, i);
1:5ab1d95:     }
1:e6e596d: 
1:e6e596d:     @Test
1:e6e596d:     public void testClearOnAbort()
1:e6e596d:     {
1:a991b64:         Object[] btree = BTree.build(seq(2), noOp);
1:a991b64:         Object[] copy = Arrays.copyOf(btree, btree.length);
1:a991b64:         BTree.update(btree, CMP, seq(94), new AbortAfterX(90));
1:e6e596d: 
1:a991b64:         assertArrayEquals(copy, btree);
1:a991b64: 
1:a991b64:         btree = BTree.update(btree, CMP, seq(94), noOp);
1:a991b64:         assertTrue(BTree.isWellFormed(btree, CMP));
1:e6e596d:     }
1:e6e596d: 
1:a991b64:     private static final class AbortAfterX implements UpdateFunction<Integer, Integer>
1:e6e596d:     {
1:e6e596d:         int counter;
1:e6e596d:         final int abortAfter;
1:e6e596d:         private AbortAfterX(int abortAfter)
1:e6e596d:         {
1:e6e596d:             this.abortAfter = abortAfter;
1:e6e596d:         }
1:a991b64:         public Integer apply(Integer replacing, Integer update)
1:e6e596d:         {
1:e6e596d:             return update;
1:e6e596d:         }
1:e6e596d:         public boolean abortEarly()
1:e6e596d:         {
1:e6e596d:             return counter++ > abortAfter;
1:e6e596d:         }
1:e6e596d:         public void allocated(long heapSize)
1:e6e596d:         {
1:e6e596d:         }
1:a991b64:         public Integer apply(Integer v)
1:e6e596d:         {
1:e6e596d:             return v;
1:e6e596d:         }
1:e6e596d:     }
1:e6e596d: 
1:5ab1d95:     /**
1:5ab1d95:      * <code>UpdateFunction</code> that count the number of call made to apply for each value.
1:5ab1d95:      */
1:a991b64:     public static final class CallsMonitor implements UpdateFunction<Integer, Integer>
1:5ab1d95:     {
1:5ab1d95:         private int[] numberOfCalls = new int[20];
1:5ab1d95: 
1:5ab1d95:         public Integer apply(Integer replacing, Integer update)
1:5ab1d95:         {
1:5ab1d95:             numberOfCalls[update] = numberOfCalls[update] + 1;
1:5ab1d95:             return update;
1:5ab1d95:         }
1:5ab1d95: 
1:5ab1d95:         public boolean abortEarly()
1:5ab1d95:         {
1:5ab1d95:             return false;
1:5ab1d95:         }
1:5ab1d95: 
1:5ab1d95:         public void allocated(long heapSize)
1:5ab1d95:         {
1:5ab1d95: 
1:e6e596d:         }
1:e6e596d: 
1:5ab1d95:         public Integer apply(Integer integer)
1:5ab1d95:         {
1:5ab1d95:             numberOfCalls[integer] = numberOfCalls[integer] + 1;
1:5ab1d95:             return integer;
1:5ab1d95:         }
1:5ab1d95: 
1:5ab1d95:         public int getNumberOfCalls(Integer key)
1:5ab1d95:         {
1:5ab1d95:             return numberOfCalls[key];
1:5ab1d95:         }
1:5ab1d95: 
1:5ab1d95:         public void clear()
1:5ab1d95:         {
1:5ab1d95:             Arrays.fill(numberOfCalls, 0);
1:5ab1d95:         }
1:5ab1d95:     };
1:e6e596d: }
============================================================================
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:dc9ed46
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.collect.Lists;
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void testApplyForwards()
1:     {
1:         List<Integer> input = seq(71);
1:         Object[] btree = BTree.build(input, noOp);
1: 
1:         final List<Integer> result = new ArrayList<>();
1:         BTree.<Integer>apply(btree, i -> result.add(i), false);
1: 
1:         org.junit.Assert.assertArrayEquals(input.toArray(),result.toArray());
1:     }
1: 
1:     @Test
1:     public void testApplyReverse()
1:     {
1:         List<Integer> input = seq(71);
1:         Object[] btree = BTree.build(input, noOp);
1: 
1:         final List<Integer> result = new ArrayList<>();
1:         BTree.<Integer>apply(btree, i -> result.add(i), true);
1: 
1:         org.junit.Assert.assertArrayEquals(Lists.reverse(input).toArray(),result.toArray());
1:     }
1: 
commit:1e92ce4
/////////////////////////////////////////////////////////////////////////
1:             builder = BTree.builder(Comparator.naturalOrder());
1:             builder.setQuickResolver(resolver);
1:                 builder = BTree.builder(Comparator.naturalOrder());
1:                 builder.setQuickResolver(resolver);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:             builder = BTree.builder(Comparator.naturalOrder());
1:             builder.auto(false);
1:             for (Accumulator i : sorted)
1:                 builder.add(i);
1:             // check resolution path
1: 
/////////////////////////////////////////////////////////////////////////
1:                 builder = BTree.builder(Comparator.naturalOrder());
1:                 builder.auto(false);
1:                 builder = BTree.builder(Comparator.naturalOrder());
1:                 builder.auto(false);
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:e51f83b
/////////////////////////////////////////////////////////////////////////
1:      * Tests that the apply method of the <code>QuickResolver</code> is called exactly once per duplicate value
1:     public void testBuilder_QuickResolver()
1:     {
1:         // for numbers x in 1..N, we repeat x x times, and resolve values to their sum,
1:         // so that the resulting tree is of square numbers
1:         BTree.Builder.QuickResolver<Accumulator> resolver = (a, b) -> new Accumulator(a.base, a.sum + b.sum);
1: 
1:         for (int count = 0 ; count < 10 ; count ++)
1:         {
1:             BTree.Builder<Accumulator> builder;
1:             // first check we produce the right output for sorted input
1:             List<Accumulator> sorted = resolverInput(count, false);
1:             builder = BTree.builder(Comparator.naturalOrder());
1:             builder.setQuickResolver(resolver);
1:             for (Accumulator i : sorted)
1:                 builder.add(i);
1:             // for sorted input, check non-resolve path works before checking resolution path
1:             checkResolverOutput(count, builder.build(), BTree.Dir.ASC);
0:             builder.reuse();
1:             for (int i = 0 ; i < 10 ; i++)
1:             {
1:                 // now do a few runs of randomized inputs
1:                 for (Accumulator j : resolverInput(count, true))
1:                     builder.add(j);
1:                 checkResolverOutput(count, builder.build(), BTree.Dir.ASC);
0:                 builder.reuse();
1:             }
1:             for (List<Accumulator> add : splitResolverInput(count))
1:             {
1:                 if (ThreadLocalRandom.current().nextBoolean())
1:                     builder.addAll(add);
1:                 else
1:                     builder.addAll(new TreeSet<>(add));
1:             }
1:             checkResolverOutput(count, builder.build(), BTree.Dir.ASC);
0:             builder.reuse();
1:         }
1:     }
1: 
1:     private static class Accumulator extends Number implements Comparable<Accumulator>
1:     {
1:         final int base;
1:         final int sum;
1:         private Accumulator(int base, int sum)
1:         {
1:             this.base = base;
1:             this.sum = sum;
1:         }
1: 
1:         public int compareTo(Accumulator that) { return Integer.compare(base, that.base); }
1:         public int intValue() { return sum; }
1:         public long longValue() { return sum; }
1:         public float floatValue() { return sum; }
1:         public double doubleValue() { return sum; }
1:     }
1: 
1:     /**
1:      * Tests that the apply method of the <code>Resolver</code> is called exactly once per unique value
1:      */
1:     @Test
1:     public void testBuilder_ResolverAndReverse()
1:                 sum += ((Accumulator) array[i]).sum;
1:             return new Accumulator(((Accumulator) array[lb]).base, sum);
1:             BTree.Builder<Accumulator> builder;
1:             List<Accumulator> sorted = resolverInput(count, false);
1:             for (Accumulator i : sorted)
1:             checkResolverOutput(count, builder.resolve(resolver).build(), BTree.Dir.ASC);
1:                 for (Accumulator j : resolverInput(count, true))
1:                 checkResolverOutput(count, builder.sort().resolve(resolver).build(), BTree.Dir.ASC);
0:                 builder.reuse();
1:                 for (Accumulator j : resolverInput(count, true))
1:                     builder.add(j);
1:                 checkResolverOutput(count, builder.sort().reverse().resolve(resolver).build(), BTree.Dir.DESC);
1:     private static List<Accumulator> resolverInput(int count, boolean shuffled)
1:         List<Accumulator> result = new ArrayList<>();
1:                 result.add(new Accumulator(i, i));
1:                 Accumulator t = result.get(swapWith);
/////////////////////////////////////////////////////////////////////////
1:     private static List<List<Accumulator>> splitResolverInput(int count)
1:     {
1:         List<Accumulator> all = resolverInput(count, false);
1:         List<List<Accumulator>> result = new ArrayList<>();
1:         while (!all.isEmpty())
1:         {
1:             List<Accumulator> is = new ArrayList<>();
1:             int prev = -1;
1:             for (Accumulator i : new ArrayList<>(all))
1:             {
1:                 if (i.base == prev)
1:                     continue;
1:                 is.add(i);
1:                 all.remove(i);
1:                 prev = i.base;
1:             }
1:             result.add(is);
1:         }
1:         return result;
1:     }
1: 
1:     private static void checkResolverOutput(int count, Object[] btree, BTree.Dir dir)
1:         for (Accumulator current : BTree.<Accumulator>iterable(btree, dir))
1:             Assert.assertEquals(i * i, current.sum);
commit:639d4b2
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.collect.Iterables;
1: import junit.framework.Assert;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Tests that the apply method of the <code>UpdateFunction</code> is only called once per value with each build call.
1:      */
1:     @Test
0:     public void testBuilder_Resolver()
1:     {
1:         // for numbers x in 1..N, we repeat x x times, and resolve values to their sum,
1:         // so that the resulting tree is of square numbers
1:         BTree.Builder.Resolver resolver = (array, lb, ub) -> {
1:             int sum = 0;
1:             for (int i = lb ; i < ub ; i++)
0:                 sum += (Integer) array[i];
0:             return sum;
1:         };
1: 
1:         for (int count = 0 ; count < 10 ; count ++)
1:         {
0:             BTree.Builder<Integer> builder;
1:             // first check we produce the right output for sorted input
0:             List<Integer> sorted = resolverInput(count, false);
1:             builder = BTree.builder(Comparator.naturalOrder());
1:             builder.auto(false);
0:             for (Integer i : sorted)
1:                 builder.add(i);
1:             // for sorted input, check non-resolve path works before checking resolution path
1:             Assert.assertTrue(Iterables.elementsEqual(sorted, BTree.iterable(builder.build())));
0:             checkResolverOutput(count, builder.resolve(resolver).build());
1:             builder = BTree.builder(Comparator.naturalOrder());
1:             builder.auto(false);
1:             for (int i = 0 ; i < 10 ; i++)
1:             {
1:                 // now do a few runs of randomized inputs
0:                 for (Integer j : resolverInput(count, true))
1:                     builder.add(j);
0:                 checkResolverOutput(count, builder.sort().resolve(resolver).build());
0:                 builder.reuse();
1:             }
1:         }
1:     }
1: 
0:     private static List<Integer> resolverInput(int count, boolean shuffled)
1:     {
0:         List<Integer> result = new ArrayList<>();
1:         for (int i = 1 ; i <= count ; i++)
1:             for (int j = 0 ; j < i ; j++)
0:                 result.add(i);
1:         if (shuffled)
1:         {
1:             ThreadLocalRandom random = ThreadLocalRandom.current();
1:             for (int i = 0 ; i < result.size() ; i++)
1:             {
1:                 int swapWith = random.nextInt(i, result.size());
0:                 Integer t = result.get(swapWith);
1:                 result.set(swapWith, result.get(i));
1:                 result.set(i, t);
1:             }
1:         }
1:         return result;
1:     }
1: 
0:     private static void checkResolverOutput(int count, Object[] btree)
1:     {
1:         int i = 1;
0:         for (Integer current : BTree.<Integer>iterable(btree))
1:         {
0:             Assert.assertEquals(i * i, current.intValue());
1:             i++;
1:         }
1:         Assert.assertEquals(i, count + 1);
1:     }
1: 
1:         Iterator<Integer> iter = BTree.slice(btree, CMP, BTree.Dir.ASC);
commit:5250d7f
/////////////////////////////////////////////////////////////////////////
1:         Object[] btree = new Object[1];
1:         assertArrayEquals(new Object[] {1}, btree);
1:         assertArrayEquals(new Object[] {1, 2, null}, btree);
1:         assertArrayEquals(new Object[] {1, 2, null}, btree);
1:         assertArrayEquals(new Object[] {1, 2, 3, 4, null}, btree);
1:         assertArrayEquals(new Object[] {3, new Object[]{1, 2, null}, new Object[]{4, 5, null},  new int[]{2, 5}}, btree);
/////////////////////////////////////////////////////////////////////////
1:         assertArrayEquals(new Object[] {1}, btree);
1:         assertArrayEquals(new Object[] {1, 2, null}, btree);
1:         assertArrayEquals(new Object[] {1, 2, 3}, btree);
/////////////////////////////////////////////////////////////////////////
0:         Iterator<Integer> iter = BTree.slice(btree, CMP, true);
1:         assertEquals(count, i);
commit:5ab1d95
/////////////////////////////////////////////////////////////////////////
1: import java.util.*;
0: import static org.junit.Assert.assertEquals;
0: import static org.junit.Assert.assertArrayEquals;
0: import static org.junit.Assert.assertTrue;
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Tests that the apply method of the <code>UpdateFunction</code> is only called once with each key update.
1:      * (see CASSANDRA-8018).
1:      */
1:     @Test
1:     public void testUpdate_UpdateFunctionCallBack()
1:     {
0:         Object[] btree = new Object[0];
1:         CallsMonitor monitor = new CallsMonitor();
1: 
0:         btree = BTree.update(btree, CMP, Arrays.asList(1), true, monitor);
0:         assertArrayEquals(new Object[] {1, null}, btree);
1:         assertEquals(1, monitor.getNumberOfCalls(1));
1: 
1:         monitor.clear();
0:         btree = BTree.update(btree, CMP, Arrays.asList(2), true, monitor);
0:         assertArrayEquals(new Object[] {1, 2}, btree);
1:         assertEquals(1, monitor.getNumberOfCalls(2));
1: 
1:         // with existing value
1:         monitor.clear();
0:         btree = BTree.update(btree, CMP, Arrays.asList(1), true, monitor);
0:         assertArrayEquals(new Object[] {1, 2}, btree);
1:         assertEquals(1, monitor.getNumberOfCalls(1));
1: 
1:         // with two non-existing values
1:         monitor.clear();
0:         btree = BTree.update(btree, CMP, Arrays.asList(3, 4), true, monitor);
0:         assertArrayEquals(new Object[] {1, 2, 3, 4}, btree);
1:         assertEquals(1, monitor.getNumberOfCalls(3));
1:         assertEquals(1, monitor.getNumberOfCalls(4));
1: 
0:         // with one existing value and one non existing value in disorder
1:         monitor.clear();
0:         btree = BTree.update(btree, CMP, Arrays.asList(5, 2), false, monitor);
0:         assertArrayEquals(new Object[] {3, new Object[]{1, 2}, new Object[]{4, 5}}, btree);
1:         assertEquals(1, monitor.getNumberOfCalls(2));
1:         assertEquals(1, monitor.getNumberOfCalls(5));
1:     }
1: 
1:     /**
0:      * Tests that the apply method of the <code>UpdateFunction</code> is only called once per value with each build call.
1:      */
1:     @Test
1:     public void testBuilding_UpdateFunctionCallBack()
1:     {
1:         CallsMonitor monitor = new CallsMonitor();
0:         Object[] btree = BTree.build(Arrays.asList(1), CMP, true, monitor);
0:         assertArrayEquals(new Object[] {1, null}, btree);
1:         assertEquals(1, monitor.getNumberOfCalls(1));
1: 
1:         monitor.clear();
0:         btree = BTree.build(Arrays.asList(1, 2), CMP, true, monitor);
0:         assertArrayEquals(new Object[] {1, 2}, btree);
1:         assertEquals(1, monitor.getNumberOfCalls(1));
1:         assertEquals(1, monitor.getNumberOfCalls(2));
1: 
1:         monitor.clear();
0:         btree = BTree.build(Arrays.asList(3, 1, 2), CMP, false, monitor);
0:         assertArrayEquals(new Object[] {1, 2, 3, null}, btree);
1:         assertEquals(1, monitor.getNumberOfCalls(1));
1:         assertEquals(1, monitor.getNumberOfCalls(2));
1:         assertEquals(1, monitor.getNumberOfCalls(3));
1:     }
1: 
0:             assertEquals(j, ints[i++]);
/////////////////////////////////////////////////////////////////////////
0:         assertTrue(BTree.isWellFormed(btree, cmp));
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <code>UpdateFunction</code> that count the number of call made to apply for each value.
1:      */
0:     public static final class CallsMonitor implements UpdateFunction<Integer>
1:     {
1:         private int[] numberOfCalls = new int[20];
1: 
1:         public Integer apply(Integer replacing, Integer update)
1:         {
1:             numberOfCalls[update] = numberOfCalls[update] + 1;
1:             return update;
1:         }
1: 
1:         public boolean abortEarly()
1:         {
1:             return false;
1:         }
1: 
1:         public void allocated(long heapSize)
1:         {
1: 
1:         }
1: 
1:         public Integer apply(Integer integer)
1:         {
1:             numberOfCalls[integer] = numberOfCalls[integer] + 1;
1:             return integer;
1:         }
1: 
1:         public int getNumberOfCalls(Integer key)
1:         {
1:             return numberOfCalls[key];
1:         }
1: 
1:         public void clear()
1:         {
1:             Arrays.fill(numberOfCalls, 0);
1:         }
1:     };
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.*;
/////////////////////////////////////////////////////////////////////////
1:     static final UpdateFunction<Integer, Integer> updateF = new UpdateFunction<Integer, Integer>()
/////////////////////////////////////////////////////////////////////////
1:     private static final UpdateFunction<Integer, Integer> noOp = new UpdateFunction<Integer, Integer>()
1:     {
1:         public Integer apply(Integer replacing, Integer update)
1:         {
1:             return update;
1:         }
1: 
1:         public boolean abortEarly()
1:         {
1:             return false;
1:         }
1: 
1:         public void allocated(long heapSize)
1:         {
1:         }
1: 
1:         public Integer apply(Integer k)
1:         {
1:             return k;
1:         }
1:     };
1: 
/////////////////////////////////////////////////////////////////////////
1:             checkResult(i, BTree.build(seq(i), updateF));
1:             checkResult(i, BTree.update(BTree.build(seq(i), noOp), CMP, seq(i), updateF));
/////////////////////////////////////////////////////////////////////////
1:         btree = BTree.update(btree, CMP, Arrays.asList(1), monitor);
1:         btree = BTree.update(btree, CMP, Arrays.asList(2), monitor);
1:         btree = BTree.update(btree, CMP, Arrays.asList(1), monitor);
1:         btree = BTree.update(btree, CMP, Arrays.asList(3, 4), monitor);
1:         // with one existing value and one non existing value
1:         btree = BTree.update(btree, CMP, Arrays.asList(2, 5), monitor);
/////////////////////////////////////////////////////////////////////////
1:         Object[] btree = BTree.build(Arrays.asList(1), monitor);
1:         btree = BTree.build(Arrays.asList(1, 2), monitor);
1:         btree = BTree.build(Arrays.asList(1, 2, 3), monitor);
/////////////////////////////////////////////////////////////////////////
0:         Iterator<Integer> iter = BTree.slice(btree, true);
1:         while (iter.hasNext())
1:             assertEquals(iter.next(), ints[i++]);
0:         assertFalse(iter.hasNext());
1:         Object[] btree = BTree.build(seq(2), noOp);
1:         Object[] copy = Arrays.copyOf(btree, btree.length);
1:         BTree.update(btree, CMP, seq(94), new AbortAfterX(90));
1:         assertArrayEquals(copy, btree);
1: 
1:         btree = BTree.update(btree, CMP, seq(94), noOp);
1:         assertTrue(BTree.isWellFormed(btree, CMP));
1:     private static final class AbortAfterX implements UpdateFunction<Integer, Integer>
/////////////////////////////////////////////////////////////////////////
1:         public Integer apply(Integer replacing, Integer update)
/////////////////////////////////////////////////////////////////////////
1:         public Integer apply(Integer v)
1:     public static final class CallsMonitor implements UpdateFunction<Integer, Integer>
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:e6e596d
/////////////////////////////////////////////////////////////////////////
0: import junit.framework.Assert;
/////////////////////////////////////////////////////////////////////////
0:             Assert.assertEquals(j, ints[i++]);
1:     @Test
1:     public void testClearOnAbort()
1:     {
0:         final Comparator<String> cmp = new Comparator<String>()
1:         {
0:             public int compare(String o1, String o2)
1:             {
0:                 return o1.compareTo(o2);
1:             }
1:         };
1: 
0:         Object[] btree = BTree.build(ranges(range(0, 8)), cmp, true, UpdateFunction.NoOp.<String>instance());
0:         BTree.update(btree, cmp, ranges(range(0, 94)), false, new AbortAfterX(90));
0:         btree = BTree.update(btree, cmp, ranges(range(0, 94)), false, UpdateFunction.NoOp.<String>instance());
0:         Assert.assertTrue(BTree.isWellFormed(btree, cmp));
1:     }
1: 
0:     private static final class AbortAfterX implements UpdateFunction<String>
1:     {
1:         int counter;
1:         final int abortAfter;
1:         private AbortAfterX(int abortAfter)
1:         {
1:             this.abortAfter = abortAfter;
1:         }
0:         public String apply(String replacing, String update)
1:         {
1:             return update;
1:         }
1:         public boolean abortEarly()
1:         {
1:             return counter++ > abortAfter;
1:         }
1:         public void allocated(long heapSize)
1:         {
1:         }
0:         public String apply(String v)
1:         {
1:             return v;
1:         }
1:     }
1: 
0:     private static int[] range(int lb, int ub)
1:     {
0:         return new int[] { lb, ub };
1:     }
1: 
0:     private static List<String> ranges(int[] ... ranges)
1:     {
1: 
0:         List<String> r = new ArrayList<>();
0:         for (int[] range : ranges)
1:         {
0:             for (int i = range[0] ; i < range[1] ; i+=1)
0:                 r.add(Integer.toString(i));
1:         }
1:         return r;
1:     }
commit:0cb1e3d
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.utils;
1: 
0: import java.util.ArrayList;
0: import java.util.Comparator;
0: import java.util.List;
0: import java.util.Random;
1: import java.util.concurrent.ThreadLocalRandom;
1: 
1: import org.junit.Test;
1: 
1: import org.apache.cassandra.utils.btree.BTree;
0: import org.apache.cassandra.utils.btree.BTreeSet;
1: import org.apache.cassandra.utils.btree.UpdateFunction;
1: 
1: public class BTreeTest
1: {
1: 
1:     static Integer[] ints = new Integer[20];
1:     static
1:     {
1:         System.setProperty("cassandra.btree.fanfactor", "4");
1:         for (int i = 0 ; i < ints.length ; i++)
1:             ints[i] = new Integer(i);
1:     }
1: 
0:     static final UpdateFunction<Integer> updateF = new UpdateFunction<Integer>()
1:     {
1:         public Integer apply(Integer replacing, Integer update)
1:         {
1:             return ints[update];
1:         }
1: 
1:         public boolean abortEarly()
1:         {
1:             return false;
1:         }
1: 
1:         public void allocated(long heapSize)
1:         {
1: 
1:         }
1: 
1:         public Integer apply(Integer integer)
1:         {
1:             return ints[integer];
1:         }
1:     };
1: 
1:     private static List<Integer> seq(int count)
1:     {
1:         List<Integer> r = new ArrayList<>();
1:         for (int i = 0 ; i < count ; i++)
1:             r.add(i);
1:         return r;
1:     }
1: 
1:     private static List<Integer> rand(int count)
1:     {
1:         Random rand = ThreadLocalRandom.current();
1:         List<Integer> r = seq(count);
1:         for (int i = 0 ; i < count - 1 ; i++)
1:         {
1:             int swap = i + rand.nextInt(count - i);
1:             Integer tmp = r.get(i);
1:             r.set(i, r.get(swap));
1:             r.set(swap, tmp);
1:         }
1:         return r;
1:     }
1: 
1:     private static final Comparator<Integer> CMP = new Comparator<Integer>()
1:     {
1:         public int compare(Integer o1, Integer o2)
1:         {
1:             return Integer.compare(o1, o2);
1:         }
1:     };
1: 
1:     @Test
1:     public void testBuilding_UpdateFunctionReplacement()
1:     {
1:         for (int i = 0; i < 20 ; i++)
1:         {
0:             checkResult(i, BTree.build(seq(i), CMP, true, updateF));
0:             checkResult(i, BTree.build(rand(i), CMP, false, updateF));
1:         }
1:     }
1: 
1:     @Test
1:     public void testUpdate_UpdateFunctionReplacement()
1:     {
1:         for (int i = 0; i < 20 ; i++)
1:         {
0:             checkResult(i, BTree.update(BTree.build(seq(i), CMP, true, UpdateFunction.NoOp.<Integer>instance()), CMP, seq(i), true, updateF));
0:             checkResult(i, BTree.update(BTree.build(rand(i), CMP, false, UpdateFunction.NoOp.<Integer>instance()), CMP, rand(i), false, updateF));
1:         }
1:     }
1: 
1:     private static void checkResult(int count, Object[] btree)
1:     {
0:         BTreeSet<Integer> vs = new BTreeSet<>(btree, CMP);
0:         assert vs.size() == count;
1:         int i = 0;
0:         for (Integer j : vs)
0:             assert j == ints[i++];
1:     }
1: 
1: }
============================================================================