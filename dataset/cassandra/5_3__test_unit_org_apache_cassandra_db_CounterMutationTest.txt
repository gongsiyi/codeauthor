1:714c423: /*
1:cc69205:  * Licensed to the Apache Software Foundation (ASF) under one
1:cc69205:  * or more contributor license agreements.  See the NOTICE file
1:cc69205:  * distributed with this work for additional information
1:cc69205:  * regarding copyright ownership.  The ASF licenses this file
1:cc69205:  * to you under the Apache License, Version 2.0 (the
1:cc69205:  * "License"); you may not use this file except in compliance
1:cc69205:  * with the License.  You may obtain a copy of the License at
1:cc69205:  *
1:cc69205:  *     http://www.apache.org/licenses/LICENSE-2.0
1:cc69205:  *
1:cc69205:  * Unless required by applicable law or agreed to in writing, software
1:cc69205:  * distributed under the License is distributed on an "AS IS" BASIS,
1:cc69205:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:cc69205:  * See the License for the specific language governing permissions and
1:cc69205:  * limitations under the License.
1:cc69205:  */
1:cc69205: package org.apache.cassandra.db;
1:8125047: 
1:d2a3827: import org.junit.BeforeClass;
1:cc69205: import org.junit.Test;
1:17ad4cc: 
1:a991b64: import org.apache.cassandra.Util;
1:a991b64: import org.apache.cassandra.config.ColumnDefinition;
1:438acfc: import org.apache.cassandra.SchemaLoader;
1:a991b64: import org.apache.cassandra.db.rows.Row;
1:714c423: import org.apache.cassandra.db.context.CounterContext;
1:d2a3827: import org.apache.cassandra.exceptions.ConfigurationException;
1:714c423: import org.apache.cassandra.exceptions.WriteTimeoutException;
1:31e3f61: import org.apache.cassandra.schema.KeyspaceParams;
1:a991b64: import org.apache.cassandra.utils.ByteBufferUtil;
1:714c423: 
1:714c423: import static org.junit.Assert.assertEquals;
1:714c423: 
1:d2a3827: public class CounterMutationTest
3:640deaa: {
1:d2a3827:     private static final String KEYSPACE1 = "CounterMutationTest";
1:714c423:     private static final String CF1 = "Counter1";
1:714c423:     private static final String CF2 = "Counter2";
1:714c423: 
1:d2a3827:     @BeforeClass
1:d2a3827:     public static void defineSchema() throws ConfigurationException
1:640deaa:     {
1:d2a3827:         SchemaLoader.prepareServer();
1:d2a3827:         SchemaLoader.createKeyspace(KEYSPACE1,
1:31e3f61:                                     KeyspaceParams.simple(1),
1:a991b64:                                     SchemaLoader.counterCFMD(KEYSPACE1, CF1),
1:a991b64:                                     SchemaLoader.counterCFMD(KEYSPACE1, CF2));
1:a991b64:     }
1:8125047: 
1:8125047:     @Test
1:714c423:     public void testSingleCell() throws WriteTimeoutException
1:8125047:     {
1:d2a3827:         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF1);
1:8125047:         cfs.truncateBlocking();
1:a991b64:         ColumnDefinition cDef = cfs.metadata.getColumnDefinition(ByteBufferUtil.bytes("val"));
1:8125047: 
1:714c423:         // Do the initial update (+1)
1:a991b64:         addAndCheck(cfs, 1, 1);
1:8125047: 
1:714c423:         // Make another increment (+2)
1:a991b64:         addAndCheck(cfs, 2, 3);
1:714c423: 
1:714c423:         // Decrement to 0 (-3)
1:a991b64:         addAndCheck(cfs, -3, 0);
1:8125047:     }
1:714c423: 
1:a991b64:     private void addAndCheck(ColumnFamilyStore cfs, long toAdd, long expected)
1:a991b64:     {
1:a991b64:         ColumnDefinition cDef = cfs.metadata.getColumnDefinition(ByteBufferUtil.bytes("val"));
1:a991b64:         Mutation m = new RowUpdateBuilder(cfs.metadata, 5, "key1").clustering("cc").add("val", toAdd).build();
1:a991b64:         new CounterMutation(m, ConsistencyLevel.ONE).apply();
1:a991b64: 
1:a991b64:         Row row = Util.getOnlyRow(Util.cmd(cfs).includeRow("cc").columns("val").build());
1:a991b64:         assertEquals(expected, CounterContext.instance().total(row.getCell(cDef).value()));
1:714c423:     }
1:a991b64: 
1:714c423:     @Test
1:714c423:     public void testTwoCells() throws WriteTimeoutException
1:714c423:     {
1:d2a3827:         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF1);
2:714c423:         cfs.truncateBlocking();
1:714c423: 
1:714c423:         // Do the initial update (+1, -1)
1:a991b64:         addTwoAndCheck(cfs, 1L, 1L, -1L, -1L);
1:714c423: 
1:714c423:         // Make another increment (+2, -2)
1:a991b64:         addTwoAndCheck(cfs, 2L, 3L, -2L, -3L);
1:714c423: 
1:714c423:         // Decrement to 0 (-3, +3)
1:a991b64:         addTwoAndCheck(cfs, -3L, 0L, 3L, 0L);
1:714c423:     }
1:714c423: 
1:a991b64:     private void addTwoAndCheck(ColumnFamilyStore cfs, long addOne, long expectedOne, long addTwo, long expectedTwo)
1:a991b64:     {
1:a991b64:         ColumnDefinition cDefOne = cfs.metadata.getColumnDefinition(ByteBufferUtil.bytes("val"));
1:a991b64:         ColumnDefinition cDefTwo = cfs.metadata.getColumnDefinition(ByteBufferUtil.bytes("val2"));
1:714c423: 
1:a991b64:         Mutation m = new RowUpdateBuilder(cfs.metadata, 5, "key1")
1:a991b64:             .clustering("cc")
1:a991b64:             .add("val", addOne)
1:a991b64:             .add("val2", addTwo)
1:a991b64:             .build();
1:a991b64:         new CounterMutation(m, ConsistencyLevel.ONE).apply();
1:a991b64: 
1:a991b64:         Row row = Util.getOnlyRow(Util.cmd(cfs).includeRow("cc").columns("val", "val2").build());
1:a991b64:         assertEquals(expectedOne, CounterContext.instance().total(row.getCell(cDefOne).value()));
1:a991b64:         assertEquals(expectedTwo, CounterContext.instance().total(row.getCell(cDefTwo).value()));
1:a991b64:     }
1:a991b64: 
1:714c423:     @Test
1:714c423:     public void testBatch() throws WriteTimeoutException
1:714c423:     {
1:a991b64:         ColumnFamilyStore cfsOne = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF1);
1:a991b64:         ColumnFamilyStore cfsTwo = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF2);
1:714c423: 
1:a991b64:         cfsOne.truncateBlocking();
1:a991b64:         cfsTwo.truncateBlocking();
1:714c423: 
1:714c423:         // Do the update (+1, -1), (+2, -2)
1:a991b64:         Mutation batch = new Mutation(KEYSPACE1, Util.dk("key1"));
1:a991b64:         batch.add(new RowUpdateBuilder(cfsOne.metadata, 5, "key1")
1:a991b64:             .clustering("cc")
1:a991b64:             .add("val", 1L)
1:a991b64:             .add("val2", -1L)
1:a991b64:             .build().get(cfsOne.metadata));
1:714c423: 
1:a991b64:         batch.add(new RowUpdateBuilder(cfsTwo.metadata, 5, "key1")
1:a991b64:             .clustering("cc")
1:a991b64:             .add("val", 2L)
1:a991b64:             .add("val2", -2L)
1:a991b64:             .build().get(cfsTwo.metadata));
1:714c423: 
1:a991b64:         new CounterMutation(batch, ConsistencyLevel.ONE).apply();
1:714c423: 
1:a991b64:         ColumnDefinition c1cfs1 = cfsOne.metadata.getColumnDefinition(ByteBufferUtil.bytes("val"));
1:a991b64:         ColumnDefinition c2cfs1 = cfsOne.metadata.getColumnDefinition(ByteBufferUtil.bytes("val2"));
1:714c423: 
1:a991b64:         Row row = Util.getOnlyRow(Util.cmd(cfsOne).includeRow("cc").columns("val", "val2").build());
1:a991b64:         assertEquals(1L, CounterContext.instance().total(row.getCell(c1cfs1).value()));
1:a991b64:         assertEquals(-1L, CounterContext.instance().total(row.getCell(c2cfs1).value()));
1:714c423: 
1:a991b64:         ColumnDefinition c1cfs2 = cfsTwo.metadata.getColumnDefinition(ByteBufferUtil.bytes("val"));
1:a991b64:         ColumnDefinition c2cfs2 = cfsTwo.metadata.getColumnDefinition(ByteBufferUtil.bytes("val2"));
1:a991b64:         row = Util.getOnlyRow(Util.cmd(cfsTwo).includeRow("cc").columns("val", "val2").build());
1:a991b64:         assertEquals(2L, CounterContext.instance().total(row.getCell(c1cfs2).value()));
1:a991b64:         assertEquals(-2L, CounterContext.instance().total(row.getCell(c2cfs2).value()));
1:714c423: 
2:714c423:         // Check the caches, separately
1:a991b64:         CBuilder cb = CBuilder.create(cfsOne.metadata.comparator);
1:a991b64:         cb.add("cc");
1:714c423: 
1:ecaf3b0:         assertEquals(1L, cfsOne.getCachedCounter(Util.dk("key1").getKey(), cb.build(), c1cfs1, null).count);
1:ecaf3b0:         assertEquals(-1L, cfsOne.getCachedCounter(Util.dk("key1").getKey(), cb.build(), c2cfs1, null).count);
1:714c423: 
1:ecaf3b0:         assertEquals(2L, cfsTwo.getCachedCounter(Util.dk("key1").getKey(), cb.build(), c1cfs2, null).count);
1:ecaf3b0:         assertEquals(-2L, cfsTwo.getCachedCounter(Util.dk("key1").getKey(), cb.build(), c2cfs2, null).count);
1:714c423:     }
1:a991b64: 
1:714c423:     @Test
1:714c423:     public void testDeletes() throws WriteTimeoutException
1:714c423:     {
1:d2a3827:         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF1);
1:714c423:         cfs.truncateBlocking();
1:a991b64:         ColumnDefinition cOne = cfs.metadata.getColumnDefinition(ByteBufferUtil.bytes("val"));
1:a991b64:         ColumnDefinition cTwo = cfs.metadata.getColumnDefinition(ByteBufferUtil.bytes("val2"));
1:714c423: 
1:714c423:         // Do the initial update (+1, -1)
1:a991b64:         new CounterMutation(
1:a991b64:             new RowUpdateBuilder(cfs.metadata, 5, "key1")
1:a991b64:                 .clustering("cc")
1:a991b64:                 .add("val", 1L)
1:a991b64:                 .add("val2", -1L)
1:a991b64:                 .build(),
1:a991b64:             ConsistencyLevel.ONE).apply();
1:a991b64: 
1:a991b64:         Row row = Util.getOnlyRow(Util.cmd(cfs).includeRow("cc").columns("val", "val2").build());
1:a991b64:         assertEquals(1L, CounterContext.instance().total(row.getCell(cOne).value()));
1:a991b64:         assertEquals(-1L, CounterContext.instance().total(row.getCell(cTwo).value()));
1:a991b64: 
1:714c423:         // Remove the first counter, increment the second counter
1:a991b64:         new CounterMutation(
1:a991b64:             new RowUpdateBuilder(cfs.metadata, 5, "key1")
1:a991b64:                 .clustering("cc")
1:a991b64:                 .delete(cOne)
1:a991b64:                 .add("val2", -5L)
1:a991b64:                 .build(),
1:a991b64:             ConsistencyLevel.ONE).apply();
1:714c423: 
1:a991b64:         row = Util.getOnlyRow(Util.cmd(cfs).includeRow("cc").columns("val", "val2").build());
1:a991b64:         assertEquals(null, row.getCell(cOne));
1:a991b64:         assertEquals(-6L, CounterContext.instance().total(row.getCell(cTwo).value()));
1:a991b64: 
1:714c423:         // Increment the first counter, make sure it's still shadowed by the tombstone
1:a991b64:         new CounterMutation(
1:a991b64:             new RowUpdateBuilder(cfs.metadata, 5, "key1")
1:a991b64:                 .clustering("cc")
1:a991b64:                 .add("val", 1L)
1:a991b64:                 .build(),
1:a991b64:             ConsistencyLevel.ONE).apply();
1:a991b64:         row = Util.getOnlyRow(Util.cmd(cfs).includeRow("cc").columns("val", "val2").build());
1:a991b64:         assertEquals(null, row.getCell(cOne));
1:714c423: 
1:714c423:         // Get rid of the complete partition
1:a991b64:         RowUpdateBuilder.deleteRow(cfs.metadata, 6, "key1", "cc").applyUnsafe();
1:a991b64:         Util.assertEmpty(Util.cmd(cfs).includeRow("cc").columns("val", "val2").build());
1:714c423: 
1:714c423:         // Increment both counters, ensure that both stay dead
1:a991b64:         new CounterMutation(
1:a991b64:             new RowUpdateBuilder(cfs.metadata, 6, "key1")
1:a991b64:                 .clustering("cc")
1:a991b64:                 .add("val", 1L)
1:a991b64:                 .add("val2", 1L)
1:a991b64:                 .build(),
1:a991b64:             ConsistencyLevel.ONE).apply();
1:a991b64:         Util.assertEmpty(Util.cmd(cfs).includeRow("cc").columns("val", "val2").build());
3:640deaa:     }
1:640deaa: }
============================================================================
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:ecaf3b0
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(1L, cfsOne.getCachedCounter(Util.dk("key1").getKey(), cb.build(), c1cfs1, null).count);
1:         assertEquals(-1L, cfsOne.getCachedCounter(Util.dk("key1").getKey(), cb.build(), c2cfs1, null).count);
1:         assertEquals(2L, cfsTwo.getCachedCounter(Util.dk("key1").getKey(), cb.build(), c1cfs2, null).count);
1:         assertEquals(-2L, cfsTwo.getCachedCounter(Util.dk("key1").getKey(), cb.build(), c2cfs2, null).count);
commit:31e3f61
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.schema.KeyspaceParams;
/////////////////////////////////////////////////////////////////////////
1:                                     KeyspaceParams.simple(1),
commit:8125047
/////////////////////////////////////////////////////////////////////////
0: import java.nio.ByteBuffer;
1: 
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cells = ArrayBackedSortedColumns.factory.create(cfs.metadata);
0:         cells = ArrayBackedSortedColumns.factory.create(cfs.metadata);
0:         cells = ArrayBackedSortedColumns.factory.create(cfs.metadata);
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cells = ArrayBackedSortedColumns.factory.create(cfs.metadata);
/////////////////////////////////////////////////////////////////////////
0:         cells = ArrayBackedSortedColumns.factory.create(cfs.metadata);
/////////////////////////////////////////////////////////////////////////
0:         cells = ArrayBackedSortedColumns.factory.create(cfs.metadata);
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cells1 = ArrayBackedSortedColumns.factory.create(cfs1.metadata);
0:         ColumnFamily cells2 = ArrayBackedSortedColumns.factory.create(cfs2.metadata);
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cells = ArrayBackedSortedColumns.factory.create(cfs.metadata);
/////////////////////////////////////////////////////////////////////////
0:         cells = ArrayBackedSortedColumns.factory.create(cfs.metadata);
/////////////////////////////////////////////////////////////////////////
0:         cells = ArrayBackedSortedColumns.factory.create(cfs.metadata);
/////////////////////////////////////////////////////////////////////////
0:         cells = ArrayBackedSortedColumns.factory.create(cfs.metadata);
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test
0:     public void testDuplicateCells() throws WriteTimeoutException
1:     {
0:         ColumnFamilyStore cfs = Keyspace.open(KS).getColumnFamilyStore(CF1);
1:         cfs.truncateBlocking();
1: 
0:         ColumnFamily cells = ArrayBackedSortedColumns.factory.create(cfs.metadata);
0:         cells.addCounter(cellname(1), 1L);
0:         cells.addCounter(cellname(1), 2L);
0:         cells.addCounter(cellname(1), 3L);
0:         cells.addCounter(cellname(1), 4L);
0:         new CounterMutation(new Mutation(KS, bytes(1), cells), ConsistencyLevel.ONE).apply();
1: 
0:         ColumnFamily current = cfs.getColumnFamily(QueryFilter.getIdentityFilter(dk(bytes(1)), CF1, System.currentTimeMillis()));
0:         ByteBuffer context = current.getColumn(cellname(1)).value();
0:         assertEquals(10L, CounterContext.instance().total(context));
0:         assertEquals(ClockAndCount.create(1L, 10L), CounterContext.instance().getLocalClockAndCount(context));
0:         assertEquals(ClockAndCount.create(1L, 10L), cfs.getCachedCounter(bytes(1), cellname(1)));
1:     }
commit:714c423
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.context.CounterContext;
0: import org.apache.cassandra.db.filter.QueryFilter;
1: import org.apache.cassandra.exceptions.WriteTimeoutException;
0: import org.apache.cassandra.utils.FBUtilities;
1: 
1: import static org.junit.Assert.assertEquals;
0: import static org.junit.Assert.assertNull;
1: 
0: import static org.apache.cassandra.Util.cellname;
0: import static org.apache.cassandra.Util.dk;
0: import static org.apache.cassandra.utils.ByteBufferUtil.bytes;
0:     private static final String KS = "CounterCacheSpace";
1:     private static final String CF1 = "Counter1";
1:     private static final String CF2 = "Counter2";
1: 
1:     public void testSingleCell() throws WriteTimeoutException
0:         ColumnFamilyStore cfs = Keyspace.open(KS).getColumnFamilyStore(CF1);
1:         cfs.truncateBlocking();
1:         // Do the initial update (+1)
0:         ColumnFamily cells = UnsortedColumns.factory.create(cfs.metadata);
0:         cells.addCounter(cellname(1), 1L);
0:         new CounterMutation(new Mutation(KS, bytes(1), cells), ConsistencyLevel.ONE).apply();
0:         ColumnFamily current = cfs.getColumnFamily(QueryFilter.getIdentityFilter(dk(bytes(1)), CF1, System.currentTimeMillis()));
0:         assertEquals(1L, CounterContext.instance().total(current.getColumn(cellname(1)).value()));
1:         // Make another increment (+2)
0:         cells = UnsortedColumns.factory.create(cfs.metadata);
0:         cells.addCounter(cellname(1), 2L);
0:         new CounterMutation(new Mutation(KS, bytes(1), cells), ConsistencyLevel.ONE).apply();
0:         current = cfs.getColumnFamily(QueryFilter.getIdentityFilter(dk(bytes(1)), CF1, System.currentTimeMillis()));
0:         assertEquals(3L, CounterContext.instance().total(current.getColumn(cellname(1)).value()));
1: 
1:         // Decrement to 0 (-3)
0:         cells = UnsortedColumns.factory.create(cfs.metadata);
0:         cells.addCounter(cellname(1), -3L);
0:         new CounterMutation(new Mutation(KS, bytes(1), cells), ConsistencyLevel.ONE).apply();
0:         current = cfs.getColumnFamily(QueryFilter.getIdentityFilter(dk(bytes(1)), CF1, System.currentTimeMillis()));
0:         assertEquals(0L, CounterContext.instance().total(current.getColumn(cellname(1)).value()));
0:         assertEquals(ClockAndCount.create(3L, 0L), cfs.getCachedCounter(bytes(1), cellname(1)));
1:     }
1: 
1:     @Test
1:     public void testTwoCells() throws WriteTimeoutException
1:     {
0:         ColumnFamilyStore cfs = Keyspace.open(KS).getColumnFamilyStore(CF1);
1:         cfs.truncateBlocking();
1: 
1:         // Do the initial update (+1, -1)
0:         ColumnFamily cells = UnsortedColumns.factory.create(cfs.metadata);
0:         cells.addCounter(cellname(1), 1L);
0:         cells.addCounter(cellname(2), -1L);
0:         new CounterMutation(new Mutation(KS, bytes(1), cells), ConsistencyLevel.ONE).apply();
0:         ColumnFamily current = cfs.getColumnFamily(QueryFilter.getIdentityFilter(dk(bytes(1)), CF1, System.currentTimeMillis()));
0:         assertEquals(1L, CounterContext.instance().total(current.getColumn(cellname(1)).value()));
0:         assertEquals(-1L, CounterContext.instance().total(current.getColumn(cellname(2)).value()));
1: 
1:         // Make another increment (+2, -2)
0:         cells = UnsortedColumns.factory.create(cfs.metadata);
0:         cells.addCounter(cellname(1), 2L);
0:         cells.addCounter(cellname(2), -2L);
0:         new CounterMutation(new Mutation(KS, bytes(1), cells), ConsistencyLevel.ONE).apply();
0:         current = cfs.getColumnFamily(QueryFilter.getIdentityFilter(dk(bytes(1)), CF1, System.currentTimeMillis()));
0:         assertEquals(3L, CounterContext.instance().total(current.getColumn(cellname(1)).value()));
1: 
1:         // Decrement to 0 (-3, +3)
0:         cells = UnsortedColumns.factory.create(cfs.metadata);
0:         cells.addCounter(cellname(1), -3L);
0:         cells.addCounter(cellname(2), 3L);
0:         new CounterMutation(new Mutation(KS, bytes(1), cells), ConsistencyLevel.ONE).apply();
0:         current = cfs.getColumnFamily(QueryFilter.getIdentityFilter(dk(bytes(1)), CF1, System.currentTimeMillis()));
0:         assertEquals(0L, CounterContext.instance().total(current.getColumn(cellname(1)).value()));
0:         assertEquals(0L, CounterContext.instance().total(current.getColumn(cellname(2)).value()));
1: 
1:         // Check the caches, separately
0:         assertEquals(ClockAndCount.create(3L, 0L), cfs.getCachedCounter(bytes(1), cellname(1)));
0:         assertEquals(ClockAndCount.create(3L, 0L), cfs.getCachedCounter(bytes(1), cellname(2)));
1:     }
1: 
1:     @Test
1:     public void testBatch() throws WriteTimeoutException
1:     {
0:         ColumnFamilyStore cfs1 = Keyspace.open(KS).getColumnFamilyStore(CF1);
0:         ColumnFamilyStore cfs2 = Keyspace.open(KS).getColumnFamilyStore(CF2);
1: 
0:         cfs1.truncateBlocking();
0:         cfs2.truncateBlocking();
1: 
1:         // Do the update (+1, -1), (+2, -2)
0:         ColumnFamily cells1 = UnsortedColumns.factory.create(cfs1.metadata);
0:         cells1.addCounter(cellname(1), 1L);
0:         cells1.addCounter(cellname(2), -1L);
1: 
0:         ColumnFamily cells2 = UnsortedColumns.factory.create(cfs2.metadata);
0:         cells2.addCounter(cellname(1), 2L);
0:         cells2.addCounter(cellname(2), -2L);
1: 
0:         Mutation mutation = new Mutation(KS, bytes(1));
0:         mutation.add(cells1);
0:         mutation.add(cells2);
1: 
0:         new CounterMutation(mutation, ConsistencyLevel.ONE).apply();
1: 
0:         // Validate all values
0:         ColumnFamily current1 = cfs1.getColumnFamily(QueryFilter.getIdentityFilter(dk(bytes(1)), CF1, System.currentTimeMillis()));
0:         ColumnFamily current2 = cfs2.getColumnFamily(QueryFilter.getIdentityFilter(dk(bytes(1)), CF2, System.currentTimeMillis()));
1: 
0:         assertEquals(1L, CounterContext.instance().total(current1.getColumn(cellname(1)).value()));
0:         assertEquals(-1L, CounterContext.instance().total(current1.getColumn(cellname(2)).value()));
0:         assertEquals(2L, CounterContext.instance().total(current2.getColumn(cellname(1)).value()));
0:         assertEquals(-2L, CounterContext.instance().total(current2.getColumn(cellname(2)).value()));
1: 
1:         // Check the caches, separately
0:         assertEquals(ClockAndCount.create(1L, 1L), cfs1.getCachedCounter(bytes(1), cellname(1)));
0:         assertEquals(ClockAndCount.create(1L, -1L), cfs1.getCachedCounter(bytes(1), cellname(2)));
0:         assertEquals(ClockAndCount.create(1L, 2L), cfs2.getCachedCounter(bytes(1), cellname(1)));
0:         assertEquals(ClockAndCount.create(1L, -2L), cfs2.getCachedCounter(bytes(1), cellname(2)));
1:     }
1: 
1:     @Test
1:     public void testDeletes() throws WriteTimeoutException
1:     {
0:         ColumnFamilyStore cfs = Keyspace.open(KS).getColumnFamilyStore(CF1);
1:         cfs.truncateBlocking();
1: 
1:         // Do the initial update (+1, -1)
0:         ColumnFamily cells = UnsortedColumns.factory.create(cfs.metadata);
0:         cells.addCounter(cellname(1), 1L);
0:         cells.addCounter(cellname(2), 1L);
0:         new CounterMutation(new Mutation(KS, bytes(1), cells), ConsistencyLevel.ONE).apply();
0:         ColumnFamily current = cfs.getColumnFamily(QueryFilter.getIdentityFilter(dk(bytes(1)), CF1, System.currentTimeMillis()));
0:         assertEquals(1L, CounterContext.instance().total(current.getColumn(cellname(1)).value()));
0:         assertEquals(1L, CounterContext.instance().total(current.getColumn(cellname(2)).value()));
1: 
1:         // Remove the first counter, increment the second counter
0:         cells = UnsortedColumns.factory.create(cfs.metadata);
0:         cells.addTombstone(cellname(1), (int) System.currentTimeMillis() / 1000, FBUtilities.timestampMicros());
0:         cells.addCounter(cellname(2), 1L);
0:         new CounterMutation(new Mutation(KS, bytes(1), cells), ConsistencyLevel.ONE).apply();
0:         current = cfs.getColumnFamily(QueryFilter.getIdentityFilter(dk(bytes(1)), CF1, System.currentTimeMillis()));
0:         assertNull(current.getColumn(cellname(1)));
0:         assertEquals(2L, CounterContext.instance().total(current.getColumn(cellname(2)).value()));
1: 
1:         // Increment the first counter, make sure it's still shadowed by the tombstone
0:         cells = UnsortedColumns.factory.create(cfs.metadata);
0:         cells.addCounter(cellname(1), 1L);
0:         new CounterMutation(new Mutation(KS, bytes(1), cells), ConsistencyLevel.ONE).apply();
0:         current = cfs.getColumnFamily(QueryFilter.getIdentityFilter(dk(bytes(1)), CF1, System.currentTimeMillis()));
0:         assertNull(current.getColumn(cellname(1)));
1: 
1:         // Get rid of the complete partition
0:         Mutation mutation = new Mutation(KS, bytes(1));
0:         mutation.delete(CF1, FBUtilities.timestampMicros());
0:         new CounterMutation(mutation, ConsistencyLevel.ONE).apply();
0:         current = cfs.getColumnFamily(QueryFilter.getIdentityFilter(dk(bytes(1)), CF1, System.currentTimeMillis()));
0:         assertNull(current.getColumn(cellname(1)));
0:         assertNull(current.getColumn(cellname(2)));
1: 
1:         // Increment both counters, ensure that both stay dead
0:         cells = UnsortedColumns.factory.create(cfs.metadata);
0:         cells.addCounter(cellname(1), 1L);
0:         cells.addCounter(cellname(2), 1L);
0:         new CounterMutation(new Mutation(KS, bytes(1), cells), ConsistencyLevel.ONE).apply();
0:         current = cfs.getColumnFamily(QueryFilter.getIdentityFilter(dk(bytes(1)), CF1, System.currentTimeMillis()));
0:         assertNull(current.getColumn(cellname(1)));
0:         assertNull(current.getColumn(cellname(2)));
commit:83cd80b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:0e96e58
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = Util.getColumnFamily(Keyspace.open("Keyspace1"), dk, "Counter1");
/////////////////////////////////////////////////////////////////////////
0:     public void testGetOldShardFromSystemKeyspace() throws IOException
0:         // the system keyspace that what is in memory
0:         List<CounterId.CounterIdRecord> onDisk = SystemKeyspace.getOldLocalCounterIds();
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.Util;
1: import org.apache.cassandra.config.ColumnDefinition;
1: import org.apache.cassandra.db.rows.Row;
0: import org.apache.cassandra.db.partitions.PartitionIterator;
1: import org.apache.cassandra.utils.ByteBufferUtil;
/////////////////////////////////////////////////////////////////////////
1:                                     SchemaLoader.counterCFMD(KEYSPACE1, CF1),
1:                                     SchemaLoader.counterCFMD(KEYSPACE1, CF2));
/////////////////////////////////////////////////////////////////////////
1:         ColumnDefinition cDef = cfs.metadata.getColumnDefinition(ByteBufferUtil.bytes("val"));
1:         addAndCheck(cfs, 1, 1);
1:         addAndCheck(cfs, 2, 3);
1:         addAndCheck(cfs, -3, 0);
1:     }
1: 
1:     private void addAndCheck(ColumnFamilyStore cfs, long toAdd, long expected)
1:     {
1:         ColumnDefinition cDef = cfs.metadata.getColumnDefinition(ByteBufferUtil.bytes("val"));
1:         Mutation m = new RowUpdateBuilder(cfs.metadata, 5, "key1").clustering("cc").add("val", toAdd).build();
1:         new CounterMutation(m, ConsistencyLevel.ONE).apply();
1: 
1:         Row row = Util.getOnlyRow(Util.cmd(cfs).includeRow("cc").columns("val").build());
1:         assertEquals(expected, CounterContext.instance().total(row.getCell(cDef).value()));
/////////////////////////////////////////////////////////////////////////
1:         addTwoAndCheck(cfs, 1L, 1L, -1L, -1L);
1:         addTwoAndCheck(cfs, 2L, 3L, -2L, -3L);
1:         addTwoAndCheck(cfs, -3L, 0L, 3L, 0L);
1:     }
1:     private void addTwoAndCheck(ColumnFamilyStore cfs, long addOne, long expectedOne, long addTwo, long expectedTwo)
1:     {
1:         ColumnDefinition cDefOne = cfs.metadata.getColumnDefinition(ByteBufferUtil.bytes("val"));
1:         ColumnDefinition cDefTwo = cfs.metadata.getColumnDefinition(ByteBufferUtil.bytes("val2"));
1: 
1:         Mutation m = new RowUpdateBuilder(cfs.metadata, 5, "key1")
1:             .clustering("cc")
1:             .add("val", addOne)
1:             .add("val2", addTwo)
1:             .build();
1:         new CounterMutation(m, ConsistencyLevel.ONE).apply();
1: 
1:         Row row = Util.getOnlyRow(Util.cmd(cfs).includeRow("cc").columns("val", "val2").build());
1:         assertEquals(expectedOne, CounterContext.instance().total(row.getCell(cDefOne).value()));
1:         assertEquals(expectedTwo, CounterContext.instance().total(row.getCell(cDefTwo).value()));
1:         ColumnFamilyStore cfsOne = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF1);
1:         ColumnFamilyStore cfsTwo = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF2);
1:         cfsOne.truncateBlocking();
1:         cfsTwo.truncateBlocking();
1:         Mutation batch = new Mutation(KEYSPACE1, Util.dk("key1"));
1:         batch.add(new RowUpdateBuilder(cfsOne.metadata, 5, "key1")
1:             .clustering("cc")
1:             .add("val", 1L)
1:             .add("val2", -1L)
1:             .build().get(cfsOne.metadata));
1:         batch.add(new RowUpdateBuilder(cfsTwo.metadata, 5, "key1")
1:             .clustering("cc")
1:             .add("val", 2L)
1:             .add("val2", -2L)
1:             .build().get(cfsTwo.metadata));
1:         new CounterMutation(batch, ConsistencyLevel.ONE).apply();
1:         ColumnDefinition c1cfs1 = cfsOne.metadata.getColumnDefinition(ByteBufferUtil.bytes("val"));
1:         ColumnDefinition c2cfs1 = cfsOne.metadata.getColumnDefinition(ByteBufferUtil.bytes("val2"));
1:         Row row = Util.getOnlyRow(Util.cmd(cfsOne).includeRow("cc").columns("val", "val2").build());
1:         assertEquals(1L, CounterContext.instance().total(row.getCell(c1cfs1).value()));
1:         assertEquals(-1L, CounterContext.instance().total(row.getCell(c2cfs1).value()));
1:         ColumnDefinition c1cfs2 = cfsTwo.metadata.getColumnDefinition(ByteBufferUtil.bytes("val"));
1:         ColumnDefinition c2cfs2 = cfsTwo.metadata.getColumnDefinition(ByteBufferUtil.bytes("val2"));
1:         row = Util.getOnlyRow(Util.cmd(cfsTwo).includeRow("cc").columns("val", "val2").build());
1:         assertEquals(2L, CounterContext.instance().total(row.getCell(c1cfs2).value()));
1:         assertEquals(-2L, CounterContext.instance().total(row.getCell(c2cfs2).value()));
1:         CBuilder cb = CBuilder.create(cfsOne.metadata.comparator);
1:         cb.add("cc");
1: 
0:         assertEquals(ClockAndCount.create(1L, 1L), cfsOne.getCachedCounter(Util.dk("key1").getKey(), cb.build(), c1cfs1, null));
0:         assertEquals(ClockAndCount.create(1L, -1L), cfsOne.getCachedCounter(Util.dk("key1").getKey(), cb.build(), c2cfs1, null));
1: 
0:         assertEquals(ClockAndCount.create(1L, 2L), cfsTwo.getCachedCounter(Util.dk("key1").getKey(), cb.build(), c1cfs2, null));
0:         assertEquals(ClockAndCount.create(1L, -2L), cfsTwo.getCachedCounter(Util.dk("key1").getKey(), cb.build(), c2cfs2, null));
/////////////////////////////////////////////////////////////////////////
1:         ColumnDefinition cOne = cfs.metadata.getColumnDefinition(ByteBufferUtil.bytes("val"));
1:         ColumnDefinition cTwo = cfs.metadata.getColumnDefinition(ByteBufferUtil.bytes("val2"));
1:         new CounterMutation(
1:             new RowUpdateBuilder(cfs.metadata, 5, "key1")
1:                 .clustering("cc")
1:                 .add("val", 1L)
1:                 .add("val2", -1L)
1:                 .build(),
1:             ConsistencyLevel.ONE).apply();
1: 
1:         Row row = Util.getOnlyRow(Util.cmd(cfs).includeRow("cc").columns("val", "val2").build());
1:         assertEquals(1L, CounterContext.instance().total(row.getCell(cOne).value()));
1:         assertEquals(-1L, CounterContext.instance().total(row.getCell(cTwo).value()));
1:         new CounterMutation(
1:             new RowUpdateBuilder(cfs.metadata, 5, "key1")
1:                 .clustering("cc")
1:                 .delete(cOne)
1:                 .add("val2", -5L)
1:                 .build(),
1:             ConsistencyLevel.ONE).apply();
1: 
1:         row = Util.getOnlyRow(Util.cmd(cfs).includeRow("cc").columns("val", "val2").build());
1:         assertEquals(null, row.getCell(cOne));
1:         assertEquals(-6L, CounterContext.instance().total(row.getCell(cTwo).value()));
1:         new CounterMutation(
1:             new RowUpdateBuilder(cfs.metadata, 5, "key1")
1:                 .clustering("cc")
1:                 .add("val", 1L)
1:                 .build(),
1:             ConsistencyLevel.ONE).apply();
1:         row = Util.getOnlyRow(Util.cmd(cfs).includeRow("cc").columns("val", "val2").build());
1:         assertEquals(null, row.getCell(cOne));
1:         RowUpdateBuilder.deleteRow(cfs.metadata, 6, "key1", "cc").applyUnsafe();
1:         Util.assertEmpty(Util.cmd(cfs).includeRow("cc").columns("val", "val2").build());
1:         new CounterMutation(
1:             new RowUpdateBuilder(cfs.metadata, 6, "key1")
1:                 .clustering("cc")
1:                 .add("val", 1L)
1:                 .add("val2", 1L)
1:                 .build(),
1:             ConsistencyLevel.ONE).apply();
1:         Util.assertEmpty(Util.cmd(cfs).includeRow("cc").columns("val", "val2").build());
commit:3a005df
/////////////////////////////////////////////////////////////////////////
0:         rm.addCounter("Counter1", ByteBufferUtil.bytes("Column1"), 3);
/////////////////////////////////////////////////////////////////////////
0:         rm.addCounter("Counter1", ByteBufferUtil.bytes("Column1"), 4);
/////////////////////////////////////////////////////////////////////////
0:         rm.addCounter("Counter1", ByteBufferUtil.bytes("Column1"), 5);
0:         rm.addCounter("Counter1", ByteBufferUtil.bytes("Column2"), 1);
/////////////////////////////////////////////////////////////////////////
0:         Column c = cf.getColumn(ByteBufferUtil.bytes("Column1"));
/////////////////////////////////////////////////////////////////////////
commit:3b13457
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         CounterId id1 = CounterId.getLocalId();
0:         CounterId.renewLocalId(2L); // faking time of renewal for test
0:         CounterId id2 = CounterId.getLocalId();
0:         CounterId.renewLocalId(4L); // faking time of renewal for test
0:         CounterId id3 = CounterId.getLocalId();
/////////////////////////////////////////////////////////////////////////
0:         assert s.getCounterId().equals(id1);
0:         assert s.getCounterId().equals(id2);
0:         assert s.getCounterId().equals(id3);
/////////////////////////////////////////////////////////////////////////
0:         assert s.getCounterId().equals(id3);
/////////////////////////////////////////////////////////////////////////
0:         CounterId.renewLocalId();
0:         CounterId.renewLocalId();
0:         CounterId.renewLocalId();
0:         List<CounterId.CounterIdRecord> inMem = CounterId.getOldLocalCounterIds();
0:         List<CounterId.CounterIdRecord> onDisk = SystemTable.getOldLocalCounterIds();
/////////////////////////////////////////////////////////////////////////
0:         CounterId id1 = CounterId.getLocalId();
0:         CounterId.renewLocalId();
0:         CounterId id2 = CounterId.getLocalId();
0:         state.writeElement(CounterId.fromInt(1), 1, 4, false);
/////////////////////////////////////////////////////////////////////////
0:             ByteBuffer merger = ctx.computeOldShardMerger(state.context, Collections.<CounterId.CounterIdRecord>emptyList(), 0);
0:         CounterId.renewLocalId();
0:         ByteBuffer merger = ctx.computeOldShardMerger(state.context, Collections.<CounterId.CounterIdRecord>emptyList(), 0);
commit:438acfc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.SchemaLoader;
0: public class CounterMutationTest extends SchemaLoader
commit:17ad4cc
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collections;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.Util;
/////////////////////////////////////////////////////////////////////////
0:         NodeId id1 = NodeId.getLocalId();
1: 
0:         NodeId id2 = NodeId.getLocalId();
/////////////////////////////////////////////////////////////////////////
0:         NodeId id3 = NodeId.getLocalId();
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey dk = Util.dk("key1");
0:         ColumnFamily cf = Util.getColumnFamily(Table.open("Keyspace1"), dk, "Counter1");
0: 
0:         // First merges old shards
0:         CounterColumn.mergeAndRemoveOldShards(dk, cf, Integer.MIN_VALUE, Integer.MAX_VALUE, false);
0:         long now = System.currentTimeMillis();
0:         assert s.getCount() == 0L;
0:         assert -s.getClock() > now - 1000 : " >";
0:         assert -s.getClock() <= now;
0:         assert s.getCount() == 0L;
0:         assert -s.getClock() > now - 1000;
0:         assert -s.getClock() <= now;
0:         s.moveToNext();
0:         assert s.getNodeId().equals(id3);
0:         assert s.getCount() == 12L;
0: 
0:         // Then collect old shards
0:         CounterColumn.mergeAndRemoveOldShards(dk, cf, Integer.MAX_VALUE, Integer.MIN_VALUE, false);
0:         c = cf.getColumn(ByteBufferUtil.bytes("Column1"));
0:         assert c != null;
0:         assert c instanceof CounterColumn;
0:         assert ((CounterColumn)c).total() == 12L;
0:         s = new ContextState(c.value());
0:         assert s.getNodeId().equals(id3);
0:         assert s.getCount() == 12L;
/////////////////////////////////////////////////////////////////////////
0:         int now = (int) (System.currentTimeMillis() / 1000);
/////////////////////////////////////////////////////////////////////////
0:         state.writeElement(id2, -100, 5, true); // corrupted!
0:             ByteBuffer merger = ctx.computeOldShardMerger(state.context, Collections.<NodeId.NodeIdRecord>emptyList(), 0);
0:             ctx.removeOldShards(ctx.merge(state.context, merger, HeapAllocator.instance), now);
0:         ByteBuffer merger = ctx.computeOldShardMerger(state.context, Collections.<NodeId.NodeIdRecord>emptyList(), 0);
0:         ByteBuffer cleaned = ctx.removeOldShards(ctx.merge(state.context, merger, HeapAllocator.instance), now);
commit:640deaa
/////////////////////////////////////////////////////////////////////////
0: import java.nio.ByteBuffer;
0: import java.util.List;
0: import static org.junit.Assert.fail;
0: import org.apache.cassandra.db.context.CounterContext;
/////////////////////////////////////////////////////////////////////////
0: 
0:     @Test
0:     public void testGetOldShardFromSystemTable() throws IOException
1:     {
0:         // Renewing a bunch of times and checking we get the same thing from
0:         // the system table that what is in memory
0:         NodeId.renewLocalId();
0:         NodeId.renewLocalId();
0:         NodeId.renewLocalId();
0: 
0:         List<NodeId.NodeIdRecord> inMem = NodeId.getOldLocalNodeIds();
0:         List<NodeId.NodeIdRecord> onDisk = SystemTable.getOldLocalNodeIds();
0: 
0:         assert inMem.equals(onDisk);
1:     }
0: 
0:     @Test
0:     public void testRemoveOldShardFixCorrupted() throws IOException
1:     {
0:         CounterContext ctx = CounterContext.instance();
0: 
0:         // Check that corrupted context created prior to #2968 are fixed by removeOldShards
0:         NodeId id1 = NodeId.getLocalId();
0:         NodeId.renewLocalId();
0:         NodeId id2 = NodeId.getLocalId();
0: 
0:         ContextState state = ContextState.allocate(3, 2);
0:         state.writeElement(NodeId.fromInt(1), 1, 4, false);
0:         state.writeElement(id1, 3, 2, true);
0:         state.writeElement(id2, -System.currentTimeMillis(), 5, true); // corrupted!
0: 
0:         assert ctx.total(state.context) == 11;
0: 
0:         try
1:         {
0:             ctx.removeOldShards(state.context, Integer.MAX_VALUE);
0:             fail("RemoveOldShards should throw an exception if the current id is non-sensical");
1:         }
0:         catch (RuntimeException e) {}
0: 
0:         NodeId.renewLocalId();
0:         ByteBuffer cleaned = ctx.removeOldShards(state.context, Integer.MAX_VALUE);
0:         assert ctx.total(cleaned) == 11;
0: 
0:         // Check it is not corrupted anymore
0:         ContextState state2 = new ContextState(cleaned);
0:         while (state2.hasRemaining())
1:         {
0:             assert state2.getClock() >= 0 || state2.getCount() == 0;
0:             state2.moveToNext();
1:         }
0: 
0:         // Check that if we merge old and clean on another node, we keep the right count
0:         ByteBuffer onRemote = ctx.merge(ctx.clearAllDelta(state.context), ctx.clearAllDelta(cleaned));
0:         assert ctx.total(onRemote) == 11;
1:     }
commit:826eab0
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.cassandra.utils.ByteBufferUtil.bytes;
/////////////////////////////////////////////////////////////////////////
0: 
0:     @Test
0:     public void testMutateSuperColumns() throws IOException
0:     {
0:         RowMutation rm;
0:         CounterMutation cm;
0: 
0:         rm = new RowMutation("Keyspace1", bytes("key1"));
0:         rm.addCounter(new QueryPath("SuperCounter1", bytes("sc1"), bytes("Column1")), 1);
0:         rm.addCounter(new QueryPath("SuperCounter1", bytes("sc2"), bytes("Column1")), 1);
0:         cm = new CounterMutation(rm, ConsistencyLevel.ONE);
0:         cm.apply();
0: 
0:         rm = new RowMutation("Keyspace1", bytes("key1"));
0:         rm.addCounter(new QueryPath("SuperCounter1", bytes("sc1"), bytes("Column2")), 1);
0:         rm.addCounter(new QueryPath("SuperCounter1", bytes("sc2"), bytes("Column2")), 1);
0:         cm = new CounterMutation(rm, ConsistencyLevel.ONE);
0:         cm.apply();
0: 
0:         RowMutation reprm = cm.makeReplicationMutation();
0:         ColumnFamily cf = reprm.getColumnFamilies().iterator().next();
0: 
0:         assert cf.getColumnCount() == 2;
0: 
0:         IColumn sc1 = cf.getColumn(bytes("sc1"));
0:         assert sc1 != null && sc1 instanceof SuperColumn;
0:         assert sc1.getSubColumns().size() == 1;
0:         assert sc1.getSubColumn(bytes("Column2")) != null;
0: 
0:         IColumn sc2 = cf.getColumn(bytes("sc2"));
0:         assert sc2 != null && sc2 instanceof SuperColumn;
0:         assert sc2.getSubColumns().size() == 1;
0:         assert sc2.getSubColumn(bytes("Column2")) != null;
0:     }
commit:cc69205
/////////////////////////////////////////////////////////////////////////
0: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.db;
0: 
0: import java.io.IOException;
0: 
1: import org.junit.Test;
0: 
0: import org.apache.cassandra.db.filter.*;
0: import org.apache.cassandra.CleanupHelper;
0: import org.apache.cassandra.thrift.*;
0: import org.apache.cassandra.utils.*;
0: import static org.apache.cassandra.db.context.CounterContext.ContextState;
0: 
0: public class CounterMutationTest extends CleanupHelper
0: {
0:     @Test
0:     public void testMergeOldShards() throws IOException
0:     {
0:         RowMutation rm;
0:         CounterMutation cm;
0: 
0:         rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes("key1"));
0:         rm.addCounter(new QueryPath("Counter1", null, ByteBufferUtil.bytes("Column1")), 3);
0:         cm = new CounterMutation(rm, ConsistencyLevel.ONE);
0:         cm.apply();
0: 
0:         NodeId.renewLocalId(2L); // faking time of renewal for test
0:         NodeId id1 = NodeId.getLocalId();
0: 
0:         rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes("key1"));
0:         rm.addCounter(new QueryPath("Counter1", null, ByteBufferUtil.bytes("Column1")), 4);
0:         cm = new CounterMutation(rm, ConsistencyLevel.ONE);
0:         cm.apply();
0: 
0:         NodeId.renewLocalId(4L); // faking time of renewal for test
0:         NodeId id2 = NodeId.getLocalId();
0: 
0:         rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes("key1"));
0:         rm.addCounter(new QueryPath("Counter1", null, ByteBufferUtil.bytes("Column1")), 5);
0:         rm.addCounter(new QueryPath("Counter1", null, ByteBufferUtil.bytes("Column2")), 1);
0:         cm = new CounterMutation(rm, ConsistencyLevel.ONE);
0:         cm.apply();
0: 
0:         RowMutation reprm = cm.makeReplicationMutation();
0:         ColumnFamily cf = reprm.getColumnFamilies().iterator().next();
0:         CounterColumn.removeOldShards(cf, Integer.MAX_VALUE);
0:         IColumn c = cf.getColumn(ByteBufferUtil.bytes("Column1"));
0:         assert c != null;
0:         assert c instanceof CounterColumn;
0: 
0:         assert ((CounterColumn)c).total() == 12L;
0:         ContextState s = new ContextState(c.value());
0:         assert s.getNodeId().equals(id1);
0:         assert s.getCount() == 7;
0:         s.moveToNext();
0:         assert s.getNodeId().equals(id2);
0:         assert s.getCount() == 5;
0:     }
0: }
0: 
author:lyubent
-------------------------------------------------------------------------------
commit:d2a3827
/////////////////////////////////////////////////////////////////////////
1: import org.junit.BeforeClass;
0: import org.apache.cassandra.config.KSMetaData;
0: import org.apache.cassandra.db.marshal.CounterColumnType;
1: import org.apache.cassandra.exceptions.ConfigurationException;
0: import org.apache.cassandra.locator.SimpleStrategy;
/////////////////////////////////////////////////////////////////////////
1: public class CounterMutationTest
1:     private static final String KEYSPACE1 = "CounterMutationTest";
1:     @BeforeClass
1:     public static void defineSchema() throws ConfigurationException
0:     {
1:         SchemaLoader.prepareServer();
1:         SchemaLoader.createKeyspace(KEYSPACE1,
0:                                     SimpleStrategy.class,
0:                                     KSMetaData.optsWithRF(1),
0:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF1).defaultValidator(CounterColumnType.instance),
0:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF2).defaultValidator(CounterColumnType.instance));
0:     }
0: 
1:         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF1);
0:         new CounterMutation(new Mutation(KEYSPACE1, bytes(1), cells), ConsistencyLevel.ONE).apply();
0:         new CounterMutation(new Mutation(KEYSPACE1, bytes(1), cells), ConsistencyLevel.ONE).apply();
0:         new CounterMutation(new Mutation(KEYSPACE1, bytes(1), cells), ConsistencyLevel.ONE).apply();
/////////////////////////////////////////////////////////////////////////
1:         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF1);
0:         new CounterMutation(new Mutation(KEYSPACE1, bytes(1), cells), ConsistencyLevel.ONE).apply();
/////////////////////////////////////////////////////////////////////////
0:         new CounterMutation(new Mutation(KEYSPACE1, bytes(1), cells), ConsistencyLevel.ONE).apply();
/////////////////////////////////////////////////////////////////////////
0:         new CounterMutation(new Mutation(KEYSPACE1, bytes(1), cells), ConsistencyLevel.ONE).apply();
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamilyStore cfs1 = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF1);
0:         ColumnFamilyStore cfs2 = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF2);
/////////////////////////////////////////////////////////////////////////
0:         Mutation mutation = new Mutation(KEYSPACE1, bytes(1));
/////////////////////////////////////////////////////////////////////////
1:         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF1);
0:         new CounterMutation(new Mutation(KEYSPACE1, bytes(1), cells), ConsistencyLevel.ONE).apply();
/////////////////////////////////////////////////////////////////////////
0:         new CounterMutation(new Mutation(KEYSPACE1, bytes(1), cells), ConsistencyLevel.ONE).apply();
/////////////////////////////////////////////////////////////////////////
0:         new CounterMutation(new Mutation(KEYSPACE1, bytes(1), cells), ConsistencyLevel.ONE).apply();
0:         Mutation mutation = new Mutation(KEYSPACE1, bytes(1));
/////////////////////////////////////////////////////////////////////////
0:         new CounterMutation(new Mutation(KEYSPACE1, bytes(1), cells), ConsistencyLevel.ONE).apply();
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF1);
/////////////////////////////////////////////////////////////////////////
0:         new CounterMutation(new Mutation(KEYSPACE1, bytes(1), cells), ConsistencyLevel.ONE).apply();
author:Dave Brosius
-------------------------------------------------------------------------------
commit:bc6b5f4
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:b95a49c
/////////////////////////////////////////////////////////////////////////
0:         ByteBuffer onRemote = ctx.merge(ctx.clearAllDelta(state.context), ctx.clearAllDelta(cleaned), HeapAllocator.instance);
============================================================================