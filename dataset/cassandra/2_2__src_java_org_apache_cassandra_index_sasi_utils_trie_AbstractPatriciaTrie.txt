1:72790dc: /*
1:72790dc:  * Copyright 2005-2010 Roger Kapsi, Sam Berlin
17:72790dc:  *
1:72790dc:  *   Licensed under the Apache License, Version 2.0 (the "License");
1:72790dc:  *   you may not use this file except in compliance with the License.
1:72790dc:  *   You may obtain a copy of the License at
1:72790dc:  *
1:72790dc:  *       http://www.apache.org/licenses/LICENSE-2.0
1:72790dc:  *
1:72790dc:  *   Unless required by applicable law or agreed to in writing, software
1:72790dc:  *   distributed under the License is distributed on an "AS IS" BASIS,
1:72790dc:  *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:72790dc:  *   See the License for the specific language governing permissions and
1:72790dc:  *   limitations under the License.
1:72790dc:  */
137:72790dc: 
6:72790dc: /**
1:72790dc:  * This class is taken from https://github.com/rkapsi/patricia-trie (v0.6), and slightly modified
1:72790dc:  * to correspond to Cassandra code style, as the only Patricia Trie implementation,
1:72790dc:  * which supports pluggable key comparators (e.g. commons-collections PatriciaTrie (which is based
1:72790dc:  * on rkapsi/patricia-trie project) only supports String keys)
1:72790dc:  * but unfortunately is not deployed to the maven central as a downloadable artifact.
1:72790dc:  */
1:72790dc: 
1:72790dc: package org.apache.cassandra.index.sasi.utils.trie;
1:72790dc: 
1:72790dc: import java.util.AbstractCollection;
1:72790dc: import java.util.AbstractSet;
1:72790dc: import java.util.Collection;
1:72790dc: import java.util.ConcurrentModificationException;
1:72790dc: import java.util.Iterator;
1:72790dc: import java.util.Map;
1:72790dc: import java.util.NoSuchElementException;
1:72790dc: import java.util.Set;
1:72790dc: 
1:72790dc: import org.apache.cassandra.index.sasi.utils.trie.Cursor.Decision;
1:72790dc: 
1:72790dc: /**
1:72790dc:  * This class implements the base PATRICIA algorithm and everything that
1:72790dc:  * is related to the {@link Map} interface.
1:72790dc:  */
1:72790dc: abstract class AbstractPatriciaTrie<K, V> extends AbstractTrie<K, V>
2:72790dc: {
1:72790dc:     private static final long serialVersionUID = -2303909182832019043L;
1:72790dc: 
1:72790dc:     /**
1:68d2526:      * The root node of the {@link Trie}.
1:72790dc:      */
1:72790dc:     final TrieEntry<K, V> root = new TrieEntry<>(null, null, -1);
1:68d2526: 
1:72790dc:     /**
1:72790dc:      * Each of these fields are initialized to contain an instance of the
1:72790dc:      * appropriate view the first time this view is requested. The views are
1:72790dc:      * stateless, so there's no reason to create more than one of each.
1:72790dc:      */
1:72790dc:     private transient volatile Set<K> keySet;
1:72790dc:     private transient volatile Collection<V> values;
1:72790dc:     private transient volatile Set<Map.Entry<K,V>> entrySet;
1:68d2526: 
1:72790dc:     /**
1:72790dc:      * The current size of the {@link Trie}
1:72790dc:      */
1:72790dc:     private int size = 0;
1:68d2526: 
1:72790dc:     /**
1:72790dc:      * The number of times this {@link Trie} has been modified.
1:72790dc:      * It's used to detect concurrent modifications and fail-fast
1:72790dc:      * the {@link Iterator}s.
1:72790dc:      */
1:72790dc:     transient int modCount = 0;
1:68d2526: 
1:72790dc:     public AbstractPatriciaTrie(KeyAnalyzer<? super K> keyAnalyzer)
1:72790dc:     {
1:72790dc:         super(keyAnalyzer);
3:72790dc:     }
1:68d2526: 
1:72790dc:     public AbstractPatriciaTrie(KeyAnalyzer<? super K> keyAnalyzer, Map<? extends K, ? extends V> m)
1:72790dc:     {
1:72790dc:         super(keyAnalyzer);
1:72790dc:         putAll(m);
1:72790dc:     }
1:68d2526: 
1:72790dc:     @Override
1:72790dc:     public void clear()
1:72790dc:     {
1:72790dc:         root.key = null;
1:72790dc:         root.bitIndex = -1;
1:72790dc:         root.value = null;
1:68d2526: 
1:72790dc:         root.parent = null;
1:72790dc:         root.left = root;
1:72790dc:         root.right = null;
1:72790dc:         root.predecessor = root;
1:68d2526: 
1:72790dc:         size = 0;
1:72790dc:         incrementModCount();
1:72790dc:     }
1:68d2526: 
1:72790dc:     @Override
1:72790dc:     public int size()
1:72790dc:     {
1:72790dc:         return size;
1:72790dc:     }
1:68d2526: 
1:68d2526:     /**
1:72790dc:      * A helper method to increment the {@link Trie} size
1:72790dc:      * and the modification counter.
1:72790dc:      */
1:72790dc:     void incrementSize()
1:72790dc:     {
1:72790dc:         size++;
1:72790dc:         incrementModCount();
1:72790dc:     }
1:68d2526: 
1:72790dc:     /**
1:72790dc:      * A helper method to decrement the {@link Trie} size
1:72790dc:      * and increment the modification counter.
1:72790dc:      */
1:72790dc:     void decrementSize()
1:72790dc:     {
1:72790dc:         size--;
1:72790dc:         incrementModCount();
1:72790dc:     }
1:68d2526: 
1:72790dc:     /**
1:72790dc:      * A helper method to increment the modification counter.
1:72790dc:      */
1:72790dc:     private void incrementModCount()
1:72790dc:     {
1:72790dc:         ++modCount;
1:72790dc:     }
1:68d2526: 
1:72790dc:     @Override
1:72790dc:     public V put(K key, V value)
1:72790dc:     {
1:72790dc:         if (key == null)
1:72790dc:             throw new NullPointerException("Key cannot be null");
1:68d2526: 
1:72790dc:         int lengthInBits = lengthInBits(key);
1:68d2526: 
1:72790dc:         // The only place to store a key with a length
1:72790dc:         // of zero bits is the root node
1:72790dc:         if (lengthInBits == 0)
1:72790dc:         {
1:72790dc:             if (root.isEmpty())
1:72790dc:                 incrementSize();
1:72790dc:             else
1:72790dc:                 incrementModCount();
1:68d2526: 
1:72790dc:             return root.setKeyValue(key, value);
1:72790dc:         }
1:68d2526: 
1:72790dc:         TrieEntry<K, V> found = getNearestEntryForKey(key);
1:72790dc:         if (compareKeys(key, found.key))
1:72790dc:         {
1:72790dc:             if (found.isEmpty()) // <- must be the root
1:72790dc:                 incrementSize();
1:72790dc:             else
1:72790dc:                 incrementModCount();
1:68d2526: 
1:72790dc:             return found.setKeyValue(key, value);
1:72790dc:         }
1:68d2526: 
1:72790dc:         int bitIndex = bitIndex(key, found.key);
1:72790dc:         if (!Tries.isOutOfBoundsIndex(bitIndex))
1:72790dc:         {
1:72790dc:             if (Tries.isValidBitIndex(bitIndex)) // in 99.999...9% the case
1:72790dc:             {
1:72790dc:                 /* NEW KEY+VALUE TUPLE */
1:72790dc:                 TrieEntry<K, V> t = new TrieEntry<>(key, value, bitIndex);
1:72790dc:                 addEntry(t);
1:72790dc:                 incrementSize();
1:72790dc:                 return null;
1:72790dc:             }
1:72790dc:             else if (Tries.isNullBitKey(bitIndex))
1:72790dc:             {
1:72790dc:                 // A bits of the Key are zero. The only place to
1:72790dc:                 // store such a Key is the root Node!
1:68d2526: 
1:72790dc:                 /* NULL BIT KEY */
1:72790dc:                 if (root.isEmpty())
1:72790dc:                     incrementSize();
1:72790dc:                 else
1:72790dc:                     incrementModCount();
1:68d2526: 
1:72790dc:                 return root.setKeyValue(key, value);
1:68d2526: 
1:72790dc:             }
1:72790dc:             else if (Tries.isEqualBitKey(bitIndex))
1:72790dc:             {
1:72790dc:                 // This is a very special and rare case.
1:68d2526: 
1:72790dc:                 /* REPLACE OLD KEY+VALUE */
1:68d2526:                 if (found != root)
1:68d2526:                 {
1:72790dc:                     incrementModCount();
1:72790dc:                     return found.setKeyValue(key, value);
1:72790dc:                 }
1:72790dc:             }
1:72790dc:         }
1:68d2526: 
1:68d2526:         throw new IndexOutOfBoundsException("Failed to put: "
1:72790dc:                 + key + " -> " + value + ", " + bitIndex);
1:72790dc:     }
1:68d2526: 
1:72790dc:     /**
1:72790dc:      * Adds the given {@link TrieEntry} to the {@link Trie}
1:72790dc:      */
1:72790dc:     TrieEntry<K, V> addEntry(TrieEntry<K, V> entry)
1:72790dc:     {
1:72790dc:         TrieEntry<K, V> current = root.left;
1:72790dc:         TrieEntry<K, V> path = root;
1:68d2526: 
1:72790dc:         while(true)
1:72790dc:         {
1:72790dc:             if (current.bitIndex >= entry.bitIndex || current.bitIndex <= path.bitIndex)
1:72790dc:             {
1:72790dc:                 entry.predecessor = entry;
1:68d2526: 
1:72790dc:                 if (!isBitSet(entry.key, entry.bitIndex))
1:72790dc:                 {
1:72790dc:                     entry.left = entry;
1:72790dc:                     entry.right = current;
1:72790dc:                 }
1:72790dc:                 else
1:72790dc:                 {
1:72790dc:                     entry.left = current;
1:72790dc:                     entry.right = entry;
1:72790dc:                 }
1:68d2526: 
1:72790dc:                 entry.parent = path;
1:72790dc:                 if (current.bitIndex >= entry.bitIndex)
1:72790dc:                     current.parent = entry;
1:68d2526: 
1:72790dc:                 // if we inserted an uplink, set the predecessor on it
1:72790dc:                 if (current.bitIndex <= path.bitIndex)
1:72790dc:                     current.predecessor = entry;
1:68d2526: 
1:72790dc:                 if (path == root || !isBitSet(entry.key, path.bitIndex))
1:72790dc:                     path.left = entry;
1:72790dc:                 else
1:72790dc:                     path.right = entry;
1:68d2526: 
1:72790dc:                 return entry;
1:72790dc:             }
1:68d2526: 
1:72790dc:             path = current;
1:68d2526: 
1:72790dc:             current = !isBitSet(entry.key, current.bitIndex)
1:72790dc:                        ? current.left : current.right;
1:72790dc:         }
1:72790dc:     }
1:68d2526: 
1:72790dc:     @Override
1:72790dc:     public V get(Object k)
1:72790dc:     {
1:72790dc:         TrieEntry<K, V> entry = getEntry(k);
1:72790dc:         return entry != null ? entry.getValue() : null;
1:72790dc:     }
1:72790dc: 
1:72790dc:     /**
1:72790dc:      * Returns the entry associated with the specified key in the
1:72790dc:      * AbstractPatriciaTrie.  Returns null if the map contains no mapping
1:72790dc:      * for this key.
1:68d2526:      *
1:72790dc:      * This may throw ClassCastException if the object is not of type K.
1:72790dc:      */
1:72790dc:     TrieEntry<K,V> getEntry(Object k)
1:72790dc:     {
1:72790dc:         K key = Tries.cast(k);
1:72790dc:         if (key == null)
1:72790dc:             return null;
1:68d2526: 
1:72790dc:         TrieEntry<K,V> entry = getNearestEntryForKey(key);
1:72790dc:         return !entry.isEmpty() && compareKeys(key, entry.key) ? entry : null;
1:72790dc:     }
1:68d2526: 
1:72790dc:     @Override
1:72790dc:     public Map.Entry<K, V> select(K key)
1:72790dc:     {
1:72790dc:         Reference<Map.Entry<K, V>> reference = new Reference<>();
1:72790dc:         return !selectR(root.left, -1, key, reference) ? reference.get() : null;
1:72790dc:     }
1:68d2526: 
1:72790dc:     @Override
1:72790dc:     public Map.Entry<K,V> select(K key, Cursor<? super K, ? super V> cursor)
1:72790dc:     {
1:72790dc:         Reference<Map.Entry<K, V>> reference = new Reference<>();
1:72790dc:         selectR(root.left, -1, key, cursor, reference);
1:72790dc:         return reference.get();
1:72790dc:     }
1:72790dc: 
1:72790dc:     /**
1:72790dc:      * This is equivalent to the other {@link #selectR(TrieEntry, int,
1:72790dc:      * K, Cursor, Reference)} method but without its overhead
1:72790dc:      * because we're selecting only one best matching Entry from the
1:72790dc:      * {@link Trie}.
1:72790dc:      */
1:72790dc:     private boolean selectR(TrieEntry<K, V> h, int bitIndex, final K key, final Reference<Map.Entry<K, V>> reference)
1:72790dc:     {
1:72790dc:         if (h.bitIndex <= bitIndex)
1:72790dc:         {
1:72790dc:             // If we hit the root Node and it is empty
1:72790dc:             // we have to look for an alternative best
1:72790dc:             // matching node.
1:72790dc:             if (!h.isEmpty())
1:72790dc:             {
1:72790dc:                 reference.set(h);
1:72790dc:                 return false;
1:72790dc:             }
1:72790dc:             return true;
1:72790dc:         }
1:68d2526: 
1:72790dc:         if (!isBitSet(key, h.bitIndex))
1:72790dc:         {
1:72790dc:             if (selectR(h.left, h.bitIndex, key, reference))
1:72790dc:             {
1:72790dc:                 return selectR(h.right, h.bitIndex, key, reference);
1:72790dc:             }
1:72790dc:         }
1:72790dc:         else
1:72790dc:         {
1:72790dc:             if (selectR(h.right, h.bitIndex, key, reference))
1:72790dc:             {
1:72790dc:                 return selectR(h.left, h.bitIndex, key, reference);
1:72790dc:             }
1:72790dc:         }
1:68d2526: 
1:72790dc:         return false;
1:72790dc:     }
1:72790dc: 
1:72790dc:     /**
1:68d2526:      *
1:72790dc:      */
1:68d2526:     private boolean selectR(TrieEntry<K,V> h, int bitIndex,
1:72790dc:                             final K key, final Cursor<? super K, ? super V> cursor,
1:72790dc:                             final Reference<Map.Entry<K, V>> reference)
1:72790dc:     {
1:72790dc:         if (h.bitIndex <= bitIndex)
1:72790dc:         {
1:72790dc:             if (!h.isEmpty())
1:72790dc:             {
1:72790dc:                 Decision decision = cursor.select(h);
1:72790dc:                 switch(decision)
1:72790dc:                 {
1:72790dc:                     case REMOVE:
1:72790dc:                         throw new UnsupportedOperationException("Cannot remove during select");
1:72790dc: 
1:72790dc:                     case EXIT:
1:72790dc:                         reference.set(h);
1:72790dc:                         return false; // exit
1:72790dc: 
1:72790dc:                     case REMOVE_AND_EXIT:
1:72790dc:                         TrieEntry<K, V> entry = new TrieEntry<>(h.getKey(), h.getValue(), -1);
1:72790dc:                         reference.set(entry);
1:72790dc:                         removeEntry(h);
1:72790dc:                         return false;
1:72790dc: 
1:72790dc:                     case CONTINUE:
1:72790dc:                         // fall through.
1:72790dc:                 }
1:72790dc:             }
1:72790dc: 
1:72790dc:             return true; // continue
1:72790dc:         }
1:72790dc: 
1:72790dc:         if (!isBitSet(key, h.bitIndex))
1:72790dc:         {
1:72790dc:             if (selectR(h.left, h.bitIndex, key, cursor, reference))
1:72790dc:             {
1:72790dc:                 return selectR(h.right, h.bitIndex, key, cursor, reference);
1:72790dc:             }
1:72790dc:         }
1:72790dc:         else
1:72790dc:         {
1:72790dc:             if (selectR(h.right, h.bitIndex, key, cursor, reference))
1:72790dc:             {
1:72790dc:                 return selectR(h.left, h.bitIndex, key, cursor, reference);
1:72790dc:             }
1:72790dc:         }
1:68d2526: 
1:72790dc:         return false;
1:72790dc:     }
1:68d2526: 
1:72790dc:     @Override
1:72790dc:     public Map.Entry<K, V> traverse(Cursor<? super K, ? super V> cursor)
1:72790dc:     {
1:72790dc:         TrieEntry<K, V> entry = nextEntry(null);
1:72790dc:         while (entry != null)
1:72790dc:         {
1:72790dc:             TrieEntry<K, V> current = entry;
1:68d2526: 
1:72790dc:             Decision decision = cursor.select(current);
1:72790dc:             entry = nextEntry(current);
1:68d2526: 
1:72790dc:             switch(decision)
1:72790dc:             {
1:72790dc:                 case EXIT:
1:72790dc:                     return current;
1:68d2526: 
1:72790dc:                 case REMOVE:
1:72790dc:                     removeEntry(current);
1:72790dc:                     break; // out of switch, stay in while loop
1:72790dc: 
1:72790dc:                 case REMOVE_AND_EXIT:
1:72790dc:                     Map.Entry<K, V> value = new TrieEntry<>(current.getKey(), current.getValue(), -1);
1:72790dc:                     removeEntry(current);
1:72790dc:                     return value;
1:72790dc: 
1:72790dc:                 case CONTINUE: // do nothing.
1:72790dc:             }
1:72790dc:         }
1:68d2526: 
1:72790dc:         return null;
1:72790dc:     }
1:68d2526: 
1:72790dc:     @Override
1:72790dc:     public boolean containsKey(Object k)
1:72790dc:     {
1:72790dc:         if (k == null)
1:72790dc:             return false;
1:68d2526: 
1:72790dc:         K key = Tries.cast(k);
1:72790dc:         TrieEntry<K, V> entry = getNearestEntryForKey(key);
1:72790dc:         return !entry.isEmpty() && compareKeys(key, entry.key);
1:72790dc:     }
1:68d2526: 
1:72790dc:     @Override
1:72790dc:     public Set<Map.Entry<K,V>> entrySet()
1:72790dc:     {
1:72790dc:         if (entrySet == null)
1:72790dc:             entrySet = new EntrySet();
1:72790dc: 
1:72790dc:         return entrySet;
1:72790dc:     }
1:68d2526: 
1:72790dc:     @Override
1:72790dc:     public Set<K> keySet()
1:72790dc:     {
1:72790dc:         if (keySet == null)
1:72790dc:             keySet = new KeySet();
1:72790dc:         return keySet;
1:72790dc:     }
1:68d2526: 
1:72790dc:     @Override
1:72790dc:     public Collection<V> values()
1:72790dc:     {
1:72790dc:         if (values == null)
1:72790dc:             values = new Values();
1:72790dc:         return values;
1:72790dc:     }
1:68d2526: 
1:72790dc:     /**
1:72790dc:      * {@inheritDoc}
1:68d2526:      *
1:68d2526:      * @throws ClassCastException if provided key is of an incompatible type
1:72790dc:      */
1:72790dc:     @Override
1:72790dc:     public V remove(Object k)
1:72790dc:     {
1:72790dc:         if (k == null)
1:72790dc:             return null;
1:68d2526: 
1:72790dc:         K key = Tries.cast(k);
1:72790dc:         TrieEntry<K, V> current = root.left;
1:72790dc:         TrieEntry<K, V> path = root;
1:72790dc:         while (true)
1:72790dc:         {
1:72790dc:             if (current.bitIndex <= path.bitIndex)
1:72790dc:             {
1:72790dc:                 if (!current.isEmpty() && compareKeys(key, current.key))
1:72790dc:                 {
1:72790dc:                     return removeEntry(current);
1:72790dc:                 }
1:72790dc:                 else
1:72790dc:                 {
1:72790dc:                     return null;
1:72790dc:                 }
1:72790dc:             }
1:72790dc: 
1:72790dc:             path = current;
1:72790dc:             current = !isBitSet(key, current.bitIndex) ? current.left : current.right;
1:72790dc:         }
1:72790dc:     }
1:68d2526: 
1:72790dc:     /**
1:72790dc:      * Returns the nearest entry for a given key.  This is useful
1:72790dc:      * for finding knowing if a given key exists (and finding the value
1:72790dc:      * for it), or for inserting the key.
1:68d2526:      *
1:72790dc:      * The actual get implementation. This is very similar to
1:72790dc:      * selectR but with the exception that it might return the
1:72790dc:      * root Entry even if it's empty.
1:72790dc:      */
1:72790dc:     TrieEntry<K, V> getNearestEntryForKey(K key)
1:72790dc:     {
1:72790dc:         TrieEntry<K, V> current = root.left;
1:72790dc:         TrieEntry<K, V> path = root;
1:68d2526: 
1:72790dc:         while(true)
1:72790dc:         {
1:72790dc:             if (current.bitIndex <= path.bitIndex)
1:72790dc:                 return current;
1:72790dc: 
1:72790dc:             path = current;
1:72790dc:             current = !isBitSet(key, current.bitIndex) ? current.left : current.right;
1:72790dc:         }
1:72790dc:     }
1:72790dc: 
1:72790dc:     /**
1:72790dc:      * Removes a single entry from the {@link Trie}.
1:68d2526:      *
1:72790dc:      * If we found a Key (Entry h) then figure out if it's
1:68d2526:      * an internal (hard to remove) or external Entry (easy
1:72790dc:      * to remove)
1:72790dc:      */
1:72790dc:     V removeEntry(TrieEntry<K, V> h)
1:72790dc:     {
1:72790dc:         if (h != root)
1:72790dc:         {
1:72790dc:             if (h.isInternalNode())
1:72790dc:             {
1:72790dc:                 removeInternalEntry(h);
1:72790dc:             }
1:72790dc:             else
1:72790dc:             {
1:72790dc:                 removeExternalEntry(h);
1:72790dc:             }
1:72790dc:         }
1:68d2526: 
1:72790dc:         decrementSize();
1:72790dc:         return h.setKeyValue(null, null);
1:72790dc:     }
1:68d2526: 
1:72790dc:     /**
1:72790dc:      * Removes an external entry from the {@link Trie}.
1:68d2526:      *
1:72790dc:      * If it's an external Entry then just remove it.
1:72790dc:      * This is very easy and straight forward.
1:72790dc:      */
1:72790dc:     private void removeExternalEntry(TrieEntry<K, V> h)
1:72790dc:     {
1:72790dc:         if (h == root)
1:72790dc:         {
1:72790dc:             throw new IllegalArgumentException("Cannot delete root Entry!");
1:72790dc:         }
1:72790dc:         else if (!h.isExternalNode())
1:72790dc:         {
1:72790dc:             throw new IllegalArgumentException(h + " is not an external Entry!");
1:68d2526:         }
1:68d2526: 
1:72790dc:         TrieEntry<K, V> parent = h.parent;
1:72790dc:         TrieEntry<K, V> child = (h.left == h) ? h.right : h.left;
1:68d2526: 
1:72790dc:         if (parent.left == h)
1:72790dc:         {
1:72790dc:             parent.left = child;
1:72790dc:         }
1:72790dc:         else
1:72790dc:         {
1:72790dc:             parent.right = child;
1:72790dc:         }
1:68d2526: 
1:72790dc:         // either the parent is changing, or the predecessor is changing.
1:72790dc:         if (child.bitIndex > parent.bitIndex)
1:72790dc:         {
1:72790dc:             child.parent = parent;
1:72790dc:         }
1:72790dc:         else
1:72790dc:         {
1:72790dc:             child.predecessor = parent;
1:72790dc:         }
1:68d2526: 
1:72790dc:     }
1:68d2526: 
1:72790dc:     /**
1:72790dc:      * Removes an internal entry from the {@link Trie}.
1:68d2526:      *
1:72790dc:      * If it's an internal Entry then "good luck" with understanding
1:72790dc:      * this code. The Idea is essentially that Entry p takes Entry h's
1:72790dc:      * place in the trie which requires some re-wiring.
1:72790dc:      */
1:72790dc:     private void removeInternalEntry(TrieEntry<K, V> h)
1:72790dc:     {
1:72790dc:         if (h == root)
1:72790dc:         {
1:72790dc:             throw new IllegalArgumentException("Cannot delete root Entry!");
1:72790dc:         }
1:72790dc:         else if (!h.isInternalNode())
1:72790dc:         {
1:72790dc:             throw new IllegalArgumentException(h + " is not an internal Entry!");
1:68d2526:         }
1:68d2526: 
1:72790dc:         TrieEntry<K, V> p = h.predecessor;
1:68d2526: 
1:72790dc:         // Set P's bitIndex
1:72790dc:         p.bitIndex = h.bitIndex;
1:68d2526: 
1:72790dc:         // Fix P's parent, predecessor and child Nodes
1:72790dc:         {
1:72790dc:             TrieEntry<K, V> parent = p.parent;
1:72790dc:             TrieEntry<K, V> child = (p.left == h) ? p.right : p.left;
1:68d2526: 
1:72790dc:             // if it was looping to itself previously,
1:72790dc:             // it will now be pointed from it's parent
1:72790dc:             // (if we aren't removing it's parent --
1:72790dc:             //  in that case, it remains looping to itself).
1:72790dc:             // otherwise, it will continue to have the same
1:72790dc:             // predecessor.
1:72790dc:             if (p.predecessor == p && p.parent != h)
1:72790dc:                 p.predecessor = p.parent;
1:68d2526: 
1:72790dc:             if (parent.left == p)
1:72790dc:             {
1:72790dc:                 parent.left = child;
1:72790dc:             }
1:72790dc:             else
1:72790dc:             {
1:72790dc:                 parent.right = child;
1:72790dc:             }
1:68d2526: 
1:72790dc:             if (child.bitIndex > parent.bitIndex)
1:72790dc:             {
1:72790dc:                 child.parent = parent;
1:72790dc:             }
1:72790dc:         }
1:68d2526: 
1:72790dc:         // Fix H's parent and child Nodes
1:68d2526:         {
1:68d2526:             // If H is a parent of its left and right child
1:72790dc:             // then change them to P
1:72790dc:             if (h.left.parent == h)
1:72790dc:                 h.left.parent = p;
1:72790dc: 
1:72790dc:             if (h.right.parent == h)
1:72790dc:                 h.right.parent = p;
1:68d2526: 
1:72790dc:             // Change H's parent
1:72790dc:             if (h.parent.left == h)
1:72790dc:             {
1:72790dc:                 h.parent.left = p;
1:72790dc:             }
1:72790dc:             else
1:72790dc:             {
1:72790dc:                 h.parent.right = p;
1:72790dc:             }
1:72790dc:         }
1:68d2526: 
1:72790dc:         // Copy the remaining fields from H to P
1:72790dc:         //p.bitIndex = h.bitIndex;
1:72790dc:         p.parent = h.parent;
1:72790dc:         p.left = h.left;
1:72790dc:         p.right = h.right;
1:68d2526: 
1:72790dc:         // Make sure that if h was pointing to any uplinks,
1:72790dc:         // p now points to them.
1:72790dc:         if (isValidUplink(p.left, p))
1:72790dc:             p.left.predecessor = p;
1:68d2526: 
1:72790dc:         if (isValidUplink(p.right, p))
1:72790dc:             p.right.predecessor = p;
1:72790dc:     }
1:68d2526: 
1:72790dc:     /**
1:72790dc:      * Returns the entry lexicographically after the given entry.
1:72790dc:      * If the given entry is null, returns the first node.
1:72790dc:      */
1:72790dc:     TrieEntry<K, V> nextEntry(TrieEntry<K, V> node)
1:72790dc:     {
1:72790dc:         return (node == null) ? firstEntry() : nextEntryImpl(node.predecessor, node, null);
1:72790dc:     }
1:68d2526: 
1:72790dc:     /**
1:72790dc:      * Scans for the next node, starting at the specified point, and using 'previous'
1:72790dc:      * as a hint that the last node we returned was 'previous' (so we know not to return
1:72790dc:      * it again).  If 'tree' is non-null, this will limit the search to the given tree.
1:68d2526:      *
1:72790dc:      * The basic premise is that each iteration can follow the following steps:
1:68d2526:      *
1:72790dc:      * 1) Scan all the way to the left.
1:72790dc:      *   a) If we already started from this node last time, proceed to Step 2.
1:72790dc:      *   b) If a valid uplink is found, use it.
1:72790dc:      *   c) If the result is an empty node (root not set), break the scan.
1:72790dc:      *   d) If we already returned the left node, break the scan.
1:68d2526:      *
1:72790dc:      * 2) Check the right.
1:72790dc:      *   a) If we already returned the right node, proceed to Step 3.
1:72790dc:      *   b) If it is a valid uplink, use it.
1:72790dc:      *   c) Do Step 1 from the right node.
1:68d2526:      *
1:72790dc:      * 3) Back up through the parents until we encounter find a parent
1:72790dc:      *    that we're not the right child of.
1:68d2526:      *
1:72790dc:      * 4) If there's no right child of that parent, the iteration is finished.
1:72790dc:      *    Otherwise continue to Step 5.
1:68d2526:      *
1:72790dc:      * 5) Check to see if the right child is a valid uplink.
1:72790dc:      *    a) If we already returned that child, proceed to Step 6.
1:72790dc:      *       Otherwise, use it.
1:68d2526:      *
1:72790dc:      * 6) If the right child of the parent is the parent itself, we've
1:72790dc:      *    already found & returned the end of the Trie, so exit.
1:68d2526:      *
1:72790dc:      * 7) Do Step 1 on the parent's right child.
1:72790dc:      */
1:72790dc:     TrieEntry<K, V> nextEntryImpl(TrieEntry<K, V> start, TrieEntry<K, V> previous, TrieEntry<K, V> tree)
1:72790dc:     {
1:72790dc:         TrieEntry<K, V> current = start;
1:72790dc: 
1:72790dc:         // Only look at the left if this was a recursive or
1:72790dc:         // the first check, otherwise we know we've already looked
1:72790dc:         // at the left.
1:72790dc:         if (previous == null || start != previous.predecessor)
1:72790dc:         {
1:72790dc:             while (!current.left.isEmpty())
1:72790dc:             {
1:72790dc:                 // stop traversing if we've already
1:72790dc:                 // returned the left of this node.
1:72790dc:                 if (previous == current.left)
1:72790dc:                     break;
1:68d2526: 
1:72790dc:                 if (isValidUplink(current.left, current))
1:72790dc:                     return current.left;
1:68d2526: 
1:72790dc:                 current = current.left;
1:72790dc:             }
1:72790dc:         }
1:68d2526: 
1:72790dc:         // If there's no data at all, exit.
1:72790dc:         if (current.isEmpty())
1:72790dc:             return null;
1:68d2526: 
1:72790dc:         // If we've already returned the left,
1:72790dc:         // and the immediate right is null,
1:72790dc:         // there's only one entry in the Trie
1:72790dc:         // which is stored at the root.
1:72790dc:         //
1:72790dc:         //  / ("")   <-- root
1:72790dc:         //  \_/  \
1:72790dc:         //       null <-- 'current'
1:72790dc:         //
1:72790dc:         if (current.right == null)
1:72790dc:             return null;
1:68d2526: 
1:72790dc:         // If nothing valid on the left, try the right.
1:72790dc:         if (previous != current.right)
1:72790dc:         {
1:72790dc:             // See if it immediately is valid.
1:72790dc:             if (isValidUplink(current.right, current))
1:72790dc:                 return current.right;
1:68d2526: 
1:72790dc:             // Must search on the right's side if it wasn't initially valid.
1:72790dc:             return nextEntryImpl(current.right, previous, tree);
1:72790dc:         }
1:68d2526: 
1:72790dc:         // Neither left nor right are valid, find the first parent
1:72790dc:         // whose child did not come from the right & traverse it.
1:72790dc:         while (current == current.parent.right)
1:72790dc:         {
1:72790dc:             // If we're going to traverse to above the subtree, stop.
1:72790dc:             if (current == tree)
1:72790dc:                 return null;
1:68d2526: 
1:72790dc:             current = current.parent;
1:72790dc:         }
1:72790dc: 
1:72790dc:         // If we're on the top of the subtree, we can't go any higher.
1:72790dc:         if (current == tree)
1:72790dc:             return null;
1:68d2526: 
1:72790dc:         // If there's no right, the parent must be root, so we're done.
1:72790dc:         if (current.parent.right == null)
1:72790dc:             return null;
1:68d2526: 
1:72790dc:         // If the parent's right points to itself, we've found one.
1:72790dc:         if (previous != current.parent.right && isValidUplink(current.parent.right, current.parent))
1:72790dc:             return current.parent.right;
1:68d2526: 
1:72790dc:         // If the parent's right is itself, there can't be any more nodes.
1:72790dc:         if (current.parent.right == current.parent)
1:72790dc:             return null;
1:68d2526: 
1:72790dc:         // We need to traverse down the parent's right's path.
1:72790dc:         return nextEntryImpl(current.parent.right, previous, tree);
1:72790dc:     }
1:68d2526: 
1:72790dc:     /**
1:72790dc:      * Returns the first entry the {@link Trie} is storing.
1:68d2526:      *
1:72790dc:      * This is implemented by going always to the left until
1:72790dc:      * we encounter a valid uplink. That uplink is the first key.
1:72790dc:      */
1:72790dc:     TrieEntry<K, V> firstEntry()
1:72790dc:     {
1:72790dc:         // if Trie is empty, no first node.
1:72790dc:         return isEmpty() ? null : followLeft(root);
1:72790dc:     }
1:68d2526: 
1:68d2526:     /**
1:68d2526:      * Goes left through the tree until it finds a valid node.
1:72790dc:      */
1:72790dc:     TrieEntry<K, V> followLeft(TrieEntry<K, V> node)
1:72790dc:     {
1:72790dc:         while(true)
1:72790dc:         {
1:72790dc:             TrieEntry<K, V> child = node.left;
1:72790dc:             // if we hit root and it didn't have a node, go right instead.
1:72790dc:             if (child.isEmpty())
1:72790dc:                 child = node.right;
1:68d2526: 
1:72790dc:             if (child.bitIndex <= node.bitIndex)
1:72790dc:                 return child;
1:68d2526: 
1:72790dc:             node = child;
1:72790dc:         }
1:72790dc:     }
1:68d2526: 
1:68d2526:     /**
1:68d2526:      * Returns true if 'next' is a valid uplink coming from 'from'.
1:72790dc:      */
1:72790dc:     static boolean isValidUplink(TrieEntry<?, ?> next, TrieEntry<?, ?> from)
1:72790dc:     {
1:72790dc:         return next != null && next.bitIndex <= from.bitIndex && !next.isEmpty();
1:72790dc:     }
1:68d2526: 
1:72790dc:     /**
1:68d2526:      * A {@link Reference} allows us to return something through a Method's
1:68d2526:      * argument list. An alternative would be to an Array with a length of
1:72790dc:      * one (1) but that leads to compiler warnings. Computationally and memory
1:68d2526:      * wise there's no difference (except for the need to load the
1:72790dc:      * {@link Reference} Class but that happens only once).
1:72790dc:      */
1:72790dc:     private static class Reference<E>
1:72790dc:     {
1:68d2526: 
1:72790dc:         private E item;
1:68d2526: 
1:72790dc:         public void set(E item)
1:72790dc:         {
1:72790dc:             this.item = item;
1:72790dc:         }
1:68d2526: 
1:72790dc:         public E get()
1:72790dc:         {
1:72790dc:             return item;
1:72790dc:         }
1:72790dc:     }
1:68d2526: 
1:72790dc:     /**
1:72790dc:      *  A {@link Trie} is a set of {@link TrieEntry} nodes
1:72790dc:      */
1:72790dc:     static class TrieEntry<K,V> extends BasicEntry<K, V>
1:72790dc:     {
1:68d2526: 
1:72790dc:         private static final long serialVersionUID = 4596023148184140013L;
1:68d2526: 
1:72790dc:         /** The index this entry is comparing. */
1:72790dc:         protected int bitIndex;
1:68d2526: 
1:72790dc:         /** The parent of this entry. */
1:72790dc:         protected TrieEntry<K,V> parent;
1:68d2526: 
1:72790dc:         /** The left child of this entry. */
1:72790dc:         protected TrieEntry<K,V> left;
1:68d2526: 
1:72790dc:         /** The right child of this entry. */
1:72790dc:         protected TrieEntry<K,V> right;
1:68d2526: 
1:68d2526:         /** The entry who uplinks to this entry. */
1:72790dc:         protected TrieEntry<K,V> predecessor;
1:68d2526: 
1:72790dc:         public TrieEntry(K key, V value, int bitIndex)
1:72790dc:         {
1:72790dc:             super(key, value);
1:68d2526: 
1:72790dc:             this.bitIndex = bitIndex;
1:68d2526: 
1:72790dc:             this.parent = null;
1:72790dc:             this.left = this;
1:72790dc:             this.right = null;
1:72790dc:             this.predecessor = this;
1:72790dc:         }
1:68d2526: 
1:72790dc:         /**
1:72790dc:          * Whether or not the entry is storing a key.
1:72790dc:          * Only the root can potentially be empty, all other
1:72790dc:          * nodes must have a key.
1:72790dc:          */
1:72790dc:         public boolean isEmpty()
1:72790dc:         {
1:72790dc:             return key == null;
1:72790dc:         }
1:68d2526: 
1:68d2526:         /**
1:68d2526:          * Neither the left nor right child is a loopback
1:72790dc:          */
1:72790dc:         public boolean isInternalNode()
1:72790dc:         {
1:72790dc:             return left != this && right != this;
1:72790dc:         }
1:68d2526: 
1:68d2526:         /**
1:68d2526:          * Either the left or right child is a loopback
1:72790dc:          */
1:72790dc:         public boolean isExternalNode()
1:72790dc:         {
1:72790dc:             return !isInternalNode();
1:72790dc:         }
1:72790dc:     }
1:68d2526: 
1:72790dc: 
1:72790dc:     /**
1:68d2526:      * This is a entry set view of the {@link Trie} as returned
1:72790dc:      * by {@link Map#entrySet()}
1:72790dc:      */
1:72790dc:     private class EntrySet extends AbstractSet<Map.Entry<K,V>>
1:72790dc:     {
1:72790dc:         @Override
1:72790dc:         public Iterator<Map.Entry<K,V>> iterator()
1:72790dc:         {
1:72790dc:             return new EntryIterator();
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public boolean contains(Object o)
1:72790dc:         {
1:72790dc:             if (!(o instanceof Map.Entry))
1:72790dc:                 return false;
1:68d2526: 
1:72790dc:             TrieEntry<K,V> candidate = getEntry(((Map.Entry<?, ?>)o).getKey());
1:72790dc:             return candidate != null && candidate.equals(o);
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public boolean remove(Object o)
1:72790dc:         {
1:72790dc:             int size = size();
1:72790dc:             AbstractPatriciaTrie.this.remove(o);
1:72790dc:             return size != size();
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public int size()
1:72790dc:         {
1:72790dc:             return AbstractPatriciaTrie.this.size();
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public void clear()
1:72790dc:         {
1:72790dc:             AbstractPatriciaTrie.this.clear();
1:72790dc:         }
1:68d2526: 
1:72790dc:         /**
1:72790dc:          * An {@link Iterator} that returns {@link Entry} Objects
1:72790dc:          */
1:72790dc:         private class EntryIterator extends TrieIterator<Map.Entry<K,V>>
1:72790dc:         {
1:72790dc:             @Override
1:72790dc:             public Map.Entry<K,V> next()
1:72790dc:             {
1:72790dc:                 return nextEntry();
1:72790dc:             }
1:72790dc:         }
1:72790dc:     }
1:68d2526: 
1:72790dc:     /**
1:68d2526:      * This is a key set view of the {@link Trie} as returned
1:72790dc:      * by {@link Map#keySet()}
1:72790dc:      */
1:72790dc:     private class KeySet extends AbstractSet<K>
1:72790dc:     {
1:72790dc:         @Override
1:72790dc:         public Iterator<K> iterator()
1:72790dc:         {
1:72790dc:             return new KeyIterator();
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public int size()
1:72790dc:         {
1:72790dc:             return AbstractPatriciaTrie.this.size();
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public boolean contains(Object o)
1:72790dc:         {
1:72790dc:             return containsKey(o);
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public boolean remove(Object o)
1:72790dc:         {
1:72790dc:             int size = size();
1:72790dc:             AbstractPatriciaTrie.this.remove(o);
1:72790dc:             return size != size();
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public void clear()
1:72790dc:         {
1:72790dc:             AbstractPatriciaTrie.this.clear();
1:72790dc:         }
1:68d2526: 
1:72790dc:         /**
1:72790dc:          * An {@link Iterator} that returns Key Objects
1:72790dc:          */
1:72790dc:         private class KeyIterator extends TrieIterator<K>
1:72790dc:         {
1:72790dc:             @Override
1:72790dc:             public K next()
1:72790dc:             {
1:72790dc:                 return nextEntry().getKey();
1:72790dc:             }
1:72790dc:         }
1:72790dc:     }
1:72790dc: 
1:72790dc:     /**
1:68d2526:      * This is a value view of the {@link Trie} as returned
1:72790dc:      * by {@link Map#values()}
1:72790dc:      */
1:72790dc:     private class Values extends AbstractCollection<V>
1:72790dc:     {
1:72790dc:         @Override
1:72790dc:         public Iterator<V> iterator()
1:72790dc:         {
1:72790dc:             return new ValueIterator();
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public int size()
1:72790dc:         {
1:72790dc:             return AbstractPatriciaTrie.this.size();
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public boolean contains(Object o)
1:72790dc:         {
1:72790dc:             return containsValue(o);
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public void clear()
1:72790dc:         {
1:72790dc:             AbstractPatriciaTrie.this.clear();
1:72790dc:         }
1:72790dc: 
1:72790dc:         @Override
1:72790dc:         public boolean remove(Object o)
1:72790dc:         {
1:72790dc:             for (Iterator<V> it = iterator(); it.hasNext(); )
1:72790dc:             {
1:72790dc:                 V value = it.next();
1:72790dc:                 if (Tries.areEqual(value, o))
1:72790dc:                 {
1:72790dc:                     it.remove();
1:72790dc:                     return true;
1:72790dc:                 }
1:72790dc:             }
1:72790dc:             return false;
1:72790dc:         }
1:72790dc: 
1:72790dc:         /**
1:72790dc:          * An {@link Iterator} that returns Value Objects
1:72790dc:          */
1:72790dc:         private class ValueIterator extends TrieIterator<V>
1:72790dc:         {
1:72790dc:             @Override
1:72790dc:             public V next()
1:72790dc:             {
1:72790dc:                 return nextEntry().getValue();
1:72790dc:             }
1:72790dc:         }
1:72790dc:     }
1:72790dc: 
1:72790dc:     /**
1:68d2526:      * An iterator for the entries.
1:72790dc:      */
1:72790dc:     abstract class TrieIterator<E> implements Iterator<E>
1:72790dc:     {
1:72790dc:         /**
1:72790dc:          * For fast-fail
1:72790dc:          */
1:72790dc:         protected int expectedModCount = AbstractPatriciaTrie.this.modCount;
1:68d2526: 
1:72790dc:         protected TrieEntry<K, V> next; // the next node to return
1:72790dc:         protected TrieEntry<K, V> current; // the current entry we're on
1:68d2526: 
1:72790dc:         /**
1:72790dc:          * Starts iteration from the root
1:72790dc:          */
1:72790dc:         protected TrieIterator()
1:72790dc:         {
1:72790dc:             next = AbstractPatriciaTrie.this.nextEntry(null);
1:72790dc:         }
1:68d2526: 
1:72790dc:         /**
1:72790dc:          * Starts iteration at the given entry
1:72790dc:          */
1:72790dc:         protected TrieIterator(TrieEntry<K, V> firstEntry)
1:72790dc:         {
1:72790dc:             next = firstEntry;
1:72790dc:         }
1:68d2526: 
1:72790dc:         /**
1:72790dc:          * Returns the next {@link TrieEntry}
1:72790dc:          */
1:72790dc:         protected TrieEntry<K,V> nextEntry()
1:72790dc:         {
1:72790dc:             if (expectedModCount != AbstractPatriciaTrie.this.modCount)
1:72790dc:                 throw new ConcurrentModificationException();
1:68d2526: 
1:72790dc:             TrieEntry<K,V> e = next;
1:72790dc:             if (e == null)
1:72790dc:                 throw new NoSuchElementException();
1:68d2526: 
1:72790dc:             next = findNext(e);
1:72790dc:             current = e;
1:72790dc:             return e;
1:72790dc:         }
1:68d2526: 
1:72790dc:         /**
1:72790dc:          * @see PatriciaTrie#nextEntry(TrieEntry)
1:72790dc:          */
1:72790dc:         protected TrieEntry<K, V> findNext(TrieEntry<K, V> prior)
1:72790dc:         {
1:72790dc:             return AbstractPatriciaTrie.this.nextEntry(prior);
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public boolean hasNext()
1:72790dc:         {
1:72790dc:             return next != null;
1:72790dc:         }
1:68d2526: 
1:72790dc:         @Override
1:72790dc:         public void remove()
1:72790dc:         {
1:72790dc:             if (current == null)
1:72790dc:                 throw new IllegalStateException();
1:68d2526: 
1:72790dc:             if (expectedModCount != AbstractPatriciaTrie.this.modCount)
1:72790dc:                 throw new ConcurrentModificationException();
1:68d2526: 
1:72790dc:             TrieEntry<K, V> node = current;
1:72790dc:             current = null;
1:72790dc:             AbstractPatriciaTrie.this.removeEntry(node);
1:68d2526: 
1:72790dc:             expectedModCount = AbstractPatriciaTrie.this.modCount;
1:72790dc:         }
1:72790dc:     }
1:72790dc: }
============================================================================
author:Dave Brosius
-------------------------------------------------------------------------------
commit:68d2526
/////////////////////////////////////////////////////////////////////////
1:      * The root node of the {@link Trie}.
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:                 if (found != root)
1:                 {
1: 
1:         throw new IndexOutOfBoundsException("Failed to put: "
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:      *
1:     private boolean selectR(TrieEntry<K,V> h, int bitIndex,
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:      *
1:      * @throws ClassCastException if provided key is of an incompatible type
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:      *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:      *
1:      * an internal (hard to remove) or external Entry (easy
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:      *
/////////////////////////////////////////////////////////////////////////
1:         }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:      *
/////////////////////////////////////////////////////////////////////////
1:         }
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         {
1:             // If H is a parent of its left and right child
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:      *
1:      *
1:      *
1:      *
1:      *
1:      *
1:      *
1:      *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1: 
1:      *
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Goes left through the tree until it finds a valid node.
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1:     /**
1:      * Returns true if 'next' is a valid uplink coming from 'from'.
1: 
1:      * A {@link Reference} allows us to return something through a Method's
1:      * argument list. An alternative would be to an Array with a length of
1:      * wise there's no difference (except for the need to load the
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1:         /** The entry who uplinks to this entry. */
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         /**
1:          * Neither the left nor right child is a loopback
1: 
1:         /**
1:          * Either the left or right child is a loopback
1: 
1:      * This is a entry set view of the {@link Trie} as returned
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:      * This is a key set view of the {@link Trie} as returned
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:      * This is a value view of the {@link Trie} as returned
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * An iterator for the entries.
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:72790dc
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Copyright 2005-2010 Roger Kapsi, Sam Berlin
1:  *
1:  *   Licensed under the Apache License, Version 2.0 (the "License");
1:  *   you may not use this file except in compliance with the License.
1:  *   You may obtain a copy of the License at
1:  *
1:  *       http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  *   Unless required by applicable law or agreed to in writing, software
1:  *   distributed under the License is distributed on an "AS IS" BASIS,
1:  *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  *   See the License for the specific language governing permissions and
1:  *   limitations under the License.
1:  */
1: 
1: /**
1:  * This class is taken from https://github.com/rkapsi/patricia-trie (v0.6), and slightly modified
1:  * to correspond to Cassandra code style, as the only Patricia Trie implementation,
1:  * which supports pluggable key comparators (e.g. commons-collections PatriciaTrie (which is based
1:  * on rkapsi/patricia-trie project) only supports String keys)
1:  * but unfortunately is not deployed to the maven central as a downloadable artifact.
1:  */
1: 
1: package org.apache.cassandra.index.sasi.utils.trie;
1: 
1: import java.util.AbstractCollection;
1: import java.util.AbstractSet;
1: import java.util.Collection;
1: import java.util.ConcurrentModificationException;
1: import java.util.Iterator;
1: import java.util.Map;
1: import java.util.NoSuchElementException;
1: import java.util.Set;
1: 
1: import org.apache.cassandra.index.sasi.utils.trie.Cursor.Decision;
1: 
1: /**
1:  * This class implements the base PATRICIA algorithm and everything that
1:  * is related to the {@link Map} interface.
1:  */
1: abstract class AbstractPatriciaTrie<K, V> extends AbstractTrie<K, V>
1: {
1:     private static final long serialVersionUID = -2303909182832019043L;
1: 
1:     /**
0:      * The root node of the {@link Trie}. 
1:      */
1:     final TrieEntry<K, V> root = new TrieEntry<>(null, null, -1);
1:     
1:     /**
1:      * Each of these fields are initialized to contain an instance of the
1:      * appropriate view the first time this view is requested. The views are
1:      * stateless, so there's no reason to create more than one of each.
1:      */
1:     private transient volatile Set<K> keySet;
1:     private transient volatile Collection<V> values;
1:     private transient volatile Set<Map.Entry<K,V>> entrySet;
1:     
1:     /**
1:      * The current size of the {@link Trie}
1:      */
1:     private int size = 0;
1:     
1:     /**
1:      * The number of times this {@link Trie} has been modified.
1:      * It's used to detect concurrent modifications and fail-fast
1:      * the {@link Iterator}s.
1:      */
1:     transient int modCount = 0;
1:     
1:     public AbstractPatriciaTrie(KeyAnalyzer<? super K> keyAnalyzer)
1:     {
1:         super(keyAnalyzer);
1:     }
1:     
1:     public AbstractPatriciaTrie(KeyAnalyzer<? super K> keyAnalyzer, Map<? extends K, ? extends V> m)
1:     {
1:         super(keyAnalyzer);
1:         putAll(m);
1:     }
1:     
1:     @Override
1:     public void clear()
1:     {
1:         root.key = null;
1:         root.bitIndex = -1;
1:         root.value = null;
1:         
1:         root.parent = null;
1:         root.left = root;
1:         root.right = null;
1:         root.predecessor = root;
1:         
1:         size = 0;
1:         incrementModCount();
1:     }
1:     
1:     @Override
1:     public int size()
1:     {
1:         return size;
1:     }
1:    
1:     /**
1:      * A helper method to increment the {@link Trie} size
1:      * and the modification counter.
1:      */
1:     void incrementSize()
1:     {
1:         size++;
1:         incrementModCount();
1:     }
1:     
1:     /**
1:      * A helper method to decrement the {@link Trie} size
1:      * and increment the modification counter.
1:      */
1:     void decrementSize()
1:     {
1:         size--;
1:         incrementModCount();
1:     }
1:     
1:     /**
1:      * A helper method to increment the modification counter.
1:      */
1:     private void incrementModCount()
1:     {
1:         ++modCount;
1:     }
1:     
1:     @Override
1:     public V put(K key, V value)
1:     {
1:         if (key == null)
1:             throw new NullPointerException("Key cannot be null");
1:         
1:         int lengthInBits = lengthInBits(key);
1:         
1:         // The only place to store a key with a length
1:         // of zero bits is the root node
1:         if (lengthInBits == 0)
1:         {
1:             if (root.isEmpty())
1:                 incrementSize();
1:             else
1:                 incrementModCount();
1: 
1:             return root.setKeyValue(key, value);
1:         }
1:         
1:         TrieEntry<K, V> found = getNearestEntryForKey(key);
1:         if (compareKeys(key, found.key))
1:         {
1:             if (found.isEmpty()) // <- must be the root
1:                 incrementSize();
1:             else
1:                 incrementModCount();
1: 
1:             return found.setKeyValue(key, value);
1:         }
1:         
1:         int bitIndex = bitIndex(key, found.key);
1:         if (!Tries.isOutOfBoundsIndex(bitIndex))
1:         {
1:             if (Tries.isValidBitIndex(bitIndex)) // in 99.999...9% the case
1:             {
1:                 /* NEW KEY+VALUE TUPLE */
1:                 TrieEntry<K, V> t = new TrieEntry<>(key, value, bitIndex);
1:                 addEntry(t);
1:                 incrementSize();
1:                 return null;
1:             }
1:             else if (Tries.isNullBitKey(bitIndex))
1:             {
1:                 // A bits of the Key are zero. The only place to
1:                 // store such a Key is the root Node!
1:                 
1:                 /* NULL BIT KEY */
1:                 if (root.isEmpty())
1:                     incrementSize();
1:                 else
1:                     incrementModCount();
1: 
1:                 return root.setKeyValue(key, value);
1:                 
1:             }
1:             else if (Tries.isEqualBitKey(bitIndex))
1:             {
1:                 // This is a very special and rare case.
1:                 
1:                 /* REPLACE OLD KEY+VALUE */
0:                 if (found != root) {
1:                     incrementModCount();
1:                     return found.setKeyValue(key, value);
1:                 }
1:             }
1:         }
1:         
0:         throw new IndexOutOfBoundsException("Failed to put: " 
1:                 + key + " -> " + value + ", " + bitIndex);
1:     }
1:     
1:     /**
1:      * Adds the given {@link TrieEntry} to the {@link Trie}
1:      */
1:     TrieEntry<K, V> addEntry(TrieEntry<K, V> entry)
1:     {
1:         TrieEntry<K, V> current = root.left;
1:         TrieEntry<K, V> path = root;
1: 
1:         while(true)
1:         {
1:             if (current.bitIndex >= entry.bitIndex || current.bitIndex <= path.bitIndex)
1:             {
1:                 entry.predecessor = entry;
1:                 
1:                 if (!isBitSet(entry.key, entry.bitIndex))
1:                 {
1:                     entry.left = entry;
1:                     entry.right = current;
1:                 }
1:                 else
1:                 {
1:                     entry.left = current;
1:                     entry.right = entry;
1:                 }
1:                
1:                 entry.parent = path;
1:                 if (current.bitIndex >= entry.bitIndex)
1:                     current.parent = entry;
1:                 
1:                 // if we inserted an uplink, set the predecessor on it
1:                 if (current.bitIndex <= path.bitIndex)
1:                     current.predecessor = entry;
1:          
1:                 if (path == root || !isBitSet(entry.key, path.bitIndex))
1:                     path.left = entry;
1:                 else
1:                     path.right = entry;
1:                 
1:                 return entry;
1:             }
1:                 
1:             path = current;
1:             
1:             current = !isBitSet(entry.key, current.bitIndex)
1:                        ? current.left : current.right;
1:         }
1:     }
1:     
1:     @Override
1:     public V get(Object k)
1:     {
1:         TrieEntry<K, V> entry = getEntry(k);
1:         return entry != null ? entry.getValue() : null;
1:     }
1: 
1:     /**
1:      * Returns the entry associated with the specified key in the
1:      * AbstractPatriciaTrie.  Returns null if the map contains no mapping
1:      * for this key.
1:      * 
1:      * This may throw ClassCastException if the object is not of type K.
1:      */
1:     TrieEntry<K,V> getEntry(Object k)
1:     {
1:         K key = Tries.cast(k);
1:         if (key == null)
1:             return null;
1:         
1:         TrieEntry<K,V> entry = getNearestEntryForKey(key);
1:         return !entry.isEmpty() && compareKeys(key, entry.key) ? entry : null;
1:     }
1:     
1:     @Override
1:     public Map.Entry<K, V> select(K key)
1:     {
1:         Reference<Map.Entry<K, V>> reference = new Reference<>();
1:         return !selectR(root.left, -1, key, reference) ? reference.get() : null;
1:     }
1:     
1:     @Override
1:     public Map.Entry<K,V> select(K key, Cursor<? super K, ? super V> cursor)
1:     {
1:         Reference<Map.Entry<K, V>> reference = new Reference<>();
1:         selectR(root.left, -1, key, cursor, reference);
1:         return reference.get();
1:     }
1: 
1:     /**
1:      * This is equivalent to the other {@link #selectR(TrieEntry, int,
1:      * K, Cursor, Reference)} method but without its overhead
1:      * because we're selecting only one best matching Entry from the
1:      * {@link Trie}.
1:      */
1:     private boolean selectR(TrieEntry<K, V> h, int bitIndex, final K key, final Reference<Map.Entry<K, V>> reference)
1:     {
1:         if (h.bitIndex <= bitIndex)
1:         {
1:             // If we hit the root Node and it is empty
1:             // we have to look for an alternative best
1:             // matching node.
1:             if (!h.isEmpty())
1:             {
1:                 reference.set(h);
1:                 return false;
1:             }
1:             return true;
1:         }
1: 
1:         if (!isBitSet(key, h.bitIndex))
1:         {
1:             if (selectR(h.left, h.bitIndex, key, reference))
1:             {
1:                 return selectR(h.right, h.bitIndex, key, reference);
1:             }
1:         }
1:         else
1:         {
1:             if (selectR(h.right, h.bitIndex, key, reference))
1:             {
1:                 return selectR(h.left, h.bitIndex, key, reference);
1:             }
1:         }
1: 
1:         return false;
1:     }
1:     
1:     /**
1:      * 
1:      */
0:     private boolean selectR(TrieEntry<K,V> h, int bitIndex, 
1:                             final K key, final Cursor<? super K, ? super V> cursor,
1:                             final Reference<Map.Entry<K, V>> reference)
1:     {
1:         if (h.bitIndex <= bitIndex)
1:         {
1:             if (!h.isEmpty())
1:             {
1:                 Decision decision = cursor.select(h);
1:                 switch(decision)
1:                 {
1:                     case REMOVE:
1:                         throw new UnsupportedOperationException("Cannot remove during select");
1: 
1:                     case EXIT:
1:                         reference.set(h);
1:                         return false; // exit
1: 
1:                     case REMOVE_AND_EXIT:
1:                         TrieEntry<K, V> entry = new TrieEntry<>(h.getKey(), h.getValue(), -1);
1:                         reference.set(entry);
1:                         removeEntry(h);
1:                         return false;
1: 
1:                     case CONTINUE:
1:                         // fall through.
1:                 }
1:             }
1: 
1:             return true; // continue
1:         }
1: 
1:         if (!isBitSet(key, h.bitIndex))
1:         {
1:             if (selectR(h.left, h.bitIndex, key, cursor, reference))
1:             {
1:                 return selectR(h.right, h.bitIndex, key, cursor, reference);
1:             }
1:         }
1:         else
1:         {
1:             if (selectR(h.right, h.bitIndex, key, cursor, reference))
1:             {
1:                 return selectR(h.left, h.bitIndex, key, cursor, reference);
1:             }
1:         }
1:         
1:         return false;
1:     }
1:     
1:     @Override
1:     public Map.Entry<K, V> traverse(Cursor<? super K, ? super V> cursor)
1:     {
1:         TrieEntry<K, V> entry = nextEntry(null);
1:         while (entry != null)
1:         {
1:             TrieEntry<K, V> current = entry;
1:             
1:             Decision decision = cursor.select(current);
1:             entry = nextEntry(current);
1:             
1:             switch(decision)
1:             {
1:                 case EXIT:
1:                     return current;
1: 
1:                 case REMOVE:
1:                     removeEntry(current);
1:                     break; // out of switch, stay in while loop
1: 
1:                 case REMOVE_AND_EXIT:
1:                     Map.Entry<K, V> value = new TrieEntry<>(current.getKey(), current.getValue(), -1);
1:                     removeEntry(current);
1:                     return value;
1: 
1:                 case CONTINUE: // do nothing.
1:             }
1:         }
1:         
1:         return null;
1:     }
1:     
1:     @Override
1:     public boolean containsKey(Object k)
1:     {
1:         if (k == null)
1:             return false;
1:         
1:         K key = Tries.cast(k);
1:         TrieEntry<K, V> entry = getNearestEntryForKey(key);
1:         return !entry.isEmpty() && compareKeys(key, entry.key);
1:     }
1:     
1:     @Override
1:     public Set<Map.Entry<K,V>> entrySet()
1:     {
1:         if (entrySet == null)
1:             entrySet = new EntrySet();
1: 
1:         return entrySet;
1:     }
1:     
1:     @Override
1:     public Set<K> keySet()
1:     {
1:         if (keySet == null)
1:             keySet = new KeySet();
1:         return keySet;
1:     }
1:     
1:     @Override
1:     public Collection<V> values()
1:     {
1:         if (values == null)
1:             values = new Values();
1:         return values;
1:     }
1:     
1:     /**
1:      * {@inheritDoc}
1:      * 
0:      * @throws ClassCastException if provided key is of an incompatible type 
1:      */
1:     @Override
1:     public V remove(Object k)
1:     {
1:         if (k == null)
1:             return null;
1:         
1:         K key = Tries.cast(k);
1:         TrieEntry<K, V> current = root.left;
1:         TrieEntry<K, V> path = root;
1:         while (true)
1:         {
1:             if (current.bitIndex <= path.bitIndex)
1:             {
1:                 if (!current.isEmpty() && compareKeys(key, current.key))
1:                 {
1:                     return removeEntry(current);
1:                 }
1:                 else
1:                 {
1:                     return null;
1:                 }
1:             }
1:             
1:             path = current;
1:             current = !isBitSet(key, current.bitIndex) ? current.left : current.right;
1:         }
1:     }
1:     
1:     /**
1:      * Returns the nearest entry for a given key.  This is useful
1:      * for finding knowing if a given key exists (and finding the value
1:      * for it), or for inserting the key.
1:      * 
1:      * The actual get implementation. This is very similar to
1:      * selectR but with the exception that it might return the
1:      * root Entry even if it's empty.
1:      */
1:     TrieEntry<K, V> getNearestEntryForKey(K key)
1:     {
1:         TrieEntry<K, V> current = root.left;
1:         TrieEntry<K, V> path = root;
1: 
1:         while(true)
1:         {
1:             if (current.bitIndex <= path.bitIndex)
1:                 return current;
1:             
1:             path = current;
1:             current = !isBitSet(key, current.bitIndex) ? current.left : current.right;
1:         }
1:     }
1:     
1:     /**
1:      * Removes a single entry from the {@link Trie}.
1:      * 
1:      * If we found a Key (Entry h) then figure out if it's
0:      * an internal (hard to remove) or external Entry (easy 
1:      * to remove)
1:      */
1:     V removeEntry(TrieEntry<K, V> h)
1:     {
1:         if (h != root)
1:         {
1:             if (h.isInternalNode())
1:             {
1:                 removeInternalEntry(h);
1:             }
1:             else
1:             {
1:                 removeExternalEntry(h);
1:             }
1:         }
1:         
1:         decrementSize();
1:         return h.setKeyValue(null, null);
1:     }
1:     
1:     /**
1:      * Removes an external entry from the {@link Trie}.
1:      * 
1:      * If it's an external Entry then just remove it.
1:      * This is very easy and straight forward.
1:      */
1:     private void removeExternalEntry(TrieEntry<K, V> h)
1:     {
1:         if (h == root)
1:         {
1:             throw new IllegalArgumentException("Cannot delete root Entry!");
1:         }
1:         else if (!h.isExternalNode())
1:         {
1:             throw new IllegalArgumentException(h + " is not an external Entry!");
1:         } 
1:         
1:         TrieEntry<K, V> parent = h.parent;
1:         TrieEntry<K, V> child = (h.left == h) ? h.right : h.left;
1:         
1:         if (parent.left == h)
1:         {
1:             parent.left = child;
1:         }
1:         else
1:         {
1:             parent.right = child;
1:         }
1:         
1:         // either the parent is changing, or the predecessor is changing.
1:         if (child.bitIndex > parent.bitIndex)
1:         {
1:             child.parent = parent;
1:         }
1:         else
1:         {
1:             child.predecessor = parent;
1:         }
1:         
1:     }
1:     
1:     /**
1:      * Removes an internal entry from the {@link Trie}.
1:      * 
1:      * If it's an internal Entry then "good luck" with understanding
1:      * this code. The Idea is essentially that Entry p takes Entry h's
1:      * place in the trie which requires some re-wiring.
1:      */
1:     private void removeInternalEntry(TrieEntry<K, V> h)
1:     {
1:         if (h == root)
1:         {
1:             throw new IllegalArgumentException("Cannot delete root Entry!");
1:         }
1:         else if (!h.isInternalNode())
1:         {
1:             throw new IllegalArgumentException(h + " is not an internal Entry!");
1:         } 
1:         
1:         TrieEntry<K, V> p = h.predecessor;
1:         
1:         // Set P's bitIndex
1:         p.bitIndex = h.bitIndex;
1:         
1:         // Fix P's parent, predecessor and child Nodes
1:         {
1:             TrieEntry<K, V> parent = p.parent;
1:             TrieEntry<K, V> child = (p.left == h) ? p.right : p.left;
1:             
1:             // if it was looping to itself previously,
1:             // it will now be pointed from it's parent
1:             // (if we aren't removing it's parent --
1:             //  in that case, it remains looping to itself).
1:             // otherwise, it will continue to have the same
1:             // predecessor.
1:             if (p.predecessor == p && p.parent != h)
1:                 p.predecessor = p.parent;
1:             
1:             if (parent.left == p)
1:             {
1:                 parent.left = child;
1:             }
1:             else
1:             {
1:                 parent.right = child;
1:             }
1:             
1:             if (child.bitIndex > parent.bitIndex)
1:             {
1:                 child.parent = parent;
1:             }
1:         }
1:         
1:         // Fix H's parent and child Nodes
1:         {         
0:             // If H is a parent of its left and right child 
1:             // then change them to P
1:             if (h.left.parent == h)
1:                 h.left.parent = p;
1: 
1:             if (h.right.parent == h)
1:                 h.right.parent = p;
1:             
1:             // Change H's parent
1:             if (h.parent.left == h)
1:             {
1:                 h.parent.left = p;
1:             }
1:             else
1:             {
1:                 h.parent.right = p;
1:             }
1:         }
1:         
1:         // Copy the remaining fields from H to P
1:         //p.bitIndex = h.bitIndex;
1:         p.parent = h.parent;
1:         p.left = h.left;
1:         p.right = h.right;
1:         
1:         // Make sure that if h was pointing to any uplinks,
1:         // p now points to them.
1:         if (isValidUplink(p.left, p))
1:             p.left.predecessor = p;
1:         
1:         if (isValidUplink(p.right, p))
1:             p.right.predecessor = p;
1:     }
1:     
1:     /**
1:      * Returns the entry lexicographically after the given entry.
1:      * If the given entry is null, returns the first node.
1:      */
1:     TrieEntry<K, V> nextEntry(TrieEntry<K, V> node)
1:     {
1:         return (node == null) ? firstEntry() : nextEntryImpl(node.predecessor, node, null);
1:     }
1:     
1:     /**
1:      * Scans for the next node, starting at the specified point, and using 'previous'
1:      * as a hint that the last node we returned was 'previous' (so we know not to return
1:      * it again).  If 'tree' is non-null, this will limit the search to the given tree.
1:      * 
1:      * The basic premise is that each iteration can follow the following steps:
1:      * 
1:      * 1) Scan all the way to the left.
1:      *   a) If we already started from this node last time, proceed to Step 2.
1:      *   b) If a valid uplink is found, use it.
1:      *   c) If the result is an empty node (root not set), break the scan.
1:      *   d) If we already returned the left node, break the scan.
1:      *   
1:      * 2) Check the right.
1:      *   a) If we already returned the right node, proceed to Step 3.
1:      *   b) If it is a valid uplink, use it.
1:      *   c) Do Step 1 from the right node.
1:      *   
1:      * 3) Back up through the parents until we encounter find a parent
1:      *    that we're not the right child of.
1:      *    
1:      * 4) If there's no right child of that parent, the iteration is finished.
1:      *    Otherwise continue to Step 5.
1:      * 
1:      * 5) Check to see if the right child is a valid uplink.
1:      *    a) If we already returned that child, proceed to Step 6.
1:      *       Otherwise, use it.
1:      *    
1:      * 6) If the right child of the parent is the parent itself, we've
1:      *    already found & returned the end of the Trie, so exit.
1:      *    
1:      * 7) Do Step 1 on the parent's right child.
1:      */
1:     TrieEntry<K, V> nextEntryImpl(TrieEntry<K, V> start, TrieEntry<K, V> previous, TrieEntry<K, V> tree)
1:     {
1:         TrieEntry<K, V> current = start;
1: 
1:         // Only look at the left if this was a recursive or
1:         // the first check, otherwise we know we've already looked
1:         // at the left.
1:         if (previous == null || start != previous.predecessor)
1:         {
1:             while (!current.left.isEmpty())
1:             {
1:                 // stop traversing if we've already
1:                 // returned the left of this node.
1:                 if (previous == current.left)
1:                     break;
1:                 
1:                 if (isValidUplink(current.left, current))
1:                     return current.left;
1:                 
1:                 current = current.left;
1:             }
1:         }
1:         
1:         // If there's no data at all, exit.
1:         if (current.isEmpty())
1:             return null;
1:         
1:         // If we've already returned the left,
1:         // and the immediate right is null,
1:         // there's only one entry in the Trie
1:         // which is stored at the root.
1:         //
1:         //  / ("")   <-- root
1:         //  \_/  \
1:         //       null <-- 'current'
1:         //
1:         if (current.right == null)
1:             return null;
1:         
1:         // If nothing valid on the left, try the right.
1:         if (previous != current.right)
1:         {
1:             // See if it immediately is valid.
1:             if (isValidUplink(current.right, current))
1:                 return current.right;
1:             
1:             // Must search on the right's side if it wasn't initially valid.
1:             return nextEntryImpl(current.right, previous, tree);
1:         }
1:         
1:         // Neither left nor right are valid, find the first parent
1:         // whose child did not come from the right & traverse it.
1:         while (current == current.parent.right)
1:         {
1:             // If we're going to traverse to above the subtree, stop.
1:             if (current == tree)
1:                 return null;
1:             
1:             current = current.parent;
1:         }
1: 
1:         // If we're on the top of the subtree, we can't go any higher.
1:         if (current == tree)
1:             return null;
1:         
1:         // If there's no right, the parent must be root, so we're done.
1:         if (current.parent.right == null)
1:             return null;
1:         
1:         // If the parent's right points to itself, we've found one.
1:         if (previous != current.parent.right && isValidUplink(current.parent.right, current.parent))
1:             return current.parent.right;
1:         
1:         // If the parent's right is itself, there can't be any more nodes.
1:         if (current.parent.right == current.parent)
1:             return null;
1:         
1:         // We need to traverse down the parent's right's path.
1:         return nextEntryImpl(current.parent.right, previous, tree);
1:     }
1:     
1:     /**
1:      * Returns the first entry the {@link Trie} is storing.
1:      * 
1:      * This is implemented by going always to the left until
1:      * we encounter a valid uplink. That uplink is the first key.
1:      */
1:     TrieEntry<K, V> firstEntry()
1:     {
1:         // if Trie is empty, no first node.
1:         return isEmpty() ? null : followLeft(root);
1:     }
1:     
1:     /** 
0:      * Goes left through the tree until it finds a valid node. 
1:      */
1:     TrieEntry<K, V> followLeft(TrieEntry<K, V> node)
1:     {
1:         while(true)
1:         {
1:             TrieEntry<K, V> child = node.left;
1:             // if we hit root and it didn't have a node, go right instead.
1:             if (child.isEmpty())
1:                 child = node.right;
1:             
1:             if (child.bitIndex <= node.bitIndex)
1:                 return child;
1:             
1:             node = child;
1:         }
1:     }
1:     
1:     /** 
0:      * Returns true if 'next' is a valid uplink coming from 'from'. 
1:      */
1:     static boolean isValidUplink(TrieEntry<?, ?> next, TrieEntry<?, ?> from)
1:     {
1:         return next != null && next.bitIndex <= from.bitIndex && !next.isEmpty();
1:     }
1:     
1:     /**
0:      * A {@link Reference} allows us to return something through a Method's 
0:      * argument list. An alternative would be to an Array with a length of 
1:      * one (1) but that leads to compiler warnings. Computationally and memory
0:      * wise there's no difference (except for the need to load the 
1:      * {@link Reference} Class but that happens only once).
1:      */
1:     private static class Reference<E>
1:     {
1:         
1:         private E item;
1:         
1:         public void set(E item)
1:         {
1:             this.item = item;
1:         }
1:         
1:         public E get()
1:         {
1:             return item;
1:         }
1:     }
1:     
1:     /**
1:      *  A {@link Trie} is a set of {@link TrieEntry} nodes
1:      */
1:     static class TrieEntry<K,V> extends BasicEntry<K, V>
1:     {
1:         
1:         private static final long serialVersionUID = 4596023148184140013L;
1:         
1:         /** The index this entry is comparing. */
1:         protected int bitIndex;
1:         
1:         /** The parent of this entry. */
1:         protected TrieEntry<K,V> parent;
1:         
1:         /** The left child of this entry. */
1:         protected TrieEntry<K,V> left;
1:         
1:         /** The right child of this entry. */
1:         protected TrieEntry<K,V> right;
1:         
0:         /** The entry who uplinks to this entry. */ 
1:         protected TrieEntry<K,V> predecessor;
1:         
1:         public TrieEntry(K key, V value, int bitIndex)
1:         {
1:             super(key, value);
1:             
1:             this.bitIndex = bitIndex;
1:             
1:             this.parent = null;
1:             this.left = this;
1:             this.right = null;
1:             this.predecessor = this;
1:         }
1:         
1:         /**
1:          * Whether or not the entry is storing a key.
1:          * Only the root can potentially be empty, all other
1:          * nodes must have a key.
1:          */
1:         public boolean isEmpty()
1:         {
1:             return key == null;
1:         }
1:         
1:         /** 
0:          * Neither the left nor right child is a loopback 
1:          */
1:         public boolean isInternalNode()
1:         {
1:             return left != this && right != this;
1:         }
1:         
1:         /** 
0:          * Either the left or right child is a loopback 
1:          */
1:         public boolean isExternalNode()
1:         {
1:             return !isInternalNode();
1:         }
1:     }
1:     
1: 
1:     /**
0:      * This is a entry set view of the {@link Trie} as returned 
1:      * by {@link Map#entrySet()}
1:      */
1:     private class EntrySet extends AbstractSet<Map.Entry<K,V>>
1:     {
1:         @Override
1:         public Iterator<Map.Entry<K,V>> iterator()
1:         {
1:             return new EntryIterator();
1:         }
1:         
1:         @Override
1:         public boolean contains(Object o)
1:         {
1:             if (!(o instanceof Map.Entry))
1:                 return false;
1:             
1:             TrieEntry<K,V> candidate = getEntry(((Map.Entry<?, ?>)o).getKey());
1:             return candidate != null && candidate.equals(o);
1:         }
1:         
1:         @Override
1:         public boolean remove(Object o)
1:         {
1:             int size = size();
1:             AbstractPatriciaTrie.this.remove(o);
1:             return size != size();
1:         }
1:         
1:         @Override
1:         public int size()
1:         {
1:             return AbstractPatriciaTrie.this.size();
1:         }
1:         
1:         @Override
1:         public void clear()
1:         {
1:             AbstractPatriciaTrie.this.clear();
1:         }
1:         
1:         /**
1:          * An {@link Iterator} that returns {@link Entry} Objects
1:          */
1:         private class EntryIterator extends TrieIterator<Map.Entry<K,V>>
1:         {
1:             @Override
1:             public Map.Entry<K,V> next()
1:             {
1:                 return nextEntry();
1:             }
1:         }
1:     }
1:     
1:     /**
0:      * This is a key set view of the {@link Trie} as returned 
1:      * by {@link Map#keySet()}
1:      */
1:     private class KeySet extends AbstractSet<K>
1:     {
1:         @Override
1:         public Iterator<K> iterator()
1:         {
1:             return new KeyIterator();
1:         }
1:         
1:         @Override
1:         public int size()
1:         {
1:             return AbstractPatriciaTrie.this.size();
1:         }
1:         
1:         @Override
1:         public boolean contains(Object o)
1:         {
1:             return containsKey(o);
1:         }
1:         
1:         @Override
1:         public boolean remove(Object o)
1:         {
1:             int size = size();
1:             AbstractPatriciaTrie.this.remove(o);
1:             return size != size();
1:         }
1:         
1:         @Override
1:         public void clear()
1:         {
1:             AbstractPatriciaTrie.this.clear();
1:         }
1:         
1:         /**
1:          * An {@link Iterator} that returns Key Objects
1:          */
1:         private class KeyIterator extends TrieIterator<K>
1:         {
1:             @Override
1:             public K next()
1:             {
1:                 return nextEntry().getKey();
1:             }
1:         }
1:     }
1:     
1:     /**
0:      * This is a value view of the {@link Trie} as returned 
1:      * by {@link Map#values()}
1:      */
1:     private class Values extends AbstractCollection<V>
1:     {
1:         @Override
1:         public Iterator<V> iterator()
1:         {
1:             return new ValueIterator();
1:         }
1:         
1:         @Override
1:         public int size()
1:         {
1:             return AbstractPatriciaTrie.this.size();
1:         }
1:         
1:         @Override
1:         public boolean contains(Object o)
1:         {
1:             return containsValue(o);
1:         }
1:         
1:         @Override
1:         public void clear()
1:         {
1:             AbstractPatriciaTrie.this.clear();
1:         }
1:         
1:         @Override
1:         public boolean remove(Object o)
1:         {
1:             for (Iterator<V> it = iterator(); it.hasNext(); )
1:             {
1:                 V value = it.next();
1:                 if (Tries.areEqual(value, o))
1:                 {
1:                     it.remove();
1:                     return true;
1:                 }
1:             }
1:             return false;
1:         }
1:         
1:         /**
1:          * An {@link Iterator} that returns Value Objects
1:          */
1:         private class ValueIterator extends TrieIterator<V>
1:         {
1:             @Override
1:             public V next()
1:             {
1:                 return nextEntry().getValue();
1:             }
1:         }
1:     }
1:     
1:     /** 
0:      * An iterator for the entries. 
1:      */
1:     abstract class TrieIterator<E> implements Iterator<E>
1:     {
1:         /**
1:          * For fast-fail
1:          */
1:         protected int expectedModCount = AbstractPatriciaTrie.this.modCount;
1:         
1:         protected TrieEntry<K, V> next; // the next node to return
1:         protected TrieEntry<K, V> current; // the current entry we're on
1:         
1:         /**
1:          * Starts iteration from the root
1:          */
1:         protected TrieIterator()
1:         {
1:             next = AbstractPatriciaTrie.this.nextEntry(null);
1:         }
1:         
1:         /**
1:          * Starts iteration at the given entry
1:          */
1:         protected TrieIterator(TrieEntry<K, V> firstEntry)
1:         {
1:             next = firstEntry;
1:         }
1:         
1:         /**
1:          * Returns the next {@link TrieEntry}
1:          */
1:         protected TrieEntry<K,V> nextEntry()
1:         {
1:             if (expectedModCount != AbstractPatriciaTrie.this.modCount)
1:                 throw new ConcurrentModificationException();
1:             
1:             TrieEntry<K,V> e = next;
1:             if (e == null)
1:                 throw new NoSuchElementException();
1:             
1:             next = findNext(e);
1:             current = e;
1:             return e;
1:         }
1:         
1:         /**
1:          * @see PatriciaTrie#nextEntry(TrieEntry)
1:          */
1:         protected TrieEntry<K, V> findNext(TrieEntry<K, V> prior)
1:         {
1:             return AbstractPatriciaTrie.this.nextEntry(prior);
1:         }
1:         
1:         @Override
1:         public boolean hasNext()
1:         {
1:             return next != null;
1:         }
1:         
1:         @Override
1:         public void remove()
1:         {
1:             if (current == null)
1:                 throw new IllegalStateException();
1:             
1:             if (expectedModCount != AbstractPatriciaTrie.this.modCount)
1:                 throw new ConcurrentModificationException();
1:             
1:             TrieEntry<K, V> node = current;
1:             current = null;
1:             AbstractPatriciaTrie.this.removeEntry(node);
1:             
1:             expectedModCount = AbstractPatriciaTrie.this.modCount;
1:         }
1:     }
1: }
============================================================================