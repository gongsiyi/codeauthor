1:6e81f81: /*
1:6e81f81: * Licensed to the Apache Software Foundation (ASF) under one
1:6e81f81: * or more contributor license agreements.  See the NOTICE file
1:6e81f81: * distributed with this work for additional information
1:6e81f81: * regarding copyright ownership.  The ASF licenses this file
1:6e81f81: * to you under the Apache License, Version 2.0 (the
1:6e81f81: * "License"); you may not use this file except in compliance
1:6e81f81: * with the License.  You may obtain a copy of the License at
1:6e81f81: *
1:6e81f81: *    http://www.apache.org/licenses/LICENSE-2.0
1:6e81f81: *
1:6e81f81: * Unless required by applicable law or agreed to in writing,
1:6e81f81: * software distributed under the License is distributed on an
1:6e81f81: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:6e81f81: * KIND, either express or implied.  See the License for the
1:6e81f81: * specific language governing permissions and limitations
1:6e81f81: * under the License.
1:6e81f81: */
1:6e81f81: package org.apache.cassandra.db;
25:6e81f81: 
1:a991b64: import java.nio.ByteBuffer;
1:6e81f81: import java.util.*;
1:e338d2f: import java.util.regex.Pattern;
1:e338d2f: import java.util.regex.Matcher;
1:e338d2f: 
1:e338d2f: import com.google.common.base.Joiner;
1:6e81f81: 
1:6e81f81: import org.junit.Test;
1:6e81f81: import static org.junit.Assert.*;
1:6e81f81: 
1:7813dee: import org.apache.cassandra.db.marshal.Int32Type;
1:6e81f81: import org.apache.cassandra.utils.ByteBufferUtil;
1:6e81f81: 
1:6e81f81: public class RangeTombstoneListTest
14:6e81f81: {
1:7813dee:     private static final ClusteringComparator cmp = new ClusteringComparator(Int32Type.instance);
1:6e81f81: 
4:6e81f81:     @Test
1:6e81f81:     public void sortedAdditionTest()
1:6e81f81:     {
1:6e81f81:         sortedAdditionTest(0);
1:6e81f81:         sortedAdditionTest(10);
14:6e81f81:     }
1:2e3727e: 
1:6e81f81:     private void sortedAdditionTest(int initialCapacity)
1:7895273:     {
1:6e81f81:         RangeTombstoneList l = new RangeTombstoneList(cmp, initialCapacity);
1:6e81f81:         RangeTombstone rt1 = rt(1, 5, 3);
1:6e81f81:         RangeTombstone rt2 = rt(7, 10, 2);
1:6e81f81:         RangeTombstone rt3 = rt(10, 13, 1);
1:5bd37b9: 
1:6e81f81:         l.add(rt1);
1:6e81f81:         l.add(rt2);
1:6e81f81:         l.add(rt3);
1:5bd37b9: 
2:6e81f81:         Iterator<RangeTombstone> iter = l.iterator();
1:6e81f81:         assertRT(rt1, iter.next());
1:6e81f81:         assertRT(rt2, iter.next());
1:a991b64:         assertRT(rtei(10, 13, 1), iter.next());
1:5bd37b9: 
2:6e81f81:         assert !iter.hasNext();
1:5bd37b9:     }
1:5bd37b9: 
1:2e3727e:     @Test
1:6e81f81:     public void nonSortedAdditionTest()
1:5bd37b9:     {
1:6e81f81:         nonSortedAdditionTest(0);
1:6e81f81:         nonSortedAdditionTest(10);
1:5bd37b9:     }
1:5bd37b9: 
1:6e81f81:     private void nonSortedAdditionTest(int initialCapacity)
1:5bd37b9:     {
1:6e81f81:         RangeTombstoneList l = new RangeTombstoneList(cmp, initialCapacity);
1:6e81f81:         RangeTombstone rt1 = rt(1, 5, 3);
1:6e81f81:         RangeTombstone rt2 = rt(7, 10, 2);
1:6e81f81:         RangeTombstone rt3 = rt(10, 13, 1);
1:5bd37b9: 
1:6e81f81:         l.add(rt2);
1:6e81f81:         l.add(rt1);
1:6e81f81:         l.add(rt3);
1:5bd37b9: 
1:6e81f81:         Iterator<RangeTombstone> iter = l.iterator();
1:6e81f81:         assertRT(rt1, iter.next());
1:6e81f81:         assertRT(rt2, iter.next());
1:a991b64:         assertRT(rtei(10, 13, 1), iter.next());
1:5bd37b9: 
1:6e81f81:         assert !iter.hasNext();
1:6e81f81:     }
1:6e81f81: 
1:e338d2f:     @Test
1:6e81f81:     public void overlappingAdditionTest()
1:5bd37b9:     {
1:6e81f81:         overlappingAdditionTest(0);
1:6e81f81:         overlappingAdditionTest(10);
1:6e81f81:     }
1:6e81f81: 
1:6e81f81:     private void overlappingAdditionTest(int initialCapacity)
1:6e81f81:     {
1:6e81f81:         RangeTombstoneList l = new RangeTombstoneList(cmp, initialCapacity);
1:6e81f81: 
1:6e81f81:         l.add(rt(4, 10, 3));
1:6e81f81:         l.add(rt(1, 7, 2));
1:6e81f81:         l.add(rt(8, 13, 4));
1:6e81f81:         l.add(rt(0, 15, 1));
1:6e81f81: 
1:6e81f81:         Iterator<RangeTombstone> iter = l.iterator();
1:a991b64:         assertRT(rtie(0, 1, 1), iter.next());
1:a991b64:         assertRT(rtie(1, 4, 2), iter.next());
1:a991b64:         assertRT(rtie(4, 8, 3), iter.next());
1:4768daa:         assertRT(rt(8, 13, 4), iter.next());
1:a991b64:         assertRT(rtei(13, 15, 1), iter.next());
1:6e81f81:         assert !iter.hasNext();
1:6e81f81: 
1:6e81f81:         RangeTombstoneList l2 = new RangeTombstoneList(cmp, initialCapacity);
1:8d3d67e:         l2.add(rt(4, 10, 12L));
1:8d3d67e:         l2.add(rt(0, 8, 25L));
1:6e81f81: 
1:a991b64:         assertEquals(25L, l2.searchDeletionTime(clustering(8)).markedForDeleteAt());
1:6e81f81:     }
1:6e81f81: 
1:5bd37b9:     @Test
1:4768daa:     public void largeAdditionTest()
1:6e81f81:     {
1:4768daa:         int N = 3000;
1:4768daa:         // Test that the StackOverflow from #6181 is fixed
1:4768daa:         RangeTombstoneList l = new RangeTombstoneList(cmp, N);
1:4768daa:         for (int i = 0; i < N; i++)
1:4768daa:             l.add(rt(2*i+1, 2*i+2, 1));
1:4768daa:         assertEquals(l.size(), N);
1:4768daa: 
1:4768daa:         l.add(rt(0, 2*N+3, 2));
1:6e81f81:     }
1:6e81f81: 
1:6e81f81:     @Test
1:6e81f81:     public void simpleOverlapTest()
1:6e81f81:     {
1:6e81f81:         RangeTombstoneList l1 = new RangeTombstoneList(cmp, 0);
1:6e81f81:         l1.add(rt(0, 10, 3));
1:6e81f81:         l1.add(rt(3, 7, 5));
1:6e81f81: 
1:6e81f81:         Iterator<RangeTombstone> iter1 = l1.iterator();
1:a991b64:         assertRT(rtie(0, 3, 3), iter1.next());
1:6e81f81:         assertRT(rt(3, 7, 5), iter1.next());
1:a991b64:         assertRT(rtei(7, 10, 3), iter1.next());
1:6e81f81:         assert !iter1.hasNext();
1:6e81f81: 
1:6e81f81:         RangeTombstoneList l2 = new RangeTombstoneList(cmp, 0);
1:6e81f81:         l2.add(rt(0, 10, 3));
1:6e81f81:         l2.add(rt(3, 7, 2));
1:6e81f81: 
1:6e81f81:         Iterator<RangeTombstone> iter2 = l2.iterator();
1:6e81f81:         assertRT(rt(0, 10, 3), iter2.next());
1:6e81f81:         assert !iter2.hasNext();
1:6e81f81:     }
1:6e81f81: 
1:6e81f81:     @Test
1:4768daa:     public void overlappingPreviousEndEqualsStartTest()
1:4768daa:     {
1:4768daa:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
1:4768daa:         // add a RangeTombstone, so, last insert is not in insertion order
1:4768daa:         l.add(rt(11, 12, 2));
1:4768daa:         l.add(rt(1, 4, 2));
1:4768daa:         l.add(rt(4, 10, 5));
1:4768daa: 
1:a991b64:         assertEquals(2, l.searchDeletionTime(clustering(3)).markedForDeleteAt());
1:a991b64:         assertEquals(5, l.searchDeletionTime(clustering(4)).markedForDeleteAt());
1:a991b64:         assertEquals(5, l.searchDeletionTime(clustering(8)).markedForDeleteAt());
1:4768daa:         assertEquals(3, l.size());
1:4768daa:     }
1:4768daa: 
1:4768daa:     @Test
1:6e81f81:     public void searchTest()
1:6e81f81:     {
3:6e81f81:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
1:6e81f81:         l.add(rt(0, 4, 5));
1:6e81f81:         l.add(rt(4, 6, 2));
1:6e81f81:         l.add(rt(9, 12, 1));
1:6e81f81:         l.add(rt(14, 15, 3));
1:6e81f81:         l.add(rt(15, 17, 6));
1:6e81f81: 
1:a991b64:         assertEquals(null, l.searchDeletionTime(clustering(-1)));
1:6e81f81: 
1:a991b64:         assertEquals(5, l.searchDeletionTime(clustering(0)).markedForDeleteAt());
1:a991b64:         assertEquals(5, l.searchDeletionTime(clustering(3)).markedForDeleteAt());
1:a991b64:         assertEquals(5, l.searchDeletionTime(clustering(4)).markedForDeleteAt());
1:6e81f81: 
1:a991b64:         assertEquals(2, l.searchDeletionTime(clustering(5)).markedForDeleteAt());
1:6e81f81: 
1:a991b64:         assertEquals(null, l.searchDeletionTime(clustering(7)));
1:6e81f81: 
1:a991b64:         assertEquals(3, l.searchDeletionTime(clustering(14)).markedForDeleteAt());
1:6e81f81: 
1:a991b64:         assertEquals(6, l.searchDeletionTime(clustering(15)).markedForDeleteAt());
1:a991b64:         assertEquals(null, l.searchDeletionTime(clustering(18)));
1:6e81f81:     }
1:6e81f81: 
1:6e81f81:     @Test
1:6e81f81:     public void addAllTest()
1:6e81f81:     {
1:6e81f81:         RangeTombstoneList l1 = new RangeTombstoneList(cmp, 0);
1:6e81f81:         l1.add(rt(0, 4, 5));
1:6e81f81:         l1.add(rt(6, 10, 2));
1:6e81f81:         l1.add(rt(15, 17, 1));
1:6e81f81: 
1:6e81f81:         RangeTombstoneList l2 = new RangeTombstoneList(cmp, 0);
1:6e81f81:         l2.add(rt(3, 5, 7));
1:6e81f81:         l2.add(rt(7, 8, 3));
1:6e81f81:         l2.add(rt(8, 12, 1));
1:6e81f81:         l2.add(rt(14, 17, 4));
1:6e81f81: 
1:5bd37b9:         l1.addAll(l2);
1:5bd37b9: 
1:6e81f81:         Iterator<RangeTombstone> iter = l1.iterator();
1:a991b64:         assertRT(rtie(0, 3, 5), iter.next());
1:a991b64:         assertRT(rt(3, 5, 7), iter.next());
1:a991b64:         assertRT(rtie(6, 7, 2), iter.next());
1:6e81f81:         assertRT(rt(7, 8, 3), iter.next());
1:a991b64:         assertRT(rtei(8, 10, 2), iter.next());
1:a991b64:         assertRT(rtei(10, 12, 1), iter.next());
1:4768daa:         assertRT(rt(14, 17, 4), iter.next());
1:5bd37b9: 
1:6e81f81:         assert !iter.hasNext();
1:5bd37b9:     }
1:5bd37b9: 
1:6e81f81:     @Test
1:f5b224c:     public void addAllSequentialTest()
1:f5b224c:     {
1:f5b224c:         RangeTombstoneList l1 = new RangeTombstoneList(cmp, 0);
1:f5b224c:         l1.add(rt(3, 5, 2));
1:f5b224c: 
1:f5b224c:         RangeTombstoneList l2 = new RangeTombstoneList(cmp, 0);
1:f5b224c:         l2.add(rt(5, 7, 7));
1:f5b224c: 
1:f5b224c:         l1.addAll(l2);
1:f5b224c: 
1:f5b224c:         Iterator<RangeTombstone> iter = l1.iterator();
1:a991b64:         assertRT(rtie(3, 5, 2), iter.next());
1:f5b224c:         assertRT(rt(5, 7, 7), iter.next());
1:f5b224c: 
1:f5b224c:         assert !iter.hasNext();
1:f5b224c:     }
1:f5b224c: 
1:f5b224c:     @Test
1:f5b224c:     public void addAllIncludedTest()
1:f5b224c:     {
1:f5b224c:         RangeTombstoneList l1 = new RangeTombstoneList(cmp, 0);
1:f5b224c:         l1.add(rt(3, 10, 5));
1:f5b224c: 
1:f5b224c:         RangeTombstoneList l2 = new RangeTombstoneList(cmp, 0);
1:f5b224c:         l2.add(rt(4, 5, 2));
1:f5b224c:         l2.add(rt(5, 7, 3));
1:f5b224c:         l2.add(rt(7, 9, 4));
1:f5b224c: 
1:f5b224c:         l1.addAll(l2);
1:f5b224c: 
1:f5b224c:         Iterator<RangeTombstone> iter = l1.iterator();
1:f5b224c:         assertRT(rt(3, 10, 5), iter.next());
1:f5b224c: 
1:f5b224c:         assert !iter.hasNext();
1:f5b224c:     }
1:f5b224c: 
1:f5b224c:     @Test
1:e338d2f:     public void addAllBugFrom9799()
1:e338d2f:     {
1:e338d2f:         RangeTombstoneList l1 = fromString("{ (6, 7]@4 - (7, 8)@1 - [12, 12]@0 - [13, 13]@0 - (20, 21)@3 - [27, 27]@2 - (33, 34)@2 - (35, 36]@4 - (40, 41]@0 - (42, 43)@2 - (44, 45)@3 - [47, 47]@1 - (47, 48)@0 - [55, 55]@4 - [61, 61]@4 - [67, 67]@0 - [70, 70]@4 - [77, 77]@1 - (83, 84)@1 - [90, 90]@0 - (91, 92]@4 - [93, 93]@0 - (94, 95)@2 - (100, 101]@3 - (103, 104]@0 - (108, 109]@2 - (115, 116]@3 - (116, 117]@3 - (118, 119)@4 - (125, 126)@2 - [131, 131]@1 - [132, 132]@3 - [139, 139]@0 - [145, 145]@1 - (145, 146]@3 - (147, 148]@4 - (150, 151]@1 - (156, 157)@2 - (158, 159)@2 - [164, 164]@4 - (168, 169)@0 - (171, 172)@4 - (173, 174]@0 - [179, 179]@1 - (186, 187]@4 - [191, 191]@1 }");
1:e338d2f:         RangeTombstoneList l2 = fromString("{ (1, 12)@8 - [12, 13)@8 - [13, 18]@7 }");
1:e338d2f:         l1.addAll(l2);
1:e338d2f:         assertValid(l1);
1:e338d2f:     }
1:e338d2f: 
1:173f255:     private RangeTombstoneList makeRandom(Random rand, int size, int maxItSize, int maxItDistance, int maxMarkedAt)
1:5bd37b9:     {
1:7895273:         RangeTombstoneList l = new RangeTombstoneList(cmp, size);
1:7895273: 
1:7895273:         int prevStart = -1;
1:7895273:         int prevEnd = 0;
1:7813dee:         boolean prevStartInclusive = false;
1:7813dee:         boolean prevEndInclusive = false;
1:7895273:         for (int i = 0; i < size; i++)
1:7895273:         {
1:7895273:             int nextStart = prevEnd + rand.nextInt(maxItDistance);
1:7895273:             int nextEnd = nextStart + rand.nextInt(maxItSize);
1:7895273: 
1:7813dee:             boolean startInclusive = rand.nextBoolean();
1:7813dee:             boolean endInclusive = rand.nextBoolean();
1:7895273: 
1:7813dee:             // Now make sure we create meaningful ranges
1:7813dee: 
1:7813dee:             if (prevEnd == nextStart)
1:7813dee:                 startInclusive = !prevEndInclusive;
1:7813dee: 
1:7813dee:             if (nextStart == nextEnd)
1:7813dee:             {
1:7813dee:                 if (startInclusive)
1:7813dee:                     endInclusive = true;
1:7813dee:                 else
1:7813dee:                     nextEnd += 1;
1:7813dee:             }
1:7813dee: 
1:7813dee:             l.add(rt(nextStart, startInclusive, nextEnd, endInclusive, rand.nextInt(maxMarkedAt)));
1:7895273: 
1:7895273:             prevStart = nextStart;
1:7895273:             prevEnd = nextEnd;
1:7813dee:             prevStartInclusive = startInclusive;
1:7813dee:             prevEndInclusive = endInclusive;
1:7895273:         }
1:7895273:         return l;
1:7895273:     }
1:7895273: 
1:7895273:     @Test
1:7895273:     public void addAllRandomTest() throws Throwable
1:7895273:     {
1:7895273:         int TEST_COUNT = 1000;
1:7895273:         int MAX_LIST_SIZE = 50;
1:7895273: 
1:7895273:         int MAX_IT_SIZE = 20;
1:7895273:         int MAX_IT_DISTANCE = 10;
1:7895273:         int MAX_MARKEDAT = 10;
1:7895273: 
1:173f255:         long seed = System.nanoTime();
1:173f255:         Random rand = new Random(seed);
1:5bd37b9: 
1:7895273:         for (int i = 0; i < TEST_COUNT; i++)
1:7895273:         {
1:173f255:             RangeTombstoneList l1 = makeRandom(rand, rand.nextInt(MAX_LIST_SIZE) + 1, rand.nextInt(MAX_IT_SIZE) + 1, rand.nextInt(MAX_IT_DISTANCE) + 1, rand.nextInt(MAX_MARKEDAT) + 1);
1:173f255:             RangeTombstoneList l2 = makeRandom(rand, rand.nextInt(MAX_LIST_SIZE) + 1, rand.nextInt(MAX_IT_SIZE) + 1, rand.nextInt(MAX_IT_DISTANCE) + 1, rand.nextInt(MAX_MARKEDAT) + 1);
1:7895273: 
1:7895273:             RangeTombstoneList l1Initial = l1.copy();
1:7895273: 
1:7895273:             try
1:7895273:             {
1:7895273:                 // We generate the list randomly, so "all" we check is that the resulting range tombstone list looks valid.
1:7895273:                 l1.addAll(l2);
1:7895273:                 assertValid(l1);
1:7895273:             }
1:7895273:             catch (Throwable e)
1:7895273:             {
1:7895273:                 System.out.println("Error merging:");
1:7895273:                 System.out.println(" l1: " + toString(l1Initial));
1:7895273:                 System.out.println(" l2: " + toString(l2));
1:173f255:                 System.out.println("Seed was: " + seed);
1:7895273:                 throw e;
1:7895273:             }
1:7895273:         }
1:7895273:     }
1:7895273: 
1:6e81f81:     @Test
1:2e3727e:     public void nonSortedAdditionTestWithOneTombstoneWithEmptyEnd()
1:2e3727e:     {
1:2e3727e:         nonSortedAdditionTestWithOneRangeWithEmptyEnd(0);
1:2e3727e:         nonSortedAdditionTestWithOneRangeWithEmptyEnd(10);
1:2e3727e:     }
1:2e3727e: 
1:2e3727e:   private static void nonSortedAdditionTestWithOneRangeWithEmptyEnd(int initialCapacity)
1:2e3727e:     {
1:2e3727e:         RangeTombstoneList l = new RangeTombstoneList(cmp, initialCapacity);
1:2e3727e:         RangeTombstone rt1 = rt(1, 5, 3);
1:2e3727e:         RangeTombstone rt2 = rt(7, 10, 2);
1:2e3727e:         RangeTombstone rt3 = atLeast(11, 1, 0);
1:2e3727e: 
1:2e3727e:         l.add(rt2);
1:2e3727e:         l.add(rt3);
1:2e3727e:         l.add(rt1);
1:2e3727e: 
1:2e3727e:         Iterator<RangeTombstone> iter = l.iterator();
1:2e3727e:         assertRT(rt1, iter.next());
1:2e3727e:         assertRT(rt2, iter.next());
1:2e3727e:         assertRT(rt3, iter.next());
1:2e3727e: 
1:2e3727e:         assert !iter.hasNext();
1:2e3727e:     }
1:2e3727e: 
1:2e3727e:     @Test
1:2e3727e:     public void addRangeWithEmptyEndWitchIncludeExistingRange()
1:2e3727e:     {
1:2e3727e: 
1:2e3727e:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
1:2e3727e: 
1:2e3727e:         l.add(rt(4, 10, 3));
1:2e3727e:         l.add(atLeast(3, 4, 0));
1:2e3727e: 
1:2e3727e:         Iterator<RangeTombstone> iter = l.iterator();
1:2e3727e:         assertRT(atLeast(3, 4, 0), iter.next());
1:2e3727e:         assertFalse(iter.hasNext());
1:2e3727e:     }
1:2e3727e: 
1:2e3727e:     @Test
1:2e3727e:     public void addRangeWithEmptyStartAndEnd()
1:2e3727e:     {
1:2e3727e: 
1:2e3727e:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
1:2e3727e: 
1:2e3727e:         l.add(rt(4, 10, 3));
1:2e3727e:         l.add(atMost(12, 4, 0));
1:2e3727e: 
1:2e3727e:         Iterator<RangeTombstone> iter = l.iterator();
1:2e3727e:         assertRT(atMost(12, 4, 0), iter.next());
1:2e3727e:         assertFalse(iter.hasNext());
1:2e3727e:     }
1:2e3727e: 
1:2e3727e:     @Test
1:2e3727e:     public void addRangeWithEmptyEndToRangeWithEmptyStartAndEnd()
1:2e3727e:     {
1:2e3727e: 
1:2e3727e:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
1:2e3727e: 
1:2e3727e:         l.add(new RangeTombstone(Slice.ALL, new DeletionTime(2, 0)));
1:2e3727e:         l.add(atLeast(12, 4, 0));
1:2e3727e: 
1:2e3727e:         Iterator<RangeTombstone> iter = l.iterator();
1:2e3727e:         assertRT(lessThan(12, 2, 0), iter.next());
1:2e3727e:         assertRT(atLeast(12, 4, 0), iter.next());
1:2e3727e:         assertFalse(iter.hasNext());
1:2e3727e:     }
1:2e3727e: 
1:2e3727e:     @Test
1:2e3727e:     public void addRangeWithEmptyEndWitchIncludeExistingRangeWithEmptyEnd()
1:2e3727e:     {
1:2e3727e: 
1:2e3727e:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
1:2e3727e: 
1:2e3727e:         l.add(atLeast(5, 3, 0));
1:2e3727e:         l.add(atLeast(3, 4, 0));
1:2e3727e: 
1:2e3727e:         Iterator<RangeTombstone> iter = l.iterator();
1:2e3727e:         assertRT(atLeast(3, 4, 0), iter.next());
1:2e3727e:         assertFalse(iter.hasNext());
1:2e3727e:     }
1:2e3727e: 
1:2e3727e:     @Test
1:2e3727e:     public void addIncludedRangeToRangeWithEmptyEnd()
1:2e3727e:     {
1:2e3727e: 
1:2e3727e:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
1:2e3727e: 
1:2e3727e:         l.add(atLeast(3, 3, 0));
1:2e3727e:         l.add(rt(4, 10, 4));
1:2e3727e: 
1:2e3727e:         Iterator<RangeTombstone> iter = l.iterator();
1:2e3727e:         assertRT(rtie(3, 4, 3), iter.next());
1:2e3727e:         assertRT(rt(4, 10, 4), iter.next());
1:2e3727e:         assertRT(greaterThan(10, 3, 0), iter.next());
1:2e3727e:         assertFalse(iter.hasNext());
1:2e3727e:     }
1:2e3727e: 
1:2e3727e:     @Test
1:2e3727e:     public void addIncludedRangeWithEmptyEndToRangeWithEmptyEnd()
1:2e3727e:     {
1:2e3727e: 
1:2e3727e:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
1:2e3727e: 
1:2e3727e:         l.add(atLeast(3, 3, 0));
1:2e3727e:         l.add(atLeast(5, 4, 0));
1:2e3727e: 
1:2e3727e:         Iterator<RangeTombstone> iter = l.iterator();
1:2e3727e:         assertRT(rtie(3, 5, 3), iter.next());
1:2e3727e:         assertRT(atLeast(5, 4, 0), iter.next());
1:2e3727e:         assertFalse(iter.hasNext());
1:2e3727e:     }
1:2e3727e: 
1:2e3727e:     @Test
1:2e3727e:     public void addRangeWithEmptyEndWitchOverlapExistingRange()
1:2e3727e:     {
1:2e3727e: 
1:2e3727e:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
1:2e3727e: 
1:2e3727e:         l.add(rt(4, 10, 3));
1:2e3727e:         l.add(atLeast(6, 4, 0));
1:2e3727e: 
1:2e3727e:         Iterator<RangeTombstone> iter = l.iterator();
1:2e3727e:         assertRT(rtie(4, 6, 3), iter.next());
1:2e3727e:         assertRT(atLeast(6, 4, 0), iter.next());
1:2e3727e:         assertFalse(iter.hasNext());
1:2e3727e:     }
1:2e3727e: 
1:2e3727e:     @Test
1:2e3727e:     public void addOverlappingRangeToRangeWithEmptyEnd()
1:2e3727e:     {
1:2e3727e: 
1:2e3727e:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
1:2e3727e: 
1:2e3727e:         l.add(atLeast(3, 3, 0));
1:2e3727e:         l.add(rt(1, 10, 4));
1:2e3727e: 
1:2e3727e:         Iterator<RangeTombstone> iter = l.iterator();
1:2e3727e:         assertRT(rt(1, 10, 4), iter.next());
1:2e3727e:         assertRT(greaterThan(10, 3, 0), iter.next());
1:2e3727e:         assertFalse(iter.hasNext());
1:2e3727e:     }
1:2e3727e: 
1:2e3727e:     @Test
1:2e3727e:     public void searchTestWithEmptyStart()
1:2e3727e:     {
1:2e3727e:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
1:2e3727e:         l.add(atMost(4, 5, 0));
1:2e3727e:         l.add(rt(4, 6, 2));
1:2e3727e:         l.add(rt(9, 12, 1));
1:2e3727e:         l.add(rt(14, 15, 3));
1:2e3727e:         l.add(rt(15, 17, 6));
1:2e3727e: 
1:2e3727e:         assertEquals(5, l.searchDeletionTime(clustering(-1)).markedForDeleteAt());
1:2e3727e:         assertEquals(5, l.searchDeletionTime(clustering(0)).markedForDeleteAt());
1:2e3727e:         assertEquals(5, l.searchDeletionTime(clustering(3)).markedForDeleteAt());
1:2e3727e:         assertEquals(5, l.searchDeletionTime(clustering(4)).markedForDeleteAt());
1:2e3727e: 
1:2e3727e:         assertEquals(2, l.searchDeletionTime(clustering(5)).markedForDeleteAt());
1:2e3727e: 
1:2e3727e:         assertEquals(null, l.searchDeletionTime(clustering(7)));
1:2e3727e: 
1:2e3727e:         assertEquals(3, l.searchDeletionTime(clustering(14)).markedForDeleteAt());
1:2e3727e: 
1:2e3727e:         assertEquals(6, l.searchDeletionTime(clustering(15)).markedForDeleteAt());
1:2e3727e:         assertEquals(null, l.searchDeletionTime(clustering(18)));
1:2e3727e:     }
1:2e3727e: 
1:2e3727e:     @Test
1:2e3727e:     public void searchTestWithRangeWithEmptyEnd()
1:2e3727e:     {
1:2e3727e:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
1:2e3727e:         l.add(rt(0, 4, 5));
1:2e3727e:         l.add(rt(4, 6, 2));
1:2e3727e:         l.add(rt(9, 12, 1));
1:2e3727e:         l.add(rt(14, 15, 3));
1:2e3727e:         l.add(atLeast(15, 6, 0));
1:2e3727e: 
1:2e3727e:         assertEquals(null, l.searchDeletionTime(clustering(-1)));
1:2e3727e: 
1:2e3727e:         assertEquals(5, l.searchDeletionTime(clustering(0)).markedForDeleteAt());
1:2e3727e:         assertEquals(5, l.searchDeletionTime(clustering(3)).markedForDeleteAt());
1:2e3727e:         assertEquals(5, l.searchDeletionTime(clustering(4)).markedForDeleteAt());
1:2e3727e: 
1:2e3727e:         assertEquals(2, l.searchDeletionTime(clustering(5)).markedForDeleteAt());
1:2e3727e: 
1:2e3727e:         assertEquals(null, l.searchDeletionTime(clustering(7)));
1:2e3727e: 
1:2e3727e:         assertEquals(3, l.searchDeletionTime(clustering(14)).markedForDeleteAt());
1:2e3727e: 
1:2e3727e:         assertEquals(6, l.searchDeletionTime(clustering(15)).markedForDeleteAt());
1:2e3727e:         assertEquals(6, l.searchDeletionTime(clustering(1000)).markedForDeleteAt());
1:2e3727e:     }
1:2e3727e: 
1:6e81f81:     private static void assertRT(RangeTombstone expected, RangeTombstone actual)
1:5bd37b9:     {
1:a991b64:         assertTrue(String.format("%s != %s", toString(expected), toString(actual)), cmp.compare(expected.deletedSlice().start(), actual.deletedSlice().start()) == 0);
1:a991b64:         assertTrue(String.format("%s != %s", toString(expected), toString(actual)), cmp.compare(expected.deletedSlice().end(), actual.deletedSlice().end()) == 0);
1:a991b64:         assertEquals(String.format("%s != %s", toString(expected), toString(actual)), expected.deletionTime(), actual.deletionTime());
1:5bd37b9:     }
1:7895273: 
1:7895273:     private static void assertValid(RangeTombstoneList l)
1:7895273:     {
1:a991b64:         if (l.isEmpty())
1:a991b64:             return;
1:a991b64: 
1:a991b64:         // We check that ranges are in the right order and non overlapping
1:a991b64:         Iterator<RangeTombstone> iter = l.iterator();
1:a991b64:         Slice prev = iter.next().deletedSlice();
1:a991b64:         assertFalse("Invalid empty slice " + prev.toString(cmp), prev.isEmpty(cmp));
1:a991b64: 
1:a991b64:         while (iter.hasNext())
1:7895273:         {
1:a991b64:             Slice curr = iter.next().deletedSlice();
1:7895273: 
1:a991b64:             assertFalse("Invalid empty slice " + curr.toString(cmp), curr.isEmpty(cmp));
1:7813dee:             assertTrue("Slice not in order or overlapping : " + prev.toString(cmp) + curr.toString(cmp), cmp.compare(prev.end(), curr.start()) <= 0);
1:7895273:         }
1:7895273:     }
1:7895273: 
1:6e81f81:     private static String toString(RangeTombstone rt)
1:5bd37b9:     {
1:a991b64:         return String.format("%s@%d", rt.deletedSlice().toString(cmp), rt.deletionTime().markedForDeleteAt());
1:5bd37b9:     }
1:7895273: 
1:7895273:     private static String toString(RangeTombstoneList l)
1:7895273:     {
1:e338d2f:         String[] ranges = new String[l.size()];
1:e338d2f:         int i = 0;
2:7895273:         for (RangeTombstone rt : l)
1:e338d2f:             ranges[i++] = toString(rt);
1:e338d2f: 
1:e338d2f:         return "{ " + Joiner.on(" - ").join(ranges) + " }";
1:7895273:     }
1:7895273: 
1:e338d2f:     private static RangeTombstone rangeFromString(String range)
1:e338d2f:     {
1:e338d2f:         Matcher matcher = Pattern.compile("([\\[(])(\\d+), (\\d+)([)\\]])@(\\d+)").matcher(range.trim());
1:e338d2f:         matcher.matches();
1:e338d2f:         boolean isOpenInclusive = matcher.group(1).equals("[");
1:e338d2f:         int start = Integer.valueOf(matcher.group(2));
1:e338d2f:         int end = Integer.valueOf(matcher.group(3));
1:e338d2f:         boolean isCloseInclusive = matcher.group(4).equals("]");
1:e338d2f:         long timestamp = Long.valueOf(matcher.group(5));
1:e338d2f:         return rt(start, isOpenInclusive, end, isCloseInclusive, timestamp);
1:e338d2f:     }
1:e338d2f: 
1:e338d2f:     private static RangeTombstoneList fromString(String str)
1:e338d2f:     {
1:e338d2f:         str = str.trim();
1:e338d2f:         String[] ranges = str.substring(1, str.length() - 1).split("-", 0);
1:e338d2f:         RangeTombstoneList l = new RangeTombstoneList(cmp, ranges.length);
1:e338d2f:         for (String range : ranges)
1:e338d2f:             l.add(rangeFromString(range));
1:e338d2f:         return l;
1:e338d2f:     }
1:e338d2f: 
1:e338d2f: 
1:a991b64:     private static Clustering clustering(int i)
1:5bd37b9:     {
1:2f41243:         return Clustering.make(bb(i));
1:5bd37b9:     }
1:5bd37b9: 
1:a991b64:     private static ByteBuffer bb(int i)
1:a991b64:     {
1:a991b64:         return ByteBufferUtil.bytes(i);
1:a991b64:     }
1:a991b64: 
1:6e81f81:     private static RangeTombstone rt(int start, int end, long tstamp)
1:5bd37b9:     {
1:6e81f81:         return rt(start, end, tstamp, 0);
1:5bd37b9:     }
1:5bd37b9: 
1:7813dee:     private static RangeTombstone rt(int start, boolean startInclusive, int end, boolean endInclusive, long tstamp)
1:7813dee:     {
1:2cc26eb:         return new RangeTombstone(Slice.make(ClusteringBound.create(cmp, true, startInclusive, start), ClusteringBound.create(cmp, false, endInclusive, end)), new DeletionTime(tstamp, 0));
1:7813dee:     }
1:7813dee: 
1:6e81f81:     private static RangeTombstone rt(int start, int end, long tstamp, int delTime)
1:5bd37b9:     {
1:2cc26eb:         return new RangeTombstone(Slice.make(ClusteringBound.inclusiveStartOf(bb(start)), ClusteringBound.inclusiveEndOf(bb(end))), new DeletionTime(tstamp, delTime));
1:a991b64:     }
1:a991b64: 
1:a991b64:     private static RangeTombstone rtei(int start, int end, long tstamp)
1:a991b64:     {
1:a991b64:         return rtei(start, end, tstamp, 0);
1:a991b64:     }
1:a991b64: 
1:a991b64:     private static RangeTombstone rtei(int start, int end, long tstamp, int delTime)
1:a991b64:     {
1:2cc26eb:         return new RangeTombstone(Slice.make(ClusteringBound.exclusiveStartOf(bb(start)), ClusteringBound.inclusiveEndOf(bb(end))), new DeletionTime(tstamp, delTime));
1:a991b64:     }
1:a991b64: 
1:a991b64:     private static RangeTombstone rtie(int start, int end, long tstamp)
1:a991b64:     {
1:a991b64:         return rtie(start, end, tstamp, 0);
1:a991b64:     }
1:a991b64: 
1:a991b64:     private static RangeTombstone rtie(int start, int end, long tstamp, int delTime)
1:a991b64:     {
1:2cc26eb:         return new RangeTombstone(Slice.make(ClusteringBound.inclusiveStartOf(bb(start)), ClusteringBound.exclusiveEndOf(bb(end))), new DeletionTime(tstamp, delTime));
1:5bd37b9:     }
1:5bd37b9: 
1:2e3727e:     private static RangeTombstone atLeast(int start, long tstamp, int delTime)
1:2e3727e:     {
1:2cc26eb:         return new RangeTombstone(Slice.make(ClusteringBound.inclusiveStartOf(bb(start)), ClusteringBound.TOP), new DeletionTime(tstamp, delTime));
1:2e3727e:     }
1:2e3727e: 
1:2e3727e:     private static RangeTombstone atMost(int end, long tstamp, int delTime)
1:2e3727e:     {
1:2cc26eb:         return new RangeTombstone(Slice.make(ClusteringBound.BOTTOM, ClusteringBound.inclusiveEndOf(bb(end))), new DeletionTime(tstamp, delTime));
1:2e3727e:     }
1:2e3727e: 
1:2e3727e:     private static RangeTombstone lessThan(int end, long tstamp, int delTime)
1:2e3727e:     {
1:2cc26eb:         return new RangeTombstone(Slice.make(ClusteringBound.BOTTOM, ClusteringBound.exclusiveEndOf(bb(end))), new DeletionTime(tstamp, delTime));
1:2e3727e:     }
1:2e3727e: 
1:2e3727e:     private static RangeTombstone greaterThan(int start, long tstamp, int delTime)
1:2e3727e:     {
1:2cc26eb:         return new RangeTombstone(Slice.make(ClusteringBound.exclusiveStartOf(bb(start)), ClusteringBound.TOP), new DeletionTime(tstamp, delTime));
1:2e3727e:     }
1:5bd37b9: }
============================================================================
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:2cc26eb
/////////////////////////////////////////////////////////////////////////
1:         return new RangeTombstone(Slice.make(ClusteringBound.create(cmp, true, startInclusive, start), ClusteringBound.create(cmp, false, endInclusive, end)), new DeletionTime(tstamp, 0));
1:         return new RangeTombstone(Slice.make(ClusteringBound.inclusiveStartOf(bb(start)), ClusteringBound.inclusiveEndOf(bb(end))), new DeletionTime(tstamp, delTime));
/////////////////////////////////////////////////////////////////////////
1:         return new RangeTombstone(Slice.make(ClusteringBound.exclusiveStartOf(bb(start)), ClusteringBound.inclusiveEndOf(bb(end))), new DeletionTime(tstamp, delTime));
/////////////////////////////////////////////////////////////////////////
1:         return new RangeTombstone(Slice.make(ClusteringBound.inclusiveStartOf(bb(start)), ClusteringBound.exclusiveEndOf(bb(end))), new DeletionTime(tstamp, delTime));
1:         return new RangeTombstone(Slice.make(ClusteringBound.inclusiveStartOf(bb(start)), ClusteringBound.TOP), new DeletionTime(tstamp, delTime));
1:         return new RangeTombstone(Slice.make(ClusteringBound.BOTTOM, ClusteringBound.inclusiveEndOf(bb(end))), new DeletionTime(tstamp, delTime));
1:         return new RangeTombstone(Slice.make(ClusteringBound.BOTTOM, ClusteringBound.exclusiveEndOf(bb(end))), new DeletionTime(tstamp, delTime));
1:         return new RangeTombstone(Slice.make(ClusteringBound.exclusiveStartOf(bb(start)), ClusteringBound.TOP), new DeletionTime(tstamp, delTime));
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:2f41243
/////////////////////////////////////////////////////////////////////////
1:         return Clustering.make(bb(i));
author:blerer
-------------------------------------------------------------------------------
commit:2e3727e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void nonSortedAdditionTestWithOneTombstoneWithEmptyEnd()
1:     {
1:         nonSortedAdditionTestWithOneRangeWithEmptyEnd(0);
1:         nonSortedAdditionTestWithOneRangeWithEmptyEnd(10);
1:     }
1: 
1:   private static void nonSortedAdditionTestWithOneRangeWithEmptyEnd(int initialCapacity)
1:     {
1:         RangeTombstoneList l = new RangeTombstoneList(cmp, initialCapacity);
1:         RangeTombstone rt1 = rt(1, 5, 3);
1:         RangeTombstone rt2 = rt(7, 10, 2);
1:         RangeTombstone rt3 = atLeast(11, 1, 0);
1: 
1:         l.add(rt2);
1:         l.add(rt3);
1:         l.add(rt1);
1: 
1:         Iterator<RangeTombstone> iter = l.iterator();
1:         assertRT(rt1, iter.next());
1:         assertRT(rt2, iter.next());
1:         assertRT(rt3, iter.next());
1: 
1:         assert !iter.hasNext();
1:     }
1: 
1:     @Test
1:     public void addRangeWithEmptyEndWitchIncludeExistingRange()
1:     {
1: 
1:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
1: 
1:         l.add(rt(4, 10, 3));
1:         l.add(atLeast(3, 4, 0));
1: 
1:         Iterator<RangeTombstone> iter = l.iterator();
1:         assertRT(atLeast(3, 4, 0), iter.next());
1:         assertFalse(iter.hasNext());
1:     }
1: 
1:     @Test
1:     public void addRangeWithEmptyStartAndEnd()
1:     {
1: 
1:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
1: 
1:         l.add(rt(4, 10, 3));
1:         l.add(atMost(12, 4, 0));
1: 
1:         Iterator<RangeTombstone> iter = l.iterator();
1:         assertRT(atMost(12, 4, 0), iter.next());
1:         assertFalse(iter.hasNext());
1:     }
1: 
1:     @Test
1:     public void addRangeWithEmptyEndToRangeWithEmptyStartAndEnd()
1:     {
1: 
1:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
1: 
1:         l.add(new RangeTombstone(Slice.ALL, new DeletionTime(2, 0)));
1:         l.add(atLeast(12, 4, 0));
1: 
1:         Iterator<RangeTombstone> iter = l.iterator();
1:         assertRT(lessThan(12, 2, 0), iter.next());
1:         assertRT(atLeast(12, 4, 0), iter.next());
1:         assertFalse(iter.hasNext());
1:     }
1: 
1:     @Test
1:     public void addRangeWithEmptyEndWitchIncludeExistingRangeWithEmptyEnd()
1:     {
1: 
1:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
1: 
1:         l.add(atLeast(5, 3, 0));
1:         l.add(atLeast(3, 4, 0));
1: 
1:         Iterator<RangeTombstone> iter = l.iterator();
1:         assertRT(atLeast(3, 4, 0), iter.next());
1:         assertFalse(iter.hasNext());
1:     }
1: 
1:     @Test
1:     public void addIncludedRangeToRangeWithEmptyEnd()
1:     {
1: 
1:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
1: 
1:         l.add(atLeast(3, 3, 0));
1:         l.add(rt(4, 10, 4));
1: 
1:         Iterator<RangeTombstone> iter = l.iterator();
1:         assertRT(rtie(3, 4, 3), iter.next());
1:         assertRT(rt(4, 10, 4), iter.next());
1:         assertRT(greaterThan(10, 3, 0), iter.next());
1:         assertFalse(iter.hasNext());
1:     }
1: 
1:     @Test
1:     public void addIncludedRangeWithEmptyEndToRangeWithEmptyEnd()
1:     {
1: 
1:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
1: 
1:         l.add(atLeast(3, 3, 0));
1:         l.add(atLeast(5, 4, 0));
1: 
1:         Iterator<RangeTombstone> iter = l.iterator();
1:         assertRT(rtie(3, 5, 3), iter.next());
1:         assertRT(atLeast(5, 4, 0), iter.next());
1:         assertFalse(iter.hasNext());
1:     }
1: 
1:     @Test
1:     public void addRangeWithEmptyEndWitchOverlapExistingRange()
1:     {
1: 
1:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
1: 
1:         l.add(rt(4, 10, 3));
1:         l.add(atLeast(6, 4, 0));
1: 
1:         Iterator<RangeTombstone> iter = l.iterator();
1:         assertRT(rtie(4, 6, 3), iter.next());
1:         assertRT(atLeast(6, 4, 0), iter.next());
1:         assertFalse(iter.hasNext());
1:     }
1: 
1:     @Test
1:     public void addOverlappingRangeToRangeWithEmptyEnd()
1:     {
1: 
1:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
1: 
1:         l.add(atLeast(3, 3, 0));
1:         l.add(rt(1, 10, 4));
1: 
1:         Iterator<RangeTombstone> iter = l.iterator();
1:         assertRT(rt(1, 10, 4), iter.next());
1:         assertRT(greaterThan(10, 3, 0), iter.next());
1:         assertFalse(iter.hasNext());
1:     }
1: 
1:     @Test
1:     public void searchTestWithEmptyStart()
1:     {
1:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
1:         l.add(atMost(4, 5, 0));
1:         l.add(rt(4, 6, 2));
1:         l.add(rt(9, 12, 1));
1:         l.add(rt(14, 15, 3));
1:         l.add(rt(15, 17, 6));
1: 
1:         assertEquals(5, l.searchDeletionTime(clustering(-1)).markedForDeleteAt());
1:         assertEquals(5, l.searchDeletionTime(clustering(0)).markedForDeleteAt());
1:         assertEquals(5, l.searchDeletionTime(clustering(3)).markedForDeleteAt());
1:         assertEquals(5, l.searchDeletionTime(clustering(4)).markedForDeleteAt());
1: 
1:         assertEquals(2, l.searchDeletionTime(clustering(5)).markedForDeleteAt());
1: 
1:         assertEquals(null, l.searchDeletionTime(clustering(7)));
1: 
1:         assertEquals(3, l.searchDeletionTime(clustering(14)).markedForDeleteAt());
1: 
1:         assertEquals(6, l.searchDeletionTime(clustering(15)).markedForDeleteAt());
1:         assertEquals(null, l.searchDeletionTime(clustering(18)));
1:     }
1: 
1:     @Test
1:     public void searchTestWithRangeWithEmptyEnd()
1:     {
1:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
1:         l.add(rt(0, 4, 5));
1:         l.add(rt(4, 6, 2));
1:         l.add(rt(9, 12, 1));
1:         l.add(rt(14, 15, 3));
1:         l.add(atLeast(15, 6, 0));
1: 
1:         assertEquals(null, l.searchDeletionTime(clustering(-1)));
1: 
1:         assertEquals(5, l.searchDeletionTime(clustering(0)).markedForDeleteAt());
1:         assertEquals(5, l.searchDeletionTime(clustering(3)).markedForDeleteAt());
1:         assertEquals(5, l.searchDeletionTime(clustering(4)).markedForDeleteAt());
1: 
1:         assertEquals(2, l.searchDeletionTime(clustering(5)).markedForDeleteAt());
1: 
1:         assertEquals(null, l.searchDeletionTime(clustering(7)));
1: 
1:         assertEquals(3, l.searchDeletionTime(clustering(14)).markedForDeleteAt());
1: 
1:         assertEquals(6, l.searchDeletionTime(clustering(15)).markedForDeleteAt());
1:         assertEquals(6, l.searchDeletionTime(clustering(1000)).markedForDeleteAt());
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     private static RangeTombstone atLeast(int start, long tstamp, int delTime)
1:     {
0:         return new RangeTombstone(Slice.make(Slice.Bound.inclusiveStartOf(bb(start)), Slice.Bound.TOP), new DeletionTime(tstamp, delTime));
1:     }
1: 
1:     private static RangeTombstone atMost(int end, long tstamp, int delTime)
1:     {
0:         return new RangeTombstone(Slice.make(Slice.Bound.BOTTOM, Slice.Bound.inclusiveEndOf(bb(end))), new DeletionTime(tstamp, delTime));
1:     }
1: 
1:     private static RangeTombstone lessThan(int end, long tstamp, int delTime)
1:     {
0:         return new RangeTombstone(Slice.make(Slice.Bound.BOTTOM, Slice.Bound.exclusiveEndOf(bb(end))), new DeletionTime(tstamp, delTime));
1:     }
1: 
1:     private static RangeTombstone greaterThan(int start, long tstamp, int delTime)
1:     {
0:         return new RangeTombstone(Slice.make(Slice.Bound.exclusiveStartOf(bb(start)), Slice.Bound.TOP), new DeletionTime(tstamp, delTime));
1:     }
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:e338d2f
/////////////////////////////////////////////////////////////////////////
1: import java.util.regex.Pattern;
1: import java.util.regex.Matcher;
1: 
1: import com.google.common.base.Joiner;
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void addAllBugFrom9799()
1:     {
1:         RangeTombstoneList l1 = fromString("{ (6, 7]@4 - (7, 8)@1 - [12, 12]@0 - [13, 13]@0 - (20, 21)@3 - [27, 27]@2 - (33, 34)@2 - (35, 36]@4 - (40, 41]@0 - (42, 43)@2 - (44, 45)@3 - [47, 47]@1 - (47, 48)@0 - [55, 55]@4 - [61, 61]@4 - [67, 67]@0 - [70, 70]@4 - [77, 77]@1 - (83, 84)@1 - [90, 90]@0 - (91, 92]@4 - [93, 93]@0 - (94, 95)@2 - (100, 101]@3 - (103, 104]@0 - (108, 109]@2 - (115, 116]@3 - (116, 117]@3 - (118, 119)@4 - (125, 126)@2 - [131, 131]@1 - [132, 132]@3 - [139, 139]@0 - [145, 145]@1 - (145, 146]@3 - (147, 148]@4 - (150, 151]@1 - (156, 157)@2 - (158, 159)@2 - [164, 164]@4 - (168, 169)@0 - (171, 172)@4 - (173, 174]@0 - [179, 179]@1 - (186, 187]@4 - [191, 191]@1 }");
1:         RangeTombstoneList l2 = fromString("{ (1, 12)@8 - [12, 13)@8 - [13, 18]@7 }");
1:         l1.addAll(l2);
1:         assertValid(l1);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         String[] ranges = new String[l.size()];
1:         int i = 0;
1:             ranges[i++] = toString(rt);
1: 
1:         return "{ " + Joiner.on(" - ").join(ranges) + " }";
1:     private static RangeTombstone rangeFromString(String range)
1:     {
1:         Matcher matcher = Pattern.compile("([\\[(])(\\d+), (\\d+)([)\\]])@(\\d+)").matcher(range.trim());
1:         matcher.matches();
1:         boolean isOpenInclusive = matcher.group(1).equals("[");
1:         int start = Integer.valueOf(matcher.group(2));
1:         int end = Integer.valueOf(matcher.group(3));
1:         boolean isCloseInclusive = matcher.group(4).equals("]");
1:         long timestamp = Long.valueOf(matcher.group(5));
1:         return rt(start, isOpenInclusive, end, isCloseInclusive, timestamp);
1:     }
1: 
1:     private static RangeTombstoneList fromString(String str)
1:     {
1:         str = str.trim();
1:         String[] ranges = str.substring(1, str.length() - 1).split("-", 0);
1:         RangeTombstoneList l = new RangeTombstoneList(cmp, ranges.length);
1:         for (String range : ranges)
1:             l.add(rangeFromString(range));
1:         return l;
1:     }
1: 
1: 
commit:2457599
/////////////////////////////////////////////////////////////////////////
0:         return new Clustering(bb(i));
/////////////////////////////////////////////////////////////////////////
0:         return new RangeTombstone(Slice.make(Slice.Bound.create(cmp, true, startInclusive, start), Slice.Bound.create(cmp, false, endInclusive, end)), new DeletionTime(tstamp, 0));
0:         return new RangeTombstone(Slice.make(Slice.Bound.inclusiveStartOf(bb(start)), Slice.Bound.inclusiveEndOf(bb(end))), new DeletionTime(tstamp, delTime));
/////////////////////////////////////////////////////////////////////////
0:         return new RangeTombstone(Slice.make(Slice.Bound.exclusiveStartOf(bb(start)), Slice.Bound.inclusiveEndOf(bb(end))), new DeletionTime(tstamp, delTime));
/////////////////////////////////////////////////////////////////////////
0:         return new RangeTombstone(Slice.make(Slice.Bound.inclusiveStartOf(bb(start)), Slice.Bound.exclusiveEndOf(bb(end))), new DeletionTime(tstamp, delTime));
commit:7813dee
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.marshal.Int32Type;
1:     private static final ClusteringComparator cmp = new ClusteringComparator(Int32Type.instance);
/////////////////////////////////////////////////////////////////////////
1:         boolean prevStartInclusive = false;
1:         boolean prevEndInclusive = false;
1:             boolean startInclusive = rand.nextBoolean();
1:             boolean endInclusive = rand.nextBoolean();
1:             // Now make sure we create meaningful ranges
1: 
1:             if (prevEnd == nextStart)
1:                 startInclusive = !prevEndInclusive;
1: 
1:             if (nextStart == nextEnd)
1:             {
1:                 if (startInclusive)
1:                     endInclusive = true;
1:                 else
1:                     nextEnd += 1;
1:             }
1: 
1:             l.add(rt(nextStart, startInclusive, nextEnd, endInclusive, rand.nextInt(maxMarkedAt)));
1:             prevStartInclusive = startInclusive;
1:             prevEndInclusive = endInclusive;
/////////////////////////////////////////////////////////////////////////
1:             assertTrue("Slice not in order or overlapping : " + prev.toString(cmp) + curr.toString(cmp), cmp.compare(prev.end(), curr.start()) <= 0);
/////////////////////////////////////////////////////////////////////////
1:     private static RangeTombstone rt(int start, boolean startInclusive, int end, boolean endInclusive, long tstamp)
1:     {
0:         return new RangeTombstone(Slice.make(Slice.Bound.create(cmp, true, startInclusive, start), Slice.Bound.create(cmp, false, endInclusive, end)), new SimpleDeletionTime(tstamp, 0));
1:     }
1: 
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: import java.nio.ByteBuffer;
0: import org.apache.cassandra.db.*;
0:     private static final ClusteringComparator cmp = new ClusteringComparator(IntegerType.instance);
/////////////////////////////////////////////////////////////////////////
1:         assertRT(rtei(10, 13, 1), iter.next());
/////////////////////////////////////////////////////////////////////////
1:         assertRT(rtei(10, 13, 1), iter.next());
/////////////////////////////////////////////////////////////////////////
1:         assertRT(rtie(0, 1, 1), iter.next());
1:         assertRT(rtie(1, 4, 2), iter.next());
1:         assertRT(rtie(4, 8, 3), iter.next());
1:         assertRT(rtei(13, 15, 1), iter.next());
1:         assertEquals(25L, l2.searchDeletionTime(clustering(8)).markedForDeleteAt());
/////////////////////////////////////////////////////////////////////////
1:         assertRT(rtie(0, 3, 3), iter1.next());
1:         assertRT(rtei(7, 10, 3), iter1.next());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(2, l.searchDeletionTime(clustering(3)).markedForDeleteAt());
1:         assertEquals(5, l.searchDeletionTime(clustering(4)).markedForDeleteAt());
1:         assertEquals(5, l.searchDeletionTime(clustering(8)).markedForDeleteAt());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(null, l.searchDeletionTime(clustering(-1)));
1:         assertEquals(5, l.searchDeletionTime(clustering(0)).markedForDeleteAt());
1:         assertEquals(5, l.searchDeletionTime(clustering(3)).markedForDeleteAt());
1:         assertEquals(5, l.searchDeletionTime(clustering(4)).markedForDeleteAt());
1:         assertEquals(2, l.searchDeletionTime(clustering(5)).markedForDeleteAt());
1:         assertEquals(null, l.searchDeletionTime(clustering(7)));
1:         assertEquals(3, l.searchDeletionTime(clustering(14)).markedForDeleteAt());
1:         assertEquals(6, l.searchDeletionTime(clustering(15)).markedForDeleteAt());
1:         assertEquals(null, l.searchDeletionTime(clustering(18)));
/////////////////////////////////////////////////////////////////////////
1:         assertRT(rtie(0, 3, 5), iter.next());
1:         assertRT(rt(3, 5, 7), iter.next());
1:         assertRT(rtie(6, 7, 2), iter.next());
1:         assertRT(rtei(8, 10, 2), iter.next());
1:         assertRT(rtei(10, 12, 1), iter.next());
/////////////////////////////////////////////////////////////////////////
1:         assertRT(rtie(3, 5, 2), iter.next());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         assertTrue(String.format("%s != %s", toString(expected), toString(actual)), cmp.compare(expected.deletedSlice().start(), actual.deletedSlice().start()) == 0);
1:         assertTrue(String.format("%s != %s", toString(expected), toString(actual)), cmp.compare(expected.deletedSlice().end(), actual.deletedSlice().end()) == 0);
1:         assertEquals(String.format("%s != %s", toString(expected), toString(actual)), expected.deletionTime(), actual.deletionTime());
1:         if (l.isEmpty())
1:             return;
1: 
1:         // We check that ranges are in the right order and non overlapping
1:         Iterator<RangeTombstone> iter = l.iterator();
1:         Slice prev = iter.next().deletedSlice();
1:         assertFalse("Invalid empty slice " + prev.toString(cmp), prev.isEmpty(cmp));
1: 
1:         while (iter.hasNext())
1:             Slice curr = iter.next().deletedSlice();
1:             assertFalse("Invalid empty slice " + curr.toString(cmp), curr.isEmpty(cmp));
0:             assertTrue("Slice not in order or overlapping : " + prev.toString(cmp) + curr.toString(cmp), cmp.compare(prev.end(), curr.start()) < 0);
1:         return String.format("%s@%d", rt.deletedSlice().toString(cmp), rt.deletionTime().markedForDeleteAt());
/////////////////////////////////////////////////////////////////////////
1:     private static Clustering clustering(int i)
0:         return new SimpleClustering(bb(i));
1:     private static ByteBuffer bb(int i)
1:         return ByteBufferUtil.bytes(i);
1:     }
1: 
0:     private static int i(Slice.Bound bound)
1:     {
0:         return ByteBufferUtil.toInt(bound.get(0));
/////////////////////////////////////////////////////////////////////////
0:         return new RangeTombstone(Slice.make(Slice.Bound.inclusiveStartOf(bb(start)), Slice.Bound.inclusiveEndOf(bb(end))), new SimpleDeletionTime(tstamp, delTime));
1:     }
1: 
1:     private static RangeTombstone rtei(int start, int end, long tstamp)
1:     {
1:         return rtei(start, end, tstamp, 0);
1:     }
1: 
1:     private static RangeTombstone rtei(int start, int end, long tstamp, int delTime)
1:     {
0:         return new RangeTombstone(Slice.make(Slice.Bound.exclusiveStartOf(bb(start)), Slice.Bound.inclusiveEndOf(bb(end))), new SimpleDeletionTime(tstamp, delTime));
1:     }
1: 
1:     private static RangeTombstone rtie(int start, int end, long tstamp)
1:     {
1:         return rtie(start, end, tstamp, 0);
1:     }
1: 
1:     private static RangeTombstone rtie(int start, int end, long tstamp, int delTime)
1:     {
0:         return new RangeTombstone(Slice.make(Slice.Bound.inclusiveStartOf(bb(start)), Slice.Bound.exclusiveEndOf(bb(end))), new SimpleDeletionTime(tstamp, delTime));
commit:e1a67a4
commit:7895273
/////////////////////////////////////////////////////////////////////////
0:     private static final Random rand = new Random();
/////////////////////////////////////////////////////////////////////////
0:     private RangeTombstoneList makeRandom(int size, int maxItSize, int maxItDistance, int maxMarkedAt)
1:     {
1:         RangeTombstoneList l = new RangeTombstoneList(cmp, size);
1: 
1:         int prevStart = -1;
1:         int prevEnd = 0;
1:         for (int i = 0; i < size; i++)
1:         {
1:             int nextStart = prevEnd + rand.nextInt(maxItDistance);
1:             int nextEnd = nextStart + rand.nextInt(maxItSize);
1: 
0:             // We can have an interval [x, x], but not 2 consecutives ones for the same x
0:             if (nextEnd == nextStart && prevEnd == prevStart && prevEnd == nextStart)
0:                 nextEnd += 1 + rand.nextInt(maxItDistance);
1: 
0:             l.add(rt(nextStart, nextEnd, rand.nextInt(maxMarkedAt)));
1: 
1:             prevStart = nextStart;
1:             prevEnd = nextEnd;
1:         }
1:         return l;
1:     }
1: 
1:     @Test
1:     public void addAllRandomTest() throws Throwable
1:     {
1:         int TEST_COUNT = 1000;
1:         int MAX_LIST_SIZE = 50;
1: 
1:         int MAX_IT_SIZE = 20;
1:         int MAX_IT_DISTANCE = 10;
1:         int MAX_MARKEDAT = 10;
1: 
1:         for (int i = 0; i < TEST_COUNT; i++)
1:         {
0:             RangeTombstoneList l1 = makeRandom(rand.nextInt(MAX_LIST_SIZE) + 1, rand.nextInt(MAX_IT_SIZE) + 1, rand.nextInt(MAX_IT_DISTANCE) + 1, rand.nextInt(MAX_MARKEDAT) + 1);
0:             RangeTombstoneList l2 = makeRandom(rand.nextInt(MAX_LIST_SIZE) + 1, rand.nextInt(MAX_IT_SIZE) + 1, rand.nextInt(MAX_IT_DISTANCE) + 1, rand.nextInt(MAX_MARKEDAT) + 1);
1: 
1:             RangeTombstoneList l1Initial = l1.copy();
1: 
1:             try
1:             {
1:                 // We generate the list randomly, so "all" we check is that the resulting range tombstone list looks valid.
1:                 l1.addAll(l2);
1:                 assertValid(l1);
1:             }
1:             catch (Throwable e)
1:             {
1:                 System.out.println("Error merging:");
1:                 System.out.println(" l1: " + toString(l1Initial));
1:                 System.out.println(" l2: " + toString(l2));
1:                 throw e;
1:             }
1:         }
1:     }
1: 
1:     private static void assertValid(RangeTombstoneList l)
1:     {
0:         // We check that ranges are in the right order and that we never have something
0:         // like ...[x, x][x, x] ...
0:         int prevStart = -2;
0:         int prevEnd = -1;
1:         for (RangeTombstone rt : l)
1:         {
0:             int curStart = i(rt.min);
0:             int curEnd = i(rt.max);
1: 
0:             assertTrue("Invalid " + toString(l), prevEnd <= curStart);
0:             assertTrue("Invalid " + toString(l), curStart <= curEnd);
1: 
0:             if (curStart == curEnd && prevEnd == curStart)
0:                 assertTrue("Invalid " + toString(l), prevStart != prevEnd);
1: 
0:             prevStart = curStart;
0:             prevEnd = curEnd;
1:         }
1:     }
1: 
1:     private static String toString(RangeTombstoneList l)
1:     {
0:         StringBuilder sb = new StringBuilder();
0:         sb.append("{");
1:         for (RangeTombstone rt : l)
0:             sb.append(" ").append(toString(rt));
0:         return sb.append(" }").toString();
1:     }
1: 
commit:5bd37b9
/////////////////////////////////////////////////////////////////////////
0:     private static final Random rand = new Random();
/////////////////////////////////////////////////////////////////////////
0:     private RangeTombstoneList makeRandom(int size, int maxItSize, int maxItDistance, int maxMarkedAt)
1:     {
0:         RangeTombstoneList l = new RangeTombstoneList(cmp, size);
1: 
0:         int prevStart = -1;
0:         int prevEnd = 0;
0:         for (int i = 0; i < size; i++)
1:         {
0:             int nextStart = prevEnd + rand.nextInt(maxItDistance);
0:             int nextEnd = nextStart + rand.nextInt(maxItSize);
1: 
0:             // We can have an interval [x, x], but not 2 consecutives ones for the same x
0:             if (nextEnd == nextStart && prevEnd == prevStart && prevEnd == nextStart)
0:                 nextEnd += 1 + rand.nextInt(maxItDistance);
1: 
0:             l.add(rt(nextStart, nextEnd, rand.nextInt(maxMarkedAt)));
1: 
0:             prevStart = nextStart;
0:             prevEnd = nextEnd;
1:         }
0:         return l;
1:     }
1: 
1:     @Test
0:     public void addAllRandomTest() throws Throwable
1:     {
0:         int TEST_COUNT = 1000;
0:         int MAX_LIST_SIZE = 50;
1: 
0:         int MAX_IT_SIZE = 20;
0:         int MAX_IT_DISTANCE = 10;
0:         int MAX_MARKEDAT = 10;
1: 
0:         for (int i = 0; i < TEST_COUNT; i++)
1:         {
0:             RangeTombstoneList l1 = makeRandom(rand.nextInt(MAX_LIST_SIZE) + 1, rand.nextInt(MAX_IT_SIZE) + 1, rand.nextInt(MAX_IT_DISTANCE) + 1, rand.nextInt(MAX_MARKEDAT) + 1);
0:             RangeTombstoneList l2 = makeRandom(rand.nextInt(MAX_LIST_SIZE) + 1, rand.nextInt(MAX_IT_SIZE) + 1, rand.nextInt(MAX_IT_DISTANCE) + 1, rand.nextInt(MAX_MARKEDAT) + 1);
1: 
0:             RangeTombstoneList l1Initial = l1.copy();
1: 
0:             try
1:             {
0:                 // We generate the list randomly, so "all" we check is that the resulting range tombstone list looks valid.
1:                 l1.addAll(l2);
0:                 assertValid(l1);
1:             }
0:             catch (Throwable e)
1:             {
0:                 System.out.println("Error merging:");
0:                 System.out.println(" l1: " + toString(l1Initial));
0:                 System.out.println(" l2: " + toString(l2));
0:                 throw e;
1:             }
1:         }
1:     }
1: 
0:     private static void assertValid(RangeTombstoneList l)
1:     {
0:         // We check that ranges are in the right order and that we never have something
0:         // like ...[x, x][x, x] ...
0:         int prevStart = -2;
0:         int prevEnd = -1;
0:         for (RangeTombstone rt : l)
1:         {
0:             int curStart = i(rt.min);
0:             int curEnd = i(rt.max);
1: 
0:             assertTrue("Invalid " + toString(l), prevEnd <= curStart);
0:             assertTrue("Invalid " + toString(l), curStart <= curEnd);
1: 
0:             if (curStart == curEnd && prevEnd == curStart)
0:                 assertTrue("Invalid " + toString(l), prevStart != prevEnd);
1: 
0:             prevStart = curStart;
0:             prevEnd = curEnd;
1:         }
1:     }
1: 
0:     private static String toString(RangeTombstoneList l)
1:     {
0:         StringBuilder sb = new StringBuilder();
0:         sb.append("{");
0:         for (RangeTombstone rt : l)
0:             sb.append(" ").append(toString(rt));
0:         return sb.append(" }").toString();
1:     }
1: 
commit:74258e2
/////////////////////////////////////////////////////////////////////////
0:         assertEquals(25L, l2.searchDeletionTime(b(8)).markedForDeleteAt);
/////////////////////////////////////////////////////////////////////////
0:         assertEquals(2, l.searchDeletionTime(b(3)).markedForDeleteAt);
0:         assertEquals(5, l.searchDeletionTime(b(4)).markedForDeleteAt);
0:         assertEquals(5, l.searchDeletionTime(b(8)).markedForDeleteAt);
/////////////////////////////////////////////////////////////////////////
0:         assertEquals(null, l.searchDeletionTime(b(-1)));
0:         assertEquals(5, l.searchDeletionTime(b(0)).markedForDeleteAt);
0:         assertEquals(5, l.searchDeletionTime(b(3)).markedForDeleteAt);
0:         assertEquals(5, l.searchDeletionTime(b(4)).markedForDeleteAt);
0:         assertEquals(2, l.searchDeletionTime(b(5)).markedForDeleteAt);
0:         assertEquals(null, l.searchDeletionTime(b(7)));
0:         assertEquals(3, l.searchDeletionTime(b(14)).markedForDeleteAt);
0:         assertEquals(6, l.searchDeletionTime(b(15)).markedForDeleteAt);
0:         assertEquals(null, l.searchDeletionTime(b(18)));
commit:362cc05
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.Util;
0: import org.apache.cassandra.db.*;
0: import org.apache.cassandra.db.composites.*;
0:     private static final Comparator<Composite> cmp = new SimpleDenseCellNameType(IntegerType.instance);
/////////////////////////////////////////////////////////////////////////
0:     private static Composite b(int i)
0:         return Util.cellname(i);
0:     private static int i(Composite c)
0:         return ByteBufferUtil.toInt(c.toByteBuffer());
commit:4768daa
/////////////////////////////////////////////////////////////////////////
1:         assertRT(rt(8, 13, 4), iter.next());
/////////////////////////////////////////////////////////////////////////
1:     public void largeAdditionTest()
1:         int N = 3000;
1:         // Test that the StackOverflow from #6181 is fixed
1:         RangeTombstoneList l = new RangeTombstoneList(cmp, N);
1:         for (int i = 0; i < N; i++)
1:             l.add(rt(2*i+1, 2*i+2, 1));
1:         assertEquals(l.size(), N);
1: 
1:         l.add(rt(0, 2*N+3, 2));
/////////////////////////////////////////////////////////////////////////
1:     public void overlappingPreviousEndEqualsStartTest()
1:     {
1:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
1:         // add a RangeTombstone, so, last insert is not in insertion order
1:         l.add(rt(11, 12, 2));
1:         l.add(rt(1, 4, 2));
1:         l.add(rt(4, 10, 5));
1: 
0:         assertEquals(2, l.search(b(3)).markedForDeleteAt);
0:         assertEquals(5, l.search(b(4)).markedForDeleteAt);
0:         assertEquals(5, l.search(b(8)).markedForDeleteAt);
1:         assertEquals(3, l.size());
1:     }
1: 
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:         assertRT(rt(14, 17, 4), iter.next());
commit:f5b224c
/////////////////////////////////////////////////////////////////////////
1:     public void addAllSequentialTest()
1:     {
1:         RangeTombstoneList l1 = new RangeTombstoneList(cmp, 0);
1:         l1.add(rt(3, 5, 2));
1: 
1:         RangeTombstoneList l2 = new RangeTombstoneList(cmp, 0);
1:         l2.add(rt(5, 7, 7));
1: 
1:         l1.addAll(l2);
1: 
1:         Iterator<RangeTombstone> iter = l1.iterator();
0:         assertRT(rt(3, 5, 2), iter.next());
1:         assertRT(rt(5, 7, 7), iter.next());
1: 
1:         assert !iter.hasNext();
1:     }
1: 
1:     @Test
1:     public void addAllIncludedTest()
1:     {
1:         RangeTombstoneList l1 = new RangeTombstoneList(cmp, 0);
1:         l1.add(rt(3, 10, 5));
1: 
1:         RangeTombstoneList l2 = new RangeTombstoneList(cmp, 0);
1:         l2.add(rt(4, 5, 2));
1:         l2.add(rt(5, 7, 3));
1:         l2.add(rt(7, 9, 4));
1: 
1:         l1.addAll(l2);
1: 
1:         Iterator<RangeTombstone> iter = l1.iterator();
1:         assertRT(rt(3, 10, 5), iter.next());
1: 
1:         assert !iter.hasNext();
1:     }
1: 
1:     @Test
commit:6e81f81
/////////////////////////////////////////////////////////////////////////
1: /*
1: * Licensed to the Apache Software Foundation (ASF) under one
1: * or more contributor license agreements.  See the NOTICE file
1: * distributed with this work for additional information
1: * regarding copyright ownership.  The ASF licenses this file
1: * to you under the Apache License, Version 2.0 (the
1: * "License"); you may not use this file except in compliance
1: * with the License.  You may obtain a copy of the License at
1: *
1: *    http://www.apache.org/licenses/LICENSE-2.0
1: *
1: * Unless required by applicable law or agreed to in writing,
1: * software distributed under the License is distributed on an
1: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1: * KIND, either express or implied.  See the License for the
1: * specific language governing permissions and limitations
1: * under the License.
1: */
1: package org.apache.cassandra.db;
1: 
0: import java.nio.ByteBuffer;
1: import java.util.*;
1: 
1: import org.junit.Test;
1: import static org.junit.Assert.*;
1: 
0: import org.apache.cassandra.db.marshal.IntegerType;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: 
1: public class RangeTombstoneListTest
1: {
0:     private static final Comparator<ByteBuffer> cmp = IntegerType.instance;
1: 
1:     @Test
1:     public void sortedAdditionTest()
1:     {
1:         sortedAdditionTest(0);
1:         sortedAdditionTest(10);
1:     }
1: 
1:     private void sortedAdditionTest(int initialCapacity)
1:     {
1:         RangeTombstoneList l = new RangeTombstoneList(cmp, initialCapacity);
1:         RangeTombstone rt1 = rt(1, 5, 3);
1:         RangeTombstone rt2 = rt(7, 10, 2);
1:         RangeTombstone rt3 = rt(10, 13, 1);
1: 
1:         l.add(rt1);
1:         l.add(rt2);
1:         l.add(rt3);
1: 
1:         Iterator<RangeTombstone> iter = l.iterator();
1:         assertRT(rt1, iter.next());
1:         assertRT(rt2, iter.next());
0:         assertRT(rt3, iter.next());
1: 
1:         assert !iter.hasNext();
1:     }
1: 
1:     @Test
1:     public void nonSortedAdditionTest()
1:     {
1:         nonSortedAdditionTest(0);
1:         nonSortedAdditionTest(10);
1:     }
1: 
1:     private void nonSortedAdditionTest(int initialCapacity)
1:     {
1:         RangeTombstoneList l = new RangeTombstoneList(cmp, initialCapacity);
1:         RangeTombstone rt1 = rt(1, 5, 3);
1:         RangeTombstone rt2 = rt(7, 10, 2);
1:         RangeTombstone rt3 = rt(10, 13, 1);
1: 
1:         l.add(rt2);
1:         l.add(rt1);
1:         l.add(rt3);
1: 
1:         Iterator<RangeTombstone> iter = l.iterator();
1:         assertRT(rt1, iter.next());
1:         assertRT(rt2, iter.next());
0:         assertRT(rt3, iter.next());
1: 
1:         assert !iter.hasNext();
1:     }
1: 
1:     @Test
1:     public void overlappingAdditionTest()
1:     {
1:         overlappingAdditionTest(0);
1:         overlappingAdditionTest(10);
1:     }
1: 
1:     private void overlappingAdditionTest(int initialCapacity)
1:     {
1:         RangeTombstoneList l = new RangeTombstoneList(cmp, initialCapacity);
1: 
1:         l.add(rt(4, 10, 3));
1:         l.add(rt(1, 7, 2));
1:         l.add(rt(8, 13, 4));
1:         l.add(rt(0, 15, 1));
1: 
1:         Iterator<RangeTombstone> iter = l.iterator();
0:         assertRT(rt(0, 1, 1), iter.next());
0:         assertRT(rt(1, 4, 2), iter.next());
0:         assertRT(rt(4, 8, 3), iter.next());
0:         assertRT(rt(8, 10, 4), iter.next());
0:         assertRT(rt(10, 13, 4), iter.next());
0:         assertRT(rt(13, 15, 1), iter.next());
1:         assert !iter.hasNext();
1: 
1:         RangeTombstoneList l2 = new RangeTombstoneList(cmp, initialCapacity);
0:         l.add(rt(4, 10, 12L));
0:         l.add(rt(0, 8, 25L));
1: 
0:         assertEquals(25L, l.search(b(8)).markedForDeleteAt);
1:     }
1: 
1:     @Test
0:     public void overlappingSearchTest()
1:     {
1:     }
1: 
1:     @Test
1:     public void simpleOverlapTest()
1:     {
1:         RangeTombstoneList l1 = new RangeTombstoneList(cmp, 0);
1:         l1.add(rt(0, 10, 3));
1:         l1.add(rt(3, 7, 5));
1: 
1:         Iterator<RangeTombstone> iter1 = l1.iterator();
0:         assertRT(rt(0, 3, 3), iter1.next());
1:         assertRT(rt(3, 7, 5), iter1.next());
0:         assertRT(rt(7, 10, 3), iter1.next());
1:         assert !iter1.hasNext();
1: 
1:         RangeTombstoneList l2 = new RangeTombstoneList(cmp, 0);
1:         l2.add(rt(0, 10, 3));
1:         l2.add(rt(3, 7, 2));
1: 
1:         Iterator<RangeTombstone> iter2 = l2.iterator();
1:         assertRT(rt(0, 10, 3), iter2.next());
1:         assert !iter2.hasNext();
1:     }
1: 
1:     @Test
1:     public void searchTest()
1:     {
1:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
1:         l.add(rt(0, 4, 5));
1:         l.add(rt(4, 6, 2));
1:         l.add(rt(9, 12, 1));
1:         l.add(rt(14, 15, 3));
1:         l.add(rt(15, 17, 6));
1: 
0:         assertEquals(null, l.search(b(-1)));
1: 
0:         assertEquals(5, l.search(b(0)).markedForDeleteAt);
0:         assertEquals(5, l.search(b(3)).markedForDeleteAt);
0:         assertEquals(5, l.search(b(4)).markedForDeleteAt);
1: 
0:         assertEquals(2, l.search(b(5)).markedForDeleteAt);
1: 
0:         assertEquals(null, l.search(b(7)));
1: 
0:         assertEquals(3, l.search(b(14)).markedForDeleteAt);
1: 
0:         assertEquals(6, l.search(b(15)).markedForDeleteAt);
0:         assertEquals(null, l.search(b(18)));
1:     }
1: 
1:     @Test
1:     public void addAllTest()
1:     {
0:         //addAllTest(false);
0:         addAllTest(true);
1:     }
1: 
0:     private void addAllTest(boolean doMerge)
1:     {
1:         RangeTombstoneList l1 = new RangeTombstoneList(cmp, 0);
1:         l1.add(rt(0, 4, 5));
1:         l1.add(rt(6, 10, 2));
1:         l1.add(rt(15, 17, 1));
1: 
1:         RangeTombstoneList l2 = new RangeTombstoneList(cmp, 0);
1:         l2.add(rt(3, 5, 7));
1:         l2.add(rt(7, 8, 3));
1:         l2.add(rt(8, 12, 1));
1:         l2.add(rt(14, 17, 4));
1: 
0:         l1.addAll(l2);
1: 
1:         Iterator<RangeTombstone> iter = l1.iterator();
0:         assertRT(rt(0, 3, 5), iter.next());
0:         assertRT(rt(3, 4, 7), iter.next());
0:         assertRT(rt(4, 5, 7), iter.next());
0:         assertRT(rt(6, 7, 2), iter.next());
1:         assertRT(rt(7, 8, 3), iter.next());
0:         assertRT(rt(8, 10, 2), iter.next());
0:         assertRT(rt(10, 12, 1), iter.next());
0:         assertRT(rt(14, 15, 4), iter.next());
0:         assertRT(rt(15, 17, 4), iter.next());
1: 
1:         assert !iter.hasNext();
1:     }
1: 
1:     @Test
0:     public void purgetTest()
1:     {
1:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
0:         l.add(rt(0, 4, 5, 110));
0:         l.add(rt(4, 6, 2, 98));
0:         l.add(rt(9, 12, 1, 200));
0:         l.add(rt(14, 15, 3, 3));
0:         l.add(rt(15, 17, 6, 45));
1: 
0:         l.purge(100);
1: 
1:         Iterator<RangeTombstone> iter = l.iterator();
0:         assertRT(rt(0, 4, 5, 110), iter.next());
0:         assertRT(rt(9, 12, 1, 200), iter.next());
1: 
1:         assert !iter.hasNext();
1:     }
1: 
1:     @Test
0:     public void minMaxTest()
1:     {
1:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
0:         l.add(rt(0, 4, 5, 110));
0:         l.add(rt(4, 6, 2, 98));
0:         l.add(rt(9, 12, 1, 200));
0:         l.add(rt(14, 15, 3, 3));
0:         l.add(rt(15, 17, 6, 45));
1: 
0:         assertEquals(1, l.minMarkedAt());
0:         assertEquals(6, l.maxMarkedAt());
1:     }
1: 
1:     private static void assertRT(RangeTombstone expected, RangeTombstone actual)
1:     {
0:         assertEquals(String.format("Expected %s but got %s", toString(expected), toString(actual)), expected, actual);
1:     }
1: 
1:     private static String toString(RangeTombstone rt)
1:     {
0:         return String.format("[%d, %d]@%d", i(rt.min), i(rt.max), rt.data.markedForDeleteAt);
1:     }
1: 
0:     private static ByteBuffer b(int i)
1:     {
0:         return ByteBufferUtil.bytes(i);
1:     }
1: 
0:     private static int i(ByteBuffer bb)
1:     {
0:         return ByteBufferUtil.toInt(bb);
1:     }
1: 
1:     private static RangeTombstone rt(int start, int end, long tstamp)
1:     {
1:         return rt(start, end, tstamp, 0);
1:     }
1: 
1:     private static RangeTombstone rt(int start, int end, long tstamp, int delTime)
1:     {
0:         return new RangeTombstone(b(start), b(end), tstamp, delTime);
1:     }
1: }
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:173f255
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     @Test
0:     public void insertSameTest()
0:     {
0:         // Simple test that adding the same element multiple time ends up
0:         // with that element only a single time (CASSANDRA-9485)
0: 
0:         RangeTombstoneList l = new RangeTombstoneList(cmp, 0);
0:         l.add(rt(4, 4, 5, 100));
0:         l.add(rt(4, 4, 6, 110));
0:         l.add(rt(4, 4, 4, 90));
0: 
0:         Iterator<RangeTombstone> iter = l.iterator();
0:         assertRT(rt(4, 4, 6, 110), iter.next());
0:         assert !iter.hasNext();
0:     }
0: 
1:     private RangeTombstoneList makeRandom(Random rand, int size, int maxItSize, int maxItDistance, int maxMarkedAt)
/////////////////////////////////////////////////////////////////////////
1:         long seed = System.nanoTime();
1:         Random rand = new Random(seed);
0: 
1:             RangeTombstoneList l1 = makeRandom(rand, rand.nextInt(MAX_LIST_SIZE) + 1, rand.nextInt(MAX_IT_SIZE) + 1, rand.nextInt(MAX_IT_DISTANCE) + 1, rand.nextInt(MAX_MARKEDAT) + 1);
1:             RangeTombstoneList l2 = makeRandom(rand, rand.nextInt(MAX_LIST_SIZE) + 1, rand.nextInt(MAX_IT_SIZE) + 1, rand.nextInt(MAX_IT_DISTANCE) + 1, rand.nextInt(MAX_MARKEDAT) + 1);
/////////////////////////////////////////////////////////////////////////
1:                 System.out.println("Seed was: " + seed);
author:Philo Yang
-------------------------------------------------------------------------------
commit:f0893f5
/////////////////////////////////////////////////////////////////////////
0:     public void testDiff()
0:     {
0:         RangeTombstoneList superset;
0:         RangeTombstoneList subset;
0:         RangeTombstoneList diff;
0:         Iterator<RangeTombstone> iter;
0: 
0:         // no difference
0:         superset = new RangeTombstoneList(cmp, 10);
0:         subset = new RangeTombstoneList(cmp, 10);
0:         superset.add(rt(1, 10, 10));
0:         superset.add(rt(20, 30, 10));
0:         superset.add(rt(40, 50, 10));
0:         subset.add(rt(1, 10, 10));
0:         subset.add(rt(20, 30, 10));
0:         subset.add(rt(40, 50, 10));
0:         assertNull( subset.diff(superset));
0: 
0:         // all items in subset are contained by the first range in the superset
0:         superset = new RangeTombstoneList(cmp, 10);
0:         subset = new RangeTombstoneList(cmp, 10);
0:         subset.add(rt(1, 2, 3));
0:         subset.add(rt(3, 4, 4));
0:         subset.add(rt(5, 6, 5));
0:         superset.add(rt(1, 10, 10));
0:         superset.add(rt(20, 30, 10));
0:         superset.add(rt(40, 50, 10));
0:         diff = subset.diff(superset);
0:         iter = diff.iterator();
0:         assertRT(rt(1, 10, 10), iter.next());
0:         assertRT(rt(20, 30, 10), iter.next());
0:         assertRT(rt(40, 50, 10), iter.next());
0:         assertFalse(iter.hasNext());
0: 
0:         // multiple subset RTs are contained by superset RTs
0:         superset = new RangeTombstoneList(cmp, 10);
0:         subset = new RangeTombstoneList(cmp, 10);
0:         subset.add(rt(1, 2, 1));
0:         subset.add(rt(3, 4, 2));
0:         subset.add(rt(5, 6, 3));
0:         superset.add(rt(1, 5, 2));
0:         superset.add(rt(5, 6, 3));
0:         superset.add(rt(6, 10, 2));
0:         diff = subset.diff(superset);
0:         iter = diff.iterator();
0:         assertRT(rt(1, 5, 2), iter.next());
0:         assertRT(rt(6, 10, 2), iter.next());
0:         assertFalse(iter.hasNext());
0: 
0:         // the superset has one RT that covers the entire subset
0:         superset = new RangeTombstoneList(cmp, 10);
0:         subset = new RangeTombstoneList(cmp, 10);
0:         superset.add(rt(1, 50, 10));
0:         subset.add(rt(1, 10, 10));
0:         subset.add(rt(20, 30, 10));
0:         subset.add(rt(40, 50, 10));
0:         diff = subset.diff(superset);
0:         iter = diff.iterator();
0:         assertRT(rt(1, 50, 10), iter.next());
0:         assertFalse(iter.hasNext());
0: 
0:         // the superset has one RT that covers the remainder of the subset
0:         superset = new RangeTombstoneList(cmp, 10);
0:         subset = new RangeTombstoneList(cmp, 10);
0:         superset.add(rt(1, 10, 10));
0:         superset.add(rt(20, 50, 10));
0:         subset.add(rt(1, 10, 10));
0:         subset.add(rt(20, 30, 10));
0:         subset.add(rt(40, 50, 10));
0:         diff = subset.diff(superset);
0:         iter = diff.iterator();
0:         assertRT(rt(20, 50, 10), iter.next());
0:         assertFalse(iter.hasNext());
0: 
0:         // only the timestamp differs on one RT
0:         superset = new RangeTombstoneList(cmp, 10);
0:         subset = new RangeTombstoneList(cmp, 10);
0:         superset.add(rt(1, 10, 10));
0:         superset.add(rt(20, 30, 20));
0:         superset.add(rt(40, 50, 10));
0:         subset.add(rt(1, 10, 10));
0:         subset.add(rt(20, 30, 10));
0:         subset.add(rt(40, 50, 10));
0:         diff = subset.diff(superset);
0:         iter = diff.iterator();
0:         assertRT(rt(20, 30, 20), iter.next());
0:         assertFalse(iter.hasNext());
0: 
0:         // superset has a large range on an RT at the start
0:         superset = new RangeTombstoneList(cmp, 10);
0:         subset = new RangeTombstoneList(cmp, 10);
0:         superset.add(rt(1, 10, 10));
0:         superset.add(rt(20, 30, 10));
0:         superset.add(rt(40, 50, 10));
0:         subset.add(rt(1, 2, 3));
0:         subset.add(rt(20, 30, 10));
0:         subset.add(rt(40, 50, 10));
0:         diff = subset.diff(superset);
0:         iter = diff.iterator();
0:         assertRT(rt(1, 10, 10), iter.next());
0:         assertFalse(iter.hasNext());
0: 
0:         // superset has a larger range on an RT in the middle
0:         superset = new RangeTombstoneList(cmp, 10);
0:         subset = new RangeTombstoneList(cmp, 10);
0:         superset.add(rt(1, 10, 10));
0:         superset.add(rt(20, 30, 10));
0:         superset.add(rt(40, 50, 10));
0:         subset.add(rt(1, 10, 10));
0:         subset.add(rt(20, 25, 10));
0:         subset.add(rt(40, 50, 10));
0:         diff = subset.diff(superset);
0:         iter = diff.iterator();
0:         assertRT(rt(20, 30, 10), iter.next());
0:         assertFalse(iter.hasNext());
0: 
0:         // superset has a larger range on an RT at the end
0:         superset = new RangeTombstoneList(cmp, 10);
0:         subset = new RangeTombstoneList(cmp, 10);
0:         superset.add(rt(1, 10, 10));
0:         superset.add(rt(20, 30, 10));
0:         superset.add(rt(40, 55, 10));
0:         subset.add(rt(1, 10, 10));
0:         subset.add(rt(20, 30, 10));
0:         subset.add(rt(40, 50, 10));
0:         diff = subset.diff(superset);
0:         iter = diff.iterator();
0:         assertRT(rt(40, 55, 10), iter.next());
0:         assertFalse(iter.hasNext());
0: 
0:          // superset has one additional RT in the middle
0:         superset = new RangeTombstoneList(cmp, 10);
0:         subset = new RangeTombstoneList(cmp, 10);
0:         superset.add(rt(1, 10, 10));
0:         superset.add(rt(20, 30, 10));
0:         superset.add(rt(40, 50, 10));
0:         subset.add(rt(1, 10, 10));
0:         subset.add(rt(40, 50, 10));
0:         diff = subset.diff(superset);
0:         iter = diff.iterator();
0:         assertRT(rt(20, 30, 10), iter.next());
0:         assertFalse(iter.hasNext());
0: 
0:         // superset has one additional RT at the start
0:         superset = new RangeTombstoneList(cmp, 10);
0:         subset = new RangeTombstoneList(cmp, 10);
0:         superset.add(rt(1, 10, 10));
0:         superset.add(rt(20, 30, 10));
0:         superset.add(rt(40, 50, 10));
0:         subset.add(rt(20, 30, 10));
0:         subset.add(rt(40, 50, 10));
0:         diff = subset.diff(superset);
0:         iter = diff.iterator();
0:         assertRT(rt(1, 10, 10), iter.next());
0:         assertFalse(iter.hasNext());
0: 
0:         // superset has one additional RT at the end
0:         superset = new RangeTombstoneList(cmp, 10);
0:         subset = new RangeTombstoneList(cmp, 10);
0:         superset.add(rt(1, 10, 10));
0:         superset.add(rt(20, 30, 10));
0:         superset.add(rt(40, 50, 10));
0:         subset.add(rt(1, 10, 10));
0:         subset.add(rt(20, 30, 10));
0:         diff = subset.diff(superset);
0:         iter = diff.iterator();
0:         assertRT(rt(40, 50, 10), iter.next());
0:         assertFalse(iter.hasNext());
0:     }
0: 
0:     @Test
author:Dave Brosius
-------------------------------------------------------------------------------
commit:9639f95
/////////////////////////////////////////////////////////////////////////
commit:4334f99
/////////////////////////////////////////////////////////////////////////
commit:8d3d67e
/////////////////////////////////////////////////////////////////////////
1:         l2.add(rt(4, 10, 12L));
1:         l2.add(rt(0, 8, 25L));
0:         assertEquals(25L, l2.search(b(8)).markedForDeleteAt);
============================================================================