1:133acbb: /*
1:133acbb: * Licensed to the Apache Software Foundation (ASF) under one
1:133acbb: * or more contributor license agreements.  See the NOTICE file
1:133acbb: * distributed with this work for additional information
1:133acbb: * regarding copyright ownership.  The ASF licenses this file
1:133acbb: * to you under the Apache License, Version 2.0 (the
1:133acbb: * "License"); you may not use this file except in compliance
1:133acbb: * with the License.  You may obtain a copy of the License at
1:133acbb: *
1:133acbb: *    http://www.apache.org/licenses/LICENSE-2.0
1:133acbb: *
1:133acbb: * Unless required by applicable law or agreed to in writing,
1:133acbb: * software distributed under the License is distributed on an
1:133acbb: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:133acbb: * KIND, either express or implied.  See the License for the
1:133acbb: * specific language governing permissions and limitations
1:133acbb: * under the License.
1:133acbb: */
1:133acbb: 
1:133acbb: package org.apache.cassandra.service;
1:133acbb: 
1:133acbb: import java.net.InetAddress;
1:133acbb: import java.net.UnknownHostException;
1:133acbb: import java.util.*;
1:133acbb: 
1:133acbb: import com.google.common.collect.HashMultimap;
1:133acbb: import com.google.common.collect.Multimap;
1:0a08525: 
1:a991b64: import org.junit.AfterClass;
1:a991b64: import org.junit.BeforeClass;
1:133acbb: import org.junit.Test;
1:133acbb: 
1:438acfc: import org.apache.cassandra.SchemaLoader;
1:133acbb: import org.apache.cassandra.Util;
1:0a08525: import org.apache.cassandra.Util.PartitionerSwitcher;
1:9797511: import org.apache.cassandra.config.DatabaseDescriptor;
1:d2a3827: import org.apache.cassandra.config.Schema;
1:d2a3827: import org.apache.cassandra.db.SystemKeyspace;
1:a991b64: import org.apache.cassandra.dht.IPartitioner;
1:a991b64: import org.apache.cassandra.dht.RandomPartitioner;
1:07893d7: import org.apache.cassandra.dht.RandomPartitioner.BigIntegerToken;
1:a991b64: import org.apache.cassandra.dht.Token;
1:133acbb: import org.apache.cassandra.gms.ApplicationState;
1:ab95f98: import org.apache.cassandra.gms.Gossiper;
1:133acbb: import org.apache.cassandra.gms.VersionedValue;
1:133acbb: import org.apache.cassandra.locator.AbstractReplicationStrategy;
1:133acbb: import org.apache.cassandra.locator.SimpleSnitch;
1:133acbb: import org.apache.cassandra.locator.TokenMetadata;
1:a89597d: import org.apache.cassandra.schema.KeyspaceMetadata;
1:69f77cb: 
1:133acbb: import static org.junit.Assert.*;
1:133acbb: 
1:438acfc: public class LeaveAndBootstrapTest
1:133acbb: {
1:07893d7:     private static final IPartitioner partitioner = RandomPartitioner.instance;
1:0a08525:     private static PartitionerSwitcher partitionerSwitcher;
1:d2a3827:     private static final String KEYSPACE1 = "LeaveAndBootstrapTestKeyspace1";
1:d2a3827:     private static final String KEYSPACE2 = "LeaveAndBootstrapTestKeyspace2";
1:d2a3827:     private static final String KEYSPACE3 = "LeaveAndBootstrapTestKeyspace3";
1:d2a3827:     private static final String KEYSPACE4 = "LeaveAndBootstrapTestKeyspace4";
1:133acbb: 
1:438acfc:     @BeforeClass
1:d2a3827:     public static void defineSchema() throws Exception
1:438acfc:     {
1:9797511:         DatabaseDescriptor.daemonInitialization();
1:0a08525:         partitionerSwitcher = Util.switchPartitioner(partitioner);
1:438acfc:         SchemaLoader.loadSchema();
1:d2a3827:         SchemaLoader.schemaDefinition("LeaveAndBootstrapTest");
1:438acfc:     }
1:133acbb: 
1:438acfc:     @AfterClass
1:438acfc:     public static void tearDown()
1:438acfc:     {
1:0a08525:         partitionerSwitcher.close();
1:438acfc:     }
1:a991b64: 
1:133acbb:     /**
1:133acbb:      * Test whether write endpoints is correct when the node is leaving. Uses
1:133acbb:      * StorageService.onChange and does not manipulate token metadata directly.
1:133acbb:      */
1:133acbb:     @Test
1:133acbb:     public void newTestWriteEndpointsDuringLeave() throws Exception
1:133acbb:     {
1:133acbb:         StorageService ss = StorageService.instance;
1:133acbb:         final int RING_SIZE = 6;
1:133acbb:         final int LEAVING_NODE = 3;
1:133acbb: 
1:133acbb:         TokenMetadata tmd = ss.getTokenMetadata();
1:133acbb:         tmd.clearUnsafe();
1:07893d7:         IPartitioner partitioner = RandomPartitioner.instance;
1:133acbb:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
1:133acbb: 
1:133acbb:         ArrayList<Token> endpointTokens = new ArrayList<Token>();
1:133acbb:         ArrayList<Token> keyTokens = new ArrayList<Token>();
1:133acbb:         List<InetAddress> hosts = new ArrayList<InetAddress>();
1:ad685c4:         List<UUID> hostIds = new ArrayList<UUID>();
1:133acbb: 
1:ad685c4:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, RING_SIZE);
1:133acbb: 
1:133acbb:         Map<Token, List<InetAddress>> expectedEndpoints = new HashMap<Token, List<InetAddress>>();
1:a4e1182:         for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces())
1:133acbb:         {
1:133acbb:             for (Token token : keyTokens)
1:133acbb:             {
1:133acbb:                 List<InetAddress> endpoints = new ArrayList<InetAddress>();
1:133acbb:                 Iterator<Token> tokenIter = TokenMetadata.ringIterator(tmd.sortedTokens(), token, false);
1:133acbb:                 while (tokenIter.hasNext())
1:133acbb:                 {
1:133acbb:                     endpoints.add(tmd.getEndpoint(tokenIter.next()));
1:133acbb:                 }
1:133acbb:                 expectedEndpoints.put(token, endpoints);
1:133acbb:             }
1:133acbb:         }
1:133acbb: 
1:133acbb:         // Third node leaves
1:133acbb:         ss.onChange(hosts.get(LEAVING_NODE),
1:133acbb:                 ApplicationState.STATUS,
1:66b96ee:                 valueFactory.leaving(Collections.singleton(endpointTokens.get(LEAVING_NODE))));
1:133acbb:         assertTrue(tmd.isLeaving(hosts.get(LEAVING_NODE)));
1:133acbb: 
1:2dd55c7:         Thread.sleep(100); // because there is a tight race between submit and blockUntilFinished
1:eeb8d1b:         PendingRangeCalculatorService.instance.blockUntilFinished();
1:133acbb: 
1:133acbb:         AbstractReplicationStrategy strategy;
1:a4e1182:         for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces())
1:133acbb:         {
1:0e96e58:             strategy = getStrategy(keyspaceName, tmd);
1:133acbb:             for (Token token : keyTokens)
1:133acbb:             {
1:133acbb:                 int replicationFactor = strategy.getReplicationFactor();
1:133acbb: 
1:0e96e58:                 HashSet<InetAddress> actual = new HashSet<InetAddress>(tmd.getWriteEndpoints(token, keyspaceName, strategy.calculateNaturalEndpoints(token, tmd.cloneOnlyTokenMap())));
1:133acbb:                 HashSet<InetAddress> expected = new HashSet<InetAddress>();
1:133acbb: 
1:133acbb:                 for (int i = 0; i < replicationFactor; i++)
1:133acbb:                 {
1:133acbb:                     expected.add(expectedEndpoints.get(token).get(i));
1:133acbb:                 }
1:133acbb: 
1:133acbb:                 // if the leaving node is in the endpoint list,
1:133acbb:                 // then we should expect it plus one extra for when it's gone
1:133acbb:                 if (expected.contains(hosts.get(LEAVING_NODE)))
1:133acbb:                     expected.add(expectedEndpoints.get(token).get(replicationFactor));
1:133acbb: 
1:133acbb:                 assertEquals("mismatched endpoint sets", expected, actual);
1:133acbb:             }
1:133acbb:         }
1:133acbb:     }
1:133acbb: 
1:133acbb:     /**
1:133acbb:      * Test pending ranges and write endpoints when multiple nodes are on the move
1:133acbb:      * simultaneously
1:133acbb:      */
1:133acbb:     @Test
1:9639f95:     public void testSimultaneousMove() throws UnknownHostException
1:133acbb:     {
1:133acbb:         StorageService ss = StorageService.instance;
1:133acbb:         final int RING_SIZE = 10;
1:133acbb:         TokenMetadata tmd = ss.getTokenMetadata();
1:133acbb:         tmd.clearUnsafe();
1:07893d7:         IPartitioner partitioner = RandomPartitioner.instance;
1:133acbb:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
1:133acbb: 
1:133acbb:         ArrayList<Token> endpointTokens = new ArrayList<Token>();
1:133acbb:         ArrayList<Token> keyTokens = new ArrayList<Token>();
1:133acbb:         List<InetAddress> hosts = new ArrayList<InetAddress>();
1:ad685c4:         List<UUID> hostIds = new ArrayList<UUID>();
1:133acbb: 
1:133acbb:         // create a ring or 10 nodes
1:ad685c4:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, RING_SIZE);
1:133acbb: 
1:133acbb:         // nodes 6, 8 and 9 leave
1:133acbb:         final int[] LEAVING = new int[] {6, 8, 9};
1:133acbb:         for (int leaving : LEAVING)
1:66b96ee:             ss.onChange(hosts.get(leaving),
1:66b96ee:                         ApplicationState.STATUS,
1:66b96ee:                         valueFactory.leaving(Collections.singleton(endpointTokens.get(leaving))));
1:133acbb: 
1:133acbb:         // boot two new nodes with keyTokens.get(5) and keyTokens.get(7)
1:133acbb:         InetAddress boot1 = InetAddress.getByName("127.0.1.1");
1:b475bc6:         Gossiper.instance.initializeNodeUnsafe(boot1, UUID.randomUUID(), 1);
1:b475bc6:         Gossiper.instance.injectApplicationState(boot1, ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(5))));
1:66b96ee:         ss.onChange(boot1,
1:66b96ee:                     ApplicationState.STATUS,
1:b475bc6:                     valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(5))));
1:133acbb:         InetAddress boot2 = InetAddress.getByName("127.0.1.2");
1:b475bc6:         Gossiper.instance.initializeNodeUnsafe(boot2, UUID.randomUUID(), 1);
1:b475bc6:         Gossiper.instance.injectApplicationState(boot2, ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(7))));
1:66b96ee:         ss.onChange(boot2,
1:66b96ee:                     ApplicationState.STATUS,
1:b475bc6:                     valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(7))));
1:133acbb: 
1:133acbb:         Collection<InetAddress> endpoints = null;
1:133acbb: 
1:133acbb:         /* don't require test update every time a new keyspace is added to test/conf/cassandra.yaml */
1:0e96e58:         Map<String, AbstractReplicationStrategy> keyspaceStrategyMap = new HashMap<String, AbstractReplicationStrategy>();
1:133acbb:         for (int i=1; i<=4; i++)
1:133acbb:         {
1:d2a3827:             keyspaceStrategyMap.put("LeaveAndBootstrapTestKeyspace" + i, getStrategy("LeaveAndBootstrapTestKeyspace" + i, tmd));
1:133acbb:         }
1:133acbb: 
1:133acbb:         // pre-calculate the results.
1:133acbb:         Map<String, Multimap<Token, InetAddress>> expectedEndpoints = new HashMap<String, Multimap<Token, InetAddress>>();
1:d2a3827:         expectedEndpoints.put(KEYSPACE1, HashMultimap.<Token, InetAddress>create());
1:d2a3827:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("5"), makeAddrs("127.0.0.2"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.1.1"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.8"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.1.2", "127.0.0.1"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.10", "127.0.0.1"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.1"));
1:d2a3827:         expectedEndpoints.put(KEYSPACE2, HashMultimap.<Token, InetAddress>create());
1:d2a3827:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("5"), makeAddrs("127.0.0.2"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.1.1"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.8"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.1.2", "127.0.0.1"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.10", "127.0.0.1"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.1"));
1:d2a3827:         expectedEndpoints.put(KEYSPACE3, HashMultimap.<Token, InetAddress>create());
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("5"), makeAddrs("127.0.0.2", "127.0.0.3", "127.0.0.4", "127.0.0.5", "127.0.0.6"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3", "127.0.0.4", "127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.1.1", "127.0.0.8"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4", "127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.1.2", "127.0.0.1", "127.0.1.1"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.1.2", "127.0.0.1", "127.0.0.2", "127.0.1.1"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.1.2", "127.0.0.1", "127.0.0.2", "127.0.1.1", "127.0.0.3"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.0.3", "127.0.0.4", "127.0.1.1", "127.0.1.2"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.1.2", "127.0.0.3", "127.0.0.4"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.0.3", "127.0.1.2", "127.0.0.4", "127.0.0.5"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.0.3", "127.0.0.4", "127.0.0.5"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.1", "127.0.0.2", "127.0.0.3", "127.0.0.4", "127.0.0.5"));
1:d2a3827:         expectedEndpoints.put(KEYSPACE4, HashMultimap.<Token, InetAddress>create());
1:d2a3827:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("5"), makeAddrs("127.0.0.2", "127.0.0.3", "127.0.0.4"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3", "127.0.0.4", "127.0.0.5"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4", "127.0.0.5", "127.0.0.6"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.1.1", "127.0.0.8"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.1.2", "127.0.0.1", "127.0.1.1"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.0.1", "127.0.0.2", "127.0.1.1", "127.0.1.2"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.1.2", "127.0.0.1", "127.0.0.2"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.1.2", "127.0.0.2", "127.0.0.3"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.0.3"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.1", "127.0.0.2", "127.0.0.3"));
1:133acbb: 
1:eeb8d1b:         PendingRangeCalculatorService.instance.blockUntilFinished();
1:133acbb: 
1:0e96e58:         for (Map.Entry<String, AbstractReplicationStrategy> keyspaceStrategy : keyspaceStrategyMap.entrySet())
1:133acbb:         {
1:0e96e58:             String keyspaceName = keyspaceStrategy.getKey();
1:0e96e58:             AbstractReplicationStrategy strategy = keyspaceStrategy.getValue();
1:133acbb: 
1:133acbb:             for (int i = 0; i < keyTokens.size(); i++)
1:133acbb:             {
1:0e96e58:                 endpoints = tmd.getWriteEndpoints(keyTokens.get(i), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(i)));
1:3020555:                 assertEquals(expectedEndpoints.get(keyspaceName).get(keyTokens.get(i)).size(), endpoints.size());
1:0e96e58:                 assertTrue(expectedEndpoints.get(keyspaceName).get(keyTokens.get(i)).containsAll(endpoints));
1:133acbb:             }
1:133acbb: 
1:133acbb:             // just to be sure that things still work according to the old tests, run them:
1:133acbb:             if (strategy.getReplicationFactor() != 3)
1:133acbb:                 continue;
1:133acbb:             // tokens 5, 15 and 25 should go three nodes
1:133acbb:             for (int i=0; i<3; ++i)
1:133acbb:             {
1:0e96e58:                 endpoints = tmd.getWriteEndpoints(keyTokens.get(i), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(i)));
1:3020555:                 assertEquals(3, endpoints.size());
1:133acbb:                 assertTrue(endpoints.contains(hosts.get(i+1)));
1:133acbb:                 assertTrue(endpoints.contains(hosts.get(i+2)));
1:133acbb:                 assertTrue(endpoints.contains(hosts.get(i+3)));
1:133acbb:             }
1:133acbb: 
1:133acbb:             // token 35 should go to nodes 4, 5, 6, 7 and boot1
1:0e96e58:             endpoints = tmd.getWriteEndpoints(keyTokens.get(3), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(3)));
1:3020555:             assertEquals(5, endpoints.size());
1:133acbb:             assertTrue(endpoints.contains(hosts.get(4)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(5)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(6)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(7)));
1:133acbb:             assertTrue(endpoints.contains(boot1));
1:133acbb: 
1:133acbb:             // token 45 should go to nodes 5, 6, 7, 0, boot1 and boot2
1:0e96e58:             endpoints = tmd.getWriteEndpoints(keyTokens.get(4), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(4)));
1:3020555:             assertEquals(6, endpoints.size());
1:133acbb:             assertTrue(endpoints.contains(hosts.get(5)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(6)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(7)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(0)));
1:133acbb:             assertTrue(endpoints.contains(boot1));
1:133acbb:             assertTrue(endpoints.contains(boot2));
1:133acbb: 
1:133acbb:             // token 55 should go to nodes 6, 7, 8, 0, 1, boot1 and boot2
1:0e96e58:             endpoints = tmd.getWriteEndpoints(keyTokens.get(5), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(5)));
1:3020555:             assertEquals(7, endpoints.size());
1:133acbb:             assertTrue(endpoints.contains(hosts.get(6)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(7)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(8)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(0)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(1)));
1:133acbb:             assertTrue(endpoints.contains(boot1));
1:133acbb:             assertTrue(endpoints.contains(boot2));
1:133acbb: 
1:133acbb:             // token 65 should go to nodes 7, 8, 9, 0, 1 and boot2
1:0e96e58:             endpoints = tmd.getWriteEndpoints(keyTokens.get(6), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(6)));
1:3020555:             assertEquals(6, endpoints.size());
1:133acbb:             assertTrue(endpoints.contains(hosts.get(7)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(8)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(9)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(0)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(1)));
1:133acbb:             assertTrue(endpoints.contains(boot2));
1:133acbb: 
1:133acbb:             // token 75 should to go nodes 8, 9, 0, 1, 2 and boot2
1:0e96e58:             endpoints = tmd.getWriteEndpoints(keyTokens.get(7), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(7)));
1:3020555:             assertEquals(6, endpoints.size());
1:133acbb:             assertTrue(endpoints.contains(hosts.get(8)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(9)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(0)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(1)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(2)));
1:133acbb:             assertTrue(endpoints.contains(boot2));
1:133acbb: 
1:133acbb:             // token 85 should go to nodes 9, 0, 1 and 2
1:0e96e58:             endpoints = tmd.getWriteEndpoints(keyTokens.get(8), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(8)));
1:3020555:             assertEquals(4, endpoints.size());
1:133acbb:             assertTrue(endpoints.contains(hosts.get(9)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(0)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(1)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(2)));
1:133acbb: 
1:133acbb:             // token 95 should go to nodes 0, 1 and 2
1:0e96e58:             endpoints = tmd.getWriteEndpoints(keyTokens.get(9), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(9)));
1:3020555:             assertEquals(3, endpoints.size());
1:133acbb:             assertTrue(endpoints.contains(hosts.get(0)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(1)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(2)));
1:133acbb: 
1:133acbb:         }
1:133acbb: 
1:133acbb:         // Now finish node 6 and node 9 leaving, as well as boot1 (after this node 8 is still
1:133acbb:         // leaving and boot2 in progress
1:ab95f98:         ss.onChange(hosts.get(LEAVING[0]), ApplicationState.STATUS,
1:66b96ee:                 valueFactory.left(Collections.singleton(endpointTokens.get(LEAVING[0])), Gossiper.computeExpireTime()));
1:ab95f98:         ss.onChange(hosts.get(LEAVING[2]), ApplicationState.STATUS,
1:66b96ee:                 valueFactory.left(Collections.singleton(endpointTokens.get(LEAVING[2])), Gossiper.computeExpireTime()));
1:b475bc6:         ss.onChange(boot1, ApplicationState.STATUS, valueFactory.normal(Collections.singleton(keyTokens.get(5))));
1:133acbb: 
1:133acbb:         // adjust precalcuated results.  this changes what the epected endpoints are.
1:d2a3827:         expectedEndpoints.get(KEYSPACE1).get(new BigIntegerToken("55")).removeAll(makeAddrs("127.0.0.7", "127.0.0.8"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE1).get(new BigIntegerToken("85")).removeAll(makeAddrs("127.0.0.10"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE2).get(new BigIntegerToken("55")).removeAll(makeAddrs("127.0.0.7", "127.0.0.8"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE2).get(new BigIntegerToken("85")).removeAll(makeAddrs("127.0.0.10"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).get(new BigIntegerToken("15")).removeAll(makeAddrs("127.0.0.7", "127.0.0.8"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).get(new BigIntegerToken("25")).removeAll(makeAddrs("127.0.0.7", "127.0.1.2", "127.0.0.1"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).get(new BigIntegerToken("35")).removeAll(makeAddrs("127.0.0.7", "127.0.0.2"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).get(new BigIntegerToken("45")).removeAll(makeAddrs("127.0.0.7", "127.0.0.10", "127.0.0.3"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).get(new BigIntegerToken("55")).removeAll(makeAddrs("127.0.0.7", "127.0.0.10", "127.0.0.4"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).get(new BigIntegerToken("65")).removeAll(makeAddrs("127.0.0.10"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).get(new BigIntegerToken("75")).removeAll(makeAddrs("127.0.0.10"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE3).get(new BigIntegerToken("85")).removeAll(makeAddrs("127.0.0.10"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE4).get(new BigIntegerToken("35")).removeAll(makeAddrs("127.0.0.7", "127.0.0.8"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE4).get(new BigIntegerToken("45")).removeAll(makeAddrs("127.0.0.7", "127.0.1.2", "127.0.0.1"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE4).get(new BigIntegerToken("55")).removeAll(makeAddrs("127.0.0.2", "127.0.0.7"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE4).get(new BigIntegerToken("65")).removeAll(makeAddrs("127.0.0.10"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE4).get(new BigIntegerToken("75")).removeAll(makeAddrs("127.0.0.10"));
1:d2a3827:         expectedEndpoints.get(KEYSPACE4).get(new BigIntegerToken("85")).removeAll(makeAddrs("127.0.0.10"));
1:133acbb: 
1:eeb8d1b:         PendingRangeCalculatorService.instance.blockUntilFinished();
1:133acbb: 
1:0e96e58:         for (Map.Entry<String, AbstractReplicationStrategy> keyspaceStrategy : keyspaceStrategyMap.entrySet())
1:133acbb:         {
1:0e96e58:             String keyspaceName = keyspaceStrategy.getKey();
1:0e96e58:             AbstractReplicationStrategy strategy = keyspaceStrategy.getValue();
1:133acbb: 
1:133acbb:             for (int i = 0; i < keyTokens.size(); i++)
1:133acbb:             {
1:0e96e58:                 endpoints = tmd.getWriteEndpoints(keyTokens.get(i), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(i)));
1:3020555:                 assertEquals(expectedEndpoints.get(keyspaceName).get(keyTokens.get(i)).size(), endpoints.size());
1:0e96e58:                 assertTrue(expectedEndpoints.get(keyspaceName).get(keyTokens.get(i)).containsAll(endpoints));
1:133acbb:             }
1:133acbb: 
1:133acbb:             if (strategy.getReplicationFactor() != 3)
1:133acbb:                 continue;
1:133acbb:             // leave this stuff in to guarantee the old tests work the way they were supposed to.
1:133acbb:             // tokens 5, 15 and 25 should go three nodes
1:133acbb:             for (int i=0; i<3; ++i)
1:133acbb:             {
1:0e96e58:                 endpoints = tmd.getWriteEndpoints(keyTokens.get(i), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(i)));
1:3020555:                 assertEquals(3, endpoints.size());
1:133acbb:                 assertTrue(endpoints.contains(hosts.get(i+1)));
1:133acbb:                 assertTrue(endpoints.contains(hosts.get(i+2)));
1:133acbb:                 assertTrue(endpoints.contains(hosts.get(i+3)));
1:133acbb:             }
1:133acbb: 
1:133acbb:             // token 35 goes to nodes 4, 5 and boot1
1:0e96e58:             endpoints = tmd.getWriteEndpoints(keyTokens.get(3), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(3)));
1:3020555:             assertEquals(3, endpoints.size());
1:133acbb:             assertTrue(endpoints.contains(hosts.get(4)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(5)));
1:133acbb:             assertTrue(endpoints.contains(boot1));
1:133acbb: 
1:133acbb:             // token 45 goes to nodes 5, boot1 and node7
1:0e96e58:             endpoints = tmd.getWriteEndpoints(keyTokens.get(4), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(4)));
1:3020555:             assertEquals(3, endpoints.size());
1:133acbb:             assertTrue(endpoints.contains(hosts.get(5)));
1:133acbb:             assertTrue(endpoints.contains(boot1));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(7)));
1:133acbb: 
1:133acbb:             // token 55 goes to boot1, 7, boot2, 8 and 0
1:0e96e58:             endpoints = tmd.getWriteEndpoints(keyTokens.get(5), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(5)));
1:3020555:             assertEquals(5, endpoints.size());
1:133acbb:             assertTrue(endpoints.contains(boot1));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(7)));
1:133acbb:             assertTrue(endpoints.contains(boot2));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(8)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(0)));
1:133acbb: 
1:133acbb:             // token 65 goes to nodes 7, boot2, 8, 0 and 1
1:0e96e58:             endpoints = tmd.getWriteEndpoints(keyTokens.get(6), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(6)));
1:3020555:             assertEquals(5, endpoints.size());
1:133acbb:             assertTrue(endpoints.contains(hosts.get(7)));
1:133acbb:             assertTrue(endpoints.contains(boot2));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(8)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(0)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(1)));
1:133acbb: 
1:133acbb:             // token 75 goes to nodes boot2, 8, 0, 1 and 2
1:0e96e58:             endpoints = tmd.getWriteEndpoints(keyTokens.get(7), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(7)));
1:3020555:             assertEquals(5, endpoints.size());
1:133acbb:             assertTrue(endpoints.contains(boot2));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(8)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(0)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(1)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(2)));
1:133acbb: 
1:133acbb:             // token 85 goes to nodes 0, 1 and 2
1:0e96e58:             endpoints = tmd.getWriteEndpoints(keyTokens.get(8), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(8)));
1:3020555:             assertEquals(3, endpoints.size());
1:133acbb:             assertTrue(endpoints.contains(hosts.get(0)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(1)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(2)));
1:133acbb: 
1:133acbb:             // token 95 goes to nodes 0, 1 and 2
1:0e96e58:             endpoints = tmd.getWriteEndpoints(keyTokens.get(9), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(9)));
1:3020555:             assertEquals(3, endpoints.size());
1:133acbb:             assertTrue(endpoints.contains(hosts.get(0)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(1)));
1:133acbb:             assertTrue(endpoints.contains(hosts.get(2)));
1:133acbb:         }
1:133acbb:     }
1:133acbb: 
1:133acbb:     @Test
1:133acbb:     public void testStateJumpToBootstrap() throws UnknownHostException
1:133acbb:     {
1:133acbb:         StorageService ss = StorageService.instance;
1:133acbb:         TokenMetadata tmd = ss.getTokenMetadata();
1:133acbb:         tmd.clearUnsafe();
1:07893d7:         IPartitioner partitioner = RandomPartitioner.instance;
1:133acbb:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
1:133acbb: 
1:133acbb:         ArrayList<Token> endpointTokens = new ArrayList<Token>();
1:133acbb:         ArrayList<Token> keyTokens = new ArrayList<Token>();
1:133acbb:         List<InetAddress> hosts = new ArrayList<InetAddress>();
1:ad685c4:         List<UUID> hostIds = new ArrayList<UUID>();
1:133acbb: 
1:133acbb:         // create a ring or 5 nodes
1:ad685c4:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, 7);
1:133acbb: 
1:133acbb:         // node 2 leaves
1:66b96ee:         ss.onChange(hosts.get(2),
1:66b96ee:                     ApplicationState.STATUS,
1:66b96ee:                     valueFactory.leaving(Collections.singleton(endpointTokens.get(2))));
1:133acbb: 
1:133acbb:         // don't bother to test pending ranges here, that is extensively tested by other
1:133acbb:         // tests. Just check that the node is in appropriate lists.
1:133acbb:         assertTrue(tmd.isMember(hosts.get(2)));
1:133acbb:         assertTrue(tmd.isLeaving(hosts.get(2)));
1:133acbb:         assertTrue(tmd.getBootstrapTokens().isEmpty());
1:133acbb: 
1:133acbb:         // Bootstrap the node immedidiately to keyTokens.get(4) without going through STATE_LEFT
1:b475bc6:         Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(4))));
1:66b96ee:         ss.onChange(hosts.get(2),
1:66b96ee:                     ApplicationState.STATUS,
1:b475bc6:                     valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(4))));
1:133acbb: 
1:133acbb:         assertFalse(tmd.isMember(hosts.get(2)));
1:133acbb:         assertFalse(tmd.isLeaving(hosts.get(2)));
1:3020555:         assertEquals(hosts.get(2), tmd.getBootstrapTokens().get(keyTokens.get(4)));
1:133acbb: 
1:133acbb:         // Bootstrap node hosts.get(3) to keyTokens.get(1)
1:b475bc6:         Gossiper.instance.injectApplicationState(hosts.get(3), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(1))));
1:66b96ee:         ss.onChange(hosts.get(3),
1:66b96ee:                     ApplicationState.STATUS,
1:b475bc6:                     valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(1))));
1:133acbb: 
1:133acbb:         assertFalse(tmd.isMember(hosts.get(3)));
1:133acbb:         assertFalse(tmd.isLeaving(hosts.get(3)));
1:3020555:         assertEquals(hosts.get(2), tmd.getBootstrapTokens().get(keyTokens.get(4)));
1:3020555:         assertEquals(hosts.get(3), tmd.getBootstrapTokens().get(keyTokens.get(1)));
1:133acbb: 
1:133acbb:         // Bootstrap node hosts.get(2) further to keyTokens.get(3)
1:b475bc6:         Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(3))));
1:66b96ee:         ss.onChange(hosts.get(2),
1:66b96ee:                     ApplicationState.STATUS,
1:b475bc6:                     valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(3))));
1:133acbb: 
1:133acbb:         assertFalse(tmd.isMember(hosts.get(2)));
1:133acbb:         assertFalse(tmd.isLeaving(hosts.get(2)));
1:3020555:         assertEquals(hosts.get(2), tmd.getBootstrapTokens().get(keyTokens.get(3)));
1:3020555:         assertNull(tmd.getBootstrapTokens().get(keyTokens.get(4)));
1:3020555:         assertEquals(hosts.get(3), tmd.getBootstrapTokens().get(keyTokens.get(1)));
1:133acbb: 
1:133acbb:         // Go to normal again for both nodes
1:b475bc6:         Gossiper.instance.injectApplicationState(hosts.get(3), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(2))));
1:b475bc6:         Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(3))));
1:b475bc6:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(keyTokens.get(3))));
1:b475bc6:         ss.onChange(hosts.get(3), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(keyTokens.get(2))));
1:133acbb: 
1:133acbb:         assertTrue(tmd.isMember(hosts.get(2)));
1:133acbb:         assertFalse(tmd.isLeaving(hosts.get(2)));
1:3020555:         assertEquals(keyTokens.get(3), tmd.getToken(hosts.get(2)));
1:133acbb:         assertTrue(tmd.isMember(hosts.get(3)));
1:133acbb:         assertFalse(tmd.isLeaving(hosts.get(3)));
1:3020555:         assertEquals(keyTokens.get(2), tmd.getToken(hosts.get(3)));
1:133acbb: 
1:133acbb:         assertTrue(tmd.getBootstrapTokens().isEmpty());
1:133acbb:     }
1:133acbb: 
1:133acbb:     @Test
1:133acbb:     public void testStateJumpToNormal() throws UnknownHostException
1:133acbb:     {
1:133acbb:         StorageService ss = StorageService.instance;
1:133acbb:         TokenMetadata tmd = ss.getTokenMetadata();
1:133acbb:         tmd.clearUnsafe();
1:07893d7:         IPartitioner partitioner = RandomPartitioner.instance;
1:133acbb:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
1:133acbb: 
1:133acbb:         ArrayList<Token> endpointTokens = new ArrayList<Token>();
1:133acbb:         ArrayList<Token> keyTokens = new ArrayList<Token>();
1:133acbb:         List<InetAddress> hosts = new ArrayList<InetAddress>();
1:ad685c4:         List<UUID> hostIds = new ArrayList<UUID>();
1:133acbb: 
1:133acbb:         // create a ring or 5 nodes
1:ad685c4:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, 6);
1:133acbb: 
1:133acbb:         // node 2 leaves
1:66b96ee:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(Collections.singleton(endpointTokens.get(2))));
1:133acbb: 
1:133acbb:         assertTrue(tmd.isLeaving(hosts.get(2)));
1:3020555:         assertEquals(endpointTokens.get(2), tmd.getToken(hosts.get(2)));
1:133acbb: 
1:133acbb:         // back to normal
1:b475bc6:         Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(2))));
1:b475bc6:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(keyTokens.get(2))));
1:133acbb: 
1:133acbb:         assertTrue(tmd.getLeavingEndpoints().isEmpty());
1:3020555:         assertEquals(keyTokens.get(2), tmd.getToken(hosts.get(2)));
1:133acbb: 
1:133acbb:         // node 3 goes through leave and left and then jumps to normal at its new token
1:66b96ee:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(Collections.singleton(keyTokens.get(2))));
1:ab95f98:         ss.onChange(hosts.get(2), ApplicationState.STATUS,
1:66b96ee:                 valueFactory.left(Collections.singleton(keyTokens.get(2)), Gossiper.computeExpireTime()));
1:b475bc6:         Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(4))));
1:b475bc6:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(keyTokens.get(4))));
1:133acbb: 
1:133acbb:         assertTrue(tmd.getBootstrapTokens().isEmpty());
1:133acbb:         assertTrue(tmd.getLeavingEndpoints().isEmpty());
1:3020555:         assertEquals(keyTokens.get(4), tmd.getToken(hosts.get(2)));
1:133acbb:     }
1:133acbb: 
1:133acbb:     @Test
1:133acbb:     public void testStateJumpToLeaving() throws UnknownHostException
1:133acbb:     {
1:133acbb:         StorageService ss = StorageService.instance;
1:133acbb:         TokenMetadata tmd = ss.getTokenMetadata();
1:133acbb:         tmd.clearUnsafe();
1:07893d7:         IPartitioner partitioner = RandomPartitioner.instance;
1:133acbb:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
1:133acbb: 
1:133acbb:         ArrayList<Token> endpointTokens = new ArrayList<Token>();
1:133acbb:         ArrayList<Token> keyTokens = new ArrayList<Token>();
1:133acbb:         List<InetAddress> hosts = new ArrayList<InetAddress>();
1:ad685c4:         List<UUID> hostIds = new ArrayList<UUID>();
1:133acbb: 
1:133acbb:         // create a ring or 5 nodes
1:ad685c4:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, 6);
1:133acbb: 
1:133acbb:         // node 2 leaves with _different_ token
1:b475bc6:         Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(0))));
1:66b96ee:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(Collections.singleton(keyTokens.get(0))));
1:133acbb: 
1:3020555:         assertEquals(keyTokens.get(0), tmd.getToken(hosts.get(2)));
1:133acbb:         assertTrue(tmd.isLeaving(hosts.get(2)));
1:3020555:         assertNull(tmd.getEndpoint(endpointTokens.get(2)));
1:133acbb: 
1:133acbb:         // go to boostrap
1:b475bc6:         Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(1))));
1:66b96ee:         ss.onChange(hosts.get(2),
1:66b96ee:                     ApplicationState.STATUS,
1:b475bc6:                     valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(1))));
1:133acbb: 
1:133acbb:         assertFalse(tmd.isLeaving(hosts.get(2)));
1:3020555:         assertEquals(1, tmd.getBootstrapTokens().size());
1:3020555:         assertEquals(hosts.get(2), tmd.getBootstrapTokens().get(keyTokens.get(1)));
1:133acbb: 
1:133acbb:         // jump to leaving again
1:66b96ee:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(Collections.singleton(keyTokens.get(1))));
1:133acbb: 
1:3020555:         assertEquals(hosts.get(2), tmd.getEndpoint(keyTokens.get(1)));
1:133acbb:         assertTrue(tmd.isLeaving(hosts.get(2)));
1:133acbb:         assertTrue(tmd.getBootstrapTokens().isEmpty());
1:133acbb: 
1:133acbb:         // go to state left
1:ab95f98:         ss.onChange(hosts.get(2), ApplicationState.STATUS,
1:66b96ee:                 valueFactory.left(Collections.singleton(keyTokens.get(1)), Gossiper.computeExpireTime()));
1:133acbb: 
1:133acbb:         assertFalse(tmd.isMember(hosts.get(2)));
1:133acbb:         assertFalse(tmd.isLeaving(hosts.get(2)));
1:133acbb:     }
1:133acbb: 
1:133acbb:     @Test
1:133acbb:     public void testStateJumpToLeft() throws UnknownHostException
1:133acbb:     {
1:133acbb:         StorageService ss = StorageService.instance;
1:133acbb:         TokenMetadata tmd = ss.getTokenMetadata();
1:133acbb:         tmd.clearUnsafe();
1:07893d7:         IPartitioner partitioner = RandomPartitioner.instance;
1:133acbb:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
1:133acbb: 
1:133acbb:         ArrayList<Token> endpointTokens = new ArrayList<Token>();
1:133acbb:         ArrayList<Token> keyTokens = new ArrayList<Token>();
1:133acbb:         List<InetAddress> hosts = new ArrayList<InetAddress>();
1:ad685c4:         List<UUID> hostIds = new ArrayList<UUID>();
1:133acbb: 
1:133acbb:         // create a ring of 6 nodes
1:ad685c4:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, 7);
1:133acbb: 
1:133acbb:         // node hosts.get(2) goes jumps to left
1:ab95f98:         ss.onChange(hosts.get(2), ApplicationState.STATUS,
1:66b96ee:                 valueFactory.left(Collections.singleton(endpointTokens.get(2)), Gossiper.computeExpireTime()));
1:133acbb: 
1:133acbb:         assertFalse(tmd.isMember(hosts.get(2)));
1:133acbb: 
1:133acbb:         // node hosts.get(4) goes to bootstrap
1:b475bc6:         Gossiper.instance.injectApplicationState(hosts.get(3), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(1))));
1:b475bc6:         ss.onChange(hosts.get(3), ApplicationState.STATUS, valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(1))));
1:133acbb: 
1:133acbb:         assertFalse(tmd.isMember(hosts.get(3)));
1:3020555:         assertEquals(1, tmd.getBootstrapTokens().size());
1:3020555:         assertEquals(hosts.get(3), tmd.getBootstrapTokens().get(keyTokens.get(1)));
1:133acbb: 
1:133acbb:         // and then directly to 'left'
1:b475bc6:         Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(1))));
1:ab95f98:         ss.onChange(hosts.get(2), ApplicationState.STATUS,
1:66b96ee:                 valueFactory.left(Collections.singleton(keyTokens.get(1)), Gossiper.computeExpireTime()));
1:133acbb: 
1:133acbb:         assertTrue(tmd.getBootstrapTokens().size() == 0);
1:133acbb:         assertFalse(tmd.isMember(hosts.get(2)));
1:133acbb:         assertFalse(tmd.isLeaving(hosts.get(2)));
1:133acbb:     }
1:133acbb: 
1:c1c3d8f:     /**
1:c1c3d8f:      * Tests that the system.peers table is not updated after a node has been removed. (See CASSANDRA-6053)
1:c1c3d8f:      */
1:c612a36:     @Test
1:c1c3d8f:     public void testStateChangeOnRemovedNode() throws UnknownHostException
1:c612a36:     {
1:c612a36:         StorageService ss = StorageService.instance;
1:c612a36:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
1:133acbb: 
1:c1c3d8f:         // create a ring of 2 nodes
1:db69dce:         ArrayList<Token> endpointTokens = new ArrayList<>();
1:db69dce:         List<InetAddress> hosts = new ArrayList<>();
1:c1c3d8f:         Util.createInitialRing(ss, partitioner, endpointTokens, new ArrayList<Token>(), hosts, new ArrayList<UUID>(), 2);
1:133acbb: 
1:c1c3d8f:         InetAddress toRemove = hosts.get(1);
1:1147ee3:         SystemKeyspace.updatePeerInfo(toRemove, "data_center", "dc42");
1:1147ee3:         SystemKeyspace.updatePeerInfo(toRemove, "rack", "rack42");
1:db69dce:         assertEquals("rack42", SystemKeyspace.loadDcRackInfo().get(toRemove).get("rack"));
1:133acbb: 
1:c1c3d8f:         // mark the node as removed
1:c1c3d8f:         Gossiper.instance.injectApplicationState(toRemove, ApplicationState.STATUS,
1:c1c3d8f:                 valueFactory.left(Collections.singleton(endpointTokens.get(1)), Gossiper.computeExpireTime()));
1:c1c3d8f:         assertTrue(Gossiper.instance.isDeadState(Gossiper.instance.getEndpointStateForEndpoint(hosts.get(1))));
1:133acbb: 
1:c1c3d8f:         // state changes made after the endpoint has left should be ignored
1:c1c3d8f:         ss.onChange(hosts.get(1), ApplicationState.RACK,
1:c1c3d8f:                 valueFactory.rack("rack9999"));
1:db69dce:         assertEquals("rack42", SystemKeyspace.loadDcRackInfo().get(toRemove).get("rack"));
1:c612a36:     }
1:133acbb: 
1:a169863:     @Test
1:a169863:     public void testRemovingStatusForNonMember()  throws UnknownHostException
1:a169863:     {
1:a169863:         // create a ring of 1 node
1:a169863:         StorageService ss = StorageService.instance;
1:a169863:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
1:a991b64:         Util.createInitialRing(ss, partitioner, new ArrayList<Token>(), new ArrayList<Token>(), new ArrayList<InetAddress>(), new ArrayList<UUID>(), 1);
1:133acbb: 
1:a169863:         // make a REMOVING state change on a non-member endpoint; without the CASSANDRA-6564 fix, this
1:a169863:         // would result in an ArrayIndexOutOfBoundsException
1:a169863:         ss.onChange(InetAddress.getByName("192.168.1.42"), ApplicationState.STATUS, valueFactory.removingNonlocal(UUID.randomUUID()));
1:a169863:     }
1:133acbb: 
1:133acbb:     private static Collection<InetAddress> makeAddrs(String... hosts) throws UnknownHostException
1:133acbb:     {
1:133acbb:         ArrayList<InetAddress> addrs = new ArrayList<InetAddress>(hosts.length);
1:133acbb:         for (String host : hosts)
1:133acbb:             addrs.add(InetAddress.getByName(host));
1:133acbb:         return addrs;
1:133acbb:     }
1:133acbb: 
1:9639f95:     private AbstractReplicationStrategy getStrategy(String keyspaceName, TokenMetadata tmd)
1:133acbb:     {
1:a89597d:         KeyspaceMetadata ksmd = Schema.instance.getKSMetaData(keyspaceName);
1:133acbb:         return AbstractReplicationStrategy.createReplicationStrategy(
1:0e96e58:                 keyspaceName,
1:31e3f61:                 ksmd.params.replication.klass,
1:133acbb:                 tmd,
1:133acbb:                 new SimpleSnitch(),
1:31e3f61:                 ksmd.params.replication.options);
1:133acbb:     }
1:133acbb: 
1:133acbb: }
============================================================================
author:Robert Stupp
-------------------------------------------------------------------------------
commit:9797511
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.DatabaseDescriptor;
/////////////////////////////////////////////////////////////////////////
1:         DatabaseDescriptor.daemonInitialization();
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:a4e1182
/////////////////////////////////////////////////////////////////////////
1:         for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces())
/////////////////////////////////////////////////////////////////////////
1:         for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces())
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:0a08525
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.cassandra.Util.PartitionerSwitcher;
/////////////////////////////////////////////////////////////////////////
1:     private static PartitionerSwitcher partitionerSwitcher;
/////////////////////////////////////////////////////////////////////////
1:         partitionerSwitcher = Util.switchPartitioner(partitioner);
/////////////////////////////////////////////////////////////////////////
1:         partitionerSwitcher.close();
commit:a89597d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.schema.KeyspaceMetadata;
/////////////////////////////////////////////////////////////////////////
1:         KeyspaceMetadata ksmd = Schema.instance.getKSMetaData(keyspaceName);
commit:31e3f61
/////////////////////////////////////////////////////////////////////////
1:                 ksmd.params.replication.klass,
1:                 ksmd.params.replication.options);
commit:0e96e58
/////////////////////////////////////////////////////////////////////////
0:         for (String keyspaceName : Schema.instance.getNonSystemKeyspaces())
/////////////////////////////////////////////////////////////////////////
0:         for (String keyspaceName : Schema.instance.getNonSystemKeyspaces())
1:             strategy = getStrategy(keyspaceName, tmd);
1:                 HashSet<InetAddress> actual = new HashSet<InetAddress>(tmd.getWriteEndpoints(token, keyspaceName, strategy.calculateNaturalEndpoints(token, tmd.cloneOnlyTokenMap())));
/////////////////////////////////////////////////////////////////////////
1:         Map<String, AbstractReplicationStrategy> keyspaceStrategyMap = new HashMap<String, AbstractReplicationStrategy>();
0:             keyspaceStrategyMap.put("Keyspace" + i, getStrategy("Keyspace" + i, tmd));
/////////////////////////////////////////////////////////////////////////
1:         for (Map.Entry<String, AbstractReplicationStrategy> keyspaceStrategy : keyspaceStrategyMap.entrySet())
1:             String keyspaceName = keyspaceStrategy.getKey();
1:             AbstractReplicationStrategy strategy = keyspaceStrategy.getValue();
1:                 endpoints = tmd.getWriteEndpoints(keyTokens.get(i), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(i)));
0:                 assertTrue(expectedEndpoints.get(keyspaceName).get(keyTokens.get(i)).size() == endpoints.size());
1:                 assertTrue(expectedEndpoints.get(keyspaceName).get(keyTokens.get(i)).containsAll(endpoints));
/////////////////////////////////////////////////////////////////////////
1:                 endpoints = tmd.getWriteEndpoints(keyTokens.get(i), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(i)));
/////////////////////////////////////////////////////////////////////////
1:             endpoints = tmd.getWriteEndpoints(keyTokens.get(3), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(3)));
/////////////////////////////////////////////////////////////////////////
1:             endpoints = tmd.getWriteEndpoints(keyTokens.get(4), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(4)));
/////////////////////////////////////////////////////////////////////////
1:             endpoints = tmd.getWriteEndpoints(keyTokens.get(5), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(5)));
/////////////////////////////////////////////////////////////////////////
1:             endpoints = tmd.getWriteEndpoints(keyTokens.get(6), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(6)));
/////////////////////////////////////////////////////////////////////////
1:             endpoints = tmd.getWriteEndpoints(keyTokens.get(7), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(7)));
/////////////////////////////////////////////////////////////////////////
1:             endpoints = tmd.getWriteEndpoints(keyTokens.get(8), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(8)));
/////////////////////////////////////////////////////////////////////////
1:             endpoints = tmd.getWriteEndpoints(keyTokens.get(9), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(9)));
/////////////////////////////////////////////////////////////////////////
1:         for (Map.Entry<String, AbstractReplicationStrategy> keyspaceStrategy : keyspaceStrategyMap.entrySet())
1:             String keyspaceName = keyspaceStrategy.getKey();
1:             AbstractReplicationStrategy strategy = keyspaceStrategy.getValue();
1:                 endpoints = tmd.getWriteEndpoints(keyTokens.get(i), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(i)));
0:                 assertTrue(expectedEndpoints.get(keyspaceName).get(keyTokens.get(i)).size() == endpoints.size());
1:                 assertTrue(expectedEndpoints.get(keyspaceName).get(keyTokens.get(i)).containsAll(endpoints));
/////////////////////////////////////////////////////////////////////////
1:                 endpoints = tmd.getWriteEndpoints(keyTokens.get(i), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(i)));
/////////////////////////////////////////////////////////////////////////
1:             endpoints = tmd.getWriteEndpoints(keyTokens.get(3), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(3)));
1:             endpoints = tmd.getWriteEndpoints(keyTokens.get(4), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(4)));
1:             endpoints = tmd.getWriteEndpoints(keyTokens.get(5), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(5)));
/////////////////////////////////////////////////////////////////////////
1:             endpoints = tmd.getWriteEndpoints(keyTokens.get(6), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(6)));
/////////////////////////////////////////////////////////////////////////
1:             endpoints = tmd.getWriteEndpoints(keyTokens.get(7), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(7)));
/////////////////////////////////////////////////////////////////////////
1:             endpoints = tmd.getWriteEndpoints(keyTokens.get(8), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(8)));
1:             endpoints = tmd.getWriteEndpoints(keyTokens.get(9), keyspaceName, strategy.getNaturalEndpoints(keyTokens.get(9)));
/////////////////////////////////////////////////////////////////////////
0:     private AbstractReplicationStrategy getStrategy(String keyspaceName, TokenMetadata tmd) throws ConfigurationException
0:         KSMetaData ksmd = Schema.instance.getKSMetaData(keyspaceName);
1:                 keyspaceName,
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:a22ce89
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private static IPartitioner oldPartitioner;
/////////////////////////////////////////////////////////////////////////
0:         oldPartitioner = StorageService.instance.setPartitionerUnsafe(partitioner);
/////////////////////////////////////////////////////////////////////////
0:         StorageService.instance.setPartitionerUnsafe(oldPartitioner);
commit:a9bd531
/////////////////////////////////////////////////////////////////////////
0:     public static void setup() throws IOException, ConfigurationException
commit:893d1da
/////////////////////////////////////////////////////////////////////////
0:                 HashSet<InetAddress> actual = new HashSet<InetAddress>(tmd.getWriteEndpoints(token, table, strategy.calculateNaturalEndpoints(token, tmd.cloneOnlyTokenMap())));
commit:8c7bc2f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.KSMetaData;
/////////////////////////////////////////////////////////////////////////
0:         KSMetaData ksmd =  DatabaseDescriptor.getKSMetaData(table);
0:                 ksmd.strategyClass,
0:                 ksmd.strategyOptions);
commit:133acbb
/////////////////////////////////////////////////////////////////////////
1: /*
1: * Licensed to the Apache Software Foundation (ASF) under one
1: * or more contributor license agreements.  See the NOTICE file
1: * distributed with this work for additional information
1: * regarding copyright ownership.  The ASF licenses this file
1: * to you under the Apache License, Version 2.0 (the
1: * "License"); you may not use this file except in compliance
1: * with the License.  You may obtain a copy of the License at
1: *
1: *    http://www.apache.org/licenses/LICENSE-2.0
1: *
1: * Unless required by applicable law or agreed to in writing,
1: * software distributed under the License is distributed on an
1: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1: * KIND, either express or implied.  See the License for the
1: * specific language governing permissions and limitations
1: * under the License.
1: */
1: 
1: package org.apache.cassandra.service;
1: 
1: import java.net.InetAddress;
1: import java.net.UnknownHostException;
1: import java.util.*;
1: 
0: import org.apache.cassandra.config.ConfigurationException;
1: import org.junit.Test;
1: 
1: import static org.junit.Assert.*;
1: import com.google.common.collect.HashMultimap;
1: import com.google.common.collect.Multimap;
0: import org.apache.cassandra.CleanupHelper;
1: import org.apache.cassandra.Util;
0: import org.apache.cassandra.config.DatabaseDescriptor;
0: import org.apache.cassandra.dht.*;
1: import org.apache.cassandra.gms.ApplicationState;
1: import org.apache.cassandra.gms.VersionedValue;
1: import org.apache.cassandra.locator.AbstractReplicationStrategy;
1: import org.apache.cassandra.locator.SimpleSnitch;
1: import org.apache.cassandra.locator.TokenMetadata;
1: 
0: public class LeaveAndBootstrapTest extends CleanupHelper
1: {
1:     /**
1:      * Test whether write endpoints is correct when the node is leaving. Uses
1:      * StorageService.onChange and does not manipulate token metadata directly.
1:      */
1:     @Test
1:     public void newTestWriteEndpointsDuringLeave() throws Exception
1:     {
1:         StorageService ss = StorageService.instance;
1:         final int RING_SIZE = 6;
1:         final int LEAVING_NODE = 3;
1: 
1:         TokenMetadata tmd = ss.getTokenMetadata();
1:         tmd.clearUnsafe();
0:         IPartitioner partitioner = new RandomPartitioner();
1:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
1: 
0:         IPartitioner oldPartitioner = ss.setPartitionerUnsafe(partitioner);
1: 
1:         ArrayList<Token> endpointTokens = new ArrayList<Token>();
1:         ArrayList<Token> keyTokens = new ArrayList<Token>();
1:         List<InetAddress> hosts = new ArrayList<InetAddress>();
1: 
0:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, RING_SIZE);
1: 
1:         Map<Token, List<InetAddress>> expectedEndpoints = new HashMap<Token, List<InetAddress>>();
0:         for (String table : DatabaseDescriptor.getNonSystemTables())
1:         {
1:             for (Token token : keyTokens)
1:             {
1:                 List<InetAddress> endpoints = new ArrayList<InetAddress>();
1:                 Iterator<Token> tokenIter = TokenMetadata.ringIterator(tmd.sortedTokens(), token, false);
1:                 while (tokenIter.hasNext())
1:                 {
1:                     endpoints.add(tmd.getEndpoint(tokenIter.next()));
1:                 }
1:                 expectedEndpoints.put(token, endpoints);
1:             }
1:         }
1: 
1:         // Third node leaves
1:         ss.onChange(hosts.get(LEAVING_NODE),
1:                 ApplicationState.STATUS,
0:                 valueFactory.leaving(endpointTokens.get(LEAVING_NODE)));
1:         assertTrue(tmd.isLeaving(hosts.get(LEAVING_NODE)));
1: 
1:         AbstractReplicationStrategy strategy;
0:         for (String table : DatabaseDescriptor.getNonSystemTables())
1:         {
0:             strategy = getStrategy(table, tmd);
1:             for (Token token : keyTokens)
1:             {
1:                 int replicationFactor = strategy.getReplicationFactor();
1: 
0:                 HashSet<InetAddress> actual = new HashSet<InetAddress>(tmd.getWriteEndpoints(token, table, strategy.calculateNaturalEndpoints(token, tmd)));
1:                 HashSet<InetAddress> expected = new HashSet<InetAddress>();
1: 
1:                 for (int i = 0; i < replicationFactor; i++)
1:                 {
1:                     expected.add(expectedEndpoints.get(token).get(i));
1:                 }
1: 
1:                 // if the leaving node is in the endpoint list,
1:                 // then we should expect it plus one extra for when it's gone
1:                 if (expected.contains(hosts.get(LEAVING_NODE)))
1:                     expected.add(expectedEndpoints.get(token).get(replicationFactor));
1: 
1:                 assertEquals("mismatched endpoint sets", expected, actual);
1:             }
1:         }
1: 
0:         ss.setPartitionerUnsafe(oldPartitioner);
1:     }
1: 
1:     /**
1:      * Test pending ranges and write endpoints when multiple nodes are on the move
1:      * simultaneously
1:      */
1:     @Test
0:     public void testSimultaneousMove() throws UnknownHostException, ConfigurationException
1:     {
1:         StorageService ss = StorageService.instance;
1:         final int RING_SIZE = 10;
1:         TokenMetadata tmd = ss.getTokenMetadata();
1:         tmd.clearUnsafe();
0:         IPartitioner partitioner = new RandomPartitioner();
1:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
1: 
0:         IPartitioner oldPartitioner = ss.setPartitionerUnsafe(partitioner);
1: 
1:         ArrayList<Token> endpointTokens = new ArrayList<Token>();
1:         ArrayList<Token> keyTokens = new ArrayList<Token>();
1:         List<InetAddress> hosts = new ArrayList<InetAddress>();
1: 
1:         // create a ring or 10 nodes
0:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, RING_SIZE);
1: 
1:         // nodes 6, 8 and 9 leave
1:         final int[] LEAVING = new int[] {6, 8, 9};
1:         for (int leaving : LEAVING)
0:             ss.onChange(hosts.get(leaving), ApplicationState.STATUS, valueFactory.leaving(endpointTokens.get(leaving)));
1: 
1:         // boot two new nodes with keyTokens.get(5) and keyTokens.get(7)
1:         InetAddress boot1 = InetAddress.getByName("127.0.1.1");
0:         ss.onChange(boot1, ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(5)));
1:         InetAddress boot2 = InetAddress.getByName("127.0.1.2");
0:         ss.onChange(boot2, ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(7)));
1: 
1:         Collection<InetAddress> endpoints = null;
1: 
1:         /* don't require test update every time a new keyspace is added to test/conf/cassandra.yaml */
0:         Map<String, AbstractReplicationStrategy> tableStrategyMap = new HashMap<String, AbstractReplicationStrategy>();
1:         for (int i=1; i<=4; i++)
1:         {
0:             tableStrategyMap.put("Keyspace" + i, getStrategy("Keyspace" + i, tmd));
1:         }
1: 
1:         // pre-calculate the results.
1:         Map<String, Multimap<Token, InetAddress>> expectedEndpoints = new HashMap<String, Multimap<Token, InetAddress>>();
0:         expectedEndpoints.put("Keyspace1", HashMultimap.<Token, InetAddress>create());
0:         expectedEndpoints.get("Keyspace1").putAll(new BigIntegerToken("5"), makeAddrs("127.0.0.2"));
0:         expectedEndpoints.get("Keyspace1").putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3"));
0:         expectedEndpoints.get("Keyspace1").putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4"));
0:         expectedEndpoints.get("Keyspace1").putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5"));
0:         expectedEndpoints.get("Keyspace1").putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6"));
0:         expectedEndpoints.get("Keyspace1").putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.1.1"));
0:         expectedEndpoints.get("Keyspace1").putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.8"));
0:         expectedEndpoints.get("Keyspace1").putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.1.2", "127.0.0.1"));
0:         expectedEndpoints.get("Keyspace1").putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.10", "127.0.0.1"));
0:         expectedEndpoints.get("Keyspace1").putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.1"));
0:         expectedEndpoints.put("Keyspace2", HashMultimap.<Token, InetAddress>create());
0:         expectedEndpoints.get("Keyspace2").putAll(new BigIntegerToken("5"), makeAddrs("127.0.0.2"));
0:         expectedEndpoints.get("Keyspace2").putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3"));
0:         expectedEndpoints.get("Keyspace2").putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4"));
0:         expectedEndpoints.get("Keyspace2").putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5"));
0:         expectedEndpoints.get("Keyspace2").putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6"));
0:         expectedEndpoints.get("Keyspace2").putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.1.1"));
0:         expectedEndpoints.get("Keyspace2").putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.8"));
0:         expectedEndpoints.get("Keyspace2").putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.1.2", "127.0.0.1"));
0:         expectedEndpoints.get("Keyspace2").putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.10", "127.0.0.1"));
0:         expectedEndpoints.get("Keyspace2").putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.1"));
0:         expectedEndpoints.put("Keyspace3", HashMultimap.<Token, InetAddress>create());
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("5"), makeAddrs("127.0.0.2", "127.0.0.3", "127.0.0.4", "127.0.0.5", "127.0.0.6"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3", "127.0.0.4", "127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.1.1", "127.0.0.8"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4", "127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.1.2", "127.0.0.1", "127.0.1.1"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.1.2", "127.0.0.1", "127.0.0.2", "127.0.1.1"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.1.2", "127.0.0.1", "127.0.0.2", "127.0.1.1", "127.0.0.3"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.0.3", "127.0.0.4", "127.0.1.1", "127.0.1.2"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.1.2", "127.0.0.3", "127.0.0.4"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.0.3", "127.0.1.2", "127.0.0.4", "127.0.0.5"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.0.3", "127.0.0.4", "127.0.0.5"));
0:         expectedEndpoints.get("Keyspace3").putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.1", "127.0.0.2", "127.0.0.3", "127.0.0.4", "127.0.0.5"));
0:         expectedEndpoints.put("Keyspace4", HashMultimap.<Token, InetAddress>create());
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("5"), makeAddrs("127.0.0.2", "127.0.0.3", "127.0.0.4"));
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3", "127.0.0.4", "127.0.0.5"));
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4", "127.0.0.5", "127.0.0.6"));
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.1.1", "127.0.0.8"));
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.1.2", "127.0.0.1", "127.0.1.1"));
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.0.1", "127.0.0.2", "127.0.1.1", "127.0.1.2"));
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.1.2", "127.0.0.1", "127.0.0.2"));
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.1.2", "127.0.0.2", "127.0.0.3"));
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.0.3"));
0:         expectedEndpoints.get("Keyspace4").putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.1", "127.0.0.2", "127.0.0.3"));
1: 
0:         for (Map.Entry<String, AbstractReplicationStrategy> tableStrategy : tableStrategyMap.entrySet())
1:         {
0:             String table = tableStrategy.getKey();
0:             AbstractReplicationStrategy strategy = tableStrategy.getValue();
1: 
1:             for (int i = 0; i < keyTokens.size(); i++)
1:             {
0:                 endpoints = tmd.getWriteEndpoints(keyTokens.get(i), table, strategy.getNaturalEndpoints(keyTokens.get(i)));
0:                 assertTrue(expectedEndpoints.get(table).get(keyTokens.get(i)).size() == endpoints.size());
0:                 assertTrue(expectedEndpoints.get(table).get(keyTokens.get(i)).containsAll(endpoints));
1:             }
1: 
1:             // just to be sure that things still work according to the old tests, run them:
1:             if (strategy.getReplicationFactor() != 3)
1:                 continue;
1:             // tokens 5, 15 and 25 should go three nodes
1:             for (int i=0; i<3; ++i)
1:             {
0:                 endpoints = tmd.getWriteEndpoints(keyTokens.get(i), table, strategy.getNaturalEndpoints(keyTokens.get(i)));
0:                 assertTrue(endpoints.size() == 3);
1:                 assertTrue(endpoints.contains(hosts.get(i+1)));
1:                 assertTrue(endpoints.contains(hosts.get(i+2)));
1:                 assertTrue(endpoints.contains(hosts.get(i+3)));
1:             }
1: 
1:             // token 35 should go to nodes 4, 5, 6, 7 and boot1
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(3), table, strategy.getNaturalEndpoints(keyTokens.get(3)));
0:             assertTrue(endpoints.size() == 5);
1:             assertTrue(endpoints.contains(hosts.get(4)));
1:             assertTrue(endpoints.contains(hosts.get(5)));
1:             assertTrue(endpoints.contains(hosts.get(6)));
1:             assertTrue(endpoints.contains(hosts.get(7)));
1:             assertTrue(endpoints.contains(boot1));
1: 
1:             // token 45 should go to nodes 5, 6, 7, 0, boot1 and boot2
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(4), table, strategy.getNaturalEndpoints(keyTokens.get(4)));
0:             assertTrue(endpoints.size() == 6);
1:             assertTrue(endpoints.contains(hosts.get(5)));
1:             assertTrue(endpoints.contains(hosts.get(6)));
1:             assertTrue(endpoints.contains(hosts.get(7)));
1:             assertTrue(endpoints.contains(hosts.get(0)));
1:             assertTrue(endpoints.contains(boot1));
1:             assertTrue(endpoints.contains(boot2));
1: 
1:             // token 55 should go to nodes 6, 7, 8, 0, 1, boot1 and boot2
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(5), table, strategy.getNaturalEndpoints(keyTokens.get(5)));
0:             assertTrue(endpoints.size() == 7);
1:             assertTrue(endpoints.contains(hosts.get(6)));
1:             assertTrue(endpoints.contains(hosts.get(7)));
1:             assertTrue(endpoints.contains(hosts.get(8)));
1:             assertTrue(endpoints.contains(hosts.get(0)));
1:             assertTrue(endpoints.contains(hosts.get(1)));
1:             assertTrue(endpoints.contains(boot1));
1:             assertTrue(endpoints.contains(boot2));
1: 
1:             // token 65 should go to nodes 7, 8, 9, 0, 1 and boot2
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(6), table, strategy.getNaturalEndpoints(keyTokens.get(6)));
0:             assertTrue(endpoints.size() == 6);
1:             assertTrue(endpoints.contains(hosts.get(7)));
1:             assertTrue(endpoints.contains(hosts.get(8)));
1:             assertTrue(endpoints.contains(hosts.get(9)));
1:             assertTrue(endpoints.contains(hosts.get(0)));
1:             assertTrue(endpoints.contains(hosts.get(1)));
1:             assertTrue(endpoints.contains(boot2));
1: 
1:             // token 75 should to go nodes 8, 9, 0, 1, 2 and boot2
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(7), table, strategy.getNaturalEndpoints(keyTokens.get(7)));
0:             assertTrue(endpoints.size() == 6);
1:             assertTrue(endpoints.contains(hosts.get(8)));
1:             assertTrue(endpoints.contains(hosts.get(9)));
1:             assertTrue(endpoints.contains(hosts.get(0)));
1:             assertTrue(endpoints.contains(hosts.get(1)));
1:             assertTrue(endpoints.contains(hosts.get(2)));
1:             assertTrue(endpoints.contains(boot2));
1: 
1:             // token 85 should go to nodes 9, 0, 1 and 2
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(8), table, strategy.getNaturalEndpoints(keyTokens.get(8)));
0:             assertTrue(endpoints.size() == 4);
1:             assertTrue(endpoints.contains(hosts.get(9)));
1:             assertTrue(endpoints.contains(hosts.get(0)));
1:             assertTrue(endpoints.contains(hosts.get(1)));
1:             assertTrue(endpoints.contains(hosts.get(2)));
1: 
1:             // token 95 should go to nodes 0, 1 and 2
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(9), table, strategy.getNaturalEndpoints(keyTokens.get(9)));
0:             assertTrue(endpoints.size() == 3);
1:             assertTrue(endpoints.contains(hosts.get(0)));
1:             assertTrue(endpoints.contains(hosts.get(1)));
1:             assertTrue(endpoints.contains(hosts.get(2)));
1: 
1:         }
1: 
1:         // Now finish node 6 and node 9 leaving, as well as boot1 (after this node 8 is still
1:         // leaving and boot2 in progress
0:         ss.onChange(hosts.get(LEAVING[0]), ApplicationState.STATUS, valueFactory.left(endpointTokens.get(LEAVING[0])));
0:         ss.onChange(hosts.get(LEAVING[2]), ApplicationState.STATUS, valueFactory.left(endpointTokens.get(LEAVING[2])));
0:         ss.onChange(boot1, ApplicationState.STATUS, valueFactory.normal(keyTokens.get(5)));
1: 
1:         // adjust precalcuated results.  this changes what the epected endpoints are.
0:         expectedEndpoints.get("Keyspace1").get(new BigIntegerToken("55")).removeAll(makeAddrs("127.0.0.7", "127.0.0.8"));
0:         expectedEndpoints.get("Keyspace1").get(new BigIntegerToken("85")).removeAll(makeAddrs("127.0.0.10"));
0:         expectedEndpoints.get("Keyspace2").get(new BigIntegerToken("55")).removeAll(makeAddrs("127.0.0.7", "127.0.0.8"));
0:         expectedEndpoints.get("Keyspace2").get(new BigIntegerToken("85")).removeAll(makeAddrs("127.0.0.10"));
0:         expectedEndpoints.get("Keyspace3").get(new BigIntegerToken("15")).removeAll(makeAddrs("127.0.0.7", "127.0.0.8"));
0:         expectedEndpoints.get("Keyspace3").get(new BigIntegerToken("25")).removeAll(makeAddrs("127.0.0.7", "127.0.1.2", "127.0.0.1"));
0:         expectedEndpoints.get("Keyspace3").get(new BigIntegerToken("35")).removeAll(makeAddrs("127.0.0.7", "127.0.0.2"));
0:         expectedEndpoints.get("Keyspace3").get(new BigIntegerToken("45")).removeAll(makeAddrs("127.0.0.7", "127.0.0.10", "127.0.0.3"));
0:         expectedEndpoints.get("Keyspace3").get(new BigIntegerToken("55")).removeAll(makeAddrs("127.0.0.7", "127.0.0.10", "127.0.0.4"));
0:         expectedEndpoints.get("Keyspace3").get(new BigIntegerToken("65")).removeAll(makeAddrs("127.0.0.10"));
0:         expectedEndpoints.get("Keyspace3").get(new BigIntegerToken("75")).removeAll(makeAddrs("127.0.0.10"));
0:         expectedEndpoints.get("Keyspace3").get(new BigIntegerToken("85")).removeAll(makeAddrs("127.0.0.10"));
0:         expectedEndpoints.get("Keyspace4").get(new BigIntegerToken("35")).removeAll(makeAddrs("127.0.0.7", "127.0.0.8"));
0:         expectedEndpoints.get("Keyspace4").get(new BigIntegerToken("45")).removeAll(makeAddrs("127.0.0.7", "127.0.1.2", "127.0.0.1"));
0:         expectedEndpoints.get("Keyspace4").get(new BigIntegerToken("55")).removeAll(makeAddrs("127.0.0.2", "127.0.0.7"));
0:         expectedEndpoints.get("Keyspace4").get(new BigIntegerToken("65")).removeAll(makeAddrs("127.0.0.10"));
0:         expectedEndpoints.get("Keyspace4").get(new BigIntegerToken("75")).removeAll(makeAddrs("127.0.0.10"));
0:         expectedEndpoints.get("Keyspace4").get(new BigIntegerToken("85")).removeAll(makeAddrs("127.0.0.10"));
1: 
0:         for (Map.Entry<String, AbstractReplicationStrategy> tableStrategy : tableStrategyMap.entrySet())
1:         {
0:             String table = tableStrategy.getKey();
0:             AbstractReplicationStrategy strategy = tableStrategy.getValue();
1: 
1:             for (int i = 0; i < keyTokens.size(); i++)
1:             {
0:                 endpoints = tmd.getWriteEndpoints(keyTokens.get(i), table, strategy.getNaturalEndpoints(keyTokens.get(i)));
0:                 assertTrue(expectedEndpoints.get(table).get(keyTokens.get(i)).size() == endpoints.size());
0:                 assertTrue(expectedEndpoints.get(table).get(keyTokens.get(i)).containsAll(endpoints));
1:             }
1: 
1:             if (strategy.getReplicationFactor() != 3)
1:                 continue;
1:             // leave this stuff in to guarantee the old tests work the way they were supposed to.
1:             // tokens 5, 15 and 25 should go three nodes
1:             for (int i=0; i<3; ++i)
1:             {
0:                 endpoints = tmd.getWriteEndpoints(keyTokens.get(i), table, strategy.getNaturalEndpoints(keyTokens.get(i)));
0:                 assertTrue(endpoints.size() == 3);
1:                 assertTrue(endpoints.contains(hosts.get(i+1)));
1:                 assertTrue(endpoints.contains(hosts.get(i+2)));
1:                 assertTrue(endpoints.contains(hosts.get(i+3)));
1:             }
1: 
1:             // token 35 goes to nodes 4, 5 and boot1
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(3), table, strategy.getNaturalEndpoints(keyTokens.get(3)));
0:             assertTrue(endpoints.size() == 3);
1:             assertTrue(endpoints.contains(hosts.get(4)));
1:             assertTrue(endpoints.contains(hosts.get(5)));
1:             assertTrue(endpoints.contains(boot1));
1: 
1:             // token 45 goes to nodes 5, boot1 and node7
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(4), table, strategy.getNaturalEndpoints(keyTokens.get(4)));
0:             assertTrue(endpoints.size() == 3);
1:             assertTrue(endpoints.contains(hosts.get(5)));
1:             assertTrue(endpoints.contains(boot1));
1:             assertTrue(endpoints.contains(hosts.get(7)));
1: 
1:             // token 55 goes to boot1, 7, boot2, 8 and 0
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(5), table, strategy.getNaturalEndpoints(keyTokens.get(5)));
0:             assertTrue(endpoints.size() == 5);
1:             assertTrue(endpoints.contains(boot1));
1:             assertTrue(endpoints.contains(hosts.get(7)));
1:             assertTrue(endpoints.contains(boot2));
1:             assertTrue(endpoints.contains(hosts.get(8)));
1:             assertTrue(endpoints.contains(hosts.get(0)));
1: 
1:             // token 65 goes to nodes 7, boot2, 8, 0 and 1
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(6), table, strategy.getNaturalEndpoints(keyTokens.get(6)));
0:             assertTrue(endpoints.size() == 5);
1:             assertTrue(endpoints.contains(hosts.get(7)));
1:             assertTrue(endpoints.contains(boot2));
1:             assertTrue(endpoints.contains(hosts.get(8)));
1:             assertTrue(endpoints.contains(hosts.get(0)));
1:             assertTrue(endpoints.contains(hosts.get(1)));
1: 
1:             // token 75 goes to nodes boot2, 8, 0, 1 and 2
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(7), table, strategy.getNaturalEndpoints(keyTokens.get(7)));
0:             assertTrue(endpoints.size() == 5);
1:             assertTrue(endpoints.contains(boot2));
1:             assertTrue(endpoints.contains(hosts.get(8)));
1:             assertTrue(endpoints.contains(hosts.get(0)));
1:             assertTrue(endpoints.contains(hosts.get(1)));
1:             assertTrue(endpoints.contains(hosts.get(2)));
1: 
1:             // token 85 goes to nodes 0, 1 and 2
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(8), table, strategy.getNaturalEndpoints(keyTokens.get(8)));
0:             assertTrue(endpoints.size() == 3);
1:             assertTrue(endpoints.contains(hosts.get(0)));
1:             assertTrue(endpoints.contains(hosts.get(1)));
1:             assertTrue(endpoints.contains(hosts.get(2)));
1: 
1:             // token 95 goes to nodes 0, 1 and 2
0:             endpoints = tmd.getWriteEndpoints(keyTokens.get(9), table, strategy.getNaturalEndpoints(keyTokens.get(9)));
0:             assertTrue(endpoints.size() == 3);
1:             assertTrue(endpoints.contains(hosts.get(0)));
1:             assertTrue(endpoints.contains(hosts.get(1)));
1:             assertTrue(endpoints.contains(hosts.get(2)));
1:         }
1: 
0:         ss.setPartitionerUnsafe(oldPartitioner);
1:     }
1: 
1:     @Test
1:     public void testStateJumpToBootstrap() throws UnknownHostException
1:     {
1:         StorageService ss = StorageService.instance;
1:         TokenMetadata tmd = ss.getTokenMetadata();
1:         tmd.clearUnsafe();
0:         IPartitioner partitioner = new RandomPartitioner();
1:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
1: 
0:         IPartitioner oldPartitioner = ss.setPartitionerUnsafe(partitioner);
1: 
1:         ArrayList<Token> endpointTokens = new ArrayList<Token>();
1:         ArrayList<Token> keyTokens = new ArrayList<Token>();
1:         List<InetAddress> hosts = new ArrayList<InetAddress>();
1: 
1:         // create a ring or 5 nodes
0:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, 7);
1: 
1:         // node 2 leaves
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(endpointTokens.get(2)));
1: 
1:         // don't bother to test pending ranges here, that is extensively tested by other
1:         // tests. Just check that the node is in appropriate lists.
1:         assertTrue(tmd.isMember(hosts.get(2)));
1:         assertTrue(tmd.isLeaving(hosts.get(2)));
1:         assertTrue(tmd.getBootstrapTokens().isEmpty());
1: 
1:         // Bootstrap the node immedidiately to keyTokens.get(4) without going through STATE_LEFT
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(4)));
1: 
1:         assertFalse(tmd.isMember(hosts.get(2)));
1:         assertFalse(tmd.isLeaving(hosts.get(2)));
0:         assertTrue(tmd.getBootstrapTokens().get(keyTokens.get(4)).equals(hosts.get(2)));
1: 
1:         // Bootstrap node hosts.get(3) to keyTokens.get(1)
0:         ss.onChange(hosts.get(3), ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(1)));
1: 
1:         assertFalse(tmd.isMember(hosts.get(3)));
1:         assertFalse(tmd.isLeaving(hosts.get(3)));
0:         assertTrue(tmd.getBootstrapTokens().get(keyTokens.get(4)).equals(hosts.get(2)));
0:         assertTrue(tmd.getBootstrapTokens().get(keyTokens.get(1)).equals(hosts.get(3)));
1: 
1:         // Bootstrap node hosts.get(2) further to keyTokens.get(3)
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(3)));
1: 
1:         assertFalse(tmd.isMember(hosts.get(2)));
1:         assertFalse(tmd.isLeaving(hosts.get(2)));
0:         assertTrue(tmd.getBootstrapTokens().get(keyTokens.get(3)).equals(hosts.get(2)));
0:         assertTrue(tmd.getBootstrapTokens().get(keyTokens.get(4)) == null);
0:         assertTrue(tmd.getBootstrapTokens().get(keyTokens.get(1)).equals(hosts.get(3)));
1: 
1:         // Go to normal again for both nodes
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(keyTokens.get(3)));
0:         ss.onChange(hosts.get(3), ApplicationState.STATUS, valueFactory.normal(keyTokens.get(2)));
1: 
1:         assertTrue(tmd.isMember(hosts.get(2)));
1:         assertFalse(tmd.isLeaving(hosts.get(2)));
0:         assertTrue(tmd.getToken(hosts.get(2)).equals(keyTokens.get(3)));
1:         assertTrue(tmd.isMember(hosts.get(3)));
1:         assertFalse(tmd.isLeaving(hosts.get(3)));
0:         assertTrue(tmd.getToken(hosts.get(3)).equals(keyTokens.get(2)));
1: 
1:         assertTrue(tmd.getBootstrapTokens().isEmpty());
1: 
0:         ss.setPartitionerUnsafe(oldPartitioner);
1:     }
1: 
1:     @Test
1:     public void testStateJumpToNormal() throws UnknownHostException
1:     {
1:         StorageService ss = StorageService.instance;
1:         TokenMetadata tmd = ss.getTokenMetadata();
1:         tmd.clearUnsafe();
0:         IPartitioner partitioner = new RandomPartitioner();
1:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
1: 
0:         IPartitioner oldPartitioner = ss.setPartitionerUnsafe(partitioner);
1: 
1:         ArrayList<Token> endpointTokens = new ArrayList<Token>();
1:         ArrayList<Token> keyTokens = new ArrayList<Token>();
1:         List<InetAddress> hosts = new ArrayList<InetAddress>();
1: 
1:         // create a ring or 5 nodes
0:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, 6);
1: 
1:         // node 2 leaves
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(endpointTokens.get(2)));
1: 
1:         assertTrue(tmd.isLeaving(hosts.get(2)));
0:         assertTrue(tmd.getToken(hosts.get(2)).equals(endpointTokens.get(2)));
1: 
1:         // back to normal
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(keyTokens.get(2)));
1: 
1:         assertTrue(tmd.getLeavingEndpoints().isEmpty());
0:         assertTrue(tmd.getToken(hosts.get(2)).equals(keyTokens.get(2)));
1: 
1:         // node 3 goes through leave and left and then jumps to normal at its new token
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(keyTokens.get(2)));
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.left(keyTokens.get(2)));
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(keyTokens.get(4)));
1: 
1:         assertTrue(tmd.getBootstrapTokens().isEmpty());
1:         assertTrue(tmd.getLeavingEndpoints().isEmpty());
0:         assertTrue(tmd.getToken(hosts.get(2)).equals(keyTokens.get(4)));
1: 
0:         ss.setPartitionerUnsafe(oldPartitioner);
1:     }
1: 
1:     @Test
1:     public void testStateJumpToLeaving() throws UnknownHostException
1:     {
1:         StorageService ss = StorageService.instance;
1:         TokenMetadata tmd = ss.getTokenMetadata();
1:         tmd.clearUnsafe();
0:         IPartitioner partitioner = new RandomPartitioner();
1:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
1: 
0:         IPartitioner oldPartitioner = ss.setPartitionerUnsafe(partitioner);
1: 
1:         ArrayList<Token> endpointTokens = new ArrayList<Token>();
1:         ArrayList<Token> keyTokens = new ArrayList<Token>();
1:         List<InetAddress> hosts = new ArrayList<InetAddress>();
1: 
1:         // create a ring or 5 nodes
0:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, 6);
1: 
1:         // node 2 leaves with _different_ token
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(keyTokens.get(0)));
1: 
0:         assertTrue(tmd.getToken(hosts.get(2)).equals(keyTokens.get(0)));
1:         assertTrue(tmd.isLeaving(hosts.get(2)));
0:         assertTrue(tmd.getEndpoint(endpointTokens.get(2)) == null);
1: 
1:         // go to boostrap
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(1)));
1: 
1:         assertFalse(tmd.isLeaving(hosts.get(2)));
0:         assertTrue(tmd.getBootstrapTokens().size() == 1);
0:         assertTrue(tmd.getBootstrapTokens().get(keyTokens.get(1)).equals(hosts.get(2)));
1: 
1:         // jump to leaving again
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(keyTokens.get(1)));
1: 
0:         assertTrue(tmd.getEndpoint(keyTokens.get(1)).equals(hosts.get(2)));
1:         assertTrue(tmd.isLeaving(hosts.get(2)));
1:         assertTrue(tmd.getBootstrapTokens().isEmpty());
1: 
1:         // go to state left
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.left(keyTokens.get(1)));
1: 
1:         assertFalse(tmd.isMember(hosts.get(2)));
1:         assertFalse(tmd.isLeaving(hosts.get(2)));
1: 
0:         ss.setPartitionerUnsafe(oldPartitioner);
1:     }
1: 
1:     @Test
1:     public void testStateJumpToLeft() throws UnknownHostException
1:     {
1:         StorageService ss = StorageService.instance;
1:         TokenMetadata tmd = ss.getTokenMetadata();
1:         tmd.clearUnsafe();
0:         IPartitioner partitioner = new RandomPartitioner();
1:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
1: 
0:         IPartitioner oldPartitioner = ss.setPartitionerUnsafe(partitioner);
1: 
1:         ArrayList<Token> endpointTokens = new ArrayList<Token>();
1:         ArrayList<Token> keyTokens = new ArrayList<Token>();
1:         List<InetAddress> hosts = new ArrayList<InetAddress>();
1: 
1:         // create a ring of 6 nodes
0:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, 7);
1: 
1:         // node hosts.get(2) goes jumps to left
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.left(endpointTokens.get(2)));
1: 
1:         assertFalse(tmd.isMember(hosts.get(2)));
1: 
1:         // node hosts.get(4) goes to bootstrap
0:         ss.onChange(hosts.get(3), ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(1)));
1: 
1:         assertFalse(tmd.isMember(hosts.get(3)));
0:         assertTrue(tmd.getBootstrapTokens().size() == 1);
0:         assertTrue(tmd.getBootstrapTokens().get(keyTokens.get(1)).equals(hosts.get(3)));
1: 
1:         // and then directly to 'left'
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.left(keyTokens.get(1)));
1: 
1:         assertTrue(tmd.getBootstrapTokens().size() == 0);
1:         assertFalse(tmd.isMember(hosts.get(2)));
1:         assertFalse(tmd.isLeaving(hosts.get(2)));
1: 
0:         ss.setPartitionerUnsafe(oldPartitioner);
1:     }
1: 
1:     private static Collection<InetAddress> makeAddrs(String... hosts) throws UnknownHostException
1:     {
1:         ArrayList<InetAddress> addrs = new ArrayList<InetAddress>(hosts.length);
1:         for (String host : hosts)
1:             addrs.add(InetAddress.getByName(host));
1:         return addrs;
1:     }
1: 
0:     private AbstractReplicationStrategy getStrategy(String table, TokenMetadata tmd) throws ConfigurationException
1:     {
1:         return AbstractReplicationStrategy.createReplicationStrategy(
0:                 table,
0:                 "org.apache.cassandra.locator.SimpleStrategy",
1:                 tmd,
1:                 new SimpleSnitch(),
0:                 null);
1:     }
1: 
1: }
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:69f77cb
/////////////////////////////////////////////////////////////////////////
1: 
0: import org.apache.cassandra.Util.PartitionerSwitcher;
/////////////////////////////////////////////////////////////////////////
0:     private static PartitionerSwitcher partitionerSwitcher;
/////////////////////////////////////////////////////////////////////////
0:         partitionerSwitcher = Util.switchPartitioner(partitioner);
/////////////////////////////////////////////////////////////////////////
0:         partitionerSwitcher.close();
commit:07893d7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.dht.RandomPartitioner.BigIntegerToken;
/////////////////////////////////////////////////////////////////////////
1:     private static final IPartitioner partitioner = RandomPartitioner.instance;
/////////////////////////////////////////////////////////////////////////
1:         IPartitioner partitioner = RandomPartitioner.instance;
/////////////////////////////////////////////////////////////////////////
1:         IPartitioner partitioner = RandomPartitioner.instance;
/////////////////////////////////////////////////////////////////////////
1:         IPartitioner partitioner = RandomPartitioner.instance;
/////////////////////////////////////////////////////////////////////////
1:         IPartitioner partitioner = RandomPartitioner.instance;
/////////////////////////////////////////////////////////////////////////
1:         IPartitioner partitioner = RandomPartitioner.instance;
/////////////////////////////////////////////////////////////////////////
1:         IPartitioner partitioner = RandomPartitioner.instance;
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: import org.junit.AfterClass;
1: import org.junit.BeforeClass;
0: import org.junit.Test;
1: 
1: import org.apache.cassandra.dht.IPartitioner;
1: import org.apache.cassandra.dht.RandomPartitioner;
1: import org.apache.cassandra.dht.Token;
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.*;
0: 
/////////////////////////////////////////////////////////////////////////
1:         Util.createInitialRing(ss, partitioner, new ArrayList<Token>(), new ArrayList<Token>(), new ArrayList<InetAddress>(), new ArrayList<UUID>(), 1);
commit:1147ee3
/////////////////////////////////////////////////////////////////////////
1:         SystemKeyspace.updatePeerInfo(toRemove, "data_center", "dc42");
1:         SystemKeyspace.updatePeerInfo(toRemove, "rack", "rack42");
commit:71a5127
commit:723792d
commit:6b1fb2c
commit:eeb8d1b
/////////////////////////////////////////////////////////////////////////
1:         PendingRangeCalculatorService.instance.blockUntilFinished();
0: 
/////////////////////////////////////////////////////////////////////////
1:         PendingRangeCalculatorService.instance.blockUntilFinished();
0: 
/////////////////////////////////////////////////////////////////////////
1:         PendingRangeCalculatorService.instance.blockUntilFinished();
0: 
commit:3a2faf9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.exceptions.ConfigurationException;
commit:438acfc
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
0: import org.junit.AfterClass;
0: import org.junit.BeforeClass;
1: import org.apache.cassandra.SchemaLoader;
/////////////////////////////////////////////////////////////////////////
1: public class LeaveAndBootstrapTest
0:     private static final IPartitioner partitioner = new RandomPartitioner();
0:     private static IPartitioner oldPartitioner;
0: 
1:     @BeforeClass
0:     public static void setup() throws IOException
1:     {
0:         oldPartitioner = StorageService.instance.setPartitionerUnsafe(partitioner);
1:         SchemaLoader.loadSchema();
1:     }
0: 
1:     @AfterClass
1:     public static void tearDown()
1:     {
0:         StorageService.instance.setPartitionerUnsafe(oldPartitioner);
0:         SchemaLoader.stopGossiper();
1:     }
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:lyubent
-------------------------------------------------------------------------------
commit:d2a3827
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.Schema;
1: import org.apache.cassandra.db.SystemKeyspace;
/////////////////////////////////////////////////////////////////////////
1:     private static final String KEYSPACE1 = "LeaveAndBootstrapTestKeyspace1";
1:     private static final String KEYSPACE2 = "LeaveAndBootstrapTestKeyspace2";
1:     private static final String KEYSPACE3 = "LeaveAndBootstrapTestKeyspace3";
1:     private static final String KEYSPACE4 = "LeaveAndBootstrapTestKeyspace4";
1:     public static void defineSchema() throws Exception
1:         SchemaLoader.schemaDefinition("LeaveAndBootstrapTest");
/////////////////////////////////////////////////////////////////////////
1:             keyspaceStrategyMap.put("LeaveAndBootstrapTestKeyspace" + i, getStrategy("LeaveAndBootstrapTestKeyspace" + i, tmd));
1:         expectedEndpoints.put(KEYSPACE1, HashMultimap.<Token, InetAddress>create());
1:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("5"), makeAddrs("127.0.0.2"));
1:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3"));
1:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4"));
1:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5"));
1:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6"));
1:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.1.1"));
1:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.8"));
1:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.1.2", "127.0.0.1"));
1:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.10", "127.0.0.1"));
1:         expectedEndpoints.get(KEYSPACE1).putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.1"));
1:         expectedEndpoints.put(KEYSPACE2, HashMultimap.<Token, InetAddress>create());
1:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("5"), makeAddrs("127.0.0.2"));
1:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3"));
1:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4"));
1:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5"));
1:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6"));
1:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.1.1"));
1:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.8"));
1:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.1.2", "127.0.0.1"));
1:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.10", "127.0.0.1"));
1:         expectedEndpoints.get(KEYSPACE2).putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.1"));
1:         expectedEndpoints.put(KEYSPACE3, HashMultimap.<Token, InetAddress>create());
1:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("5"), makeAddrs("127.0.0.2", "127.0.0.3", "127.0.0.4", "127.0.0.5", "127.0.0.6"));
1:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3", "127.0.0.4", "127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.1.1", "127.0.0.8"));
1:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4", "127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.1.2", "127.0.0.1", "127.0.1.1"));
1:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.1.2", "127.0.0.1", "127.0.0.2", "127.0.1.1"));
1:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.1.2", "127.0.0.1", "127.0.0.2", "127.0.1.1", "127.0.0.3"));
1:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.0.3", "127.0.0.4", "127.0.1.1", "127.0.1.2"));
1:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.1.2", "127.0.0.3", "127.0.0.4"));
1:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.0.3", "127.0.1.2", "127.0.0.4", "127.0.0.5"));
1:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.0.3", "127.0.0.4", "127.0.0.5"));
1:         expectedEndpoints.get(KEYSPACE3).putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.1", "127.0.0.2", "127.0.0.3", "127.0.0.4", "127.0.0.5"));
1:         expectedEndpoints.put(KEYSPACE4, HashMultimap.<Token, InetAddress>create());
1:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("5"), makeAddrs("127.0.0.2", "127.0.0.3", "127.0.0.4"));
1:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("15"), makeAddrs("127.0.0.3", "127.0.0.4", "127.0.0.5"));
1:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("25"), makeAddrs("127.0.0.4", "127.0.0.5", "127.0.0.6"));
1:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("35"), makeAddrs("127.0.0.5", "127.0.0.6", "127.0.0.7", "127.0.1.1", "127.0.0.8"));
1:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("45"), makeAddrs("127.0.0.6", "127.0.0.7", "127.0.0.8", "127.0.1.2", "127.0.0.1", "127.0.1.1"));
1:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("55"), makeAddrs("127.0.0.7", "127.0.0.8", "127.0.0.9", "127.0.0.1", "127.0.0.2", "127.0.1.1", "127.0.1.2"));
1:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("65"), makeAddrs("127.0.0.8", "127.0.0.9", "127.0.0.10", "127.0.1.2", "127.0.0.1", "127.0.0.2"));
1:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("75"), makeAddrs("127.0.0.9", "127.0.0.10", "127.0.0.1", "127.0.1.2", "127.0.0.2", "127.0.0.3"));
1:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("85"), makeAddrs("127.0.0.10", "127.0.0.1", "127.0.0.2", "127.0.0.3"));
1:         expectedEndpoints.get(KEYSPACE4).putAll(new BigIntegerToken("95"), makeAddrs("127.0.0.1", "127.0.0.2", "127.0.0.3"));
/////////////////////////////////////////////////////////////////////////
1:         expectedEndpoints.get(KEYSPACE1).get(new BigIntegerToken("55")).removeAll(makeAddrs("127.0.0.7", "127.0.0.8"));
1:         expectedEndpoints.get(KEYSPACE1).get(new BigIntegerToken("85")).removeAll(makeAddrs("127.0.0.10"));
1:         expectedEndpoints.get(KEYSPACE2).get(new BigIntegerToken("55")).removeAll(makeAddrs("127.0.0.7", "127.0.0.8"));
1:         expectedEndpoints.get(KEYSPACE2).get(new BigIntegerToken("85")).removeAll(makeAddrs("127.0.0.10"));
1:         expectedEndpoints.get(KEYSPACE3).get(new BigIntegerToken("15")).removeAll(makeAddrs("127.0.0.7", "127.0.0.8"));
1:         expectedEndpoints.get(KEYSPACE3).get(new BigIntegerToken("25")).removeAll(makeAddrs("127.0.0.7", "127.0.1.2", "127.0.0.1"));
1:         expectedEndpoints.get(KEYSPACE3).get(new BigIntegerToken("35")).removeAll(makeAddrs("127.0.0.7", "127.0.0.2"));
1:         expectedEndpoints.get(KEYSPACE3).get(new BigIntegerToken("45")).removeAll(makeAddrs("127.0.0.7", "127.0.0.10", "127.0.0.3"));
1:         expectedEndpoints.get(KEYSPACE3).get(new BigIntegerToken("55")).removeAll(makeAddrs("127.0.0.7", "127.0.0.10", "127.0.0.4"));
1:         expectedEndpoints.get(KEYSPACE3).get(new BigIntegerToken("65")).removeAll(makeAddrs("127.0.0.10"));
1:         expectedEndpoints.get(KEYSPACE3).get(new BigIntegerToken("75")).removeAll(makeAddrs("127.0.0.10"));
1:         expectedEndpoints.get(KEYSPACE3).get(new BigIntegerToken("85")).removeAll(makeAddrs("127.0.0.10"));
1:         expectedEndpoints.get(KEYSPACE4).get(new BigIntegerToken("35")).removeAll(makeAddrs("127.0.0.7", "127.0.0.8"));
1:         expectedEndpoints.get(KEYSPACE4).get(new BigIntegerToken("45")).removeAll(makeAddrs("127.0.0.7", "127.0.1.2", "127.0.0.1"));
1:         expectedEndpoints.get(KEYSPACE4).get(new BigIntegerToken("55")).removeAll(makeAddrs("127.0.0.2", "127.0.0.7"));
1:         expectedEndpoints.get(KEYSPACE4).get(new BigIntegerToken("65")).removeAll(makeAddrs("127.0.0.10"));
1:         expectedEndpoints.get(KEYSPACE4).get(new BigIntegerToken("75")).removeAll(makeAddrs("127.0.0.10"));
1:         expectedEndpoints.get(KEYSPACE4).get(new BigIntegerToken("85")).removeAll(makeAddrs("127.0.0.10"));
author:Dave Brosius
-------------------------------------------------------------------------------
commit:9639f95
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public static void setup() throws ConfigurationException
/////////////////////////////////////////////////////////////////////////
1:     public void testSimultaneousMove() throws UnknownHostException
/////////////////////////////////////////////////////////////////////////
1:     private AbstractReplicationStrategy getStrategy(String keyspaceName, TokenMetadata tmd)
commit:3020555
/////////////////////////////////////////////////////////////////////////
1:                 assertEquals(expectedEndpoints.get(keyspaceName).get(keyTokens.get(i)).size(), endpoints.size());
/////////////////////////////////////////////////////////////////////////
1:                 assertEquals(3, endpoints.size());
/////////////////////////////////////////////////////////////////////////
1:             assertEquals(5, endpoints.size());
/////////////////////////////////////////////////////////////////////////
1:             assertEquals(6, endpoints.size());
/////////////////////////////////////////////////////////////////////////
1:             assertEquals(7, endpoints.size());
/////////////////////////////////////////////////////////////////////////
1:             assertEquals(6, endpoints.size());
/////////////////////////////////////////////////////////////////////////
1:             assertEquals(6, endpoints.size());
/////////////////////////////////////////////////////////////////////////
1:             assertEquals(4, endpoints.size());
/////////////////////////////////////////////////////////////////////////
1:             assertEquals(3, endpoints.size());
/////////////////////////////////////////////////////////////////////////
1:                 assertEquals(expectedEndpoints.get(keyspaceName).get(keyTokens.get(i)).size(), endpoints.size());
/////////////////////////////////////////////////////////////////////////
1:                 assertEquals(3, endpoints.size());
/////////////////////////////////////////////////////////////////////////
1:             assertEquals(3, endpoints.size());
1:             assertEquals(3, endpoints.size());
1:             assertEquals(5, endpoints.size());
/////////////////////////////////////////////////////////////////////////
1:             assertEquals(5, endpoints.size());
/////////////////////////////////////////////////////////////////////////
1:             assertEquals(5, endpoints.size());
/////////////////////////////////////////////////////////////////////////
1:             assertEquals(3, endpoints.size());
1:             assertEquals(3, endpoints.size());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(hosts.get(2), tmd.getBootstrapTokens().get(keyTokens.get(4)));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(hosts.get(2), tmd.getBootstrapTokens().get(keyTokens.get(4)));
1:         assertEquals(hosts.get(3), tmd.getBootstrapTokens().get(keyTokens.get(1)));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(hosts.get(2), tmd.getBootstrapTokens().get(keyTokens.get(3)));
1:         assertNull(tmd.getBootstrapTokens().get(keyTokens.get(4)));
1:         assertEquals(hosts.get(3), tmd.getBootstrapTokens().get(keyTokens.get(1)));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(keyTokens.get(3), tmd.getToken(hosts.get(2)));
1:         assertEquals(keyTokens.get(2), tmd.getToken(hosts.get(3)));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(endpointTokens.get(2), tmd.getToken(hosts.get(2)));
1:         assertEquals(keyTokens.get(2), tmd.getToken(hosts.get(2)));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(keyTokens.get(4), tmd.getToken(hosts.get(2)));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(keyTokens.get(0), tmd.getToken(hosts.get(2)));
1:         assertNull(tmd.getEndpoint(endpointTokens.get(2)));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(1, tmd.getBootstrapTokens().size());
1:         assertEquals(hosts.get(2), tmd.getBootstrapTokens().get(keyTokens.get(1)));
1:         assertEquals(hosts.get(2), tmd.getEndpoint(keyTokens.get(1)));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(1, tmd.getBootstrapTokens().size());
1:         assertEquals(hosts.get(3), tmd.getBootstrapTokens().get(keyTokens.get(1)));
author:Brandon Williams
-------------------------------------------------------------------------------
commit:4c0b4fa
commit:7407cf9
commit:2dd55c7
/////////////////////////////////////////////////////////////////////////
1:         Thread.sleep(100); // because there is a tight race between submit and blockUntilFinished
commit:e488e58
commit:a169863
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void testRemovingStatusForNonMember()  throws UnknownHostException
1:     {
1:         // create a ring of 1 node
1:         StorageService ss = StorageService.instance;
1:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
0:         Util.createInitialRing(ss, partitioner, new ArrayList<Token>(), new ArrayList<Token>(),  new ArrayList<InetAddress>(), new ArrayList<UUID>(), 1);
0: 
1:         // make a REMOVING state change on a non-member endpoint; without the CASSANDRA-6564 fix, this
1:         // would result in an ArrayIndexOutOfBoundsException
1:         ss.onChange(InetAddress.getByName("192.168.1.42"), ApplicationState.STATUS, valueFactory.removingNonlocal(UUID.randomUUID()));
1:     }
0: 
commit:c612a36
/////////////////////////////////////////////////////////////////////////
1:     @Test
0:     public void testRemovingStatusForNonMember()  throws UnknownHostException
1:     {
0:         // create a ring of 1 node
1:         StorageService ss = StorageService.instance;
1:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
0:         Util.createInitialRing(ss, partitioner, new ArrayList<Token>(), new ArrayList<Token>(),  new ArrayList<InetAddress>(), new ArrayList<UUID>(), 1);
0: 
0:         // make a REMOVING state change on a non-member endpoint; without the CASSANDRA-6564 fix, this
0:         // would result in an ArrayIndexOutOfBoundsException
0:         ss.onChange(InetAddress.getByName("192.168.1.42"), ApplicationState.STATUS, valueFactory.removingNonlocal(UUID.randomUUID()));
1:     }
0: 
commit:db69dce
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.SystemKeyspace;
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<Token> endpointTokens = new ArrayList<>();
1:         List<InetAddress> hosts = new ArrayList<>();
0:         SystemKeyspace.updatePeerInfo(toRemove, "data_center", "'dc42'");
0:         SystemKeyspace.updatePeerInfo(toRemove, "rack", "'rack42'");
1:         assertEquals("rack42", SystemKeyspace.loadDcRackInfo().get(toRemove).get("rack"));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("rack42", SystemKeyspace.loadDcRackInfo().get(toRemove).get("rack"));
commit:2bfaf8f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.SystemKeyspace;
/////////////////////////////////////////////////////////////////////////
0:         ArrayList<Token> endpointTokens = new ArrayList<>();
0:         List<InetAddress> hosts = new ArrayList<>();
0:         SystemKeyspace.updatePeerInfo(toRemove, "data_center", "'dc42'");
0:         SystemKeyspace.updatePeerInfo(toRemove, "rack", "'rack42'");
0:         assertEquals("rack42", SystemKeyspace.loadDcRackInfo().get(toRemove).get("rack"));
/////////////////////////////////////////////////////////////////////////
0:         assertEquals("rack42", SystemKeyspace.loadDcRackInfo().get(toRemove).get("rack"));
commit:fbd51b7
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.SystemTable;
/////////////////////////////////////////////////////////////////////////
0:         ArrayList<Token> endpointTokens = new ArrayList<Token>();
0:         List<InetAddress> hosts = new ArrayList<InetAddress>();
0:         SystemTable.updatePeerInfo(toRemove, "data_center", "'dc42'");
0:         SystemTable.updatePeerInfo(toRemove, "rack", "'rack42'");
0:         assertEquals("rack42", SystemTable.loadDcRackInfo().get(toRemove).get("rack"));
/////////////////////////////////////////////////////////////////////////
0:         assertEquals("rack42", SystemTable.loadDcRackInfo().get(toRemove).get("rack"));
commit:1997b7b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.SystemTable;
/////////////////////////////////////////////////////////////////////////
0:         ArrayList<Token> endpointTokens = new ArrayList<Token>();
0:         List<InetAddress> hosts = new ArrayList<InetAddress>();
0:         SystemTable.updatePeerInfo(toRemove, "data_center", "'dc42'");
0:         SystemTable.updatePeerInfo(toRemove, "rack", "'rack42'");
0:         assertEquals("rack42", SystemTable.loadDcRackInfo().get(toRemove).get("rack"));
/////////////////////////////////////////////////////////////////////////
0:         assertEquals("rack42", SystemTable.loadDcRackInfo().get(toRemove).get("rack"));
commit:b5e2a01
commit:c1c3d8f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.SystemKeyspace;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Tests that the system.peers table is not updated after a node has been removed. (See CASSANDRA-6053)
1:      */
0:     @Test
1:     public void testStateChangeOnRemovedNode() throws UnknownHostException
0:     {
0:         StorageService ss = StorageService.instance;
0:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
0: 
1:         // create a ring of 2 nodes
0:         ArrayList<Token> endpointTokens = new ArrayList<>();
0:         List<InetAddress> hosts = new ArrayList<>();
1:         Util.createInitialRing(ss, partitioner, endpointTokens, new ArrayList<Token>(), hosts, new ArrayList<UUID>(), 2);
0: 
1:         InetAddress toRemove = hosts.get(1);
0:         SystemKeyspace.updatePeerInfo(toRemove, "data_center", "'dc42'");
0:         SystemKeyspace.updatePeerInfo(toRemove, "rack", "'rack42'");
0:         assertEquals("rack42", SystemKeyspace.loadDcRackInfo().get(toRemove).get("rack"));
0: 
1:         // mark the node as removed
1:         Gossiper.instance.injectApplicationState(toRemove, ApplicationState.STATUS,
1:                 valueFactory.left(Collections.singleton(endpointTokens.get(1)), Gossiper.computeExpireTime()));
1:         assertTrue(Gossiper.instance.isDeadState(Gossiper.instance.getEndpointStateForEndpoint(hosts.get(1))));
0: 
1:         // state changes made after the endpoint has left should be ignored
1:         ss.onChange(hosts.get(1), ApplicationState.RACK,
1:                 valueFactory.rack("rack9999"));
0:         assertEquals("rack42", SystemKeyspace.loadDcRackInfo().get(toRemove).get("rack"));
0:     }
0: 
commit:5977e7b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.SystemKeyspace;
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Tests that the system.peers table is not updated after a node has been removed. (See CASSANDRA-6053)
0:      */
0:     @Test
0:     public void testStateChangeOnRemovedNode() throws UnknownHostException
0:     {
0:         StorageService ss = StorageService.instance;
0:         VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner);
0: 
0:         // create a ring of 2 nodes
0:         ArrayList<Token> endpointTokens = new ArrayList<>();
0:         List<InetAddress> hosts = new ArrayList<>();
0:         Util.createInitialRing(ss, partitioner, endpointTokens, new ArrayList<Token>(), hosts, new ArrayList<UUID>(), 2);
0: 
0:         InetAddress toRemove = hosts.get(1);
0:         SystemKeyspace.updatePeerInfo(toRemove, "data_center", "'dc42'");
0:         SystemKeyspace.updatePeerInfo(toRemove, "rack", "'rack42'");
0:         assertEquals("rack42", SystemKeyspace.loadDcRackInfo().get(toRemove).get("rack"));
0: 
0:         // mark the node as removed
0:         Gossiper.instance.injectApplicationState(toRemove, ApplicationState.STATUS,
0:                 valueFactory.left(Collections.singleton(endpointTokens.get(1)), Gossiper.computeExpireTime()));
0:         assertTrue(Gossiper.instance.isDeadState(Gossiper.instance.getEndpointStateForEndpoint(hosts.get(1))));
0: 
0:         // state changes made after the endpoint has left should be ignored
0:         ss.onChange(hosts.get(1), ApplicationState.RACK,
0:                 valueFactory.rack("rack9999"));
0:         assertEquals("rack42", SystemKeyspace.loadDcRackInfo().get(toRemove).get("rack"));
0:     }
0: 
commit:7de6f96
/////////////////////////////////////////////////////////////////////////
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
/////////////////////////////////////////////////////////////////////////
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
/////////////////////////////////////////////////////////////////////////
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
/////////////////////////////////////////////////////////////////////////
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
/////////////////////////////////////////////////////////////////////////
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
/////////////////////////////////////////////////////////////////////////
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
/////////////////////////////////////////////////////////////////////////
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
/////////////////////////////////////////////////////////////////////////
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
/////////////////////////////////////////////////////////////////////////
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
/////////////////////////////////////////////////////////////////////////
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
/////////////////////////////////////////////////////////////////////////
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
/////////////////////////////////////////////////////////////////////////
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
/////////////////////////////////////////////////////////////////////////
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
/////////////////////////////////////////////////////////////////////////
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
/////////////////////////////////////////////////////////////////////////
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
/////////////////////////////////////////////////////////////////////////
0:         PendingRangeCalculatorService.instance.blockUntilFinished();
commit:b475bc6
/////////////////////////////////////////////////////////////////////////
1:         Gossiper.instance.initializeNodeUnsafe(boot1, UUID.randomUUID(), 1);
1:         Gossiper.instance.injectApplicationState(boot1, ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(5))));
1:                     valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(5))));
1:         Gossiper.instance.initializeNodeUnsafe(boot2, UUID.randomUUID(), 1);
1:         Gossiper.instance.injectApplicationState(boot2, ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(7))));
1:                     valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(7))));
/////////////////////////////////////////////////////////////////////////
1:         ss.onChange(boot1, ApplicationState.STATUS, valueFactory.normal(Collections.singleton(keyTokens.get(5))));
/////////////////////////////////////////////////////////////////////////
1:         Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(4))));
1:                     valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(4))));
1:         Gossiper.instance.injectApplicationState(hosts.get(3), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(1))));
1:                     valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(1))));
/////////////////////////////////////////////////////////////////////////
1:         Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(3))));
1:                     valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(3))));
/////////////////////////////////////////////////////////////////////////
1:         Gossiper.instance.injectApplicationState(hosts.get(3), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(2))));
1:         Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(3))));
1:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(keyTokens.get(3))));
1:         ss.onChange(hosts.get(3), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(keyTokens.get(2))));
/////////////////////////////////////////////////////////////////////////
1:         Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(2))));
1:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(keyTokens.get(2))));
/////////////////////////////////////////////////////////////////////////
1:         Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(4))));
1:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(keyTokens.get(4))));
/////////////////////////////////////////////////////////////////////////
1:         Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(0))));
/////////////////////////////////////////////////////////////////////////
1:         Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(1))));
1:                     valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(1))));
/////////////////////////////////////////////////////////////////////////
1:         Gossiper.instance.injectApplicationState(hosts.get(3), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(1))));
1:         ss.onChange(hosts.get(3), ApplicationState.STATUS, valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(1))));
1:         Gossiper.instance.injectApplicationState(hosts.get(2), ApplicationState.TOKENS, valueFactory.tokens(Collections.singleton(keyTokens.get(1))));
commit:877a8ca
/////////////////////////////////////////////////////////////////////////
0:         Gossiper.instance.initializeNodeUnsafe(boot1, 1);
0:         Gossiper.instance.initializeNodeUnsafe(boot2, 1);
commit:ab95f98
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.gms.Gossiper;
/////////////////////////////////////////////////////////////////////////
1:         ss.onChange(hosts.get(LEAVING[0]), ApplicationState.STATUS,
0:                 valueFactory.left(endpointTokens.get(LEAVING[0]), Gossiper.computeExpireTime()));
1:         ss.onChange(hosts.get(LEAVING[2]), ApplicationState.STATUS,
0:                 valueFactory.left(endpointTokens.get(LEAVING[2]), Gossiper.computeExpireTime()));
/////////////////////////////////////////////////////////////////////////
1:         ss.onChange(hosts.get(2), ApplicationState.STATUS,
0:                 valueFactory.left(keyTokens.get(2), Gossiper.computeExpireTime()));
/////////////////////////////////////////////////////////////////////////
1:         ss.onChange(hosts.get(2), ApplicationState.STATUS,
0:                 valueFactory.left(keyTokens.get(1), Gossiper.computeExpireTime()));
/////////////////////////////////////////////////////////////////////////
1:         ss.onChange(hosts.get(2), ApplicationState.STATUS,
0:                 valueFactory.left(endpointTokens.get(2), Gossiper.computeExpireTime()));
/////////////////////////////////////////////////////////////////////////
1:         ss.onChange(hosts.get(2), ApplicationState.STATUS,
0:                 valueFactory.left(keyTokens.get(1), Gossiper.computeExpireTime()));
author:Eric Evans
-------------------------------------------------------------------------------
commit:66b96ee
/////////////////////////////////////////////////////////////////////////
1:                 valueFactory.leaving(Collections.singleton(endpointTokens.get(LEAVING_NODE))));
/////////////////////////////////////////////////////////////////////////
1:             ss.onChange(hosts.get(leaving),
1:                         ApplicationState.STATUS,
1:                         valueFactory.leaving(Collections.singleton(endpointTokens.get(leaving))));
1:         ss.onChange(boot1,
1:                     ApplicationState.STATUS,
0:                     valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(5)), boot1Id));
1:         ss.onChange(boot2,
1:                     ApplicationState.STATUS,
0:                     valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(7)), UUID.randomUUID()));
/////////////////////////////////////////////////////////////////////////
1:                 valueFactory.left(Collections.singleton(endpointTokens.get(LEAVING[0])), Gossiper.computeExpireTime()));
1:                 valueFactory.left(Collections.singleton(endpointTokens.get(LEAVING[2])), Gossiper.computeExpireTime()));
0:         ss.onChange(boot1, ApplicationState.STATUS, valueFactory.normal(Collections.singleton(keyTokens.get(5)), boot1Id));
/////////////////////////////////////////////////////////////////////////
1:         ss.onChange(hosts.get(2),
1:                     ApplicationState.STATUS,
1:                     valueFactory.leaving(Collections.singleton(endpointTokens.get(2))));
/////////////////////////////////////////////////////////////////////////
1:         ss.onChange(hosts.get(2),
1:                     ApplicationState.STATUS,
0:                     valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(4)), hostIds.get(2)));
1:         ss.onChange(hosts.get(3),
1:                     ApplicationState.STATUS,
0:                     valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(1)), hostIds.get(3)));
/////////////////////////////////////////////////////////////////////////
1:         ss.onChange(hosts.get(2),
1:                     ApplicationState.STATUS,
0:                     valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(3)), hostIds.get(2)));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(keyTokens.get(3)),
0:                                                                                hostIds.get(2)));
0:         ss.onChange(hosts.get(3), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(keyTokens.get(2)),
0:                                                                                hostIds.get(3)));
/////////////////////////////////////////////////////////////////////////
1:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(Collections.singleton(endpointTokens.get(2))));
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(keyTokens.get(2)),
0:                                                                                hostIds.get(2)));
1:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(Collections.singleton(keyTokens.get(2))));
1:                 valueFactory.left(Collections.singleton(keyTokens.get(2)), Gossiper.computeExpireTime()));
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(Collections.singleton(keyTokens.get(4)),
0:                                                                                hostIds.get(2)));
/////////////////////////////////////////////////////////////////////////
1:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(Collections.singleton(keyTokens.get(0))));
1:         ss.onChange(hosts.get(2),
1:                     ApplicationState.STATUS,
0:                     valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(1)), hostIds.get(2)));
1:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.leaving(Collections.singleton(keyTokens.get(1))));
/////////////////////////////////////////////////////////////////////////
1:                 valueFactory.left(Collections.singleton(keyTokens.get(1)), Gossiper.computeExpireTime()));
/////////////////////////////////////////////////////////////////////////
1:                 valueFactory.left(Collections.singleton(endpointTokens.get(2)), Gossiper.computeExpireTime()));
0:         ss.onChange(hosts.get(3), ApplicationState.STATUS, valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(1)), hostIds.get(3)));
/////////////////////////////////////////////////////////////////////////
1:                 valueFactory.left(Collections.singleton(keyTokens.get(1)), Gossiper.computeExpireTime()));
commit:ad685c4
/////////////////////////////////////////////////////////////////////////
1:         List<UUID> hostIds = new ArrayList<UUID>();
1:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, RING_SIZE);
/////////////////////////////////////////////////////////////////////////
1:         List<UUID> hostIds = new ArrayList<UUID>();
1:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, RING_SIZE);
/////////////////////////////////////////////////////////////////////////
0:         UUID boot1Id = UUID.randomUUID();
0:         ss.onChange(boot1, ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(5), boot1Id));
0:         ss.onChange(boot2, ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(7), UUID.randomUUID()));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(boot1, ApplicationState.STATUS, valueFactory.normal(keyTokens.get(5), boot1Id));
/////////////////////////////////////////////////////////////////////////
1:         List<UUID> hostIds = new ArrayList<UUID>();
1:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, 7);
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(4), hostIds.get(2)));
0:         ss.onChange(hosts.get(3), ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(1), hostIds.get(3)));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(3), hostIds.get(2)));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(keyTokens.get(3), hostIds.get(2)));
0:         ss.onChange(hosts.get(3), ApplicationState.STATUS, valueFactory.normal(keyTokens.get(2), hostIds.get(3)));
/////////////////////////////////////////////////////////////////////////
1:         List<UUID> hostIds = new ArrayList<UUID>();
1:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, 6);
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(keyTokens.get(2), hostIds.get(2)));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.normal(keyTokens.get(4), hostIds.get(2)));
/////////////////////////////////////////////////////////////////////////
1:         List<UUID> hostIds = new ArrayList<UUID>();
1:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, 6);
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(2), ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(1), hostIds.get(2)));
/////////////////////////////////////////////////////////////////////////
1:         List<UUID> hostIds = new ArrayList<UUID>();
1:         Util.createInitialRing(ss, partitioner, endpointTokens, keyTokens, hosts, hostIds, 7);
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(hosts.get(3), ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(1), hostIds.get(3)));
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:7b532bc
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.Schema;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         for (String table : Schema.instance.getNonSystemTables())
/////////////////////////////////////////////////////////////////////////
0:         for (String table : Schema.instance.getNonSystemTables())
/////////////////////////////////////////////////////////////////////////
0:         KSMetaData ksmd = Schema.instance.getKSMetaData(table);
============================================================================