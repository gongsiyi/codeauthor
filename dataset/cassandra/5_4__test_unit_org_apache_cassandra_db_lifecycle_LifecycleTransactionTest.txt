1:e5a76bd: /*
1:e5a76bd: * Licensed to the Apache Software Foundation (ASF) under one
1:e5a76bd: * or more contributor license agreements.  See the NOTICE file
1:e5a76bd: * distributed with this work for additional information
1:e5a76bd: * regarding copyright ownership.  The ASF licenses this file
1:e5a76bd: * to you under the Apache License, Version 2.0 (the
1:e5a76bd: * "License"); you may not use this file except in compliance
1:e5a76bd: * with the License.  You may obtain a copy of the License at
1:e5a76bd: *
1:e5a76bd: *    http://www.apache.org/licenses/LICENSE-2.0
1:e5a76bd: *
1:e5a76bd: * Unless required by applicable law or agreed to in writing,
1:e5a76bd: * software distributed under the License is distributed on an
1:e5a76bd: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:e5a76bd: * KIND, either express or implied.  See the License for the
1:e5a76bd: * specific language governing permissions and limitations
1:e5a76bd: * under the License.
1:e5a76bd: */
1:e5a76bd: package org.apache.cassandra.db.lifecycle;
1:e5a76bd: 
1:e5a76bd: import java.util.ArrayList;
1:e5a76bd: import java.util.List;
1:e5a76bd: 
1:e5a76bd: import org.junit.After;
1:e5a76bd: import org.junit.Before;
1:99a84bc: import org.junit.BeforeClass;
1:e5a76bd: import org.junit.Test;
1:e5a76bd: 
1:e5a76bd: import junit.framework.Assert;
1:e5a76bd: import org.apache.cassandra.MockSchema;
1:e5a76bd: import org.apache.cassandra.config.DatabaseDescriptor;
1:99da210: import org.apache.cassandra.db.ColumnFamilyStore;
1:e5a76bd: import org.apache.cassandra.db.compaction.OperationType;
1:e5a76bd: import org.apache.cassandra.db.lifecycle.LifecycleTransaction.ReaderState;
1:e5a76bd: import org.apache.cassandra.db.lifecycle.LifecycleTransaction.ReaderState.Action;
1:e5a76bd: import org.apache.cassandra.io.sstable.format.SSTableReader;
1:e5a76bd: import org.apache.cassandra.utils.Pair;
1:e5a76bd: import org.apache.cassandra.utils.concurrent.AbstractTransactionalTest;
1:e5a76bd: import org.apache.cassandra.utils.concurrent.Transactional.AbstractTransactional.State;
1:e5a76bd: 
1:e5a76bd: import static com.google.common.base.Predicates.in;
1:e5a76bd: import static com.google.common.collect.ImmutableList.copyOf;
1:e5a76bd: import static com.google.common.collect.ImmutableList.of;
1:e5a76bd: import static com.google.common.collect.Iterables.all;
1:e5a76bd: import static com.google.common.collect.Iterables.concat;
1:e5a76bd: import static com.google.common.collect.Iterables.size;
1:e5a76bd: import static org.apache.cassandra.db.lifecycle.Helpers.idIn;
1:e5a76bd: import static org.apache.cassandra.db.lifecycle.Helpers.orIn;
1:e5a76bd: import static org.apache.cassandra.db.lifecycle.Helpers.select;
1:e5a76bd: 
1:e5a76bd: public class LifecycleTransactionTest extends AbstractTransactionalTest
1:e5a76bd: {
1:e5a76bd:     private boolean incrementalBackups;
1:e5a76bd: 
1:99a84bc:     @BeforeClass
1:99a84bc:     public static void setUp()
1:99a84bc:     {
1:99a84bc:         MockSchema.cleanup();
1:99a84bc:     }
1:99a84bc: 
1:e5a76bd:     @Before
1:e5a76bd:     public void disableIncrementalBackup()
1:e5a76bd:     {
1:e5a76bd:         incrementalBackups = DatabaseDescriptor.isIncrementalBackupsEnabled();
1:e5a76bd:         DatabaseDescriptor.setIncrementalBackupsEnabled(false);
1:e5a76bd:     }
1:e5a76bd:     @After
1:e5a76bd:     public void restoreIncrementalBackup()
1:e5a76bd:     {
1:e5a76bd:         DatabaseDescriptor.setIncrementalBackupsEnabled(incrementalBackups);
1:e5a76bd:     }
1:e5a76bd: 
1:e5a76bd:     @Test
1:e5a76bd:     public void testUpdates() // (including obsoletion)
1:e5a76bd:     {
1:99da210:         ColumnFamilyStore cfs = MockSchema.newCFS();
1:e5a76bd:         Tracker tracker = new Tracker(null, false);
1:99da210:         SSTableReader[] readers = readersArray(0, 3, cfs);
1:99da210:         SSTableReader[] readers2 = readersArray(0, 4, cfs);
1:99da210:         SSTableReader[] readers3 = readersArray(0, 4, cfs);
1:e5a76bd:         tracker.addInitialSSTables(copyOf(readers));
1:e5a76bd:         LifecycleTransaction txn = tracker.tryModify(copyOf(readers), OperationType.UNKNOWN);
1:e5a76bd: 
1:e5a76bd:         txn.update(readers2[0], true);
1:e5a76bd:         txn.obsolete(readers[1]);
1:e5a76bd: 
1:e5a76bd:         Assert.assertTrue(txn.isObsolete(readers[1]));
1:e5a76bd:         Assert.assertFalse(txn.isObsolete(readers[0]));
1:e5a76bd: 
1:e5a76bd:         testBadUpdate(txn, readers2[0], true);  // same reader && instances
1:e5a76bd:         testBadUpdate(txn, readers2[1], true);  // staged obsolete; cannot update
1:e5a76bd:         testBadUpdate(txn, readers3[0], true);  // same reader, diff instances
1:e5a76bd:         testBadUpdate(txn, readers2[2], false); // incorrectly declared original status
1:e5a76bd:         testBadUpdate(txn, readers2[3], true); // incorrectly declared original status
1:e5a76bd: 
1:e5a76bd:         testBadObsolete(txn, readers[1]);  // staged obsolete; cannot obsolete again
1:e5a76bd:         testBadObsolete(txn, readers2[0]);  // staged update; cannot obsolete
1:e5a76bd: 
1:e5a76bd:         txn.update(readers2[3], false);
1:e5a76bd: 
1:e5a76bd:         Assert.assertEquals(3, tracker.getView().compacting.size());
1:e5a76bd:         txn.checkpoint();
1:e5a76bd:         Assert.assertTrue(txn.isObsolete(readers[1]));
1:e5a76bd:         Assert.assertFalse(txn.isObsolete(readers[0]));
1:e5a76bd:         Assert.assertEquals(4, tracker.getView().compacting.size());
1:e5a76bd:         Assert.assertEquals(3, tracker.getView().sstables.size());
1:e5a76bd:         Assert.assertEquals(3, size(txn.current()));
1:e5a76bd:         Assert.assertTrue(all(of(readers2[0], readers[2], readers2[3]), idIn(tracker.getView().sstablesMap)));
1:e5a76bd:         Assert.assertTrue(all(txn.current(), idIn(tracker.getView().sstablesMap)));
1:e5a76bd: 
1:e5a76bd:         testBadObsolete(txn, readers[1]);  // logged obsolete; cannot obsolete again
1:e5a76bd:         testBadObsolete(txn, readers2[2]);  // never seen instance; cannot obsolete
1:e5a76bd:         testBadObsolete(txn, readers2[3]);  // non-original; cannot obsolete
1:e5a76bd:         testBadUpdate(txn, readers3[1], true);  // logged obsolete; cannot update
1:e5a76bd:         testBadUpdate(txn, readers2[0], true);  // same instance as logged update
1:e5a76bd: 
1:e5a76bd:         txn.update(readers3[0], true);  // same reader as logged update, different instance
1:e5a76bd:         txn.checkpoint();
1:e5a76bd: 
1:e5a76bd:         Assert.assertEquals(4, tracker.getView().compacting.size());
1:e5a76bd:         Assert.assertEquals(3, tracker.getView().sstables.size());
1:e5a76bd:         Assert.assertEquals(3, size(txn.current()));
1:e5a76bd:         Assert.assertTrue(all(of(readers3[0], readers[2], readers2[3]), idIn(tracker.getView().sstablesMap)));
1:e5a76bd:         Assert.assertTrue(all(txn.current(), idIn(tracker.getView().sstablesMap)));
1:e5a76bd: 
1:e5a76bd:         testBadObsolete(txn, readers2[0]); // not current version of sstable
1:e5a76bd: 
1:e5a76bd:         txn.obsoleteOriginals();
1:e5a76bd:         txn.checkpoint();
1:e5a76bd:         Assert.assertEquals(1, tracker.getView().sstables.size());
1:e5a76bd:         txn.obsoleteOriginals(); // should be no-op
1:e5a76bd:         txn.checkpoint();
1:e5a76bd:         Assert.assertEquals(1, tracker.getView().sstables.size());
1:e5a76bd:         Assert.assertEquals(4, tracker.getView().compacting.size());
1:e5a76bd:     }
1:e5a76bd: 
1:e5a76bd:     @Test
1:e5a76bd:     public void testCancellation()
1:e5a76bd:     {
1:99da210:         ColumnFamilyStore cfs = MockSchema.newCFS();
1:e5a76bd:         Tracker tracker = new Tracker(null, false);
1:99da210:         List<SSTableReader> readers = readers(0, 3, cfs);
1:e5a76bd:         tracker.addInitialSSTables(readers);
1:e5a76bd:         LifecycleTransaction txn = tracker.tryModify(readers, OperationType.UNKNOWN);
1:e5a76bd: 
1:e5a76bd:         SSTableReader cancel = readers.get(0);
1:99da210:         SSTableReader update = readers(1, 2, cfs).get(0);
1:99da210:         SSTableReader fresh = readers(3, 4,cfs).get(0);
1:99da210:         SSTableReader notPresent = readers(4, 5, cfs).get(0);
1:e5a76bd: 
1:e5a76bd:         txn.cancel(cancel);
1:e5a76bd:         txn.update(update, true);
1:e5a76bd:         txn.update(fresh, false);
1:e5a76bd: 
1:e5a76bd:         testBadCancel(txn, cancel);
1:e5a76bd:         testBadCancel(txn, update);
1:e5a76bd:         testBadCancel(txn, fresh);
1:e5a76bd:         testBadCancel(txn, notPresent);
1:e5a76bd:         Assert.assertEquals(2, txn.originals().size());
1:e5a76bd:         Assert.assertEquals(2, tracker.getView().compacting.size());
1:e5a76bd:         Assert.assertTrue(all(readers.subList(1, 3), idIn(tracker.getView().compacting)));
1:e5a76bd: 
1:e5a76bd:         txn.checkpoint();
1:e5a76bd: 
1:e5a76bd:         testBadCancel(txn, cancel);
1:e5a76bd:         testBadCancel(txn, update);
1:e5a76bd:         testBadCancel(txn, fresh);
1:e5a76bd:         testBadCancel(txn, notPresent);
1:e5a76bd:         Assert.assertEquals(2, txn.originals().size());
1:e5a76bd:         Assert.assertEquals(3, tracker.getView().compacting.size());
1:e5a76bd:         Assert.assertEquals(3, size(txn.current()));
1:e5a76bd:         Assert.assertTrue(all(concat(readers.subList(1, 3), of(fresh)), idIn(tracker.getView().compacting)));
1:e5a76bd: 
1:e5a76bd:         txn.cancel(readers.get(2));
1:e5a76bd:         Assert.assertEquals(1, txn.originals().size());
1:e5a76bd:         Assert.assertEquals(2, tracker.getView().compacting.size());
1:e5a76bd:         Assert.assertEquals(2, size(txn.current()));
1:e5a76bd:         Assert.assertTrue(all(of(readers.get(1), fresh), idIn(tracker.getView().compacting)));
1:e5a76bd:     }
1:e5a76bd: 
1:e5a76bd:     @Test
1:e5a76bd:     public void testSplit()
1:e5a76bd:     {
1:99da210:         ColumnFamilyStore cfs = MockSchema.newCFS();
1:e5a76bd:         Tracker tracker = new Tracker(null, false);
1:1960e5b:         List<SSTableReader> readers = readers(0, 4, cfs);
1:e5a76bd:         tracker.addInitialSSTables(readers);
1:e5a76bd:         LifecycleTransaction txn = tracker.tryModify(readers, OperationType.UNKNOWN);
1:1960e5b:         txn.cancel(readers.get(3));
1:e5a76bd:         LifecycleTransaction txn2 = txn.split(readers.subList(0, 1));
1:e5a76bd:         Assert.assertEquals(2, txn.originals().size());
1:e5a76bd:         Assert.assertTrue(all(readers.subList(1, 3), in(txn.originals())));
1:e5a76bd:         Assert.assertEquals(1, txn2.originals().size());
1:e5a76bd:         Assert.assertTrue(all(readers.subList(0, 1), in(txn2.originals())));
1:99da210:         txn.update(readers(1, 2, cfs).get(0), true);
1:e5a76bd:         boolean failed = false;
1:e5a76bd:         try
1:e5a76bd:         {
1:e5a76bd:             txn.split(readers.subList(2, 3));
1:e5a76bd:         }
1:e5a76bd:         catch (Throwable t)
1:e5a76bd:         {
1:e5a76bd:             failed = true;
1:e5a76bd:         }
1:e5a76bd:         Assert.assertTrue(failed);
1:e5a76bd:     }
1:e5a76bd: 
1:e5a76bd:     private static void testBadUpdate(LifecycleTransaction txn, SSTableReader update, boolean original)
1:e5a76bd:     {
1:e5a76bd:         boolean failed = false;
1:e5a76bd:         try
1:e5a76bd:         {
1:e5a76bd:             txn.update(update, original);
1:e5a76bd:         }
1:e5a76bd:         catch (Throwable t)
1:e5a76bd:         {
1:e5a76bd:             failed = true;
1:e5a76bd:         }
1:e5a76bd:         Assert.assertTrue(failed);
1:e5a76bd:     }
1:e5a76bd: 
1:e5a76bd:     private static void testBadObsolete(LifecycleTransaction txn, SSTableReader update)
1:e5a76bd:     {
1:e5a76bd:         boolean failed = false;
1:e5a76bd:         try
1:e5a76bd:         {
1:e5a76bd:             txn.obsolete(update);
1:e5a76bd:         }
1:e5a76bd:         catch (Throwable t)
1:e5a76bd:         {
1:e5a76bd:             failed = true;
1:e5a76bd:         }
1:e5a76bd:         Assert.assertTrue(failed);
1:e5a76bd:     }
1:e5a76bd: 
1:e5a76bd:     private static void testBadCancel(LifecycleTransaction txn, SSTableReader cancel)
1:e5a76bd:     {
1:e5a76bd:         boolean failed = false;
1:e5a76bd:         try
1:e5a76bd:         {
1:e5a76bd:             txn.cancel(cancel);
1:e5a76bd:         }
1:e5a76bd:         catch (Throwable t)
1:e5a76bd:         {
1:e5a76bd:             failed = true;
1:e5a76bd:         }
1:e5a76bd:         Assert.assertTrue(failed);
1:e5a76bd:     }
1:e5a76bd: 
1:e5a76bd:     protected TestableTransaction newTest()
1:e5a76bd:     {
1:351c7ca:         LogTransaction.waitForDeletions();
1:e5a76bd:         SSTableReader.resetTidying();
1:e5a76bd:         return new TxnTest();
1:e5a76bd:     }
1:e5a76bd: 
1:e5a76bd:     private static final class TxnTest extends TestableTransaction
1:e5a76bd:     {
1:e5a76bd:         final List<SSTableReader> originals;
1:e5a76bd:         final List<SSTableReader> untouchedOriginals;
1:e5a76bd:         final List<SSTableReader> loggedUpdate;
1:e5a76bd:         final List<SSTableReader> loggedObsolete;
1:e5a76bd:         final List<SSTableReader> stagedObsolete;
1:e5a76bd:         final List<SSTableReader> loggedNew;
1:e5a76bd:         final List<SSTableReader> stagedNew;
1:e5a76bd:         final Tracker tracker;
1:e5a76bd:         final LifecycleTransaction txn;
1:e5a76bd: 
1:99da210:         private static Tracker tracker(ColumnFamilyStore cfs, List<SSTableReader> readers)
1:e5a76bd:         {
1:99da210:             Tracker tracker = new Tracker(cfs, false);
1:e5a76bd:             tracker.addInitialSSTables(readers);
1:e5a76bd:             return tracker;
1:e5a76bd:         }
1:e5a76bd: 
1:e5a76bd:         private TxnTest()
1:e5a76bd:         {
1:99da210:             this(MockSchema.newCFS());
1:e5a76bd:         }
1:e5a76bd: 
1:99da210:         private TxnTest(ColumnFamilyStore cfs)
1:e5a76bd:         {
1:99da210:             this(cfs, readers(0, 8, cfs));
1:99da210:         }
1:99da210: 
1:99da210:         private TxnTest(ColumnFamilyStore cfs, List<SSTableReader> readers)
1:99da210:         {
1:99da210:             this(tracker(cfs, readers), readers);
1:e5a76bd:         }
1:e5a76bd: 
1:e5a76bd:         private TxnTest(Tracker tracker, List<SSTableReader> readers)
1:e5a76bd:         {
1:e5a76bd:             this(tracker, readers, tracker.tryModify(readers, OperationType.UNKNOWN));
1:e5a76bd:         }
1:e5a76bd: 
1:e5a76bd:         private TxnTest(Tracker tracker, List<SSTableReader> readers, LifecycleTransaction txn)
1:e5a76bd:         {
1:e5a76bd:             super(txn);
1:e5a76bd:             this.tracker = tracker;
1:e5a76bd:             this.originals = readers;
1:e5a76bd:             this.txn = txn;
1:99da210:             update(txn, loggedUpdate = readers(0, 2, tracker.cfstore), true);
1:e5a76bd:             obsolete(txn, loggedObsolete = readers.subList(2, 4));
1:99da210:             update(txn, loggedNew = readers(8, 10, tracker.cfstore), false);
1:e5a76bd:             txn.checkpoint();
1:99da210:             update(txn, stagedNew = readers(10, 12, tracker.cfstore), false);
1:e5a76bd:             obsolete(txn, stagedObsolete = copyOf(concat(loggedUpdate, originals.subList(4, 6))));
1:e5a76bd:             untouchedOriginals = originals.subList(6, 8);
1:e5a76bd:         }
1:e5a76bd: 
1:e5a76bd:         private ReaderState state(SSTableReader reader, State state)
1:e5a76bd:         {
1:e5a76bd:             SSTableReader original = select(reader, originals);
1:e5a76bd:             boolean isOriginal = original != null;
1:e5a76bd: 
1:e5a76bd:             switch (state)
1:e5a76bd:             {
1:e5a76bd:                 case ABORTED:
1:e5a76bd:                 {
1:e5a76bd:                     return new ReaderState(Action.NONE, Action.NONE, original, original, isOriginal);
1:e5a76bd:                 }
1:e5a76bd: 
1:e5a76bd:                 case READY_TO_COMMIT:
1:e5a76bd:                 {
1:e5a76bd:                     ReaderState prev = state(reader, State.IN_PROGRESS);
1:e5a76bd:                     Action logged;
1:e5a76bd:                     SSTableReader visible;
1:e5a76bd:                     if (prev.staged == Action.NONE)
1:e5a76bd:                     {
1:e5a76bd:                         logged = prev.logged;
1:e5a76bd:                         visible = prev.currentlyVisible;
1:e5a76bd:                     }
1:e5a76bd:                     else
1:e5a76bd:                     {
1:e5a76bd:                         logged = prev.staged;
1:e5a76bd:                         visible = prev.nextVisible;
1:e5a76bd:                     }
1:e5a76bd:                     return new ReaderState(logged, Action.NONE, visible, visible, isOriginal);
1:e5a76bd:                 }
1:e5a76bd: 
1:e5a76bd:                 case IN_PROGRESS:
1:e5a76bd:                 {
1:e5a76bd:                     Action logged = Action.get(loggedUpdate.contains(reader) || loggedNew.contains(reader), loggedObsolete.contains(reader));
1:e5a76bd:                     Action staged = Action.get(stagedNew.contains(reader), stagedObsolete.contains(reader));
1:e5a76bd:                     SSTableReader currentlyVisible = ReaderState.visible(reader, in(loggedObsolete), loggedNew, loggedUpdate, originals);
1:e5a76bd:                     SSTableReader nextVisible = ReaderState.visible(reader, orIn(stagedObsolete, loggedObsolete), stagedNew, loggedNew, loggedUpdate, originals);
1:e5a76bd:                     return new ReaderState(logged, staged, currentlyVisible, nextVisible, isOriginal);
1:e5a76bd:                 }
1:e5a76bd:             }
1:e5a76bd:             throw new IllegalStateException();
1:e5a76bd:         }
1:e5a76bd: 
1:e5a76bd:         private List<Pair<SSTableReader, ReaderState>> states(State state)
1:e5a76bd:         {
1:e5a76bd:             List<Pair<SSTableReader, ReaderState>> result = new ArrayList<>();
1:e5a76bd:             for (SSTableReader reader : concat(originals, loggedNew, stagedNew))
1:e5a76bd:                 result.add(Pair.create(reader, state(reader, state)));
1:e5a76bd:             return result;
1:e5a76bd:         }
1:e5a76bd: 
1:e5a76bd:         protected void doAssert(State state)
1:e5a76bd:         {
1:e5a76bd:             for (Pair<SSTableReader, ReaderState> pair : states(state))
1:e5a76bd:             {
1:e5a76bd:                 SSTableReader reader = pair.left;
1:e5a76bd:                 ReaderState readerState = pair.right;
1:e5a76bd: 
1:e5a76bd:                 Assert.assertEquals(readerState, txn.state(reader));
1:e5a76bd:                 Assert.assertEquals(readerState.currentlyVisible, tracker.getView().sstablesMap.get(reader));
1:e5a76bd:                 if (readerState.currentlyVisible == null && readerState.nextVisible == null && !readerState.original)
1:e5a76bd:                     Assert.assertTrue(reader.selfRef().globalCount() == 0);
1:e5a76bd:             }
1:e5a76bd:         }
1:e5a76bd: 
1:e5a76bd:         protected void assertInProgress() throws Exception
1:e5a76bd:         {
1:e5a76bd:             doAssert(State.IN_PROGRESS);
1:e5a76bd:         }
1:e5a76bd: 
1:e5a76bd:         protected void assertPrepared() throws Exception
1:e5a76bd:         {
1:e5a76bd:             doAssert(State.READY_TO_COMMIT);
1:e5a76bd:         }
1:e5a76bd: 
1:e5a76bd:         protected void assertAborted() throws Exception
1:e5a76bd:         {
1:e5a76bd:             doAssert(State.ABORTED);
1:e5a76bd:             Assert.assertEquals(0, tracker.getView().compacting.size());
1:e5a76bd:             Assert.assertEquals(8, tracker.getView().sstables.size());
1:e5a76bd:             for (SSTableReader reader : concat(loggedNew, stagedNew))
1:e5a76bd:                 Assert.assertTrue(reader.selfRef().globalCount() == 0);
1:e5a76bd:         }
1:e5a76bd: 
1:e5a76bd:         protected void assertCommitted() throws Exception
1:e5a76bd:         {
1:e5a76bd:             doAssert(State.READY_TO_COMMIT);
1:e5a76bd:             Assert.assertEquals(0, tracker.getView().compacting.size());
1:e5a76bd:             Assert.assertEquals(6, tracker.getView().sstables.size());
1:e5a76bd:             for (SSTableReader reader : concat(loggedObsolete, stagedObsolete))
1:e5a76bd:                 Assert.assertTrue(reader.selfRef().globalCount() == 0);
1:e5a76bd:         }
1:b09e60f: 
1:b09e60f:         @Override
1:b09e60f:         protected boolean commitCanThrow()
1:b09e60f:         {
1:b09e60f:             return true;
1:b09e60f:         }
1:e5a76bd:     }
1:e5a76bd: 
1:99da210:     private static SSTableReader[] readersArray(int lb, int ub, ColumnFamilyStore cfs)
1:e5a76bd:     {
1:99da210:         return readers(lb, ub, cfs).toArray(new SSTableReader[0]);
1:e5a76bd:     }
1:e5a76bd: 
1:99da210:     private static List<SSTableReader> readers(int lb, int ub, ColumnFamilyStore cfs)
1:e5a76bd:     {
1:e5a76bd:         List<SSTableReader> readers = new ArrayList<>();
1:e5a76bd:         for (int i = lb ; i < ub ; i++)
1:99da210:             readers.add(MockSchema.sstable(i, i, true, cfs));
1:e5a76bd:         return copyOf(readers);
1:e5a76bd:     }
1:e5a76bd: 
1:e5a76bd:     private static void update(LifecycleTransaction txn, Iterable<SSTableReader> readers, boolean originals)
1:e5a76bd:     {
1:e5a76bd:         for (SSTableReader reader : readers)
1:e5a76bd:             txn.update(reader, originals);
1:e5a76bd:     }
1:e5a76bd: 
1:e5a76bd:     private static void obsolete(LifecycleTransaction txn, Iterable<SSTableReader> readers)
1:e5a76bd:     {
1:e5a76bd:         for (SSTableReader reader : readers)
1:e5a76bd:             txn.obsolete(reader);
1:e5a76bd:     }
1:e5a76bd: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:351c7ca
/////////////////////////////////////////////////////////////////////////
1:         LogTransaction.waitForDeletions();
commit:5726625
/////////////////////////////////////////////////////////////////////////
0:         TransactionLog.waitForDeletions();
commit:b09e60f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         TransactionLogs.waitForDeletions();
/////////////////////////////////////////////////////////////////////////
1: 
1:         @Override
1:         protected boolean commitCanThrow()
1:         {
1:             return true;
1:         }
commit:0bd5170
/////////////////////////////////////////////////////////////////////////
author:Joshua McKenzie
-------------------------------------------------------------------------------
commit:a1a260c
author:Chris Moos
-------------------------------------------------------------------------------
commit:1960e5b
/////////////////////////////////////////////////////////////////////////
1:         List<SSTableReader> readers = readers(0, 4, cfs);
1:         txn.cancel(readers.get(3));
author:stefania
-------------------------------------------------------------------------------
commit:99a84bc
/////////////////////////////////////////////////////////////////////////
1: import org.junit.BeforeClass;
/////////////////////////////////////////////////////////////////////////
1:     @BeforeClass
1:     public static void setUp()
1:     {
1:         MockSchema.cleanup();
1:     }
1: 
commit:99da210
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.ColumnFamilyStore;
0: import org.apache.cassandra.metrics.ColumnFamilyMetrics;
/////////////////////////////////////////////////////////////////////////
1:         ColumnFamilyStore cfs = MockSchema.newCFS();
1:         SSTableReader[] readers = readersArray(0, 3, cfs);
1:         SSTableReader[] readers2 = readersArray(0, 4, cfs);
1:         SSTableReader[] readers3 = readersArray(0, 4, cfs);
/////////////////////////////////////////////////////////////////////////
1:         ColumnFamilyStore cfs = MockSchema.newCFS();
1:         List<SSTableReader> readers = readers(0, 3, cfs);
1:         SSTableReader update = readers(1, 2, cfs).get(0);
1:         SSTableReader fresh = readers(3, 4,cfs).get(0);
1:         SSTableReader notPresent = readers(4, 5, cfs).get(0);
/////////////////////////////////////////////////////////////////////////
1:         ColumnFamilyStore cfs = MockSchema.newCFS();
0:         List<SSTableReader> readers = readers(0, 3, cfs);
/////////////////////////////////////////////////////////////////////////
1:         txn.update(readers(1, 2, cfs).get(0), true);
/////////////////////////////////////////////////////////////////////////
1:         private static Tracker tracker(ColumnFamilyStore cfs, List<SSTableReader> readers)
1:             Tracker tracker = new Tracker(cfs, false);
1:             this(MockSchema.newCFS());
1:         private TxnTest(ColumnFamilyStore cfs)
1:             this(cfs, readers(0, 8, cfs));
1:         }
1: 
1:         private TxnTest(ColumnFamilyStore cfs, List<SSTableReader> readers)
1:         {
1:             this(tracker(cfs, readers), readers);
/////////////////////////////////////////////////////////////////////////
1:             update(txn, loggedUpdate = readers(0, 2, tracker.cfstore), true);
1:             update(txn, loggedNew = readers(8, 10, tracker.cfstore), false);
1:             update(txn, stagedNew = readers(10, 12, tracker.cfstore), false);
/////////////////////////////////////////////////////////////////////////
1:     private static SSTableReader[] readersArray(int lb, int ub, ColumnFamilyStore cfs)
1:         return readers(lb, ub, cfs).toArray(new SSTableReader[0]);
1:     private static List<SSTableReader> readers(int lb, int ub, ColumnFamilyStore cfs)
1:             readers.add(MockSchema.sstable(i, i, true, cfs));
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:e5a76bd
/////////////////////////////////////////////////////////////////////////
1: /*
1: * Licensed to the Apache Software Foundation (ASF) under one
1: * or more contributor license agreements.  See the NOTICE file
1: * distributed with this work for additional information
1: * regarding copyright ownership.  The ASF licenses this file
1: * to you under the Apache License, Version 2.0 (the
1: * "License"); you may not use this file except in compliance
1: * with the License.  You may obtain a copy of the License at
1: *
1: *    http://www.apache.org/licenses/LICENSE-2.0
1: *
1: * Unless required by applicable law or agreed to in writing,
1: * software distributed under the License is distributed on an
1: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1: * KIND, either express or implied.  See the License for the
1: * specific language governing permissions and limitations
1: * under the License.
1: */
1: package org.apache.cassandra.db.lifecycle;
1: 
1: import java.util.ArrayList;
1: import java.util.List;
1: 
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Test;
1: 
1: import junit.framework.Assert;
1: import org.apache.cassandra.MockSchema;
1: import org.apache.cassandra.config.DatabaseDescriptor;
1: import org.apache.cassandra.db.compaction.OperationType;
1: import org.apache.cassandra.db.lifecycle.LifecycleTransaction.ReaderState;
1: import org.apache.cassandra.db.lifecycle.LifecycleTransaction.ReaderState.Action;
0: import org.apache.cassandra.io.sstable.SSTableDeletingTask;
1: import org.apache.cassandra.io.sstable.format.SSTableReader;
1: import org.apache.cassandra.utils.Pair;
1: import org.apache.cassandra.utils.concurrent.AbstractTransactionalTest;
1: import org.apache.cassandra.utils.concurrent.Transactional.AbstractTransactional.State;
1: 
1: import static com.google.common.base.Predicates.in;
1: import static com.google.common.collect.ImmutableList.copyOf;
1: import static com.google.common.collect.ImmutableList.of;
1: import static com.google.common.collect.Iterables.all;
1: import static com.google.common.collect.Iterables.concat;
1: import static com.google.common.collect.Iterables.size;
1: import static org.apache.cassandra.db.lifecycle.Helpers.idIn;
1: import static org.apache.cassandra.db.lifecycle.Helpers.orIn;
1: import static org.apache.cassandra.db.lifecycle.Helpers.select;
1: 
1: public class LifecycleTransactionTest extends AbstractTransactionalTest
1: {
1:     private boolean incrementalBackups;
1: 
1:     @Before
1:     public void disableIncrementalBackup()
1:     {
1:         incrementalBackups = DatabaseDescriptor.isIncrementalBackupsEnabled();
1:         DatabaseDescriptor.setIncrementalBackupsEnabled(false);
1:     }
1:     @After
1:     public void restoreIncrementalBackup()
1:     {
1:         DatabaseDescriptor.setIncrementalBackupsEnabled(incrementalBackups);
1:     }
1: 
1:     @Test
1:     public void testUpdates() // (including obsoletion)
1:     {
1:         Tracker tracker = new Tracker(null, false);
0:         SSTableReader[] readers = readersArray(0, 3);
0:         SSTableReader[] readers2 = readersArray(0, 4);
0:         SSTableReader[] readers3 = readersArray(0, 4);
1:         tracker.addInitialSSTables(copyOf(readers));
1:         LifecycleTransaction txn = tracker.tryModify(copyOf(readers), OperationType.UNKNOWN);
1: 
1:         txn.update(readers2[0], true);
1:         txn.obsolete(readers[1]);
1: 
1:         Assert.assertTrue(txn.isObsolete(readers[1]));
1:         Assert.assertFalse(txn.isObsolete(readers[0]));
1: 
1:         testBadUpdate(txn, readers2[0], true);  // same reader && instances
1:         testBadUpdate(txn, readers2[1], true);  // staged obsolete; cannot update
1:         testBadUpdate(txn, readers3[0], true);  // same reader, diff instances
1:         testBadUpdate(txn, readers2[2], false); // incorrectly declared original status
1:         testBadUpdate(txn, readers2[3], true); // incorrectly declared original status
1: 
1:         testBadObsolete(txn, readers[1]);  // staged obsolete; cannot obsolete again
1:         testBadObsolete(txn, readers2[0]);  // staged update; cannot obsolete
1: 
1:         txn.update(readers2[3], false);
1: 
1:         Assert.assertEquals(3, tracker.getView().compacting.size());
1:         txn.checkpoint();
1:         Assert.assertTrue(txn.isObsolete(readers[1]));
1:         Assert.assertFalse(txn.isObsolete(readers[0]));
1:         Assert.assertEquals(4, tracker.getView().compacting.size());
1:         Assert.assertEquals(3, tracker.getView().sstables.size());
1:         Assert.assertEquals(3, size(txn.current()));
1:         Assert.assertTrue(all(of(readers2[0], readers[2], readers2[3]), idIn(tracker.getView().sstablesMap)));
1:         Assert.assertTrue(all(txn.current(), idIn(tracker.getView().sstablesMap)));
1: 
1:         testBadObsolete(txn, readers[1]);  // logged obsolete; cannot obsolete again
1:         testBadObsolete(txn, readers2[2]);  // never seen instance; cannot obsolete
1:         testBadObsolete(txn, readers2[3]);  // non-original; cannot obsolete
1:         testBadUpdate(txn, readers3[1], true);  // logged obsolete; cannot update
1:         testBadUpdate(txn, readers2[0], true);  // same instance as logged update
1: 
1:         txn.update(readers3[0], true);  // same reader as logged update, different instance
1:         txn.checkpoint();
1: 
1:         Assert.assertEquals(4, tracker.getView().compacting.size());
1:         Assert.assertEquals(3, tracker.getView().sstables.size());
1:         Assert.assertEquals(3, size(txn.current()));
1:         Assert.assertTrue(all(of(readers3[0], readers[2], readers2[3]), idIn(tracker.getView().sstablesMap)));
1:         Assert.assertTrue(all(txn.current(), idIn(tracker.getView().sstablesMap)));
1: 
1:         testBadObsolete(txn, readers2[0]); // not current version of sstable
1: 
1:         txn.obsoleteOriginals();
1:         txn.checkpoint();
1:         Assert.assertEquals(1, tracker.getView().sstables.size());
1:         txn.obsoleteOriginals(); // should be no-op
1:         txn.checkpoint();
1:         Assert.assertEquals(1, tracker.getView().sstables.size());
1:         Assert.assertEquals(4, tracker.getView().compacting.size());
1:     }
1: 
1:     @Test
1:     public void testCancellation()
1:     {
1:         Tracker tracker = new Tracker(null, false);
0:         List<SSTableReader> readers = readers(0, 3);
1:         tracker.addInitialSSTables(readers);
1:         LifecycleTransaction txn = tracker.tryModify(readers, OperationType.UNKNOWN);
1: 
1:         SSTableReader cancel = readers.get(0);
0:         SSTableReader update = readers(1, 2).get(0);
0:         SSTableReader fresh = readers(3, 4).get(0);
0:         SSTableReader notPresent = readers(4, 5).get(0);
1: 
1:         txn.cancel(cancel);
1:         txn.update(update, true);
1:         txn.update(fresh, false);
1: 
1:         testBadCancel(txn, cancel);
1:         testBadCancel(txn, update);
1:         testBadCancel(txn, fresh);
1:         testBadCancel(txn, notPresent);
1:         Assert.assertEquals(2, txn.originals().size());
1:         Assert.assertEquals(2, tracker.getView().compacting.size());
1:         Assert.assertTrue(all(readers.subList(1, 3), idIn(tracker.getView().compacting)));
1: 
1:         txn.checkpoint();
1: 
1:         testBadCancel(txn, cancel);
1:         testBadCancel(txn, update);
1:         testBadCancel(txn, fresh);
1:         testBadCancel(txn, notPresent);
1:         Assert.assertEquals(2, txn.originals().size());
1:         Assert.assertEquals(3, tracker.getView().compacting.size());
1:         Assert.assertEquals(3, size(txn.current()));
1:         Assert.assertTrue(all(concat(readers.subList(1, 3), of(fresh)), idIn(tracker.getView().compacting)));
1: 
1:         txn.cancel(readers.get(2));
1:         Assert.assertEquals(1, txn.originals().size());
1:         Assert.assertEquals(2, tracker.getView().compacting.size());
1:         Assert.assertEquals(2, size(txn.current()));
1:         Assert.assertTrue(all(of(readers.get(1), fresh), idIn(tracker.getView().compacting)));
1:     }
1: 
1:     @Test
1:     public void testSplit()
1:     {
1:         Tracker tracker = new Tracker(null, false);
0:         List<SSTableReader> readers = readers(0, 3);
1:         tracker.addInitialSSTables(readers);
1:         LifecycleTransaction txn = tracker.tryModify(readers, OperationType.UNKNOWN);
1:         LifecycleTransaction txn2 = txn.split(readers.subList(0, 1));
1:         Assert.assertEquals(2, txn.originals().size());
1:         Assert.assertTrue(all(readers.subList(1, 3), in(txn.originals())));
1:         Assert.assertEquals(1, txn2.originals().size());
1:         Assert.assertTrue(all(readers.subList(0, 1), in(txn2.originals())));
0:         txn.update(readers(1, 2).get(0), true);
1:         boolean failed = false;
1:         try
1:         {
1:             txn.split(readers.subList(2, 3));
1:         }
1:         catch (Throwable t)
1:         {
1:             failed = true;
1:         }
1:         Assert.assertTrue(failed);
1:     }
1: 
1:     private static void testBadUpdate(LifecycleTransaction txn, SSTableReader update, boolean original)
1:     {
1:         boolean failed = false;
1:         try
1:         {
1:             txn.update(update, original);
1:         }
1:         catch (Throwable t)
1:         {
1:             failed = true;
1:         }
1:         Assert.assertTrue(failed);
1:     }
1: 
1:     private static void testBadObsolete(LifecycleTransaction txn, SSTableReader update)
1:     {
1:         boolean failed = false;
1:         try
1:         {
1:             txn.obsolete(update);
1:         }
1:         catch (Throwable t)
1:         {
1:             failed = true;
1:         }
1:         Assert.assertTrue(failed);
1:     }
1: 
1:     private static void testBadCancel(LifecycleTransaction txn, SSTableReader cancel)
1:     {
1:         boolean failed = false;
1:         try
1:         {
1:             txn.cancel(cancel);
1:         }
1:         catch (Throwable t)
1:         {
1:             failed = true;
1:         }
1:         Assert.assertTrue(failed);
1:     }
1: 
1:     protected TestableTransaction newTest()
1:     {
0:         SSTableDeletingTask.waitForDeletions();
1:         SSTableReader.resetTidying();
1:         return new TxnTest();
1:     }
1: 
1:     private static final class TxnTest extends TestableTransaction
1:     {
1:         final List<SSTableReader> originals;
1:         final List<SSTableReader> untouchedOriginals;
1:         final List<SSTableReader> loggedUpdate;
1:         final List<SSTableReader> loggedObsolete;
1:         final List<SSTableReader> stagedObsolete;
1:         final List<SSTableReader> loggedNew;
1:         final List<SSTableReader> stagedNew;
1:         final Tracker tracker;
1:         final LifecycleTransaction txn;
1: 
0:         private static Tracker tracker(List<SSTableReader> readers)
1:         {
0:             Tracker tracker = new Tracker(MockSchema.cfs, false);
1:             tracker.addInitialSSTables(readers);
1:             return tracker;
1:         }
1: 
1:         private TxnTest()
1:         {
0:             this(readers(0, 8));
1:         }
1: 
0:         private TxnTest(List<SSTableReader> readers)
1:         {
0:             this(tracker(readers), readers);
1:         }
1: 
1:         private TxnTest(Tracker tracker, List<SSTableReader> readers)
1:         {
1:             this(tracker, readers, tracker.tryModify(readers, OperationType.UNKNOWN));
1:         }
1: 
1:         private TxnTest(Tracker tracker, List<SSTableReader> readers, LifecycleTransaction txn)
1:         {
1:             super(txn);
1:             this.tracker = tracker;
1:             this.originals = readers;
1:             this.txn = txn;
0:             update(txn, loggedUpdate = readers(0, 2), true);
1:             obsolete(txn, loggedObsolete = readers.subList(2, 4));
0:             update(txn, loggedNew = readers(8, 10), false);
1:             txn.checkpoint();
0:             update(txn, stagedNew = readers(10, 12), false);
1:             obsolete(txn, stagedObsolete = copyOf(concat(loggedUpdate, originals.subList(4, 6))));
1:             untouchedOriginals = originals.subList(6, 8);
1:         }
1: 
1:         private ReaderState state(SSTableReader reader, State state)
1:         {
1:             SSTableReader original = select(reader, originals);
1:             boolean isOriginal = original != null;
1: 
1:             switch (state)
1:             {
1:                 case ABORTED:
1:                 {
1:                     return new ReaderState(Action.NONE, Action.NONE, original, original, isOriginal);
1:                 }
1: 
1:                 case READY_TO_COMMIT:
1:                 {
1:                     ReaderState prev = state(reader, State.IN_PROGRESS);
1:                     Action logged;
1:                     SSTableReader visible;
1:                     if (prev.staged == Action.NONE)
1:                     {
1:                         logged = prev.logged;
1:                         visible = prev.currentlyVisible;
1:                     }
1:                     else
1:                     {
1:                         logged = prev.staged;
1:                         visible = prev.nextVisible;
1:                     }
1:                     return new ReaderState(logged, Action.NONE, visible, visible, isOriginal);
1:                 }
1: 
1:                 case IN_PROGRESS:
1:                 {
1:                     Action logged = Action.get(loggedUpdate.contains(reader) || loggedNew.contains(reader), loggedObsolete.contains(reader));
1:                     Action staged = Action.get(stagedNew.contains(reader), stagedObsolete.contains(reader));
1:                     SSTableReader currentlyVisible = ReaderState.visible(reader, in(loggedObsolete), loggedNew, loggedUpdate, originals);
1:                     SSTableReader nextVisible = ReaderState.visible(reader, orIn(stagedObsolete, loggedObsolete), stagedNew, loggedNew, loggedUpdate, originals);
1:                     return new ReaderState(logged, staged, currentlyVisible, nextVisible, isOriginal);
1:                 }
1:             }
1:             throw new IllegalStateException();
1:         }
1: 
1:         private List<Pair<SSTableReader, ReaderState>> states(State state)
1:         {
1:             List<Pair<SSTableReader, ReaderState>> result = new ArrayList<>();
1:             for (SSTableReader reader : concat(originals, loggedNew, stagedNew))
1:                 result.add(Pair.create(reader, state(reader, state)));
1:             return result;
1:         }
1: 
1:         protected void doAssert(State state)
1:         {
1:             for (Pair<SSTableReader, ReaderState> pair : states(state))
1:             {
1:                 SSTableReader reader = pair.left;
1:                 ReaderState readerState = pair.right;
1: 
1:                 Assert.assertEquals(readerState, txn.state(reader));
1:                 Assert.assertEquals(readerState.currentlyVisible, tracker.getView().sstablesMap.get(reader));
1:                 if (readerState.currentlyVisible == null && readerState.nextVisible == null && !readerState.original)
1:                     Assert.assertTrue(reader.selfRef().globalCount() == 0);
1:             }
1:         }
1: 
1:         protected void assertInProgress() throws Exception
1:         {
1:             doAssert(State.IN_PROGRESS);
1:         }
1: 
1:         protected void assertPrepared() throws Exception
1:         {
1:             doAssert(State.READY_TO_COMMIT);
1:         }
1: 
1:         protected void assertAborted() throws Exception
1:         {
1:             doAssert(State.ABORTED);
1:             Assert.assertEquals(0, tracker.getView().compacting.size());
1:             Assert.assertEquals(8, tracker.getView().sstables.size());
1:             for (SSTableReader reader : concat(loggedNew, stagedNew))
1:                 Assert.assertTrue(reader.selfRef().globalCount() == 0);
1:         }
1: 
1:         protected void assertCommitted() throws Exception
1:         {
1:             doAssert(State.READY_TO_COMMIT);
1:             Assert.assertEquals(0, tracker.getView().compacting.size());
1:             Assert.assertEquals(6, tracker.getView().sstables.size());
1:             for (SSTableReader reader : concat(loggedObsolete, stagedObsolete))
1:                 Assert.assertTrue(reader.selfRef().globalCount() == 0);
1:         }
1:     }
1: 
0:     private static SSTableReader[] readersArray(int lb, int ub)
1:     {
0:         return readers(lb, ub).toArray(new SSTableReader[0]);
1:     }
1: 
0:     private static List<SSTableReader> readers(int lb, int ub)
1:     {
1:         List<SSTableReader> readers = new ArrayList<>();
1:         for (int i = lb ; i < ub ; i++)
0:             readers.add(MockSchema.sstable(i, i, true));
1:         return copyOf(readers);
1:     }
1: 
1:     private static void update(LifecycleTransaction txn, Iterable<SSTableReader> readers, boolean originals)
1:     {
1:         for (SSTableReader reader : readers)
1:             txn.update(reader, originals);
1:     }
1: 
1:     private static void obsolete(LifecycleTransaction txn, Iterable<SSTableReader> readers)
1:     {
1:         for (SSTableReader reader : readers)
1:             txn.obsolete(reader);
1:     }
1: }
============================================================================