1:2e1e98a: package org.apache.cassandra.stress.settings;
1:9f14856: /*
1:89f275c:  *
1:9f14856:  * Licensed to the Apache Software Foundation (ASF) under one
1:9f14856:  * or more contributor license agreements.  See the NOTICE file
1:9f14856:  * distributed with this work for additional information
1:9f14856:  * regarding copyright ownership.  The ASF licenses this file
1:9f14856:  * to you under the Apache License, Version 2.0 (the
1:9f14856:  * "License"); you may not use this file except in compliance
1:9f14856:  * with the License.  You may obtain a copy of the License at
1:89f275c:  *
1:9f14856:  *   http://www.apache.org/licenses/LICENSE-2.0
1:89f275c:  *
1:9f14856:  * Unless required by applicable law or agreed to in writing,
1:9f14856:  * software distributed under the License is distributed on an
1:9f14856:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:9f14856:  * KIND, either express or implied.  See the License for the
1:9f14856:  * specific language governing permissions and limitations
1:9f14856:  * under the License.
1:89f275c:  *
1:9f14856:  */
1:9f14856: 
3:2e1e98a: 
1:2e1e98a: import java.io.Serializable;
1:2e1e98a: import java.util.*;
1:2e1e98a: 
1:2e1e98a: import com.datastax.driver.core.Metadata;
1:a78451e: import com.google.common.collect.ImmutableMap;
1:016a2b0: import org.apache.cassandra.config.EncryptionOptions;
1:2e1e98a: import org.apache.cassandra.stress.util.JavaDriverClient;
1:f42e235: import org.apache.cassandra.stress.util.ResultLogger;
1:2e1e98a: import org.apache.cassandra.stress.util.SimpleThriftClient;
1:2e1e98a: import org.apache.cassandra.stress.util.SmartThriftClient;
1:7536429: import org.apache.cassandra.stress.util.ThriftClient;
1:a78451e: import org.apache.cassandra.thrift.AuthenticationRequest;
1:2e1e98a: import org.apache.cassandra.thrift.Cassandra;
1:2e1e98a: import org.apache.cassandra.thrift.InvalidRequestException;
1:2e1e98a: import org.apache.cassandra.transport.SimpleClient;
1:2e1e98a: import org.apache.thrift.protocol.TBinaryProtocol;
1:2e1e98a: import org.apache.thrift.transport.TTransport;
1:2e1e98a: 
1:2e1e98a: public class StressSettings implements Serializable
4:2e1e98a: {
1:2e1e98a:     public final SettingsCommand command;
1:2e1e98a:     public final SettingsRate rate;
1:0580fb2:     public final SettingsPopulation generate;
1:0580fb2:     public final SettingsInsert insert;
1:2e1e98a:     public final SettingsColumn columns;
1:0580fb2:     public final SettingsErrors errors;
1:2e1e98a:     public final SettingsLog log;
1:2e1e98a:     public final SettingsMode mode;
1:2e1e98a:     public final SettingsNode node;
1:2e1e98a:     public final SettingsSchema schema;
1:2e1e98a:     public final SettingsTransport transport;
1:2e1e98a:     public final SettingsPort port;
1:2e1e98a:     public final String sendToDaemon;
1:e4467a0:     public final SettingsGraph graph;
1:f27ab29:     public final SettingsTokenRange tokenRange;
1:2e1e98a: 
1:e4467a0:     public StressSettings(SettingsCommand command,
1:e4467a0:                           SettingsRate rate,
1:e4467a0:                           SettingsPopulation generate,
1:e4467a0:                           SettingsInsert insert,
1:e4467a0:                           SettingsColumn columns,
1:e4467a0:                           SettingsErrors errors,
1:e4467a0:                           SettingsLog log,
1:e4467a0:                           SettingsMode mode,
1:e4467a0:                           SettingsNode node,
1:e4467a0:                           SettingsSchema schema,
1:e4467a0:                           SettingsTransport transport,
1:e4467a0:                           SettingsPort port,
1:e4467a0:                           String sendToDaemon,
1:f27ab29:                           SettingsGraph graph,
1:f27ab29:                           SettingsTokenRange tokenRange)
1:2e1e98a:     {
1:2e1e98a:         this.command = command;
1:2e1e98a:         this.rate = rate;
1:0580fb2:         this.insert = insert;
1:0580fb2:         this.generate = generate;
1:2e1e98a:         this.columns = columns;
1:0580fb2:         this.errors = errors;
1:2e1e98a:         this.log = log;
1:2e1e98a:         this.mode = mode;
1:2e1e98a:         this.node = node;
1:2e1e98a:         this.schema = schema;
1:2e1e98a:         this.transport = transport;
1:2e1e98a:         this.port = port;
1:2e1e98a:         this.sendToDaemon = sendToDaemon;
1:e4467a0:         this.graph = graph;
1:f27ab29:         this.tokenRange = tokenRange;
4:2e1e98a:     }
1:2e1e98a: 
1:7536429:     private SmartThriftClient tclient;
1:7536429: 
1:7536429:     /**
1:7536429:      * Thrift client connection
1:7536429:      * @return cassandra client connection
1:7536429:      */
1:7536429:     public synchronized ThriftClient getThriftClient()
1:7536429:     {
1:7536429:         if (mode.api != ConnectionAPI.THRIFT_SMART)
1:7536429:             return getSimpleThriftClient();
1:7536429: 
1:7536429:         if (tclient == null)
1:7536429:             tclient = getSmartThriftClient();
1:7536429: 
1:7536429:         return tclient;
1:7536429:     }
1:7536429: 
1:7536429:     private SmartThriftClient getSmartThriftClient()
1:2e1e98a:     {
1:2e1e98a:         Metadata metadata = getJavaDriverClient().getCluster().getMetadata();
1:2e1e98a:         return new SmartThriftClient(this, schema.keyspace, metadata);
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a:     /**
1:2e1e98a:      * Thrift client connection
1:2e1e98a:      * @return cassandra client connection
1:2e1e98a:      */
1:7536429:     private SimpleThriftClient getSimpleThriftClient()
1:2e1e98a:     {
1:2e1e98a:         return new SimpleThriftClient(getRawThriftClient(node.randomNode(), true));
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a:     public Cassandra.Client getRawThriftClient(boolean setKeyspace)
1:2e1e98a:     {
1:2e1e98a:         return getRawThriftClient(node.randomNode(), setKeyspace);
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a:     public Cassandra.Client getRawThriftClient(String host)
1:2e1e98a:     {
1:2e1e98a:         return getRawThriftClient(host, true);
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a:     public Cassandra.Client getRawThriftClient(String host, boolean setKeyspace)
1:2e1e98a:     {
1:2e1e98a:         Cassandra.Client client;
1:2e1e98a: 
1:3e2c610:         try
1:2e1e98a:         {
1:016a2b0:             TTransport transport = this.transport.getFactory().openTransport(host, port.thriftPort);
1:2e1e98a: 
1:2e1e98a:             client = new Cassandra.Client(new TBinaryProtocol(transport));
1:2e1e98a: 
1:2e1e98a:             if (mode.cqlVersion.isCql())
1:2e1e98a:                 client.set_cql_version(mode.cqlVersion.connectVersion);
1:2e1e98a: 
1:2e1e98a:             if (setKeyspace)
1:ce94010:                 client.set_keyspace(schema.keyspace);
1:a78451e: 
1:a78451e:             if (mode.username != null)
1:a78451e:                 client.login(new AuthenticationRequest(ImmutableMap.of("username", mode.username, "password", mode.password)));
1:a78451e: 
1:2e1e98a:         }
1:2e1e98a:         catch (InvalidRequestException e)
1:2e1e98a:         {
1:2e1e98a:             throw new RuntimeException(e.getWhy());
1:2e1e98a:         }
2:2e1e98a:         catch (Exception e)
1:2e1e98a:         {
1:0580fb2:             throw new RuntimeException(e);
1:2e1e98a:         }
1:2e1e98a: 
1:2e1e98a:         return client;
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a: 
1:2e1e98a:     public SimpleClient getSimpleNativeClient()
1:2e1e98a:     {
3:2e1e98a:         try
1:2e1e98a:         {
1:2e1e98a:             String currentNode = node.randomNode();
1:2e1e98a:             SimpleClient client = new SimpleClient(currentNode, port.nativePort);
1:2e1e98a:             client.connect(false);
1:ce94010:             client.execute("USE \"" + schema.keyspace + "\";", org.apache.cassandra.db.ConsistencyLevel.ONE);
1:2e1e98a:             return client;
1:2e1e98a:         }
1:2e1e98a:         catch (Exception e)
1:2e1e98a:         {
2:2e1e98a:             throw new RuntimeException(e.getMessage());
1:2e1e98a:         }
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a:     private static volatile JavaDriverClient client;
1:7043744:     private static volatile int numFailures;
1:7043744:     private static int MAX_NUM_FAILURES = 10;
1:2e1e98a: 
1:2e1e98a:     public JavaDriverClient getJavaDriverClient()
1:2e1e98a:     {
1:7536429:         return getJavaDriverClient(true);
1:7536429:     }
1:7536429: 
1:7536429:     public JavaDriverClient getJavaDriverClient(boolean setKeyspace)
1:7536429:     {
1:2e1e98a:         if (client != null)
1:2e1e98a:             return client;
1:2e1e98a: 
1:7043744:         synchronized (this)
1:2e1e98a:         {
1:7043744:             if (numFailures >= MAX_NUM_FAILURES)
1:7043744:                 throw new RuntimeException("Failed to create client too many times");
1:7043744: 
1:7043744:             try
1:2e1e98a:             {
1:2e1e98a:                 String currentNode = node.randomNode();
1:2e1e98a:                 if (client != null)
1:2e1e98a:                     return client;
1:2e1e98a: 
1:016a2b0:                 EncryptionOptions.ClientEncryptionOptions encOptions = transport.getEncryptionOptions();
1:eea042b:                 JavaDriverClient c = new JavaDriverClient(this, currentNode, port.nativePort, encOptions);
1:2e1e98a:                 c.connect(mode.compression());
1:7536429:                 if (setKeyspace)
1:7536429:                     c.execute("USE \"" + schema.keyspace + "\";", org.apache.cassandra.db.ConsistencyLevel.ONE);
1:7536429: 
1:2e1e98a:                 return client = c;
1:2e1e98a:             }
1:7043744:             catch (Exception e)
1:7043744:             {
1:7043744:                 numFailures +=1;
1:7043744:                 throw new RuntimeException(e);
1:7043744:             }
1:2e1e98a:         }
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a:     public void maybeCreateKeyspaces()
1:2e1e98a:     {
1:0580fb2:         if (command.type == Command.WRITE || command.type == Command.COUNTER_WRITE)
1:2e1e98a:             schema.createKeySpaces(this);
1:0580fb2:         else if (command.type == Command.USER)
1:0580fb2:             ((SettingsCommandUser) command).profile.maybeCreateSchema(this);
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a:     public static StressSettings parse(String[] args)
1:3e2c610:     {
1:7043744:         args = repairParams(args);
1:7043744:         final Map<String, String[]> clArgs = parseMap(args);
1:7043744:         if (clArgs.containsKey("legacy"))
1:7043744:             return Legacy.build(Arrays.copyOfRange(args, 1, args.length));
1:7043744:         if (SettingsMisc.maybeDoSpecial(clArgs))
1:7043744:             return null;
1:7043744:         return get(clArgs);
1:7043744: 
1:3e2c610:     }
1:2e1e98a: 
1:c643bbc:     private static String[] repairParams(String[] args)
1:c643bbc:     {
1:c643bbc:         StringBuilder sb = new StringBuilder();
1:c643bbc:         boolean first = true;
1:c643bbc:         for (String arg : args)
1:c643bbc:         {
1:c643bbc:             if (!first)
1:c643bbc:                 sb.append(" ");
1:c643bbc:             sb.append(arg);
1:c643bbc:             first = false;
1:c643bbc:         }
1:c643bbc:         return sb.toString()
1:f57ec8c:                  .replaceAll("\\s+([,=()])", "$1")
1:f57ec8c:                  .replaceAll("([,=(])\\s+", "$1")
1:c643bbc:                  .split(" +");
1:c643bbc:     }
1:c643bbc: 
1:2e1e98a:     public static StressSettings get(Map<String, String[]> clArgs)
1:2e1e98a:     {
1:2e1e98a:         SettingsCommand command = SettingsCommand.get(clArgs);
1:2e1e98a:         if (command == null)
1:2e1e98a:             throw new IllegalArgumentException("No command specified");
1:2e1e98a:         String sendToDaemon = SettingsMisc.getSendToDaemon(clArgs);
1:2e1e98a:         SettingsPort port = SettingsPort.get(clArgs);
1:2e1e98a:         SettingsRate rate = SettingsRate.get(clArgs, command);
1:0580fb2:         SettingsPopulation generate = SettingsPopulation.get(clArgs, command);
1:f27ab29:         SettingsTokenRange tokenRange = SettingsTokenRange.get(clArgs);
1:0580fb2:         SettingsInsert insert = SettingsInsert.get(clArgs);
1:2e1e98a:         SettingsColumn columns = SettingsColumn.get(clArgs);
1:0580fb2:         SettingsErrors errors = SettingsErrors.get(clArgs);
1:2e1e98a:         SettingsLog log = SettingsLog.get(clArgs);
1:2e1e98a:         SettingsMode mode = SettingsMode.get(clArgs);
1:2e1e98a:         SettingsNode node = SettingsNode.get(clArgs);
1:7536429:         SettingsSchema schema = SettingsSchema.get(clArgs, command);
1:2e1e98a:         SettingsTransport transport = SettingsTransport.get(clArgs);
1:e4467a0:         SettingsGraph graph = SettingsGraph.get(clArgs, command);
1:2e1e98a:         if (!clArgs.isEmpty())
1:2e1e98a:         {
1:2e1e98a:             printHelp();
1:2e1e98a:             System.out.println("Error processing command line arguments. The following were ignored:");
1:2e1e98a:             for (Map.Entry<String, String[]> e : clArgs.entrySet())
1:2e1e98a:             {
1:2e1e98a:                 System.out.print(e.getKey());
1:2e1e98a:                 for (String v : e.getValue())
1:2e1e98a:                 {
1:2e1e98a:                     System.out.print(" ");
1:2e1e98a:                     System.out.print(v);
1:2e1e98a:                 }
1:2e1e98a:                 System.out.println();
1:2e1e98a:             }
1:3e2c610:             System.exit(1);
1:3e2c610:         }
1:e4467a0: 
1:89f275c:         return new StressSettings(command, rate, generate, insert, columns, errors, log, mode, node, schema, transport, port, sendToDaemon, graph, tokenRange);
1:2e1e98a:     }
1:2e1e98a: 
1:2e1e98a:     private static Map<String, String[]> parseMap(String[] args)
1:3e2c610:     {
1:2e1e98a:         // first is the main command/operation, so specified without a -
1:2e1e98a:         if (args.length == 0)
1:2e1e98a:         {
1:2e1e98a:             System.out.println("No command provided");
1:2e1e98a:             printHelp();
3:2e1e98a:             System.exit(1);
1:2e1e98a:         }
1:2e1e98a:         final LinkedHashMap<String, String[]> r = new LinkedHashMap<>();
1:2e1e98a:         String key = null;
1:2e1e98a:         List<String> params = new ArrayList<>();
1:2e1e98a:         for (int i = 0 ; i < args.length ; i++)
1:2e1e98a:         {
1:2e1e98a:             if (i == 0 || args[i].startsWith("-"))
1:2e1e98a:             {
1:2e1e98a:                 if (i > 0)
1:3e2c610:                     putParam(key, params.toArray(new String[0]), r);
1:2e1e98a:                 key = args[i].toLowerCase();
1:2e1e98a:                 params.clear();
1:2e1e98a:             }
1:2e1e98a:             else
1:2e1e98a:                 params.add(args[i]);
1:2e1e98a:         }
1:3e2c610:         putParam(key, params.toArray(new String[0]), r);
1:2e1e98a:         return r;
1:2e1e98a:     }
1:2e1e98a: 
1:3e2c610:     private static void putParam(String key, String[] args, Map<String, String[]> clArgs)
1:3e2c610:     {
1:3e2c610:         String[] prev = clArgs.put(key, args);
1:3e2c610:         if (prev != null)
1:3e2c610:             throw new IllegalArgumentException(key + " is defined multiple times. Each option/command can be specified at most once.");
1:3e2c610:     }
1:3e2c610: 
1:2e1e98a:     public static void printHelp()
1:2e1e98a:     {
1:2e1e98a:         SettingsMisc.printHelp();
1:2e1e98a:     }
1:2e1e98a: 
1:f42e235:     public void printSettings(ResultLogger out)
1:938faa2:     {
1:938faa2:         out.println("******************** Stress Settings ********************");
1:938faa2:         // done
1:938faa2:         out.println("Command:");
1:938faa2:         command.printSettings(out);
1:938faa2:         out.println("Rate:");
1:938faa2:         rate.printSettings(out);
1:938faa2:         out.println("Population:");
1:938faa2:         generate.printSettings(out);
1:938faa2:         out.println("Insert:");
1:938faa2:         insert.printSettings(out);
1:938faa2:         if (command.type != Command.USER)
1:938faa2:         {
1:938faa2:             out.println("Columns:");
1:938faa2:             columns.printSettings(out);
1:938faa2:         }
1:938faa2:         out.println("Errors:");
1:938faa2:         errors.printSettings(out);
1:938faa2:         out.println("Log:");
1:938faa2:         log.printSettings(out);
1:938faa2:         out.println("Mode:");
1:938faa2:         mode.printSettings(out);
1:938faa2:         out.println("Node:");
1:938faa2:         node.printSettings(out);
1:938faa2:         out.println("Schema:");
1:938faa2:         schema.printSettings(out);
1:938faa2:         out.println("Transport:");
1:938faa2:         transport.printSettings(out);
1:938faa2:         out.println("Port:");
1:938faa2:         port.printSettings(out);
1:938faa2:         out.println("Send To Daemon:");
1:938faa2:         out.printf("  " + (sendToDaemon != null ? sendToDaemon : "*not set*") + "%n");
1:938faa2:         out.println("Graph:");
1:938faa2:         graph.printSettings(out);
1:938faa2:         out.println("TokenRange:");
1:938faa2:         tokenRange.printSettings(out);
1:938faa2: 
1:938faa2:         if (command.type == Command.USER)
1:938faa2:         {
1:938faa2:             out.println();
1:938faa2:             out.println("******************** Profile ********************");
1:938faa2:             ((SettingsCommandUser) command).profile.printSettings(out, this);
1:938faa2:         }
1:938faa2:         out.println();
1:938faa2: 
1:938faa2:     }
1:938faa2: 
1:2e1e98a:     public synchronized void disconnect()
1:2e1e98a:     {
1:2e1e98a:         if (client == null)
1:2e1e98a:             return;
1:2e1e98a: 
1:2e1e98a:         client.disconnect();
1:2e1e98a:         client = null;
1:2e1e98a:     }
1:2e1e98a: }
============================================================================
author:Christopher Batey
-------------------------------------------------------------------------------
commit:f42e235
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.stress.util.ResultLogger;
/////////////////////////////////////////////////////////////////////////
1:     public void printSettings(ResultLogger out)
author:Ben Slater
-------------------------------------------------------------------------------
commit:938faa2
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.stress.util.MultiPrintStream;
/////////////////////////////////////////////////////////////////////////
0:     public void printSettings(MultiPrintStream out)
1:     {
1:         out.println("******************** Stress Settings ********************");
1:         // done
1:         out.println("Command:");
1:         command.printSettings(out);
1:         out.println("Rate:");
1:         rate.printSettings(out);
1:         out.println("Population:");
1:         generate.printSettings(out);
1:         out.println("Insert:");
1:         insert.printSettings(out);
1:         if (command.type != Command.USER)
1:         {
1:             out.println("Columns:");
1:             columns.printSettings(out);
1:         }
1:         out.println("Errors:");
1:         errors.printSettings(out);
1:         out.println("Log:");
1:         log.printSettings(out);
1:         out.println("Mode:");
1:         mode.printSettings(out);
1:         out.println("Node:");
1:         node.printSettings(out);
1:         out.println("Schema:");
1:         schema.printSettings(out);
1:         out.println("Transport:");
1:         transport.printSettings(out);
1:         out.println("Port:");
1:         port.printSettings(out);
1:         out.println("Send To Daemon:");
1:         out.printf("  " + (sendToDaemon != null ? sendToDaemon : "*not set*") + "%n");
1:         out.println("Graph:");
1:         graph.printSettings(out);
1:         out.println("TokenRange:");
1:         tokenRange.printSettings(out);
1: 
1:         if (command.type == Command.USER)
1:         {
1:             out.println();
1:             out.println("******************** Profile ********************");
1:             ((SettingsCommandUser) command).profile.printSettings(out, this);
1:         }
1:         out.println();
1: 
1:     }
1: 
author:nitsanw
-------------------------------------------------------------------------------
commit:89f275c
/////////////////////////////////////////////////////////////////////////
1:  *
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
1:  *
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return new StressSettings(command, rate, generate, insert, columns, errors, log, mode, node, schema, transport, port, sendToDaemon, graph, tokenRange);
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:7043744
/////////////////////////////////////////////////////////////////////////
1:     private static volatile int numFailures;
1:     private static int MAX_NUM_FAILURES = 10;
/////////////////////////////////////////////////////////////////////////
1:         synchronized (this)
1:             if (numFailures >= MAX_NUM_FAILURES)
1:                 throw new RuntimeException("Failed to create client too many times");
1: 
1:             try
/////////////////////////////////////////////////////////////////////////
1:             catch (Exception e)
1:             {
1:                 numFailures +=1;
1:                 throw new RuntimeException(e);
1:             }
/////////////////////////////////////////////////////////////////////////
1:         args = repairParams(args);
1:         final Map<String, String[]> clArgs = parseMap(args);
1:         if (clArgs.containsKey("legacy"))
1:             return Legacy.build(Arrays.copyOfRange(args, 1, args.length));
1:         if (SettingsMisc.maybeDoSpecial(clArgs))
1:             return null;
1:         return get(clArgs);
1: 
commit:f27ab29
/////////////////////////////////////////////////////////////////////////
1:     public final SettingsTokenRange tokenRange;
/////////////////////////////////////////////////////////////////////////
1:                           SettingsGraph graph,
1:                           SettingsTokenRange tokenRange)
/////////////////////////////////////////////////////////////////////////
1:         this.tokenRange = tokenRange;
/////////////////////////////////////////////////////////////////////////
1:         SettingsTokenRange tokenRange = SettingsTokenRange.get(clArgs);
/////////////////////////////////////////////////////////////////////////
0:         return new StressSettings(command, rate, generate, insert, columns, samples, errors, log, mode, node, schema, transport, port, sendToDaemon, graph, tokenRange);
commit:232e12b
/////////////////////////////////////////////////////////////////////////
0:     public final SettingsTokenRange tokenRange;
0:     public StressSettings(SettingsCommand command, SettingsRate rate, SettingsPopulation generate, SettingsInsert insert, SettingsColumn columns, SettingsSamples samples, SettingsErrors errors, SettingsLog log, SettingsMode mode, SettingsNode node, SettingsSchema schema, SettingsTransport transport, SettingsPort port, String sendToDaemon, SettingsTokenRange tokenRange)
/////////////////////////////////////////////////////////////////////////
0:         this.tokenRange = tokenRange;
/////////////////////////////////////////////////////////////////////////
0:         SettingsTokenRange tokenRange = SettingsTokenRange.get(clArgs);
/////////////////////////////////////////////////////////////////////////
0:         return new StressSettings(command, rate, generate, insert, columns, samples, errors, log, mode, node, schema, transport, port, sendToDaemon, tokenRange);
author:Ryan McGuire
-------------------------------------------------------------------------------
commit:e4467a0
/////////////////////////////////////////////////////////////////////////
1:     public final SettingsGraph graph;
1:     public StressSettings(SettingsCommand command,
1:                           SettingsRate rate,
1:                           SettingsPopulation generate,
1:                           SettingsInsert insert,
1:                           SettingsColumn columns,
0:                           SettingsSamples samples,
1:                           SettingsErrors errors,
1:                           SettingsLog log,
1:                           SettingsMode mode,
1:                           SettingsNode node,
1:                           SettingsSchema schema,
1:                           SettingsTransport transport,
1:                           SettingsPort port,
1:                           String sendToDaemon,
0:                           SettingsGraph graph)
/////////////////////////////////////////////////////////////////////////
1:         this.graph = graph;
/////////////////////////////////////////////////////////////////////////
1:         SettingsGraph graph = SettingsGraph.get(clArgs, command);
/////////////////////////////////////////////////////////////////////////
1: 
0:         return new StressSettings(command, rate, generate, insert, columns, samples, errors, log, mode, node, schema, transport, port, sendToDaemon, graph);
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:f57ec8c
/////////////////////////////////////////////////////////////////////////
1:                  .replaceAll("\\s+([,=()])", "$1")
1:                  .replaceAll("([,=(])\\s+", "$1")
commit:c643bbc
/////////////////////////////////////////////////////////////////////////
0:             args = repairParams(args);
/////////////////////////////////////////////////////////////////////////
1:     private static String[] repairParams(String[] args)
1:     {
1:         StringBuilder sb = new StringBuilder();
1:         boolean first = true;
1:         for (String arg : args)
1:         {
1:             if (!first)
1:                 sb.append(" ");
1:             sb.append(arg);
1:             first = false;
1:         }
1:         return sb.toString()
0:                  .replaceAll("\s+([,=()])", "$1")
0:                  .replaceAll("([,=(])\s+", "$1")
1:                  .split(" +");
1:     }
1: 
commit:6c579a0
/////////////////////////////////////////////////////////////////////////
commit:cdba5aa
/////////////////////////////////////////////////////////////////////////
0:     public final SettingsSamples samples;
/////////////////////////////////////////////////////////////////////////
0:     public StressSettings(SettingsCommand command, SettingsRate rate, SettingsPopulation generate, SettingsInsert insert, SettingsColumn columns, SettingsSamples samples, SettingsErrors errors, SettingsLog log, SettingsMode mode, SettingsNode node, SettingsSchema schema, SettingsTransport transport, SettingsPort port, String sendToDaemon)
0:         this.samples = samples;
/////////////////////////////////////////////////////////////////////////
0:         SettingsSamples samples = SettingsSamples.get(clArgs);
/////////////////////////////////////////////////////////////////////////
0:         return new StressSettings(command, rate, generate, insert, columns, samples, errors, log, mode, node, schema, transport, port, sendToDaemon);
commit:eea042b
/////////////////////////////////////////////////////////////////////////
0: import com.datastax.driver.core.policies.DCAwareRoundRobinPolicy;
0: import com.datastax.driver.core.policies.RoundRobinPolicy;
0: import com.datastax.driver.core.policies.WhiteListPolicy;
/////////////////////////////////////////////////////////////////////////
1:                 JavaDriverClient c = new JavaDriverClient(this, currentNode, port.nativePort, encOptions);
commit:0580fb2
/////////////////////////////////////////////////////////////////////////
1:     public final SettingsPopulation generate;
1:     public final SettingsInsert insert;
1:     public final SettingsErrors errors;
/////////////////////////////////////////////////////////////////////////
0:     public StressSettings(SettingsCommand command, SettingsRate rate, SettingsPopulation generate, SettingsInsert insert, SettingsColumn columns, SettingsErrors errors, SettingsLog log, SettingsMode mode, SettingsNode node, SettingsSchema schema, SettingsTransport transport, SettingsPort port, String sendToDaemon)
1:         this.insert = insert;
1:         this.generate = generate;
1:         this.errors = errors;
/////////////////////////////////////////////////////////////////////////
1:             throw new RuntimeException(e);
/////////////////////////////////////////////////////////////////////////
1:         if (command.type == Command.WRITE || command.type == Command.COUNTER_WRITE)
1:         else if (command.type == Command.USER)
1:             ((SettingsCommandUser) command).profile.maybeCreateSchema(this);
/////////////////////////////////////////////////////////////////////////
1:         SettingsPopulation generate = SettingsPopulation.get(clArgs, command);
1:         SettingsInsert insert = SettingsInsert.get(clArgs);
1:         SettingsErrors errors = SettingsErrors.get(clArgs);
/////////////////////////////////////////////////////////////////////////
0:         return new StressSettings(command, rate, generate, insert, columns, errors, log, mode, node, schema, transport, port, sendToDaemon);
commit:7536429
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.stress.util.ThriftClient;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private SmartThriftClient tclient;
1: 
1:     /**
1:      * Thrift client connection
1:      * @return cassandra client connection
1:      */
1:     public synchronized ThriftClient getThriftClient()
1:     {
1:         if (mode.api != ConnectionAPI.THRIFT_SMART)
1:             return getSimpleThriftClient();
1: 
1:         if (tclient == null)
1:             tclient = getSmartThriftClient();
1: 
1:         return tclient;
1:     }
1: 
1:     private SmartThriftClient getSmartThriftClient()
/////////////////////////////////////////////////////////////////////////
1:     private SimpleThriftClient getSimpleThriftClient()
/////////////////////////////////////////////////////////////////////////
1:         return getJavaDriverClient(true);
1:     }
1: 
1:     public JavaDriverClient getJavaDriverClient(boolean setKeyspace)
1:     {
/////////////////////////////////////////////////////////////////////////
1:                 if (setKeyspace)
1:                     c.execute("USE \"" + schema.keyspace + "\";", org.apache.cassandra.db.ConsistencyLevel.ONE);
1: 
/////////////////////////////////////////////////////////////////////////
0:         if (command.type == Command.WRITE || command.type == Command.COUNTER_WRITE || command.type == Command.USER)
/////////////////////////////////////////////////////////////////////////
1:         SettingsSchema schema = SettingsSchema.get(clArgs, command);
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:a78451e
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.collect.ImmutableMap;
1: import org.apache.cassandra.thrift.AuthenticationRequest;
/////////////////////////////////////////////////////////////////////////
1: 
1:             if (mode.username != null)
1:                 client.login(new AuthenticationRequest(ImmutableMap.of("username", mode.username, "password", mode.password)));
1: 
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:92381fd
/////////////////////////////////////////////////////////////////////////
0:         if (command.type == Command.WRITE || command.type == Command.COUNTER_WRITE)
commit:3e2c610
/////////////////////////////////////////////////////////////////////////
1:         try
1:         {
0:             final Map<String, String[]> clArgs = parseMap(args);
0:             if (clArgs.containsKey("legacy"))
0:                 return Legacy.build(Arrays.copyOfRange(args, 1, args.length));
0:             if (SettingsMisc.maybeDoSpecial(clArgs))
1:                 System.exit(1);
0:             return get(clArgs);
1:         }
0:         catch (IllegalArgumentException e)
1:         {
0:             System.out.println(e.getMessage());
0:             throw new AssertionError();
1:         }
/////////////////////////////////////////////////////////////////////////
1:                     putParam(key, params.toArray(new String[0]), r);
1:         putParam(key, params.toArray(new String[0]), r);
1:     private static void putParam(String key, String[] args, Map<String, String[]> clArgs)
1:     {
1:         String[] prev = clArgs.put(key, args);
1:         if (prev != null)
1:             throw new IllegalArgumentException(key + " is defined multiple times. Each option/command can be specified at most once.");
1:     }
1: 
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:ce94010
/////////////////////////////////////////////////////////////////////////
1:                 client.set_keyspace(schema.keyspace);
/////////////////////////////////////////////////////////////////////////
1:             client.execute("USE \"" + schema.keyspace + "\";", org.apache.cassandra.db.ConsistencyLevel.ONE);
/////////////////////////////////////////////////////////////////////////
0:                 c.execute("USE \"" + schema.keyspace + "\";", org.apache.cassandra.db.ConsistencyLevel.ONE);
commit:9f14856
/////////////////////////////////////////////////////////////////////////
1: /*
0:  * 
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
0:  * 
1:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  * 
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
0:  * 
1:  */
1: 
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:016a2b0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.EncryptionOptions;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             TTransport transport = this.transport.getFactory().openTransport(host, port.thriftPort);
/////////////////////////////////////////////////////////////////////////
1:                 EncryptionOptions.ClientEncryptionOptions encOptions = transport.getEncryptionOptions();
0:                 JavaDriverClient c = new JavaDriverClient(currentNode, port.nativePort, encOptions);
author:Dave Brosius
-------------------------------------------------------------------------------
commit:e603555
/////////////////////////////////////////////////////////////////////////
author:belliottsmith
-------------------------------------------------------------------------------
commit:2e1e98a
/////////////////////////////////////////////////////////////////////////
1: package org.apache.cassandra.stress.settings;
1: 
1: import java.io.Serializable;
1: import java.util.*;
1: 
1: import com.datastax.driver.core.Metadata;
1: import org.apache.cassandra.stress.util.JavaDriverClient;
1: import org.apache.cassandra.stress.util.SimpleThriftClient;
1: import org.apache.cassandra.stress.util.SmartThriftClient;
1: import org.apache.cassandra.thrift.Cassandra;
1: import org.apache.cassandra.thrift.InvalidRequestException;
0: import org.apache.cassandra.thrift.TFramedTransportFactory;
1: import org.apache.cassandra.transport.SimpleClient;
1: import org.apache.thrift.protocol.TBinaryProtocol;
0: import org.apache.thrift.transport.TSocket;
1: import org.apache.thrift.transport.TTransport;
1: 
1: public class StressSettings implements Serializable
1: {
1: 
1:     public final SettingsCommand command;
1:     public final SettingsRate rate;
0:     public final SettingsKey keys;
1:     public final SettingsColumn columns;
1:     public final SettingsLog log;
1:     public final SettingsMode mode;
1:     public final SettingsNode node;
1:     public final SettingsSchema schema;
1:     public final SettingsTransport transport;
1:     public final SettingsPort port;
1:     public final String sendToDaemon;
1: 
0:     public StressSettings(SettingsCommand command, SettingsRate rate, SettingsKey keys, SettingsColumn columns, SettingsLog log, SettingsMode mode, SettingsNode node, SettingsSchema schema, SettingsTransport transport, SettingsPort port, String sendToDaemon)
1:     {
1:         this.command = command;
1:         this.rate = rate;
0:         this.keys = keys;
1:         this.columns = columns;
1:         this.log = log;
1:         this.mode = mode;
1:         this.node = node;
1:         this.schema = schema;
1:         this.transport = transport;
1:         this.port = port;
1:         this.sendToDaemon = sendToDaemon;
1:     }
1: 
0:     public SmartThriftClient getSmartThriftClient()
1:     {
1:         Metadata metadata = getJavaDriverClient().getCluster().getMetadata();
1:         return new SmartThriftClient(this, schema.keyspace, metadata);
1:     }
1: 
1:     /**
1:      * Thrift client connection
1:      * @return cassandra client connection
1:      */
0:     public SimpleThriftClient getThriftClient()
1:     {
1:         return new SimpleThriftClient(getRawThriftClient(node.randomNode(), true));
1:     }
1: 
1:     public Cassandra.Client getRawThriftClient(boolean setKeyspace)
1:     {
1:         return getRawThriftClient(node.randomNode(), setKeyspace);
1:     }
1: 
1:     public Cassandra.Client getRawThriftClient(String host)
1:     {
1:         return getRawThriftClient(host, true);
1:     }
1: 
1:     public Cassandra.Client getRawThriftClient(String host, boolean setKeyspace)
1:     {
0:         TSocket socket = new TSocket(host, port.thriftPort);
1:         Cassandra.Client client;
1: 
1:         try
1:         {
0:             TTransport transport = this.transport.getFactory().getTransport(socket);
0:             transport.open();
1: 
1:             client = new Cassandra.Client(new TBinaryProtocol(transport));
1: 
1:             if (mode.cqlVersion.isCql())
1:                 client.set_cql_version(mode.cqlVersion.connectVersion);
1: 
1:             if (setKeyspace)
0:                 client.set_keyspace("Keyspace1");
1:         }
1:         catch (InvalidRequestException e)
1:         {
1:             throw new RuntimeException(e.getWhy());
1:         }
1:         catch (Exception e)
1:         {
1:             throw new RuntimeException(e.getMessage());
1:         }
1: 
1:         return client;
1:     }
1: 
1: 
1:     public SimpleClient getSimpleNativeClient()
1:     {
1:         try
1:         {
1:             String currentNode = node.randomNode();
1:             SimpleClient client = new SimpleClient(currentNode, port.nativePort);
1:             client.connect(false);
0:             client.execute("USE \"Keyspace1\";", org.apache.cassandra.db.ConsistencyLevel.ONE);
1:             return client;
1:         }
1:         catch (Exception e)
1:         {
1:             throw new RuntimeException(e.getMessage());
1:         }
1:     }
1: 
1:     private static volatile JavaDriverClient client;
1: 
1:     public JavaDriverClient getJavaDriverClient()
1:     {
1:         if (client != null)
1:             return client;
1: 
1:         try
1:         {
0:             synchronized (this)
1:             {
1:                 String currentNode = node.randomNode();
1:                 if (client != null)
1:                     return client;
1: 
0:                 JavaDriverClient c = new JavaDriverClient(currentNode, port.nativePort);
1:                 c.connect(mode.compression());
0:                 c.execute("USE \"Keyspace1\";", org.apache.cassandra.db.ConsistencyLevel.ONE);
1:                 return client = c;
1:             }
1:         }
1:         catch (Exception e)
1:         {
0:             throw new RuntimeException(e);
1:         }
1:     }
1: 
1:     public void maybeCreateKeyspaces()
1:     {
0:         if (command.type == Command.WRITE || command.type == Command.COUNTERWRITE)
1:             schema.createKeySpaces(this);
1: 
1:     }
1: 
1:     public static StressSettings parse(String[] args)
1:     {
0:         final Map<String, String[]> clArgs = parseMap(args);
0:         if (clArgs.containsKey("legacy"))
0:             return Legacy.build(Arrays.copyOfRange(args, 1, args.length));
0:         if (SettingsMisc.maybeDoSpecial(clArgs))
1:             System.exit(1);
0:         return get(clArgs);
1:     }
1: 
1:     public static StressSettings get(Map<String, String[]> clArgs)
1:     {
1:         SettingsCommand command = SettingsCommand.get(clArgs);
1:         if (command == null)
1:             throw new IllegalArgumentException("No command specified");
1:         String sendToDaemon = SettingsMisc.getSendToDaemon(clArgs);
1:         SettingsPort port = SettingsPort.get(clArgs);
1:         SettingsRate rate = SettingsRate.get(clArgs, command);
0:         SettingsKey keys = SettingsKey.get(clArgs, command);
1:         SettingsColumn columns = SettingsColumn.get(clArgs);
1:         SettingsLog log = SettingsLog.get(clArgs);
1:         SettingsMode mode = SettingsMode.get(clArgs);
1:         SettingsNode node = SettingsNode.get(clArgs);
0:         SettingsSchema schema = SettingsSchema.get(clArgs);
1:         SettingsTransport transport = SettingsTransport.get(clArgs);
1:         if (!clArgs.isEmpty())
1:         {
1:             printHelp();
1:             System.out.println("Error processing command line arguments. The following were ignored:");
1:             for (Map.Entry<String, String[]> e : clArgs.entrySet())
1:             {
1:                 System.out.print(e.getKey());
1:                 for (String v : e.getValue())
1:                 {
1:                     System.out.print(" ");
1:                     System.out.print(v);
1:                 }
1:                 System.out.println();
1:             }
1:             System.exit(1);
1:         }
0:         return new StressSettings(command, rate, keys, columns, log, mode, node, schema, transport, port, sendToDaemon);
1:     }
1: 
1:     private static Map<String, String[]> parseMap(String[] args)
1:     {
1:         // first is the main command/operation, so specified without a -
1:         if (args.length == 0)
1:         {
1:             System.out.println("No command provided");
1:             printHelp();
1:             System.exit(1);
1:         }
1:         final LinkedHashMap<String, String[]> r = new LinkedHashMap<>();
1:         String key = null;
1:         List<String> params = new ArrayList<>();
1:         for (int i = 0 ; i < args.length ; i++)
1:         {
1:             if (i == 0 || args[i].startsWith("-"))
1:             {
1:                 if (i > 0)
0:                     r.put(key, params.toArray(new String[0]));
1:                 key = args[i].toLowerCase();
1:                 params.clear();
1:             }
1:             else
1:                 params.add(args[i]);
1:         }
0:         r.put(key, params.toArray(new String[0]));
1:         return r;
1:     }
1: 
1:     public static void printHelp()
1:     {
1:         SettingsMisc.printHelp();
1:     }
1: 
1:     public synchronized void disconnect()
1:     {
1:         if (client == null)
1:             return;
1: 
1:         client.disconnect();
1:         client = null;
1:     }
1: }
============================================================================