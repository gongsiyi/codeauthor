1:6528fbf: /*
1:6528fbf:  * Licensed to the Apache Software Foundation (ASF) under one
1:6528fbf:  * or more contributor license agreements.  See the NOTICE file
1:6528fbf:  * distributed with this work for additional information
1:6528fbf:  * regarding copyright ownership.  The ASF licenses this file
1:6528fbf:  * to you under the Apache License, Version 2.0 (the
1:6528fbf:  * "License"); you may not use this file except in compliance
1:6528fbf:  * with the License.  You may obtain a copy of the License at
1:6528fbf:  *
1:6528fbf:  *     http://www.apache.org/licenses/LICENSE-2.0
1:6528fbf:  *
1:6528fbf:  * Unless required by applicable law or agreed to in writing, software
1:6528fbf:  * distributed under the License is distributed on an "AS IS" BASIS,
1:6528fbf:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:6528fbf:  * See the License for the specific language governing permissions and
1:6528fbf:  * limitations under the License.
1:6528fbf:  */
1:6528fbf: 
1:6528fbf: package org.apache.cassandra.db;
1:6528fbf: 
1:6528fbf: import java.io.FileReader;
1:6528fbf: import java.nio.ByteBuffer;
1:6528fbf: import java.nio.charset.Charset;
1:6528fbf: import java.util.*;
1:6528fbf: 
1:6528fbf: import com.google.common.collect.ImmutableList;
1:6528fbf: import com.google.common.collect.ImmutableMap;
1:6528fbf: import com.google.common.io.Files;
1:6528fbf: import org.junit.Assert;
1:6528fbf: import org.junit.Before;
1:6528fbf: import org.junit.Test;
1:6528fbf: 
1:6528fbf: import org.apache.cassandra.*;
1:6528fbf: import org.apache.cassandra.config.*;
1:6528fbf: import org.apache.cassandra.cql3.*;
1:6528fbf: import org.apache.cassandra.cql3.statements.*;
1:6528fbf: import org.apache.cassandra.db.marshal.*;
1:6528fbf: import org.apache.cassandra.exceptions.*;
1:a123e98: import org.apache.cassandra.index.sasi.*;
1:6528fbf: import org.apache.cassandra.schema.*;
1:6528fbf: import org.apache.cassandra.utils.*;
1:6528fbf: import org.json.simple.JSONArray;
1:6528fbf: import org.json.simple.JSONObject;
1:6528fbf: import org.json.simple.parser.JSONParser;
1:6528fbf: 
1:6528fbf: import static org.junit.Assert.assertEquals;
1:6528fbf: import static org.junit.Assert.assertTrue;
1:6528fbf: 
1:6528fbf: public class ColumnFamilyStoreCQLHelperTest extends CQLTester
1:6528fbf: {
1:6528fbf:     @Before
1:6528fbf:     public void defineSchema() throws ConfigurationException
1:6528fbf:     {
1:6528fbf:         SchemaLoader.prepareServer();
1:6528fbf:     }
1:6528fbf: 
1:6528fbf:     @Test
1:6528fbf:     public void testUserTypesCQL()
1:6528fbf:     {
1:6528fbf:         String keyspace = "cql_test_keyspace_user_types";
1:6528fbf:         String table = "test_table_user_types";
1:6528fbf: 
1:6528fbf:         UserType typeA = new UserType(keyspace, ByteBufferUtil.bytes("a"),
1:a123e98:                                       Arrays.asList(FieldIdentifier.forUnquoted("a1"),
1:a123e98:                                                     FieldIdentifier.forUnquoted("a2"),
1:a123e98:                                                     FieldIdentifier.forUnquoted("a3")),
1:6528fbf:                                       Arrays.asList(IntegerType.instance,
1:6528fbf:                                                     IntegerType.instance,
1:a123e98:                                                     IntegerType.instance),
1:a123e98:                                       true);
1:6528fbf: 
1:6528fbf:         UserType typeB = new UserType(keyspace, ByteBufferUtil.bytes("b"),
1:a123e98:                                       Arrays.asList(FieldIdentifier.forUnquoted("b1"),
1:a123e98:                                                     FieldIdentifier.forUnquoted("b2"),
1:a123e98:                                                     FieldIdentifier.forUnquoted("b3")),
1:6528fbf:                                       Arrays.asList(typeA,
1:6528fbf:                                                     typeA,
1:a123e98:                                                     typeA),
1:a123e98:                                       true);
1:6528fbf: 
1:6528fbf:         UserType typeC = new UserType(keyspace, ByteBufferUtil.bytes("c"),
1:a123e98:                                       Arrays.asList(FieldIdentifier.forUnquoted("c1"),
1:a123e98:                                                     FieldIdentifier.forUnquoted("c2"),
1:a123e98:                                                     FieldIdentifier.forUnquoted("c3")),
1:6528fbf:                                       Arrays.asList(typeB,
1:6528fbf:                                                     typeB,
1:a123e98:                                                     typeB),
1:a123e98:                                       true);
1:6528fbf: 
1:6528fbf:         CFMetaData cfm = CFMetaData.Builder.create(keyspace, table)
1:6528fbf:                                            .addPartitionKey("pk1", IntegerType.instance)
1:6528fbf:                                            .addClusteringColumn("ck1", IntegerType.instance)
1:6528fbf:                                            .addRegularColumn("reg1", typeC)
1:6528fbf:                                            .addRegularColumn("reg2", ListType.getInstance(IntegerType.instance, false))
1:6528fbf:                                            .addRegularColumn("reg3", MapType.getInstance(AsciiType.instance, IntegerType.instance, true))
1:6528fbf:                                            .build();
1:6528fbf: 
1:6528fbf:         SchemaLoader.createKeyspace(keyspace,
1:6528fbf:                                     KeyspaceParams.simple(1),
1:6528fbf:                                     Tables.of(cfm),
1:6528fbf:                                     Types.of(typeA, typeB, typeC));
1:6528fbf: 
1:6528fbf:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
1:6528fbf: 
1:6528fbf:         assertEquals(ImmutableList.of("CREATE TYPE cql_test_keyspace_user_types.a(a1 varint, a2 varint, a3 varint);",
1:a123e98:                                       "CREATE TYPE cql_test_keyspace_user_types.b(b1 a, b2 a, b3 a);",
1:a123e98:                                       "CREATE TYPE cql_test_keyspace_user_types.c(c1 b, c2 b, c3 b);"),
1:6528fbf:                      ColumnFamilyStoreCQLHelper.getUserTypesAsCQL(cfs.metadata));
1:6528fbf:     }
1:6528fbf: 
1:6528fbf:     @Test
1:6528fbf:     public void testDroppedColumnsCQL()
1:6528fbf:     {
1:6528fbf:         String keyspace = "cql_test_keyspace_dropped_columns";
1:6528fbf:         String table = "test_table_dropped_columns";
1:6528fbf: 
1:6528fbf:         CFMetaData cfm = CFMetaData.Builder.create(keyspace, table)
1:6528fbf:                                            .addPartitionKey("pk1", IntegerType.instance)
1:6528fbf:                                            .addClusteringColumn("ck1", IntegerType.instance)
1:6528fbf:                                            .addRegularColumn("reg1", IntegerType.instance)
1:6528fbf:                                            .addRegularColumn("reg2", IntegerType.instance)
1:6528fbf:                                            .addRegularColumn("reg3", IntegerType.instance)
1:6528fbf:                                            .build();
1:6528fbf: 
1:6528fbf: 
1:6528fbf:         ColumnDefinition reg1 = cfm.getColumnDefinition(ByteBufferUtil.bytes("reg1"));
1:6528fbf:         ColumnDefinition reg2 = cfm.getColumnDefinition(ByteBufferUtil.bytes("reg2"));
1:6528fbf:         ColumnDefinition reg3 = cfm.getColumnDefinition(ByteBufferUtil.bytes("reg3"));
1:6528fbf: 
1:6528fbf:         cfm.removeColumnDefinition(reg1);
1:6528fbf:         cfm.removeColumnDefinition(reg2);
1:6528fbf:         cfm.removeColumnDefinition(reg3);
1:6528fbf: 
1:6528fbf:         cfm.recordColumnDrop(reg1, 10000);
1:6528fbf:         cfm.recordColumnDrop(reg2, 20000);
1:6528fbf:         cfm.recordColumnDrop(reg3, 30000);
1:6528fbf: 
1:6528fbf:         SchemaLoader.createKeyspace(keyspace,
1:6528fbf:                                     KeyspaceParams.simple(1),
1:6528fbf:                                     cfm);
1:6528fbf: 
1:6528fbf:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
1:6528fbf: 
1:6528fbf:         assertEquals(ImmutableList.of("ALTER TABLE cql_test_keyspace_dropped_columns.test_table_dropped_columns DROP reg1 USING TIMESTAMP 10000;",
1:6528fbf:                                       "ALTER TABLE cql_test_keyspace_dropped_columns.test_table_dropped_columns DROP reg3 USING TIMESTAMP 30000;",
1:6528fbf:                                       "ALTER TABLE cql_test_keyspace_dropped_columns.test_table_dropped_columns DROP reg2 USING TIMESTAMP 20000;"),
1:6528fbf:                      ColumnFamilyStoreCQLHelper.getDroppedColumnsAsCQL(cfs.metadata));
1:6528fbf: 
1:6528fbf:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
1:6528fbf:         "CREATE TABLE IF NOT EXISTS cql_test_keyspace_dropped_columns.test_table_dropped_columns (\n" +
1:6528fbf:         "\tpk1 varint,\n" +
1:6528fbf:         "\tck1 varint,\n" +
1:6528fbf:         "\treg1 varint,\n" +
1:6528fbf:         "\treg3 varint,\n" +
1:6528fbf:         "\treg2 varint,\n" +
1:6528fbf:         "\tPRIMARY KEY (pk1, ck1))"));
1:6528fbf:     }
1:6528fbf: 
1:6528fbf:     @Test
1:6528fbf:     public void testReaddedColumns()
1:6528fbf:     {
1:6528fbf:         String keyspace = "cql_test_keyspace_readded_columns";
1:6528fbf:         String table = "test_table_readded_columns";
1:6528fbf: 
1:6528fbf:         CFMetaData cfm = CFMetaData.Builder.create(keyspace, table)
1:6528fbf:                                            .addPartitionKey("pk1", IntegerType.instance)
1:6528fbf:                                            .addClusteringColumn("ck1", IntegerType.instance)
1:6528fbf:                                            .addRegularColumn("reg1", IntegerType.instance)
1:6528fbf:                                            .addStaticColumn("reg2", IntegerType.instance)
1:6528fbf:                                            .addRegularColumn("reg3", IntegerType.instance)
1:6528fbf:                                            .build();
1:6528fbf: 
1:6528fbf:         ColumnDefinition reg1 = cfm.getColumnDefinition(ByteBufferUtil.bytes("reg1"));
1:6528fbf:         ColumnDefinition reg2 = cfm.getColumnDefinition(ByteBufferUtil.bytes("reg2"));
1:6528fbf: 
1:6528fbf:         cfm.removeColumnDefinition(reg1);
1:6528fbf:         cfm.removeColumnDefinition(reg2);
1:6528fbf: 
1:6528fbf:         cfm.recordColumnDrop(reg1, 10000);
1:6528fbf:         cfm.recordColumnDrop(reg2, 20000);
1:6528fbf: 
1:6528fbf:         cfm.addColumnDefinition(reg1);
1:6528fbf:         cfm.addColumnDefinition(reg2);
1:6528fbf: 
1:6528fbf:         SchemaLoader.createKeyspace(keyspace,
1:6528fbf:                                     KeyspaceParams.simple(1),
1:6528fbf:                                     cfm);
1:6528fbf: 
1:6528fbf:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
1:6528fbf: 
1:6528fbf:         // when re-adding, column is present in CREATE, then in DROP and then in ADD again, to record DROP with a proper timestamp
1:6528fbf:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
1:6528fbf:         "CREATE TABLE IF NOT EXISTS cql_test_keyspace_readded_columns.test_table_readded_columns (\n" +
1:6528fbf:         "\tpk1 varint,\n" +
1:6528fbf:         "\tck1 varint,\n" +
1:6528fbf:         "\treg2 varint static,\n" +
1:6528fbf:         "\treg1 varint,\n" +
1:6528fbf:         "\treg3 varint,\n" +
1:6528fbf:         "\tPRIMARY KEY (pk1, ck1))"));
1:6528fbf: 
1:6528fbf:         assertEquals(ImmutableList.of("ALTER TABLE cql_test_keyspace_readded_columns.test_table_readded_columns DROP reg1 USING TIMESTAMP 10000;",
1:6528fbf:                                       "ALTER TABLE cql_test_keyspace_readded_columns.test_table_readded_columns ADD reg1 varint;",
1:6528fbf:                                       "ALTER TABLE cql_test_keyspace_readded_columns.test_table_readded_columns DROP reg2 USING TIMESTAMP 20000;",
1:6528fbf:                                       "ALTER TABLE cql_test_keyspace_readded_columns.test_table_readded_columns ADD reg2 varint static;"),
1:6528fbf:                      ColumnFamilyStoreCQLHelper.getDroppedColumnsAsCQL(cfs.metadata));
1:6528fbf:     }
1:6528fbf: 
1:6528fbf:     @Test
1:6528fbf:     public void testCfmColumnsCQL()
1:6528fbf:     {
1:6528fbf:         String keyspace = "cql_test_keyspace_create_table";
1:6528fbf:         String table = "test_table_create_table";
1:6528fbf: 
1:6528fbf:         CFMetaData cfm = CFMetaData.Builder.create(keyspace, table)
1:6528fbf:                                            .addPartitionKey("pk1", IntegerType.instance)
1:6528fbf:                                            .addPartitionKey("pk2", AsciiType.instance)
1:6528fbf:                                            .addClusteringColumn("ck1", ReversedType.getInstance(IntegerType.instance))
1:6528fbf:                                            .addClusteringColumn("ck2", IntegerType.instance)
1:6528fbf:                                            .addStaticColumn("st1", AsciiType.instance)
1:6528fbf:                                            .addRegularColumn("reg1", AsciiType.instance)
1:6528fbf:                                            .addRegularColumn("reg2", ListType.getInstance(IntegerType.instance, false))
1:6528fbf:                                            .addRegularColumn("reg3", MapType.getInstance(AsciiType.instance, IntegerType.instance, true))
1:6528fbf:                                            .build();
1:6528fbf: 
1:6528fbf:         SchemaLoader.createKeyspace(keyspace,
1:6528fbf:                                     KeyspaceParams.simple(1),
1:6528fbf:                                     cfm);
1:6528fbf: 
1:6528fbf:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
1:6528fbf: 
1:6528fbf:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
1:6528fbf:         "CREATE TABLE IF NOT EXISTS cql_test_keyspace_create_table.test_table_create_table (\n" +
1:6528fbf:         "\tpk1 varint,\n" +
1:6528fbf:         "\tpk2 ascii,\n" +
1:6528fbf:         "\tck1 varint,\n" +
1:6528fbf:         "\tck2 varint,\n" +
1:6528fbf:         "\tst1 ascii static,\n" +
1:6528fbf:         "\treg1 ascii,\n" +
1:6528fbf:         "\treg2 frozen<list<varint>>,\n" +
1:6528fbf:         "\treg3 map<ascii, varint>,\n" +
1:6528fbf:         "\tPRIMARY KEY ((pk1, pk2), ck1, ck2))\n" +
1:6528fbf:         "\tWITH ID = " + cfs.metadata.cfId + "\n" +
1:6528fbf:         "\tAND CLUSTERING ORDER BY (ck1 DESC, ck2 ASC)"));
1:6528fbf:     }
1:6528fbf: 
1:6528fbf:     @Test
1:6528fbf:     public void testCfmCompactStorageCQL()
1:6528fbf:     {
1:6528fbf:         String keyspace = "cql_test_keyspace_compact";
1:6528fbf:         String table = "test_table_compact";
1:6528fbf: 
1:6528fbf:         CFMetaData cfm = CFMetaData.Builder.createDense(keyspace, table, true, false)
1:6528fbf:                                            .addPartitionKey("pk1", IntegerType.instance)
1:6528fbf:                                            .addPartitionKey("pk2", AsciiType.instance)
1:6528fbf:                                            .addClusteringColumn("ck1", ReversedType.getInstance(IntegerType.instance))
1:6528fbf:                                            .addClusteringColumn("ck2", IntegerType.instance)
1:6528fbf:                                            .addRegularColumn("reg", IntegerType.instance)
1:6528fbf:                                            .build();
1:6528fbf: 
1:6528fbf:         SchemaLoader.createKeyspace(keyspace,
1:6528fbf:                                     KeyspaceParams.simple(1),
1:6528fbf:                                     cfm);
1:6528fbf: 
1:6528fbf:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
1:6528fbf: 
1:6528fbf:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
1:6528fbf:         "CREATE TABLE IF NOT EXISTS cql_test_keyspace_compact.test_table_compact (\n" +
1:6528fbf:         "\tpk1 varint,\n" +
1:6528fbf:         "\tpk2 ascii,\n" +
1:6528fbf:         "\tck1 varint,\n" +
1:6528fbf:         "\tck2 varint,\n" +
1:6528fbf:         "\treg varint,\n" +
1:6528fbf:         "\tPRIMARY KEY ((pk1, pk2), ck1, ck2))\n" +
1:6528fbf:         "\tWITH ID = " + cfm.cfId + "\n" +
1:6528fbf:         "\tAND COMPACT STORAGE\n" +
1:6528fbf:         "\tAND CLUSTERING ORDER BY (ck1 DESC, ck2 ASC)"));
1:6528fbf:     }
1:6528fbf: 
1:6528fbf:     @Test
1:6528fbf:     public void testCfmCounterCQL()
1:6528fbf:     {
1:6528fbf:         String keyspace = "cql_test_keyspace_counter";
1:6528fbf:         String table = "test_table_counter";
1:6528fbf: 
1:6528fbf:         CFMetaData cfm = CFMetaData.Builder.createDense(keyspace, table, true, true)
1:6528fbf:                                            .addPartitionKey("pk1", IntegerType.instance)
1:6528fbf:                                            .addPartitionKey("pk2", AsciiType.instance)
1:6528fbf:                                            .addClusteringColumn("ck1", ReversedType.getInstance(IntegerType.instance))
1:6528fbf:                                            .addClusteringColumn("ck2", IntegerType.instance)
1:6528fbf:                                            .addRegularColumn("cnt", CounterColumnType.instance)
1:6528fbf:                                            .build();
1:6528fbf: 
1:6528fbf:         SchemaLoader.createKeyspace(keyspace,
1:6528fbf:                                     KeyspaceParams.simple(1),
1:6528fbf:                                     cfm);
1:6528fbf: 
1:6528fbf:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
1:6528fbf: 
1:6528fbf:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
1:6528fbf:         "CREATE TABLE IF NOT EXISTS cql_test_keyspace_counter.test_table_counter (\n" +
1:6528fbf:         "\tpk1 varint,\n" +
1:6528fbf:         "\tpk2 ascii,\n" +
1:6528fbf:         "\tck1 varint,\n" +
1:6528fbf:         "\tck2 varint,\n" +
1:6528fbf:         "\tcnt counter,\n" +
1:6528fbf:         "\tPRIMARY KEY ((pk1, pk2), ck1, ck2))\n" +
1:6528fbf:         "\tWITH ID = " + cfm.cfId + "\n" +
1:6528fbf:         "\tAND COMPACT STORAGE\n" +
1:6528fbf:         "\tAND CLUSTERING ORDER BY (ck1 DESC, ck2 ASC)"));
1:6528fbf:     }
1:6528fbf: 
1:6528fbf:     @Test
1:6528fbf:     public void testCfmOptionsCQL()
1:6528fbf:     {
1:6528fbf:         String keyspace = "cql_test_keyspace_options";
1:6528fbf:         String table = "test_table_options";
1:6528fbf: 
1:6528fbf:         CFMetaData cfm = CFMetaData.Builder.create(keyspace, table)
1:6528fbf:                                            .addPartitionKey("pk1", IntegerType.instance)
1:6528fbf:                                            .addClusteringColumn("cl1", IntegerType.instance)
1:6528fbf:                                            .addRegularColumn("reg1", AsciiType.instance)
1:6528fbf:                                            .build();
1:6528fbf: 
1:6528fbf:         cfm.recordColumnDrop(cfm.getColumnDefinition(ByteBuffer.wrap("reg1".getBytes())), FBUtilities.timestampMicros());
1:6528fbf:         cfm.bloomFilterFpChance(1.0);
1:6528fbf:         cfm.comment("comment");
1:6528fbf:         cfm.compaction(CompactionParams.lcs(Collections.singletonMap("sstable_size_in_mb", "1")));
1:6528fbf:         cfm.compression(CompressionParams.lz4(1 << 16));
1:6528fbf:         cfm.dcLocalReadRepairChance(0.2);
1:6528fbf:         cfm.crcCheckChance(0.3);
1:6528fbf:         cfm.defaultTimeToLive(4);
1:6528fbf:         cfm.gcGraceSeconds(5);
1:6528fbf:         cfm.minIndexInterval(6);
1:6528fbf:         cfm.maxIndexInterval(7);
1:6528fbf:         cfm.memtableFlushPeriod(8);
1:6528fbf:         cfm.readRepairChance(0.9);
1:6528fbf:         cfm.speculativeRetry(SpeculativeRetryParam.always());
1:6528fbf:         cfm.extensions(ImmutableMap.of("ext1",
1:6528fbf:                                        ByteBuffer.wrap("val1".getBytes())));
1:6528fbf: 
1:6528fbf:         SchemaLoader.createKeyspace(keyspace,
1:6528fbf:                                     KeyspaceParams.simple(1),
1:6528fbf:                                     cfm);
1:6528fbf:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
1:6528fbf: 
1:6528fbf:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).endsWith(
1:6528fbf:         "AND bloom_filter_fp_chance = 1.0\n" +
1:6528fbf:         "\tAND dclocal_read_repair_chance = 0.2\n" +
1:6528fbf:         "\tAND crc_check_chance = 0.3\n" +
1:6528fbf:         "\tAND default_time_to_live = 4\n" +
1:6528fbf:         "\tAND gc_grace_seconds = 5\n" +
1:6528fbf:         "\tAND min_index_interval = 6\n" +
1:6528fbf:         "\tAND max_index_interval = 7\n" +
1:6528fbf:         "\tAND memtable_flush_period_in_ms = 8\n" +
1:6528fbf:         "\tAND read_repair_chance = 0.9\n" +
1:6528fbf:         "\tAND speculative_retry = 'ALWAYS'\n" +
1:6528fbf:         "\tAND comment = 'comment'\n" +
1:6528fbf:         "\tAND caching = { 'keys': 'ALL', 'rows_per_partition': 'NONE' }\n" +
1:6528fbf:         "\tAND compaction = { 'class': 'org.apache.cassandra.db.compaction.LeveledCompactionStrategy', 'sstable_size_in_mb': '1' }\n" +
1:6528fbf:         "\tAND compression = { 'chunk_length_in_kb': '64', 'class': 'org.apache.cassandra.io.compress.LZ4Compressor' }\n" +
1:a123e98:         "\tAND cdc = false\n" +
1:6528fbf:         "\tAND extensions = { 'ext1': 0x76616c31 };"
1:6528fbf:         ));
1:6528fbf:     }
1:6528fbf: 
1:6528fbf:     @Test
1:6528fbf:     public void testCfmIndexJson()
1:6528fbf:     {
1:6528fbf:         String keyspace = "cql_test_keyspace_3";
1:6528fbf:         String table = "test_table_3";
1:6528fbf: 
1:6528fbf:         CFMetaData cfm = CFMetaData.Builder.create(keyspace, table)
1:6528fbf:                                            .addPartitionKey("pk1", IntegerType.instance)
1:6528fbf:                                            .addClusteringColumn("cl1", IntegerType.instance)
1:6528fbf:                                            .addRegularColumn("reg1", AsciiType.instance)
1:6528fbf:                                            .build();
1:6528fbf: 
1:6528fbf:         cfm.indexes(cfm.getIndexes()
1:6528fbf:                        .with(IndexMetadata.fromIndexTargets(cfm,
1:6528fbf:                                                             Collections.singletonList(new IndexTarget(cfm.getColumnDefinition(ByteBufferUtil.bytes("reg1")).name,
1:6528fbf:                                                                                                       IndexTarget.Type.VALUES)),
1:6528fbf:                                                             "indexName",
1:6528fbf:                                                             IndexMetadata.Kind.COMPOSITES,
1:6528fbf:                                                             Collections.emptyMap()))
1:6528fbf:                        .with(IndexMetadata.fromIndexTargets(cfm,
1:6528fbf:                                                             Collections.singletonList(new IndexTarget(cfm.getColumnDefinition(ByteBufferUtil.bytes("reg1")).name,
1:6528fbf:                                                                                                       IndexTarget.Type.KEYS)),
1:6528fbf:                                                             "indexName2",
1:6528fbf:                                                             IndexMetadata.Kind.COMPOSITES,
1:6528fbf:                                                             Collections.emptyMap()))
1:6528fbf:                        .with(IndexMetadata.fromIndexTargets(cfm,
1:6528fbf:                                                             Collections.singletonList(new IndexTarget(cfm.getColumnDefinition(ByteBufferUtil.bytes("reg1")).name,
1:6528fbf:                                                                                                       IndexTarget.Type.KEYS_AND_VALUES)),
1:6528fbf:                                                             "indexName3",
1:6528fbf:                                                             IndexMetadata.Kind.COMPOSITES,
3:a123e98:                                                             Collections.emptyMap()))
4:a123e98:                        .with(IndexMetadata.fromIndexTargets(cfm,
4:a123e98:                                                             Collections.singletonList(new IndexTarget(cfm.getColumnDefinition(ByteBufferUtil.bytes("reg1")).name,
2:a123e98:                                                                                                       IndexTarget.Type.KEYS_AND_VALUES)),
1:a123e98:                                                             "indexName4",
1:a123e98:                                                             IndexMetadata.Kind.CUSTOM,
1:a123e98:                                                             Collections.singletonMap(IndexTarget.CUSTOM_INDEX_OPTION_NAME,
1:a123e98:                                                                                      SASIIndex.class.getName()))
2:a123e98:                        ));
1:6528fbf: 
1:6528fbf: 
1:6528fbf:         SchemaLoader.createKeyspace(keyspace,
1:6528fbf:                                     KeyspaceParams.simple(1),
1:6528fbf:                                     cfm);
1:6528fbf: 
1:6528fbf:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
1:6528fbf: 
1:6528fbf:         assertEquals(ImmutableList.of("CREATE INDEX \"indexName\" ON cql_test_keyspace_3.test_table_3 (reg1);",
1:6528fbf:                                       "CREATE INDEX \"indexName2\" ON cql_test_keyspace_3.test_table_3 (reg1);",
1:a123e98:                                       "CREATE INDEX \"indexName3\" ON cql_test_keyspace_3.test_table_3 (reg1);",
1:a123e98:                                       "CREATE CUSTOM INDEX \"indexName4\" ON cql_test_keyspace_3.test_table_3 (reg1) USING 'org.apache.cassandra.index.sasi.SASIIndex';"),
1:6528fbf:                      ColumnFamilyStoreCQLHelper.getIndexesAsCQL(cfs.metadata));
1:6528fbf:     }
1:6528fbf: 
1:6528fbf:     private final static String SNAPSHOT = "testsnapshot";
1:6528fbf: 
1:6528fbf:     @Test
1:6528fbf:     public void testSnapshot() throws Throwable
1:6528fbf:     {
1:6528fbf:         String typeA = createType("CREATE TYPE %s (a1 varint, a2 varint, a3 varint);");
1:6528fbf:         String typeB = createType("CREATE TYPE %s (b1 frozen<" + typeA + ">, b2 frozen<" + typeA + ">, b3 frozen<" + typeA + ">);");
1:6528fbf:         String typeC = createType("CREATE TYPE %s (c1 frozen<" + typeB + ">, c2 frozen<" + typeB + ">, c3 frozen<" + typeB + ">);");
1:6528fbf: 
1:6528fbf:         String tableName = createTable("CREATE TABLE IF NOT EXISTS %s (" +
1:6528fbf:                                        "pk1 varint," +
1:6528fbf:                                        "pk2 ascii," +
1:6528fbf:                                        "ck1 varint," +
1:6528fbf:                                        "ck2 varint," +
1:a123e98:                                        "reg1 " + typeC + "," +
1:6528fbf:                                        "reg2 int," +
1:6528fbf:                                        "reg3 int," +
1:6528fbf:                                        "PRIMARY KEY ((pk1, pk2), ck1, ck2)) WITH " +
1:6528fbf:                                        "CLUSTERING ORDER BY (ck1 ASC, ck2 DESC);");
1:6528fbf: 
1:6528fbf:         alterTable("ALTER TABLE %s DROP reg3 USING TIMESTAMP 10000;");
1:6528fbf:         alterTable("ALTER TABLE %s ADD reg3 int;");
1:6528fbf: 
1:6528fbf:         for (int i = 0; i < 10; i++)
1:6528fbf:             execute("INSERT INTO %s (pk1, pk2, ck1, ck2, reg1, reg2) VALUES (?, ?, ?, ?, ?, ?)", i, i + 1, i + 2, i + 3, null, i + 5);
1:6528fbf: 
1:6528fbf:         ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(tableName);
1:6528fbf:         cfs.snapshot(SNAPSHOT);
1:6528fbf: 
1:6528fbf:         String schema = Files.toString(cfs.getDirectories().getSnapshotSchemaFile(SNAPSHOT), Charset.defaultCharset());
1:6528fbf:         assertTrue(schema.contains(String.format("CREATE TYPE %s.%s(a1 varint, a2 varint, a3 varint);", keyspace(), typeA)));
1:6528fbf:         assertTrue(schema.contains(String.format("CREATE TYPE %s.%s(a1 varint, a2 varint, a3 varint);", keyspace(), typeA)));
1:6528fbf:         assertTrue(schema.contains(String.format("CREATE TYPE %s.%s(b1 frozen<%s>, b2 frozen<%s>, b3 frozen<%s>);", keyspace(), typeB, typeA, typeA, typeA)));
1:6528fbf:         assertTrue(schema.contains(String.format("CREATE TYPE %s.%s(c1 frozen<%s>, c2 frozen<%s>, c3 frozen<%s>);", keyspace(), typeC, typeB, typeB, typeB)));
1:6528fbf: 
1:6528fbf:         schema = schema.substring(schema.indexOf("CREATE TABLE")); // trim to ensure order
1:6528fbf: 
1:6528fbf:         assertTrue(schema.startsWith("CREATE TABLE IF NOT EXISTS " + keyspace() + "." + tableName + " (\n" +
1:6528fbf:                                      "\tpk1 varint,\n" +
1:6528fbf:                                      "\tpk2 ascii,\n" +
1:6528fbf:                                      "\tck1 varint,\n" +
1:6528fbf:                                      "\tck2 varint,\n" +
1:6528fbf:                                      "\treg2 int,\n" +
1:6528fbf:                                      "\treg3 int,\n" +
1:a123e98:                                      "\treg1 " + typeC + ",\n" +
1:6528fbf:                                      "\tPRIMARY KEY ((pk1, pk2), ck1, ck2))\n" +
1:6528fbf:                                      "\tWITH ID = " + cfs.metadata.cfId + "\n" +
1:6528fbf:                                      "\tAND CLUSTERING ORDER BY (ck1 ASC, ck2 DESC)"));
1:6528fbf: 
1:6528fbf:         schema = schema.substring(schema.indexOf("ALTER"));
1:6528fbf:         assertTrue(schema.startsWith(String.format("ALTER TABLE %s.%s DROP reg3 USING TIMESTAMP 10000;", keyspace(), tableName)));
1:6528fbf:         assertTrue(schema.contains(String.format("ALTER TABLE %s.%s ADD reg3 int;", keyspace(), tableName)));
1:6528fbf: 
1:6528fbf:         JSONObject manifest = (JSONObject) new JSONParser().parse(new FileReader(cfs.getDirectories().getSnapshotManifestFile(SNAPSHOT)));
1:6528fbf:         JSONArray files = (JSONArray) manifest.get("files");
1:6528fbf:         Assert.assertEquals(1, files.size());
1:6528fbf:     }
1:6528fbf: 
1:6528fbf:     @Test
1:6528fbf:     public void testSystemKsSnapshot() throws Throwable
1:6528fbf:     {
1:6528fbf:         ColumnFamilyStore cfs = Keyspace.open("system").getColumnFamilyStore("peers");
1:6528fbf:         cfs.snapshot(SNAPSHOT);
1:6528fbf: 
1:6528fbf:         Assert.assertTrue(cfs.getDirectories().getSnapshotManifestFile(SNAPSHOT).exists());
1:6528fbf:         Assert.assertFalse(cfs.getDirectories().getSnapshotSchemaFile(SNAPSHOT).exists());
1:6528fbf:     }
1:6528fbf: 
1:6528fbf:     @Test
1:6528fbf:     public void testDroppedType() throws Throwable
1:6528fbf:     {
1:6528fbf:         String typeA = createType("CREATE TYPE %s (a1 varint, a2 varint, a3 varint);");
1:6528fbf:         String typeB = createType("CREATE TYPE %s (b1 frozen<" + typeA + ">, b2 frozen<" + typeA + ">, b3 frozen<" + typeA + ">);");
1:6528fbf: 
1:6528fbf:         String tableName = createTable("CREATE TABLE IF NOT EXISTS %s (" +
1:6528fbf:                                        "pk1 varint," +
1:6528fbf:                                        "ck1 varint," +
1:a123e98:                                        "reg1 " + typeB + "," +
1:6528fbf:                                        "reg2 varint," +
1:6528fbf:                                        "PRIMARY KEY (pk1, ck1));");
1:6528fbf: 
1:6528fbf:         alterTable("ALTER TABLE %s DROP reg1 USING TIMESTAMP 10000;");
1:6528fbf: 
1:6528fbf:         Runnable validate = () -> {
1:6528fbf:             try
1:6528fbf:             {
1:6528fbf:                 ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(tableName);
1:6528fbf:                 cfs.snapshot(SNAPSHOT);
1:6528fbf:                 String schema = Files.toString(cfs.getDirectories().getSnapshotSchemaFile(SNAPSHOT), Charset.defaultCharset());
1:6528fbf: 
1:6528fbf:                 // When both column and it's type are dropped, the type in column definition gets substituted with a tuple
1:6528fbf:                 assertTrue(schema.startsWith("CREATE TABLE IF NOT EXISTS " + keyspace() + "." + tableName + " (\n" +
1:6528fbf:                                              "\tpk1 varint,\n" +
1:6528fbf:                                              "\tck1 varint,\n" +
1:6528fbf:                                              "\treg2 varint,\n" +
1:6528fbf:                                              "\treg1 frozen<tuple<frozen<tuple<varint, varint, varint>>, frozen<tuple<varint, varint, varint>>, frozen<tuple<varint, varint, varint>>>>,\n" +
1:6528fbf:                                              "\tPRIMARY KEY (pk1, ck1))"));
1:6528fbf:                 assertTrue(schema.contains("ALTER TABLE " + keyspace() + "." + tableName + " DROP reg1 USING TIMESTAMP 10000;"));
1:6528fbf:             }
1:6528fbf:             catch (Exception e)
1:6528fbf:             {
1:6528fbf:                 throw new RuntimeException(e);
1:6528fbf:             }
1:6528fbf:         };
1:6528fbf: 
1:6528fbf:         // Validate before and after the type drop
1:6528fbf:         validate.run();
1:6528fbf:         schemaChange("DROP TYPE " + keyspace() + "." + typeB);
1:6528fbf:         schemaChange("DROP TYPE " + keyspace() + "." + typeA);
1:6528fbf:         validate.run();
1:6528fbf:     }
1:6528fbf: 
1:6528fbf:     @Test
1:6528fbf:     public void testDenseTable() throws Throwable
1:6528fbf:     {
1:6528fbf:         String tableName = createTable("CREATE TABLE IF NOT EXISTS %s (" +
1:6528fbf:                                        "pk1 varint PRIMARY KEY," +
1:6528fbf:                                        "reg1 int)" +
1:6528fbf:                                        " WITH COMPACT STORAGE");
1:6528fbf: 
1:6528fbf:         ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(tableName);
1:6528fbf: 
1:6528fbf:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
1:6528fbf:         "CREATE TABLE IF NOT EXISTS " + keyspace() + "." + tableName + " (\n" +
1:6528fbf:         "\tpk1 varint PRIMARY KEY,\n" +
1:6528fbf:         "\treg1 int)\n" +
1:6528fbf:         "\tWITH ID = " + cfs.metadata.cfId + "\n" +
1:6528fbf:         "\tAND COMPACT STORAGE"));
1:6528fbf:     }
1:6528fbf: 
1:6528fbf:     @Test
1:6528fbf:     public void testStaticCompactTable() throws Throwable
1:6528fbf:     {
1:6528fbf:         String tableName = createTable("CREATE TABLE IF NOT EXISTS %s (" +
1:6528fbf:                                        "pk1 varint PRIMARY KEY," +
1:6528fbf:                                        "reg1 int," +
1:6528fbf:                                        "reg2 int)" +
1:6528fbf:                                        " WITH COMPACT STORAGE");
1:6528fbf: 
1:6528fbf:         ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(tableName);
1:6528fbf: 
1:6528fbf:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
1:6528fbf:         "CREATE TABLE IF NOT EXISTS " + keyspace() + "." + tableName + " (\n" +
1:6528fbf:         "\tpk1 varint PRIMARY KEY,\n" +
1:6528fbf:         "\treg1 int,\n" +
1:6528fbf:         "\treg2 int)\n" +
1:6528fbf:         "\tWITH ID = " + cfs.metadata.cfId + "\n" +
1:6528fbf:         "\tAND COMPACT STORAGE"));
1:6528fbf:     }
1:6528fbf: 
1:6528fbf:     @Test
1:6528fbf:     public void testStaticCompactWithCounters() throws Throwable
1:6528fbf:     {
1:6528fbf:         String tableName = createTable("CREATE TABLE IF NOT EXISTS %s (" +
1:6528fbf:                                        "pk1 varint PRIMARY KEY," +
1:6528fbf:                                        "reg1 counter," +
1:6528fbf:                                        "reg2 counter)" +
1:6528fbf:                                        " WITH COMPACT STORAGE");
1:6528fbf: 
1:6528fbf: 
1:6528fbf:         ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(tableName);
1:6528fbf: 
1:6528fbf:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
1:6528fbf:         "CREATE TABLE IF NOT EXISTS " + keyspace() + "." + tableName + " (\n" +
1:6528fbf:         "\tpk1 varint PRIMARY KEY,\n" +
1:6528fbf:         "\treg1 counter,\n" +
1:6528fbf:         "\treg2 counter)\n" +
1:6528fbf:         "\tWITH ID = " + cfs.metadata.cfId + "\n" +
1:6528fbf:         "\tAND COMPACT STORAGE"));
1:6528fbf:     }
1:6528fbf: 
1:6528fbf:     @Test
1:6528fbf:     public void testDenseCompactTableWithoutRegulars() throws Throwable
1:6528fbf:     {
1:6528fbf:         String tableName = createTable("CREATE TABLE IF NOT EXISTS %s (" +
1:6528fbf:                                        "pk1 varint," +
1:6528fbf:                                        "ck1 int," +
1:6528fbf:                                        "PRIMARY KEY (pk1, ck1))" +
1:6528fbf:                                        " WITH COMPACT STORAGE");
1:6528fbf: 
1:6528fbf:         ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(tableName);
1:6528fbf: 
1:6528fbf:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
1:6528fbf:         "CREATE TABLE IF NOT EXISTS " + keyspace() + "." + tableName + " (\n" +
1:6528fbf:         "\tpk1 varint,\n" +
1:6528fbf:         "\tck1 int,\n" +
1:6528fbf:         "\tPRIMARY KEY (pk1, ck1))\n" +
1:6528fbf:         "\tWITH ID = " + cfs.metadata.cfId + "\n" +
1:6528fbf:         "\tAND COMPACT STORAGE"));
1:6528fbf:     }
1:6528fbf: 
1:6528fbf:     @Test
1:6528fbf:     public void testCompactDynamic() throws Throwable
1:6528fbf:     {
1:6528fbf:         String tableName = createTable("CREATE TABLE IF NOT EXISTS %s (" +
1:6528fbf:                                        "pk1 varint," +
1:6528fbf:                                        "ck1 int," +
1:6528fbf:                                        "reg int," +
1:6528fbf:                                        "PRIMARY KEY (pk1, ck1))" +
1:6528fbf:                                        " WITH COMPACT STORAGE");
1:6528fbf: 
1:6528fbf:         ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(tableName);
1:6528fbf: 
1:6528fbf:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
1:6528fbf:         "CREATE TABLE IF NOT EXISTS " + keyspace() + "." + tableName + " (\n" +
1:6528fbf:         "\tpk1 varint,\n" +
1:6528fbf:         "\tck1 int,\n" +
1:6528fbf:         "\treg int,\n" +
1:6528fbf:         "\tPRIMARY KEY (pk1, ck1))\n" +
1:6528fbf:         "\tWITH ID = " + cfs.metadata.cfId + "\n" +
1:6528fbf:         "\tAND COMPACT STORAGE"));
1:6528fbf:     }
1:6528fbf: 
1:6528fbf:     @Test
1:6528fbf:     public void testDynamicComposite() throws Throwable
1:6528fbf:     {
1:6528fbf:         Map<Byte, AbstractType<?>> aliases = new HashMap<>();
1:6528fbf:         aliases.put((byte)'a', BytesType.instance);
1:6528fbf:         aliases.put((byte)'b', BytesType.instance);
1:6528fbf:         aliases.put((byte)'c', BytesType.instance);
1:6528fbf: 
1:6528fbf:         String DYNAMIC_COMPOSITE = "dynamic_composite";
1:6528fbf:         AbstractType<?> dynamicComposite = DynamicCompositeType.getInstance(aliases);
1:6528fbf: 
1:6528fbf:         SchemaLoader.createKeyspace(DYNAMIC_COMPOSITE,
1:6528fbf:                                     KeyspaceParams.simple(1),
1:6528fbf:                                     SchemaLoader.denseCFMD(DYNAMIC_COMPOSITE, DYNAMIC_COMPOSITE, dynamicComposite));
1:6528fbf: 
1:6528fbf:         ColumnFamilyStore cfs = Keyspace.open(DYNAMIC_COMPOSITE).getColumnFamilyStore(DYNAMIC_COMPOSITE);
1:6528fbf: 
1:6528fbf:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
1:6528fbf:         "CREATE TABLE IF NOT EXISTS " + DYNAMIC_COMPOSITE + "." + DYNAMIC_COMPOSITE + " (\n" +
1:55568c1:         "\tkey ascii,\n" +
1:6528fbf:         "\tcols 'org.apache.cassandra.db.marshal.DynamicCompositeType(a=>org.apache.cassandra.db.marshal.BytesType,b=>org.apache.cassandra.db.marshal.BytesType,c=>org.apache.cassandra.db.marshal.BytesType)',\n" +
1:6528fbf:         "\tval ascii,\n" +
1:55568c1:         "\tPRIMARY KEY (key, cols))\n" +
1:6528fbf:         "\tWITH ID = " + cfs.metadata.cfId + "\n" +
1:6528fbf:         "\tAND COMPACT STORAGE"));
1:6528fbf:     }
1:6528fbf: 
1:6528fbf:     @Test
1:6528fbf:     public void superColumnFamilyTest() throws Throwable
1:6528fbf:     {
1:6528fbf:         final String KEYSPACE = "thrift_compact_table_with_supercolumns_test";
1:6528fbf:         final String TABLE = "test_table_1";
1:6528fbf: 
1:6528fbf:         CFMetaData cfm = CFMetaData.Builder.createSuper(KEYSPACE, TABLE, false)
1:6528fbf:                                            .addPartitionKey("pk", BytesType.instance)
1:6528fbf:                                            .addClusteringColumn("c1", AsciiType.instance)
1:6528fbf:                                            .addClusteringColumn("c2", AsciiType.instance)
1:6528fbf:                                            .addRegularColumn("", MapType.getInstance(Int32Type.instance, AsciiType.instance, true))
1:6528fbf:                                            .build();
1:6528fbf: 
1:6528fbf:         SchemaLoader.createKeyspace(KEYSPACE,
1:6528fbf:                                     KeyspaceParams.simple(1),
1:6528fbf:                                     cfm);
1:6528fbf: 
1:6528fbf:         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(TABLE);
1:6528fbf: 
1:6528fbf:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
1:6528fbf:         "/*\n" +
1:6528fbf:         "Warning: Table " + KEYSPACE + "." + TABLE + " omitted because it has constructs not compatible with CQL (was created via legacy API).\n\n" +
1:6528fbf:         "Approximate structure, for reference:\n" +
1:6528fbf:         "(this should not be used to reproduce this schema)\n\n" +
1:6528fbf:         "CREATE TABLE IF NOT EXISTS " + KEYSPACE + "." + TABLE + " (\n" +
1:6528fbf:         "\tpk blob,\n" +
1:6528fbf:         "\tc1 ascii,\n" +
1:6528fbf:         "\tc2 ascii,\n" +
1:6528fbf:         "\t\"\" map<int, ascii>,\n" +
1:6528fbf:         "\tPRIMARY KEY (pk, c1, c2))\n" +
1:6528fbf:         "\tWITH ID = " + cfs.metadata.cfId + "\n" +
1:6528fbf:         "\tAND COMPACT STORAGE"));
1:6528fbf:     }
1:6528fbf: }
============================================================================
author:Alex Petrov
-------------------------------------------------------------------------------
commit:55568c1
/////////////////////////////////////////////////////////////////////////
1:         "\tkey ascii,\n" +
1:         "\tPRIMARY KEY (key, cols))\n" +
commit:5f2367e
/////////////////////////////////////////////////////////////////////////
0:         "\tkey ascii,\n" +
0:         "\tPRIMARY KEY (key, cols))\n" +
commit:6528fbf
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.cassandra.db;
1: 
1: import java.io.FileReader;
1: import java.nio.ByteBuffer;
1: import java.nio.charset.Charset;
1: import java.util.*;
1: 
1: import com.google.common.collect.ImmutableList;
1: import com.google.common.collect.ImmutableMap;
1: import com.google.common.io.Files;
1: import org.junit.Assert;
1: import org.junit.Before;
1: import org.junit.Test;
1: 
1: import org.apache.cassandra.*;
1: import org.apache.cassandra.config.*;
1: import org.apache.cassandra.cql3.*;
1: import org.apache.cassandra.cql3.statements.*;
1: import org.apache.cassandra.db.marshal.*;
1: import org.apache.cassandra.exceptions.*;
1: import org.apache.cassandra.schema.*;
1: import org.apache.cassandra.utils.*;
1: import org.json.simple.JSONArray;
1: import org.json.simple.JSONObject;
1: import org.json.simple.parser.JSONParser;
1: 
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertTrue;
1: 
1: public class ColumnFamilyStoreCQLHelperTest extends CQLTester
1: {
1:     @Before
1:     public void defineSchema() throws ConfigurationException
1:     {
1:         SchemaLoader.prepareServer();
1:     }
1: 
1:     @Test
1:     public void testUserTypesCQL()
1:     {
1:         String keyspace = "cql_test_keyspace_user_types";
1:         String table = "test_table_user_types";
1: 
1:         UserType typeA = new UserType(keyspace, ByteBufferUtil.bytes("a"),
0:                                       Arrays.asList(ByteBufferUtil.bytes("a1"),
0:                                                     ByteBufferUtil.bytes("a2"),
0:                                                     ByteBufferUtil.bytes("a3")),
1:                                       Arrays.asList(IntegerType.instance,
1:                                                     IntegerType.instance,
0:                                                     IntegerType.instance));
1: 
1:         UserType typeB = new UserType(keyspace, ByteBufferUtil.bytes("b"),
0:                                       Arrays.asList(ByteBufferUtil.bytes("b1"),
0:                                                     ByteBufferUtil.bytes("b2"),
0:                                                     ByteBufferUtil.bytes("b3")),
1:                                       Arrays.asList(typeA,
1:                                                     typeA,
0:                                                     typeA));
1: 
1:         UserType typeC = new UserType(keyspace, ByteBufferUtil.bytes("c"),
0:                                       Arrays.asList(ByteBufferUtil.bytes("c1"),
0:                                                     ByteBufferUtil.bytes("c2"),
0:                                                     ByteBufferUtil.bytes("c3")),
1:                                       Arrays.asList(typeB,
1:                                                     typeB,
0:                                                     typeB));
1: 
1:         CFMetaData cfm = CFMetaData.Builder.create(keyspace, table)
1:                                            .addPartitionKey("pk1", IntegerType.instance)
1:                                            .addClusteringColumn("ck1", IntegerType.instance)
1:                                            .addRegularColumn("reg1", typeC)
1:                                            .addRegularColumn("reg2", ListType.getInstance(IntegerType.instance, false))
1:                                            .addRegularColumn("reg3", MapType.getInstance(AsciiType.instance, IntegerType.instance, true))
1:                                            .build();
1: 
1:         SchemaLoader.createKeyspace(keyspace,
1:                                     KeyspaceParams.simple(1),
1:                                     Tables.of(cfm),
1:                                     Types.of(typeA, typeB, typeC));
1: 
1:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
1: 
1:         assertEquals(ImmutableList.of("CREATE TYPE cql_test_keyspace_user_types.a(a1 varint, a2 varint, a3 varint);",
0:                                       "CREATE TYPE cql_test_keyspace_user_types.b(b1 frozen<a>, b2 frozen<a>, b3 frozen<a>);",
0:                                       "CREATE TYPE cql_test_keyspace_user_types.c(c1 frozen<b>, c2 frozen<b>, c3 frozen<b>);"),
1:                      ColumnFamilyStoreCQLHelper.getUserTypesAsCQL(cfs.metadata));
1:     }
1: 
1:     @Test
1:     public void testDroppedColumnsCQL()
1:     {
1:         String keyspace = "cql_test_keyspace_dropped_columns";
1:         String table = "test_table_dropped_columns";
1: 
1:         CFMetaData cfm = CFMetaData.Builder.create(keyspace, table)
1:                                            .addPartitionKey("pk1", IntegerType.instance)
1:                                            .addClusteringColumn("ck1", IntegerType.instance)
1:                                            .addRegularColumn("reg1", IntegerType.instance)
1:                                            .addRegularColumn("reg2", IntegerType.instance)
1:                                            .addRegularColumn("reg3", IntegerType.instance)
1:                                            .build();
1: 
1: 
1:         ColumnDefinition reg1 = cfm.getColumnDefinition(ByteBufferUtil.bytes("reg1"));
1:         ColumnDefinition reg2 = cfm.getColumnDefinition(ByteBufferUtil.bytes("reg2"));
1:         ColumnDefinition reg3 = cfm.getColumnDefinition(ByteBufferUtil.bytes("reg3"));
1: 
1:         cfm.removeColumnDefinition(reg1);
1:         cfm.removeColumnDefinition(reg2);
1:         cfm.removeColumnDefinition(reg3);
1: 
1:         cfm.recordColumnDrop(reg1, 10000);
1:         cfm.recordColumnDrop(reg2, 20000);
1:         cfm.recordColumnDrop(reg3, 30000);
1: 
1:         SchemaLoader.createKeyspace(keyspace,
1:                                     KeyspaceParams.simple(1),
1:                                     cfm);
1: 
1:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
1: 
1:         assertEquals(ImmutableList.of("ALTER TABLE cql_test_keyspace_dropped_columns.test_table_dropped_columns DROP reg1 USING TIMESTAMP 10000;",
1:                                       "ALTER TABLE cql_test_keyspace_dropped_columns.test_table_dropped_columns DROP reg3 USING TIMESTAMP 30000;",
1:                                       "ALTER TABLE cql_test_keyspace_dropped_columns.test_table_dropped_columns DROP reg2 USING TIMESTAMP 20000;"),
1:                      ColumnFamilyStoreCQLHelper.getDroppedColumnsAsCQL(cfs.metadata));
1: 
1:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
1:         "CREATE TABLE IF NOT EXISTS cql_test_keyspace_dropped_columns.test_table_dropped_columns (\n" +
1:         "\tpk1 varint,\n" +
1:         "\tck1 varint,\n" +
1:         "\treg1 varint,\n" +
1:         "\treg3 varint,\n" +
1:         "\treg2 varint,\n" +
1:         "\tPRIMARY KEY (pk1, ck1))"));
1:     }
1: 
1:     @Test
1:     public void testReaddedColumns()
1:     {
1:         String keyspace = "cql_test_keyspace_readded_columns";
1:         String table = "test_table_readded_columns";
1: 
1:         CFMetaData cfm = CFMetaData.Builder.create(keyspace, table)
1:                                            .addPartitionKey("pk1", IntegerType.instance)
1:                                            .addClusteringColumn("ck1", IntegerType.instance)
1:                                            .addRegularColumn("reg1", IntegerType.instance)
1:                                            .addStaticColumn("reg2", IntegerType.instance)
1:                                            .addRegularColumn("reg3", IntegerType.instance)
1:                                            .build();
1: 
1:         ColumnDefinition reg1 = cfm.getColumnDefinition(ByteBufferUtil.bytes("reg1"));
1:         ColumnDefinition reg2 = cfm.getColumnDefinition(ByteBufferUtil.bytes("reg2"));
1: 
1:         cfm.removeColumnDefinition(reg1);
1:         cfm.removeColumnDefinition(reg2);
1: 
1:         cfm.recordColumnDrop(reg1, 10000);
1:         cfm.recordColumnDrop(reg2, 20000);
1: 
1:         cfm.addColumnDefinition(reg1);
1:         cfm.addColumnDefinition(reg2);
1: 
1:         SchemaLoader.createKeyspace(keyspace,
1:                                     KeyspaceParams.simple(1),
1:                                     cfm);
1: 
1:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
1: 
1:         // when re-adding, column is present in CREATE, then in DROP and then in ADD again, to record DROP with a proper timestamp
1:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
1:         "CREATE TABLE IF NOT EXISTS cql_test_keyspace_readded_columns.test_table_readded_columns (\n" +
1:         "\tpk1 varint,\n" +
1:         "\tck1 varint,\n" +
1:         "\treg2 varint static,\n" +
1:         "\treg1 varint,\n" +
1:         "\treg3 varint,\n" +
1:         "\tPRIMARY KEY (pk1, ck1))"));
1: 
1:         assertEquals(ImmutableList.of("ALTER TABLE cql_test_keyspace_readded_columns.test_table_readded_columns DROP reg1 USING TIMESTAMP 10000;",
1:                                       "ALTER TABLE cql_test_keyspace_readded_columns.test_table_readded_columns ADD reg1 varint;",
1:                                       "ALTER TABLE cql_test_keyspace_readded_columns.test_table_readded_columns DROP reg2 USING TIMESTAMP 20000;",
1:                                       "ALTER TABLE cql_test_keyspace_readded_columns.test_table_readded_columns ADD reg2 varint static;"),
1:                      ColumnFamilyStoreCQLHelper.getDroppedColumnsAsCQL(cfs.metadata));
1:     }
1: 
1:     @Test
1:     public void testCfmColumnsCQL()
1:     {
1:         String keyspace = "cql_test_keyspace_create_table";
1:         String table = "test_table_create_table";
1: 
1:         CFMetaData cfm = CFMetaData.Builder.create(keyspace, table)
1:                                            .addPartitionKey("pk1", IntegerType.instance)
1:                                            .addPartitionKey("pk2", AsciiType.instance)
1:                                            .addClusteringColumn("ck1", ReversedType.getInstance(IntegerType.instance))
1:                                            .addClusteringColumn("ck2", IntegerType.instance)
1:                                            .addStaticColumn("st1", AsciiType.instance)
1:                                            .addRegularColumn("reg1", AsciiType.instance)
1:                                            .addRegularColumn("reg2", ListType.getInstance(IntegerType.instance, false))
1:                                            .addRegularColumn("reg3", MapType.getInstance(AsciiType.instance, IntegerType.instance, true))
1:                                            .build();
1: 
1:         SchemaLoader.createKeyspace(keyspace,
1:                                     KeyspaceParams.simple(1),
1:                                     cfm);
1: 
1:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
1: 
1:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
1:         "CREATE TABLE IF NOT EXISTS cql_test_keyspace_create_table.test_table_create_table (\n" +
1:         "\tpk1 varint,\n" +
1:         "\tpk2 ascii,\n" +
1:         "\tck1 varint,\n" +
1:         "\tck2 varint,\n" +
1:         "\tst1 ascii static,\n" +
1:         "\treg1 ascii,\n" +
1:         "\treg2 frozen<list<varint>>,\n" +
1:         "\treg3 map<ascii, varint>,\n" +
1:         "\tPRIMARY KEY ((pk1, pk2), ck1, ck2))\n" +
1:         "\tWITH ID = " + cfs.metadata.cfId + "\n" +
1:         "\tAND CLUSTERING ORDER BY (ck1 DESC, ck2 ASC)"));
1:     }
1: 
1:     @Test
1:     public void testCfmCompactStorageCQL()
1:     {
1:         String keyspace = "cql_test_keyspace_compact";
1:         String table = "test_table_compact";
1: 
1:         CFMetaData cfm = CFMetaData.Builder.createDense(keyspace, table, true, false)
1:                                            .addPartitionKey("pk1", IntegerType.instance)
1:                                            .addPartitionKey("pk2", AsciiType.instance)
1:                                            .addClusteringColumn("ck1", ReversedType.getInstance(IntegerType.instance))
1:                                            .addClusteringColumn("ck2", IntegerType.instance)
1:                                            .addRegularColumn("reg", IntegerType.instance)
1:                                            .build();
1: 
1:         SchemaLoader.createKeyspace(keyspace,
1:                                     KeyspaceParams.simple(1),
1:                                     cfm);
1: 
1:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
1: 
1:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
1:         "CREATE TABLE IF NOT EXISTS cql_test_keyspace_compact.test_table_compact (\n" +
1:         "\tpk1 varint,\n" +
1:         "\tpk2 ascii,\n" +
1:         "\tck1 varint,\n" +
1:         "\tck2 varint,\n" +
1:         "\treg varint,\n" +
1:         "\tPRIMARY KEY ((pk1, pk2), ck1, ck2))\n" +
1:         "\tWITH ID = " + cfm.cfId + "\n" +
1:         "\tAND COMPACT STORAGE\n" +
1:         "\tAND CLUSTERING ORDER BY (ck1 DESC, ck2 ASC)"));
1:     }
1: 
1:     @Test
1:     public void testCfmCounterCQL()
1:     {
1:         String keyspace = "cql_test_keyspace_counter";
1:         String table = "test_table_counter";
1: 
1:         CFMetaData cfm = CFMetaData.Builder.createDense(keyspace, table, true, true)
1:                                            .addPartitionKey("pk1", IntegerType.instance)
1:                                            .addPartitionKey("pk2", AsciiType.instance)
1:                                            .addClusteringColumn("ck1", ReversedType.getInstance(IntegerType.instance))
1:                                            .addClusteringColumn("ck2", IntegerType.instance)
1:                                            .addRegularColumn("cnt", CounterColumnType.instance)
1:                                            .build();
1: 
1:         SchemaLoader.createKeyspace(keyspace,
1:                                     KeyspaceParams.simple(1),
1:                                     cfm);
1: 
1:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
1: 
1:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
1:         "CREATE TABLE IF NOT EXISTS cql_test_keyspace_counter.test_table_counter (\n" +
1:         "\tpk1 varint,\n" +
1:         "\tpk2 ascii,\n" +
1:         "\tck1 varint,\n" +
1:         "\tck2 varint,\n" +
1:         "\tcnt counter,\n" +
1:         "\tPRIMARY KEY ((pk1, pk2), ck1, ck2))\n" +
1:         "\tWITH ID = " + cfm.cfId + "\n" +
1:         "\tAND COMPACT STORAGE\n" +
1:         "\tAND CLUSTERING ORDER BY (ck1 DESC, ck2 ASC)"));
1:     }
1: 
1:     @Test
1:     public void testCfmOptionsCQL()
1:     {
1:         String keyspace = "cql_test_keyspace_options";
1:         String table = "test_table_options";
1: 
1:         CFMetaData cfm = CFMetaData.Builder.create(keyspace, table)
1:                                            .addPartitionKey("pk1", IntegerType.instance)
1:                                            .addClusteringColumn("cl1", IntegerType.instance)
1:                                            .addRegularColumn("reg1", AsciiType.instance)
1:                                            .build();
1: 
1:         cfm.recordColumnDrop(cfm.getColumnDefinition(ByteBuffer.wrap("reg1".getBytes())), FBUtilities.timestampMicros());
1:         cfm.bloomFilterFpChance(1.0);
1:         cfm.comment("comment");
1:         cfm.compaction(CompactionParams.lcs(Collections.singletonMap("sstable_size_in_mb", "1")));
1:         cfm.compression(CompressionParams.lz4(1 << 16));
1:         cfm.dcLocalReadRepairChance(0.2);
1:         cfm.crcCheckChance(0.3);
1:         cfm.defaultTimeToLive(4);
1:         cfm.gcGraceSeconds(5);
1:         cfm.minIndexInterval(6);
1:         cfm.maxIndexInterval(7);
1:         cfm.memtableFlushPeriod(8);
1:         cfm.readRepairChance(0.9);
1:         cfm.speculativeRetry(SpeculativeRetryParam.always());
1:         cfm.extensions(ImmutableMap.of("ext1",
1:                                        ByteBuffer.wrap("val1".getBytes())));
1: 
1:         SchemaLoader.createKeyspace(keyspace,
1:                                     KeyspaceParams.simple(1),
1:                                     cfm);
1:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
1: 
1:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).endsWith(
1:         "AND bloom_filter_fp_chance = 1.0\n" +
1:         "\tAND dclocal_read_repair_chance = 0.2\n" +
1:         "\tAND crc_check_chance = 0.3\n" +
1:         "\tAND default_time_to_live = 4\n" +
1:         "\tAND gc_grace_seconds = 5\n" +
1:         "\tAND min_index_interval = 6\n" +
1:         "\tAND max_index_interval = 7\n" +
1:         "\tAND memtable_flush_period_in_ms = 8\n" +
1:         "\tAND read_repair_chance = 0.9\n" +
1:         "\tAND speculative_retry = 'ALWAYS'\n" +
1:         "\tAND comment = 'comment'\n" +
1:         "\tAND caching = { 'keys': 'ALL', 'rows_per_partition': 'NONE' }\n" +
1:         "\tAND compaction = { 'class': 'org.apache.cassandra.db.compaction.LeveledCompactionStrategy', 'sstable_size_in_mb': '1' }\n" +
1:         "\tAND compression = { 'chunk_length_in_kb': '64', 'class': 'org.apache.cassandra.io.compress.LZ4Compressor' }\n" +
1:         "\tAND extensions = { 'ext1': 0x76616c31 };"
1:         ));
1:     }
1: 
1:     @Test
1:     public void testCfmIndexJson()
1:     {
1:         String keyspace = "cql_test_keyspace_3";
1:         String table = "test_table_3";
1: 
1:         CFMetaData cfm = CFMetaData.Builder.create(keyspace, table)
1:                                            .addPartitionKey("pk1", IntegerType.instance)
1:                                            .addClusteringColumn("cl1", IntegerType.instance)
1:                                            .addRegularColumn("reg1", AsciiType.instance)
1:                                            .build();
1: 
1:         cfm.indexes(cfm.getIndexes()
1:                        .with(IndexMetadata.fromIndexTargets(cfm,
1:                                                             Collections.singletonList(new IndexTarget(cfm.getColumnDefinition(ByteBufferUtil.bytes("reg1")).name,
1:                                                                                                       IndexTarget.Type.VALUES)),
1:                                                             "indexName",
1:                                                             IndexMetadata.Kind.COMPOSITES,
1:                                                             Collections.emptyMap()))
1:                        .with(IndexMetadata.fromIndexTargets(cfm,
1:                                                             Collections.singletonList(new IndexTarget(cfm.getColumnDefinition(ByteBufferUtil.bytes("reg1")).name,
1:                                                                                                       IndexTarget.Type.KEYS)),
1:                                                             "indexName2",
1:                                                             IndexMetadata.Kind.COMPOSITES,
1:                                                             Collections.emptyMap()))
1:                        .with(IndexMetadata.fromIndexTargets(cfm,
1:                                                             Collections.singletonList(new IndexTarget(cfm.getColumnDefinition(ByteBufferUtil.bytes("reg1")).name,
1:                                                                                                       IndexTarget.Type.KEYS_AND_VALUES)),
1:                                                             "indexName3",
1:                                                             IndexMetadata.Kind.COMPOSITES,
0:                                                             Collections.emptyMap())));
1: 
1: 
1:         SchemaLoader.createKeyspace(keyspace,
1:                                     KeyspaceParams.simple(1),
1:                                     cfm);
1: 
1:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
1: 
1:         assertEquals(ImmutableList.of("CREATE INDEX \"indexName\" ON cql_test_keyspace_3.test_table_3 (reg1);",
1:                                       "CREATE INDEX \"indexName2\" ON cql_test_keyspace_3.test_table_3 (reg1);",
0:                                       "CREATE INDEX \"indexName3\" ON cql_test_keyspace_3.test_table_3 (reg1);"),
1:                      ColumnFamilyStoreCQLHelper.getIndexesAsCQL(cfs.metadata));
1:     }
1: 
1:     private final static String SNAPSHOT = "testsnapshot";
1: 
1:     @Test
1:     public void testSnapshot() throws Throwable
1:     {
1:         String typeA = createType("CREATE TYPE %s (a1 varint, a2 varint, a3 varint);");
1:         String typeB = createType("CREATE TYPE %s (b1 frozen<" + typeA + ">, b2 frozen<" + typeA + ">, b3 frozen<" + typeA + ">);");
1:         String typeC = createType("CREATE TYPE %s (c1 frozen<" + typeB + ">, c2 frozen<" + typeB + ">, c3 frozen<" + typeB + ">);");
1: 
1:         String tableName = createTable("CREATE TABLE IF NOT EXISTS %s (" +
1:                                        "pk1 varint," +
1:                                        "pk2 ascii," +
1:                                        "ck1 varint," +
1:                                        "ck2 varint," +
0:                                        "reg1 frozen<" + typeC + ">," +
1:                                        "reg2 int," +
1:                                        "reg3 int," +
1:                                        "PRIMARY KEY ((pk1, pk2), ck1, ck2)) WITH " +
1:                                        "CLUSTERING ORDER BY (ck1 ASC, ck2 DESC);");
1: 
1:         alterTable("ALTER TABLE %s DROP reg3 USING TIMESTAMP 10000;");
1:         alterTable("ALTER TABLE %s ADD reg3 int;");
1: 
1:         for (int i = 0; i < 10; i++)
1:             execute("INSERT INTO %s (pk1, pk2, ck1, ck2, reg1, reg2) VALUES (?, ?, ?, ?, ?, ?)", i, i + 1, i + 2, i + 3, null, i + 5);
1: 
1:         ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(tableName);
1:         cfs.snapshot(SNAPSHOT);
1: 
1:         String schema = Files.toString(cfs.getDirectories().getSnapshotSchemaFile(SNAPSHOT), Charset.defaultCharset());
1:         assertTrue(schema.contains(String.format("CREATE TYPE %s.%s(a1 varint, a2 varint, a3 varint);", keyspace(), typeA)));
1:         assertTrue(schema.contains(String.format("CREATE TYPE %s.%s(a1 varint, a2 varint, a3 varint);", keyspace(), typeA)));
1:         assertTrue(schema.contains(String.format("CREATE TYPE %s.%s(b1 frozen<%s>, b2 frozen<%s>, b3 frozen<%s>);", keyspace(), typeB, typeA, typeA, typeA)));
1:         assertTrue(schema.contains(String.format("CREATE TYPE %s.%s(c1 frozen<%s>, c2 frozen<%s>, c3 frozen<%s>);", keyspace(), typeC, typeB, typeB, typeB)));
1: 
1:         schema = schema.substring(schema.indexOf("CREATE TABLE")); // trim to ensure order
1: 
1:         assertTrue(schema.startsWith("CREATE TABLE IF NOT EXISTS " + keyspace() + "." + tableName + " (\n" +
1:                                      "\tpk1 varint,\n" +
1:                                      "\tpk2 ascii,\n" +
1:                                      "\tck1 varint,\n" +
1:                                      "\tck2 varint,\n" +
0:                                      "\treg1 frozen<" + typeC + ">,\n" +
1:                                      "\treg2 int,\n" +
1:                                      "\treg3 int,\n" +
1:                                      "\tPRIMARY KEY ((pk1, pk2), ck1, ck2))\n" +
1:                                      "\tWITH ID = " + cfs.metadata.cfId + "\n" +
1:                                      "\tAND CLUSTERING ORDER BY (ck1 ASC, ck2 DESC)"));
1: 
1:         schema = schema.substring(schema.indexOf("ALTER"));
1:         assertTrue(schema.startsWith(String.format("ALTER TABLE %s.%s DROP reg3 USING TIMESTAMP 10000;", keyspace(), tableName)));
1:         assertTrue(schema.contains(String.format("ALTER TABLE %s.%s ADD reg3 int;", keyspace(), tableName)));
1: 
1:         JSONObject manifest = (JSONObject) new JSONParser().parse(new FileReader(cfs.getDirectories().getSnapshotManifestFile(SNAPSHOT)));
1:         JSONArray files = (JSONArray) manifest.get("files");
1:         Assert.assertEquals(1, files.size());
1:     }
1: 
1:     @Test
1:     public void testSystemKsSnapshot() throws Throwable
1:     {
1:         ColumnFamilyStore cfs = Keyspace.open("system").getColumnFamilyStore("peers");
1:         cfs.snapshot(SNAPSHOT);
1: 
1:         Assert.assertTrue(cfs.getDirectories().getSnapshotManifestFile(SNAPSHOT).exists());
1:         Assert.assertFalse(cfs.getDirectories().getSnapshotSchemaFile(SNAPSHOT).exists());
1:     }
1: 
1:     @Test
1:     public void testDroppedType() throws Throwable
1:     {
1:         String typeA = createType("CREATE TYPE %s (a1 varint, a2 varint, a3 varint);");
1:         String typeB = createType("CREATE TYPE %s (b1 frozen<" + typeA + ">, b2 frozen<" + typeA + ">, b3 frozen<" + typeA + ">);");
1: 
1:         String tableName = createTable("CREATE TABLE IF NOT EXISTS %s (" +
1:                                        "pk1 varint," +
1:                                        "ck1 varint," +
0:                                        "reg1 frozen<" + typeB + ">," +
1:                                        "reg2 varint," +
1:                                        "PRIMARY KEY (pk1, ck1));");
1: 
1:         alterTable("ALTER TABLE %s DROP reg1 USING TIMESTAMP 10000;");
1: 
1:         Runnable validate = () -> {
1:             try
1:             {
1:                 ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(tableName);
1:                 cfs.snapshot(SNAPSHOT);
1:                 String schema = Files.toString(cfs.getDirectories().getSnapshotSchemaFile(SNAPSHOT), Charset.defaultCharset());
1: 
1:                 // When both column and it's type are dropped, the type in column definition gets substituted with a tuple
1:                 assertTrue(schema.startsWith("CREATE TABLE IF NOT EXISTS " + keyspace() + "." + tableName + " (\n" +
1:                                              "\tpk1 varint,\n" +
1:                                              "\tck1 varint,\n" +
1:                                              "\treg2 varint,\n" +
1:                                              "\treg1 frozen<tuple<frozen<tuple<varint, varint, varint>>, frozen<tuple<varint, varint, varint>>, frozen<tuple<varint, varint, varint>>>>,\n" +
1:                                              "\tPRIMARY KEY (pk1, ck1))"));
1:                 assertTrue(schema.contains("ALTER TABLE " + keyspace() + "." + tableName + " DROP reg1 USING TIMESTAMP 10000;"));
1:             }
1:             catch (Exception e)
1:             {
1:                 throw new RuntimeException(e);
1:             }
1:         };
1: 
1:         // Validate before and after the type drop
1:         validate.run();
1:         schemaChange("DROP TYPE " + keyspace() + "." + typeB);
1:         schemaChange("DROP TYPE " + keyspace() + "." + typeA);
1:         validate.run();
1:     }
1: 
1:     @Test
1:     public void testDenseTable() throws Throwable
1:     {
1:         String tableName = createTable("CREATE TABLE IF NOT EXISTS %s (" +
1:                                        "pk1 varint PRIMARY KEY," +
1:                                        "reg1 int)" +
1:                                        " WITH COMPACT STORAGE");
1: 
1:         ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(tableName);
1: 
1:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
1:         "CREATE TABLE IF NOT EXISTS " + keyspace() + "." + tableName + " (\n" +
1:         "\tpk1 varint PRIMARY KEY,\n" +
1:         "\treg1 int)\n" +
1:         "\tWITH ID = " + cfs.metadata.cfId + "\n" +
1:         "\tAND COMPACT STORAGE"));
1:     }
1: 
1:     @Test
1:     public void testStaticCompactTable() throws Throwable
1:     {
1:         String tableName = createTable("CREATE TABLE IF NOT EXISTS %s (" +
1:                                        "pk1 varint PRIMARY KEY," +
1:                                        "reg1 int," +
1:                                        "reg2 int)" +
1:                                        " WITH COMPACT STORAGE");
1: 
1:         ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(tableName);
1: 
1:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
1:         "CREATE TABLE IF NOT EXISTS " + keyspace() + "." + tableName + " (\n" +
1:         "\tpk1 varint PRIMARY KEY,\n" +
1:         "\treg1 int,\n" +
1:         "\treg2 int)\n" +
1:         "\tWITH ID = " + cfs.metadata.cfId + "\n" +
1:         "\tAND COMPACT STORAGE"));
1:     }
1: 
1:     @Test
1:     public void testStaticCompactWithCounters() throws Throwable
1:     {
1:         String tableName = createTable("CREATE TABLE IF NOT EXISTS %s (" +
1:                                        "pk1 varint PRIMARY KEY," +
1:                                        "reg1 counter," +
1:                                        "reg2 counter)" +
1:                                        " WITH COMPACT STORAGE");
1: 
1: 
1:         ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(tableName);
1: 
1:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
1:         "CREATE TABLE IF NOT EXISTS " + keyspace() + "." + tableName + " (\n" +
1:         "\tpk1 varint PRIMARY KEY,\n" +
1:         "\treg1 counter,\n" +
1:         "\treg2 counter)\n" +
1:         "\tWITH ID = " + cfs.metadata.cfId + "\n" +
1:         "\tAND COMPACT STORAGE"));
1:     }
1: 
1:     @Test
1:     public void testDenseCompactTableWithoutRegulars() throws Throwable
1:     {
1:         String tableName = createTable("CREATE TABLE IF NOT EXISTS %s (" +
1:                                        "pk1 varint," +
1:                                        "ck1 int," +
1:                                        "PRIMARY KEY (pk1, ck1))" +
1:                                        " WITH COMPACT STORAGE");
1: 
1:         ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(tableName);
1: 
1:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
1:         "CREATE TABLE IF NOT EXISTS " + keyspace() + "." + tableName + " (\n" +
1:         "\tpk1 varint,\n" +
1:         "\tck1 int,\n" +
1:         "\tPRIMARY KEY (pk1, ck1))\n" +
1:         "\tWITH ID = " + cfs.metadata.cfId + "\n" +
1:         "\tAND COMPACT STORAGE"));
1:     }
1: 
1:     @Test
1:     public void testCompactDynamic() throws Throwable
1:     {
1:         String tableName = createTable("CREATE TABLE IF NOT EXISTS %s (" +
1:                                        "pk1 varint," +
1:                                        "ck1 int," +
1:                                        "reg int," +
1:                                        "PRIMARY KEY (pk1, ck1))" +
1:                                        " WITH COMPACT STORAGE");
1: 
1:         ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(tableName);
1: 
1:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
1:         "CREATE TABLE IF NOT EXISTS " + keyspace() + "." + tableName + " (\n" +
1:         "\tpk1 varint,\n" +
1:         "\tck1 int,\n" +
1:         "\treg int,\n" +
1:         "\tPRIMARY KEY (pk1, ck1))\n" +
1:         "\tWITH ID = " + cfs.metadata.cfId + "\n" +
1:         "\tAND COMPACT STORAGE"));
1:     }
1: 
1:     @Test
1:     public void testDynamicComposite() throws Throwable
1:     {
1:         Map<Byte, AbstractType<?>> aliases = new HashMap<>();
1:         aliases.put((byte)'a', BytesType.instance);
1:         aliases.put((byte)'b', BytesType.instance);
1:         aliases.put((byte)'c', BytesType.instance);
1: 
1:         String DYNAMIC_COMPOSITE = "dynamic_composite";
1:         AbstractType<?> dynamicComposite = DynamicCompositeType.getInstance(aliases);
1: 
1:         SchemaLoader.createKeyspace(DYNAMIC_COMPOSITE,
1:                                     KeyspaceParams.simple(1),
1:                                     SchemaLoader.denseCFMD(DYNAMIC_COMPOSITE, DYNAMIC_COMPOSITE, dynamicComposite));
1: 
1:         ColumnFamilyStore cfs = Keyspace.open(DYNAMIC_COMPOSITE).getColumnFamilyStore(DYNAMIC_COMPOSITE);
1: 
1:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
1:         "CREATE TABLE IF NOT EXISTS " + DYNAMIC_COMPOSITE + "." + DYNAMIC_COMPOSITE + " (\n" +
0:         "\tkey ascii,\n" +
1:         "\tcols 'org.apache.cassandra.db.marshal.DynamicCompositeType(a=>org.apache.cassandra.db.marshal.BytesType,b=>org.apache.cassandra.db.marshal.BytesType,c=>org.apache.cassandra.db.marshal.BytesType)',\n" +
1:         "\tval ascii,\n" +
0:         "\tPRIMARY KEY (key, cols))\n" +
1:         "\tWITH ID = " + cfs.metadata.cfId + "\n" +
1:         "\tAND COMPACT STORAGE"));
1:     }
1: 
1:     @Test
1:     public void superColumnFamilyTest() throws Throwable
1:     {
1:         final String KEYSPACE = "thrift_compact_table_with_supercolumns_test";
1:         final String TABLE = "test_table_1";
1: 
1:         CFMetaData cfm = CFMetaData.Builder.createSuper(KEYSPACE, TABLE, false)
1:                                            .addPartitionKey("pk", BytesType.instance)
1:                                            .addClusteringColumn("c1", AsciiType.instance)
1:                                            .addClusteringColumn("c2", AsciiType.instance)
1:                                            .addRegularColumn("", MapType.getInstance(Int32Type.instance, AsciiType.instance, true))
1:                                            .build();
1: 
1:         SchemaLoader.createKeyspace(KEYSPACE,
1:                                     KeyspaceParams.simple(1),
1:                                     cfm);
1: 
1:         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(TABLE);
1: 
1:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
1:         "/*\n" +
1:         "Warning: Table " + KEYSPACE + "." + TABLE + " omitted because it has constructs not compatible with CQL (was created via legacy API).\n\n" +
1:         "Approximate structure, for reference:\n" +
1:         "(this should not be used to reproduce this schema)\n\n" +
1:         "CREATE TABLE IF NOT EXISTS " + KEYSPACE + "." + TABLE + " (\n" +
1:         "\tpk blob,\n" +
1:         "\tc1 ascii,\n" +
1:         "\tc2 ascii,\n" +
1:         "\t\"\" map<int, ascii>,\n" +
1:         "\tPRIMARY KEY (pk, c1, c2))\n" +
1:         "\tWITH ID = " + cfs.metadata.cfId + "\n" +
1:         "\tAND COMPACT STORAGE"));
1:     }
1: }
commit:a123e98
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: 
0: package org.apache.cassandra.db;
0: 
0: import java.io.FileReader;
0: import java.nio.ByteBuffer;
0: import java.nio.charset.Charset;
0: import java.util.*;
0: 
0: import com.google.common.collect.ImmutableList;
0: import com.google.common.collect.ImmutableMap;
0: import com.google.common.io.Files;
0: import org.junit.Assert;
0: import org.junit.Before;
0: import org.junit.Test;
0: 
0: import org.apache.cassandra.*;
0: import org.apache.cassandra.config.*;
0: import org.apache.cassandra.cql3.*;
0: import org.apache.cassandra.cql3.statements.*;
0: import org.apache.cassandra.db.marshal.*;
0: import org.apache.cassandra.exceptions.*;
1: import org.apache.cassandra.index.sasi.*;
0: import org.apache.cassandra.schema.*;
0: import org.apache.cassandra.utils.*;
0: import org.json.simple.JSONArray;
0: import org.json.simple.JSONObject;
0: import org.json.simple.parser.JSONParser;
0: 
0: import static org.junit.Assert.assertEquals;
0: import static org.junit.Assert.assertTrue;
0: 
0: public class ColumnFamilyStoreCQLHelperTest extends CQLTester
0: {
0:     @Before
0:     public void defineSchema() throws ConfigurationException
0:     {
0:         SchemaLoader.prepareServer();
0:     }
0: 
0:     @Test
0:     public void testUserTypesCQL()
0:     {
0:         String keyspace = "cql_test_keyspace_user_types";
0:         String table = "test_table_user_types";
0: 
0:         UserType typeA = new UserType(keyspace, ByteBufferUtil.bytes("a"),
1:                                       Arrays.asList(FieldIdentifier.forUnquoted("a1"),
1:                                                     FieldIdentifier.forUnquoted("a2"),
1:                                                     FieldIdentifier.forUnquoted("a3")),
0:                                       Arrays.asList(IntegerType.instance,
0:                                                     IntegerType.instance,
1:                                                     IntegerType.instance),
1:                                       true);
0: 
0:         UserType typeB = new UserType(keyspace, ByteBufferUtil.bytes("b"),
1:                                       Arrays.asList(FieldIdentifier.forUnquoted("b1"),
1:                                                     FieldIdentifier.forUnquoted("b2"),
1:                                                     FieldIdentifier.forUnquoted("b3")),
0:                                       Arrays.asList(typeA,
0:                                                     typeA,
1:                                                     typeA),
1:                                       true);
0: 
0:         UserType typeC = new UserType(keyspace, ByteBufferUtil.bytes("c"),
1:                                       Arrays.asList(FieldIdentifier.forUnquoted("c1"),
1:                                                     FieldIdentifier.forUnquoted("c2"),
1:                                                     FieldIdentifier.forUnquoted("c3")),
0:                                       Arrays.asList(typeB,
0:                                                     typeB,
1:                                                     typeB),
1:                                       true);
0: 
0:         CFMetaData cfm = CFMetaData.Builder.create(keyspace, table)
0:                                            .addPartitionKey("pk1", IntegerType.instance)
0:                                            .addClusteringColumn("ck1", IntegerType.instance)
0:                                            .addRegularColumn("reg1", typeC)
0:                                            .addRegularColumn("reg2", ListType.getInstance(IntegerType.instance, false))
0:                                            .addRegularColumn("reg3", MapType.getInstance(AsciiType.instance, IntegerType.instance, true))
0:                                            .build();
0: 
0:         SchemaLoader.createKeyspace(keyspace,
0:                                     KeyspaceParams.simple(1),
0:                                     Tables.of(cfm),
0:                                     Types.of(typeA, typeB, typeC));
0: 
0:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
0: 
0:         assertEquals(ImmutableList.of("CREATE TYPE cql_test_keyspace_user_types.a(a1 varint, a2 varint, a3 varint);",
1:                                       "CREATE TYPE cql_test_keyspace_user_types.b(b1 a, b2 a, b3 a);",
1:                                       "CREATE TYPE cql_test_keyspace_user_types.c(c1 b, c2 b, c3 b);"),
0:                      ColumnFamilyStoreCQLHelper.getUserTypesAsCQL(cfs.metadata));
0:     }
0: 
0:     @Test
0:     public void testDroppedColumnsCQL()
0:     {
0:         String keyspace = "cql_test_keyspace_dropped_columns";
0:         String table = "test_table_dropped_columns";
0: 
0:         CFMetaData cfm = CFMetaData.Builder.create(keyspace, table)
0:                                            .addPartitionKey("pk1", IntegerType.instance)
0:                                            .addClusteringColumn("ck1", IntegerType.instance)
0:                                            .addRegularColumn("reg1", IntegerType.instance)
0:                                            .addRegularColumn("reg2", IntegerType.instance)
0:                                            .addRegularColumn("reg3", IntegerType.instance)
0:                                            .build();
0: 
0: 
0:         ColumnDefinition reg1 = cfm.getColumnDefinition(ByteBufferUtil.bytes("reg1"));
0:         ColumnDefinition reg2 = cfm.getColumnDefinition(ByteBufferUtil.bytes("reg2"));
0:         ColumnDefinition reg3 = cfm.getColumnDefinition(ByteBufferUtil.bytes("reg3"));
0: 
0:         cfm.removeColumnDefinition(reg1);
0:         cfm.removeColumnDefinition(reg2);
0:         cfm.removeColumnDefinition(reg3);
0: 
0:         cfm.recordColumnDrop(reg1, 10000);
0:         cfm.recordColumnDrop(reg2, 20000);
0:         cfm.recordColumnDrop(reg3, 30000);
0: 
0:         SchemaLoader.createKeyspace(keyspace,
0:                                     KeyspaceParams.simple(1),
0:                                     cfm);
0: 
0:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
0: 
0:         assertEquals(ImmutableList.of("ALTER TABLE cql_test_keyspace_dropped_columns.test_table_dropped_columns DROP reg1 USING TIMESTAMP 10000;",
0:                                       "ALTER TABLE cql_test_keyspace_dropped_columns.test_table_dropped_columns DROP reg3 USING TIMESTAMP 30000;",
0:                                       "ALTER TABLE cql_test_keyspace_dropped_columns.test_table_dropped_columns DROP reg2 USING TIMESTAMP 20000;"),
0:                      ColumnFamilyStoreCQLHelper.getDroppedColumnsAsCQL(cfs.metadata));
0: 
0:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
0:         "CREATE TABLE IF NOT EXISTS cql_test_keyspace_dropped_columns.test_table_dropped_columns (\n" +
0:         "\tpk1 varint,\n" +
0:         "\tck1 varint,\n" +
0:         "\treg1 varint,\n" +
0:         "\treg3 varint,\n" +
0:         "\treg2 varint,\n" +
0:         "\tPRIMARY KEY (pk1, ck1))"));
0:     }
0: 
0:     @Test
0:     public void testReaddedColumns()
0:     {
0:         String keyspace = "cql_test_keyspace_readded_columns";
0:         String table = "test_table_readded_columns";
0: 
0:         CFMetaData cfm = CFMetaData.Builder.create(keyspace, table)
0:                                            .addPartitionKey("pk1", IntegerType.instance)
0:                                            .addClusteringColumn("ck1", IntegerType.instance)
0:                                            .addRegularColumn("reg1", IntegerType.instance)
0:                                            .addStaticColumn("reg2", IntegerType.instance)
0:                                            .addRegularColumn("reg3", IntegerType.instance)
0:                                            .build();
0: 
0:         ColumnDefinition reg1 = cfm.getColumnDefinition(ByteBufferUtil.bytes("reg1"));
0:         ColumnDefinition reg2 = cfm.getColumnDefinition(ByteBufferUtil.bytes("reg2"));
0: 
0:         cfm.removeColumnDefinition(reg1);
0:         cfm.removeColumnDefinition(reg2);
0: 
0:         cfm.recordColumnDrop(reg1, 10000);
0:         cfm.recordColumnDrop(reg2, 20000);
0: 
0:         cfm.addColumnDefinition(reg1);
0:         cfm.addColumnDefinition(reg2);
0: 
0:         SchemaLoader.createKeyspace(keyspace,
0:                                     KeyspaceParams.simple(1),
0:                                     cfm);
0: 
0:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
0: 
0:         // when re-adding, column is present in CREATE, then in DROP and then in ADD again, to record DROP with a proper timestamp
0:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
0:         "CREATE TABLE IF NOT EXISTS cql_test_keyspace_readded_columns.test_table_readded_columns (\n" +
0:         "\tpk1 varint,\n" +
0:         "\tck1 varint,\n" +
0:         "\treg2 varint static,\n" +
0:         "\treg1 varint,\n" +
0:         "\treg3 varint,\n" +
0:         "\tPRIMARY KEY (pk1, ck1))"));
0: 
0:         assertEquals(ImmutableList.of("ALTER TABLE cql_test_keyspace_readded_columns.test_table_readded_columns DROP reg1 USING TIMESTAMP 10000;",
0:                                       "ALTER TABLE cql_test_keyspace_readded_columns.test_table_readded_columns ADD reg1 varint;",
0:                                       "ALTER TABLE cql_test_keyspace_readded_columns.test_table_readded_columns DROP reg2 USING TIMESTAMP 20000;",
0:                                       "ALTER TABLE cql_test_keyspace_readded_columns.test_table_readded_columns ADD reg2 varint static;"),
0:                      ColumnFamilyStoreCQLHelper.getDroppedColumnsAsCQL(cfs.metadata));
0:     }
0: 
0:     @Test
0:     public void testCfmColumnsCQL()
0:     {
0:         String keyspace = "cql_test_keyspace_create_table";
0:         String table = "test_table_create_table";
0: 
0:         CFMetaData cfm = CFMetaData.Builder.create(keyspace, table)
0:                                            .addPartitionKey("pk1", IntegerType.instance)
0:                                            .addPartitionKey("pk2", AsciiType.instance)
0:                                            .addClusteringColumn("ck1", ReversedType.getInstance(IntegerType.instance))
0:                                            .addClusteringColumn("ck2", IntegerType.instance)
0:                                            .addStaticColumn("st1", AsciiType.instance)
0:                                            .addRegularColumn("reg1", AsciiType.instance)
0:                                            .addRegularColumn("reg2", ListType.getInstance(IntegerType.instance, false))
0:                                            .addRegularColumn("reg3", MapType.getInstance(AsciiType.instance, IntegerType.instance, true))
0:                                            .build();
0: 
0:         SchemaLoader.createKeyspace(keyspace,
0:                                     KeyspaceParams.simple(1),
0:                                     cfm);
0: 
0:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
0: 
0:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
0:         "CREATE TABLE IF NOT EXISTS cql_test_keyspace_create_table.test_table_create_table (\n" +
0:         "\tpk1 varint,\n" +
0:         "\tpk2 ascii,\n" +
0:         "\tck1 varint,\n" +
0:         "\tck2 varint,\n" +
0:         "\tst1 ascii static,\n" +
0:         "\treg1 ascii,\n" +
0:         "\treg2 frozen<list<varint>>,\n" +
0:         "\treg3 map<ascii, varint>,\n" +
0:         "\tPRIMARY KEY ((pk1, pk2), ck1, ck2))\n" +
0:         "\tWITH ID = " + cfs.metadata.cfId + "\n" +
0:         "\tAND CLUSTERING ORDER BY (ck1 DESC, ck2 ASC)"));
0:     }
0: 
0:     @Test
0:     public void testCfmCompactStorageCQL()
0:     {
0:         String keyspace = "cql_test_keyspace_compact";
0:         String table = "test_table_compact";
0: 
0:         CFMetaData cfm = CFMetaData.Builder.createDense(keyspace, table, true, false)
0:                                            .addPartitionKey("pk1", IntegerType.instance)
0:                                            .addPartitionKey("pk2", AsciiType.instance)
0:                                            .addClusteringColumn("ck1", ReversedType.getInstance(IntegerType.instance))
0:                                            .addClusteringColumn("ck2", IntegerType.instance)
0:                                            .addRegularColumn("reg", IntegerType.instance)
0:                                            .build();
0: 
0:         SchemaLoader.createKeyspace(keyspace,
0:                                     KeyspaceParams.simple(1),
0:                                     cfm);
0: 
0:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
0: 
0:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
0:         "CREATE TABLE IF NOT EXISTS cql_test_keyspace_compact.test_table_compact (\n" +
0:         "\tpk1 varint,\n" +
0:         "\tpk2 ascii,\n" +
0:         "\tck1 varint,\n" +
0:         "\tck2 varint,\n" +
0:         "\treg varint,\n" +
0:         "\tPRIMARY KEY ((pk1, pk2), ck1, ck2))\n" +
0:         "\tWITH ID = " + cfm.cfId + "\n" +
0:         "\tAND COMPACT STORAGE\n" +
0:         "\tAND CLUSTERING ORDER BY (ck1 DESC, ck2 ASC)"));
0:     }
0: 
0:     @Test
0:     public void testCfmCounterCQL()
0:     {
0:         String keyspace = "cql_test_keyspace_counter";
0:         String table = "test_table_counter";
0: 
0:         CFMetaData cfm = CFMetaData.Builder.createDense(keyspace, table, true, true)
0:                                            .addPartitionKey("pk1", IntegerType.instance)
0:                                            .addPartitionKey("pk2", AsciiType.instance)
0:                                            .addClusteringColumn("ck1", ReversedType.getInstance(IntegerType.instance))
0:                                            .addClusteringColumn("ck2", IntegerType.instance)
0:                                            .addRegularColumn("cnt", CounterColumnType.instance)
0:                                            .build();
0: 
0:         SchemaLoader.createKeyspace(keyspace,
0:                                     KeyspaceParams.simple(1),
0:                                     cfm);
0: 
0:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
0: 
0:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
0:         "CREATE TABLE IF NOT EXISTS cql_test_keyspace_counter.test_table_counter (\n" +
0:         "\tpk1 varint,\n" +
0:         "\tpk2 ascii,\n" +
0:         "\tck1 varint,\n" +
0:         "\tck2 varint,\n" +
0:         "\tcnt counter,\n" +
0:         "\tPRIMARY KEY ((pk1, pk2), ck1, ck2))\n" +
0:         "\tWITH ID = " + cfm.cfId + "\n" +
0:         "\tAND COMPACT STORAGE\n" +
0:         "\tAND CLUSTERING ORDER BY (ck1 DESC, ck2 ASC)"));
0:     }
0: 
0:     @Test
0:     public void testCfmOptionsCQL()
0:     {
0:         String keyspace = "cql_test_keyspace_options";
0:         String table = "test_table_options";
0: 
0:         CFMetaData cfm = CFMetaData.Builder.create(keyspace, table)
0:                                            .addPartitionKey("pk1", IntegerType.instance)
0:                                            .addClusteringColumn("cl1", IntegerType.instance)
0:                                            .addRegularColumn("reg1", AsciiType.instance)
0:                                            .build();
0: 
0:         cfm.recordColumnDrop(cfm.getColumnDefinition(ByteBuffer.wrap("reg1".getBytes())), FBUtilities.timestampMicros());
0:         cfm.bloomFilterFpChance(1.0);
0:         cfm.comment("comment");
0:         cfm.compaction(CompactionParams.lcs(Collections.singletonMap("sstable_size_in_mb", "1")));
0:         cfm.compression(CompressionParams.lz4(1 << 16));
0:         cfm.dcLocalReadRepairChance(0.2);
0:         cfm.crcCheckChance(0.3);
0:         cfm.defaultTimeToLive(4);
0:         cfm.gcGraceSeconds(5);
0:         cfm.minIndexInterval(6);
0:         cfm.maxIndexInterval(7);
0:         cfm.memtableFlushPeriod(8);
0:         cfm.readRepairChance(0.9);
0:         cfm.speculativeRetry(SpeculativeRetryParam.always());
0:         cfm.extensions(ImmutableMap.of("ext1",
0:                                        ByteBuffer.wrap("val1".getBytes())));
0: 
0:         SchemaLoader.createKeyspace(keyspace,
0:                                     KeyspaceParams.simple(1),
0:                                     cfm);
0:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
0: 
0:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).endsWith(
0:         "AND bloom_filter_fp_chance = 1.0\n" +
0:         "\tAND dclocal_read_repair_chance = 0.2\n" +
0:         "\tAND crc_check_chance = 0.3\n" +
0:         "\tAND default_time_to_live = 4\n" +
0:         "\tAND gc_grace_seconds = 5\n" +
0:         "\tAND min_index_interval = 6\n" +
0:         "\tAND max_index_interval = 7\n" +
0:         "\tAND memtable_flush_period_in_ms = 8\n" +
0:         "\tAND read_repair_chance = 0.9\n" +
0:         "\tAND speculative_retry = 'ALWAYS'\n" +
0:         "\tAND comment = 'comment'\n" +
0:         "\tAND caching = { 'keys': 'ALL', 'rows_per_partition': 'NONE' }\n" +
0:         "\tAND compaction = { 'class': 'org.apache.cassandra.db.compaction.LeveledCompactionStrategy', 'sstable_size_in_mb': '1' }\n" +
0:         "\tAND compression = { 'chunk_length_in_kb': '64', 'class': 'org.apache.cassandra.io.compress.LZ4Compressor' }\n" +
1:         "\tAND cdc = false\n" +
0:         "\tAND extensions = { 'ext1': 0x76616c31 };"
1:         ));
0:     }
0: 
0:     @Test
0:     public void testCfmIndexJson()
0:     {
0:         String keyspace = "cql_test_keyspace_3";
0:         String table = "test_table_3";
0: 
0:         CFMetaData cfm = CFMetaData.Builder.create(keyspace, table)
0:                                            .addPartitionKey("pk1", IntegerType.instance)
0:                                            .addClusteringColumn("cl1", IntegerType.instance)
0:                                            .addRegularColumn("reg1", AsciiType.instance)
0:                                            .build();
0: 
0:         cfm.indexes(cfm.getIndexes()
1:                        .with(IndexMetadata.fromIndexTargets(cfm,
1:                                                             Collections.singletonList(new IndexTarget(cfm.getColumnDefinition(ByteBufferUtil.bytes("reg1")).name,
0:                                                                                                       IndexTarget.Type.VALUES)),
0:                                                             "indexName",
0:                                                             IndexMetadata.Kind.COMPOSITES,
1:                                                             Collections.emptyMap()))
1:                        .with(IndexMetadata.fromIndexTargets(cfm,
1:                                                             Collections.singletonList(new IndexTarget(cfm.getColumnDefinition(ByteBufferUtil.bytes("reg1")).name,
0:                                                                                                       IndexTarget.Type.KEYS)),
0:                                                             "indexName2",
0:                                                             IndexMetadata.Kind.COMPOSITES,
1:                                                             Collections.emptyMap()))
1:                        .with(IndexMetadata.fromIndexTargets(cfm,
1:                                                             Collections.singletonList(new IndexTarget(cfm.getColumnDefinition(ByteBufferUtil.bytes("reg1")).name,
1:                                                                                                       IndexTarget.Type.KEYS_AND_VALUES)),
0:                                                             "indexName3",
0:                                                             IndexMetadata.Kind.COMPOSITES,
1:                                                             Collections.emptyMap()))
1:                        .with(IndexMetadata.fromIndexTargets(cfm,
1:                                                             Collections.singletonList(new IndexTarget(cfm.getColumnDefinition(ByteBufferUtil.bytes("reg1")).name,
1:                                                                                                       IndexTarget.Type.KEYS_AND_VALUES)),
1:                                                             "indexName4",
1:                                                             IndexMetadata.Kind.CUSTOM,
1:                                                             Collections.singletonMap(IndexTarget.CUSTOM_INDEX_OPTION_NAME,
1:                                                                                      SASIIndex.class.getName()))
1:                        ));
0: 
0: 
0:         SchemaLoader.createKeyspace(keyspace,
0:                                     KeyspaceParams.simple(1),
0:                                     cfm);
0: 
0:         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
0: 
0:         assertEquals(ImmutableList.of("CREATE INDEX \"indexName\" ON cql_test_keyspace_3.test_table_3 (reg1);",
0:                                       "CREATE INDEX \"indexName2\" ON cql_test_keyspace_3.test_table_3 (reg1);",
1:                                       "CREATE INDEX \"indexName3\" ON cql_test_keyspace_3.test_table_3 (reg1);",
1:                                       "CREATE CUSTOM INDEX \"indexName4\" ON cql_test_keyspace_3.test_table_3 (reg1) USING 'org.apache.cassandra.index.sasi.SASIIndex';"),
0:                      ColumnFamilyStoreCQLHelper.getIndexesAsCQL(cfs.metadata));
0:     }
0: 
0:     private final static String SNAPSHOT = "testsnapshot";
0: 
0:     @Test
0:     public void testSnapshot() throws Throwable
0:     {
0:         String typeA = createType("CREATE TYPE %s (a1 varint, a2 varint, a3 varint);");
0:         String typeB = createType("CREATE TYPE %s (b1 frozen<" + typeA + ">, b2 frozen<" + typeA + ">, b3 frozen<" + typeA + ">);");
0:         String typeC = createType("CREATE TYPE %s (c1 frozen<" + typeB + ">, c2 frozen<" + typeB + ">, c3 frozen<" + typeB + ">);");
0: 
0:         String tableName = createTable("CREATE TABLE IF NOT EXISTS %s (" +
0:                                        "pk1 varint," +
0:                                        "pk2 ascii," +
0:                                        "ck1 varint," +
0:                                        "ck2 varint," +
1:                                        "reg1 " + typeC + "," +
0:                                        "reg2 int," +
0:                                        "reg3 int," +
0:                                        "PRIMARY KEY ((pk1, pk2), ck1, ck2)) WITH " +
0:                                        "CLUSTERING ORDER BY (ck1 ASC, ck2 DESC);");
0: 
0:         alterTable("ALTER TABLE %s DROP reg3 USING TIMESTAMP 10000;");
0:         alterTable("ALTER TABLE %s ADD reg3 int;");
0: 
0:         for (int i = 0; i < 10; i++)
0:             execute("INSERT INTO %s (pk1, pk2, ck1, ck2, reg1, reg2) VALUES (?, ?, ?, ?, ?, ?)", i, i + 1, i + 2, i + 3, null, i + 5);
0: 
0:         ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(tableName);
0:         cfs.snapshot(SNAPSHOT);
0: 
0:         String schema = Files.toString(cfs.getDirectories().getSnapshotSchemaFile(SNAPSHOT), Charset.defaultCharset());
0:         assertTrue(schema.contains(String.format("CREATE TYPE %s.%s(a1 varint, a2 varint, a3 varint);", keyspace(), typeA)));
0:         assertTrue(schema.contains(String.format("CREATE TYPE %s.%s(a1 varint, a2 varint, a3 varint);", keyspace(), typeA)));
0:         assertTrue(schema.contains(String.format("CREATE TYPE %s.%s(b1 frozen<%s>, b2 frozen<%s>, b3 frozen<%s>);", keyspace(), typeB, typeA, typeA, typeA)));
0:         assertTrue(schema.contains(String.format("CREATE TYPE %s.%s(c1 frozen<%s>, c2 frozen<%s>, c3 frozen<%s>);", keyspace(), typeC, typeB, typeB, typeB)));
0: 
0:         schema = schema.substring(schema.indexOf("CREATE TABLE")); // trim to ensure order
0: 
0:         assertTrue(schema.startsWith("CREATE TABLE IF NOT EXISTS " + keyspace() + "." + tableName + " (\n" +
0:                                      "\tpk1 varint,\n" +
0:                                      "\tpk2 ascii,\n" +
0:                                      "\tck1 varint,\n" +
0:                                      "\tck2 varint,\n" +
0:                                      "\treg2 int,\n" +
0:                                      "\treg3 int,\n" +
1:                                      "\treg1 " + typeC + ",\n" +
0:                                      "\tPRIMARY KEY ((pk1, pk2), ck1, ck2))\n" +
0:                                      "\tWITH ID = " + cfs.metadata.cfId + "\n" +
0:                                      "\tAND CLUSTERING ORDER BY (ck1 ASC, ck2 DESC)"));
0: 
0:         schema = schema.substring(schema.indexOf("ALTER"));
0:         assertTrue(schema.startsWith(String.format("ALTER TABLE %s.%s DROP reg3 USING TIMESTAMP 10000;", keyspace(), tableName)));
0:         assertTrue(schema.contains(String.format("ALTER TABLE %s.%s ADD reg3 int;", keyspace(), tableName)));
0: 
0:         JSONObject manifest = (JSONObject) new JSONParser().parse(new FileReader(cfs.getDirectories().getSnapshotManifestFile(SNAPSHOT)));
0:         JSONArray files = (JSONArray) manifest.get("files");
0:         Assert.assertEquals(1, files.size());
0:     }
0: 
0:     @Test
0:     public void testDroppedType() throws Throwable
0:     {
0:         String typeA = createType("CREATE TYPE %s (a1 varint, a2 varint, a3 varint);");
0:         String typeB = createType("CREATE TYPE %s (b1 frozen<" + typeA + ">, b2 frozen<" + typeA + ">, b3 frozen<" + typeA + ">);");
0: 
0:         String tableName = createTable("CREATE TABLE IF NOT EXISTS %s (" +
0:                                        "pk1 varint," +
0:                                        "ck1 varint," +
1:                                        "reg1 " + typeB + "," +
0:                                        "reg2 varint," +
0:                                        "PRIMARY KEY (pk1, ck1));");
0: 
0:         alterTable("ALTER TABLE %s DROP reg1 USING TIMESTAMP 10000;");
0: 
0:         Runnable validate = () -> {
0:             try
0:             {
0:                 ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(tableName);
0:                 cfs.snapshot(SNAPSHOT);
0:                 String schema = Files.toString(cfs.getDirectories().getSnapshotSchemaFile(SNAPSHOT), Charset.defaultCharset());
0: 
0:                 // When both column and it's type are dropped, the type in column definition gets substituted with a tuple
0:                 assertTrue(schema.startsWith("CREATE TABLE IF NOT EXISTS " + keyspace() + "." + tableName + " (\n" +
0:                                              "\tpk1 varint,\n" +
0:                                              "\tck1 varint,\n" +
0:                                              "\treg2 varint,\n" +
0:                                              "\treg1 frozen<tuple<frozen<tuple<varint, varint, varint>>, frozen<tuple<varint, varint, varint>>, frozen<tuple<varint, varint, varint>>>>,\n" +
0:                                              "\tPRIMARY KEY (pk1, ck1))"));
0:                 assertTrue(schema.contains("ALTER TABLE " + keyspace() + "." + tableName + " DROP reg1 USING TIMESTAMP 10000;"));
0:             }
0:             catch (Exception e)
0:             {
0:                 throw new RuntimeException(e);
0:             }
0:         };
0: 
0:         // Validate before and after the type drop
0:         validate.run();
0:         schemaChange("DROP TYPE " + keyspace() + "." + typeB);
0:         schemaChange("DROP TYPE " + keyspace() + "." + typeA);
0:         validate.run();
0:     }
0: 
0:     @Test
0:     public void testDenseTable() throws Throwable
0:     {
0:         String tableName = createTable("CREATE TABLE IF NOT EXISTS %s (" +
0:                                        "pk1 varint PRIMARY KEY," +
0:                                        "reg1 int)" +
0:                                        " WITH COMPACT STORAGE");
0: 
0:         ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(tableName);
0: 
0:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
0:         "CREATE TABLE IF NOT EXISTS " + keyspace() + "." + tableName + " (\n" +
0:         "\tpk1 varint PRIMARY KEY,\n" +
0:         "\treg1 int)\n" +
0:         "\tWITH ID = " + cfs.metadata.cfId + "\n" +
0:         "\tAND COMPACT STORAGE"));
0:     }
0: 
0:     @Test
0:     public void testStaticCompactTable() throws Throwable
0:     {
0:         String tableName = createTable("CREATE TABLE IF NOT EXISTS %s (" +
0:                                        "pk1 varint PRIMARY KEY," +
0:                                        "reg1 int," +
0:                                        "reg2 int)" +
0:                                        " WITH COMPACT STORAGE");
0: 
0:         ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(tableName);
0: 
0:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
0:         "CREATE TABLE IF NOT EXISTS " + keyspace() + "." + tableName + " (\n" +
0:         "\tpk1 varint PRIMARY KEY,\n" +
0:         "\treg1 int,\n" +
0:         "\treg2 int)\n" +
0:         "\tWITH ID = " + cfs.metadata.cfId + "\n" +
0:         "\tAND COMPACT STORAGE"));
0:     }
0: 
0:     @Test
0:     public void testStaticCompactWithCounters() throws Throwable
0:     {
0:         String tableName = createTable("CREATE TABLE IF NOT EXISTS %s (" +
0:                                        "pk1 varint PRIMARY KEY," +
0:                                        "reg1 counter," +
0:                                        "reg2 counter)" +
0:                                        " WITH COMPACT STORAGE");
0: 
0: 
0:         ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(tableName);
0: 
0:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
0:         "CREATE TABLE IF NOT EXISTS " + keyspace() + "." + tableName + " (\n" +
0:         "\tpk1 varint PRIMARY KEY,\n" +
0:         "\treg1 counter,\n" +
0:         "\treg2 counter)\n" +
0:         "\tWITH ID = " + cfs.metadata.cfId + "\n" +
0:         "\tAND COMPACT STORAGE"));
0:     }
0: 
0:     @Test
0:     public void testDenseCompactTableWithoutRegulars() throws Throwable
0:     {
0:         String tableName = createTable("CREATE TABLE IF NOT EXISTS %s (" +
0:                                        "pk1 varint," +
0:                                        "ck1 int," +
0:                                        "PRIMARY KEY (pk1, ck1))" +
0:                                        " WITH COMPACT STORAGE");
0: 
0:         ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(tableName);
0: 
0:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
0:         "CREATE TABLE IF NOT EXISTS " + keyspace() + "." + tableName + " (\n" +
0:         "\tpk1 varint,\n" +
0:         "\tck1 int,\n" +
0:         "\tPRIMARY KEY (pk1, ck1))\n" +
0:         "\tWITH ID = " + cfs.metadata.cfId + "\n" +
0:         "\tAND COMPACT STORAGE"));
0:     }
0: 
0:     @Test
0:     public void testCompactDynamic() throws Throwable
0:     {
0:         String tableName = createTable("CREATE TABLE IF NOT EXISTS %s (" +
0:                                        "pk1 varint," +
0:                                        "ck1 int," +
0:                                        "reg int," +
0:                                        "PRIMARY KEY (pk1, ck1))" +
0:                                        " WITH COMPACT STORAGE");
0: 
0:         ColumnFamilyStore cfs = Keyspace.open(keyspace()).getColumnFamilyStore(tableName);
0: 
0:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
0:         "CREATE TABLE IF NOT EXISTS " + keyspace() + "." + tableName + " (\n" +
0:         "\tpk1 varint,\n" +
0:         "\tck1 int,\n" +
0:         "\treg int,\n" +
0:         "\tPRIMARY KEY (pk1, ck1))\n" +
0:         "\tWITH ID = " + cfs.metadata.cfId + "\n" +
0:         "\tAND COMPACT STORAGE"));
0:     }
0: 
0:     @Test
0:     public void testDynamicComposite() throws Throwable
0:     {
0:         Map<Byte, AbstractType<?>> aliases = new HashMap<>();
0:         aliases.put((byte)'a', BytesType.instance);
0:         aliases.put((byte)'b', BytesType.instance);
0:         aliases.put((byte)'c', BytesType.instance);
0: 
0:         String DYNAMIC_COMPOSITE = "dynamic_composite";
0:         AbstractType<?> dynamicComposite = DynamicCompositeType.getInstance(aliases);
0: 
0:         SchemaLoader.createKeyspace(DYNAMIC_COMPOSITE,
0:                                     KeyspaceParams.simple(1),
0:                                     SchemaLoader.denseCFMD(DYNAMIC_COMPOSITE, DYNAMIC_COMPOSITE, dynamicComposite));
0: 
0:         ColumnFamilyStore cfs = Keyspace.open(DYNAMIC_COMPOSITE).getColumnFamilyStore(DYNAMIC_COMPOSITE);
0: 
0:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
0:         "CREATE TABLE IF NOT EXISTS " + DYNAMIC_COMPOSITE + "." + DYNAMIC_COMPOSITE + " (\n" +
0:         "\tkey ascii,\n" +
0:         "\tcols 'org.apache.cassandra.db.marshal.DynamicCompositeType(a=>org.apache.cassandra.db.marshal.BytesType,b=>org.apache.cassandra.db.marshal.BytesType,c=>org.apache.cassandra.db.marshal.BytesType)',\n" +
0:         "\tval ascii,\n" +
0:         "\tPRIMARY KEY (key, cols))\n" +
0:         "\tWITH ID = " + cfs.metadata.cfId + "\n" +
0:         "\tAND COMPACT STORAGE"));
0:     }
0: 
0:     @Test
0:     public void superColumnFamilyTest() throws Throwable
0:     {
0:         final String KEYSPACE = "thrift_compact_table_with_supercolumns_test";
0:         final String TABLE = "test_table_1";
0: 
0:         CFMetaData cfm = CFMetaData.Builder.createSuper(KEYSPACE, TABLE, false)
0:                                            .addPartitionKey("pk", BytesType.instance)
0:                                            .addClusteringColumn("c1", AsciiType.instance)
0:                                            .addClusteringColumn("c2", AsciiType.instance)
0:                                            .addRegularColumn("", MapType.getInstance(Int32Type.instance, AsciiType.instance, true))
0:                                            .build();
0: 
0:         SchemaLoader.createKeyspace(KEYSPACE,
0:                                     KeyspaceParams.simple(1),
0:                                     cfm);
0: 
0:         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(TABLE);
0: 
0:         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
0:         "/*\n" +
0:         "Warning: Table " + KEYSPACE + "." + TABLE + " omitted because it has constructs not compatible with CQL (was created via legacy API).\n\n" +
0:         "Approximate structure, for reference:\n" +
0:         "(this should not be used to reproduce this schema)\n\n" +
0:         "CREATE TABLE IF NOT EXISTS " + KEYSPACE + "." + TABLE + " (\n" +
0:         "\tpk blob,\n" +
0:         "\tc1 ascii,\n" +
0:         "\tc2 ascii,\n" +
0:         "\t\"\" map<int, ascii>,\n" +
0:         "\tPRIMARY KEY (pk, c1, c2))\n" +
0:         "\tWITH ID = " + cfs.metadata.cfId + "\n" +
0:         "\tAND COMPACT STORAGE"));
0:     }
0: }
author:Carl Yeksigian
-------------------------------------------------------------------------------
commit:206a7bb
commit:153583b
/////////////////////////////////////////////////////////////////////////
0:         "\t\"key\" ascii,\n" +
0:         "\tPRIMARY KEY (\"key\", cols))\n" +
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:e22170e
============================================================================