1:bf51f24: /*
1:bf51f24:  * Licensed to the Apache Software Foundation (ASF) under one
1:bf51f24:  * or more contributor license agreements.  See the NOTICE file
1:bf51f24:  * distributed with this work for additional information
1:bf51f24:  * regarding copyright ownership.  The ASF licenses this file
1:bf51f24:  * to you under the Apache License, Version 2.0 (the
1:bf51f24:  * "License"); you may not use this file except in compliance
1:bf51f24:  * with the License.  You may obtain a copy of the License at
1:bf51f24:  *
1:bf51f24:  *     http://www.apache.org/licenses/LICENSE-2.0
1:bf51f24:  *
1:bf51f24:  * Unless required by applicable law or agreed to in writing, software
1:bf51f24:  * distributed under the License is distributed on an "AS IS" BASIS,
1:bf51f24:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:bf51f24:  * See the License for the specific language governing permissions and
1:bf51f24:  * limitations under the License.
2:bf51f24:  */
1:bf51f24: package org.apache.cassandra.tools.nodetool;
32:bf51f24: 
1:07ddb8a: import java.util.*;
1:bf51f24: import io.airlift.command.Arguments;
1:bf51f24: import io.airlift.command.Command;
1:bf51f24: import io.airlift.command.Option;
1:bf51f24: 
1:bf51f24: import org.apache.cassandra.tools.NodeProbe;
1:bf51f24: import org.apache.cassandra.tools.NodeTool.NodeToolCmd;
1:27d25c6: import org.apache.cassandra.tools.nodetool.stats.*;
1:bf51f24: 
1:bf51f24: @Command(name = "tablestats", description = "Print statistics on tables")
1:bf51f24: public class TableStats extends NodeToolCmd
22:bf51f24: {
1:bf51f24:     @Arguments(usage = "[<keyspace.table>...]", description = "List of tables (or keyspace) names")
1:bf51f24:     private List<String> tableNames = new ArrayList<>();
1:bf51f24: 
1:bf51f24:     @Option(name = "-i", description = "Ignore the list of tables and display the remaining tables")
1:bf51f24:     private boolean ignore = false;
1:bf51f24: 
1:bf51f24:     @Option(title = "human_readable",
1:bf51f24:             name = {"-H", "--human-readable"},
1:db68ac9:             description = "Display bytes in human readable form, i.e. KiB, MiB, GiB, TiB")
1:bf51f24:     private boolean humanReadable = false;
1:bf51f24: 
1:5805a76:     @Option(title = "format",
1:5805a76:             name = {"-F", "--format"},
1:5805a76:             description = "Output format (json, yaml)")
1:5805a76:     private String outputFormat = "";
1:bf51f24: 
1:bf51f24:     @Override
1:bf51f24:     public void execute(NodeProbe probe)
1:bf51f24:     {
1:5805a76:         if (!outputFormat.isEmpty() && !"json".equals(outputFormat) && !"yaml".equals(outputFormat))
1:bf51f24:         {
1:5805a76:             throw new IllegalArgumentException("arguments for -F are json,yaml only.");
21:bf51f24:         }
1:bf51f24: 
1:27d25c6:         StatsHolder holder = new TableStatsHolder(probe, humanReadable, ignore, tableNames);
1:5805a76:         // print out the keyspace and table statistics
1:27d25c6:         StatsPrinter printer = TableStatsPrinter.from(outputFormat);
1:5805a76:         printer.print(holder, System.out);
1:bf51f24:     }
1:bf51f24: 
1:bf51f24: }
============================================================================
author:Dave Brosius
-------------------------------------------------------------------------------
commit:087264f
/////////////////////////////////////////////////////////////////////////
commit:bf51f24
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.tools.nodetool;
1: 
1: import io.airlift.command.Arguments;
1: import io.airlift.command.Command;
1: import io.airlift.command.Option;
1: 
0: import java.util.ArrayList;
0: import java.util.HashMap;
0: import java.util.Iterator;
0: import java.util.List;
0: import java.util.Map;
1: 
0: import javax.management.InstanceNotFoundException;
1: 
0: import org.apache.cassandra.db.ColumnFamilyStoreMBean;
0: import org.apache.cassandra.io.util.FileUtils;
0: import org.apache.cassandra.metrics.CassandraMetricsRegistry;
1: import org.apache.cassandra.tools.NodeProbe;
1: import org.apache.cassandra.tools.NodeTool.NodeToolCmd;
1: 
1: @Command(name = "tablestats", description = "Print statistics on tables")
1: public class TableStats extends NodeToolCmd
1: {
1:     @Arguments(usage = "[<keyspace.table>...]", description = "List of tables (or keyspace) names")
1:     private List<String> tableNames = new ArrayList<>();
1: 
1:     @Option(name = "-i", description = "Ignore the list of tables and display the remaining tables")
1:     private boolean ignore = false;
1: 
1:     @Option(title = "human_readable",
1:             name = {"-H", "--human-readable"},
0:             description = "Display bytes in human readable form, i.e. KB, MB, GB, TB")
1:     private boolean humanReadable = false;
1: 
1:     @Override
1:     public void execute(NodeProbe probe)
1:     {
0:         TableStats.OptionFilter filter = new OptionFilter(ignore, tableNames);
0:         Map<String, List<ColumnFamilyStoreMBean>> tableStoreMap = new HashMap<>();
1: 
0:         // get a list of column family stores
0:         Iterator<Map.Entry<String, ColumnFamilyStoreMBean>> tables = probe.getColumnFamilyStoreMBeanProxies();
1: 
0:         while (tables.hasNext())
1:         {
0:             Map.Entry<String, ColumnFamilyStoreMBean> entry = tables.next();
0:             String keyspaceName = entry.getKey();
0:             ColumnFamilyStoreMBean tableProxy = entry.getValue();
1: 
0:             if (!tableStoreMap.containsKey(keyspaceName) && filter.isColumnFamilyIncluded(entry.getKey(), tableProxy.getColumnFamilyName()))
1:             {
0:                 List<ColumnFamilyStoreMBean> columnFamilies = new ArrayList<>();
0:                 columnFamilies.add(tableProxy);
0:                 tableStoreMap.put(keyspaceName, columnFamilies);
0:             } else if (filter.isColumnFamilyIncluded(entry.getKey(), tableProxy.getColumnFamilyName()))
1:             {
0:                 tableStoreMap.get(keyspaceName).add(tableProxy);
1:             }
1:         }
1: 
0:         // make sure all specified keyspace and tables exist
0:         filter.verifyKeyspaces(probe.getKeyspaces());
0:         filter.verifyColumnFamilies();
1: 
0:         // print out the table statistics
0:         for (Map.Entry<String, List<ColumnFamilyStoreMBean>> entry : tableStoreMap.entrySet())
1:         {
0:             String keyspaceName = entry.getKey();
0:             List<ColumnFamilyStoreMBean> columnFamilies = entry.getValue();
0:             long keyspaceReadCount = 0;
0:             long keyspaceWriteCount = 0;
0:             int keyspacePendingFlushes = 0;
0:             double keyspaceTotalReadTime = 0.0f;
0:             double keyspaceTotalWriteTime = 0.0f;
1: 
0:             System.out.println("Keyspace: " + keyspaceName);
0:             for (ColumnFamilyStoreMBean table : columnFamilies)
1:             {
0:                 String tableName = table.getColumnFamilyName();
0:                 long writeCount = ((CassandraMetricsRegistry.JmxTimerMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, "WriteLatency")).getCount();
0:                 long readCount = ((CassandraMetricsRegistry.JmxTimerMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, "ReadLatency")).getCount();
1: 
0:                 if (readCount > 0)
1:                 {
0:                     keyspaceReadCount += readCount;
0:                     keyspaceTotalReadTime += (long) probe.getColumnFamilyMetric(keyspaceName, tableName, "ReadTotalLatency");
1:                 }
0:                 if (writeCount > 0)
1:                 {
0:                     keyspaceWriteCount += writeCount;
0:                     keyspaceTotalWriteTime += (long) probe.getColumnFamilyMetric(keyspaceName, tableName, "WriteTotalLatency");
1:                 }
0:                 keyspacePendingFlushes += (long) probe.getColumnFamilyMetric(keyspaceName, tableName, "PendingFlushes");
1:             }
1: 
0:             double keyspaceReadLatency = keyspaceReadCount > 0
0:                                          ? keyspaceTotalReadTime / keyspaceReadCount / 1000
0:                                          : Double.NaN;
0:             double keyspaceWriteLatency = keyspaceWriteCount > 0
0:                                           ? keyspaceTotalWriteTime / keyspaceWriteCount / 1000
0:                                           : Double.NaN;
1: 
0:             System.out.println("\tRead Count: " + keyspaceReadCount);
0:             System.out.println("\tRead Latency: " + String.format("%s", keyspaceReadLatency) + " ms.");
0:             System.out.println("\tWrite Count: " + keyspaceWriteCount);
0:             System.out.println("\tWrite Latency: " + String.format("%s", keyspaceWriteLatency) + " ms.");
0:             System.out.println("\tPending Flushes: " + keyspacePendingFlushes);
1: 
0:             // print out column family statistics for this keyspace
0:             for (ColumnFamilyStoreMBean table : columnFamilies)
1:             {
0:                 String tableName = table.getColumnFamilyName();
0:                 if (tableName.contains("."))
0:                     System.out.println("\t\tTable (index): " + tableName);
0:                 else
0:                     System.out.println("\t\tTable: " + tableName);
1: 
0:                 System.out.println("\t\tSSTable count: " + probe.getColumnFamilyMetric(keyspaceName, tableName, "LiveSSTableCount"));
1: 
0:                 int[] leveledSStables = table.getSSTableCountPerLevel();
0:                 if (leveledSStables != null)
1:                 {
0:                     System.out.print("\t\tSSTables in each level: [");
0:                     for (int level = 0; level < leveledSStables.length; level++)
1:                     {
0:                         int count = leveledSStables[level];
0:                         System.out.print(count);
0:                         long maxCount = 4L; // for L0
0:                         if (level > 0)
0:                             maxCount = (long) Math.pow(10, level);
0:                         //  show max threshold for level when exceeded
0:                         if (count > maxCount)
0:                             System.out.print("/" + maxCount);
1: 
0:                         if (level < leveledSStables.length - 1)
0:                             System.out.print(", ");
0:                         else
0:                             System.out.println("]");
1:                     }
1:                 }
1: 
0:                 Long memtableOffHeapSize = null;
0:                 Long bloomFilterOffHeapSize = null;
0:                 Long indexSummaryOffHeapSize = null;
0:                 Long compressionMetadataOffHeapSize = null;
1: 
0:                 Long offHeapSize = null;
1: 
0:                 try
1:                 {
0:                     memtableOffHeapSize = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "MemtableOffHeapSize");
0:                     bloomFilterOffHeapSize = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "BloomFilterOffHeapMemoryUsed");
0:                     indexSummaryOffHeapSize = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "IndexSummaryOffHeapMemoryUsed");
0:                     compressionMetadataOffHeapSize = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "CompressionMetadataOffHeapMemoryUsed");
1: 
0:                     offHeapSize = memtableOffHeapSize + bloomFilterOffHeapSize + indexSummaryOffHeapSize + compressionMetadataOffHeapSize;
1:                 }
0:                 catch (RuntimeException e)
1:                 {
0:                     // offheap-metrics introduced in 2.1.3 - older versions do not have the appropriate mbeans
0:                     if (!(e.getCause() instanceof InstanceNotFoundException))
0:                         throw e;
1:                 }
1: 
0:                 System.out.println("\t\tSpace used (live): " + format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "LiveDiskSpaceUsed"), humanReadable));
0:                 System.out.println("\t\tSpace used (total): " + format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "TotalDiskSpaceUsed"), humanReadable));
0:                 System.out.println("\t\tSpace used by snapshots (total): " + format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "SnapshotsSize"), humanReadable));
0:                 if (offHeapSize != null)
0:                     System.out.println("\t\tOff heap memory used (total): " + format(offHeapSize, humanReadable));
0:                 System.out.println("\t\tSSTable Compression Ratio: " + probe.getColumnFamilyMetric(keyspaceName, tableName, "CompressionRatio"));
0:                 long numberOfKeys = 0;
0:                 for (long keys : (long[]) probe.getColumnFamilyMetric(keyspaceName, tableName, "EstimatedColumnCountHistogram"))
0:                     numberOfKeys += keys;
0:                 System.out.println("\t\tNumber of keys (estimate): " + numberOfKeys);
0:                 System.out.println("\t\tMemtable cell count: " + probe.getColumnFamilyMetric(keyspaceName, tableName, "MemtableColumnsCount"));
0:                 System.out.println("\t\tMemtable data size: " + format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "MemtableLiveDataSize"), humanReadable));
0:                 if (memtableOffHeapSize != null)
0:                     System.out.println("\t\tMemtable off heap memory used: " + format(memtableOffHeapSize, humanReadable));
0:                 System.out.println("\t\tMemtable switch count: " + probe.getColumnFamilyMetric(keyspaceName, tableName, "MemtableSwitchCount"));
0:                 System.out.println("\t\tLocal read count: " + ((CassandraMetricsRegistry.JmxTimerMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, "ReadLatency")).getCount());
0:                 double localReadLatency = ((CassandraMetricsRegistry.JmxTimerMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, "ReadLatency")).getMean() / 1000;
0:                 double localRLatency = localReadLatency > 0 ? localReadLatency : Double.NaN;
0:                 System.out.printf("\t\tLocal read latency: %01.3f ms%n", localRLatency);
0:                 System.out.println("\t\tLocal write count: " + ((CassandraMetricsRegistry.JmxTimerMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, "WriteLatency")).getCount());
0:                 double localWriteLatency = ((CassandraMetricsRegistry.JmxTimerMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, "WriteLatency")).getMean() / 1000;
0:                 double localWLatency = localWriteLatency > 0 ? localWriteLatency : Double.NaN;
0:                 System.out.printf("\t\tLocal write latency: %01.3f ms%n", localWLatency);
0:                 System.out.println("\t\tPending flushes: " + probe.getColumnFamilyMetric(keyspaceName, tableName, "PendingFlushes"));
0:                 System.out.println("\t\tBloom filter false positives: " + probe.getColumnFamilyMetric(keyspaceName, tableName, "BloomFilterFalsePositives"));
0:                 System.out.printf("\t\tBloom filter false ratio: %s%n", String.format("%01.5f", probe.getColumnFamilyMetric(keyspaceName, tableName, "RecentBloomFilterFalseRatio")));
0:                 System.out.println("\t\tBloom filter space used: " + format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "BloomFilterDiskSpaceUsed"), humanReadable));
0:                 if (bloomFilterOffHeapSize != null)
0:                     System.out.println("\t\tBloom filter off heap memory used: " + format(bloomFilterOffHeapSize, humanReadable));
0:                 if (indexSummaryOffHeapSize != null)
0:                     System.out.println("\t\tIndex summary off heap memory used: " + format(indexSummaryOffHeapSize, humanReadable));
0:                 if (compressionMetadataOffHeapSize != null)
0:                     System.out.println("\t\tCompression metadata off heap memory used: " + format(compressionMetadataOffHeapSize, humanReadable));
1: 
0:                 System.out.println("\t\tCompacted partition minimum bytes: " + format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "MinRowSize"), humanReadable));
0:                 System.out.println("\t\tCompacted partition maximum bytes: " + format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "MaxRowSize"), humanReadable));
0:                 System.out.println("\t\tCompacted partition mean bytes: " + format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "MeanRowSize"), humanReadable));
0:                 CassandraMetricsRegistry.JmxHistogramMBean histogram = (CassandraMetricsRegistry.JmxHistogramMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, "LiveScannedHistogram");
0:                 System.out.println("\t\tAverage live cells per slice (last five minutes): " + histogram.getMean());
0:                 System.out.println("\t\tMaximum live cells per slice (last five minutes): " + histogram.getMax());
0:                 histogram = (CassandraMetricsRegistry.JmxHistogramMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, "TombstoneScannedHistogram");
0:                 System.out.println("\t\tAverage tombstones per slice (last five minutes): " + histogram.getMean());
0:                 System.out.println("\t\tMaximum tombstones per slice (last five minutes): " + histogram.getMax());
1: 
0:                 System.out.println("");
1:             }
0:             System.out.println("----------------");
1:         }
1:     }
1: 
0:     private String format(long bytes, boolean humanReadable) {
0:         return humanReadable ? FileUtils.stringifyFileSize(bytes) : Long.toString(bytes);
1:     }
1: 
0:     /**
0:      * Used for filtering keyspaces and tables to be displayed using the tablestats command.
1:      */
0:     private static class OptionFilter
1:     {
0:         private Map<String, List<String>> filter = new HashMap<>();
0:         private Map<String, List<String>> verifier = new HashMap<>();
0:         private List<String> filterList = new ArrayList<>();
0:         private boolean ignoreMode;
1: 
0:         public OptionFilter(boolean ignoreMode, List<String> filterList)
1:         {
0:             this.filterList.addAll(filterList);
0:             this.ignoreMode = ignoreMode;
1: 
0:             for (String s : filterList)
1:             {
0:                 String[] keyValues = s.split("\\.", 2);
1: 
0:                 // build the map that stores the keyspaces and tables to use
0:                 if (!filter.containsKey(keyValues[0]))
1:                 {
0:                     filter.put(keyValues[0], new ArrayList<String>());
0:                     verifier.put(keyValues[0], new ArrayList<String>());
1: 
0:                     if (keyValues.length == 2)
1:                     {
0:                         filter.get(keyValues[0]).add(keyValues[1]);
0:                         verifier.get(keyValues[0]).add(keyValues[1]);
1:                     }
0:                 } else
1:                 {
0:                     if (keyValues.length == 2)
1:                     {
0:                         filter.get(keyValues[0]).add(keyValues[1]);
0:                         verifier.get(keyValues[0]).add(keyValues[1]);
1:                     }
1:                 }
1:             }
1:         }
1: 
0:         public boolean isColumnFamilyIncluded(String keyspace, String columnFamily)
1:         {
0:             // supplying empty params list is treated as wanting to display all keyspaces and tables
0:             if (filterList.isEmpty())
0:                 return !ignoreMode;
1: 
0:             List<String> tables = filter.get(keyspace);
1: 
0:             // no such keyspace is in the map
0:             if (tables == null)
0:                 return ignoreMode;
0:                 // only a keyspace with no tables was supplied
0:                 // so ignore or include (based on the flag) every column family in specified keyspace
0:             else if (tables.size() == 0)
0:                 return !ignoreMode;
1: 
0:             // keyspace exists, and it contains specific table
0:             verifier.get(keyspace).remove(columnFamily);
0:             return ignoreMode ^ tables.contains(columnFamily);
1:         }
1: 
0:         public void verifyKeyspaces(List<String> keyspaces)
1:         {
0:             for (String ks : verifier.keySet())
0:                 if (!keyspaces.contains(ks))
0:                     throw new IllegalArgumentException("Unknown keyspace: " + ks);
1:         }
1: 
0:         public void verifyColumnFamilies()
1:         {
0:             for (String ks : filter.keySet())
0:                 if (verifier.get(ks).size() > 0)
0:                     throw new IllegalArgumentException("Unknown tables: " + verifier.get(ks) + " in keyspace: " + ks);
1:         }
1:     }
1: }
author:Hiroyuki Nishi
-------------------------------------------------------------------------------
commit:27d25c6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.tools.nodetool.stats.*;
/////////////////////////////////////////////////////////////////////////
1:         StatsHolder holder = new TableStatsHolder(probe, humanReadable, ignore, tableNames);
1:         StatsPrinter printer = TableStatsPrinter.from(outputFormat);
author:Geoffrey Yu
-------------------------------------------------------------------------------
commit:54cbdd7
/////////////////////////////////////////////////////////////////////////
0:         StatsHolder holder = new StatsHolder(probe.getNumberOfTables());
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:f55d2d4
commit:f000ff0
commit:4aaf2b3
author:Mahdi Mohammadi
-------------------------------------------------------------------------------
commit:39b86e3
/////////////////////////////////////////////////////////////////////////
0: 
0:                 Object estimatedRowCount = probe.getColumnFamilyMetric(keyspaceName, tableName, "EstimatedRowCount");
0:                 if (Long.valueOf(-1L).equals(estimatedRowCount))
0:                 {
0:                     estimatedRowCount = 0L;
0:                 }
0: 
0:                 System.out.println("\t\tNumber of keys (estimate): " + estimatedRowCount);
0: 
author:Chris Lohfink
-------------------------------------------------------------------------------
commit:9b47dd5
/////////////////////////////////////////////////////////////////////////
0:                 Double percentRepaired = null;
/////////////////////////////////////////////////////////////////////////
0:                     percentRepaired = (Double) probe.getColumnFamilyMetric(keyspaceName, tableName, "PercentRepaired");
/////////////////////////////////////////////////////////////////////////
0:                 if (percentRepaired != null)
0:                 {
0:                     statsTable.percentRepaired = Math.round(100 * percentRepaired) / 100.0;
0:                 }
author:Shogo Hoshii
-------------------------------------------------------------------------------
commit:5805a76
/////////////////////////////////////////////////////////////////////////
0: import io.airlift.command.Arguments;
0: import io.airlift.command.Command;
0: import io.airlift.command.Option;
0: import org.apache.cassandra.tools.nodetool.stats.StatsHolder;
0: import org.apache.cassandra.tools.nodetool.stats.StatsKeyspace;
0: import org.apache.cassandra.tools.nodetool.stats.StatsTable;
0: import org.apache.cassandra.tools.nodetool.stats.TableStatsPrinter;
/////////////////////////////////////////////////////////////////////////
1:     @Option(title = "format",
1:             name = {"-F", "--format"},
1:             description = "Output format (json, yaml)")
1:     private String outputFormat = "";
0: 
1:         if (!outputFormat.isEmpty() && !"json".equals(outputFormat) && !"yaml".equals(outputFormat))
0:         {
1:             throw new IllegalArgumentException("arguments for -F are json,yaml only.");
0:         }
0: 
0:         Map<String, StatsKeyspace> keyspaceStats = new HashMap<>();
0:         // get a list of table stores
/////////////////////////////////////////////////////////////////////////
0:                 StatsKeyspace stats = keyspaceStats.get(keyspaceName);
0:                     stats = new StatsKeyspace(probe, keyspaceName);
/////////////////////////////////////////////////////////////////////////
0:         // get metrics of keyspace
0:         StatsHolder holder = new StatsHolder();
0:             StatsKeyspace statsKeyspace = keyspaceStats.get(keyspaceName);
0:             // get metrics of table statistics for this keyspace
0:                 StatsTable statsTable = new StatsTable();
0:                 statsTable.name = tableName;
0:                 statsTable.isIndex = tableName.contains(".");
0:                 statsTable.sstableCount = probe.getColumnFamilyMetric(keyspaceName, tableName, "LiveSSTableCount");
0:                     statsTable.isLeveledSstable = true;
0: 
0:                         // show max threshold for level when exceeded
0:                         statsTable.sstablesInEachLevel.add(count + ((count > maxCount) ? "/" + maxCount : ""));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 statsTable.spaceUsedLive = format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "LiveDiskSpaceUsed"), humanReadable);
0:                 statsTable.spaceUsedTotal = format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "TotalDiskSpaceUsed"), humanReadable);
0:                 statsTable.spaceUsedBySnapshotsTotal = format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "SnapshotsSize"), humanReadable);
0:                 {
0:                     statsTable.offHeapUsed = true;
0:                     statsTable.offHeapMemoryUsedTotal = format(offHeapSize, humanReadable);
0: 
0:                 }
0:                 statsTable.sstableCompressionRatio = probe.getColumnFamilyMetric(keyspaceName, tableName, "CompressionRatio");
0:                 statsTable.numberOfKeysEstimate = probe.getColumnFamilyMetric(keyspaceName, tableName, "EstimatedPartitionCount");
0:                 statsTable.memtableCellCount = probe.getColumnFamilyMetric(keyspaceName, tableName, "MemtableColumnsCount");
0:                 statsTable.memtableDataSize = format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "MemtableLiveDataSize"), humanReadable);
0:                 {
0:                     statsTable.memtableOffHeapUsed = true;
0:                     statsTable.memtableOffHeapMemoryUsed = format(memtableOffHeapSize, humanReadable);
0:                 }
0:                 statsTable.memtableSwitchCount = probe.getColumnFamilyMetric(keyspaceName, tableName, "MemtableSwitchCount");
0:                 statsTable.localReadCount = ((CassandraMetricsRegistry.JmxTimerMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, "ReadLatency")).getCount();
0: 
0:                 statsTable.localReadLatencyMs = localRLatency;
0:                 statsTable.localWriteCount = ((CassandraMetricsRegistry.JmxTimerMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, "WriteLatency")).getCount();
0: 
0:                 statsTable.localWriteLatencyMs = localWLatency;
0:                 statsTable.pendingFlushes = probe.getColumnFamilyMetric(keyspaceName, tableName, "PendingFlushes");
0: 
0:                 statsTable.bloomFilterFalsePositives = probe.getColumnFamilyMetric(keyspaceName, tableName, "BloomFilterFalsePositives");
0:                 statsTable.bloomFilterFalseRatio = probe.getColumnFamilyMetric(keyspaceName, tableName, "RecentBloomFilterFalseRatio");
0:                 statsTable.bloomFilterSpaceUsed = format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "BloomFilterDiskSpaceUsed"), humanReadable);
0: 
0:                 {
0:                     statsTable.bloomFilterOffHeapUsed = true;
0:                     statsTable.bloomFilterOffHeapMemoryUsed = format(bloomFilterOffHeapSize, humanReadable);
0:                 }
0: 
0:                 {
0:                     statsTable.indexSummaryOffHeapUsed = true;
0:                     statsTable.indexSummaryOffHeapMemoryUsed = format(indexSummaryOffHeapSize, humanReadable);
0:                 }
0:                 {
0:                     statsTable.compressionMetadataOffHeapUsed = true;
0:                     statsTable.compressionMetadataOffHeapMemoryUsed = format(compressionMetadataOffHeapSize, humanReadable);
0:                 }
0:                 statsTable.compactedPartitionMinimumBytes = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "MinPartitionSize");
0:                 statsTable.compactedPartitionMaximumBytes = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "MaxPartitionSize");
0:                 statsTable.compactedPartitionMeanBytes = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "MeanPartitionSize");
0:                 statsTable.averageLiveCellsPerSliceLastFiveMinutes = histogram.getMean();
0:                 statsTable.maximumLiveCellsPerSliceLastFiveMinutes = histogram.getMax();
0:                 histogram = (CassandraMetricsRegistry.JmxHistogramMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, "TombstoneScannedHistogram");
0:                 statsTable.averageTombstonesPerSliceLastFiveMinutes = histogram.getMean();
0:                 statsTable.maximumTombstonesPerSliceLastFiveMinutes = histogram.getMax();
0:                 statsTable.droppedMutations = format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "DroppedMutations"), humanReadable);
0:                 statsKeyspace.tables.add(statsTable);
0:             holder.keyspaces.add(statsKeyspace);
1:         // print out the keyspace and table statistics
0:         TableStatsPrinter printer = TableStatsPrinter.from(outputFormat);
1:         printer.print(holder, System.out);
/////////////////////////////////////////////////////////////////////////
0:         private final Map<String, List<String>> filter = new HashMap<>();
0:         private final Map<String, List<String>> verifier = new HashMap<>(); // Same as filter initially, but we remove tables every time we've checked them for inclusion
0:                                                                             // in isTableIncluded() so that we detect if those table requested don't exist (verifyTables())
0:         private final List<String> filterList = new ArrayList<>();
0:         private final boolean ignoreMode;
0:         OptionFilter(boolean ignoreMode, List<String> filterList)
/////////////////////////////////////////////////////////////////////////
0:                     filter.put(keyValues[0], new ArrayList<>());
0:                     verifier.put(keyValues[0], new ArrayList<>());
/////////////////////////////////////////////////////////////////////////
0:             else if (tables.isEmpty())
/////////////////////////////////////////////////////////////////////////
0:                 if (!verifier.get(ks).isEmpty())
author:Giampaolo Trapasso
-------------------------------------------------------------------------------
commit:db68ac9
/////////////////////////////////////////////////////////////////////////
1:             description = "Display bytes in human readable form, i.e. KiB, MiB, GiB, TiB")
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:07ddb8a
/////////////////////////////////////////////////////////////////////////
1: import java.util.*;
0: import com.google.common.collect.ArrayListMultimap;
0: 
/////////////////////////////////////////////////////////////////////////
0:         ArrayListMultimap<String, ColumnFamilyStoreMBean> selectedTableMbeans = ArrayListMultimap.create();
0:         Map<String, KeyspaceStats> keyspaceStats = new HashMap<>();
0:         Iterator<Map.Entry<String, ColumnFamilyStoreMBean>> tableMBeans = probe.getColumnFamilyStoreMBeanProxies();
0:         while (tableMBeans.hasNext())
0:             Map.Entry<String, ColumnFamilyStoreMBean> entry = tableMBeans.next();
0:             if (filter.isKeyspaceIncluded(keyspaceName))
0:                 KeyspaceStats stats = keyspaceStats.get(keyspaceName);
0:                 if (stats == null)
0:                 {
0:                     stats = new KeyspaceStats(probe, keyspaceName);
0:                     keyspaceStats.put(keyspaceName, stats);
0:                 }
0:                 stats.add(tableProxy);
0: 
0:                 if (filter.isTableIncluded(keyspaceName, tableProxy.getTableName()))
0:                     selectedTableMbeans.put(keyspaceName, tableProxy);
0:         filter.verifyTables();
0:         for (Map.Entry<String, Collection<ColumnFamilyStoreMBean>> entry : selectedTableMbeans.asMap().entrySet())
0:             Collection<ColumnFamilyStoreMBean> tables = entry.getValue();
0:             KeyspaceStats stats = keyspaceStats.get(keyspaceName);
0:             System.out.println("\tRead Count: " + stats.readCount);
0:             System.out.println("\tRead Latency: " + String.format("%s", stats.readLatency()) + " ms.");
0:             System.out.println("\tWrite Count: " + stats.writeCount);
0:             System.out.println("\tWrite Latency: " + String.format("%s", stats.writeLatency()) + " ms.");
0:             System.out.println("\tPending Flushes: " + stats.pendingFlushes);
0:             for (ColumnFamilyStoreMBean table : tables)
0:                 String tableName = table.getTableName();
/////////////////////////////////////////////////////////////////////////
0:     private String format(long bytes, boolean humanReadable)
0:     {
/////////////////////////////////////////////////////////////////////////
0:         private Map<String, List<String>> verifier = new HashMap<>(); // Same as filter initially, but we remove tables every time we've checked them for inclusion
0:                                                                       // in isTableIncluded() so that we detect if those table requested don't exist (verifyTables())
/////////////////////////////////////////////////////////////////////////
0:                 }
0:                 if (keyValues.length == 2)
0:                     filter.get(keyValues[0]).add(keyValues[1]);
0:                     verifier.get(keyValues[0]).add(keyValues[1]);
0:         public boolean isTableIncluded(String keyspace, String table)
/////////////////////////////////////////////////////////////////////////
0:             verifier.get(keyspace).remove(table);
0:             return ignoreMode ^ tables.contains(table);
0:         }
0: 
0:         public boolean isKeyspaceIncluded(String keyspace)
0:         {
0:             // supplying empty params list is treated as wanting to display all keyspaces and tables
0:             if (filterList.isEmpty())
0:                 return !ignoreMode;
0: 
0:             // Note that if there is any table for the keyspace, we want to include the keyspace irregarding
0:             // of the ignoreMode, since the ignoreMode then apply to the table inside the keyspace but the
0:             // keyspace itself is not ignored
0:             return filter.get(keyspace) != null || ignoreMode;
/////////////////////////////////////////////////////////////////////////
0:         public void verifyTables()
0: 
0:     private static class KeyspaceStats
0:     {
0:         private final NodeProbe probe;
0:         private final String keyspaceName;
0: 
0:         public long readCount;
0:         public long writeCount;
0:         public int pendingFlushes;
0:         private double totalReadTime;
0:         private double totalWriteTime;
0: 
0:         public KeyspaceStats(NodeProbe probe, String keyspaceName)
0:         {
0:             this.probe = probe;
0:             this.keyspaceName = keyspaceName;
0:         }
0: 
0:         public void add(ColumnFamilyStoreMBean table)
0:         {
0:             String tableName = table.getTableName();
0:             long tableWriteCount = ((CassandraMetricsRegistry.JmxTimerMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, "WriteLatency")).getCount();
0:             long tableReadCount = ((CassandraMetricsRegistry.JmxTimerMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, "ReadLatency")).getCount();
0: 
0:             if (tableReadCount > 0)
0:             {
0:                 readCount += tableReadCount;
0:                 totalReadTime += (long) probe.getColumnFamilyMetric(keyspaceName, tableName, "ReadTotalLatency");
0:             }
0:             if (tableWriteCount > 0)
0:             {
0:                 writeCount += tableWriteCount;
0:                 totalWriteTime += (long) probe.getColumnFamilyMetric(keyspaceName, tableName, "WriteTotalLatency");
0:             }
0:             pendingFlushes += (long) probe.getColumnFamilyMetric(keyspaceName, tableName, "PendingFlushes");
0:         }
0: 
0:         public double readLatency()
0:         {
0:             return readCount > 0
0:                  ? totalReadTime / readCount / 1000
0:                  : Double.NaN;
0:         }
0: 
0:         public double writeLatency()
0:         {
0:             return writeCount > 0
0:                  ? totalWriteTime / writeCount / 1000
0:                  : Double.NaN;
0:         }
0:     }
author:anubhavkale
-------------------------------------------------------------------------------
commit:66d3428
/////////////////////////////////////////////////////////////////////////
0:                 System.out.println("\t\tDropped Mutations: " + format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "DroppedMutations"), humanReadable));
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:0bd5170
/////////////////////////////////////////////////////////////////////////
0:                 System.out.println("\t\tNumber of keys (estimate): " + probe.getColumnFamilyMetric(keyspaceName, tableName, "EstimatedPartitionCount"));
/////////////////////////////////////////////////////////////////////////
0:                 System.out.println("\t\tCompacted partition minimum bytes: " + format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "MinPartitionSize"), humanReadable));
0:                 System.out.println("\t\tCompacted partition maximum bytes: " + format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "MaxPartitionSize"), humanReadable));
0:                 System.out.println("\t\tCompacted partition mean bytes: " + format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "MeanPartitionSize"), humanReadable));
author:Sam Tunnicliffe
-------------------------------------------------------------------------------
commit:868e720
============================================================================