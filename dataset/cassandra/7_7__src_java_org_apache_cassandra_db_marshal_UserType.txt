1:a552b30: /*
1:a552b30:  * Licensed to the Apache Software Foundation (ASF) under one
1:a552b30:  * or more contributor license agreements.  See the NOTICE file
1:a552b30:  * distributed with this work for additional information
1:a552b30:  * regarding copyright ownership.  The ASF licenses this file
1:a552b30:  * to you under the Apache License, Version 2.0 (the
1:a552b30:  * "License"); you may not use this file except in compliance
1:a552b30:  * with the License.  You may obtain a copy of the License at
2:a552b30:  *
1:a552b30:  *     http://www.apache.org/licenses/LICENSE-2.0
1:a552b30:  *
1:a552b30:  * Unless required by applicable law or agreed to in writing, software
1:a552b30:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a552b30:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a552b30:  * See the License for the specific language governing permissions and
1:a552b30:  * limitations under the License.
2:a552b30:  */
1:a552b30: package org.apache.cassandra.db.marshal;
1:a552b30: 
1:a552b30: import java.nio.ByteBuffer;
1:c7b02d1: import java.util.*;
1:d62b2cf: import java.util.stream.Collectors;
1:a552b30: 
1:a552b30: import com.google.common.base.Objects;
1:a552b30: 
1:c7b02d1: import org.apache.cassandra.cql3.*;
1:677230d: import org.apache.cassandra.db.rows.Cell;
1:677230d: import org.apache.cassandra.db.rows.CellPath;
1:a552b30: import org.apache.cassandra.exceptions.ConfigurationException;
1:a552b30: import org.apache.cassandra.exceptions.SyntaxException;
1:6dc595d: import org.apache.cassandra.serializers.MarshalException;
1:e0adc16: import org.apache.cassandra.transport.ProtocolVersion;
1:db9ef0b: import org.apache.cassandra.utils.ByteBufferUtil;
1:a552b30: import org.apache.cassandra.utils.Pair;
1:677230d: import org.slf4j.Logger;
1:677230d: import org.slf4j.LoggerFactory;
1:a552b30: 
1:db9ef0b: /**
1:a552b30:  * A user defined type.
1:0932ed6:  *
1:0932ed6:  * A user type is really just a tuple type on steroids.
1:db9ef0b:  */
1:0932ed6: public class UserType extends TupleType
1:ca7e9d5: {
1:677230d:     private static final Logger logger = LoggerFactory.getLogger(UserType.class);
1:677230d: 
1:d63d07b:     public final String keyspace;
1:a552b30:     public final ByteBuffer name;
1:4ed0060:     private final List<FieldIdentifier> fieldNames;
1:c7b02d1:     private final List<String> stringFieldNames;
1:677230d:     private final boolean isMultiCell;
1:a552b30: 
1:4ed0060:     public UserType(String keyspace, ByteBuffer name, List<FieldIdentifier> fieldNames, List<AbstractType<?>> fieldTypes, boolean isMultiCell)
1:ca7e9d5:     {
1:677230d:         super(fieldTypes, false);
1:db9ef0b:         assert fieldNames.size() == fieldTypes.size();
1:d63d07b:         this.keyspace = keyspace;
1:a552b30:         this.name = name;
1:db9ef0b:         this.fieldNames = fieldNames;
1:c7b02d1:         this.stringFieldNames = new ArrayList<>(fieldNames.size());
1:677230d:         this.isMultiCell = isMultiCell;
1:677230d: 
1:4ed0060:         for (FieldIdentifier fieldName : fieldNames)
1:4ed0060:             stringFieldNames.add(fieldName.toString());
1:ca7e9d5:     }
1:a552b30: 
1:a552b30:     public static UserType getInstance(TypeParser parser) throws ConfigurationException, SyntaxException
1:a552b30:     {
1:d63d07b:         Pair<Pair<String, ByteBuffer>, List<Pair<ByteBuffer, AbstractType>>> params = parser.getUserTypeParameters();
1:d63d07b:         String keyspace = params.left.left;
1:d63d07b:         ByteBuffer name = params.left.right;
1:4ed0060:         List<FieldIdentifier> columnNames = new ArrayList<>(params.right.size());
1:a552b30:         List<AbstractType<?>> columnTypes = new ArrayList<>(params.right.size());
1:a552b30:         for (Pair<ByteBuffer, AbstractType> p : params.right)
1:a552b30:         {
1:4ed0060:             columnNames.add(new FieldIdentifier(p.left));
1:a552b30:             columnTypes.add(p.right);
1:a552b30:         }
1:a552b30: 
1:677230d:         return new UserType(keyspace, name, columnNames, columnTypes, true);
1:a552b30:     }
1:677230d: 
1:a552b30:     @Override
1:677230d:     public boolean isUDT()
1:a552b30:     {
1:677230d:         return true;
1:a552b30:     }
1:a552b30: 
1:a552b30:     @Override
1:677230d:     public boolean isMultiCell()
1:a552b30:     {
1:677230d:         return isMultiCell;
1:a552b30:     }
1:677230d: 
1:677230d:     @Override
1:677230d:     public boolean isFreezable()
1:a552b30:     {
1:677230d:         return true;
1:677230d:     }
1:677230d: 
1:0932ed6:     public AbstractType<?> fieldType(int i)
1:0932ed6:     {
1:0932ed6:         return type(i);
1:0932ed6:     }
1:0932ed6: 
1:0932ed6:     public List<AbstractType<?>> fieldTypes()
1:0932ed6:     {
1:0932ed6:         return types;
1:0932ed6:     }
1:0932ed6: 
1:4ed0060:     public FieldIdentifier fieldName(int i)
1:0932ed6:     {
1:0932ed6:         return fieldNames.get(i);
1:0932ed6:     }
1:0932ed6: 
1:48f6446:     public String fieldNameAsString(int i)
1:0932ed6:     {
1:48f6446:         return stringFieldNames.get(i);
1:677230d:     }
1:677230d: 
1:4ed0060:     public List<FieldIdentifier> fieldNames()
1:a552b30:     {
1:0932ed6:         return fieldNames;
1:0932ed6:     }
1:0932ed6: 
1:9872b74:     public String getNameAsString()
1:9872b74:     {
1:9872b74:         return UTF8Type.instance.compose(name);
1:db9ef0b:     }
1:db9ef0b: 
1:4ed0060:     public int fieldPosition(FieldIdentifier fieldName)
1:db9ef0b:     {
1:4ed0060:         return fieldNames.indexOf(fieldName);
1:db9ef0b:     }
1:db9ef0b: 
1:4ed0060:     public CellPath cellPathForField(FieldIdentifier fieldName)
1:db9ef0b:     {
1:677230d:         // we use the field position instead of the field name to allow for field renaming in ALTER TYPE statements
1:4ed0060:         return CellPath.create(ByteBufferUtil.bytes((short)fieldPosition(fieldName)));
1:db9ef0b:     }
1:db9ef0b: 
1:677230d:     public ShortType nameComparator()
1:db9ef0b:     {
1:677230d:         return ShortType.instance;
1:9872b74:     }
1:db9ef0b: 
1:e0adc16:     public ByteBuffer serializeForNativeProtocol(Iterator<Cell> cells, ProtocolVersion protocolVersion)
1:d62b2cf:     {
1:677230d:         assert isMultiCell;
1:db9ef0b: 
1:677230d:         ByteBuffer[] components = new ByteBuffer[size()];
1:677230d:         short fieldPosition = 0;
1:677230d:         while (cells.hasNext())
1:677230d:         {
1:677230d:             Cell cell = cells.next();
1:db9ef0b: 
1:677230d:             // handle null fields that aren't at the end
1:677230d:             short fieldPositionOfCell = ByteBufferUtil.toShort(cell.path().get(0));
1:677230d:             while (fieldPosition < fieldPositionOfCell)
1:677230d:                 components[fieldPosition++] = null;
1:db9ef0b: 
1:677230d:             components[fieldPosition++] = cell.value();
1:677230d:         }
1:db9ef0b: 
1:677230d:         // append trailing nulls for missing cells
1:677230d:         while (fieldPosition < size())
1:677230d:             components[fieldPosition++] = null;
1:db9ef0b: 
1:677230d:         return TupleType.buildValue(components);
1:677230d:     }
1:db9ef0b: 
1:0932ed6:     // Note: the only reason we override this is to provide nicer error message, but since that's not that much code...
1:db9ef0b:     @Override
1:db9ef0b:     public void validate(ByteBuffer bytes) throws MarshalException
1:db9ef0b:     {
1:db9ef0b:         ByteBuffer input = bytes.duplicate();
1:0932ed6:         for (int i = 0; i < size(); i++)
1:db9ef0b:         {
1:db9ef0b:             // we allow the input to have less fields than declared so as to support field addition.
3:db9ef0b:             if (!input.hasRemaining())
1:db9ef0b:                 return;
1:db9ef0b: 
1:db9ef0b:             if (input.remaining() < 4)
1:6dc595d:                 throw new MarshalException(String.format("Not enough bytes to read size of %dth field %s", i, fieldNameAsString(i)));
1:db9ef0b: 
3:db9ef0b:             int size = input.getInt();
1:ca7e9d5: 
1:ca7e9d5:             // size < 0 means null value
1:ca7e9d5:             if (size < 0)
1:ca7e9d5:                 continue;
1:ca7e9d5: 
1:db9ef0b:             if (input.remaining() < size)
1:6dc595d:                 throw new MarshalException(String.format("Not enough bytes to read %dth field %s", i, fieldNameAsString(i)));
1:ca7e9d5: 
2:db9ef0b:             ByteBuffer field = ByteBufferUtil.readBytes(input, size);
1:0932ed6:             types.get(i).validate(field);
1:ca7e9d5:         }
1:db9ef0b: 
1:db9ef0b:         // We're allowed to get less fields than declared, but not more
1:db9ef0b:         if (input.hasRemaining())
1:db9ef0b:             throw new MarshalException("Invalid remaining data after end of UDT value");
1:db9ef0b:     }
1:db9ef0b: 
1:0932ed6:     @Override
1:c7b02d1:     public Term fromJSONObject(Object parsed) throws MarshalException
1:db9ef0b:     {
1:b7be198:         if (parsed instanceof String)
1:b7be198:             parsed = Json.decodeJson((String) parsed);
1:db9ef0b: 
1:c7b02d1:         if (!(parsed instanceof Map))
1:c7b02d1:             throw new MarshalException(String.format(
1:c7b02d1:                     "Expected a map, but got a %s: %s", parsed.getClass().getSimpleName(), parsed));
1:db9ef0b: 
1:c7b02d1:         Map<String, Object> map = (Map<String, Object>) parsed;
1:db9ef0b: 
1:c7b02d1:         Json.handleCaseSensitivity(map);
1:db9ef0b: 
1:c7b02d1:         List<Term> terms = new ArrayList<>(types.size());
1:db9ef0b: 
1:c7b02d1:         Set keys = map.keySet();
1:c7b02d1:         assert keys.isEmpty() || keys.iterator().next() instanceof String;
1:db9ef0b: 
1:c7b02d1:         int foundValues = 0;
1:c7b02d1:         for (int i = 0; i < types.size(); i++)
1:db9ef0b:         {
1:c7b02d1:             Object value = map.get(stringFieldNames.get(i));
1:c7b02d1:             if (value == null)
1:db9ef0b:             {
1:c7b02d1:                 terms.add(Constants.NULL_VALUE);
1:db9ef0b:             }
1:ca7e9d5:             else
1:ca7e9d5:             {
1:c7b02d1:                 terms.add(types.get(i).fromJSONObject(value));
1:c7b02d1:                 foundValues += 1;
1:ca7e9d5:             }
1:db9ef0b:         }
1:9872b74: 
1:c7b02d1:         // check for extra, unrecognized fields
1:c7b02d1:         if (foundValues != map.size())
1:db9ef0b:         {
1:c7b02d1:             for (Object fieldName : keys)
1:db9ef0b:             {
1:1fab7b7:                 if (!stringFieldNames.contains(fieldName))
1:c7b02d1:                     throw new MarshalException(String.format(
1:c7b02d1:                             "Unknown field '%s' in value of user defined type %s", fieldName, getNameAsString()));
1:db9ef0b:             }
1:db9ef0b:         }
1:677230d: 
1:c7b02d1:         return new UserTypes.DelayedValue(this, terms);
1:db9ef0b:     }
1:677230d: 
1:db9ef0b:     @Override
1:e0adc16:     public String toJSONString(ByteBuffer buffer, ProtocolVersion protocolVersion)
1:db9ef0b:     {
1:c7b02d1:         ByteBuffer[] buffers = split(buffer);
1:c7b02d1:         StringBuilder sb = new StringBuilder("{");
1:c7b02d1:         for (int i = 0; i < types.size(); i++)
1:677230d:         {
1:db9ef0b:             if (i > 0)
1:c7b02d1:                 sb.append(", ");
1:db9ef0b: 
1:c7b02d1:             String name = stringFieldNames.get(i);
1:c7b02d1:             if (!name.equals(name.toLowerCase(Locale.US)))
1:c7b02d1:                 name = "\"" + name + "\"";
1:db9ef0b: 
1:c7b02d1:             sb.append('"');
1:6b1bd17:             sb.append(Json.quoteAsJsonString(name));
1:c7b02d1:             sb.append("\": ");
1:db9ef0b: 
1:c116207:             ByteBuffer valueBuffer = (i >= buffers.length) ? null : buffers[i];
1:c7b02d1:             if (valueBuffer == null)
1:c7b02d1:                 sb.append("null");
2:c7b02d1:             else
1:c7b02d1:                 sb.append(types.get(i).toJSONString(valueBuffer, protocolVersion));
1:db9ef0b:         }
1:c7b02d1:         return sb.append("}").toString();
1:db9ef0b:     }
1:db9ef0b: 
1:677230d:     @Override
1:677230d:     public UserType freeze()
1:db9ef0b:     {
1:677230d:         if (isMultiCell)
1:677230d:             return new UserType(keyspace, name, fieldNames, fieldTypes(), false);
1:677230d:         else
1:677230d:             return this;
1:db9ef0b:     }
1:677230d: 
1:677230d:     @Override
1:dee84cc:     public AbstractType<?> freezeNestedMulticellTypes()
1:db9ef0b:     {
1:dee84cc:         if (!isMultiCell())
1:dee84cc:             return this;
1:dee84cc: 
1:d62b2cf:         // the behavior here doesn't exactly match the method name: we want to freeze everything inside of UDTs
1:d62b2cf:         List<AbstractType<?>> newTypes = fieldTypes().stream()
1:d62b2cf:                 .map(subtype -> (subtype.isFreezable() && subtype.isMultiCell() ? subtype.freeze() : subtype))
1:d62b2cf:                 .collect(Collectors.toList());
1:d62b2cf: 
1:d62b2cf:         return new UserType(keyspace, name, fieldNames, newTypes, isMultiCell);
1:db9ef0b:     }
1:d62b2cf: 
1:d62b2cf:     @Override
1:0932ed6:     public int hashCode()
1:db9ef0b:     {
1:677230d:         return Objects.hashCode(keyspace, name, fieldNames, types, isMultiCell);
1:db9ef0b:     }
1:677230d: 
1:677230d:     @Override
1:677230d:     public boolean isValueCompatibleWith(AbstractType<?> previous)
1:677230d:     {
1:677230d:         if (this == previous)
1:677230d:             return true;
1:677230d: 
1:677230d:         if (!(previous instanceof UserType))
1:677230d:             return false;
1:677230d: 
1:677230d:         UserType other = (UserType) previous;
1:677230d:         if (isMultiCell != other.isMultiCell())
1:677230d:             return false;
1:677230d: 
1:677230d:         if (!keyspace.equals(other.keyspace))
1:677230d:             return false;
1:677230d: 
1:677230d:         Iterator<AbstractType<?>> thisTypeIter = types.iterator();
1:677230d:         Iterator<AbstractType<?>> previousTypeIter = other.types.iterator();
1:677230d:         while (thisTypeIter.hasNext() && previousTypeIter.hasNext())
1:677230d:         {
1:677230d:             if (!thisTypeIter.next().isCompatibleWith(previousTypeIter.next()))
1:677230d:                 return false;
1:d62b2cf:         }
1:677230d: 
1:677230d:         // it's okay for the new type to have additional fields, but not for the old type to have additional fields
1:677230d:         return !previousTypeIter.hasNext();
1:677230d:     }
1:677230d: 
1:677230d:     @Override
1:0932ed6:     public boolean equals(Object o)
1:677230d:     {
1:677230d:         return o instanceof UserType && equals(o, false);
1:677230d:     }
5:677230d: 
1:677230d:     @Override
1:677230d:     public boolean equals(Object o, boolean ignoreFreezing)
1:677230d:     {
1:a552b30:         if(!(o instanceof UserType))
1:a552b30:             return false;
1:a552b30: 
1:a552b30:         UserType that = (UserType)o;
1:a552b30: 
1:677230d:         if (!keyspace.equals(that.keyspace) || !name.equals(that.name) || !fieldNames.equals(that.fieldNames))
1:677230d:             return false;
1:677230d: 
1:677230d:         if (!ignoreFreezing && isMultiCell != that.isMultiCell)
1:677230d:             return false;
1:677230d: 
1:677230d:         if (this.types.size() != that.types.size())
1:677230d:             return false;
1:677230d: 
1:677230d:         Iterator<AbstractType<?>> otherTypeIter = that.types.iterator();
1:677230d:         for (AbstractType<?> type : types)
1:677230d:         {
1:677230d:             if (!type.equals(otherTypeIter.next(), ignoreFreezing))
1:677230d:                 return false;
1:a552b30:         }
1:677230d: 
1:677230d:         return true;
1:677230d:     }
1:677230d: 
1:a552b30:     @Override
1:a552b30:     public CQL3Type asCQL3Type()
1:a552b30:     {
1:d63d07b:         return CQL3Type.UserDefined.create(this);
1:a552b30:     }
1:a552b30: 
1:a552b30:     @Override
1:7a3c3ab:     public boolean referencesUserType(String userTypeName)
1:677230d:     {
1:7a3c3ab:         return getNameAsString().equals(userTypeName) ||
1:7a3c3ab:                fieldTypes().stream().anyMatch(f -> f.referencesUserType(userTypeName));
1:677230d:     }
1:677230d: 
2:c7b02d1:     @Override
1:ecf05b8:     public boolean referencesDuration()
1:ecf05b8:     {
1:ecf05b8:         return fieldTypes().stream().anyMatch(f -> f.referencesDuration());
1:ecf05b8:     }
1:ecf05b8: 
1:ecf05b8:     @Override
1:a552b30:     public String toString()
1:a552b30:     {
1:677230d:         return this.toString(false);
1:a552b30:     }
1:677230d: 
1:677230d:     @Override
1:677230d:     public String toString(boolean ignoreFreezing)
1:677230d:     {
1:677230d:         boolean includeFrozenType = !ignoreFreezing && !isMultiCell();
1:677230d: 
1:db9ef0b:         StringBuilder sb = new StringBuilder();
1:677230d:         if (includeFrozenType)
1:677230d:             sb.append(FrozenType.class.getName()).append("(");
1:677230d:         sb.append(getClass().getName());
1:677230d:         sb.append(TypeParser.stringifyUserTypeParameters(keyspace, name, fieldNames, types, ignoreFreezing || !isMultiCell));
1:677230d:         if (includeFrozenType)
1:677230d:             sb.append(")");
2:db9ef0b:         return sb.toString();
1:a552b30:     }
1:677230d: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:e0adc16
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.transport.ProtocolVersion;
/////////////////////////////////////////////////////////////////////////
1:     public ByteBuffer serializeForNativeProtocol(Iterator<Cell> cells, ProtocolVersion protocolVersion)
/////////////////////////////////////////////////////////////////////////
1:     public String toJSONString(ByteBuffer buffer, ProtocolVersion protocolVersion)
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:ecf05b8
/////////////////////////////////////////////////////////////////////////
1:     public boolean referencesDuration()
1:     {
1:         return fieldTypes().stream().anyMatch(f -> f.referencesDuration());
1:     }
1: 
1:     @Override
commit:7bef418
commit:b7fc5dc
commit:6dc595d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.serializers.MarshalException;
/////////////////////////////////////////////////////////////////////////
1:                 throw new MarshalException(String.format("Not enough bytes to read size of %dth field %s", i, fieldNameAsString(i)));
/////////////////////////////////////////////////////////////////////////
1:                 throw new MarshalException(String.format("Not enough bytes to read %dth field %s", i, fieldNameAsString(i)));
author:Dave Brosius
-------------------------------------------------------------------------------
commit:087264f
/////////////////////////////////////////////////////////////////////////
commit:a01d2d3
/////////////////////////////////////////////////////////////////////////
0: import java.nio.charset.StandardCharsets;
/////////////////////////////////////////////////////////////////////////
0:                 stringFieldNames.add(ByteBufferUtil.string(fieldName, StandardCharsets.UTF_8));
commit:1fab7b7
/////////////////////////////////////////////////////////////////////////
1:                 if (!stringFieldNames.contains(fieldName))
commit:1def02f
/////////////////////////////////////////////////////////////////////////
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:4ed0060
/////////////////////////////////////////////////////////////////////////
1:     private final List<FieldIdentifier> fieldNames;
1:     public UserType(String keyspace, ByteBuffer name, List<FieldIdentifier> fieldNames, List<AbstractType<?>> fieldTypes, boolean isMultiCell)
/////////////////////////////////////////////////////////////////////////
1:         for (FieldIdentifier fieldName : fieldNames)
1:             stringFieldNames.add(fieldName.toString());
/////////////////////////////////////////////////////////////////////////
1:         List<FieldIdentifier> columnNames = new ArrayList<>(params.right.size());
1:             columnNames.add(new FieldIdentifier(p.left));
/////////////////////////////////////////////////////////////////////////
1:     public FieldIdentifier fieldName(int i)
/////////////////////////////////////////////////////////////////////////
1:     public List<FieldIdentifier> fieldNames()
/////////////////////////////////////////////////////////////////////////
1:     public int fieldPosition(FieldIdentifier fieldName)
1:         return fieldNames.indexOf(fieldName);
1:     public CellPath cellPathForField(FieldIdentifier fieldName)
1:         return CellPath.create(ByteBufferUtil.bytes((short)fieldPosition(fieldName)));
commit:0932ed6
/////////////////////////////////////////////////////////////////////////
1:  *
1:  * A user type is really just a tuple type on steroids.
1: public class UserType extends TupleType
0:     private final List<ByteBuffer> fieldNames;
0:         super(fieldTypes);
/////////////////////////////////////////////////////////////////////////
1:     public AbstractType<?> fieldType(int i)
1:     {
1:         return type(i);
1:     }
1: 
1:     public List<AbstractType<?>> fieldTypes()
1:     {
1:         return types;
1:     }
1: 
0:     public ByteBuffer fieldName(int i)
1:     {
1:         return fieldNames.get(i);
1:     }
1: 
0:     public List<ByteBuffer> fieldNames()
1:     {
1:         return fieldNames;
1:     }
1: 
1:     // Note: the only reason we override this is to provide nicer error message, but since that's not that much code...
1:         for (int i = 0; i < size(); i++)
0:                 throw new MarshalException(String.format("Not enough bytes to read size of %dth field %s", i, fieldName(i)));
/////////////////////////////////////////////////////////////////////////
0:                 throw new MarshalException(String.format("Not enough bytes to read %dth field %s", i, fieldName(i)));
1:             types.get(i).validate(field);
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public int hashCode()
0:         return Objects.hashCode(keyspace, name, fieldNames, types);
1:     public boolean equals(Object o)
0:         return keyspace.equals(that.keyspace) && name.equals(that.name) && fieldNames.equals(that.fieldNames) && types.equals(that.types);
/////////////////////////////////////////////////////////////////////////
0:         return getClass().getName() + TypeParser.stringifyUserTypeParameters(keyspace, name, fieldNames, types);
commit:ca7e9d5
/////////////////////////////////////////////////////////////////////////
1: 
1:             // size < 0 means null value
1:                 continue;
/////////////////////////////////////////////////////////////////////////
0:             totalLength += 4 + (field == null ? 0 : field.remaining());
0:             if (field == null)
1:             {
0:                 result.putInt(-1);
1:             }
1:             else
1:             {
0:                 result.putInt(field.remaining());
0:                 result.put(field.duplicate());
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if (size < 0)
1:             {
0:                 sb.append("@");
0:                 continue;
1:             }
1: 
0:             // We use ':' as delimiter, and @ to represent null, so escape them in the generated string
0:             sb.append(type.getString(field).replaceAll(":", "\\\\:").replaceAll("@", "\\\\@"));
/////////////////////////////////////////////////////////////////////////
0:             String fieldString = fieldStrings.get(i);
0:             // We use @ to represent nulls
0:             if (fieldString.equals("@"))
0:                 continue;
1: 
0:             fields[i] = type.fromString(fieldString.replaceAll("\\\\:", ":").replaceAll("\\\\@", "@"));
commit:db9ef0b
/////////////////////////////////////////////////////////////////////////
0: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.serializers.*;
1: import org.apache.cassandra.utils.ByteBufferUtil;
0: public class UserType extends AbstractType<ByteBuffer>
0:     public final List<ByteBuffer> fieldNames;
0:     public final List<AbstractType<?>> fieldTypes;
0:     public UserType(String keyspace, ByteBuffer name, List<ByteBuffer> fieldNames, List<AbstractType<?>> fieldTypes)
1:         assert fieldNames.size() == fieldTypes.size();
1:         this.fieldNames = fieldNames;
0:         this.fieldTypes = fieldTypes;
/////////////////////////////////////////////////////////////////////////
0:     public int compare(ByteBuffer o1, ByteBuffer o2)
1:     {
0:         if (!o1.hasRemaining() || !o2.hasRemaining())
0:             return o1.hasRemaining() ? 1 : o2.hasRemaining() ? -1 : 0;
1: 
0:         ByteBuffer bb1 = o1.duplicate();
0:         ByteBuffer bb2 = o2.duplicate();
1: 
0:         int i = 0;
0:         while (bb1.remaining() > 0 && bb2.remaining() > 0)
1:         {
0:             AbstractType<?> comparator = fieldTypes.get(i);
1: 
0:             int size1 = bb1.getInt();
0:             int size2 = bb2.getInt();
1: 
0:             // Handle nulls
0:             if (size1 < 0)
1:             {
0:                 if (size2 < 0)
0:                     continue;
0:                 return -1;
1:             }
0:             if (size2 < 0)
0:                 return 1;
1: 
0:             ByteBuffer value1 = ByteBufferUtil.readBytes(bb1, size1);
0:             ByteBuffer value2 = ByteBufferUtil.readBytes(bb2, size2);
0:             int cmp = comparator.compare(value1, value2);
0:             if (cmp != 0)
0:                 return cmp;
1: 
0:             ++i;
1:         }
1: 
0:         if (bb1.remaining() == 0)
0:             return bb2.remaining() == 0 ? 0 : -1;
1: 
0:         // bb1.remaining() > 0 && bb2.remaining() == 0
0:         return 1;
1:     }
1: 
1:     @Override
1:     public void validate(ByteBuffer bytes) throws MarshalException
1:     {
1:         ByteBuffer input = bytes.duplicate();
0:         for (int i = 0; i < fieldTypes.size(); i++)
1:         {
1:             // we allow the input to have less fields than declared so as to support field addition.
1:             if (!input.hasRemaining())
1:                 return;
1: 
1:             if (input.remaining() < 4)
0:                 throw new MarshalException(String.format("Not enough bytes to read size of %dth field %s", i, fieldNames.get(i)));
1: 
1:             int size = input.getInt();
0:             // We don't handle null just yet, but we should fix that soon (CASSANDRA-7206)
0:             if (size < 0)
0:                 throw new MarshalException("Nulls are not yet supported inside UDT values");
1: 
1:             if (input.remaining() < size)
0:                 throw new MarshalException(String.format("Not enough bytes to read %dth field %s", i, fieldNames.get(i)));
1: 
1:             ByteBuffer field = ByteBufferUtil.readBytes(input, size);
0:             fieldTypes.get(i).validate(field);
1:         }
1: 
1:         // We're allowed to get less fields than declared, but not more
1:         if (input.hasRemaining())
1:             throw new MarshalException("Invalid remaining data after end of UDT value");
1:     }
1: 
1:     /**
0:      * Split a UDT value into its fields values.
1:      */
0:     public ByteBuffer[] split(ByteBuffer value)
1:     {
0:         ByteBuffer[] fields = new ByteBuffer[fieldTypes.size()];
0:         ByteBuffer input = value.duplicate();
0:         for (int i = 0; i < fieldTypes.size(); i++)
1:         {
1:             if (!input.hasRemaining())
0:                 return Arrays.copyOfRange(fields, 0, i);
1: 
1:             int size = input.getInt();
0:             fields[i] = size < 0 ? null : ByteBufferUtil.readBytes(input, size);
1:         }
0:         return fields;
1:     }
1: 
0:     public static ByteBuffer buildValue(ByteBuffer[] fields)
1:     {
0:         int totalLength = 0;
0:         for (ByteBuffer field : fields)
0:             totalLength += 4 + field.remaining();
1: 
0:         ByteBuffer result = ByteBuffer.allocate(totalLength);
0:         for (ByteBuffer field : fields)
1:         {
0:             result.putInt(field.remaining());
0:             result.put(field.duplicate());
1:         }
0:         result.rewind();
0:         return result;
1:     }
1: 
1:     @Override
0:     public String getString(ByteBuffer value)
1:     {
1:         StringBuilder sb = new StringBuilder();
0:         ByteBuffer input = value.duplicate();
0:         for (int i = 0; i < fieldTypes.size(); i++)
1:         {
1:             if (!input.hasRemaining())
1:                 return sb.toString();
1: 
1:             if (i > 0)
0:                 sb.append(":");
1: 
0:             AbstractType<?> type = fieldTypes.get(i);
1:             int size = input.getInt();
0:             assert size >= 0; // We don't support nulls yet, but we will likely do with #7206 and we'll need
0:                               // a way to represent it as a string (without it conflicting with a user value)
1:             ByteBuffer field = ByteBufferUtil.readBytes(input, size);
0:             // We use ':' as delimiter so escape it if it's in the generated string
0:             sb.append(field == null ? "null" : type.getString(value).replaceAll(":", "\\\\:"));
1:         }
1:         return sb.toString();
1:     }
1: 
0:     public ByteBuffer fromString(String source)
1:     {
0:         // Split the input on non-escaped ':' characters
0:         List<String> fieldStrings = AbstractCompositeType.split(source);
0:         ByteBuffer[] fields = new ByteBuffer[fieldStrings.size()];
0:         for (int i = 0; i < fieldStrings.size(); i++)
1:         {
0:             AbstractType<?> type = fieldTypes.get(i);
0:             // TODO: we'll need to handle null somehow here once we support them
0:             String fieldString = fieldStrings.get(i).replaceAll("\\\\:", ":");
0:             fields[i] = type.fromString(fieldString);
1:         }
0:         return buildValue(fields);
1:     }
1: 
0:     public TypeSerializer<ByteBuffer> getSerializer()
1:     {
0:         return BytesSerializer.instance;
1:     }
1: 
0:         return Objects.hashCode(keyspace, name, fieldNames, fieldTypes);
/////////////////////////////////////////////////////////////////////////
0:         return keyspace.equals(that.keyspace) && name.equals(that.name) && fieldNames.equals(that.fieldNames) && fieldTypes.equals(that.fieldTypes);
/////////////////////////////////////////////////////////////////////////
0:         return getClass().getName() + TypeParser.stringifyUserTypeParameters(keyspace, name, fieldNames, fieldTypes);
commit:9872b74
/////////////////////////////////////////////////////////////////////////
1:     public String getNameAsString()
1:     {
1:         return UTF8Type.instance.compose(name);
1:     }
1: 
commit:d63d07b
/////////////////////////////////////////////////////////////////////////
1:     public final String keyspace;
0:     public UserType(String keyspace, ByteBuffer name, List<ByteBuffer> columnNames, List<AbstractType<?>> types)
1:         this.keyspace = keyspace;
1:         Pair<Pair<String, ByteBuffer>, List<Pair<ByteBuffer, AbstractType>>> params = parser.getUserTypeParameters();
1:         String keyspace = params.left.left;
1:         ByteBuffer name = params.left.right;
/////////////////////////////////////////////////////////////////////////
0:         return new UserType(keyspace, name, columnNames, columnTypes);
0:         return Objects.hashCode(keyspace, name, columnNames, types);
/////////////////////////////////////////////////////////////////////////
0:         return keyspace.equals(that.keyspace) && name.equals(that.name) && columnNames.equals(that.columnNames) && types.equals(that.types);
1:         return CQL3Type.UserDefined.create(this);
0:         return getClass().getName() + TypeParser.stringifyUserTypeParameters(keyspace, name, columnNames, types);
commit:a552b30
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.db.marshal;
1: 
1: import java.nio.ByteBuffer;
0: import java.util.ArrayList;
0: import java.util.List;
1: 
1: import com.google.common.base.Objects;
1: 
0: import org.apache.cassandra.cql3.CQL3Type;
1: import org.apache.cassandra.exceptions.ConfigurationException;
1: import org.apache.cassandra.exceptions.SyntaxException;
1: import org.apache.cassandra.utils.Pair;
1: 
0: /**
1:  * A user defined type.
1:  *
0:  * The serialized format and sorting is exactly the one of CompositeType, but
0:  * we keep additional metadata (the name of the type and the names
0:  * of the columns).
1:  */
0: public class UserType extends CompositeType
1: {
1:     public final ByteBuffer name;
0:     public final List<ByteBuffer> columnNames;
1: 
0:     public UserType(ByteBuffer name, List<ByteBuffer> columnNames, List<AbstractType<?>> types)
1:     {
0:         super(types);
1:         this.name = name;
0:         this.columnNames = columnNames;
1:     }
1: 
1:     public static UserType getInstance(TypeParser parser) throws ConfigurationException, SyntaxException
1:     {
0:         Pair<ByteBuffer, List<Pair<ByteBuffer, AbstractType>>> params = parser.getUserTypeParameters();
0:         ByteBuffer name = params.left;
0:         List<ByteBuffer> columnNames = new ArrayList<>(params.right.size());
1:         List<AbstractType<?>> columnTypes = new ArrayList<>(params.right.size());
1:         for (Pair<ByteBuffer, AbstractType> p : params.right)
1:         {
0:             columnNames.add(p.left);
1:             columnTypes.add(p.right);
1:         }
0:         return new UserType(name, columnNames, columnTypes);
1:     }
1: 
1:     @Override
0:     public final int hashCode()
1:     {
0:         return Objects.hashCode(name, columnNames, types);
1:     }
1: 
1:     @Override
0:     public final boolean equals(Object o)
1:     {
1:         if(!(o instanceof UserType))
1:             return false;
1: 
1:         UserType that = (UserType)o;
0:         return name.equals(that.name) && columnNames.equals(that.columnNames) && types.equals(that.types);
1:     }
1: 
1:     @Override
1:     public CQL3Type asCQL3Type()
1:     {
0:         return CQL3Type.UserDefined.create(name, this);
1:     }
1: 
1:     @Override
1:     public String toString()
1:     {
0:         return getClass().getName() + TypeParser.stringifyUserTypeParameters(name, columnNames, types);
1:     }
1: }
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:dee84cc
/////////////////////////////////////////////////////////////////////////
1:     public AbstractType<?> freezeNestedMulticellTypes()
1:         if (!isMultiCell())
1:             return this;
1: 
commit:d62b2cf
/////////////////////////////////////////////////////////////////////////
1: import java.util.stream.Collectors;
/////////////////////////////////////////////////////////////////////////
0:     public AbstractType<?> freezeNestedUDTs()
1:     {
1:         // the behavior here doesn't exactly match the method name: we want to freeze everything inside of UDTs
1:         List<AbstractType<?>> newTypes = fieldTypes().stream()
1:                 .map(subtype -> (subtype.isFreezable() && subtype.isMultiCell() ? subtype.freeze() : subtype))
1:                 .collect(Collectors.toList());
1: 
1:         return new UserType(keyspace, name, fieldNames, newTypes, isMultiCell);
1:     }
1: 
1:     @Override
commit:677230d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.rows.Cell;
1: import org.apache.cassandra.db.rows.CellPath;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger logger = LoggerFactory.getLogger(UserType.class);
1: 
1:     private final boolean isMultiCell;
0:     public UserType(String keyspace, ByteBuffer name, List<ByteBuffer> fieldNames, List<AbstractType<?>> fieldTypes, boolean isMultiCell)
1:         super(fieldTypes, false);
1:         this.isMultiCell = isMultiCell;
1: 
/////////////////////////////////////////////////////////////////////////
0:             columnTypes.add(p.right);
1: 
1:         return new UserType(keyspace, name, columnNames, columnTypes, true);
1:     }
1: 
1:     @Override
1:     public boolean isUDT()
1:     {
1:         return true;
1:     }
1: 
1:     @Override
1:     public boolean isMultiCell()
1:     {
1:         return isMultiCell;
1:     }
1: 
1:     @Override
1:     public boolean isFreezable()
1:     {
1:         return true;
/////////////////////////////////////////////////////////////////////////
0:     public short fieldPosition(ColumnIdentifier field)
1:     {
0:         return fieldPosition(field.bytes);
1:     }
1: 
0:     public short fieldPosition(ByteBuffer fieldName)
1:     {
0:         for (short i = 0; i < fieldNames.size(); i++)
0:             if (fieldName.equals(fieldNames.get(i)))
0:                 return i;
0:         return -1;
1:     }
1: 
0:     public CellPath cellPathForField(ByteBuffer fieldName)
1:     {
1:         // we use the field position instead of the field name to allow for field renaming in ALTER TYPE statements
0:         return CellPath.create(ByteBufferUtil.bytes(fieldPosition(fieldName)));
1:     }
1: 
1:     public ShortType nameComparator()
1:     {
1:         return ShortType.instance;
1:     }
1: 
0:     public ByteBuffer serializeForNativeProtocol(Iterator<Cell> cells, int protocolVersion)
1:     {
1:         assert isMultiCell;
1: 
1:         ByteBuffer[] components = new ByteBuffer[size()];
1:         short fieldPosition = 0;
1:         while (cells.hasNext())
1:         {
1:             Cell cell = cells.next();
1: 
1:             // handle null fields that aren't at the end
1:             short fieldPositionOfCell = ByteBufferUtil.toShort(cell.path().get(0));
1:             while (fieldPosition < fieldPositionOfCell)
1:                 components[fieldPosition++] = null;
1: 
1:             components[fieldPosition++] = cell.value();
1:         }
1: 
1:         // append trailing nulls for missing cells
1:         while (fieldPosition < size())
1:             components[fieldPosition++] = null;
1: 
1:         return TupleType.buildValue(components);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public UserType freeze()
0:     {
1:         if (isMultiCell)
1:             return new UserType(keyspace, name, fieldNames, fieldTypes(), false);
1:         else
1:             return this;
0:     }
1: 
1:     @Override
1:         return Objects.hashCode(keyspace, name, fieldNames, types, isMultiCell);
0:     }
1: 
1:     @Override
1:     public boolean isValueCompatibleWith(AbstractType<?> previous)
0:     {
1:         if (this == previous)
1:             return true;
1: 
1:         if (!(previous instanceof UserType))
1:             return false;
1: 
1:         UserType other = (UserType) previous;
1:         if (isMultiCell != other.isMultiCell())
1:             return false;
1: 
1:         if (!keyspace.equals(other.keyspace))
1:             return false;
1: 
1:         Iterator<AbstractType<?>> thisTypeIter = types.iterator();
1:         Iterator<AbstractType<?>> previousTypeIter = other.types.iterator();
1:         while (thisTypeIter.hasNext() && previousTypeIter.hasNext())
0:         {
1:             if (!thisTypeIter.next().isCompatibleWith(previousTypeIter.next()))
1:                 return false;
0:         }
1: 
1:         // it's okay for the new type to have additional fields, but not for the old type to have additional fields
1:         return !previousTypeIter.hasNext();
1:         return o instanceof UserType && equals(o, false);
0:     }
1: 
1:     @Override
1:     public boolean equals(Object o, boolean ignoreFreezing)
0:     {
1: 
1:         if (!keyspace.equals(that.keyspace) || !name.equals(that.name) || !fieldNames.equals(that.fieldNames))
1:             return false;
1: 
1:         if (!ignoreFreezing && isMultiCell != that.isMultiCell)
1:             return false;
1: 
1:         if (this.types.size() != that.types.size())
1:             return false;
1: 
1:         Iterator<AbstractType<?>> otherTypeIter = that.types.iterator();
1:         for (AbstractType<?> type : types)
0:         {
1:             if (!type.equals(otherTypeIter.next(), ignoreFreezing))
1:                 return false;
0:         }
1: 
1:         return true;
/////////////////////////////////////////////////////////////////////////
1:         return this.toString(false);
0:     }
0: 
1:     @Override
1:     public String toString(boolean ignoreFreezing)
0:     {
1:         boolean includeFrozenType = !ignoreFreezing && !isMultiCell();
0: 
0:         StringBuilder sb = new StringBuilder();
1:         if (includeFrozenType)
1:             sb.append(FrozenType.class.getName()).append("(");
1:         sb.append(getClass().getName());
1:         sb.append(TypeParser.stringifyUserTypeParameters(keyspace, name, fieldNames, types, ignoreFreezing || !isMultiCell));
1:         if (includeFrozenType)
1:             sb.append(")");
0:         return sb.toString();
commit:c64d3a5
commit:c116207
/////////////////////////////////////////////////////////////////////////
1:             ByteBuffer valueBuffer = (i >= buffers.length) ? null : buffers[i];
commit:6b1bd17
/////////////////////////////////////////////////////////////////////////
1:             sb.append(Json.quoteAsJsonString(name));
commit:b7be198
/////////////////////////////////////////////////////////////////////////
1:         if (parsed instanceof String)
1:             parsed = Json.decodeJson((String) parsed);
0: 
commit:c7b02d1
/////////////////////////////////////////////////////////////////////////
0: import java.nio.charset.CharacterCodingException;
0: import java.nio.charset.Charset;
1: import java.util.*;
1: import org.apache.cassandra.cql3.*;
0: import org.apache.cassandra.transport.Server;
/////////////////////////////////////////////////////////////////////////
1:     private final List<String> stringFieldNames;
/////////////////////////////////////////////////////////////////////////
1:         this.stringFieldNames = new ArrayList<>(fieldNames.size());
0:         for (ByteBuffer fieldName : fieldNames)
0:         {
0:             try
0:             {
0:                 stringFieldNames.add(ByteBufferUtil.string(fieldName, Charset.forName("UTF-8")));
0:             }
0:             catch (CharacterCodingException ex)
0:             {
0:                 throw new AssertionError("Got non-UTF8 field name for user-defined type: " + ByteBufferUtil.bytesToHex(fieldName), ex);
0:             }
0:         }
/////////////////////////////////////////////////////////////////////////
1:     public Term fromJSONObject(Object parsed) throws MarshalException
0:     {
1:         if (!(parsed instanceof Map))
1:             throw new MarshalException(String.format(
1:                     "Expected a map, but got a %s: %s", parsed.getClass().getSimpleName(), parsed));
0: 
1:         Map<String, Object> map = (Map<String, Object>) parsed;
0: 
1:         Json.handleCaseSensitivity(map);
0: 
1:         List<Term> terms = new ArrayList<>(types.size());
0: 
1:         Set keys = map.keySet();
1:         assert keys.isEmpty() || keys.iterator().next() instanceof String;
0: 
1:         int foundValues = 0;
1:         for (int i = 0; i < types.size(); i++)
0:         {
1:             Object value = map.get(stringFieldNames.get(i));
1:             if (value == null)
0:             {
1:                 terms.add(Constants.NULL_VALUE);
0:             }
1:             else
0:             {
1:                 terms.add(types.get(i).fromJSONObject(value));
1:                 foundValues += 1;
0:             }
0:         }
0: 
1:         // check for extra, unrecognized fields
1:         if (foundValues != map.size())
0:         {
1:             for (Object fieldName : keys)
0:             {
0:                 if (!stringFieldNames.contains((String) fieldName))
1:                     throw new MarshalException(String.format(
1:                             "Unknown field '%s' in value of user defined type %s", fieldName, getNameAsString()));
0:             }
0:         }
0: 
1:         return new UserTypes.DelayedValue(this, terms);
0:     }
0: 
1:     @Override
0:     public String toJSONString(ByteBuffer buffer, int protocolVersion)
0:     {
1:         ByteBuffer[] buffers = split(buffer);
1:         StringBuilder sb = new StringBuilder("{");
1:         for (int i = 0; i < types.size(); i++)
0:         {
0:             if (i > 0)
1:                 sb.append(", ");
0: 
1:             String name = stringFieldNames.get(i);
1:             if (!name.equals(name.toLowerCase(Locale.US)))
1:                 name = "\"" + name + "\"";
0: 
1:             sb.append('"');
0:             sb.append(Json.JSON_STRING_ENCODER.quoteAsString(name));
1:             sb.append("\": ");
0: 
0:             ByteBuffer valueBuffer = buffers[i];
1:             if (valueBuffer == null)
1:                 sb.append("null");
1:             else
1:                 sb.append(types.get(i).toJSONString(valueBuffer, protocolVersion));
0:         }
1:         return sb.append("}").toString();
0:     }
0: 
1:     @Override
commit:fb4356a
commit:ee55f36
/////////////////////////////////////////////////////////////////////////
0:             columnTypes.add(p.right.freeze());
author:Robert Stupp
-------------------------------------------------------------------------------
commit:7a3c3ab
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public boolean referencesUserType(String userTypeName)
0:     {
1:         return getNameAsString().equals(userTypeName) ||
1:                fieldTypes().stream().anyMatch(f -> f.referencesUserType(userTypeName));
0:     }
0: 
0:     @Override
author:Oded Peer
-------------------------------------------------------------------------------
commit:48f6446
/////////////////////////////////////////////////////////////////////////
1:     public String fieldNameAsString(int i)
0:     {
1:         return stringFieldNames.get(i);
0:     }
0: 
============================================================================