1:a991b64: /*
1:a991b64: * Licensed to the Apache Software Foundation (ASF) under one
1:a991b64: * or more contributor license agreements.  See the NOTICE file
1:a991b64: * distributed with this work for additional information
1:a991b64: * regarding copyright ownership.  The ASF licenses this file
1:a991b64: * to you under the Apache License, Version 2.0 (the
1:a991b64: * "License"); you may not use this file except in compliance
1:a991b64: * with the License.  You may obtain a copy of the License at
1:a991b64: *
1:a991b64: *    http://www.apache.org/licenses/LICENSE-2.0
1:a991b64: *
1:a991b64: * Unless required by applicable law or agreed to in writing,
1:a991b64: * software distributed under the License is distributed on an
1:a991b64: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:a991b64: * KIND, either express or implied.  See the License for the
1:a991b64: * specific language governing permissions and limitations
1:a991b64: * under the License.
1:a991b64: */
1:a991b64: package org.apache.cassandra.db;
1:a991b64: 
1:a991b64: import java.math.BigInteger;
1:a991b64: import java.nio.ByteBuffer;
1:a991b64: import java.nio.charset.CharacterCodingException;
1:a991b64: import java.util.List;
1:a991b64: 
1:a991b64: import org.junit.BeforeClass;
1:a991b64: import org.junit.Test;
1:a991b64: 
1:a991b64: import static org.junit.Assert.assertEquals;
1:a991b64: import static org.junit.Assert.assertTrue;
1:a991b64: 
1:a991b64: import org.apache.cassandra.*;
1:a991b64: import org.apache.cassandra.config.ColumnDefinition;
1:a991b64: import org.apache.cassandra.db.rows.Row;
1:a991b64: import org.apache.cassandra.db.marshal.IntegerType;
1:a991b64: import org.apache.cassandra.db.partitions.*;
1:a991b64: import org.apache.cassandra.exceptions.ConfigurationException;
1:31e3f61: import org.apache.cassandra.schema.KeyspaceParams;
1:a991b64: import org.apache.cassandra.utils.ByteBufferUtil;
1:a991b64: 
1:a991b64: public class PartitionRangeReadTest
1:a991b64: {
1:a991b64:     public static final String KEYSPACE1 = "PartitionRangeReadTest1";
1:a991b64:     public static final String KEYSPACE2 = "PartitionRangeReadTest2";
1:a991b64:     public static final String CF_STANDARD1 = "Standard1";
1:a991b64:     public static final String CF_STANDARDINT = "StandardInteger1";
1:a991b64: 
1:a991b64:     @BeforeClass
1:a991b64:     public static void defineSchema() throws ConfigurationException
1:a991b64:     {
1:a991b64:         SchemaLoader.prepareServer();
1:a991b64:         SchemaLoader.createKeyspace(KEYSPACE1,
1:31e3f61:                                     KeyspaceParams.simple(1),
1:a991b64:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD1),
1:a991b64:                                     SchemaLoader.denseCFMD(KEYSPACE1, CF_STANDARDINT, IntegerType.instance));
1:a991b64:         SchemaLoader.createKeyspace(KEYSPACE2,
1:31e3f61:                                     KeyspaceParams.simple(1),
1:a991b64:                                     SchemaLoader.standardCFMD(KEYSPACE2, CF_STANDARD1));
1:a991b64:     }
1:a991b64: 
1:a991b64:     @Test
1:a991b64:     public void testInclusiveBounds()
1:a991b64:     {
1:a991b64:         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE2).getColumnFamilyStore(CF_STANDARD1);
1:a991b64:         new RowUpdateBuilder(cfs.metadata, 0, ByteBufferUtil.bytes("key1"))
1:a991b64:                 .clustering("cc1")
1:a991b64:                 .add("val", "asdf").build().applyUnsafe();
1:a991b64:         new RowUpdateBuilder(cfs.metadata, 0, ByteBufferUtil.bytes("key2"))
1:a991b64:                 .clustering("cc2")
1:a991b64:                 .add("val", "asdf").build().applyUnsafe();
1:a991b64: 
1:a991b64:         assertEquals(2, Util.getAll(Util.cmd(cfs).fromIncl("cc1").toIncl("cc2").build()).size());
1:a991b64:     }
1:a991b64: 
1:a991b64:     @Test
1:a991b64:     public void testCassandra6778() throws CharacterCodingException
1:a991b64:     {
1:a991b64:         String cfname = CF_STANDARDINT;
1:a991b64:         Keyspace keyspace = Keyspace.open(KEYSPACE1);
1:a991b64:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfname);
1:a991b64:         cfs.truncateBlocking();
1:a991b64: 
1:a991b64:         ByteBuffer col = ByteBufferUtil.bytes("val");
1:a991b64:         ColumnDefinition cDef = cfs.metadata.getColumnDefinition(col);
1:a991b64: 
1:a991b64:         // insert two columns that represent the same integer but have different binary forms (the
1:a991b64:         // second one is padded with extra zeros)
1:a991b64:         new RowUpdateBuilder(cfs.metadata, 0, "k1")
1:a991b64:                 .clustering(new BigInteger(new byte[]{1}))
1:a991b64:                 .add("val", "val1")
1:a991b64:                 .build()
1:a991b64:                 .applyUnsafe();
1:a991b64:         cfs.forceBlockingFlush();
1:a991b64: 
1:a991b64:         new RowUpdateBuilder(cfs.metadata, 1, "k1")
1:a991b64:                 .clustering(new BigInteger(new byte[]{0, 0, 1}))
1:a991b64:                 .add("val", "val2")
1:a991b64:                 .build()
1:a991b64:                 .applyUnsafe();
1:a991b64:         cfs.forceBlockingFlush();
1:a991b64: 
1:a991b64:         // fetch by the first column name; we should get the second version of the column value
1:a991b64:         Row row = Util.getOnlyRow(Util.cmd(cfs, "k1").includeRow(new BigInteger(new byte[]{1})).build());
1:a991b64:         assertTrue(row.getCell(cDef).value().equals(ByteBufferUtil.bytes("val2")));
1:a991b64: 
1:a991b64:         // fetch by the second column name; we should get the second version of the column value
1:a991b64:         row = Util.getOnlyRow(Util.cmd(cfs, "k1").includeRow(new BigInteger(new byte[]{0, 0, 1})).build());
1:a991b64:         assertTrue(row.getCell(cDef).value().equals(ByteBufferUtil.bytes("val2")));
1:a991b64:     }
1:a991b64: 
1:a991b64:     @Test
1:a991b64:     public void testRangeSliceInclusionExclusion() throws Throwable
1:a991b64:     {
1:a991b64:         String keyspaceName = KEYSPACE1;
1:a991b64:         String cfName = CF_STANDARD1;
1:a991b64:         Keyspace keyspace = Keyspace.open(keyspaceName);
1:a991b64:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfName);
1:a991b64:         cfs.clearUnsafe();
1:a991b64: 
1:a991b64:         for (int i = 0; i < 10; ++i)
1:a991b64:         {
1:a991b64:             RowUpdateBuilder builder = new RowUpdateBuilder(cfs.metadata, 10, String.valueOf(i));
1:a991b64:             builder.clustering("c");
1:a991b64:             builder.add("val", String.valueOf(i));
1:a991b64:             builder.build().applyUnsafe();
1:a991b64:         }
1:a991b64: 
1:a991b64:         cfs.forceBlockingFlush();
1:a991b64: 
1:a991b64:         ColumnDefinition cDef = cfs.metadata.getColumnDefinition(ByteBufferUtil.bytes("val"));
1:a991b64: 
1:a991b64:         List<FilteredPartition> partitions;
1:a991b64: 
1:a991b64:         // Start and end inclusive
1:a991b64:         partitions = Util.getAll(Util.cmd(cfs).fromKeyIncl("2").toKeyIncl("7").build());
1:a991b64:         assertEquals(6, partitions.size());
1:a991b64:         assertTrue(partitions.get(0).iterator().next().getCell(cDef).value().equals(ByteBufferUtil.bytes("2")));
1:a991b64:         assertTrue(partitions.get(partitions.size() - 1).iterator().next().getCell(cDef).value().equals(ByteBufferUtil.bytes("7")));
1:a991b64: 
1:a991b64:         // Start and end excluded
1:a991b64:         partitions = Util.getAll(Util.cmd(cfs).fromKeyExcl("2").toKeyExcl("7").build());
1:a991b64:         assertEquals(4, partitions.size());
1:a991b64:         assertTrue(partitions.get(0).iterator().next().getCell(cDef).value().equals(ByteBufferUtil.bytes("3")));
1:a991b64:         assertTrue(partitions.get(partitions.size() - 1).iterator().next().getCell(cDef).value().equals(ByteBufferUtil.bytes("6")));
1:a991b64: 
1:a991b64:         // Start excluded, end included
1:a991b64:         partitions = Util.getAll(Util.cmd(cfs).fromKeyExcl("2").toKeyIncl("7").build());
1:a991b64:         assertEquals(5, partitions.size());
1:a991b64:         assertTrue(partitions.get(0).iterator().next().getCell(cDef).value().equals(ByteBufferUtil.bytes("3")));
1:a991b64:         assertTrue(partitions.get(partitions.size() - 1).iterator().next().getCell(cDef).value().equals(ByteBufferUtil.bytes("7")));
1:a991b64: 
1:a991b64:         // Start included, end excluded
1:a991b64:         partitions = Util.getAll(Util.cmd(cfs).fromKeyIncl("2").toKeyExcl("7").build());
1:a991b64:         assertEquals(5, partitions.size());
1:a991b64:         assertTrue(partitions.get(0).iterator().next().getCell(cDef).value().equals(ByteBufferUtil.bytes("2")));
1:a991b64:         assertTrue(partitions.get(partitions.size() - 1).iterator().next().getCell(cDef).value().equals(ByteBufferUtil.bytes("6")));
1:a991b64:     }
1:a991b64: 
1:a991b64:         // TODO: Port or remove, depending on what DataLimits.thriftLimits (per cell) looks like
1:a991b64: //    @Test
1:a991b64: //    public void testRangeSliceColumnsLimit() throws Throwable
1:a991b64: //    {
1:a991b64: //        String keyspaceName = KEYSPACE1;
1:a991b64: //        String cfName = CF_STANDARD1;
1:a991b64: //        Keyspace keyspace = Keyspace.open(keyspaceName);
1:a991b64: //        ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfName);
1:a991b64: //        cfs.clearUnsafe();
1:a991b64: //
1:a991b64: //        Cell[] cols = new Cell[5];
1:a991b64: //        for (int i = 0; i < 5; i++)
1:a991b64: //            cols[i] = column("c" + i, "value", 1);
1:a991b64: //
1:a991b64: //        putColsStandard(cfs, Util.dk("a"), cols[0], cols[1], cols[2], cols[3], cols[4]);
1:a991b64: //        putColsStandard(cfs, Util.dk("b"), cols[0], cols[1]);
1:a991b64: //        putColsStandard(cfs, Util.dk("c"), cols[0], cols[1], cols[2], cols[3]);
1:a991b64: //        cfs.forceBlockingFlush();
1:a991b64: //
1:a991b64: //        SlicePredicate sp = new SlicePredicate();
1:a991b64: //        sp.setSlice_range(new SliceRange());
1:a991b64: //        sp.getSlice_range().setCount(1);
1:a991b64: //        sp.getSlice_range().setStart(ArrayUtils.EMPTY_BYTE_ARRAY);
1:a991b64: //        sp.getSlice_range().setFinish(ArrayUtils.EMPTY_BYTE_ARRAY);
1:a991b64: //
1:a991b64: //        assertTotalColCount(cfs.getRangeSlice(Util.range("", ""),
1:a991b64: //                                              null,
1:a991b64: //                                              ThriftValidation.asIFilter(sp, cfs.metadata, null),
1:a991b64: //                                              3,
1:a991b64: //                                              System.currentTimeMillis(),
1:a991b64: //                                              true,
1:a991b64: //                                              false),
1:a991b64: //                            3);
1:a991b64: //        assertTotalColCount(cfs.getRangeSlice(Util.range("", ""),
1:a991b64: //                                              null,
1:a991b64: //                                              ThriftValidation.asIFilter(sp, cfs.metadata, null),
1:a991b64: //                                              5,
1:a991b64: //                                              System.currentTimeMillis(),
1:a991b64: //                                              true,
1:a991b64: //                                              false),
1:a991b64: //                            5);
1:a991b64: //        assertTotalColCount(cfs.getRangeSlice(Util.range("", ""),
1:a991b64: //                                              null,
1:a991b64: //                                              ThriftValidation.asIFilter(sp, cfs.metadata, null),
1:a991b64: //                                              8,
1:a991b64: //                                              System.currentTimeMillis(),
1:a991b64: //                                              true,
1:a991b64: //                                              false),
1:a991b64: //                            8);
1:a991b64: //        assertTotalColCount(cfs.getRangeSlice(Util.range("", ""),
1:a991b64: //                                              null,
1:a991b64: //                                              ThriftValidation.asIFilter(sp, cfs.metadata, null),
1:a991b64: //                                              10,
1:a991b64: //                                              System.currentTimeMillis(),
1:a991b64: //                                              true,
1:a991b64: //                                              false),
1:a991b64: //                            10);
1:a991b64: //        assertTotalColCount(cfs.getRangeSlice(Util.range("", ""),
1:a991b64: //                                              null,
1:a991b64: //                                              ThriftValidation.asIFilter(sp, cfs.metadata, null),
1:a991b64: //                                              100,
1:a991b64: //                                              System.currentTimeMillis(),
1:a991b64: //                                              true,
1:a991b64: //                                              false),
1:a991b64: //                            11);
1:a991b64: //
1:a991b64: //        // Check that when querying by name, we always include all names for a
1:a991b64: //        // gien row even if it means returning more columns than requested (this is necesseray for CQL)
1:a991b64: //        sp = new SlicePredicate();
1:a991b64: //        sp.setColumn_names(Arrays.asList(
1:a991b64: //            ByteBufferUtil.bytes("c0"),
1:a991b64: //            ByteBufferUtil.bytes("c1"),
1:a991b64: //            ByteBufferUtil.bytes("c2")
1:a991b64: //        ));
1:a991b64: //
1:a991b64: //        assertTotalColCount(cfs.getRangeSlice(Util.range("", ""),
1:a991b64: //                                              null,
1:a991b64: //                                              ThriftValidation.asIFilter(sp, cfs.metadata, null),
1:a991b64: //                                              1,
1:a991b64: //                                              System.currentTimeMillis(),
1:a991b64: //                                              true,
1:a991b64: //                                              false),
1:a991b64: //                            3);
1:a991b64: //        assertTotalColCount(cfs.getRangeSlice(Util.range("", ""),
1:a991b64: //                                              null,
1:a991b64: //                                              ThriftValidation.asIFilter(sp, cfs.metadata, null),
1:a991b64: //                                              4,
1:a991b64: //                                              System.currentTimeMillis(),
1:a991b64: //                                              true,
1:a991b64: //                                              false),
1:a991b64: //                            5);
1:a991b64: //        assertTotalColCount(cfs.getRangeSlice(Util.range("", ""),
1:a991b64: //                                              null,
1:a991b64: //                                              ThriftValidation.asIFilter(sp, cfs.metadata, null),
1:a991b64: //                                              5,
1:a991b64: //                                              System.currentTimeMillis(),
1:a991b64: //                                              true,
1:a991b64: //                                              false),
1:a991b64: //                            5);
1:a991b64: //        assertTotalColCount(cfs.getRangeSlice(Util.range("", ""),
1:a991b64: //                                              null,
1:a991b64: //                                              ThriftValidation.asIFilter(sp, cfs.metadata, null),
1:a991b64: //                                              6,
1:a991b64: //                                              System.currentTimeMillis(),
1:a991b64: //                                              true,
1:a991b64: //                                              false),
1:a991b64: //                            8);
1:a991b64: //        assertTotalColCount(cfs.getRangeSlice(Util.range("", ""),
1:a991b64: //                                              null,
1:a991b64: //                                              ThriftValidation.asIFilter(sp, cfs.metadata, null),
1:a991b64: //                                              100,
1:a991b64: //                                              System.currentTimeMillis(),
1:a991b64: //                                              true,
1:a991b64: //                                              false),
1:a991b64: //                            8);
1:a991b64: //    }
1:a991b64: 
1:a991b64:     // TODO: Port or remove, depending on what DataLimits.thriftLimits (per cell) looks like
1:a991b64: //    @Test
1:a991b64: //    public void testRangeSlicePaging() throws Throwable
1:a991b64: //    {
1:a991b64: //        String keyspaceName = KEYSPACE1;
1:a991b64: //        String cfName = CF_STANDARD1;
1:a991b64: //        Keyspace keyspace = Keyspace.open(keyspaceName);
1:a991b64: //        ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfName);
1:a991b64: //        cfs.clearUnsafe();
1:a991b64: //
1:a991b64: //        Cell[] cols = new Cell[4];
1:a991b64: //        for (int i = 0; i < 4; i++)
1:a991b64: //            cols[i] = column("c" + i, "value", 1);
1:a991b64: //
1:a991b64: //        DecoratedKey ka = Util.dk("a");
1:a991b64: //        DecoratedKey kb = Util.dk("b");
1:a991b64: //        DecoratedKey kc = Util.dk("c");
1:a991b64: //
1:a991b64: //        PartitionPosition min = Util.rp("");
1:a991b64: //
1:a991b64: //        putColsStandard(cfs, ka, cols[0], cols[1], cols[2], cols[3]);
1:a991b64: //        putColsStandard(cfs, kb, cols[0], cols[1], cols[2]);
1:a991b64: //        putColsStandard(cfs, kc, cols[0], cols[1], cols[2], cols[3]);
1:a991b64: //        cfs.forceBlockingFlush();
1:a991b64: //
1:a991b64: //        SlicePredicate sp = new SlicePredicate();
1:a991b64: //        sp.setSlice_range(new SliceRange());
1:a991b64: //        sp.getSlice_range().setCount(1);
1:a991b64: //        sp.getSlice_range().setStart(ArrayUtils.EMPTY_BYTE_ARRAY);
1:a991b64: //        sp.getSlice_range().setFinish(ArrayUtils.EMPTY_BYTE_ARRAY);
1:a991b64: //
1:a991b64: //        Collection<Row> rows;
1:a991b64: //        Row row, row1, row2;
1:a991b64: //        IDiskAtomFilter filter = ThriftValidation.asIFilter(sp, cfs.metadata, null);
1:a991b64: //
1:a991b64: //        rows = cfs.getRangeSlice(cfs.makeExtendedFilter(Util.range("", ""), filter, null, 3, true, true, System.currentTimeMillis()));
1:a991b64: //        assert rows.size() == 1 : "Expected 1 row, got " + toString(rows);
1:a991b64: //        row = rows.iterator().next();
1:a991b64: //        assertColumnNames(row, "c0", "c1", "c2");
1:a991b64: //
1:a991b64: //        sp.getSlice_range().setStart(ByteBufferUtil.getArray(ByteBufferUtil.bytes("c2")));
1:a991b64: //        filter = ThriftValidation.asIFilter(sp, cfs.metadata, null);
1:a991b64: //        rows = cfs.getRangeSlice(cfs.makeExtendedFilter(new Bounds<PartitionPosition>(ka, min), filter, null, 3, true, true, System.currentTimeMillis()));
1:a991b64: //        assert rows.size() == 2 : "Expected 2 rows, got " + toString(rows);
1:a991b64: //        Iterator<Row> iter = rows.iterator();
1:a991b64: //        row1 = iter.next();
1:a991b64: //        row2 = iter.next();
1:a991b64: //        assertColumnNames(row1, "c2", "c3");
1:a991b64: //        assertColumnNames(row2, "c0");
1:a991b64: //
1:a991b64: //        sp.getSlice_range().setStart(ByteBufferUtil.getArray(ByteBufferUtil.bytes("c0")));
1:a991b64: //        filter = ThriftValidation.asIFilter(sp, cfs.metadata, null);
1:a991b64: //        rows = cfs.getRangeSlice(cfs.makeExtendedFilter(new Bounds<PartitionPosition>(row2.key, min), filter, null, 3, true, true, System.currentTimeMillis()));
1:a991b64: //        assert rows.size() == 1 : "Expected 1 row, got " + toString(rows);
1:a991b64: //        row = rows.iterator().next();
1:a991b64: //        assertColumnNames(row, "c0", "c1", "c2");
1:a991b64: //
1:a991b64: //        sp.getSlice_range().setStart(ByteBufferUtil.getArray(ByteBufferUtil.bytes("c2")));
1:a991b64: //        filter = ThriftValidation.asIFilter(sp, cfs.metadata, null);
1:a991b64: //        rows = cfs.getRangeSlice(cfs.makeExtendedFilter(new Bounds<PartitionPosition>(row.key, min), filter, null, 3, true, true, System.currentTimeMillis()));
1:a991b64: //        assert rows.size() == 2 : "Expected 2 rows, got " + toString(rows);
1:a991b64: //        iter = rows.iterator();
1:a991b64: //        row1 = iter.next();
1:a991b64: //        row2 = iter.next();
1:a991b64: //        assertColumnNames(row1, "c2");
1:a991b64: //        assertColumnNames(row2, "c0", "c1");
1:a991b64: //
1:a991b64: //        // Paging within bounds
1:a991b64: //        SliceQueryFilter sf = new SliceQueryFilter(cellname("c1"),
1:a991b64: //                                                   cellname("c2"),
1:a991b64: //                                                   false,
1:a991b64: //                                                   0);
1:a991b64: //        rows = cfs.getRangeSlice(cfs.makeExtendedFilter(new Bounds<PartitionPosition>(ka, kc), sf, cellname("c2"), cellname("c1"), null, 2, true, System.currentTimeMillis()));
1:a991b64: //        assert rows.size() == 2 : "Expected 2 rows, got " + toString(rows);
1:a991b64: //        iter = rows.iterator();
1:a991b64: //        row1 = iter.next();
1:a991b64: //        row2 = iter.next();
1:a991b64: //        assertColumnNames(row1, "c2");
1:a991b64: //        assertColumnNames(row2, "c1");
1:a991b64: //
1:a991b64: //        rows = cfs.getRangeSlice(cfs.makeExtendedFilter(new Bounds<PartitionPosition>(kb, kc), sf, cellname("c1"), cellname("c1"), null, 10, true, System.currentTimeMillis()));
1:a991b64: //        assert rows.size() == 2 : "Expected 2 rows, got " + toString(rows);
1:a991b64: //        iter = rows.iterator();
1:a991b64: //        row1 = iter.next();
1:a991b64: //        row2 = iter.next();
1:a991b64: //        assertColumnNames(row1, "c1", "c2");
1:a991b64: //        assertColumnNames(row2, "c1");
1:a991b64: //    }
1:a991b64: }
1:a991b64: 
============================================================================
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:31e3f61
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.schema.KeyspaceParams;
/////////////////////////////////////////////////////////////////////////
1:                                     KeyspaceParams.simple(1),
1:                                     KeyspaceParams.simple(1),
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: /*
1: * Licensed to the Apache Software Foundation (ASF) under one
1: * or more contributor license agreements.  See the NOTICE file
1: * distributed with this work for additional information
1: * regarding copyright ownership.  The ASF licenses this file
1: * to you under the Apache License, Version 2.0 (the
1: * "License"); you may not use this file except in compliance
1: * with the License.  You may obtain a copy of the License at
1: *
1: *    http://www.apache.org/licenses/LICENSE-2.0
1: *
1: * Unless required by applicable law or agreed to in writing,
1: * software distributed under the License is distributed on an
1: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1: * KIND, either express or implied.  See the License for the
1: * specific language governing permissions and limitations
1: * under the License.
1: */
1: package org.apache.cassandra.db;
1: 
0: import java.io.File;
1: import java.math.BigInteger;
1: import java.nio.ByteBuffer;
1: import java.nio.charset.CharacterCodingException;
0: import java.util.Collection;
1: import java.util.List;
1: 
1: import org.junit.BeforeClass;
1: import org.junit.Test;
0: import com.google.common.collect.Iterators;
1: 
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertTrue;
1: 
1: import org.apache.cassandra.*;
1: import org.apache.cassandra.config.ColumnDefinition;
0: import org.apache.cassandra.config.KSMetaData;
1: import org.apache.cassandra.db.rows.Row;
0: import org.apache.cassandra.db.rows.RowIterator;
1: import org.apache.cassandra.db.marshal.IntegerType;
1: import org.apache.cassandra.db.partitions.*;
1: import org.apache.cassandra.exceptions.ConfigurationException;
0: import org.apache.cassandra.io.sstable.Component;
0: import org.apache.cassandra.io.sstable.format.SSTableReader;
0: import org.apache.cassandra.locator.SimpleStrategy;
1: import org.apache.cassandra.utils.ByteBufferUtil;
0: import org.apache.cassandra.utils.FBUtilities;
1: 
1: public class PartitionRangeReadTest
1: {
1:     public static final String KEYSPACE1 = "PartitionRangeReadTest1";
1:     public static final String KEYSPACE2 = "PartitionRangeReadTest2";
1:     public static final String CF_STANDARD1 = "Standard1";
1:     public static final String CF_STANDARDINT = "StandardInteger1";
1: 
1:     @BeforeClass
1:     public static void defineSchema() throws ConfigurationException
1:     {
1:         SchemaLoader.prepareServer();
1:         SchemaLoader.createKeyspace(KEYSPACE1,
0:                                     SimpleStrategy.class,
0:                                     KSMetaData.optsWithRF(1),
1:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD1),
1:                                     SchemaLoader.denseCFMD(KEYSPACE1, CF_STANDARDINT, IntegerType.instance));
1:         SchemaLoader.createKeyspace(KEYSPACE2,
0:                                     SimpleStrategy.class,
0:                                     KSMetaData.optsWithRF(1),
1:                                     SchemaLoader.standardCFMD(KEYSPACE2, CF_STANDARD1));
1:     }
1: 
1:     @Test
1:     public void testInclusiveBounds()
1:     {
1:         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE2).getColumnFamilyStore(CF_STANDARD1);
1:         new RowUpdateBuilder(cfs.metadata, 0, ByteBufferUtil.bytes("key1"))
1:                 .clustering("cc1")
1:                 .add("val", "asdf").build().applyUnsafe();
1:         new RowUpdateBuilder(cfs.metadata, 0, ByteBufferUtil.bytes("key2"))
1:                 .clustering("cc2")
1:                 .add("val", "asdf").build().applyUnsafe();
1: 
1:         assertEquals(2, Util.getAll(Util.cmd(cfs).fromIncl("cc1").toIncl("cc2").build()).size());
1:     }
1: 
1:     @Test
1:     public void testCassandra6778() throws CharacterCodingException
1:     {
1:         String cfname = CF_STANDARDINT;
1:         Keyspace keyspace = Keyspace.open(KEYSPACE1);
1:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfname);
1:         cfs.truncateBlocking();
1: 
1:         ByteBuffer col = ByteBufferUtil.bytes("val");
1:         ColumnDefinition cDef = cfs.metadata.getColumnDefinition(col);
1: 
1:         // insert two columns that represent the same integer but have different binary forms (the
1:         // second one is padded with extra zeros)
1:         new RowUpdateBuilder(cfs.metadata, 0, "k1")
1:                 .clustering(new BigInteger(new byte[]{1}))
1:                 .add("val", "val1")
1:                 .build()
1:                 .applyUnsafe();
1:         cfs.forceBlockingFlush();
1: 
1:         new RowUpdateBuilder(cfs.metadata, 1, "k1")
1:                 .clustering(new BigInteger(new byte[]{0, 0, 1}))
1:                 .add("val", "val2")
1:                 .build()
1:                 .applyUnsafe();
1:         cfs.forceBlockingFlush();
1: 
1:         // fetch by the first column name; we should get the second version of the column value
1:         Row row = Util.getOnlyRow(Util.cmd(cfs, "k1").includeRow(new BigInteger(new byte[]{1})).build());
1:         assertTrue(row.getCell(cDef).value().equals(ByteBufferUtil.bytes("val2")));
1: 
1:         // fetch by the second column name; we should get the second version of the column value
1:         row = Util.getOnlyRow(Util.cmd(cfs, "k1").includeRow(new BigInteger(new byte[]{0, 0, 1})).build());
1:         assertTrue(row.getCell(cDef).value().equals(ByteBufferUtil.bytes("val2")));
1:     }
1: 
1:     @Test
1:     public void testRangeSliceInclusionExclusion() throws Throwable
1:     {
1:         String keyspaceName = KEYSPACE1;
1:         String cfName = CF_STANDARD1;
1:         Keyspace keyspace = Keyspace.open(keyspaceName);
1:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfName);
1:         cfs.clearUnsafe();
1: 
1:         for (int i = 0; i < 10; ++i)
1:         {
1:             RowUpdateBuilder builder = new RowUpdateBuilder(cfs.metadata, 10, String.valueOf(i));
1:             builder.clustering("c");
1:             builder.add("val", String.valueOf(i));
1:             builder.build().applyUnsafe();
1:         }
1: 
1:         cfs.forceBlockingFlush();
1: 
1:         ColumnDefinition cDef = cfs.metadata.getColumnDefinition(ByteBufferUtil.bytes("val"));
1: 
1:         List<FilteredPartition> partitions;
1: 
1:         // Start and end inclusive
1:         partitions = Util.getAll(Util.cmd(cfs).fromKeyIncl("2").toKeyIncl("7").build());
1:         assertEquals(6, partitions.size());
1:         assertTrue(partitions.get(0).iterator().next().getCell(cDef).value().equals(ByteBufferUtil.bytes("2")));
1:         assertTrue(partitions.get(partitions.size() - 1).iterator().next().getCell(cDef).value().equals(ByteBufferUtil.bytes("7")));
1: 
1:         // Start and end excluded
1:         partitions = Util.getAll(Util.cmd(cfs).fromKeyExcl("2").toKeyExcl("7").build());
1:         assertEquals(4, partitions.size());
1:         assertTrue(partitions.get(0).iterator().next().getCell(cDef).value().equals(ByteBufferUtil.bytes("3")));
1:         assertTrue(partitions.get(partitions.size() - 1).iterator().next().getCell(cDef).value().equals(ByteBufferUtil.bytes("6")));
1: 
1:         // Start excluded, end included
1:         partitions = Util.getAll(Util.cmd(cfs).fromKeyExcl("2").toKeyIncl("7").build());
1:         assertEquals(5, partitions.size());
1:         assertTrue(partitions.get(0).iterator().next().getCell(cDef).value().equals(ByteBufferUtil.bytes("3")));
1:         assertTrue(partitions.get(partitions.size() - 1).iterator().next().getCell(cDef).value().equals(ByteBufferUtil.bytes("7")));
1: 
1:         // Start included, end excluded
1:         partitions = Util.getAll(Util.cmd(cfs).fromKeyIncl("2").toKeyExcl("7").build());
1:         assertEquals(5, partitions.size());
1:         assertTrue(partitions.get(0).iterator().next().getCell(cDef).value().equals(ByteBufferUtil.bytes("2")));
1:         assertTrue(partitions.get(partitions.size() - 1).iterator().next().getCell(cDef).value().equals(ByteBufferUtil.bytes("6")));
1:     }
1: 
1:         // TODO: Port or remove, depending on what DataLimits.thriftLimits (per cell) looks like
1: //    @Test
1: //    public void testRangeSliceColumnsLimit() throws Throwable
1: //    {
1: //        String keyspaceName = KEYSPACE1;
1: //        String cfName = CF_STANDARD1;
1: //        Keyspace keyspace = Keyspace.open(keyspaceName);
1: //        ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfName);
1: //        cfs.clearUnsafe();
1: //
1: //        Cell[] cols = new Cell[5];
1: //        for (int i = 0; i < 5; i++)
1: //            cols[i] = column("c" + i, "value", 1);
1: //
1: //        putColsStandard(cfs, Util.dk("a"), cols[0], cols[1], cols[2], cols[3], cols[4]);
1: //        putColsStandard(cfs, Util.dk("b"), cols[0], cols[1]);
1: //        putColsStandard(cfs, Util.dk("c"), cols[0], cols[1], cols[2], cols[3]);
1: //        cfs.forceBlockingFlush();
1: //
1: //        SlicePredicate sp = new SlicePredicate();
1: //        sp.setSlice_range(new SliceRange());
1: //        sp.getSlice_range().setCount(1);
1: //        sp.getSlice_range().setStart(ArrayUtils.EMPTY_BYTE_ARRAY);
1: //        sp.getSlice_range().setFinish(ArrayUtils.EMPTY_BYTE_ARRAY);
1: //
1: //        assertTotalColCount(cfs.getRangeSlice(Util.range("", ""),
1: //                                              null,
1: //                                              ThriftValidation.asIFilter(sp, cfs.metadata, null),
1: //                                              3,
1: //                                              System.currentTimeMillis(),
1: //                                              true,
1: //                                              false),
1: //                            3);
1: //        assertTotalColCount(cfs.getRangeSlice(Util.range("", ""),
1: //                                              null,
1: //                                              ThriftValidation.asIFilter(sp, cfs.metadata, null),
1: //                                              5,
1: //                                              System.currentTimeMillis(),
1: //                                              true,
1: //                                              false),
1: //                            5);
1: //        assertTotalColCount(cfs.getRangeSlice(Util.range("", ""),
1: //                                              null,
1: //                                              ThriftValidation.asIFilter(sp, cfs.metadata, null),
1: //                                              8,
1: //                                              System.currentTimeMillis(),
1: //                                              true,
1: //                                              false),
1: //                            8);
1: //        assertTotalColCount(cfs.getRangeSlice(Util.range("", ""),
1: //                                              null,
1: //                                              ThriftValidation.asIFilter(sp, cfs.metadata, null),
1: //                                              10,
1: //                                              System.currentTimeMillis(),
1: //                                              true,
1: //                                              false),
1: //                            10);
1: //        assertTotalColCount(cfs.getRangeSlice(Util.range("", ""),
1: //                                              null,
1: //                                              ThriftValidation.asIFilter(sp, cfs.metadata, null),
1: //                                              100,
1: //                                              System.currentTimeMillis(),
1: //                                              true,
1: //                                              false),
1: //                            11);
1: //
1: //        // Check that when querying by name, we always include all names for a
1: //        // gien row even if it means returning more columns than requested (this is necesseray for CQL)
1: //        sp = new SlicePredicate();
1: //        sp.setColumn_names(Arrays.asList(
1: //            ByteBufferUtil.bytes("c0"),
1: //            ByteBufferUtil.bytes("c1"),
1: //            ByteBufferUtil.bytes("c2")
1: //        ));
1: //
1: //        assertTotalColCount(cfs.getRangeSlice(Util.range("", ""),
1: //                                              null,
1: //                                              ThriftValidation.asIFilter(sp, cfs.metadata, null),
1: //                                              1,
1: //                                              System.currentTimeMillis(),
1: //                                              true,
1: //                                              false),
1: //                            3);
1: //        assertTotalColCount(cfs.getRangeSlice(Util.range("", ""),
1: //                                              null,
1: //                                              ThriftValidation.asIFilter(sp, cfs.metadata, null),
1: //                                              4,
1: //                                              System.currentTimeMillis(),
1: //                                              true,
1: //                                              false),
1: //                            5);
1: //        assertTotalColCount(cfs.getRangeSlice(Util.range("", ""),
1: //                                              null,
1: //                                              ThriftValidation.asIFilter(sp, cfs.metadata, null),
1: //                                              5,
1: //                                              System.currentTimeMillis(),
1: //                                              true,
1: //                                              false),
1: //                            5);
1: //        assertTotalColCount(cfs.getRangeSlice(Util.range("", ""),
1: //                                              null,
1: //                                              ThriftValidation.asIFilter(sp, cfs.metadata, null),
1: //                                              6,
1: //                                              System.currentTimeMillis(),
1: //                                              true,
1: //                                              false),
1: //                            8);
1: //        assertTotalColCount(cfs.getRangeSlice(Util.range("", ""),
1: //                                              null,
1: //                                              ThriftValidation.asIFilter(sp, cfs.metadata, null),
1: //                                              100,
1: //                                              System.currentTimeMillis(),
1: //                                              true,
1: //                                              false),
1: //                            8);
1: //    }
1: 
1:     // TODO: Port or remove, depending on what DataLimits.thriftLimits (per cell) looks like
1: //    @Test
1: //    public void testRangeSlicePaging() throws Throwable
1: //    {
1: //        String keyspaceName = KEYSPACE1;
1: //        String cfName = CF_STANDARD1;
1: //        Keyspace keyspace = Keyspace.open(keyspaceName);
1: //        ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfName);
1: //        cfs.clearUnsafe();
1: //
1: //        Cell[] cols = new Cell[4];
1: //        for (int i = 0; i < 4; i++)
1: //            cols[i] = column("c" + i, "value", 1);
1: //
1: //        DecoratedKey ka = Util.dk("a");
1: //        DecoratedKey kb = Util.dk("b");
1: //        DecoratedKey kc = Util.dk("c");
1: //
1: //        PartitionPosition min = Util.rp("");
1: //
1: //        putColsStandard(cfs, ka, cols[0], cols[1], cols[2], cols[3]);
1: //        putColsStandard(cfs, kb, cols[0], cols[1], cols[2]);
1: //        putColsStandard(cfs, kc, cols[0], cols[1], cols[2], cols[3]);
1: //        cfs.forceBlockingFlush();
1: //
1: //        SlicePredicate sp = new SlicePredicate();
1: //        sp.setSlice_range(new SliceRange());
1: //        sp.getSlice_range().setCount(1);
1: //        sp.getSlice_range().setStart(ArrayUtils.EMPTY_BYTE_ARRAY);
1: //        sp.getSlice_range().setFinish(ArrayUtils.EMPTY_BYTE_ARRAY);
1: //
1: //        Collection<Row> rows;
1: //        Row row, row1, row2;
1: //        IDiskAtomFilter filter = ThriftValidation.asIFilter(sp, cfs.metadata, null);
1: //
1: //        rows = cfs.getRangeSlice(cfs.makeExtendedFilter(Util.range("", ""), filter, null, 3, true, true, System.currentTimeMillis()));
1: //        assert rows.size() == 1 : "Expected 1 row, got " + toString(rows);
1: //        row = rows.iterator().next();
1: //        assertColumnNames(row, "c0", "c1", "c2");
1: //
1: //        sp.getSlice_range().setStart(ByteBufferUtil.getArray(ByteBufferUtil.bytes("c2")));
1: //        filter = ThriftValidation.asIFilter(sp, cfs.metadata, null);
1: //        rows = cfs.getRangeSlice(cfs.makeExtendedFilter(new Bounds<PartitionPosition>(ka, min), filter, null, 3, true, true, System.currentTimeMillis()));
1: //        assert rows.size() == 2 : "Expected 2 rows, got " + toString(rows);
1: //        Iterator<Row> iter = rows.iterator();
1: //        row1 = iter.next();
1: //        row2 = iter.next();
1: //        assertColumnNames(row1, "c2", "c3");
1: //        assertColumnNames(row2, "c0");
1: //
1: //        sp.getSlice_range().setStart(ByteBufferUtil.getArray(ByteBufferUtil.bytes("c0")));
1: //        filter = ThriftValidation.asIFilter(sp, cfs.metadata, null);
1: //        rows = cfs.getRangeSlice(cfs.makeExtendedFilter(new Bounds<PartitionPosition>(row2.key, min), filter, null, 3, true, true, System.currentTimeMillis()));
1: //        assert rows.size() == 1 : "Expected 1 row, got " + toString(rows);
1: //        row = rows.iterator().next();
1: //        assertColumnNames(row, "c0", "c1", "c2");
1: //
1: //        sp.getSlice_range().setStart(ByteBufferUtil.getArray(ByteBufferUtil.bytes("c2")));
1: //        filter = ThriftValidation.asIFilter(sp, cfs.metadata, null);
1: //        rows = cfs.getRangeSlice(cfs.makeExtendedFilter(new Bounds<PartitionPosition>(row.key, min), filter, null, 3, true, true, System.currentTimeMillis()));
1: //        assert rows.size() == 2 : "Expected 2 rows, got " + toString(rows);
1: //        iter = rows.iterator();
1: //        row1 = iter.next();
1: //        row2 = iter.next();
1: //        assertColumnNames(row1, "c2");
1: //        assertColumnNames(row2, "c0", "c1");
1: //
1: //        // Paging within bounds
1: //        SliceQueryFilter sf = new SliceQueryFilter(cellname("c1"),
1: //                                                   cellname("c2"),
1: //                                                   false,
1: //                                                   0);
1: //        rows = cfs.getRangeSlice(cfs.makeExtendedFilter(new Bounds<PartitionPosition>(ka, kc), sf, cellname("c2"), cellname("c1"), null, 2, true, System.currentTimeMillis()));
1: //        assert rows.size() == 2 : "Expected 2 rows, got " + toString(rows);
1: //        iter = rows.iterator();
1: //        row1 = iter.next();
1: //        row2 = iter.next();
1: //        assertColumnNames(row1, "c2");
1: //        assertColumnNames(row2, "c1");
1: //
1: //        rows = cfs.getRangeSlice(cfs.makeExtendedFilter(new Bounds<PartitionPosition>(kb, kc), sf, cellname("c1"), cellname("c1"), null, 10, true, System.currentTimeMillis()));
1: //        assert rows.size() == 2 : "Expected 2 rows, got " + toString(rows);
1: //        iter = rows.iterator();
1: //        row1 = iter.next();
1: //        row2 = iter.next();
1: //        assertColumnNames(row1, "c1", "c2");
1: //        assertColumnNames(row2, "c1");
1: //    }
1: }
1: 
============================================================================