1:5151169: /*
1:5151169:  * Licensed to the Apache Software Foundation (ASF) under one
1:5151169:  * or more contributor license agreements.  See the NOTICE file
1:5151169:  * distributed with this work for additional information
1:5151169:  * regarding copyright ownership.  The ASF licenses this file
1:5151169:  * to you under the Apache License, Version 2.0 (the
1:5151169:  * "License"); you may not use this file except in compliance
1:5151169:  * with the License.  You may obtain a copy of the License at
2:5151169:  *
1:5151169:  *     http://www.apache.org/licenses/LICENSE-2.0
1:5151169:  *
1:5151169:  * Unless required by applicable law or agreed to in writing, software
1:5151169:  * distributed under the License is distributed on an "AS IS" BASIS,
1:5151169:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:5151169:  * See the License for the specific language governing permissions and
1:5151169:  * limitations under the License.
3:5151169:  */
1:5151169: package org.apache.cassandra.streaming;
1:5151169: 
1:16499ca: import java.io.BufferedOutputStream;
1:5151169: import java.io.IOException;
1:5151169: import java.net.Socket;
1:5151169: import java.net.SocketException;
1:41ffca1: import java.nio.ByteBuffer;
1:5151169: import java.nio.channels.Channels;
1:5151169: import java.nio.channels.ReadableByteChannel;
1:5151169: import java.nio.channels.WritableByteChannel;
1:5151169: import java.util.Collection;
1:5151169: import java.util.Comparator;
1:5151169: import java.util.concurrent.PriorityBlockingQueue;
1:5151169: import java.util.concurrent.TimeUnit;
1:67ccdab: import java.util.concurrent.atomic.AtomicReference;
1:5151169: 
1:67ccdab: import com.google.common.util.concurrent.Futures;
1:67ccdab: import com.google.common.util.concurrent.ListenableFuture;
1:67ccdab: import com.google.common.util.concurrent.SettableFuture;
1:5151169: 
1:5151169: import org.slf4j.Logger;
1:5151169: import org.slf4j.LoggerFactory;
1:5151169: 
1:1e92ce4: import io.netty.util.concurrent.FastThreadLocalThread;
1:16499ca: import org.apache.cassandra.io.util.DataOutputStreamPlus;
1:16499ca: import org.apache.cassandra.io.util.BufferedDataOutputStreamPlus;
1:16499ca: import org.apache.cassandra.io.util.WrappedDataOutputStreamPlus;
1:2811f15: import org.apache.cassandra.net.IncomingStreamingConnection;
1:5151169: import org.apache.cassandra.streaming.messages.StreamInitMessage;
1:5151169: import org.apache.cassandra.streaming.messages.StreamMessage;
1:67ccdab: import org.apache.cassandra.utils.FBUtilities;
1:1452134: import org.apache.cassandra.utils.JVMStabilityInspector;
1:5151169: 
3:5151169: /**
1:5151169:  * ConnectionHandler manages incoming/outgoing message exchange for the {@link StreamSession}.
1:5151169:  *
1:5151169:  * <p>
1:5151169:  * Internally, ConnectionHandler manages thread to receive incoming {@link StreamMessage} and thread to
1:5151169:  * send outgoing message. Messages are encoded/decoded on those thread and handed to
1:5151169:  * {@link StreamSession#messageReceived(org.apache.cassandra.streaming.messages.StreamMessage)}.
1:5151169:  */
1:5151169: public class ConnectionHandler
4:5151169: {
1:5151169:     private static final Logger logger = LoggerFactory.getLogger(ConnectionHandler.class);
1:5151169: 
1:5151169:     private final StreamSession session;
1:8af61ac:     private int incomingSocketTimeout;
1:5151169: 
1:5151169:     private IncomingMessageHandler incoming;
1:5151169:     private OutgoingMessageHandler outgoing;
1:5151169: 
1:8af61ac:     ConnectionHandler(StreamSession session, int incomingSocketTimeout)
1:5151169:     {
2:5151169:         this.session = session;
1:8af61ac:         this.incoming = new IncomingMessageHandler(session, incomingSocketTimeout);
1:41ffca1:         this.outgoing = new OutgoingMessageHandler(session);
4:5151169:     }
1:5151169: 
1:d881024:     /**
1:d881024:      * Set up incoming message handler and initiate streaming.
1:d881024:      *
1:d881024:      * This method is called once on initiator.
1:d881024:      *
1:d881024:      * @throws IOException
1:d881024:      */
1:7aafe05:     @SuppressWarnings("resource")
1:d881024:     public void initiate() throws IOException
1:2811f15:     {
1:d881024:         logger.debug("[Stream #{}] Sending stream init for incoming stream", session.planId());
1:563cea1:         Socket incomingSocket = session.createConnection();
1:8af61ac:         incoming.start(incomingSocket, StreamMessage.CURRENT_VERSION, true);
1:8af61ac:         incomingSocket.shutdownOutput();
1:5151169: 
1:d881024:         logger.debug("[Stream #{}] Sending stream init for outgoing stream", session.planId());
1:563cea1:         Socket outgoingSocket = session.createConnection();
1:8af61ac:         outgoing.start(outgoingSocket, StreamMessage.CURRENT_VERSION, true);
1:8af61ac:         outgoingSocket.shutdownInput();
1:5151169:     }
1:5151169: 
1:d881024:     /**
1:d881024:      * Set up outgoing message handler on receiving side.
1:d881024:      *
1:2811f15:      * @param connection Incoming connection to use for {@link OutgoingMessageHandler}.
1:d881024:      * @param version Streaming message version
1:d881024:      * @throws IOException
1:d881024:      */
1:2811f15:     public void initiateOnReceivingSide(IncomingStreamingConnection connection, boolean isForOutgoing, int version) throws IOException
1:5151169:     {
1:d881024:         if (isForOutgoing)
1:8af61ac:         {
1:2811f15:             outgoing.start(connection, version);
1:8af61ac:             outgoing.socket.shutdownInput();
1:8af61ac:         }
1:d881024:         else
1:8af61ac:         {
1:2811f15:             incoming.start(connection, version);
1:8af61ac:             incoming.socket.shutdownOutput();
1:8af61ac:         }
1:d881024:     }
1:5151169: 
1:67ccdab:     public ListenableFuture<?> close()
1:d881024:     {
1:1e73b33:         logger.debug("[Stream #{}] Closing stream connection handler on {}", session.planId(), session.peer);
1:5151169: 
1:561000a:         ListenableFuture<?> inClosed = closeIncoming();
1:561000a:         ListenableFuture<?> outClosed = closeOutgoing();
1:5151169: 
1:67ccdab:         return Futures.allAsList(inClosed, outClosed);
1:d881024:     }
1:5151169: 
1:561000a:     public ListenableFuture<?> closeOutgoing()
1:561000a:     {
1:561000a:         return outgoing == null ? Futures.immediateFuture(null) : outgoing.close();
1:561000a:     }
1:561000a: 
1:561000a:     public ListenableFuture<?> closeIncoming()
1:561000a:     {
1:561000a:         return incoming == null ? Futures.immediateFuture(null) : incoming.close();
1:561000a:     }
1:561000a: 
1:5151169:     /**
1:5151169:      * Enqueue messages to be sent.
1:5151169:      *
1:5151169:      * @param messages messages to send
1:5151169:      */
1:5151169:     public void sendMessages(Collection<? extends StreamMessage> messages)
1:d881024:     {
1:5151169:         for (StreamMessage message : messages)
1:5151169:             sendMessage(message);
1:5151169:     }
1:5151169: 
1:5151169:     public void sendMessage(StreamMessage message)
1:5151169:     {
1:67ccdab:         if (outgoing.isClosed())
1:67ccdab:             throw new RuntimeException("Outgoing stream handler has been closed");
1:5151169: 
1:5151169:         outgoing.enqueue(message);
1:5151169:     }
1:5151169: 
1:d881024:     /**
1:d881024:      * @return true if outgoing connection is opened and ready to send messages
1:d881024:      */
1:d881024:     public boolean isOutgoingConnected()
1:d881024:     {
1:d881024:         return outgoing != null && !outgoing.isClosed();
1:d881024:     }
1:d881024: 
1:5151169:     abstract static class MessageHandler implements Runnable
1:5151169:     {
1:5151169:         protected final StreamSession session;
1:5151169: 
1:41ffca1:         protected int protocolVersion;
1:8af61ac:         private final boolean isOutgoingHandler;
1:41ffca1:         protected Socket socket;
1:1e92ce4: 
1:67ccdab:         private final AtomicReference<SettableFuture<?>> closeFuture = new AtomicReference<>();
1:2811f15:         private IncomingStreamingConnection incomingConnection;
1:67ccdab: 
1:8af61ac:         protected MessageHandler(StreamSession session, boolean isOutgoingHandler)
1:5151169:         {
1:5151169:             this.session = session;
1:8af61ac:             this.isOutgoingHandler = isOutgoingHandler;
1:5151169:         }
1:67ccdab: 
1:67ccdab:         protected abstract String name();
1:67ccdab: 
1:7aafe05:         @SuppressWarnings("resource")
1:16499ca:         protected static DataOutputStreamPlus getWriteChannel(Socket socket) throws IOException
1:5151169:         {
1:67ccdab:             WritableByteChannel out = socket.getChannel();
2:5151169:             // socket channel is null when encrypted(SSL)
1:75508ec:             if (out == null)
1:16499ca:                 return new WrappedDataOutputStreamPlus(new BufferedOutputStream(socket.getOutputStream()));
1:16499ca:             return new BufferedDataOutputStreamPlus(out);
1:5151169:         }
1:5151169: 
1:41ffca1:         protected static ReadableByteChannel getReadChannel(Socket socket) throws IOException
1:5151169:         {
1:561000a:             //we do this instead of socket.getChannel() so socketSoTimeout is respected
1:561000a:             return Channels.newChannel(socket.getInputStream());
1:5151169:         }
1:5151169: 
1:7aafe05:         @SuppressWarnings("resource")
1:8af61ac:         private void sendInitMessage() throws IOException
1:5151169:         {
1:44fa2cd:             StreamInitMessage message = new StreamInitMessage(
1:44fa2cd:                     FBUtilities.getBroadcastAddress(),
1:44fa2cd:                     session.sessionIndex(),
1:44fa2cd:                     session.planId(),
1:44fa2cd:                     session.description(),
1:8af61ac:                     !isOutgoingHandler,
1:a5b90f1:                     session.keepSSTableLevel(),
1:a5b90f1:                     session.isIncremental());
1:41ffca1:             ByteBuffer messageBuf = message.createMessage(false, protocolVersion);
1:16499ca:             DataOutputStreamPlus out = getWriteChannel(socket);
1:16499ca:             out.write(messageBuf);
1:16499ca:             out.flush();
1:5151169:         }
1:5151169: 
1:8af61ac:         public void start(IncomingStreamingConnection connection, int protocolVersion) throws IOException
1:5151169:         {
1:2811f15:             this.incomingConnection = connection;
1:8af61ac:             start(connection.socket, protocolVersion, false);
1:2811f15:         }
1:2811f15: 
1:8af61ac:         public void start(Socket socket, int protocolVersion, boolean initiator) throws IOException
1:5151169:         {
1:41ffca1:             this.socket = socket;
1:41ffca1:             this.protocolVersion = protocolVersion;
1:8af61ac:             if (initiator)
1:8af61ac:                 sendInitMessage();
1:41ffca1: 
1:1e92ce4:             new FastThreadLocalThread(this, name() + "-" + socket.getRemoteSocketAddress()).start();
1:5151169:         }
1:5151169: 
1:67ccdab:         public ListenableFuture<?> close()
1:5151169:         {
1:67ccdab:             // Assume it wasn't closed. Not a huge deal if we create a future on a race
1:67ccdab:             SettableFuture<?> future = SettableFuture.create();
1:67ccdab:             return closeFuture.compareAndSet(null, future)
1:67ccdab:                  ? future
1:67ccdab:                  : closeFuture.get();
1:5151169:         }
1:5151169: 
1:67ccdab:         public boolean isClosed()
1:5151169:         {
1:67ccdab:             return closeFuture.get() != null;
1:5151169:         }
1:5151169: 
1:67ccdab:         protected void signalCloseDone()
1:5151169:         {
1:e983590:             if (!isClosed())
1:00e7ecf:                 close();
1:00e7ecf: 
1:67ccdab:             closeFuture.get().set(null);
1:5151169: 
1:67ccdab:             // We can now close the socket
1:2811f15:             if (incomingConnection != null)
1:5151169:             {
1:2811f15:                 //this will close the underlying socket and remove it
1:2811f15:                 //from active MessagingService connections (CASSANDRA-11854)
1:2811f15:                 incomingConnection.close();
1:5151169:             }
1:2811f15:             else
1:5151169:             {
1:2811f15:                 //this is an outgoing connection not registered in the MessagingService
1:2811f15:                 //so we can close the socket directly
1:2811f15:                 try
1:2811f15:                 {
1:2811f15:                     socket.close();
1:2811f15:                 }
1:2811f15:                 catch (IOException e)
1:2811f15:                 {
1:2811f15:                     // Erroring out while closing shouldn't happen but is not really a big deal, so just log
1:2811f15:                     // it at DEBUG and ignore otherwise.
1:2811f15:                     logger.debug("Unexpected error while closing streaming connection", e);
1:2811f15:                 }
1:5151169:             }
1:5151169:         }
1:5151169:     }
1:5151169: 
1:5151169:     /**
1:5151169:      * Incoming streaming message handler
1:5151169:      */
1:5151169:     static class IncomingMessageHandler extends MessageHandler
1:5151169:     {
1:8af61ac:         private final int socketTimeout;
1:8af61ac: 
1:8af61ac:         IncomingMessageHandler(StreamSession session, int socketTimeout)
1:5151169:         {
1:8af61ac:             super(session, false);
1:8af61ac:             this.socketTimeout = socketTimeout;
1:8af61ac:         }
1:8af61ac: 
1:8af61ac:         @Override
1:8af61ac:         public void start(Socket socket, int version, boolean initiator) throws IOException
1:8af61ac:         {
1:8af61ac:             try
1:8af61ac:             {
1:8af61ac:                 socket.setSoTimeout(socketTimeout);
1:8af61ac:             }
1:8af61ac:             catch (SocketException e)
1:8af61ac:             {
1:8af61ac:                 logger.warn("Could not set incoming socket timeout to {}", socketTimeout, e);
1:8af61ac:             }
1:8af61ac:             super.start(socket, version, initiator);
1:5151169:         }
1:5151169: 
1:67ccdab:         protected String name()
1:5151169:         {
1:67ccdab:             return "STREAM-IN";
1:5151169:         }
1:5151169: 
1:7aafe05:         @SuppressWarnings("resource")
1:5151169:         public void run()
1:5151169:         {
1:41ffca1:             try
1:5151169:             {
1:41ffca1:                 ReadableByteChannel in = getReadChannel(socket);
1:41ffca1:                 while (!isClosed())
1:5151169:                 {
1:5151169:                     // receive message
1:5151169:                     StreamMessage message = StreamMessage.deserialize(in, protocolVersion, session);
1:58a0079:                     logger.debug("[Stream #{}] Received {}", session.planId(), message);
1:67ccdab:                     // Might be null if there is an error during streaming (see FileMessage.deserialize). It's ok
1:67ccdab:                     // to ignore here since we'll have asked for a retry.
1:67ccdab:                     if (message != null)
1:5151169:                     {
1:5151169:                         session.messageReceived(message);
1:41ffca1:                     }
1:5151169:                 }
1:5151169:             }
1:1452134:             catch (Throwable t)
1:41ffca1:             {
1:1452134:                 JVMStabilityInspector.inspectThrowable(t);
1:1452134:                 session.onError(t);
1:5151169:             }
1:67ccdab:             finally
1:5151169:             {
1:67ccdab:                 signalCloseDone();
1:5151169:             }
1:5151169:         }
1:5151169:     }
1:41ffca1: 
1:5151169:     /**
1:5151169:      * Outgoing file transfer thread
1:5151169:      */
1:5151169:     static class OutgoingMessageHandler extends MessageHandler
1:5151169:     {
1:5151169:         /*
1:5151169:          * All out going messages are queued up into messageQueue.
1:5151169:          * The size will grow when received streaming request.
1:5151169:          *
1:5151169:          * Queue is also PriorityQueue so that prior messages can go out fast.
1:5151169:          */
1:5151169:         private final PriorityBlockingQueue<StreamMessage> messageQueue = new PriorityBlockingQueue<>(64, new Comparator<StreamMessage>()
1:5151169:         {
1:5151169:             public int compare(StreamMessage o1, StreamMessage o2)
1:5151169:             {
1:5151169:                 return o2.getPriority() - o1.getPriority();
1:5151169:             }
1:5151169:         });
1:5151169: 
1:41ffca1:         OutgoingMessageHandler(StreamSession session)
1:5151169:         {
1:8af61ac:             super(session, true);
1:5151169:         }
1:5151169: 
1:67ccdab:         protected String name()
1:5151169:         {
1:67ccdab:             return "STREAM-OUT";
1:5151169:         }
1:5151169: 
1:5151169:         public void enqueue(StreamMessage message)
1:5151169:         {
1:5151169:             messageQueue.put(message);
1:5151169:         }
1:5151169: 
1:7aafe05:         @SuppressWarnings("resource")
1:5151169:         public void run()
1:5151169:         {
1:41ffca1:             try
1:5151169:             {
1:16499ca:                 DataOutputStreamPlus out = getWriteChannel(socket);
1:67ccdab: 
1:41ffca1:                 StreamMessage next;
1:41ffca1:                 while (!isClosed())
1:5151169:                 {
1:67ccdab:                     if ((next = messageQueue.poll(1, TimeUnit.SECONDS)) != null)
1:5151169:                     {
1:1e73b33:                         logger.debug("[Stream #{}] Sending {}", session.planId(), next);
1:41ffca1:                         sendMessage(out, next);
1:5151169:                         if (next.type == StreamMessage.Type.SESSION_FAILED)
1:41ffca1:                             close();
1:5151169:                     }
1:5151169:                 }
1:67ccdab: 
1:67ccdab:                 // Sends the last messages on the queue
1:67ccdab:                 while ((next = messageQueue.poll()) != null)
1:41ffca1:                     sendMessage(out, next);
1:41ffca1:             }
1:41ffca1:             catch (InterruptedException e)
1:41ffca1:             {
1:41ffca1:                 throw new AssertionError(e);
1:41ffca1:             }
1:c6ec5d5:             catch (Throwable e)
1:41ffca1:             {
1:41ffca1:                 session.onError(e);
1:41ffca1:             }
1:41ffca1:             finally
1:41ffca1:             {
1:41ffca1:                 signalCloseDone();
1:41ffca1:             }
1:5151169:         }
1:67ccdab: 
1:16499ca:         private void sendMessage(DataOutputStreamPlus out, StreamMessage message)
1:41ffca1:         {
5:5151169:             try
1:5151169:             {
1:67ccdab:                 StreamMessage.serialize(message, out, protocolVersion, session);
1:16499ca:                 out.flush();
1:8af61ac:                 message.sent();
1:5151169:             }
1:41ffca1:             catch (SocketException e)
1:5151169:             {
1:41ffca1:                 session.onError(e);
1:67ccdab:                 close();
1:5151169:             }
1:41ffca1:             catch (IOException e)
1:5151169:             {
3:5151169:                 session.onError(e);
1:5151169:             }
1:5151169:         }
1:5151169:     }
1:5151169: }
============================================================================
author:Paulo Motta
-------------------------------------------------------------------------------
commit:8af61ac
/////////////////////////////////////////////////////////////////////////
1:     private int incomingSocketTimeout;
1:     ConnectionHandler(StreamSession session, int incomingSocketTimeout)
1:         this.incoming = new IncomingMessageHandler(session, incomingSocketTimeout);
/////////////////////////////////////////////////////////////////////////
1:         incoming.start(incomingSocket, StreamMessage.CURRENT_VERSION, true);
1:         incomingSocket.shutdownOutput();
1:         outgoing.start(outgoingSocket, StreamMessage.CURRENT_VERSION, true);
1:         outgoingSocket.shutdownInput();
/////////////////////////////////////////////////////////////////////////
1:         {
1:             outgoing.socket.shutdownInput();
1:         }
1:         {
1:             incoming.socket.shutdownOutput();
1:         }
/////////////////////////////////////////////////////////////////////////
1:         private final boolean isOutgoingHandler;
1:         protected MessageHandler(StreamSession session, boolean isOutgoingHandler)
1:             this.isOutgoingHandler = isOutgoingHandler;
/////////////////////////////////////////////////////////////////////////
1:         private void sendInitMessage() throws IOException
1:                     !isOutgoingHandler,
/////////////////////////////////////////////////////////////////////////
1:         public void start(IncomingStreamingConnection connection, int protocolVersion) throws IOException
1:             start(connection.socket, protocolVersion, false);
1:         public void start(Socket socket, int protocolVersion, boolean initiator) throws IOException
1:             if (initiator)
1:                 sendInitMessage();
/////////////////////////////////////////////////////////////////////////
1:         private final int socketTimeout;
1: 
1:         IncomingMessageHandler(StreamSession session, int socketTimeout)
1:             super(session, false);
1:             this.socketTimeout = socketTimeout;
1:         }
1: 
1:         @Override
1:         public void start(Socket socket, int version, boolean initiator) throws IOException
1:         {
1:             try
1:             {
1:                 socket.setSoTimeout(socketTimeout);
1:             }
1:             catch (SocketException e)
1:             {
1:                 logger.warn("Could not set incoming socket timeout to {}", socketTimeout, e);
1:             }
1:             super.start(socket, version, initiator);
/////////////////////////////////////////////////////////////////////////
1:             super(session, true);
/////////////////////////////////////////////////////////////////////////
1:                 message.sent();
commit:00e7ecf
/////////////////////////////////////////////////////////////////////////
0:             if (closeFuture == null)
1:                 close();
1: 
/////////////////////////////////////////////////////////////////////////
commit:2811f15
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.net.IncomingStreamingConnection;
/////////////////////////////////////////////////////////////////////////
1:      * @param connection Incoming connection to use for {@link OutgoingMessageHandler}.
1:     public void initiateOnReceivingSide(IncomingStreamingConnection connection, boolean isForOutgoing, int version) throws IOException
1:             outgoing.start(connection, version);
1:             incoming.start(connection, version);
/////////////////////////////////////////////////////////////////////////
1:         private IncomingStreamingConnection incomingConnection;
/////////////////////////////////////////////////////////////////////////
0:         public void start(IncomingStreamingConnection connection, int protocolVersion)
1:         {
1:             this.incomingConnection = connection;
0:             start(connection.socket, protocolVersion);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:             if (incomingConnection != null)
1:                 //this will close the underlying socket and remove it
1:                 //from active MessagingService connections (CASSANDRA-11854)
1:                 incomingConnection.close();
1:             else
1:                 //this is an outgoing connection not registered in the MessagingService
1:                 //so we can close the socket directly
1:                 try
1:                 {
1:                     socket.close();
1:                 }
1:                 catch (IOException e)
1:                 {
1:                     // Erroring out while closing shouldn't happen but is not really a big deal, so just log
1:                     // it at DEBUG and ignore otherwise.
1:                     logger.debug("Unexpected error while closing streaming connection", e);
1:                 }
commit:561000a
/////////////////////////////////////////////////////////////////////////
1:         ListenableFuture<?> inClosed = closeIncoming();
1:         ListenableFuture<?> outClosed = closeOutgoing();
1:     public ListenableFuture<?> closeOutgoing()
1:     {
1:         return outgoing == null ? Futures.immediateFuture(null) : outgoing.close();
1:     }
1: 
1:     public ListenableFuture<?> closeIncoming()
1:     {
1:         return incoming == null ? Futures.immediateFuture(null) : incoming.close();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             //we do this instead of socket.getChannel() so socketSoTimeout is respected
1:             return Channels.newChannel(socket.getInputStream());
commit:58a0079
/////////////////////////////////////////////////////////////////////////
1:                     logger.debug("[Stream #{}] Received {}", session.planId(), message);
commit:582bdba
/////////////////////////////////////////////////////////////////////////
0:                     logger.debug("[Stream #{}] Received {}", session.planId(), message);
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:1417a51
commit:e983590
/////////////////////////////////////////////////////////////////////////
1:             if (!isClosed())
commit:59ee46e
commit:b9ff7fe
commit:de5bb58
commit:563cea1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         Socket incomingSocket = session.createConnection();
1:         Socket outgoingSocket = session.createConnection();
/////////////////////////////////////////////////////////////////////////
commit:db3935e
commit:c6ec5d5
/////////////////////////////////////////////////////////////////////////
1:             catch (Throwable e)
commit:9c9552a
commit:41ffca1
/////////////////////////////////////////////////////////////////////////
1: import java.nio.ByteBuffer;
/////////////////////////////////////////////////////////////////////////
0:         this.incoming = new IncomingMessageHandler(session);
1:         this.outgoing = new OutgoingMessageHandler(session);
/////////////////////////////////////////////////////////////////////////
0:         incoming.start(incomingSocket, StreamMessage.CURRENT_VERSION);
0:         incoming.sendInitMessage(incomingSocket, true);
0:         outgoing.start(outgoingSocket, StreamMessage.CURRENT_VERSION);
0:         outgoing.sendInitMessage(outgoingSocket, false);
/////////////////////////////////////////////////////////////////////////
0:             outgoing.start(socket, version);
0:             incoming.start(socket, version);
/////////////////////////////////////////////////////////////////////////
1:         protected int protocolVersion;
1:         protected Socket socket;
0:         protected MessageHandler(StreamSession session)
0:         protected static WritableByteChannel getWriteChannel(Socket socket) throws IOException
/////////////////////////////////////////////////////////////////////////
1:         protected static ReadableByteChannel getReadChannel(Socket socket) throws IOException
/////////////////////////////////////////////////////////////////////////
0:         public void sendInitMessage(Socket socket, boolean isForOutgoing) throws IOException
1:             ByteBuffer messageBuf = message.createMessage(false, protocolVersion);
0:             while (messageBuf.hasRemaining())
0:                 getWriteChannel(socket).write(messageBuf);
0:         public void start(Socket socket, int protocolVersion)
1:             this.socket = socket;
1:             this.protocolVersion = protocolVersion;
1: 
/////////////////////////////////////////////////////////////////////////
0:         IncomingMessageHandler(StreamSession session)
0:             super(session);
/////////////////////////////////////////////////////////////////////////
1:             try
1:                 ReadableByteChannel in = getReadChannel(socket);
1:                 while (!isClosed())
/////////////////////////////////////////////////////////////////////////
1:             catch (SocketException e)
1:             {
0:                 // socket is closed
1:                 close();
1:             }
0:             catch (Throwable e)
1:             {
1:                 session.onError(e);
1:             }
1:             finally
1:             {
1:                 signalCloseDone();
1:             }
/////////////////////////////////////////////////////////////////////////
1:         OutgoingMessageHandler(StreamSession session)
0:             super(session);
/////////////////////////////////////////////////////////////////////////
1:             try
0:                 WritableByteChannel out = getWriteChannel(socket);
1: 
1:                 StreamMessage next;
1:                 while (!isClosed())
1:                         sendMessage(out, next);
1:                     sendMessage(out, next);
1:             }
1:             catch (InterruptedException e)
1:             {
1:                 throw new AssertionError(e);
1:             }
1:             catch (IOException e)
1:             {
1:                 session.onError(e);
/////////////////////////////////////////////////////////////////////////
0:         private void sendMessage(WritableByteChannel out, StreamMessage message)
commit:1e73b33
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         logger.debug("[Stream #{}] Closing stream connection handler on {}", session.planId(), session.peer);
/////////////////////////////////////////////////////////////////////////
0:                         logger.debug("[Stream #{}] Received {}", session.planId(), message);
/////////////////////////////////////////////////////////////////////////
1:                         logger.debug("[Stream #{}] Sending {}", session.planId(), next);
commit:d881024
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.net.OutboundTcpConnectionPool;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Set up incoming message handler and initiate streaming.
1:      *
1:      * This method is called once on initiator.
1:      *
1:      * @throws IOException
1:      */
1:     public void initiate() throws IOException
1:         logger.debug("[Stream #{}] Sending stream init for incoming stream", session.planId());
0:         Socket incomingSocket = connect(session.peer);
0:         incoming = new IncomingMessageHandler(session, incomingSocket, StreamMessage.CURRENT_VERSION);
0:         incoming.sendInitMessage(true);
1:         logger.debug("[Stream #{}] Sending stream init for outgoing stream", session.planId());
0:         Socket outgoingSocket = connect(session.peer);
0:         outgoing = new OutgoingMessageHandler(session, outgoingSocket, StreamMessage.CURRENT_VERSION);
1:     /**
1:      * Set up outgoing message handler on receiving side.
1:      *
0:      * @param socket socket to use for {@link OutgoingMessageHandler}.
1:      * @param version Streaming message version
1:      * @throws IOException
1:      */
0:     public void initiateOnReceivingSide(Socket socket, boolean isForOutgoing, int version) throws IOException
1:         if (isForOutgoing)
1:         {
0:             outgoing = new OutgoingMessageHandler(session, socket, version);
0:             outgoing.start();
1:         }
1:         else
1:         {
0:             incoming = new IncomingMessageHandler(session, socket, version);
0:             incoming.start();
1:         }
/////////////////////////////////////////////////////////////////////////
0:                 Socket socket = OutboundTcpConnectionPool.newSocket(peer);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @return true if outgoing connection is opened and ready to send messages
1:      */
1:     public boolean isOutgoingConnected()
1:     {
1:         return outgoing != null && !outgoing.isClosed();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         public void sendInitMessage(boolean isForOutgoing) throws IOException
0:             StreamInitMessage message = new StreamInitMessage(FBUtilities.getBroadcastAddress(), session.planId(), session.description(), isForOutgoing);
commit:5151169
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.streaming;
1: 
1: import java.io.IOException;
1: import java.net.Socket;
1: import java.net.SocketException;
1: import java.nio.channels.Channels;
1: import java.nio.channels.ReadableByteChannel;
0: import java.nio.channels.SocketChannel;
1: import java.nio.channels.WritableByteChannel;
1: import java.util.Collection;
1: import java.util.Comparator;
1: import java.util.concurrent.PriorityBlockingQueue;
1: import java.util.concurrent.TimeUnit;
0: import java.util.concurrent.atomic.AtomicBoolean;
1: 
0: import com.google.common.base.Preconditions;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
0: import org.apache.cassandra.config.DatabaseDescriptor;
0: import org.apache.cassandra.net.MessagingService;
1: import org.apache.cassandra.streaming.messages.StreamInitMessage;
1: import org.apache.cassandra.streaming.messages.StreamMessage;
1: 
1: /**
1:  * ConnectionHandler manages incoming/outgoing message exchange for the {@link StreamSession}.
1:  *
1:  * <p>
1:  * Internally, ConnectionHandler manages thread to receive incoming {@link StreamMessage} and thread to
1:  * send outgoing message. Messages are encoded/decoded on those thread and handed to
1:  * {@link StreamSession#messageReceived(org.apache.cassandra.streaming.messages.StreamMessage)}.
1:  */
1: public class ConnectionHandler
1: {
1:     private static final Logger logger = LoggerFactory.getLogger(ConnectionHandler.class);
1: 
0:     private static final int MAX_CONNECT_ATTEMPTS = 3;
1: 
1:     private final StreamSession session;
0:     private final int protocolVersion;
1: 
1:     private IncomingMessageHandler incoming;
1:     private OutgoingMessageHandler outgoing;
1: 
0:     private boolean connected = false;
0:     private Socket socket;
1: 
0:     ConnectionHandler(StreamSession session)
1:     {
1:         this.session = session;
0:         this.protocolVersion = StreamMessage.CURRENT_VERSION;
1:     }
1: 
0:     ConnectionHandler(StreamSession session, Socket socket, int protocolVersion)
1:     {
1:         this.session = session;
0:         this.socket = Preconditions.checkNotNull(socket);
0:         this.connected = socket.isConnected();
0:         this.protocolVersion = protocolVersion;
1:     }
1: 
1:     /**
0:      * Connect to peer and start exchanging message.
0:      * When connect attempt fails, this retries for maximum of MAX_CONNECT_ATTEMPTS times.
1:      *
0:      * @throws IOException when connection failed.
1:      */
0:     public void connect() throws IOException
1:     {
0:         int attempts = 0;
0:         while (true)
1:         {
1:             try
1:             {
0:                 socket = MessagingService.instance().getConnectionPool(session.peer).newSocket();
0:                 socket.setSoTimeout(DatabaseDescriptor.getStreamingSocketTimeout());
0:                 break;
1:             }
0:             catch (IOException e)
1:             {
0:                 if (++attempts >= MAX_CONNECT_ATTEMPTS)
0:                     throw e;
1: 
0:                 long waitms = DatabaseDescriptor.getRpcTimeout() * (long)Math.pow(2, attempts);
0:                 logger.warn("Failed attempt " + attempts + " to connect to " + session.peer + ". Retrying in " + waitms + " ms. (" + e + ")");
1:                 try
1:                 {
0:                     Thread.sleep(waitms);
1:                 }
0:                 catch (InterruptedException wtf)
1:                 {
0:                     throw new IOException("interrupted", wtf);
1:                 }
1:             }
1:         }
0:         // send stream init message
0:         SocketChannel channel = socket.getChannel();
0:         WritableByteChannel out = channel;
1:         // socket channel is null when encrypted(SSL)
0:         if (channel == null)
1:         {
0:             out = Channels.newChannel(socket.getOutputStream());
1:         }
0:         logger.debug("Sending stream init...");
0:         StreamInitMessage message = new StreamInitMessage(session.planId(), session.description());
0:         out.write(message.createMessage(false, protocolVersion));
1: 
0:         connected = true;
1: 
0:         start();
0:         session.onConnect();
1:     }
1: 
0:     public void close()
1:     {
0:         incoming.terminate();
0:         outgoing.terminate();
0:         if (socket != null && !isConnected())
1:         {
1:             try
1:             {
0:                 socket.close();
1:             }
0:             catch (IOException ignore) {}
1:         }
1:     }
1: 
1:     /**
0:      * Start incoming/outgoing messaging threads.
1:      */
0:     public void start() throws IOException
1:     {
0:         SocketChannel channel = socket.getChannel();
0:         ReadableByteChannel in = channel;
0:         WritableByteChannel out = channel;
1:         // socket channel is null when encrypted(SSL)
0:         if (channel == null)
1:         {
0:             in = Channels.newChannel(socket.getInputStream());
0:             out = Channels.newChannel(socket.getOutputStream());
1:         }
1: 
0:         incoming = new IncomingMessageHandler(session, protocolVersion, in);
0:         outgoing = new OutgoingMessageHandler(session, protocolVersion, out);
1: 
0:         // ready to send/receive files
0:         new Thread(incoming, "STREAM-IN-" + session.peer).start();
0:         new Thread(outgoing, "STREAM-OUT-" + session.peer).start();
1:     }
1: 
0:     public boolean isConnected()
1:     {
0:         return connected;
1:     }
1: 
1:     /**
1:      * Enqueue messages to be sent.
1:      *
1:      * @param messages messages to send
1:      */
1:     public void sendMessages(Collection<? extends StreamMessage> messages)
1:     {
1:         for (StreamMessage message : messages)
1:             sendMessage(message);
1:     }
1: 
1:     public void sendMessage(StreamMessage message)
1:     {
0:         assert isConnected();
1:         outgoing.enqueue(message);
1:     }
1: 
1:     abstract static class MessageHandler implements Runnable
1:     {
1:         protected final StreamSession session;
0:         protected final int protocolVersion;
0:         private volatile boolean terminated;
1: 
0:         protected MessageHandler(StreamSession session, int protocolVersion)
1:         {
1:             this.session = session;
0:             this.protocolVersion = protocolVersion;
1:         }
1: 
0:         public void terminate()
1:         {
0:             terminated = true;
1:         }
1: 
0:         public boolean terminated()
1:         {
0:             return terminated;
1:         }
1:     }
1: 
1:     /**
1:      * Incoming streaming message handler
1:      */
1:     static class IncomingMessageHandler extends MessageHandler
1:     {
0:         private final ReadableByteChannel in;
1: 
0:         IncomingMessageHandler(StreamSession session, int protocolVersion, ReadableByteChannel in)
1:         {
0:             super(session, protocolVersion);
0:             this.in = in;
1:         }
1: 
1:         public void run()
1:         {
0:             while (!terminated())
1:             {
1:                 try
1:                 {
1:                     // receive message
1:                     StreamMessage message = StreamMessage.deserialize(in, protocolVersion, session);
0:                     assert message != null;
1:                     session.messageReceived(message);
1:                 }
0:                 catch (SocketException e)
1:                 {
0:                     // socket is closed
0:                     terminate();
1:                 }
0:                 catch (Throwable e)
1:                 {
1:                     session.onError(e);
1:                 }
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Outgoing file transfer thread
1:      */
1:     static class OutgoingMessageHandler extends MessageHandler
1:     {
1:         /*
1:          * All out going messages are queued up into messageQueue.
1:          * The size will grow when received streaming request.
1:          *
1:          * Queue is also PriorityQueue so that prior messages can go out fast.
1:          */
1:         private final PriorityBlockingQueue<StreamMessage> messageQueue = new PriorityBlockingQueue<>(64, new Comparator<StreamMessage>()
1:         {
1:             public int compare(StreamMessage o1, StreamMessage o2)
1:             {
1:                 return o2.getPriority() - o1.getPriority();
1:             }
1:         });
1: 
0:         private final WritableByteChannel out;
1: 
0:         OutgoingMessageHandler(StreamSession session, int protocolVersion, WritableByteChannel out)
1:         {
0:             super(session, protocolVersion);
0:             this.out = out;
1:         }
1: 
1:         public void enqueue(StreamMessage message)
1:         {
1:             messageQueue.put(message);
1:         }
1: 
1:         public void run()
1:         {
0:             while (!terminated())
1:             {
1:                 try
1:                 {
0:                     StreamMessage next = messageQueue.poll(1, TimeUnit.SECONDS);
0:                     if (next != null)
1:                     {
0:                         logger.debug("Sending " + next);
0:                         StreamMessage.serialize(next, out, protocolVersion, session);
1:                         if (next.type == StreamMessage.Type.SESSION_FAILED)
0:                             terminate();
1:                     }
1:                 }
0:                 catch (SocketException e)
1:                 {
1:                     session.onError(e);
0:                     terminate();
1:                 }
0:                 catch (InterruptedException | IOException e)
1:                 {
1:                     session.onError(e);
1:                 }
1:             }
1:         }
1:     }
1: }
author:Marcus Eriksson
-------------------------------------------------------------------------------
commit:8b60fb7
commit:3b448b3
commit:a5b90f1
/////////////////////////////////////////////////////////////////////////
1:                     session.keepSSTableLevel(),
1:                     session.isIncremental());
commit:0de0b8c
/////////////////////////////////////////////////////////////////////////
0:                     isForOutgoing,
0:                     session.keepSSTableLevel());
commit:0f2d7d0
/////////////////////////////////////////////////////////////////////////
0:                 socket.setKeepAlive(true);
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:1e92ce4
/////////////////////////////////////////////////////////////////////////
1: 
1: import io.netty.util.concurrent.FastThreadLocalThread;
/////////////////////////////////////////////////////////////////////////
1:             new FastThreadLocalThread(this, name() + "-" + socket.getRemoteSocketAddress()).start();
commit:7aafe05
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("resource")
/////////////////////////////////////////////////////////////////////////
1:         @SuppressWarnings("resource")
/////////////////////////////////////////////////////////////////////////
1:         @SuppressWarnings("resource")
/////////////////////////////////////////////////////////////////////////
1:         @SuppressWarnings("resource")
/////////////////////////////////////////////////////////////////////////
1:         @SuppressWarnings("resource")
author:Kaide Mu
-------------------------------------------------------------------------------
commit:7f6d70d
/////////////////////////////////////////////////////////////////////////
0:             new Thread(this, name() + "-" + socket.getRemoteSocketAddress()).start();
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:816c2b3
commit:59b8e17
/////////////////////////////////////////////////////////////////////////
0:             catch (IOException e)
0:             {
0:                 // Erroring out while closing shouldn't happen but is not really a big deal, so just log
0:                 // it at DEBUG and ignore otherwise.
0:                 logger.debug("Unexpected error while closing streaming connection", e);
0:             }
commit:67ccdab
/////////////////////////////////////////////////////////////////////////
0: import java.net.InetAddress;
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ExecutionException;
0: import java.util.concurrent.Future;
1: import java.util.concurrent.atomic.AtomicReference;
1: import com.google.common.util.concurrent.Futures;
1: import com.google.common.util.concurrent.ListenableFuture;
1: import com.google.common.util.concurrent.SettableFuture;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.FBUtilities;
/////////////////////////////////////////////////////////////////////////
0:     public ConnectionHandler initiate() throws IOException
0:         // Connect to other side and use that as the outgoing socket. Once the receiving
0:         // peer send back his init message, we'll have our incoming handling.
0:         outgoing = new OutgoingMessageHandler(session, connect(session.peer), StreamMessage.CURRENT_VERSION);
1: 
0:         logger.debug("Sending stream init... for {}", session.planId());
0:         outgoing.sendInitMessage(true);
0:         outgoing.start();
1: 
0:         return this;
0:     }
1: 
0:     public ConnectionHandler initiateOnReceivingSide(Socket incomingSocket, int version) throws IOException
0:     {
0:         // Create and start the incoming handler
0:         incoming = new IncomingMessageHandler(session, incomingSocket, version);
0:         incoming.start();
1: 
0:         // Connect back to the other side, and use that new socket for the outgoing handler
0:         outgoing = new OutgoingMessageHandler(session, connect(session.peer), version);
1: 
0:         logger.debug("Sending stream init back to initiator...");
0:         outgoing.sendInitMessage(false);
0:         outgoing.start();
0:         return this;
0:     }
1: 
0:     public void attachIncomingSocket(Socket incomingSocket, int version) throws IOException
0:     {
0:         incoming = new IncomingMessageHandler(session, incomingSocket, version);
0:         incoming.start();
0:      * @param peer the peer to connect to.
0:      * @return the created socket.
0:      *
0:     private static Socket connect(InetAddress peer) throws IOException
0:                 logger.info("Connecting to {} for streaming", peer);
0:                 Socket socket = MessagingService.instance().getConnectionPool(peer).newSocket();
0:                 return socket;
/////////////////////////////////////////////////////////////////////////
0:                 logger.warn("Failed attempt " + attempts + " to connect to " + peer + ". Retrying in " + waitms + " ms. (" + e + ")");
/////////////////////////////////////////////////////////////////////////
1:     public ListenableFuture<?> close()
0:         logger.debug("Closing stream connection handler on {}", session.peer);
0:         ListenableFuture<?> inClosed = incoming == null ? Futures.immediateFuture(null) : incoming.close();
0:         ListenableFuture<?> outClosed = outgoing == null ? Futures.immediateFuture(null) : outgoing.close();
1:         return Futures.allAsList(inClosed, outClosed);
/////////////////////////////////////////////////////////////////////////
1:         if (outgoing.isClosed())
1:             throw new RuntimeException("Outgoing stream handler has been closed");
0: 
0:         protected final Socket socket;
0:         protected final int protocolVersion;
0: 
1:         private final AtomicReference<SettableFuture<?>> closeFuture = new AtomicReference<>();
0: 
0:         protected MessageHandler(StreamSession session, Socket socket, int protocolVersion)
0:             this.socket = socket;
1:         protected abstract String name();
0: 
0:         protected WritableByteChannel getWriteChannel() throws IOException
1:             WritableByteChannel out = socket.getChannel();
0:             // socket channel is null when encrypted(SSL)
0:             return out == null
0:                  ? Channels.newChannel(socket.getOutputStream())
0:                  : out;
0:         protected ReadableByteChannel getReadChannel() throws IOException
0:             ReadableByteChannel in = socket.getChannel();
0:             // socket channel is null when encrypted(SSL)
0:             return in == null
0:                  ? Channels.newChannel(socket.getInputStream())
0:                  : in;
0:         }
0: 
0:         public void sendInitMessage(boolean sentByInitiator) throws IOException
0:         {
0:             StreamInitMessage message = new StreamInitMessage(FBUtilities.getBroadcastAddress(), session.planId(), session.description(), sentByInitiator);
0:             getWriteChannel().write(message.createMessage(false, protocolVersion));
0:         }
0: 
0:         public void start()
0:         {
0:             new Thread(this, name() + "-" + session.peer).start();
0:         }
0: 
1:         public ListenableFuture<?> close()
0:         {
1:             // Assume it wasn't closed. Not a huge deal if we create a future on a race
1:             SettableFuture<?> future = SettableFuture.create();
1:             return closeFuture.compareAndSet(null, future)
1:                  ? future
1:                  : closeFuture.get();
0:         }
0: 
1:         public boolean isClosed()
0:         {
1:             return closeFuture.get() != null;
0:         }
0: 
1:         protected void signalCloseDone()
0:         {
1:             closeFuture.get().set(null);
0: 
1:             // We can now close the socket
0:             try
0:             {
0:                 socket.close();
0:             }
0:             catch (IOException ignore) {}
/////////////////////////////////////////////////////////////////////////
0:         IncomingMessageHandler(StreamSession session, Socket socket, int protocolVersion) throws IOException
0:             super(session, socket, protocolVersion);
0:             this.in = getReadChannel();
0:         }
0: 
1:         protected String name()
0:         {
1:             return "STREAM-IN";
0:             while (!isClosed())
1:                     // Might be null if there is an error during streaming (see FileMessage.deserialize). It's ok
1:                     // to ignore here since we'll have asked for a retry.
1:                     if (message != null)
0:                     {
0:                         logger.debug("Received {}", message);
0:                         session.messageReceived(message);
0:                     }
1:                     close();
1:             signalCloseDone();
/////////////////////////////////////////////////////////////////////////
0:         OutgoingMessageHandler(StreamSession session, Socket socket, int protocolVersion) throws IOException
0:             super(session, socket, protocolVersion);
0:             this.out = getWriteChannel();
0:         }
0: 
1:         protected String name()
0:         {
1:             return "STREAM-OUT";
/////////////////////////////////////////////////////////////////////////
0:             StreamMessage next;
0:             while (!isClosed())
1:                     if ((next = messageQueue.poll(1, TimeUnit.SECONDS)) != null)
0:                         logger.debug("Sending {}", next);
0:                         sendMessage(next);
0:                             close();
0:                 catch (InterruptedException e)
0:                     throw new AssertionError(e);
0:             }
0: 
0:             try
0:             {
1:                 // Sends the last messages on the queue
1:                 while ((next = messageQueue.poll()) != null)
0:                     sendMessage(next);
0:             }
1:             finally
0:             {
0:                 signalCloseDone();
0:             }
0:         }
0: 
0:         private void sendMessage(StreamMessage message)
0:         {
0:             try
0:             {
1:                 StreamMessage.serialize(message, out, protocolVersion, session);
0:             }
0:             catch (SocketException e)
0:             {
0:                 session.onError(e);
0:                 close();
0:             }
0:             catch (IOException e)
0:             {
0:                 session.onError(e);
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:16499ca
/////////////////////////////////////////////////////////////////////////
1: import java.io.BufferedOutputStream;
/////////////////////////////////////////////////////////////////////////
0: 
1: import org.apache.cassandra.io.util.DataOutputStreamPlus;
1: import org.apache.cassandra.io.util.BufferedDataOutputStreamPlus;
1: import org.apache.cassandra.io.util.WrappedDataOutputStreamPlus;
/////////////////////////////////////////////////////////////////////////
1:         protected static DataOutputStreamPlus getWriteChannel(Socket socket) throws IOException
1:                 return new WrappedDataOutputStreamPlus(new BufferedOutputStream(socket.getOutputStream()));
1:             return new BufferedDataOutputStreamPlus(out);
/////////////////////////////////////////////////////////////////////////
1:             DataOutputStreamPlus out = getWriteChannel(socket);
1:             out.write(messageBuf);
1:             out.flush();
/////////////////////////////////////////////////////////////////////////
1:                 DataOutputStreamPlus out = getWriteChannel(socket);
/////////////////////////////////////////////////////////////////////////
1:         private void sendMessage(DataOutputStreamPlus out, StreamMessage message)
1:                 out.flush();
author:Joshua McKenzie
-------------------------------------------------------------------------------
commit:1452134
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.JVMStabilityInspector;
/////////////////////////////////////////////////////////////////////////
1:             catch (Throwable t)
1:                 JVMStabilityInspector.inspectThrowable(t);
1:                 session.onError(t);
commit:44fa2cd
/////////////////////////////////////////////////////////////////////////
1:             StreamInitMessage message = new StreamInitMessage(
1:                     FBUtilities.getBroadcastAddress(),
1:                     session.sessionIndex(),
1:                     session.planId(),
1:                     session.description(),
0:                     isForOutgoing);
author:belliottsmith
-------------------------------------------------------------------------------
commit:75508ec
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.util.DataOutputStreamAndChannel;
/////////////////////////////////////////////////////////////////////////
0:         protected static DataOutputStreamAndChannel getWriteChannel(Socket socket) throws IOException
1:             if (out == null)
0:                 out = Channels.newChannel(socket.getOutputStream());
0:             return new DataOutputStreamAndChannel(socket.getOutputStream(), out);
/////////////////////////////////////////////////////////////////////////
0:             getWriteChannel(socket).write(messageBuf);
/////////////////////////////////////////////////////////////////////////
0:                 DataOutputStreamAndChannel out = getWriteChannel(socket);
/////////////////////////////////////////////////////////////////////////
0:         private void sendMessage(DataOutputStreamAndChannel out, StreamMessage message)
author:Dave Brosius
-------------------------------------------------------------------------------
commit:db9bc69
/////////////////////////////////////////////////////////////////////////
0:                 logger.warn("Failed attempt {} to connect to {}. Retrying in {} ms. ({})", attempts, peer, waitms, e);
commit:cc10724
/////////////////////////////////////////////////////////////////////////
0:      * @param socket socket to use for {@link org.apache.cassandra.streaming.ConnectionHandler.OutgoingMessageHandler}.
============================================================================