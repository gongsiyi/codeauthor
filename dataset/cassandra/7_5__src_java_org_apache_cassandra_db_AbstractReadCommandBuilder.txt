1:a991b64: /*
1:a991b64:  * Licensed to the Apache Software Foundation (ASF) under one
1:a991b64:  * or more contributor license agreements.  See the NOTICE file
1:a991b64:  * distributed with this work for additional information
1:a991b64:  * regarding copyright ownership.  The ASF licenses this file
1:a991b64:  * to you under the Apache License, Version 2.0 (the
1:a991b64:  * "License"); you may not use this file except in compliance
1:a991b64:  * with the License.  You may obtain a copy of the License at
3:a991b64:  *
1:3c43775:  *     http://www.apache.org/licenses/LICENSE-2.0
1:a991b64:  *
1:3c43775:  * Unless required by applicable law or agreed to in writing, software
1:3c43775:  * distributed under the License is distributed on an "AS IS" BASIS,
1:3c43775:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:3c43775:  * See the License for the specific language governing permissions and
1:3c43775:  * limitations under the License.
1:a991b64:  */
1:a991b64: 
1:3c43775: package org.apache.cassandra.db;
1:24d185d: 
1:a991b64: import java.nio.ByteBuffer;
1:a991b64: import java.util.*;
1:a991b64: 
1:3c43775: import org.apache.cassandra.config.CFMetaData;
1:a991b64: import org.apache.cassandra.config.ColumnDefinition;
1:e097efc: import org.apache.cassandra.cql3.ColumnIdentifier;
1:e097efc: import org.apache.cassandra.cql3.Operator;
1:a991b64: import org.apache.cassandra.db.filter.*;
1:e097efc: import org.apache.cassandra.db.marshal.AbstractType;
1:e097efc: import org.apache.cassandra.db.marshal.CollectionType;
1:a991b64: import org.apache.cassandra.dht.*;
1:a991b64: import org.apache.cassandra.utils.FBUtilities;
1:a991b64: 
1:a991b64: public abstract class AbstractReadCommandBuilder
1:a991b64: {
1:a991b64:     protected final ColumnFamilyStore cfs;
1:a991b64:     protected int nowInSeconds;
1:a991b64: 
1:a991b64:     private int cqlLimit = -1;
1:a991b64:     private int pagingLimit = -1;
1:3c43775:     protected boolean reversed = false;
1:a991b64: 
1:3c43775:     protected Set<ColumnIdentifier> columns;
1:a991b64:     protected final RowFilter filter = RowFilter.create();
1:a991b64: 
1:2cc26eb:     private ClusteringBound lowerClusteringBound;
1:2cc26eb:     private ClusteringBound upperClusteringBound;
1:a991b64: 
1:a991b64:     private NavigableSet<Clustering> clusterings;
1:a991b64: 
1:a991b64:     // Use Util.cmd() instead of this ctor directly
1:a991b64:     AbstractReadCommandBuilder(ColumnFamilyStore cfs)
1:a991b64:     {
1:a991b64:         this.cfs = cfs;
1:a991b64:         this.nowInSeconds = FBUtilities.nowInSeconds();
1:a991b64:     }
1:a991b64: 
1:a991b64:     public AbstractReadCommandBuilder withNowInSeconds(int nowInSec)
1:a991b64:     {
1:a991b64:         this.nowInSeconds = nowInSec;
1:a991b64:         return this;
1:a991b64:     }
1:a991b64: 
1:a991b64:     public AbstractReadCommandBuilder fromIncl(Object... values)
1:a991b64:     {
1:a991b64:         assert lowerClusteringBound == null && clusterings == null;
1:2cc26eb:         this.lowerClusteringBound = ClusteringBound.create(cfs.metadata.comparator, true, true, values);
1:a991b64:         return this;
1:a991b64:     }
1:a991b64: 
1:a991b64:     public AbstractReadCommandBuilder fromExcl(Object... values)
1:a991b64:     {
1:a991b64:         assert lowerClusteringBound == null && clusterings == null;
1:2cc26eb:         this.lowerClusteringBound = ClusteringBound.create(cfs.metadata.comparator, true, false, values);
1:a991b64:         return this;
1:a991b64:     }
1:a991b64: 
1:a991b64:     public AbstractReadCommandBuilder toIncl(Object... values)
1:a991b64:     {
1:a991b64:         assert upperClusteringBound == null && clusterings == null;
1:2cc26eb:         this.upperClusteringBound = ClusteringBound.create(cfs.metadata.comparator, false, true, values);
1:a991b64:         return this;
1:a991b64:     }
1:a991b64: 
1:a991b64:     public AbstractReadCommandBuilder toExcl(Object... values)
1:a991b64:     {
1:a991b64:         assert upperClusteringBound == null && clusterings == null;
1:2cc26eb:         this.upperClusteringBound = ClusteringBound.create(cfs.metadata.comparator, false, false, values);
1:a991b64:         return this;
1:a991b64:     }
1:a991b64: 
1:a991b64:     public AbstractReadCommandBuilder includeRow(Object... values)
1:a991b64:     {
1:a991b64:         assert lowerClusteringBound == null && upperClusteringBound == null;
1:a991b64: 
1:a991b64:         if (this.clusterings == null)
1:a991b64:             this.clusterings = new TreeSet<>(cfs.metadata.comparator);
1:a991b64: 
1:a991b64:         this.clusterings.add(cfs.metadata.comparator.make(values));
1:a991b64:         return this;
1:a991b64:     }
1:a991b64: 
1:a991b64:     public AbstractReadCommandBuilder reverse()
1:a991b64:     {
1:a991b64:         this.reversed = true;
1:a991b64:         return this;
1:a991b64:     }
1:a991b64: 
1:a991b64:     public AbstractReadCommandBuilder withLimit(int newLimit)
1:a991b64:     {
1:a991b64:         this.cqlLimit = newLimit;
1:a991b64:         return this;
1:a991b64:     }
1:a991b64: 
1:a991b64:     public AbstractReadCommandBuilder withPagingLimit(int newLimit)
1:a991b64:     {
1:a991b64:         this.pagingLimit = newLimit;
1:a991b64:         return this;
1:a991b64:     }
1:a991b64: 
1:a991b64:     public AbstractReadCommandBuilder columns(String... columns)
1:a991b64:     {
1:a991b64:         if (this.columns == null)
1:a991b64:             this.columns = new HashSet<>();
1:a991b64: 
1:a991b64:         for (String column : columns)
1:a991b64:             this.columns.add(ColumnIdentifier.getInterned(column, true));
1:a991b64:         return this;
1:a991b64:     }
1:a991b64: 
1:a991b64:     private ByteBuffer bb(Object value, AbstractType<?> type)
1:a991b64:     {
1:a991b64:         return value instanceof ByteBuffer ? (ByteBuffer)value : ((AbstractType)type).decompose(value);
1:a991b64:     }
1:a991b64: 
1:a991b64:     private AbstractType<?> forValues(AbstractType<?> collectionType)
1:a991b64:     {
1:a991b64:         assert collectionType instanceof CollectionType;
1:a991b64:         CollectionType ct = (CollectionType)collectionType;
1:a991b64:         switch (ct.kind)
1:a991b64:         {
1:a991b64:             case LIST:
1:a991b64:             case MAP:
1:a991b64:                 return ct.valueComparator();
1:a991b64:             case SET:
1:a991b64:                 return ct.nameComparator();
1:a991b64:         }
1:a991b64:         throw new AssertionError();
1:a991b64:     }
1:a991b64: 
1:a991b64:     private AbstractType<?> forKeys(AbstractType<?> collectionType)
1:a991b64:     {
1:a991b64:         assert collectionType instanceof CollectionType;
1:a991b64:         CollectionType ct = (CollectionType)collectionType;
1:a991b64:         switch (ct.kind)
1:a991b64:         {
1:a991b64:             case LIST:
1:a991b64:             case MAP:
1:a991b64:                 return ct.nameComparator();
1:a991b64:         }
1:a991b64:         throw new AssertionError();
1:a991b64:     }
1:a991b64: 
1:a991b64:     public AbstractReadCommandBuilder filterOn(String column, Operator op, Object value)
1:a991b64:     {
1:a991b64:         ColumnDefinition def = cfs.metadata.getColumnDefinition(ColumnIdentifier.getInterned(column, true));
1:a991b64:         assert def != null;
1:a991b64: 
1:a991b64:         AbstractType<?> type = def.type;
1:a991b64:         if (op == Operator.CONTAINS)
1:a991b64:             type = forValues(type);
1:a991b64:         else if (op == Operator.CONTAINS_KEY)
1:a991b64:             type = forKeys(type);
1:a991b64: 
1:a991b64:         this.filter.add(def, op, bb(value, type));
1:a991b64:         return this;
1:a991b64:     }
1:a991b64: 
1:a991b64:     protected ColumnFilter makeColumnFilter()
1:a991b64:     {
1:3c43775:         if (columns == null || columns.isEmpty())
1:a991b64:             return ColumnFilter.all(cfs.metadata);
1:a991b64: 
1:3c43775:         ColumnFilter.Builder filter = ColumnFilter.selectionBuilder();
1:a991b64:         for (ColumnIdentifier column : columns)
1:3c43775:             filter.add(cfs.metadata.getColumnDefinition(column));
1:3c43775:         return filter.build();
1:a991b64:     }
1:a991b64: 
1:a991b64:     protected ClusteringIndexFilter makeFilter()
1:a991b64:     {
1:a991b64:         if (clusterings != null)
1:a991b64:         {
1:a991b64:             return new ClusteringIndexNamesFilter(clusterings, reversed);
1:a991b64:         }
1:a991b64:         else
1:a991b64:         {
1:2cc26eb:             Slice slice = Slice.make(lowerClusteringBound == null ? ClusteringBound.BOTTOM : lowerClusteringBound,
1:2cc26eb:                                      upperClusteringBound == null ? ClusteringBound.TOP : upperClusteringBound);
1:a991b64:             return new ClusteringIndexSliceFilter(Slices.with(cfs.metadata.comparator, slice), reversed);
1:a991b64:         }
1:a991b64:     }
1:a991b64: 
1:a991b64:     protected DataLimits makeLimits()
1:a991b64:     {
1:a991b64:         DataLimits limits = cqlLimit < 0 ? DataLimits.NONE : DataLimits.cqlLimits(cqlLimit);
1:a991b64:         if (pagingLimit >= 0)
1:a991b64:             limits = limits.forPaging(pagingLimit);
1:a991b64:         return limits;
1:a991b64:     }
1:a991b64: 
1:a991b64:     public abstract ReadCommand build();
1:a991b64: 
1:a991b64:     public static class SinglePartitionBuilder extends AbstractReadCommandBuilder
1:a991b64:     {
1:a991b64:         private final DecoratedKey partitionKey;
1:a991b64: 
1:3c43775:         public SinglePartitionBuilder(ColumnFamilyStore cfs, DecoratedKey key)
1:a991b64:         {
1:a991b64:             super(cfs);
1:a991b64:             this.partitionKey = key;
1:a991b64:         }
1:a991b64: 
1:a991b64:         @Override
1:a991b64:         public ReadCommand build()
1:a991b64:         {
1:4beb54d:             return SinglePartitionReadCommand.create(cfs.metadata, nowInSeconds, makeColumnFilter(), filter, makeLimits(), partitionKey, makeFilter());
1:a991b64:         }
1:a991b64:     }
1:a991b64: 
1:3c43775:     public static class SinglePartitionSliceBuilder extends AbstractReadCommandBuilder
1:a991b64:     {
1:3c43775:         private final DecoratedKey partitionKey;
1:3c43775:         private Slices.Builder sliceBuilder;
1:a991b64: 
1:3c43775:         public SinglePartitionSliceBuilder(ColumnFamilyStore cfs, DecoratedKey key)
1:a991b64:         {
1:3c43775:             super(cfs);
1:3c43775:             this.partitionKey = key;
1:3c43775:             sliceBuilder = new Slices.Builder(cfs.getComparator());
1:a991b64:         }
1:a991b64: 
1:3c43775:         public SinglePartitionSliceBuilder addSlice(Slice slice)
1:a991b64:         {
1:3c43775:             sliceBuilder.add(slice);
1:3c43775:             return this;
1:a991b64:         }
1:a991b64: 
1:3c43775:         @Override
1:3c43775:         protected ClusteringIndexFilter makeFilter()
1:a991b64:         {
1:3c43775:             return new ClusteringIndexSliceFilter(sliceBuilder.build(), reversed);
1:a991b64:         }
1:a991b64: 
1:3c43775:         @Override
1:3c43775:         public ReadCommand build()
3:24d185d:         {
1:a991b64:             return SinglePartitionReadCommand.create(cfs.metadata, nowInSeconds, makeColumnFilter(), filter, makeLimits(), partitionKey, makeFilter());
1:a991b64:         }
3:24d185d:     }
1:24d185d: 
1:a991b64:     public static class PartitionRangeBuilder extends AbstractReadCommandBuilder
1:a991b64:     {
1:a991b64:         private DecoratedKey startKey;
1:a991b64:         private boolean startInclusive;
1:a991b64:         private DecoratedKey endKey;
1:a991b64:         private boolean endInclusive;
1:a991b64: 
1:3c43775:         public PartitionRangeBuilder(ColumnFamilyStore cfs)
1:a991b64:         {
1:a991b64:             super(cfs);
1:a991b64:         }
1:a991b64: 
1:a991b64:         public PartitionRangeBuilder fromKeyIncl(Object... values)
1:a991b64:         {
1:a991b64:             assert startKey == null;
1:a991b64:             this.startInclusive = true;
1:3c43775:             this.startKey = makeKey(cfs.metadata, values);
1:a991b64:             return this;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public PartitionRangeBuilder fromKeyExcl(Object... values)
1:a991b64:         {
1:a991b64:             assert startKey == null;
1:a991b64:             this.startInclusive = false;
1:3c43775:             this.startKey = makeKey(cfs.metadata, values);
1:a991b64:             return this;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public PartitionRangeBuilder toKeyIncl(Object... values)
1:a991b64:         {
1:a991b64:             assert endKey == null;
1:a991b64:             this.endInclusive = true;
1:3c43775:             this.endKey = makeKey(cfs.metadata, values);
1:a991b64:             return this;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public PartitionRangeBuilder toKeyExcl(Object... values)
1:a991b64:         {
1:a991b64:             assert endKey == null;
1:a991b64:             this.endInclusive = false;
1:3c43775:             this.endKey = makeKey(cfs.metadata, values);
1:a991b64:             return this;
1:a991b64:         }
1:a991b64: 
1:a991b64:         @Override
1:a991b64:         public ReadCommand build()
1:a991b64:         {
1:a991b64:             PartitionPosition start = startKey;
1:a991b64:             if (start == null)
1:a991b64:             {
1:69f77cb:                 start = cfs.getPartitioner().getMinimumToken().maxKeyBound();
1:a991b64:                 startInclusive = false;
1:a991b64:             }
1:a991b64:             PartitionPosition end = endKey;
1:a991b64:             if (end == null)
1:a991b64:             {
1:69f77cb:                 end = cfs.getPartitioner().getMinimumToken().maxKeyBound();
1:a991b64:                 endInclusive = true;
1:a991b64:             }
1:a991b64: 
1:a991b64:             AbstractBounds<PartitionPosition> bounds;
1:a991b64:             if (startInclusive && endInclusive)
1:3c43775:                 bounds = new Bounds<>(start, end);
1:a991b64:             else if (startInclusive && !endInclusive)
1:3c43775:                 bounds = new IncludingExcludingBounds<>(start, end);
1:a991b64:             else if (!startInclusive && endInclusive)
1:3c43775:                 bounds = new Range<>(start, end);
1:a991b64:             else
1:3c43775:                 bounds = new ExcludingBounds<>(start, end);
1:a991b64: 
1:e097efc:             return new PartitionRangeReadCommand(cfs.metadata, nowInSeconds, makeColumnFilter(), filter, makeLimits(), new DataRange(bounds, makeFilter()), Optional.empty());
1:a991b64:         }
1:24d185d: 
1:3c43775:         static DecoratedKey makeKey(CFMetaData metadata, Object... partitionKey)
1:24d185d:         {
1:3c43775:             if (partitionKey.length == 1 && partitionKey[0] instanceof DecoratedKey)
1:3c43775:                 return (DecoratedKey)partitionKey[0];
1:24d185d: 
1:3c43775:             ByteBuffer key = CFMetaData.serializePartitionKey(metadata.getKeyValidatorAsClusteringComparator().make(partitionKey));
1:69f77cb:             return metadata.decorateKey(key);
1:a991b64:         }
1:a991b64:     }
1:24d185d: }
============================================================================
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:2cc26eb
/////////////////////////////////////////////////////////////////////////
1:     private ClusteringBound lowerClusteringBound;
1:     private ClusteringBound upperClusteringBound;
/////////////////////////////////////////////////////////////////////////
1:         this.lowerClusteringBound = ClusteringBound.create(cfs.metadata.comparator, true, true, values);
1:         this.lowerClusteringBound = ClusteringBound.create(cfs.metadata.comparator, true, false, values);
1:         this.upperClusteringBound = ClusteringBound.create(cfs.metadata.comparator, false, true, values);
1:         this.upperClusteringBound = ClusteringBound.create(cfs.metadata.comparator, false, false, values);
/////////////////////////////////////////////////////////////////////////
1:             Slice slice = Slice.make(lowerClusteringBound == null ? ClusteringBound.BOTTOM : lowerClusteringBound,
1:                                      upperClusteringBound == null ? ClusteringBound.TOP : upperClusteringBound);
commit:69f77cb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 start = cfs.getPartitioner().getMinimumToken().maxKeyBound();
1:                 end = cfs.getPartitioner().getMinimumToken().maxKeyBound();
/////////////////////////////////////////////////////////////////////////
1:             return metadata.decorateKey(key);
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:4beb54d
/////////////////////////////////////////////////////////////////////////
1:             return SinglePartitionReadCommand.create(cfs.metadata, nowInSeconds, makeColumnFilter(), filter, makeLimits(), partitionKey, makeFilter());
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
1:  *
1:  */
0: package org.apache.cassandra;
1: 
1: import java.nio.ByteBuffer;
1: import java.util.*;
1: 
1: import org.apache.cassandra.config.ColumnDefinition;
0: import org.apache.cassandra.cql3.*;
0: import org.apache.cassandra.db.*;
0: import org.apache.cassandra.db.rows.Row;
1: import org.apache.cassandra.db.filter.*;
0: import org.apache.cassandra.db.partitions.*;
0: import org.apache.cassandra.db.marshal.*;
1: import org.apache.cassandra.dht.*;
0: import org.apache.cassandra.service.StorageService;
1: import org.apache.cassandra.utils.FBUtilities;
1: 
1: public abstract class AbstractReadCommandBuilder
1: {
1:     protected final ColumnFamilyStore cfs;
1:     protected int nowInSeconds;
1: 
1:     private int cqlLimit = -1;
1:     private int pagingLimit = -1;
0:     private boolean reversed = false;
1: 
0:     private Set<ColumnIdentifier> columns;
1:     protected final RowFilter filter = RowFilter.create();
1: 
0:     private Slice.Bound lowerClusteringBound;
0:     private Slice.Bound upperClusteringBound;
1: 
1:     private NavigableSet<Clustering> clusterings;
1: 
1:     // Use Util.cmd() instead of this ctor directly
1:     AbstractReadCommandBuilder(ColumnFamilyStore cfs)
1:     {
1:         this.cfs = cfs;
1:         this.nowInSeconds = FBUtilities.nowInSeconds();
1:     }
1: 
1:     public AbstractReadCommandBuilder withNowInSeconds(int nowInSec)
1:     {
1:         this.nowInSeconds = nowInSec;
1:         return this;
1:     }
1: 
1:     public AbstractReadCommandBuilder fromIncl(Object... values)
1:     {
1:         assert lowerClusteringBound == null && clusterings == null;
0:         this.lowerClusteringBound = Slice.Bound.create(cfs.metadata.comparator, true, true, values);
1:         return this;
1:     }
1: 
1:     public AbstractReadCommandBuilder fromExcl(Object... values)
1:     {
1:         assert lowerClusteringBound == null && clusterings == null;
0:         this.lowerClusteringBound = Slice.Bound.create(cfs.metadata.comparator, true, false, values);
1:         return this;
1:     }
1: 
1:     public AbstractReadCommandBuilder toIncl(Object... values)
1:     {
1:         assert upperClusteringBound == null && clusterings == null;
0:         this.upperClusteringBound = Slice.Bound.create(cfs.metadata.comparator, false, true, values);
1:         return this;
1:     }
1: 
1:     public AbstractReadCommandBuilder toExcl(Object... values)
1:     {
1:         assert upperClusteringBound == null && clusterings == null;
0:         this.upperClusteringBound = Slice.Bound.create(cfs.metadata.comparator, false, false, values);
1:         return this;
1:     }
1: 
1:     public AbstractReadCommandBuilder includeRow(Object... values)
1:     {
1:         assert lowerClusteringBound == null && upperClusteringBound == null;
1: 
1:         if (this.clusterings == null)
1:             this.clusterings = new TreeSet<>(cfs.metadata.comparator);
1: 
1:         this.clusterings.add(cfs.metadata.comparator.make(values));
1:         return this;
1:     }
1: 
1:     public AbstractReadCommandBuilder reverse()
1:     {
1:         this.reversed = true;
1:         return this;
1:     }
1: 
1:     public AbstractReadCommandBuilder withLimit(int newLimit)
1:     {
1:         this.cqlLimit = newLimit;
1:         return this;
1:     }
1: 
1:     public AbstractReadCommandBuilder withPagingLimit(int newLimit)
1:     {
1:         this.pagingLimit = newLimit;
1:         return this;
1:     }
1: 
1:     public AbstractReadCommandBuilder columns(String... columns)
1:     {
1:         if (this.columns == null)
1:             this.columns = new HashSet<>();
1: 
1:         for (String column : columns)
1:             this.columns.add(ColumnIdentifier.getInterned(column, true));
1:         return this;
1:     }
1: 
1:     private ByteBuffer bb(Object value, AbstractType<?> type)
1:     {
1:         return value instanceof ByteBuffer ? (ByteBuffer)value : ((AbstractType)type).decompose(value);
1:     }
1: 
1:     private AbstractType<?> forValues(AbstractType<?> collectionType)
1:     {
1:         assert collectionType instanceof CollectionType;
1:         CollectionType ct = (CollectionType)collectionType;
1:         switch (ct.kind)
1:         {
1:             case LIST:
1:             case MAP:
1:                 return ct.valueComparator();
1:             case SET:
1:                 return ct.nameComparator();
1:         }
1:         throw new AssertionError();
1:     }
1: 
1:     private AbstractType<?> forKeys(AbstractType<?> collectionType)
1:     {
1:         assert collectionType instanceof CollectionType;
1:         CollectionType ct = (CollectionType)collectionType;
1:         switch (ct.kind)
1:         {
1:             case LIST:
1:             case MAP:
1:                 return ct.nameComparator();
1:         }
1:         throw new AssertionError();
1:     }
1: 
1:     public AbstractReadCommandBuilder filterOn(String column, Operator op, Object value)
1:     {
1:         ColumnDefinition def = cfs.metadata.getColumnDefinition(ColumnIdentifier.getInterned(column, true));
1:         assert def != null;
1: 
1:         AbstractType<?> type = def.type;
1:         if (op == Operator.CONTAINS)
1:             type = forValues(type);
1:         else if (op == Operator.CONTAINS_KEY)
1:             type = forKeys(type);
1: 
1:         this.filter.add(def, op, bb(value, type));
1:         return this;
1:     }
1: 
1:     protected ColumnFilter makeColumnFilter()
1:     {
0:         if (columns == null)
1:             return ColumnFilter.all(cfs.metadata);
1: 
0:         ColumnFilter.Builder builder = ColumnFilter.allColumnsBuilder(cfs.metadata);
1:         for (ColumnIdentifier column : columns)
0:             builder.add(cfs.metadata.getColumnDefinition(column));
0:         return builder.build();
1:     }
1: 
1:     protected ClusteringIndexFilter makeFilter()
1:     {
1:         if (clusterings != null)
1:         {
1:             return new ClusteringIndexNamesFilter(clusterings, reversed);
1:         }
1:         else
1:         {
0:             Slice slice = Slice.make(lowerClusteringBound == null ? Slice.Bound.BOTTOM : lowerClusteringBound,
0:                                      upperClusteringBound == null ? Slice.Bound.TOP : upperClusteringBound);
1:             return new ClusteringIndexSliceFilter(Slices.with(cfs.metadata.comparator, slice), reversed);
1:         }
1:     }
1: 
1:     protected DataLimits makeLimits()
1:     {
1:         DataLimits limits = cqlLimit < 0 ? DataLimits.NONE : DataLimits.cqlLimits(cqlLimit);
1:         if (pagingLimit >= 0)
1:             limits = limits.forPaging(pagingLimit);
1:         return limits;
1:     }
1: 
0:     public Row getOnlyRow()
1:     {
0:         return Util.getOnlyRow(build());
1:     }
1: 
0:     public Row getOnlyRowUnfiltered()
1:     {
0:         return Util.getOnlyRowUnfiltered(build());
1:     }
1: 
0:     public FilteredPartition getOnlyPartition()
1:     {
0:         return Util.getOnlyPartition(build());
1:     }
1: 
0:     public Partition getOnlyPartitionUnfiltered()
1:     {
0:         return Util.getOnlyPartitionUnfiltered(build());
1:     }
1: 
1:     public abstract ReadCommand build();
1: 
1:     public static class SinglePartitionBuilder extends AbstractReadCommandBuilder
1:     {
1:         private final DecoratedKey partitionKey;
1: 
0:         SinglePartitionBuilder(ColumnFamilyStore cfs, DecoratedKey key)
1:         {
1:             super(cfs);
1:             this.partitionKey = key;
1:         }
1: 
1:         @Override
1:         public ReadCommand build()
1:         {
1:             return SinglePartitionReadCommand.create(cfs.metadata, nowInSeconds, makeColumnFilter(), filter, makeLimits(), partitionKey, makeFilter());
1:         }
1:     }
1: 
1:     public static class PartitionRangeBuilder extends AbstractReadCommandBuilder
1:     {
1:         private DecoratedKey startKey;
1:         private boolean startInclusive;
1:         private DecoratedKey endKey;
1:         private boolean endInclusive;
1: 
0:         PartitionRangeBuilder(ColumnFamilyStore cfs)
1:         {
1:             super(cfs);
1:         }
1: 
1:         public PartitionRangeBuilder fromKeyIncl(Object... values)
1:         {
1:             assert startKey == null;
1:             this.startInclusive = true;
0:             this.startKey = Util.makeKey(cfs.metadata, values);
1:             return this;
1:         }
1: 
1:         public PartitionRangeBuilder fromKeyExcl(Object... values)
1:         {
1:             assert startKey == null;
1:             this.startInclusive = false;
0:             this.startKey = Util.makeKey(cfs.metadata, values);
1:             return this;
1:         }
1: 
1:         public PartitionRangeBuilder toKeyIncl(Object... values)
1:         {
1:             assert endKey == null;
1:             this.endInclusive = true;
0:             this.endKey = Util.makeKey(cfs.metadata, values);
1:             return this;
1:         }
1: 
1:         public PartitionRangeBuilder toKeyExcl(Object... values)
1:         {
1:             assert endKey == null;
1:             this.endInclusive = false;
0:             this.endKey = Util.makeKey(cfs.metadata, values);
1:             return this;
1:         }
1: 
1:         @Override
1:         public ReadCommand build()
1:         {
1:             PartitionPosition start = startKey;
1:             if (start == null)
1:             {
0:                 start = StorageService.getPartitioner().getMinimumToken().maxKeyBound();
1:                 startInclusive = false;
1:             }
1:             PartitionPosition end = endKey;
1:             if (end == null)
1:             {
0:                 end = StorageService.getPartitioner().getMinimumToken().maxKeyBound();
1:                 endInclusive = true;
1:             }
1:             
1:             AbstractBounds<PartitionPosition> bounds;
1:             if (startInclusive && endInclusive)
0:                 bounds = new Bounds<PartitionPosition>(start, end);
1:             else if (startInclusive && !endInclusive)
0:                 bounds = new IncludingExcludingBounds<PartitionPosition>(start, end);
1:             else if (!startInclusive && endInclusive)
0:                 bounds = new Range<PartitionPosition>(start, end);
1:             else
0:                 bounds = new ExcludingBounds<PartitionPosition>(start, end);
1: 
0:             return new PartitionRangeReadCommand(cfs.metadata, nowInSeconds, makeColumnFilter(), filter, makeLimits(), new DataRange(bounds, makeFilter()));
1:         }
1:     }
1: }
author:Sam Tunnicliffe
-------------------------------------------------------------------------------
commit:e097efc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.cql3.ColumnIdentifier;
1: import org.apache.cassandra.cql3.Operator;
1: import org.apache.cassandra.db.marshal.AbstractType;
1: import org.apache.cassandra.db.marshal.CollectionType;
/////////////////////////////////////////////////////////////////////////
1:             return new PartitionRangeReadCommand(cfs.metadata, nowInSeconds, makeColumnFilter(), filter, makeLimits(), new DataRange(bounds, makeFilter()), Optional.empty());
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:0a08525
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 start = cfs.getPartitioner().getMinimumToken().maxKeyBound();
0:                 end = cfs.getPartitioner().getMinimumToken().maxKeyBound();
/////////////////////////////////////////////////////////////////////////
0:             return metadata.decorateKey(key);
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:a22ce89
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.*;
0: import org.apache.cassandra.db.rows.Row;
0: import org.apache.cassandra.db.rows.RowIterator;
0: import org.apache.cassandra.db.partitions.*;
0: import org.apache.cassandra.service.StorageService;
/////////////////////////////////////////////////////////////////////////
0:                 start = StorageService.getPartitioner().getMinimumToken().maxKeyBound();
0:                 end = StorageService.getPartitioner().getMinimumToken().maxKeyBound();
/////////////////////////////////////////////////////////////////////////
0:             return StorageService.getPartitioner().decorateKey(key);
commit:24d185d
/////////////////////////////////////////////////////////////////////////
0:  *
/////////////////////////////////////////////////////////////////////////
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  *
0: package org.apache.cassandra;
/////////////////////////////////////////////////////////////////////////
0:     private boolean reversed = false;
0:     private Set<ColumnIdentifier> columns;
/////////////////////////////////////////////////////////////////////////
0:         if (columns == null)
0:         ColumnFilter.Builder builder = ColumnFilter.allColumnsBuilder(cfs.metadata);
0:             builder.add(cfs.metadata.getColumnDefinition(column));
0:         return builder.build();
/////////////////////////////////////////////////////////////////////////
0:     public Row getOnlyRow()
1:     {
0:         return Util.getOnlyRow(build());
1:     }
1: 
0:     public Row getOnlyRowUnfiltered()
1:     {
0:         return Util.getOnlyRowUnfiltered(build());
1:     }
1: 
0:     public FilteredPartition getOnlyPartition()
1:     {
0:         return Util.getOnlyPartition(build());
1:     }
1: 
0:     public Partition getOnlyPartitionUnfiltered()
1:     {
0:         return Util.getOnlyPartitionUnfiltered(build());
1:     }
1: 
0:         SinglePartitionBuilder(ColumnFamilyStore cfs, DecoratedKey key)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         PartitionRangeBuilder(ColumnFamilyStore cfs)
/////////////////////////////////////////////////////////////////////////
0:             this.startKey = Util.makeKey(cfs.metadata, values);
/////////////////////////////////////////////////////////////////////////
0:             this.startKey = Util.makeKey(cfs.metadata, values);
/////////////////////////////////////////////////////////////////////////
0:             this.endKey = Util.makeKey(cfs.metadata, values);
/////////////////////////////////////////////////////////////////////////
0:             this.endKey = Util.makeKey(cfs.metadata, values);
/////////////////////////////////////////////////////////////////////////
0:             
0:                 bounds = new Bounds<PartitionPosition>(start, end);
0:                 bounds = new IncludingExcludingBounds<PartitionPosition>(start, end);
0:                 bounds = new Range<PartitionPosition>(start, end);
0:                 bounds = new ExcludingBounds<PartitionPosition>(start, end);
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:3c43775
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0: 
1: package org.apache.cassandra.db;
1: import org.apache.cassandra.config.CFMetaData;
0: import org.apache.cassandra.db.rows.RowIterator;
/////////////////////////////////////////////////////////////////////////
1:     protected boolean reversed = false;
1:     protected Set<ColumnIdentifier> columns;
/////////////////////////////////////////////////////////////////////////
1:         if (columns == null || columns.isEmpty())
1:         ColumnFilter.Builder filter = ColumnFilter.selectionBuilder();
1:             filter.add(cfs.metadata.getColumnDefinition(column));
1:         return filter.build();
/////////////////////////////////////////////////////////////////////////
1:         public SinglePartitionBuilder(ColumnFamilyStore cfs, DecoratedKey key)
/////////////////////////////////////////////////////////////////////////
1:     public static class SinglePartitionSliceBuilder extends AbstractReadCommandBuilder
0:     {
1:         private final DecoratedKey partitionKey;
1:         private Slices.Builder sliceBuilder;
0: 
1:         public SinglePartitionSliceBuilder(ColumnFamilyStore cfs, DecoratedKey key)
0:         {
1:             super(cfs);
1:             this.partitionKey = key;
1:             sliceBuilder = new Slices.Builder(cfs.getComparator());
0:         }
0: 
1:         public SinglePartitionSliceBuilder addSlice(Slice slice)
0:         {
1:             sliceBuilder.add(slice);
1:             return this;
0:         }
0: 
1:         @Override
1:         protected ClusteringIndexFilter makeFilter()
0:         {
1:             return new ClusteringIndexSliceFilter(sliceBuilder.build(), reversed);
0:         }
0: 
1:         @Override
1:         public ReadCommand build()
0:         {
0:             return SinglePartitionSliceCommand.create(cfs.metadata, nowInSeconds, makeColumnFilter(), filter, makeLimits(), partitionKey, makeFilter());
0:         }
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:         public PartitionRangeBuilder(ColumnFamilyStore cfs)
/////////////////////////////////////////////////////////////////////////
1:             this.startKey = makeKey(cfs.metadata, values);
/////////////////////////////////////////////////////////////////////////
1:             this.startKey = makeKey(cfs.metadata, values);
/////////////////////////////////////////////////////////////////////////
1:             this.endKey = makeKey(cfs.metadata, values);
/////////////////////////////////////////////////////////////////////////
1:             this.endKey = makeKey(cfs.metadata, values);
/////////////////////////////////////////////////////////////////////////
0: 
1:                 bounds = new Bounds<>(start, end);
1:                 bounds = new IncludingExcludingBounds<>(start, end);
1:                 bounds = new Range<>(start, end);
1:                 bounds = new ExcludingBounds<>(start, end);
0: 
1:         static DecoratedKey makeKey(CFMetaData metadata, Object... partitionKey)
0:         {
1:             if (partitionKey.length == 1 && partitionKey[0] instanceof DecoratedKey)
1:                 return (DecoratedKey)partitionKey[0];
0: 
1:             ByteBuffer key = CFMetaData.serializePartitionKey(metadata.getKeyValidatorAsClusteringComparator().make(partitionKey));
0:             return StorageService.getPartitioner().decorateKey(key);
0:         }
author:Carl Yeksigian
-------------------------------------------------------------------------------
commit:3bdcaa3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0: 
0: package org.apache.cassandra.db;
0: import org.apache.cassandra.config.CFMetaData;
0: import org.apache.cassandra.db.rows.RowIterator;
/////////////////////////////////////////////////////////////////////////
0:     protected boolean reversed = false;
0:     protected Set<ColumnIdentifier> columns;
/////////////////////////////////////////////////////////////////////////
0:         if (columns == null || columns.isEmpty())
0:         ColumnFilter.Builder filter = ColumnFilter.selectionBuilder();
0:             filter.add(cfs.metadata.getColumnDefinition(column));
0:         return filter.build();
/////////////////////////////////////////////////////////////////////////
0:         public SinglePartitionBuilder(ColumnFamilyStore cfs, DecoratedKey key)
/////////////////////////////////////////////////////////////////////////
0:     public static class SinglePartitionSliceBuilder extends AbstractReadCommandBuilder
0:     {
0:         private final DecoratedKey partitionKey;
0:         private Slices.Builder sliceBuilder;
0: 
0:         public SinglePartitionSliceBuilder(ColumnFamilyStore cfs, DecoratedKey key)
0:         {
0:             super(cfs);
0:             this.partitionKey = key;
0:             sliceBuilder = new Slices.Builder(cfs.getComparator());
0:         }
0: 
0:         public SinglePartitionSliceBuilder addSlice(Slice slice)
0:         {
0:             sliceBuilder.add(slice);
0:             return this;
0:         }
0: 
0:         @Override
0:         protected ClusteringIndexFilter makeFilter()
0:         {
0:             return new ClusteringIndexSliceFilter(sliceBuilder.build(), reversed);
0:         }
0: 
0:         @Override
0:         public ReadCommand build()
0:         {
0:             return SinglePartitionSliceCommand.create(cfs.metadata, nowInSeconds, makeColumnFilter(), filter, makeLimits(), partitionKey, makeFilter());
0:         }
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         public PartitionRangeBuilder(ColumnFamilyStore cfs)
/////////////////////////////////////////////////////////////////////////
0:             this.startKey = makeKey(cfs.metadata, values);
/////////////////////////////////////////////////////////////////////////
0:             this.startKey = makeKey(cfs.metadata, values);
/////////////////////////////////////////////////////////////////////////
0:             this.endKey = makeKey(cfs.metadata, values);
/////////////////////////////////////////////////////////////////////////
0:             this.endKey = makeKey(cfs.metadata, values);
/////////////////////////////////////////////////////////////////////////
0: 
0:                 bounds = new Bounds<>(start, end);
0:                 bounds = new IncludingExcludingBounds<>(start, end);
0:                 bounds = new Range<>(start, end);
0:                 bounds = new ExcludingBounds<>(start, end);
0: 
0:         static DecoratedKey makeKey(CFMetaData metadata, Object... partitionKey)
0:         {
0:             if (partitionKey.length == 1 && partitionKey[0] instanceof DecoratedKey)
0:                 return (DecoratedKey)partitionKey[0];
0: 
0:             ByteBuffer key = CFMetaData.serializePartitionKey(metadata.getKeyValidatorAsClusteringComparator().make(partitionKey));
0:             return StorageService.getPartitioner().decorateKey(key);
0:         }
============================================================================