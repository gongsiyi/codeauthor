1:c613fea: /*
1:c613fea:  * Licensed to the Apache Software Foundation (ASF) under one
1:c613fea:  * or more contributor license agreements.  See the NOTICE file
1:c613fea:  * distributed with this work for additional information
1:c613fea:  * regarding copyright ownership.  The ASF licenses this file
1:c613fea:  * to you under the Apache License, Version 2.0 (the
1:c613fea:  * "License"); you may not use this file except in compliance
1:c613fea:  * with the License.  You may obtain a copy of the License at
1:07cdfd0:  *
1:07cf56f:  *     http://www.apache.org/licenses/LICENSE-2.0
1:07cdfd0:  *
1:07cf56f:  * Unless required by applicable law or agreed to in writing, software
1:07cf56f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:07cf56f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:07cf56f:  * See the License for the specific language governing permissions and
1:07cf56f:  * limitations under the License.
1:887dba9:  */
1:07cf56f: package org.apache.cassandra.utils;
1:2fd3268: 
1:937d5c5: import java.net.InetAddress;
1:e7a385a: import java.nio.ByteBuffer;
1:89ed0b6: import java.security.MessageDigest;
1:89ed0b6: import java.security.NoSuchAlgorithmException;
1:720870b: import java.security.SecureRandom;
1:7442fc0: import java.util.Collection;
1:8384396: import java.util.Random;
1:937d5c5: import java.util.UUID;
1:d9083a9: import java.util.concurrent.atomic.AtomicLong;
1:53f8f09: import java.util.concurrent.TimeUnit;
1:2fd3268: 
1:7536429: import com.google.common.annotations.VisibleForTesting;
1:53f8f09: import com.google.common.primitives.Ints;
1:2fd3268: 
1:8384396: /**
1:8384396:  * The goods are here: www.ietf.org/rfc/rfc4122.txt.
1:c613fea:  */
1:937d5c5: public class UUIDGen
1:7536429: {
1:8384396:     // A grand day! millis at 00:00:00.000 15 Oct 1582.
1:8384396:     private static final long START_EPOCH = -12219292800000L;
1:7442fc0:     private static final long clockSeqAndNode = makeClockSeqAndNode();
1:07cdfd0: 
1:8be7e5c:     /*
1:8be7e5c:      * The min and max possible lsb for a UUID.
1:8be7e5c:      * Note that his is not 0 and all 1's because Cassandra TimeUUIDType
1:8be7e5c:      * compares the lsb parts as a signed byte array comparison. So the min
1:8be7e5c:      * value is 8 times -128 and the max is 8 times +127.
1:8be7e5c:      *
1:8be7e5c:      * Note that we ignore the uuid variant (namely, MIN_CLOCK_SEQ_AND_NODE
1:8be7e5c:      * have variant 2 as it should, but MAX_CLOCK_SEQ_AND_NODE have variant 0).
1:8be7e5c:      * I don't think that has any practical consequence and is more robust in
1:8be7e5c:      * case someone provides a UUID with a broken variant.
1:8be7e5c:      */
1:8be7e5c:     private static final long MIN_CLOCK_SEQ_AND_NODE = 0x8080808080808080L;
1:8be7e5c:     private static final long MAX_CLOCK_SEQ_AND_NODE = 0x7f7f7f7f7f7f7f7fL;
1:8be7e5c: 
1:720870b:     private static final SecureRandom secureRandom = new SecureRandom();
1:720870b: 
1:8384396:     // placement of this singleton is important.  It needs to be instantiated *AFTER* the other statics.
1:8384396:     private static final UUIDGen instance = new UUIDGen();
1:07cdfd0: 
1:d9083a9:     private AtomicLong lastNanos = new AtomicLong();
1:07cdfd0: 
1:8384396:     private UUIDGen()
1:89ed0b6:     {
1:7442fc0:         // make sure someone didn't whack the clockSeqAndNode by changing the order of instantiation.
1:7442fc0:         if (clockSeqAndNode == 0) throw new RuntimeException("singleton instantiation is misplaced.");
1:91bdf7f:     }
1:91bdf7f: 
1:91bdf7f:     /**
1:7442fc0:      * Creates a type 1 UUID (time-based UUID).
1:91bdf7f:      *
1:8384396:      * @return a UUID instance
1:8384396:      */
1:7442fc0:     public static UUID getTimeUUID()
1:2fd3268:     {
1:7442fc0:         return new UUID(instance.createTimeSafe(), clockSeqAndNode);
1:e4e1993:     }
1:07cdfd0: 
1:8e003d8:     /**
1:8e003d8:      * Creates a type 1 UUID (time-based UUID) with the timestamp of @param when, in milliseconds.
1:07cdfd0:      *
1:8e003d8:      * @return a UUID instance
1:8e003d8:      */
1:8e003d8:     public static UUID getTimeUUID(long when)
1:e4e1993:     {
1:7536429:         return new UUID(createTime(fromUnixTimestamp(when)), clockSeqAndNode);
1:f797bfa:     }
1:07cdfd0: 
1:720870b:     /**
1:720870b:      * Returns a version 1 UUID using the provided timestamp and the local clock and sequence.
1:720870b:      * <p>
1:720870b:      * Note that this method is generally only safe to use if you can guarantee that the provided
1:720870b:      * parameter is unique across calls (otherwise the returned UUID won't be unique accross calls).
1:720870b:      *
1:720870b:      * @param whenInMicros a unix time in microseconds.
1:720870b:      * @return a new UUID {@code id} such that {@code microsTimestamp(id) == whenInMicros}. Please not that
1:720870b:      * multiple calls to this method with the same value of {@code whenInMicros} will return the <b>same</b>
1:720870b:      * UUID.
1:720870b:      */
1:fe65707:     public static UUID getTimeUUIDFromMicros(long whenInMicros)
1:fe65707:     {
1:fe65707:         long whenInMillis = whenInMicros / 1000;
1:fe65707:         long nanos = (whenInMicros - (whenInMillis * 1000)) * 10;
1:fe65707:         return getTimeUUID(whenInMillis, nanos);
1:fe65707:     }
1:fe65707: 
1:720870b:     /**
1:720870b:      * Similar to {@link getTimeUUIDFromMicros}, but randomize (using SecureRandom) the clock and sequence.
1:720870b:      * <p>
1:720870b:      * If you can guarantee that the {@code whenInMicros} argument is unique (for this JVM instance) for
1:720870b:      * every call, then you should prefer {@link getTimeUUIDFromMicros} which is faster. If you can't
1:720870b:      * guarantee this however, this method will ensure the returned UUID are still unique (accross calls)
1:720870b:      * through randomization.
1:720870b:      *
1:720870b:      * @param whenInMicros a unix time in microseconds.
1:720870b:      * @return a new UUID {@code id} such that {@code microsTimestamp(id) == whenInMicros}. The UUID returned
1:720870b:      * by different calls will be unique even if {@code whenInMicros} is not.
1:720870b:      */
1:720870b:     public static UUID getRandomTimeUUIDFromMicros(long whenInMicros)
1:720870b:     {
1:720870b:         long whenInMillis = whenInMicros / 1000;
1:720870b:         long nanos = (whenInMicros - (whenInMillis * 1000)) * 10;
1:720870b:         return new UUID(createTime(fromUnixTimestamp(whenInMillis, nanos)), secureRandom.nextLong());
1:720870b:     }
1:720870b: 
1:01115f7:     public static UUID getTimeUUID(long when, long nanos)
1:e4e1993:     {
1:01115f7:         return new UUID(createTime(fromUnixTimestamp(when, nanos)), clockSeqAndNode);
1:01115f7:     }
1:07cdfd0: 
1:01115f7:     @VisibleForTesting
1:01115f7:     public static UUID getTimeUUID(long when, long nanos, long clockSeqAndNode)
1:01115f7:     {
1:01115f7:         return new UUID(createTime(fromUnixTimestamp(when, nanos)), clockSeqAndNode);
1:f797bfa:     }
1:2fd3268: 
1:937d5c5:     /** creates a type 1 uuid from raw bytes. */
1:9b5c44c:     public static UUID getUUID(ByteBuffer raw)
1:f797bfa:     {
1:d36ec10:         return new UUID(raw.getLong(raw.position()), raw.getLong(raw.position() + 8));
1:e4e1993:     }
1:2fd3268: 
1:2d991a7:     public static ByteBuffer toByteBuffer(UUID uuid)
1:2d991a7:     {
1:2d991a7:         ByteBuffer buffer = ByteBuffer.allocate(16);
1:2d991a7:         buffer.putLong(uuid.getMostSignificantBits());
1:2d991a7:         buffer.putLong(uuid.getLeastSignificantBits());
1:2d991a7:         buffer.flip();
1:2d991a7:         return buffer;
1:2d991a7:     }
1:2d991a7: 
1:937d5c5:     /** decomposes a uuid into raw bytes. */
1:a89fd2a:     public static byte[] decompose(UUID uuid)
1:8e003d8:     {
1:937d5c5:         long most = uuid.getMostSignificantBits();
1:937d5c5:         long least = uuid.getLeastSignificantBits();
1:a89fd2a:         byte[] b = new byte[16];
2:937d5c5:         for (int i = 0; i < 8; i++)
1:5a6f0b8:         {
1:937d5c5:             b[i] = (byte)(most >>> ((7-i) * 8));
1:937d5c5:             b[8+i] = (byte)(least >>> ((7-i) * 8));
1:7536429:         }
1:937d5c5:         return b;
1:8e003d8:     }
1:07cdfd0: 
1:8b0e186:     /**
1:8384396:      * Returns a 16 byte representation of a type 1 UUID (a time-based UUID),
1:8384396:      * based on the current system time.
1:07cdfd0:      *
2:8384396:      * @return a type 1 UUID represented as a byte[]
2:8384396:      */
1:8384396:     public static byte[] getTimeUUIDBytes()
1:5a6f0b8:     {
1:4921acd:         return createTimeUUIDBytes(instance.createTimeSafe());
1:5a6f0b8:     }
1:07cdfd0: 
1:8384396:     /**
1:8be7e5c:      * Returns the smaller possible type 1 UUID having the provided timestamp.
1:8be7e5c:      *
1:8be7e5c:      * <b>Warning:</b> this method should only be used for querying as this
1:8be7e5c:      * doesn't at all guarantee the uniqueness of the resulting UUID.
1:8be7e5c:      */
1:8be7e5c:     public static UUID minTimeUUID(long timestamp)
1:8be7e5c:     {
1:8be7e5c:         return new UUID(createTime(fromUnixTimestamp(timestamp)), MIN_CLOCK_SEQ_AND_NODE);
1:8be7e5c:     }
1:8be7e5c: 
1:8be7e5c:     /**
1:8be7e5c:      * Returns the biggest possible type 1 UUID having the provided timestamp.
1:8be7e5c:      *
1:8be7e5c:      * <b>Warning:</b> this method should only be used for querying as this
1:8be7e5c:      * doesn't at all guarantee the uniqueness of the resulting UUID.
1:8be7e5c:      */
1:8be7e5c:     public static UUID maxTimeUUID(long timestamp)
1:8be7e5c:     {
1:8be7e5c:         // unix timestamp are milliseconds precision, uuid timestamp are 100's
1:8be7e5c:         // nanoseconds precision. If we ask for the biggest uuid have unix
1:8be7e5c:         // timestamp 1ms, then we should not extend 100's nanoseconds
1:8be7e5c:         // precision by taking 10000, but rather 19999.
1:8be7e5c:         long uuidTstamp = fromUnixTimestamp(timestamp + 1) - 1;
1:8be7e5c:         return new UUID(createTime(uuidTstamp), MAX_CLOCK_SEQ_AND_NODE);
1:8be7e5c:     }
1:8be7e5c: 
1:8be7e5c:     /**
1:8b0e186:      * @param uuid
1:8b0e186:      * @return milliseconds since Unix epoch
1:8b0e186:      */
1:8b0e186:     public static long unixTimestamp(UUID uuid)
1:8b0e186:     {
1:8b0e186:         return (uuid.timestamp() / 10000) + START_EPOCH;
1:8be7e5c:     }
1:8be7e5c: 
1:8b0e186:     /**
1:8b0e186:      * @param uuid
1:53f8f09:      * @return seconds since Unix epoch
1:53f8f09:      */
1:53f8f09:     public static int unixTimestampInSec(UUID uuid)
1:53f8f09:     {
1:53f8f09:         return Ints.checkedCast(TimeUnit.MILLISECONDS.toSeconds(unixTimestamp(uuid)));
1:53f8f09:     }
1:53f8f09: 
1:53f8f09:     /**
1:53f8f09:      * @param uuid
1:8b0e186:      * @return microseconds since Unix epoch
1:8b0e186:      */
1:8b0e186:     public static long microsTimestamp(UUID uuid)
1:8b0e186:     {
1:8b0e186:         return (uuid.timestamp() / 10) + START_EPOCH * 1000;
1:8be7e5c:     }
1:8be7e5c: 
1:8b0e186:     /**
1:8b0e186:      * @param timestamp milliseconds since Unix epoch
1:8b0e186:      * @return
1:8b0e186:      */
1:68d2526:     private static long fromUnixTimestamp(long timestamp)
1:68d2526:     {
1:01115f7:         return fromUnixTimestamp(timestamp, 0L);
1:01115f7:     }
1:8be7e5c: 
1:01115f7:     private static long fromUnixTimestamp(long timestamp, long nanos)
1:01115f7:     {
1:01115f7:         return ((timestamp - START_EPOCH) * 10000) + nanos;
1:8b0e186:     }
1:2fd3268: 
1:8384396:     /**
1:91bdf7f:      * Converts a 100-nanoseconds precision timestamp into the 16 byte representation
1:91bdf7f:      * of a type 1 UUID (a time-based UUID).
1:8be7e5c:      *
1:91bdf7f:      * To specify a 100-nanoseconds precision timestamp, one should provide a milliseconds timestamp and
1:6b7db8a:      * a number {@code 0 <= n < 10000} such that n*100 is the number of nanoseconds within that millisecond.
1:91bdf7f:      *
1:91bdf7f:      * <p><i><b>Warning:</b> This method is not guaranteed to return unique UUIDs; Multiple
1:91bdf7f:      * invocations using identical timestamps will result in identical UUIDs.</i></p>
1:91bdf7f:      *
1:91bdf7f:      * @return a type 1 UUID represented as a byte[]
1:91bdf7f:      */
1:91bdf7f:     public static byte[] getTimeUUIDBytes(long timeMillis, int nanos)
1:91bdf7f:     {
1:91bdf7f:         if (nanos >= 10000)
1:91bdf7f:             throw new IllegalArgumentException();
1:91bdf7f:         return createTimeUUIDBytes(instance.createTimeUnsafe(timeMillis, nanos));
1:91bdf7f:     }
1:91bdf7f: 
1:4921acd:     private static byte[] createTimeUUIDBytes(long msb)
1:f797bfa:     {
1:7442fc0:         long lsb = clockSeqAndNode;
1:8384396:         byte[] uuidBytes = new byte[16];
1:07cdfd0: 
1:8384396:         for (int i = 0; i < 8; i++)
1:8384396:             uuidBytes[i] = (byte) (msb >>> 8 * (7 - i));
1:07cdfd0: 
1:8384396:         for (int i = 8; i < 16; i++)
1:8384396:             uuidBytes[i] = (byte) (lsb >>> 8 * (7 - i));
1:07cdfd0: 
1:8384396:         return uuidBytes;
1:5a6f0b8:     }
1:07cdfd0: 
1:4921acd:     /**
1:4921acd:      * Returns a milliseconds-since-epoch value for a type-1 UUID.
1:07cdfd0:      *
1:4921acd:      * @param uuid a type-1 (time-based) UUID
1:4921acd:      * @return the number of milliseconds since the unix epoch
1:84eeb28:      * @throws IllegalArgumentException if the UUID is not version 1
1:4921acd:      */
1:4921acd:     public static long getAdjustedTimestamp(UUID uuid)
1:5a6f0b8:     {
1:8be7e5c:         if (uuid.version() != 1)
1:4921acd:             throw new IllegalArgumentException("incompatible with uuid version: "+uuid.version());
1:f726cb2:         return (uuid.timestamp() / 10000) + START_EPOCH;
1:5a6f0b8:     }
1:2fd3268: 
1:7442fc0:     private static long makeClockSeqAndNode()
1:89ed0b6:     {
1:c19066e:         long clock = new SecureRandom().nextLong();
1:7442fc0: 
1:8384396:         long lsb = 0;
1:f726cb2:         lsb |= 0x8000000000000000L;                 // variant (2 bits)
1:f726cb2:         lsb |= (clock & 0x0000000000003FFFL) << 48; // clock sequence (14 bits)
1:7442fc0:         lsb |= makeNode();                          // 6 bytes
1:8384396:         return lsb;
1:89ed0b6:     }
1:07cdfd0: 
1:8384396:     // needs to return two different values for the same when.
1:8384396:     // we can generate at most 10k UUIDs per ms.
1:d9083a9:     private long createTimeSafe()
1:89ed0b6:     {
1:d9083a9:         long newLastNanos;
1:d9083a9:         while (true)
1:d9083a9:         {
1:d9083a9:             //Generate a candidate value for new lastNanos
1:d9083a9:             newLastNanos = (System.currentTimeMillis() - START_EPOCH) * 10000;
1:d9083a9:             long originalLastNanos = lastNanos.get();
1:d9083a9:             if (newLastNanos > originalLastNanos)
1:d9083a9:             {
1:d9083a9:                 //Slow path once per millisecond do a CAS
1:d9083a9:                 if (lastNanos.compareAndSet(originalLastNanos, newLastNanos))
1:d9083a9:                 {
1:d9083a9:                     break;
1:d9083a9:                 }
1:d9083a9:             }
1:d9083a9:             else
1:d9083a9:             {
1:d9083a9:                 //Fast path do an atomic increment
1:d9083a9:                 //Or when falling behind this will move time forward past the clock if necessary
1:d9083a9:                 newLastNanos = lastNanos.incrementAndGet();
1:d9083a9:                 break;
1:d9083a9:             }
1:d9083a9:         }
1:d9083a9:         return createTime(newLastNanos);
1:89ed0b6:     }
1:07cdfd0: 
1:91bdf7f:     private long createTimeUnsafe(long when, int nanos)
1:91bdf7f:     {
1:91bdf7f:         long nanosSince = ((when - START_EPOCH) * 10000) + nanos;
2:4921acd:         return createTime(nanosSince);
1:89ed0b6:     }
1:07cdfd0: 
1:8be7e5c:     private static long createTime(long nanosSince)
1:07cdfd0:     {
1:07cdfd0:         long msb = 0L;
1:8384396:         msb |= (0x00000000ffffffffL & nanosSince) << 32;
1:07cdfd0:         msb |= (0x0000ffff00000000L & nanosSince) >>> 16;
1:8384396:         msb |= (0xffff000000000000L & nanosSince) >>> 48;
1:8384396:         msb |= 0x0000000000001000L; // sets the version to 1.
1:8384396:         return msb;
1:89ed0b6:     }
1:2fd3268: 
1:7442fc0:     private static long makeNode()
1:89ed0b6:     {
1:7442fc0:        /*
1:7442fc0:         * We don't have access to the MAC address but need to generate a node part
1:7442fc0:         * that identify this host as uniquely as possible.
1:7442fc0:         * The spec says that one option is to take as many source that identify
1:7442fc0:         * this node as possible and hash them together. That's what we do here by
1:7442fc0:         * gathering all the ip of this host.
1:7442fc0:         * Note that FBUtilities.getBroadcastAddress() should be enough to uniquely
1:7442fc0:         * identify the node *in the cluster* but it triggers DatabaseDescriptor
1:7442fc0:         * instanciation and the UUID generator is used in Stress for instance,
1:7442fc0:         * where we don't want to require the yaml.
1:7442fc0:         */
1:7442fc0:         Collection<InetAddress> localAddresses = FBUtilities.getAllLocalAddresses();
1:7442fc0:         if (localAddresses.isEmpty())
1:7442fc0:             throw new RuntimeException("Cannot generate the node component of the UUID because cannot retrieve any IP addresses.");
1:2fd3268: 
1:8384396:         // ideally, we'd use the MAC address, but java doesn't expose that.
1:7442fc0:         byte[] hash = hash(localAddresses);
1:8384396:         long node = 0;
1:8384396:         for (int i = 0; i < Math.min(6, hash.length); i++)
1:8384396:             node |= (0x00000000000000ff & (long)hash[i]) << (5-i)*8;
1:8384396:         assert (0xff00000000000000L & node) == 0;
1:07cdfd0: 
1:7442fc0:         // Since we don't use the mac address, the spec says that multicast
1:7442fc0:         // bit (least significant bit of the first octet of the node ID) must be 1.
1:7442fc0:         return node | 0x0000010000000000L;
1:4921acd:     }
1:07cdfd0: 
1:7442fc0:     private static byte[] hash(Collection<InetAddress> data)
1:89ed0b6:     {
1:7442fc0:         try
1:7442fc0:         {
1:47e8ef9:             // Identify the host.
1:7442fc0:             MessageDigest messageDigest = MessageDigest.getInstance("MD5");
1:7442fc0:             for(InetAddress addr : data)
1:7442fc0:                 messageDigest.update(addr.getAddress());
1:2fd3268: 
1:47e8ef9:             // Identify the process on the load: we use both the PID and class loader hash.
1:47e8ef9:             long pid = SigarLibrary.instance.getPid();
1:47e8ef9:             if (pid < 0)
1:47e8ef9:                 pid = new Random(System.currentTimeMillis()).nextLong();
1:47e8ef9:             FBUtilities.updateWithLong(messageDigest, pid);
1:47e8ef9: 
1:47e8ef9:             ClassLoader loader = UUIDGen.class.getClassLoader();
1:47e8ef9:             int loaderId = loader != null ? System.identityHashCode(loader) : 0;
1:47e8ef9:             FBUtilities.updateWithInt(messageDigest, loaderId);
1:47e8ef9: 
1:7442fc0:             return messageDigest.digest();
1:7442fc0:         }
1:7442fc0:         catch (NoSuchAlgorithmException nsae)
1:7442fc0:         {
1:7442fc0:             throw new RuntimeException("MD5 digest algorithm is not available", nsae);
1:7442fc0:         }
1:89ed0b6:     }
1:4921acd: }
1:2fd3268: 
1:8384396: // for the curious, here is how I generated START_EPOCH
1:8384396: //        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT-0"));
1:8384396: //        c.set(Calendar.YEAR, 1582);
1:8384396: //        c.set(Calendar.MONTH, Calendar.OCTOBER);
1:8384396: //        c.set(Calendar.DAY_OF_MONTH, 15);
1:8384396: //        c.set(Calendar.HOUR_OF_DAY, 0);
1:8384396: //        c.set(Calendar.MINUTE, 0);
1:8384396: //        c.set(Calendar.SECOND, 0);
1:8384396: //        c.set(Calendar.MILLISECOND, 0);
1:887dba9: //        long START_EPOCH = c.getTimeInMillis();
============================================================================
author:Dave Brosius
-------------------------------------------------------------------------------
commit:68d2526
/////////////////////////////////////////////////////////////////////////
1:     private static long fromUnixTimestamp(long timestamp)
1:     {
commit:087264f
/////////////////////////////////////////////////////////////////////////
commit:6b7db8a
/////////////////////////////////////////////////////////////////////////
1:      * a number {@code 0 <= n < 10000} such that n*100 is the number of nanoseconds within that millisecond.
commit:bd889dc
/////////////////////////////////////////////////////////////////////////
commit:56f35db
/////////////////////////////////////////////////////////////////////////
commit:978d7bb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:53f8f09
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.TimeUnit;
0: import com.google.common.base.Charsets;
1: import com.google.common.primitives.Ints;
/////////////////////////////////////////////////////////////////////////
1:      * @return seconds since Unix epoch
1:      */
1:     public static int unixTimestampInSec(UUID uuid)
1:     {
1:         return Ints.checkedCast(TimeUnit.MILLISECONDS.toSeconds(unixTimestamp(uuid)));
1:     }
1: 
1:     /**
1:      * @param uuid
commit:7005972
commit:484e1c4
commit:969f797
commit:b3dd05e
commit:720870b
/////////////////////////////////////////////////////////////////////////
1: import java.security.SecureRandom;
/////////////////////////////////////////////////////////////////////////
1:     private static final SecureRandom secureRandom = new SecureRandom();
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Returns a version 1 UUID using the provided timestamp and the local clock and sequence.
1:      * <p>
1:      * Note that this method is generally only safe to use if you can guarantee that the provided
1:      * parameter is unique across calls (otherwise the returned UUID won't be unique accross calls).
1:      *
1:      * @param whenInMicros a unix time in microseconds.
1:      * @return a new UUID {@code id} such that {@code microsTimestamp(id) == whenInMicros}. Please not that
1:      * multiple calls to this method with the same value of {@code whenInMicros} will return the <b>same</b>
1:      * UUID.
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Similar to {@link getTimeUUIDFromMicros}, but randomize (using SecureRandom) the clock and sequence.
1:      * <p>
1:      * If you can guarantee that the {@code whenInMicros} argument is unique (for this JVM instance) for
1:      * every call, then you should prefer {@link getTimeUUIDFromMicros} which is faster. If you can't
1:      * guarantee this however, this method will ensure the returned UUID are still unique (accross calls)
1:      * through randomization.
1:      *
1:      * @param whenInMicros a unix time in microseconds.
1:      * @return a new UUID {@code id} such that {@code microsTimestamp(id) == whenInMicros}. The UUID returned
1:      * by different calls will be unique even if {@code whenInMicros} is not.
1:      */
1:     public static UUID getRandomTimeUUIDFromMicros(long whenInMicros)
1:     {
1:         long whenInMillis = whenInMicros / 1000;
1:         long nanos = (whenInMicros - (whenInMillis * 1000)) * 10;
1:         return new UUID(createTime(fromUnixTimestamp(whenInMillis, nanos)), secureRandom.nextLong());
1:     }
1: 
commit:bf917cb
commit:47e8ef9
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.base.Charsets;
/////////////////////////////////////////////////////////////////////////
1:             // Identify the host.
1:             // Identify the process on the load: we use both the PID and class loader hash.
1:             long pid = SigarLibrary.instance.getPid();
1:             if (pid < 0)
1:                 pid = new Random(System.currentTimeMillis()).nextLong();
1:             FBUtilities.updateWithLong(messageDigest, pid);
1: 
1:             ClassLoader loader = UUIDGen.class.getClassLoader();
1:             int loaderId = loader != null ? System.identityHashCode(loader) : 0;
1:             FBUtilities.updateWithInt(messageDigest, loaderId);
1: 
commit:2d991a7
/////////////////////////////////////////////////////////////////////////
1:     public static ByteBuffer toByteBuffer(UUID uuid)
1:     {
1:         ByteBuffer buffer = ByteBuffer.allocate(16);
1:         buffer.putLong(uuid.getMostSignificantBits());
1:         buffer.putLong(uuid.getLeastSignificantBits());
1:         buffer.flip();
1:         return buffer;
1:     }
1: 
commit:75e85b9
commit:fe65707
/////////////////////////////////////////////////////////////////////////
1:     public static UUID getTimeUUIDFromMicros(long whenInMicros)
1:     {
1:         long whenInMillis = whenInMicros / 1000;
1:         long nanos = (whenInMicros - (whenInMillis * 1000)) * 10;
1:         return getTimeUUID(whenInMillis, nanos);
1:     }
1: 
commit:8be7e5c
/////////////////////////////////////////////////////////////////////////
1:     /*
1:      * The min and max possible lsb for a UUID.
1:      * Note that his is not 0 and all 1's because Cassandra TimeUUIDType
1:      * compares the lsb parts as a signed byte array comparison. So the min
1:      * value is 8 times -128 and the max is 8 times +127.
1:      *
1:      * Note that we ignore the uuid variant (namely, MIN_CLOCK_SEQ_AND_NODE
1:      * have variant 2 as it should, but MAX_CLOCK_SEQ_AND_NODE have variant 0).
1:      * I don't think that has any practical consequence and is more robust in
1:      * case someone provides a UUID with a broken variant.
1:      */
1:     private static final long MIN_CLOCK_SEQ_AND_NODE = 0x8080808080808080L;
1:     private static final long MAX_CLOCK_SEQ_AND_NODE = 0x7f7f7f7f7f7f7f7fL;
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Returns the smaller possible type 1 UUID having the provided timestamp.
1:      *
1:      * <b>Warning:</b> this method should only be used for querying as this
1:      * doesn't at all guarantee the uniqueness of the resulting UUID.
1:      */
1:     public static UUID minTimeUUID(long timestamp)
1:     {
1:         return new UUID(createTime(fromUnixTimestamp(timestamp)), MIN_CLOCK_SEQ_AND_NODE);
1:     }
1: 
1:     /**
1:      * Returns the biggest possible type 1 UUID having the provided timestamp.
1:      *
1:      * <b>Warning:</b> this method should only be used for querying as this
1:      * doesn't at all guarantee the uniqueness of the resulting UUID.
1:      */
1:     public static UUID maxTimeUUID(long timestamp)
1:     {
1:         // unix timestamp are milliseconds precision, uuid timestamp are 100's
1:         // nanoseconds precision. If we ask for the biggest uuid have unix
1:         // timestamp 1ms, then we should not extend 100's nanoseconds
1:         // precision by taking 10000, but rather 19999.
1:         long uuidTstamp = fromUnixTimestamp(timestamp + 1) - 1;
1:         return new UUID(createTime(uuidTstamp), MAX_CLOCK_SEQ_AND_NODE);
1:     }
1: 
0:     public static long unixTimestamp(UUID uuid) {
1:         if (uuid.version() != 1)
0:             throw new IllegalArgumentException(String.format("Can only retrieve the unix timestamp for version 1 uuid (provided version %d)", uuid.version()));
1: 
0:         long timestamp = uuid.timestamp();
0:         return (timestamp / 10000) + START_EPOCH;
1:     }
1: 
0:     private static long fromUnixTimestamp(long tstamp) {
0:         return (tstamp - START_EPOCH) * 10000;
1:     }
1: 
1:     /**
0:      * <p><i><b>Deprecated:</b> This method goes again the principle of a time
0:      * UUID and should not be used. For queries based on timestamp, minTimeUUID() and
0:      * maxTimeUUID() can be used but this method has questionable usefulness. This is
0:      * only kept because CQL2 uses it (see TimeUUID.fromStringCQL2) and we
0:      * don't want to break compatibility.</i></p>
1:      *
/////////////////////////////////////////////////////////////////////////
1:     private static long createTime(long nanosSince)
commit:7442fc0
/////////////////////////////////////////////////////////////////////////
0: import java.net.UnknownHostException;
1: import java.util.Collection;
0: import java.util.Enumeration;
0: import java.util.HashSet;
0: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1:     private static final long clockSeqAndNode = makeClockSeqAndNode();
1:         // make sure someone didn't whack the clockSeqAndNode by changing the order of instantiation.
1:         if (clockSeqAndNode == 0) throw new RuntimeException("singleton instantiation is misplaced.");
1:      * Creates a type 1 UUID (time-based UUID).
1:     public static UUID getTimeUUID()
1:         return new UUID(instance.createTimeSafe(), clockSeqAndNode);
/////////////////////////////////////////////////////////////////////////
1:         long lsb = clockSeqAndNode;
/////////////////////////////////////////////////////////////////////////
1:     private static long makeClockSeqAndNode()
0:         long clock = new Random(System.currentTimeMillis()).nextLong();
1: 
1:         lsb |= makeNode();                          // 6 bytes
/////////////////////////////////////////////////////////////////////////
1:     private static long makeNode()
1:        /*
1:         * We don't have access to the MAC address but need to generate a node part
1:         * that identify this host as uniquely as possible.
1:         * The spec says that one option is to take as many source that identify
1:         * this node as possible and hash them together. That's what we do here by
1:         * gathering all the ip of this host.
1:         * Note that FBUtilities.getBroadcastAddress() should be enough to uniquely
1:         * identify the node *in the cluster* but it triggers DatabaseDescriptor
1:         * instanciation and the UUID generator is used in Stress for instance,
1:         * where we don't want to require the yaml.
1:         */
1:         Collection<InetAddress> localAddresses = FBUtilities.getAllLocalAddresses();
1:         if (localAddresses.isEmpty())
1:             throw new RuntimeException("Cannot generate the node component of the UUID because cannot retrieve any IP addresses.");
1:         byte[] hash = hash(localAddresses);
1:         // Since we don't use the mac address, the spec says that multicast
1:         // bit (least significant bit of the first octet of the node ID) must be 1.
1:         return node | 0x0000010000000000L;
1:     private static byte[] hash(Collection<InetAddress> data)
1:         try
1:         {
1:             MessageDigest messageDigest = MessageDigest.getInstance("MD5");
1:             for(InetAddress addr : data)
1:                 messageDigest.update(addr.getAddress());
1:             return messageDigest.digest();
1:         }
1:         catch (NoSuchAlgorithmException nsae)
1:         {
1:             throw new RuntimeException("MD5 digest algorithm is not available", nsae);
1:         }
commit:f726cb2
/////////////////////////////////////////////////////////////////////////
1:         return (uuid.timestamp() / 10000) + START_EPOCH;
1:         lsb |= 0x8000000000000000L;                 // variant (2 bits)
1:         lsb |= (clock & 0x0000000000003FFFL) << 48; // clock sequence (14 bits)
0:         lsb |= makeNode(addr);                      // 6 bytes
commit:91bdf7f
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Converts a 100-nanoseconds precision timestamp into the 16 byte representation
1:      * of a type 1 UUID (a time-based UUID).
1:      *
1:      * To specify a 100-nanoseconds precision timestamp, one should provide a milliseconds timestamp and
0:      * a number 0 <= n < 10000 such that n*100 is the number of nanoseconds within that millisecond.
1:      *
1:      * <p><i><b>Warning:</b> This method is not guaranteed to return unique UUIDs; Multiple
1:      * invocations using identical timestamps will result in identical UUIDs.</i></p>
1:      *
1:      * @return a type 1 UUID represented as a byte[]
1:      */
1:     public static byte[] getTimeUUIDBytes(long timeMillis, int nanos)
1:     {
1:         if (nanos >= 10000)
1:             throw new IllegalArgumentException();
1:         return createTimeUUIDBytes(instance.createTimeUnsafe(timeMillis, nanos));
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         return createTimeUnsafe(when, 0);
1:     }
1: 
1:     private long createTimeUnsafe(long when, int nanos)
1:     {
1:         long nanosSince = ((when - START_EPOCH) * 10000) + nanos;
commit:07cdfd0
/////////////////////////////////////////////////////////////////////////
1:  *
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
1:  *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:      *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:      *
1: 
0:      *
0:      *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
0:      *
/////////////////////////////////////////////////////////////////////////
0:         lsb |= (clock & 0x00ff000000000000L) >>> 48;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     {
1:         long msb = 0L;
1:         msb |= (0x0000ffff00000000L & nanosSince) >>> 16;
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
commit:2fd3268
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:      *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:      *
1: 
0:      *
0:      *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
0:      *
/////////////////////////////////////////////////////////////////////////
0:         lsb |= (clock & 0x00ff000000000000L) >>> 48;
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:     {
0:         long msb = 0L;
0:         msb |= (0x0000ffff00000000L & nanosSince) >>> 16;
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1: package org.apache.cassandra.utils;
commit:e4e1993
/////////////////////////////////////////////////////////////////////////
0: import java.io.DataInputStream;
0: import java.io.DataOutputStream;
0: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
0:     /** reads a uuid from an input stream. */
0:     public static UUID read(DataInputStream dis) throws IOException
1:     {
0:         return new UUID(dis.readLong(), dis.readLong());
1:     }
0: 
0:     /** writes a uuid to an output stream. */
0:     public static void write(UUID uuid, DataOutputStream dos) throws IOException
1:     {
0:         dos.writeLong(uuid.getMostSignificantBits());
0:         dos.writeLong(uuid.getLeastSignificantBits());
1:     }
0: 
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:d9083a9
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicLong;
/////////////////////////////////////////////////////////////////////////
1:     private AtomicLong lastNanos = new AtomicLong();
/////////////////////////////////////////////////////////////////////////
1:     private long createTimeSafe()
1:         long newLastNanos;
1:         while (true)
1:         {
1:             //Generate a candidate value for new lastNanos
1:             newLastNanos = (System.currentTimeMillis() - START_EPOCH) * 10000;
1:             long originalLastNanos = lastNanos.get();
1:             if (newLastNanos > originalLastNanos)
1:             {
1:                 //Slow path once per millisecond do a CAS
1:                 if (lastNanos.compareAndSet(originalLastNanos, newLastNanos))
1:                 {
1:                     break;
1:                 }
1:             }
1:             else
1:             {
1:                 //Fast path do an atomic increment
1:                 //Or when falling behind this will move time forward past the clock if necessary
1:                 newLastNanos = lastNanos.incrementAndGet();
1:                 break;
1:             }
1:         }
1:         return createTime(newLastNanos);
commit:c19066e
/////////////////////////////////////////////////////////////////////////
0: import java.security.SecureRandom;
/////////////////////////////////////////////////////////////////////////
1:         long clock = new SecureRandom().nextLong();
author:Josh McKenzie
-------------------------------------------------------------------------------
commit:4e364d7
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:01115f7
/////////////////////////////////////////////////////////////////////////
1:     public static UUID getTimeUUID(long when, long nanos)
1:         return new UUID(createTime(fromUnixTimestamp(when, nanos)), clockSeqAndNode);
1:     }
0: 
1:     @VisibleForTesting
1:     public static UUID getTimeUUID(long when, long nanos, long clockSeqAndNode)
1:     {
1:         return new UUID(createTime(fromUnixTimestamp(when, nanos)), clockSeqAndNode);
/////////////////////////////////////////////////////////////////////////
1:         return fromUnixTimestamp(timestamp, 0L);
1:     }
0: 
1:     private static long fromUnixTimestamp(long timestamp, long nanos)
1:     {
1:         return ((timestamp - START_EPOCH) * 10000) + nanos;
commit:f797bfa
/////////////////////////////////////////////////////////////////////////
0:     public static UUID getTimeUUID(long when, long nanos)
0:         return new UUID(createTime(fromUnixTimestamp(when, nanos)), clockSeqAndNode);
1:     }
0: 
0:     @VisibleForTesting
0:     public static UUID getTimeUUID(long when, long nanos, long clockSeqAndNode)
1:     {
0:         return new UUID(createTime(fromUnixTimestamp(when, nanos)), clockSeqAndNode);
/////////////////////////////////////////////////////////////////////////
0:         return fromUnixTimestamp(timestamp, 0L);
1:     }
0: 
0:     private static long fromUnixTimestamp(long timestamp, long nanos)
1:     {
0:         return ((timestamp - START_EPOCH) * 10000) + nanos;
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:047c046
commit:7536429
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.annotations.VisibleForTesting;
0: 
/////////////////////////////////////////////////////////////////////////
0:     @VisibleForTesting
0:     public static UUID getTimeUUID(long when, long clockSeqAndNode)
1:     {
1:         return new UUID(createTime(fromUnixTimestamp(when)), clockSeqAndNode);
1:     }
0: 
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:2621707
/////////////////////////////////////////////////////////////////////////
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:8e003d8
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Creates a type 1 UUID (time-based UUID) with the timestamp of @param when, in milliseconds.
0:      *
1:      * @return a UUID instance
1:      */
1:     public static UUID getTimeUUID(long when)
1:     {
0:         return new UUID(createTime(fromUnixTimestamp(when)), clockSeqAndNode);
1:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     /** @param when time in milliseconds */
commit:8b0e186
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @param uuid
1:      * @return milliseconds since Unix epoch
1:      */
1:     public static long unixTimestamp(UUID uuid)
1:     {
1:         return (uuid.timestamp() / 10000) + START_EPOCH;
1:     /**
1:      * @param uuid
1:      * @return microseconds since Unix epoch
1:      */
1:     public static long microsTimestamp(UUID uuid)
1:     {
1:         return (uuid.timestamp() / 10) + START_EPOCH * 1000;
1:     }
0: 
1:     /**
1:      * @param timestamp milliseconds since Unix epoch
1:      * @return
1:      */
0:     private static long fromUnixTimestamp(long timestamp) {
0:         return (timestamp - START_EPOCH) * 10000;
commit:2ae5272
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.TypeSizes;
/////////////////////////////////////////////////////////////////////////
0:             return TypeSizes.NATIVE.sizeof(uuid.getMostSignificantBits()) + TypeSizes.NATIVE.sizeof(uuid.getLeastSignificantBits());
commit:5b9fc26
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.DBTypeSizes;
/////////////////////////////////////////////////////////////////////////
0:             return DBTypeSizes.NATIVE.sizeof(uuid.getMostSignificantBits()) + DBTypeSizes.NATIVE.sizeof(uuid.getLeastSignificantBits());
commit:5a6f0b8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.DBConstants;
0: import org.apache.cassandra.io.IVersionedSerializer;
0: 
0:     public static UUIDSerializer serializer = new UUIDSerializer();
0: 
/////////////////////////////////////////////////////////////////////////
0:     public static class UUIDSerializer implements IVersionedSerializer<UUID>
0:         public void serialize(UUID uuid, DataOutput out, int version) throws IOException
1:         {
0:             out.writeLong(uuid.getMostSignificantBits());
0:             out.writeLong(uuid.getLeastSignificantBits());
1:         }
0:         public UUID deserialize(DataInput in, int version) throws IOException
1:         {
0:             return new UUID(in.readLong(), in.readLong());
1:         }
0: 
0:         public long serializedSize(UUID uuid, int version)
1:         {
0:             return DBConstants.LONG_SIZE + DBConstants.LONG_SIZE;
1:         }
commit:9f9b65e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         long lsb = instance.getClockSeqAndNode(FBUtilities.getLocalAddress());
/////////////////////////////////////////////////////////////////////////
0: 
commit:84eeb28
/////////////////////////////////////////////////////////////////////////
0: import java.io.*;
/////////////////////////////////////////////////////////////////////////
0:     public static UUID read(DataInput dis) throws IOException
0:     public static void write(UUID uuid, DataOutput dos) throws IOException
/////////////////////////////////////////////////////////////////////////
1:      * @throws IllegalArgumentException if the UUID is not version 1
commit:d36ec10
/////////////////////////////////////////////////////////////////////////
1:         return new UUID(raw.getLong(raw.position()), raw.getLong(raw.position() + 8));
commit:9b5c44c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             return getUUID(ByteBuffer.wrap(UUIDGenerator.getInstance().generateTimeBasedUUID(new EthernetAddress(fauxMac)).toByteArray()));
/////////////////////////////////////////////////////////////////////////
1:     public static UUID getUUID(ByteBuffer raw)
0:         return new UUID(raw.getLong(raw.position() + raw.arrayOffset()), raw.getLong(raw.position() + raw.arrayOffset() + 8));
commit:e7a385a
/////////////////////////////////////////////////////////////////////////
1: import java.nio.ByteBuffer;
0: import org.safehaus.uuid.EthernetAddress;
0: import org.safehaus.uuid.UUIDGenerator;
0: 
/////////////////////////////////////////////////////////////////////////
0:             return makeType1UUID(ByteBuffer.wrap(UUIDGenerator.getInstance().generateTimeBasedUUID(new EthernetAddress(fauxMac)).toByteArray()));
/////////////////////////////////////////////////////////////////////////
0:         return makeType1UUID(ByteBuffer.wrap(b));
0:     public static UUID makeType1UUID(ByteBuffer raw)
0:         assert raw.remaining() == 16;
0:             most = (most << 8) | (raw.array()[raw.position()+raw.arrayOffset() + i] & 0xff);
0:             least = (least << 8) | (raw.array()[raw.position()+raw.arrayOffset() + i] & 0xff);
commit:c613fea
/////////////////////////////////////////////////////////////////////////
1: /*
0:  * 
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
0:  * 
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  * 
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  * 
1:  */
0: 
author:Eric Evans
-------------------------------------------------------------------------------
commit:89ed0b6
/////////////////////////////////////////////////////////////////////////
1: import java.security.MessageDigest;
1: import java.security.NoSuchAlgorithmException;
/////////////////////////////////////////////////////////////////////////
0: 
0:     private static final ThreadLocal<MessageDigest> localMD5Digest = new ThreadLocal<MessageDigest>()
1:     {
0:         @Override
0:         protected MessageDigest initialValue()
1:         {
0:             try
1:             {
0:                 return MessageDigest.getInstance("MD5");
1:             }
0:             catch (NoSuchAlgorithmException nsae)
1:             {
0:                 throw new RuntimeException("MD5 digest algorithm is not available", nsae);
1:             }
1:         }
0: 
0:         @Override
0:         public MessageDigest get()
1:         {
0:             MessageDigest digest = super.get();
0:             digest.reset();
0:             return digest;
1:         }
0:     };
0: 
/////////////////////////////////////////////////////////////////////////
0:         byte[] hash = hash(addr.toString());
/////////////////////////////////////////////////////////////////////////
0: 
0:     private static byte[] hash(String... data)
0:     {
0:         MessageDigest messageDigest = localMD5Digest.get();
0:         for(String block : data)
0:             messageDigest.update(block.getBytes());
0: 
0:         return messageDigest.digest();
1:     }
commit:887dba9
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * 
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  * 
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  * 
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  * 
1:  */
0: 
/////////////////////////////////////////////////////////////////////////
1: //        long START_EPOCH = c.getTimeInMillis();
commit:4921acd
/////////////////////////////////////////////////////////////////////////
0:         return new UUID(instance.createTimeSafe(), instance.getClockSeqAndNode(addr));
/////////////////////////////////////////////////////////////////////////
1:         return createTimeUUIDBytes(instance.createTimeSafe());
0:      * <p><i><b>Warning:</b> This method is not guaranteed to return unique UUIDs; Multiple
0:      * invocations using identical timestamps will result in identical UUIDs.</i></p>
0:      * 
0:         return createTimeUUIDBytes(instance.createTimeUnsafe(timeMillis));
1:     }
0:     
1:     private static byte[] createTimeUUIDBytes(long msb)
0:     {
0:         long lsb = instance.getClockSeqAndNode();
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Returns a milliseconds-since-epoch value for a type-1 UUID.
0:      * 
1:      * @param uuid a type-1 (time-based) UUID
1:      * @return the number of milliseconds since the unix epoch
0:      * @throws InvalidArgumentException if the UUID is not version 1
1:      */
1:     public static long getAdjustedTimestamp(UUID uuid)
0:     {
0:         if (uuid.version() != 1)
1:             throw new IllegalArgumentException("incompatible with uuid version: "+uuid.version());
0:         return (uuid.timestamp() / 10000) - START_EPOCH;
1:     }
0:     
/////////////////////////////////////////////////////////////////////////
0:     private synchronized long createTimeSafe()
0:         long nanosSince = (System.currentTimeMillis() - START_EPOCH) * 10000;
1:         return createTime(nanosSince);
0:     }
0: 
0:     private long createTimeUnsafe(long when)
0:     {
0:         long nanosSince = (when - START_EPOCH) * 10000;
1:         return createTime(nanosSince);
0:     }
0:     
0:     private long createTime(long nanosSince)
0:     {   
/////////////////////////////////////////////////////////////////////////
0: 
commit:8384396
/////////////////////////////////////////////////////////////////////////
0: import java.net.UnknownHostException;
0: import java.util.HashMap;
0: import java.util.Map;
1: import java.util.Random;
1:  * The goods are here: www.ietf.org/rfc/rfc4122.txt.
1:     // A grand day! millis at 00:00:00.000 15 Oct 1582.
1:     private static final long START_EPOCH = -12219292800000L;
0:     private static final long clock = new Random(System.currentTimeMillis()).nextLong();
0:     
1:     // placement of this singleton is important.  It needs to be instantiated *AFTER* the other statics.
1:     private static final UUIDGen instance = new UUIDGen();
0:     
0:     private long lastNanos;
0:     private final Map<InetAddress, Long> nodeCache = new HashMap<InetAddress, Long>();
0:     
1:     private UUIDGen()
0:         // make sure someone didn't whack the clock by changing the order of instantiation.
0:         if (clock == 0) throw new RuntimeException("singleton instantiation is misplaced.");
0:     }
0:     
1:     /**
0:      * Creates a type 1 UUID (time-based UUID) that substitutes a hash of
0:      * an IP address in place of the MAC (unavailable to Java).
0:      * 
0:      * @param addr the host address to use
1:      * @return a UUID instance
1:      */
0:     public static UUID makeType1UUIDFromHost(InetAddress addr)
0:     {
0:         return new UUID(instance.createTime(System.currentTimeMillis()), instance.getClockSeqAndNode(addr));
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
1:      * Returns a 16 byte representation of a type 1 UUID (a time-based UUID),
1:      * based on the current system time.
0:      * 
1:      * @return a type 1 UUID represented as a byte[]
1:      */
1:     public static byte[] getTimeUUIDBytes()
0:     {
0:         return getTimeUUIDBytes(System.currentTimeMillis());
0:     }
0:     
1:     /**
0:      * Converts a milliseconds-since-epoch timestamp into the 16 byte representation
0:      * of a type 1 UUID (a time-based UUID).
0:      * 
0:      * @param timeMillis
1:      * @return a type 1 UUID represented as a byte[]
1:      */
0:     public static byte[] getTimeUUIDBytes(long timeMillis)
0:     {
0:         long msb = instance.createTime(timeMillis), lsb = instance.getClockSeqAndNode();
1:         byte[] uuidBytes = new byte[16];
0:         
1:         for (int i = 0; i < 8; i++)
1:             uuidBytes[i] = (byte) (msb >>> 8 * (7 - i));
0:         
1:         for (int i = 8; i < 16; i++)
1:             uuidBytes[i] = (byte) (lsb >>> 8 * (7 - i));
0:         
1:         return uuidBytes;
0:     }
0:     
0:     private long getClockSeqAndNode()
0:     {
0:         try
0:         {
0:             return getClockSeqAndNode(InetAddress.getLocalHost());
0:         }
0:         catch (UnknownHostException e)
0:         {
0:             throw new RuntimeException(e);
0:         }
0:     }
0:     
0:     // todo: could cache value if we assume node doesn't change.
0:     private long getClockSeqAndNode(InetAddress addr)
0:     {
1:         long lsb = 0;
0:         lsb |= (clock & 0x3f00000000000000L) >>> 56; // was 58?
0:         lsb |= 0x0000000000000080;
0:         lsb |= (clock & 0x00ff000000000000L) >>> 48; 
0:         lsb |= makeNode(addr);
1:         return lsb;
0:     }
0:     
1:     // needs to return two different values for the same when.
1:     // we can generate at most 10k UUIDs per ms.
0:     private synchronized long createTime(long when)
0:     {
0:         long nanosSince = (when - START_EPOCH) * 10000;
0:         if (nanosSince > lastNanos)
0:             lastNanos = nanosSince;
0:         else
0:             nanosSince = ++lastNanos;
0:         
0:         long msb = 0L; 
1:         msb |= (0x00000000ffffffffL & nanosSince) << 32;
0:         msb |= (0x0000ffff00000000L & nanosSince) >>> 16; 
1:         msb |= (0xffff000000000000L & nanosSince) >>> 48;
1:         msb |= 0x0000000000001000L; // sets the version to 1.
1:         return msb;
0:     }
0:     
0:     // Lazily create node hashes, and cache them for later
0:     private long makeNode(InetAddress addr)
0:     {
0:         if (nodeCache.containsKey(addr))
0:             return nodeCache.get(addr);
0:         
1:         // ideally, we'd use the MAC address, but java doesn't expose that.
0:         byte[] hash = FBUtilities.hash(ByteBuffer.wrap(addr.toString().getBytes()));
1:         long node = 0;
1:         for (int i = 0; i < Math.min(6, hash.length); i++)
1:             node |= (0x00000000000000ff & (long)hash[i]) << (5-i)*8;
1:         assert (0xff00000000000000L & node) == 0;
0:         
0:         nodeCache.put(addr, node);
0:         
0:         return node;
0:     }
0: 
1: // for the curious, here is how I generated START_EPOCH
1: //        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT-0"));
1: //        c.set(Calendar.YEAR, 1582);
1: //        c.set(Calendar.MONTH, Calendar.OCTOBER);
1: //        c.set(Calendar.DAY_OF_MONTH, 15);
1: //        c.set(Calendar.HOUR_OF_DAY, 0);
1: //        c.set(Calendar.MINUTE, 0);
1: //        c.set(Calendar.SECOND, 0);
1: //        c.set(Calendar.MILLISECOND, 0);
0: //        long START_EPOCH = c.getTimeInMillis();
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:a89fd2a
/////////////////////////////////////////////////////////////////////////
0: import java.io.DataInputStream;
0: import java.io.IOException;
0: import java.io.InputStream;
/////////////////////////////////////////////////////////////////////////
0:     
0:     public static UUID makeType1UUID(DataInputStream in) throws IOException
0:     {
1:         byte[] b = new byte[16];
0:         in.readFully(b);
0:         return makeType1UUID(b);
0:     }
0:     public static UUID makeType1UUID(byte[] raw)
/////////////////////////////////////////////////////////////////////////
1:     public static byte[] decompose(UUID uuid)
commit:937d5c5
/////////////////////////////////////////////////////////////////////////
0: package org.apache.cassandra.utils;
0: 
0: import org.safehaus.uuid.EthernetAddress;
0: import org.safehaus.uuid.UUIDGenerator;
0: 
0: import java.math.BigInteger;
1: import java.net.InetAddress;
0: import java.security.MessageDigest;
0: import java.security.NoSuchAlgorithmException;
0: import java.util.Random;
1: import java.util.UUID;
0: 
0: /**
0:  * Generates type 1 (time-based) UUIDs
0:  */
1: public class UUIDGen
0: {
0:     /** creates a type1 uuid but substitutes hash of the IP where the mac would go. */
0:     public static synchronized UUID makeType1UUIDFromHost(InetAddress addr)
0:     {
0:         try
0:         {
0:             MessageDigest digest = MessageDigest.getInstance("MD5");
0:             digest.update(addr.getAddress());
0:             byte[] md5 = digest.digest();
0:             byte[] fauxMac = new byte[6];
0:             System.arraycopy(md5, 0, fauxMac, 0, Math.min(md5.length, fauxMac.length));
0:             return makeType1UUID(UUIDGenerator.getInstance().generateTimeBasedUUID(new EthernetAddress(fauxMac)).toByteArray());
0:         }
0:         catch (NoSuchAlgorithmException ex)
0:         {
0:             throw new RuntimeException("Your platform has no support for generating MD5 sums");
0:         }
0:     }
0: 
1:     /** creates a type 1 uuid from raw bytes. */
0:     static UUID makeType1UUID(byte[] raw)
0:     {
0:         long most = 0;
0:         long least = 0;
0:         assert raw.length == 16;
1:         for (int i = 0; i < 8; i++)
0:             most = (most << 8) | (raw[i] & 0xff);
0:         for (int i =8 ; i < 16; i++)
0:             least = (least << 8) | (raw[i] & 0xff);
0:         return new UUID(most, least);
0:     }
0: 
1:     /** decomposes a uuid into raw bytes. */
0:     static byte[] decompose(UUID uuid)
0:     {
1:         long most = uuid.getMostSignificantBits();
1:         long least = uuid.getLeastSignificantBits();
0:         byte[] b = new byte[16];
1:         for (int i = 0; i < 8; i++)
0:         {
1:             b[i] = (byte)(most >>> ((7-i) * 8));
1:             b[8+i] = (byte)(least >>> ((7-i) * 8));
0:         }
1:         return b;
0:     }
0: }
============================================================================