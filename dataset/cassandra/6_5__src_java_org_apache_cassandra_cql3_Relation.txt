1:655ccc3: /*
1:655ccc3:  * Licensed to the Apache Software Foundation (ASF) under one
1:655ccc3:  * or more contributor license agreements.  See the NOTICE file
1:655ccc3:  * distributed with this work for additional information
1:655ccc3:  * regarding copyright ownership.  The ASF licenses this file
1:655ccc3:  * to you under the Apache License, Version 2.0 (the
1:655ccc3:  * "License"); you may not use this file except in compliance
1:655ccc3:  * with the License.  You may obtain a copy of the License at
1:655ccc3:  *
1:07cf56f:  *     http://www.apache.org/licenses/LICENSE-2.0
1:655ccc3:  *
1:07cf56f:  * Unless required by applicable law or agreed to in writing, software
1:07cf56f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:07cf56f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:07cf56f:  * See the License for the specific language governing permissions and
1:07cf56f:  * limitations under the License.
1:655ccc3:  */
1:655ccc3: package org.apache.cassandra.cql3;
1:655ccc3: 
1:655ccc3: import java.util.ArrayList;
1:655ccc3: import java.util.List;
1:652ec6a: 
1:65a7088: import org.apache.cassandra.config.CFMetaData;
1:65a7088: import org.apache.cassandra.config.ColumnDefinition;
1:65a7088: import org.apache.cassandra.cql3.restrictions.Restriction;
1:65a7088: import org.apache.cassandra.cql3.statements.Bound;
1:65a7088: import org.apache.cassandra.exceptions.InvalidRequestException;
1:655ccc3: 
1:65a7088: import static org.apache.cassandra.cql3.statements.RequestValidations.invalidRequest;
1:5a4253b: 
1:4ed0060: public abstract class Relation
1:4ed0060: {
1:5117a5d:     protected Operator relationType;
1:d12a0d7: 
1:5117a5d:     public Operator operator()
1:d12a0d7:     {
1:655ccc3:         return relationType;
1:8b81c8f:     }
1:652ec6a: 
1:655ccc3:     /**
1:5a4253b:      * Returns the raw value for this relation, or null if this is an IN relation.
1:655ccc3:      */
1:5a4253b:     public abstract Term.Raw getValue();
1:8b81c8f: 
1:655ccc3:     /**
1:5a4253b:      * Returns the list of raw IN values for this relation, or null if this is not an IN relation.
1:655ccc3:      */
1:5a4253b:     public abstract List<? extends Term.Raw> getInValues();
1:655ccc3: 
1:5a4253b:     /**
1:65a7088:      * Checks if this relation apply to multiple columns.
1:655ccc3:      *
1:65a7088:      * @return <code>true</code> if this relation apply to multiple columns, <code>false</code> otherwise.
1:5a4253b:      */
1:65a7088:     public boolean isMultiColumn()
1:652ec6a:     {
1:d12a0d7:         return false;
1:652ec6a:     }
1:655ccc3: 
1:5a4253b:     /**
1:65a7088:      * Checks if this relation is a token relation (e.g. <pre>token(a) = token(1)</pre>).
1:655ccc3:      *
1:65a7088:      * @return <code>true</code> if this relation is a token relation, <code>false</code> otherwise.
1:5a4253b:      */
1:65a7088:     public boolean onToken()
1:d12a0d7:     {
2:65a7088:         return false;
1:d12a0d7:     }
1:655ccc3: 
1:5a4253b:     /**
1:65a7088:      * Checks if the operator of this relation is a <code>CONTAINS</code>.
1:65a7088:      * @return <code>true</code>  if the operator of this relation is a <code>CONTAINS</code>, <code>false</code>
1:65a7088:      * otherwise.
4:65a7088:      */
1:65a7088:     public final boolean isContains()
1:8b81c8f:     {
1:65a7088:         return relationType == Operator.CONTAINS;
1:d12a0d7:     }
1:655ccc3: 
4:65a7088:     /**
1:65a7088:      * Checks if the operator of this relation is a <code>CONTAINS_KEY</code>.
1:65a7088:      * @return <code>true</code>  if the operator of this relation is a <code>CONTAINS_KEY</code>, <code>false</code>
1:65a7088:      * otherwise.
1:65a7088:      */
1:65a7088:     public final boolean isContainsKey()
5:655ccc3:     {
1:65a7088:         return relationType == Operator.CONTAINS_KEY;
4:655ccc3:     }
1:655ccc3: 
1:65a7088:     /**
1:65a7088:      * Checks if the operator of this relation is a <code>IN</code>.
1:65a7088:      * @return <code>true</code>  if the operator of this relation is a <code>IN</code>, <code>false</code>
1:65a7088:      * otherwise.
1:65a7088:      */
1:65a7088:     public final boolean isIN()
1:655ccc3:     {
1:65a7088:         return relationType == Operator.IN;
1:655ccc3:     }
1:655ccc3: 
1:65a7088:     /**
1:65a7088:      * Checks if the operator of this relation is a <code>EQ</code>.
1:65a7088:      * @return <code>true</code>  if the operator of this relation is a <code>EQ</code>, <code>false</code>
1:65a7088:      * otherwise.
1:65a7088:      */
1:65a7088:     public final boolean isEQ()
1:655ccc3:     {
1:65a7088:         return relationType == Operator.EQ;
1:655ccc3:     }
1:655ccc3: 
1:3928665:     public final boolean isLIKE()
1:655ccc3:     {
1:3928665:         return relationType == Operator.LIKE_PREFIX
1:3928665:                 || relationType == Operator.LIKE_SUFFIX
1:479e8af:                 || relationType == Operator.LIKE_CONTAINS
1:bdae452:                 || relationType == Operator.LIKE_MATCHES
1:bdae452:                 || relationType == Operator.LIKE;
1:655ccc3:     }
1:655ccc3: 
1:65a7088:     /**
1:65a7088:      * Checks if the operator of this relation is a <code>Slice</code> (GT, GTE, LTE, LT).
4:65a7088:      *
1:65a7088:      * @return <code>true</code> if the operator of this relation is a <code>Slice</code>, <code>false</code> otherwise.
1:65a7088:      */
1:65a7088:     public final boolean isSlice()
1:655ccc3:     {
1:65a7088:         return relationType == Operator.GT
1:65a7088:                 || relationType == Operator.GTE
1:65a7088:                 || relationType == Operator.LTE
1:65a7088:                 || relationType == Operator.LT;
1:655ccc3:     }
1:655ccc3: 
1:65a7088:     /**
1:65a7088:      * Converts this <code>Relation</code> into a <code>Restriction</code>.
1:65a7088:      *
1:65a7088:      * @param cfm the Column Family meta data
1:65a7088:      * @param boundNames the variables specification where to collect the bind variables
1:65a7088:      * @return the <code>Restriction</code> corresponding to this <code>Relation</code>
1:65a7088:      * @throws InvalidRequestException if this <code>Relation</code> is not valid
1:65a7088:      */
1:65a7088:     public final Restriction toRestriction(CFMetaData cfm,
1:65a7088:                                            VariableSpecifications boundNames) throws InvalidRequestException
1:655ccc3:     {
1:65a7088:         switch (relationType)
1:655ccc3:         {
1:65a7088:             case EQ: return newEQRestriction(cfm, boundNames);
1:65a7088:             case LT: return newSliceRestriction(cfm, boundNames, Bound.END, false);
1:65a7088:             case LTE: return newSliceRestriction(cfm, boundNames, Bound.END, true);
1:65a7088:             case GTE: return newSliceRestriction(cfm, boundNames, Bound.START, true);
1:65a7088:             case GT: return newSliceRestriction(cfm, boundNames, Bound.START, false);
1:65a7088:             case IN: return newINRestriction(cfm, boundNames);
1:65a7088:             case CONTAINS: return newContainsRestriction(cfm, boundNames, false);
1:65a7088:             case CONTAINS_KEY: return newContainsRestriction(cfm, boundNames, true);
1:5a4253b:             case IS_NOT: return newIsNotRestriction(cfm, boundNames);
1:3928665:             case LIKE_PREFIX:
1:3928665:             case LIKE_SUFFIX:
1:3928665:             case LIKE_CONTAINS:
1:479e8af:             case LIKE_MATCHES:
1:bdae452:             case LIKE:
1:3928665:                 return newLikeRestriction(cfm, boundNames, relationType);
1:65a7088:             default: throw invalidRequest("Unsupported \"!=\" relation: %s", this);
1:655ccc3:         }
1:655ccc3:     }
1:655ccc3: 
1:65a7088:     /**
1:65a7088:      * Creates a new EQ restriction instance.
1:65a7088:      *
1:65a7088:      * @param cfm the Column Family meta data
1:65a7088:      * @param boundNames the variables specification where to collect the bind variables
1:65a7088:      * @return a new EQ restriction instance.
1:65a7088:      * @throws InvalidRequestException if the relation cannot be converted into an EQ restriction.
1:65a7088:      */
1:65a7088:     protected abstract Restriction newEQRestriction(CFMetaData cfm,
1:65a7088:                                                     VariableSpecifications boundNames) throws InvalidRequestException;
1:655ccc3: 
1:65a7088:     /**
1:65a7088:      * Creates a new IN restriction instance.
1:65a7088:      *
1:65a7088:      * @param cfm the Column Family meta data
1:65a7088:      * @param boundNames the variables specification where to collect the bind variables
1:65a7088:      * @return a new IN restriction instance
1:65a7088:      * @throws InvalidRequestException if the relation cannot be converted into an IN restriction.
1:65a7088:      */
1:65a7088:     protected abstract Restriction newINRestriction(CFMetaData cfm,
1:65a7088:                                                     VariableSpecifications boundNames) throws InvalidRequestException;
1:655ccc3: 
1:65a7088:     /**
1:65a7088:      * Creates a new Slice restriction instance.
1:65a7088:      *
1:65a7088:      * @param cfm the Column Family meta data
1:65a7088:      * @param boundNames the variables specification where to collect the bind variables
1:65a7088:      * @param bound the slice bound
1:65a7088:      * @param inclusive <code>true</code> if the bound is included.
1:65a7088:      * @return a new slice restriction instance
1:65a7088:      * @throws InvalidRequestException if the <code>Relation</code> is not valid
1:65a7088:      */
1:65a7088:     protected abstract Restriction newSliceRestriction(CFMetaData cfm,
1:65a7088:                                                        VariableSpecifications boundNames,
1:65a7088:                                                        Bound bound,
1:65a7088:                                                        boolean inclusive) throws InvalidRequestException;
1:3928665: 
1:65a7088:     /**
1:65a7088:      * Creates a new Contains restriction instance.
1:65a7088:      *
1:65a7088:      * @param cfm the Column Family meta data
1:65a7088:      * @param boundNames the variables specification where to collect the bind variables
1:65a7088:      * @param isKey <code>true</code> if the restriction to create is a CONTAINS KEY
1:65a7088:      * @return a new Contains <code>Restriction</code> instance
1:65a7088:      * @throws InvalidRequestException if the <code>Relation</code> is not valid
1:65a7088:      */
1:65a7088:     protected abstract Restriction newContainsRestriction(CFMetaData cfm,
1:65a7088:                                                           VariableSpecifications boundNames,
1:65a7088:                                                           boolean isKey) throws InvalidRequestException;
1:5a4253b: 
1:5a4253b:     protected abstract Restriction newIsNotRestriction(CFMetaData cfm,
1:5a4253b:                                                        VariableSpecifications boundNames) throws InvalidRequestException;
1:5a4253b: 
1:3928665:     protected abstract Restriction newLikeRestriction(CFMetaData cfm,
1:3928665:                                                       VariableSpecifications boundNames,
1:3928665:                                                       Operator operator) throws InvalidRequestException;
1:3928665: 
1:65a7088:     /**
1:65a7088:      * Converts the specified <code>Raw</code> into a <code>Term</code>.
1:65a7088:      * @param receivers the columns to which the values must be associated at
1:65a7088:      * @param raw the raw term to convert
1:65a7088:      * @param keyspace the keyspace name
1:65a7088:      * @param boundNames the variables specification where to collect the bind variables
1:65a7088:      *
1:65a7088:      * @return the <code>Term</code> corresponding to the specified <code>Raw</code>
1:65a7088:      * @throws InvalidRequestException if the <code>Raw</code> term is not valid
1:65a7088:      */
1:65a7088:     protected abstract Term toTerm(List<? extends ColumnSpecification> receivers,
1:65a7088:                                    Term.Raw raw,
1:65a7088:                                    String keyspace,
1:65a7088:                                    VariableSpecifications boundNames)
1:65a7088:                                    throws InvalidRequestException;
1:5a4253b: 
1:65a7088:     /**
1:65a7088:      * Converts the specified <code>Raw</code> terms into a <code>Term</code>s.
1:65a7088:      * @param receivers the columns to which the values must be associated at
1:65a7088:      * @param raws the raw terms to convert
1:65a7088:      * @param keyspace the keyspace name
1:65a7088:      * @param boundNames the variables specification where to collect the bind variables
1:65a7088:      *
1:65a7088:      * @return the <code>Term</code>s corresponding to the specified <code>Raw</code> terms
1:65a7088:      * @throws InvalidRequestException if the <code>Raw</code> terms are not valid
1:65a7088:      */
1:65a7088:     protected final List<Term> toTerms(List<? extends ColumnSpecification> receivers,
1:65a7088:                                        List<? extends Term.Raw> raws,
1:65a7088:                                        String keyspace,
1:65a7088:                                        VariableSpecifications boundNames) throws InvalidRequestException
1:655ccc3:     {
1:65a7088:         if (raws == null)
1:655ccc3:             return null;
1:65a7088: 
1:65a7088:         List<Term> terms = new ArrayList<>();
1:65a7088:         for (int i = 0, m = raws.size(); i < m; i++)
1:65a7088:             terms.add(toTerm(receivers, raws.get(i), keyspace, boundNames));
1:65a7088: 
1:65a7088:         return terms;
1:655ccc3:     }
1:65a7088: 
1:65a7088:     /**
1:5a4253b:      * Renames an identifier in this Relation, if applicable.
1:5a4253b:      * @param from the old identifier
1:5a4253b:      * @param to the new identifier
1:5a4253b:      * @return this object, if the old identifier is not in the set of entities that this relation covers; otherwise
1:5a4253b:      *         a new Relation with "from" replaced by "to" is returned.
1:5a4253b:      */
1:4ed0060:     public abstract Relation renameIdentifier(ColumnDefinition.Raw from, ColumnDefinition.Raw to);
1:655ccc3: }
============================================================================
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:4ed0060
/////////////////////////////////////////////////////////////////////////
1: public abstract class Relation
1: {
/////////////////////////////////////////////////////////////////////////
1:     public abstract Relation renameIdentifier(ColumnDefinition.Raw from, ColumnDefinition.Raw to);
commit:4c727f6
commit:652ec6a
/////////////////////////////////////////////////////////////////////////
0:     // Will be null unless for tuple notations (#4851)
0:     public final ColumnIdentifier previousInTuple;
1: 
0:     private Relation(ColumnIdentifier entity, Type type, Term.Raw value, List<Term.Raw> inValues, boolean onToken, ColumnIdentifier previousInTuple)
0:         this.previousInTuple = previousInTuple;
/////////////////////////////////////////////////////////////////////////
0:         this(entity, type, value, null, false, null);
0:         this(entity, type, value, null, onToken, null);
1:     }
1: 
0:     public Relation(ColumnIdentifier entity, Type type, Term.Raw value, ColumnIdentifier previousInTuple)
1:     {
0:         this(entity, type, value, null, false, previousInTuple);
0:         return new Relation(entity, Type.IN, null, new ArrayList<Term.Raw>(), false, null);
commit:d12a0d7
/////////////////////////////////////////////////////////////////////////
0:         EQ, LT, LTE, GTE, GT, IN, CONTAINS, CONTAINS_KEY;
1: 
0:         public boolean allowsIndexQuery()
1:         {
0:             switch (this)
1:             {
0:                 case EQ:
0:                 case CONTAINS:
0:                 case CONTAINS_KEY:
0:                     return true;
0:                 default:
1:                     return false;
1:             }
1:         }
commit:e93578b
/////////////////////////////////////////////////////////////////////////
0:         assert relationType != Type.IN || value == null || value instanceof AbstractMarker.INRaw;
commit:31e669a
/////////////////////////////////////////////////////////////////////////
0:     private final Term.Raw value;
0:     private final List<Term.Raw> inValues;
0:     private Relation(ColumnIdentifier entity, Type type, Term.Raw value, List<Term.Raw> inValues, boolean onToken)
/////////////////////////////////////////////////////////////////////////
0:     public Relation(ColumnIdentifier entity, Type type, Term.Raw value)
0:         this(entity, type, value, null, false);
0:     public Relation(ColumnIdentifier entity, Type type, Term.Raw value, boolean onToken)
0:         this(entity, type, value, null, onToken);
0:         return new Relation(entity, Type.IN, null, new ArrayList<Term.Raw>(), false);
/////////////////////////////////////////////////////////////////////////
0:     public Term.Raw getValue()
0:     public List<Term.Raw> getInValues()
0:     public void addInValue(Term.Raw t)
commit:8b81c8f
/////////////////////////////////////////////////////////////////////////
0:     public final boolean onToken;
/////////////////////////////////////////////////////////////////////////
0:     private Relation(ColumnIdentifier entity, Type type, Term value, List<Term> inValues, boolean onToken)
0:         this.onToken = onToken;
/////////////////////////////////////////////////////////////////////////
0:         this(entity, Type.forString(type), value, null, false);
1:     }
1: 
0:     public Relation(ColumnIdentifier entity, String type, Term value, boolean onToken)
1:     {
0:         this(entity, Type.forString(type), value, null, onToken);
0:         return new Relation(entity, Type.IN, null, new ArrayList<Term>(), false);
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
commit:655ccc3
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
1:  */
1: package org.apache.cassandra.cql3;
1: 
1: import java.util.ArrayList;
1: import java.util.List;
1: 
1: /**
0:  * Relations encapsulate the relationship between an entity of some kind, and
0:  * a value (term). For example, <key> > "start" or "colname1" = "somevalue".
1:  *
1:  */
0: public class Relation
1: {
0:     private final ColumnIdentifier entity;
0:     private final Type relationType;
0:     private final Term value;
0:     private final List<Term> inValues;
1: 
0:     public static enum Type
1:     {
0:         EQ, LT, LTE, GTE, GT, IN;
1: 
0:         public static Type forString(String s)
1:         {
0:             if (s.equals("="))
0:                 return EQ;
0:             else if (s.equals("<"))
0:                 return LT;
0:             else if (s.equals("<="))
0:                 return LTE;
0:             else if (s.equals(">="))
0:                 return GTE;
0:             else if (s.equals(">"))
0:                 return GT;
1: 
1:             return null;
1:         }
1:     }
1: 
0:     private Relation(ColumnIdentifier entity, Type type, Term value, List<Term> inValues)
1:     {
0:         this.entity = entity;
0:         this.relationType = type;
0:         this.value = value;
0:         this.inValues = inValues;
1:     }
1: 
1:     /**
0:      * Creates a new relation.
1:      *
0:      * @param entity the kind of relation this is; what the term is being compared to.
0:      * @param type the type that describes how this entity relates to the value.
0:      * @param value the value being compared.
1:      */
0:     public Relation(ColumnIdentifier entity, String type, Term value)
1:     {
0:         this(entity, Type.forString(type), value, null);
1:     }
1: 
0:     public static Relation createInRelation(ColumnIdentifier entity)
1:     {
0:         return new Relation(entity, Type.IN, null, new ArrayList<Term>());
1:     }
1: 
0:     public Type operator()
1:     {
1:         return relationType;
1:     }
1: 
0:     public ColumnIdentifier getEntity()
1:     {
0:         return entity;
1:     }
1: 
0:     public Term getValue()
1:     {
0:         assert relationType != Type.IN;
0:         return value;
1:     }
1: 
0:     public List<Term> getInValues()
1:     {
0:         assert relationType == Type.IN;
0:         return inValues;
1:     }
1: 
0:     public void addInValue(Term t)
1:     {
0:         inValues.add(t);
1:     }
1: 
0:     @Override
0:     public String toString()
1:     {
0:         if (relationType == Type.IN)
0:             return String.format("%s IN %s", entity, inValues);
0:         else
0:             return String.format("%s %s %s", entity, relationType, value);
1:     }
1: }
author:Sam Tunnicliffe
-------------------------------------------------------------------------------
commit:bdae452
/////////////////////////////////////////////////////////////////////////
1:                 || relationType == Operator.LIKE_MATCHES
1:                 || relationType == Operator.LIKE;
/////////////////////////////////////////////////////////////////////////
1:             case LIKE:
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:479e8af
/////////////////////////////////////////////////////////////////////////
1:                 || relationType == Operator.LIKE_CONTAINS
0:                 || relationType == Operator.LIKE_MATCHES;
/////////////////////////////////////////////////////////////////////////
1:             case LIKE_MATCHES:
commit:3928665
/////////////////////////////////////////////////////////////////////////
1:     public final boolean isLIKE()
0:     {
1:         return relationType == Operator.LIKE_PREFIX
1:                 || relationType == Operator.LIKE_SUFFIX
0:                 || relationType == Operator.LIKE_CONTAINS;
0:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             case LIKE_PREFIX:
1:             case LIKE_SUFFIX:
1:             case LIKE_CONTAINS:
1:                 return newLikeRestriction(cfm, boundNames, relationType);
/////////////////////////////////////////////////////////////////////////
1:     protected abstract Restriction newLikeRestriction(CFMetaData cfm,
1:                                                       VariableSpecifications boundNames,
1:                                                       Operator operator) throws InvalidRequestException;
1: 
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:5a4253b
/////////////////////////////////////////////////////////////////////////
1:      * Returns the raw value for this relation, or null if this is an IN relation.
1:      */
1:     public abstract Term.Raw getValue();
1: 
1:     /**
1:      * Returns the list of raw IN values for this relation, or null if this is not an IN relation.
1:      */
1:     public abstract List<? extends Term.Raw> getInValues();
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:             case IS_NOT: return newIsNotRestriction(cfm, boundNames);
/////////////////////////////////////////////////////////////////////////
1:     protected abstract Restriction newIsNotRestriction(CFMetaData cfm,
1:                                                        VariableSpecifications boundNames) throws InvalidRequestException;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Renames an identifier in this Relation, if applicable.
1:      * @param from the old identifier
1:      * @param to the new identifier
1:      * @return this object, if the old identifier is not in the set of entities that this relation covers; otherwise
1:      *         a new Relation with "from" replaced by "to" is returned.
1:      */
0:     public abstract Relation renameIdentifier(ColumnIdentifier.Raw from, ColumnIdentifier.Raw to);
commit:3d5f3a6
/////////////////////////////////////////////////////////////////////////
0:         EQ, LT, LTE, GTE, GT, IN, CONTAINS, CONTAINS_KEY, NEQ;
/////////////////////////////////////////////////////////////////////////
0:                 case NEQ:
0:                     return "!=";
commit:bf52190
commit:4349638
/////////////////////////////////////////////////////////////////////////
0: public abstract class Relation {
0:     protected Type relationType;
0:         @Override
0:         public String toString()
0:         {
0:             switch (this)
0:             {
0:                 case EQ:
0:                     return "=";
0:                 case LT:
0:                     return "<";
0:                 case LTE:
0:                     return "<=";
0:                 case GT:
0:                     return ">";
0:                 case GTE:
0:                     return ">=";
0:                 case IN:
0:                     return "IN";
0:                 default:
0:                     return this.name();
0:             }
0:         }
/////////////////////////////////////////////////////////////////////////
0:     public abstract boolean isMultiColumn();
author:blerer
-------------------------------------------------------------------------------
commit:65a7088
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
0: import java.util.List;
1: 
1: import org.apache.cassandra.config.CFMetaData;
1: import org.apache.cassandra.config.ColumnDefinition;
1: import org.apache.cassandra.cql3.restrictions.Restriction;
1: import org.apache.cassandra.cql3.statements.Bound;
1: import org.apache.cassandra.exceptions.InvalidRequestException;
0: import org.apache.cassandra.exceptions.UnrecognizedEntityException;
1: 
1: import static org.apache.cassandra.cql3.statements.RequestValidations.invalidRequest;
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Checks if this relation apply to multiple columns.
1:      *
1:      * @return <code>true</code> if this relation apply to multiple columns, <code>false</code> otherwise.
1:      */
1:     public boolean isMultiColumn()
0:     {
1:         return false;
0:     }
0: 
1:     /**
1:      * Checks if this relation is a token relation (e.g. <pre>token(a) = token(1)</pre>).
1:      *
1:      * @return <code>true</code> if this relation is a token relation, <code>false</code> otherwise.
1:      */
1:     public boolean onToken()
0:     {
1:         return false;
0:     }
0: 
1:     /**
1:      * Checks if the operator of this relation is a <code>CONTAINS</code>.
1:      * @return <code>true</code>  if the operator of this relation is a <code>CONTAINS</code>, <code>false</code>
1:      * otherwise.
1:      */
1:     public final boolean isContains()
0:     {
1:         return relationType == Operator.CONTAINS;
0:     }
0: 
1:     /**
1:      * Checks if the operator of this relation is a <code>CONTAINS_KEY</code>.
1:      * @return <code>true</code>  if the operator of this relation is a <code>CONTAINS_KEY</code>, <code>false</code>
1:      * otherwise.
1:      */
1:     public final boolean isContainsKey()
0:     {
1:         return relationType == Operator.CONTAINS_KEY;
0:     }
0: 
1:     /**
1:      * Checks if the operator of this relation is a <code>IN</code>.
1:      * @return <code>true</code>  if the operator of this relation is a <code>IN</code>, <code>false</code>
1:      * otherwise.
1:      */
1:     public final boolean isIN()
0:     {
1:         return relationType == Operator.IN;
0:     }
0: 
1:     /**
1:      * Checks if the operator of this relation is a <code>EQ</code>.
1:      * @return <code>true</code>  if the operator of this relation is a <code>EQ</code>, <code>false</code>
1:      * otherwise.
1:      */
1:     public final boolean isEQ()
0:     {
1:         return relationType == Operator.EQ;
0:     }
0: 
1:     /**
1:      * Checks if the operator of this relation is a <code>Slice</code> (GT, GTE, LTE, LT).
1:      *
1:      * @return <code>true</code> if the operator of this relation is a <code>Slice</code>, <code>false</code> otherwise.
1:      */
1:     public final boolean isSlice()
0:     {
1:         return relationType == Operator.GT
1:                 || relationType == Operator.GTE
1:                 || relationType == Operator.LTE
1:                 || relationType == Operator.LT;
0:     }
0: 
1:     /**
1:      * Converts this <code>Relation</code> into a <code>Restriction</code>.
1:      *
1:      * @param cfm the Column Family meta data
1:      * @param boundNames the variables specification where to collect the bind variables
1:      * @return the <code>Restriction</code> corresponding to this <code>Relation</code>
1:      * @throws InvalidRequestException if this <code>Relation</code> is not valid
1:      */
1:     public final Restriction toRestriction(CFMetaData cfm,
1:                                            VariableSpecifications boundNames) throws InvalidRequestException
0:     {
1:         switch (relationType)
0:         {
1:             case EQ: return newEQRestriction(cfm, boundNames);
1:             case LT: return newSliceRestriction(cfm, boundNames, Bound.END, false);
1:             case LTE: return newSliceRestriction(cfm, boundNames, Bound.END, true);
1:             case GTE: return newSliceRestriction(cfm, boundNames, Bound.START, true);
1:             case GT: return newSliceRestriction(cfm, boundNames, Bound.START, false);
1:             case IN: return newINRestriction(cfm, boundNames);
1:             case CONTAINS: return newContainsRestriction(cfm, boundNames, false);
1:             case CONTAINS_KEY: return newContainsRestriction(cfm, boundNames, true);
1:             default: throw invalidRequest("Unsupported \"!=\" relation: %s", this);
0:         }
0:     }
0: 
1:     /**
1:      * Creates a new EQ restriction instance.
1:      *
1:      * @param cfm the Column Family meta data
1:      * @param boundNames the variables specification where to collect the bind variables
1:      * @return a new EQ restriction instance.
1:      * @throws InvalidRequestException if the relation cannot be converted into an EQ restriction.
1:      */
1:     protected abstract Restriction newEQRestriction(CFMetaData cfm,
1:                                                     VariableSpecifications boundNames) throws InvalidRequestException;
0: 
1:     /**
1:      * Creates a new IN restriction instance.
1:      *
1:      * @param cfm the Column Family meta data
1:      * @param boundNames the variables specification where to collect the bind variables
1:      * @return a new IN restriction instance
1:      * @throws InvalidRequestException if the relation cannot be converted into an IN restriction.
1:      */
1:     protected abstract Restriction newINRestriction(CFMetaData cfm,
1:                                                     VariableSpecifications boundNames) throws InvalidRequestException;
0: 
1:     /**
1:      * Creates a new Slice restriction instance.
1:      *
1:      * @param cfm the Column Family meta data
1:      * @param boundNames the variables specification where to collect the bind variables
1:      * @param bound the slice bound
1:      * @param inclusive <code>true</code> if the bound is included.
1:      * @return a new slice restriction instance
1:      * @throws InvalidRequestException if the <code>Relation</code> is not valid
1:      */
1:     protected abstract Restriction newSliceRestriction(CFMetaData cfm,
1:                                                        VariableSpecifications boundNames,
1:                                                        Bound bound,
1:                                                        boolean inclusive) throws InvalidRequestException;
0: 
1:     /**
1:      * Creates a new Contains restriction instance.
1:      *
1:      * @param cfm the Column Family meta data
1:      * @param boundNames the variables specification where to collect the bind variables
1:      * @param isKey <code>true</code> if the restriction to create is a CONTAINS KEY
1:      * @return a new Contains <code>Restriction</code> instance
1:      * @throws InvalidRequestException if the <code>Relation</code> is not valid
1:      */
1:     protected abstract Restriction newContainsRestriction(CFMetaData cfm,
1:                                                           VariableSpecifications boundNames,
1:                                                           boolean isKey) throws InvalidRequestException;
0: 
1:     /**
1:      * Converts the specified <code>Raw</code> into a <code>Term</code>.
1:      * @param receivers the columns to which the values must be associated at
1:      * @param raw the raw term to convert
1:      * @param keyspace the keyspace name
1:      * @param boundNames the variables specification where to collect the bind variables
1:      *
1:      * @return the <code>Term</code> corresponding to the specified <code>Raw</code>
1:      * @throws InvalidRequestException if the <code>Raw</code> term is not valid
1:      */
1:     protected abstract Term toTerm(List<? extends ColumnSpecification> receivers,
1:                                    Term.Raw raw,
1:                                    String keyspace,
1:                                    VariableSpecifications boundNames)
1:                                    throws InvalidRequestException;
0: 
1:     /**
1:      * Converts the specified <code>Raw</code> terms into a <code>Term</code>s.
1:      * @param receivers the columns to which the values must be associated at
1:      * @param raws the raw terms to convert
1:      * @param keyspace the keyspace name
1:      * @param boundNames the variables specification where to collect the bind variables
1:      *
1:      * @return the <code>Term</code>s corresponding to the specified <code>Raw</code> terms
1:      * @throws InvalidRequestException if the <code>Raw</code> terms are not valid
1:      */
1:     protected final List<Term> toTerms(List<? extends ColumnSpecification> receivers,
1:                                        List<? extends Term.Raw> raws,
1:                                        String keyspace,
1:                                        VariableSpecifications boundNames) throws InvalidRequestException
0:     {
1:         if (raws == null)
0:             return null;
0: 
1:         List<Term> terms = new ArrayList<>();
1:         for (int i = 0, m = raws.size(); i < m; i++)
1:             terms.add(toTerm(receivers, raws.get(i), keyspace, boundNames));
0: 
1:         return terms;
0:     }
0: 
1:     /**
0:      * Converts the specified entity into a column definition.
1:      *
0:      * @param cfm the column family meta data
0:      * @param entity the entity to convert
0:      * @return the column definition corresponding to the specified entity
0:      * @throws InvalidRequestException if the entity cannot be recognized
1:      */
0:     protected final ColumnDefinition toColumnDefinition(CFMetaData cfm,
0:                                                         ColumnIdentifier.Raw entity) throws InvalidRequestException
0:     {
0:         ColumnIdentifier identifier = entity.prepare(cfm);
0:         ColumnDefinition def = cfm.getColumnDefinition(identifier);
0: 
0:         if (def == null)
0:             throw new UnrecognizedEntityException(identifier, this);
0: 
0:         return def;
0:     }
commit:5117a5d
/////////////////////////////////////////////////////////////////////////
1:     protected Operator relationType;
1:     public Operator operator()
commit:52a701f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.ColumnDefinition;
0: import org.apache.cassandra.db.index.SecondaryIndex;
0: import org.apache.cassandra.db.marshal.CollectionType;
0: 
/////////////////////////////////////////////////////////////////////////
0:         EQ
0:             public boolean allowsIndexQueryOn(ColumnDefinition columnDef)
0:                 return columnDef.isIndexed();
0:         },
0:         LT,
0:         LTE,
0:         GTE,
0:         GT,
0:         IN,
0:         CONTAINS
0:         {
0:             public boolean allowsIndexQueryOn(ColumnDefinition columnDef)
0:             {
0:                 return columnDef.isIndexed()
0:                         && columnDef.type.isCollection()
0:                         && (!((CollectionType<?>) columnDef.type).isMap()
0:                                 || columnDef.hasIndexOption(SecondaryIndex.INDEX_VALUES_OPTION_NAME));
0:             }
0:         },
0:         CONTAINS_KEY
0:         {
0:             public boolean allowsIndexQueryOn(ColumnDefinition columnDef)
0:             {
0:                 return columnDef.isIndexed()
0:                         && columnDef.type.isCollection()
0:                         && (!((CollectionType<?>) columnDef.type).isMap()
0:                                 || columnDef.hasIndexOption(SecondaryIndex.INDEX_KEYS_OPTION_NAME));
0:             }
0:         },
0:         NEQ;
0: 
0:         /**
0:          * Checks if this relation type allow index queries on the specified column
0:          *
0:          * @param columnDef the column definition.
0:          * @return <code>true</code> if this relation type allow index queries on the specified column,
0:          * <code>false</code> otherwise.
0:          */
0:         public boolean allowsIndexQueryOn(ColumnDefinition columnDef)
0:         {
0:             return false;
/////////////////////////////////////////////////////////////////////////
0:                 case CONTAINS_KEY:
0:                     return "CONTAINS KEY";
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:4357676
============================================================================