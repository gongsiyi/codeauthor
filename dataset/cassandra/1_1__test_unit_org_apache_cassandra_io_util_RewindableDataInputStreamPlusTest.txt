1:e8651b6: /*
1:e8651b6:  * Licensed to the Apache Software Foundation (ASF) under one
1:e8651b6:  * or more contributor license agreements.  See the NOTICE file
1:e8651b6:  * distributed with this work for additional information
1:e8651b6:  * regarding copyright ownership.  The ASF licenses this file
1:e8651b6:  * to you under the Apache License, Version 2.0 (the
1:e8651b6:  * "License"); you may not use this file except in compliance
1:e8651b6:  * with the License.  You may obtain a copy of the License at
1:e8651b6:  *
1:e8651b6:  *     http://www.apache.org/licenses/LICENSE-2.0
1:e8651b6:  *
1:e8651b6:  * Unless required by applicable law or agreed to in writing, software
1:e8651b6:  * distributed under the License is distributed on an "AS IS" BASIS,
1:e8651b6:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:e8651b6:  * See the License for the specific language governing permissions and
1:e8651b6:  * limitations under the License.
1:e8651b6:  */
1:e8651b6: 
1:e8651b6: package org.apache.cassandra.io.util;
1:e8651b6: 
1:e8651b6: import java.io.ByteArrayInputStream;
1:e8651b6: import java.io.ByteArrayOutputStream;
1:e8651b6: import java.io.DataOutputStream;
1:e8651b6: import java.io.File;
1:e8651b6: import java.io.IOException;
1:e8651b6: 
1:e8651b6: import org.junit.Before;
1:e8651b6: import org.junit.Test;
1:e8651b6: 
1:e8651b6: import static org.junit.Assert.assertEquals;
1:e8651b6: import static org.junit.Assert.assertFalse;
1:e8651b6: import static org.junit.Assert.assertTrue;
1:e8651b6: import static org.junit.Assert.fail;
1:e8651b6: 
1:e8651b6: public class RewindableDataInputStreamPlusTest
1:e8651b6: {
1:e8651b6: 
1:e8651b6:     private final int INITIAL_BUFFER_SIZE = 1;
1:e8651b6: 
1:e8651b6:     private File file;
1:e8651b6: 
1:e8651b6:     @Before
1:e8651b6:     public void setup() throws Exception
1:e8651b6:     {
1:e8651b6:         this.file = new File(System.getProperty("java.io.tmpdir"), "subdir/test.buffer");
1:e8651b6:     }
1:e8651b6: 
1:e8651b6:     @Test
1:e8651b6:     public void testMarkAndResetSimple() throws Exception
1:e8651b6:     {
1:e8651b6:         byte[] testData;
1:e8651b6: 
1:e8651b6:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:e8651b6:         try (DataOutputStream out = new DataOutputStream(baos))
1:e8651b6:         {
1:e8651b6:             // boolean
1:e8651b6:             out.writeBoolean(true);
1:e8651b6:             // byte
1:e8651b6:             out.writeByte(0x1);
1:e8651b6:             // char
1:e8651b6:             out.writeChar('a');
1:e8651b6:             // short
1:e8651b6:             out.writeShort(1);
1:e8651b6:             // int
1:e8651b6:             out.writeInt(1);
1:e8651b6:             // long
1:e8651b6:             out.writeLong(1L);
1:e8651b6:             // float
1:e8651b6:             out.writeFloat(1.0f);
1:e8651b6:             // double
1:e8651b6:             out.writeDouble(1.0d);
1:e8651b6: 
1:e8651b6:             // String
1:e8651b6:             out.writeUTF("abc");
1:e8651b6:             testData = baos.toByteArray();
1:e8651b6:         }
1:e8651b6: 
1:e8651b6:         for (int memCapacity = 0; memCapacity <= 16; memCapacity++)
1:e8651b6:         {
1:e8651b6:             int diskCapacity = 16 - memCapacity;
1:e8651b6:             try (RewindableDataInputStreamPlus reader = new RewindableDataInputStreamPlus(new ByteArrayInputStream(testData),
1:e8651b6:                                                                                           INITIAL_BUFFER_SIZE, memCapacity, file,
1:e8651b6:                                                                                           diskCapacity))
1:e8651b6:             {
1:e8651b6:                 try {
1:e8651b6:                     //should mark before resetting
1:e8651b6:                     reader.reset(null);
1:e8651b6:                     fail("Should have thrown IOException");
1:e8651b6:                 } catch (IOException e) {}
1:e8651b6: 
1:e8651b6:                 assertTrue(reader.readBoolean());
1:e8651b6: 
1:e8651b6:                 reader.mark();
1:e8651b6: 
1:e8651b6:                 try {
1:e8651b6:                     //cannot mark already marked stream
1:e8651b6:                     reader.mark();
1:e8651b6:                     fail("Should have thrown IllegalStateException");
1:e8651b6:                 } catch (IllegalStateException e) {}
1:e8651b6: 
1:e8651b6:                 assertEquals(0x1, reader.readByte());
1:e8651b6:                 assertEquals('a', reader.readChar());
1:e8651b6:                 assertEquals(3, reader.bytesPastMark(null));
1:e8651b6:                 reader.reset(null);
1:e8651b6: 
1:e8651b6:                 try {
1:e8651b6:                     //cannot mark when reading from cache
1:e8651b6:                     reader.mark();
1:e8651b6:                     fail("Should have thrown IllegalStateException");
1:e8651b6:                 } catch (IllegalStateException e) {}
1:e8651b6: 
1:e8651b6:                 //read again previous sequence
1:e8651b6:                 assertEquals(0x1, reader.readByte());
1:e8651b6:                 assertEquals('a', reader.readChar());
1:e8651b6:                 //finish reading again previous sequence
1:e8651b6:                 assertEquals(1, reader.readShort());
1:e8651b6: 
1:e8651b6:                 reader.mark();
1:e8651b6:                 assertEquals(1, reader.readInt());
1:e8651b6:                 assertEquals(1L, reader.readLong());
1:e8651b6:                 assertEquals(1.0f, reader.readFloat(), 0);
1:e8651b6:                 assertEquals(16, reader.bytesPastMark(null));
1:e8651b6:                 reader.reset(null);
1:e8651b6: 
1:e8651b6:                 //read again previous sequence
1:e8651b6:                 assertEquals(1, reader.readInt());
1:e8651b6:                 assertEquals(1L, reader.readLong());
1:e8651b6:                 assertEquals(1.0f, reader.readFloat(), 0);
1:e8651b6:                 //finish reading again previous sequence
1:e8651b6: 
1:e8651b6:                 //mark again
1:e8651b6:                 reader.mark();
1:e8651b6:                 assertEquals(1.0d, reader.readDouble(), 0);
1:e8651b6:                 assertEquals(8, reader.bytesPastMark(null));
1:e8651b6:                 reader.reset(null);
1:e8651b6: 
1:e8651b6:                 //read again previous sequence
1:e8651b6:                 assertEquals(1.0d, reader.readDouble(), 0);
1:e8651b6:                 //finish reading again previous sequence
1:e8651b6: 
1:e8651b6:                 //mark and reset
1:e8651b6:                 reader.mark();
1:e8651b6:                 reader.reset(null);
1:e8651b6: 
1:e8651b6:                 assertEquals("abc", reader.readUTF());
1:e8651b6: 
1:e8651b6:                 //check max file size
1:e8651b6:                 assertEquals(diskCapacity, file.length());
1:e8651b6:             }
1:e8651b6:             assertFalse(file.exists());
1:e8651b6:         }
1:e8651b6:     }
1:e8651b6: 
1:e8651b6:     @Test
1:e8651b6:     public void testVeryLargeCapacity() throws Exception
1:e8651b6:     {
1:e8651b6:         byte[] testData;
1:e8651b6: 
1:e8651b6:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:e8651b6:         try (DataOutputStream out = new DataOutputStream(baos))
1:e8651b6:         {
1:e8651b6:             out.writeUTF("abc");
1:e8651b6:             testData = baos.toByteArray();
1:e8651b6:         }
1:e8651b6: 
1:e8651b6:         try (RewindableDataInputStreamPlus reader = new RewindableDataInputStreamPlus(new ByteArrayInputStream(testData),
1:e8651b6:                                                                                       INITIAL_BUFFER_SIZE, Integer.MAX_VALUE, file,
1:e8651b6:                                                                                       Integer.MAX_VALUE))
1:e8651b6:         {
1:e8651b6:             reader.mark();
1:e8651b6:             assertEquals("abc", reader.readUTF());
1:e8651b6:             reader.reset();
1:e8651b6:             assertEquals("abc", reader.readUTF());
1:e8651b6:         }
1:e8651b6:         assertFalse(file.exists());
1:e8651b6: 
1:e8651b6: 
1:e8651b6:         baos = new ByteArrayOutputStream();
1:e8651b6:         try (DataOutputStream out = new DataOutputStream(baos))
1:e8651b6:         {
1:e8651b6:             out.writeBoolean(true);
1:e8651b6:             out.writeBoolean(true);
1:e8651b6:             testData = baos.toByteArray();
1:e8651b6:         }
1:e8651b6:     }
1:e8651b6: 
1:e8651b6:     @Test
1:e8651b6:     public void testMarkAndResetBigBuffer() throws Exception
1:e8651b6:     {
1:e8651b6:         byte[] testData;
1:e8651b6: 
1:e8651b6:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:e8651b6:         try (DataOutputStream out = new DataOutputStream(baos))
1:e8651b6:         {
1:e8651b6:             // boolean
1:e8651b6:             out.writeBoolean(true);
1:e8651b6:             // byte
1:e8651b6:             out.writeByte(0x1);
1:e8651b6:             // char
1:e8651b6:             out.writeChar('a');
1:e8651b6:             // short
1:e8651b6:             out.writeShort(1);
1:e8651b6:             // int
1:e8651b6:             out.writeInt(1);
1:e8651b6:             // long
1:e8651b6:             out.writeLong(1L);
1:e8651b6:             // float
1:e8651b6:             out.writeFloat(1.0f);
1:e8651b6:             // double
1:e8651b6:             out.writeDouble(1.0d);
1:e8651b6: 
1:e8651b6:             // String
1:e8651b6:             out.writeUTF("abc");
1:e8651b6:             testData = baos.toByteArray();
1:e8651b6: 
1:e8651b6:             // 1 (boolean) + 1 (byte) + 2 (char) + 2 (short) + 4 (int) + 8 (long)
1:e8651b6:             // + 4 (float) + 8 (double) + 5 bytes (utf string)
1:e8651b6:         }
1:e8651b6: 
1:e8651b6:         for (int memCapacity = 0; memCapacity <= 18; memCapacity++)
1:e8651b6:         {
1:e8651b6:             int diskCapacity = 18 - memCapacity;
1:e8651b6:             try (RewindableDataInputStreamPlus reader = new RewindableDataInputStreamPlus(new ByteArrayInputStream(testData),
1:e8651b6:                                                                                           INITIAL_BUFFER_SIZE, memCapacity, file,
1:e8651b6:                                                                                           diskCapacity))
1:e8651b6:             {
1:e8651b6:                 //read a big amount before resetting
1:e8651b6:                 reader.mark();
1:e8651b6:                 assertTrue(reader.readBoolean());
1:e8651b6:                 assertEquals(0x1, reader.readByte());
1:e8651b6:                 assertEquals('a', reader.readChar());
1:e8651b6:                 assertEquals(1, reader.readShort());
1:e8651b6:                 assertEquals(1, reader.readInt());
1:e8651b6:                 assertEquals(1L, reader.readLong());
1:e8651b6:                 reader.reset();
1:e8651b6: 
1:e8651b6:                 //read from buffer
1:e8651b6:                 assertTrue(reader.readBoolean());
1:e8651b6:                 assertEquals(0x1, reader.readByte());
1:e8651b6:                 assertEquals('a', reader.readChar());
1:e8651b6:                 assertEquals(1, reader.readShort());
1:e8651b6:                 assertEquals(1, reader.readInt());
1:e8651b6:                 assertEquals(1L, reader.readLong());
1:e8651b6: 
1:e8651b6:                 assertEquals(17, reader.available());
1:e8651b6: 
1:e8651b6:                 //mark again
1:e8651b6:                 reader.mark();
1:e8651b6:                 assertEquals(1.0f, reader.readFloat(), 0);
1:e8651b6:                 assertEquals(1.0d, reader.readDouble(), 0);
1:e8651b6:                 assertEquals("abc", reader.readUTF());
1:e8651b6:                 reader.reset();
1:e8651b6: 
1:e8651b6:                 assertEquals(17, reader.available());
1:e8651b6: 
1:e8651b6:                 assertEquals(1.0f, reader.readFloat(), 0);
1:e8651b6:                 assertEquals(1.0d, reader.readDouble(), 0);
1:e8651b6:                 assertEquals("abc", reader.readUTF());
1:e8651b6:             }
1:e8651b6:             assertFalse(file.exists());
1:e8651b6:         }
1:e8651b6:     }
1:e8651b6: 
1:e8651b6: 
1:e8651b6:     @Test
1:e8651b6:     public void testCircularSpillFile() throws Exception
1:e8651b6:     {
1:e8651b6:         byte[] testData;
1:e8651b6: 
1:e8651b6:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:e8651b6:         try (DataOutputStream out = new DataOutputStream(baos))
1:e8651b6:         {
1:e8651b6:             // boolean
1:e8651b6:             out.writeBoolean(true);
1:e8651b6:             // byte
1:e8651b6:             out.writeByte(0x1);
1:e8651b6:             // char
1:e8651b6:             out.writeChar('a');
1:e8651b6:             // short
1:e8651b6:             out.writeShort(1);
1:e8651b6:             // int
1:e8651b6:             out.writeInt(1);
1:e8651b6: 
1:e8651b6:             // String
1:e8651b6:             out.writeUTF("ab");
1:e8651b6:             testData = baos.toByteArray();
1:e8651b6: 
1:e8651b6:             // 1 (boolean) + 1 (byte) + 2 (char) + 2 (short) + 4 (int) + 4 bytes (utf string)
1:e8651b6:         }
1:e8651b6: 
1:e8651b6:         //read at most 4 bytes multiple times (and then check file size)
1:e8651b6:         int MEM_SIZE = 0;
1:e8651b6:         int DISK_SIZE = 4;
1:e8651b6:         try (RewindableDataInputStreamPlus reader = new RewindableDataInputStreamPlus(new ByteArrayInputStream(testData),
1:e8651b6:                                                                                       INITIAL_BUFFER_SIZE, MEM_SIZE, file,
1:e8651b6:                                                                                       DISK_SIZE))
1:e8651b6:         {
1:e8651b6:             //read 2 bytes and reset
1:e8651b6:             reader.mark();
1:e8651b6:             assertTrue(reader.readBoolean());
1:e8651b6:             assertEquals(0x1, reader.readByte());
1:e8651b6:             assertEquals(2, reader.bytesPastMark(null));
1:e8651b6:             reader.reset();
1:e8651b6: 
1:e8651b6:             //read again previous sequence
1:e8651b6:             assertTrue(reader.readBoolean());
1:e8651b6:             assertEquals(0x1, reader.readByte());
1:e8651b6:             //finish reading again previous sequence
1:e8651b6: 
1:e8651b6:             //read 4 bytes and reset
1:e8651b6:             reader.mark();
1:e8651b6:             assertEquals('a', reader.readChar());
1:e8651b6:             assertEquals(1, reader.readShort());
1:e8651b6:             assertEquals(4, reader.bytesPastMark(null));
1:e8651b6:             reader.reset();
1:e8651b6: 
1:e8651b6:             //read again previous sequence
1:e8651b6:             assertEquals('a', reader.readChar());
1:e8651b6:             assertEquals(1, reader.readShort());
1:e8651b6:             //finish reading again previous sequence
1:e8651b6: 
1:e8651b6:             //read 4 bytes and reset
1:e8651b6:             reader.mark();
1:e8651b6:             assertEquals(1, reader.readInt());
1:e8651b6:             assertEquals(4, reader.bytesPastMark(null));
1:e8651b6:             reader.reset();
1:e8651b6: 
1:e8651b6:             //read again previous sequence
1:e8651b6:             assertEquals(1, reader.readInt());
1:e8651b6: 
1:e8651b6:             //check max file size
1:e8651b6:             assertEquals(DISK_SIZE, file.length());
1:e8651b6:         }
1:e8651b6:         assertFalse(file.exists());
1:e8651b6:     }
1:e8651b6: 
1:e8651b6:     @Test
1:e8651b6:     public void testExhaustCapacity() throws Exception
1:e8651b6:     {
1:e8651b6:         byte[] testData;
1:e8651b6: 
1:e8651b6:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:e8651b6:         try (DataOutputStream out = new DataOutputStream(baos))
1:e8651b6:         {
1:e8651b6:             // boolean
1:e8651b6:             out.writeBoolean(true);
1:e8651b6:             // byte
1:e8651b6:             out.writeByte(0x1);
1:e8651b6:             // char
1:e8651b6:             out.writeChar('a');
1:e8651b6:             // short
1:e8651b6:             out.writeShort(1);
1:e8651b6:             testData = baos.toByteArray();
1:e8651b6:         }
1:e8651b6: 
1:e8651b6:         //test capacity exhausted when reading more than 4 bytes
1:e8651b6:         testCapacityExhausted(testData, 0, 2);
1:e8651b6:         testCapacityExhausted(testData, 2, 0);
1:e8651b6:         testCapacityExhausted(testData, 1, 1);
1:e8651b6:     }
1:e8651b6: 
1:e8651b6:     private void testCapacityExhausted(byte[] testData, int memSize, int diskSize) throws IOException
1:e8651b6:     {
1:e8651b6:         try (RewindableDataInputStreamPlus reader = new RewindableDataInputStreamPlus(new ByteArrayInputStream(testData),
1:e8651b6:                                                                                       INITIAL_BUFFER_SIZE, memSize, file,
1:e8651b6:                                                                                       diskSize))
1:e8651b6:         {
1:e8651b6:             //read 2 bytes and reset
1:e8651b6:             reader.mark();
1:e8651b6:             assertTrue(reader.readBoolean());
1:e8651b6:             assertEquals(0x1, reader.readByte());
1:e8651b6:             assertEquals(2, reader.bytesPastMark(null));
1:e8651b6:             reader.reset();
1:e8651b6: 
1:e8651b6:             //read again previous sequence
1:e8651b6:             assertTrue(reader.readBoolean());
1:e8651b6:             assertEquals(0x1, reader.readByte());
1:e8651b6:             //finish reading again previous sequence
1:e8651b6: 
1:e8651b6:             reader.mark();
1:e8651b6:             //read 3 bytes - OK
1:e8651b6:             assertEquals('a', reader.readChar());
1:e8651b6:             //read 1 more bytes - CAPACITY will exhaust when trying to reset :(
1:e8651b6:             assertEquals(1, reader.readShort());
1:e8651b6: 
1:e8651b6:             try
1:e8651b6:             {
1:e8651b6:                 reader.reset();
1:e8651b6:                 fail("Should have thrown IOException");
1:e8651b6:             }
1:e8651b6:             catch (IOException e) {}
1:e8651b6: 
1:e8651b6:             //check max file size
1:e8651b6:             assertEquals(diskSize, file.length());
1:e8651b6:         }
1:e8651b6:         assertFalse(file.exists());
1:e8651b6:     }
1:e8651b6: 
1:e8651b6:     @Test
1:e8651b6:     public void testMarkAndResetUnsignedRead() throws Exception
1:e8651b6:     {
1:e8651b6:         byte[] testData;
1:e8651b6: 
1:e8651b6:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:e8651b6:         try (DataOutputStream out = new DataOutputStream(baos))
1:e8651b6:         {
1:e8651b6:             // byte
1:e8651b6:             out.writeByte(0x1);
1:e8651b6:             // short
1:e8651b6:             out.writeShort(2);
1:e8651b6:             testData = baos.toByteArray();
1:e8651b6:         }
1:e8651b6: 
1:e8651b6:         for (int memCapacity = 0; memCapacity <= 1; memCapacity++)
1:e8651b6:         {
1:e8651b6:             int diskCapacity = 1 - memCapacity;
1:e8651b6:             try (RewindableDataInputStreamPlus reader = new RewindableDataInputStreamPlus(new ByteArrayInputStream(testData),
1:e8651b6:                                                                                           INITIAL_BUFFER_SIZE, memCapacity, file,
1:e8651b6:                                                                                           diskCapacity))
1:e8651b6:             {
1:e8651b6:                 reader.mark();
1:e8651b6:                 assertEquals(1, reader.readUnsignedByte());
1:e8651b6:                 reader.reset();
1:e8651b6:                 assertEquals(1, reader.readUnsignedByte());
1:e8651b6: 
1:e8651b6:                 //will read first byte of short 2
1:e8651b6:                 reader.mark();
1:e8651b6:                 assertEquals(0, reader.readUnsignedByte());
1:e8651b6:                 reader.reset();
1:e8651b6: 
1:e8651b6:                 assertEquals(2, reader.readUnsignedShort());
1:e8651b6: 
1:e8651b6:                 reader.mark();
1:e8651b6:                 reader.reset();
1:e8651b6:                 assertEquals(0, reader.available());
1:e8651b6:             }
1:e8651b6:         }
1:e8651b6:         assertFalse(file.exists());
1:e8651b6:     }
1:e8651b6: 
1:e8651b6:     @Test
1:e8651b6:     public void testMarkAndResetSkipBytes() throws Exception
1:e8651b6:     {
1:e8651b6:         String testStr = "1234567890";
1:e8651b6:         byte[] testData = testStr.getBytes();
1:e8651b6: 
1:e8651b6:         for (int memCapacity = 0; memCapacity <= 7; memCapacity++)
1:e8651b6:         {
1:e8651b6:             int diskCapacity = 7 - memCapacity;
1:e8651b6:             try (RewindableDataInputStreamPlus reader = new RewindableDataInputStreamPlus(new ByteArrayInputStream(testData),
1:e8651b6:                                                                                           INITIAL_BUFFER_SIZE, memCapacity, file,
1:e8651b6:                                                                                           diskCapacity))
1:e8651b6:             {
1:e8651b6:                 reader.mark();
1:e8651b6:                 // read first 5 bytes and rewind
1:e8651b6:                 byte[] out = new byte[5];
1:e8651b6:                 reader.readFully(out, 0, 5);
1:e8651b6:                 assertEquals("12345", new String(out));
1:e8651b6: 
1:e8651b6:                 // then skip 2 bytes (67)
1:e8651b6:                 reader.skipBytes(2);
1:e8651b6: 
1:e8651b6:                 assertEquals(7, reader.bytesPastMark(null));
1:e8651b6:                 reader.reset();
1:e8651b6: 
1:e8651b6:                 //now read part of the previously skipped bytes
1:e8651b6:                 out = new byte[5];
1:e8651b6:                 reader.readFully(out);
1:e8651b6:                 assertEquals("12345", new String(out));
1:e8651b6: 
1:e8651b6:                 //skip 3 bytes (2 from cache, 1 from stream)
1:e8651b6:                 reader.skip(3);
1:e8651b6: 
1:e8651b6:                 // mark and read 2 more bytes
1:e8651b6:                 reader.mark();
1:e8651b6:                 out = new byte[2];
1:e8651b6:                 reader.readFully(out);
1:e8651b6:                 assertEquals("90", new String(out));
1:e8651b6:                 assertEquals(0, reader.available());
1:e8651b6:                 reader.reset();
1:e8651b6: 
1:e8651b6:                 //reset and read only the next byte "9" in the third position
1:e8651b6:                 reader.readFully(out, 1, 1);
1:e8651b6:                 assertEquals("99", new String(out));
1:e8651b6: 
1:e8651b6:                 //now we read the remainder via readline
1:e8651b6:                 assertEquals(1, reader.available());
1:e8651b6:                 assertEquals("0", reader.readLine());
1:e8651b6: 
1:e8651b6:             }
1:e8651b6:             assertFalse(file.exists());
1:e8651b6:         }
1:e8651b6:     }
1:e8651b6: 
1:e8651b6:     @Test
1:e8651b6:     public void testMarkAndResetReadFully() throws Exception
1:e8651b6:     {
1:e8651b6:         String testStr = "1234567890";
1:e8651b6:         byte[] testData = testStr.getBytes();
1:e8651b6: 
1:e8651b6:         for (int memCapacity = 0; memCapacity <= 5; memCapacity++)
1:e8651b6:         {
1:e8651b6:             int diskCapacity = 5 - memCapacity;
1:e8651b6:             try (RewindableDataInputStreamPlus reader = new RewindableDataInputStreamPlus(new ByteArrayInputStream(testData),
1:e8651b6:                                                                                           INITIAL_BUFFER_SIZE, memCapacity, file,
1:e8651b6:                                                                                           diskCapacity))
1:e8651b6:             {
1:e8651b6:                 reader.mark();
1:e8651b6:                 // read first 5 bytes and rewind
1:e8651b6:                 byte[] out = new byte[5];
1:e8651b6:                 reader.readFully(out, 0, 5);
1:e8651b6:                 assertEquals("12345", new String(out));
1:e8651b6:                 reader.reset();
1:e8651b6: 
1:e8651b6:                 // read half from cache, half from parent stream
1:e8651b6:                 out = new byte[7];
1:e8651b6:                 reader.readFully(out);
1:e8651b6:                 assertEquals("1234567", new String(out));
1:e8651b6: 
1:e8651b6:                 // mark and read 3 more bytes
1:e8651b6:                 reader.mark();
1:e8651b6:                 out = new byte[3];
1:e8651b6:                 reader.readFully(out);
1:e8651b6:                 assertEquals("890", new String(out));
1:e8651b6:                 assertEquals(0, reader.available());
1:e8651b6:                 reader.reset();
1:e8651b6: 
1:e8651b6:                 //reset and read only the next byte "8" in the third position
1:e8651b6:                 reader.readFully(out, 2, 1);
1:e8651b6:                 assertEquals("898", new String(out));
1:e8651b6: 
1:e8651b6:                 //now we read the remainder via readline
1:e8651b6:                 assertEquals(2, reader.available());
1:e8651b6:                 assertEquals("90", reader.readLine());
1:e8651b6:             }
1:e8651b6:             assertFalse(file.exists());
1:e8651b6:         }
1:e8651b6:     }
1:e8651b6: }
============================================================================
author:Paulo Motta
-------------------------------------------------------------------------------
commit:e8651b6
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.cassandra.io.util;
1: 
1: import java.io.ByteArrayInputStream;
1: import java.io.ByteArrayOutputStream;
1: import java.io.DataOutputStream;
1: import java.io.File;
1: import java.io.IOException;
1: 
1: import org.junit.Before;
1: import org.junit.Test;
1: 
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertFalse;
1: import static org.junit.Assert.assertTrue;
1: import static org.junit.Assert.fail;
1: 
1: public class RewindableDataInputStreamPlusTest
1: {
1: 
1:     private final int INITIAL_BUFFER_SIZE = 1;
1: 
1:     private File file;
1: 
1:     @Before
1:     public void setup() throws Exception
1:     {
1:         this.file = new File(System.getProperty("java.io.tmpdir"), "subdir/test.buffer");
1:     }
1: 
1:     @Test
1:     public void testMarkAndResetSimple() throws Exception
1:     {
1:         byte[] testData;
1: 
1:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:         try (DataOutputStream out = new DataOutputStream(baos))
1:         {
1:             // boolean
1:             out.writeBoolean(true);
1:             // byte
1:             out.writeByte(0x1);
1:             // char
1:             out.writeChar('a');
1:             // short
1:             out.writeShort(1);
1:             // int
1:             out.writeInt(1);
1:             // long
1:             out.writeLong(1L);
1:             // float
1:             out.writeFloat(1.0f);
1:             // double
1:             out.writeDouble(1.0d);
1: 
1:             // String
1:             out.writeUTF("abc");
1:             testData = baos.toByteArray();
1:         }
1: 
1:         for (int memCapacity = 0; memCapacity <= 16; memCapacity++)
1:         {
1:             int diskCapacity = 16 - memCapacity;
1:             try (RewindableDataInputStreamPlus reader = new RewindableDataInputStreamPlus(new ByteArrayInputStream(testData),
1:                                                                                           INITIAL_BUFFER_SIZE, memCapacity, file,
1:                                                                                           diskCapacity))
1:             {
1:                 try {
1:                     //should mark before resetting
1:                     reader.reset(null);
1:                     fail("Should have thrown IOException");
1:                 } catch (IOException e) {}
1: 
1:                 assertTrue(reader.readBoolean());
1: 
1:                 reader.mark();
1: 
1:                 try {
1:                     //cannot mark already marked stream
1:                     reader.mark();
1:                     fail("Should have thrown IllegalStateException");
1:                 } catch (IllegalStateException e) {}
1: 
1:                 assertEquals(0x1, reader.readByte());
1:                 assertEquals('a', reader.readChar());
1:                 assertEquals(3, reader.bytesPastMark(null));
1:                 reader.reset(null);
1: 
1:                 try {
1:                     //cannot mark when reading from cache
1:                     reader.mark();
1:                     fail("Should have thrown IllegalStateException");
1:                 } catch (IllegalStateException e) {}
1: 
1:                 //read again previous sequence
1:                 assertEquals(0x1, reader.readByte());
1:                 assertEquals('a', reader.readChar());
1:                 //finish reading again previous sequence
1:                 assertEquals(1, reader.readShort());
1: 
1:                 reader.mark();
1:                 assertEquals(1, reader.readInt());
1:                 assertEquals(1L, reader.readLong());
1:                 assertEquals(1.0f, reader.readFloat(), 0);
1:                 assertEquals(16, reader.bytesPastMark(null));
1:                 reader.reset(null);
1: 
1:                 //read again previous sequence
1:                 assertEquals(1, reader.readInt());
1:                 assertEquals(1L, reader.readLong());
1:                 assertEquals(1.0f, reader.readFloat(), 0);
1:                 //finish reading again previous sequence
1: 
1:                 //mark again
1:                 reader.mark();
1:                 assertEquals(1.0d, reader.readDouble(), 0);
1:                 assertEquals(8, reader.bytesPastMark(null));
1:                 reader.reset(null);
1: 
1:                 //read again previous sequence
1:                 assertEquals(1.0d, reader.readDouble(), 0);
1:                 //finish reading again previous sequence
1: 
1:                 //mark and reset
1:                 reader.mark();
1:                 reader.reset(null);
1: 
1:                 assertEquals("abc", reader.readUTF());
1: 
1:                 //check max file size
1:                 assertEquals(diskCapacity, file.length());
1:             }
1:             assertFalse(file.exists());
1:         }
1:     }
1: 
1:     @Test
1:     public void testVeryLargeCapacity() throws Exception
1:     {
1:         byte[] testData;
1: 
1:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:         try (DataOutputStream out = new DataOutputStream(baos))
1:         {
1:             out.writeUTF("abc");
1:             testData = baos.toByteArray();
1:         }
1: 
1:         try (RewindableDataInputStreamPlus reader = new RewindableDataInputStreamPlus(new ByteArrayInputStream(testData),
1:                                                                                       INITIAL_BUFFER_SIZE, Integer.MAX_VALUE, file,
1:                                                                                       Integer.MAX_VALUE))
1:         {
1:             reader.mark();
1:             assertEquals("abc", reader.readUTF());
1:             reader.reset();
1:             assertEquals("abc", reader.readUTF());
1:         }
1:         assertFalse(file.exists());
1: 
1: 
1:         baos = new ByteArrayOutputStream();
1:         try (DataOutputStream out = new DataOutputStream(baos))
1:         {
1:             out.writeBoolean(true);
1:             out.writeBoolean(true);
1:             testData = baos.toByteArray();
1:         }
1:     }
1: 
1:     @Test
1:     public void testMarkAndResetBigBuffer() throws Exception
1:     {
1:         byte[] testData;
1: 
1:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:         try (DataOutputStream out = new DataOutputStream(baos))
1:         {
1:             // boolean
1:             out.writeBoolean(true);
1:             // byte
1:             out.writeByte(0x1);
1:             // char
1:             out.writeChar('a');
1:             // short
1:             out.writeShort(1);
1:             // int
1:             out.writeInt(1);
1:             // long
1:             out.writeLong(1L);
1:             // float
1:             out.writeFloat(1.0f);
1:             // double
1:             out.writeDouble(1.0d);
1: 
1:             // String
1:             out.writeUTF("abc");
1:             testData = baos.toByteArray();
1: 
1:             // 1 (boolean) + 1 (byte) + 2 (char) + 2 (short) + 4 (int) + 8 (long)
1:             // + 4 (float) + 8 (double) + 5 bytes (utf string)
1:         }
1: 
1:         for (int memCapacity = 0; memCapacity <= 18; memCapacity++)
1:         {
1:             int diskCapacity = 18 - memCapacity;
1:             try (RewindableDataInputStreamPlus reader = new RewindableDataInputStreamPlus(new ByteArrayInputStream(testData),
1:                                                                                           INITIAL_BUFFER_SIZE, memCapacity, file,
1:                                                                                           diskCapacity))
1:             {
1:                 //read a big amount before resetting
1:                 reader.mark();
1:                 assertTrue(reader.readBoolean());
1:                 assertEquals(0x1, reader.readByte());
1:                 assertEquals('a', reader.readChar());
1:                 assertEquals(1, reader.readShort());
1:                 assertEquals(1, reader.readInt());
1:                 assertEquals(1L, reader.readLong());
1:                 reader.reset();
1: 
1:                 //read from buffer
1:                 assertTrue(reader.readBoolean());
1:                 assertEquals(0x1, reader.readByte());
1:                 assertEquals('a', reader.readChar());
1:                 assertEquals(1, reader.readShort());
1:                 assertEquals(1, reader.readInt());
1:                 assertEquals(1L, reader.readLong());
1: 
1:                 assertEquals(17, reader.available());
1: 
1:                 //mark again
1:                 reader.mark();
1:                 assertEquals(1.0f, reader.readFloat(), 0);
1:                 assertEquals(1.0d, reader.readDouble(), 0);
1:                 assertEquals("abc", reader.readUTF());
1:                 reader.reset();
1: 
1:                 assertEquals(17, reader.available());
1: 
1:                 assertEquals(1.0f, reader.readFloat(), 0);
1:                 assertEquals(1.0d, reader.readDouble(), 0);
1:                 assertEquals("abc", reader.readUTF());
1:             }
1:             assertFalse(file.exists());
1:         }
1:     }
1: 
1: 
1:     @Test
1:     public void testCircularSpillFile() throws Exception
1:     {
1:         byte[] testData;
1: 
1:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:         try (DataOutputStream out = new DataOutputStream(baos))
1:         {
1:             // boolean
1:             out.writeBoolean(true);
1:             // byte
1:             out.writeByte(0x1);
1:             // char
1:             out.writeChar('a');
1:             // short
1:             out.writeShort(1);
1:             // int
1:             out.writeInt(1);
1: 
1:             // String
1:             out.writeUTF("ab");
1:             testData = baos.toByteArray();
1: 
1:             // 1 (boolean) + 1 (byte) + 2 (char) + 2 (short) + 4 (int) + 4 bytes (utf string)
1:         }
1: 
1:         //read at most 4 bytes multiple times (and then check file size)
1:         int MEM_SIZE = 0;
1:         int DISK_SIZE = 4;
1:         try (RewindableDataInputStreamPlus reader = new RewindableDataInputStreamPlus(new ByteArrayInputStream(testData),
1:                                                                                       INITIAL_BUFFER_SIZE, MEM_SIZE, file,
1:                                                                                       DISK_SIZE))
1:         {
1:             //read 2 bytes and reset
1:             reader.mark();
1:             assertTrue(reader.readBoolean());
1:             assertEquals(0x1, reader.readByte());
1:             assertEquals(2, reader.bytesPastMark(null));
1:             reader.reset();
1: 
1:             //read again previous sequence
1:             assertTrue(reader.readBoolean());
1:             assertEquals(0x1, reader.readByte());
1:             //finish reading again previous sequence
1: 
1:             //read 4 bytes and reset
1:             reader.mark();
1:             assertEquals('a', reader.readChar());
1:             assertEquals(1, reader.readShort());
1:             assertEquals(4, reader.bytesPastMark(null));
1:             reader.reset();
1: 
1:             //read again previous sequence
1:             assertEquals('a', reader.readChar());
1:             assertEquals(1, reader.readShort());
1:             //finish reading again previous sequence
1: 
1:             //read 4 bytes and reset
1:             reader.mark();
1:             assertEquals(1, reader.readInt());
1:             assertEquals(4, reader.bytesPastMark(null));
1:             reader.reset();
1: 
1:             //read again previous sequence
1:             assertEquals(1, reader.readInt());
1: 
1:             //check max file size
1:             assertEquals(DISK_SIZE, file.length());
1:         }
1:         assertFalse(file.exists());
1:     }
1: 
1:     @Test
1:     public void testExhaustCapacity() throws Exception
1:     {
1:         byte[] testData;
1: 
1:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:         try (DataOutputStream out = new DataOutputStream(baos))
1:         {
1:             // boolean
1:             out.writeBoolean(true);
1:             // byte
1:             out.writeByte(0x1);
1:             // char
1:             out.writeChar('a');
1:             // short
1:             out.writeShort(1);
1:             testData = baos.toByteArray();
1:         }
1: 
1:         //test capacity exhausted when reading more than 4 bytes
1:         testCapacityExhausted(testData, 0, 2);
1:         testCapacityExhausted(testData, 2, 0);
1:         testCapacityExhausted(testData, 1, 1);
1:     }
1: 
1:     private void testCapacityExhausted(byte[] testData, int memSize, int diskSize) throws IOException
1:     {
1:         try (RewindableDataInputStreamPlus reader = new RewindableDataInputStreamPlus(new ByteArrayInputStream(testData),
1:                                                                                       INITIAL_BUFFER_SIZE, memSize, file,
1:                                                                                       diskSize))
1:         {
1:             //read 2 bytes and reset
1:             reader.mark();
1:             assertTrue(reader.readBoolean());
1:             assertEquals(0x1, reader.readByte());
1:             assertEquals(2, reader.bytesPastMark(null));
1:             reader.reset();
1: 
1:             //read again previous sequence
1:             assertTrue(reader.readBoolean());
1:             assertEquals(0x1, reader.readByte());
1:             //finish reading again previous sequence
1: 
1:             reader.mark();
1:             //read 3 bytes - OK
1:             assertEquals('a', reader.readChar());
1:             //read 1 more bytes - CAPACITY will exhaust when trying to reset :(
1:             assertEquals(1, reader.readShort());
1: 
1:             try
1:             {
1:                 reader.reset();
1:                 fail("Should have thrown IOException");
1:             }
1:             catch (IOException e) {}
1: 
1:             //check max file size
1:             assertEquals(diskSize, file.length());
1:         }
1:         assertFalse(file.exists());
1:     }
1: 
1:     @Test
1:     public void testMarkAndResetUnsignedRead() throws Exception
1:     {
1:         byte[] testData;
1: 
1:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:         try (DataOutputStream out = new DataOutputStream(baos))
1:         {
1:             // byte
1:             out.writeByte(0x1);
1:             // short
1:             out.writeShort(2);
1:             testData = baos.toByteArray();
1:         }
1: 
1:         for (int memCapacity = 0; memCapacity <= 1; memCapacity++)
1:         {
1:             int diskCapacity = 1 - memCapacity;
1:             try (RewindableDataInputStreamPlus reader = new RewindableDataInputStreamPlus(new ByteArrayInputStream(testData),
1:                                                                                           INITIAL_BUFFER_SIZE, memCapacity, file,
1:                                                                                           diskCapacity))
1:             {
1:                 reader.mark();
1:                 assertEquals(1, reader.readUnsignedByte());
1:                 reader.reset();
1:                 assertEquals(1, reader.readUnsignedByte());
1: 
1:                 //will read first byte of short 2
1:                 reader.mark();
1:                 assertEquals(0, reader.readUnsignedByte());
1:                 reader.reset();
1: 
1:                 assertEquals(2, reader.readUnsignedShort());
1: 
1:                 reader.mark();
1:                 reader.reset();
1:                 assertEquals(0, reader.available());
1:             }
1:         }
1:         assertFalse(file.exists());
1:     }
1: 
1:     @Test
1:     public void testMarkAndResetSkipBytes() throws Exception
1:     {
1:         String testStr = "1234567890";
1:         byte[] testData = testStr.getBytes();
1: 
1:         for (int memCapacity = 0; memCapacity <= 7; memCapacity++)
1:         {
1:             int diskCapacity = 7 - memCapacity;
1:             try (RewindableDataInputStreamPlus reader = new RewindableDataInputStreamPlus(new ByteArrayInputStream(testData),
1:                                                                                           INITIAL_BUFFER_SIZE, memCapacity, file,
1:                                                                                           diskCapacity))
1:             {
1:                 reader.mark();
1:                 // read first 5 bytes and rewind
1:                 byte[] out = new byte[5];
1:                 reader.readFully(out, 0, 5);
1:                 assertEquals("12345", new String(out));
1: 
1:                 // then skip 2 bytes (67)
1:                 reader.skipBytes(2);
1: 
1:                 assertEquals(7, reader.bytesPastMark(null));
1:                 reader.reset();
1: 
1:                 //now read part of the previously skipped bytes
1:                 out = new byte[5];
1:                 reader.readFully(out);
1:                 assertEquals("12345", new String(out));
1: 
1:                 //skip 3 bytes (2 from cache, 1 from stream)
1:                 reader.skip(3);
1: 
1:                 // mark and read 2 more bytes
1:                 reader.mark();
1:                 out = new byte[2];
1:                 reader.readFully(out);
1:                 assertEquals("90", new String(out));
1:                 assertEquals(0, reader.available());
1:                 reader.reset();
1: 
1:                 //reset and read only the next byte "9" in the third position
1:                 reader.readFully(out, 1, 1);
1:                 assertEquals("99", new String(out));
1: 
1:                 //now we read the remainder via readline
1:                 assertEquals(1, reader.available());
1:                 assertEquals("0", reader.readLine());
1: 
1:             }
1:             assertFalse(file.exists());
1:         }
1:     }
1: 
1:     @Test
1:     public void testMarkAndResetReadFully() throws Exception
1:     {
1:         String testStr = "1234567890";
1:         byte[] testData = testStr.getBytes();
1: 
1:         for (int memCapacity = 0; memCapacity <= 5; memCapacity++)
1:         {
1:             int diskCapacity = 5 - memCapacity;
1:             try (RewindableDataInputStreamPlus reader = new RewindableDataInputStreamPlus(new ByteArrayInputStream(testData),
1:                                                                                           INITIAL_BUFFER_SIZE, memCapacity, file,
1:                                                                                           diskCapacity))
1:             {
1:                 reader.mark();
1:                 // read first 5 bytes and rewind
1:                 byte[] out = new byte[5];
1:                 reader.readFully(out, 0, 5);
1:                 assertEquals("12345", new String(out));
1:                 reader.reset();
1: 
1:                 // read half from cache, half from parent stream
1:                 out = new byte[7];
1:                 reader.readFully(out);
1:                 assertEquals("1234567", new String(out));
1: 
1:                 // mark and read 3 more bytes
1:                 reader.mark();
1:                 out = new byte[3];
1:                 reader.readFully(out);
1:                 assertEquals("890", new String(out));
1:                 assertEquals(0, reader.available());
1:                 reader.reset();
1: 
1:                 //reset and read only the next byte "8" in the third position
1:                 reader.readFully(out, 2, 1);
1:                 assertEquals("898", new String(out));
1: 
1:                 //now we read the remainder via readline
1:                 assertEquals(2, reader.available());
1:                 assertEquals("90", reader.readLine());
1:             }
1:             assertFalse(file.exists());
1:         }
1:     }
1: }
============================================================================