1:f41684f: /**
1:f41684f:  * Licensed to the Apache Software Foundation (ASF) under one
1:f41684f:  * or more contributor license agreements.  See the NOTICE file
1:f41684f:  * distributed with this work for additional information
1:f41684f:  * regarding copyright ownership.  The ASF licenses this file
1:f41684f:  * to you under the Apache License, Version 2.0 (the
1:f41684f:  * "License"); you may not use this file except in compliance
1:f41684f:  * with the License.  You may obtain a copy of the License at
1:f41684f:  *
1:f41684f:  *     http://www.apache.org/licenses/LICENSE-2.0
1:f41684f:  *
1:f41684f:  * Unless required by applicable law or agreed to in writing, software
1:f41684f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:f41684f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f41684f:  * See the License for the specific language governing permissions and
1:f41684f:  * limitations under the License.
1:f41684f:  */
1:f41684f: package org.apache.cassandra.dht;
4:f41684f: 
1:e7ae7c9: import java.math.BigDecimal;
1:f41684f: import java.math.BigInteger;
1:f41684f: import java.nio.ByteBuffer;
1:9a3fa88: import java.util.*;
1:028880e: import java.util.concurrent.ThreadLocalRandom;
1:f41684f: 
1:a89ef1f: import org.apache.cassandra.db.DecoratedKey;
1:18d8f26: import org.apache.cassandra.db.PreHashedDecoratedKey;
1:a67f779: import org.apache.cassandra.db.marshal.AbstractType;
1:0a08525: import org.apache.cassandra.db.marshal.PartitionerDefinedOrder;
1:a67f779: import org.apache.cassandra.db.marshal.LongType;
1:3a2faf9: import org.apache.cassandra.exceptions.ConfigurationException;
1:a89ef1f: import org.apache.cassandra.utils.ByteBufferUtil;
1:f41684f: import org.apache.cassandra.utils.MurmurHash;
1:4b54b8a: import org.apache.cassandra.utils.ObjectSizes;
1:a89ef1f: 
1:07893d7: import com.google.common.primitives.Longs;
1:07893d7: 
1:f41684f: /**
1:f41684f:  * This class generates a BigIntegerToken using a Murmur3 hash.
1:f41684f:  */
1:07893d7: public class Murmur3Partitioner implements IPartitioner
1:a89ef1f: {
1:93685a4:     public static final LongToken MINIMUM = new LongToken(Long.MIN_VALUE);
1:a89ef1f:     public static final long MAXIMUM = Long.MAX_VALUE;
1:a89ef1f: 
1:4b54b8a:     private static final int HEAP_SIZE = (int) ObjectSizes.measureDeep(MINIMUM);
1:4b54b8a: 
1:07893d7:     public static final Murmur3Partitioner instance = new Murmur3Partitioner();
1:0a08525:     public static final AbstractType<?> partitionOrdering = new PartitionerDefinedOrder(instance);
1:07893d7: 
1:e2c6341:     private final Splitter splitter = new Splitter(this)
1:e2c6341:     {
1:e2c6341:         public Token tokenForValue(BigInteger value)
1:e2c6341:         {
1:e2c6341:             return new LongToken(value.longValue());
1:e2c6341:         }
1:e2c6341: 
1:e2c6341:         public BigInteger valueForToken(Token token)
1:e2c6341:         {
1:e2c6341:             return BigInteger.valueOf(((LongToken) token).token);
1:e2c6341:         }
1:e2c6341:     };
1:e2c6341: 
1:a89ef1f:     public DecoratedKey decorateKey(ByteBuffer key)
1:4b54b8a:     {
1:18d8f26:         long[] hash = getHash(key);
1:18d8f26:         return new PreHashedDecoratedKey(getToken(key, hash), key, hash[0], hash[1]);
1:f41684f:     }
1:69f77cb: 
1:a89ef1f:     public Token midpoint(Token lToken, Token rToken)
1:69f77cb:     {
1:a89ef1f:         // using BigInteger to avoid long overflow in intermediate operations
1:a89ef1f:         BigInteger l = BigInteger.valueOf(((LongToken) lToken).token),
1:a89ef1f:                    r = BigInteger.valueOf(((LongToken) rToken).token),
1:a89ef1f:                    midpoint;
1:9a3fa88: 
1:a89ef1f:         if (l.compareTo(r) < 0)
1:a89ef1f:         {
1:a89ef1f:             BigInteger sum = l.add(r);
1:a89ef1f:             midpoint = sum.shiftRight(1);
1:a89ef1f:         }
1:a89ef1f:         else // wrapping case
1:a89ef1f:         {
1:a89ef1f:             BigInteger max = BigInteger.valueOf(MAXIMUM);
1:0ea28c8:             BigInteger min = BigInteger.valueOf(MINIMUM.token);
1:0ea28c8:             // length of range we're bisecting is (R - min) + (max - L)
1:0ea28c8:             // so we add that to L giving
1:0ea28c8:             // L + ((R - min) + (max - L) / 2) = (L + R + max - min) / 2
1:0ea28c8:             midpoint = (max.subtract(min).add(l).add(r)).shiftRight(1);
1:0ea28c8:             if (midpoint.compareTo(max) > 0)
1:0ea28c8:                 midpoint = min.add(midpoint.subtract(max));
1:a89ef1f:         }
1:a89ef1f: 
1:a89ef1f:         return new LongToken(midpoint.longValue());
1:a89ef1f:     }
1:a89ef1f: 
1:e2a0d75:     public Token split(Token lToken, Token rToken, double ratioToLeft)
1:e2a0d75:     {
1:e2a0d75:         BigDecimal l = BigDecimal.valueOf(((LongToken) lToken).token),
1:e2a0d75:                    r = BigDecimal.valueOf(((LongToken) rToken).token),
1:e2a0d75:                    ratio = BigDecimal.valueOf(ratioToLeft);
1:e2a0d75:         long newToken;
1:e2a0d75: 
1:e2a0d75:         if (l.compareTo(r) < 0)
1:e2a0d75:         {
1:e2a0d75:             newToken = r.subtract(l).multiply(ratio).add(l).toBigInteger().longValue();
1:e2a0d75:         }
1:e2a0d75:         else
1:e2a0d75:         {
1:e2a0d75:             // wrapping case
1:e2a0d75:             // L + ((R - min) + (max - L)) * pct
1:e2a0d75:             BigDecimal max = BigDecimal.valueOf(MAXIMUM);
1:e2a0d75:             BigDecimal min = BigDecimal.valueOf(MINIMUM.token);
1:e2a0d75: 
1:e2a0d75:             BigInteger token = max.subtract(min).add(r).subtract(l).multiply(ratio).add(l).toBigInteger();
1:e2a0d75: 
1:e2a0d75:             BigInteger maxToken = BigInteger.valueOf(MAXIMUM);
1:e2a0d75: 
1:e2a0d75:             if (token.compareTo(maxToken) <= 0)
1:e2a0d75:             {
1:e2a0d75:                 newToken = token.longValue();
1:e2a0d75:             }
1:e2a0d75:             else
1:e2a0d75:             {
1:e2a0d75:                 // if the value is above maximum
1:e2a0d75:                 BigInteger minToken = BigInteger.valueOf(MINIMUM.token);
1:e2a0d75:                 newToken = minToken.add(token.subtract(maxToken)).longValue();
1:e2a0d75:             }
1:e2a0d75:         }
1:e2a0d75:         return new LongToken(newToken);
1:e2a0d75:     }
1:e2a0d75: 
1:a89ef1f:     public LongToken getMinimumToken()
1:a89ef1f:     {
1:a89ef1f:         return MINIMUM;
1:a89ef1f:     }
1:a89ef1f: 
1:07893d7:     public static class LongToken extends Token
1:07893d7:     {
1:07893d7:         static final long serialVersionUID = -5833580143318243006L;
1:07893d7: 
1:07893d7:         final long token;
1:07893d7: 
1:07893d7:         public LongToken(long token)
1:07893d7:         {
1:07893d7:             this.token = token;
1:07893d7:         }
1:07893d7: 
1:07893d7:         public String toString()
1:07893d7:         {
1:07893d7:             return Long.toString(token);
1:07893d7:         }
1:07893d7: 
1:07893d7:         public boolean equals(Object obj)
1:07893d7:         {
1:07893d7:             if (this == obj)
1:07893d7:                 return true;
1:07893d7:             if (obj == null || this.getClass() != obj.getClass())
1:07893d7:                 return false;
1:07893d7: 
1:07893d7:             return token == (((LongToken)obj).token);
1:07893d7:         }
1:07893d7: 
1:07893d7:         public int hashCode()
1:07893d7:         {
1:07893d7:             return Longs.hashCode(token);
1:07893d7:         }
1:07893d7: 
1:07893d7:         public int compareTo(Token o)
1:07893d7:         {
1:07893d7:             return Long.compare(token, ((LongToken) o).token);
1:07893d7:         }
1:07893d7: 
1:07893d7:         @Override
1:07893d7:         public IPartitioner getPartitioner()
1:07893d7:         {
1:07893d7:             return instance;
1:07893d7:         }
1:07893d7: 
1:07893d7:         @Override
1:07893d7:         public long getHeapSize()
1:07893d7:         {
1:4b54b8a:             return HEAP_SIZE;
1:07893d7:         }
1:07893d7: 
1:07893d7:         @Override
1:07893d7:         public Object getTokenValue()
1:07893d7:         {
1:07893d7:             return token;
1:07893d7:         }
1:07893d7: 
1:9a3fa88:         @Override
1:9a3fa88:         public double size(Token next)
1:9a3fa88:         {
1:9a3fa88:             LongToken n = (LongToken) next;
1:9a3fa88:             long v = n.token - token;  // Overflow acceptable and desired.
1:9a3fa88:             double d = Math.scalb((double) v, -Long.SIZE); // Scale so that the full range is 1.
1:9a3fa88:             return d > 0.0 ? d : (d + 1.0); // Adjust for signed long, also making sure t.size(t) == 1.
1:07893d7:         }
1:9a3fa88: 
1:9a3fa88:         @Override
1:9a3fa88:         public Token increaseSlightly()
1:9a3fa88:         {
1:9a3fa88:             return new LongToken(token + 1);
1:9a3fa88:         }
1:9a3fa88:     }
1:a89ef1f: 
1:93685a4:     /**
1:93685a4:      * Generate the token of a key.
1:93685a4:      * Note that we need to ensure all generated token are strictly bigger than MINIMUM.
1:93685a4:      * In particular we don't want MINIMUM to correspond to any key because the range (MINIMUM, X] doesn't
1:93685a4:      * include MINIMUM but we use such range to select all data whose token is smaller than X.
1:93685a4:      */
1:a89ef1f:     public LongToken getToken(ByteBuffer key)
1:a89ef1f:     {
1:18d8f26:         return getToken(key, getHash(key));
1:18d8f26:     }
1:18d8f26: 
1:18d8f26:     private LongToken getToken(ByteBuffer key, long[] hash)
1:18d8f26:     {
1:a89ef1f:         if (key.remaining() == 0)
1:a89ef1f:             return MINIMUM;
1:18d8f26: 
1:20c2adc:         return new LongToken(normalize(hash[0]));
1:4b54b8a:     }
1:4b54b8a: 
1:18d8f26:     private long[] getHash(ByteBuffer key)
1:18d8f26:     {
1:20c2adc:         long[] hash = new long[2];
1:20c2adc:         MurmurHash.hash3_x64_128(key, key.position(), key.remaining(), 0, hash);
1:18d8f26:         return hash;
1:18d8f26:     }
1:a89ef1f: 
1:a89ef1f:     public LongToken getRandomToken()
1:a89ef1f:     {
1:9a3fa88:         return getRandomToken(ThreadLocalRandom.current());
1:9a3fa88:     }
1:9a3fa88: 
1:9a3fa88:     public LongToken getRandomToken(Random r)
1:9a3fa88:     {
1:9a3fa88:         return new LongToken(normalize(r.nextLong()));
1:a89ef1f:     }
1:a89ef1f: 
1:93685a4:     private long normalize(long v)
1:a89ef1f:     {
1:93685a4:         // We exclude the MINIMUM value; see getToken()
1:93685a4:         return v == Long.MIN_VALUE ? Long.MAX_VALUE : v;
1:a89ef1f:     }
1:a89ef1f: 
1:a89ef1f:     public boolean preservesOrder()
1:a89ef1f:     {
1:a89ef1f:         return false;
1:a89ef1f:     }
1:a89ef1f: 
1:a89ef1f:     public Map<Token, Float> describeOwnership(List<Token> sortedTokens)
1:a89ef1f:     {
1:a89ef1f:         Map<Token, Float> ownerships = new HashMap<Token, Float>();
1:ad84e4d:         Iterator<Token> i = sortedTokens.iterator();
1:a89ef1f: 
1:a89ef1f:         // 0-case
1:a89ef1f:         if (!i.hasNext())
1:dedeb0b:             throw new RuntimeException("No nodes present in the cluster. Has this node finished starting up?");
1:a89ef1f:         // 1-case
1:a89ef1f:         if (sortedTokens.size() == 1)
1:1fab7b7:             ownerships.put(i.next(), new Float(1.0));
1:a89ef1f:         // n-case
1:a89ef1f:         else
1:a89ef1f:         {
1:e7ae7c9:             final BigInteger ri = BigInteger.valueOf(MAXIMUM).subtract(BigInteger.valueOf(MINIMUM.token + 1));  //  (used for addition later)
1:e7ae7c9:             final BigDecimal r  = new BigDecimal(ri);
1:ad84e4d:             Token start = i.next();BigInteger ti = BigInteger.valueOf(((LongToken)start).token);  // The first token and its value
1:e7ae7c9:             Token t; BigInteger tim1 = ti;                                                                // The last token and its value (after loop)
1:a89ef1f: 
1:a89ef1f:             while (i.hasNext())
1:a89ef1f:             {
1:1fab7b7:                 t = i.next(); ti = BigInteger.valueOf(((LongToken) t).token); // The next token and its value
1:e7ae7c9:                 float age = new BigDecimal(ti.subtract(tim1).add(ri).mod(ri)).divide(r, 6, BigDecimal.ROUND_HALF_EVEN).floatValue(); // %age = ((T(i) - T(i-1) + R) % R) / R
1:a89ef1f:                 ownerships.put(t, age);                           // save (T(i) -> %age)
1:a89ef1f:                 tim1 = ti;                                        // -> advance loop
1:a89ef1f:             }
1:a89ef1f: 
1:a89ef1f:             // The start token's range extends backward to the last token, which is why both were saved above.
1:e7ae7c9:             float x = new BigDecimal(BigInteger.valueOf(((LongToken)start).token).subtract(ti).add(ri).mod(ri)).divide(r, 6, BigDecimal.ROUND_HALF_EVEN).floatValue();
1:a89ef1f:             ownerships.put(start, x);
1:a89ef1f:         }
1:a89ef1f: 
1:a89ef1f:         return ownerships;
1:a89ef1f:     }
1:a89ef1f: 
1:ad84e4d:     public Token.TokenFactory getTokenFactory()
1:a89ef1f:     {
1:a89ef1f:         return tokenFactory;
1:a89ef1f:     }
1:a89ef1f: 
1:ad84e4d:     private final Token.TokenFactory tokenFactory = new Token.TokenFactory()
1:a89ef1f:     {
1:ad84e4d:         public ByteBuffer toByteArray(Token token)
1:a89ef1f:         {
2:ad84e4d:             LongToken longToken = (LongToken) token;
1:a89ef1f:             return ByteBufferUtil.bytes(longToken.token);
1:a89ef1f:         }
1:a89ef1f: 
1:ad84e4d:         public Token fromByteArray(ByteBuffer bytes)
1:a89ef1f:         {
1:31e669a:             return new LongToken(ByteBufferUtil.toLong(bytes));
1:a89ef1f:         }
1:a89ef1f: 
1:ad84e4d:         public String toString(Token token)
1:a89ef1f:         {
1:6eef6f7:             return token.toString();
1:a89ef1f:         }
1:a89ef1f: 
1:a89ef1f:         public void validate(String token) throws ConfigurationException
1:a89ef1f:         {
1:a89ef1f:             try
1:a89ef1f:             {
1:87fdc9b:                 fromString(token);
1:a89ef1f:             }
1:a89ef1f:             catch (NumberFormatException e)
1:a89ef1f:             {
1:a89ef1f:                 throw new ConfigurationException(e.getMessage());
1:a89ef1f:             }
1:a89ef1f:         }
1:a89ef1f: 
1:ad84e4d:         public Token fromString(String string)
1:a89ef1f:         {
1:a301ea1:             try
1:f41684f:             {
1:a7c1729:                 return new LongToken(Long.parseLong(string));
1:a89ef1f:             }
1:a301ea1:             catch (NumberFormatException e)
1:f41684f:             {
1:b678035:                 throw new IllegalArgumentException(String.format("Invalid token for Murmur3Partitioner. Got %s but expected a long value (unsigned 8 bytes integer).", string));
1:f41684f:             }
1:f41684f:         }
1:a89ef1f:     };
1:a89ef1f: 
1:a67f779:     public AbstractType<?> getTokenValidator()
1:f41684f:     {
1:a67f779:         return LongType.instance;
2:a301ea1:     }
1:0a08525: 
1:e2c6341:     public Token getMaximumToken()
1:e2c6341:     {
1:e2c6341:         return new LongToken(Long.MAX_VALUE);
1:e2c6341:     }
1:e2c6341: 
1:0a08525:     public AbstractType<?> partitionOrdering()
1:0a08525:     {
1:0a08525:         return partitionOrdering;
1:0a08525:     }
1:e2c6341: 
1:e2c6341:     public Optional<Splitter> splitter()
1:e2c6341:     {
1:e2c6341:         return Optional.of(splitter);
1:e2c6341:     }
1:69f77cb: }
============================================================================
author:Dikang Gu
-------------------------------------------------------------------------------
commit:e2a0d75
/////////////////////////////////////////////////////////////////////////
1:     public Token split(Token lToken, Token rToken, double ratioToLeft)
1:     {
1:         BigDecimal l = BigDecimal.valueOf(((LongToken) lToken).token),
1:                    r = BigDecimal.valueOf(((LongToken) rToken).token),
1:                    ratio = BigDecimal.valueOf(ratioToLeft);
1:         long newToken;
1: 
1:         if (l.compareTo(r) < 0)
1:         {
1:             newToken = r.subtract(l).multiply(ratio).add(l).toBigInteger().longValue();
1:         }
1:         else
1:         {
1:             // wrapping case
1:             // L + ((R - min) + (max - L)) * pct
1:             BigDecimal max = BigDecimal.valueOf(MAXIMUM);
1:             BigDecimal min = BigDecimal.valueOf(MINIMUM.token);
1: 
1:             BigInteger token = max.subtract(min).add(r).subtract(l).multiply(ratio).add(l).toBigInteger();
1: 
1:             BigInteger maxToken = BigInteger.valueOf(MAXIMUM);
1: 
1:             if (token.compareTo(maxToken) <= 0)
1:             {
1:                 newToken = token.longValue();
1:             }
1:             else
1:             {
1:                 // if the value is above maximum
1:                 BigInteger minToken = BigInteger.valueOf(MINIMUM.token);
1:                 newToken = minToken.add(token.subtract(maxToken)).longValue();
1:             }
1:         }
1:         return new LongToken(newToken);
1:     }
1: 
author:Abhishek Verma
-------------------------------------------------------------------------------
commit:87fdc9b
/////////////////////////////////////////////////////////////////////////
1:                 fromString(token);
author:Marcus Eriksson
-------------------------------------------------------------------------------
commit:e2c6341
/////////////////////////////////////////////////////////////////////////
1:     private final Splitter splitter = new Splitter(this)
1:     {
1:         public Token tokenForValue(BigInteger value)
1:         {
1:             return new LongToken(value.longValue());
1:         }
1: 
1:         public BigInteger valueForToken(Token token)
1:         {
1:             return BigInteger.valueOf(((LongToken) token).token);
1:         }
1:     };
1: 
/////////////////////////////////////////////////////////////////////////
1:     public Token getMaximumToken()
1:     {
1:         return new LongToken(Long.MAX_VALUE);
1:     }
1: 
1: 
1:     public Optional<Splitter> splitter()
1:     {
1:         return Optional.of(splitter);
1:     }
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:0a08525
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.marshal.PartitionerDefinedOrder;
/////////////////////////////////////////////////////////////////////////
1:     public static final AbstractType<?> partitionOrdering = new PartitionerDefinedOrder(instance);
/////////////////////////////////////////////////////////////////////////
1: 
1:     public AbstractType<?> partitionOrdering()
1:     {
1:         return partitionOrdering;
1:     }
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:a22ce89
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:4b54b8a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.ObjectSizes;
/////////////////////////////////////////////////////////////////////////
1:     private static final int HEAP_SIZE = (int) ObjectSizes.measureDeep(MINIMUM);
1: 
/////////////////////////////////////////////////////////////////////////
0:     public long getHeapSizeOf(LongToken token)
1:     {
1:         return HEAP_SIZE;
1:     }
1: 
commit:20c2adc
/////////////////////////////////////////////////////////////////////////
1:         long[] hash = new long[2];
1:         MurmurHash.hash3_x64_128(key, key.position(), key.remaining(), 0, hash);
1:         return new LongToken(normalize(hash[0]));
commit:7f2c3a8
/////////////////////////////////////////////////////////////////////////
commit:0ea28c8
/////////////////////////////////////////////////////////////////////////
1:             BigInteger min = BigInteger.valueOf(MINIMUM.token);
1:             // length of range we're bisecting is (R - min) + (max - L)
1:             // so we add that to L giving
1:             // L + ((R - min) + (max - L) / 2) = (L + R + max - min) / 2
1:             midpoint = (max.subtract(min).add(l).add(r)).shiftRight(1);
1:             if (midpoint.compareTo(max) > 0)
1:                 midpoint = min.add(midpoint.subtract(max));
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:69f77cb
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.marshal.PartitionerDefinedOrder;
/////////////////////////////////////////////////////////////////////////
0:     public static final AbstractType<?> partitionOrdering = new PartitionerDefinedOrder(instance);
/////////////////////////////////////////////////////////////////////////
1: 
0:     public AbstractType<?> partitionOrdering()
1:     {
0:         return partitionOrdering;
1:     }
commit:07893d7
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.primitives.Longs;
1: 
1: public class Murmur3Partitioner implements IPartitioner
1:     public static final Murmur3Partitioner instance = new Murmur3Partitioner();
1: 
/////////////////////////////////////////////////////////////////////////
1:     public static class LongToken extends Token
1:     {
1:         static final long serialVersionUID = -5833580143318243006L;
1: 
1:         final long token;
1: 
1:         public LongToken(long token)
1:         {
1:             this.token = token;
1:         }
1: 
1:         public String toString()
1:         {
1:             return Long.toString(token);
1:         }
1: 
1:         public boolean equals(Object obj)
1:         {
1:             if (this == obj)
1:                 return true;
1:             if (obj == null || this.getClass() != obj.getClass())
1:                 return false;
1: 
1:             return token == (((LongToken)obj).token);
1:         }
1: 
1:         public int hashCode()
1:         {
1:             return Longs.hashCode(token);
1:         }
1: 
1:         public int compareTo(Token o)
1:         {
1:             return Long.compare(token, ((LongToken) o).token);
1:         }
1: 
1:         @Override
1:         public IPartitioner getPartitioner()
1:         {
1:             return instance;
1:         }
1: 
1:         @Override
1:         public long getHeapSize()
1:         {
0:             return HEAP_SIZE;
1:         }
1: 
1:         @Override
1:         public Object getTokenValue()
1:         {
1:             return token;
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
commit:ad84e4d
/////////////////////////////////////////////////////////////////////////
0: public class Murmur3Partitioner extends AbstractPartitioner
/////////////////////////////////////////////////////////////////////////
0:     public long getHeapSizeOf(Token token)
/////////////////////////////////////////////////////////////////////////
1:         Iterator<Token> i = sortedTokens.iterator();
/////////////////////////////////////////////////////////////////////////
1:             Token start = i.next();BigInteger ti = BigInteger.valueOf(((LongToken)start).token);  // The first token and its value
/////////////////////////////////////////////////////////////////////////
1:     public Token.TokenFactory getTokenFactory()
1:     private final Token.TokenFactory tokenFactory = new Token.TokenFactory()
1:         public ByteBuffer toByteArray(Token token)
1:             LongToken longToken = (LongToken) token;
1:         public Token fromByteArray(ByteBuffer bytes)
1:         public String toString(Token token)
1:             LongToken longToken = (LongToken) token;
/////////////////////////////////////////////////////////////////////////
0:                 Long.valueOf(token);
/////////////////////////////////////////////////////////////////////////
1:         public Token fromString(String string)
author:branimir
-------------------------------------------------------------------------------
commit:9a3fa88
/////////////////////////////////////////////////////////////////////////
1: import java.util.*;
/////////////////////////////////////////////////////////////////////////
1: 
1:         @Override
1:         public double size(Token next)
1:         {
1:             LongToken n = (LongToken) next;
1:             long v = n.token - token;  // Overflow acceptable and desired.
1:             double d = Math.scalb((double) v, -Long.SIZE); // Scale so that the full range is 1.
1:             return d > 0.0 ? d : (d + 1.0); // Adjust for signed long, also making sure t.size(t) == 1.
1:         }
1: 
1:         @Override
1:         public Token increaseSlightly()
1:         {
1:             return new LongToken(token + 1);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         return getRandomToken(ThreadLocalRandom.current());
1:     }
1: 
1:     public LongToken getRandomToken(Random r)
1:     {
1:         return new LongToken(normalize(r.nextLong()));
author:Dave Brosius
-------------------------------------------------------------------------------
commit:1fab7b7
/////////////////////////////////////////////////////////////////////////
1:             ownerships.put(i.next(), new Float(1.0));
/////////////////////////////////////////////////////////////////////////
1:                 t = i.next(); ti = BigInteger.valueOf(((LongToken) t).token); // The next token and its value
commit:a7c1729
/////////////////////////////////////////////////////////////////////////
1:                 return new LongToken(Long.parseLong(string));
commit:ade99b9
commit:b678035
/////////////////////////////////////////////////////////////////////////
1:                 throw new IllegalArgumentException(String.format("Invalid token for Murmur3Partitioner. Got %s but expected a long value (unsigned 8 bytes integer).", string));
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:18d8f26
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.PreHashedDecoratedKey;
/////////////////////////////////////////////////////////////////////////
1:         long[] hash = getHash(key);
1:         return new PreHashedDecoratedKey(getToken(key, hash), key, hash[0], hash[1]);
/////////////////////////////////////////////////////////////////////////
1:         return getToken(key, getHash(key));
1:     }
1: 
1:     private LongToken getToken(ByteBuffer key, long[] hash)
1:     {
0:         return new LongToken(normalize(hash[0]));
1:     }
1: 
1:     private long[] getHash(ByteBuffer key)
1:     {
1:         return hash;
commit:028880e
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ThreadLocalRandom;
/////////////////////////////////////////////////////////////////////////
0:         return new LongToken(normalize(ThreadLocalRandom.current().nextLong()));
author:Joshua McKenzie
-------------------------------------------------------------------------------
commit:6eef6f7
/////////////////////////////////////////////////////////////////////////
1:             return token.toString();
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:8541cca
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.BufferDecoratedKey;
/////////////////////////////////////////////////////////////////////////
0:         return new BufferDecoratedKey(getToken(key), key);
commit:a89ef1f
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
0: import java.util.Iterator;
0: import java.util.List;
0: import java.util.Map;
0: import org.apache.cassandra.config.ConfigurationException;
1: import org.apache.cassandra.db.DecoratedKey;
1: import org.apache.cassandra.utils.ByteBufferUtil;
0: import org.apache.cassandra.utils.FBUtilities;
0: public class Murmur3Partitioner extends AbstractPartitioner<LongToken>
0:     public static final LongToken MINIMUM = new LongToken(0L);
1:     public static final long MAXIMUM = Long.MAX_VALUE;
0:     public DecoratedKey convertFromDiskFormat(ByteBuffer key)
1:     {
0:         throw new UnsupportedOperationException();
1:     public DecoratedKey decorateKey(ByteBuffer key)
0:         return new DecoratedKey(getToken(key), key);
1: 
1:     public Token midpoint(Token lToken, Token rToken)
1:     {
1:         // using BigInteger to avoid long overflow in intermediate operations
1:         BigInteger l = BigInteger.valueOf(((LongToken) lToken).token),
1:                    r = BigInteger.valueOf(((LongToken) rToken).token),
1:                    midpoint;
1: 
1:         if (l.compareTo(r) < 0)
1:         {
1:             BigInteger sum = l.add(r);
1:             midpoint = sum.shiftRight(1);
1:         }
1:         else // wrapping case
1:         {
1:             BigInteger max = BigInteger.valueOf(MAXIMUM);
0:             midpoint = max.add(r).subtract(l).shiftRight(1).add(l).mod(max);
1:         }
1: 
1:         return new LongToken(midpoint.longValue());
1:     }
1: 
1:     public LongToken getMinimumToken()
1:     {
1:         return MINIMUM;
1:     }
1: 
1:     public LongToken getToken(ByteBuffer key)
1:     {
1:         if (key.remaining() == 0)
1:             return MINIMUM;
1: 
0:         long hash = MurmurHash.hash3_x64_128(key, key.position(), key.remaining(), 0)[0];
0:         return new LongToken((hash < 0) ? -hash : hash);
1:     }
1: 
1:     public LongToken getRandomToken()
1:     {
0:         return new LongToken(FBUtilities.threadLocalRandom().nextLong());
1:     }
1: 
1:     public boolean preservesOrder()
1:     {
1:         return false;
1:     }
1: 
1:     public Map<Token, Float> describeOwnership(List<Token> sortedTokens)
1:     {
1:         Map<Token, Float> ownerships = new HashMap<Token, Float>();
0:         Iterator i = sortedTokens.iterator();
1: 
1:         // 0-case
1:         if (!i.hasNext())
0:             throw new RuntimeException("No nodes present in the cluster. How did you call this?");
1:         // 1-case
1:         if (sortedTokens.size() == 1)
0:             ownerships.put((Token) i.next(), new Float(1.0));
1:         // n-case
1:         else
1:         {
0:             final float ri = MAXIMUM;                                            //  (used for addition later)
0:             Token start = (Token) i.next(); Long ti = ((LongToken)start).token;  // The first token and its value
0:             Token t; Long tim1 = ti;                                             // The last token and its value (after loop)
1: 
1:             while (i.hasNext())
1:             {
0:                 t = (Token) i.next(); ti = ((LongToken) t).token; // The next token and its value
0:                 float age = ((ti - tim1 + ri) % ri) / ri;         // %age = ((T(i) - T(i-1) + R) % R) / R
1:                 ownerships.put(t, age);                           // save (T(i) -> %age)
1:                 tim1 = ti;                                        // -> advance loop
1:             }
1: 
1:             // The start token's range extends backward to the last token, which is why both were saved above.
0:             float x = ((((LongToken) start).token - ti + ri) % ri) / ri;
1:             ownerships.put(start, x);
1:         }
1: 
1:         return ownerships;
1:     }
1: 
0:     public Token.TokenFactory<Long> getTokenFactory()
1:     {
1:         return tokenFactory;
1:     }
1: 
0:     private final Token.TokenFactory<Long> tokenFactory = new Token.TokenFactory<Long>()
1:     {
0:         public ByteBuffer toByteArray(Token<Long> longToken)
1:         {
1:             return ByteBufferUtil.bytes(longToken.token);
1:         }
1: 
0:         public Token<Long> fromByteArray(ByteBuffer bytes)
1:         {
0:             return new LongToken(bytes.getLong());
1:         }
1: 
0:         public String toString(Token<Long> longToken)
1:         {
0:             return longToken.token.toString();
1:         }
1: 
1:         public void validate(String token) throws ConfigurationException
1:         {
1:             try
1:             {
0:                 Long i = Long.valueOf(token);
1: 
0:                 if (i.compareTo(MINIMUM.token) < 0)
0:                     throw new ConfigurationException("Token must be >= 0");
1: 
0:                 if (i.compareTo(MAXIMUM) > 0)
0:                     throw new ConfigurationException("Token must be <= " + Long.MAX_VALUE);
1:             }
1:             catch (NumberFormatException e)
1:             {
1:                 throw new ConfigurationException(e.getMessage());
1:             }
1:         }
1: 
0:         public Token<Long> fromString(String string)
1:         {
0:             return new LongToken(Long.valueOf(string));
1:         }
1:     };
commit:f41684f
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.dht;
1: 
1: import java.math.BigInteger;
1: import java.nio.ByteBuffer;
1: 
1: import org.apache.cassandra.utils.MurmurHash;
1: 
1: /**
1:  * This class generates a BigIntegerToken using a Murmur3 hash.
1:  */
0: public class Murmur3Partitioner extends AbstractHashedPartitioner
1: {
0:     protected BigInteger hash(ByteBuffer buffer)
1:     {
0:         long[] bufferHash = MurmurHash.hash3_x64_128(buffer, buffer.position(), buffer.remaining(), 0);
0:         byte[] hashBytes = new byte[16];
1: 
0:         writeLong(bufferHash[0], hashBytes, 0);
0:         writeLong(bufferHash[1], hashBytes, 8);
0:         // make sure it's positive, this isn't the same as abs() but doesn't effect distribution
0:         hashBytes[0] = (byte) (hashBytes[0] & 0x7F);
0:         return new BigInteger(hashBytes);
1:     }
1: 
0:     public static void writeLong(long src, byte[] dest, int offset)
1:     {
0:         dest[offset] = (byte) (src >> 56);
0:         dest[offset + 1] = (byte) (src >> 48);
0:         dest[offset + 2] = (byte) (src >> 40);
0:         dest[offset + 3] = (byte) (src >> 32);
0:         dest[offset + 4] = (byte) (src >> 24);
0:         dest[offset + 5] = (byte) (src >> 16);
0:         dest[offset + 6] = (byte) (src >> 8);
0:         dest[offset + 7] = (byte) (src);
1:     }
1: }
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:25471ba
commit:a301ea1
/////////////////////////////////////////////////////////////////////////
1:             try
0:             {
0:                 return new LongToken(Long.valueOf(string));
1:             }
1:             catch (NumberFormatException e)
0:             {
0:                 throw new IllegalArgumentException(String.format("Invalid token for Murmur3Partitioner. Got %s but expected a long value (unsigned 8 bytes integer)."));
1:             }
commit:31e669a
/////////////////////////////////////////////////////////////////////////
1:             return new LongToken(ByteBufferUtil.toLong(bytes));
commit:a67f779
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.marshal.AbstractType;
1: import org.apache.cassandra.db.marshal.LongType;
/////////////////////////////////////////////////////////////////////////
0: 
1:     public AbstractType<?> getTokenValidator()
0:     {
1:         return LongType.instance;
0:     }
commit:93685a4
/////////////////////////////////////////////////////////////////////////
1:     public static final LongToken MINIMUM = new LongToken(Long.MIN_VALUE);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Generate the token of a key.
1:      * Note that we need to ensure all generated token are strictly bigger than MINIMUM.
1:      * In particular we don't want MINIMUM to correspond to any key because the range (MINIMUM, X] doesn't
1:      * include MINIMUM but we use such range to select all data whose token is smaller than X.
1:      */
0:         return new LongToken(normalize(hash));
0:         return new LongToken(normalize(FBUtilities.threadLocalRandom().nextLong()));
0:     }
0: 
1:     private long normalize(long v)
0:     {
1:         // We exclude the MINIMUM value; see getToken()
1:         return v == Long.MIN_VALUE ? Long.MAX_VALUE : v;
/////////////////////////////////////////////////////////////////////////
commit:3a2faf9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.exceptions.ConfigurationException;
author:Brandon Williams
-------------------------------------------------------------------------------
commit:dedeb0b
/////////////////////////////////////////////////////////////////////////
1:             throw new RuntimeException("No nodes present in the cluster. Has this node finished starting up?");
commit:25438e6
commit:72e031e
/////////////////////////////////////////////////////////////////////////
0:             throw new RuntimeException("No nodes present in the cluster. Has this node finished starting up?");
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:e7ae7c9
/////////////////////////////////////////////////////////////////////////
1: import java.math.BigDecimal;
/////////////////////////////////////////////////////////////////////////
1:             final BigInteger ri = BigInteger.valueOf(MAXIMUM).subtract(BigInteger.valueOf(MINIMUM.token + 1));  //  (used for addition later)
1:             final BigDecimal r  = new BigDecimal(ri);
0:             Token start = (Token) i.next();BigInteger ti = BigInteger.valueOf(((LongToken)start).token);  // The first token and its value
1:             Token t; BigInteger tim1 = ti;                                                                // The last token and its value (after loop)
0:                 t = (Token) i.next(); ti = BigInteger.valueOf(((LongToken) t).token); // The next token and its value
1:                 float age = new BigDecimal(ti.subtract(tim1).add(ri).mod(ri)).divide(r, 6, BigDecimal.ROUND_HALF_EVEN).floatValue(); // %age = ((T(i) - T(i-1) + R) % R) / R
1:             float x = new BigDecimal(BigInteger.valueOf(((LongToken)start).token).subtract(ti).add(ri).mod(ri)).divide(r, 6, BigDecimal.ROUND_HALF_EVEN).floatValue();
============================================================================