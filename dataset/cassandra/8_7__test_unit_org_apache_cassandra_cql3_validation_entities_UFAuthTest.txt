1:cb5897f: /*
1:cb5897f:  * Licensed to the Apache Software Foundation (ASF) under one
1:cb5897f:  * or more contributor license agreements.  See the NOTICE file
1:cb5897f:  * distributed with this work for additional information
1:cb5897f:  * regarding copyright ownership.  The ASF licenses this file
1:cb5897f:  * to you under the Apache License, Version 2.0 (the
1:cb5897f:  * "License"); you may not use this file except in compliance
1:cb5897f:  * with the License.  You may obtain a copy of the License at
1:cb5897f:  *
1:cb5897f:  *     http://www.apache.org/licenses/LICENSE-2.0
1:cb5897f:  *
1:cb5897f:  * Unless required by applicable law or agreed to in writing, software
1:cb5897f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:cb5897f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:cb5897f:  * See the License for the specific language governing permissions and
1:cb5897f:  * limitations under the License.
1:cb5897f:  */
1:01115f7: package org.apache.cassandra.cql3.validation.entities;
41:cb5897f: 
1:cb5897f: import java.lang.reflect.Field;
1:cb5897f: import java.util.*;
1:cb5897f: 
1:cb5897f: import com.google.common.base.Joiner;
1:cb5897f: import com.google.common.collect.ImmutableSet;
1:cb5897f: import org.junit.Before;
1:cb5897f: import org.junit.BeforeClass;
1:cb5897f: import org.junit.Test;
1:cb5897f: 
1:cb5897f: import org.apache.cassandra.auth.*;
1:cb5897f: import org.apache.cassandra.config.DatabaseDescriptor;
1:3566843: import org.apache.cassandra.config.Schema;
1:7b0c716: import org.apache.cassandra.cql3.*;
1:cb5897f: import org.apache.cassandra.cql3.functions.Function;
1:cb5897f: import org.apache.cassandra.cql3.functions.FunctionName;
1:cb5897f: import org.apache.cassandra.cql3.statements.BatchStatement;
1:cb5897f: import org.apache.cassandra.cql3.statements.ModificationStatement;
1:cb5897f: import org.apache.cassandra.exceptions.*;
1:cb5897f: import org.apache.cassandra.service.ClientState;
1:cb5897f: 
1:cb5897f: import static org.junit.Assert.assertEquals;
1:cb5897f: import static org.junit.Assert.assertTrue;
1:cb5897f: import static org.junit.Assert.fail;
1:cb5897f: 
1:cb5897f: public class UFAuthTest extends CQLTester
34:cb5897f: {
1:cb5897f:     String roleName = "test_role";
1:cb5897f:     AuthenticatedUser user;
1:cb5897f:     RoleResource role;
1:cb5897f:     ClientState clientState;
1:cb5897f: 
1:cb5897f:     @BeforeClass
1:cb5897f:     public static void setupAuthorizer()
1:cb5897f:     {
1:cb5897f:         try
1:cb5897f:         {
1:cb5897f:             IAuthorizer authorizer = new StubAuthorizer();
1:cb5897f:             Field authorizerField = DatabaseDescriptor.class.getDeclaredField("authorizer");
1:cb5897f:             authorizerField.setAccessible(true);
1:cb5897f:             authorizerField.set(null, authorizer);
1:cb5897f:             DatabaseDescriptor.setPermissionsValidity(0);
34:cb5897f:         }
1:cb5897f:         catch (IllegalAccessException | NoSuchFieldException e)
1:cb5897f:         {
1:cb5897f:             throw new RuntimeException(e);
1:cb5897f:         }
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Before
1:cb5897f:     public void setup() throws Throwable
1:cb5897f:     {
1:cb5897f:         ((StubAuthorizer) DatabaseDescriptor.getAuthorizer()).clear();
1:cb5897f:         setupClientState();
1:cb5897f:         setupTable("CREATE TABLE %s (k int, v1 int, v2 int, PRIMARY KEY (k, v1))");
1:cb5897f:     }
1:cb5897f: 
21:cb5897f:     @Test
1:b2abcb7:     public void functionInSelection() throws Throwable
1:cb5897f:     {
1:b2abcb7:         String functionName = createSimpleFunction();
2:cb5897f:         String cql = String.format("SELECT k, %s FROM %s WHERE k = 1;",
8:cb5897f:                                    functionCall(functionName),
2:cb5897f:                                    KEYSPACE + "." + currentTable());
19:cb5897f:         assertPermissionsOnFunction(cql, functionName);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:b2abcb7:     public void functionInSelectPKRestriction() throws Throwable
1:cb5897f:     {
1:b2abcb7:         String functionName = createSimpleFunction();
2:cb5897f:         String cql = String.format("SELECT * FROM %s WHERE k = %s",
18:cb5897f:                                    KEYSPACE + "." + currentTable(),
18:cb5897f:                                    functionCall(functionName));
1:cb5897f:         assertPermissionsOnFunction(cql, functionName);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:b2abcb7:     public void functionInSelectClusteringRestriction() throws Throwable
1:cb5897f:     {
1:b2abcb7:         String functionName = createSimpleFunction();
2:cb5897f:         String cql = String.format("SELECT * FROM %s WHERE k = 0 AND v1 = %s",
1:cb5897f:                                    KEYSPACE + "." + currentTable(),
1:cb5897f:                                    functionCall(functionName));
1:cb5897f:         assertPermissionsOnFunction(cql, functionName);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:b2abcb7:     public void functionInSelectInRestriction() throws Throwable
1:cb5897f:     {
1:b2abcb7:         String functionName = createSimpleFunction();
2:cb5897f:         String cql = String.format("SELECT * FROM %s WHERE k IN (%s, %s)",
1:cb5897f:                                    KEYSPACE + "." + currentTable(),
1:cb5897f:                                    functionCall(functionName),
1:cb5897f:                                    functionCall(functionName));
1:cb5897f:         assertPermissionsOnFunction(cql, functionName);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:b2abcb7:     public void functionInSelectMultiColumnInRestriction() throws Throwable
1:cb5897f:     {
4:cb5897f:         setupTable("CREATE TABLE %s (k int, v1 int, v2 int, v3 int, PRIMARY KEY (k, v1, v2))");
1:b2abcb7:         String functionName = createSimpleFunction();
2:cb5897f:         String cql = String.format("SELECT * FROM %s WHERE k=0 AND (v1, v2) IN ((%s, %s))",
1:cb5897f:                                    KEYSPACE + "." + currentTable(),
1:cb5897f:                                    functionCall(functionName),
1:cb5897f:                                    functionCall(functionName));
1:cb5897f:         assertPermissionsOnFunction(cql, functionName);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:b2abcb7:     public void functionInSelectMultiColumnEQRestriction() throws Throwable
1:cb5897f:     {
1:cb5897f:         setupTable("CREATE TABLE %s (k int, v1 int, v2 int, v3 int, PRIMARY KEY (k, v1, v2))");
1:b2abcb7:         String functionName = createSimpleFunction();
2:cb5897f:         String cql = String.format("SELECT * FROM %s WHERE k=0 AND (v1, v2) = (%s, %s)",
1:cb5897f:                                    KEYSPACE + "." + currentTable(),
1:cb5897f:                                    functionCall(functionName),
1:cb5897f:                                    functionCall(functionName));
1:cb5897f:         assertPermissionsOnFunction(cql, functionName);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:b2abcb7:     public void functionInSelectMultiColumnSliceRestriction() throws Throwable
1:cb5897f:     {
1:cb5897f:         setupTable("CREATE TABLE %s (k int, v1 int, v2 int, v3 int, PRIMARY KEY (k, v1, v2))");
1:b2abcb7:         String functionName = createSimpleFunction();
1:cb5897f:         String cql = String.format("SELECT * FROM %s WHERE k=0 AND (v1, v2) < (%s, %s)",
1:cb5897f:                                    KEYSPACE + "." + currentTable(),
1:cb5897f:                                    functionCall(functionName),
1:cb5897f:                                    functionCall(functionName));
1:cb5897f:         assertPermissionsOnFunction(cql, functionName);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:b2abcb7:     public void functionInSelectTokenEQRestriction() throws Throwable
1:cb5897f:     {
1:b2abcb7:         String functionName = createSimpleFunction();
2:cb5897f:         String cql = String.format("SELECT * FROM %s WHERE token(k) = token(%s)",
1:cb5897f:                                    KEYSPACE + "." + currentTable(),
1:cb5897f:                                    functionCall(functionName));
1:cb5897f:         assertPermissionsOnFunction(cql, functionName);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:b2abcb7:     public void functionInSelectTokenSliceRestriction() throws Throwable
1:cb5897f:     {
1:b2abcb7:         String functionName = createSimpleFunction();
1:cb5897f:         String cql = String.format("SELECT * FROM %s WHERE token(k) < token(%s)",
1:cb5897f:                                    KEYSPACE + "." + currentTable(),
1:cb5897f:                                    functionCall(functionName));
1:cb5897f:         assertPermissionsOnFunction(cql, functionName);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:b2abcb7:     public void functionInPKForInsert() throws Throwable
1:cb5897f:     {
1:b2abcb7:         String functionName = createSimpleFunction();
1:cb5897f:         String cql = String.format("INSERT INTO %s (k, v1, v2) VALUES (%s, 0, 0)",
1:cb5897f:                                    KEYSPACE + "." + currentTable(),
1:cb5897f:                                    functionCall(functionName));
1:cb5897f:         assertPermissionsOnFunction(cql, functionName);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:b2abcb7:     public void functionInClusteringValuesForInsert() throws Throwable
1:cb5897f:     {
1:b2abcb7:         String functionName = createSimpleFunction();
2:cb5897f:         String cql = String.format("INSERT INTO %s (k, v1, v2) VALUES (0, %s, 0)",
1:cb5897f:                                    KEYSPACE + "." + currentTable(),
1:cb5897f:                                    functionCall(functionName));
1:cb5897f:         assertPermissionsOnFunction(cql, functionName);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:b2abcb7:     public void functionInPKForDelete() throws Throwable
1:cb5897f:     {
1:b2abcb7:         String functionName = createSimpleFunction();
2:cb5897f:         String cql = String.format("DELETE FROM %s WHERE k = %s",
1:cb5897f:                                    KEYSPACE + "." + currentTable(),
1:cb5897f:                                    functionCall(functionName));
1:cb5897f:         assertPermissionsOnFunction(cql, functionName);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:b2abcb7:     public void functionInClusteringValuesForDelete() throws Throwable
1:cb5897f:     {
1:b2abcb7:         String functionName = createSimpleFunction();
2:cb5897f:         String cql = String.format("DELETE FROM %s WHERE k = 0 AND v1 = %s",
1:cb5897f:                                    KEYSPACE + "." + currentTable(),
1:cb5897f:                                    functionCall(functionName));
1:cb5897f:         assertPermissionsOnFunction(cql, functionName);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:cb5897f:     public void testBatchStatement() throws Throwable
1:cb5897f:     {
1:cb5897f:         List<ModificationStatement> statements = new ArrayList<>();
1:cb5897f:         List<String> functions = new ArrayList<>();
1:cb5897f:         for (int i = 0; i < 3; i++)
1:cb5897f:         {
1:b2abcb7:             String functionName = createSimpleFunction();
1:cb5897f:             ModificationStatement stmt =
1:cb5897f:             (ModificationStatement) getStatement(String.format("INSERT INTO %s (k, v1, v2) " +
1:cb5897f:                                                                "VALUES (%s, %s, %s)",
1:cb5897f:                                                                KEYSPACE + "." + currentTable(),
1:cb5897f:                                                                i, i, functionCall(functionName)));
1:cb5897f:             functions.add(functionName);
1:cb5897f:             statements.add(stmt);
1:cb5897f:         }
1:cb5897f:         BatchStatement batch = new BatchStatement(-1, BatchStatement.Type.LOGGED, statements, Attributes.none());
1:cb5897f:         assertUnauthorized(batch, functions);
1:cb5897f: 
1:cb5897f:         grantExecuteOnFunction(functions.get(0));
1:cb5897f:         assertUnauthorized(batch, functions.subList(1, functions.size()));
1:cb5897f: 
1:cb5897f:         grantExecuteOnFunction(functions.get(1));
1:cb5897f:         assertUnauthorized(batch, functions.subList(2, functions.size()));
1:cb5897f: 
1:cb5897f:         grantExecuteOnFunction(functions.get(2));
1:cb5897f:         batch.checkAccess(clientState);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:b2abcb7:     public void testNestedFunctions() throws Throwable
1:cb5897f:     {
1:b2abcb7:         String innerFunctionName = createSimpleFunction();
3:cb5897f:         String outerFunctionName = createFunction("int",
1:cb5897f:                                                   "CREATE FUNCTION %s(input int) " +
1:1937bed:                                                   " CALLED ON NULL INPUT" +
4:cb5897f:                                                   " RETURNS int" +
4:cb5897f:                                                   " LANGUAGE java" +
4:cb5897f:                                                   " AS 'return Integer.valueOf(0);'");
4:cb5897f:         assertPermissionsOnNestedFunctions(innerFunctionName, outerFunctionName);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:b2abcb7:     public void functionInStaticColumnRestrictionInSelect() throws Throwable
1:cb5897f:     {
3:cb5897f:         setupTable("CREATE TABLE %s (k int, s int STATIC, v1 int, v2 int, PRIMARY KEY(k, v1))");
1:b2abcb7:         String functionName = createSimpleFunction();
1:a991b64:         String cql = String.format("SELECT k FROM %s WHERE k = 0 AND s = %s ALLOW FILTERING",
1:cb5897f:                                    KEYSPACE + "." + currentTable(),
1:cb5897f:                                    functionCall(functionName));
1:cb5897f:         assertPermissionsOnFunction(cql, functionName);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:b2abcb7:     public void functionInRegularCondition() throws Throwable
1:cb5897f:     {
1:b2abcb7:         String functionName = createSimpleFunction();
2:cb5897f:         String cql = String.format("UPDATE %s SET v2 = 0 WHERE k = 0 AND v1 = 0 IF v2 = %s",
1:cb5897f:                                    KEYSPACE + "." + currentTable(),
1:cb5897f:                                    functionCall(functionName));
1:cb5897f:         assertPermissionsOnFunction(cql, functionName);
1:cb5897f:     }
1:cb5897f:     @Test
1:b2abcb7:     public void functionInStaticColumnCondition() throws Throwable
1:cb5897f:     {
1:cb5897f:         setupTable("CREATE TABLE %s (k int, s int STATIC, v1 int, v2 int, PRIMARY KEY(k, v1))");
1:b2abcb7:         String functionName = createSimpleFunction();
2:cb5897f:         String cql = String.format("UPDATE %s SET v2 = 0 WHERE k = 0 AND v1 = 0 IF s = %s",
1:cb5897f:                                    KEYSPACE + "." + currentTable(),
1:cb5897f:                                    functionCall(functionName));
1:cb5897f:         assertPermissionsOnFunction(cql, functionName);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:b2abcb7:     public void functionInCollectionLiteralCondition() throws Throwable
1:cb5897f:     {
3:cb5897f:         setupTable("CREATE TABLE %s (k int, v1 int, m_val map<int, int>, PRIMARY KEY(k))");
1:b2abcb7:         String functionName = createSimpleFunction();
2:cb5897f:         String cql = String.format("UPDATE %s SET v1 = 0 WHERE k = 0 IF m_val = {%s : %s}",
1:cb5897f:                                    KEYSPACE + "." + currentTable(),
1:cb5897f:                                    functionCall(functionName),
1:cb5897f:                                    functionCall(functionName));
1:cb5897f:         assertPermissionsOnFunction(cql, functionName);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:b2abcb7:     public void functionInCollectionElementCondition() throws Throwable
1:cb5897f:     {
1:cb5897f:         setupTable("CREATE TABLE %s (k int, v1 int, m_val map<int, int>, PRIMARY KEY(k))");
1:b2abcb7:         String functionName = createSimpleFunction();
2:cb5897f:         String cql = String.format("UPDATE %s SET v1 = 0 WHERE k = 0 IF m_val[%s] = %s",
1:cb5897f:                                    KEYSPACE + "." + currentTable(),
1:cb5897f:                                    functionCall(functionName),
1:cb5897f:                                    functionCall(functionName));
1:cb5897f:         assertPermissionsOnFunction(cql, functionName);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:cb5897f:     public void systemFunctionsRequireNoExplicitPrivileges() throws Throwable
1:cb5897f:     {
1:cb5897f:         // with terminal arguments, so evaluated at prepare time
1:2e3727e:         String cql = String.format("UPDATE %s SET v2 = 0 WHERE k = blobasint(intasblob(0)) and v1 = 0",
1:cb5897f:                                    KEYSPACE + "." + currentTable());
1:cb5897f:         getStatement(cql).checkAccess(clientState);
1:cb5897f: 
1:cb5897f:         // with non-terminal arguments, so evaluated at execution
1:b2abcb7:         String functionName = createSimpleFunction();
1:cb5897f:         grantExecuteOnFunction(functionName);
1:2e3727e:         cql = String.format("UPDATE %s SET v2 = 0 WHERE k = blobasint(intasblob(%s)) and v1 = 0",
1:cb5897f:                             KEYSPACE + "." + currentTable(),
1:cb5897f:                             functionCall(functionName));
1:cb5897f:         getStatement(cql).checkAccess(clientState);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:cb5897f:     public void requireExecutePermissionOnComponentFunctionsWhenDefiningAggregate() throws Throwable
1:cb5897f:     {
1:cb5897f:         String sFunc = createSimpleStateFunction();
1:cb5897f:         String fFunc = createSimpleFinalFunction();
1:cb5897f:         // aside from the component functions, we need CREATE on the keyspace's functions
1:cb5897f:         DatabaseDescriptor.getAuthorizer().grant(AuthenticatedUser.SYSTEM_USER,
1:cb5897f:                                                  ImmutableSet.of(Permission.CREATE),
1:cb5897f:                                                  FunctionResource.keyspace(KEYSPACE),
1:cb5897f:                                                  role);
1:cb5897f:         String aggDef = String.format(aggregateCql(sFunc, fFunc),
1:cb5897f:                                       KEYSPACE + ".aggregate_for_permissions_test");
1:cb5897f: 
1:cb5897f:         assertUnauthorized(aggDef, sFunc, "int, int");
1:cb5897f:         grantExecuteOnFunction(sFunc);
1:cb5897f: 
1:cb5897f:         assertUnauthorized(aggDef, fFunc, "int");
1:cb5897f:         grantExecuteOnFunction(fFunc);
1:cb5897f: 
1:cb5897f:         getStatement(aggDef).checkAccess(clientState);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:cb5897f:     public void revokeExecutePermissionsOnAggregateComponents() throws Throwable
1:cb5897f:     {
1:cb5897f:         String sFunc = createSimpleStateFunction();
1:cb5897f:         String fFunc = createSimpleFinalFunction();
1:cb5897f:         String aggDef = aggregateCql(sFunc, fFunc);
1:cb5897f:         grantExecuteOnFunction(sFunc);
1:cb5897f:         grantExecuteOnFunction(fFunc);
1:cb5897f: 
1:cb5897f:         String aggregate = createAggregate(KEYSPACE, "int", aggDef);
1:cb5897f:         grantExecuteOnFunction(aggregate);
1:cb5897f: 
1:cb5897f:         String cql = String.format("SELECT %s(v1) FROM %s",
1:cb5897f:                                    aggregate,
1:cb5897f:                                    KEYSPACE + "." + currentTable());
1:cb5897f:         getStatement(cql).checkAccess(clientState);
1:cb5897f: 
1:cb5897f:         // check that revoking EXECUTE permission on any one of the
1:cb5897f:         // component functions means we lose the ability to execute it
1:cb5897f:         revokeExecuteOnFunction(aggregate);
1:cb5897f:         assertUnauthorized(cql, aggregate, "int");
1:cb5897f:         grantExecuteOnFunction(aggregate);
1:cb5897f:         getStatement(cql).checkAccess(clientState);
1:cb5897f: 
1:cb5897f:         revokeExecuteOnFunction(sFunc);
1:cb5897f:         assertUnauthorized(cql, sFunc, "int, int");
1:cb5897f:         grantExecuteOnFunction(sFunc);
1:cb5897f:         getStatement(cql).checkAccess(clientState);
1:cb5897f: 
1:cb5897f:         revokeExecuteOnFunction(fFunc);
1:cb5897f:         assertUnauthorized(cql, fFunc, "int");
1:cb5897f:         grantExecuteOnFunction(fFunc);
1:cb5897f:         getStatement(cql).checkAccess(clientState);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:b2abcb7:     public void functionWrappingAggregate() throws Throwable
1:cb5897f:     {
1:cb5897f:         String outerFunc = createFunction("int",
1:cb5897f:                                           "CREATE FUNCTION %s(input int) " +
1:1937bed:                                           "CALLED ON NULL INPUT " +
1:cb5897f:                                           "RETURNS int " +
1:cb5897f:                                           "LANGUAGE java " +
1:cb5897f:                                           "AS 'return input;'");
1:cb5897f: 
1:cb5897f:         String sFunc = createSimpleStateFunction();
1:cb5897f:         String fFunc = createSimpleFinalFunction();
1:cb5897f:         String aggDef = aggregateCql(sFunc, fFunc);
1:cb5897f:         grantExecuteOnFunction(sFunc);
1:cb5897f:         grantExecuteOnFunction(fFunc);
1:cb5897f: 
1:cb5897f:         String aggregate = createAggregate(KEYSPACE, "int", aggDef);
1:cb5897f: 
1:cb5897f:         String cql = String.format("SELECT %s(%s(v1)) FROM %s",
1:cb5897f:                                    outerFunc,
1:cb5897f:                                    aggregate,
1:cb5897f:                                    KEYSPACE + "." + currentTable());
1:cb5897f: 
1:cb5897f:         assertUnauthorized(cql, outerFunc, "int");
1:cb5897f:         grantExecuteOnFunction(outerFunc);
1:cb5897f: 
1:cb5897f:         assertUnauthorized(cql, aggregate, "int");
1:cb5897f:         grantExecuteOnFunction(aggregate);
1:cb5897f: 
1:cb5897f:         getStatement(cql).checkAccess(clientState);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     @Test
1:b2abcb7:     public void aggregateWrappingFunction() throws Throwable
1:cb5897f:     {
1:cb5897f:         String innerFunc = createFunction("int",
1:b2abcb7:                                           "CREATE FUNCTION %s(input int) " +
1:1937bed:                                           "CALLED ON NULL INPUT " +
1:cb5897f:                                           "RETURNS int " +
1:cb5897f:                                           "LANGUAGE java " +
1:cb5897f:                                           "AS 'return input;'");
1:cb5897f: 
1:cb5897f:         String sFunc = createSimpleStateFunction();
1:cb5897f:         String fFunc = createSimpleFinalFunction();
1:cb5897f:         String aggDef = aggregateCql(sFunc, fFunc);
1:cb5897f:         grantExecuteOnFunction(sFunc);
1:cb5897f:         grantExecuteOnFunction(fFunc);
1:cb5897f: 
1:cb5897f:         String aggregate = createAggregate(KEYSPACE, "int", aggDef);
1:cb5897f: 
1:cb5897f:         String cql = String.format("SELECT %s(%s(v1)) FROM %s",
1:cb5897f:                                    aggregate,
1:cb5897f:                                    innerFunc,
1:cb5897f:                                    KEYSPACE + "." + currentTable());
1:cb5897f: 
1:cb5897f:         assertUnauthorized(cql, aggregate, "int");
1:cb5897f:         grantExecuteOnFunction(aggregate);
1:cb5897f: 
1:cb5897f:         assertUnauthorized(cql, innerFunc, "int");
1:cb5897f:         grantExecuteOnFunction(innerFunc);
1:cb5897f: 
1:cb5897f:         getStatement(cql).checkAccess(clientState);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     private void assertPermissionsOnNestedFunctions(String innerFunction, String outerFunction) throws Throwable
1:cb5897f:     {
1:cb5897f:         String cql = String.format("SELECT k, %s FROM %s WHERE k=0",
1:cb5897f:                                    functionCall(outerFunction, functionCall(innerFunction)),
1:cb5897f:                                    KEYSPACE + "." + currentTable());
1:cb5897f:         // fail fast with an UAE on the first function
1:cb5897f:         assertUnauthorized(cql, outerFunction, "int");
1:cb5897f:         grantExecuteOnFunction(outerFunction);
1:cb5897f: 
1:cb5897f:         // after granting execute on the first function, still fail due to the inner function
1:cb5897f:         assertUnauthorized(cql, innerFunction, "");
1:cb5897f:         grantExecuteOnFunction(innerFunction);
1:cb5897f: 
1:cb5897f:         // now execution of both is permitted
1:cb5897f:         getStatement(cql).checkAccess(clientState);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     private void assertPermissionsOnFunction(String cql, String functionName) throws Throwable
1:cb5897f:     {
1:cb5897f:         assertPermissionsOnFunction(cql, functionName, "");
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     private void assertPermissionsOnFunction(String cql, String functionName, String argTypes) throws Throwable
1:cb5897f:     {
1:cb5897f:         assertUnauthorized(cql, functionName, argTypes);
1:cb5897f:         grantExecuteOnFunction(functionName);
1:cb5897f:         getStatement(cql).checkAccess(clientState);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     private void assertUnauthorized(BatchStatement batch, Iterable<String> functionNames) throws Throwable
1:cb5897f:     {
1:cb5897f:         try
1:cb5897f:         {
1:cb5897f:             batch.checkAccess(clientState);
1:cb5897f:             fail("Expected an UnauthorizedException, but none was thrown");
1:cb5897f:         }
1:cb5897f:         catch (UnauthorizedException e)
1:cb5897f:         {
1:cb5897f:             String functions = String.format("(%s)", Joiner.on("|").join(functionNames));
1:cb5897f:             assertTrue(e.getLocalizedMessage()
1:cb5897f:                         .matches(String.format("User %s has no EXECUTE permission on <function %s\\(\\)> or any of its parents",
1:cb5897f:                                                roleName,
1:cb5897f:                                                functions)));
1:cb5897f:         }
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     private void assertUnauthorized(String cql, String functionName, String argTypes) throws Throwable
1:cb5897f:     {
1:cb5897f:         try
1:cb5897f:         {
1:cb5897f:             getStatement(cql).checkAccess(clientState);
1:cb5897f:             fail("Expected an UnauthorizedException, but none was thrown");
1:cb5897f:         }
1:cb5897f:         catch (UnauthorizedException e)
1:cb5897f:         {
1:cb5897f:             assertEquals(String.format("User %s has no EXECUTE permission on <function %s(%s)> or any of its parents",
1:cb5897f:                                        roleName,
1:cb5897f:                                        functionName,
1:cb5897f:                                        argTypes),
1:cb5897f:                          e.getLocalizedMessage());
1:cb5897f:         }
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     private void grantExecuteOnFunction(String functionName)
1:cb5897f:     {
1:cb5897f:             DatabaseDescriptor.getAuthorizer().grant(AuthenticatedUser.SYSTEM_USER,
1:cb5897f:                                                      ImmutableSet.of(Permission.EXECUTE),
1:cb5897f:                                                      functionResource(functionName),
1:cb5897f:                                                      role);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     private void revokeExecuteOnFunction(String functionName)
1:cb5897f:     {
1:cb5897f:         DatabaseDescriptor.getAuthorizer().revoke(AuthenticatedUser.SYSTEM_USER,
1:cb5897f:                                                   ImmutableSet.of(Permission.EXECUTE),
1:cb5897f:                                                   functionResource(functionName),
1:cb5897f:                                                   role);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     void setupClientState()
1:cb5897f:     {
1:cb5897f: 
1:cb5897f:         try
1:cb5897f:         {
1:cb5897f:             role = RoleResource.role(roleName);
1:cb5897f:             // use reflection to set the logged in user so that we don't need to
1:cb5897f:             // bother setting up an IRoleManager
1:cb5897f:             user = new AuthenticatedUser(roleName);
1:cb5897f:             clientState = ClientState.forInternalCalls();
1:cb5897f:             Field userField = ClientState.class.getDeclaredField("user");
1:cb5897f:             userField.setAccessible(true);
1:cb5897f:             userField.set(clientState, user);
1:cb5897f:         }
1:cb5897f:         catch (IllegalAccessException | NoSuchFieldException e)
1:cb5897f:         {
1:cb5897f:             throw new RuntimeException(e);
1:cb5897f:         }
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     private void setupTable(String tableDef) throws Throwable
1:cb5897f:     {
1:cb5897f:         createTable(tableDef);
1:cb5897f:         // test user needs SELECT & MODIFY on the table regardless of permissions on any function
1:cb5897f:         DatabaseDescriptor.getAuthorizer().grant(AuthenticatedUser.SYSTEM_USER,
1:cb5897f:                                                  ImmutableSet.of(Permission.SELECT, Permission.MODIFY),
1:cb5897f:                                                  DataResource.table(KEYSPACE, currentTable()),
1:cb5897f:                                                  RoleResource.role(user.getName()));
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     private String aggregateCql(String sFunc, String fFunc)
1:cb5897f:     {
1:cb5897f:         return "CREATE AGGREGATE %s(int) " +
1:cb5897f:                "SFUNC " + shortFunctionName(sFunc) + " " +
1:cb5897f:                "STYPE int " +
1:cb5897f:                "FINALFUNC " + shortFunctionName(fFunc) + " " +
1:cb5897f:                "INITCOND 0";
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     private String createSimpleStateFunction() throws Throwable
1:cb5897f:     {
1:cb5897f:         return createFunction("int, int",
1:cb5897f:                               "CREATE FUNCTION %s(a int, b int) " +
1:1937bed:                               "CALLED ON NULL INPUT " +
1:cb5897f:                               "RETURNS int " +
1:cb5897f:                               "LANGUAGE java " +
1:cb5897f:                               "AS 'return Integer.valueOf( (a != null ? a.intValue() : 0 ) + b.intValue());'");
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     private String createSimpleFinalFunction() throws Throwable
1:cb5897f:     {
1:cb5897f:         return createFunction("int",
1:cb5897f:                               "CREATE FUNCTION %s(a int) " +
1:1937bed:                               "CALLED ON NULL INPUT " +
1:cb5897f:                               "RETURNS int " +
1:cb5897f:                               "LANGUAGE java " +
1:cb5897f:                               "AS 'return a;'");
1:cb5897f:     }
1:cb5897f: 
1:b2abcb7:     private String createSimpleFunction() throws Throwable
1:cb5897f:     {
1:cb5897f:         return createFunction("",
1:b2abcb7:                               "CREATE FUNCTION %s() " +
1:1937bed:                               "  CALLED ON NULL INPUT " +
1:cb5897f:                               "  RETURNS int " +
1:cb5897f:                               "  LANGUAGE java " +
1:cb5897f:                               "  AS 'return Integer.valueOf(0);'");
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     private String createFunction(String argTypes, String functionDef) throws Throwable
1:cb5897f:     {
1:cb5897f:         return createFunction(KEYSPACE, argTypes, functionDef);
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     private CQLStatement getStatement(String cql)
1:cb5897f:     {
1:cb5897f:         return QueryProcessor.getStatement(cql, clientState).statement;
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     private FunctionResource functionResource(String functionName)
1:cb5897f:     {
1:cb5897f:         // Note that this is somewhat brittle as it assumes that function names are
1:cb5897f:         // truly unique. As such, it will break in the face of overloading.
1:cb5897f:         // It is here to avoid having to duplicate the functionality of CqlParser
1:cb5897f:         // for transforming cql types into AbstractTypes
1:cb5897f:         FunctionName fn = parseFunctionName(functionName);
1:3566843:         Collection<Function> functions = Schema.instance.getFunctions(fn);
1:cb5897f:         assertEquals(String.format("Expected a single function definition for %s, but found %s",
1:cb5897f:                                    functionName,
1:cb5897f:                                    functions.size()),
1:cb5897f:                      1, functions.size());
1:3566843:         return FunctionResource.function(fn.keyspace, fn.name, functions.iterator().next().argTypes());
1:cb5897f:     }
1:cb5897f: 
1:cb5897f:     private String functionCall(String functionName, String...args)
1:cb5897f:     {
1:cb5897f:         return String.format("%s(%s)", functionName, Joiner.on(",").join(args));
1:cb5897f:     }
1:cb5897f: }
============================================================================
author:Dave Brosius
-------------------------------------------------------------------------------
commit:087264f
/////////////////////////////////////////////////////////////////////////
author:Sam Tunnicliffe
-------------------------------------------------------------------------------
commit:7b0c716
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.cql3.*;
/////////////////////////////////////////////////////////////////////////
commit:cb5897f
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: package org.apache.cassandra.cql3;
1: 
1: import java.lang.reflect.Field;
1: import java.util.*;
1: 
1: import com.google.common.base.Joiner;
1: import com.google.common.collect.ImmutableSet;
1: import org.junit.Before;
1: import org.junit.BeforeClass;
1: import org.junit.Test;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
1: 
1: import org.apache.cassandra.auth.*;
1: import org.apache.cassandra.config.DatabaseDescriptor;
1: import org.apache.cassandra.cql3.functions.Function;
1: import org.apache.cassandra.cql3.functions.FunctionName;
0: import org.apache.cassandra.cql3.functions.Functions;
1: import org.apache.cassandra.cql3.statements.BatchStatement;
1: import org.apache.cassandra.cql3.statements.ModificationStatement;
1: import org.apache.cassandra.exceptions.*;
1: import org.apache.cassandra.service.ClientState;
0: import org.apache.cassandra.utils.Pair;
1: 
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertTrue;
1: import static org.junit.Assert.fail;
1: 
1: public class UFAuthTest extends CQLTester
1: {
0:     private static final Logger logger = LoggerFactory.getLogger(UFAuthTest.class);
1: 
1:     String roleName = "test_role";
1:     AuthenticatedUser user;
1:     RoleResource role;
1:     ClientState clientState;
1: 
1:     @BeforeClass
1:     public static void setupAuthorizer()
1:     {
1:         try
1:         {
1:             IAuthorizer authorizer = new StubAuthorizer();
1:             Field authorizerField = DatabaseDescriptor.class.getDeclaredField("authorizer");
1:             authorizerField.setAccessible(true);
1:             authorizerField.set(null, authorizer);
1:             DatabaseDescriptor.setPermissionsValidity(0);
1:         }
1:         catch (IllegalAccessException | NoSuchFieldException e)
1:         {
1:             throw new RuntimeException(e);
1:         }
1:     }
1: 
1:     @Before
1:     public void setup() throws Throwable
1:     {
1:         ((StubAuthorizer) DatabaseDescriptor.getAuthorizer()).clear();
1:         setupClientState();
1:         setupTable("CREATE TABLE %s (k int, v1 int, v2 int, PRIMARY KEY (k, v1))");
1:     }
1: 
1:     @Test
0:     public void nonDeterministicFunctionInSelection() throws Throwable
1:     {
0:         String functionName = createSimpleFunction(false);
1:         String cql = String.format("SELECT k, %s FROM %s WHERE k = 1;",
1:                                    functionCall(functionName),
1:                                    KEYSPACE + "." + currentTable());
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void deterministicFunctionInSelection() throws Throwable
1:     {
0:         String functionName = createSimpleFunction(true);
1:         String cql = String.format("SELECT k, %s FROM %s WHERE k = 1;",
1:                                    functionCall(functionName),
1:                                    KEYSPACE + "." + currentTable());
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void nonDeterministicFunctionInSelectPKRestriction() throws Throwable
1:     {
0:         String functionName = createSimpleFunction(false);
1:         String cql = String.format("SELECT * FROM %s WHERE k = %s",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void deterministicFunctionInSelectPKRestriction() throws Throwable
1:     {
0:         String functionName = createSimpleFunction(true);
1:         String cql = String.format("SELECT * FROM %s WHERE k = %s",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void nonDeterministicFunctionInSelectClusteringRestriction() throws Throwable
1:     {
0:         String functionName = createSimpleFunction(false);
1:         String cql = String.format("SELECT * FROM %s WHERE k = 0 AND v1 = %s",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void deterministicFunctionInSelectClusteringRestriction() throws Throwable
1:     {
0:         String functionName = createSimpleFunction(true);
1:         String cql = String.format("SELECT * FROM %s WHERE k = 0 AND v1 = %s",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void nonDeterministicFunctionInSelectInRestriction() throws Throwable
1:     {
0:         String functionName = createSimpleFunction(false);
1:         String cql = String.format("SELECT * FROM %s WHERE k IN (%s, %s)",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void deterministicFunctionInSelectInRestriction() throws Throwable
1:     {
0:         String functionName = createSimpleFunction(true);
1:         String cql = String.format("SELECT * FROM %s WHERE k IN (%s, %s)",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void nonDeterministicFunctionInSelectMultiColumnInRestriction() throws Throwable
1:     {
1:         setupTable("CREATE TABLE %s (k int, v1 int, v2 int, v3 int, PRIMARY KEY (k, v1, v2))");
0:         String functionName = createSimpleFunction(false);
1:         String cql = String.format("SELECT * FROM %s WHERE k=0 AND (v1, v2) IN ((%s, %s))",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void deterministicFunctionInSelectMultiColumnInRestriction() throws Throwable
1:     {
1:         setupTable("CREATE TABLE %s (k int, v1 int, v2 int, v3 int, PRIMARY KEY (k, v1, v2))");
0:         String functionName = createSimpleFunction(true);
1:         String cql = String.format("SELECT * FROM %s WHERE k=0 AND (v1, v2) IN ((%s, %s))",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1: 
1:     @Test
0:     public void nonDeterministicFunctionInSelectMultiColumnEQRestriction() throws Throwable
1:     {
1:         setupTable("CREATE TABLE %s (k int, v1 int, v2 int, v3 int, PRIMARY KEY (k, v1, v2))");
0:         String functionName = createSimpleFunction(false);
1:         String cql = String.format("SELECT * FROM %s WHERE k=0 AND (v1, v2) = (%s, %s)",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void deterministicFunctionInSelectMultiColumnEQRestriction() throws Throwable
1:     {
1:         setupTable("CREATE TABLE %s (k int, v1 int, v2 int, v3 int, PRIMARY KEY (k, v1, v2))");
0:         String functionName = createSimpleFunction(true);
1:         String cql = String.format("SELECT * FROM %s WHERE k=0 AND (v1, v2) = (%s, %s)",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void nonDeterministicFunctionInSelectMultiColumnSliceRestriction() throws Throwable
1:     {
1:         setupTable("CREATE TABLE %s (k int, v1 int, v2 int, v3 int, PRIMARY KEY (k, v1, v2))");
0:         String functionName = createSimpleFunction(false);
0:         String cql = String.format("SELECT * FROM %s WHERE k=0 AND (v1, v2) > (%s, %s)",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void deterministicFunctionInSelectMultiColumnSliceRestriction() throws Throwable
1:     {
1:         setupTable("CREATE TABLE %s (k int, v1 int, v2 int, v3 int, PRIMARY KEY (k, v1, v2))");
0:         String functionName = createSimpleFunction(true);
1:         String cql = String.format("SELECT * FROM %s WHERE k=0 AND (v1, v2) < (%s, %s)",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void nonDeterministicFunctionInSelectTokenEQRestriction() throws Throwable
1:     {
0:         String functionName = createSimpleFunction(false);
1:         String cql = String.format("SELECT * FROM %s WHERE token(k) = token(%s)",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void deterministicFunctionInSelectTokenEQRestriction() throws Throwable
1:     {
0:         String functionName = createSimpleFunction(true);
1:         String cql = String.format("SELECT * FROM %s WHERE token(k) = token(%s)",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void nonDeterministicFunctionInSelectTokenSliceRestriction() throws Throwable
1:     {
0:         String functionName = createSimpleFunction(false);
0:         String cql = String.format("SELECT * FROM %s WHERE token(k) > token(%s)",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void deterministicFunctionInSelectTokenSliceRestriction() throws Throwable
1:     {
0:         String functionName = createSimpleFunction(true);
1:         String cql = String.format("SELECT * FROM %s WHERE token(k) < token(%s)",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1:     @Test
0:     public void nonDeterministicFunctionInPKForInsert() throws Throwable
1:     {
0:         String functionName = createSimpleFunction(false);
0:         String cql = String.format("INSERT INTO %s (k, v1 ,v2) VALUES (%s, 0, 0)",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void deterministicFunctionInPKForInsert() throws Throwable
1:     {
0:         String functionName = createSimpleFunction(true);
1:         String cql = String.format("INSERT INTO %s (k, v1, v2) VALUES (%s, 0, 0)",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void nonDeterministicFunctionInClusteringValuesForInsert() throws Throwable
1:     {
0:         String functionName = createSimpleFunction(false);
1:         String cql = String.format("INSERT INTO %s (k, v1, v2) VALUES (0, %s, 0)",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void deterministicFunctionInClusteringValuesForInsert() throws Throwable
1:     {
0:         String functionName = createSimpleFunction(true);
1:         String cql = String.format("INSERT INTO %s (k, v1, v2) VALUES (0, %s, 0)",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void nonDeterministicFunctionInPKForDelete() throws Throwable
1:     {
0:         String functionName = createSimpleFunction(false);
1:         String cql = String.format("DELETE FROM %s WHERE k = %s",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void deterministicFunctionInPKForDelete() throws Throwable
1:     {
0:         String functionName = createSimpleFunction(true);
1:         String cql = String.format("DELETE FROM %s WHERE k = %s",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void nonDeterministicFunctionInClusteringValuesForDelete() throws Throwable
1:     {
0:         String functionName = createSimpleFunction(false);
1:         String cql = String.format("DELETE FROM %s WHERE k = 0 AND v1 = %s",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
1: 
0:     public void deterministicFunctionInClusteringValuesForDelete() throws Throwable
1:     {
0:         String functionName = createSimpleFunction(true);
1:         String cql = String.format("DELETE FROM %s WHERE k = 0 AND v1 = %s",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
1:     public void testBatchStatement() throws Throwable
1:     {
1:         List<ModificationStatement> statements = new ArrayList<>();
1:         List<String> functions = new ArrayList<>();
1:         for (int i = 0; i < 3; i++)
1:         {
0:             String functionName = createSimpleFunction(false);
1:             ModificationStatement stmt =
1:             (ModificationStatement) getStatement(String.format("INSERT INTO %s (k, v1, v2) " +
1:                                                                "VALUES (%s, %s, %s)",
1:                                                                KEYSPACE + "." + currentTable(),
1:                                                                i, i, functionCall(functionName)));
1:             functions.add(functionName);
1:             statements.add(stmt);
1:         }
1:         BatchStatement batch = new BatchStatement(-1, BatchStatement.Type.LOGGED, statements, Attributes.none());
1:         assertUnauthorized(batch, functions);
1: 
1:         grantExecuteOnFunction(functions.get(0));
1:         assertUnauthorized(batch, functions.subList(1, functions.size()));
1: 
1:         grantExecuteOnFunction(functions.get(1));
1:         assertUnauthorized(batch, functions.subList(2, functions.size()));
1: 
1:         grantExecuteOnFunction(functions.get(2));
1:         batch.checkAccess(clientState);
1:     }
1: 
1:     @Test
0:     public void testNestedNonDeterministicFunctions() throws Throwable
1:     {
0:         String innerFunctionName = createSimpleFunction(false);
1:         String outerFunctionName = createFunction("int",
0:                                                   "CREATE NON DETERMINISTIC FUNCTION %s(input int) " +
1:                                                   " RETURNS int" +
1:                                                   " LANGUAGE java" +
1:                                                   " AS 'return Integer.valueOf(0);'");
1:         assertPermissionsOnNestedFunctions(innerFunctionName, outerFunctionName);
1:     }
1: 
1:     @Test
0:     public void testNestedDeterministicFunctions() throws Throwable
1:     {
0:         String innerFunctionName = createSimpleFunction(true);
1:         String outerFunctionName = createFunction("int",
1:                                                   "CREATE FUNCTION %s(input int) " +
1:                                                   " RETURNS int" +
1:                                                   " LANGUAGE java" +
1:                                                   " AS 'return Integer.valueOf(0);'");
1:         assertPermissionsOnNestedFunctions(innerFunctionName, outerFunctionName);
1:     }
1: 
1:     @Test
0:     public void testNestedMixedFunctions() throws Throwable
1:     {
0:         String innerFunctionName = createSimpleFunction(true);
1:         String outerFunctionName = createFunction("int",
0:                                                   "CREATE NON DETERMINISTIC FUNCTION %s(input int) " +
1:                                                   " RETURNS int" +
1:                                                   " LANGUAGE java" +
1:                                                   " AS 'return Integer.valueOf(0);'");
1:         assertPermissionsOnNestedFunctions(innerFunctionName, outerFunctionName);
1: 
0:         innerFunctionName = createSimpleFunction(false);
0:         outerFunctionName = createFunction("int",
1:                                            "CREATE FUNCTION %s(input int) " +
1:                                            " RETURNS int" +
1:                                            " LANGUAGE java" +
1:                                            " AS 'return Integer.valueOf(0);'");
1:         assertPermissionsOnNestedFunctions(innerFunctionName, outerFunctionName);
1:     }
1: 
1:     @Test
0:     public void nonDeterministicFunctionInStaticColumnRestrictionInSelect() throws Throwable
1:     {
1:         setupTable("CREATE TABLE %s (k int, s int STATIC, v1 int, v2 int, PRIMARY KEY(k, v1))");
0:         String functionName = createSimpleFunction(false);
0:         String cql = String.format("SELECT k FROM %s WHERE k = 0 AND s = %s",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void deterministicFunctionInStaticColumnRestrictionInSelect() throws Throwable
1:     {
1:         setupTable("CREATE TABLE %s (k int, s int STATIC, v1 int, v2 int, PRIMARY KEY(k, v1))");
0:         String functionName = createSimpleFunction(true);
0:         String cql = String.format("SELECT k FROM %s WHERE k = 0 AND s = %s",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void nonDeterministicFunctionInRegularCondition() throws Throwable
1:     {
0:         String functionName = createSimpleFunction(false);
1:         String cql = String.format("UPDATE %s SET v2 = 0 WHERE k = 0 AND v1 = 0 IF v2 = %s",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void deterministicFunctionInRegularCondition() throws Throwable
1:     {
0:         String functionName = createSimpleFunction(true);
1:         String cql = String.format("UPDATE %s SET v2 = 0 WHERE k = 0 AND v1 = 0 IF v2 = %s",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void nonDeterministicFunctionInStaticColumnCondition() throws Throwable
1:     {
1:         setupTable("CREATE TABLE %s (k int, s int STATIC, v1 int, v2 int, PRIMARY KEY(k, v1))");
0:         String functionName = createSimpleFunction(false);
1:         String cql = String.format("UPDATE %s SET v2 = 0 WHERE k = 0 AND v1 = 0 IF s = %s",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void deterministicFunctionInStaticColumnCondition() throws Throwable
1:     {
1:         setupTable("CREATE TABLE %s (k int, s int STATIC, v1 int, v2 int, PRIMARY KEY(k, v1))");
0:         String functionName = createSimpleFunction(true);
1:         String cql = String.format("UPDATE %s SET v2 = 0 WHERE k = 0 AND v1 = 0 IF s = %s",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void nonDeterministicFunctionInCollectionLiteralCondition() throws Throwable
1:     {
1:         setupTable("CREATE TABLE %s (k int, v1 int, m_val map<int, int>, PRIMARY KEY(k))");
0:         String functionName = createSimpleFunction(false);
1:         String cql = String.format("UPDATE %s SET v1 = 0 WHERE k = 0 IF m_val = {%s : %s}",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void deterministicFunctionInCollectionLiteralCondition() throws Throwable
1:     {
1:         setupTable("CREATE TABLE %s (k int, v1 int, m_val map<int, int>, PRIMARY KEY(k))");
0:         String functionName = createSimpleFunction(true);
1:         String cql = String.format("UPDATE %s SET v1 = 0 WHERE k = 0 IF m_val = {%s : %s}",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void nonDeterministicFunctionInCollectionElementCondition() throws Throwable
1:     {
1:         setupTable("CREATE TABLE %s (k int, v1 int, m_val map<int, int>, PRIMARY KEY(k))");
0:         String functionName = createSimpleFunction(false);
1:         String cql = String.format("UPDATE %s SET v1 = 0 WHERE k = 0 IF m_val[%s] = %s",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
0:     public void deterministicFunctionInCollectionElementCondition() throws Throwable
1:     {
1:         setupTable("CREATE TABLE %s (k int, v1 int, m_val map<int, int>, PRIMARY KEY(k))");
0:         String functionName = createSimpleFunction(true);
1:         String cql = String.format("UPDATE %s SET v1 = 0 WHERE k = 0 IF m_val[%s] = %s",
1:                                    KEYSPACE + "." + currentTable(),
1:                                    functionCall(functionName),
1:                                    functionCall(functionName));
1:         assertPermissionsOnFunction(cql, functionName);
1:     }
1: 
1:     @Test
1:     public void systemFunctionsRequireNoExplicitPrivileges() throws Throwable
1:     {
1:         // with terminal arguments, so evaluated at prepare time
0:         String cql = String.format("UPDATE %s SET v2 = 0 WHERE k = blobasint(intasblob(0))",
1:                                    KEYSPACE + "." + currentTable());
1:         getStatement(cql).checkAccess(clientState);
1: 
1:         // with non-terminal arguments, so evaluated at execution
0:         String functionName = createSimpleFunction(false);
1:         grantExecuteOnFunction(functionName);
0:         cql = String.format("UPDATE %s SET v2 = 0 WHERE k = blobasint(intasblob(%s))",
1:                             KEYSPACE + "." + currentTable(),
1:                             functionCall(functionName));
1:         getStatement(cql).checkAccess(clientState);
1:     }
1: 
1:     @Test
1:     public void requireExecutePermissionOnComponentFunctionsWhenDefiningAggregate() throws Throwable
1:     {
1:         String sFunc = createSimpleStateFunction();
1:         String fFunc = createSimpleFinalFunction();
1:         // aside from the component functions, we need CREATE on the keyspace's functions
1:         DatabaseDescriptor.getAuthorizer().grant(AuthenticatedUser.SYSTEM_USER,
1:                                                  ImmutableSet.of(Permission.CREATE),
1:                                                  FunctionResource.keyspace(KEYSPACE),
1:                                                  role);
1:         String aggDef = String.format(aggregateCql(sFunc, fFunc),
1:                                       KEYSPACE + ".aggregate_for_permissions_test");
1: 
1:         assertUnauthorized(aggDef, sFunc, "int, int");
1:         grantExecuteOnFunction(sFunc);
1: 
1:         assertUnauthorized(aggDef, fFunc, "int");
1:         grantExecuteOnFunction(fFunc);
1: 
1:         getStatement(aggDef).checkAccess(clientState);
1:     }
1: 
1:     @Test
1:     public void revokeExecutePermissionsOnAggregateComponents() throws Throwable
1:     {
1:         String sFunc = createSimpleStateFunction();
1:         String fFunc = createSimpleFinalFunction();
1:         String aggDef = aggregateCql(sFunc, fFunc);
1:         grantExecuteOnFunction(sFunc);
1:         grantExecuteOnFunction(fFunc);
1: 
1:         String aggregate = createAggregate(KEYSPACE, "int", aggDef);
1:         grantExecuteOnFunction(aggregate);
1: 
1:         String cql = String.format("SELECT %s(v1) FROM %s",
1:                                    aggregate,
1:                                    KEYSPACE + "." + currentTable());
1:         getStatement(cql).checkAccess(clientState);
1: 
1:         // check that revoking EXECUTE permission on any one of the
1:         // component functions means we lose the ability to execute it
1:         revokeExecuteOnFunction(aggregate);
1:         assertUnauthorized(cql, aggregate, "int");
1:         grantExecuteOnFunction(aggregate);
1:         getStatement(cql).checkAccess(clientState);
1: 
1:         revokeExecuteOnFunction(sFunc);
1:         assertUnauthorized(cql, sFunc, "int, int");
1:         grantExecuteOnFunction(sFunc);
1:         getStatement(cql).checkAccess(clientState);
1: 
1:         revokeExecuteOnFunction(fFunc);
1:         assertUnauthorized(cql, fFunc, "int");
1:         grantExecuteOnFunction(fFunc);
1:         getStatement(cql).checkAccess(clientState);
1:     }
1: 
1:     @Test
0:     public void nonDeterministicFunctionWrappingAggregate() throws Throwable
1:     {
1:         String outerFunc = createFunction("int",
0:                                           "CREATE NON DETERMINISTIC FUNCTION %s(input int) " +
1:                                           "RETURNS int " +
1:                                           "LANGUAGE java " +
1:                                           "AS 'return input;'");
1: 
1:         String sFunc = createSimpleStateFunction();
1:         String fFunc = createSimpleFinalFunction();
1:         String aggDef = aggregateCql(sFunc, fFunc);
1:         grantExecuteOnFunction(sFunc);
1:         grantExecuteOnFunction(fFunc);
1: 
1:         String aggregate = createAggregate(KEYSPACE, "int", aggDef);
1: 
1:         String cql = String.format("SELECT %s(%s(v1)) FROM %s",
1:                                    outerFunc,
1:                                    aggregate,
1:                                    KEYSPACE + "." + currentTable());
1: 
1:         assertUnauthorized(cql, outerFunc, "int");
1:         grantExecuteOnFunction(outerFunc);
1: 
1:         assertUnauthorized(cql, aggregate, "int");
1:         grantExecuteOnFunction(aggregate);
1: 
1:         getStatement(cql).checkAccess(clientState);
1:     }
1: 
1:     @Test
0:     public void aggregateWrappingNonDeterministicFunction() throws Throwable
1:     {
1:         String innerFunc = createFunction("int",
0:                                           "CREATE NON DETERMINISTIC FUNCTION %s(input int) " +
1:                                           "RETURNS int " +
1:                                           "LANGUAGE java " +
1:                                           "AS 'return input;'");
1: 
1:         String sFunc = createSimpleStateFunction();
1:         String fFunc = createSimpleFinalFunction();
1:         String aggDef = aggregateCql(sFunc, fFunc);
1:         grantExecuteOnFunction(sFunc);
1:         grantExecuteOnFunction(fFunc);
1: 
1:         String aggregate = createAggregate(KEYSPACE, "int", aggDef);
1: 
1:         String cql = String.format("SELECT %s(%s(v1)) FROM %s",
1:                                    aggregate,
1:                                    innerFunc,
1:                                    KEYSPACE + "." + currentTable());
1: 
1:         assertUnauthorized(cql, aggregate, "int");
1:         grantExecuteOnFunction(aggregate);
1: 
1:         assertUnauthorized(cql, innerFunc, "int");
1:         grantExecuteOnFunction(innerFunc);
1: 
1:         getStatement(cql).checkAccess(clientState);
1:     }
1: 
1:     private void assertPermissionsOnNestedFunctions(String innerFunction, String outerFunction) throws Throwable
1:     {
1:         String cql = String.format("SELECT k, %s FROM %s WHERE k=0",
1:                                    functionCall(outerFunction, functionCall(innerFunction)),
1:                                    KEYSPACE + "." + currentTable());
1:         // fail fast with an UAE on the first function
1:         assertUnauthorized(cql, outerFunction, "int");
1:         grantExecuteOnFunction(outerFunction);
1: 
1:         // after granting execute on the first function, still fail due to the inner function
1:         assertUnauthorized(cql, innerFunction, "");
1:         grantExecuteOnFunction(innerFunction);
1: 
1:         // now execution of both is permitted
1:         getStatement(cql).checkAccess(clientState);
1:     }
1: 
1:     private void assertPermissionsOnFunction(String cql, String functionName) throws Throwable
1:     {
1:         assertPermissionsOnFunction(cql, functionName, "");
1:     }
1: 
1:     private void assertPermissionsOnFunction(String cql, String functionName, String argTypes) throws Throwable
1:     {
1:         assertUnauthorized(cql, functionName, argTypes);
1:         grantExecuteOnFunction(functionName);
1:         getStatement(cql).checkAccess(clientState);
1:     }
1: 
1:     private void assertUnauthorized(BatchStatement batch, Iterable<String> functionNames) throws Throwable
1:     {
1:         try
1:         {
1:             batch.checkAccess(clientState);
1:             fail("Expected an UnauthorizedException, but none was thrown");
1:         }
1:         catch (UnauthorizedException e)
1:         {
1:             String functions = String.format("(%s)", Joiner.on("|").join(functionNames));
1:             assertTrue(e.getLocalizedMessage()
1:                         .matches(String.format("User %s has no EXECUTE permission on <function %s\\(\\)> or any of its parents",
1:                                                roleName,
1:                                                functions)));
1:         }
1:     }
1: 
1:     private void assertUnauthorized(String cql, String functionName, String argTypes) throws Throwable
1:     {
1:         try
1:         {
1:             getStatement(cql).checkAccess(clientState);
1:             fail("Expected an UnauthorizedException, but none was thrown");
1:         }
1:         catch (UnauthorizedException e)
1:         {
1:             assertEquals(String.format("User %s has no EXECUTE permission on <function %s(%s)> or any of its parents",
1:                                        roleName,
1:                                        functionName,
1:                                        argTypes),
1:                          e.getLocalizedMessage());
1:         }
1:     }
1: 
1:     private void grantExecuteOnFunction(String functionName)
1:     {
1:             DatabaseDescriptor.getAuthorizer().grant(AuthenticatedUser.SYSTEM_USER,
1:                                                      ImmutableSet.of(Permission.EXECUTE),
1:                                                      functionResource(functionName),
1:                                                      role);
1:     }
1: 
1:     private void revokeExecuteOnFunction(String functionName)
1:     {
1:         DatabaseDescriptor.getAuthorizer().revoke(AuthenticatedUser.SYSTEM_USER,
1:                                                   ImmutableSet.of(Permission.EXECUTE),
1:                                                   functionResource(functionName),
1:                                                   role);
1:     }
1: 
1:     void setupClientState()
1:     {
1: 
1:         try
1:         {
1:             role = RoleResource.role(roleName);
1:             // use reflection to set the logged in user so that we don't need to
1:             // bother setting up an IRoleManager
1:             user = new AuthenticatedUser(roleName);
1:             clientState = ClientState.forInternalCalls();
1:             Field userField = ClientState.class.getDeclaredField("user");
1:             userField.setAccessible(true);
1:             userField.set(clientState, user);
1:         }
1:         catch (IllegalAccessException | NoSuchFieldException e)
1:         {
1:             throw new RuntimeException(e);
1:         }
1:     }
1: 
1:     private void setupTable(String tableDef) throws Throwable
1:     {
1:         createTable(tableDef);
1:         // test user needs SELECT & MODIFY on the table regardless of permissions on any function
1:         DatabaseDescriptor.getAuthorizer().grant(AuthenticatedUser.SYSTEM_USER,
1:                                                  ImmutableSet.of(Permission.SELECT, Permission.MODIFY),
1:                                                  DataResource.table(KEYSPACE, currentTable()),
1:                                                  RoleResource.role(user.getName()));
1:     }
1: 
1:     private String aggregateCql(String sFunc, String fFunc)
1:     {
1:         return "CREATE AGGREGATE %s(int) " +
1:                "SFUNC " + shortFunctionName(sFunc) + " " +
1:                "STYPE int " +
1:                "FINALFUNC " + shortFunctionName(fFunc) + " " +
1:                "INITCOND 0";
1:     }
1: 
1:     private String createSimpleStateFunction() throws Throwable
1:     {
1:         return createFunction("int, int",
1:                               "CREATE FUNCTION %s(a int, b int) " +
1:                               "RETURNS int " +
1:                               "LANGUAGE java " +
1:                               "AS 'return Integer.valueOf( (a != null ? a.intValue() : 0 ) + b.intValue());'");
1:     }
1: 
1:     private String createSimpleFinalFunction() throws Throwable
1:     {
1:         return createFunction("int",
1:                               "CREATE FUNCTION %s(a int) " +
1:                               "RETURNS int " +
1:                               "LANGUAGE java " +
1:                               "AS 'return a;'");
1:     }
1: 
0:     private String createSimpleFunction(boolean deterministic) throws Throwable
1:     {
1:         return createFunction("",
0:                               "CREATE " + (deterministic ? "" : " NON ") +  " DETERMINISTIC FUNCTION %s() " +
1:                               "  RETURNS int " +
1:                               "  LANGUAGE java " +
1:                               "  AS 'return Integer.valueOf(0);'");
1:     }
1: 
1:     private String createFunction(String argTypes, String functionDef) throws Throwable
1:     {
1:         return createFunction(KEYSPACE, argTypes, functionDef);
1:     }
1: 
1:     private CQLStatement getStatement(String cql)
1:     {
1:         return QueryProcessor.getStatement(cql, clientState).statement;
1:     }
1: 
1:     private FunctionResource functionResource(String functionName)
1:     {
1:         // Note that this is somewhat brittle as it assumes that function names are
1:         // truly unique. As such, it will break in the face of overloading.
1:         // It is here to avoid having to duplicate the functionality of CqlParser
1:         // for transforming cql types into AbstractTypes
1:         FunctionName fn = parseFunctionName(functionName);
0:         List<Function> functions = Functions.find(fn);
1:         assertEquals(String.format("Expected a single function definition for %s, but found %s",
1:                                    functionName,
1:                                    functions.size()),
1:                      1, functions.size());
0:         return FunctionResource.function(fn.keyspace, fn.name, functions.get(0).argTypes());
1:     }
1: 
1:     private String functionCall(String functionName, String...args)
1:     {
1:         return String.format("%s(%s)", functionName, Joiner.on(",").join(args));
1:     }
1: 
0:     static class StubAuthorizer implements IAuthorizer
1:     {
0:         Map<Pair<String, IResource>, Set<Permission>> userPermissions = new HashMap<>();
1: 
0:         private void clear()
1:         {
0:             userPermissions.clear();
1:         }
1: 
0:         public Set<Permission> authorize(AuthenticatedUser user, IResource resource)
1:         {
0:             Pair<String, IResource> key = Pair.create(user.getName(), resource);
0:             Set<Permission> perms = userPermissions.get(key);
0:             return perms != null ? perms : Collections.<Permission>emptySet();
1:         }
1: 
0:         public void grant(AuthenticatedUser performer,
0:                           Set<Permission> permissions,
0:                           IResource resource,
0:                           RoleResource grantee) throws RequestValidationException, RequestExecutionException
1:         {
0:             Pair<String, IResource> key = Pair.create(grantee.getRoleName(), resource);
0:             Set<Permission> perms = userPermissions.get(key);
0:             if (null == perms)
1:             {
0:                 perms = new HashSet<>();
0:                 userPermissions.put(key, perms);
1:             }
0:             perms.addAll(permissions);
1:         }
1: 
0:         public void revoke(AuthenticatedUser performer,
0:                            Set<Permission> permissions,
0:                            IResource resource,
0:                            RoleResource revokee) throws RequestValidationException, RequestExecutionException
1:         {
0:             Pair<String, IResource> key = Pair.create(revokee.getRoleName(), resource);
0:             Set<Permission> perms = userPermissions.get(key);
0:             if (null != perms)
0:                 perms.removeAll(permissions);
0:             if (perms.isEmpty())
0:                 userPermissions.remove(key);
1:         }
1: 
0:         public Set<PermissionDetails> list(AuthenticatedUser performer,
0:                                            Set<Permission> permissions,
0:                                            IResource resource,
0:                                            RoleResource grantee) throws RequestValidationException, RequestExecutionException
1:         {
0:             Pair<String, IResource> key = Pair.create(grantee.getRoleName(), resource);
0:             Set<Permission> perms = userPermissions.get(key);
0:             if (perms == null)
0:                 return Collections.emptySet();
1: 
1: 
0:             Set<PermissionDetails> details = new HashSet<>();
0:             for (Permission permission : perms)
1:             {
0:                 if (permissions.contains(permission))
0:                     details.add(new PermissionDetails(grantee.getRoleName(), resource, permission));
1:             }
0:             return details;
1:         }
1: 
0:         public void revokeAllFrom(RoleResource revokee)
1:         {
0:             for (Pair<String, IResource> key : userPermissions.keySet())
0:                 if (key.left.equals(revokee.getRoleName()))
0:                     userPermissions.remove(key);
1:         }
1: 
0:         public void revokeAllOn(IResource droppedResource)
1:         {
0:             for (Pair<String, IResource> key : userPermissions.keySet())
0:                 if (key.right.equals(droppedResource))
0:                     userPermissions.remove(key);
1: 
1:         }
1: 
0:         public Set<? extends IResource> protectedResources()
1:         {
0:             return Collections.emptySet();
1:         }
1: 
0:         public void validateConfiguration() throws ConfigurationException
1:         {
1: 
1:         }
1: 
0:         public void setup()
1:         {
1: 
1:         }
1:     }
1: }
author:blerer
-------------------------------------------------------------------------------
commit:2e3727e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         String cql = String.format("UPDATE %s SET v2 = 0 WHERE k = blobasint(intasblob(0)) and v1 = 0",
1:         cql = String.format("UPDATE %s SET v2 = 0 WHERE k = blobasint(intasblob(%s)) and v1 = 0",
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:3566843
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.Schema;
/////////////////////////////////////////////////////////////////////////
1:         Collection<Function> functions = Schema.instance.getFunctions(fn);
1:         return FunctionResource.function(fn.keyspace, fn.name, functions.iterator().next().argTypes());
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1:         String cql = String.format("SELECT k FROM %s WHERE k = 0 AND s = %s ALLOW FILTERING",
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:01115f7
/////////////////////////////////////////////////////////////////////////
1: package org.apache.cassandra.cql3.validation.entities;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.cql3.Attributes;
0: import org.apache.cassandra.cql3.CQLStatement;
0: import org.apache.cassandra.cql3.QueryProcessor;
0: import org.apache.cassandra.cql3.CQLTester;
author:Robert Stupp
-------------------------------------------------------------------------------
commit:1937bed
/////////////////////////////////////////////////////////////////////////
1:                                                   " CALLED ON NULL INPUT" +
/////////////////////////////////////////////////////////////////////////
1:                                           "CALLED ON NULL INPUT " +
/////////////////////////////////////////////////////////////////////////
1:                                           "CALLED ON NULL INPUT " +
/////////////////////////////////////////////////////////////////////////
1:                               "CALLED ON NULL INPUT " +
/////////////////////////////////////////////////////////////////////////
1:                               "CALLED ON NULL INPUT " +
/////////////////////////////////////////////////////////////////////////
1:                               "  CALLED ON NULL INPUT " +
author:Carl Yeksigian
-------------------------------------------------------------------------------
commit:b2abcb7
/////////////////////////////////////////////////////////////////////////
1:     public void functionInSelection() throws Throwable
1:         String functionName = createSimpleFunction();
/////////////////////////////////////////////////////////////////////////
1:     public void functionInSelectPKRestriction() throws Throwable
1:         String functionName = createSimpleFunction();
/////////////////////////////////////////////////////////////////////////
1:     public void functionInSelectClusteringRestriction() throws Throwable
1:         String functionName = createSimpleFunction();
/////////////////////////////////////////////////////////////////////////
1:     public void functionInSelectInRestriction() throws Throwable
1:         String functionName = createSimpleFunction();
/////////////////////////////////////////////////////////////////////////
1:     public void functionInSelectMultiColumnInRestriction() throws Throwable
1:         String functionName = createSimpleFunction();
/////////////////////////////////////////////////////////////////////////
1:     public void functionInSelectMultiColumnEQRestriction() throws Throwable
1:         String functionName = createSimpleFunction();
/////////////////////////////////////////////////////////////////////////
1:     public void functionInSelectMultiColumnSliceRestriction() throws Throwable
1:         String functionName = createSimpleFunction();
/////////////////////////////////////////////////////////////////////////
1:     public void functionInSelectTokenEQRestriction() throws Throwable
1:         String functionName = createSimpleFunction();
/////////////////////////////////////////////////////////////////////////
1:     public void functionInSelectTokenSliceRestriction() throws Throwable
1:         String functionName = createSimpleFunction();
1:     public void functionInPKForInsert() throws Throwable
1:         String functionName = createSimpleFunction();
/////////////////////////////////////////////////////////////////////////
1:     public void functionInClusteringValuesForInsert() throws Throwable
1:         String functionName = createSimpleFunction();
/////////////////////////////////////////////////////////////////////////
1:     public void functionInPKForDelete() throws Throwable
1:         String functionName = createSimpleFunction();
/////////////////////////////////////////////////////////////////////////
1:     public void functionInClusteringValuesForDelete() throws Throwable
1:         String functionName = createSimpleFunction();
/////////////////////////////////////////////////////////////////////////
1:             String functionName = createSimpleFunction();
/////////////////////////////////////////////////////////////////////////
1:     public void testNestedFunctions() throws Throwable
1:         String innerFunctionName = createSimpleFunction();
/////////////////////////////////////////////////////////////////////////
1:     public void functionInStaticColumnRestrictionInSelect() throws Throwable
1:         String functionName = createSimpleFunction();
/////////////////////////////////////////////////////////////////////////
1:     public void functionInRegularCondition() throws Throwable
1:         String functionName = createSimpleFunction();
1:     public void functionInStaticColumnCondition() throws Throwable
1:         String functionName = createSimpleFunction();
/////////////////////////////////////////////////////////////////////////
1:     public void functionInCollectionLiteralCondition() throws Throwable
1:         String functionName = createSimpleFunction();
/////////////////////////////////////////////////////////////////////////
1:     public void functionInCollectionElementCondition() throws Throwable
1:         String functionName = createSimpleFunction();
/////////////////////////////////////////////////////////////////////////
1:         String functionName = createSimpleFunction();
/////////////////////////////////////////////////////////////////////////
1:     public void functionWrappingAggregate() throws Throwable
1:                                           "CREATE FUNCTION %s(input int) " +
/////////////////////////////////////////////////////////////////////////
1:     public void aggregateWrappingFunction() throws Throwable
0:                                           "CREATE FUNCTION %s(input int) " +
/////////////////////////////////////////////////////////////////////////
1:     private String createSimpleFunction() throws Throwable
1:                               "CREATE FUNCTION %s() " +
============================================================================