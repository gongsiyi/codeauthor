1:a552b30: /*
1:a552b30:  * Licensed to the Apache Software Foundation (ASF) under one
1:a552b30:  * or more contributor license agreements.  See the NOTICE file
1:a552b30:  * distributed with this work for additional information
1:a552b30:  * regarding copyright ownership.  The ASF licenses this file
1:a552b30:  * to you under the Apache License, Version 2.0 (the
1:a552b30:  * "License"); you may not use this file except in compliance
1:a552b30:  * with the License.  You may obtain a copy of the License at
1:a552b30:  *
1:a552b30:  *     http://www.apache.org/licenses/LICENSE-2.0
1:a552b30:  *
1:a552b30:  * Unless required by applicable law or agreed to in writing, software
1:a552b30:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a552b30:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a552b30:  * See the License for the specific language governing permissions and
1:a552b30:  * limitations under the License.
1:a552b30:  */
1:a552b30: package org.apache.cassandra.cql3;
1:a552b30: 
1:a552b30: import java.nio.ByteBuffer;
1:a552b30: import java.util.*;
1:a552b30: 
1:677230d: import org.apache.cassandra.config.ColumnDefinition;
1:cb5897f: import org.apache.cassandra.cql3.functions.Function;
1:677230d: import org.apache.cassandra.db.DecoratedKey;
1:4ed0060: import org.apache.cassandra.db.marshal.*;
1:677230d: import org.apache.cassandra.db.rows.CellPath;
1:a552b30: import org.apache.cassandra.exceptions.InvalidRequestException;
1:e0adc16: import org.apache.cassandra.transport.ProtocolVersion;
1:48f6446: import org.apache.cassandra.utils.ByteBufferUtil;
1:a552b30: 
1:677230d: import static org.apache.cassandra.cql3.Constants.UNSET_VALUE;
1:677230d: 
1:a552b30: /**
1:a552b30:  * Static helper methods and classes for user types.
1:a552b30:  */
1:a552b30: public abstract class UserTypes
1:a552b30: {
1:a552b30:     private UserTypes() {}
1:a552b30: 
1:a552b30:     public static ColumnSpecification fieldSpecOf(ColumnSpecification column, int field)
1:a552b30:     {
1:9b539f9:         UserType ut = (UserType)column.type;
1:db9ef0b:         return new ColumnSpecification(column.ksName,
1:db9ef0b:                                        column.cfName,
1:4ed0060:                                        new ColumnIdentifier(column.name + "." + ut.fieldName(field), true),
1:9b539f9:                                        ut.fieldType(field));
1:a552b30:     }
1:a552b30: 
1:5a4253b:     public static class Literal extends Term.Raw
1:a552b30:     {
1:4ed0060:         public final Map<FieldIdentifier, Term.Raw> entries;
1:a552b30: 
1:4ed0060:         public Literal(Map<FieldIdentifier, Term.Raw> entries)
1:a552b30:         {
1:a552b30:             this.entries = entries;
1:a552b30:         }
1:a552b30: 
1:d63d07b:         public Term prepare(String keyspace, ColumnSpecification receiver) throws InvalidRequestException
1:a552b30:         {
1:d63d07b:             validateAssignableTo(keyspace, receiver);
1:a552b30: 
1:a552b30:             UserType ut = (UserType)receiver.type;
1:a552b30:             boolean allTerminal = true;
1:a552b30:             List<Term> values = new ArrayList<>(entries.size());
1:8d87e0e:             int foundValues = 0;
1:0932ed6:             for (int i = 0; i < ut.size(); i++)
1:a552b30:             {
1:4ed0060:                 FieldIdentifier field = ut.fieldName(i);
1:ca7e9d5:                 Term.Raw raw = entries.get(field);
1:ca7e9d5:                 if (raw == null)
1:ca7e9d5:                     raw = Constants.NULL_LITERAL;
1:8d87e0e:                 else
1:8d87e0e:                     ++foundValues;
1:ca7e9d5:                 Term value = raw.prepare(keyspace, fieldSpecOf(receiver, i));
1:a552b30: 
1:a552b30:                 if (value instanceof Term.NonTerminal)
1:a552b30:                     allTerminal = false;
1:a552b30: 
1:a552b30:                 values.add(value);
1:a552b30:             }
1:8d87e0e:             if (foundValues != entries.size())
1:8d87e0e:             {
1:8d87e0e:                 // We had some field that are not part of the type
1:4ed0060:                 for (FieldIdentifier id : entries.keySet())
1:677230d:                 {
1:4ed0060:                     if (!ut.fieldNames().contains(id))
1:8d87e0e:                         throw new InvalidRequestException(String.format("Unknown field '%s' in value of user defined type %s", id, ut.getNameAsString()));
1:8d87e0e:                 }
1:677230d:             }
1:8d87e0e: 
1:a552b30:             DelayedValue value = new DelayedValue(((UserType)receiver.type), values);
1:9872b74:             return allTerminal ? value.bind(QueryOptions.DEFAULT) : value;
1:a552b30:         }
1:a552b30: 
1:d63d07b:         private void validateAssignableTo(String keyspace, ColumnSpecification receiver) throws InvalidRequestException
1:a552b30:         {
1:677230d:             if (!receiver.type.isUDT())
1:a552b30:                 throw new InvalidRequestException(String.format("Invalid user type literal for %s of type %s", receiver, receiver.type.asCQL3Type()));
1:a552b30: 
1:a552b30:             UserType ut = (UserType)receiver.type;
1:0932ed6:             for (int i = 0; i < ut.size(); i++)
1:a552b30:             {
1:4ed0060:                 FieldIdentifier field = ut.fieldName(i);
1:a552b30:                 Term.Raw value = entries.get(field);
1:a552b30:                 if (value == null)
1:ca7e9d5:                     continue;
1:a552b30: 
1:a552b30:                 ColumnSpecification fieldSpec = fieldSpecOf(receiver, i);
1:44fa12e:                 if (!value.testAssignment(keyspace, fieldSpec).isAssignable())
1:a552b30:                 {
1:677230d:                     throw new InvalidRequestException(String.format("Invalid user type literal for %s: field %s is not of type %s",
1:677230d:                             receiver, field, fieldSpec.type.asCQL3Type()));
1:a552b30:                 }
1:a552b30:             }
1:677230d:         }
1:a552b30: 
1:44fa12e:         public AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
1:677230d:         {
1:a552b30:             try
1:a552b30:             {
1:d63d07b:                 validateAssignableTo(keyspace, receiver);
1:44fa12e:                 return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
1:a552b30:             }
1:a552b30:             catch (InvalidRequestException e)
1:a552b30:             {
1:44fa12e:                 return AssignmentTestable.TestResult.NOT_ASSIGNABLE;
1:a552b30:             }
1:a552b30:         }
1:a552b30: 
1:4ed0060:         public AbstractType<?> getExactTypeIfKnown(String keyspace)
1:4ed0060:         {
1:4ed0060:             return null;
1:4ed0060:         }
1:4ed0060: 
1:5a4253b:         public String getText()
1:a552b30:         {
1:a552b30:             StringBuilder sb = new StringBuilder();
1:a552b30:             sb.append("{");
1:4ed0060:             Iterator<Map.Entry<FieldIdentifier, Term.Raw>> iter = entries.entrySet().iterator();
1:a552b30:             while (iter.hasNext())
1:a552b30:             {
1:4ed0060:                 Map.Entry<FieldIdentifier, Term.Raw> entry = iter.next();
1:5a4253b:                 sb.append(entry.getKey()).append(": ").append(entry.getValue().getText());
1:a552b30:                 if (iter.hasNext())
1:a552b30:                     sb.append(", ");
1:a552b30:             }
1:a552b30:             sb.append("}");
1:a552b30:             return sb.toString();
1:677230d:         }
1:677230d:     }
1:677230d: 
1:677230d:     public static class Value extends Term.MultiItemTerminal
1:677230d:     {
1:677230d:         private final UserType type;
1:677230d:         public final ByteBuffer[] elements;
1:677230d: 
1:677230d:         public Value(UserType type, ByteBuffer[] elements)
1:677230d:         {
1:677230d:             this.type = type;
1:677230d:             this.elements = elements;
1:677230d:         }
1:677230d: 
1:677230d:         public static Value fromSerialized(ByteBuffer bytes, UserType type)
1:677230d:         {
1:677230d:             ByteBuffer[] values = type.split(bytes);
1:677230d:             if (values.length > type.size())
1:677230d:             {
1:677230d:                 throw new InvalidRequestException(String.format(
1:677230d:                         "UDT value contained too many fields (expected %s, got %s)", type.size(), values.length));
1:677230d:             }
1:677230d: 
1:677230d:             return new Value(type, type.split(bytes));
1:677230d:         }
1:677230d: 
1:e0adc16:         public ByteBuffer get(ProtocolVersion protocolVersion)
1:677230d:         {
1:677230d:             return TupleType.buildValue(elements);
1:677230d:         }
1:677230d: 
1:677230d:         public boolean equals(UserType userType, Value v)
1:677230d:         {
1:677230d:             if (elements.length != v.elements.length)
1:a552b30:                 return false;
1:677230d: 
1:677230d:             for (int i = 0; i < elements.length; i++)
1:677230d:                 if (userType.fieldType(i).compare(elements[i], v.elements[i]) != 0)
2:677230d:                     return false;
1:677230d: 
1:a552b30:             return true;
1:a552b30:         }
1:a552b30: 
1:677230d:         public List<ByteBuffer> getElements()
1:677230d:         {
1:677230d:             return Arrays.asList(elements);
1:a552b30:         }
1:677230d:     }
1:677230d: 
1:a552b30:     public static class DelayedValue extends Term.NonTerminal
1:a552b30:     {
1:a552b30:         private final UserType type;
1:a552b30:         private final List<Term> values;
1:a552b30: 
1:a552b30:         public DelayedValue(UserType type, List<Term> values)
1:a552b30:         {
1:a552b30:             this.type = type;
1:a552b30:             this.values = values;
1:a552b30:         }
1:a552b30: 
1:89464ea:         public void addFunctionsTo(List<Function> functions)
1:677230d:         {
1:89464ea:             Terms.addFunctions(values, functions);
1:677230d:         }
1:677230d: 
1:a552b30:         public boolean containsBindMarker()
1:a552b30:         {
1:a552b30:             for (Term t : values)
1:a552b30:                 if (t.containsBindMarker())
1:a552b30:                     return true;
1:a552b30:             return false;
1:a552b30:         }
1:a552b30: 
1:a552b30:         public void collectMarkerSpecification(VariableSpecifications boundNames)
1:a552b30:         {
1:0932ed6:             for (int i = 0; i < type.size(); i++)
1:a552b30:                 values.get(i).collectMarkerSpecification(boundNames);
1:a552b30:         }
1:a552b30: 
1:9872b74:         private ByteBuffer[] bindInternal(QueryOptions options) throws InvalidRequestException
1:a552b30:         {
1:677230d:             if (values.size() > type.size())
1:677230d:             {
1:677230d:                 throw new InvalidRequestException(String.format(
1:677230d:                         "UDT value contained too many fields (expected %s, got %s)", type.size(), values.size()));
1:677230d:             }
1:9872b74: 
1:a552b30:             ByteBuffer[] buffers = new ByteBuffer[values.size()];
1:0932ed6:             for (int i = 0; i < type.size(); i++)
1:a552b30:             {
1:ca7e9d5:                 buffers[i] = values.get(i).bindAndGet(options);
1:677230d:                 // Since a frozen UDT value is always written in its entirety Cassandra can't preserve a pre-existing
1:677230d:                 // value by 'not setting' the new value. Reject the query.
1:677230d:                 if (!type.isMultiCell() && buffers[i] == ByteBufferUtil.UNSET_BYTE_BUFFER)
1:48f6446:                     throw new InvalidRequestException(String.format("Invalid unset value for field '%s' of user defined type %s", type.fieldNameAsString(i), type.getNameAsString()));
1:a552b30:             }
1:a552b30:             return buffers;
1:677230d:         }
2:677230d: 
1:677230d:         public Value bind(QueryOptions options) throws InvalidRequestException
1:677230d:         {
1:677230d:             return new Value(type, bindInternal(options));
1:cb5897f:         }
1:677230d: 
2:a552b30:         @Override
1:9872b74:         public ByteBuffer bindAndGet(QueryOptions options) throws InvalidRequestException
1:cb5897f:         {
1:db9ef0b:             return UserType.buildValue(bindInternal(options));
1:677230d:         }
1:677230d:     }
1:677230d: 
1:677230d:     public static class Marker extends AbstractMarker
1:677230d:     {
1:677230d:         protected Marker(int bindIndex, ColumnSpecification receiver)
1:677230d:         {
1:677230d:             super(bindIndex, receiver);
1:677230d:             assert receiver.type.isUDT();
1:677230d:         }
1:677230d: 
1:677230d:         public Terminal bind(QueryOptions options) throws InvalidRequestException
1:677230d:         {
1:677230d:             ByteBuffer value = options.getValues().get(bindIndex);
1:677230d:             if (value == null)
1:677230d:                 return null;
1:677230d:             if (value == ByteBufferUtil.UNSET_BYTE_BUFFER)
1:677230d:                 return UNSET_VALUE;
1:677230d:             return Value.fromSerialized(value, (UserType) receiver.type);
1:677230d:         }
1:677230d:     }
1:677230d: 
1:677230d:     public static class Setter extends Operation
1:677230d:     {
1:677230d:         public Setter(ColumnDefinition column, Term t)
1:677230d:         {
1:677230d:             super(column, t);
1:677230d:         }
1:677230d: 
1:677230d:         public void execute(DecoratedKey partitionKey, UpdateParameters params) throws InvalidRequestException
1:677230d:         {
1:677230d:             Term.Terminal value = t.bind(params.options);
1:677230d:             if (value == UNSET_VALUE)
1:677230d:                 return;
1:677230d: 
1:677230d:             Value userTypeValue = (Value) value;
1:677230d:             if (column.type.isMultiCell())
1:677230d:             {
1:677230d:                 // setting a whole UDT at once means we overwrite all cells, so delete existing cells
1:677230d:                 params.setComplexDeletionTimeForOverwrite(column);
1:677230d:                 if (value == null)
1:677230d:                     return;
1:677230d: 
1:4ed0060:                 Iterator<FieldIdentifier> fieldNameIter = userTypeValue.type.fieldNames().iterator();
1:677230d:                 for (ByteBuffer buffer : userTypeValue.elements)
1:677230d:                 {
1:4ed0060:                     assert fieldNameIter.hasNext();
1:4ed0060:                     FieldIdentifier fieldName = fieldNameIter.next();
1:a552b30:                     if (buffer == null)
1:677230d:                         continue;
1:a552b30: 
1:677230d:                     CellPath fieldPath = userTypeValue.type.cellPathForField(fieldName);
1:677230d:                     params.addCell(column, fieldPath, buffer);
1:a552b30:                 }
1:a552b30:             }
1:677230d:             else
1:a552b30:             {
1:677230d:                 // for frozen UDTs, we're overwriting the whole cell value
1:677230d:                 if (value == null)
1:677230d:                     params.addTombstone(column);
1:677230d:                 else
1:677230d:                     params.addCell(column, value.get(params.options.getProtocolVersion()));
1:a552b30:             }
1:a552b30:         }
1:a552b30:     }
1:a552b30: 
1:677230d:     public static class SetterByField extends Operation
1:a552b30:     {
1:4ed0060:         private final FieldIdentifier field;
1:a552b30: 
1:4ed0060:         public SetterByField(ColumnDefinition column, FieldIdentifier field, Term t)
1:677230d:         {
1:677230d:             super(column, t);
1:677230d:             this.field = field;
1:677230d:         }
1:677230d: 
1:677230d:         public void execute(DecoratedKey partitionKey, UpdateParameters params) throws InvalidRequestException
1:677230d:         {
1:677230d:             // we should not get here for frozen UDTs
1:677230d:             assert column.type.isMultiCell() : "Attempted to set an individual field on a frozen UDT";
1:677230d: 
1:677230d:             Term.Terminal value = t.bind(params.options);
1:677230d:             if (value == UNSET_VALUE)
1:677230d:                 return;
1:677230d: 
1:4ed0060:             CellPath fieldPath = ((UserType) column.type).cellPathForField(field);
1:677230d:             if (value == null)
1:677230d:                 params.addTombstone(column, fieldPath);
1:677230d:             else
1:677230d:                 params.addCell(column, fieldPath, value.get(params.options.getProtocolVersion()));
1:677230d:         }
1:677230d:     }
1:677230d: 
1:677230d:     public static class DeleterByField extends Operation
1:677230d:     {
1:4ed0060:         private final FieldIdentifier field;
1:677230d: 
1:4ed0060:         public DeleterByField(ColumnDefinition column, FieldIdentifier field)
1:677230d:         {
1:677230d:             super(column, null);
1:677230d:             this.field = field;
1:677230d:         }
1:677230d: 
1:677230d:         public void execute(DecoratedKey partitionKey, UpdateParameters params) throws InvalidRequestException
1:677230d:         {
1:677230d:             // we should not get here for frozen UDTs
1:677230d:             assert column.type.isMultiCell() : "Attempted to delete a single field from a frozen UDT";
1:677230d: 
1:4ed0060:             CellPath fieldPath = ((UserType) column.type).cellPathForField(field);
1:677230d:             params.addTombstone(column, fieldPath);
1:677230d:         }
1:677230d:     }
1:677230d: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:e0adc16
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.transport.ProtocolVersion;
/////////////////////////////////////////////////////////////////////////
1:         public ByteBuffer get(ProtocolVersion protocolVersion)
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:4ed0060
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.marshal.*;
/////////////////////////////////////////////////////////////////////////
1:                                        new ColumnIdentifier(column.name + "." + ut.fieldName(field), true),
1:         public final Map<FieldIdentifier, Term.Raw> entries;
1:         public Literal(Map<FieldIdentifier, Term.Raw> entries)
/////////////////////////////////////////////////////////////////////////
1:                 FieldIdentifier field = ut.fieldName(i);
/////////////////////////////////////////////////////////////////////////
1:                 for (FieldIdentifier id : entries.keySet())
1:                     if (!ut.fieldNames().contains(id))
/////////////////////////////////////////////////////////////////////////
1:                 FieldIdentifier field = ut.fieldName(i);
/////////////////////////////////////////////////////////////////////////
1:         public AbstractType<?> getExactTypeIfKnown(String keyspace)
1:         {
1:             return null;
1:         }
1: 
1:             Iterator<Map.Entry<FieldIdentifier, Term.Raw>> iter = entries.entrySet().iterator();
1:                 Map.Entry<FieldIdentifier, Term.Raw> entry = iter.next();
/////////////////////////////////////////////////////////////////////////
1:                 Iterator<FieldIdentifier> fieldNameIter = userTypeValue.type.fieldNames().iterator();
1:                     assert fieldNameIter.hasNext();
1:                     FieldIdentifier fieldName = fieldNameIter.next();
/////////////////////////////////////////////////////////////////////////
1:         private final FieldIdentifier field;
1:         public SetterByField(ColumnDefinition column, FieldIdentifier field, Term t)
/////////////////////////////////////////////////////////////////////////
1:             CellPath fieldPath = ((UserType) column.type).cellPathForField(field);
/////////////////////////////////////////////////////////////////////////
1:         private final FieldIdentifier field;
1:         public DeleterByField(ColumnDefinition column, FieldIdentifier field)
/////////////////////////////////////////////////////////////////////////
1:             CellPath fieldPath = ((UserType) column.type).cellPathForField(field);
commit:44fa12e
/////////////////////////////////////////////////////////////////////////
1:                 if (!value.testAssignment(keyspace, fieldSpec).isAssignable())
1:         public AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
1:                 return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
1:                 return AssignmentTestable.TestResult.NOT_ASSIGNABLE;
commit:a3d8375
/////////////////////////////////////////////////////////////////////////
0:                 if (version < 3 && type.fieldType(i).isCollection() && buffers[i] != null)
commit:8d87e0e
/////////////////////////////////////////////////////////////////////////
1:             int foundValues = 0;
1:                 else
1:                     ++foundValues;
/////////////////////////////////////////////////////////////////////////
1:             if (foundValues != entries.size())
1:             {
1:                 // We had some field that are not part of the type
0:                 for (ColumnIdentifier id : entries.keySet())
0:                     if (!ut.fieldNames().contains(id.bytes))
1:                         throw new InvalidRequestException(String.format("Unknown field '%s' in value of user defined type %s", id, ut.getNameAsString()));
1:             }
1: 
commit:0932ed6
/////////////////////////////////////////////////////////////////////////
0:                                        ((UserType)column.type).fieldType(field));
/////////////////////////////////////////////////////////////////////////
1:             for (int i = 0; i < ut.size(); i++)
0:                 ColumnIdentifier field = new ColumnIdentifier(ut.fieldName(i), UTF8Type.instance);
/////////////////////////////////////////////////////////////////////////
1:             for (int i = 0; i < ut.size(); i++)
0:                 ColumnIdentifier field = new ColumnIdentifier(ut.fieldName(i), UTF8Type.instance);
/////////////////////////////////////////////////////////////////////////
1:             for (int i = 0; i < type.size(); i++)
/////////////////////////////////////////////////////////////////////////
1:             for (int i = 0; i < type.size(); i++)
commit:ca7e9d5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 Term.Raw raw = entries.get(field);
1:                 if (raw == null)
1:                     raw = Constants.NULL_LITERAL;
1:                 Term value = raw.prepare(keyspace, fieldSpecOf(receiver, i));
/////////////////////////////////////////////////////////////////////////
1:                     continue;
/////////////////////////////////////////////////////////////////////////
1:                 buffers[i] = values.get(i).bindAndGet(options);
commit:465a09c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:db9ef0b
/////////////////////////////////////////////////////////////////////////
1:         return new ColumnSpecification(column.ksName,
1:                                        column.cfName,
0:                                        new ColumnIdentifier(column.name + "." + field, true),
0:                                        ((UserType)column.type).fieldTypes.get(field));
/////////////////////////////////////////////////////////////////////////
0:             for (int i = 0; i < ut.fieldTypes.size(); i++)
0:                 ColumnIdentifier field = new ColumnIdentifier(ut.fieldNames.get(i), UTF8Type.instance);
/////////////////////////////////////////////////////////////////////////
0:             for (int i = 0; i < ut.fieldTypes.size(); i++)
0:                 ColumnIdentifier field = new ColumnIdentifier(ut.fieldNames.get(i), UTF8Type.instance);
/////////////////////////////////////////////////////////////////////////
0:             for (int i = 0; i < type.fieldTypes.size(); i++)
/////////////////////////////////////////////////////////////////////////
0:             for (int i = 0; i < type.fieldTypes.size(); i++)
0:                                                                     UTF8Type.instance.getString(type.fieldNames.get(i)),
/////////////////////////////////////////////////////////////////////////
1:             return UserType.buildValue(bindInternal(options));
commit:9872b74
/////////////////////////////////////////////////////////////////////////
1:             return allTerminal ? value.bind(QueryOptions.DEFAULT) : value;
/////////////////////////////////////////////////////////////////////////
1:         private ByteBuffer[] bindInternal(QueryOptions options) throws InvalidRequestException
0:             // Inside UDT values, we must force the serialization of collections whatever the protocol version is in
0:             // use since we're going to store directly that serialized value.
0:             options = options.withProtocolVersion(3);
1: 
0:                 ByteBuffer buffer = values.get(i).bindAndGet(options);
/////////////////////////////////////////////////////////////////////////
0:         public Constants.Value bind(QueryOptions options) throws InvalidRequestException
0:             return new Constants.Value(bindAndGet(options));
1:         public ByteBuffer bindAndGet(QueryOptions options) throws InvalidRequestException
0:             return CompositeType.build(bindInternal(options));
commit:d63d07b
/////////////////////////////////////////////////////////////////////////
1:         public Term prepare(String keyspace, ColumnSpecification receiver) throws InvalidRequestException
1:             validateAssignableTo(keyspace, receiver);
/////////////////////////////////////////////////////////////////////////
0:                 Term value = entries.get(field).prepare(keyspace, fieldSpecOf(receiver, i));
/////////////////////////////////////////////////////////////////////////
1:         private void validateAssignableTo(String keyspace, ColumnSpecification receiver) throws InvalidRequestException
/////////////////////////////////////////////////////////////////////////
0:                 if (!value.isAssignableTo(keyspace, fieldSpec))
0:         public boolean isAssignableTo(String keyspace, ColumnSpecification receiver)
1:                 validateAssignableTo(keyspace, receiver);
commit:a552b30
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.cql3;
1: 
1: import java.nio.ByteBuffer;
1: import java.util.*;
1: 
0: import org.apache.cassandra.db.marshal.CompositeType;
0: import org.apache.cassandra.db.marshal.UserType;
0: import org.apache.cassandra.db.marshal.UTF8Type;
1: import org.apache.cassandra.exceptions.InvalidRequestException;
0: import org.apache.cassandra.utils.FBUtilities;
1: 
1: /**
1:  * Static helper methods and classes for user types.
1:  */
1: public abstract class UserTypes
1: {
1:     private UserTypes() {}
1: 
1:     public static ColumnSpecification fieldSpecOf(ColumnSpecification column, int field)
1:     {
0:         return new ColumnSpecification(column.ksName, column.cfName, new ColumnIdentifier(column.name + "." + field, true), ((UserType)column.type).types.get(field));
1:     }
1: 
0:     public static class Literal implements Term.Raw
1:     {
0:         public final Map<ColumnIdentifier, Term.Raw> entries;
1: 
0:         public Literal(Map<ColumnIdentifier, Term.Raw> entries)
1:         {
1:             this.entries = entries;
1:         }
1: 
0:         public Term prepare(ColumnSpecification receiver) throws InvalidRequestException
1:         {
0:             validateAssignableTo(receiver);
1: 
1:             UserType ut = (UserType)receiver.type;
1:             boolean allTerminal = true;
1:             List<Term> values = new ArrayList<>(entries.size());
0:             for (int i = 0; i < ut.types.size(); i++)
1:             {
0:                 ColumnIdentifier field = new ColumnIdentifier(ut.columnNames.get(i), UTF8Type.instance);
0:                 Term value = entries.get(field).prepare(fieldSpecOf(receiver, i));
1: 
1:                 if (value instanceof Term.NonTerminal)
1:                     allTerminal = false;
1: 
1:                 values.add(value);
1:             }
1:             DelayedValue value = new DelayedValue(((UserType)receiver.type), values);
0:             return allTerminal ? value.bind(Collections.<ByteBuffer>emptyList()) : value;
1:         }
1: 
0:         private void validateAssignableTo(ColumnSpecification receiver) throws InvalidRequestException
1:         {
0:             if (!(receiver.type instanceof UserType))
1:                 throw new InvalidRequestException(String.format("Invalid user type literal for %s of type %s", receiver, receiver.type.asCQL3Type()));
1: 
1:             UserType ut = (UserType)receiver.type;
0:             for (int i = 0; i < ut.types.size(); i++)
1:             {
0:                 ColumnIdentifier field = new ColumnIdentifier(ut.columnNames.get(i), UTF8Type.instance);
1:                 Term.Raw value = entries.get(field);
1:                 if (value == null)
0:                     throw new InvalidRequestException(String.format("Invalid user type literal for %s: missing field %s", receiver, field));
1: 
1:                 ColumnSpecification fieldSpec = fieldSpecOf(receiver, i);
0:                 if (!value.isAssignableTo(fieldSpec))
0:                     throw new InvalidRequestException(String.format("Invalid user type literal for %s: field %s is not of type %s", receiver, field, fieldSpec.type.asCQL3Type()));
1:             }
1:         }
1: 
0:         public boolean isAssignableTo(ColumnSpecification receiver)
1:         {
1:             try
1:             {
0:                 validateAssignableTo(receiver);
1:                 return true;
1:             }
1:             catch (InvalidRequestException e)
1:             {
1:                 return false;
1:             }
1:         }
1: 
1:         @Override
0:         public String toString()
1:         {
1:             StringBuilder sb = new StringBuilder();
1:             sb.append("{");
0:             Iterator<Map.Entry<ColumnIdentifier, Term.Raw>> iter = entries.entrySet().iterator();
1:             while (iter.hasNext())
1:             {
0:                 Map.Entry<ColumnIdentifier, Term.Raw> entry = iter.next();
0:                 sb.append(entry.getKey()).append(":").append(entry.getValue());
1:                 if (iter.hasNext())
1:                     sb.append(", ");
1:             }
1:             sb.append("}");
1:             return sb.toString();
1:         }
1:     }
1: 
0:     // Same purpose than Lists.DelayedValue, except we do handle bind marker in that case
1:     public static class DelayedValue extends Term.NonTerminal
1:     {
1:         private final UserType type;
1:         private final List<Term> values;
1: 
1:         public DelayedValue(UserType type, List<Term> values)
1:         {
1:             this.type = type;
1:             this.values = values;
1:         }
1: 
1:         public boolean containsBindMarker()
1:         {
1:             for (Term t : values)
1:                 if (t.containsBindMarker())
1:                     return true;
1:             return false;
1:         }
1: 
1:         public void collectMarkerSpecification(VariableSpecifications boundNames)
1:         {
0:             for (int i = 0; i < type.types.size(); i++)
1:                 values.get(i).collectMarkerSpecification(boundNames);
1:         }
1: 
0:         private ByteBuffer[] bindInternal(List<ByteBuffer> variables) throws InvalidRequestException
1:         {
1:             ByteBuffer[] buffers = new ByteBuffer[values.size()];
0:             for (int i = 0; i < type.types.size(); i++)
1:             {
0:                 ByteBuffer buffer = values.get(i).bindAndGet(variables);
1:                 if (buffer == null)
0:                     throw new InvalidRequestException("null is not supported inside user type literals");
0:                 if (buffer.remaining() > FBUtilities.MAX_UNSIGNED_SHORT)
0:                     throw new InvalidRequestException(String.format("Value for field %s is too long. User type fields are limited to %d bytes but %d bytes provided",
0:                                                                     UTF8Type.instance.getString(type.columnNames.get(i)),
0:                                                                     FBUtilities.MAX_UNSIGNED_SHORT,
0:                                                                     buffer.remaining()));
1: 
0:                 buffers[i] = buffer;
1:             }
1:             return buffers;
1:         }
1: 
0:         public Constants.Value bind(List<ByteBuffer> variables) throws InvalidRequestException
1:         {
0:             return new Constants.Value(bindAndGet(variables));
1:         }
1: 
1:         @Override
0:         public ByteBuffer bindAndGet(List<ByteBuffer> variables) throws InvalidRequestException
1:         {
0:             return CompositeType.build(bindInternal(variables));
1:         }
1:     }
1: }
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:4edd9ed
commit:89464ea
/////////////////////////////////////////////////////////////////////////
1:         public void addFunctionsTo(List<Function> functions)
1:             Terms.addFunctions(values, functions);
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:677230d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.ColumnDefinition;
1: import org.apache.cassandra.db.DecoratedKey;
0: import org.apache.cassandra.db.marshal.TupleType;
1: import org.apache.cassandra.db.rows.CellPath;
1: import static org.apache.cassandra.cql3.Constants.UNSET_VALUE;
1: 
/////////////////////////////////////////////////////////////////////////
1:                 {
1:                 }
/////////////////////////////////////////////////////////////////////////
1:             if (!receiver.type.isUDT())
/////////////////////////////////////////////////////////////////////////
1:                 {
1:                     throw new InvalidRequestException(String.format("Invalid user type literal for %s: field %s is not of type %s",
1:                             receiver, field, fieldSpec.type.asCQL3Type()));
1:                 }
/////////////////////////////////////////////////////////////////////////
1:     public static class Value extends Term.MultiItemTerminal
1:     {
1:         private final UserType type;
1:         public final ByteBuffer[] elements;
1: 
1:         public Value(UserType type, ByteBuffer[] elements)
1:         {
1:             this.type = type;
1:             this.elements = elements;
1:         }
1: 
1:         public static Value fromSerialized(ByteBuffer bytes, UserType type)
1:         {
1:             ByteBuffer[] values = type.split(bytes);
1:             if (values.length > type.size())
1:             {
1:                 throw new InvalidRequestException(String.format(
1:                         "UDT value contained too many fields (expected %s, got %s)", type.size(), values.length));
1:             }
1: 
1:             return new Value(type, type.split(bytes));
1:         }
1: 
0:         public ByteBuffer get(int protocolVersion)
1:         {
1:             return TupleType.buildValue(elements);
1:         }
1: 
1:         public boolean equals(UserType userType, Value v)
1:         {
1:             if (elements.length != v.elements.length)
1:                 return false;
1: 
1:             for (int i = 0; i < elements.length; i++)
1:                 if (userType.fieldType(i).compare(elements[i], v.elements[i]) != 0)
1:                     return false;
1: 
0:             return true;
1:         }
1: 
1:         public List<ByteBuffer> getElements()
1:         {
1:             return Arrays.asList(elements);
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             if (values.size() > type.size())
1:             {
1:                 throw new InvalidRequestException(String.format(
1:                         "UDT value contained too many fields (expected %s, got %s)", type.size(), values.size()));
1:             }
1: 
1:                 // Since a frozen UDT value is always written in its entirety Cassandra can't preserve a pre-existing
1:                 // value by 'not setting' the new value. Reject the query.
1:                 if (!type.isMultiCell() && buffers[i] == ByteBufferUtil.UNSET_BYTE_BUFFER)
1:         public Value bind(QueryOptions options) throws InvalidRequestException
1:             return new Value(type, bindInternal(options));
/////////////////////////////////////////////////////////////////////////
1: 
1:     public static class Marker extends AbstractMarker
1:     {
1:         protected Marker(int bindIndex, ColumnSpecification receiver)
1:         {
1:             super(bindIndex, receiver);
1:             assert receiver.type.isUDT();
1:         }
1: 
1:         public Terminal bind(QueryOptions options) throws InvalidRequestException
1:         {
1:             ByteBuffer value = options.getValues().get(bindIndex);
1:             if (value == null)
1:                 return null;
1:             if (value == ByteBufferUtil.UNSET_BYTE_BUFFER)
1:                 return UNSET_VALUE;
1:             return Value.fromSerialized(value, (UserType) receiver.type);
1:         }
1:     }
1: 
1:     public static class Setter extends Operation
1:     {
1:         public Setter(ColumnDefinition column, Term t)
1:         {
1:             super(column, t);
1:         }
1: 
1:         public void execute(DecoratedKey partitionKey, UpdateParameters params) throws InvalidRequestException
1:         {
1:             Term.Terminal value = t.bind(params.options);
1:             if (value == UNSET_VALUE)
1:                 return;
1: 
1:             Value userTypeValue = (Value) value;
1:             if (column.type.isMultiCell())
1:             {
1:                 // setting a whole UDT at once means we overwrite all cells, so delete existing cells
1:                 params.setComplexDeletionTimeForOverwrite(column);
1:                 if (value == null)
1:                     return;
1: 
0:                 Iterator<ByteBuffer> fieldNameIter = userTypeValue.type.fieldNames().iterator();
1:                 for (ByteBuffer buffer : userTypeValue.elements)
1:                 {
0:                     ByteBuffer fieldName = fieldNameIter.next();
0:                     if (buffer == null)
1:                         continue;
1: 
1:                     CellPath fieldPath = userTypeValue.type.cellPathForField(fieldName);
1:                     params.addCell(column, fieldPath, buffer);
1:                 }
1:             }
1:             else
1:             {
1:                 // for frozen UDTs, we're overwriting the whole cell value
1:                 if (value == null)
1:                     params.addTombstone(column);
1:                 else
1:                     params.addCell(column, value.get(params.options.getProtocolVersion()));
1:             }
1:         }
1:     }
1: 
1:     public static class SetterByField extends Operation
1:     {
0:         private final ColumnIdentifier field;
1: 
0:         public SetterByField(ColumnDefinition column, ColumnIdentifier field, Term t)
1:         {
1:             super(column, t);
1:             this.field = field;
1:         }
1: 
1:         public void execute(DecoratedKey partitionKey, UpdateParameters params) throws InvalidRequestException
1:         {
1:             // we should not get here for frozen UDTs
1:             assert column.type.isMultiCell() : "Attempted to set an individual field on a frozen UDT";
1: 
1:             Term.Terminal value = t.bind(params.options);
1:             if (value == UNSET_VALUE)
1:                 return;
1: 
0:             CellPath fieldPath = ((UserType) column.type).cellPathForField(field.bytes);
1:             if (value == null)
1:                 params.addTombstone(column, fieldPath);
1:             else
1:                 params.addCell(column, fieldPath, value.get(params.options.getProtocolVersion()));
1:         }
1:     }
1: 
1:     public static class DeleterByField extends Operation
1:     {
0:         private final ColumnIdentifier field;
1: 
0:         public DeleterByField(ColumnDefinition column, ColumnIdentifier field)
1:         {
1:             super(column, null);
1:             this.field = field;
1:         }
1: 
1:         public void execute(DecoratedKey partitionKey, UpdateParameters params) throws InvalidRequestException
1:         {
1:             // we should not get here for frozen UDTs
1:             assert column.type.isMultiCell() : "Attempted to delete a single field from a frozen UDT";
1: 
0:             CellPath fieldPath = ((UserType) column.type).cellPathForField(field.bytes);
1:             params.addTombstone(column, fieldPath);
1:         }
1:     }
commit:5a4253b
/////////////////////////////////////////////////////////////////////////
1:     public static class Literal extends Term.Raw
/////////////////////////////////////////////////////////////////////////
1:         public String getText()
/////////////////////////////////////////////////////////////////////////
1:                 sb.append(entry.getKey()).append(": ").append(entry.getValue().getText());
commit:fb4356a
commit:ee55f36
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.transport.Server;
/////////////////////////////////////////////////////////////////////////
0:                 if (version < Server.VERSION_3 && type.fieldType(i).isCollection() && buffers[i] != null)
author:blerer
-------------------------------------------------------------------------------
commit:8439e74
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Sam Tunnicliffe
-------------------------------------------------------------------------------
commit:d9836e0
/////////////////////////////////////////////////////////////////////////
commit:cb5897f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.cql3.functions.Function;
0: import org.apache.cassandra.db.marshal.UserType;
/////////////////////////////////////////////////////////////////////////
0:         public Iterable<Function> getFunctions()
1:         {
0:             return Terms.getFunctions(values);
1:         }
0: 
author:Oded Peer
-------------------------------------------------------------------------------
commit:48f6446
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.ByteBufferUtil;
/////////////////////////////////////////////////////////////////////////
0:                 // Since A UDT value is always written in its entirety Cassandra can't preserve a pre-existing value by 'not setting' the new value. Reject the query.
0:                 if (buffers[i] == ByteBufferUtil.UNSET_BYTE_BUFFER)
1:                     throw new InvalidRequestException(String.format("Invalid unset value for field '%s' of user defined type %s", type.fieldNameAsString(i), type.getNameAsString()));
author:Robert Stupp
-------------------------------------------------------------------------------
commit:b4d7f3b
/////////////////////////////////////////////////////////////////////////
0:         public boolean usesFunction(String ksName, String functionName)
0:         {
0:             if (values != null)
0:                 for (Term value : values)
0:                     if (value != null && value.usesFunction(ksName, functionName))
0:                         return true;
0:             return false;
0:         }
0: 
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:9b539f9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.marshal.CollectionType;
/////////////////////////////////////////////////////////////////////////
1:         UserType ut = (UserType)column.type;
0:                                        new ColumnIdentifier(column.name + "." + UTF8Type.instance.compose(ut.fieldName(field)), true),
1:                                        ut.fieldType(field));
/////////////////////////////////////////////////////////////////////////
0:             int version = options.getProtocolVersion();
0:             {
0:                 // Inside UDT values, we must force the serialization of collections to v3 whatever protocol
0:                 // version is in use since we're going to store directly that serialized value.
0:                 if (version < 3 && type.fieldType(i).isCollection())
0:                     buffers[i] = ((CollectionType)type.fieldType(i)).getSerializer().reserializeToV3(buffers[i]);
0:             }
============================================================================