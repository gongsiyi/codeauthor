1:56e0ad1: package org.apache.cassandra.hadoop.cql3;
1:56e0ad1: /*
1:56e0ad1: *
1:56e0ad1: * Licensed to the Apache Software Foundation (ASF) under one
1:56e0ad1: * or more contributor license agreements.  See the NOTICE file
1:56e0ad1: * distributed with this work for additional information
1:56e0ad1: * regarding copyright ownership.  The ASF licenses this file
1:56e0ad1: * to you under the Apache License, Version 2.0 (the
1:56e0ad1: * "License"); you may not use this file except in compliance
1:56e0ad1: * with the License.  You may obtain a copy of the License at
1:56e0ad1: *
1:56e0ad1: *   http://www.apache.org/licenses/LICENSE-2.0
1:56e0ad1: *
1:56e0ad1: * Unless required by applicable law or agreed to in writing,
1:56e0ad1: * software distributed under the License is distributed on an
1:56e0ad1: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:56e0ad1: * KIND, either express or implied.  See the License for the
1:56e0ad1: * specific language governing permissions and limitations
1:56e0ad1: * under the License.
1:56e0ad1: *
1:56e0ad1: */
1:d7cb970: import java.io.FileInputStream;
1:d7cb970: import java.io.IOException;
1:d7cb970: import java.security.KeyManagementException;
1:d7cb970: import java.security.KeyStore;
1:d7cb970: import java.security.KeyStoreException;
1:d7cb970: import java.security.NoSuchAlgorithmException;
1:d7cb970: import java.security.SecureRandom;
1:d7cb970: import java.security.UnrecoverableKeyException;
1:d7cb970: import java.security.cert.CertificateException;
1:c1d2b86: import java.util.Arrays;
1:19b4b63: 
1:d7cb970: import javax.net.ssl.KeyManagerFactory;
1:d7cb970: import javax.net.ssl.SSLContext;
1:d7cb970: import javax.net.ssl.TrustManagerFactory;
1:d7cb970: 
1:d7cb970: import com.google.common.base.Optional;
1:569177f: import org.apache.commons.lang3.StringUtils;
1:d7cb970: 
1:d7cb970: import com.datastax.driver.core.AuthProvider;
1:d7cb970: import com.datastax.driver.core.Cluster;
1:d7cb970: import com.datastax.driver.core.HostDistance;
1:f340362: import com.datastax.driver.core.JdkSSLOptions;
1:f698cc2: import com.datastax.driver.core.PlainTextAuthProvider;
1:16b0288: import com.datastax.driver.core.ProtocolVersion;
1:d7cb970: import com.datastax.driver.core.policies.LoadBalancingPolicy;
1:d7cb970: import com.datastax.driver.core.PoolingOptions;
1:d7cb970: import com.datastax.driver.core.ProtocolOptions;
1:d7cb970: import com.datastax.driver.core.QueryOptions;
1:d7cb970: import com.datastax.driver.core.SSLOptions;
1:d7cb970: import com.datastax.driver.core.SocketOptions;
1:d7cb970: import org.apache.cassandra.hadoop.ConfigHelper;
1:f698cc2: import org.apache.hadoop.conf.Configuration;
1:d7cb970: 
5:b0841d8: 
1:a004779: public class CqlConfigHelper
69:3b708f9: {
1:52df514:     private static final String INPUT_CQL_COLUMNS_CONFIG = "cassandra.input.columnfamily.columns";
1:56e0ad1:     private static final String INPUT_CQL_PAGE_ROW_SIZE_CONFIG = "cassandra.input.page.row.size";
1:56e0ad1:     private static final String INPUT_CQL_WHERE_CLAUSE_CONFIG = "cassandra.input.where.clause";
1:d7cb970:     private static final String INPUT_CQL = "cassandra.input.cql";
1:d7cb970: 
1:569177f:     private static final String USERNAME = "cassandra.username";
1:569177f:     private static final String PASSWORD = "cassandra.password";
1:d7cb970: 
1:d7cb970:     private static final String INPUT_NATIVE_PORT = "cassandra.input.native.port";
1:d7cb970:     private static final String INPUT_NATIVE_CORE_CONNECTIONS_PER_HOST = "cassandra.input.native.core.connections.per.host";
1:d7cb970:     private static final String INPUT_NATIVE_MAX_CONNECTIONS_PER_HOST = "cassandra.input.native.max.connections.per.host";
1:d7cb970:     private static final String INPUT_NATIVE_MAX_SIMULT_REQ_PER_CONNECTION = "cassandra.input.native.max.simult.reqs.per.connection";
1:d7cb970:     private static final String INPUT_NATIVE_CONNECTION_TIMEOUT = "cassandra.input.native.connection.timeout";
1:d7cb970:     private static final String INPUT_NATIVE_READ_CONNECTION_TIMEOUT = "cassandra.input.native.read.connection.timeout";
1:d7cb970:     private static final String INPUT_NATIVE_RECEIVE_BUFFER_SIZE = "cassandra.input.native.receive.buffer.size";
1:d7cb970:     private static final String INPUT_NATIVE_SEND_BUFFER_SIZE = "cassandra.input.native.send.buffer.size";
1:d7cb970:     private static final String INPUT_NATIVE_SOLINGER = "cassandra.input.native.solinger";
1:d7cb970:     private static final String INPUT_NATIVE_TCP_NODELAY = "cassandra.input.native.tcp.nodelay";
1:d7cb970:     private static final String INPUT_NATIVE_REUSE_ADDRESS = "cassandra.input.native.reuse.address";
1:d7cb970:     private static final String INPUT_NATIVE_KEEP_ALIVE = "cassandra.input.native.keep.alive";
1:d7cb970:     private static final String INPUT_NATIVE_AUTH_PROVIDER = "cassandra.input.native.auth.provider";
1:d7cb970:     private static final String INPUT_NATIVE_SSL_TRUST_STORE_PATH = "cassandra.input.native.ssl.trust.store.path";
1:d7cb970:     private static final String INPUT_NATIVE_SSL_KEY_STORE_PATH = "cassandra.input.native.ssl.key.store.path";
1:d7cb970:     private static final String INPUT_NATIVE_SSL_TRUST_STORE_PASSWARD = "cassandra.input.native.ssl.trust.store.password";
1:d7cb970:     private static final String INPUT_NATIVE_SSL_KEY_STORE_PASSWARD = "cassandra.input.native.ssl.key.store.password";
1:d7cb970:     private static final String INPUT_NATIVE_SSL_CIPHER_SUITES = "cassandra.input.native.ssl.cipher.suites";
1:d7cb970: 
1:1cb426b:     private static final String INPUT_NATIVE_PROTOCOL_VERSION = "cassandra.input.native.protocol.version";
1:d7cb970: 
1:56e0ad1:     private static final String OUTPUT_CQL = "cassandra.output.cql";
1:f698cc2:     private static final String OUTPUT_NATIVE_PORT = "cassandra.output.native.port";
1:d7cb970:     
1:56e0ad1:     /**
1:56e0ad1:      * Set the CQL columns for the input of this job.
1:56e0ad1:      *
1:56e0ad1:      * @param conf Job configuration you are about to run
1:56e0ad1:      * @param columns
1:56e0ad1:      */
1:56e0ad1:     public static void setInputColumns(Configuration conf, String columns)
1:d7cb970:     {
1:56e0ad1:         if (columns == null || columns.isEmpty())
2:56e0ad1:             return;
1:d7cb970:         
1:56e0ad1:         conf.set(INPUT_CQL_COLUMNS_CONFIG, columns);
65:3b708f9:     }
1:4b6d6eb:     
1:56e0ad1:     /**
1:56e0ad1:      * Set the CQL query Limit for the input of this job.
1:56e0ad1:      *
1:56e0ad1:      * @param conf Job configuration you are about to run
1:56e0ad1:      * @param cqlPageRowSize
1:56e0ad1:      */
1:56e0ad1:     public static void setInputCQLPageRowSize(Configuration conf, String cqlPageRowSize)
1:4b6d6eb:     {
1:56e0ad1:         if (cqlPageRowSize == null)
1:9f1e957:         {
1:56e0ad1:             throw new UnsupportedOperationException("cql page row size may not be null");
1:4b6d6eb:         }
1:9f1e957: 
1:56e0ad1:         conf.set(INPUT_CQL_PAGE_ROW_SIZE_CONFIG, cqlPageRowSize);
1:9f1e957:     }
1:d7cb970: 
1:56e0ad1:     /**
1:56e0ad1:      * Set the CQL user defined where clauses for the input of this job.
1:56e0ad1:      *
1:56e0ad1:      * @param conf Job configuration you are about to run
1:56e0ad1:      * @param clauses
1:56e0ad1:      */
1:56e0ad1:     public static void setInputWhereClauses(Configuration conf, String clauses)
1:d7cb970:     {
1:56e0ad1:         if (clauses == null || clauses.isEmpty())
1:56e0ad1:             return;
1:d7cb970:         
1:56e0ad1:         conf.set(INPUT_CQL_WHERE_CLAUSE_CONFIG, clauses);
1:3b708f9:     }
1:d7cb970:   
1:56e0ad1:     /**
1:56e0ad1:      * Set the CQL prepared statement for the output of this job.
1:56e0ad1:      *
1:56e0ad1:      * @param conf Job configuration you are about to run
1:56e0ad1:      * @param cql
1:56e0ad1:      */
1:56e0ad1:     public static void setOutputCql(Configuration conf, String cql)
1:d7cb970:     {
1:3b708f9:         if (cql == null || cql.isEmpty())
1:3b708f9:             return;
1:d7cb970:         
1:56e0ad1:         conf.set(OUTPUT_CQL, cql);
1:3b708f9:     }
1:d7cb970: 
1:d7cb970:     public static void setInputCql(Configuration conf, String cql)
1:d7cb970:     {
1:d7cb970:         if (cql == null || cql.isEmpty())
1:d7cb970:             return;
1:d7cb970: 
1:d7cb970:         conf.set(INPUT_CQL, cql);
1:d7cb970:     }
1:d7cb970: 
1:569177f:     public static void setUserNameAndPassword(Configuration conf, String username, String password)
1:d7cb970:     {
1:569177f:         if (StringUtils.isNotBlank(username))
1:d7cb970:         {
1:569177f:             conf.set(INPUT_NATIVE_AUTH_PROVIDER, PlainTextAuthProvider.class.getName());
1:569177f:             conf.set(USERNAME, username);
1:569177f:             conf.set(PASSWORD, password);
1:d7cb970:         }
1:3b708f9:     }
1:d7cb970: 
1:d7cb970:     public static Optional<Integer> getInputCoreConnections(Configuration conf)
1:d7cb970:     {
1:d7cb970:         return getIntSetting(INPUT_NATIVE_CORE_CONNECTIONS_PER_HOST, conf);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static Optional<Integer> getInputMaxConnections(Configuration conf)
1:d7cb970:     {
1:d7cb970:         return getIntSetting(INPUT_NATIVE_MAX_CONNECTIONS_PER_HOST, conf);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static int getInputNativePort(Configuration conf)
1:d7cb970:     {
1:d7cb970:         return Integer.parseInt(conf.get(INPUT_NATIVE_PORT, "9042"));
1:d7cb970:     }
1:d7cb970: 
1:f698cc2:     public static int getOutputNativePort(Configuration conf)
1:d7cb970:     {
1:f698cc2:         return Integer.parseInt(conf.get(OUTPUT_NATIVE_PORT, "9042"));
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static Optional<Integer> getInputMaxSimultReqPerConnections(Configuration conf)
1:d7cb970:     {
1:d7cb970:         return getIntSetting(INPUT_NATIVE_MAX_SIMULT_REQ_PER_CONNECTION, conf);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static Optional<Integer> getInputNativeConnectionTimeout(Configuration conf)
1:d7cb970:     {
1:d7cb970:         return getIntSetting(INPUT_NATIVE_CONNECTION_TIMEOUT, conf);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static Optional<Integer> getInputNativeReadConnectionTimeout(Configuration conf)
1:d7cb970:     {
1:d7cb970:         return getIntSetting(INPUT_NATIVE_READ_CONNECTION_TIMEOUT, conf);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static Optional<Integer> getInputNativeReceiveBufferSize(Configuration conf)
1:d7cb970:     {
1:d7cb970:         return getIntSetting(INPUT_NATIVE_RECEIVE_BUFFER_SIZE, conf);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static Optional<Integer> getInputNativeSendBufferSize(Configuration conf)
1:d7cb970:     {
1:d7cb970:         return getIntSetting(INPUT_NATIVE_SEND_BUFFER_SIZE, conf);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static Optional<Integer> getInputNativeSolinger(Configuration conf)
1:d7cb970:     {
1:d7cb970:         return getIntSetting(INPUT_NATIVE_SOLINGER, conf);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static Optional<Boolean> getInputNativeTcpNodelay(Configuration conf)
1:d7cb970:     {
1:d7cb970:         return getBooleanSetting(INPUT_NATIVE_TCP_NODELAY, conf);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static Optional<Boolean> getInputNativeReuseAddress(Configuration conf)
1:d7cb970:     {
1:d7cb970:         return getBooleanSetting(INPUT_NATIVE_REUSE_ADDRESS, conf);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static Optional<String> getInputNativeAuthProvider(Configuration conf)
1:d7cb970:     {
1:d7cb970:         return getStringSetting(INPUT_NATIVE_AUTH_PROVIDER, conf);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static Optional<String> getInputNativeSSLTruststorePath(Configuration conf)
1:d7cb970:     {
1:d7cb970:         return getStringSetting(INPUT_NATIVE_SSL_TRUST_STORE_PATH, conf);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static Optional<String> getInputNativeSSLKeystorePath(Configuration conf)
1:d7cb970:     {
1:d7cb970:         return getStringSetting(INPUT_NATIVE_SSL_KEY_STORE_PATH, conf);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static Optional<String> getInputNativeSSLKeystorePassword(Configuration conf)
1:d7cb970:     {
1:d7cb970:         return getStringSetting(INPUT_NATIVE_SSL_KEY_STORE_PASSWARD, conf);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static Optional<String> getInputNativeSSLTruststorePassword(Configuration conf)
1:d7cb970:     {
1:d7cb970:         return getStringSetting(INPUT_NATIVE_SSL_TRUST_STORE_PASSWARD, conf);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static Optional<String> getInputNativeSSLCipherSuites(Configuration conf)
1:d7cb970:     {
1:d7cb970:         return getStringSetting(INPUT_NATIVE_SSL_CIPHER_SUITES, conf);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static Optional<Boolean> getInputNativeKeepAlive(Configuration conf)
1:d7cb970:     {
1:d7cb970:         return getBooleanSetting(INPUT_NATIVE_KEEP_ALIVE, conf);
1:d7cb970:     }
1:d7cb970: 
1:56e0ad1:     public static String getInputcolumns(Configuration conf)
1:d7cb970:     {
1:56e0ad1:         return conf.get(INPUT_CQL_COLUMNS_CONFIG);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static Optional<Integer> getInputPageRowSize(Configuration conf)
1:d7cb970:     {
1:d7cb970:         return getIntSetting(INPUT_CQL_PAGE_ROW_SIZE_CONFIG, conf);
1:d7cb970:     }
1:d7cb970: 
1:56e0ad1:     public static String getInputWhereClauses(Configuration conf)
1:d7cb970:     {
1:56e0ad1:         return conf.get(INPUT_CQL_WHERE_CLAUSE_CONFIG);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static String getInputCql(Configuration conf)
1:d7cb970:     {
1:d7cb970:         return conf.get(INPUT_CQL);
1:d7cb970:     }
1:d7cb970: 
1:56e0ad1:     public static String getOutputCql(Configuration conf)
1:d7cb970:     {
1:56e0ad1:         return conf.get(OUTPUT_CQL);
1:d7cb970:     }
1:d7cb970: 
1:68d2526:     private static Optional<Integer> getProtocolVersion(Configuration conf) 
1:68d2526:     {
1:1cb426b:         return getIntSetting(INPUT_NATIVE_PROTOCOL_VERSION, conf);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static Cluster getInputCluster(String host, Configuration conf)
1:d7cb970:     {
1:fe39eb7:         // this method has been left for backward compatibility
1:fe39eb7:         return getInputCluster(new String[] {host}, conf);
1:fe39eb7:     }
1:fe39eb7: 
1:fe39eb7:     public static Cluster getInputCluster(String[] hosts, Configuration conf)
1:fe39eb7:     {
1:d7cb970:         int port = getInputNativePort(conf);
1:f698cc2:         return getCluster(hosts, conf, port);
1:d7cb970:     }
1:d7cb970: 
1:f698cc2:     public static Cluster getOutputCluster(String host, Configuration conf)
1:d7cb970:     {
1:f698cc2:         return getOutputCluster(new String[]{host}, conf);
1:d7cb970:     }
1:d7cb970: 
1:f698cc2:     public static Cluster getOutputCluster(String[] hosts, Configuration conf)
1:d7cb970:     {
1:f698cc2:         int port = getOutputNativePort(conf);
1:f698cc2:         return getCluster(hosts, conf, port);
1:d7cb970:     }
1:d7cb970: 
1:f698cc2:     public static Cluster getCluster(String[] hosts, Configuration conf, int port)
1:d7cb970:     {
1:d7cb970:         Optional<AuthProvider> authProvider = getAuthProvider(conf);
1:d7cb970:         Optional<SSLOptions> sslOptions = getSSLOptions(conf);
1:1cb426b:         Optional<Integer> protocolVersion = getProtocolVersion(conf);
1:d06fd78:         LoadBalancingPolicy loadBalancingPolicy = getReadLoadBalancingPolicy(hosts);
1:d7cb970:         SocketOptions socketOptions = getReadSocketOptions(conf);
1:d7cb970:         QueryOptions queryOptions = getReadQueryOptions(conf);
1:d7cb970:         PoolingOptions poolingOptions = getReadPoolingOptions(conf);
1:d7cb970: 
1:d7cb970:         Cluster.Builder builder = Cluster.builder()
1:fe39eb7:                 .addContactPoints(hosts)
1:d7cb970:                 .withPort(port)
1:d7cb970:                 .withCompression(ProtocolOptions.Compression.NONE);
1:d7cb970: 
1:d7cb970:         if (authProvider.isPresent())
1:d7cb970:             builder.withAuthProvider(authProvider.get());
1:d7cb970:         if (sslOptions.isPresent())
1:d7cb970:             builder.withSSL(sslOptions.get());
1:d7cb970: 
1:68d2526:         if (protocolVersion.isPresent()) 
1:68d2526:         {
1:16b0288:             builder.withProtocolVersion(ProtocolVersion.fromInt(protocolVersion.get()));
1:d7cb970:         }
1:d7cb970:         builder.withLoadBalancingPolicy(loadBalancingPolicy)
1:d7cb970:                 .withSocketOptions(socketOptions)
1:d7cb970:                 .withQueryOptions(queryOptions)
1:d7cb970:                 .withPoolingOptions(poolingOptions);
1:d7cb970: 
1:d7cb970:         return builder.build();
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static void setInputCoreConnections(Configuration conf, String connections)
1:d7cb970:     {
1:d7cb970:         conf.set(INPUT_NATIVE_CORE_CONNECTIONS_PER_HOST, connections);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static void setInputMaxConnections(Configuration conf, String connections)
1:d7cb970:     {
1:d7cb970:         conf.set(INPUT_NATIVE_MAX_CONNECTIONS_PER_HOST, connections);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static void setInputMaxSimultReqPerConnections(Configuration conf, String reqs)
1:d7cb970:     {
1:d7cb970:         conf.set(INPUT_NATIVE_MAX_SIMULT_REQ_PER_CONNECTION, reqs);
1:d7cb970:     }    
1:d7cb970: 
1:d7cb970:     public static void setInputNativeConnectionTimeout(Configuration conf, String timeout)
1:d7cb970:     {
1:d7cb970:         conf.set(INPUT_NATIVE_CONNECTION_TIMEOUT, timeout);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static void setInputNativeReadConnectionTimeout(Configuration conf, String timeout)
1:d7cb970:     {
1:d7cb970:         conf.set(INPUT_NATIVE_READ_CONNECTION_TIMEOUT, timeout);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static void setInputNativeReceiveBufferSize(Configuration conf, String size)
1:d7cb970:     {
1:d7cb970:         conf.set(INPUT_NATIVE_RECEIVE_BUFFER_SIZE, size);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static void setInputNativeSendBufferSize(Configuration conf, String size)
1:d7cb970:     {
1:d7cb970:         conf.set(INPUT_NATIVE_SEND_BUFFER_SIZE, size);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static void setInputNativeSolinger(Configuration conf, String solinger)
1:d7cb970:     {
1:d7cb970:         conf.set(INPUT_NATIVE_SOLINGER, solinger);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static void setInputNativeTcpNodelay(Configuration conf, String tcpNodelay)
1:d7cb970:     {
1:d7cb970:         conf.set(INPUT_NATIVE_TCP_NODELAY, tcpNodelay);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static void setInputNativeAuthProvider(Configuration conf, String authProvider)
1:d7cb970:     {
1:d7cb970:         conf.set(INPUT_NATIVE_AUTH_PROVIDER, authProvider);
1:d7cb970:     }
1:d7cb970: 
1:0356ee7:     public static void setInputNativeSSLTruststorePath(Configuration conf, String path)
1:d7cb970:     {
1:0356ee7:         conf.set(INPUT_NATIVE_SSL_TRUST_STORE_PATH, path);
1:d7cb970:     } 
1:d7cb970: 
1:0356ee7:     public static void setInputNativeSSLKeystorePath(Configuration conf, String path)
1:d7cb970:     {
1:0356ee7:         conf.set(INPUT_NATIVE_SSL_KEY_STORE_PATH, path);
1:d7cb970:     }
1:d7cb970: 
1:0356ee7:     public static void setInputNativeSSLKeystorePassword(Configuration conf, String pass)
1:d7cb970:     {
1:0356ee7:         conf.set(INPUT_NATIVE_SSL_KEY_STORE_PASSWARD, pass);
1:d7cb970:     }
1:d7cb970: 
1:0356ee7:     public static void setInputNativeSSLTruststorePassword(Configuration conf, String pass)
1:d7cb970:     {
1:0356ee7:         conf.set(INPUT_NATIVE_SSL_TRUST_STORE_PASSWARD, pass);
1:d7cb970:     }
1:d7cb970: 
1:0356ee7:     public static void setInputNativeSSLCipherSuites(Configuration conf, String suites)
1:d7cb970:     {
1:0356ee7:         conf.set(INPUT_NATIVE_SSL_CIPHER_SUITES, suites);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static void setInputNativeReuseAddress(Configuration conf, String reuseAddress)
1:d7cb970:     {
1:d7cb970:         conf.set(INPUT_NATIVE_REUSE_ADDRESS, reuseAddress);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static void setInputNativeKeepAlive(Configuration conf, String keepAlive)
1:d7cb970:     {
1:d7cb970:         conf.set(INPUT_NATIVE_KEEP_ALIVE, keepAlive);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     public static void setInputNativePort(Configuration conf, String port)
1:d7cb970:     {
1:d7cb970:         conf.set(INPUT_NATIVE_PORT, port);
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     private static PoolingOptions getReadPoolingOptions(Configuration conf)
1:d7cb970:     {
1:d7cb970:         Optional<Integer> coreConnections = getInputCoreConnections(conf);
1:d7cb970:         Optional<Integer> maxConnections = getInputMaxConnections(conf);
1:d7cb970:         Optional<Integer> maxSimultaneousRequests = getInputMaxSimultReqPerConnections(conf);
1:16b0288: 
1:d7cb970:         PoolingOptions poolingOptions = new PoolingOptions();
1:d7cb970: 
1:c1d2b86:         for (HostDistance hostDistance : Arrays.asList(HostDistance.LOCAL, HostDistance.REMOTE))
1:c1d2b86:         {
1:c1d2b86:             if (coreConnections.isPresent())
1:c1d2b86:                 poolingOptions.setCoreConnectionsPerHost(hostDistance, coreConnections.get());
1:c1d2b86:             if (maxConnections.isPresent())
1:c1d2b86:                 poolingOptions.setMaxConnectionsPerHost(hostDistance, maxConnections.get());
1:c1d2b86:             if (maxSimultaneousRequests.isPresent())
1:f340362:                 poolingOptions.setNewConnectionThreshold(hostDistance, maxSimultaneousRequests.get());
1:c1d2b86:         }
1:d7cb970: 
1:d7cb970:         return poolingOptions;
1:d7cb970:     }  
1:d7cb970: 
1:d7cb970:     private static QueryOptions getReadQueryOptions(Configuration conf)
1:d7cb970:     {
1:d7cb970:         String CL = ConfigHelper.getReadConsistencyLevel(conf);
1:d7cb970:         Optional<Integer> fetchSize = getInputPageRowSize(conf);
1:d7cb970:         QueryOptions queryOptions = new QueryOptions();
1:d7cb970:         if (CL != null && !CL.isEmpty())
1:d7cb970:             queryOptions.setConsistencyLevel(com.datastax.driver.core.ConsistencyLevel.valueOf(CL));
1:d7cb970: 
1:d7cb970:         if (fetchSize.isPresent())
1:d7cb970:             queryOptions.setFetchSize(fetchSize.get());
1:d7cb970:         return queryOptions;
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     private static SocketOptions getReadSocketOptions(Configuration conf)
1:d7cb970:     {
1:d7cb970:         SocketOptions socketOptions = new SocketOptions();
1:d7cb970:         Optional<Integer> connectTimeoutMillis = getInputNativeConnectionTimeout(conf);
1:d7cb970:         Optional<Integer> readTimeoutMillis = getInputNativeReadConnectionTimeout(conf);
1:d7cb970:         Optional<Integer> receiveBufferSize = getInputNativeReceiveBufferSize(conf);
1:d7cb970:         Optional<Integer> sendBufferSize = getInputNativeSendBufferSize(conf);
1:d7cb970:         Optional<Integer> soLinger = getInputNativeSolinger(conf);
1:d7cb970:         Optional<Boolean> tcpNoDelay = getInputNativeTcpNodelay(conf);
1:d7cb970:         Optional<Boolean> reuseAddress = getInputNativeReuseAddress(conf);       
1:d7cb970:         Optional<Boolean> keepAlive = getInputNativeKeepAlive(conf);
1:d7cb970: 
1:d7cb970:         if (connectTimeoutMillis.isPresent())
1:d7cb970:             socketOptions.setConnectTimeoutMillis(connectTimeoutMillis.get());
1:d7cb970:         if (readTimeoutMillis.isPresent())
1:d7cb970:             socketOptions.setReadTimeoutMillis(readTimeoutMillis.get());
1:d7cb970:         if (receiveBufferSize.isPresent())
1:d7cb970:             socketOptions.setReceiveBufferSize(receiveBufferSize.get());
1:d7cb970:         if (sendBufferSize.isPresent())
1:d7cb970:             socketOptions.setSendBufferSize(sendBufferSize.get());
1:d7cb970:         if (soLinger.isPresent())
1:d7cb970:             socketOptions.setSoLinger(soLinger.get());
1:d7cb970:         if (tcpNoDelay.isPresent())
1:d7cb970:             socketOptions.setTcpNoDelay(tcpNoDelay.get());
1:d7cb970:         if (reuseAddress.isPresent())
1:d7cb970:             socketOptions.setReuseAddress(reuseAddress.get());
1:d7cb970:         if (keepAlive.isPresent())
1:d7cb970:             socketOptions.setKeepAlive(keepAlive.get());     
1:d7cb970: 
1:d7cb970:         return socketOptions;
1:d7cb970:     }
1:d7cb970: 
1:d06fd78:     private static LoadBalancingPolicy getReadLoadBalancingPolicy(final String[] stickHosts)
1:d7cb970:     {
1:fe39eb7:         return new LimitedLocalNodeFirstLocalBalancingPolicy(stickHosts);
1:d7cb970:     }
1:d7cb970: 
1:fee9791:     private static Optional<AuthProvider> getDefaultAuthProvider(Configuration conf)
1:fee9791:     {
1:fee9791:         Optional<String> username = getStringSetting(USERNAME, conf);
1:fee9791:         Optional<String> password = getStringSetting(PASSWORD, conf);
1:fee9791: 
1:fee9791:         if (username.isPresent() && password.isPresent())
1:fee9791:         {
1:fee9791:             return Optional.of(new PlainTextAuthProvider(username.get(), password.get()));
1:fee9791:         }
1:fee9791:         else
1:fee9791:         {
1:fee9791:             return Optional.absent();
1:fee9791:         }
1:fee9791:     }
1:fee9791: 
1:d7cb970:     private static Optional<AuthProvider> getAuthProvider(Configuration conf)
1:d7cb970:     {
1:d7cb970:         Optional<String> authProvider = getInputNativeAuthProvider(conf);
1:d7cb970:         if (!authProvider.isPresent())
1:fee9791:             return getDefaultAuthProvider(conf);
1:d7cb970: 
1:569177f:         return Optional.of(getClientAuthProvider(authProvider.get(), conf));
1:d7cb970:     }
1:d7cb970: 
1:f698cc2:     public static Optional<SSLOptions> getSSLOptions(Configuration conf)
1:d7cb970:     {
1:d7cb970:         Optional<String> truststorePath = getInputNativeSSLTruststorePath(conf);
1:d7cb970: 
1:19b4b63:         if (truststorePath.isPresent())
1:d7cb970:         {
1:fe5ef55:             Optional<String> keystorePath = getInputNativeSSLKeystorePath(conf);
1:fe5ef55:             Optional<String> truststorePassword = getInputNativeSSLTruststorePassword(conf);
1:fe5ef55:             Optional<String> keystorePassword = getInputNativeSSLKeystorePassword(conf);
1:fe5ef55:             Optional<String> cipherSuites = getInputNativeSSLCipherSuites(conf);
1:fe5ef55: 
1:d7cb970:             SSLContext context;
2:d7cb970:             try
1:d7cb970:             {
1:19b4b63:                 context = getSSLContext(truststorePath, truststorePassword, keystorePath, keystorePassword);
1:d7cb970:             }
1:d7cb970:             catch (UnrecoverableKeyException | KeyManagementException |
1:d7cb970:                     NoSuchAlgorithmException | KeyStoreException | CertificateException | IOException e)
1:d7cb970:             {
1:d7cb970:                 throw new RuntimeException(e);
1:d7cb970:             }
1:f340362:             String[] css = null;
1:d7cb970:             if (cipherSuites.isPresent())
1:d7cb970:                 css = cipherSuites.get().split(",");
1:f340362:             return Optional.of(JdkSSLOptions.builder()
1:f340362:                                             .withSSLContext(context)
1:f340362:                                             .withCipherSuites(css)
1:f340362:                                             .build());
1:d7cb970:         }
2:d7cb970:         return Optional.absent();
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     private static Optional<Integer> getIntSetting(String parameter, Configuration conf)
1:d7cb970:     {
1:d7cb970:         String setting = conf.get(parameter);
1:d7cb970:         if (setting == null)
1:d7cb970:             return Optional.absent();
1:5cc7a11:         return Optional.of(Integer.valueOf(setting));  
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     private static Optional<Boolean> getBooleanSetting(String parameter, Configuration conf)
1:d7cb970:     {
1:d7cb970:         String setting = conf.get(parameter);
1:d7cb970:         if (setting == null)
1:d7cb970:             return Optional.absent();
1:5cc7a11:         return Optional.of(Boolean.valueOf(setting));  
1:d7cb970:     }
1:d7cb970: 
1:d7cb970:     private static Optional<String> getStringSetting(String parameter, Configuration conf)
1:d7cb970:     {
1:d7cb970:         String setting = conf.get(parameter);
1:d7cb970:         if (setting == null)
1:d7cb970:             return Optional.absent();
1:d7cb970:         return Optional.of(setting);  
1:d7cb970:     }
1:d7cb970: 
1:569177f:     private static AuthProvider getClientAuthProvider(String factoryClassName, Configuration conf)
1:d7cb970:     {
1:d7cb970:         try
1:d7cb970:         {
1:569177f:             Class<?> c = Class.forName(factoryClassName);
1:569177f:             if (PlainTextAuthProvider.class.equals(c))
1:d7cb970:             {
1:569177f:                 String username = getStringSetting(USERNAME, conf).or("");
1:569177f:                 String password = getStringSetting(PASSWORD, conf).or("");
1:569177f:                 return (AuthProvider) c.getConstructor(String.class, String.class)
1:569177f:                         .newInstance(username, password);
1:d7cb970:             }
2:d7cb970:             else
1:d7cb970:             {
1:569177f:                 return (AuthProvider) c.newInstance();
1:d7cb970:             }
1:d7cb970:         }
1:d7cb970:         catch (Exception e)
1:d7cb970:         {
1:d7cb970:             throw new RuntimeException("Failed to instantiate auth provider:" + factoryClassName, e);
1:d7cb970:         }
1:d7cb970:     }
1:d7cb970: 
1:19b4b63:     private static SSLContext getSSLContext(Optional<String> truststorePath,
1:19b4b63:                                             Optional<String> truststorePassword,
1:19b4b63:                                             Optional<String> keystorePath,
1:19b4b63:                                             Optional<String> keystorePassword)
1:19b4b63:     throws NoSuchAlgorithmException,
1:19b4b63:            KeyStoreException,
1:19b4b63:            CertificateException,
1:19b4b63:            IOException,
1:19b4b63:            UnrecoverableKeyException,
1:19b4b63:            KeyManagementException
1:d7cb970:     {
1:19b4b63:         SSLContext ctx = SSLContext.getInstance("SSL");
1:19b4b63: 
1:19b4b63:         TrustManagerFactory tmf = null;
1:19b4b63:         if (truststorePath.isPresent())
1:d7cb970:         {
1:19b4b63:             try (FileInputStream tsf = new FileInputStream(truststorePath.get()))
1:19b4b63:             {
1:19b4b63:                 KeyStore ts = KeyStore.getInstance("JKS");
1:19b4b63:                 ts.load(tsf, truststorePassword.isPresent() ? truststorePassword.get().toCharArray() : null);
1:19b4b63:                 tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
1:19b4b63:                 tmf.init(ts);
1:19b4b63:             }
1:d7cb970:         }
1:19b4b63: 
1:19b4b63:         KeyManagerFactory kmf = null;
1:19b4b63:         if (keystorePath.isPresent())
1:19b4b63:         {
1:19b4b63:             try (FileInputStream ksf = new FileInputStream(keystorePath.get()))
1:19b4b63:             {
1:19b4b63:                 KeyStore ks = KeyStore.getInstance("JKS");
1:19b4b63:                 ks.load(ksf, keystorePassword.isPresent() ? keystorePassword.get().toCharArray() : null);
1:19b4b63:                 kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
1:19b4b63:                 kmf.init(ks, keystorePassword.isPresent() ? keystorePassword.get().toCharArray() : null);
1:19b4b63:             }
1:19b4b63:         }
1:19b4b63: 
1:19b4b63:         ctx.init(kmf != null ? kmf.getKeyManagers() : null,
1:19b4b63:                  tmf != null ? tmf.getTrustManagers() : null,
1:19b4b63:                  new SecureRandom());
1:d7cb970:         return ctx;
1:d7cb970:     }
1:d7cb970: }
============================================================================
author:Dave Brosius
-------------------------------------------------------------------------------
commit:68d2526
/////////////////////////////////////////////////////////////////////////
1:     private static Optional<Integer> getProtocolVersion(Configuration conf) 
1:     {
/////////////////////////////////////////////////////////////////////////
1:         if (protocolVersion.isPresent()) 
1:         {
commit:fe5ef55
/////////////////////////////////////////////////////////////////////////
1:             Optional<String> keystorePath = getInputNativeSSLKeystorePath(conf);
1:             Optional<String> truststorePassword = getInputNativeSSLTruststorePassword(conf);
1:             Optional<String> keystorePassword = getInputNativeSSLKeystorePassword(conf);
1:             Optional<String> cipherSuites = getInputNativeSSLCipherSuites(conf);
1: 
commit:d06fd78
/////////////////////////////////////////////////////////////////////////
1:         LoadBalancingPolicy loadBalancingPolicy = getReadLoadBalancingPolicy(hosts);
/////////////////////////////////////////////////////////////////////////
1:     private static LoadBalancingPolicy getReadLoadBalancingPolicy(final String[] stickHosts)
commit:5cc7a11
/////////////////////////////////////////////////////////////////////////
1:         return Optional.of(Integer.valueOf(setting));  
/////////////////////////////////////////////////////////////////////////
1:         return Optional.of(Boolean.valueOf(setting));  
commit:3ca9576
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:60b3584
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:4238cdd
author:Jacek Lewandowski
-------------------------------------------------------------------------------
commit:19b4b63
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (truststorePath.isPresent())
1:                 context = getSSLContext(truststorePath, truststorePassword, keystorePath, keystorePassword);
/////////////////////////////////////////////////////////////////////////
1:     private static SSLContext getSSLContext(Optional<String> truststorePath,
1:                                             Optional<String> truststorePassword,
1:                                             Optional<String> keystorePath,
1:                                             Optional<String> keystorePassword)
1:     throws NoSuchAlgorithmException,
1:            KeyStoreException,
1:            CertificateException,
1:            IOException,
1:            UnrecoverableKeyException,
1:            KeyManagementException
1:         SSLContext ctx = SSLContext.getInstance("SSL");
1: 
1:         TrustManagerFactory tmf = null;
1:         if (truststorePath.isPresent())
1:             try (FileInputStream tsf = new FileInputStream(truststorePath.get()))
1:             {
1:                 KeyStore ts = KeyStore.getInstance("JKS");
1:                 ts.load(tsf, truststorePassword.isPresent() ? truststorePassword.get().toCharArray() : null);
1:                 tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
1:                 tmf.init(ts);
1:             }
1: 
1:         KeyManagerFactory kmf = null;
1:         if (keystorePath.isPresent())
1:         {
1:             try (FileInputStream ksf = new FileInputStream(keystorePath.get()))
1:             {
1:                 KeyStore ks = KeyStore.getInstance("JKS");
1:                 ks.load(ksf, keystorePassword.isPresent() ? keystorePassword.get().toCharArray() : null);
1:                 kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
1:                 kmf.init(ks, keystorePassword.isPresent() ? keystorePassword.get().toCharArray() : null);
1:             }
1:         }
1: 
1:         ctx.init(kmf != null ? kmf.getKeyManagers() : null,
1:                  tmf != null ? tmf.getTrustManagers() : null,
1:                  new SecureRandom());
commit:fe39eb7
/////////////////////////////////////////////////////////////////////////
1:         // this method has been left for backward compatibility
1:         return getInputCluster(new String[] {host}, conf);
1:     }
1: 
1:     public static Cluster getInputCluster(String[] hosts, Configuration conf)
1:     {
0:         LoadBalancingPolicy loadBalancingPolicy = getReadLoadBalancingPolicy(conf, hosts);
1:                                          .addContactPoints(hosts)
/////////////////////////////////////////////////////////////////////////
0:     private static LoadBalancingPolicy getReadLoadBalancingPolicy(Configuration conf, final String[] stickHosts)
1:         return new LimitedLocalNodeFirstLocalBalancingPolicy(stickHosts);
author:Robert Stupp
-------------------------------------------------------------------------------
commit:f340362
/////////////////////////////////////////////////////////////////////////
1: import com.datastax.driver.core.JdkSSLOptions;
/////////////////////////////////////////////////////////////////////////
1:                 poolingOptions.setNewConnectionThreshold(hostDistance, maxSimultaneousRequests.get());
/////////////////////////////////////////////////////////////////////////
1:             String[] css = null;
1:             return Optional.of(JdkSSLOptions.builder()
1:                                             .withSSLContext(context)
1:                                             .withCipherSuites(css)
1:                                             .build());
commit:16b0288
/////////////////////////////////////////////////////////////////////////
1: import com.datastax.driver.core.ProtocolVersion;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             builder.withProtocolVersion(ProtocolVersion.fromInt(protocolVersion.get()));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         SSLContext ctx;
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:fee9791
/////////////////////////////////////////////////////////////////////////
1:     private static Optional<AuthProvider> getDefaultAuthProvider(Configuration conf)
1:     {
1:         Optional<String> username = getStringSetting(USERNAME, conf);
1:         Optional<String> password = getStringSetting(PASSWORD, conf);
1: 
1:         if (username.isPresent() && password.isPresent())
1:         {
1:             return Optional.of(new PlainTextAuthProvider(username.get(), password.get()));
1:         }
1:         else
1:         {
1:             return Optional.absent();
1:         }
1:     }
1: 
1:             return getDefaultAuthProvider(conf);
commit:25272a4
commit:c1d2b86
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         for (HostDistance hostDistance : Arrays.asList(HostDistance.LOCAL, HostDistance.REMOTE))
1:         {
1:             if (coreConnections.isPresent())
1:                 poolingOptions.setCoreConnectionsPerHost(hostDistance, coreConnections.get());
1:             if (maxConnections.isPresent())
1:                 poolingOptions.setMaxConnectionsPerHost(hostDistance, maxConnections.get());
0:             if (minSimultaneousRequests.isPresent())
0:                 poolingOptions.setMinSimultaneousRequestsPerConnectionThreshold(hostDistance, minSimultaneousRequests.get());
1:             if (maxSimultaneousRequests.isPresent())
0:                 poolingOptions.setMaxSimultaneousRequestsPerConnectionThreshold(hostDistance, maxSimultaneousRequests.get());
1:         }
commit:4b6d6eb
/////////////////////////////////////////////////////////////////////////
0:             public void onSuspected(Host host)
1:             {
1:             }
1: 
0:             @Override
commit:9f1e957
/////////////////////////////////////////////////////////////////////////
0:             public void onSuspected(Host host)
1:             {
1:             }
1: 
0:             @Override
commit:95d289b
commit:5151fd5
/////////////////////////////////////////////////////////////////////////
0:         if (maxSimultaneousRequests.isPresent())
0:             poolingOptions.setMaxSimultaneousRequestsPerConnectionThreshold(HostDistance.LOCAL, maxSimultaneousRequests.get());
0:                       .setMinSimultaneousRequestsPerConnectionThreshold(HostDistance.REMOTE, 0)
0:                       .setMaxSimultaneousRequestsPerConnectionThreshold(HostDistance.REMOTE, 0);
commit:d7cb970
/////////////////////////////////////////////////////////////////////////
1: import java.io.FileInputStream;
0: import java.io.FileNotFoundException;
1: import java.io.IOException;
1: import java.security.KeyManagementException;
1: import java.security.KeyStore;
1: import java.security.KeyStoreException;
1: import java.security.NoSuchAlgorithmException;
1: import java.security.SecureRandom;
1: import java.security.UnrecoverableKeyException;
1: import java.security.cert.CertificateException;
0: import java.util.Collection;
0: import java.util.Collections;
0: import java.util.Iterator;
0: import java.util.Set;
1: 
1: import javax.net.ssl.KeyManagerFactory;
1: import javax.net.ssl.SSLContext;
1: import javax.net.ssl.TrustManagerFactory;
1: 
1: import org.apache.cassandra.hadoop.ConfigHelper;
0: import org.apache.cassandra.io.util.FileUtils;
1: import com.datastax.driver.core.AuthProvider;
1: import com.datastax.driver.core.Cluster;
0: import com.datastax.driver.core.Host;
1: import com.datastax.driver.core.HostDistance;
1: import com.datastax.driver.core.PoolingOptions;
1: import com.datastax.driver.core.ProtocolOptions;
1: import com.datastax.driver.core.QueryOptions;
1: import com.datastax.driver.core.SSLOptions;
1: import com.datastax.driver.core.SocketOptions;
0: import com.datastax.driver.core.Statement;
1: import com.datastax.driver.core.policies.LoadBalancingPolicy;
1: import com.google.common.base.Optional;
0: import com.google.common.collect.Iterators;
0: import com.google.common.collect.Sets;
1: 
1:     private static final String INPUT_CQL = "cassandra.input.cql";
1: 
1:     private static final String INPUT_NATIVE_PORT = "cassandra.input.native.port";
1:     private static final String INPUT_NATIVE_CORE_CONNECTIONS_PER_HOST = "cassandra.input.native.core.connections.per.host";
1:     private static final String INPUT_NATIVE_MAX_CONNECTIONS_PER_HOST = "cassandra.input.native.max.connections.per.host";
0:     private static final String INPUT_NATIVE_MIN_SIMULT_REQ_PER_CONNECTION = "cassandra.input.native.min.simult.reqs.per.connection"; 
1:     private static final String INPUT_NATIVE_MAX_SIMULT_REQ_PER_CONNECTION = "cassandra.input.native.max.simult.reqs.per.connection";
1:     private static final String INPUT_NATIVE_CONNECTION_TIMEOUT = "cassandra.input.native.connection.timeout";
1:     private static final String INPUT_NATIVE_READ_CONNECTION_TIMEOUT = "cassandra.input.native.read.connection.timeout";
1:     private static final String INPUT_NATIVE_RECEIVE_BUFFER_SIZE = "cassandra.input.native.receive.buffer.size";
1:     private static final String INPUT_NATIVE_SEND_BUFFER_SIZE = "cassandra.input.native.send.buffer.size";
1:     private static final String INPUT_NATIVE_SOLINGER = "cassandra.input.native.solinger";
1:     private static final String INPUT_NATIVE_TCP_NODELAY = "cassandra.input.native.tcp.nodelay";
1:     private static final String INPUT_NATIVE_REUSE_ADDRESS = "cassandra.input.native.reuse.address";
1:     private static final String INPUT_NATIVE_KEEP_ALIVE = "cassandra.input.native.keep.alive";
1:     private static final String INPUT_NATIVE_AUTH_PROVIDER = "cassandra.input.native.auth.provider";
1:     private static final String INPUT_NATIVE_SSL_TRUST_STORE_PATH = "cassandra.input.native.ssl.trust.store.path";
1:     private static final String INPUT_NATIVE_SSL_KEY_STORE_PATH = "cassandra.input.native.ssl.key.store.path";
1:     private static final String INPUT_NATIVE_SSL_TRUST_STORE_PASSWARD = "cassandra.input.native.ssl.trust.store.password";
1:     private static final String INPUT_NATIVE_SSL_KEY_STORE_PASSWARD = "cassandra.input.native.ssl.key.store.password";
1:     private static final String INPUT_NATIVE_SSL_CIPHER_SUITES = "cassandra.input.native.ssl.cipher.suites";
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public static void setInputCql(Configuration conf, String cql)
1:     {
1:         if (cql == null || cql.isEmpty())
1:             return;
1: 
1:         conf.set(INPUT_CQL, cql);
1:     }
1: 
1:     public static Optional<Integer> getInputCoreConnections(Configuration conf)
1:     {
1:         return getIntSetting(INPUT_NATIVE_CORE_CONNECTIONS_PER_HOST, conf);
1:     }
1: 
1:     public static Optional<Integer> getInputMaxConnections(Configuration conf)
1:     {
1:         return getIntSetting(INPUT_NATIVE_MAX_CONNECTIONS_PER_HOST, conf);
1:     }
1: 
1:     public static int getInputNativePort(Configuration conf)
1:     {
1:         return Integer.parseInt(conf.get(INPUT_NATIVE_PORT, "9042"));
1:     }
1: 
0:     public static Optional<Integer> getInputMinSimultReqPerConnections(Configuration conf)
1:     {
0:         return getIntSetting(INPUT_NATIVE_MIN_SIMULT_REQ_PER_CONNECTION, conf);
1:     }
1: 
1:     public static Optional<Integer> getInputMaxSimultReqPerConnections(Configuration conf)
1:     {
1:         return getIntSetting(INPUT_NATIVE_MAX_SIMULT_REQ_PER_CONNECTION, conf);
1:     }
1: 
1:     public static Optional<Integer> getInputNativeConnectionTimeout(Configuration conf)
1:     {
1:         return getIntSetting(INPUT_NATIVE_CONNECTION_TIMEOUT, conf);
1:     }
1: 
1:     public static Optional<Integer> getInputNativeReadConnectionTimeout(Configuration conf)
1:     {
1:         return getIntSetting(INPUT_NATIVE_READ_CONNECTION_TIMEOUT, conf);
1:     }
1: 
1:     public static Optional<Integer> getInputNativeReceiveBufferSize(Configuration conf)
1:     {
1:         return getIntSetting(INPUT_NATIVE_RECEIVE_BUFFER_SIZE, conf);
1:     }
1: 
1:     public static Optional<Integer> getInputNativeSendBufferSize(Configuration conf)
1:     {
1:         return getIntSetting(INPUT_NATIVE_SEND_BUFFER_SIZE, conf);
1:     }
1: 
1:     public static Optional<Integer> getInputNativeSolinger(Configuration conf)
1:     {
1:         return getIntSetting(INPUT_NATIVE_SOLINGER, conf);
1:     }
1: 
1:     public static Optional<Boolean> getInputNativeTcpNodelay(Configuration conf)
1:     {
1:         return getBooleanSetting(INPUT_NATIVE_TCP_NODELAY, conf);
1:     }
1: 
1:     public static Optional<Boolean> getInputNativeReuseAddress(Configuration conf)
1:     {
1:         return getBooleanSetting(INPUT_NATIVE_REUSE_ADDRESS, conf);
1:     }
1: 
1:     public static Optional<String> getInputNativeAuthProvider(Configuration conf)
1:     {
1:         return getStringSetting(INPUT_NATIVE_AUTH_PROVIDER, conf);
1:     }
1: 
1:     public static Optional<String> getInputNativeSSLTruststorePath(Configuration conf)
1:     {
1:         return getStringSetting(INPUT_NATIVE_SSL_TRUST_STORE_PATH, conf);
1:     }
1: 
1:     public static Optional<String> getInputNativeSSLKeystorePath(Configuration conf)
1:     {
1:         return getStringSetting(INPUT_NATIVE_SSL_KEY_STORE_PATH, conf);
1:     }
1: 
1:     public static Optional<String> getInputNativeSSLKeystorePassword(Configuration conf)
1:     {
1:         return getStringSetting(INPUT_NATIVE_SSL_KEY_STORE_PASSWARD, conf);
1:     }
1: 
1:     public static Optional<String> getInputNativeSSLTruststorePassword(Configuration conf)
1:     {
1:         return getStringSetting(INPUT_NATIVE_SSL_TRUST_STORE_PASSWARD, conf);
1:     }
1: 
1:     public static Optional<String> getInputNativeSSLCipherSuites(Configuration conf)
1:     {
1:         return getStringSetting(INPUT_NATIVE_SSL_CIPHER_SUITES, conf);
1:     }
1: 
1:     public static Optional<Boolean> getInputNativeKeepAlive(Configuration conf)
1:     {
1:         return getBooleanSetting(INPUT_NATIVE_KEEP_ALIVE, conf);
1:     }
1: 
1: 
1:     public static Optional<Integer> getInputPageRowSize(Configuration conf)
1:         return getIntSetting(INPUT_CQL_PAGE_ROW_SIZE_CONFIG, conf);
1: 
1: 
1:     public static String getInputCql(Configuration conf)
1:     {
1:         return conf.get(INPUT_CQL);
1:     }
1: 
1: 
1:     public static Cluster getInputCluster(String host, Configuration conf)
1:     {
1:         int port = getInputNativePort(conf);
1:         Optional<AuthProvider> authProvider = getAuthProvider(conf);
1:         Optional<SSLOptions> sslOptions = getSSLOptions(conf);
0:         LoadBalancingPolicy loadBalancingPolicy = getReadLoadBalancingPolicy(conf, host);
1:         SocketOptions socketOptions = getReadSocketOptions(conf);
1:         QueryOptions queryOptions = getReadQueryOptions(conf);
1:         PoolingOptions poolingOptions = getReadPoolingOptions(conf);
1:         
1:         Cluster.Builder builder = Cluster.builder()
0:                                          .addContactPoint(host)
1:                                          .withPort(port)
1:                                          .withCompression(ProtocolOptions.Compression.NONE);
1: 
1:         if (authProvider.isPresent())
1:             builder.withAuthProvider(authProvider.get());
1:         if (sslOptions.isPresent())
1:             builder.withSSL(sslOptions.get());
1: 
1:         builder.withLoadBalancingPolicy(loadBalancingPolicy)
1:                .withSocketOptions(socketOptions)
1:                .withQueryOptions(queryOptions)
1:                .withPoolingOptions(poolingOptions);
1: 
1:         return builder.build();
1:     }
1: 
1:     public static void setInputCoreConnections(Configuration conf, String connections)
1:     {
1:         conf.set(INPUT_NATIVE_CORE_CONNECTIONS_PER_HOST, connections);
1:     }
1: 
1:     public static void setInputMaxConnections(Configuration conf, String connections)
1:     {
1:         conf.set(INPUT_NATIVE_MAX_CONNECTIONS_PER_HOST, connections);
1:     }
1: 
0:     public static void setInputMinSimultReqPerConnections(Configuration conf, String reqs)
1:     {
0:         conf.set(INPUT_NATIVE_MIN_SIMULT_REQ_PER_CONNECTION, reqs);
1:     }
1: 
1:     public static void setInputMaxSimultReqPerConnections(Configuration conf, String reqs)
1:     {
1:         conf.set(INPUT_NATIVE_MAX_SIMULT_REQ_PER_CONNECTION, reqs);
1:     }    
1: 
1:     public static void setInputNativeConnectionTimeout(Configuration conf, String timeout)
1:     {
1:         conf.set(INPUT_NATIVE_CONNECTION_TIMEOUT, timeout);
1:     }
1: 
1:     public static void setInputNativeReadConnectionTimeout(Configuration conf, String timeout)
1:     {
1:         conf.set(INPUT_NATIVE_READ_CONNECTION_TIMEOUT, timeout);
1:     }
1: 
1:     public static void setInputNativeReceiveBufferSize(Configuration conf, String size)
1:     {
1:         conf.set(INPUT_NATIVE_RECEIVE_BUFFER_SIZE, size);
1:     }
1: 
1:     public static void setInputNativeSendBufferSize(Configuration conf, String size)
1:     {
1:         conf.set(INPUT_NATIVE_SEND_BUFFER_SIZE, size);
1:     }
1: 
1:     public static void setInputNativeSolinger(Configuration conf, String solinger)
1:     {
1:         conf.set(INPUT_NATIVE_SOLINGER, solinger);
1:     }
1: 
1:     public static void setInputNativeTcpNodelay(Configuration conf, String tcpNodelay)
1:     {
1:         conf.set(INPUT_NATIVE_TCP_NODELAY, tcpNodelay);
1:     }
1: 
1:     public static void setInputNativeAuthProvider(Configuration conf, String authProvider)
1:     {
1:         conf.set(INPUT_NATIVE_AUTH_PROVIDER, authProvider);
1:     }
1: 
0:     public static void setInputNativeSSLTruststorePath(Configuration conf, String authProvider)
1:     {
0:         conf.set(INPUT_NATIVE_SSL_TRUST_STORE_PATH, authProvider);
1:     } 
1: 
0:     public static void setInputNativeSSLKeystorePath(Configuration conf, String authProvider)
1:     {
0:         conf.set(INPUT_NATIVE_SSL_KEY_STORE_PATH, authProvider);
1:     }
1: 
0:     public static void setInputNativeSSLKeystorePassword(Configuration conf, String authProvider)
1:     {
0:         conf.set(INPUT_NATIVE_SSL_KEY_STORE_PASSWARD, authProvider);
1:     }
1: 
0:     public static void setInputNativeSSLTruststorePassword(Configuration conf, String authProvider)
1:     {
0:         conf.set(INPUT_NATIVE_SSL_TRUST_STORE_PASSWARD, authProvider);
1:     }
1: 
0:     public static void setInputNativeSSLCipherSuites(Configuration conf, String authProvider)
1:     {
0:         conf.set(INPUT_NATIVE_SSL_CIPHER_SUITES, authProvider);
1:     }
1: 
1:     public static void setInputNativeReuseAddress(Configuration conf, String reuseAddress)
1:     {
1:         conf.set(INPUT_NATIVE_REUSE_ADDRESS, reuseAddress);
1:     }
1: 
1:     public static void setInputNativeKeepAlive(Configuration conf, String keepAlive)
1:     {
1:         conf.set(INPUT_NATIVE_KEEP_ALIVE, keepAlive);
1:     }
1: 
1:     public static void setInputNativePort(Configuration conf, String port)
1:     {
1:         conf.set(INPUT_NATIVE_PORT, port);
1:     }
1: 
1:     private static PoolingOptions getReadPoolingOptions(Configuration conf)
1:     {
1:         Optional<Integer> coreConnections = getInputCoreConnections(conf);
1:         Optional<Integer> maxConnections = getInputMaxConnections(conf);
1:         Optional<Integer> maxSimultaneousRequests = getInputMaxSimultReqPerConnections(conf);
0:         Optional<Integer> minSimultaneousRequests = getInputMinSimultReqPerConnections(conf);
1:         
1:         PoolingOptions poolingOptions = new PoolingOptions();
1: 
0:         if (coreConnections.isPresent())
0:             poolingOptions.setCoreConnectionsPerHost(HostDistance.LOCAL, coreConnections.get());
0:         if (maxConnections.isPresent())
0:             poolingOptions.setMaxConnectionsPerHost(HostDistance.LOCAL, maxConnections.get());
0:         if (maxSimultaneousRequests.isPresent())
0:             poolingOptions.setMaxSimultaneousRequestsPerConnectionThreshold(HostDistance.LOCAL, maxSimultaneousRequests.get());
0:         if (minSimultaneousRequests.isPresent())
0:             poolingOptions.setMinSimultaneousRequestsPerConnectionThreshold(HostDistance.LOCAL, minSimultaneousRequests.get());
1: 
0:         poolingOptions.setCoreConnectionsPerHost(HostDistance.REMOTE, 0)
0:                       .setMaxConnectionsPerHost(HostDistance.REMOTE, 0)
0:                       .setMaxSimultaneousRequestsPerConnectionThreshold(HostDistance.REMOTE, 0)
0:                       .setMinSimultaneousRequestsPerConnectionThreshold(HostDistance.REMOTE, 0);
1: 
1:         return poolingOptions;
1:     }  
1: 
1:     private static QueryOptions getReadQueryOptions(Configuration conf)
1:     {
1:         String CL = ConfigHelper.getReadConsistencyLevel(conf);
1:         Optional<Integer> fetchSize = getInputPageRowSize(conf);
1:         QueryOptions queryOptions = new QueryOptions();
1:         if (CL != null && !CL.isEmpty())
1:             queryOptions.setConsistencyLevel(com.datastax.driver.core.ConsistencyLevel.valueOf(CL));
1: 
1:         if (fetchSize.isPresent())
1:             queryOptions.setFetchSize(fetchSize.get());
1:         return queryOptions;
1:     }
1: 
1:     private static SocketOptions getReadSocketOptions(Configuration conf)
1:     {
1:         SocketOptions socketOptions = new SocketOptions();
1:         Optional<Integer> connectTimeoutMillis = getInputNativeConnectionTimeout(conf);
1:         Optional<Integer> readTimeoutMillis = getInputNativeReadConnectionTimeout(conf);
1:         Optional<Integer> receiveBufferSize = getInputNativeReceiveBufferSize(conf);
1:         Optional<Integer> sendBufferSize = getInputNativeSendBufferSize(conf);
1:         Optional<Integer> soLinger = getInputNativeSolinger(conf);
1:         Optional<Boolean> tcpNoDelay = getInputNativeTcpNodelay(conf);
1:         Optional<Boolean> reuseAddress = getInputNativeReuseAddress(conf);       
1:         Optional<Boolean> keepAlive = getInputNativeKeepAlive(conf);
1: 
1:         if (connectTimeoutMillis.isPresent())
1:             socketOptions.setConnectTimeoutMillis(connectTimeoutMillis.get());
1:         if (readTimeoutMillis.isPresent())
1:             socketOptions.setReadTimeoutMillis(readTimeoutMillis.get());
1:         if (receiveBufferSize.isPresent())
1:             socketOptions.setReceiveBufferSize(receiveBufferSize.get());
1:         if (sendBufferSize.isPresent())
1:             socketOptions.setSendBufferSize(sendBufferSize.get());
1:         if (soLinger.isPresent())
1:             socketOptions.setSoLinger(soLinger.get());
1:         if (tcpNoDelay.isPresent())
1:             socketOptions.setTcpNoDelay(tcpNoDelay.get());
1:         if (reuseAddress.isPresent())
1:             socketOptions.setReuseAddress(reuseAddress.get());
1:         if (keepAlive.isPresent())
1:             socketOptions.setKeepAlive(keepAlive.get());     
1: 
1:         return socketOptions;
1:     }
1: 
0:     private static LoadBalancingPolicy getReadLoadBalancingPolicy(Configuration conf, final String stickHost)
1:     {
0:         return new LoadBalancingPolicy()
1:         {
0:             private Host origHost;
0:             private Set<Host> liveRemoteHosts = Sets.newHashSet();
1: 
0:             @Override
0:             public void onAdd(Host host)
1:             {
0:                 if (host.getAddress().getHostName().equals(stickHost))
0:                     origHost = host;
1:             }
1: 
0:             @Override
0:             public void onDown(Host host)
1:             {
0:                 if (host.getAddress().getHostName().equals(stickHost))
0:                     origHost = null;
0:                 liveRemoteHosts.remove(host);
1:             }
1: 
0:             @Override
0:             public void onRemove(Host host)
1:             {
0:                 if (host.getAddress().getHostName().equals(stickHost))
0:                     origHost = null;
0:                 liveRemoteHosts.remove(host);
1:             }
1: 
0:             @Override
0:             public void onUp(Host host)
1:             {
0:                 if (host.getAddress().getHostName().equals(stickHost))
0:                     origHost = host;
0:                 liveRemoteHosts.add(host);
1:             }
1: 
0:             @Override
0:             public HostDistance distance(Host host)
1:             {
0:                 if (host.getAddress().getHostName().equals(stickHost))
0:                     return HostDistance.LOCAL;
1:                 else
0:                     return HostDistance.REMOTE;
1:             }
1: 
0:             @Override
0:             public void init(Cluster cluster, Collection<Host> hosts)
1:             {
0:                 for (Host host : hosts)
1:                 {
0:                     if (host.getAddress().getHostName().equals(stickHost))
1:                     {
0:                         origHost = host;
0:                         break;
1:                     }
1:                 }
1:             }
1: 
0:             @Override
0:             public Iterator<Host> newQueryPlan(String loggedKeyspace, Statement statement)
1:             {
0:                 if (origHost != null)
1:                 {
0:                     return Iterators.concat(Collections.singletonList(origHost).iterator(), liveRemoteHosts.iterator());
1:                 }
1:                 else
1:                 {
0:                     return liveRemoteHosts.iterator();
1:                 }
1:             }
0:         };
1:     }
1: 
1:     private static Optional<AuthProvider> getAuthProvider(Configuration conf)
1:     {
1:         Optional<String> authProvider = getInputNativeAuthProvider(conf);
1:         if (!authProvider.isPresent())
1:             return Optional.absent();
1: 
0:         return Optional.of(getClientAuthProvider(authProvider.get()));  
1:     }
1: 
0:     private static Optional<SSLOptions> getSSLOptions(Configuration conf)
1:     {
1:         Optional<String> truststorePath = getInputNativeSSLTruststorePath(conf);
0:         Optional<String> keystorePath = getInputNativeSSLKeystorePath(conf);
0:         Optional<String> truststorePassword = getInputNativeSSLTruststorePassword(conf);
0:         Optional<String> keystorePassword = getInputNativeSSLKeystorePassword(conf);
0:         Optional<String> cipherSuites = getInputNativeSSLCipherSuites(conf);
1:         
0:         if (truststorePath.isPresent() && keystorePath.isPresent() && truststorePassword.isPresent() && keystorePassword.isPresent())
1:         {
1:             SSLContext context;
1:             try
1:             {
0:                 context = getSSLContext(truststorePath.get(), truststorePassword.get(), keystorePath.get(), keystorePassword.get());
1:             }
1:             catch (UnrecoverableKeyException | KeyManagementException |
1:                     NoSuchAlgorithmException | KeyStoreException | CertificateException | IOException e)
1:             {
1:                 throw new RuntimeException(e);
1:             }
0:             String[] css = SSLOptions.DEFAULT_SSL_CIPHER_SUITES;
1:             if (cipherSuites.isPresent())
1:                 css = cipherSuites.get().split(",");
0:             return Optional.of(new SSLOptions(context,css));
1:         }
1:         return Optional.absent();
1:     }
1: 
1:     private static Optional<Integer> getIntSetting(String parameter, Configuration conf)
1:     {
1:         String setting = conf.get(parameter);
1:         if (setting == null)
1:             return Optional.absent();
0:         return Optional.of(Integer.parseInt(setting));  
1:     }
1: 
1:     private static Optional<Boolean> getBooleanSetting(String parameter, Configuration conf)
1:     {
1:         String setting = conf.get(parameter);
1:         if (setting == null)
1:             return Optional.absent();
0:         return Optional.of(Boolean.parseBoolean(setting));  
1:     }
1: 
1:     private static Optional<String> getStringSetting(String parameter, Configuration conf)
1:     {
1:         String setting = conf.get(parameter);
1:         if (setting == null)
1:             return Optional.absent();
1:         return Optional.of(setting);  
1:     }
1: 
0:     private static AuthProvider getClientAuthProvider(String factoryClassName)
1:     {
1:         try
1:         {
0:             return (AuthProvider) Class.forName(factoryClassName).newInstance();
1:         }
1:         catch (Exception e)
1:         {
1:             throw new RuntimeException("Failed to instantiate auth provider:" + factoryClassName, e);
1:         }
1:     }
1: 
0:     private static SSLContext getSSLContext(String truststorePath, String truststorePassword, String keystorePath, String keystorePassword)
0:             throws NoSuchAlgorithmException, KeyStoreException, CertificateException, IOException, UnrecoverableKeyException, KeyManagementException
1:     {
0:         FileInputStream tsf = null;
0:         FileInputStream ksf = null;
0:         SSLContext ctx = null;
1:         try
1:         {
0:             tsf = new FileInputStream(truststorePath);
0:             ksf = new FileInputStream(keystorePath);
0:             ctx = SSLContext.getInstance("SSL");
1: 
0:             KeyStore ts = KeyStore.getInstance("JKS");
0:             ts.load(tsf, truststorePassword.toCharArray());
0:             TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
0:             tmf.init(ts);
1: 
0:             KeyStore ks = KeyStore.getInstance("JKS");
0:             ks.load(ksf, keystorePassword.toCharArray());
0:             KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
0:             kmf.init(ks, keystorePassword.toCharArray());
1: 
0:             ctx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new SecureRandom());
1:         }
0:         finally
1:         {
0:             FileUtils.closeQuietly(tsf);
0:             FileUtils.closeQuietly(ksf);
1:         }
1:         return ctx;
1:     }
commit:b0841d8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     
1:     
1:     
0:     public static String getInputPageRowSize(Configuration conf)
0:         return conf.get(INPUT_CQL_PAGE_ROW_SIZE_CONFIG);
1:     
1:     
commit:3b708f9
/////////////////////////////////////////////////////////////////////////
0: import java.io.FileInputStream;
0: import java.io.IOException;
0: import java.security.KeyManagementException;
0: import java.security.KeyStore;
0: import java.security.KeyStoreException;
0: import java.security.NoSuchAlgorithmException;
0: import java.security.SecureRandom;
0: import java.security.UnrecoverableKeyException;
0: import java.security.cert.CertificateException;
0: import java.util.Collection;
0: import java.util.Collections;
0: import java.util.Iterator;
0: import java.util.Set;
0: 
0: import javax.net.ssl.KeyManagerFactory;
0: import javax.net.ssl.SSLContext;
0: import javax.net.ssl.TrustManagerFactory;
0: 
0: import org.apache.cassandra.hadoop.ConfigHelper;
0: import com.datastax.driver.core.AuthProvider;
0: import com.datastax.driver.core.Cluster;
0: import com.datastax.driver.core.Host;
0: import com.datastax.driver.core.HostDistance;
0: import com.datastax.driver.core.PoolingOptions;
0: import com.datastax.driver.core.ProtocolOptions;
0: import com.datastax.driver.core.QueryOptions;
0: import com.datastax.driver.core.SSLOptions;
0: import com.datastax.driver.core.SocketOptions;
0: import com.datastax.driver.core.Statement;
0: import com.datastax.driver.core.policies.LoadBalancingPolicy;
0: import com.google.common.base.Optional;
0: import com.google.common.collect.Iterators;
0: import com.google.common.collect.Sets;
0: 
0:     private static final String INPUT_CQL = "cassandra.input.cql";
0: 
0:     private static final String INPUT_NATIVE_PORT = "cassandra.input.native.port";
0:     private static final String INPUT_NATIVE_CORE_CONNECTIONS_PER_HOST = "cassandra.input.native.core.connections.per.host";
0:     private static final String INPUT_NATIVE_MAX_CONNECTIONS_PER_HOST = "cassandra.input.native.max.connections.per.host";
0:     private static final String INPUT_NATIVE_MIN_SIMULT_REQ_PER_CONNECTION = "cassandra.input.native.min.simult.reqs.per.connection"; 
0:     private static final String INPUT_NATIVE_MAX_SIMULT_REQ_PER_CONNECTION = "cassandra.input.native.max.simult.reqs.per.connection";
0:     private static final String INPUT_NATIVE_CONNECTION_TIMEOUT = "cassandra.input.native.connection.timeout";
0:     private static final String INPUT_NATIVE_READ_CONNECTION_TIMEOUT = "cassandra.input.native.read.connection.timeout";
0:     private static final String INPUT_NATIVE_RECEIVE_BUFFER_SIZE = "cassandra.input.native.receive.buffer.size";
0:     private static final String INPUT_NATIVE_SEND_BUFFER_SIZE = "cassandra.input.native.send.buffer.size";
0:     private static final String INPUT_NATIVE_SOLINGER = "cassandra.input.native.solinger";
0:     private static final String INPUT_NATIVE_TCP_NODELAY = "cassandra.input.native.tcp.nodelay";
0:     private static final String INPUT_NATIVE_REUSE_ADDRESS = "cassandra.input.native.reuse.address";
0:     private static final String INPUT_NATIVE_KEEP_ALIVE = "cassandra.input.native.keep.alive";
0:     private static final String INPUT_NATIVE_AUTH_PROVIDER = "cassandra.input.native.auth.provider";
0:     private static final String INPUT_NATIVE_SSL_TRUST_STORE_PATH = "cassandra.input.native.ssl.trust.store.path";
0:     private static final String INPUT_NATIVE_SSL_KEY_STORE_PATH = "cassandra.input.native.ssl.key.store.path";
0:     private static final String INPUT_NATIVE_SSL_TRUST_STORE_PASSWARD = "cassandra.input.native.ssl.trust.store.password";
0:     private static final String INPUT_NATIVE_SSL_KEY_STORE_PASSWARD = "cassandra.input.native.ssl.key.store.password";
0:     private static final String INPUT_NATIVE_SSL_CIPHER_SUITES = "cassandra.input.native.ssl.cipher.suites";
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:     public static void setInputCql(Configuration conf, String cql)
1:     {
1:         if (cql == null || cql.isEmpty())
1:             return;
0: 
0:         conf.set(INPUT_CQL, cql);
1:     }
0: 
0:     public static Optional<Integer> getInputCoreConnections(Configuration conf)
1:     {
0:         return getIntSetting(INPUT_NATIVE_CORE_CONNECTIONS_PER_HOST, conf);
1:     }
0: 
0:     public static Optional<Integer> getInputMaxConnections(Configuration conf)
1:     {
0:         return getIntSetting(INPUT_NATIVE_MAX_CONNECTIONS_PER_HOST, conf);
1:     }
0: 
0:     public static int getInputNativePort(Configuration conf)
1:     {
0:         return Integer.parseInt(conf.get(INPUT_NATIVE_PORT, "9042"));
1:     }
0: 
0:     public static Optional<Integer> getInputMinSimultReqPerConnections(Configuration conf)
1:     {
0:         return getIntSetting(INPUT_NATIVE_MIN_SIMULT_REQ_PER_CONNECTION, conf);
1:     }
0: 
0:     public static Optional<Integer> getInputMaxSimultReqPerConnections(Configuration conf)
1:     {
0:         return getIntSetting(INPUT_NATIVE_MAX_SIMULT_REQ_PER_CONNECTION, conf);
1:     }
0: 
0:     public static Optional<Integer> getInputNativeConnectionTimeout(Configuration conf)
1:     {
0:         return getIntSetting(INPUT_NATIVE_CONNECTION_TIMEOUT, conf);
1:     }
0: 
0:     public static Optional<Integer> getInputNativeReadConnectionTimeout(Configuration conf)
1:     {
0:         return getIntSetting(INPUT_NATIVE_READ_CONNECTION_TIMEOUT, conf);
1:     }
0: 
0:     public static Optional<Integer> getInputNativeReceiveBufferSize(Configuration conf)
1:     {
0:         return getIntSetting(INPUT_NATIVE_RECEIVE_BUFFER_SIZE, conf);
1:     }
0: 
0:     public static Optional<Integer> getInputNativeSendBufferSize(Configuration conf)
1:     {
0:         return getIntSetting(INPUT_NATIVE_SEND_BUFFER_SIZE, conf);
1:     }
0: 
0:     public static Optional<Integer> getInputNativeSolinger(Configuration conf)
1:     {
0:         return getIntSetting(INPUT_NATIVE_SOLINGER, conf);
1:     }
0: 
0:     public static Optional<Boolean> getInputNativeTcpNodelay(Configuration conf)
1:     {
0:         return getBooleanSetting(INPUT_NATIVE_TCP_NODELAY, conf);
1:     }
0: 
0:     public static Optional<Boolean> getInputNativeReuseAddress(Configuration conf)
1:     {
0:         return getBooleanSetting(INPUT_NATIVE_REUSE_ADDRESS, conf);
1:     }
0: 
0:     public static Optional<String> getInputNativeAuthProvider(Configuration conf)
1:     {
0:         return getStringSetting(INPUT_NATIVE_AUTH_PROVIDER, conf);
1:     }
0: 
0:     public static Optional<String> getInputNativeSSLTruststorePath(Configuration conf)
1:     {
0:         return getStringSetting(INPUT_NATIVE_SSL_TRUST_STORE_PATH, conf);
1:     }
0: 
0:     public static Optional<String> getInputNativeSSLKeystorePath(Configuration conf)
1:     {
0:         return getStringSetting(INPUT_NATIVE_SSL_KEY_STORE_PATH, conf);
1:     }
0: 
0:     public static Optional<String> getInputNativeSSLKeystorePassword(Configuration conf)
1:     {
0:         return getStringSetting(INPUT_NATIVE_SSL_KEY_STORE_PASSWARD, conf);
1:     }
0: 
0:     public static Optional<String> getInputNativeSSLTruststorePassword(Configuration conf)
1:     {
0:         return getStringSetting(INPUT_NATIVE_SSL_TRUST_STORE_PASSWARD, conf);
1:     }
0: 
0:     public static Optional<String> getInputNativeSSLCipherSuites(Configuration conf)
1:     {
0:         return getStringSetting(INPUT_NATIVE_SSL_CIPHER_SUITES, conf);
1:     }
0: 
0:     public static Optional<Boolean> getInputNativeKeepAlive(Configuration conf)
1:     {
0:         return getBooleanSetting(INPUT_NATIVE_KEEP_ALIVE, conf);
1:     }
0: 
0: 
0:     public static Optional<Integer> getInputPageRowSize(Configuration conf)
0:         return getIntSetting(INPUT_CQL_PAGE_ROW_SIZE_CONFIG, conf);
0: 
0: 
0:     public static String getInputCql(Configuration conf)
1:     {
0:         return conf.get(INPUT_CQL);
1:     }
0: 
0: 
0:     public static Cluster getInputCluster(String host, Configuration conf)
1:     {
0:         int port = getInputNativePort(conf);
0:         Optional<AuthProvider> authProvider = getAuthProvider(conf);
0:         Optional<SSLOptions> sslOptions = getSSLOptions(conf);
0:         LoadBalancingPolicy loadBalancingPolicy = getReadLoadBalancingPolicy(conf, host);
0:         SocketOptions socketOptions = getReadSocketOptions(conf);
0:         QueryOptions queryOptions = getReadQueryOptions(conf);
0:         PoolingOptions poolingOptions = getReadPoolingOptions(conf);
0:         
0:         Cluster.Builder builder = Cluster.builder()
0:                                          .addContactPoint(host)
0:                                          .withPort(port)
0:                                          .withCompression(ProtocolOptions.Compression.NONE);
0: 
0:         if (authProvider.isPresent())
0:             builder.withAuthProvider(authProvider.get());
0:         if (sslOptions.isPresent())
0:             builder.withSSL(sslOptions.get());
0: 
0:         builder.withLoadBalancingPolicy(loadBalancingPolicy)
0:                .withSocketOptions(socketOptions)
0:                .withQueryOptions(queryOptions)
0:                .withPoolingOptions(poolingOptions);
0: 
0:         return builder.build();
1:     }
0: 
0:     public static void setInputCoreConnections(Configuration conf, String connections)
1:     {
0:         conf.set(INPUT_NATIVE_CORE_CONNECTIONS_PER_HOST, connections);
1:     }
0: 
0:     public static void setInputMaxConnections(Configuration conf, String connections)
1:     {
0:         conf.set(INPUT_NATIVE_MAX_CONNECTIONS_PER_HOST, connections);
1:     }
0: 
0:     public static void setInputMinSimultReqPerConnections(Configuration conf, String reqs)
1:     {
0:         conf.set(INPUT_NATIVE_MIN_SIMULT_REQ_PER_CONNECTION, reqs);
1:     }
0: 
0:     public static void setInputMaxSimultReqPerConnections(Configuration conf, String reqs)
1:     {
0:         conf.set(INPUT_NATIVE_MAX_SIMULT_REQ_PER_CONNECTION, reqs);
1:     }    
0: 
0:     public static void setInputNativeConnectionTimeout(Configuration conf, String timeout)
1:     {
0:         conf.set(INPUT_NATIVE_CONNECTION_TIMEOUT, timeout);
1:     }
0: 
0:     public static void setInputNativeReadConnectionTimeout(Configuration conf, String timeout)
1:     {
0:         conf.set(INPUT_NATIVE_READ_CONNECTION_TIMEOUT, timeout);
1:     }
0: 
0:     public static void setInputNativeReceiveBufferSize(Configuration conf, String size)
1:     {
0:         conf.set(INPUT_NATIVE_RECEIVE_BUFFER_SIZE, size);
1:     }
0: 
0:     public static void setInputNativeSendBufferSize(Configuration conf, String size)
1:     {
0:         conf.set(INPUT_NATIVE_SEND_BUFFER_SIZE, size);
1:     }
0: 
0:     public static void setInputNativeSolinger(Configuration conf, String solinger)
1:     {
0:         conf.set(INPUT_NATIVE_SOLINGER, solinger);
1:     }
0: 
0:     public static void setInputNativeTcpNodelay(Configuration conf, String tcpNodelay)
1:     {
0:         conf.set(INPUT_NATIVE_TCP_NODELAY, tcpNodelay);
1:     }
0: 
0:     public static void setInputNativeAuthProvider(Configuration conf, String authProvider)
1:     {
0:         conf.set(INPUT_NATIVE_AUTH_PROVIDER, authProvider);
1:     }
0: 
0:     public static void setInputNativeSSLTruststorePath(Configuration conf, String authProvider)
1:     {
0:         conf.set(INPUT_NATIVE_SSL_TRUST_STORE_PATH, authProvider);
1:     } 
0: 
0:     public static void setInputNativeSSLKeystorePath(Configuration conf, String authProvider)
1:     {
0:         conf.set(INPUT_NATIVE_SSL_KEY_STORE_PATH, authProvider);
1:     }
0: 
0:     public static void setInputNativeSSLKeystorePassword(Configuration conf, String authProvider)
1:     {
0:         conf.set(INPUT_NATIVE_SSL_KEY_STORE_PASSWARD, authProvider);
1:     }
0: 
0:     public static void setInputNativeSSLTruststorePassword(Configuration conf, String authProvider)
1:     {
0:         conf.set(INPUT_NATIVE_SSL_TRUST_STORE_PASSWARD, authProvider);
1:     }
0: 
0:     public static void setInputNativeSSLCipherSuites(Configuration conf, String authProvider)
1:     {
0:         conf.set(INPUT_NATIVE_SSL_CIPHER_SUITES, authProvider);
1:     }
0: 
0:     public static void setInputNativeReuseAddress(Configuration conf, String reuseAddress)
1:     {
0:         conf.set(INPUT_NATIVE_REUSE_ADDRESS, reuseAddress);
1:     }
0: 
0:     public static void setInputNativeKeepAlive(Configuration conf, String keepAlive)
1:     {
0:         conf.set(INPUT_NATIVE_KEEP_ALIVE, keepAlive);
1:     }
0: 
0:     public static void setInputNativePort(Configuration conf, String port)
1:     {
0:         conf.set(INPUT_NATIVE_PORT, port);
1:     }
0: 
0:     private static PoolingOptions getReadPoolingOptions(Configuration conf)
1:     {
0:         Optional<Integer> coreConnections = getInputCoreConnections(conf);
0:         Optional<Integer> maxConnections = getInputMaxConnections(conf);
0:         Optional<Integer> maxSimultaneousRequests = getInputMaxSimultReqPerConnections(conf);
0:         Optional<Integer> minSimultaneousRequests = getInputMinSimultReqPerConnections(conf);
0:         
0:         PoolingOptions poolingOptions = new PoolingOptions();
0: 
0:         if (coreConnections.isPresent())
0:             poolingOptions.setCoreConnectionsPerHost(HostDistance.LOCAL, coreConnections.get());
0:         if (maxConnections.isPresent())
0:             poolingOptions.setMaxConnectionsPerHost(HostDistance.LOCAL, maxConnections.get());
0:         if (maxSimultaneousRequests.isPresent())
0:             poolingOptions.setMaxSimultaneousRequestsPerConnectionThreshold(HostDistance.LOCAL, maxSimultaneousRequests.get());
0:         if (minSimultaneousRequests.isPresent())
0:             poolingOptions.setMinSimultaneousRequestsPerConnectionThreshold(HostDistance.LOCAL, minSimultaneousRequests.get());
0: 
0:         poolingOptions.setCoreConnectionsPerHost(HostDistance.REMOTE, 0)
0:                       .setMaxConnectionsPerHost(HostDistance.REMOTE, 0)
0:                       .setMaxSimultaneousRequestsPerConnectionThreshold(HostDistance.REMOTE, 0)
0:                       .setMinSimultaneousRequestsPerConnectionThreshold(HostDistance.REMOTE, 0);
0: 
0:         return poolingOptions;
1:     }  
0: 
0:     private static QueryOptions getReadQueryOptions(Configuration conf)
1:     {
0:         String CL = ConfigHelper.getReadConsistencyLevel(conf);
0:         Optional<Integer> fetchSize = getInputPageRowSize(conf);
0:         QueryOptions queryOptions = new QueryOptions();
0:         if (CL != null && !CL.isEmpty())
0:             queryOptions.setConsistencyLevel(com.datastax.driver.core.ConsistencyLevel.valueOf(CL));
0: 
0:         if (fetchSize.isPresent())
0:             queryOptions.setFetchSize(fetchSize.get());
0:         return queryOptions;
1:     }
0: 
0:     private static SocketOptions getReadSocketOptions(Configuration conf)
1:     {
0:         SocketOptions socketOptions = new SocketOptions();
0:         Optional<Integer> connectTimeoutMillis = getInputNativeConnectionTimeout(conf);
0:         Optional<Integer> readTimeoutMillis = getInputNativeReadConnectionTimeout(conf);
0:         Optional<Integer> receiveBufferSize = getInputNativeReceiveBufferSize(conf);
0:         Optional<Integer> sendBufferSize = getInputNativeSendBufferSize(conf);
0:         Optional<Integer> soLinger = getInputNativeSolinger(conf);
0:         Optional<Boolean> tcpNoDelay = getInputNativeTcpNodelay(conf);
0:         Optional<Boolean> reuseAddress = getInputNativeReuseAddress(conf);       
0:         Optional<Boolean> keepAlive = getInputNativeKeepAlive(conf);
0: 
0:         if (connectTimeoutMillis.isPresent())
0:             socketOptions.setConnectTimeoutMillis(connectTimeoutMillis.get());
0:         if (readTimeoutMillis.isPresent())
0:             socketOptions.setReadTimeoutMillis(readTimeoutMillis.get());
0:         if (receiveBufferSize.isPresent())
0:             socketOptions.setReceiveBufferSize(receiveBufferSize.get());
0:         if (sendBufferSize.isPresent())
0:             socketOptions.setSendBufferSize(sendBufferSize.get());
0:         if (soLinger.isPresent())
0:             socketOptions.setSoLinger(soLinger.get());
0:         if (tcpNoDelay.isPresent())
0:             socketOptions.setTcpNoDelay(tcpNoDelay.get());
0:         if (reuseAddress.isPresent())
0:             socketOptions.setReuseAddress(reuseAddress.get());
0:         if (keepAlive.isPresent())
0:             socketOptions.setKeepAlive(keepAlive.get());     
0: 
0:         return socketOptions;
1:     }
0: 
0:     private static LoadBalancingPolicy getReadLoadBalancingPolicy(Configuration conf, final String stickHost)
1:     {
0:         return new LoadBalancingPolicy()
1:         {
0:             private Host origHost;
0:             private Set<Host> liveRemoteHosts = Sets.newHashSet();
0: 
0:             @Override
0:             public void onAdd(Host host)
1:             {
0:                 if (host.getAddress().getHostName().equals(stickHost))
0:                     origHost = host;
1:             }
0: 
0:             @Override
0:             public void onDown(Host host)
1:             {
0:                 if (host.getAddress().getHostName().equals(stickHost))
0:                     origHost = null;
0:                 liveRemoteHosts.remove(host);
1:             }
0: 
0:             @Override
0:             public void onRemove(Host host)
1:             {
0:                 if (host.getAddress().getHostName().equals(stickHost))
0:                     origHost = null;
0:                 liveRemoteHosts.remove(host);
1:             }
0: 
0:             @Override
0:             public void onUp(Host host)
1:             {
0:                 if (host.getAddress().getHostName().equals(stickHost))
0:                     origHost = host;
0:                 liveRemoteHosts.add(host);
1:             }
0: 
0:             @Override
0:             public HostDistance distance(Host host)
1:             {
0:                 if (host.getAddress().getHostName().equals(stickHost))
0:                     return HostDistance.LOCAL;
0:                 else
0:                     return HostDistance.REMOTE;
1:             }
0: 
0:             @Override
0:             public void init(Cluster cluster, Collection<Host> hosts)
1:             {
0:                 for (Host host : hosts)
1:                 {
0:                     if (host.getAddress().getHostName().equals(stickHost))
1:                     {
0:                         origHost = host;
0:                         break;
1:                     }
1:                 }
1:             }
0: 
0:             @Override
0:             public Iterator<Host> newQueryPlan(String loggedKeyspace, Statement statement)
1:             {
0:                 if (origHost != null)
1:                 {
0:                     return Iterators.concat(Collections.singletonList(origHost).iterator(), liveRemoteHosts.iterator());
1:                 }
0:                 else
1:                 {
0:                     return liveRemoteHosts.iterator();
1:                 }
1:             }
0:         };
1:     }
0: 
0:     private static Optional<AuthProvider> getAuthProvider(Configuration conf)
1:     {
0:         Optional<String> authProvider = getInputNativeAuthProvider(conf);
0:         if (!authProvider.isPresent())
0:             return Optional.absent();
0: 
0:         return Optional.of(getClientAuthProvider(authProvider.get()));  
1:     }
0: 
0:     private static Optional<SSLOptions> getSSLOptions(Configuration conf)
1:     {
0:         Optional<String> truststorePath = getInputNativeSSLTruststorePath(conf);
0:         Optional<String> keystorePath = getInputNativeSSLKeystorePath(conf);
0:         Optional<String> truststorePassword = getInputNativeSSLTruststorePassword(conf);
0:         Optional<String> keystorePassword = getInputNativeSSLKeystorePassword(conf);
0:         Optional<String> cipherSuites = getInputNativeSSLCipherSuites(conf);
0:         
0:         if (truststorePath.isPresent() && keystorePath.isPresent() && truststorePassword.isPresent() && keystorePassword.isPresent())
1:         {
0:             SSLContext context;
0:             try
1:             {
0:                 context = getSSLContext(truststorePath.get(), truststorePassword.get(), keystorePath.get(), keystorePassword.get());
1:             }
0:             catch (UnrecoverableKeyException | KeyManagementException |
0:                     NoSuchAlgorithmException | KeyStoreException | CertificateException | IOException e)
1:             {
0:                 throw new RuntimeException(e);
1:             }
0:             String[] css = SSLOptions.DEFAULT_SSL_CIPHER_SUITES;
0:             if (cipherSuites.isPresent())
0:                 css = cipherSuites.get().split(",");
0:             return Optional.of(new SSLOptions(context,css));
1:         }
0:         return Optional.absent();
1:     }
0: 
0:     private static Optional<Integer> getIntSetting(String parameter, Configuration conf)
1:     {
0:         String setting = conf.get(parameter);
0:         if (setting == null)
0:             return Optional.absent();
0:         return Optional.of(Integer.parseInt(setting));  
1:     }
0: 
0:     private static Optional<Boolean> getBooleanSetting(String parameter, Configuration conf)
1:     {
0:         String setting = conf.get(parameter);
0:         if (setting == null)
0:             return Optional.absent();
0:         return Optional.of(Boolean.parseBoolean(setting));  
1:     }
0: 
0:     private static Optional<String> getStringSetting(String parameter, Configuration conf)
1:     {
0:         String setting = conf.get(parameter);
0:         if (setting == null)
0:             return Optional.absent();
0:         return Optional.of(setting);  
1:     }
0: 
0:     private static AuthProvider getClientAuthProvider(String factoryClassName)
1:     {
0:         try
1:         {
0:             return (AuthProvider) Class.forName(factoryClassName).newInstance();
1:         }
0:         catch (Exception e)
1:         {
0:             throw new RuntimeException("Failed to instantiate auth provider:" + factoryClassName, e);
1:         }
1:     }
0: 
0:     private static SSLContext getSSLContext(String truststorePath, String truststorePassword, String keystorePath, String keystorePassword)
0:             throws NoSuchAlgorithmException, KeyStoreException, CertificateException, IOException, UnrecoverableKeyException, KeyManagementException
1:     {
0:         
0:         FileInputStream tsf = new FileInputStream(truststorePath);
0:         FileInputStream ksf = new FileInputStream(keystorePath);
0:         SSLContext ctx = SSLContext.getInstance("SSL");
0: 
0:         KeyStore ts = KeyStore.getInstance("JKS");
0:         ts.load(tsf, truststorePassword.toCharArray());
0:         TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
0:         tmf.init(ts);
0: 
0:         KeyStore ks = KeyStore.getInstance("JKS");
0:         ks.load(ksf, keystorePassword.toCharArray());
0:         KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
0:         kmf.init(ks, keystorePassword.toCharArray());
0: 
0:         ctx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new SecureRandom());
0:         return ctx;
1:     }
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:7aafe05
/////////////////////////////////////////////////////////////////////////
0:         try (FileInputStream tsf = new FileInputStream(truststorePath); FileInputStream ksf = new FileInputStream(keystorePath))
/////////////////////////////////////////////////////////////////////////
author:Philip Thompson
-------------------------------------------------------------------------------
commit:f698cc2
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.base.Optional;
1: import com.datastax.driver.core.PlainTextAuthProvider;
0: import com.datastax.driver.core.policies.LoadBalancingPolicy;
0: import org.apache.cassandra.hadoop.ConfigHelper;
0: import org.apache.cassandra.io.util.FileUtils;
1: import org.apache.hadoop.conf.Configuration;
0: 
/////////////////////////////////////////////////////////////////////////
1:     private static final String OUTPUT_NATIVE_PORT = "cassandra.output.native.port";
/////////////////////////////////////////////////////////////////////////
1:     public static int getOutputNativePort(Configuration conf)
0:     {
1:         return Integer.parseInt(conf.get(OUTPUT_NATIVE_PORT, "9042"));
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:         return getCluster(hosts, conf, port);
0:     }
0: 
1:     public static Cluster getOutputCluster(String host, Configuration conf)
0:     {
1:         return getOutputCluster(new String[]{host}, conf);
0:     }
0: 
1:     public static Cluster getOutputCluster(String[] hosts, Configuration conf)
0:     {
1:         int port = getOutputNativePort(conf);
1:         return getCluster(hosts, conf, port);
0:     }
0: 
1:     public static Cluster getCluster(String[] hosts, Configuration conf, int port)
0:     {
/////////////////////////////////////////////////////////////////////////
0: 
0:                 .addContactPoints(hosts)
0:                 .withPort(port)
0:                 .withCompression(ProtocolOptions.Compression.NONE);
/////////////////////////////////////////////////////////////////////////
0:                 .withSocketOptions(socketOptions)
0:                 .withQueryOptions(queryOptions)
0:                 .withPoolingOptions(poolingOptions);
/////////////////////////////////////////////////////////////////////////
1:     public static Optional<SSLOptions> getSSLOptions(Configuration conf)
author:Brandon Williams
-------------------------------------------------------------------------------
commit:42e483a
commit:1cb426b
/////////////////////////////////////////////////////////////////////////
1:     private static final String INPUT_NATIVE_PROTOCOL_VERSION = "cassandra.input.native.protocol.version";
0: 
/////////////////////////////////////////////////////////////////////////
0:     private static Optional<Integer> getProtocolVersion(Configuration conf) {
1:         return getIntSetting(INPUT_NATIVE_PROTOCOL_VERSION, conf);
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:         Optional<Integer> protocolVersion = getProtocolVersion(conf);
/////////////////////////////////////////////////////////////////////////
0:         if (protocolVersion.isPresent()) {
0:             builder.withProtocolVersion(protocolVersion.get());
0:         }
/////////////////////////////////////////////////////////////////////////
0: 
commit:44764c0
/////////////////////////////////////////////////////////////////////////
0:     
commit:1d744b5
commit:52df514
/////////////////////////////////////////////////////////////////////////
1:     private static final String INPUT_CQL_COLUMNS_CONFIG = "cassandra.input.columnfamily.columns";
commit:1e2a5b0
/////////////////////////////////////////////////////////////////////////
commit:0356ee7
/////////////////////////////////////////////////////////////////////////
1:     public static void setInputNativeSSLTruststorePath(Configuration conf, String path)
1:         conf.set(INPUT_NATIVE_SSL_TRUST_STORE_PATH, path);
1:     public static void setInputNativeSSLKeystorePath(Configuration conf, String path)
1:         conf.set(INPUT_NATIVE_SSL_KEY_STORE_PATH, path);
1:     public static void setInputNativeSSLKeystorePassword(Configuration conf, String pass)
1:         conf.set(INPUT_NATIVE_SSL_KEY_STORE_PASSWARD, pass);
1:     public static void setInputNativeSSLTruststorePassword(Configuration conf, String pass)
1:         conf.set(INPUT_NATIVE_SSL_TRUST_STORE_PASSWARD, pass);
1:     public static void setInputNativeSSLCipherSuites(Configuration conf, String suites)
1:         conf.set(INPUT_NATIVE_SSL_CIPHER_SUITES, suites);
commit:569177f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.commons.lang3.StringUtils;
0: import com.datastax.driver.core.PlainTextAuthProvider;
/////////////////////////////////////////////////////////////////////////
1:     private static final String USERNAME = "cassandra.username";
1:     private static final String PASSWORD = "cassandra.password";
0: 
/////////////////////////////////////////////////////////////////////////
1:     public static void setUserNameAndPassword(Configuration conf, String username, String password)
0:     {
1:         if (StringUtils.isNotBlank(username))
0:         {
1:             conf.set(INPUT_NATIVE_AUTH_PROVIDER, PlainTextAuthProvider.class.getName());
1:             conf.set(USERNAME, username);
1:             conf.set(PASSWORD, password);
0:         }
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:         return Optional.of(getClientAuthProvider(authProvider.get(), conf));
/////////////////////////////////////////////////////////////////////////
1:     private static AuthProvider getClientAuthProvider(String factoryClassName, Configuration conf)
1:             Class<?> c = Class.forName(factoryClassName);
1:             if (PlainTextAuthProvider.class.equals(c))
0:             {
1:                 String username = getStringSetting(USERNAME, conf).or("");
1:                 String password = getStringSetting(PASSWORD, conf).or("");
1:                 return (AuthProvider) c.getConstructor(String.class, String.class)
1:                         .newInstance(username, password);
0:             }
0:             else
0:             {
1:                 return (AuthProvider) c.newInstance();
0:             }
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:a004779
/////////////////////////////////////////////////////////////////////////
1: public class CqlConfigHelper
commit:56e0ad1
/////////////////////////////////////////////////////////////////////////
1: package org.apache.cassandra.hadoop.cql3;
1: /*
1: *
1: * Licensed to the Apache Software Foundation (ASF) under one
1: * or more contributor license agreements.  See the NOTICE file
1: * distributed with this work for additional information
1: * regarding copyright ownership.  The ASF licenses this file
1: * to you under the Apache License, Version 2.0 (the
1: * "License"); you may not use this file except in compliance
1: * with the License.  You may obtain a copy of the License at
1: *
1: *   http://www.apache.org/licenses/LICENSE-2.0
1: *
1: * Unless required by applicable law or agreed to in writing,
1: * software distributed under the License is distributed on an
1: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1: * KIND, either express or implied.  See the License for the
1: * specific language governing permissions and limitations
1: * under the License.
1: *
1: */
0: import org.apache.hadoop.conf.Configuration;
0: 
0: public class CQLConfigHelper
0: {
0:     private static final String INPUT_CQL_COLUMNS_CONFIG = "cassandra.input.columnfamily.columns"; // separate by colon ,
1:     private static final String INPUT_CQL_PAGE_ROW_SIZE_CONFIG = "cassandra.input.page.row.size";
1:     private static final String INPUT_CQL_WHERE_CLAUSE_CONFIG = "cassandra.input.where.clause";
1:     private static final String OUTPUT_CQL = "cassandra.output.cql";
0: 
1:     /**
1:      * Set the CQL columns for the input of this job.
1:      *
1:      * @param conf Job configuration you are about to run
1:      * @param columns
1:      */
1:     public static void setInputColumns(Configuration conf, String columns)
0:     {
1:         if (columns == null || columns.isEmpty())
1:             return;
0:         
1:         conf.set(INPUT_CQL_COLUMNS_CONFIG, columns);
0:     }
0:     
1:     /**
1:      * Set the CQL query Limit for the input of this job.
1:      *
1:      * @param conf Job configuration you are about to run
1:      * @param cqlPageRowSize
1:      */
1:     public static void setInputCQLPageRowSize(Configuration conf, String cqlPageRowSize)
0:     {
1:         if (cqlPageRowSize == null)
0:         {
1:             throw new UnsupportedOperationException("cql page row size may not be null");
0:         }
0: 
1:         conf.set(INPUT_CQL_PAGE_ROW_SIZE_CONFIG, cqlPageRowSize);
0:     }
0: 
1:     /**
1:      * Set the CQL user defined where clauses for the input of this job.
1:      *
1:      * @param conf Job configuration you are about to run
1:      * @param clauses
1:      */
1:     public static void setInputWhereClauses(Configuration conf, String clauses)
0:     {
1:         if (clauses == null || clauses.isEmpty())
1:             return;
0:         
1:         conf.set(INPUT_CQL_WHERE_CLAUSE_CONFIG, clauses);
0:     }
0:   
1:     /**
1:      * Set the CQL prepared statement for the output of this job.
1:      *
1:      * @param conf Job configuration you are about to run
1:      * @param cql
1:      */
1:     public static void setOutputCql(Configuration conf, String cql)
0:     {
0:         if (cql == null || cql.isEmpty())
1:             return;
0:         
1:         conf.set(OUTPUT_CQL, cql);
0:     }
0:     
0:     
1:     public static String getInputcolumns(Configuration conf)
0:     {
1:         return conf.get(INPUT_CQL_COLUMNS_CONFIG);
0:     }
0:     
0:     public static String getInputPageRowSize(Configuration conf)
0:     {
0:         return conf.get(INPUT_CQL_PAGE_ROW_SIZE_CONFIG);
0:     }
0:     
1:     public static String getInputWhereClauses(Configuration conf)
0:     {
1:         return conf.get(INPUT_CQL_WHERE_CLAUSE_CONFIG);
0:     }
0:     
1:     public static String getOutputCql(Configuration conf)
0:     {
1:         return conf.get(OUTPUT_CQL);
0:     }
0: }
============================================================================