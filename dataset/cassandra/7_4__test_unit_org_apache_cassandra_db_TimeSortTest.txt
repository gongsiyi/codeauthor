1:e425474: /*
1:e425474: * Licensed to the Apache Software Foundation (ASF) under one
1:e425474: * or more contributor license agreements.  See the NOTICE file
1:e425474: * distributed with this work for additional information
1:e425474: * regarding copyright ownership.  The ASF licenses this file
1:e425474: * to you under the Apache License, Version 2.0 (the
1:e425474: * "License"); you may not use this file except in compliance
1:e425474: * with the License.  You may obtain a copy of the License at
1:e425474: *
1:e425474: *    http://www.apache.org/licenses/LICENSE-2.0
1:e425474: *
1:e425474: * Unless required by applicable law or agreed to in writing,
1:e425474: * software distributed under the License is distributed on an
1:e425474: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:e425474: * KIND, either express or implied.  See the License for the
1:e425474: * specific language governing permissions and limitations
1:e425474: * under the License.
1:e425474: */
1:e425474: package org.apache.cassandra.db;
1:8358669: 
1:a991b64: import java.util.Iterator;
1:e425474: import org.junit.Test;
1:bf98ec9: 
1:a991b64: import org.apache.cassandra.cql3.CQLTester;
1:a991b64: import org.apache.cassandra.cql3.UntypedResultSet;
1:434564d: import org.apache.cassandra.Util;
10:e425474: 
1:a991b64: import static org.junit.Assert.assertEquals;
1:e425474: 
1:a991b64: public class TimeSortTest extends CQLTester
6:e425474: {
1:a991b64:     @Test
1:a991b64:     public void testMixedSources() throws Throwable
1:d2a3827:     {
1:a991b64:         String tableName = createTable("CREATE TABLE %s (a int, b int, c int, PRIMARY KEY (a, b))");
1:a991b64:         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(tableName);
1:a991b64: 
1:a991b64:         execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?) USING TIMESTAMP ?", 0, 100, 0, 100L);
1:a991b64:         cfs.forceBlockingFlush();
1:a991b64:         execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?) USING TIMESTAMP ?", 0, 0, 1, 0L);
1:a991b64: 
1:a991b64:         assertRows(execute("SELECT * FROM %s WHERE a = ? AND b >= ? LIMIT 1000", 0, 10), row(0, 100, 0));
1:d2a3827:     }
1:d2a3827: 
2:e425474:     @Test
1:a991b64:     public void testTimeSort() throws Throwable
1:e425474:     {
1:a991b64:         String tableName = createTable("CREATE TABLE %s (a int, b int, c int, PRIMARY KEY (a, b))");
1:a991b64:         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(tableName);
1:d2a3827: 
1:e425474:         for (int i = 900; i < 1000; ++i)
1:e425474:             for (int j = 0; j < 8; ++j)
1:a991b64:                 execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?) USING TIMESTAMP ?", i, j * 2, 0, (long)j * 2);
1:cba59a8: 
1:a991b64:         validateTimeSort();
1:a991b64:         cfs.forceBlockingFlush();
1:a991b64:         validateTimeSort();
1:e425474: 
1:e425474:         // interleave some new data to test memtable + sstable
1:434564d:         DecoratedKey key = Util.dk("900");
1:e425474:         for (int j = 0; j < 4; ++j)
1:a991b64:             execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?) USING TIMESTAMP ?", 900, j * 2 + 1, 1, (long)j * 2 + 1);
1:a991b64: 
1:e425474:         // and some overwrites
1:a991b64:         execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?) USING TIMESTAMP ?", 900, 0, 2, 100L);
1:a991b64:         execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?) USING TIMESTAMP ?", 900, 10, 2, 100L);
1:e425474: 
1:e425474:         // verify
1:a991b64:         UntypedResultSet results = execute("SELECT * FROM %s WHERE a = ? AND b >= ? LIMIT 1000", 900, 0);
1:a991b64:         assertEquals(12, results.size());
1:a991b64:         Iterator<UntypedResultSet.Row> iter = results.iterator();
1:e425474:         for (int j = 0; j < 8; j++)
1:e425474:         {
1:a991b64:             UntypedResultSet.Row row = iter.next();
1:a991b64:             assertEquals(j, row.getInt("b"));
6:e425474:         }
1:a991b64: 
1:a991b64:         assertRows(execute("SELECT * FROM %s WHERE a = ? AND b IN (?, ?)", 900, 0, 10),
1:a991b64:                 row(900, 0, 2),
1:a991b64:                 row(900, 10, 2));
1:e425474:     }
1:e425474: 
1:a991b64:     private void validateTimeSort() throws Throwable
1:e425474:     {
1:e425474:         for (int i = 900; i < 1000; ++i)
1:e425474:         {
1:e425474:             for (int j = 0; j < 8; j += 3)
1:e425474:             {
1:a991b64:                 UntypedResultSet results = execute("SELECT writetime(c) AS wt FROM %s WHERE a = ? AND b >= ? LIMIT 1000", i, j * 2);
1:a991b64:                 assertEquals(8 - j, results.size());
1:e425474:                 int k = j;
1:a991b64:                 for (UntypedResultSet.Row row : results)
1:a991b64:                     assertEquals((k++) * 2, row.getLong("wt"));
1:e425474:             }
1:e425474:         }
1:e425474:     }
1:e425474: }
============================================================================
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: import java.util.Iterator;
1: import org.apache.cassandra.cql3.CQLTester;
1: import org.apache.cassandra.cql3.UntypedResultSet;
1: import static org.junit.Assert.assertEquals;
1: public class TimeSortTest extends CQLTester
1:     @Test
1:     public void testMixedSources() throws Throwable
1:         String tableName = createTable("CREATE TABLE %s (a int, b int, c int, PRIMARY KEY (a, b))");
1:         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(tableName);
1: 
1:         execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?) USING TIMESTAMP ?", 0, 100, 0, 100L);
1:         cfs.forceBlockingFlush();
1:         execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?) USING TIMESTAMP ?", 0, 0, 1, 0L);
1: 
1:         assertRows(execute("SELECT * FROM %s WHERE a = ? AND b >= ? LIMIT 1000", 0, 10), row(0, 100, 0));
1:     public void testTimeSort() throws Throwable
1:         String tableName = createTable("CREATE TABLE %s (a int, b int, c int, PRIMARY KEY (a, b))");
1:         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(tableName);
1:                 execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?) USING TIMESTAMP ?", i, j * 2, 0, (long)j * 2);
1:         validateTimeSort();
1:         cfs.forceBlockingFlush();
1:         validateTimeSort();
1:             execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?) USING TIMESTAMP ?", 900, j * 2 + 1, 1, (long)j * 2 + 1);
1: 
1:         execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?) USING TIMESTAMP ?", 900, 0, 2, 100L);
1:         execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?) USING TIMESTAMP ?", 900, 10, 2, 100L);
1:         UntypedResultSet results = execute("SELECT * FROM %s WHERE a = ? AND b >= ? LIMIT 1000", 900, 0);
1:         assertEquals(12, results.size());
1:         Iterator<UntypedResultSet.Row> iter = results.iterator();
1:             UntypedResultSet.Row row = iter.next();
1:             assertEquals(j, row.getInt("b"));
1: 
1:         assertRows(execute("SELECT * FROM %s WHERE a = ? AND b IN (?, ?)", 900, 0, 10),
1:                 row(900, 0, 2),
1:                 row(900, 10, 2));
1:     private void validateTimeSort() throws Throwable
1:                 UntypedResultSet results = execute("SELECT writetime(c) AS wt FROM %s WHERE a = ? AND b >= ? LIMIT 1000", i, j * 2);
1:                 assertEquals(8 - j, results.size());
1:                 for (UntypedResultSet.Row row : results)
1:                     assertEquals((k++) * 2, row.getLong("wt"));
commit:e50d6af
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         Collection<Cell> cells = cf.getSortedColumns();
0:         assert cells.size() == 1;
/////////////////////////////////////////////////////////////////////////
0:         Collection<Cell> cells = cf.getSortedColumns();
0:         assertEquals(12, cells.size());
0:         Iterator<Cell> iter = cells.iterator();
0:         Cell cell;
0:             cell = iter.next();
0:             assert cell.name().toByteBuffer().equals(getBytes(j));
/////////////////////////////////////////////////////////////////////////
0:                 Collection<Cell> cells = cf.getSortedColumns();
0:                 assert cells.size() == 8 - j;
0:                 for (Cell c : cells)
commit:362cc05
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.cassandra.Util.cellname;
0: import org.apache.cassandra.db.composites.*;
/////////////////////////////////////////////////////////////////////////
0:         rm.add("StandardLong1", cellname(100), ByteBufferUtil.bytes("a"), 100);
0:         rm.add("StandardLong1", cellname(0), ByteBufferUtil.bytes("b"), 0);
0:         ColumnFamily cf = cfStore.getColumnFamily(key, cellname(10), Composites.EMPTY, false, 1000, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:                 rm.add("StandardLong1", cellname(j * 2), ByteBufferUtil.bytes("a"), j * 2);
/////////////////////////////////////////////////////////////////////////
0:             rm.add("StandardLong1", cellname(j * 2 + 1), ByteBufferUtil.bytes("b"), j * 2 + 1);
0:         rm.add("StandardLong1", cellname(0), ByteBufferUtil.bytes("c"), 100);
0:         rm.add("StandardLong1", cellname(10), ByteBufferUtil.bytes("c"), 100);
0:         ColumnFamily cf = cfStore.getColumnFamily(key, cellname(0), Composites.EMPTY, false, 1000, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:             assert column.name().toByteBuffer().equals(getBytes(j));
0:         TreeSet<CellName> columnNames = new TreeSet<CellName>(cfStore.getComparator());
0:         columnNames.add(cellname(10));
0:         columnNames.add(cellname(0));
0:         assert "c".equals(ByteBufferUtil.string(cf.getColumn(cellname(0)).value()));
0:         assert "c".equals(ByteBufferUtil.string(cf.getColumn(cellname(10)).value()));
/////////////////////////////////////////////////////////////////////////
0:                 ColumnFamilyStore cfs = keyspace.getColumnFamilyStore("StandardLong1");
0:                 ColumnFamily cf = cfs.getColumnFamily(key, cellname(j * 2), Composites.EMPTY, false, 1000, System.currentTimeMillis());
commit:3a005df
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         rm.add("StandardLong1", getBytes(100), ByteBufferUtil.bytes("a"), 100);
0:         rm.add("StandardLong1", getBytes(0), ByteBufferUtil.bytes("b"), 0);
0:         ColumnFamily cf = cfStore.getColumnFamily(key, getBytes(10), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 1000);
0:         Collection<Column> columns = cf.getSortedColumns();
/////////////////////////////////////////////////////////////////////////
0:                 rm.add("StandardLong1", getBytes(j * 2), ByteBufferUtil.bytes("a"), j * 2);
/////////////////////////////////////////////////////////////////////////
0:             rm.add("StandardLong1", getBytes(j * 2 + 1), ByteBufferUtil.bytes("b"), j * 2 + 1);
0:         rm.add("StandardLong1", getBytes(0), ByteBufferUtil.bytes("c"), 100);
0:         rm.add("StandardLong1", getBytes(10), ByteBufferUtil.bytes("c"), 100);
0:         ColumnFamily cf = cfStore.getColumnFamily(key, getBytes(0), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 1000);
0:         Collection<Column> columns = cf.getSortedColumns();
0:         Iterator<Column> iter = columns.iterator();
0:         Column column;
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(Util.dk("900"), "StandardLong1", columnNames));
/////////////////////////////////////////////////////////////////////////
0:                 ColumnFamily cf = table.getColumnFamilyStore("StandardLong1").getColumnFamily(key, getBytes(j * 2), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 1000);
0:                 Collection<Column> columns = cf.getSortedColumns();
0:                 for (Column c : columns)
commit:438acfc
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.SchemaLoader;
/////////////////////////////////////////////////////////////////////////
0: public class TimeSortTest extends SchemaLoader
commit:b62b0ae
/////////////////////////////////////////////////////////////////////////
0:             RowMutation rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes(Integer.toString(i)));
author:lyubent
-------------------------------------------------------------------------------
commit:b453f08
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe();
0:         rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:             rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe();
0:         rm.applyUnsafe();
commit:d2a3827
/////////////////////////////////////////////////////////////////////////
0: import org.junit.BeforeClass;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.KSMetaData;
0: import org.apache.cassandra.exceptions.ConfigurationException;
0: import org.apache.cassandra.locator.SimpleStrategy;
0: public class TimeSortTest
0:     private static final String KEYSPACE1 = "TimeSortTest";
0:     private static final String CF_STANDARD1 = "StandardLong1";
1: 
0:     @BeforeClass
0:     public static void defineSchema() throws ConfigurationException
1:     {
0:         SchemaLoader.prepareServer();
0:         SchemaLoader.createKeyspace(KEYSPACE1,
0:                                     SimpleStrategy.class,
0:                                     KSMetaData.optsWithRF(1),
0:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD1));
1:     }
1: 
0:         Keyspace keyspace = Keyspace.open(KEYSPACE1);
0:         ColumnFamilyStore cfStore = keyspace.getColumnFamilyStore(CF_STANDARD1);
0:         rm = new Mutation(KEYSPACE1, key.getKey());
0:         rm.add(CF_STANDARD1, cellname(100), ByteBufferUtil.bytes("a"), 100);
0:         rm = new Mutation(KEYSPACE1, key.getKey());
0:         rm.add(CF_STANDARD1, cellname(0), ByteBufferUtil.bytes("b"), 0);
/////////////////////////////////////////////////////////////////////////
0:         Keyspace keyspace = Keyspace.open(KEYSPACE1);
0:         ColumnFamilyStore cfStore = keyspace.getColumnFamilyStore(CF_STANDARD1);
0:             Mutation rm = new Mutation(KEYSPACE1, ByteBufferUtil.bytes(Integer.toString(i)));
0:                 rm.add(CF_STANDARD1, cellname(j * 2), ByteBufferUtil.bytes("a"), j * 2);
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation(KEYSPACE1, key.getKey());
0:             rm.add(CF_STANDARD1, cellname(j * 2 + 1), ByteBufferUtil.bytes("b"), j * 2 + 1);
0:         rm = new Mutation(KEYSPACE1, key.getKey());
0:         rm.add(CF_STANDARD1, cellname(0), ByteBufferUtil.bytes("c"), 100);
0:         rm.add(CF_STANDARD1, cellname(10), ByteBufferUtil.bytes("c"), 100);
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(Util.dk("900"), CF_STANDARD1, columnNames, System.currentTimeMillis()));
/////////////////////////////////////////////////////////////////////////
0:                 ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(CF_STANDARD1);
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:8541cca
/////////////////////////////////////////////////////////////////////////
0:         rm = new Mutation("Keyspace1", key.getKey());
0:         rm = new Mutation("Keyspace1", key.getKey());
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation("Keyspace1", key.getKey());
0:         rm = new Mutation("Keyspace1", key.getKey());
author:Dave Brosius
-------------------------------------------------------------------------------
commit:9639f95
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public void testMixedSources()
/////////////////////////////////////////////////////////////////////////
0:     public void testTimeSort() throws IOException
/////////////////////////////////////////////////////////////////////////
0:     private void validateTimeSort(Keyspace keyspace)
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:6bbb13b
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm;
0:         rm = new Mutation("Keyspace1", key.key);
0:         rm = new Mutation("Keyspace1", key.key);
/////////////////////////////////////////////////////////////////////////
0:             Mutation rm = new Mutation("Keyspace1", ByteBufferUtil.bytes(Integer.toString(i)));
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation("Keyspace1", key.key);
0:         rm = new Mutation("Keyspace1", key.key);
commit:0e96e58
/////////////////////////////////////////////////////////////////////////
0:         Keyspace keyspace = Keyspace.open("Keyspace1");
0:         ColumnFamilyStore cfStore = keyspace.getColumnFamilyStore("StandardLong1");
/////////////////////////////////////////////////////////////////////////
0:         Keyspace keyspace = Keyspace.open("Keyspace1");
0:         ColumnFamilyStore cfStore = keyspace.getColumnFamilyStore("StandardLong1");
/////////////////////////////////////////////////////////////////////////
0:         validateTimeSort(keyspace);
0:         validateTimeSort(keyspace);
/////////////////////////////////////////////////////////////////////////
0:     private void validateTimeSort(Keyspace keyspace) throws IOException
0:                 ColumnFamily cf = keyspace.getColumnFamilyStore("StandardLong1").getColumnFamily(key,
0:                                                                                                  getBytes(j * 2),
0:                                                                                                  ByteBufferUtil.EMPTY_BYTE_BUFFER,
0:                                                                                                  false,
0:                                                                                                  1000,
0:                                                                                                  System.currentTimeMillis());
commit:1f7628c
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = cfStore.getColumnFamily(key, getBytes(10), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 1000, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = cfStore.getColumnFamily(key, getBytes(0), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 1000, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(Util.dk("900"), "StandardLong1", columnNames, System.currentTimeMillis()));
/////////////////////////////////////////////////////////////////////////
0:                 ColumnFamily cf = table.getColumnFamilyStore("StandardLong1").getColumnFamily(key,
0:                                                                                               getBytes(j * 2),
0:                                                                                               ByteBufferUtil.EMPTY_BYTE_BUFFER,
0:                                                                                               false,
0:                                                                                               1000,
0:                                                                                               System.currentTimeMillis());
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:b95a49c
/////////////////////////////////////////////////////////////////////////
0:         assert "c".equals(ByteBufferUtil.string(cf.getColumn(getBytes(0)).value()));
0:         assert "c".equals(ByteBufferUtil.string(cf.getColumn(getBytes(10)).value()));
commit:43d330d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = cfStore.getColumnFamily(key, new QueryPath("StandardLong1"), getBytes(10), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 1000);
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = cfStore.getColumnFamily(key, new QueryPath("StandardLong1"), getBytes(0), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 1000);
/////////////////////////////////////////////////////////////////////////
0:                 ColumnFamily cf = table.getColumnFamilyStore("StandardLong1").getColumnFamily(key, new QueryPath("StandardLong1"), getBytes(j * 2), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 1000);
commit:8358669
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.ByteBufferUtil;
1: 
/////////////////////////////////////////////////////////////////////////
0:         rm.add(new QueryPath("StandardLong1", null, getBytes(100)), ByteBufferUtil.bytes("a"), 100);
0:         rm.add(new QueryPath("StandardLong1", null, getBytes(0)), ByteBufferUtil.bytes("b"), 0);
/////////////////////////////////////////////////////////////////////////
0:                 rm.add(new QueryPath("StandardLong1", null, getBytes(j * 2)), ByteBufferUtil.bytes("a"), j * 2);
/////////////////////////////////////////////////////////////////////////
0:             rm.add(new QueryPath("StandardLong1", null, getBytes(j * 2 + 1)), ByteBufferUtil.bytes("b"), j * 2 + 1);
0:         rm.add(new QueryPath("StandardLong1", null, getBytes(0)), ByteBufferUtil.bytes("c"), 100);
0:         rm.add(new QueryPath("StandardLong1", null, getBytes(10)), ByteBufferUtil.bytes("c"), 100);
commit:e7a385a
/////////////////////////////////////////////////////////////////////////
0: import java.nio.ByteBuffer;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.FBUtilities;
/////////////////////////////////////////////////////////////////////////
0:         rm.add(new QueryPath("StandardLong1", null, getBytes(100)), ByteBuffer.wrap("a".getBytes()), 100);
0:         rm.add(new QueryPath("StandardLong1", null, getBytes(0)), ByteBuffer.wrap("b".getBytes()), 0);
0:         ColumnFamily cf = cfStore.getColumnFamily(key, new QueryPath("StandardLong1"), getBytes(10), FBUtilities.EMPTY_BYTE_BUFFER, false, 1000);
/////////////////////////////////////////////////////////////////////////
0:             RowMutation rm = new RowMutation("Keyspace1", ByteBuffer.wrap(Integer.toString(i).getBytes()));
0:                 rm.add(new QueryPath("StandardLong1", null, getBytes(j * 2)), ByteBuffer.wrap("a".getBytes()), j * 2);
/////////////////////////////////////////////////////////////////////////
0:             rm.add(new QueryPath("StandardLong1", null, getBytes(j * 2 + 1)), ByteBuffer.wrap("b".getBytes()), j * 2 + 1);
0:         rm.add(new QueryPath("StandardLong1", null, getBytes(0)), ByteBuffer.wrap("c".getBytes()), 100);
0:         rm.add(new QueryPath("StandardLong1", null, getBytes(10)), ByteBuffer.wrap("c".getBytes()), 100);
0:         ColumnFamily cf = cfStore.getColumnFamily(key, new QueryPath("StandardLong1"), getBytes(0), FBUtilities.EMPTY_BYTE_BUFFER, false, 1000);
/////////////////////////////////////////////////////////////////////////
0:             assert column.name().equals(getBytes(j));
0:         TreeSet<ByteBuffer> columnNames = new TreeSet<ByteBuffer>(LongType.instance);
0:         assert "c".equals(new String(cf.getColumn(getBytes(0)).value().array()));
0:         assert "c".equals(new String(cf.getColumn(getBytes(10)).value().array()));
/////////////////////////////////////////////////////////////////////////
0:                 ColumnFamily cf = table.getColumnFamilyStore("StandardLong1").getColumnFamily(key, new QueryPath("StandardLong1"), getBytes(j * 2), FBUtilities.EMPTY_BYTE_BUFFER, false, 1000);
commit:9d32382
/////////////////////////////////////////////////////////////////////////
0:         rm.add(new QueryPath("StandardLong1", null, getBytes(100)), "a".getBytes(), 100);
0:         rm.add(new QueryPath("StandardLong1", null, getBytes(0)), "b".getBytes(), 0);
/////////////////////////////////////////////////////////////////////////
0:                 rm.add(new QueryPath("StandardLong1", null, getBytes(j * 2)), "a".getBytes(), j * 2);
/////////////////////////////////////////////////////////////////////////
0:             rm.add(new QueryPath("StandardLong1", null, getBytes(j * 2 + 1)), "b".getBytes(), j * 2 + 1);
0:         rm.add(new QueryPath("StandardLong1", null, getBytes(0)), "c".getBytes(), 100);
0:         rm.add(new QueryPath("StandardLong1", null, getBytes(10)), "c".getBytes(), 100);
/////////////////////////////////////////////////////////////////////////
0:                     assertEquals((k++) * 2, c.timestamp());
commit:242b717
/////////////////////////////////////////////////////////////////////////
0:         TreeSet<byte[]> columnNames = new TreeSet<byte[]>(LongType.instance);
commit:cba59a8
/////////////////////////////////////////////////////////////////////////
0:         rm.add(new QueryPath("StandardLong1", null, getBytes(100)), "a".getBytes(), new TimestampClock(100));
0:         rm.add(new QueryPath("StandardLong1", null, getBytes(0)), "b".getBytes(), new TimestampClock(0));
/////////////////////////////////////////////////////////////////////////
0:                 rm.add(new QueryPath("StandardLong1", null, getBytes(j * 2)), "a".getBytes(), new TimestampClock(j * 2));
/////////////////////////////////////////////////////////////////////////
0:             rm.add(new QueryPath("StandardLong1", null, getBytes(j * 2 + 1)), "b".getBytes(), new TimestampClock(j * 2 + 1));
0:         rm.add(new QueryPath("StandardLong1", null, getBytes(0)), "c".getBytes(), new TimestampClock(100));
0:         rm.add(new QueryPath("StandardLong1", null, getBytes(10)), "c".getBytes(), new TimestampClock(100));
/////////////////////////////////////////////////////////////////////////
0:                     assertEquals((k++) * 2, ((TimestampClock)c.clock()).timestamp());
1: 
commit:bf98ec9
/////////////////////////////////////////////////////////////////////////
1: 
0: import org.apache.cassandra.db.filter.QueryFilter;
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter("900", new QueryPath("StandardLong1"), columnNames));
commit:6b7a1c3
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = cfStore.getColumnFamily("key0", new QueryPath("StandardLong1"), getBytes(10), ArrayUtils.EMPTY_BYTE_ARRAY, false, 1000);
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = cfStore.getColumnFamily(key, new QueryPath("StandardLong1"), getBytes(0), ArrayUtils.EMPTY_BYTE_ARRAY, false, 1000);
/////////////////////////////////////////////////////////////////////////
0:                 ColumnFamily cf = table.getColumnFamilyStore("StandardLong1").getColumnFamily(key, new QueryPath("StandardLong1"), getBytes(j * 2), ArrayUtils.EMPTY_BYTE_ARRAY, false, 1000);
commit:572b5f8
/////////////////////////////////////////////////////////////////////////
0:         Table table = Table.open("Keyspace1");
0:         rm = new RowMutation("Keyspace1", "key0");
0:         rm = new RowMutation("Keyspace1", "key0");
/////////////////////////////////////////////////////////////////////////
0:         Table table = Table.open("Keyspace1");
0:             RowMutation rm = new RowMutation("Keyspace1", Integer.toString(i));
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", key);
0:         rm = new RowMutation("Keyspace1", key);
commit:e425474
/////////////////////////////////////////////////////////////////////////
1: /*
1: * Licensed to the Apache Software Foundation (ASF) under one
1: * or more contributor license agreements.  See the NOTICE file
1: * distributed with this work for additional information
1: * regarding copyright ownership.  The ASF licenses this file
1: * to you under the Apache License, Version 2.0 (the
1: * "License"); you may not use this file except in compliance
1: * with the License.  You may obtain a copy of the License at
1: *
1: *    http://www.apache.org/licenses/LICENSE-2.0
1: *
1: * Unless required by applicable law or agreed to in writing,
1: * software distributed under the License is distributed on an
1: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1: * KIND, either express or implied.  See the License for the
1: * specific language governing permissions and limitations
1: * under the License.
1: */
1: package org.apache.cassandra.db;
1: 
0: import java.io.IOException;
0: import java.util.concurrent.ExecutionException;
0: import java.util.*;
1: 
0: import org.apache.commons.lang.ArrayUtils;
1: import org.junit.Test;
0: import static org.junit.Assert.assertEquals;
1: 
0: import org.apache.cassandra.CleanupHelper;
0: import static org.apache.cassandra.Util.getBytes;
0: import org.apache.cassandra.db.filter.QueryPath;
0: import org.apache.cassandra.db.filter.NamesQueryFilter;
0: import org.apache.cassandra.db.marshal.LongType;
1: 
0: public class TimeSortTest extends CleanupHelper
1: {
1:     @Test
0:     public void testMixedSources() throws IOException, ExecutionException, InterruptedException
1:     {
0:         Table table = Table.open("Table1");
0:         ColumnFamilyStore cfStore = table.getColumnFamilyStore("StandardLong1");
0:         RowMutation rm;
1: 
0:         rm = new RowMutation("Table1", "key0");
0:         rm.add(new QueryPath("StandardLong1", null, getBytes(100)), "a".getBytes(), 100);
0:         rm.apply();
0:         cfStore.forceBlockingFlush();
1: 
0:         rm = new RowMutation("Table1", "key0");
0:         rm.add(new QueryPath("StandardLong1", null, getBytes(0)), "b".getBytes(), 0);
0:         rm.apply();
1: 
0:         ColumnFamily cf = cfStore.getColumnFamily("key0", new QueryPath("StandardLong1"), getBytes(10), ArrayUtils.EMPTY_BYTE_ARRAY, true, 1000);
0:         Collection<IColumn> columns = cf.getSortedColumns();
0:         assert columns.size() == 1;
1:     }
1: 
1:     @Test
0:     public void testTimeSort() throws IOException, ExecutionException, InterruptedException
1:     {
0:         Table table = Table.open("Table1");
0:         ColumnFamilyStore cfStore = table.getColumnFamilyStore("StandardLong1");
1: 
1:         for (int i = 900; i < 1000; ++i)
1:         {
0:             RowMutation rm = new RowMutation("Table1", Integer.toString(i));
1:             for (int j = 0; j < 8; ++j)
1:             {
0:                 rm.add(new QueryPath("StandardLong1", null, getBytes(j * 2)), "a".getBytes(), j * 2);
1:             }
0:             rm.apply();
1:         }
1: 
0:         validateTimeSort(table);
1: 
0:         cfStore.forceBlockingFlush();
0:         validateTimeSort(table);
1: 
1:         // interleave some new data to test memtable + sstable
0:         String key = "900";
0:         RowMutation rm = new RowMutation("Table1", key);
1:         for (int j = 0; j < 4; ++j)
1:         {
0:             rm.add(new QueryPath("StandardLong1", null, getBytes(j * 2 + 1)), "b".getBytes(), j * 2 + 1);
1:         }
0:         rm.apply();
1:         // and some overwrites
0:         rm = new RowMutation("Table1", key);
0:         rm.add(new QueryPath("StandardLong1", null, getBytes(0)), "c".getBytes(), 100);
0:         rm.add(new QueryPath("StandardLong1", null, getBytes(10)), "c".getBytes(), 100);
0:         rm.apply();
1: 
1:         // verify
0:         ColumnFamily cf = cfStore.getColumnFamily(key, new QueryPath("StandardLong1"), getBytes(0), ArrayUtils.EMPTY_BYTE_ARRAY, true, 1000);
0:         Collection<IColumn> columns = cf.getSortedColumns();
0:         assertEquals(12, columns.size());
0:         Iterator<IColumn> iter = columns.iterator();
0:         IColumn column;
1:         for (int j = 0; j < 8; j++)
1:         {
0:             column = iter.next();
0:             assert Arrays.equals(column.name(), getBytes(j));
1:         }
0:         TreeSet<byte[]> columnNames = new TreeSet<byte[]>(new LongType());
0:         columnNames.add(getBytes(10));
0:         columnNames.add(getBytes(0));
0:         cf = cfStore.getColumnFamily(new NamesQueryFilter("900", new QueryPath("StandardLong1"), columnNames));
0:         assert "c".equals(new String(cf.getColumn(getBytes(0)).value()));
0:         assert "c".equals(new String(cf.getColumn(getBytes(10)).value()));
1:     }
1: 
0:     private void validateTimeSort(Table table) throws IOException
1:     {
1:         for (int i = 900; i < 1000; ++i)
1:         {
0:             String key = Integer.toString(i);
1:             for (int j = 0; j < 8; j += 3)
1:             {
0:                 ColumnFamily cf = table.getColumnFamilyStore("StandardLong1").getColumnFamily(key, new QueryPath("StandardLong1"), getBytes(j * 2), ArrayUtils.EMPTY_BYTE_ARRAY, true, 1000);
0:                 Collection<IColumn> columns = cf.getSortedColumns();
0:                 assert columns.size() == 8 - j;
1:                 int k = j;
0:                 for (IColumn c : columns)
1:                 {
0:                     assertEquals((k++) * 2, c.timestamp());
1:                 }
1:             }
1:         }
1:     }
1: }
commit:8ff63a9
/////////////////////////////////////////////////////////////////////////
commit:f2da00f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.filter.QueryPath;
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamilyStore cfStore = table.getColumnFamilyStore("StandardByTime1");
0:         rm.add(new QueryPath("StandardByTime1", null, "C0"), "a".getBytes(), 100);
0:         cfStore.forceBlockingFlush();
0:         rm.add(new QueryPath("StandardByTime1", null, "C1"), "b".getBytes(), 0);
0:         ColumnFamily cf = cfStore.getColumnFamily("key0", new QueryPath("StandardByTime1"), 10);
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamilyStore cfStore = table.getColumnFamilyStore("StandardByTime1");
/////////////////////////////////////////////////////////////////////////
0:                 rm.add(new QueryPath("StandardByTime1", null, "Column-" + j), bytes, j * 2);
0:         cfStore.forceBlockingFlush();
/////////////////////////////////////////////////////////////////////////
0:             rm.add(new QueryPath("StandardByTime1", null, "Column+" + j), ArrayUtils.EMPTY_BYTE_ARRAY, j * 2 + 1);
0:             rm.add(new QueryPath("StandardByTime1", null, "Column-" + j), ArrayUtils.EMPTY_BYTE_ARRAY, j * 3);
0:         ColumnFamily cf = cfStore.getColumnFamily(key, new QueryPath("StandardByTime1"), 0);
/////////////////////////////////////////////////////////////////////////
0:                 ColumnFamily cf = table.getColumnFamilyStore("StandardByTime1").getColumnFamily(key, new QueryPath("StandardByTime1"), j * 2);
commit:479c1a4
/////////////////////////////////////////////////////////////////////////
0:     public void testMixedSources() throws IOException, ExecutionException, InterruptedException
0:     {
0:         Table table = Table.open("Table1");
0:         RowMutation rm;
0: 
0:         rm = new RowMutation("Table1", "key0");
0:         rm.add("StandardByTime1:C0", "a".getBytes(), 100);
0:         rm.apply();
0:         table.getColumnFamilyStore("StandardByTime1").forceBlockingFlush();
0: 
0:         rm = new RowMutation("Table1", "key0");
0:         rm.add("StandardByTime1:C1", "b".getBytes(), 0);
0:         rm.apply();
0: 
0:         Row row = table.getRow("key0", "StandardByTime1", 10);
0:         assert !row.isEmpty();
0:         ColumnFamily cf = row.getColumnFamilies().iterator().next();
0:         SortedSet<IColumn> columns = cf.getAllColumns();
0:         assert columns.size() == 1;
0:     }
0: 
0:     @Test
commit:16306e0
/////////////////////////////////////////////////////////////////////////
0:             RowMutation rm = new RowMutation("Table1", key);
0:             rm.apply();
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Table1", key);
0:         rm.apply();
0:         rm = new RowMutation("Table1", key);
0:         rm.apply();
commit:72e6eea
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.CleanupHelper;
0: 
0: public class TimeSortTest extends CleanupHelper
/////////////////////////////////////////////////////////////////////////
0:                 byte[] bytes = j % 2 == 0 ? "a".getBytes() : "b".getBytes();
commit:88edbed
/////////////////////////////////////////////////////////////////////////
0: /*
0: * Licensed to the Apache Software Foundation (ASF) under one
0: * or more contributor license agreements.  See the NOTICE file
0: * distributed with this work for additional information
0: * regarding copyright ownership.  The ASF licenses this file
0: * to you under the Apache License, Version 2.0 (the
0: * "License"); you may not use this file except in compliance
0: * with the License.  You may obtain a copy of the License at
0: *
0: *    http://www.apache.org/licenses/LICENSE-2.0
0: *
0: * Unless required by applicable law or agreed to in writing,
0: * software distributed under the License is distributed on an
0: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0: * KIND, either express or implied.  See the License for the
0: * specific language governing permissions and limitations
0: * under the License.
0: */
commit:5964cd4
/////////////////////////////////////////////////////////////////////////
0: package org.apache.cassandra.db;
0: 
0: import java.io.IOException;
0: import java.util.concurrent.ExecutionException;
0: import java.util.SortedSet;
0: import java.util.Iterator;
0: 
0: import org.apache.commons.lang.ArrayUtils;
0: import org.junit.Test;
0: 
0: public class TimeSortTest extends ColumnFamilyStoreTest
0: {
0:     @Test
0:     public void testTimeSort() throws IOException, ExecutionException, InterruptedException
0:     {
0:         Table table = Table.open("Table1");
0: 
0:         for (int i = 900; i < 1000; ++i)
0:         {
0:             String key = Integer.toString(i);
0:             RowMutation rm;
0:             for (int j = 0; j < 8; ++j)
0:             {
0:                 byte[] bytes = j % 2 == 0 ? bytes1 : bytes2;
0:                 rm = new RowMutation("Table1", key);
0:                 rm.add("StandardByTime1:" + "Column-" + j, bytes, j * 2);
0:                 rm.apply();
0:             }
0:         }
0: 
0:         validateTimeSort(table);
0: 
0:         table.getColumnFamilyStore("StandardByTime1").forceBlockingFlush();
0:         validateTimeSort(table);
0: 
0:         // interleave some new data to test memtable + sstable
0:         String key = "900";
0:         RowMutation rm;
0:         for (int j = 0; j < 4; ++j)
0:         {
0:             rm = new RowMutation("Table1", key);
0:             rm.add("StandardByTime1:" + "Column+" + j, ArrayUtils.EMPTY_BYTE_ARRAY, j * 2 + 1);
0:             rm.apply();
0:         }
0:         // and some overwrites
0:         for (int j = 4; j < 8; ++j)
0:         {
0:             rm = new RowMutation("Table1", key);
0:             rm.add("StandardByTime1:" + "Column-" + j, ArrayUtils.EMPTY_BYTE_ARRAY, j * 3);
0:             rm.apply();
0:         }
0:         // verify
0:         ColumnFamily cf = table.getRow(key, "StandardByTime1", 0).getColumnFamilies().iterator().next();
0:         SortedSet<IColumn> columns = cf.getAllColumns();
0:         assert columns.size() == 12;
0:         Iterator<IColumn> iter = columns.iterator();
0:         IColumn column;
0:         for (int j = 7; j >= 4; j--)
0:         {
0:             column = iter.next();
0:             assert column.name().equals("Column-" + j);
0:             assert column.timestamp() == j * 3;
0:             assert column.value().length == 0;
0:         }
0:         for (int j = 3; j >= 0; j--)
0:         {
0:             column = iter.next();
0:             assert column.name().equals("Column+" + j);
0:             column = iter.next();
0:             assert column.name().equals("Column-" + j);
0:         }
0:     }
0: 
0:     private void validateTimeSort(Table table) throws IOException
0:     {
0:         for (int i = 900; i < 1000; ++i)
0:         {
0:             String key = Integer.toString(i);
0:             for (int j = 0; j < 8; j += 3)
0:             {
0:                 ColumnFamily cf = table.getRow(key, "StandardByTime1", j * 2).getColumnFamilies().iterator().next();
0:                 SortedSet<IColumn> columns = cf.getAllColumns();
0:                 assert columns.size() == 8 - j;
0:                 int k = 7;
0:                 for (IColumn c : columns)
0:                 {
0:                     assert c.timestamp() == (k--) * 2;
0:                 }
0:             }
0:         }
0:     }
0: }
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:434564d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.Util;
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey key = Util.dk("key0");
0:         rm = new RowMutation("Keyspace1", key.key);
0:         rm = new RowMutation("Keyspace1", key.key);
0:         ColumnFamily cf = cfStore.getColumnFamily(key, new QueryPath("StandardLong1"), getBytes(10), ArrayUtils.EMPTY_BYTE_ARRAY, false, 1000);
/////////////////////////////////////////////////////////////////////////
0:             RowMutation rm = new RowMutation("Keyspace1", Integer.toString(i).getBytes());
/////////////////////////////////////////////////////////////////////////
1:         DecoratedKey key = Util.dk("900");
0:         RowMutation rm = new RowMutation("Keyspace1", key.key);
0:         rm = new RowMutation("Keyspace1", key.key);
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(Util.dk("900"), new QueryPath("StandardLong1"), columnNames));
/////////////////////////////////////////////////////////////////////////
0:             DecoratedKey key = Util.dk(Integer.toString(i));
============================================================================