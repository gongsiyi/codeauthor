1:07cf56f: /*
1:5d98581:  * Licensed to the Apache Software Foundation (ASF) under one
1:5d98581:  * or more contributor license agreements.  See the NOTICE file
1:5d98581:  * distributed with this work for additional information
1:5d98581:  * regarding copyright ownership.  The ASF licenses this file
1:5d98581:  * to you under the Apache License, Version 2.0 (the
1:5d98581:  * "License"); you may not use this file except in compliance
1:5d98581:  * with the License.  You may obtain a copy of the License at
1:5d98581:  *
1:07cf56f:  *     http://www.apache.org/licenses/LICENSE-2.0
1:5d98581:  *
1:07cf56f:  * Unless required by applicable law or agreed to in writing, software
1:07cf56f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:07cf56f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:07cf56f:  * See the License for the specific language governing permissions and
1:07cf56f:  * limitations under the License.
1:5d98581:  */
1:5d98581: package org.apache.cassandra.db.marshal;
1:e9c6742: 
1:5d98581: import java.nio.ByteBuffer;
1:5d98581: import java.util.ArrayList;
1:5d5207b: import java.util.Collections;
1:5d98581: import java.util.List;
1:01d26dd: import java.util.regex.Pattern;
1:b09d876: 
1:c7b02d1: import org.apache.cassandra.cql3.Term;
1:8a52f5a: import org.apache.cassandra.serializers.TypeSerializer;
1:8a52f5a: import org.apache.cassandra.serializers.BytesSerializer;
1:8a52f5a: import org.apache.cassandra.serializers.MarshalException;
1:e0adc16: import org.apache.cassandra.transport.ProtocolVersion;
1:8a52f5a: import org.apache.cassandra.utils.ByteBufferUtil;
1:8a52f5a: 
1:5d98581: /**
1:5d98581:  * A class avoiding class duplication between CompositeType and
1:5d98581:  * DynamicCompositeType.
1:5d98581:  * Those two differs only in that for DynamicCompositeType, the comparators
1:5d98581:  * are in the encoded column name at the front of each component.
1:5d98581:  */
1:5d98581: public abstract class AbstractCompositeType extends AbstractType<ByteBuffer>
23:5d98581: {
1:07594ee:     protected AbstractCompositeType()
1:07594ee:     {
1:07594ee:         super(ComparisonType.CUSTOM);
1:07594ee:     }
1:07594ee: 
1:07594ee:     public int compareCustom(ByteBuffer o1, ByteBuffer o2)
1:b09d876:     {
1:acf1b18:         if (!o1.hasRemaining() || !o2.hasRemaining())
1:acf1b18:             return o1.hasRemaining() ? 1 : o2.hasRemaining() ? -1 : 0;
1:b09d876: 
1:5d98581:         ByteBuffer bb1 = o1.duplicate();
1:5d98581:         ByteBuffer bb2 = o2.duplicate();
1:b09d876: 
1:b09d876:         boolean isStatic1 = readIsStatic(bb1);
1:b09d876:         boolean isStatic2 = readIsStatic(bb2);
1:b09d876:         if (isStatic1 != isStatic2)
1:b09d876:             return isStatic1 ? -1 : 1;
1:b09d876: 
3:5d98581:         int i = 0;
19:5d98581: 
1:91bdf7f:         ByteBuffer previous = null;
1:91bdf7f: 
1:5d98581:         while (bb1.remaining() > 0 && bb2.remaining() > 0)
1:5d98581:         {
1:bfe2dfb:             AbstractType<?> comparator = getComparator(i, bb1, bb2);
1:5d98581: 
1:8a52f5a:             ByteBuffer value1 = ByteBufferUtil.readBytesWithShortLength(bb1);
1:8a52f5a:             ByteBuffer value2 = ByteBufferUtil.readBytesWithShortLength(bb2);
1:5d98581: 
1:91bdf7f:             int cmp = comparator.compareCollectionMembers(value1, value2, previous);
1:5d98581:             if (cmp != 0)
1:5d98581:                 return cmp;
1:5d98581: 
1:91bdf7f:             previous = value1;
1:91bdf7f: 
1:5d98581:             byte b1 = bb1.get();
1:5d98581:             byte b2 = bb2.get();
1:b09d876:             if (b1 != b2)
1:b09d876:                 return b1 - b2;
1:b09d876: 
2:5d98581:             ++i;
1:b09d876:         }
1:5d98581: 
1:5d98581:         if (bb1.remaining() == 0)
1:5d98581:             return bb2.remaining() == 0 ? 0 : -1;
1:5d98581: 
1:5d98581:         // bb1.remaining() > 0 && bb2.remaining() == 0
1:edf16c9:         return 1;
23:5d98581:     }
1:5d98581: 
1:b09d876:     // Check if the provided BB represents a static name and advance the
1:b09d876:     // buffer to the real beginning if so.
1:b09d876:     protected abstract boolean readIsStatic(ByteBuffer bb);
1:b09d876: 
1:655ccc3:     /**
1:655ccc3:      * Split a composite column names into it's components.
1:655ccc3:      */
1:655ccc3:     public ByteBuffer[] split(ByteBuffer name)
1:655ccc3:     {
1:655ccc3:         List<ByteBuffer> l = new ArrayList<ByteBuffer>();
1:655ccc3:         ByteBuffer bb = name.duplicate();
1:b09d876:         readIsStatic(bb);
1:655ccc3:         int i = 0;
1:655ccc3:         while (bb.remaining() > 0)
1:655ccc3:         {
1:bfe2dfb:             getComparator(i++, bb);
1:8a52f5a:             l.add(ByteBufferUtil.readBytesWithShortLength(bb));
1:655ccc3:             bb.get(); // skip end-of-component
1:655ccc3:         }
1:655ccc3:         return l.toArray(new ByteBuffer[l.size()]);
1:655ccc3:     }
1:01d26dd:     private static final String COLON = ":";
1:01d26dd:     private static final Pattern COLON_PAT = Pattern.compile(COLON);
1:01d26dd:     private static final String ESCAPED_COLON = "\\\\:";
1:01d26dd:     private static final Pattern ESCAPED_COLON_PAT = Pattern.compile(ESCAPED_COLON);
1:655ccc3: 
1:5d98581: 
2:5d98581:     /*
1:5d5207b:      * Escapes all occurences of the ':' character from the input, replacing them by "\:".
1:5d5207b:      * Furthermore, if the last character is '\' or '!', a '!' is appended.
1:5d98581:      */
1:362cc05:     public static String escape(String input)
1:5d5207b:     {
1:5d5207b:         if (input.isEmpty())
1:5d5207b:             return input;
1:5d5207b: 
1:01d26dd:         String res = COLON_PAT.matcher(input).replaceAll(ESCAPED_COLON);
1:5d5207b:         char last = res.charAt(res.length() - 1);
1:5d5207b:         return last == '\\' || last == '!' ? res + '!' : res;
1:5d5207b:     }
1:5d5207b: 
1:5d5207b:     /*
1:5d5207b:      * Reverses the effect of espace().
1:5d5207b:      * Replaces all occurences of "\:" by ":" and remove last character if it is '!'.
1:5d5207b:      */
1:5d5207b:     static String unescape(String input)
1:5d5207b:     {
1:5d5207b:         if (input.isEmpty())
1:5d5207b:             return input;
1:5d5207b: 
1:01d26dd:         String res = ESCAPED_COLON_PAT.matcher(input).replaceAll(COLON);
1:5d5207b:         char last = res.charAt(res.length() - 1);
1:5d5207b:         return last == '!' ? res.substring(0, res.length() - 1) : res;
1:5d5207b:     }
1:5d5207b: 
1:5d5207b:     /*
1:5d5207b:      * Split the input on character ':', unless the previous character is '\'.
1:5d5207b:      */
1:5d5207b:     static List<String> split(String input)
1:5d5207b:     {
1:5d5207b:         if (input.isEmpty())
1:5d5207b:             return Collections.<String>emptyList();
1:5d5207b: 
1:5d5207b:         List<String> res = new ArrayList<String>();
1:5d5207b:         int prev = 0;
1:5d5207b:         for (int i = 0; i < input.length(); i++)
1:5d5207b:         {
1:5d5207b:             if (input.charAt(i) != ':' || (i > 0 && input.charAt(i-1) == '\\'))
1:5d5207b:                 continue;
1:5d5207b: 
1:5d5207b:             res.add(input.substring(prev, i));
1:5d5207b:             prev = i + 1;
1:5d5207b:         }
1:5d5207b:         res.add(input.substring(prev, input.length()));
1:5d5207b:         return res;
1:5d5207b:     }
1:5d5207b: 
1:5d5207b:     public String getString(ByteBuffer bytes)
1:5d5207b:     {
1:5d5207b:         StringBuilder sb = new StringBuilder();
1:5d5207b:         ByteBuffer bb = bytes.duplicate();
1:b09d876:         readIsStatic(bb);
1:5d5207b: 
1:b09d876:         int i = 0;
1:5d5207b:         while (bb.remaining() > 0)
1:5d5207b:         {
1:5d5207b:             if (bb.remaining() != bytes.remaining())
1:5d5207b:                 sb.append(":");
1:5d5207b: 
1:0f255da:             AbstractType<?> comparator = getAndAppendComparator(i, bb, sb);
1:8a52f5a:             ByteBuffer value = ByteBufferUtil.readBytesWithShortLength(bb);
1:5d5207b: 
1:5d5207b:             sb.append(escape(comparator.getString(value)));
1:5d5207b: 
1:5d5207b:             byte b = bb.get();
1:5d5207b:             if (b != 0)
1:5d5207b:             {
1:362cc05:                 sb.append(b < 0 ? ":_" : ":!");
1:5d5207b:                 break;
1:5d5207b:             }
1:5d5207b:             ++i;
1:5d5207b:         }
1:5d5207b:         return sb.toString();
1:5d5207b:     }
1:5d5207b: 
1:5d98581:     public ByteBuffer fromString(String source)
1:5d98581:     {
1:5d5207b:         List<String> parts = split(source);
1:5d5207b:         List<ByteBuffer> components = new ArrayList<ByteBuffer>(parts.size());
1:5d5207b:         List<ParsedComparator> comparators = new ArrayList<ParsedComparator>(parts.size());
1:5d98581:         int totalLength = 0, i = 0;
1:5d98581:         boolean lastByteIsOne = false;
1:362cc05:         boolean lastByteIsMinusOne = false;
1:5d98581: 
1:5d98581:         for (String part : parts)
1:5d98581:         {
1:5d98581:             if (part.equals("!"))
1:5d98581:             {
1:5d98581:                 lastByteIsOne = true;
2:5d98581:                 break;
1:5d98581:             }
1:362cc05:             else if (part.equals("_"))
1:362cc05:             {
1:362cc05:                 lastByteIsMinusOne = true;
1:362cc05:                 break;
1:362cc05:             }
1:5d98581: 
1:bfe2dfb:             ParsedComparator p = parseComparator(i, part);
1:2bc0d4d:             AbstractType<?> type = p.getAbstractType();
1:5d98581:             part = p.getRemainingPart();
1:5d98581: 
1:5d5207b:             ByteBuffer component = type.fromString(unescape(part));
1:5d98581:             totalLength += p.getComparatorSerializedSize() + 2 + component.remaining() + 1;
1:5d98581:             components.add(component);
1:5d98581:             comparators.add(p);
1:5d98581:             ++i;
1:5d98581:         }
1:5d98581: 
1:5d98581:         ByteBuffer bb = ByteBuffer.allocate(totalLength);
1:5d98581:         i = 0;
1:5d98581:         for (ByteBuffer component : components)
1:5d98581:         {
1:5d98581:             comparators.get(i).serializeComparator(bb);
1:8a52f5a:             ByteBufferUtil.writeShortLength(bb, component.remaining());
1:5d98581:             bb.put(component); // it's ok to consume component as we won't use it anymore
1:5d98581:             bb.put((byte)0);
1:5d98581:             ++i;
1:5d98581:         }
1:5d98581:         if (lastByteIsOne)
1:5d98581:             bb.put(bb.limit() - 1, (byte)1);
1:362cc05:         else if (lastByteIsMinusOne)
1:362cc05:             bb.put(bb.limit() - 1, (byte)-1);
1:5d98581: 
1:5d98581:         bb.rewind();
1:5d98581:         return bb;
1:5d98581:     }
1:5d98581: 
1:daff1fc:     @Override
1:c7b02d1:     public Term fromJSONObject(Object parsed)
1:c7b02d1:     {
1:c7b02d1:         throw new UnsupportedOperationException();
1:c7b02d1:     }
1:c7b02d1: 
1:c7b02d1:     @Override
1:e0adc16:     public String toJSONString(ByteBuffer buffer, ProtocolVersion protocolVersion)
1:c7b02d1:     {
1:c7b02d1:         throw new UnsupportedOperationException();
1:c7b02d1:     }
1:c7b02d1: 
1:c7b02d1:     @Override
1:5d98581:     public void validate(ByteBuffer bytes) throws MarshalException
1:e9c6742:     {
2:5d98581:         ByteBuffer bb = bytes.duplicate();
1:b09d876:         readIsStatic(bb);
1:5d98581: 
1:5d5207b:         int i = 0;
1:91bdf7f:         ByteBuffer previous = null;
2:5d98581:         while (bb.remaining() > 0)
1:5d98581:         {
1:bfe2dfb:             AbstractType<?> comparator = validateComparator(i, bb);
1:5d98581: 
1:5d98581:             if (bb.remaining() < 2)
1:5d98581:                 throw new MarshalException("Not enough bytes to read value size of component " + i);
1:8a52f5a:             int length = ByteBufferUtil.readShortLength(bb);
1:5d98581: 
1:5d98581:             if (bb.remaining() < length)
1:5d98581:                 throw new MarshalException("Not enough bytes to read value of component " + i);
1:8a52f5a:             ByteBuffer value = ByteBufferUtil.readBytes(bb, length);
1:5d98581: 
1:91bdf7f:             comparator.validateCollectionMember(value, previous);
1:5d98581: 
1:5d98581:             if (bb.remaining() == 0)
1:5d98581:                 throw new MarshalException("Not enough bytes to read the end-of-component byte of component" + i);
2:5d98581:             byte b = bb.get();
1:5d98581:             if (b != 0 && bb.remaining() != 0)
1:5d98581:                 throw new MarshalException("Invalid bytes remaining after an end-of-component at component" + i);
1:91bdf7f: 
1:91bdf7f:             previous = value;
1:5d98581:             ++i;
1:5d98581:         }
1:5d98581:     }
1:5d98581: 
1:8ea2d2a:     public abstract ByteBuffer decompose(Object... objects);
1:5d98581: 
1:fc8b76f:     public TypeSerializer<ByteBuffer> getSerializer()
1:5d98581:     {
1:e9c6742:         return BytesSerializer.instance;
1:e9c6742:     }
1:e9c6742: 
1:7a3c3ab:     @Override
1:7a3c3ab:     public boolean referencesUserType(String name)
1:7a3c3ab:     {
1:7a3c3ab:         return getComponents().stream().anyMatch(f -> f.referencesUserType(name));
1:7a3c3ab:     }
1:7a3c3ab: 
1:5d98581:     /**
1:bfe2dfb:      * @return the comparator for the given component. static CompositeType will consult
1:9981316:      * @param i DynamicCompositeType will read the type information from @param bb
1:9981316:      * @param bb name of type definition
1:5d98581:      */
1:bfe2dfb:     abstract protected AbstractType<?> getComparator(int i, ByteBuffer bb);
1:5d98581: 
2:bfe2dfb:     /**
1:bfe2dfb:      * Adds DynamicCompositeType type information from @param bb1 to @param bb2.
1:bfe2dfb:      * @param i is ignored.
2:bfe2dfb:      */
1:bfe2dfb:     abstract protected AbstractType<?> getComparator(int i, ByteBuffer bb1, ByteBuffer bb2);
1:5d98581: 
1:bfe2dfb:     /**
1:bfe2dfb:      * Adds type information from @param bb to @param sb.  @param i is ignored.
1:bfe2dfb:      */
1:bfe2dfb:     abstract protected AbstractType<?> getAndAppendComparator(int i, ByteBuffer bb, StringBuilder sb);
1:5d98581: 
1:bfe2dfb:     /**
1:bfe2dfb:      * Like getComparator, but validates that @param i does not exceed the defined range
1:bfe2dfb:      */
1:bfe2dfb:     abstract protected AbstractType<?> validateComparator(int i, ByteBuffer bb) throws MarshalException;
1:5d98581: 
1:bfe2dfb:     /**
1:bfe2dfb:      * Used by fromString
1:bfe2dfb:      */
1:bfe2dfb:     abstract protected ParsedComparator parseComparator(int i, String part);
1:5d98581: 
1:5d98581:     protected static interface ParsedComparator
1:5d98581:     {
1:2bc0d4d:         AbstractType<?> getAbstractType();
1:5d98581:         String getRemainingPart();
1:5d98581:         int getComparatorSerializedSize();
1:5d98581:         void serializeComparator(ByteBuffer bb);
1:5d98581:     }
1:5d98581: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:e0adc16
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.transport.ProtocolVersion;
/////////////////////////////////////////////////////////////////////////
1:     public String toJSONString(ByteBuffer buffer, ProtocolVersion protocolVersion)
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:0d8e853
author:Robert Stupp
-------------------------------------------------------------------------------
commit:7a3c3ab
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public boolean referencesUserType(String name)
1:     {
1:         return getComponents().stream().anyMatch(f -> f.referencesUserType(name));
1:     }
1: 
author:Alexander Shopov
-------------------------------------------------------------------------------
commit:01d26dd
/////////////////////////////////////////////////////////////////////////
1: import java.util.regex.Pattern;
/////////////////////////////////////////////////////////////////////////
1:     private static final String COLON = ":";
1:     private static final Pattern COLON_PAT = Pattern.compile(COLON);
1:     private static final String ESCAPED_COLON = "\\\\:";
1:     private static final Pattern ESCAPED_COLON_PAT = Pattern.compile(ESCAPED_COLON);
/////////////////////////////////////////////////////////////////////////
1:         String res = COLON_PAT.matcher(input).replaceAll(ESCAPED_COLON);
/////////////////////////////////////////////////////////////////////////
1:         String res = ESCAPED_COLON_PAT.matcher(input).replaceAll(COLON);
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:07594ee
/////////////////////////////////////////////////////////////////////////
1:     protected AbstractCompositeType()
1:     {
1:         super(ComparisonType.CUSTOM);
1:     }
1: 
1:     public int compareCustom(ByteBuffer o1, ByteBuffer o2)
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:8c64cef
/////////////////////////////////////////////////////////////////////////
commit:c7b02d1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.cql3.Term;
/////////////////////////////////////////////////////////////////////////
1:     public Term fromJSONObject(Object parsed)
1:     {
1:         throw new UnsupportedOperationException();
1:     }
1: 
1:     @Override
0:     public String toJSONString(ByteBuffer buffer, int protocolVersion)
1:     {
1:         throw new UnsupportedOperationException();
1:     }
1: 
1:     @Override
author:belliottsmith
-------------------------------------------------------------------------------
commit:acf1b18
/////////////////////////////////////////////////////////////////////////
1:         if (!o1.hasRemaining() || !o2.hasRemaining())
1:             return o1.hasRemaining() ? 1 : o2.hasRemaining() ? -1 : 0;
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:8a52f5a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.serializers.TypeSerializer;
1: import org.apache.cassandra.serializers.BytesSerializer;
1: import org.apache.cassandra.serializers.MarshalException;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             ByteBuffer value1 = ByteBufferUtil.readBytesWithShortLength(bb1);
1:             ByteBuffer value2 = ByteBufferUtil.readBytesWithShortLength(bb2);
/////////////////////////////////////////////////////////////////////////
1:             l.add(ByteBufferUtil.readBytesWithShortLength(bb));
/////////////////////////////////////////////////////////////////////////
1:             ByteBuffer value = ByteBufferUtil.readBytesWithShortLength(bb);
/////////////////////////////////////////////////////////////////////////
0:             ByteBuffer value = ByteBufferUtil.readBytesWithShortLength(bb);
/////////////////////////////////////////////////////////////////////////
1:             ByteBufferUtil.writeShortLength(bb, component.remaining());
/////////////////////////////////////////////////////////////////////////
1:             int length = ByteBufferUtil.readShortLength(bb);
1:             ByteBuffer value = ByteBufferUtil.readBytes(bb, length);
commit:13b753b
commit:edf16c9
/////////////////////////////////////////////////////////////////////////
0:         if (o2 == null || !o2.hasRemaining())
1:             return 1;
commit:63b1ef4
commit:b09d876
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:     // Doesn't change bb position
0:     protected static int getShortLength(ByteBuffer bb, int position)
1:     {
0:         int length = (bb.get(position) & 0xFF) << 8;
0:         return length | (bb.get(position + 1) & 0xFF);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         if (o1 == null || !o1.hasRemaining())
0:             return o2 == null || !o2.hasRemaining() ? 0 : -1;
1: 
1:         boolean isStatic1 = readIsStatic(bb1);
1:         boolean isStatic2 = readIsStatic(bb2);
1:         if (isStatic1 != isStatic2)
1:             return isStatic1 ? -1 : 1;
1: 
/////////////////////////////////////////////////////////////////////////
1:             if (b1 != b2)
1:                 return b1 - b2;
1: 
/////////////////////////////////////////////////////////////////////////
1:     // Check if the provided BB represents a static name and advance the
1:     // buffer to the real beginning if so.
1:     protected abstract boolean readIsStatic(ByteBuffer bb);
1: 
/////////////////////////////////////////////////////////////////////////
1:         readIsStatic(bb);
/////////////////////////////////////////////////////////////////////////
1:         readIsStatic(bb);
/////////////////////////////////////////////////////////////////////////
1:         readIsStatic(bb);
1:         int i = 0;
/////////////////////////////////////////////////////////////////////////
0:         readIsStatic(bb);
commit:362cc05
/////////////////////////////////////////////////////////////////////////
0:     public static int getShortLength(ByteBuffer bb)
0:     public static void putShortLength(ByteBuffer bb, int length)
0:     public static ByteBuffer getBytes(ByteBuffer bb, int length)
/////////////////////////////////////////////////////////////////////////
0:     public static ByteBuffer getWithShortLength(ByteBuffer bb)
/////////////////////////////////////////////////////////////////////////
1:     public static String escape(String input)
/////////////////////////////////////////////////////////////////////////
1:                 sb.append(b < 0 ? ":_" : ":!");
/////////////////////////////////////////////////////////////////////////
1:         boolean lastByteIsMinusOne = false;
/////////////////////////////////////////////////////////////////////////
1:             else if (part.equals("_"))
1:             {
1:                 lastByteIsMinusOne = true;
1:                 break;
1:             }
/////////////////////////////////////////////////////////////////////////
1:         else if (lastByteIsMinusOne)
1:             bb.put(bb.limit() - 1, (byte)-1);
commit:daff1fc
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
commit:fc8b76f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.serializers.TypeSerializer;
0: import org.apache.cassandra.serializers.BytesSerializer;
0: import org.apache.cassandra.serializers.MarshalException;
/////////////////////////////////////////////////////////////////////////
1:     public TypeSerializer<ByteBuffer> getSerializer()
commit:e9c6742
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.type.AbstractSerializer;
0: import org.apache.cassandra.type.BytesSerializer;
0: import org.apache.cassandra.type.MarshalException;
1: 
/////////////////////////////////////////////////////////////////////////
0:     @Override
0:     public AbstractSerializer<ByteBuffer> asComposer()
1:     {
1:         return BytesSerializer.instance;
1:     }
1: 
commit:0f255da
/////////////////////////////////////////////////////////////////////////
1:             AbstractType<?> comparator = getAndAppendComparator(i, bb, sb);
commit:c86a7f8
commit:5d5207b
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collections;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * Escapes all occurences of the ':' character from the input, replacing them by "\:".
1:      * Furthermore, if the last character is '\' or '!', a '!' is appended.
0:     static String escape(String input)
1:     {
1:         if (input.isEmpty())
1:             return input;
1: 
0:         String res = input.replaceAll(":", "\\\\:");
1:         char last = res.charAt(res.length() - 1);
1:         return last == '\\' || last == '!' ? res + '!' : res;
1:     }
1: 
1:     /*
1:      * Reverses the effect of espace().
1:      * Replaces all occurences of "\:" by ":" and remove last character if it is '!'.
1:      */
1:     static String unescape(String input)
1:     {
1:         if (input.isEmpty())
1:             return input;
1: 
0:         String res = input.replaceAll("\\\\:", ":");
1:         char last = res.charAt(res.length() - 1);
1:         return last == '!' ? res.substring(0, res.length() - 1) : res;
1:     }
1: 
1:     /*
1:      * Split the input on character ':', unless the previous character is '\'.
1:      */
1:     static List<String> split(String input)
1:     {
1:         if (input.isEmpty())
1:             return Collections.<String>emptyList();
1: 
1:         List<String> res = new ArrayList<String>();
1:         int prev = 0;
1:         for (int i = 0; i < input.length(); i++)
1:         {
1:             if (input.charAt(i) != ':' || (i > 0 && input.charAt(i-1) == '\\'))
1:                 continue;
1: 
1:             res.add(input.substring(prev, i));
1:             prev = i + 1;
1:         }
1:         res.add(input.substring(prev, input.length()));
1:         return res;
1:     }
1: 
1:     public String getString(ByteBuffer bytes)
1:     {
1:         StringBuilder sb = new StringBuilder();
1:         ByteBuffer bb = bytes.duplicate();
1:         int i = 0;
1: 
1:         while (bb.remaining() > 0)
1:         {
1:             if (bb.remaining() != bytes.remaining())
1:                 sb.append(":");
1: 
0:             AbstractType<?> comparator = getAndAppendNextComparator(i, bb, sb);
0:             ByteBuffer value = getWithShortLength(bb);
1: 
1:             sb.append(escape(comparator.getString(value)));
1: 
1:             byte b = bb.get();
1:             if (b != 0)
1:             {
0:                 sb.append(":!");
1:                 break;
1:             }
1:             ++i;
1:         }
1:         return sb.toString();
1:     }
1: 
1:         List<String> parts = split(source);
1:         List<ByteBuffer> components = new ArrayList<ByteBuffer>(parts.size());
1:         List<ParsedComparator> comparators = new ArrayList<ParsedComparator>(parts.size());
/////////////////////////////////////////////////////////////////////////
1:             ByteBuffer component = type.fromString(unescape(part));
commit:91bdf7f
/////////////////////////////////////////////////////////////////////////
1:         ByteBuffer previous = null;
1: 
/////////////////////////////////////////////////////////////////////////
1:             int cmp = comparator.compareCollectionMembers(value1, value2, previous);
1:             previous = value1;
1: 
/////////////////////////////////////////////////////////////////////////
1:         ByteBuffer previous = null;
/////////////////////////////////////////////////////////////////////////
1:             comparator.validateCollectionMember(value, previous);
1: 
1:             previous = value;
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
commit:655ccc3
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Split a composite column names into it's components.
1:      */
1:     public ByteBuffer[] split(ByteBuffer name)
1:     {
1:         List<ByteBuffer> l = new ArrayList<ByteBuffer>();
1:         ByteBuffer bb = name.duplicate();
1:         int i = 0;
1:         while (bb.remaining() > 0)
1:         {
0:             getNextComparator(i++, bb);
0:             l.add(getWithShortLength(bb));
1:             bb.get(); // skip end-of-component
1:         }
1:         return l.toArray(new ByteBuffer[l.size()]);
1:     }
1: 
commit:5d98581
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
1:  */
1: package org.apache.cassandra.db.marshal;
1: 
1: import java.nio.ByteBuffer;
0: import java.util.Iterator;
1: import java.util.ArrayList;
0: import java.util.HashMap;
1: import java.util.List;
0: import java.util.Map;
0: import java.sql.Types;
1: 
0: import org.apache.cassandra.utils.ByteBufferUtil;
1: 
1: /**
1:  * A class avoiding class duplication between CompositeType and
1:  * DynamicCompositeType.
1:  * Those two differs only in that for DynamicCompositeType, the comparators
1:  * are in the encoded column name at the front of each component.
1:  */
1: public abstract class AbstractCompositeType extends AbstractType<ByteBuffer>
1: {
0:     // changes bb position
0:     protected static int getShortLength(ByteBuffer bb)
1:     {
0:         int length = (bb.get() & 0xFF) << 8;
0:         return length | (bb.get() & 0xFF);
1:     }
1: 
0:     // changes bb position
0:     protected static void putShortLength(ByteBuffer bb, int length)
1:     {
0:         bb.put((byte) ((length >> 8) & 0xFF));
0:         bb.put((byte) (length & 0xFF));
1:     }
1: 
0:     // changes bb position
0:     protected static ByteBuffer getBytes(ByteBuffer bb, int length)
1:     {
0:         ByteBuffer copy = bb.duplicate();
0:         copy.limit(copy.position() + length);
0:         bb.position(bb.position() + length);
0:         return copy;
1:     }
1: 
0:     // changes bb position
0:     protected static ByteBuffer getWithShortLength(ByteBuffer bb)
1:     {
0:         int length = getShortLength(bb);
0:         return getBytes(bb, length);
1:     }
1: 
0:     public int compare(ByteBuffer o1, ByteBuffer o2)
1:     {
0:         if (null == o1)
0:             return null == o2 ? 0 : -1;
1: 
1:         ByteBuffer bb1 = o1.duplicate();
1:         ByteBuffer bb2 = o2.duplicate();
1:         int i = 0;
1: 
1:         while (bb1.remaining() > 0 && bb2.remaining() > 0)
1:         {
0:             AbstractType comparator = getNextComparator(i, bb1, bb2);
1: 
0:             ByteBuffer value1 = getWithShortLength(bb1);
0:             ByteBuffer value2 = getWithShortLength(bb2);
1: 
0:             int cmp = comparator.compare(value1, value2);
1:             if (cmp != 0)
1:                 return cmp;
1: 
1:             byte b1 = bb1.get();
1:             byte b2 = bb2.get();
0:             if (b1 < 0)
1:             {
0:                 if (b2 >= 0)
0:                     return -1;
1:             }
0:             else if (b1 > 0)
1:             {
0:                 if (b2 <= 0)
0:                     return 1;
1:             }
0:             else
1:             {
0:                 // b1 == 0
0:                 if (b2 != 0)
0:                     return -b2;
1:             }
1:             ++i;
1:         }
1: 
1:         if (bb1.remaining() == 0)
1:             return bb2.remaining() == 0 ? 0 : -1;
1: 
1:         // bb1.remaining() > 0 && bb2.remaining() == 0
0:         return 1;
1:     }
1: 
0:     public String getString(ByteBuffer bytes)
1:     {
0:         StringBuilder sb = new StringBuilder();
1:         ByteBuffer bb = bytes.duplicate();
1:         int i = 0;
1: 
1:         while (bb.remaining() > 0)
1:         {
0:             if (bb.remaining() != bytes.remaining())
0:                 sb.append(":");
1: 
0:             AbstractType comparator = getAndAppendNextComparator(i, bb, sb);
0:             ByteBuffer value = getWithShortLength(bb);
1: 
0:             sb.append(comparator.getString(value));
1: 
1:             byte b = bb.get();
0:             if (b != 0)
1:             {
0:                 sb.append(":!");
1:                 break;
1:             }
1:             ++i;
1:         }
0:         return sb.toString();
1:     }
1: 
1:     /*
0:      * FIXME: this would break if some of the component string representation
0:      * contains ':'. None of our current comparator do so, so this is probably
0:      * not an urgent matter, but this could break for custom comparator.
0:      * (DynamicCompositeType would break on '@' too)
1:      */
1:     public ByteBuffer fromString(String source)
1:     {
0:         String[] parts = source.split(":");
0:         List<ByteBuffer> components = new ArrayList<ByteBuffer>();
0:         List<ParsedComparator> comparators = new ArrayList<ParsedComparator>();
1:         int totalLength = 0, i = 0;
1:         boolean lastByteIsOne = false;
1: 
1:         for (String part : parts)
1:         {
1:             if (part.equals("!"))
1:             {
1:                 lastByteIsOne = true;
1:                 break;
1:             }
1: 
0:             ParsedComparator p = parseNextComparator(i, part);
0:             AbstractType type = p.getAbstractType();
1:             part = p.getRemainingPart();
1: 
0:             ByteBuffer component = type.fromString(part);
1:             totalLength += p.getComparatorSerializedSize() + 2 + component.remaining() + 1;
1:             components.add(component);
1:             comparators.add(p);
1:             ++i;
1:         }
1: 
1:         ByteBuffer bb = ByteBuffer.allocate(totalLength);
1:         i = 0;
1:         for (ByteBuffer component : components)
1:         {
1:             comparators.get(i).serializeComparator(bb);
0:             putShortLength(bb, component.remaining());
1:             bb.put(component); // it's ok to consume component as we won't use it anymore
1:             bb.put((byte)0);
1:             ++i;
1:         }
1:         if (lastByteIsOne)
1:             bb.put(bb.limit() - 1, (byte)1);
1: 
1:         bb.rewind();
1:         return bb;
1:     }
1: 
1:     public void validate(ByteBuffer bytes) throws MarshalException
1:     {
1:         ByteBuffer bb = bytes.duplicate();
1: 
1:         int i = 0;
1:         while (bb.remaining() > 0)
1:         {
0:             AbstractType comparator = validateNextComparator(i, bb);
1: 
1:             if (bb.remaining() < 2)
1:                 throw new MarshalException("Not enough bytes to read value size of component " + i);
0:             int length = getShortLength(bb);
1: 
1:             if (bb.remaining() < length)
1:                 throw new MarshalException("Not enough bytes to read value of component " + i);
0:             ByteBuffer value = getBytes(bb, length);
1: 
0:             comparator.validate(value);
1: 
1:             if (bb.remaining() == 0)
1:                 throw new MarshalException("Not enough bytes to read the end-of-component byte of component" + i);
1:             byte b = bb.get();
1:             if (b != 0 && bb.remaining() != 0)
1:                 throw new MarshalException("Invalid bytes remaining after an end-of-component at component" + i);
1:             ++i;
1:         }
1:     }
1: 
0:     public ByteBuffer compose(ByteBuffer bytes)
1:     {
0:         return bytes;
1:     }
1: 
0:     public ByteBuffer decompose(ByteBuffer value)
1:     {
0:         return value;
1:     }
1: 
0:     public Class<ByteBuffer> getType()
1:     {
0:         return ByteBuffer.class;
1:     }
1: 
0:     public String toString(ByteBuffer value)
1:     {
0:         return getString(value);
1:     }
1: 
1:     /*
0:      * JDBC metadata. For now we don't allow the use of compositeType with
0:      * JDBC. We'll have to figure out what is the best solution here.
1:      */
0:     public boolean isSigned()
1:     {
0:         throw new UnsupportedOperationException("Not support for JDBC yet");
1:     }
1: 
0:     public boolean isCaseSensitive()
1:     {
0:         throw new UnsupportedOperationException("Not support for JDBC yet");
1:     }
1: 
0:     public boolean isCurrency()
1:     {
0:         throw new UnsupportedOperationException("Not support for JDBC yet");
1:     }
1: 
0:     public int getPrecision(ByteBuffer obj)
1:     {
0:         throw new UnsupportedOperationException("Not support for JDBC yet");
1:     }
1: 
0:     public int getScale(ByteBuffer obj)
1:     {
0:         throw new UnsupportedOperationException("Not support for JDBC yet");
1:     }
1: 
0:     public int getJdbcType()
1:     {
0:         throw new UnsupportedOperationException("Not support for JDBC yet");
1:     }
1: 
0:     public boolean needsQuotes()
1:     {
0:         throw new UnsupportedOperationException("Not support for JDBC yet");
1:     }
1: 
0:     abstract protected AbstractType getNextComparator(int i, ByteBuffer bb);
0:     abstract protected AbstractType getNextComparator(int i, ByteBuffer bb1, ByteBuffer bb2);
0:     abstract protected AbstractType getAndAppendNextComparator(int i, ByteBuffer bb, StringBuilder sb);
0:     abstract protected ParsedComparator parseNextComparator(int i, String part);
0:     abstract protected AbstractType validateNextComparator(int i, ByteBuffer bb) throws MarshalException;
1: 
1:     protected static interface ParsedComparator
1:     {
0:         AbstractType getAbstractType();
1:         String getRemainingPart();
1:         int getComparatorSerializedSize();
1:         void serializeComparator(ByteBuffer bb);
1:     }
1: }
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:0ad499e
/////////////////////////////////////////////////////////////////////////
0:         public AbstractType<?> comparator;
0:         public CompositeComponent( AbstractType<?> comparator, ByteBuffer value )
commit:d7468ea
/////////////////////////////////////////////////////////////////////////
0:             return o2 == null ? 0 : -1;
commit:7d857e6
/////////////////////////////////////////////////////////////////////////
0:         if (o1 == null)
commit:8ea2d2a
/////////////////////////////////////////////////////////////////////////
1:     public abstract ByteBuffer decompose(Object... objects);
0: 
commit:bfe2dfb
/////////////////////////////////////////////////////////////////////////
1:             AbstractType<?> comparator = getComparator(i, bb1, bb2);
/////////////////////////////////////////////////////////////////////////
1:             getComparator(i++, bb);
/////////////////////////////////////////////////////////////////////////
0:             AbstractType<?> comparator = getAndAppendComparator(i, bb, sb);
/////////////////////////////////////////////////////////////////////////
0:             AbstractType comparator = getComparator(i, bb);
/////////////////////////////////////////////////////////////////////////
1:             ParsedComparator p = parseComparator(i, part);
/////////////////////////////////////////////////////////////////////////
1:             AbstractType<?> comparator = validateComparator(i, bb);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @return the comparator for the given component. static CompositeType will consult
0:      * @param i; DynamicCompositeType will read the type information from @param bb
1:      */
1:     abstract protected AbstractType<?> getComparator(int i, ByteBuffer bb);
0: 
1:     /**
1:      * Adds DynamicCompositeType type information from @param bb1 to @param bb2.
1:      * @param i is ignored.
1:      */
1:     abstract protected AbstractType<?> getComparator(int i, ByteBuffer bb1, ByteBuffer bb2);
0: 
1:     /**
1:      * Adds type information from @param bb to @param sb.  @param i is ignored.
1:      */
1:     abstract protected AbstractType<?> getAndAppendComparator(int i, ByteBuffer bb, StringBuilder sb);
0: 
1:     /**
1:      * Like getComparator, but validates that @param i does not exceed the defined range
1:      */
1:     abstract protected AbstractType<?> validateComparator(int i, ByteBuffer bb) throws MarshalException;
0: 
1:     /**
1:      * Used by fromString
1:      */
1:     abstract protected ParsedComparator parseComparator(int i, String part);
commit:38ee718
/////////////////////////////////////////////////////////////////////////
0:         List<ByteBuffer> components = new ArrayList<ByteBuffer>(parts.length);
0:         List<ParsedComparator> comparators = new ArrayList<ParsedComparator>(parts.length);
commit:2bc0d4d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             AbstractType<?> comparator = getNextComparator(i, bb1, bb2);
/////////////////////////////////////////////////////////////////////////
0:             AbstractType<?> comparator = getAndAppendNextComparator(i, bb, sb);
/////////////////////////////////////////////////////////////////////////
1:             AbstractType<?> type = p.getAbstractType();
/////////////////////////////////////////////////////////////////////////
0:             AbstractType<?> comparator = validateNextComparator(i, bb);
/////////////////////////////////////////////////////////////////////////
0:     abstract protected AbstractType<?> getNextComparator(int i, ByteBuffer bb);
0:     abstract protected AbstractType<?> getNextComparator(int i, ByteBuffer bb1, ByteBuffer bb2);
0:     abstract protected AbstractType<?> getAndAppendNextComparator(int i, ByteBuffer bb, StringBuilder sb);
0:     abstract protected AbstractType<?> validateNextComparator(int i, ByteBuffer bb) throws MarshalException;
1:         AbstractType<?> getAbstractType();
commit:c11eeb4
/////////////////////////////////////////////////////////////////////////
author:Dave Brosius
-------------------------------------------------------------------------------
commit:9981316
/////////////////////////////////////////////////////////////////////////
1:      * @param i DynamicCompositeType will read the type information from @param bb
1:      * @param bb name of type definition
author:Brandon Williams
-------------------------------------------------------------------------------
commit:4bae174
commit:2fc2bd3
commit:470873f
commit:b61f1d4
/////////////////////////////////////////////////////////////////////////
0:     public static class CompositeComponent
0:     {
0:         public AbstractType comparator;
0:         public ByteBuffer   value;
0: 
0:         public CompositeComponent( AbstractType comparator, ByteBuffer value )
0:         {
0:             this.comparator = comparator;
0:             this.value      = value;
0:         }
0:     }
0: 
0:     public List<CompositeComponent> deconstruct( ByteBuffer bytes )
0:     {
0:         List<CompositeComponent> list = new ArrayList<CompositeComponent>();
0: 
0:         ByteBuffer bb = bytes.duplicate();
0:         int i = 0;
0: 
0:         while (bb.remaining() > 0)
0:         {
0:             AbstractType comparator = getNextComparator(i, bb);
0:             ByteBuffer value = getWithShortLength(bb);
0: 
0:             list.add( new CompositeComponent(comparator,value) );
0: 
0:             byte b = bb.get(); // Ignore; not relevant here
0:             ++i;
0:         }
0:         return list;
0:     }
0: 
author:Eric Evans
-------------------------------------------------------------------------------
commit:a0d45f7
/////////////////////////////////////////////////////////////////////////
============================================================================