1:5250d7f: /*
1:5250d7f:  * Licensed to the Apache Software Foundation (ASF) under one
1:5250d7f:  * or more contributor license agreements.  See the NOTICE file
1:5250d7f:  * distributed with this work for additional information
1:5250d7f:  * regarding copyright ownership.  The ASF licenses this file
1:5250d7f:  * to you under the Apache License, Version 2.0 (the
1:5250d7f:  * "License"); you may not use this file except in compliance
1:5250d7f:  * with the License.  You may obtain a copy of the License at
1:5250d7f:  *
1:5250d7f:  *   http://www.apache.org/licenses/LICENSE-2.0
1:5250d7f:  *
1:5250d7f:  * Unless required by applicable law or agreed to in writing,
1:5250d7f:  * software distributed under the License is distributed on an
1:5250d7f:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:5250d7f:  * KIND, either express or implied.  See the License for the
1:5250d7f:  * specific language governing permissions and limitations
1:5250d7f:  * under the License.
1:5250d7f:  */
1:5250d7f: package org.apache.cassandra.utils;
1:5250d7f: 
1:e51f83b: import java.lang.annotation.Annotation;
1:e51f83b: import java.lang.reflect.InvocationTargetException;
1:e51f83b: import java.lang.reflect.Method;
1:5250d7f: import java.util.*;
1:5250d7f: import java.util.concurrent.Callable;
1:5250d7f: import java.util.concurrent.CountDownLatch;
1:5250d7f: import java.util.concurrent.ExecutionException;
1:5250d7f: import java.util.concurrent.ExecutorService;
1:5250d7f: import java.util.concurrent.Executors;
1:5250d7f: import java.util.concurrent.ThreadLocalRandom;
1:5250d7f: import java.util.concurrent.TimeUnit;
1:5250d7f: import java.util.concurrent.atomic.AtomicLong;
1:5250d7f: import java.util.function.Consumer;
1:5250d7f: 
1:639d4b2: import com.google.common.base.Function;
1:5250d7f: import com.google.common.collect.Lists;
1:5250d7f: import com.google.common.util.concurrent.Futures;
1:5250d7f: import com.google.common.util.concurrent.ListenableFuture;
1:5250d7f: import com.google.common.util.concurrent.ListenableFutureTask;
1:5250d7f: import org.junit.Assert;
1:5250d7f: import org.junit.Test;
1:5250d7f: 
1:5250d7f: import com.codahale.metrics.MetricRegistry;
1:5250d7f: import com.codahale.metrics.Snapshot;
1:5250d7f: import com.codahale.metrics.Timer;
1:5250d7f: import org.apache.cassandra.concurrent.NamedThreadFactory;
1:5250d7f: import org.apache.cassandra.utils.btree.*;
1:5250d7f: 
1:639d4b2: import static com.google.common.base.Predicates.notNull;
1:5250d7f: import static com.google.common.collect.Iterables.filter;
1:639d4b2: import static com.google.common.collect.Iterables.transform;
1:5250d7f: import static java.util.Comparator.naturalOrder;
1:5250d7f: import static java.util.Comparator.reverseOrder;
1:639d4b2: import static org.apache.cassandra.utils.btree.BTree.iterable;
1:639d4b2: import static org.junit.Assert.assertTrue;
1:5250d7f: 
1:5250d7f: public class LongBTreeTest
5:5250d7f: {
1:5250d7f: 
1:e51f83b:     private static final boolean DEBUG = false;
1:5250d7f:     private static int perThreadTrees = 10000;
1:e51f83b:     private static int minTreeSize = 4;
1:e51f83b:     private static int maxTreeSize = 10000;
1:e51f83b:     private static int threads = DEBUG ? 1 : Runtime.getRuntime().availableProcessors() * 8;
1:5250d7f:     private static final MetricRegistry metrics = new MetricRegistry();
1:5250d7f:     private static final Timer BTREE_TIMER = metrics.timer(MetricRegistry.name(BTree.class, "BTREE"));
1:5250d7f:     private static final Timer TREE_TIMER = metrics.timer(MetricRegistry.name(BTree.class, "TREE"));
1:e51f83b:     private static final ExecutorService MODIFY = Executors.newFixedThreadPool(threads, new NamedThreadFactory("MODIFY"));
1:e51f83b:     private static final ExecutorService COMPARE = DEBUG ? MODIFY : Executors.newFixedThreadPool(threads, new NamedThreadFactory("COMPARE"));
1:5250d7f:     private static final RandomAbort<Integer> SPORADIC_ABORT = new RandomAbort<>(new Random(), 0.0001f);
1:5250d7f: 
1:5250d7f:     static
1:5250d7f:     {
1:5250d7f:         System.setProperty("cassandra.btree.fanfactor", "4");
3:5250d7f:     }
1:5250d7f: 
1:5250d7f:     /************************** TEST ACCESS ********************************************/
1:5250d7f: 
1:5250d7f:     @Test
1:5250d7f:     public void testSearchIterator() throws InterruptedException
1:5250d7f:     {
1:5250d7f:         final int perTreeSelections = 100;
1:5250d7f:         testRandomSelection(perThreadTrees, perTreeSelections,
1:5250d7f:         (test) -> {
1:5250d7f:             IndexedSearchIterator<Integer, Integer> iter1 = test.testAsSet.iterator();
1:5250d7f:             IndexedSearchIterator<Integer, Integer> iter2 = test.testAsList.iterator();
2:5250d7f:             return (key) ->
1:5250d7f:             {
1:5250d7f:                 Integer found1 = iter1.hasNext() ? iter1.next(key) : null;
1:5250d7f:                 Integer found2 = iter2.hasNext() ? iter2.next(key) : null;
1:5250d7f:                 Assert.assertSame(found1, found2);
1:5250d7f:                 if (found1 != null)
1:5250d7f:                     Assert.assertEquals(iter1.indexOfCurrent(), iter2.indexOfCurrent());
1:5250d7f: 
1:5250d7f:                 int index = Collections.binarySearch(test.canonicalList, key, test.comparator);
1:5250d7f:                 if (index < 0)
1:5250d7f:                 {
1:5250d7f:                     Assert.assertNull(found1);
1:5250d7f:                 }
1:5250d7f:                 else
1:5250d7f:                 {
1:5250d7f:                     Assert.assertEquals(key, found1);
1:5250d7f:                     Assert.assertEquals(index, iter1.indexOfCurrent());
1:5250d7f:                 }
1:5250d7f: 
1:5250d7f:                 // check that by advancing the same key again we get null, but only do it on one of the two iterators
1:5250d7f:                 // to ensure they both advance differently
1:5250d7f:                 if (ThreadLocalRandom.current().nextBoolean())
1:5250d7f:                     Assert.assertNull(iter1.next(key));
1:5250d7f:                 else
1:5250d7f:                     Assert.assertNull(iter2.next(key));
2:5250d7f:             };
3:5250d7f:         });
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Test
1:5250d7f:     public void testInequalityLookups() throws InterruptedException
1:5250d7f:     {
1:5250d7f:         final int perTreeSelections = 2;
1:5250d7f:         testRandomSelectionOfSet(perThreadTrees, perTreeSelections,
1:639d4b2:                                  (test, canonical) -> {
1:639d4b2:                                      if (!canonical.isEmpty() || !test.isEmpty())
1:639d4b2:                                      {
1:639d4b2:                                          Assert.assertEquals(canonical.isEmpty(), test.isEmpty());
1:639d4b2:                                          Assert.assertEquals(canonical.first(), test.first());
1:639d4b2:                                          Assert.assertEquals(canonical.last(), test.last());
1:639d4b2:                                      }
1:639d4b2:                                      return (key) ->
1:639d4b2:                                      {
1:639d4b2:                                          Assert.assertEquals(test.ceiling(key), canonical.ceiling(key));
1:639d4b2:                                          Assert.assertEquals(test.higher(key), canonical.higher(key));
1:639d4b2:                                          Assert.assertEquals(test.floor(key), canonical.floor(key));
1:639d4b2:                                          Assert.assertEquals(test.lower(key), canonical.lower(key));
1:639d4b2:                                      };
1:639d4b2:                                  });
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Test
1:5250d7f:     public void testListIndexes() throws InterruptedException
1:5250d7f:     {
1:5250d7f:         testRandomSelectionOfList(perThreadTrees, 4,
1:639d4b2:                                   (test, canonical, cmp) ->
1:639d4b2:                                   (key) ->
1:639d4b2:                                   {
1:639d4b2:                                       int javaIndex = Collections.binarySearch(canonical, key, cmp);
1:639d4b2:                                       int btreeIndex = test.indexOf(key);
1:639d4b2:                                       Assert.assertEquals(javaIndex, btreeIndex);
1:639d4b2:                                       if (javaIndex >= 0)
1:639d4b2:                                           Assert.assertEquals(canonical.get(javaIndex), test.get(btreeIndex));
1:639d4b2:                                   }
1:5250d7f:         );
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Test
1:5250d7f:     public void testToArray() throws InterruptedException
1:5250d7f:     {
1:5250d7f:         testRandomSelection(perThreadTrees, 4,
1:639d4b2:                             (selection) ->
1:639d4b2:                             {
1:639d4b2:                                 Integer[] array = new Integer[selection.canonicalList.size() + 1];
1:639d4b2:                                 selection.testAsList.toArray(array, 1);
1:639d4b2:                                 Assert.assertEquals(null, array[0]);
1:639d4b2:                                 for (int j = 0; j < selection.canonicalList.size(); j++)
1:639d4b2:                                     Assert.assertEquals(selection.canonicalList.get(j), array[j + 1]);
1:639d4b2:                             });
1:639d4b2:     }
1:639d4b2: 
1:639d4b2:     private static final class CountingFunction implements Function<Integer, Integer>
1:639d4b2:     {
1:639d4b2:         final Function<Integer, Integer> wrapped;
1:639d4b2:         int count = 0;
1:639d4b2:         protected CountingFunction(Function<Integer, Integer> wrapped)
1:639d4b2:         {
1:639d4b2:             this.wrapped = wrapped;
1:639d4b2:         }
1:639d4b2:         public Integer apply(Integer integer)
1:639d4b2:         {
1:639d4b2:             count++;
1:639d4b2:             return wrapped.apply(integer);
1:639d4b2:         }
1:639d4b2:     }
1:639d4b2: 
1:639d4b2:     @Test
1:639d4b2:     public void testTransformAndFilter() throws InterruptedException
1:639d4b2:     {
1:639d4b2:         testRandomSelection(perThreadTrees, 4, false, false, false,
1:639d4b2:                             (selection) ->
1:639d4b2:                             {
1:639d4b2:                                 Map<Integer, Integer> update = new LinkedHashMap<>();
1:639d4b2:                                 for (Integer i : selection.testKeys)
1:639d4b2:                                     update.put(i, new Integer(i));
1:639d4b2: 
1:639d4b2:                                 CountingFunction function;
1:639d4b2:                                 Object[] original = selection.testAsSet.tree();
1:639d4b2:                                 Object[] transformed;
1:639d4b2: 
1:639d4b2:                                 // test replacing none, leaving all present
1:639d4b2:                                 function = new CountingFunction((x) -> x);
1:639d4b2:                                 transformed = BTree.transformAndFilter(original, function);
1:639d4b2:                                 Assert.assertEquals(BTree.size(original), function.count);
1:639d4b2:                                 Assert.assertSame(original, transformed);
1:639d4b2: 
1:639d4b2:                                 // test replacing some, leaving all present
1:639d4b2:                                 function = new CountingFunction((x) -> update.containsKey(x) ? update.get(x) : x);
1:639d4b2:                                 transformed = BTree.transformAndFilter(original, function);
1:639d4b2:                                 Assert.assertEquals(BTree.size(original), function.count);
1:639d4b2:                                 assertSame(transform(selection.canonicalList, function.wrapped), iterable(transformed));
1:639d4b2: 
1:639d4b2:                                 // test replacing some, removing some
1:639d4b2:                                 function = new CountingFunction(update::get);
1:639d4b2:                                 transformed = BTree.transformAndFilter(original, function);
1:639d4b2:                                 Assert.assertEquals(BTree.size(original), function.count);
1:639d4b2:                                 assertSame(filter(transform(selection.canonicalList, function.wrapped), notNull()), iterable(transformed));
1:639d4b2: 
1:639d4b2:                                 // test replacing none, removing some
1:639d4b2:                                 function = new CountingFunction((x) -> update.containsKey(x) ? null : x);
1:639d4b2:                                 transformed = BTree.transformAndFilter(selection.testAsList.tree(), function);
1:639d4b2:                                 Assert.assertEquals(BTree.size(original), function.count);
1:639d4b2:                                 assertSame(filter(transform(selection.canonicalList, function.wrapped), notNull()), iterable(transformed));
1:639d4b2:                             });
1:639d4b2:     }
1:639d4b2: 
1:639d4b2:     private static void assertSame(Iterable<Integer> i1, Iterable<Integer> i2)
1:639d4b2:     {
1:639d4b2:         assertSame(i1.iterator(), i2.iterator());
1:639d4b2:     }
1:639d4b2: 
1:639d4b2:     private static void assertSame(Iterator<Integer> i1, Iterator<Integer> i2)
1:639d4b2:     {
1:639d4b2:         while (i1.hasNext() && i2.hasNext())
1:639d4b2:             Assert.assertSame(i1.next(), i2.next());
1:639d4b2:         Assert.assertEquals(i1.hasNext(), i2.hasNext());
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     private void testRandomSelectionOfList(int perThreadTrees, int perTreeSelections, BTreeListTestFactory testRun) throws InterruptedException
1:5250d7f:     {
1:5250d7f:         testRandomSelection(perThreadTrees, perTreeSelections,
1:5250d7f:                             (BTreeTestFactory) (selection) -> testRun.get(selection.testAsList, selection.canonicalList, selection.comparator));
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     private void testRandomSelectionOfSet(int perThreadTrees, int perTreeSelections, BTreeSetTestFactory testRun) throws InterruptedException
1:5250d7f:     {
1:5250d7f:         testRandomSelection(perThreadTrees, perTreeSelections,
1:5250d7f:                             (BTreeTestFactory) (selection) -> testRun.get(selection.testAsSet, selection.canonicalSet));
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     static interface BTreeSetTestFactory
1:5250d7f:     {
1:5250d7f:         TestEachKey get(BTreeSet<Integer> test, NavigableSet<Integer> canonical);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     static interface BTreeListTestFactory
1:5250d7f:     {
1:5250d7f:         TestEachKey get(BTreeSet<Integer> test, List<Integer> canonical, Comparator<Integer> comparator);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     static interface BTreeTestFactory
1:5250d7f:     {
1:5250d7f:         TestEachKey get(RandomSelection test);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     static interface TestEachKey
1:5250d7f:     {
1:5250d7f:         void testOne(Integer value);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     private void testRandomSelection(int perThreadTrees, int perTreeSelections, BTreeTestFactory testRun) throws InterruptedException
1:5250d7f:     {
1:5250d7f:         testRandomSelection(perThreadTrees, perTreeSelections, (selection) -> {
1:5250d7f:             TestEachKey testEachKey = testRun.get(selection);
1:5250d7f:             for (Integer key : selection.testKeys)
1:5250d7f:                 testEachKey.testOne(key);
1:5250d7f:         });
1:5250d7f:     }
1:639d4b2: 
1:5250d7f:     private void testRandomSelection(int perThreadTrees, int perTreeSelections, Consumer<RandomSelection> testRun) throws InterruptedException
1:5250d7f:     {
1:639d4b2:         testRandomSelection(perThreadTrees, perTreeSelections, true, true, true, testRun);
1:639d4b2:     }
1:639d4b2: 
1:639d4b2:     private void testRandomSelection(int perThreadTrees, int perTreeSelections, boolean narrow, boolean mixInNotPresentItems, boolean permitReversal, Consumer<RandomSelection> testRun) throws InterruptedException
1:639d4b2:     {
1:5250d7f:         int threads = Runtime.getRuntime().availableProcessors();
1:5250d7f:         final CountDownLatch latch = new CountDownLatch(threads);
1:5250d7f:         final AtomicLong errors = new AtomicLong();
1:5250d7f:         final AtomicLong count = new AtomicLong();
1:5250d7f:         final long totalCount = threads * perThreadTrees * perTreeSelections;
1:5250d7f:         for (int t = 0 ; t < threads ; t++)
1:5250d7f:         {
1:5250d7f:             Runnable runnable = new Runnable()
1:5250d7f:             {
1:5250d7f:                 public void run()
1:5250d7f:                 {
1:5250d7f:                     try
1:5250d7f:                     {
1:5250d7f:                         for (int i = 0 ; i < perThreadTrees ; i++)
1:5250d7f:                         {
1:639d4b2:                             RandomTree tree = randomTree(minTreeSize, maxTreeSize);
1:5250d7f:                             for (int j = 0 ; j < perTreeSelections ; j++)
1:5250d7f:                             {
1:639d4b2:                                 testRun.accept(tree.select(narrow, mixInNotPresentItems, permitReversal));
1:5250d7f:                                 count.incrementAndGet();
1:5250d7f:                             }
1:5250d7f:                         }
1:5250d7f:                     }
1:5250d7f:                     catch (Throwable t)
1:5250d7f:                     {
1:5250d7f:                         errors.incrementAndGet();
1:5250d7f:                         t.printStackTrace();
1:5250d7f:                     }
1:5250d7f:                     latch.countDown();
1:5250d7f:                 }
1:5250d7f:             };
1:5250d7f:             MODIFY.execute(runnable);
1:5250d7f:         }
1:5250d7f:         while (latch.getCount() > 0)
1:5250d7f:         {
1:5250d7f:             for (int i = 0 ; i < 10L ; i++)
1:5250d7f:             {
1:5250d7f:                 latch.await(1L, TimeUnit.SECONDS);
1:5250d7f:                 Assert.assertEquals(0, errors.get());
1:5250d7f:             }
1:e51f83b:             log("%.1f%% complete %s", 100 * count.get() / (double) totalCount, errors.get() > 0 ? ("Errors: " + errors.get()) : "");
1:5250d7f:         }
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     private static class RandomSelection
1:5250d7f:     {
1:5250d7f:         final List<Integer> testKeys;
1:5250d7f:         final NavigableSet<Integer> canonicalSet;
1:5250d7f:         final List<Integer> canonicalList;
1:5250d7f:         final BTreeSet<Integer> testAsSet;
1:5250d7f:         final BTreeSet<Integer> testAsList;
1:5250d7f:         final Comparator<Integer> comparator;
1:5250d7f: 
1:5250d7f:         private RandomSelection(List<Integer> testKeys, NavigableSet<Integer> canonicalSet, BTreeSet<Integer> testAsSet,
1:5250d7f:                                 List<Integer> canonicalList, BTreeSet<Integer> testAsList, Comparator<Integer> comparator)
1:5250d7f:         {
1:5250d7f:             this.testKeys = testKeys;
1:5250d7f:             this.canonicalList = canonicalList;
1:5250d7f:             this.canonicalSet = canonicalSet;
1:5250d7f:             this.testAsSet = testAsSet;
1:5250d7f:             this.testAsList = testAsList;
1:5250d7f:             this.comparator = comparator;
1:5250d7f:         }
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     private static class RandomTree
1:5250d7f:     {
1:5250d7f:         final NavigableSet<Integer> canonical;
1:5250d7f:         final BTreeSet<Integer> test;
1:5250d7f: 
1:5250d7f:         private RandomTree(NavigableSet<Integer> canonical, BTreeSet<Integer> test)
1:5250d7f:         {
1:5250d7f:             this.canonical = canonical;
1:5250d7f:             this.test = test;
1:5250d7f:         }
1:5250d7f: 
1:639d4b2:         RandomSelection select(boolean narrow, boolean mixInNotPresentItems, boolean permitReversal)
1:5250d7f:         {
1:5250d7f:             ThreadLocalRandom random = ThreadLocalRandom.current();
1:5250d7f:             NavigableSet<Integer> canonicalSet = this.canonical;
1:5250d7f:             BTreeSet<Integer> testAsSet = this.test;
1:5250d7f:             List<Integer> canonicalList = new ArrayList<>(canonicalSet);
1:5250d7f:             BTreeSet<Integer> testAsList = this.test;
1:5250d7f: 
1:5250d7f:             Assert.assertEquals(canonicalSet.size(), testAsSet.size());
1:5250d7f:             Assert.assertEquals(canonicalList.size(), testAsList.size());
1:5250d7f: 
1:5250d7f:             // sometimes select keys first, so we cover full range
1:639d4b2:             List<Integer> allKeys = randomKeys(canonical, mixInNotPresentItems);
1:5250d7f:             List<Integer> keys = allKeys;
1:5250d7f: 
1:639d4b2:             int narrowCount = random.nextInt(3);
1:639d4b2:             while (narrow && canonicalList.size() > 10 && keys.size() > 10 && narrowCount-- > 0)
1:5250d7f:             {
1:5250d7f:                 boolean useLb = random.nextBoolean();
1:5250d7f:                 boolean useUb = random.nextBoolean();
1:5250d7f:                 if (!(useLb | useUb))
1:5250d7f:                     continue;
1:5250d7f: 
1:5250d7f:                 // select a range smaller than the total span when we have more narrowing iterations left
1:639d4b2:                 int indexRange = keys.size() / (narrowCount + 1);
1:5250d7f: 
1:5250d7f:                 boolean lbInclusive = true;
1:5250d7f:                 Integer lbKey = canonicalList.get(0);
1:5250d7f:                 int lbKeyIndex = 0, lbIndex = 0;
1:5250d7f:                 boolean ubInclusive = true;
1:5250d7f:                 Integer ubKey = canonicalList.get(canonicalList.size() - 1);
1:5250d7f:                 int ubKeyIndex = keys.size(), ubIndex = canonicalList.size();
1:5250d7f: 
1:5250d7f:                 if (useLb)
1:5250d7f:                 {
1:5250d7f:                     lbKeyIndex = random.nextInt(0, indexRange - 1);
1:5250d7f:                     Integer candidate = keys.get(lbKeyIndex);
1:5250d7f:                     if (useLb = (candidate > lbKey && candidate <= ubKey))
1:5250d7f:                     {
1:5250d7f:                         lbInclusive = random.nextBoolean();
1:5250d7f:                         lbKey = keys.get(lbKeyIndex);
1:5250d7f:                         lbIndex = Collections.binarySearch(canonicalList, lbKey);
1:5250d7f:                         if (lbIndex >= 0 && !lbInclusive) lbIndex++;
1:5250d7f:                         else if (lbIndex < 0) lbIndex = -1 -lbIndex;
1:5250d7f:                     }
1:5250d7f:                 }
1:5250d7f:                 if (useUb)
1:5250d7f:                 {
1:5250d7f:                     ubKeyIndex = random.nextInt(Math.max(lbKeyIndex, keys.size() - indexRange), keys.size() - 1);
1:5250d7f:                     Integer candidate = keys.get(ubKeyIndex);
1:5250d7f:                     if (useUb = (candidate < ubKey && candidate >= lbKey))
1:5250d7f:                     {
1:5250d7f:                         ubInclusive = random.nextBoolean();
1:5250d7f:                         ubKey = keys.get(ubKeyIndex);
1:5250d7f:                         ubIndex = Collections.binarySearch(canonicalList, ubKey);
1:5250d7f:                         if (ubIndex >= 0 && ubInclusive) { ubIndex++; }
1:5250d7f:                         else if (ubIndex < 0) ubIndex = -1 -ubIndex;
1:5250d7f:                     }
1:5250d7f:                 }
1:5250d7f:                 if (ubIndex < lbIndex) { ubIndex = lbIndex; ubKey = lbKey; ubInclusive = false; }
1:5250d7f: 
1:5250d7f:                 canonicalSet = !useLb ? canonicalSet.headSet(ubKey, ubInclusive)
1:5250d7f:                                       : !useUb ? canonicalSet.tailSet(lbKey, lbInclusive)
1:5250d7f:                                                : canonicalSet.subSet(lbKey, lbInclusive, ubKey, ubInclusive);
1:5250d7f:                 testAsSet = !useLb ? testAsSet.headSet(ubKey, ubInclusive)
1:5250d7f:                                    : !useUb ? testAsSet.tailSet(lbKey, lbInclusive)
1:5250d7f:                                             : testAsSet.subSet(lbKey, lbInclusive, ubKey, ubInclusive);
1:5250d7f: 
1:5250d7f:                 keys = keys.subList(lbKeyIndex, ubKeyIndex);
1:5250d7f:                 canonicalList = canonicalList.subList(lbIndex, ubIndex);
1:5250d7f:                 testAsList = testAsList.subList(lbIndex, ubIndex);
1:5250d7f: 
1:5250d7f:                 Assert.assertEquals(canonicalSet.size(), testAsSet.size());
1:5250d7f:                 Assert.assertEquals(canonicalList.size(), testAsList.size());
1:5250d7f:             }
1:5250d7f: 
1:5250d7f:             // possibly restore full set of keys, to test case where we are provided existing keys that are out of bounds
1:5250d7f:             if (keys != allKeys && random.nextBoolean())
1:5250d7f:                 keys = allKeys;
1:5250d7f: 
1:5250d7f:             Comparator<Integer> comparator = naturalOrder();
1:639d4b2:             if (permitReversal && random.nextBoolean())
1:5250d7f:             {
1:5250d7f:                 if (allKeys != keys)
1:5250d7f:                     keys = new ArrayList<>(keys);
1:5250d7f:                 if (canonicalSet != canonical)
1:5250d7f:                     canonicalList = new ArrayList<>(canonicalList);
1:5250d7f:                 Collections.reverse(keys);
1:5250d7f:                 Collections.reverse(canonicalList);
1:5250d7f:                 testAsList = testAsList.descendingSet();
1:5250d7f: 
1:5250d7f:                 canonicalSet = canonicalSet.descendingSet();
1:5250d7f:                 testAsSet = testAsSet.descendingSet();
1:5250d7f:                 comparator = reverseOrder();
1:5250d7f:             }
1:5250d7f: 
1:5250d7f:             Assert.assertEquals(canonicalSet.size(), testAsSet.size());
1:5250d7f:             Assert.assertEquals(canonicalList.size(), testAsList.size());
1:5250d7f:             if (!canonicalSet.isEmpty())
1:5250d7f:             {
1:5250d7f:                 Assert.assertEquals(canonicalSet.first(), canonicalList.get(0));
1:5250d7f:                 Assert.assertEquals(canonicalSet.last(), canonicalList.get(canonicalList.size() - 1));
1:5250d7f:                 Assert.assertEquals(canonicalSet.first(), testAsSet.first());
1:5250d7f:                 Assert.assertEquals(canonicalSet.last(), testAsSet.last());
1:5250d7f:                 Assert.assertEquals(canonicalSet.first(), testAsList.get(0));
1:5250d7f:                 Assert.assertEquals(canonicalSet.last(), testAsList.get(testAsList.size() - 1));
1:5250d7f:             }
1:5250d7f: 
1:5250d7f:             return new RandomSelection(keys, canonicalSet, testAsSet, canonicalList, testAsList, comparator);
1:5250d7f:         }
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     private static RandomTree randomTree(int minSize, int maxSize)
1:5250d7f:     {
1:e51f83b:         // perform most of our tree constructions via update, as this is more efficient; since every run uses this
1:e51f83b:         // we test builder disproportionately more often than if it had its own test anyway
1:e51f83b:         return ThreadLocalRandom.current().nextFloat() < 0.95 ? randomTreeByUpdate(minSize, maxSize)
1:e51f83b:                                                               : randomTreeByBuilder(minSize, maxSize);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     private static RandomTree randomTreeByUpdate(int minSize, int maxSize)
1:5250d7f:     {
1:5250d7f:         assert minSize > 3;
1:5250d7f:         TreeSet<Integer> canonical = new TreeSet<>();
1:5250d7f: 
1:5250d7f:         ThreadLocalRandom random = ThreadLocalRandom.current();
1:5250d7f:         int targetSize = random.nextInt(minSize, maxSize);
1:5250d7f:         int maxModificationSize = random.nextInt(2, targetSize);
1:5250d7f:         Object[] accmumulate = BTree.empty();
1:5250d7f:         int curSize = 0;
1:5250d7f:         while (curSize < targetSize)
1:5250d7f:         {
1:5250d7f:             int nextSize = maxModificationSize == 1 ? 1 : random.nextInt(1, maxModificationSize);
1:5250d7f:             TreeSet<Integer> build = new TreeSet<>();
1:5250d7f:             for (int i = 0 ; i < nextSize ; i++)
1:5250d7f:             {
1:5250d7f:                 Integer next = random.nextInt();
1:5250d7f:                 build.add(next);
1:5250d7f:                 canonical.add(next);
1:5250d7f:             }
1:5250d7f:             accmumulate = BTree.update(accmumulate, naturalOrder(), build, UpdateFunction.<Integer>noOp());
1:5250d7f:             curSize += nextSize;
1:5250d7f:             maxModificationSize = Math.min(maxModificationSize, targetSize - curSize);
1:5250d7f:         }
1:5250d7f:         return new RandomTree(canonical, BTreeSet.<Integer>wrap(accmumulate, naturalOrder()));
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     private static RandomTree randomTreeByBuilder(int minSize, int maxSize)
1:5250d7f:     {
1:5250d7f:         assert minSize > 3;
1:5250d7f:         ThreadLocalRandom random = ThreadLocalRandom.current();
1:5250d7f:         BTree.Builder<Integer> builder = BTree.builder(naturalOrder());
1:5250d7f: 
1:5250d7f:         int targetSize = random.nextInt(minSize, maxSize);
1:5250d7f:         int maxModificationSize = (int) Math.sqrt(targetSize);
1:5250d7f: 
1:5250d7f:         TreeSet<Integer> canonical = new TreeSet<>();
1:5250d7f: 
1:5250d7f:         int curSize = 0;
1:5250d7f:         TreeSet<Integer> ordered = new TreeSet<>();
1:5250d7f:         List<Integer> shuffled = new ArrayList<>();
1:5250d7f:         while (curSize < targetSize)
1:5250d7f:         {
1:5250d7f:             int nextSize = maxModificationSize <= 1 ? 1 : random.nextInt(1, maxModificationSize);
1:5250d7f: 
1:5250d7f:             // leave a random selection of previous values
1:5250d7f:             (random.nextBoolean() ? ordered.headSet(random.nextInt()) : ordered.tailSet(random.nextInt())).clear();
1:5250d7f:             shuffled = new ArrayList<>(shuffled.subList(0, shuffled.size() < 2 ? 0 : random.nextInt(shuffled.size() / 2)));
1:5250d7f: 
1:5250d7f:             for (int i = 0 ; i < nextSize ; i++)
1:5250d7f:             {
1:5250d7f:                 Integer next = random.nextInt();
1:5250d7f:                 ordered.add(next);
1:5250d7f:                 shuffled.add(next);
1:5250d7f:                 canonical.add(next);
1:5250d7f:             }
1:5250d7f: 
1:5250d7f:             switch (random.nextInt(5))
1:5250d7f:             {
1:5250d7f:                 case 0:
1:5250d7f:                     builder.addAll(ordered);
1:5250d7f:                     break;
1:5250d7f:                 case 1:
1:5250d7f:                     builder.addAll(BTreeSet.of(ordered));
1:5250d7f:                     break;
1:5250d7f:                 case 2:
1:5250d7f:                     for (Integer i : ordered)
1:5250d7f:                         builder.add(i);
1:5250d7f:                 case 3:
1:5250d7f:                     builder.addAll(shuffled);
1:5250d7f:                     break;
1:5250d7f:                 case 4:
1:5250d7f:                     for (Integer i : shuffled)
1:5250d7f:                         builder.add(i);
1:5250d7f:             }
1:5250d7f: 
1:5250d7f:             curSize += nextSize;
1:5250d7f:             maxModificationSize = Math.min(maxModificationSize, targetSize - curSize);
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         BTreeSet<Integer> btree = BTreeSet.<Integer>wrap(builder.build(), naturalOrder());
1:5250d7f:         Assert.assertEquals(canonical.size(), btree.size());
1:5250d7f:         return new RandomTree(canonical, btree);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     // select a random subset of the keys, with an optional random population of keys inbetween those that are present
1:5250d7f:     // return a value with the search position
1:639d4b2:     private static List<Integer> randomKeys(Iterable<Integer> canonical, boolean mixInNotPresentItems)
1:5250d7f:     {
1:5250d7f:         ThreadLocalRandom rnd = ThreadLocalRandom.current();
1:639d4b2:         boolean useFake = mixInNotPresentItems && rnd.nextBoolean();
1:5250d7f:         final float fakeRatio = rnd.nextFloat();
1:5250d7f:         List<Integer> results = new ArrayList<>();
1:aef7169:         Long fakeLb = (long) Integer.MIN_VALUE, fakeUb = null;
1:aef7169:         Integer max = null;
1:5250d7f:         for (Integer v : canonical)
1:5250d7f:         {
1:5250d7f:             if (    !useFake
1:aef7169:                 ||  (fakeUb == null ? v - 1 : fakeUb) <= fakeLb + 1
1:5250d7f:                 ||  rnd.nextFloat() < fakeRatio)
1:5250d7f:             {
1:5250d7f:                 // if we cannot safely construct a fake value, or our randomizer says not to, we emit the next real value
1:5250d7f:                 results.add(v);
1:5250d7f:                 fakeLb = v.longValue();
1:5250d7f:                 fakeUb = null;
1:5250d7f:             }
1:5250d7f:             else
1:5250d7f:             {
1:5250d7f:                 // otherwise we emit a fake value in the range immediately proceeding the last real value, and not
1:5250d7f:                 // exceeding the real value that would have proceeded (ignoring any other suppressed real values since)
1:5250d7f:                 if (fakeUb == null)
1:5250d7f:                     fakeUb = v.longValue() - 1;
1:5250d7f:                 long mid = (fakeLb + fakeUb) / 2;
1:5250d7f:                 assert mid < fakeUb;
1:5250d7f:                 results.add((int) mid);
1:5250d7f:                 fakeLb = mid;
1:5250d7f:             }
1:aef7169:             max = v;
1:5250d7f:         }
1:aef7169:         if (useFake && max != null && max < Integer.MAX_VALUE)
1:aef7169:             results.add(max + 1);
1:5250d7f:         final float useChance = rnd.nextFloat();
1:5250d7f:         return Lists.newArrayList(filter(results, (x) -> rnd.nextFloat() < useChance));
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     /************************** TEST MUTATION ********************************************/
1:5250d7f: 
1:5250d7f:     @Test
1:5250d7f:     public void testOversizedMiddleInsert()
1:5250d7f:     {
1:5250d7f:         TreeSet<Integer> canon = new TreeSet<>();
1:5250d7f:         for (int i = 0 ; i < 10000000 ; i++)
1:5250d7f:             canon.add(i);
1:e51f83b:         Object[] btree = BTree.build(Arrays.asList(Integer.MIN_VALUE, Integer.MAX_VALUE), UpdateFunction.noOp());
1:5250d7f:         btree = BTree.update(btree, naturalOrder(), canon, UpdateFunction.<Integer>noOp());
1:5250d7f:         canon.add(Integer.MIN_VALUE);
1:5250d7f:         canon.add(Integer.MAX_VALUE);
1:639d4b2:         assertTrue(BTree.isWellFormed(btree, naturalOrder()));
1:639d4b2:         testEqual("Oversize", BTree.iterator(btree), canon.iterator());
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Test
1:5250d7f:     public void testIndividualInsertsSmallOverlappingRange() throws ExecutionException, InterruptedException
1:5250d7f:     {
1:e51f83b:         testInsertions(50, 1, 1, true);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Test
1:5250d7f:     public void testBatchesSmallOverlappingRange() throws ExecutionException, InterruptedException
1:5250d7f:     {
1:e51f83b:         testInsertions(50, 1, 5, true);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Test
1:5250d7f:     public void testIndividualInsertsMediumSparseRange() throws ExecutionException, InterruptedException
1:5250d7f:     {
1:e51f83b:         testInsertions(perThreadTrees / 10, 500, 10, 1, true);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Test
1:5250d7f:     public void testBatchesMediumSparseRange() throws ExecutionException, InterruptedException
1:5250d7f:     {
1:e51f83b:         testInsertions(500, 10, 10, true);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Test
1:5250d7f:     public void testLargeBatchesLargeRange() throws ExecutionException, InterruptedException
1:5250d7f:     {
1:e51f83b:         testInsertions(perThreadTrees / 10, Math.max(maxTreeSize, 5000), 3, 100, true);
1:e51f83b:     }
1:e51f83b: 
1:e51f83b:     @Test
1:e51f83b:     public void testRandomRangeAndBatches() throws ExecutionException, InterruptedException
1:e51f83b:     {
1:e51f83b:         ThreadLocalRandom random = ThreadLocalRandom.current();
1:e51f83b:         int treeSize = random.nextInt(maxTreeSize / 10, maxTreeSize * 10);
1:e51f83b:         for (int i = 0 ; i < perThreadTrees / 10 ; i++)
1:e51f83b:             testInsertions(threads * 10, treeSize, random.nextInt(1, 100) / 10f, treeSize / 100, true);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Test
1:5250d7f:     public void testSlicingSmallRandomTrees() throws ExecutionException, InterruptedException
1:5250d7f:     {
1:e51f83b:         testInsertions(50, 10, 10, false);
1:5250d7f:     }
1:5250d7f: 
1:e51f83b:     private static void testInsertions(int perTestCount, float testKeyRatio, int modificationBatchSize, boolean quickEquality) throws ExecutionException, InterruptedException
1:e51f83b:     {
1:e51f83b:         int tests = perThreadTrees * threads;
1:e51f83b:         testInsertions(tests, perTestCount, testKeyRatio, modificationBatchSize, quickEquality);
1:e51f83b:     }
1:e51f83b: 
1:e51f83b:     private static void testInsertions(int tests, int perTestCount, float testKeyRatio, int modificationBatchSize, boolean quickEquality) throws ExecutionException, InterruptedException
1:5250d7f:     {
1:5250d7f:         int batchesPerTest = perTestCount / modificationBatchSize;
1:e51f83b:         int testKeyRange = (int) (perTestCount * testKeyRatio);
1:e51f83b:         long totalCount = (long) perTestCount * tests;
1:e51f83b:         log("Performing %d tests of %d operations, with %.2f max size/key-range ratio in batches of ~%d ops",
1:e51f83b:             tests, perTestCount, 1 / testKeyRatio, modificationBatchSize);
1:5250d7f: 
1:5250d7f:         // if we're not doing quick-equality, we can spam with garbage for all the checks we perform, so we'll split the work into smaller chunks
1:5250d7f:         int chunkSize = quickEquality ? tests : (int) (100000 / Math.pow(perTestCount, 2));
1:5250d7f:         for (int chunk = 0 ; chunk < tests ; chunk += chunkSize)
1:5250d7f:         {
1:5250d7f:             final List<ListenableFutureTask<List<ListenableFuture<?>>>> outer = new ArrayList<>();
1:5250d7f:             for (int i = 0 ; i < chunkSize ; i++)
1:5250d7f:             {
1:e51f83b:                 int maxRunLength = modificationBatchSize == 1 ? 1 : ThreadLocalRandom.current().nextInt(1, modificationBatchSize);
1:e51f83b:                 outer.add(doOneTestInsertions(testKeyRange, maxRunLength, modificationBatchSize, batchesPerTest, quickEquality));
1:5250d7f:             }
1:5250d7f: 
1:5250d7f:             final List<ListenableFuture<?>> inner = new ArrayList<>();
1:e51f83b:             long complete = 0;
1:e51f83b:             int reportInterval = Math.max(1000, (int) (totalCount / 10000));
1:e51f83b:             long lastReportAt = 0;
1:5250d7f:             for (ListenableFutureTask<List<ListenableFuture<?>>> f : outer)
1:5250d7f:             {
1:5250d7f:                 inner.addAll(f.get());
1:5250d7f:                 complete += perTestCount;
1:5250d7f:                 if (complete - lastReportAt >= reportInterval)
1:5250d7f:                 {
1:e51f83b:                     long done = (chunk * perTestCount) + complete;
1:e51f83b:                     float ratio = done / (float) totalCount;
1:e51f83b:                     log("Completed %.1f%% (%d of %d operations)", ratio * 100, done, totalCount);
1:5250d7f:                     lastReportAt = complete;
1:5250d7f:                 }
1:5250d7f:             }
1:5250d7f:             Futures.allAsList(inner).get();
1:5250d7f:         }
1:5250d7f:         Snapshot snap = BTREE_TIMER.getSnapshot();
1:e51f83b:         log("btree: %.2fns, %.2fns, %.2fns", snap.getMedian(), snap.get95thPercentile(), snap.get999thPercentile());
1:5250d7f:         snap = TREE_TIMER.getSnapshot();
1:e51f83b:         log("java: %.2fns, %.2fns, %.2fns", snap.getMedian(), snap.get95thPercentile(), snap.get999thPercentile());
1:e51f83b:         log("Done");
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     private static ListenableFutureTask<List<ListenableFuture<?>>> doOneTestInsertions(final int upperBound, final int maxRunLength, final int averageModsPerIteration, final int iterations, final boolean quickEquality)
1:5250d7f:     {
1:5250d7f:         ListenableFutureTask<List<ListenableFuture<?>>> f = ListenableFutureTask.create(new Callable<List<ListenableFuture<?>>>()
1:5250d7f:         {
1:5250d7f:             @Override
1:5250d7f:             public List<ListenableFuture<?>> call()
1:5250d7f:             {
1:5250d7f:                 final List<ListenableFuture<?>> r = new ArrayList<>();
1:5250d7f:                 NavigableMap<Integer, Integer> canon = new TreeMap<>();
1:5250d7f:                 Object[] btree = BTree.empty();
1:5250d7f:                 final TreeMap<Integer, Integer> buffer = new TreeMap<>();
1:e51f83b:                 ThreadLocalRandom rnd = ThreadLocalRandom.current();
1:5250d7f:                 for (int i = 0 ; i < iterations ; i++)
1:5250d7f:                 {
1:5250d7f:                     buffer.clear();
1:e51f83b:                     int mods = rnd.nextInt(1, averageModsPerIteration * 2);
1:5250d7f:                     while (mods > 0)
1:5250d7f:                     {
1:5250d7f:                         int v = rnd.nextInt(upperBound);
1:5250d7f:                         int rc = Math.max(0, Math.min(mods, maxRunLength) - 1);
1:5250d7f:                         int c = 1 + (rc <= 0 ? 0 : rnd.nextInt(rc));
1:5250d7f:                         for (int j = 0 ; j < c ; j++)
1:5250d7f:                         {
1:5250d7f:                             buffer.put(v, v);
1:5250d7f:                             v++;
1:5250d7f:                         }
1:5250d7f:                         mods -= c;
1:5250d7f:                     }
1:5250d7f:                     Timer.Context ctxt;
1:5250d7f:                     ctxt = TREE_TIMER.time();
1:5250d7f:                     canon.putAll(buffer);
1:5250d7f:                     ctxt.stop();
1:5250d7f:                     ctxt = BTREE_TIMER.time();
1:5250d7f:                     Object[] next = null;
1:5250d7f:                     while (next == null)
1:5250d7f:                         next = BTree.update(btree, naturalOrder(), buffer.keySet(), SPORADIC_ABORT);
1:5250d7f:                     btree = next;
1:5250d7f:                     ctxt.stop();
1:5250d7f: 
1:5250d7f:                     if (!BTree.isWellFormed(btree, naturalOrder()))
1:5250d7f:                     {
1:e51f83b:                         log("ERROR: Not well formed");
1:5250d7f:                         throw new AssertionError("Not well formed!");
1:5250d7f:                     }
1:5250d7f:                     if (quickEquality)
1:639d4b2:                         testEqual("", BTree.iterator(btree), canon.keySet().iterator());
1:5250d7f:                     else
1:5250d7f:                         r.addAll(testAllSlices("RND", btree, new TreeSet<>(canon.keySet())));
1:5250d7f:                 }
1:5250d7f:                 return r;
1:5250d7f:             }
1:5250d7f:         });
1:5250d7f:         if (DEBUG)
1:5250d7f:             f.run();
1:5250d7f:         else
1:5250d7f:             MODIFY.execute(f);
1:5250d7f:         return f;
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     @Test
1:5250d7f:     public void testSlicingAllSmallTrees() throws ExecutionException, InterruptedException
1:5250d7f:     {
1:5250d7f:         Object[] cur = BTree.empty();
1:5250d7f:         TreeSet<Integer> canon = new TreeSet<>();
1:5250d7f:         // we set FAN_FACTOR to 4, so 128 items is four levels deep, three fully populated
1:5250d7f:         for (int i = 0 ; i < 128 ; i++)
1:5250d7f:         {
1:5250d7f:             String id = String.format("[0..%d)", canon.size());
1:e51f83b:             log("Testing " + id);
1:5250d7f:             Futures.allAsList(testAllSlices(id, cur, canon)).get();
1:5250d7f:             Object[] next = null;
1:5250d7f:             while (next == null)
1:5250d7f:                 next = BTree.update(cur, naturalOrder(), Arrays.asList(i), SPORADIC_ABORT);
1:5250d7f:             cur = next;
1:5250d7f:             canon.add(i);
1:5250d7f:         }
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     private static List<ListenableFuture<?>> testAllSlices(String id, Object[] btree, NavigableSet<Integer> canon)
1:5250d7f:     {
1:5250d7f:         List<ListenableFuture<?>> waitFor = new ArrayList<>();
1:5250d7f:         testAllSlices(id + " ASC", new BTreeSet<>(btree, naturalOrder()), canon, true, waitFor);
1:5250d7f:         testAllSlices(id + " DSC", new BTreeSet<Integer>(btree, naturalOrder()).descendingSet(), canon.descendingSet(), false, waitFor);
1:5250d7f:         return waitFor;
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     private static void testAllSlices(String id, NavigableSet<Integer> btree, NavigableSet<Integer> canon, boolean ascending, List<ListenableFuture<?>> results)
1:5250d7f:     {
1:5250d7f:         testOneSlice(id, btree, canon, results);
1:5250d7f:         for (Integer lb : range(canon.size(), Integer.MIN_VALUE, ascending))
1:5250d7f:         {
1:5250d7f:             // test head/tail sets
1:5250d7f:             testOneSlice(String.format("%s->[..%d)", id, lb), btree.headSet(lb, true), canon.headSet(lb, true), results);
1:5250d7f:             testOneSlice(String.format("%s->(..%d)", id, lb), btree.headSet(lb, false), canon.headSet(lb, false), results);
1:5250d7f:             testOneSlice(String.format("%s->(%d..]", id, lb), btree.tailSet(lb, true), canon.tailSet(lb, true), results);
1:5250d7f:             testOneSlice(String.format("%s->(%d..]", id, lb), btree.tailSet(lb, false), canon.tailSet(lb, false), results);
1:5250d7f:             for (Integer ub : range(canon.size(), lb, ascending))
1:5250d7f:             {
1:5250d7f:                 // test subsets
1:5250d7f:                 testOneSlice(String.format("%s->[%d..%d]", id, lb, ub), btree.subSet(lb, true, ub, true), canon.subSet(lb, true, ub, true), results);
1:5250d7f:                 testOneSlice(String.format("%s->(%d..%d]", id, lb, ub), btree.subSet(lb, false, ub, true), canon.subSet(lb, false, ub, true), results);
1:5250d7f:                 testOneSlice(String.format("%s->[%d..%d)", id, lb, ub), btree.subSet(lb, true, ub, false), canon.subSet(lb, true, ub, false), results);
1:5250d7f:                 testOneSlice(String.format("%s->(%d..%d)", id, lb, ub), btree.subSet(lb, false, ub, false), canon.subSet(lb, false, ub, false), results);
1:5250d7f:             }
1:5250d7f:         }
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     private static void testOneSlice(final String id, final NavigableSet<Integer> test, final NavigableSet<Integer> canon, List<ListenableFuture<?>> results)
1:5250d7f:     {
1:5250d7f:         ListenableFutureTask<?> f = ListenableFutureTask.create(new Runnable()
1:5250d7f:         {
1:5250d7f: 
1:5250d7f:             @Override
1:5250d7f:             public void run()
1:5250d7f:             {
1:5250d7f:                 test(id + " Count", test.size(), canon.size());
1:5250d7f:                 testEqual(id, test.iterator(), canon.iterator());
1:5250d7f:                 testEqual(id + "->DSCI", test.descendingIterator(), canon.descendingIterator());
1:5250d7f:                 testEqual(id + "->DSCS", test.descendingSet().iterator(), canon.descendingSet().iterator());
1:5250d7f:                 testEqual(id + "->DSCS->DSCI", test.descendingSet().descendingIterator(), canon.descendingSet().descendingIterator());
1:5250d7f:             }
1:5250d7f:         }, null);
1:5250d7f:         results.add(f);
1:5250d7f:         if (DEBUG)
1:5250d7f:             f.run();
1:5250d7f:         else
1:5250d7f:             COMPARE.execute(f);
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     private static void test(String id, int test, int expect)
1:5250d7f:     {
1:5250d7f:         if (test != expect)
1:5250d7f:         {
1:e51f83b:             log("%s: Expected %d, Got %d", id, expect, test);
1:5250d7f:         }
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     private static <V> void testEqual(String id, Iterator<V> btree, Iterator<V> canon)
1:5250d7f:     {
1:5250d7f:         boolean equal = true;
1:5250d7f:         while (btree.hasNext() && canon.hasNext())
1:5250d7f:         {
1:5250d7f:             Object i = btree.next();
1:5250d7f:             Object j = canon.next();
1:5250d7f:             if (!Objects.equals(i, j))
1:5250d7f:             {
1:e51f83b:                 log("%s: Expected %d, Got %d", id, j, i);
1:5250d7f:                 equal = false;
1:5250d7f:             }
1:5250d7f:         }
1:5250d7f:         while (btree.hasNext())
1:5250d7f:         {
1:e51f83b:             log("%s: Expected <Nil>, Got %d", id, btree.next());
1:5250d7f:             equal = false;
1:5250d7f:         }
1:5250d7f:         while (canon.hasNext())
1:5250d7f:         {
1:e51f83b:             log("%s: Expected %d, Got Nil", id, canon.next());
1:5250d7f:             equal = false;
1:5250d7f:         }
1:5250d7f:         if (!equal)
1:5250d7f:             throw new AssertionError("Not equal");
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     // should only be called on sets that range from 0->N or N->0
1:5250d7f:     private static final Iterable<Integer> range(final int size, final int from, final boolean ascending)
1:5250d7f:     {
1:5250d7f:         return new Iterable<Integer>()
1:5250d7f:         {
1:5250d7f:             int cur;
1:5250d7f:             int delta;
1:5250d7f:             int end;
1:5250d7f:             {
1:5250d7f:                 if (ascending)
1:5250d7f:                 {
1:5250d7f:                     end = size + 1;
1:5250d7f:                     cur = from == Integer.MIN_VALUE ? -1 : from;
1:5250d7f:                     delta = 1;
1:5250d7f:                 }
1:5250d7f:                 else
1:5250d7f:                 {
1:5250d7f:                     end = -2;
1:5250d7f:                     cur = from == Integer.MIN_VALUE ? size : from;
1:5250d7f:                     delta = -1;
1:5250d7f:                 }
1:5250d7f:             }
1:5250d7f:             @Override
1:5250d7f:             public Iterator<Integer> iterator()
1:5250d7f:             {
1:5250d7f:                 return new Iterator<Integer>()
1:5250d7f:                 {
1:5250d7f:                     @Override
1:5250d7f:                     public boolean hasNext()
1:5250d7f:                     {
1:5250d7f:                         return cur != end;
1:5250d7f:                     }
1:5250d7f: 
1:5250d7f:                     @Override
1:5250d7f:                     public Integer next()
1:5250d7f:                     {
1:5250d7f:                         Integer r = cur;
1:5250d7f:                         cur += delta;
1:5250d7f:                         return r;
1:5250d7f:                     }
1:5250d7f: 
1:5250d7f:                     @Override
1:5250d7f:                     public void remove()
1:5250d7f:                     {
1:5250d7f:                         throw new UnsupportedOperationException();
1:5250d7f:                     }
1:5250d7f:                 };
1:5250d7f:             }
1:5250d7f:         };
1:5250d7f:     }
1:5250d7f: 
1:5250d7f:     private static final class RandomAbort<V> implements UpdateFunction<V, V>
1:5250d7f:     {
1:5250d7f:         final Random rnd;
1:5250d7f:         final float chance;
1:5250d7f:         private RandomAbort(Random rnd, float chance)
1:5250d7f:         {
1:5250d7f:             this.rnd = rnd;
1:5250d7f:             this.chance = chance;
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         public V apply(V replacing, V update)
1:5250d7f:         {
1:5250d7f:             return update;
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         public boolean abortEarly()
1:5250d7f:         {
1:5250d7f:             return rnd.nextFloat() < chance;
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         public void allocated(long heapSize)
1:5250d7f:         {
1:5250d7f:         }
1:5250d7f: 
1:5250d7f:         public V apply(V v)
1:5250d7f:         {
1:5250d7f:             return v;
1:5250d7f:         }
1:5250d7f:     }
1:e51f83b: 
1:e51f83b:     public static void main(String[] args) throws ExecutionException, InterruptedException, InvocationTargetException, IllegalAccessException
1:e51f83b:     {
1:e51f83b:         for (String arg : args)
1:e51f83b:         {
1:e51f83b:             if (arg.startsWith("fan="))
1:e51f83b:                 System.setProperty("cassandra.btree.fanfactor", arg.substring(4));
1:e51f83b:             else if (arg.startsWith("min="))
1:e51f83b:                 minTreeSize = Integer.parseInt(arg.substring(4));
1:e51f83b:             else if (arg.startsWith("max="))
1:e51f83b:                 maxTreeSize = Integer.parseInt(arg.substring(4));
1:e51f83b:             else if (arg.startsWith("count="))
1:e51f83b:                 perThreadTrees = Integer.parseInt(arg.substring(6));
1:e51f83b:             else
1:e51f83b:                 exit();
1:e51f83b:         }
1:e51f83b: 
1:e51f83b:         List<Method> methods = new ArrayList<>();
1:e51f83b:         for (Method m : LongBTreeTest.class.getDeclaredMethods())
1:e51f83b:         {
1:e51f83b:             if (m.getParameters().length > 0)
1:e51f83b:                 continue;
1:e51f83b:             for (Annotation annotation : m.getAnnotations())
1:e51f83b:                 if (annotation.annotationType() == Test.class)
1:e51f83b:                     methods.add(m);
1:e51f83b:         }
1:e51f83b: 
1:e51f83b:         LongBTreeTest test = new LongBTreeTest();
1:e51f83b:         Collections.sort(methods, (a, b) -> a.getName().compareTo(b.getName()));
1:e51f83b:         log(Lists.transform(methods, (m) -> m.getName()).toString());
1:e51f83b:         for (Method m : methods)
1:e51f83b:         {
1:e51f83b:             log(m.getName());
1:e51f83b:             m.invoke(test);
1:e51f83b:         }
1:e51f83b:         log("success");
1:e51f83b:     }
1:e51f83b: 
1:e51f83b:     private static void exit()
1:e51f83b:     {
1:e51f83b:         log("usage: fan=<int> min=<int> max=<int> count=<int>");
1:e51f83b:         log("fan:   btree fanout");
1:e51f83b:         log("min:   minimum btree size (must be >= 4)");
1:e51f83b:         log("max:   maximum btree size (must be >= 4)");
1:e51f83b:         log("count: number of trees to assign each core, for each test");
1:e51f83b:     }
1:e51f83b: 
1:e51f83b:     private static void log(String formatstr, Object ... args)
1:e51f83b:     {
1:e51f83b:         args = Arrays.copyOf(args, args.length + 1);
1:e51f83b:         System.arraycopy(args, 0, args, 1, args.length - 1);
1:e51f83b:         args[0] = System.currentTimeMillis();
1:e51f83b:         System.out.printf("%tT: " + formatstr + "\n", args);
1:e51f83b:     }
1:5250d7f: }
============================================================================
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:aef7169
/////////////////////////////////////////////////////////////////////////
1:         Long fakeLb = (long) Integer.MIN_VALUE, fakeUb = null;
1:         Integer max = null;
1:                 ||  (fakeUb == null ? v - 1 : fakeUb) <= fakeLb + 1
/////////////////////////////////////////////////////////////////////////
1:             max = v;
1:         if (useFake && max != null && max < Integer.MAX_VALUE)
1:             results.add(max + 1);
commit:e51f83b
/////////////////////////////////////////////////////////////////////////
1: import java.lang.annotation.Annotation;
1: import java.lang.reflect.InvocationTargetException;
1: import java.lang.reflect.Method;
/////////////////////////////////////////////////////////////////////////
1:     private static final boolean DEBUG = false;
1:     private static int minTreeSize = 4;
1:     private static int maxTreeSize = 10000;
1:     private static int threads = DEBUG ? 1 : Runtime.getRuntime().availableProcessors() * 8;
1:     private static final ExecutorService MODIFY = Executors.newFixedThreadPool(threads, new NamedThreadFactory("MODIFY"));
1:     private static final ExecutorService COMPARE = DEBUG ? MODIFY : Executors.newFixedThreadPool(threads, new NamedThreadFactory("COMPARE"));
/////////////////////////////////////////////////////////////////////////
1:             log("%.1f%% complete %s", 100 * count.get() / (double) totalCount, errors.get() > 0 ? ("Errors: " + errors.get()) : "");
/////////////////////////////////////////////////////////////////////////
1:         // perform most of our tree constructions via update, as this is more efficient; since every run uses this
1:         // we test builder disproportionately more often than if it had its own test anyway
1:         return ThreadLocalRandom.current().nextFloat() < 0.95 ? randomTreeByUpdate(minSize, maxSize)
1:                                                               : randomTreeByBuilder(minSize, maxSize);
/////////////////////////////////////////////////////////////////////////
1:         Object[] btree = BTree.build(Arrays.asList(Integer.MIN_VALUE, Integer.MAX_VALUE), UpdateFunction.noOp());
/////////////////////////////////////////////////////////////////////////
1:         testInsertions(50, 1, 1, true);
1:         testInsertions(50, 1, 5, true);
1:         testInsertions(perThreadTrees / 10, 500, 10, 1, true);
1:         testInsertions(500, 10, 10, true);
1:         testInsertions(perThreadTrees / 10, Math.max(maxTreeSize, 5000), 3, 100, true);
1:     }
1: 
1:     @Test
1:     public void testRandomRangeAndBatches() throws ExecutionException, InterruptedException
1:     {
1:         ThreadLocalRandom random = ThreadLocalRandom.current();
1:         int treeSize = random.nextInt(maxTreeSize / 10, maxTreeSize * 10);
1:         for (int i = 0 ; i < perThreadTrees / 10 ; i++)
1:             testInsertions(threads * 10, treeSize, random.nextInt(1, 100) / 10f, treeSize / 100, true);
1:         testInsertions(50, 10, 10, false);
1:     private static void testInsertions(int perTestCount, float testKeyRatio, int modificationBatchSize, boolean quickEquality) throws ExecutionException, InterruptedException
1:     {
1:         int tests = perThreadTrees * threads;
1:         testInsertions(tests, perTestCount, testKeyRatio, modificationBatchSize, quickEquality);
1:     }
1: 
1:     private static void testInsertions(int tests, int perTestCount, float testKeyRatio, int modificationBatchSize, boolean quickEquality) throws ExecutionException, InterruptedException
1:         int testKeyRange = (int) (perTestCount * testKeyRatio);
1:         long totalCount = (long) perTestCount * tests;
1:         log("Performing %d tests of %d operations, with %.2f max size/key-range ratio in batches of ~%d ops",
1:             tests, perTestCount, 1 / testKeyRatio, modificationBatchSize);
/////////////////////////////////////////////////////////////////////////
1:                 int maxRunLength = modificationBatchSize == 1 ? 1 : ThreadLocalRandom.current().nextInt(1, modificationBatchSize);
1:                 outer.add(doOneTestInsertions(testKeyRange, maxRunLength, modificationBatchSize, batchesPerTest, quickEquality));
1:             long complete = 0;
1:             int reportInterval = Math.max(1000, (int) (totalCount / 10000));
1:             long lastReportAt = 0;
1:                     long done = (chunk * perTestCount) + complete;
1:                     float ratio = done / (float) totalCount;
1:                     log("Completed %.1f%% (%d of %d operations)", ratio * 100, done, totalCount);
1:         log("btree: %.2fns, %.2fns, %.2fns", snap.getMedian(), snap.get95thPercentile(), snap.get999thPercentile());
1:         log("java: %.2fns, %.2fns, %.2fns", snap.getMedian(), snap.get95thPercentile(), snap.get999thPercentile());
1:         log("Done");
/////////////////////////////////////////////////////////////////////////
1:                 ThreadLocalRandom rnd = ThreadLocalRandom.current();
1:                     int mods = rnd.nextInt(1, averageModsPerIteration * 2);
/////////////////////////////////////////////////////////////////////////
1:                         log("ERROR: Not well formed");
/////////////////////////////////////////////////////////////////////////
1:             log("Testing " + id);
/////////////////////////////////////////////////////////////////////////
1:             log("%s: Expected %d, Got %d", id, expect, test);
/////////////////////////////////////////////////////////////////////////
1:                 log("%s: Expected %d, Got %d", id, j, i);
1:             log("%s: Expected <Nil>, Got %d", id, btree.next());
1:             log("%s: Expected %d, Got Nil", id, canon.next());
/////////////////////////////////////////////////////////////////////////
1: 
1:     public static void main(String[] args) throws ExecutionException, InterruptedException, InvocationTargetException, IllegalAccessException
1:     {
1:         for (String arg : args)
1:         {
1:             if (arg.startsWith("fan="))
1:                 System.setProperty("cassandra.btree.fanfactor", arg.substring(4));
1:             else if (arg.startsWith("min="))
1:                 minTreeSize = Integer.parseInt(arg.substring(4));
1:             else if (arg.startsWith("max="))
1:                 maxTreeSize = Integer.parseInt(arg.substring(4));
1:             else if (arg.startsWith("count="))
1:                 perThreadTrees = Integer.parseInt(arg.substring(6));
1:             else
1:                 exit();
1:         }
1: 
1:         List<Method> methods = new ArrayList<>();
1:         for (Method m : LongBTreeTest.class.getDeclaredMethods())
1:         {
1:             if (m.getParameters().length > 0)
1:                 continue;
1:             for (Annotation annotation : m.getAnnotations())
1:                 if (annotation.annotationType() == Test.class)
1:                     methods.add(m);
1:         }
1: 
1:         LongBTreeTest test = new LongBTreeTest();
1:         Collections.sort(methods, (a, b) -> a.getName().compareTo(b.getName()));
1:         log(Lists.transform(methods, (m) -> m.getName()).toString());
1:         for (Method m : methods)
1:         {
1:             log(m.getName());
1:             m.invoke(test);
1:         }
1:         log("success");
1:     }
1: 
1:     private static void exit()
1:     {
1:         log("usage: fan=<int> min=<int> max=<int> count=<int>");
1:         log("fan:   btree fanout");
1:         log("min:   minimum btree size (must be >= 4)");
1:         log("max:   maximum btree size (must be >= 4)");
1:         log("count: number of trees to assign each core, for each test");
1:     }
1: 
1:     private static void log(String formatstr, Object ... args)
1:     {
1:         args = Arrays.copyOf(args, args.length + 1);
1:         System.arraycopy(args, 0, args, 1, args.length - 1);
1:         args[0] = System.currentTimeMillis();
1:         System.out.printf("%tT: " + formatstr + "\n", args);
1:     }
commit:639d4b2
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.base.Function;
/////////////////////////////////////////////////////////////////////////
1: import static com.google.common.base.Predicates.notNull;
1: import static com.google.common.collect.Iterables.transform;
1: import static org.apache.cassandra.utils.btree.BTree.iterable;
1: import static org.junit.Assert.assertTrue;
0:     private static int minTreeSize = 5;
0:     private static int maxTreeSize = 15;
0:     private static final boolean DEBUG = true;
/////////////////////////////////////////////////////////////////////////
1:                                  (test, canonical) -> {
1:                                      if (!canonical.isEmpty() || !test.isEmpty())
1:                                      {
1:                                          Assert.assertEquals(canonical.isEmpty(), test.isEmpty());
1:                                          Assert.assertEquals(canonical.first(), test.first());
1:                                          Assert.assertEquals(canonical.last(), test.last());
1:                                      }
1:                                      return (key) ->
1:                                      {
1:                                          Assert.assertEquals(test.ceiling(key), canonical.ceiling(key));
1:                                          Assert.assertEquals(test.higher(key), canonical.higher(key));
1:                                          Assert.assertEquals(test.floor(key), canonical.floor(key));
1:                                          Assert.assertEquals(test.lower(key), canonical.lower(key));
1:                                      };
1:                                  });
1:                                   (test, canonical, cmp) ->
1:                                   (key) ->
1:                                   {
1:                                       int javaIndex = Collections.binarySearch(canonical, key, cmp);
1:                                       int btreeIndex = test.indexOf(key);
1:                                       Assert.assertEquals(javaIndex, btreeIndex);
1:                                       if (javaIndex >= 0)
1:                                           Assert.assertEquals(canonical.get(javaIndex), test.get(btreeIndex));
1:                                   }
/////////////////////////////////////////////////////////////////////////
1:                             (selection) ->
1:                             {
1:                                 Integer[] array = new Integer[selection.canonicalList.size() + 1];
1:                                 selection.testAsList.toArray(array, 1);
1:                                 Assert.assertEquals(null, array[0]);
1:                                 for (int j = 0; j < selection.canonicalList.size(); j++)
1:                                     Assert.assertEquals(selection.canonicalList.get(j), array[j + 1]);
1:                             });
1:     }
1: 
1:     private static final class CountingFunction implements Function<Integer, Integer>
1:     {
1:         final Function<Integer, Integer> wrapped;
1:         int count = 0;
1:         protected CountingFunction(Function<Integer, Integer> wrapped)
1:         {
1:             this.wrapped = wrapped;
1:         }
1:         public Integer apply(Integer integer)
1:         {
1:             count++;
1:             return wrapped.apply(integer);
1:         }
1:     }
1: 
1:     @Test
1:     public void testTransformAndFilter() throws InterruptedException
1:     {
1:         testRandomSelection(perThreadTrees, 4, false, false, false,
1:                             (selection) ->
1:                             {
1:                                 Map<Integer, Integer> update = new LinkedHashMap<>();
1:                                 for (Integer i : selection.testKeys)
1:                                     update.put(i, new Integer(i));
1: 
1:                                 CountingFunction function;
1:                                 Object[] original = selection.testAsSet.tree();
1:                                 Object[] transformed;
1: 
1:                                 // test replacing none, leaving all present
1:                                 function = new CountingFunction((x) -> x);
1:                                 transformed = BTree.transformAndFilter(original, function);
1:                                 Assert.assertEquals(BTree.size(original), function.count);
1:                                 Assert.assertSame(original, transformed);
1: 
1:                                 // test replacing some, leaving all present
1:                                 function = new CountingFunction((x) -> update.containsKey(x) ? update.get(x) : x);
1:                                 transformed = BTree.transformAndFilter(original, function);
1:                                 Assert.assertEquals(BTree.size(original), function.count);
1:                                 assertSame(transform(selection.canonicalList, function.wrapped), iterable(transformed));
1: 
1:                                 // test replacing some, removing some
1:                                 function = new CountingFunction(update::get);
1:                                 transformed = BTree.transformAndFilter(original, function);
1:                                 Assert.assertEquals(BTree.size(original), function.count);
1:                                 assertSame(filter(transform(selection.canonicalList, function.wrapped), notNull()), iterable(transformed));
1: 
1:                                 // test replacing none, removing some
1:                                 function = new CountingFunction((x) -> update.containsKey(x) ? null : x);
1:                                 transformed = BTree.transformAndFilter(selection.testAsList.tree(), function);
1:                                 Assert.assertEquals(BTree.size(original), function.count);
1:                                 assertSame(filter(transform(selection.canonicalList, function.wrapped), notNull()), iterable(transformed));
1:                             });
1:     }
1: 
1:     private static void assertSame(Iterable<Integer> i1, Iterable<Integer> i2)
1:     {
1:         assertSame(i1.iterator(), i2.iterator());
1:     }
1: 
1:     private static void assertSame(Iterator<Integer> i1, Iterator<Integer> i2)
1:     {
1:         while (i1.hasNext() && i2.hasNext())
1:             Assert.assertSame(i1.next(), i2.next());
1:         Assert.assertEquals(i1.hasNext(), i2.hasNext());
/////////////////////////////////////////////////////////////////////////
1: 
1:         testRandomSelection(perThreadTrees, perTreeSelections, true, true, true, testRun);
1:     }
1: 
1:     private void testRandomSelection(int perThreadTrees, int perTreeSelections, boolean narrow, boolean mixInNotPresentItems, boolean permitReversal, Consumer<RandomSelection> testRun) throws InterruptedException
1:     {
/////////////////////////////////////////////////////////////////////////
1:                             RandomTree tree = randomTree(minTreeSize, maxTreeSize);
1:                                 testRun.accept(tree.select(narrow, mixInNotPresentItems, permitReversal));
/////////////////////////////////////////////////////////////////////////
1:         RandomSelection select(boolean narrow, boolean mixInNotPresentItems, boolean permitReversal)
/////////////////////////////////////////////////////////////////////////
1:             List<Integer> allKeys = randomKeys(canonical, mixInNotPresentItems);
1:             int narrowCount = random.nextInt(3);
1:             while (narrow && canonicalList.size() > 10 && keys.size() > 10 && narrowCount-- > 0)
/////////////////////////////////////////////////////////////////////////
1:                 int indexRange = keys.size() / (narrowCount + 1);
/////////////////////////////////////////////////////////////////////////
1:             if (permitReversal && random.nextBoolean())
/////////////////////////////////////////////////////////////////////////
1:     private static List<Integer> randomKeys(Iterable<Integer> canonical, boolean mixInNotPresentItems)
1:         boolean useFake = mixInNotPresentItems && rnd.nextBoolean();
/////////////////////////////////////////////////////////////////////////
1:         assertTrue(BTree.isWellFormed(btree, naturalOrder()));
1:         testEqual("Oversize", BTree.iterator(btree), canon.iterator());
/////////////////////////////////////////////////////////////////////////
1:                         testEqual("", BTree.iterator(btree), canon.keySet().iterator());
commit:5250d7f
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.cassandra.utils;
1: 
1: import java.util.*;
1: import java.util.concurrent.Callable;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.ExecutionException;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.ThreadLocalRandom;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicLong;
1: import java.util.function.Consumer;
1: 
0: import com.google.common.collect.Iterators;
1: import com.google.common.collect.Lists;
1: import com.google.common.util.concurrent.Futures;
1: import com.google.common.util.concurrent.ListenableFuture;
1: import com.google.common.util.concurrent.ListenableFutureTask;
1: import org.junit.Assert;
1: import org.junit.Test;
1: 
1: import com.codahale.metrics.MetricRegistry;
1: import com.codahale.metrics.Snapshot;
1: import com.codahale.metrics.Timer;
1: import org.apache.cassandra.concurrent.NamedThreadFactory;
1: import org.apache.cassandra.utils.btree.*;
1: 
1: import static com.google.common.collect.Iterables.filter;
1: import static java.util.Comparator.naturalOrder;
1: import static java.util.Comparator.reverseOrder;
1: 
1: public class LongBTreeTest
1: {
1: 
1:     private static int perThreadTrees = 10000;
0:     private static final boolean DEBUG = false;
1:     private static final MetricRegistry metrics = new MetricRegistry();
1:     private static final Timer BTREE_TIMER = metrics.timer(MetricRegistry.name(BTree.class, "BTREE"));
1:     private static final Timer TREE_TIMER = metrics.timer(MetricRegistry.name(BTree.class, "TREE"));
0:     private static final ExecutorService MODIFY = Executors.newFixedThreadPool(DEBUG ? 1 : Runtime.getRuntime().availableProcessors(), new NamedThreadFactory("MODIFY"));
0:     private static final ExecutorService COMPARE = DEBUG ? MODIFY : Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), new NamedThreadFactory("COMPARE"));
1:     private static final RandomAbort<Integer> SPORADIC_ABORT = new RandomAbort<>(new Random(), 0.0001f);
1: 
1:     static
1:     {
1:         System.setProperty("cassandra.btree.fanfactor", "4");
1:     }
1: 
1:     /************************** TEST ACCESS ********************************************/
1: 
1:     @Test
1:     public void testSearchIterator() throws InterruptedException
1:     {
1:         final int perTreeSelections = 100;
1:         testRandomSelection(perThreadTrees, perTreeSelections,
1:         (test) -> {
1:             IndexedSearchIterator<Integer, Integer> iter1 = test.testAsSet.iterator();
1:             IndexedSearchIterator<Integer, Integer> iter2 = test.testAsList.iterator();
1:             return (key) ->
1:             {
1:                 Integer found1 = iter1.hasNext() ? iter1.next(key) : null;
1:                 Integer found2 = iter2.hasNext() ? iter2.next(key) : null;
1:                 Assert.assertSame(found1, found2);
1:                 if (found1 != null)
1:                     Assert.assertEquals(iter1.indexOfCurrent(), iter2.indexOfCurrent());
1: 
1:                 int index = Collections.binarySearch(test.canonicalList, key, test.comparator);
1:                 if (index < 0)
1:                 {
1:                     Assert.assertNull(found1);
1:                 }
1:                 else
1:                 {
1:                     Assert.assertEquals(key, found1);
1:                     Assert.assertEquals(index, iter1.indexOfCurrent());
1:                 }
1: 
1:                 // check that by advancing the same key again we get null, but only do it on one of the two iterators
1:                 // to ensure they both advance differently
1:                 if (ThreadLocalRandom.current().nextBoolean())
1:                     Assert.assertNull(iter1.next(key));
1:                 else
1:                     Assert.assertNull(iter2.next(key));
1:             };
1:         });
1:     }
1: 
1:     @Test
1:     public void testInequalityLookups() throws InterruptedException
1:     {
1:         final int perTreeSelections = 2;
1:         testRandomSelectionOfSet(perThreadTrees, perTreeSelections,
0:          (test, canonical) -> {
0:              if (!canonical.isEmpty() || !test.isEmpty())
1:              {
0:                  Assert.assertEquals(canonical.isEmpty(), test.isEmpty());
0:                  Assert.assertEquals(canonical.first(), test.first());
0:                  Assert.assertEquals(canonical.last(), test.last());
1:              }
1:              return (key) ->
1:              {
0:                  Assert.assertEquals(test.ceiling(key), canonical.ceiling(key));
0:                  Assert.assertEquals(test.higher(key), canonical.higher(key));
0:                  Assert.assertEquals(test.floor(key), canonical.floor(key));
0:                  Assert.assertEquals(test.lower(key), canonical.lower(key));
1:              };
1:          });
1:     }
1: 
1:     @Test
1:     public void testListIndexes() throws InterruptedException
1:     {
1:         testRandomSelectionOfList(perThreadTrees, 4,
0:           (test, canonical, cmp) ->
0:           (key) ->
1:           {
0:               int javaIndex = Collections.binarySearch(canonical, key, cmp);
0:               int btreeIndex = test.indexOf(key);
0:               Assert.assertEquals(javaIndex, btreeIndex);
0:               if (javaIndex >= 0)
0:                   Assert.assertEquals(canonical.get(javaIndex), test.get(btreeIndex));
1:           }
1:         );
1:     }
1: 
1:     @Test
1:     public void testToArray() throws InterruptedException
1:     {
1:         testRandomSelection(perThreadTrees, 4,
0:           (selection) ->
1:           {
0:               Integer[] array = new Integer[selection.canonicalList.size() + 1];
0:               selection.testAsList.toArray(array, 1);
0:               Assert.assertEquals(null, array[0]);
0:               for (int j = 0 ; j < selection.canonicalList.size() ; j++)
0:                   Assert.assertEquals(selection.canonicalList.get(j), array[j + 1]);
1:           });
1:     }
1: 
1:     private void testRandomSelectionOfList(int perThreadTrees, int perTreeSelections, BTreeListTestFactory testRun) throws InterruptedException
1:     {
1:         testRandomSelection(perThreadTrees, perTreeSelections,
1:                             (BTreeTestFactory) (selection) -> testRun.get(selection.testAsList, selection.canonicalList, selection.comparator));
1:     }
1: 
1:     private void testRandomSelectionOfSet(int perThreadTrees, int perTreeSelections, BTreeSetTestFactory testRun) throws InterruptedException
1:     {
1:         testRandomSelection(perThreadTrees, perTreeSelections,
1:                             (BTreeTestFactory) (selection) -> testRun.get(selection.testAsSet, selection.canonicalSet));
1:     }
1: 
1:     static interface BTreeSetTestFactory
1:     {
1:         TestEachKey get(BTreeSet<Integer> test, NavigableSet<Integer> canonical);
1:     }
1: 
1:     static interface BTreeListTestFactory
1:     {
1:         TestEachKey get(BTreeSet<Integer> test, List<Integer> canonical, Comparator<Integer> comparator);
1:     }
1: 
1:     static interface BTreeTestFactory
1:     {
1:         TestEachKey get(RandomSelection test);
1:     }
1: 
1:     static interface TestEachKey
1:     {
1:         void testOne(Integer value);
1:     }
1: 
1:     private void testRandomSelection(int perThreadTrees, int perTreeSelections, BTreeTestFactory testRun) throws InterruptedException
1:     {
1:         testRandomSelection(perThreadTrees, perTreeSelections, (selection) -> {
1:             TestEachKey testEachKey = testRun.get(selection);
1:             for (Integer key : selection.testKeys)
1:                 testEachKey.testOne(key);
1:         });
1:     }
1:     private void testRandomSelection(int perThreadTrees, int perTreeSelections, Consumer<RandomSelection> testRun) throws InterruptedException
1:     {
1:         int threads = Runtime.getRuntime().availableProcessors();
1:         final CountDownLatch latch = new CountDownLatch(threads);
1:         final AtomicLong errors = new AtomicLong();
1:         final AtomicLong count = new AtomicLong();
1:         final long totalCount = threads * perThreadTrees * perTreeSelections;
1:         for (int t = 0 ; t < threads ; t++)
1:         {
1:             Runnable runnable = new Runnable()
1:             {
1:                 public void run()
1:                 {
1:                     try
1:                     {
1:                         for (int i = 0 ; i < perThreadTrees ; i++)
1:                         {
0:                             RandomTree tree = randomTree(100, 10000);
1:                             for (int j = 0 ; j < perTreeSelections ; j++)
1:                             {
0:                                 testRun.accept(tree.select());
1:                                 count.incrementAndGet();
1:                             }
1:                         }
1:                     }
1:                     catch (Throwable t)
1:                     {
1:                         errors.incrementAndGet();
1:                         t.printStackTrace();
1:                     }
1:                     latch.countDown();
1:                 }
1:             };
1:             MODIFY.execute(runnable);
1:         }
1:         while (latch.getCount() > 0)
1:         {
1:             for (int i = 0 ; i < 10L ; i++)
1:             {
1:                 latch.await(1L, TimeUnit.SECONDS);
1:                 Assert.assertEquals(0, errors.get());
1:             }
0:             System.out.println(String.format("%.0f%% complete %s", 100 * count.get() / (double) totalCount, errors.get() > 0 ? ("Errors: " + errors.get()) : ""));
1:         }
1:     }
1: 
1:     private static class RandomSelection
1:     {
1:         final List<Integer> testKeys;
1:         final NavigableSet<Integer> canonicalSet;
1:         final List<Integer> canonicalList;
1:         final BTreeSet<Integer> testAsSet;
1:         final BTreeSet<Integer> testAsList;
1:         final Comparator<Integer> comparator;
1: 
1:         private RandomSelection(List<Integer> testKeys, NavigableSet<Integer> canonicalSet, BTreeSet<Integer> testAsSet,
1:                                 List<Integer> canonicalList, BTreeSet<Integer> testAsList, Comparator<Integer> comparator)
1:         {
1:             this.testKeys = testKeys;
1:             this.canonicalList = canonicalList;
1:             this.canonicalSet = canonicalSet;
1:             this.testAsSet = testAsSet;
1:             this.testAsList = testAsList;
1:             this.comparator = comparator;
1:         }
1:     }
1: 
1:     private static class RandomTree
1:     {
1:         final NavigableSet<Integer> canonical;
1:         final BTreeSet<Integer> test;
1: 
1:         private RandomTree(NavigableSet<Integer> canonical, BTreeSet<Integer> test)
1:         {
1:             this.canonical = canonical;
1:             this.test = test;
1:         }
1: 
0:         RandomSelection select()
1:         {
1:             ThreadLocalRandom random = ThreadLocalRandom.current();
1:             NavigableSet<Integer> canonicalSet = this.canonical;
1:             BTreeSet<Integer> testAsSet = this.test;
1:             List<Integer> canonicalList = new ArrayList<>(canonicalSet);
1:             BTreeSet<Integer> testAsList = this.test;
1: 
1:             Assert.assertEquals(canonicalSet.size(), testAsSet.size());
1:             Assert.assertEquals(canonicalList.size(), testAsList.size());
1: 
1:             // sometimes select keys first, so we cover full range
0:             List<Integer> allKeys = randomKeys(canonical);
1:             List<Integer> keys = allKeys;
1: 
0:             int narrow = random.nextInt(3);
0:             while (canonicalList.size() > 10 && keys.size() > 10 && narrow-- > 0)
1:             {
1:                 boolean useLb = random.nextBoolean();
1:                 boolean useUb = random.nextBoolean();
1:                 if (!(useLb | useUb))
1:                     continue;
1: 
1:                 // select a range smaller than the total span when we have more narrowing iterations left
0:                 int indexRange = keys.size() / (narrow + 1);
1: 
1:                 boolean lbInclusive = true;
1:                 Integer lbKey = canonicalList.get(0);
1:                 int lbKeyIndex = 0, lbIndex = 0;
1:                 boolean ubInclusive = true;
1:                 Integer ubKey = canonicalList.get(canonicalList.size() - 1);
1:                 int ubKeyIndex = keys.size(), ubIndex = canonicalList.size();
1: 
1:                 if (useLb)
1:                 {
1:                     lbKeyIndex = random.nextInt(0, indexRange - 1);
1:                     Integer candidate = keys.get(lbKeyIndex);
1:                     if (useLb = (candidate > lbKey && candidate <= ubKey))
1:                     {
1:                         lbInclusive = random.nextBoolean();
1:                         lbKey = keys.get(lbKeyIndex);
1:                         lbIndex = Collections.binarySearch(canonicalList, lbKey);
1:                         if (lbIndex >= 0 && !lbInclusive) lbIndex++;
1:                         else if (lbIndex < 0) lbIndex = -1 -lbIndex;
1:                     }
1:                 }
1:                 if (useUb)
1:                 {
1:                     ubKeyIndex = random.nextInt(Math.max(lbKeyIndex, keys.size() - indexRange), keys.size() - 1);
1:                     Integer candidate = keys.get(ubKeyIndex);
1:                     if (useUb = (candidate < ubKey && candidate >= lbKey))
1:                     {
1:                         ubInclusive = random.nextBoolean();
1:                         ubKey = keys.get(ubKeyIndex);
1:                         ubIndex = Collections.binarySearch(canonicalList, ubKey);
1:                         if (ubIndex >= 0 && ubInclusive) { ubIndex++; }
1:                         else if (ubIndex < 0) ubIndex = -1 -ubIndex;
1:                     }
1:                 }
1:                 if (ubIndex < lbIndex) { ubIndex = lbIndex; ubKey = lbKey; ubInclusive = false; }
1: 
1:                 canonicalSet = !useLb ? canonicalSet.headSet(ubKey, ubInclusive)
1:                                       : !useUb ? canonicalSet.tailSet(lbKey, lbInclusive)
1:                                                : canonicalSet.subSet(lbKey, lbInclusive, ubKey, ubInclusive);
1:                 testAsSet = !useLb ? testAsSet.headSet(ubKey, ubInclusive)
1:                                    : !useUb ? testAsSet.tailSet(lbKey, lbInclusive)
1:                                             : testAsSet.subSet(lbKey, lbInclusive, ubKey, ubInclusive);
1: 
1:                 keys = keys.subList(lbKeyIndex, ubKeyIndex);
1:                 canonicalList = canonicalList.subList(lbIndex, ubIndex);
1:                 testAsList = testAsList.subList(lbIndex, ubIndex);
1: 
1:                 Assert.assertEquals(canonicalSet.size(), testAsSet.size());
1:                 Assert.assertEquals(canonicalList.size(), testAsList.size());
1:             }
1: 
1:             // possibly restore full set of keys, to test case where we are provided existing keys that are out of bounds
1:             if (keys != allKeys && random.nextBoolean())
1:                 keys = allKeys;
1: 
1:             Comparator<Integer> comparator = naturalOrder();
0:             if (random.nextBoolean())
1:             {
1:                 if (allKeys != keys)
1:                     keys = new ArrayList<>(keys);
1:                 if (canonicalSet != canonical)
1:                     canonicalList = new ArrayList<>(canonicalList);
1:                 Collections.reverse(keys);
1:                 Collections.reverse(canonicalList);
1:                 testAsList = testAsList.descendingSet();
1: 
1:                 canonicalSet = canonicalSet.descendingSet();
1:                 testAsSet = testAsSet.descendingSet();
1:                 comparator = reverseOrder();
1:             }
1: 
1:             Assert.assertEquals(canonicalSet.size(), testAsSet.size());
1:             Assert.assertEquals(canonicalList.size(), testAsList.size());
1:             if (!canonicalSet.isEmpty())
1:             {
1:                 Assert.assertEquals(canonicalSet.first(), canonicalList.get(0));
1:                 Assert.assertEquals(canonicalSet.last(), canonicalList.get(canonicalList.size() - 1));
1:                 Assert.assertEquals(canonicalSet.first(), testAsSet.first());
1:                 Assert.assertEquals(canonicalSet.last(), testAsSet.last());
1:                 Assert.assertEquals(canonicalSet.first(), testAsList.get(0));
1:                 Assert.assertEquals(canonicalSet.last(), testAsList.get(testAsList.size() - 1));
1:             }
1: 
1:             return new RandomSelection(keys, canonicalSet, testAsSet, canonicalList, testAsList, comparator);
1:         }
1:     }
1: 
1:     private static RandomTree randomTree(int minSize, int maxSize)
1:     {
0:         return ThreadLocalRandom.current().nextBoolean() ? randomTreeByUpdate(minSize, maxSize)
0:                                                          : randomTreeByBuilder(minSize, maxSize);
1:     }
1: 
1:     private static RandomTree randomTreeByUpdate(int minSize, int maxSize)
1:     {
1:         assert minSize > 3;
1:         TreeSet<Integer> canonical = new TreeSet<>();
1: 
1:         ThreadLocalRandom random = ThreadLocalRandom.current();
1:         int targetSize = random.nextInt(minSize, maxSize);
1:         int maxModificationSize = random.nextInt(2, targetSize);
1:         Object[] accmumulate = BTree.empty();
1:         int curSize = 0;
1:         while (curSize < targetSize)
1:         {
1:             int nextSize = maxModificationSize == 1 ? 1 : random.nextInt(1, maxModificationSize);
1:             TreeSet<Integer> build = new TreeSet<>();
1:             for (int i = 0 ; i < nextSize ; i++)
1:             {
1:                 Integer next = random.nextInt();
1:                 build.add(next);
1:                 canonical.add(next);
1:             }
1:             accmumulate = BTree.update(accmumulate, naturalOrder(), build, UpdateFunction.<Integer>noOp());
1:             curSize += nextSize;
1:             maxModificationSize = Math.min(maxModificationSize, targetSize - curSize);
1:         }
1:         return new RandomTree(canonical, BTreeSet.<Integer>wrap(accmumulate, naturalOrder()));
1:     }
1: 
1:     private static RandomTree randomTreeByBuilder(int minSize, int maxSize)
1:     {
1:         assert minSize > 3;
1:         ThreadLocalRandom random = ThreadLocalRandom.current();
1:         BTree.Builder<Integer> builder = BTree.builder(naturalOrder());
1: 
1:         int targetSize = random.nextInt(minSize, maxSize);
1:         int maxModificationSize = (int) Math.sqrt(targetSize);
1: 
1:         TreeSet<Integer> canonical = new TreeSet<>();
1: 
1:         int curSize = 0;
1:         TreeSet<Integer> ordered = new TreeSet<>();
1:         List<Integer> shuffled = new ArrayList<>();
1:         while (curSize < targetSize)
1:         {
1:             int nextSize = maxModificationSize <= 1 ? 1 : random.nextInt(1, maxModificationSize);
1: 
1:             // leave a random selection of previous values
1:             (random.nextBoolean() ? ordered.headSet(random.nextInt()) : ordered.tailSet(random.nextInt())).clear();
1:             shuffled = new ArrayList<>(shuffled.subList(0, shuffled.size() < 2 ? 0 : random.nextInt(shuffled.size() / 2)));
1: 
1:             for (int i = 0 ; i < nextSize ; i++)
1:             {
1:                 Integer next = random.nextInt();
1:                 ordered.add(next);
1:                 shuffled.add(next);
1:                 canonical.add(next);
1:             }
1: 
1:             switch (random.nextInt(5))
1:             {
1:                 case 0:
1:                     builder.addAll(ordered);
1:                     break;
1:                 case 1:
1:                     builder.addAll(BTreeSet.of(ordered));
1:                     break;
1:                 case 2:
1:                     for (Integer i : ordered)
1:                         builder.add(i);
1:                 case 3:
1:                     builder.addAll(shuffled);
1:                     break;
1:                 case 4:
1:                     for (Integer i : shuffled)
1:                         builder.add(i);
1:             }
1: 
1:             curSize += nextSize;
1:             maxModificationSize = Math.min(maxModificationSize, targetSize - curSize);
1:         }
1: 
1:         BTreeSet<Integer> btree = BTreeSet.<Integer>wrap(builder.build(), naturalOrder());
1:         Assert.assertEquals(canonical.size(), btree.size());
1:         return new RandomTree(canonical, btree);
1:     }
1: 
1:     // select a random subset of the keys, with an optional random population of keys inbetween those that are present
1:     // return a value with the search position
0:     private static List<Integer> randomKeys(Iterable<Integer> canonical)
1:     {
1:         ThreadLocalRandom rnd = ThreadLocalRandom.current();
0:         boolean useFake = rnd.nextBoolean();
1:         final float fakeRatio = rnd.nextFloat();
1:         List<Integer> results = new ArrayList<>();
0:         Long fakeLb = null, fakeUb = null;
1:         for (Integer v : canonical)
1:         {
1:             if (    !useFake
0:                 ||  fakeLb == null
0:                 || (fakeUb == null ? v - 1 : fakeUb) <= fakeLb + 1
1:                 ||  rnd.nextFloat() < fakeRatio)
1:             {
1:                 // if we cannot safely construct a fake value, or our randomizer says not to, we emit the next real value
1:                 results.add(v);
1:                 fakeLb = v.longValue();
1:                 fakeUb = null;
1:             }
1:             else
1:             {
1:                 // otherwise we emit a fake value in the range immediately proceeding the last real value, and not
1:                 // exceeding the real value that would have proceeded (ignoring any other suppressed real values since)
1:                 if (fakeUb == null)
1:                     fakeUb = v.longValue() - 1;
1:                 long mid = (fakeLb + fakeUb) / 2;
1:                 assert mid < fakeUb;
1:                 results.add((int) mid);
1:                 fakeLb = mid;
1:             }
1:         }
1:         final float useChance = rnd.nextFloat();
1:         return Lists.newArrayList(filter(results, (x) -> rnd.nextFloat() < useChance));
1:     }
1: 
1:     /************************** TEST MUTATION ********************************************/
1: 
1:     @Test
1:     public void testOversizedMiddleInsert()
1:     {
1:         TreeSet<Integer> canon = new TreeSet<>();
1:         for (int i = 0 ; i < 10000000 ; i++)
1:             canon.add(i);
0:         Object[] btree = BTree.build(Arrays.asList(Integer.MIN_VALUE, Integer.MAX_VALUE), null);
1:         btree = BTree.update(btree, naturalOrder(), canon, UpdateFunction.<Integer>noOp());
1:         canon.add(Integer.MIN_VALUE);
1:         canon.add(Integer.MAX_VALUE);
0:         Assert.assertTrue(BTree.isWellFormed(btree, naturalOrder()));
0:         testEqual("Oversize", BTree.<Integer>slice(btree, naturalOrder(), true), canon.iterator());
1:     }
1: 
1:     @Test
1:     public void testIndividualInsertsSmallOverlappingRange() throws ExecutionException, InterruptedException
1:     {
0:         testInsertions(10000000, 50, 1, 1, true);
1:     }
1: 
1:     @Test
1:     public void testBatchesSmallOverlappingRange() throws ExecutionException, InterruptedException
1:     {
0:         testInsertions(10000000, 50, 1, 5, true);
1:     }
1: 
1:     @Test
1:     public void testIndividualInsertsMediumSparseRange() throws ExecutionException, InterruptedException
1:     {
0:         testInsertions(10000000, 500, 10, 1, true);
1:     }
1: 
1:     @Test
1:     public void testBatchesMediumSparseRange() throws ExecutionException, InterruptedException
1:     {
0:         testInsertions(10000000, 500, 10, 10, true);
1:     }
1: 
1:     @Test
1:     public void testLargeBatchesLargeRange() throws ExecutionException, InterruptedException
1:     {
0:         testInsertions(100000000, 5000, 3, 100, true);
1:     }
1: 
1:     @Test
1:     public void testSlicingSmallRandomTrees() throws ExecutionException, InterruptedException
1:     {
0:         testInsertions(10000, 50, 10, 10, false);
1:     }
1: 
0:     private static void testInsertions(int totalCount, int perTestCount, int testKeyRatio, int modificationBatchSize, boolean quickEquality) throws ExecutionException, InterruptedException
1:     {
1:         int batchesPerTest = perTestCount / modificationBatchSize;
0:         int maximumRunLength = 100;
0:         int testKeyRange = perTestCount * testKeyRatio;
0:         int tests = totalCount / perTestCount;
0:         System.out.println(String.format("Performing %d tests of %d operations, with %.2f max size/key-range ratio in batches of ~%d ops",
0:                 tests, perTestCount, 1 / (float) testKeyRatio, modificationBatchSize));
1: 
1:         // if we're not doing quick-equality, we can spam with garbage for all the checks we perform, so we'll split the work into smaller chunks
1:         int chunkSize = quickEquality ? tests : (int) (100000 / Math.pow(perTestCount, 2));
1:         for (int chunk = 0 ; chunk < tests ; chunk += chunkSize)
1:         {
1:             final List<ListenableFutureTask<List<ListenableFuture<?>>>> outer = new ArrayList<>();
1:             for (int i = 0 ; i < chunkSize ; i++)
1:             {
0:                 outer.add(doOneTestInsertions(testKeyRange, maximumRunLength, modificationBatchSize, batchesPerTest, quickEquality));
1:             }
1: 
1:             final List<ListenableFuture<?>> inner = new ArrayList<>();
0:             int complete = 0;
0:             int reportInterval = totalCount / 100;
0:             int lastReportAt = 0;
1:             for (ListenableFutureTask<List<ListenableFuture<?>>> f : outer)
1:             {
1:                 inner.addAll(f.get());
1:                 complete += perTestCount;
1:                 if (complete - lastReportAt >= reportInterval)
1:                 {
0:                     System.out.println(String.format("Completed %d of %d operations", (chunk * perTestCount) + complete, totalCount));
1:                     lastReportAt = complete;
1:                 }
1:             }
1:             Futures.allAsList(inner).get();
1:         }
1:         Snapshot snap = BTREE_TIMER.getSnapshot();
0:         System.out.println(String.format("btree: %.2fns, %.2fns, %.2fns", snap.getMedian(), snap.get95thPercentile(), snap.get999thPercentile()));
1:         snap = TREE_TIMER.getSnapshot();
0:         System.out.println(String.format("java: %.2fns, %.2fns, %.2fns", snap.getMedian(), snap.get95thPercentile(), snap.get999thPercentile()));
0:         System.out.println("Done");
1:     }
1: 
1:     private static ListenableFutureTask<List<ListenableFuture<?>>> doOneTestInsertions(final int upperBound, final int maxRunLength, final int averageModsPerIteration, final int iterations, final boolean quickEquality)
1:     {
1:         ListenableFutureTask<List<ListenableFuture<?>>> f = ListenableFutureTask.create(new Callable<List<ListenableFuture<?>>>()
1:         {
1:             @Override
1:             public List<ListenableFuture<?>> call()
1:             {
1:                 final List<ListenableFuture<?>> r = new ArrayList<>();
1:                 NavigableMap<Integer, Integer> canon = new TreeMap<>();
1:                 Object[] btree = BTree.empty();
1:                 final TreeMap<Integer, Integer> buffer = new TreeMap<>();
0:                 final Random rnd = new Random();
1:                 for (int i = 0 ; i < iterations ; i++)
1:                 {
1:                     buffer.clear();
0:                     int mods = (averageModsPerIteration >> 1) + 1 + rnd.nextInt(averageModsPerIteration);
1:                     while (mods > 0)
1:                     {
1:                         int v = rnd.nextInt(upperBound);
1:                         int rc = Math.max(0, Math.min(mods, maxRunLength) - 1);
1:                         int c = 1 + (rc <= 0 ? 0 : rnd.nextInt(rc));
1:                         for (int j = 0 ; j < c ; j++)
1:                         {
1:                             buffer.put(v, v);
1:                             v++;
1:                         }
1:                         mods -= c;
1:                     }
1:                     Timer.Context ctxt;
1:                     ctxt = TREE_TIMER.time();
1:                     canon.putAll(buffer);
1:                     ctxt.stop();
1:                     ctxt = BTREE_TIMER.time();
1:                     Object[] next = null;
1:                     while (next == null)
1:                         next = BTree.update(btree, naturalOrder(), buffer.keySet(), SPORADIC_ABORT);
1:                     btree = next;
1:                     ctxt.stop();
1: 
1:                     if (!BTree.isWellFormed(btree, naturalOrder()))
1:                     {
0:                         System.out.println("ERROR: Not well formed");
1:                         throw new AssertionError("Not well formed!");
1:                     }
1:                     if (quickEquality)
0:                         testEqual("", BTree.<Integer>slice(btree, naturalOrder(), true), canon.keySet().iterator());
1:                     else
1:                         r.addAll(testAllSlices("RND", btree, new TreeSet<>(canon.keySet())));
1:                 }
1:                 return r;
1:             }
1:         });
1:         if (DEBUG)
1:             f.run();
1:         else
1:             MODIFY.execute(f);
1:         return f;
1:     }
1: 
1:     @Test
1:     public void testSlicingAllSmallTrees() throws ExecutionException, InterruptedException
1:     {
1:         Object[] cur = BTree.empty();
1:         TreeSet<Integer> canon = new TreeSet<>();
1:         // we set FAN_FACTOR to 4, so 128 items is four levels deep, three fully populated
1:         for (int i = 0 ; i < 128 ; i++)
1:         {
1:             String id = String.format("[0..%d)", canon.size());
0:             System.out.println("Testing " + id);
1:             Futures.allAsList(testAllSlices(id, cur, canon)).get();
1:             Object[] next = null;
1:             while (next == null)
1:                 next = BTree.update(cur, naturalOrder(), Arrays.asList(i), SPORADIC_ABORT);
1:             cur = next;
1:             canon.add(i);
1:         }
1:     }
1: 
1:     private static List<ListenableFuture<?>> testAllSlices(String id, Object[] btree, NavigableSet<Integer> canon)
1:     {
1:         List<ListenableFuture<?>> waitFor = new ArrayList<>();
1:         testAllSlices(id + " ASC", new BTreeSet<>(btree, naturalOrder()), canon, true, waitFor);
1:         testAllSlices(id + " DSC", new BTreeSet<Integer>(btree, naturalOrder()).descendingSet(), canon.descendingSet(), false, waitFor);
1:         return waitFor;
1:     }
1: 
1:     private static void testAllSlices(String id, NavigableSet<Integer> btree, NavigableSet<Integer> canon, boolean ascending, List<ListenableFuture<?>> results)
1:     {
1:         testOneSlice(id, btree, canon, results);
1:         for (Integer lb : range(canon.size(), Integer.MIN_VALUE, ascending))
1:         {
1:             // test head/tail sets
1:             testOneSlice(String.format("%s->[..%d)", id, lb), btree.headSet(lb, true), canon.headSet(lb, true), results);
1:             testOneSlice(String.format("%s->(..%d)", id, lb), btree.headSet(lb, false), canon.headSet(lb, false), results);
1:             testOneSlice(String.format("%s->(%d..]", id, lb), btree.tailSet(lb, true), canon.tailSet(lb, true), results);
1:             testOneSlice(String.format("%s->(%d..]", id, lb), btree.tailSet(lb, false), canon.tailSet(lb, false), results);
1:             for (Integer ub : range(canon.size(), lb, ascending))
1:             {
1:                 // test subsets
1:                 testOneSlice(String.format("%s->[%d..%d]", id, lb, ub), btree.subSet(lb, true, ub, true), canon.subSet(lb, true, ub, true), results);
1:                 testOneSlice(String.format("%s->(%d..%d]", id, lb, ub), btree.subSet(lb, false, ub, true), canon.subSet(lb, false, ub, true), results);
1:                 testOneSlice(String.format("%s->[%d..%d)", id, lb, ub), btree.subSet(lb, true, ub, false), canon.subSet(lb, true, ub, false), results);
1:                 testOneSlice(String.format("%s->(%d..%d)", id, lb, ub), btree.subSet(lb, false, ub, false), canon.subSet(lb, false, ub, false), results);
1:             }
1:         }
1:     }
1: 
1:     private static void testOneSlice(final String id, final NavigableSet<Integer> test, final NavigableSet<Integer> canon, List<ListenableFuture<?>> results)
1:     {
1:         ListenableFutureTask<?> f = ListenableFutureTask.create(new Runnable()
1:         {
1: 
1:             @Override
1:             public void run()
1:             {
1:                 test(id + " Count", test.size(), canon.size());
1:                 testEqual(id, test.iterator(), canon.iterator());
1:                 testEqual(id + "->DSCI", test.descendingIterator(), canon.descendingIterator());
1:                 testEqual(id + "->DSCS", test.descendingSet().iterator(), canon.descendingSet().iterator());
1:                 testEqual(id + "->DSCS->DSCI", test.descendingSet().descendingIterator(), canon.descendingSet().descendingIterator());
1:             }
1:         }, null);
1:         results.add(f);
1:         if (DEBUG)
1:             f.run();
1:         else
1:             COMPARE.execute(f);
1:     }
1: 
1:     private static void test(String id, int test, int expect)
1:     {
1:         if (test != expect)
1:         {
0:             System.out.println(String.format("%s: Expected %d, Got %d", id, expect, test));
1:         }
1:     }
1: 
1:     private static <V> void testEqual(String id, Iterator<V> btree, Iterator<V> canon)
1:     {
1:         boolean equal = true;
1:         while (btree.hasNext() && canon.hasNext())
1:         {
1:             Object i = btree.next();
1:             Object j = canon.next();
1:             if (!Objects.equals(i, j))
1:             {
0:                 System.out.println(String.format("%s: Expected %d, Got %d", id, j, i));
1:                 equal = false;
1:             }
1:         }
1:         while (btree.hasNext())
1:         {
0:             System.out.println(String.format("%s: Expected <Nil>, Got %d", id, btree.next()));
1:             equal = false;
1:         }
1:         while (canon.hasNext())
1:         {
0:             System.out.println(String.format("%s: Expected %d, Got Nil", id, canon.next()));
1:             equal = false;
1:         }
1:         if (!equal)
1:             throw new AssertionError("Not equal");
1:     }
1: 
1:     // should only be called on sets that range from 0->N or N->0
1:     private static final Iterable<Integer> range(final int size, final int from, final boolean ascending)
1:     {
1:         return new Iterable<Integer>()
1:         {
1:             int cur;
1:             int delta;
1:             int end;
1:             {
1:                 if (ascending)
1:                 {
1:                     end = size + 1;
1:                     cur = from == Integer.MIN_VALUE ? -1 : from;
1:                     delta = 1;
1:                 }
1:                 else
1:                 {
1:                     end = -2;
1:                     cur = from == Integer.MIN_VALUE ? size : from;
1:                     delta = -1;
1:                 }
1:             }
1:             @Override
1:             public Iterator<Integer> iterator()
1:             {
1:                 return new Iterator<Integer>()
1:                 {
1:                     @Override
1:                     public boolean hasNext()
1:                     {
1:                         return cur != end;
1:                     }
1: 
1:                     @Override
1:                     public Integer next()
1:                     {
1:                         Integer r = cur;
1:                         cur += delta;
1:                         return r;
1:                     }
1: 
1:                     @Override
1:                     public void remove()
1:                     {
1:                         throw new UnsupportedOperationException();
1:                     }
1:                 };
1:             }
1:         };
1:     }
1: 
1:     private static final class RandomAbort<V> implements UpdateFunction<V, V>
1:     {
1:         final Random rnd;
1:         final float chance;
1:         private RandomAbort(Random rnd, float chance)
1:         {
1:             this.rnd = rnd;
1:             this.chance = chance;
1:         }
1: 
1:         public V apply(V replacing, V update)
1:         {
1:             return update;
1:         }
1: 
1:         public boolean abortEarly()
1:         {
1:             return rnd.nextFloat() < chance;
1:         }
1: 
1:         public void allocated(long heapSize)
1:         {
1:         }
1: 
1:         public V apply(V v)
1:         {
1:             return v;
1:         }
1:     }
1: }
commit:a3e0418
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
0: package org.apache.cassandra.utils;
0: 
0: import java.util.ArrayList;
0: import java.util.Arrays;
0: import java.util.Comparator;
0: import java.util.Iterator;
0: import java.util.List;
0: import java.util.NavigableMap;
0: import java.util.NavigableSet;
0: import java.util.Random;
0: import java.util.TreeMap;
0: import java.util.TreeSet;
0: import java.util.concurrent.Callable;
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.ExecutionException;
0: import java.util.concurrent.ExecutorService;
0: import java.util.concurrent.Executors;
0: import java.util.concurrent.ThreadLocalRandom;
0: import java.util.concurrent.TimeUnit;
0: import java.util.concurrent.atomic.AtomicLong;
0: 
0: import com.google.common.base.Function;
0: import com.google.common.base.Predicate;
0: import com.google.common.collect.Iterables;
0: import com.google.common.util.concurrent.Futures;
0: import com.google.common.util.concurrent.ListenableFuture;
0: import com.google.common.util.concurrent.ListenableFutureTask;
0: import org.junit.Assert;
0: import org.junit.Test;
0: 
0: 
0: import com.codahale.metrics.MetricRegistry;
0: import com.codahale.metrics.Snapshot;
0: import com.codahale.metrics.Timer;
0: import org.apache.cassandra.concurrent.NamedThreadFactory;
0: import org.apache.cassandra.utils.btree.BTree;
0: import org.apache.cassandra.utils.btree.BTreeSearchIterator;
0: import org.apache.cassandra.utils.btree.BTreeSet;
0: import org.apache.cassandra.utils.btree.UpdateFunction;
0: 
0: // TODO : should probably lower fan-factor for tests to make them more intensive
0: public class LongBTreeTest
0: {
0: 
0:     private static final MetricRegistry metrics = new MetricRegistry();
0:     private static final Timer BTREE_TIMER = metrics.timer(MetricRegistry.name(BTree.class, "BTREE"));
0:     private static final Timer TREE_TIMER = metrics.timer(MetricRegistry.name(BTree.class, "TREE"));
0:     private static final ExecutorService MODIFY = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), new NamedThreadFactory("MODIFY"));
0:     private static final ExecutorService COMPARE = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), new NamedThreadFactory("COMPARE"));
0:     private static final RandomAbort<Integer> SPORADIC_ABORT = new RandomAbort<>(new Random(), 0.0001f);
0: 
0:     static
0:     {
0:         System.setProperty("cassandra.btree.fanfactor", "4");
0:     }
0: 
0:     @Test
0:     public void testOversizedMiddleInsert()
0:     {
0:         TreeSet<Integer> canon = new TreeSet<>();
0:         for (int i = 0 ; i < 10000000 ; i++)
0:             canon.add(i);
0:         Object[] btree = BTree.build(Arrays.asList(Integer.MIN_VALUE, Integer.MAX_VALUE), ICMP, true, null);
0:         btree = BTree.update(btree, ICMP, canon, true);
0:         canon.add(Integer.MIN_VALUE);
0:         canon.add(Integer.MAX_VALUE);
0:         Assert.assertTrue(BTree.isWellFormed(btree, ICMP));
0:         testEqual("Oversize", BTree.<Integer>slice(btree, true), canon.iterator());
0:     }
0: 
0:     @Test
0:     public void testIndividualInsertsSmallOverlappingRange() throws ExecutionException, InterruptedException
0:     {
0:         testInsertions(10000000, 50, 1, 1, true);
0:     }
0: 
0:     @Test
0:     public void testBatchesSmallOverlappingRange() throws ExecutionException, InterruptedException
0:     {
0:         testInsertions(10000000, 50, 1, 5, true);
0:     }
0: 
0:     @Test
0:     public void testIndividualInsertsMediumSparseRange() throws ExecutionException, InterruptedException
0:     {
0:         testInsertions(10000000, 500, 10, 1, true);
0:     }
0: 
0:     @Test
0:     public void testBatchesMediumSparseRange() throws ExecutionException, InterruptedException
0:     {
0:         testInsertions(10000000, 500, 10, 10, true);
0:     }
0: 
0:     @Test
0:     public void testLargeBatchesLargeRange() throws ExecutionException, InterruptedException
0:     {
0:         testInsertions(100000000, 5000, 3, 100, true);
0:     }
0: 
0:     @Test
0:     public void testSlicingSmallRandomTrees() throws ExecutionException, InterruptedException
0:     {
0:         testInsertions(10000, 50, 10, 10, false);
0:     }
0: 
0:     @Test
0:     public void testSearchIterator() throws InterruptedException
0:     {
0:         int threads = Runtime.getRuntime().availableProcessors();
0:         final CountDownLatch latch = new CountDownLatch(threads);
0:         final AtomicLong errors = new AtomicLong();
0:         final AtomicLong count = new AtomicLong();
0:         final int perThreadTrees = 100;
0:         final int perTreeSelections = 100;
0:         final long totalCount = threads * perThreadTrees * perTreeSelections;
0:         for (int t = 0 ; t < threads ; t++)
0:         {
0:             MODIFY.execute(new Runnable()
0:             {
0:                 public void run()
0:                 {
0:                     ThreadLocalRandom random = ThreadLocalRandom.current();
0:                     for (int i = 0 ; i < perThreadTrees ; i++)
0:                     {
0:                         Object[] tree = randomTree(10000, random);
0:                         for (int j = 0 ; j < perTreeSelections ; j++)
0:                         {
0:                             BTreeSearchIterator<Integer, Integer, Integer> searchIterator = new BTreeSearchIterator<>(tree, ICMP);
0:                             for (Integer key : randomSelection(tree, random))
0:                                 if (key != searchIterator.next(key))
0:                                     errors.incrementAndGet();
0:                             searchIterator = new BTreeSearchIterator<Integer, Integer, Integer>(tree, ICMP);
0:                             for (Integer key : randomMix(tree, random))
0:                                 if (key != searchIterator.next(key))
0:                                     if (BTree.find(tree, ICMP, key) == key)
0:                                         errors.incrementAndGet();
0:                             count.incrementAndGet();
0:                         }
0:                     }
0:                     latch.countDown();
0:                 }
0:             });
0:         }
0:         while (latch.getCount() > 0)
0:         {
0:             latch.await(10L, TimeUnit.SECONDS);
0:             System.out.println(String.format("%.0f%% complete %s", 100 * count.get() / (double) totalCount, errors.get() > 0 ? ("Errors: " + errors.get()) : ""));
0:             assert errors.get() == 0;
0:         }
0:     }
0: 
0:     private static void testInsertions(int totalCount, int perTestCount, int testKeyRatio, int modificationBatchSize, boolean quickEquality) throws ExecutionException, InterruptedException
0:     {
0:         int batchesPerTest = perTestCount / modificationBatchSize;
0:         int maximumRunLength = 100;
0:         int testKeyRange = perTestCount * testKeyRatio;
0:         int tests = totalCount / perTestCount;
0:         System.out.println(String.format("Performing %d tests of %d operations, with %.2f max size/key-range ratio in batches of ~%d ops",
0:                 tests, perTestCount, 1 / (float) testKeyRatio, modificationBatchSize));
0: 
0:         // if we're not doing quick-equality, we can spam with garbage for all the checks we perform, so we'll split the work into smaller chunks
0:         int chunkSize = quickEquality ? tests : (int) (100000 / Math.pow(perTestCount, 2));
0:         for (int chunk = 0 ; chunk < tests ; chunk += chunkSize)
0:         {
0:             final List<ListenableFutureTask<List<ListenableFuture<?>>>> outer = new ArrayList<>();
0:             for (int i = 0 ; i < chunkSize ; i++)
0:             {
0:                 outer.add(doOneTestInsertions(testKeyRange, maximumRunLength, modificationBatchSize, batchesPerTest, quickEquality));
0:             }
0: 
0:             final List<ListenableFuture<?>> inner = new ArrayList<>();
0:             int complete = 0;
0:             int reportInterval = totalCount / 100;
0:             int lastReportAt = 0;
0:             for (ListenableFutureTask<List<ListenableFuture<?>>> f : outer)
0:             {
0:                 inner.addAll(f.get());
0:                 complete += perTestCount;
0:                 if (complete - lastReportAt >= reportInterval)
0:                 {
0:                     System.out.println(String.format("Completed %d of %d operations", (chunk * perTestCount) + complete, totalCount));
0:                     lastReportAt = complete;
0:                 }
0:             }
0:             Futures.allAsList(inner).get();
0:         }
0:         Snapshot snap = BTREE_TIMER.getSnapshot();
0:         System.out.println(String.format("btree   : %.2fns, %.2fns, %.2fns", snap.getMedian(), snap.get95thPercentile(), snap.get999thPercentile()));
0:         snap = TREE_TIMER.getSnapshot();
0:         System.out.println(String.format("snaptree: %.2fns, %.2fns, %.2fns", snap.getMedian(), snap.get95thPercentile(), snap.get999thPercentile()));
0:         System.out.println("Done");
0:     }
0: 
0:     private static ListenableFutureTask<List<ListenableFuture<?>>> doOneTestInsertions(final int upperBound, final int maxRunLength, final int averageModsPerIteration, final int iterations, final boolean quickEquality)
0:     {
0:         ListenableFutureTask<List<ListenableFuture<?>>> f = ListenableFutureTask.create(new Callable<List<ListenableFuture<?>>>()
0:         {
0:             @Override
0:             public List<ListenableFuture<?>> call()
0:             {
0:                 final List<ListenableFuture<?>> r = new ArrayList<>();
0:                 NavigableMap<Integer, Integer> canon = new TreeMap<>();
0:                 Object[] btree = BTree.empty();
0:                 final TreeMap<Integer, Integer> buffer = new TreeMap<>();
0:                 final Random rnd = new Random();
0:                 for (int i = 0 ; i < iterations ; i++)
0:                 {
0:                     buffer.clear();
0:                     int mods = (averageModsPerIteration >> 1) + 1 + rnd.nextInt(averageModsPerIteration);
0:                     while (mods > 0)
0:                     {
0:                         int v = rnd.nextInt(upperBound);
0:                         int rc = Math.max(0, Math.min(mods, maxRunLength) - 1);
0:                         int c = 1 + (rc <= 0 ? 0 : rnd.nextInt(rc));
0:                         for (int j = 0 ; j < c ; j++)
0:                         {
0:                             buffer.put(v, v);
0:                             v++;
0:                         }
0:                         mods -= c;
0:                     }
0:                     Timer.Context ctxt;
0:                     ctxt = TREE_TIMER.time();
0:                     canon.putAll(buffer);
0:                     ctxt.stop();
0:                     ctxt = BTREE_TIMER.time();
0:                     Object[] next = null;
0:                     while (next == null)
0:                         next = BTree.update(btree, ICMP, buffer.keySet(), true, SPORADIC_ABORT);
0:                     btree = next;
0:                     ctxt.stop();
0: 
0:                     if (!BTree.isWellFormed(btree, ICMP))
0:                     {
0:                         System.out.println("ERROR: Not well formed");
0:                         throw new AssertionError("Not well formed!");
0:                     }
0:                     if (quickEquality)
0:                         testEqual("", BTree.<Integer>slice(btree, true), canon.keySet().iterator());
0:                     else
0:                         r.addAll(testAllSlices("RND", btree, new TreeSet<>(canon.keySet())));
0:                 }
0:                 return r;
0:             }
0:         });
0:         MODIFY.execute(f);
0:         return f;
0:     }
0: 
0:     @Test
0:     public void testSlicingAllSmallTrees() throws ExecutionException, InterruptedException
0:     {
0:         Object[] cur = BTree.empty();
0:         TreeSet<Integer> canon = new TreeSet<>();
0:         // we set FAN_FACTOR to 4, so 128 items is four levels deep, three fully populated
0:         for (int i = 0 ; i < 128 ; i++)
0:         {
0:             String id = String.format("[0..%d)", canon.size());
0:             System.out.println("Testing " + id);
0:             Futures.allAsList(testAllSlices(id, cur, canon)).get();
0:             Object[] next = null;
0:             while (next == null)
0:                 next = BTree.update(cur, ICMP, Arrays.asList(i), true, SPORADIC_ABORT);
0:             cur = next;
0:             canon.add(i);
0:         }
0:     }
0: 
0:     static final Comparator<Integer> ICMP = new Comparator<Integer>()
0:     {
0:         @Override
0:         public int compare(Integer o1, Integer o2)
0:         {
0:             return Integer.compare(o1, o2);
0:         }
0:     };
0: 
0:     private static List<ListenableFuture<?>> testAllSlices(String id, Object[] btree, NavigableSet<Integer> canon)
0:     {
0:         List<ListenableFuture<?>> waitFor = new ArrayList<>();
0:         testAllSlices(id + " ASC", new BTreeSet<>(btree, ICMP), canon, true, waitFor);
0:         testAllSlices(id + " DSC", new BTreeSet<>(btree, ICMP).descendingSet(), canon.descendingSet(), false, waitFor);
0:         return waitFor;
0:     }
0: 
0:     private static void testAllSlices(String id, NavigableSet<Integer> btree, NavigableSet<Integer> canon, boolean ascending, List<ListenableFuture<?>> results)
0:     {
0:         testOneSlice(id, btree, canon, results);
0:         for (Integer lb : range(canon.size(), Integer.MIN_VALUE, ascending))
0:         {
0:             // test head/tail sets
0:             testOneSlice(String.format("%s->[%d..)", id, lb), btree.headSet(lb, true), canon.headSet(lb, true), results);
0:             testOneSlice(String.format("%s->(%d..)", id, lb), btree.headSet(lb, false), canon.headSet(lb, false), results);
0:             testOneSlice(String.format("%s->(..%d]", id, lb), btree.tailSet(lb, true), canon.tailSet(lb, true), results);
0:             testOneSlice(String.format("%s->(..%d]", id, lb), btree.tailSet(lb, false), canon.tailSet(lb, false), results);
0:             for (Integer ub : range(canon.size(), lb, ascending))
0:             {
0:                 // test subsets
0:                 testOneSlice(String.format("%s->[%d..%d]", id, lb, ub), btree.subSet(lb, true, ub, true), canon.subSet(lb, true, ub, true), results);
0:                 testOneSlice(String.format("%s->(%d..%d]", id, lb, ub), btree.subSet(lb, false, ub, true), canon.subSet(lb, false, ub, true), results);
0:                 testOneSlice(String.format("%s->[%d..%d)", id, lb, ub), btree.subSet(lb, true, ub, false), canon.subSet(lb, true, ub, false), results);
0:                 testOneSlice(String.format("%s->(%d..%d)", id, lb, ub), btree.subSet(lb, false, ub, false), canon.subSet(lb, false, ub, false), results);
0:             }
0:         }
0:     }
0: 
0:     private static void testOneSlice(final String id, final NavigableSet<Integer> test, final NavigableSet<Integer> canon, List<ListenableFuture<?>> results)
0:     {
0:         ListenableFutureTask<?> f = ListenableFutureTask.create(new Runnable()
0:         {
0: 
0:             @Override
0:             public void run()
0:             {
0:                 test(id + " Count", test.size(), canon.size());
0:                 testEqual(id, test.iterator(), canon.iterator());
0:                 testEqual(id + "->DSCI", test.descendingIterator(), canon.descendingIterator());
0:                 testEqual(id + "->DSCS", test.descendingSet().iterator(), canon.descendingSet().iterator());
0:                 testEqual(id + "->DSCS->DSCI", test.descendingSet().descendingIterator(), canon.descendingSet().descendingIterator());
0:             }
0:         }, null);
0:         results.add(f);
0:         COMPARE.execute(f);
0:     }
0: 
0:     private static void test(String id, int test, int expect)
0:     {
0:         if (test != expect)
0:         {
0:             System.out.println(String.format("%s: Expected %d, Got %d", id, expect, test));
0:         }
0:     }
0: 
0:     private static <V> void testEqual(String id, Iterator<V> btree, Iterator<V> canon)
0:     {
0:         boolean equal = true;
0:         while (btree.hasNext() && canon.hasNext())
0:         {
0:             Object i = btree.next();
0:             Object j = canon.next();
0:             if (!i.equals(j))
0:             {
0:                 System.out.println(String.format("%s: Expected %d, Got %d", id, j, i));
0:                 equal = false;
0:             }
0:         }
0:         while (btree.hasNext())
0:         {
0:             System.out.println(String.format("%s: Expected <Nil>, Got %d", id, btree.next()));
0:             equal = false;
0:         }
0:         while (canon.hasNext())
0:         {
0:             System.out.println(String.format("%s: Expected %d, Got Nil", id, canon.next()));
0:             equal = false;
0:         }
0:         if (!equal)
0:             throw new AssertionError("Not equal");
0:     }
0: 
0:     // should only be called on sets that range from 0->N or N->0
0:     private static final Iterable<Integer> range(final int size, final int from, final boolean ascending)
0:     {
0:         return new Iterable<Integer>()
0:         {
0:             int cur;
0:             int delta;
0:             int end;
0:             {
0:                 if (ascending)
0:                 {
0:                     end = size + 1;
0:                     cur = from == Integer.MIN_VALUE ? -1 : from;
0:                     delta = 1;
0:                 }
0:                 else
0:                 {
0:                     end = -2;
0:                     cur = from == Integer.MIN_VALUE ? size : from;
0:                     delta = -1;
0:                 }
0:             }
0:             @Override
0:             public Iterator<Integer> iterator()
0:             {
0:                 return new Iterator<Integer>()
0:                 {
0:                     @Override
0:                     public boolean hasNext()
0:                     {
0:                         return cur != end;
0:                     }
0: 
0:                     @Override
0:                     public Integer next()
0:                     {
0:                         Integer r = cur;
0:                         cur += delta;
0:                         return r;
0:                     }
0: 
0:                     @Override
0:                     public void remove()
0:                     {
0:                         throw new UnsupportedOperationException();
0:                     }
0:                 };
0:             }
0:         };
0:     }
0: 
0:     private static Object[] randomTree(int maxSize, Random random)
0:     {
0:         TreeSet<Integer> build = new TreeSet<>();
0:         int size = random.nextInt(maxSize);
0:         for (int i = 0 ; i < size ; i++)
0:         {
0:             build.add(random.nextInt());
0:         }
0:         return BTree.build(build, ICMP, true, UpdateFunction.NoOp.<Integer>instance());
0:     }
0: 
0:     private static Iterable<Integer> randomSelection(Object[] iter, final Random rnd)
0:     {
0:         final float proportion = rnd.nextFloat();
0:         return Iterables.filter(new BTreeSet<>(iter, ICMP), new Predicate<Integer>()
0:         {
0:             public boolean apply(Integer integer)
0:             {
0:                 return rnd.nextFloat() < proportion;
0:             }
0:         });
0:     }
0: 
0:     private static Iterable<Integer> randomMix(Object[] iter, final Random rnd)
0:     {
0:         final float proportion = rnd.nextFloat();
0:         return Iterables.transform(new BTreeSet<>(iter, ICMP), new Function<Integer, Integer>()
0:         {
0:             long last = Integer.MIN_VALUE;
0: 
0:             public Integer apply(Integer v)
0:             {
0:                 long last = this.last;
0:                 this.last = v;
0:                 if (rnd.nextFloat() < proportion)
0:                     return v;
0:                 return (int)((v - last) / 2);
0:             }
0:         });
0:     }
0: 
0:     private static final class RandomAbort<V> implements UpdateFunction<V>
0:     {
0:         final Random rnd;
0:         final float chance;
0:         private RandomAbort(Random rnd, float chance)
0:         {
0:             this.rnd = rnd;
0:             this.chance = chance;
0:         }
0: 
0:         public V apply(V replacing, V update)
0:         {
0:             return update;
0:         }
0: 
0:         public boolean abortEarly()
0:         {
0:             return rnd.nextFloat() < chance;
0:         }
0: 
0:         public void allocated(long heapSize)
0:         {
0: 
0:         }
0: 
0:         public V apply(V v)
0:         {
0:             return v;
0:         }
0:     }
0: }
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
============================================================================