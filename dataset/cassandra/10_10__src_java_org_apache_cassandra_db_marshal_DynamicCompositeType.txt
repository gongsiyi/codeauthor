1:07cf56f: /*
1:5d98581:  * Licensed to the Apache Software Foundation (ASF) under one
1:5d98581:  * or more contributor license agreements.  See the NOTICE file
1:5d98581:  * distributed with this work for additional information
1:5d98581:  * regarding copyright ownership.  The ASF licenses this file
1:5d98581:  * to you under the Apache License, Version 2.0 (the
1:5d98581:  * "License"); you may not use this file except in compliance
1:5d98581:  * with the License.  You may obtain a copy of the License at
1:5d98581:  *
1:07cf56f:  *     http://www.apache.org/licenses/LICENSE-2.0
1:5d98581:  *
1:07cf56f:  * Unless required by applicable law or agreed to in writing, software
1:07cf56f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:07cf56f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:07cf56f:  * See the License for the specific language governing permissions and
1:07cf56f:  * limitations under the License.
1:5d98581:  */
1:5d98581: package org.apache.cassandra.db.marshal;
1:5d98581: 
1:5d98581: import java.nio.charset.CharacterCodingException;
1:5d98581: import java.nio.ByteBuffer;
1:5d98581: import java.util.HashMap;
1:5d98581: import java.util.Map;
1:5d98581: 
1:c7b02d1: import org.apache.cassandra.cql3.Term;
1:5d98581: import org.slf4j.Logger;
1:5d98581: import org.slf4j.LoggerFactory;
1:5d98581: 
1:3a2faf9: import org.apache.cassandra.exceptions.ConfigurationException;
1:3a2faf9: import org.apache.cassandra.exceptions.SyntaxException;
1:fc8b76f: import org.apache.cassandra.serializers.TypeSerializer;
1:fc8b76f: import org.apache.cassandra.serializers.MarshalException;
1:e0adc16: import org.apache.cassandra.transport.ProtocolVersion;
1:5d98581: import org.apache.cassandra.utils.ByteBufferUtil;
1:5d98581: 
1:5d98581: /*
1:5d98581:  * The encoding of a DynamicCompositeType column name should be:
1:5d98581:  *   <component><component><component> ...
1:5d98581:  * where <component> is:
1:5d98581:  *   <comparator part><value><'end-of-component' byte>
1:5d98581:  * where:
1:5d98581:  *   - <comparator part>: either the comparator full name, or a declared
1:5d98581:  *     aliases. This is at least 2 bytes (those 2 bytes are called header in
1:5d98581:  *     the following). If the first bit of the header is 1, then this
1:5d98581:  *     comparator part is an alias, otherwise it's a comparator full name:
1:5d98581:  *       - aliases: the actual alias is the 2nd byte of header taken as a
1:5d98581:  *         character. The whole <comparator part> is thus 2 byte long.
1:5d98581:  *       - comparator full name: the header is the length of the remaining
1:5d98581:  *         part. The remaining part is the UTF-8 encoded comparator class
1:5d98581:  *         name.
1:5d98581:  *   - <value>: the component value bytes preceded by 2 byte containing the
1:5d98581:  *     size of value (see CompositeType).
1:5d98581:  *   - 'end-of-component' byte is defined as in CompositeType
1:5d98581:  */
1:5d98581: public class DynamicCompositeType extends AbstractCompositeType
3:5d98581: {
1:5d98581:     private static final Logger logger = LoggerFactory.getLogger(DynamicCompositeType.class);
1:5d98581: 
1:2bc0d4d:     private final Map<Byte, AbstractType<?>> aliases;
1:5d98581: 
1:5d98581:     // interning instances
1:2bc0d4d:     private static final Map<Map<Byte, AbstractType<?>>, DynamicCompositeType> instances = new HashMap<Map<Byte, AbstractType<?>>, DynamicCompositeType>();
1:5d98581: 
1:3a2faf9:     public static synchronized DynamicCompositeType getInstance(TypeParser parser) throws ConfigurationException, SyntaxException
1:5d98581:     {
1:5d98581:         return getInstance(parser.getAliasParameters());
2:5d98581:     }
1:5d98581: 
1:2bc0d4d:     public static synchronized DynamicCompositeType getInstance(Map<Byte, AbstractType<?>> aliases)
1:3a2faf9:     {
1:5d98581:         DynamicCompositeType dct = instances.get(aliases);
1:5d98581:         if (dct == null)
1:5d98581:         {
1:5d98581:             dct = new DynamicCompositeType(aliases);
1:5d98581:             instances.put(aliases, dct);
1:5d98581:         }
1:5d98581:         return dct;
1:5d98581:     }
1:5d98581: 
1:2bc0d4d:     private DynamicCompositeType(Map<Byte, AbstractType<?>> aliases)
1:5d98581:     {
1:5d98581:         this.aliases = aliases;
1:5d98581:     }
1:5d98581: 
1:b09d876:     protected boolean readIsStatic(ByteBuffer bb)
1:b09d876:     {
1:b09d876:         // We don't have the static nothing for DCT
1:b09d876:         return false;
1:b09d876:     }
1:b09d876: 
1:2bc0d4d:     private AbstractType<?> getComparator(ByteBuffer bb)
1:5d98581:     {
1:5d98581:         try
1:5d98581:         {
1:9d06ea6:             int header = ByteBufferUtil.readShortLength(bb);
1:5d98581:             if ((header & 0x8000) == 0)
1:5d98581:             {
1:9d06ea6:                 String name = ByteBufferUtil.string(ByteBufferUtil.readBytes(bb, header));
1:5d98581:                 return TypeParser.parse(name);
1:5d98581:             }
1:5d98581:             else
1:5d98581:             {
1:5d98581:                 return aliases.get((byte)(header & 0xFF));
1:5d98581:             }
1:5d98581:         }
1:5d98581:         catch (CharacterCodingException e)
1:5d98581:         {
1:3a2faf9:             throw new RuntimeException(e);
1:3a2faf9:         }
1:3a2faf9:     }
1:5d98581: 
1:bfe2dfb:     protected AbstractType<?> getComparator(int i, ByteBuffer bb)
1:3a2faf9:     {
1:5d98581:         return getComparator(bb);
1:5d98581:     }
1:5d98581: 
1:bfe2dfb:     protected AbstractType<?> getComparator(int i, ByteBuffer bb1, ByteBuffer bb2)
1:5d98581:     {
1:2bc0d4d:         AbstractType<?> comp1 = getComparator(bb1);
1:2bc0d4d:         AbstractType<?> comp2 = getComparator(bb2);
1:b93ca58:         AbstractType<?> rawComp = comp1;
1:5d98581: 
1:b93ca58:         /*
1:b93ca58:          * If both types are ReversedType(Type), we need to compare on the wrapped type (which may differ between the two types) to avoid
1:b93ca58:          * incompatible comparisons being made.
1:6a1ed62:          */
1:68d2526:         if ((comp1 instanceof ReversedType) && (comp2 instanceof ReversedType)) 
1:68d2526:         {
1:b93ca58:             comp1 = ((ReversedType<?>) comp1).baseType;
1:b93ca58:             comp2 = ((ReversedType<?>) comp2).baseType;
1:5d98581:         }
1:b93ca58: 
1:6a1ed62:         // Fast test if the comparator uses singleton instances
1:5d98581:         if (comp1 != comp2)
1:5d98581:         {
1:6a1ed62:             /*
1:6a1ed62:              * We compare component of different types by comparing the
1:6a1ed62:              * comparator class names. We start with the simple classname
1:6a1ed62:              * first because that will be faster in almost all cases, but
1:5e15927:              * fallback on the full name if necessary
1:5e15927:              */
1:6a1ed62:             int cmp = comp1.getClass().getSimpleName().compareTo(comp2.getClass().getSimpleName());
1:6a1ed62:             if (cmp != 0)
1:5e15927:                 return cmp < 0 ? FixedValueComparator.alwaysLesserThan : FixedValueComparator.alwaysGreaterThan;
1:6a1ed62: 
1:6a1ed62:             cmp = comp1.getClass().getName().compareTo(comp2.getClass().getName());
1:6a1ed62:             if (cmp != 0)
1:5e15927:                 return cmp < 0 ? FixedValueComparator.alwaysLesserThan : FixedValueComparator.alwaysGreaterThan;
1:6a1ed62: 
1:6a1ed62:             // if cmp == 0, we're actually having the same type, but one that
1:6a1ed62:             // did not have a singleton instance. It's ok (though inefficient).
1:5d98581:         }
1:b93ca58:         // Use the raw comparator (prior to ReversedType unwrapping)
1:b93ca58:         return rawComp;
1:5d98581:     }
1:5d98581: 
1:bfe2dfb:     protected AbstractType<?> getAndAppendComparator(int i, ByteBuffer bb, StringBuilder sb)
1:5d98581:     {
1:5d98581:         try
1:5d98581:         {
1:9d06ea6:             int header = ByteBufferUtil.readShortLength(bb);
1:5d98581:             if ((header & 0x8000) == 0)
1:5d98581:             {
1:9d06ea6:                 String name = ByteBufferUtil.string(ByteBufferUtil.readBytes(bb, header));
1:5d98581:                 sb.append(name).append("@");
1:5d98581:                 return TypeParser.parse(name);
1:5d98581:             }
1:5d98581:             else
1:5d98581:             {
1:5d98581:                 sb.append((char)(header & 0xFF)).append("@");
1:5d98581:                 return aliases.get((byte)(header & 0xFF));
1:5d98581:             }
1:5d98581:         }
1:5d98581:         catch (CharacterCodingException e)
1:5d98581:         {
1:3a2faf9:             throw new RuntimeException(e);
1:5d98581:         }
1:5d98581:     }
1:5d98581: 
1:bfe2dfb:     protected ParsedComparator parseComparator(int i, String part)
1:5d98581:     {
1:5d98581:         return new DynamicParsedComparator(part);
1:5d98581:     }
1:5d98581: 
1:bfe2dfb:     protected AbstractType<?> validateComparator(int i, ByteBuffer bb) throws MarshalException
1:5d98581:     {
1:2bc0d4d:         AbstractType<?> comparator = null;
1:5d98581:         if (bb.remaining() < 2)
1:5d98581:             throw new MarshalException("Not enough bytes to header of the comparator part of component " + i);
1:9d06ea6:         int header = ByteBufferUtil.readShortLength(bb);
1:5d98581:         if ((header & 0x8000) == 0)
1:5d98581:         {
1:5d98581:             if (bb.remaining() < header)
1:5d98581:                 throw new MarshalException("Not enough bytes to read comparator name of component " + i);
1:5d98581: 
1:9d06ea6:             ByteBuffer value = ByteBufferUtil.readBytes(bb, header);
1:7a3e697:             String valueStr = null;
1:5d98581:             try
1:5d98581:             {
1:7a3e697:                 valueStr = ByteBufferUtil.string(value);
1:7a3e697:                 comparator = TypeParser.parse(valueStr);
1:5d98581:             }
1:7a3e697:             catch (CharacterCodingException ce) 
1:5d98581:             {
1:7a3e697:                 // ByteBufferUtil.string failed. 
1:7a3e697:                 // Log it here and we'll further throw an exception below since comparator == null
1:7a3e697:                 logger.error("Failed with [{}] when decoding the byte buffer in ByteBufferUtil.string()", 
1:7a3e697:                    ce.toString());
1:5d98581:             }
1:5d98581:             catch (Exception e)
1:5d98581:             {
1:7a3e697:                 // parse failed. 
1:7a3e697:                 // Log it here and we'll further throw an exception below since comparator == null
1:7a3e697:                 logger.error("Failed to parse value string \"{}\" with exception: [{}]", 
1:7a3e697:                    valueStr, e.toString());
1:5d98581:             }
1:5d98581:         }
1:5d98581:         else
1:5d98581:         {
1:5d98581:             comparator = aliases.get((byte)(header & 0xFF));
1:5d98581:         }
1:5d98581: 
1:5d98581:         if (comparator == null)
1:5d98581:             throw new MarshalException("Cannot find comparator for component " + i);
1:5d98581:         else
1:5d98581:             return comparator;
1:5d98581:     }
1:5d98581: 
1:8ea2d2a:     public ByteBuffer decompose(Object... objects)
1:0fdab63:     {
1:8ea2d2a:         throw new UnsupportedOperationException();
1:5d98581:     }
1:e9c6742: 
1:daff1fc:     @Override
1:0fdab63:     public boolean isCompatibleWith(AbstractType<?> previous)
1:e9c6742:     {
1:0fdab63:         if (this == previous)
1:0fdab63:             return true;
1:0fdab63: 
1:0fdab63:         if (!(previous instanceof DynamicCompositeType))
1:0fdab63:             return false;
1:0fdab63: 
1:0fdab63:         // Adding new aliases is fine (but removing is not)
1:0fdab63:         // Note that modifying the type for an alias to a compatible type is
1:0fdab63:         // *not* fine since this would deal correctly with mixed aliased/not
1:0fdab63:         // aliased component.
1:0fdab63:         DynamicCompositeType cp = (DynamicCompositeType)previous;
1:0fdab63:         if (aliases.size() < cp.aliases.size())
1:0fdab63:             return false;
1:0fdab63: 
1:0fdab63:         for (Map.Entry<Byte, AbstractType<?>> entry : cp.aliases.entrySet())
1:0fdab63:         {
1:0fdab63:             AbstractType<?> tprev = entry.getValue();
1:0fdab63:             AbstractType<?> tnew = aliases.get(entry.getKey());
1:0fdab63:             if (tnew == null || tnew != tprev)
1:0fdab63:                 return false;
1:e9c6742:         }
1:0fdab63:         return true;
1:0fdab63:     }
1:0fdab63: 
1:5d98581:     private class DynamicParsedComparator implements ParsedComparator
1:5d98581:     {
1:2bc0d4d:         final AbstractType<?> type;
1:5d98581:         final boolean isAlias;
1:5d98581:         final String comparatorName;
1:5d98581:         final String remainingPart;
1:5d98581: 
1:5d98581:         DynamicParsedComparator(String part)
1:5d98581:         {
1:5d98581:             String[] splits = part.split("@");
1:5d98581:             if (splits.length != 2)
1:5d98581:                 throw new IllegalArgumentException("Invalid component representation: " + part);
1:5d98581: 
1:5d98581:             comparatorName = splits[0];
1:5d98581:             remainingPart = splits[1];
1:5d98581: 
1:5d98581:             try
1:5d98581:             {
1:2bc0d4d:                 AbstractType<?> t = null;
1:5d98581:                 if (comparatorName.length() == 1)
1:5d98581:                 {
1:5d98581:                     // try for an alias
1:5d98581:                     // Note: the char to byte cast is theorically bogus for unicode character. I take full
1:5d98581:                     // responsibility if someone get hit by this (without making it on purpose)
1:5d98581:                     t = aliases.get((byte)comparatorName.charAt(0));
1:0fdab63:                 }
1:5d98581:                 isAlias = t != null;
1:5d98581:                 if (!isAlias)
1:5d98581:                 {
1:5d98581:                     t = TypeParser.parse(comparatorName);
1:5d98581:                 }
1:5d98581:                 type = t;
1:3a2faf9:             }
1:1762424:             catch (SyntaxException | ConfigurationException e)
1:3a2faf9:             {
1:3a2faf9:                 throw new IllegalArgumentException(e);
1:5d98581:             }
1:5d98581:         }
1:5d98581: 
1:2bc0d4d:         public AbstractType<?> getAbstractType()
1:5d98581:         {
1:5d98581:             return type;
1:5d98581:         }
1:5d98581: 
1:5d98581:         public String getRemainingPart()
1:5d98581:         {
1:5d98581:             return remainingPart;
1:5d98581:         }
1:5d98581: 
1:5d98581:         public int getComparatorSerializedSize()
1:5d98581:         {
1:5d98581:             return isAlias ? 2 : 2 + ByteBufferUtil.bytes(comparatorName).remaining();
1:5d98581:         }
1:5d98581: 
1:5d98581:         public void serializeComparator(ByteBuffer bb)
1:5d98581:         {
1:5d98581:             int header = 0;
1:5d98581:             if (isAlias)
1:6ea00a3:                 header = 0x8000 | (((byte)comparatorName.charAt(0)) & 0xFF);
1:5d98581:             else
1:5d98581:                 header = comparatorName.length();
1:9d06ea6:             ByteBufferUtil.writeShortLength(bb, header);
1:5d98581: 
1:5d98581:             if (!isAlias)
1:5d98581:                 bb.put(ByteBufferUtil.bytes(comparatorName));
1:5d98581:         }
1:5d98581:     }
1:5d98581: 
1:c7b02d1:     @Override
1:5d98581:     public String toString()
1:5d98581:     {
1:5d98581:         return getClass().getName() + TypeParser.stringifyAliasesParameters(aliases);
1:5d98581:     }
1:6a1ed62: 
1:6a1ed62:     /*
1:6a1ed62:      * A comparator that always sorts it's first argument before the second
1:6a1ed62:      * one.
1:6a1ed62:      */
1:6a1ed62:     private static class FixedValueComparator extends AbstractType<Void>
1:6a1ed62:     {
1:5e15927:         public static final FixedValueComparator alwaysLesserThan = new FixedValueComparator(-1);
1:5e15927:         public static final FixedValueComparator alwaysGreaterThan = new FixedValueComparator(1);
1:5e15927: 
1:5e15927:         private final int cmp;
1:5e15927: 
1:5e15927:         public FixedValueComparator(int cmp)
1:5e15927:         {
1:07594ee:             super(ComparisonType.CUSTOM);
1:5e15927:             this.cmp = cmp;
1:5e15927:         }
1:6a1ed62: 
1:07594ee:         public int compareCustom(ByteBuffer v1, ByteBuffer v2)
1:6a1ed62:         {
1:5e15927:             return cmp;
1:6a1ed62:         }
1:6a1ed62: 
1:daff1fc:         @Override
1:6a1ed62:         public Void compose(ByteBuffer bytes)
1:6a1ed62:         {
1:e9c6742:             throw new UnsupportedOperationException();
1:6a1ed62:         }
1:6a1ed62: 
1:daff1fc:         @Override
1:6a1ed62:         public ByteBuffer decompose(Void value)
1:6a1ed62:         {
1:6a1ed62:             throw new UnsupportedOperationException();
1:6a1ed62:         }
1:6a1ed62: 
1:6a1ed62:         public String getString(ByteBuffer bytes)
1:6a1ed62:         {
1:6a1ed62:             throw new UnsupportedOperationException();
1:6a1ed62:         }
1:6a1ed62: 
1:ccb0028:         public ByteBuffer fromString(String str)
1:5d98581:         {
1:6a1ed62:             throw new UnsupportedOperationException();
1:5d98581:         }
1:acf1b18: 
1:e9c6742:         @Override
1:c7b02d1:         public Term fromJSONObject(Object parsed)
1:c7b02d1:         {
1:c7b02d1:             throw new UnsupportedOperationException();
1:c7b02d1:         }
1:c7b02d1: 
1:c7b02d1:         @Override
1:e0adc16:         public String toJSONString(ByteBuffer buffer, ProtocolVersion protocolVersion)
1:c7b02d1:         {
1:c7b02d1:             throw new UnsupportedOperationException();
1:c7b02d1:         }
1:c7b02d1: 
1:0fdab63:         @Override
1:6a1ed62:         public void validate(ByteBuffer bytes)
1:6a1ed62:         {
1:6a1ed62:             throw new UnsupportedOperationException();
1:6a1ed62:         }
1:7a3e697: 
1:fc8b76f:         public TypeSerializer<Void> getSerializer()
1:5d98581:         {
1:ccb0028:             throw new UnsupportedOperationException();
1:6a1ed62:         }
1:5d98581:     }
1:5d98581: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:e0adc16
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.transport.ProtocolVersion;
/////////////////////////////////////////////////////////////////////////
1:         public String toJSONString(ByteBuffer buffer, ProtocolVersion protocolVersion)
author:Dave Brosius
-------------------------------------------------------------------------------
commit:68d2526
/////////////////////////////////////////////////////////////////////////
1:         if ((comp1 instanceof ReversedType) && (comp2 instanceof ReversedType)) 
1:         {
commit:7588f74
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:07594ee
/////////////////////////////////////////////////////////////////////////
1:             super(ComparisonType.CUSTOM);
1:         public int compareCustom(ByteBuffer v1, ByteBuffer v2)
/////////////////////////////////////////////////////////////////////////
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:c7b02d1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.cql3.Term;
/////////////////////////////////////////////////////////////////////////
1:         public Term fromJSONObject(Object parsed)
1:         {
1:             throw new UnsupportedOperationException();
1:         }
1: 
1:         @Override
0:         public String toJSONString(ByteBuffer buffer, int protocolVersion)
1:         {
1:             throw new UnsupportedOperationException();
1:         }
1: 
1:         @Override
author:Robert Stupp
-------------------------------------------------------------------------------
commit:1762424
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             catch (SyntaxException | ConfigurationException e)
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:4743811
commit:9d06ea6
/////////////////////////////////////////////////////////////////////////
1:             int header = ByteBufferUtil.readShortLength(bb);
1:                 String name = ByteBufferUtil.string(ByteBufferUtil.readBytes(bb, header));
/////////////////////////////////////////////////////////////////////////
1:             int header = ByteBufferUtil.readShortLength(bb);
1:                 String name = ByteBufferUtil.string(ByteBufferUtil.readBytes(bb, header));
/////////////////////////////////////////////////////////////////////////
1:         int header = ByteBufferUtil.readShortLength(bb);
1:             ByteBuffer value = ByteBufferUtil.readBytes(bb, header);
/////////////////////////////////////////////////////////////////////////
1:             ByteBufferUtil.writeShortLength(bb, header);
commit:8a52f5a
/////////////////////////////////////////////////////////////////////////
0:             int header = ByteBufferUtil.readShortLength(bb);
0:                 String name = ByteBufferUtil.string(ByteBufferUtil.readBytes(bb, header));
/////////////////////////////////////////////////////////////////////////
0:             int header = ByteBufferUtil.readShortLength(bb);
0:                 String name = ByteBufferUtil.string(ByteBufferUtil.readBytes(bb, header));
/////////////////////////////////////////////////////////////////////////
0:         int header = ByteBufferUtil.readShortLength(bb);
0:             ByteBuffer value = ByteBufferUtil.readBytes(bb, header);
/////////////////////////////////////////////////////////////////////////
0:             ByteBufferUtil.writeShortLength(bb, header);
commit:63b1ef4
commit:b09d876
/////////////////////////////////////////////////////////////////////////
1:     protected boolean readIsStatic(ByteBuffer bb)
1:     {
1:         // We don't have the static nothing for DCT
1:         return false;
1:     }
1: 
commit:daff1fc
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
commit:fc8b76f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.serializers.TypeSerializer;
1: import org.apache.cassandra.serializers.MarshalException;
/////////////////////////////////////////////////////////////////////////
1:         public TypeSerializer<Void> getSerializer()
commit:e9c6742
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.type.AbstractSerializer;
0: import org.apache.cassandra.type.MarshalException;
/////////////////////////////////////////////////////////////////////////
1: 
1:         @Override
0:         public AbstractSerializer<Void> asComposer()
1:         {
1:             throw new UnsupportedOperationException();
1:         }
commit:5e15927
/////////////////////////////////////////////////////////////////////////
1:              * fallback on the full name if necessary
1:              */
1:                 return cmp < 0 ? FixedValueComparator.alwaysLesserThan : FixedValueComparator.alwaysGreaterThan;
1:                 return cmp < 0 ? FixedValueComparator.alwaysLesserThan : FixedValueComparator.alwaysGreaterThan;
/////////////////////////////////////////////////////////////////////////
1:         public static final FixedValueComparator alwaysLesserThan = new FixedValueComparator(-1);
1:         public static final FixedValueComparator alwaysGreaterThan = new FixedValueComparator(1);
1: 
1:         private final int cmp;
1: 
1:         public FixedValueComparator(int cmp)
1:         {
1:             this.cmp = cmp;
1:         }
1:             return cmp;
commit:3a2faf9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.exceptions.ConfigurationException;
1: import org.apache.cassandra.exceptions.SyntaxException;
/////////////////////////////////////////////////////////////////////////
1:     public static synchronized DynamicCompositeType getInstance(TypeParser parser) throws ConfigurationException, SyntaxException
/////////////////////////////////////////////////////////////////////////
0:         catch (SyntaxException e)
1:         {
1:             throw new RuntimeException(e);
1:         }
/////////////////////////////////////////////////////////////////////////
0:         catch (SyntaxException e)
1:         {
1:             throw new RuntimeException(e);
1:         }
/////////////////////////////////////////////////////////////////////////
0:             catch (SyntaxException e)
1:             {
1:                 throw new IllegalArgumentException(e);
1:             }
commit:bc577ba
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
commit:0fdab63
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public boolean isCompatibleWith(AbstractType<?> previous)
1:     {
1:         if (this == previous)
1:             return true;
1: 
1:         if (!(previous instanceof DynamicCompositeType))
1:             return false;
1: 
1:         // Adding new aliases is fine (but removing is not)
1:         // Note that modifying the type for an alias to a compatible type is
1:         // *not* fine since this would deal correctly with mixed aliased/not
1:         // aliased component.
1:         DynamicCompositeType cp = (DynamicCompositeType)previous;
1:         if (aliases.size() < cp.aliases.size())
1:             return false;
1: 
1:         for (Map.Entry<Byte, AbstractType<?>> entry : cp.aliases.entrySet())
1:         {
1:             AbstractType<?> tprev = entry.getValue();
1:             AbstractType<?> tnew = aliases.get(entry.getKey());
1:             if (tnew == null || tnew != tprev)
1:                 return false;
1:         }
1:         return true;
1:     }
1: 
commit:6a1ed62
/////////////////////////////////////////////////////////////////////////
1:         // Fast test if the comparator uses singleton instances
1:             /*
1:              * We compare component of different types by comparing the
1:              * comparator class names. We start with the simple classname
1:              * first because that will be faster in almost all cases, but
0:              * allback on the full name if necessary
1:             */
1:             int cmp = comp1.getClass().getSimpleName().compareTo(comp2.getClass().getSimpleName());
1:             if (cmp != 0)
0:                 return cmp < 0 ? FixedValueComparator.instance : ReversedType.getInstance(FixedValueComparator.instance);
1: 
1:             cmp = comp1.getClass().getName().compareTo(comp2.getClass().getName());
1:             if (cmp != 0)
0:                 return cmp < 0 ? FixedValueComparator.instance : ReversedType.getInstance(FixedValueComparator.instance);
1: 
1:             // if cmp == 0, we're actually having the same type, but one that
1:             // did not have a singleton instance. It's ok (though inefficient).
/////////////////////////////////////////////////////////////////////////
1: 
1:     /*
1:      * A comparator that always sorts it's first argument before the second
1:      * one.
1:      */
1:     private static class FixedValueComparator extends AbstractType<Void>
1:     {
0:         public static final FixedValueComparator instance = new FixedValueComparator();
1: 
0:         public int compare(ByteBuffer v1, ByteBuffer v2)
1:         {
0:             return -1;
1:         }
1: 
1:         public Void compose(ByteBuffer bytes)
1:         {
1:             throw new UnsupportedOperationException();
1:         }
1: 
1:         public ByteBuffer decompose(Void value)
1:         {
1:             throw new UnsupportedOperationException();
1:         }
1: 
1:         public String getString(ByteBuffer bytes)
1:         {
1:             throw new UnsupportedOperationException();
1:         }
1: 
1:         public void validate(ByteBuffer bytes)
1:         {
1:             throw new UnsupportedOperationException();
1:         }
1:     }
commit:6ea00a3
/////////////////////////////////////////////////////////////////////////
1:                 header = 0x8000 | (((byte)comparatorName.charAt(0)) & 0xFF);
commit:5d98581
/////////////////////////////////////////////////////////////////////////
0: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
1:  */
1: package org.apache.cassandra.db.marshal;
1: 
1: import java.nio.charset.CharacterCodingException;
1: import java.nio.ByteBuffer;
0: import java.util.Iterator;
0: import java.util.ArrayList;
1: import java.util.HashMap;
0: import java.util.List;
1: import java.util.Map;
1: 
0: import org.apache.cassandra.config.ConfigurationException;
1: import org.apache.cassandra.utils.ByteBufferUtil;
0: import org.apache.cassandra.utils.FBUtilities;
1: 
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /*
1:  * The encoding of a DynamicCompositeType column name should be:
1:  *   <component><component><component> ...
1:  * where <component> is:
1:  *   <comparator part><value><'end-of-component' byte>
1:  * where:
1:  *   - <comparator part>: either the comparator full name, or a declared
1:  *     aliases. This is at least 2 bytes (those 2 bytes are called header in
1:  *     the following). If the first bit of the header is 1, then this
1:  *     comparator part is an alias, otherwise it's a comparator full name:
1:  *       - aliases: the actual alias is the 2nd byte of header taken as a
1:  *         character. The whole <comparator part> is thus 2 byte long.
1:  *       - comparator full name: the header is the length of the remaining
1:  *         part. The remaining part is the UTF-8 encoded comparator class
1:  *         name.
1:  *   - <value>: the component value bytes preceded by 2 byte containing the
1:  *     size of value (see CompositeType).
1:  *   - 'end-of-component' byte is defined as in CompositeType
1:  */
1: public class DynamicCompositeType extends AbstractCompositeType
1: {
1:     private static final Logger logger = LoggerFactory.getLogger(DynamicCompositeType.class);
1: 
0:     private final Map<Byte, AbstractType> aliases;
1: 
1:     // interning instances
0:     private static final Map<Map<Byte, AbstractType>, DynamicCompositeType> instances = new HashMap<Map<Byte, AbstractType>, DynamicCompositeType>();
1: 
0:     public static synchronized DynamicCompositeType getInstance(TypeParser parser) throws ConfigurationException
1:     {
1:         return getInstance(parser.getAliasParameters());
1:     }
1: 
0:     public static synchronized DynamicCompositeType getInstance(Map<Byte, AbstractType> aliases)
1:     {
1:         DynamicCompositeType dct = instances.get(aliases);
1:         if (dct == null)
1:         {
1:             dct = new DynamicCompositeType(aliases);
1:             instances.put(aliases, dct);
1:         }
1:         return dct;
1:     }
1: 
0:     private DynamicCompositeType(Map<Byte, AbstractType> aliases)
1:     {
1:         this.aliases = aliases;
1:     }
1: 
0:     private AbstractType getComparator(ByteBuffer bb)
1:     {
1:         try
1:         {
0:             int header = getShortLength(bb);
1:             if ((header & 0x8000) == 0)
1:             {
0:                 String name = ByteBufferUtil.string(getBytes(bb, header));
1:                 return TypeParser.parse(name);
1:             }
1:             else
1:             {
1:                 return aliases.get((byte)(header & 0xFF));
1:             }
1:         }
1:         catch (CharacterCodingException e)
1:         {
0:             throw new RuntimeException(e);
1:         }
0:         catch (ConfigurationException e)
1:         {
0:             throw new RuntimeException(e);
1:         }
1:     }
1: 
0:     protected AbstractType getNextComparator(int i, ByteBuffer bb)
1:     {
1:         return getComparator(bb);
1:     }
1: 
0:     protected AbstractType getNextComparator(int i, ByteBuffer bb1, ByteBuffer bb2)
1:     {
0:         AbstractType comp1 = getComparator(bb1);
0:         AbstractType comp2 = getComparator(bb2);
1: 
0:         // This rely on comparator always being singleton instances
1:         if (comp1 != comp2)
1:         {
0:             logger.error("Mismatch between {} and {}", comp1, comp2);
0:             throw new RuntimeException("Comparator mismatch while comparing two DynamicCompositeType colum name");
1:         }
0:         return comp1;
1:     }
1: 
0:     protected AbstractType getAndAppendNextComparator(int i, ByteBuffer bb, StringBuilder sb)
1:     {
1:         try
1:         {
0:             int header = getShortLength(bb);
1:             if ((header & 0x8000) == 0)
1:             {
0:                 String name = ByteBufferUtil.string(getBytes(bb, header));
1:                 sb.append(name).append("@");
1:                 return TypeParser.parse(name);
1:             }
1:             else
1:             {
1:                 sb.append((char)(header & 0xFF)).append("@");
1:                 return aliases.get((byte)(header & 0xFF));
1:             }
1:         }
1:         catch (CharacterCodingException e)
1:         {
0:             throw new RuntimeException(e);
1:         }
0:         catch (ConfigurationException e)
1:         {
0:             throw new RuntimeException(e);
1:         }
1:     }
1: 
0:     protected ParsedComparator parseNextComparator(int i, String part)
1:     {
1:         return new DynamicParsedComparator(part);
1:     }
1: 
0:     protected AbstractType validateNextComparator(int i, ByteBuffer bb) throws MarshalException
1:     {
0:         AbstractType comparator = null;
1:         if (bb.remaining() < 2)
1:             throw new MarshalException("Not enough bytes to header of the comparator part of component " + i);
0:         int header = getShortLength(bb);
1:         if ((header & 0x8000) == 0)
1:         {
1:             if (bb.remaining() < header)
1:                 throw new MarshalException("Not enough bytes to read comparator name of component " + i);
1: 
0:             ByteBuffer value = getBytes(bb, header);
1:             try
1:             {
0:                 comparator = TypeParser.parse(ByteBufferUtil.string(value));
1:             }
1:             catch (Exception e)
1:             {
0:                 // we'll deal with this below since comparator == null
1:             }
1:         }
1:         else
1:         {
1:             comparator = aliases.get((byte)(header & 0xFF));
1:         }
1: 
1:         if (comparator == null)
1:             throw new MarshalException("Cannot find comparator for component " + i);
1:         else
1:             return comparator;
1:     }
1: 
1:     private class DynamicParsedComparator implements ParsedComparator
1:     {
0:         final AbstractType type;
1:         final boolean isAlias;
1:         final String comparatorName;
1:         final String remainingPart;
1: 
1:         DynamicParsedComparator(String part)
1:         {
1:             String[] splits = part.split("@");
1:             if (splits.length != 2)
1:                 throw new IllegalArgumentException("Invalid component representation: " + part);
1: 
1:             comparatorName = splits[0];
1:             remainingPart = splits[1];
1: 
1:             try
1:             {
0:                 AbstractType t = null;
1:                 if (comparatorName.length() == 1)
1:                 {
1:                     // try for an alias
1:                     // Note: the char to byte cast is theorically bogus for unicode character. I take full
1:                     // responsibility if someone get hit by this (without making it on purpose)
1:                     t = aliases.get((byte)comparatorName.charAt(0));
1:                 }
1:                 isAlias = t != null;
1:                 if (!isAlias)
1:                 {
1:                     t = TypeParser.parse(comparatorName);
1:                 }
1:                 type = t;
1:             }
0:             catch (ConfigurationException e)
1:             {
0:                 throw new IllegalArgumentException(e);
1:             }
1:         }
1: 
0:         public AbstractType getAbstractType()
1:         {
1:             return type;
1:         }
1: 
1:         public String getRemainingPart()
1:         {
1:             return remainingPart;
1:         }
1: 
1:         public int getComparatorSerializedSize()
1:         {
1:             return isAlias ? 2 : 2 + ByteBufferUtil.bytes(comparatorName).remaining();
1:         }
1: 
1:         public void serializeComparator(ByteBuffer bb)
1:         {
1:             int header = 0;
1:             if (isAlias)
0:                 header = 0x8000 | ((byte)comparatorName.charAt(0));
1:             else
1:                 header = comparatorName.length();
0:             putShortLength(bb, header);
1: 
1:             if (!isAlias)
1:                 bb.put(ByteBufferUtil.bytes(comparatorName));
1:         }
1:     }
1: 
0:     @Override
1:     public String toString()
1:     {
1:         return getClass().getName() + TypeParser.stringifyAliasesParameters(aliases);
1:     }
1: }
author:Tim Whittington
-------------------------------------------------------------------------------
commit:b93ca58
/////////////////////////////////////////////////////////////////////////
1:         AbstractType<?> rawComp = comp1;
1: 
1:         /*
1:          * If both types are ReversedType(Type), we need to compare on the wrapped type (which may differ between the two types) to avoid
1:          * incompatible comparisons being made.
0:          */
0:         if ((comp1 instanceof ReversedType) && (comp2 instanceof ReversedType)) {
1:             comp1 = ((ReversedType<?>) comp1).baseType;
1:             comp2 = ((ReversedType<?>) comp2).baseType;
0:         }
/////////////////////////////////////////////////////////////////////////
1:         // Use the raw comparator (prior to ReversedType unwrapping)
1:         return rawComp;
author:belliottsmith
-------------------------------------------------------------------------------
commit:acf1b18
/////////////////////////////////////////////////////////////////////////
1: 
0:         public boolean isByteOrderComparable()
0:         {
0:             return false;
0:         }
author:Ding Yuan
-------------------------------------------------------------------------------
commit:7a3e697
/////////////////////////////////////////////////////////////////////////
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
1: 
/////////////////////////////////////////////////////////////////////////
0:     private static final Logger logger = LoggerFactory.getLogger(DynamicCompositeType.class);
0: 
/////////////////////////////////////////////////////////////////////////
1:             String valueStr = null;
1:                 valueStr = ByteBufferUtil.string(value);
1:                 comparator = TypeParser.parse(valueStr);
0:             }
1:             catch (CharacterCodingException ce) 
0:             {
1:                 // ByteBufferUtil.string failed. 
1:                 // Log it here and we'll further throw an exception below since comparator == null
1:                 logger.error("Failed with [{}] when decoding the byte buffer in ByteBufferUtil.string()", 
1:                    ce.toString());
1:                 // parse failed. 
1:                 // Log it here and we'll further throw an exception below since comparator == null
1:                 logger.error("Failed to parse value string \"{}\" with exception: [{}]", 
1:                    valueStr, e.toString());
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:02b59eb
commit:8ea2d2a
/////////////////////////////////////////////////////////////////////////
1:     public ByteBuffer decompose(Object... objects)
0:     {
1:         throw new UnsupportedOperationException();
0:     }
0: 
commit:bfe2dfb
/////////////////////////////////////////////////////////////////////////
1:     protected AbstractType<?> getComparator(int i, ByteBuffer bb)
1:     protected AbstractType<?> getComparator(int i, ByteBuffer bb1, ByteBuffer bb2)
/////////////////////////////////////////////////////////////////////////
1:     protected AbstractType<?> getAndAppendComparator(int i, ByteBuffer bb, StringBuilder sb)
/////////////////////////////////////////////////////////////////////////
1:     protected ParsedComparator parseComparator(int i, String part)
1:     protected AbstractType<?> validateComparator(int i, ByteBuffer bb) throws MarshalException
commit:ccb0028
/////////////////////////////////////////////////////////////////////////
1:         public ByteBuffer fromString(String str)
0:         {
1:             throw new UnsupportedOperationException();
0:         }
0: 
commit:2bc0d4d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final Map<Byte, AbstractType<?>> aliases;
1:     private static final Map<Map<Byte, AbstractType<?>>, DynamicCompositeType> instances = new HashMap<Map<Byte, AbstractType<?>>, DynamicCompositeType>();
1:     public static synchronized DynamicCompositeType getInstance(Map<Byte, AbstractType<?>> aliases)
/////////////////////////////////////////////////////////////////////////
1:     private DynamicCompositeType(Map<Byte, AbstractType<?>> aliases)
1:     private AbstractType<?> getComparator(ByteBuffer bb)
/////////////////////////////////////////////////////////////////////////
0:     protected AbstractType<?> getNextComparator(int i, ByteBuffer bb)
0:     protected AbstractType<?> getNextComparator(int i, ByteBuffer bb1, ByteBuffer bb2)
1:         AbstractType<?> comp1 = getComparator(bb1);
1:         AbstractType<?> comp2 = getComparator(bb2);
/////////////////////////////////////////////////////////////////////////
0:     protected AbstractType<?> getAndAppendNextComparator(int i, ByteBuffer bb, StringBuilder sb)
/////////////////////////////////////////////////////////////////////////
0:     protected AbstractType<?> validateNextComparator(int i, ByteBuffer bb) throws MarshalException
1:         AbstractType<?> comparator = null;
/////////////////////////////////////////////////////////////////////////
1:         final AbstractType<?> type;
/////////////////////////////////////////////////////////////////////////
1:                 AbstractType<?> t = null;
/////////////////////////////////////////////////////////////////////////
1:         public AbstractType<?> getAbstractType()
commit:44a7db7
============================================================================