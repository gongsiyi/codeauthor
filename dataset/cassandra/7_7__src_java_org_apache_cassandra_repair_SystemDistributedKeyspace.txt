1:c5b0242: /*
1:c5b0242:  * Licensed to the Apache Software Foundation (ASF) under one
1:c5b0242:  * or more contributor license agreements.  See the NOTICE file
1:c5b0242:  * distributed with this work for additional information
1:c5b0242:  * regarding copyright ownership.  The ASF licenses this file
1:c5b0242:  * to you under the Apache License, Version 2.0 (the
1:c5b0242:  * "License"); you may not use this file except in compliance
1:c5b0242:  * with the License.  You may obtain a copy of the License at
1:c5b0242:  *
1:c5b0242:  *     http://www.apache.org/licenses/LICENSE-2.0
1:c5b0242:  *
1:c5b0242:  * Unless required by applicable law or agreed to in writing, software
1:c5b0242:  * distributed under the License is distributed on an "AS IS" BASIS,
1:c5b0242:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:c5b0242:  * See the License for the specific language governing permissions and
1:c5b0242:  * limitations under the License.
1:c5b0242:  */
1:c5b0242: package org.apache.cassandra.repair;
2:c5b0242: 
1:c5b0242: import java.io.PrintWriter;
1:c5b0242: import java.io.StringWriter;
1:c5b0242: import java.net.InetAddress;
1:49c31d6: import java.nio.ByteBuffer;
1:49c31d6: import java.util.ArrayList;
1:c5b0242: import java.util.Collection;
1:21448c5: import java.util.Collections;
1:21448c5: import java.util.HashMap;
1:c5b0242: import java.util.List;
1:b210bd2: import java.util.Map;
1:c5b0242: import java.util.Set;
1:c5b0242: import java.util.UUID;
1:c5b0242: 
1:c5b0242: import com.google.common.base.Joiner;
1:21448c5: import com.google.common.collect.Lists;
1:c5b0242: import com.google.common.collect.Sets;
1:c5b0242: 
1:c5b0242: import org.slf4j.Logger;
1:c5b0242: import org.slf4j.LoggerFactory;
1:c5b0242: 
1:c5b0242: import org.apache.cassandra.config.CFMetaData;
1:b3a4e20: import org.apache.cassandra.config.DatabaseDescriptor;
1:9797511: import org.apache.cassandra.config.SchemaConstants;
1:c5b0242: import org.apache.cassandra.cql3.QueryProcessor;
1:21448c5: import org.apache.cassandra.cql3.UntypedResultSet;
1:49c31d6: import org.apache.cassandra.db.ConsistencyLevel;
1:21448c5: import org.apache.cassandra.db.Keyspace;
1:c5b0242: import org.apache.cassandra.dht.Range;
1:c5b0242: import org.apache.cassandra.dht.Token;
1:b210bd2: import org.apache.cassandra.repair.messages.RepairOption;
1:a89597d: import org.apache.cassandra.schema.KeyspaceMetadata;
1:31e3f61: import org.apache.cassandra.schema.KeyspaceParams;
1:6e1033b: import org.apache.cassandra.schema.Tables;
1:c5b0242: import org.apache.cassandra.utils.FBUtilities;
1:c5b0242: 
1:21448c5: import static org.apache.cassandra.utils.ByteBufferUtil.bytes;
1:21448c5: 
1:c5b0242: public final class SystemDistributedKeyspace
1:c5b0242: {
1:31e3f61:     private SystemDistributedKeyspace()
1:31e3f61:     {
1:31e3f61:     }
1:c5b0242: 
1:31e3f61:     private static final Logger logger = LoggerFactory.getLogger(SystemDistributedKeyspace.class);
1:c5b0242: 
1:c5b0242:     public static final String REPAIR_HISTORY = "repair_history";
1:c5b0242: 
1:c5b0242:     public static final String PARENT_REPAIR_HISTORY = "parent_repair_history";
1:c5b0242: 
1:21448c5:     public static final String VIEW_BUILD_STATUS = "view_build_status";
1:21448c5: 
1:c5b0242:     private static final CFMetaData RepairHistory =
1:c5b0242:         compile(REPAIR_HISTORY,
1:c5b0242:                 "Repair history",
1:c5b0242:                 "CREATE TABLE %s ("
1:c5b0242:                      + "keyspace_name text,"
1:c5b0242:                      + "columnfamily_name text,"
1:c5b0242:                      + "id timeuuid,"
1:c5b0242:                      + "parent_id timeuuid,"
1:c5b0242:                      + "range_begin text,"
1:c5b0242:                      + "range_end text,"
1:c5b0242:                      + "coordinator inet,"
1:c5b0242:                      + "participants set<inet>,"
1:c5b0242:                      + "exception_message text,"
1:c5b0242:                      + "exception_stacktrace text,"
1:c5b0242:                      + "status text,"
1:c5b0242:                      + "started_at timestamp,"
1:c5b0242:                      + "finished_at timestamp,"
1:c5b0242:                      + "PRIMARY KEY ((keyspace_name, columnfamily_name), id))");
1:c5b0242: 
1:c5b0242:     private static final CFMetaData ParentRepairHistory =
1:c5b0242:         compile(PARENT_REPAIR_HISTORY,
1:c5b0242:                 "Repair history",
1:c5b0242:                 "CREATE TABLE %s ("
1:c5b0242:                      + "parent_id timeuuid,"
1:c5b0242:                      + "keyspace_name text,"
1:c5b0242:                      + "columnfamily_names set<text>,"
1:c5b0242:                      + "started_at timestamp,"
1:c5b0242:                      + "finished_at timestamp,"
1:c5b0242:                      + "exception_message text,"
1:c5b0242:                      + "exception_stacktrace text,"
1:c5b0242:                      + "requested_ranges set<text>,"
1:c5b0242:                      + "successful_ranges set<text>,"
1:b210bd2:                      + "options map<text, text>,"
1:c5b0242:                      + "PRIMARY KEY (parent_id))");
1:c5b0242: 
1:21448c5:     private static final CFMetaData ViewBuildStatus =
1:21448c5:     compile(VIEW_BUILD_STATUS,
1:21448c5:             "Materialized View build status",
1:21448c5:             "CREATE TABLE %s ("
1:21448c5:                      + "keyspace_name text,"
1:21448c5:                      + "view_name text,"
1:21448c5:                      + "host_id uuid,"
1:21448c5:                      + "status text,"
1:21448c5:                      + "PRIMARY KEY ((keyspace_name, view_name), host_id))");
1:21448c5: 
1:c5b0242:     private static CFMetaData compile(String name, String description, String schema)
1:c5b0242:     {
1:9797511:         return CFMetaData.compile(String.format(schema, name), SchemaConstants.DISTRIBUTED_KEYSPACE_NAME)
1:c5b0242:                          .comment(description);
1:c5b0242:     }
1:c5b0242: 
1:a89597d:     public static KeyspaceMetadata metadata()
1:c5b0242:     {
1:9797511:         return KeyspaceMetadata.create(SchemaConstants.DISTRIBUTED_KEYSPACE_NAME, KeyspaceParams.simple(3), Tables.of(RepairHistory, ParentRepairHistory, ViewBuildStatus));
1:c5b0242:     }
1:c5b0242: 
1:b210bd2:     public static void startParentRepair(UUID parent_id, String keyspaceName, String[] cfnames, RepairOption options)
1:c5b0242:     {
1:b210bd2:         Collection<Range<Token>> ranges = options.getRanges();
1:b210bd2:         String query = "INSERT INTO %s.%s (parent_id, keyspace_name, columnfamily_names, requested_ranges, started_at,          options)"+
1:b210bd2:                                  " VALUES (%s,        '%s',          { '%s' },           { '%s' },          toTimestamp(now()), { %s })";
1:b210bd2:         String fmtQry = String.format(query,
1:9797511:                                       SchemaConstants.DISTRIBUTED_KEYSPACE_NAME,
1:b210bd2:                                       PARENT_REPAIR_HISTORY,
1:b210bd2:                                       parent_id.toString(),
1:b210bd2:                                       keyspaceName,
1:b210bd2:                                       Joiner.on("','").join(cfnames),
1:b210bd2:                                       Joiner.on("','").join(ranges),
1:b210bd2:                                       toCQLMap(options.asMap(), RepairOption.RANGES_KEY, RepairOption.COLUMNFAMILIES_KEY));
1:49c31d6:         processSilent(fmtQry);
1:c5b0242:     }
1:c5b0242: 
1:b210bd2:     private static String toCQLMap(Map<String, String> options, String ... ignore)
1:b210bd2:     {
1:b210bd2:         Set<String> toIgnore = Sets.newHashSet(ignore);
1:b210bd2:         StringBuilder map = new StringBuilder();
1:b210bd2:         boolean first = true;
1:b210bd2:         for (Map.Entry<String, String> entry : options.entrySet())
1:b210bd2:         {
1:b210bd2:             if (!toIgnore.contains(entry.getKey()))
1:b210bd2:             {
1:b210bd2:                 if (!first)
1:b210bd2:                     map.append(',');
1:b210bd2:                 first = false;
1:b210bd2:                 map.append(String.format("'%s': '%s'", entry.getKey(), entry.getValue()));
1:b210bd2:             }
1:b210bd2:         }
1:b210bd2:         return map.toString();
1:b210bd2:     }
1:b210bd2: 
1:c5b0242:     public static void failParentRepair(UUID parent_id, Throwable t)
1:c5b0242:     {
1:c08aaab:         String query = "UPDATE %s.%s SET finished_at = toTimestamp(now()), exception_message=?, exception_stacktrace=? WHERE parent_id=%s";
1:c5b0242: 
1:c5b0242:         StringWriter sw = new StringWriter();
1:c5b0242:         PrintWriter pw = new PrintWriter(sw);
1:c5b0242:         t.printStackTrace(pw);
1:9797511:         String fmtQuery = String.format(query, SchemaConstants.DISTRIBUTED_KEYSPACE_NAME, PARENT_REPAIR_HISTORY, parent_id.toString());
1:49c31d6:         processSilent(fmtQuery, t.getMessage(), sw.toString());
1:c5b0242:     }
1:c5b0242: 
1:c5b0242:     public static void successfulParentRepair(UUID parent_id, Collection<Range<Token>> successfulRanges)
1:c5b0242:     {
1:c08aaab:         String query = "UPDATE %s.%s SET finished_at = toTimestamp(now()), successful_ranges = {'%s'} WHERE parent_id=%s";
1:9797511:         String fmtQuery = String.format(query, SchemaConstants.DISTRIBUTED_KEYSPACE_NAME, PARENT_REPAIR_HISTORY, Joiner.on("','").join(successfulRanges), parent_id.toString());
1:49c31d6:         processSilent(fmtQuery);
1:c5b0242:     }
1:c5b0242: 
1:0dd50a6:     public static void startRepairs(UUID id, UUID parent_id, String keyspaceName, String[] cfnames, Collection<Range<Token>> ranges, Iterable<InetAddress> endpoints)
1:c5b0242:     {
1:c5b0242:         String coordinator = FBUtilities.getBroadcastAddress().getHostAddress();
1:c5b0242:         Set<String> participants = Sets.newHashSet(coordinator);
1:c5b0242: 
1:c5b0242:         for (InetAddress endpoint : endpoints)
1:c5b0242:             participants.add(endpoint.getHostAddress());
1:c5b0242: 
1:c5b0242:         String query =
1:c5b0242:                 "INSERT INTO %s.%s (keyspace_name, columnfamily_name, id, parent_id, range_begin, range_end, coordinator, participants, status, started_at) " +
1:c08aaab:                         "VALUES (   '%s',          '%s',              %s, %s,        '%s',        '%s',      '%s',        { '%s' },     '%s',   toTimestamp(now()))";
1:c5b0242: 
1:c5b0242:         for (String cfname : cfnames)
1:c5b0242:         {
1:0dd50a6:             for (Range<Token> range : ranges)
1:0dd50a6:             {
1:9797511:                 String fmtQry = String.format(query, SchemaConstants.DISTRIBUTED_KEYSPACE_NAME, REPAIR_HISTORY,
2:c5b0242:                                               keyspaceName,
2:c5b0242:                                               cfname,
1:c5b0242:                                               id.toString(),
1:c5b0242:                                               parent_id.toString(),
1:c5b0242:                                               range.left.toString(),
1:c5b0242:                                               range.right.toString(),
1:c5b0242:                                               coordinator,
1:c5b0242:                                               Joiner.on("', '").join(participants),
1:c5b0242:                                               RepairState.STARTED.toString());
1:49c31d6:                 processSilent(fmtQry);
1:c5b0242:             }
1:c5b0242:         }
1:0dd50a6:     }
1:c5b0242: 
1:c5b0242:     public static void failRepairs(UUID id, String keyspaceName, String[] cfnames, Throwable t)
1:c5b0242:     {
1:c5b0242:         for (String cfname : cfnames)
1:c5b0242:             failedRepairJob(id, keyspaceName, cfname, t);
1:c5b0242:     }
1:c5b0242: 
1:c5b0242:     public static void successfulRepairJob(UUID id, String keyspaceName, String cfname)
1:c5b0242:     {
1:c08aaab:         String query = "UPDATE %s.%s SET status = '%s', finished_at = toTimestamp(now()) WHERE keyspace_name = '%s' AND columnfamily_name = '%s' AND id = %s";
1:9797511:         String fmtQuery = String.format(query, SchemaConstants.DISTRIBUTED_KEYSPACE_NAME, REPAIR_HISTORY,
1:c5b0242:                                         RepairState.SUCCESS.toString(),
1:c5b0242:                                         keyspaceName,
1:c5b0242:                                         cfname,
2:c5b0242:                                         id.toString());
1:49c31d6:         processSilent(fmtQuery);
1:c5b0242:     }
1:c5b0242: 
1:c5b0242:     public static void failedRepairJob(UUID id, String keyspaceName, String cfname, Throwable t)
1:c5b0242:     {
1:c08aaab:         String query = "UPDATE %s.%s SET status = '%s', finished_at = toTimestamp(now()), exception_message=?, exception_stacktrace=? WHERE keyspace_name = '%s' AND columnfamily_name = '%s' AND id = %s";
1:c5b0242:         StringWriter sw = new StringWriter();
1:c5b0242:         PrintWriter pw = new PrintWriter(sw);
1:c5b0242:         t.printStackTrace(pw);
1:9797511:         String fmtQry = String.format(query, SchemaConstants.DISTRIBUTED_KEYSPACE_NAME, REPAIR_HISTORY,
1:9797511:                                       RepairState.FAILED.toString(),
1:9797511:                                       keyspaceName,
1:9797511:                                       cfname,
1:9797511:                                       id.toString());
1:49c31d6:         processSilent(fmtQry, t.getMessage(), sw.toString());
1:c5b0242:     }
1:c5b0242: 
1:21448c5:     public static void startViewBuild(String keyspace, String view, UUID hostId)
1:21448c5:     {
1:21448c5:         String query = "INSERT INTO %s.%s (keyspace_name, view_name, host_id, status) VALUES (?, ?, ?, ?)";
1:9797511:         QueryProcessor.process(String.format(query, SchemaConstants.DISTRIBUTED_KEYSPACE_NAME, VIEW_BUILD_STATUS),
1:21448c5:                                ConsistencyLevel.ONE,
1:21448c5:                                Lists.newArrayList(bytes(keyspace),
1:21448c5:                                                   bytes(view),
1:21448c5:                                                   bytes(hostId),
1:21448c5:                                                   bytes(BuildStatus.STARTED.toString())));
1:21448c5:     }
1:21448c5: 
1:21448c5:     public static void successfulViewBuild(String keyspace, String view, UUID hostId)
1:21448c5:     {
1:21448c5:         String query = "UPDATE %s.%s SET status = ? WHERE keyspace_name = ? AND view_name = ? AND host_id = ?";
1:9797511:         QueryProcessor.process(String.format(query, SchemaConstants.DISTRIBUTED_KEYSPACE_NAME, VIEW_BUILD_STATUS),
1:21448c5:                                ConsistencyLevel.ONE,
1:21448c5:                                Lists.newArrayList(bytes(BuildStatus.SUCCESS.toString()),
1:21448c5:                                                   bytes(keyspace),
1:21448c5:                                                   bytes(view),
1:21448c5:                                                   bytes(hostId)));
1:21448c5:     }
1:21448c5: 
1:21448c5:     public static Map<UUID, String> viewStatus(String keyspace, String view)
1:21448c5:     {
1:21448c5:         String query = "SELECT host_id, status FROM %s.%s WHERE keyspace_name = ? AND view_name = ?";
1:21448c5:         UntypedResultSet results;
1:21448c5:         try
1:21448c5:         {
1:9797511:             results = QueryProcessor.execute(String.format(query, SchemaConstants.DISTRIBUTED_KEYSPACE_NAME, VIEW_BUILD_STATUS),
1:21448c5:                                              ConsistencyLevel.ONE,
1:21448c5:                                              keyspace,
1:21448c5:                                              view);
1:68d2526:         }
1:68d2526:         catch (Exception e)
1:68d2526:         {
1:21448c5:             return Collections.emptyMap();
1:21448c5:         }
1:21448c5: 
1:21448c5: 
1:21448c5:         Map<UUID, String> status = new HashMap<>();
1:21448c5:         for (UntypedResultSet.Row row : results)
1:21448c5:         {
1:21448c5:             status.put(row.getUUID("host_id"), row.getString("status"));
1:21448c5:         }
1:21448c5:         return status;
1:21448c5:     }
1:21448c5: 
1:21448c5:     public static void setViewRemoved(String keyspaceName, String viewName)
1:21448c5:     {
1:21448c5:         String buildReq = "DELETE FROM %s.%s WHERE keyspace_name = ? AND view_name = ?";
1:9797511:         QueryProcessor.executeInternal(String.format(buildReq, SchemaConstants.DISTRIBUTED_KEYSPACE_NAME, VIEW_BUILD_STATUS), keyspaceName, viewName);
1:21448c5:         forceBlockingFlush(VIEW_BUILD_STATUS);
1:21448c5:     }
1:21448c5: 
1:49c31d6:     private static void processSilent(String fmtQry, String... values)
1:c5b0242:     {
1:c5b0242:         try
1:c5b0242:         {
1:49c31d6:             List<ByteBuffer> valueList = new ArrayList<>();
1:49c31d6:             for (String v : values)
1:49c31d6:             {
1:21448c5:                 valueList.add(bytes(v));
1:49c31d6:             }
1:49c31d6:             QueryProcessor.process(fmtQry, ConsistencyLevel.ONE, valueList);
1:c5b0242:         }
1:c5b0242:         catch (Throwable t)
1:c5b0242:         {
1:c5b0242:             logger.error("Error executing query "+fmtQry, t);
1:c5b0242:         }
1:c5b0242:     }
1:c5b0242: 
1:21448c5:     public static void forceBlockingFlush(String table)
1:21448c5:     {
1:b3a4e20:         if (!DatabaseDescriptor.isUnsafeSystem())
1:9797511:             FBUtilities.waitOnFuture(Keyspace.open(SchemaConstants.DISTRIBUTED_KEYSPACE_NAME).getColumnFamilyStore(table).forceFlush());
1:21448c5:     }
1:c5b0242: 
1:c5b0242:     private enum RepairState
1:c5b0242:     {
1:c5b0242:         STARTED, SUCCESS, FAILED
1:c5b0242:     }
1:21448c5: 
1:21448c5:     private enum BuildStatus
1:21448c5:     {
1:21448c5:         UNKNOWN, STARTED, SUCCESS
1:21448c5:     }
1:c5b0242: }
============================================================================
author:Robert Stupp
-------------------------------------------------------------------------------
commit:b3a4e20
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.DatabaseDescriptor;
/////////////////////////////////////////////////////////////////////////
1:         if (!DatabaseDescriptor.isUnsafeSystem())
commit:9797511
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.SchemaConstants;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return CFMetaData.compile(String.format(schema, name), SchemaConstants.DISTRIBUTED_KEYSPACE_NAME)
1:         return KeyspaceMetadata.create(SchemaConstants.DISTRIBUTED_KEYSPACE_NAME, KeyspaceParams.simple(3), Tables.of(RepairHistory, ParentRepairHistory, ViewBuildStatus));
/////////////////////////////////////////////////////////////////////////
1:                                       SchemaConstants.DISTRIBUTED_KEYSPACE_NAME,
/////////////////////////////////////////////////////////////////////////
1:         String fmtQuery = String.format(query, SchemaConstants.DISTRIBUTED_KEYSPACE_NAME, PARENT_REPAIR_HISTORY, parent_id.toString());
1:         String fmtQuery = String.format(query, SchemaConstants.DISTRIBUTED_KEYSPACE_NAME, PARENT_REPAIR_HISTORY, Joiner.on("','").join(successfulRanges), parent_id.toString());
/////////////////////////////////////////////////////////////////////////
1:                 String fmtQry = String.format(query, SchemaConstants.DISTRIBUTED_KEYSPACE_NAME, REPAIR_HISTORY,
/////////////////////////////////////////////////////////////////////////
1:         String fmtQuery = String.format(query, SchemaConstants.DISTRIBUTED_KEYSPACE_NAME, REPAIR_HISTORY,
/////////////////////////////////////////////////////////////////////////
1:         String fmtQry = String.format(query, SchemaConstants.DISTRIBUTED_KEYSPACE_NAME, REPAIR_HISTORY,
1:                                       RepairState.FAILED.toString(),
1:                                       keyspaceName,
1:                                       cfname,
1:                                       id.toString());
1:         QueryProcessor.process(String.format(query, SchemaConstants.DISTRIBUTED_KEYSPACE_NAME, VIEW_BUILD_STATUS),
/////////////////////////////////////////////////////////////////////////
1:         QueryProcessor.process(String.format(query, SchemaConstants.DISTRIBUTED_KEYSPACE_NAME, VIEW_BUILD_STATUS),
/////////////////////////////////////////////////////////////////////////
1:             results = QueryProcessor.execute(String.format(query, SchemaConstants.DISTRIBUTED_KEYSPACE_NAME, VIEW_BUILD_STATUS),
/////////////////////////////////////////////////////////////////////////
1:         QueryProcessor.executeInternal(String.format(buildReq, SchemaConstants.DISTRIBUTED_KEYSPACE_NAME, VIEW_BUILD_STATUS), keyspaceName, viewName);
/////////////////////////////////////////////////////////////////////////
1:             FBUtilities.waitOnFuture(Keyspace.open(SchemaConstants.DISTRIBUTED_KEYSPACE_NAME).getColumnFamilyStore(table).forceFlush());
author:Dave Brosius
-------------------------------------------------------------------------------
commit:68d2526
/////////////////////////////////////////////////////////////////////////
1:         }
1:         catch (Exception e)
1:         {
author:Carl Yeksigian
-------------------------------------------------------------------------------
commit:21448c5
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collections;
1: import java.util.HashMap;
1: import com.google.common.collect.Lists;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.cql3.UntypedResultSet;
1: import org.apache.cassandra.db.Keyspace;
1: import static org.apache.cassandra.utils.ByteBufferUtil.bytes;
1: 
/////////////////////////////////////////////////////////////////////////
1:     public static final String VIEW_BUILD_STATUS = "view_build_status";
1: 
/////////////////////////////////////////////////////////////////////////
1:     private static final CFMetaData ViewBuildStatus =
1:     compile(VIEW_BUILD_STATUS,
1:             "Materialized View build status",
1:             "CREATE TABLE %s ("
1:                      + "keyspace_name text,"
1:                      + "view_name text,"
1:                      + "host_id uuid,"
1:                      + "status text,"
1:                      + "PRIMARY KEY ((keyspace_name, view_name), host_id))");
1: 
/////////////////////////////////////////////////////////////////////////
0:         return KeyspaceMetadata.create(NAME, KeyspaceParams.simple(3), Tables.of(RepairHistory, ParentRepairHistory, ViewBuildStatus));
/////////////////////////////////////////////////////////////////////////
1:     public static void startViewBuild(String keyspace, String view, UUID hostId)
1:     {
1:         String query = "INSERT INTO %s.%s (keyspace_name, view_name, host_id, status) VALUES (?, ?, ?, ?)";
0:         QueryProcessor.process(String.format(query, NAME, VIEW_BUILD_STATUS),
1:                                ConsistencyLevel.ONE,
1:                                Lists.newArrayList(bytes(keyspace),
1:                                                   bytes(view),
1:                                                   bytes(hostId),
1:                                                   bytes(BuildStatus.STARTED.toString())));
1:     }
1: 
1:     public static void successfulViewBuild(String keyspace, String view, UUID hostId)
1:     {
1:         String query = "UPDATE %s.%s SET status = ? WHERE keyspace_name = ? AND view_name = ? AND host_id = ?";
0:         QueryProcessor.process(String.format(query, NAME, VIEW_BUILD_STATUS),
1:                                ConsistencyLevel.ONE,
1:                                Lists.newArrayList(bytes(BuildStatus.SUCCESS.toString()),
1:                                                   bytes(keyspace),
1:                                                   bytes(view),
1:                                                   bytes(hostId)));
1:     }
1: 
1:     public static Map<UUID, String> viewStatus(String keyspace, String view)
1:     {
1:         String query = "SELECT host_id, status FROM %s.%s WHERE keyspace_name = ? AND view_name = ?";
1:         UntypedResultSet results;
1:         try
1:         {
0:             results = QueryProcessor.execute(String.format(query, NAME, VIEW_BUILD_STATUS),
1:                                              ConsistencyLevel.ONE,
1:                                              keyspace,
1:                                              view);
0:         } catch (Exception e) {
1:             return Collections.emptyMap();
1:         }
1: 
1: 
1:         Map<UUID, String> status = new HashMap<>();
1:         for (UntypedResultSet.Row row : results)
1:         {
1:             status.put(row.getUUID("host_id"), row.getString("status"));
1:         }
1:         return status;
1:     }
1: 
1:     public static void setViewRemoved(String keyspaceName, String viewName)
1:     {
1:         String buildReq = "DELETE FROM %s.%s WHERE keyspace_name = ? AND view_name = ?";
0:         QueryProcessor.executeInternal(String.format(buildReq, NAME, VIEW_BUILD_STATUS), keyspaceName, viewName);
1:         forceBlockingFlush(VIEW_BUILD_STATUS);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 valueList.add(bytes(v));
/////////////////////////////////////////////////////////////////////////
1:     public static void forceBlockingFlush(String table)
1:     {
0:         if (!Boolean.getBoolean("cassandra.unsafesystem"))
0:             FBUtilities.waitOnFuture(Keyspace.open(NAME).getColumnFamilyStore(table).forceFlush());
1:     }
1: 
1:     private enum BuildStatus
1:     {
1:         UNKNOWN, STARTED, SUCCESS
1:     }
author:Marcus Eriksson
-------------------------------------------------------------------------------
commit:b210bd2
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.repair.messages.RepairOption;
/////////////////////////////////////////////////////////////////////////
1:                      + "options map<text, text>,"
/////////////////////////////////////////////////////////////////////////
1:     public static void startParentRepair(UUID parent_id, String keyspaceName, String[] cfnames, RepairOption options)
1:         Collection<Range<Token>> ranges = options.getRanges();
1:         String query = "INSERT INTO %s.%s (parent_id, keyspace_name, columnfamily_names, requested_ranges, started_at,          options)"+
1:                                  " VALUES (%s,        '%s',          { '%s' },           { '%s' },          toTimestamp(now()), { %s })";
1:         String fmtQry = String.format(query,
0:                                       NAME,
1:                                       PARENT_REPAIR_HISTORY,
1:                                       parent_id.toString(),
1:                                       keyspaceName,
1:                                       Joiner.on("','").join(cfnames),
1:                                       Joiner.on("','").join(ranges),
1:                                       toCQLMap(options.asMap(), RepairOption.RANGES_KEY, RepairOption.COLUMNFAMILIES_KEY));
1:     private static String toCQLMap(Map<String, String> options, String ... ignore)
1:     {
1:         Set<String> toIgnore = Sets.newHashSet(ignore);
1:         StringBuilder map = new StringBuilder();
1:         boolean first = true;
1:         for (Map.Entry<String, String> entry : options.entrySet())
1:         {
1:             if (!toIgnore.contains(entry.getKey()))
1:             {
1:                 if (!first)
1:                     map.append(',');
1:                 first = false;
1:                 map.append(String.format("'%s': '%s'", entry.getKey(), entry.getValue()));
1:             }
1:         }
1:         return map.toString();
1:     }
1: 
commit:49c31d6
/////////////////////////////////////////////////////////////////////////
1: import java.nio.ByteBuffer;
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.ConsistencyLevel;
0: import org.apache.cassandra.utils.ByteBufferUtil;
/////////////////////////////////////////////////////////////////////////
0:         String fmtQry = String.format(query, NAME, PARENT_REPAIR_HISTORY, parent_id.toString(), keyspaceName, Joiner.on("','").join(cfnames), Joiner.on("','").join(ranges));
1:         processSilent(fmtQry);
/////////////////////////////////////////////////////////////////////////
1:         processSilent(fmtQuery, t.getMessage(), sw.toString());
1:         processSilent(fmtQuery);
/////////////////////////////////////////////////////////////////////////
1:             processSilent(fmtQry);
/////////////////////////////////////////////////////////////////////////
1:         processSilent(fmtQuery);
/////////////////////////////////////////////////////////////////////////
1:         processSilent(fmtQry, t.getMessage(), sw.toString());
1:     private static void processSilent(String fmtQry, String... values)
1:             List<ByteBuffer> valueList = new ArrayList<>();
1:             for (String v : values)
1:             {
0:                 valueList.add(ByteBufferUtil.bytes(v));
1:             }
1:             QueryProcessor.process(fmtQry, ConsistencyLevel.ONE, valueList);
commit:c5b0242
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.repair;
1: 
1: import java.io.PrintWriter;
1: import java.io.StringWriter;
1: import java.net.InetAddress;
0: import java.util.Arrays;
1: import java.util.Collection;
1: import java.util.List;
1: import java.util.Set;
1: import java.util.UUID;
1: 
1: import com.google.common.base.Joiner;
0: import com.google.common.collect.ImmutableMap;
1: import com.google.common.collect.Sets;
1: 
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: import org.apache.cassandra.config.CFMetaData;
0: import org.apache.cassandra.config.KSMetaData;
1: import org.apache.cassandra.cql3.QueryProcessor;
1: import org.apache.cassandra.dht.Range;
1: import org.apache.cassandra.dht.Token;
0: import org.apache.cassandra.locator.SimpleStrategy;
1: import org.apache.cassandra.utils.FBUtilities;
1: 
1: public final class SystemDistributedKeyspace
1: {
0:     private static Logger logger = LoggerFactory.getLogger(SystemDistributedKeyspace.class);
1: 
0:     public static final String NAME = "system_distributed";
1: 
1:     public static final String REPAIR_HISTORY = "repair_history";
1: 
1:     public static final String PARENT_REPAIR_HISTORY = "parent_repair_history";
1: 
1:     private static final CFMetaData RepairHistory =
1:         compile(REPAIR_HISTORY,
1:                 "Repair history",
1:                 "CREATE TABLE %s ("
1:                      + "keyspace_name text,"
1:                      + "columnfamily_name text,"
1:                      + "id timeuuid,"
1:                      + "parent_id timeuuid,"
1:                      + "range_begin text,"
1:                      + "range_end text,"
1:                      + "coordinator inet,"
1:                      + "participants set<inet>,"
1:                      + "exception_message text,"
1:                      + "exception_stacktrace text,"
1:                      + "status text,"
1:                      + "started_at timestamp,"
1:                      + "finished_at timestamp,"
1:                      + "PRIMARY KEY ((keyspace_name, columnfamily_name), id))");
1: 
1:     private static final CFMetaData ParentRepairHistory =
1:         compile(PARENT_REPAIR_HISTORY,
1:                 "Repair history",
1:                 "CREATE TABLE %s ("
1:                      + "parent_id timeuuid,"
1:                      + "keyspace_name text,"
1:                      + "columnfamily_names set<text>,"
1:                      + "started_at timestamp,"
1:                      + "finished_at timestamp,"
1:                      + "exception_message text,"
1:                      + "exception_stacktrace text,"
1:                      + "requested_ranges set<text>,"
1:                      + "successful_ranges set<text>,"
1:                      + "PRIMARY KEY (parent_id))");
1: 
1:     private static CFMetaData compile(String name, String description, String schema)
1:     {
0:         return CFMetaData.compile(String.format(schema, name), NAME)
1:                          .comment(description);
1:     }
1: 
0:     public static KSMetaData definition()
1:     {
0:         List<CFMetaData> tables = Arrays.asList(RepairHistory, ParentRepairHistory);
0:         return new KSMetaData(NAME, SimpleStrategy.class, ImmutableMap.of("replication_factor", "3"), true, tables);
1:     }
1: 
0:     public static void startParentRepair(UUID parent_id, String keyspaceName, String[] cfnames, Collection<Range<Token>> ranges)
1:     {
1: 
0:         String query = "INSERT INTO %s.%s (parent_id, keyspace_name, columnfamily_names, requested_ranges, started_at)"+
0:                                  " VALUES (%s,        '%s',          { '%s' },           { '%s' },          dateOf(now()))";
0:         String fmtQry = String.format(query, NAME, PARENT_REPAIR_HISTORY, parent_id.toString(), keyspaceName, Joiner.on("','").join(ranges), Joiner.on("','").join(cfnames));
0:         executeInternalSilent(fmtQry);
1:     }
1: 
1:     public static void failParentRepair(UUID parent_id, Throwable t)
1:     {
0:         String query = "UPDATE %s.%s SET finished_at = dateOf(now()), exception_message=?, exception_stacktrace=? WHERE parent_id=%s";
1: 
1:         StringWriter sw = new StringWriter();
1:         PrintWriter pw = new PrintWriter(sw);
1:         t.printStackTrace(pw);
0:         String fmtQuery = String.format(query, NAME, PARENT_REPAIR_HISTORY, parent_id.toString());
0:         executeInternalSilent(fmtQuery, t.getMessage(), sw.toString());
1:     }
1: 
1:     public static void successfulParentRepair(UUID parent_id, Collection<Range<Token>> successfulRanges)
1:     {
0:         String query = "UPDATE %s.%s SET finished_at = dateOf(now()), successful_ranges = {'%s'} WHERE parent_id=%s";
0:         String fmtQuery = String.format(query, NAME, PARENT_REPAIR_HISTORY, Joiner.on("','").join(successfulRanges), parent_id.toString());
0:         executeInternalSilent(fmtQuery);
1:     }
1: 
0:     public static void startRepairs(UUID id, UUID parent_id, String keyspaceName, String[] cfnames, Range<Token> range, Iterable<InetAddress> endpoints)
1:     {
1:         String coordinator = FBUtilities.getBroadcastAddress().getHostAddress();
1:         Set<String> participants = Sets.newHashSet(coordinator);
1: 
1:         for (InetAddress endpoint : endpoints)
1:             participants.add(endpoint.getHostAddress());
1: 
1:         String query =
1:                 "INSERT INTO %s.%s (keyspace_name, columnfamily_name, id, parent_id, range_begin, range_end, coordinator, participants, status, started_at) " +
0:                         "VALUES (   '%s',          '%s',              %s, %s,        '%s',        '%s',      '%s',        { '%s' },     '%s',   dateOf(now()))";
1: 
1:         for (String cfname : cfnames)
1:         {
0:             String fmtQry = String.format(query, NAME, REPAIR_HISTORY,
1:                                           keyspaceName,
1:                                           cfname,
1:                                           id.toString(),
1:                                           parent_id.toString(),
1:                                           range.left.toString(),
1:                                           range.right.toString(),
1:                                           coordinator,
1:                                           Joiner.on("', '").join(participants),
1:                     RepairState.STARTED.toString());
0:             executeInternalSilent(fmtQry);
1:         }
1:     }
1: 
1:     public static void failRepairs(UUID id, String keyspaceName, String[] cfnames, Throwable t)
1:     {
1:         for (String cfname : cfnames)
1:             failedRepairJob(id, keyspaceName, cfname, t);
1:     }
1: 
1:     public static void successfulRepairJob(UUID id, String keyspaceName, String cfname)
1:     {
0:         String query = "UPDATE %s.%s SET status = '%s', finished_at = dateOf(now()) WHERE keyspace_name = '%s' AND columnfamily_name = '%s' AND id = %s";
0:         String fmtQuery = String.format(query, NAME, REPAIR_HISTORY,
1:                                         RepairState.SUCCESS.toString(),
1:                                         keyspaceName,
1:                                         cfname,
1:                                         id.toString());
0:         executeInternalSilent(fmtQuery);
1:     }
1: 
1:     public static void failedRepairJob(UUID id, String keyspaceName, String cfname, Throwable t)
1:     {
0:         String query = "UPDATE %s.%s SET status = '%s', finished_at = dateOf(now()), exception_message=?, exception_stacktrace=? WHERE keyspace_name = '%s' AND columnfamily_name = '%s' AND id = %s";
1:         StringWriter sw = new StringWriter();
1:         PrintWriter pw = new PrintWriter(sw);
1:         t.printStackTrace(pw);
0:         String fmtQry = String.format(query, NAME, REPAIR_HISTORY,
0:                 RepairState.FAILED.toString(),
1:                 keyspaceName,
1:                 cfname,
1:                 id.toString());
0:         executeInternalSilent(fmtQry, t.getMessage(), sw.toString());
1:     }
1: 
0:     private static void executeInternalSilent(String fmtQry, Object ... values)
1:     {
1:         try
1:         {
0:             QueryProcessor.executeInternal(fmtQry, values);
1:         }
1:         catch (Throwable t)
1:         {
1:             logger.error("Error executing query "+fmtQry, t);
1:         }
1:     }
1: 
1: 
1:     private enum RepairState
1:     {
1:         STARTED, SUCCESS, FAILED
1:     }
1: }
author:Marcus Olsson
-------------------------------------------------------------------------------
commit:0dd50a6
/////////////////////////////////////////////////////////////////////////
1:     public static void startRepairs(UUID id, UUID parent_id, String keyspaceName, String[] cfnames, Collection<Range<Token>> ranges, Iterable<InetAddress> endpoints)
/////////////////////////////////////////////////////////////////////////
1:             for (Range<Token> range : ranges)
1:             {
0:                 String fmtQry = String.format(query, NAME, REPAIR_HISTORY,
0:                                               keyspaceName,
0:                                               cfname,
0:                                               id.toString(),
0:                                               parent_id.toString(),
0:                                               range.left.toString(),
0:                                               range.right.toString(),
0:                                               coordinator,
0:                                               Joiner.on("', '").join(participants),
0:                                               RepairState.STARTED.toString());
0:                 processSilent(fmtQry);
1:             }
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:a89597d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.schema.KeyspaceMetadata;
/////////////////////////////////////////////////////////////////////////
1:     public static KeyspaceMetadata metadata()
0:         return KeyspaceMetadata.create(NAME, KeyspaceParams.simple(3), Tables.of(RepairHistory, ParentRepairHistory));
commit:31e3f61
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.schema.KeyspaceParams;
1:     private SystemDistributedKeyspace()
1:     {
1:     }
0: 
1:     private static final Logger logger = LoggerFactory.getLogger(SystemDistributedKeyspace.class);
/////////////////////////////////////////////////////////////////////////
0:         return KSMetaData.create(NAME, KeyspaceParams.simple(3), Tables.of(RepairHistory, ParentRepairHistory));
commit:6e1033b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.schema.Tables;
/////////////////////////////////////////////////////////////////////////
0:         Tables tables = Tables.of(RepairHistory, ParentRepairHistory);
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:c08aaab
/////////////////////////////////////////////////////////////////////////
0:                                  " VALUES (%s,        '%s',          { '%s' },           { '%s' },          toTimestamp(now()))";
1:         String query = "UPDATE %s.%s SET finished_at = toTimestamp(now()), exception_message=?, exception_stacktrace=? WHERE parent_id=%s";
/////////////////////////////////////////////////////////////////////////
1:         String query = "UPDATE %s.%s SET finished_at = toTimestamp(now()), successful_ranges = {'%s'} WHERE parent_id=%s";
/////////////////////////////////////////////////////////////////////////
1:                         "VALUES (   '%s',          '%s',              %s, %s,        '%s',        '%s',      '%s',        { '%s' },     '%s',   toTimestamp(now()))";
/////////////////////////////////////////////////////////////////////////
1:         String query = "UPDATE %s.%s SET status = '%s', finished_at = toTimestamp(now()) WHERE keyspace_name = '%s' AND columnfamily_name = '%s' AND id = %s";
/////////////////////////////////////////////////////////////////////////
1:         String query = "UPDATE %s.%s SET status = '%s', finished_at = toTimestamp(now()), exception_message=?, exception_stacktrace=? WHERE keyspace_name = '%s' AND columnfamily_name = '%s' AND id = %s";
============================================================================