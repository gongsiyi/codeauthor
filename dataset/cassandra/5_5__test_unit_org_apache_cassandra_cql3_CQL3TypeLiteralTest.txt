1:e94032a: /*
1:e94032a:  * Licensed to the Apache Software Foundation (ASF) under one
1:e94032a:  * or more contributor license agreements.  See the NOTICE file
1:e94032a:  * distributed with this work for additional information
1:e94032a:  * regarding copyright ownership.  The ASF licenses this file
1:e94032a:  * to you under the Apache License, Version 2.0 (the
1:e94032a:  * "License"); you may not use this file except in compliance
1:e94032a:  * with the License.  You may obtain a copy of the License at
1:e94032a:  *
1:e94032a:  *     http://www.apache.org/licenses/LICENSE-2.0
1:e94032a:  *
1:e94032a:  * Unless required by applicable law or agreed to in writing, software
1:e94032a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:e94032a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:e94032a:  * See the License for the specific language governing permissions and
1:e94032a:  * limitations under the License.
1:e94032a:  */
3:e94032a: 
1:e94032a: package org.apache.cassandra.cql3;
1:e94032a: 
1:e94032a: import java.math.BigDecimal;
1:e94032a: import java.math.BigInteger;
1:e94032a: import java.net.InetAddress;
1:e94032a: import java.net.UnknownHostException;
1:e94032a: import java.nio.ByteBuffer;
1:c6ed2e0: import java.util.*;
1:e94032a: import java.util.concurrent.ThreadLocalRandom;
1:e94032a: import java.util.regex.Pattern;
1:e94032a: 
1:e94032a: import org.junit.Test;
1:e94032a: 
1:e94032a: import org.apache.cassandra.db.marshal.*;
1:e94032a: import org.apache.cassandra.serializers.*;
1:e0adc16: import org.apache.cassandra.transport.ProtocolVersion;
1:e94032a: import org.apache.cassandra.utils.ByteBufferUtil;
1:e94032a: import org.apache.cassandra.utils.UUIDGen;
1:e94032a: 
1:e94032a: import static org.junit.Assert.assertEquals;
1:e94032a: 
1:e94032a: /**
1:e94032a:  * Test functionality to re-create a CQL literal from its serialized representation.
1:e94032a:  * This test uses some randomness to generate the values and nested structures (collections,tuples,UDTs).
1:e94032a:  */
1:e94032a: public class CQL3TypeLiteralTest
4:e94032a: {
1:e94032a:     private static final Pattern QUOTE = Pattern.compile("'");
1:e94032a: 
1:e94032a:     /**
1:e94032a:      * Container holding the expected CQL literal for a type and serialized value.
1:e94032a:      * The CQL literal is generated independently from the code in {@link CQL3Type}.
1:e94032a:      */
1:e94032a:     static class Value
1:e94032a:     {
1:e94032a:         final String expected;
1:e94032a:         final CQL3Type cql3Type;
1:e94032a:         final ByteBuffer value;
1:e94032a: 
1:e94032a:         Value(String expected, CQL3Type cql3Type, ByteBuffer value)
1:e94032a:         {
1:e94032a:             this.expected = expected;
1:e94032a:             this.cql3Type = cql3Type;
1:e94032a:             this.value = value;
4:e94032a:         }
1:e94032a:     }
1:e94032a: 
1:e94032a:     static final Map<CQL3Type.Native, List<Value>> nativeTypeValues = new EnumMap<>(CQL3Type.Native.class);
1:e94032a: 
1:e94032a:     static void addNativeValue(String expected, CQL3Type.Native cql3Type, ByteBuffer value)
1:e94032a:     {
1:e94032a:         List<Value> l = nativeTypeValues.get(cql3Type);
1:e94032a:         if (l == null)
1:e94032a:             nativeTypeValues.put(cql3Type, l = new ArrayList<>());
1:e94032a:         l.add(new Value(expected, cql3Type, value));
1:e94032a:     }
1:e94032a: 
1:e94032a:     static
1:e94032a:     {
1:e94032a:         // Add some (random) values for each native type.
1:e94032a:         // Also adds null values and empty values, if the type allows this.
1:e94032a: 
1:e94032a:         for (int i = 0; i < 20; i++)
1:e94032a:         {
1:e94032a:             String v = randString(true);
1:e94032a:             addNativeValue(quote(v), CQL3Type.Native.ASCII, AsciiSerializer.instance.serialize(v));
1:e94032a:         }
1:e94032a:         addNativeValue("''", CQL3Type.Native.ASCII, AsciiSerializer.instance.serialize(""));
1:e94032a:         addNativeValue("''", CQL3Type.Native.ASCII, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:e94032a:         addNativeValue("null", CQL3Type.Native.ASCII, null);
1:e94032a: 
1:e94032a:         for (int i = 0; i < 20; i++)
1:e94032a:         {
1:e94032a:             String v = randString(false);
1:e94032a:             addNativeValue(quote(v), CQL3Type.Native.TEXT, UTF8Serializer.instance.serialize(v));
1:e94032a:         }
1:e94032a:         addNativeValue("''", CQL3Type.Native.TEXT, UTF8Serializer.instance.serialize(""));
1:e94032a:         addNativeValue("''", CQL3Type.Native.TEXT, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:e94032a:         addNativeValue("null", CQL3Type.Native.TEXT, null);
1:e94032a: 
1:e94032a:         for (int i = 0; i < 20; i++)
1:e94032a:         {
1:e94032a:             String v = randString(false);
1:e94032a:             addNativeValue(quote(v), CQL3Type.Native.VARCHAR, UTF8Serializer.instance.serialize(v));
1:e94032a:         }
1:e94032a:         addNativeValue("''", CQL3Type.Native.VARCHAR, UTF8Serializer.instance.serialize(""));
1:e94032a:         addNativeValue("''", CQL3Type.Native.VARCHAR, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:e94032a:         addNativeValue("null", CQL3Type.Native.VARCHAR, null);
1:e94032a: 
1:e94032a:         addNativeValue("0", CQL3Type.Native.BIGINT, LongType.instance.decompose(0L));
1:e94032a:         for (int i = 0; i < 20; i++)
1:e94032a:         {
1:e94032a:             long v = randLong();
1:e94032a:             addNativeValue(Long.toString(v), CQL3Type.Native.BIGINT, LongType.instance.decompose(v));
1:e94032a:         }
1:e94032a:         addNativeValue("null", CQL3Type.Native.BIGINT, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:e94032a:         addNativeValue("null", CQL3Type.Native.BIGINT, null);
1:e94032a: 
1:e94032a:         addNativeValue("0", CQL3Type.Native.COUNTER, LongType.instance.decompose(0L));
1:e94032a:         for (int i = 0; i < 20; i++)
1:e94032a:         {
1:e94032a:             long v = randLong();
1:e94032a:             addNativeValue(Long.toString(v), CQL3Type.Native.COUNTER, LongType.instance.decompose(v));
1:e94032a:         }
1:e94032a:         addNativeValue("null", CQL3Type.Native.COUNTER, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:e94032a:         addNativeValue("null", CQL3Type.Native.COUNTER, null);
1:e94032a: 
1:e94032a:         addNativeValue("0", CQL3Type.Native.INT, Int32Type.instance.decompose(0));
1:e94032a:         for (int i = 0; i < 20; i++)
1:e94032a:         {
1:e94032a:             int v = randInt();
1:e94032a:             addNativeValue(Integer.toString(v), CQL3Type.Native.INT, Int32Type.instance.decompose(v));
1:e94032a:         }
1:e94032a:         addNativeValue("null", CQL3Type.Native.INT, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:e94032a:         addNativeValue("null", CQL3Type.Native.INT, null);
1:e94032a: 
1:e94032a:         addNativeValue("0", CQL3Type.Native.SMALLINT, ShortType.instance.decompose((short) 0));
1:e94032a:         for (int i = 0; i < 20; i++)
1:e94032a:         {
1:e94032a:             short v = randShort();
1:e94032a:             addNativeValue(Short.toString(v), CQL3Type.Native.SMALLINT, ShortType.instance.decompose(v));
1:e94032a:         }
1:e94032a:         addNativeValue("null", CQL3Type.Native.SMALLINT, null);
1:e94032a: 
1:e94032a:         addNativeValue("0", CQL3Type.Native.TINYINT, ByteType.instance.decompose((byte) 0));
1:e94032a:         for (int i = 0; i < 20; i++)
1:e94032a:         {
1:e94032a:             byte v = randByte();
1:e94032a:             addNativeValue(Short.toString(v), CQL3Type.Native.TINYINT, ByteType.instance.decompose(v));
1:e94032a:         }
1:e94032a:         addNativeValue("null", CQL3Type.Native.TINYINT, null);
1:e94032a: 
1:e94032a:         addNativeValue("0.0", CQL3Type.Native.FLOAT, FloatType.instance.decompose((float) 0));
1:e94032a:         for (int i = 0; i < 20; i++)
1:e94032a:         {
1:e94032a:             float v = randFloat();
1:e94032a:             addNativeValue(Float.toString(v), CQL3Type.Native.FLOAT, FloatType.instance.decompose(v));
1:e94032a:         }
1:e94032a:         addNativeValue("NaN", CQL3Type.Native.FLOAT, FloatType.instance.decompose(Float.NaN));
1:e94032a:         addNativeValue("null", CQL3Type.Native.FLOAT, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:e94032a:         addNativeValue("null", CQL3Type.Native.FLOAT, null);
1:e94032a: 
1:e94032a:         addNativeValue("0.0", CQL3Type.Native.DOUBLE, DoubleType.instance.decompose((double) 0));
1:e94032a:         for (int i = 0; i < 20; i++)
1:e94032a:         {
1:e94032a:             double v = randDouble();
1:e94032a:             addNativeValue(Double.toString(v), CQL3Type.Native.DOUBLE, DoubleType.instance.decompose(v));
1:e94032a:         }
1:e94032a:         addNativeValue("NaN", CQL3Type.Native.DOUBLE, DoubleType.instance.decompose(Double.NaN));
1:e94032a:         addNativeValue("null", CQL3Type.Native.DOUBLE, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:e94032a:         addNativeValue("null", CQL3Type.Native.DOUBLE, null);
1:e94032a: 
1:e94032a:         addNativeValue("0", CQL3Type.Native.DECIMAL, DecimalType.instance.decompose(BigDecimal.ZERO));
1:e94032a:         for (int i = 0; i < 20; i++)
1:e94032a:         {
1:e94032a:             BigDecimal v = BigDecimal.valueOf(randDouble());
1:e94032a:             addNativeValue(v.toString(), CQL3Type.Native.DECIMAL, DecimalType.instance.decompose(v));
1:e94032a:         }
1:e94032a:         addNativeValue("null", CQL3Type.Native.DECIMAL, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:e94032a:         addNativeValue("null", CQL3Type.Native.DECIMAL, null);
1:e94032a: 
1:e94032a:         addNativeValue("0", CQL3Type.Native.VARINT, IntegerType.instance.decompose(BigInteger.ZERO));
1:e94032a:         for (int i = 0; i < 20; i++)
1:e94032a:         {
1:e94032a:             BigInteger v = BigInteger.valueOf(randLong());
1:e94032a:             addNativeValue(v.toString(), CQL3Type.Native.VARINT, IntegerType.instance.decompose(v));
1:e94032a:         }
1:e94032a:         addNativeValue("null", CQL3Type.Native.VARINT, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:e94032a:         addNativeValue("null", CQL3Type.Native.VARINT, null);
1:e94032a: 
1:e94032a:         // boolean doesn't have that many possible values...
1:e94032a:         addNativeValue("false", CQL3Type.Native.BOOLEAN, BooleanType.instance.decompose(false));
1:e94032a:         addNativeValue("true", CQL3Type.Native.BOOLEAN, BooleanType.instance.decompose(true));
1:e94032a:         addNativeValue("null", CQL3Type.Native.BOOLEAN, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:e94032a:         addNativeValue("null", CQL3Type.Native.BOOLEAN, null);
1:e94032a: 
1:e94032a:         // (mostly generates date values with surreal values like in year 14273)
1:e94032a:         for (int i = 0; i < 20; i++)
1:e94032a:         {
1:e94032a:             int v = randInt();
1:e94032a:             addNativeValue(SimpleDateSerializer.instance.toString(v), CQL3Type.Native.DATE, SimpleDateSerializer.instance.serialize(v));
1:e94032a:         }
1:e94032a:         addNativeValue("null", CQL3Type.Native.DATE, null);
1:e94032a: 
1:e94032a:         for (int i = 0; i < 100; i++)
1:e94032a:         {
1:e94032a:             long v = randLong(24L * 60 * 60 * 1000 * 1000 * 1000);
1:e94032a:             addNativeValue(TimeSerializer.instance.toString(v), CQL3Type.Native.TIME, TimeSerializer.instance.serialize(v));
1:e94032a:         }
1:e94032a:         addNativeValue("null", CQL3Type.Native.TIME, null);
1:e94032a: 
1:ecf05b8:         for (int i = 0; i < 100; i++)
1:ecf05b8:         {
1:ecf05b8:             Duration duration = Duration.newInstance(Math.abs(randInt()), Math.abs(randInt()), Math.abs(randLong()));
1:ecf05b8:             addNativeValue(DurationSerializer.instance.toString(duration), CQL3Type.Native.DURATION, DurationSerializer.instance.serialize(duration));
1:ecf05b8:         }
1:ecf05b8:         addNativeValue("null", CQL3Type.Native.DURATION, null);
1:ecf05b8: 
1:e94032a:         // (mostly generates timestamp values with surreal values like in year 14273)
1:e94032a:         for (int i = 0; i < 20; i++)
1:e94032a:         {
1:e94032a:             long v = randLong();
1:e94032a:             addNativeValue(TimestampSerializer.instance.toStringUTC(new Date(v)), CQL3Type.Native.TIMESTAMP, TimestampType.instance.fromString(Long.toString(v)));
1:e94032a:         }
1:e94032a:         addNativeValue("null", CQL3Type.Native.TIMESTAMP, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:e94032a:         addNativeValue("null", CQL3Type.Native.TIMESTAMP, null);
1:e94032a: 
1:e94032a:         for (int i = 0; i < 20; i++)
1:e94032a:         {
1:e94032a:             UUID v = UUIDGen.getTimeUUID(randLong(System.currentTimeMillis()));
1:e94032a:             addNativeValue(v.toString(), CQL3Type.Native.TIMEUUID, TimeUUIDType.instance.decompose(v));
1:e94032a:         }
1:e94032a:         addNativeValue("null", CQL3Type.Native.TIMEUUID, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:e94032a:         addNativeValue("null", CQL3Type.Native.TIMEUUID, null);
1:e94032a: 
1:e94032a:         for (int i = 0; i < 20; i++)
1:e94032a:         {
1:e94032a:             UUID v = UUID.randomUUID();
1:e94032a:             addNativeValue(v.toString(), CQL3Type.Native.UUID, UUIDType.instance.decompose(v));
1:e94032a:         }
1:e94032a:         addNativeValue("null", CQL3Type.Native.UUID, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:e94032a:         addNativeValue("null", CQL3Type.Native.UUID, null);
1:e94032a: 
1:e94032a:         for (int i = 0; i < 20; i++)
1:e94032a:         {
1:e94032a:             ByteBuffer v = randBytes();
1:e94032a:             addNativeValue("0x" + BytesSerializer.instance.toString(v), CQL3Type.Native.BLOB, BytesType.instance.decompose(v));
1:e94032a:         }
1:e94032a:         addNativeValue("0x", CQL3Type.Native.BLOB, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:e94032a:         addNativeValue("null", CQL3Type.Native.BLOB, null);
1:e94032a: 
1:e94032a:         for (int i = 0; i < 20; i++)
1:e94032a:         {
1:e94032a:             InetAddress v;
1:e94032a:             try
1:e94032a:             {
1:e94032a:                 v = InetAddress.getByAddress(new byte[]{ randByte(), randByte(), randByte(), randByte() });
1:e94032a:             }
1:e94032a:             catch (UnknownHostException e)
1:e94032a:             {
1:e94032a:                 throw new RuntimeException(e);
1:e94032a:             }
1:e94032a:             addNativeValue(v.getHostAddress(), CQL3Type.Native.INET, InetAddressSerializer.instance.serialize(v));
1:e94032a:         }
1:e94032a:         addNativeValue("null", CQL3Type.Native.INET, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:e94032a:         addNativeValue("null", CQL3Type.Native.INET, null);
1:e94032a:     }
1:e94032a: 
1:e94032a:     @Test
1:e94032a:     public void testNative()
1:e94032a:     {
1:e94032a:         // test each native type against each supported protocol version (although it doesn't make sense to
1:e94032a:         // iterate through all protocol versions as of C* 3.0).
1:e94032a: 
1:e0adc16:         for (ProtocolVersion version : ProtocolVersion.SUPPORTED)
1:e94032a:         {
1:e94032a:             for (Map.Entry<CQL3Type.Native, List<Value>> entry : nativeTypeValues.entrySet())
1:e94032a:             {
1:e94032a:                 for (Value value : entry.getValue())
1:e94032a:                 {
13:e94032a:                     compareCqlLiteral(version, value);
1:e94032a:                 }
1:e94032a:             }
1:e94032a:         }
1:e94032a:     }
1:e94032a: 
1:e94032a:     @Test
1:e94032a:     public void testCollectionWithNatives()
1:e94032a:     {
1:e94032a:         // test 100 collections with varying element/key/value types against each supported protocol version,
1:e94032a:         // type of collection is randomly chosen
1:e94032a: 
1:e0adc16:         for (ProtocolVersion version : ProtocolVersion.SUPPORTED)
1:e94032a:         {
1:e94032a:             for (int n = 0; n < 100; n++)
1:e94032a:             {
1:e94032a:                 Value value = generateCollectionValue(version, randomCollectionType(0), true);
1:e94032a:                 compareCqlLiteral(version, value);
1:e94032a:             }
1:e94032a:         }
1:e94032a:     }
1:e94032a: 
1:e94032a:     @Test
1:e94032a:     public void testCollectionNullAndEmpty()
1:e94032a:     {
1:c6ed2e0:         // An empty collection is one with a size of 0 (note that rely on the fact that protocol version < 3 are not
1:c6ed2e0:         // supported anymore and so the size of a collection is always on 4 bytes).
1:c6ed2e0:         ByteBuffer emptyCollection = ByteBufferUtil.bytes(0);
1:c6ed2e0: 
1:e0adc16:         for (ProtocolVersion version : ProtocolVersion.SUPPORTED)
1:e94032a:         {
1:c6ed2e0:             for (boolean frozen : Arrays.asList(true, false))
1:c6ed2e0:             {
1:c6ed2e0:                 // empty
1:c6ed2e0:                 Value value = new Value("[]", ListType.getInstance(UTF8Type.instance, frozen).asCQL3Type(), emptyCollection);
1:c6ed2e0:                 compareCqlLiteral(version, value);
1:c6ed2e0:                 value = new Value("{}", SetType.getInstance(UTF8Type.instance, frozen).asCQL3Type(), emptyCollection);
1:c6ed2e0:                 compareCqlLiteral(version, value);
1:c6ed2e0:                 value = new Value("{}", MapType.getInstance(UTF8Type.instance, UTF8Type.instance, frozen).asCQL3Type(), emptyCollection);
1:c6ed2e0:                 compareCqlLiteral(version, value);
1:e94032a: 
1:c6ed2e0:                 // null
1:c6ed2e0:                 value = new Value("null", ListType.getInstance(UTF8Type.instance, frozen).asCQL3Type(), null);
1:c6ed2e0:                 compareCqlLiteral(version, value);
1:c6ed2e0:                 value = new Value("null", SetType.getInstance(UTF8Type.instance, frozen).asCQL3Type(), null);
1:c6ed2e0:                 compareCqlLiteral(version, value);
1:c6ed2e0:                 value = new Value("null", MapType.getInstance(UTF8Type.instance, UTF8Type.instance, frozen).asCQL3Type(), null);
1:c6ed2e0:                 compareCqlLiteral(version, value);
1:c6ed2e0:             }
1:e94032a:         }
1:e94032a:     }
1:e94032a: 
1:e94032a:     @Test
1:e94032a:     public void testTupleWithNatives()
1:e94032a:     {
1:e94032a:         // test 100 tuples with varying element/key/value types against each supported protocol version
1:e94032a: 
1:e0adc16:         for (ProtocolVersion version : ProtocolVersion.SUPPORTED)
1:e94032a:         {
1:e94032a:             for (int n = 0; n < 100; n++)
1:e94032a:             {
1:e94032a:                 Value value = generateTupleValue(version, randomTupleType(0), true);
1:e94032a:                 compareCqlLiteral(version, value);
1:e94032a:             }
1:e94032a:         }
1:e94032a:     }
1:e94032a: 
1:e94032a:     @Test
1:e94032a:     public void testUserDefinedWithNatives()
1:e94032a:     {
1:e94032a:         // test 100 UDTs with varying element/key/value types against each supported protocol version
1:e94032a: 
1:e0adc16:         for (ProtocolVersion version : ProtocolVersion.SUPPORTED)
1:e94032a:         {
1:e94032a:             for (int n = 0; n < 100; n++)
1:e94032a:             {
1:e94032a:                 Value value = generateUserDefinedValue(version, randomUserType(0), true);
1:e94032a:                 compareCqlLiteral(version, value);
1:e94032a:             }
1:e94032a:         }
1:e94032a:     }
1:e94032a: 
1:e94032a:     @Test
1:e94032a:     public void testNested()
1:e94032a:     {
1:e94032a:         // This is the "nice" part of this unit test - it tests (probably) nested type structures
1:e94032a:         // like 'tuple<map, list<user>, tuple, user>' or 'map<tuple<int, text>, set<inet>>' with
1:e94032a:         // random types  against each supported protocol version.
1:e94032a: 
1:e0adc16:         for (ProtocolVersion version : ProtocolVersion.SUPPORTED)
1:e94032a:         {
1:e94032a:             for (int n = 0; n < 100; n++)
1:e94032a:             {
1:e94032a:                 Value value = randomNested(version);
1:e94032a:                 compareCqlLiteral(version, value);
1:e94032a:             }
1:e94032a:         }
1:e94032a:     }
1:e94032a: 
1:e0adc16:     static void compareCqlLiteral(ProtocolVersion version, Value value)
1:e94032a:     {
1:e94032a:         ByteBuffer buffer = value.value != null ? value.value.duplicate() : null;
1:e94032a:         String msg = "Failed to get expected value for type " + value.cql3Type + " / " + value.cql3Type.getType() + " with protocol-version " + version + " expected:\"" + value.expected + '"';
1:e94032a:         try
1:e94032a:         {
1:e94032a:             assertEquals(msg,
1:e94032a:                          value.expected,
1:c6ed2e0:                          value.cql3Type.toCQLLiteral(buffer, version));
1:e94032a:         }
1:e94032a:         catch (RuntimeException e)
1:e94032a:         {
1:e94032a:             throw new RuntimeException(msg, e);
1:e94032a:         }
1:e94032a:     }
1:e94032a: 
1:e0adc16:     static Value randomNested(ProtocolVersion version)
1:e94032a:     {
1:e94032a:         AbstractType type = randomNestedType(2);
1:e94032a: 
1:e94032a:         return generateAnyValue(version, type.asCQL3Type());
1:e94032a:     }
1:e94032a: 
1:e94032a:     /**
1:e94032a:      * Generates type of randomly nested type structures.
1:e94032a:      */
1:e94032a:     static AbstractType randomNestedType(int level)
1:e94032a:     {
1:e94032a:         if (level == 0)
1:e94032a:             return randomNativeType();
1:e94032a:         switch (randInt(level == 2 ? 3 : 4))
1:e94032a:         {
1:e94032a:             case 0:
1:e94032a:                 return randomCollectionType(level - 1);
1:e94032a:             case 1:
1:e94032a:                 return randomTupleType(level - 1);
1:e94032a:             case 2:
1:e94032a:                 return randomUserType(level - 1);
1:e94032a:             case 3:
1:e94032a:                 return randomNativeType();
1:e94032a:         }
1:e94032a:         throw new AssertionError();
1:e94032a:     }
1:e94032a: 
1:e0adc16:     static Value generateCollectionValue(ProtocolVersion version, CollectionType collectionType, boolean allowNull)
1:e94032a:     {
1:e94032a:         StringBuilder expected = new StringBuilder();
1:e94032a:         ByteBuffer buffer;
1:e94032a: 
1:e94032a:         if (allowNull && randBool(0.05d))
1:e94032a:         {
1:c6ed2e0:             expected.append("null");
1:e94032a:             buffer = null;
1:e94032a:         }
2:e94032a:         else
1:e94032a:         {
1:e94032a:             int size = randInt(20);
1:e94032a: 
1:e94032a:             CQL3Type elements;
1:e94032a:             CQL3Type values = null;
1:e94032a:             char bracketOpen;
1:e94032a:             char bracketClose;
2:e94032a:             switch (collectionType.kind)
1:e94032a:             {
2:e94032a:                 case LIST:
1:e94032a:                     elements = ((ListType) collectionType).getElementsType().asCQL3Type();
1:e94032a:                     bracketOpen = '[';
1:e94032a:                     bracketClose = ']';
3:e94032a:                     break;
2:e94032a:                 case SET:
1:e94032a:                     elements = ((SetType) collectionType).getElementsType().asCQL3Type();
1:e94032a:                     bracketOpen = '{';
1:e94032a:                     bracketClose = '}';
1:e94032a:                     break;
2:e94032a:                 case MAP:
1:e94032a:                     elements = ((MapType) collectionType).getKeysType().asCQL3Type();
1:e94032a:                     values = ((MapType) collectionType).getValuesType().asCQL3Type();
1:e94032a:                     bracketOpen = '{';
1:e94032a:                     bracketClose = '}';
1:e94032a:                     break;
1:e94032a:                 default:
1:e94032a:                     throw new AssertionError();
1:e94032a:             }
1:e94032a: 
1:e94032a:             expected.append(bracketOpen);
1:e94032a:             Collection<ByteBuffer> buffers = new ArrayList<>();
1:e94032a:             Set<ByteBuffer> added = new HashSet<>();
1:e94032a:             for (int i = 0; i < size; i++)
1:e94032a:             {
1:e94032a:                 Value el = generateAnyValue(version, elements);
1:e94032a:                 if (!added.add(el.value))
1:e94032a:                     continue;
1:e94032a: 
1:e94032a:                 buffers.add(el.value.duplicate());
1:e94032a:                 if (expected.length() > 1)
1:e94032a:                     expected.append(", ");
1:c6ed2e0:                 expected.append(el.cql3Type.toCQLLiteral(el.value, version));
1:e94032a: 
1:e94032a:                 if (collectionType.kind == CollectionType.Kind.MAP)
1:e94032a:                 {
1:e94032a:                     // add map value
1:e94032a:                     el = generateAnyValue(version, values);
1:e94032a:                     buffers.add(el.value.duplicate());
1:e94032a:                     expected.append(": ");
1:c6ed2e0:                     expected.append(el.cql3Type.toCQLLiteral(el.value, version));
1:e94032a:                 }
1:e94032a:             }
1:e94032a:             expected.append(bracketClose);
1:e94032a:             buffer = CollectionSerializer.pack(buffers, added.size(), version);
1:e94032a:         }
1:e94032a: 
1:e94032a:         return new Value(expected.toString(), collectionType.asCQL3Type(), buffer);
1:e94032a:     }
1:e94032a: 
1:e94032a:     /**
1:e94032a:      * Generates a value for any type or type structure.
1:e94032a:      */
1:e0adc16:     static Value generateAnyValue(ProtocolVersion version, CQL3Type type)
1:e94032a:     {
1:e94032a:         if (type instanceof CQL3Type.Native)
1:e94032a:             return generateNativeValue(type, false);
1:e94032a:         if (type instanceof CQL3Type.Tuple)
1:e94032a:             return generateTupleValue(version, (TupleType) type.getType(), false);
1:e94032a:         if (type instanceof CQL3Type.UserDefined)
1:e94032a:             return generateUserDefinedValue(version, (UserType) type.getType(), false);
1:e94032a:         if (type instanceof CQL3Type.Collection)
1:e94032a:             return generateCollectionValue(version, (CollectionType) type.getType(), false);
1:e94032a:         throw new AssertionError();
1:e94032a:     }
1:e94032a: 
1:e0adc16:     static Value generateTupleValue(ProtocolVersion version, TupleType tupleType, boolean allowNull)
1:e94032a:     {
1:e94032a:         StringBuilder expected = new StringBuilder();
1:e94032a:         ByteBuffer buffer;
1:e94032a: 
1:e94032a:         if (allowNull && randBool(0.05d))
1:e94032a:         {
2:e94032a:             // generate 'null' collection
2:e94032a:             expected.append("null");
1:e94032a:             buffer = null;
1:e94032a:         }
1:e94032a:         else
1:e94032a:         {
1:e94032a:             expected.append('(');
1:e94032a: 
1:e94032a:             // # of fields in this value
1:e94032a:             int fields = tupleType.size();
1:e94032a:             if (randBool(0.2d))
1:e94032a:                 fields = randInt(fields);
1:e94032a: 
1:e94032a:             ByteBuffer[] buffers = new ByteBuffer[fields];
1:e94032a:             for (int i = 0; i < fields; i++)
1:e94032a:             {
1:e94032a:                 AbstractType<?> fieldType = tupleType.type(i);
1:e94032a: 
1:e94032a:                 if (i > 0)
1:e94032a:                     expected.append(", ");
1:e94032a: 
1:e94032a:                 if (allowNull && randBool(.1))
1:e94032a:                 {
1:e94032a:                     expected.append("null");
1:e94032a:                     continue;
1:e94032a:                 }
1:e94032a: 
1:e94032a:                 Value value = generateAnyValue(version, fieldType.asCQL3Type());
1:e94032a:                 expected.append(value.expected);
1:e94032a:                 buffers[i] = value.value.duplicate();
1:e94032a:             }
1:e94032a:             expected.append(')');
1:e94032a:             buffer = TupleType.buildValue(buffers);
1:e94032a:         }
1:e94032a: 
1:e94032a:         return new Value(expected.toString(), tupleType.asCQL3Type(), buffer);
1:e94032a:     }
1:e94032a: 
1:e0adc16:     static Value generateUserDefinedValue(ProtocolVersion version, UserType userType, boolean allowNull)
1:e94032a:     {
1:e94032a:         StringBuilder expected = new StringBuilder();
1:e94032a:         ByteBuffer buffer;
1:e94032a: 
1:e94032a:         if (allowNull && randBool(0.05d))
1:e94032a:         {
1:e94032a:             // generate 'null' collection
1:e94032a:             expected.append("null");
1:e94032a:             buffer = null;
1:e94032a:         }
1:e94032a:         else
1:e94032a:         {
1:e94032a:             expected.append('{');
1:e94032a: 
1:e94032a:             // # of fields in this value
1:e94032a:             int fields = userType.size();
1:e94032a:             if (randBool(0.2d))
1:e94032a:                 fields = randInt(fields);
1:e94032a: 
1:e94032a:             ByteBuffer[] buffers = new ByteBuffer[fields];
1:e94032a:             for (int i = 0; i < fields; i++)
1:e94032a:             {
1:e94032a:                 AbstractType<?> fieldType = userType.type(i);
1:e94032a: 
1:e94032a:                 if (i > 0)
1:e94032a:                     expected.append(", ");
1:e94032a: 
1:e94032a:                 expected.append(ColumnIdentifier.maybeQuote(userType.fieldNameAsString(i)));
1:e94032a:                 expected.append(": ");
1:e94032a: 
1:e94032a:                 if (randBool(.1))
1:e94032a:                 {
1:e94032a:                     expected.append("null");
1:e94032a:                     continue;
1:e94032a:                 }
1:e94032a: 
1:e94032a:                 Value value = generateAnyValue(version, fieldType.asCQL3Type());
1:e94032a:                 expected.append(value.expected);
1:e94032a:                 buffers[i] = value.value.duplicate();
1:e94032a:             }
1:e94032a:             expected.append('}');
1:e94032a:             buffer = TupleType.buildValue(buffers);
1:e94032a:         }
1:e94032a: 
1:e94032a:         return new Value(expected.toString(), userType.asCQL3Type(), buffer);
1:e94032a:     }
1:e94032a: 
1:e94032a:     static Value generateNativeValue(CQL3Type type, boolean allowNull)
1:e94032a:     {
1:e94032a:         List<Value> values = nativeTypeValues.get(type);
1:e94032a:         assert values != null : type.toString() + " needs to be defined";
1:e94032a:         while (true)
1:e94032a:         {
1:e94032a:             Value v = values.get(randInt(values.size()));
1:e94032a:             if (allowNull || v.value != null)
1:e94032a:                 return v;
1:e94032a:         }
1:e94032a:     }
1:e94032a: 
1:e94032a:     static CollectionType randomCollectionType(int level)
1:e94032a:     {
1:e94032a:         CollectionType.Kind kind = CollectionType.Kind.values()[randInt(CollectionType.Kind.values().length)];
1:e94032a:         switch (kind)
1:e94032a:         {
1:e94032a:             case LIST:
1:e94032a:             case SET:
1:e94032a:                 return ListType.getInstance(randomNestedType(level), randBool());
1:e94032a:             case MAP:
1:e94032a:                 return MapType.getInstance(randomNestedType(level), randomNestedType(level), randBool());
1:e94032a:         }
1:e94032a:         throw new AssertionError();
1:e94032a:     }
1:e94032a: 
1:e94032a:     static TupleType randomTupleType(int level)
1:e94032a:     {
1:e94032a:         int typeCount = 2 + randInt(5);
1:e94032a:         List<AbstractType<?>> types = new ArrayList<>();
1:e94032a:         for (int i = 0; i < typeCount; i++)
1:e94032a:             types.add(randomNestedType(level));
1:e94032a:         return new TupleType(types);
1:e94032a:     }
1:e94032a: 
1:e94032a:     static UserType randomUserType(int level)
1:e94032a:     {
1:e94032a:         int typeCount = 2 + randInt(5);
1:4ed0060:         List<FieldIdentifier> names = new ArrayList<>();
1:e94032a:         List<AbstractType<?>> types = new ArrayList<>();
1:e94032a:         for (int i = 0; i < typeCount; i++)
1:e94032a:         {
1:4ed0060:             names.add(FieldIdentifier.forQuoted('f' + randLetters(i)));
1:e94032a:             types.add(randomNestedType(level));
1:e94032a:         }
1:677230d:         return new UserType("ks", UTF8Type.instance.fromString("u" + randInt(1000000)), names, types, true);
1:e94032a:     }
1:e94032a: 
1:e94032a:     //
1:e94032a:     // Following methods are just helper methods. Mostly to generate many kinds of random values.
1:e94032a:     //
1:e94032a: 
1:e94032a:     private static String randLetters(int len)
1:e94032a:     {
1:e94032a:         StringBuilder sb = new StringBuilder(len);
1:e94032a:         while (len-- > 0)
1:e94032a:         {
1:e94032a:             int i = randInt(52);
1:e94032a:             if (i < 26)
1:e94032a:                 sb.append((char) ('A' + i));
1:e94032a:             else
1:e94032a:                 sb.append((char) ('a' + i - 26));
1:e94032a:         }
1:e94032a:         return sb.toString();
1:e94032a:     }
1:e94032a: 
1:e94032a:     static AbstractType randomNativeType()
1:e94032a:     {
1:e94032a:         while (true)
1:e94032a:         {
1:e94032a:             CQL3Type.Native t = CQL3Type.Native.values()[randInt(CQL3Type.Native.values().length)];
1:e94032a:             if (t != CQL3Type.Native.EMPTY)
1:e94032a:                 return t.getType();
1:e94032a:         }
1:e94032a:     }
1:e94032a: 
1:e94032a:     static boolean randBool()
1:e94032a:     {
1:e94032a:         return randBool(0.5d);
1:e94032a:     }
1:e94032a: 
1:e94032a:     static boolean randBool(double probability)
1:e94032a:     {
1:e94032a:         return ThreadLocalRandom.current().nextDouble() < probability;
1:e94032a:     }
1:e94032a: 
1:e94032a:     static long randLong()
1:e94032a:     {
1:e94032a:         return ThreadLocalRandom.current().nextLong();
1:e94032a:     }
1:e94032a: 
1:e94032a:     static long randLong(long max)
1:e94032a:     {
1:e94032a:         return ThreadLocalRandom.current().nextLong(max);
1:e94032a:     }
1:e94032a: 
1:e94032a:     static int randInt()
1:e94032a:     {
1:e94032a:         return ThreadLocalRandom.current().nextInt();
1:e94032a:     }
1:e94032a: 
1:e94032a:     static int randInt(int max)
1:e94032a:     {
1:e94032a:         return ThreadLocalRandom.current().nextInt(max);
1:e94032a:     }
1:e94032a: 
1:e94032a:     static short randShort()
1:e94032a:     {
1:e94032a:         return (short) ThreadLocalRandom.current().nextInt();
1:e94032a:     }
1:e94032a: 
1:e94032a:     static byte randByte()
1:e94032a:     {
1:e94032a:         return (byte) ThreadLocalRandom.current().nextInt();
1:e94032a:     }
1:e94032a: 
1:e94032a:     static double randDouble()
1:e94032a:     {
1:e94032a:         return ThreadLocalRandom.current().nextDouble();
1:e94032a:     }
1:e94032a: 
1:e94032a:     static float randFloat()
1:e94032a:     {
1:e94032a:         return ThreadLocalRandom.current().nextFloat();
1:e94032a:     }
1:e94032a: 
1:e94032a:     static String randString(boolean ascii)
1:e94032a:     {
1:e94032a:         int l = randInt(20);
1:e94032a:         StringBuilder sb = new StringBuilder(l);
1:e94032a:         for (int i = 0; i < l; i++)
1:e94032a:         {
1:e94032a:             if (randBool(.05))
1:e94032a:                 sb.append('\'');
1:e94032a:             else
1:e94032a:             {
1:e94032a:                 char c = (char) (ascii ? randInt(128) : randShort());
1:e94032a:                 sb.append(c);
1:e94032a:             }
1:e94032a:         }
1:e94032a:         return UTF8Serializer.instance.deserialize(UTF8Serializer.instance.serialize(sb.toString()));
1:e94032a:     }
1:e94032a: 
1:e94032a:     static ByteBuffer randBytes()
1:e94032a:     {
1:e94032a:         int l = randInt(20);
1:e94032a:         byte[] v = new byte[l];
1:e94032a:         for (int i = 0; i < l; i++)
1:e94032a:         {
1:e94032a:             v[i] = randByte();
1:e94032a:         }
1:e94032a:         return ByteBuffer.wrap(v);
1:e94032a:     }
1:e94032a: 
1:e94032a:     private static String quote(String v)
1:e94032a:     {
1:e94032a:         return '\'' + QUOTE.matcher(v).replaceAll("''") + '\'';
1:e94032a:     }
1:e94032a: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:e0adc16
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.transport.ProtocolVersion;
/////////////////////////////////////////////////////////////////////////
1:         for (ProtocolVersion version : ProtocolVersion.SUPPORTED)
/////////////////////////////////////////////////////////////////////////
1:         for (ProtocolVersion version : ProtocolVersion.SUPPORTED)
/////////////////////////////////////////////////////////////////////////
1:         for (ProtocolVersion version : ProtocolVersion.SUPPORTED)
/////////////////////////////////////////////////////////////////////////
1:         for (ProtocolVersion version : ProtocolVersion.SUPPORTED)
/////////////////////////////////////////////////////////////////////////
1:         for (ProtocolVersion version : ProtocolVersion.SUPPORTED)
/////////////////////////////////////////////////////////////////////////
1:         for (ProtocolVersion version : ProtocolVersion.SUPPORTED)
/////////////////////////////////////////////////////////////////////////
1:     static void compareCqlLiteral(ProtocolVersion version, Value value)
/////////////////////////////////////////////////////////////////////////
1:     static Value randomNested(ProtocolVersion version)
/////////////////////////////////////////////////////////////////////////
1:     static Value generateCollectionValue(ProtocolVersion version, CollectionType collectionType, boolean allowNull)
/////////////////////////////////////////////////////////////////////////
1:     static Value generateAnyValue(ProtocolVersion version, CQL3Type type)
/////////////////////////////////////////////////////////////////////////
1:     static Value generateTupleValue(ProtocolVersion version, TupleType tupleType, boolean allowNull)
/////////////////////////////////////////////////////////////////////////
1:     static Value generateUserDefinedValue(ProtocolVersion version, UserType userType, boolean allowNull)
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:ecf05b8
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < 100; i++)
1:         {
1:             Duration duration = Duration.newInstance(Math.abs(randInt()), Math.abs(randInt()), Math.abs(randLong()));
1:             addNativeValue(DurationSerializer.instance.toString(duration), CQL3Type.Native.DURATION, DurationSerializer.instance.serialize(duration));
1:         }
1:         addNativeValue("null", CQL3Type.Native.DURATION, null);
1: 
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:4ed0060
/////////////////////////////////////////////////////////////////////////
1:         List<FieldIdentifier> names = new ArrayList<>();
1:             names.add(FieldIdentifier.forQuoted('f' + randLetters(i)));
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:677230d
/////////////////////////////////////////////////////////////////////////
1:         return new UserType("ks", UTF8Type.instance.fromString("u" + randInt(1000000)), names, types, true);
author:Robert Stupp
-------------------------------------------------------------------------------
commit:c6ed2e0
/////////////////////////////////////////////////////////////////////////
1: import java.util.*;
/////////////////////////////////////////////////////////////////////////
1:         // An empty collection is one with a size of 0 (note that rely on the fact that protocol version < 3 are not
1:         // supported anymore and so the size of a collection is always on 4 bytes).
1:         ByteBuffer emptyCollection = ByteBufferUtil.bytes(0);
1: 
1:             for (boolean frozen : Arrays.asList(true, false))
1:             {
1:                 // empty
1:                 Value value = new Value("[]", ListType.getInstance(UTF8Type.instance, frozen).asCQL3Type(), emptyCollection);
1:                 compareCqlLiteral(version, value);
1:                 value = new Value("{}", SetType.getInstance(UTF8Type.instance, frozen).asCQL3Type(), emptyCollection);
1:                 compareCqlLiteral(version, value);
1:                 value = new Value("{}", MapType.getInstance(UTF8Type.instance, UTF8Type.instance, frozen).asCQL3Type(), emptyCollection);
1:                 compareCqlLiteral(version, value);
1:                 // null
1:                 value = new Value("null", ListType.getInstance(UTF8Type.instance, frozen).asCQL3Type(), null);
1:                 compareCqlLiteral(version, value);
1:                 value = new Value("null", SetType.getInstance(UTF8Type.instance, frozen).asCQL3Type(), null);
1:                 compareCqlLiteral(version, value);
1:                 value = new Value("null", MapType.getInstance(UTF8Type.instance, UTF8Type.instance, frozen).asCQL3Type(), null);
1:                 compareCqlLiteral(version, value);
1:             }
/////////////////////////////////////////////////////////////////////////
1:                          value.cql3Type.toCQLLiteral(buffer, version));
/////////////////////////////////////////////////////////////////////////
1:             expected.append("null");
/////////////////////////////////////////////////////////////////////////
1:                 expected.append(el.cql3Type.toCQLLiteral(el.value, version));
/////////////////////////////////////////////////////////////////////////
1:                     expected.append(el.cql3Type.toCQLLiteral(el.value, version));
commit:e94032a
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.cassandra.cql3;
1: 
1: import java.math.BigDecimal;
1: import java.math.BigInteger;
1: import java.net.InetAddress;
1: import java.net.UnknownHostException;
1: import java.nio.ByteBuffer;
0: import java.util.ArrayList;
0: import java.util.Collection;
0: import java.util.Date;
0: import java.util.EnumMap;
0: import java.util.HashSet;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.Set;
0: import java.util.UUID;
1: import java.util.concurrent.ThreadLocalRandom;
1: import java.util.regex.Pattern;
1: 
1: import org.junit.Test;
1: 
1: import org.apache.cassandra.db.marshal.*;
1: import org.apache.cassandra.serializers.*;
0: import org.apache.cassandra.transport.Server;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: import org.apache.cassandra.utils.UUIDGen;
1: 
1: import static org.junit.Assert.assertEquals;
1: 
1: /**
1:  * Test functionality to re-create a CQL literal from its serialized representation.
1:  * This test uses some randomness to generate the values and nested structures (collections,tuples,UDTs).
1:  */
1: public class CQL3TypeLiteralTest
1: {
1:     private static final Pattern QUOTE = Pattern.compile("'");
1: 
1:     /**
1:      * Container holding the expected CQL literal for a type and serialized value.
1:      * The CQL literal is generated independently from the code in {@link CQL3Type}.
1:      */
1:     static class Value
1:     {
1:         final String expected;
1:         final CQL3Type cql3Type;
1:         final ByteBuffer value;
1: 
1:         Value(String expected, CQL3Type cql3Type, ByteBuffer value)
1:         {
1:             this.expected = expected;
1:             this.cql3Type = cql3Type;
1:             this.value = value;
1:         }
1:     }
1: 
1:     static final Map<CQL3Type.Native, List<Value>> nativeTypeValues = new EnumMap<>(CQL3Type.Native.class);
1: 
1:     static void addNativeValue(String expected, CQL3Type.Native cql3Type, ByteBuffer value)
1:     {
1:         List<Value> l = nativeTypeValues.get(cql3Type);
1:         if (l == null)
1:             nativeTypeValues.put(cql3Type, l = new ArrayList<>());
1:         l.add(new Value(expected, cql3Type, value));
1:     }
1: 
1:     static
1:     {
1:         // Add some (random) values for each native type.
1:         // Also adds null values and empty values, if the type allows this.
1: 
1:         for (int i = 0; i < 20; i++)
1:         {
1:             String v = randString(true);
1:             addNativeValue(quote(v), CQL3Type.Native.ASCII, AsciiSerializer.instance.serialize(v));
1:         }
1:         addNativeValue("''", CQL3Type.Native.ASCII, AsciiSerializer.instance.serialize(""));
1:         addNativeValue("''", CQL3Type.Native.ASCII, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:         addNativeValue("null", CQL3Type.Native.ASCII, null);
1: 
1:         for (int i = 0; i < 20; i++)
1:         {
1:             String v = randString(false);
1:             addNativeValue(quote(v), CQL3Type.Native.TEXT, UTF8Serializer.instance.serialize(v));
1:         }
1:         addNativeValue("''", CQL3Type.Native.TEXT, UTF8Serializer.instance.serialize(""));
1:         addNativeValue("''", CQL3Type.Native.TEXT, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:         addNativeValue("null", CQL3Type.Native.TEXT, null);
1: 
1:         for (int i = 0; i < 20; i++)
1:         {
1:             String v = randString(false);
1:             addNativeValue(quote(v), CQL3Type.Native.VARCHAR, UTF8Serializer.instance.serialize(v));
1:         }
1:         addNativeValue("''", CQL3Type.Native.VARCHAR, UTF8Serializer.instance.serialize(""));
1:         addNativeValue("''", CQL3Type.Native.VARCHAR, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:         addNativeValue("null", CQL3Type.Native.VARCHAR, null);
1: 
1:         addNativeValue("0", CQL3Type.Native.BIGINT, LongType.instance.decompose(0L));
1:         for (int i = 0; i < 20; i++)
1:         {
1:             long v = randLong();
1:             addNativeValue(Long.toString(v), CQL3Type.Native.BIGINT, LongType.instance.decompose(v));
1:         }
1:         addNativeValue("null", CQL3Type.Native.BIGINT, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:         addNativeValue("null", CQL3Type.Native.BIGINT, null);
1: 
1:         addNativeValue("0", CQL3Type.Native.COUNTER, LongType.instance.decompose(0L));
1:         for (int i = 0; i < 20; i++)
1:         {
1:             long v = randLong();
1:             addNativeValue(Long.toString(v), CQL3Type.Native.COUNTER, LongType.instance.decompose(v));
1:         }
1:         addNativeValue("null", CQL3Type.Native.COUNTER, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:         addNativeValue("null", CQL3Type.Native.COUNTER, null);
1: 
1:         addNativeValue("0", CQL3Type.Native.INT, Int32Type.instance.decompose(0));
1:         for (int i = 0; i < 20; i++)
1:         {
1:             int v = randInt();
1:             addNativeValue(Integer.toString(v), CQL3Type.Native.INT, Int32Type.instance.decompose(v));
1:         }
1:         addNativeValue("null", CQL3Type.Native.INT, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:         addNativeValue("null", CQL3Type.Native.INT, null);
1: 
1:         addNativeValue("0", CQL3Type.Native.SMALLINT, ShortType.instance.decompose((short) 0));
1:         for (int i = 0; i < 20; i++)
1:         {
1:             short v = randShort();
1:             addNativeValue(Short.toString(v), CQL3Type.Native.SMALLINT, ShortType.instance.decompose(v));
1:         }
1:         addNativeValue("null", CQL3Type.Native.SMALLINT, null);
1: 
1:         addNativeValue("0", CQL3Type.Native.TINYINT, ByteType.instance.decompose((byte) 0));
1:         for (int i = 0; i < 20; i++)
1:         {
1:             byte v = randByte();
1:             addNativeValue(Short.toString(v), CQL3Type.Native.TINYINT, ByteType.instance.decompose(v));
1:         }
1:         addNativeValue("null", CQL3Type.Native.TINYINT, null);
1: 
1:         addNativeValue("0.0", CQL3Type.Native.FLOAT, FloatType.instance.decompose((float) 0));
1:         for (int i = 0; i < 20; i++)
1:         {
1:             float v = randFloat();
1:             addNativeValue(Float.toString(v), CQL3Type.Native.FLOAT, FloatType.instance.decompose(v));
1:         }
1:         addNativeValue("NaN", CQL3Type.Native.FLOAT, FloatType.instance.decompose(Float.NaN));
1:         addNativeValue("null", CQL3Type.Native.FLOAT, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:         addNativeValue("null", CQL3Type.Native.FLOAT, null);
1: 
1:         addNativeValue("0.0", CQL3Type.Native.DOUBLE, DoubleType.instance.decompose((double) 0));
1:         for (int i = 0; i < 20; i++)
1:         {
1:             double v = randDouble();
1:             addNativeValue(Double.toString(v), CQL3Type.Native.DOUBLE, DoubleType.instance.decompose(v));
1:         }
1:         addNativeValue("NaN", CQL3Type.Native.DOUBLE, DoubleType.instance.decompose(Double.NaN));
1:         addNativeValue("null", CQL3Type.Native.DOUBLE, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:         addNativeValue("null", CQL3Type.Native.DOUBLE, null);
1: 
1:         addNativeValue("0", CQL3Type.Native.DECIMAL, DecimalType.instance.decompose(BigDecimal.ZERO));
1:         for (int i = 0; i < 20; i++)
1:         {
1:             BigDecimal v = BigDecimal.valueOf(randDouble());
1:             addNativeValue(v.toString(), CQL3Type.Native.DECIMAL, DecimalType.instance.decompose(v));
1:         }
1:         addNativeValue("null", CQL3Type.Native.DECIMAL, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:         addNativeValue("null", CQL3Type.Native.DECIMAL, null);
1: 
1:         addNativeValue("0", CQL3Type.Native.VARINT, IntegerType.instance.decompose(BigInteger.ZERO));
1:         for (int i = 0; i < 20; i++)
1:         {
1:             BigInteger v = BigInteger.valueOf(randLong());
1:             addNativeValue(v.toString(), CQL3Type.Native.VARINT, IntegerType.instance.decompose(v));
1:         }
1:         addNativeValue("null", CQL3Type.Native.VARINT, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:         addNativeValue("null", CQL3Type.Native.VARINT, null);
1: 
1:         // boolean doesn't have that many possible values...
1:         addNativeValue("false", CQL3Type.Native.BOOLEAN, BooleanType.instance.decompose(false));
1:         addNativeValue("true", CQL3Type.Native.BOOLEAN, BooleanType.instance.decompose(true));
1:         addNativeValue("null", CQL3Type.Native.BOOLEAN, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:         addNativeValue("null", CQL3Type.Native.BOOLEAN, null);
1: 
1:         // (mostly generates date values with surreal values like in year 14273)
1:         for (int i = 0; i < 20; i++)
1:         {
1:             int v = randInt();
1:             addNativeValue(SimpleDateSerializer.instance.toString(v), CQL3Type.Native.DATE, SimpleDateSerializer.instance.serialize(v));
1:         }
1:         addNativeValue("null", CQL3Type.Native.DATE, null);
1: 
1:         for (int i = 0; i < 100; i++)
1:         {
1:             long v = randLong(24L * 60 * 60 * 1000 * 1000 * 1000);
1:             addNativeValue(TimeSerializer.instance.toString(v), CQL3Type.Native.TIME, TimeSerializer.instance.serialize(v));
1:         }
1:         addNativeValue("null", CQL3Type.Native.TIME, null);
1: 
1:         // (mostly generates timestamp values with surreal values like in year 14273)
1:         for (int i = 0; i < 20; i++)
1:         {
1:             long v = randLong();
1:             addNativeValue(TimestampSerializer.instance.toStringUTC(new Date(v)), CQL3Type.Native.TIMESTAMP, TimestampType.instance.fromString(Long.toString(v)));
1:         }
1:         addNativeValue("null", CQL3Type.Native.TIMESTAMP, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:         addNativeValue("null", CQL3Type.Native.TIMESTAMP, null);
1: 
1:         for (int i = 0; i < 20; i++)
1:         {
1:             UUID v = UUIDGen.getTimeUUID(randLong(System.currentTimeMillis()));
1:             addNativeValue(v.toString(), CQL3Type.Native.TIMEUUID, TimeUUIDType.instance.decompose(v));
1:         }
1:         addNativeValue("null", CQL3Type.Native.TIMEUUID, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:         addNativeValue("null", CQL3Type.Native.TIMEUUID, null);
1: 
1:         for (int i = 0; i < 20; i++)
1:         {
1:             UUID v = UUID.randomUUID();
1:             addNativeValue(v.toString(), CQL3Type.Native.UUID, UUIDType.instance.decompose(v));
1:         }
1:         addNativeValue("null", CQL3Type.Native.UUID, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:         addNativeValue("null", CQL3Type.Native.UUID, null);
1: 
1:         for (int i = 0; i < 20; i++)
1:         {
1:             ByteBuffer v = randBytes();
1:             addNativeValue("0x" + BytesSerializer.instance.toString(v), CQL3Type.Native.BLOB, BytesType.instance.decompose(v));
1:         }
1:         addNativeValue("0x", CQL3Type.Native.BLOB, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:         addNativeValue("null", CQL3Type.Native.BLOB, null);
1: 
1:         for (int i = 0; i < 20; i++)
1:         {
1:             InetAddress v;
1:             try
1:             {
1:                 v = InetAddress.getByAddress(new byte[]{ randByte(), randByte(), randByte(), randByte() });
1:             }
1:             catch (UnknownHostException e)
1:             {
1:                 throw new RuntimeException(e);
1:             }
1:             addNativeValue(v.getHostAddress(), CQL3Type.Native.INET, InetAddressSerializer.instance.serialize(v));
1:         }
1:         addNativeValue("null", CQL3Type.Native.INET, ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:         addNativeValue("null", CQL3Type.Native.INET, null);
1:     }
1: 
1:     @Test
1:     public void testNative()
1:     {
1:         // test each native type against each supported protocol version (although it doesn't make sense to
1:         // iterate through all protocol versions as of C* 3.0).
1: 
0:         for (int version = Server.MIN_SUPPORTED_VERSION; version <= Server.CURRENT_VERSION; version++)
1:         {
1:             for (Map.Entry<CQL3Type.Native, List<Value>> entry : nativeTypeValues.entrySet())
1:             {
1:                 for (Value value : entry.getValue())
1:                 {
1:                     compareCqlLiteral(version, value);
1:                 }
1:             }
1:         }
1:     }
1: 
1:     @Test
1:     public void testCollectionWithNatives()
1:     {
1:         // test 100 collections with varying element/key/value types against each supported protocol version,
1:         // type of collection is randomly chosen
1: 
0:         for (int version = Server.MIN_SUPPORTED_VERSION; version <= Server.CURRENT_VERSION; version++)
1:         {
1:             for (int n = 0; n < 100; n++)
1:             {
1:                 Value value = generateCollectionValue(version, randomCollectionType(0), true);
1:                 compareCqlLiteral(version, value);
1:             }
1:         }
1:     }
1: 
1:     @Test
1:     public void testCollectionNullAndEmpty()
1:     {
0:         for (int version = Server.MIN_SUPPORTED_VERSION; version <= Server.CURRENT_VERSION; version++)
1:         {
0:             // empty, frozen collections
0:             Value value = new Value("[]", ListType.getInstance(UTF8Type.instance, false).asCQL3Type(), ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:             compareCqlLiteral(version, value);
0:             value = new Value("{}", SetType.getInstance(UTF8Type.instance, false).asCQL3Type(), ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:             compareCqlLiteral(version, value);
0:             value = new Value("{}", MapType.getInstance(UTF8Type.instance, UTF8Type.instance, false).asCQL3Type(), ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:             compareCqlLiteral(version, value);
1: 
0:             // empty, non-frozen collections
0:             value = new Value("[]", ListType.getInstance(UTF8Type.instance, true).asCQL3Type(), ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:             compareCqlLiteral(version, value);
0:             value = new Value("{}", SetType.getInstance(UTF8Type.instance, true).asCQL3Type(), ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:             compareCqlLiteral(version, value);
0:             value = new Value("{}", MapType.getInstance(UTF8Type.instance, UTF8Type.instance, true).asCQL3Type(), ByteBufferUtil.EMPTY_BYTE_BUFFER);
1:             compareCqlLiteral(version, value);
1: 
0:             // null, frozen collections
0:             value = new Value("null", ListType.getInstance(UTF8Type.instance, false).asCQL3Type(), null);
1:             compareCqlLiteral(version, value);
0:             value = new Value("null", SetType.getInstance(UTF8Type.instance, false).asCQL3Type(), null);
1:             compareCqlLiteral(version, value);
0:             value = new Value("null", MapType.getInstance(UTF8Type.instance, UTF8Type.instance, false).asCQL3Type(), null);
1:             compareCqlLiteral(version, value);
1: 
0:             // null, non-frozen collections
0:             value = new Value("[]", ListType.getInstance(UTF8Type.instance, true).asCQL3Type(), null);
1:             compareCqlLiteral(version, value);
0:             value = new Value("{}", SetType.getInstance(UTF8Type.instance, true).asCQL3Type(), null);
1:             compareCqlLiteral(version, value);
0:             value = new Value("{}", MapType.getInstance(UTF8Type.instance, UTF8Type.instance, true).asCQL3Type(), null);
1:             compareCqlLiteral(version, value);
1:         }
1:     }
1: 
1:     @Test
1:     public void testTupleWithNatives()
1:     {
1:         // test 100 tuples with varying element/key/value types against each supported protocol version
1: 
0:         for (int version = Server.MIN_SUPPORTED_VERSION; version <= Server.CURRENT_VERSION; version++)
1:         {
1:             for (int n = 0; n < 100; n++)
1:             {
1:                 Value value = generateTupleValue(version, randomTupleType(0), true);
1:                 compareCqlLiteral(version, value);
1:             }
1:         }
1:     }
1: 
1:     @Test
1:     public void testUserDefinedWithNatives()
1:     {
1:         // test 100 UDTs with varying element/key/value types against each supported protocol version
1: 
0:         for (int version = Server.MIN_SUPPORTED_VERSION; version <= Server.CURRENT_VERSION; version++)
1:         {
1:             for (int n = 0; n < 100; n++)
1:             {
1:                 Value value = generateUserDefinedValue(version, randomUserType(0), true);
1:                 compareCqlLiteral(version, value);
1:             }
1:         }
1:     }
1: 
1:     @Test
1:     public void testNested()
1:     {
1:         // This is the "nice" part of this unit test - it tests (probably) nested type structures
1:         // like 'tuple<map, list<user>, tuple, user>' or 'map<tuple<int, text>, set<inet>>' with
1:         // random types  against each supported protocol version.
1: 
0:         for (int version = Server.MIN_SUPPORTED_VERSION; version <= Server.CURRENT_VERSION; version++)
1:         {
1:             for (int n = 0; n < 100; n++)
1:             {
1:                 Value value = randomNested(version);
1:                 compareCqlLiteral(version, value);
1:             }
1:         }
1:     }
1: 
0:     static void compareCqlLiteral(int version, Value value)
1:     {
1:         ByteBuffer buffer = value.value != null ? value.value.duplicate() : null;
1:         String msg = "Failed to get expected value for type " + value.cql3Type + " / " + value.cql3Type.getType() + " with protocol-version " + version + " expected:\"" + value.expected + '"';
1:         try
1:         {
1:             assertEquals(msg,
1:                          value.expected,
0:                          value.cql3Type.asCQLLiteral(buffer, version));
1:         }
1:         catch (RuntimeException e)
1:         {
1:             throw new RuntimeException(msg, e);
1:         }
1:     }
1: 
0:     static Value randomNested(int version)
1:     {
1:         AbstractType type = randomNestedType(2);
1: 
1:         return generateAnyValue(version, type.asCQL3Type());
1:     }
1: 
1:     /**
1:      * Generates type of randomly nested type structures.
1:      */
1:     static AbstractType randomNestedType(int level)
1:     {
1:         if (level == 0)
1:             return randomNativeType();
1:         switch (randInt(level == 2 ? 3 : 4))
1:         {
1:             case 0:
1:                 return randomCollectionType(level - 1);
1:             case 1:
1:                 return randomTupleType(level - 1);
1:             case 2:
1:                 return randomUserType(level - 1);
1:             case 3:
1:                 return randomNativeType();
1:         }
1:         throw new AssertionError();
1:     }
1: 
0:     static Value generateCollectionValue(int version, CollectionType collectionType, boolean allowNull)
1:     {
1:         StringBuilder expected = new StringBuilder();
1:         ByteBuffer buffer;
1: 
1:         if (allowNull && randBool(0.05d))
1:         {
1:             // generate 'null' collection
0:             if (collectionType.isMultiCell())
1:             {
1:                 switch (collectionType.kind)
1:                 {
1:                     case LIST:
0:                         expected.append("[]");
1:                         break;
1:                     case SET:
1:                     case MAP:
0:                         expected.append("{}");
1:                         break;
1:                 }
1:             }
1:             else
1:             {
1:                 expected.append("null");
1:             }
1:             buffer = null;
1:         }
1:         else
1:         {
1:             int size = randInt(20);
1: 
1:             CQL3Type elements;
1:             CQL3Type values = null;
1:             char bracketOpen;
1:             char bracketClose;
1:             switch (collectionType.kind)
1:             {
1:                 case LIST:
1:                     elements = ((ListType) collectionType).getElementsType().asCQL3Type();
1:                     bracketOpen = '[';
1:                     bracketClose = ']';
1:                     break;
1:                 case SET:
1:                     elements = ((SetType) collectionType).getElementsType().asCQL3Type();
1:                     bracketOpen = '{';
1:                     bracketClose = '}';
1:                     break;
1:                 case MAP:
1:                     elements = ((MapType) collectionType).getKeysType().asCQL3Type();
1:                     values = ((MapType) collectionType).getValuesType().asCQL3Type();
1:                     bracketOpen = '{';
1:                     bracketClose = '}';
1:                     break;
1:                 default:
1:                     throw new AssertionError();
1:             }
1: 
1:             expected.append(bracketOpen);
1:             Collection<ByteBuffer> buffers = new ArrayList<>();
1:             Set<ByteBuffer> added = new HashSet<>();
1:             for (int i = 0; i < size; i++)
1:             {
1:                 Value el = generateAnyValue(version, elements);
1:                 if (!added.add(el.value))
1:                     continue;
1: 
1:                 buffers.add(el.value.duplicate());
1:                 if (expected.length() > 1)
1:                     expected.append(", ");
0:                 el.cql3Type.toCQLLiteral(el.value, version, expected);
1: 
1:                 if (collectionType.kind == CollectionType.Kind.MAP)
1:                 {
1:                     // add map value
1:                     el = generateAnyValue(version, values);
1:                     buffers.add(el.value.duplicate());
1:                     expected.append(": ");
0:                     el.cql3Type.toCQLLiteral(el.value, version, expected);
1:                 }
1:             }
1:             expected.append(bracketClose);
1:             buffer = CollectionSerializer.pack(buffers, added.size(), version);
1:         }
1: 
1:         return new Value(expected.toString(), collectionType.asCQL3Type(), buffer);
1:     }
1: 
1:     /**
1:      * Generates a value for any type or type structure.
1:      */
0:     static Value generateAnyValue(int version, CQL3Type type)
1:     {
1:         if (type instanceof CQL3Type.Native)
1:             return generateNativeValue(type, false);
1:         if (type instanceof CQL3Type.Tuple)
1:             return generateTupleValue(version, (TupleType) type.getType(), false);
1:         if (type instanceof CQL3Type.UserDefined)
1:             return generateUserDefinedValue(version, (UserType) type.getType(), false);
1:         if (type instanceof CQL3Type.Collection)
1:             return generateCollectionValue(version, (CollectionType) type.getType(), false);
1:         throw new AssertionError();
1:     }
1: 
0:     static Value generateTupleValue(int version, TupleType tupleType, boolean allowNull)
1:     {
1:         StringBuilder expected = new StringBuilder();
1:         ByteBuffer buffer;
1: 
1:         if (allowNull && randBool(0.05d))
1:         {
1:             // generate 'null' collection
1:             expected.append("null");
1:             buffer = null;
1:         }
1:         else
1:         {
1:             expected.append('(');
1: 
1:             // # of fields in this value
1:             int fields = tupleType.size();
1:             if (randBool(0.2d))
1:                 fields = randInt(fields);
1: 
1:             ByteBuffer[] buffers = new ByteBuffer[fields];
1:             for (int i = 0; i < fields; i++)
1:             {
1:                 AbstractType<?> fieldType = tupleType.type(i);
1: 
1:                 if (i > 0)
1:                     expected.append(", ");
1: 
1:                 if (allowNull && randBool(.1))
1:                 {
1:                     expected.append("null");
1:                     continue;
1:                 }
1: 
1:                 Value value = generateAnyValue(version, fieldType.asCQL3Type());
1:                 expected.append(value.expected);
1:                 buffers[i] = value.value.duplicate();
1:             }
1:             expected.append(')');
1:             buffer = TupleType.buildValue(buffers);
1:         }
1: 
1:         return new Value(expected.toString(), tupleType.asCQL3Type(), buffer);
1:     }
1: 
0:     static Value generateUserDefinedValue(int version, UserType userType, boolean allowNull)
1:     {
1:         StringBuilder expected = new StringBuilder();
1:         ByteBuffer buffer;
1: 
1:         if (allowNull && randBool(0.05d))
1:         {
1:             // generate 'null' collection
1:             expected.append("null");
1:             buffer = null;
1:         }
1:         else
1:         {
1:             expected.append('{');
1: 
1:             // # of fields in this value
1:             int fields = userType.size();
1:             if (randBool(0.2d))
1:                 fields = randInt(fields);
1: 
1:             ByteBuffer[] buffers = new ByteBuffer[fields];
1:             for (int i = 0; i < fields; i++)
1:             {
1:                 AbstractType<?> fieldType = userType.type(i);
1: 
1:                 if (i > 0)
1:                     expected.append(", ");
1: 
1:                 expected.append(ColumnIdentifier.maybeQuote(userType.fieldNameAsString(i)));
1:                 expected.append(": ");
1: 
1:                 if (randBool(.1))
1:                 {
1:                     expected.append("null");
1:                     continue;
1:                 }
1: 
1:                 Value value = generateAnyValue(version, fieldType.asCQL3Type());
1:                 expected.append(value.expected);
1:                 buffers[i] = value.value.duplicate();
1:             }
1:             expected.append('}');
1:             buffer = TupleType.buildValue(buffers);
1:         }
1: 
1:         return new Value(expected.toString(), userType.asCQL3Type(), buffer);
1:     }
1: 
1:     static Value generateNativeValue(CQL3Type type, boolean allowNull)
1:     {
1:         List<Value> values = nativeTypeValues.get(type);
1:         assert values != null : type.toString() + " needs to be defined";
1:         while (true)
1:         {
1:             Value v = values.get(randInt(values.size()));
1:             if (allowNull || v.value != null)
1:                 return v;
1:         }
1:     }
1: 
1:     static CollectionType randomCollectionType(int level)
1:     {
1:         CollectionType.Kind kind = CollectionType.Kind.values()[randInt(CollectionType.Kind.values().length)];
1:         switch (kind)
1:         {
1:             case LIST:
1:             case SET:
1:                 return ListType.getInstance(randomNestedType(level), randBool());
1:             case MAP:
1:                 return MapType.getInstance(randomNestedType(level), randomNestedType(level), randBool());
1:         }
1:         throw new AssertionError();
1:     }
1: 
1:     static TupleType randomTupleType(int level)
1:     {
1:         int typeCount = 2 + randInt(5);
1:         List<AbstractType<?>> types = new ArrayList<>();
1:         for (int i = 0; i < typeCount; i++)
1:             types.add(randomNestedType(level));
1:         return new TupleType(types);
1:     }
1: 
1:     static UserType randomUserType(int level)
1:     {
1:         int typeCount = 2 + randInt(5);
0:         List<ByteBuffer> names = new ArrayList<>();
1:         List<AbstractType<?>> types = new ArrayList<>();
1:         for (int i = 0; i < typeCount; i++)
1:         {
0:             names.add(UTF8Type.instance.fromString('f' + randLetters(i)));
1:             types.add(randomNestedType(level));
1:         }
0:         return new UserType("ks", UTF8Type.instance.fromString("u" + randInt(1000000)), names, types);
1:     }
1: 
1:     //
1:     // Following methods are just helper methods. Mostly to generate many kinds of random values.
1:     //
1: 
1:     private static String randLetters(int len)
1:     {
1:         StringBuilder sb = new StringBuilder(len);
1:         while (len-- > 0)
1:         {
1:             int i = randInt(52);
1:             if (i < 26)
1:                 sb.append((char) ('A' + i));
1:             else
1:                 sb.append((char) ('a' + i - 26));
1:         }
1:         return sb.toString();
1:     }
1: 
1:     static AbstractType randomNativeType()
1:     {
1:         while (true)
1:         {
1:             CQL3Type.Native t = CQL3Type.Native.values()[randInt(CQL3Type.Native.values().length)];
1:             if (t != CQL3Type.Native.EMPTY)
1:                 return t.getType();
1:         }
1:     }
1: 
1:     static boolean randBool()
1:     {
1:         return randBool(0.5d);
1:     }
1: 
1:     static boolean randBool(double probability)
1:     {
1:         return ThreadLocalRandom.current().nextDouble() < probability;
1:     }
1: 
1:     static long randLong()
1:     {
1:         return ThreadLocalRandom.current().nextLong();
1:     }
1: 
1:     static long randLong(long max)
1:     {
1:         return ThreadLocalRandom.current().nextLong(max);
1:     }
1: 
1:     static int randInt()
1:     {
1:         return ThreadLocalRandom.current().nextInt();
1:     }
1: 
1:     static int randInt(int max)
1:     {
1:         return ThreadLocalRandom.current().nextInt(max);
1:     }
1: 
1:     static short randShort()
1:     {
1:         return (short) ThreadLocalRandom.current().nextInt();
1:     }
1: 
1:     static byte randByte()
1:     {
1:         return (byte) ThreadLocalRandom.current().nextInt();
1:     }
1: 
1:     static double randDouble()
1:     {
1:         return ThreadLocalRandom.current().nextDouble();
1:     }
1: 
1:     static float randFloat()
1:     {
1:         return ThreadLocalRandom.current().nextFloat();
1:     }
1: 
1:     static String randString(boolean ascii)
1:     {
1:         int l = randInt(20);
1:         StringBuilder sb = new StringBuilder(l);
1:         for (int i = 0; i < l; i++)
1:         {
1:             if (randBool(.05))
1:                 sb.append('\'');
1:             else
1:             {
1:                 char c = (char) (ascii ? randInt(128) : randShort());
1:                 sb.append(c);
1:             }
1:         }
1:         return UTF8Serializer.instance.deserialize(UTF8Serializer.instance.serialize(sb.toString()));
1:     }
1: 
1:     static ByteBuffer randBytes()
1:     {
1:         int l = randInt(20);
1:         byte[] v = new byte[l];
1:         for (int i = 0; i < l; i++)
1:         {
1:             v[i] = randByte();
1:         }
1:         return ByteBuffer.wrap(v);
1:     }
1: 
1:     private static String quote(String v)
1:     {
1:         return '\'' + QUOTE.matcher(v).replaceAll("''") + '\'';
1:     }
1: }
============================================================================