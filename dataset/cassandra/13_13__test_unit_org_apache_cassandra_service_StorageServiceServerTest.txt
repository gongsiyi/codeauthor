1:360d9b6: /*
1:360d9b6: * Licensed to the Apache Software Foundation (ASF) under one
1:360d9b6: * or more contributor license agreements.  See the NOTICE file
1:360d9b6: * distributed with this work for additional information
1:360d9b6: * regarding copyright ownership.  The ASF licenses this file
1:360d9b6: * to you under the Apache License, Version 2.0 (the
1:360d9b6: * "License"); you may not use this file except in compliance
1:360d9b6: * with the License.  You may obtain a copy of the License at
1:360d9b6: *
1:360d9b6: *    http://www.apache.org/licenses/LICENSE-2.0
1:360d9b6: *
1:360d9b6: * Unless required by applicable law or agreed to in writing,
1:360d9b6: * software distributed under the License is distributed on an
1:360d9b6: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:360d9b6: * KIND, either express or implied.  See the License for the
1:360d9b6: * specific language governing permissions and limitations
1:360d9b6: * under the License.
1:360d9b6: */
1:4797b40: 
1:360d9b6: package org.apache.cassandra.service;
1:aa7794c: 
1:360d9b6: import java.io.File;
1:b7ae07e: import java.io.FileWriter;
1:360d9b6: import java.io.IOException;
1:b7ae07e: import java.io.PrintWriter;
1:debd8f0: import java.net.InetAddress;
1:debd8f0: import java.util.*;
1:125b464: 
1:debd8f0: import com.google.common.collect.HashMultimap;
1:debd8f0: import com.google.common.collect.Multimap;
1:debd8f0: import org.junit.BeforeClass;
1:5b52240: import org.junit.Test;
1:018e82b: import org.junit.runner.RunWith;
1:7fd4228: 
1:018e82b: import org.apache.cassandra.OrderedJUnit4ClassRunner;
1:438acfc: import org.apache.cassandra.SchemaLoader;
1:125b464: import org.apache.cassandra.config.DatabaseDescriptor;
1:9797511: import org.apache.cassandra.config.SchemaConstants;
1:a89597d: import org.apache.cassandra.schema.KeyspaceMetadata;
1:debd8f0: import org.apache.cassandra.config.Schema;
1:0e96e58: import org.apache.cassandra.db.Keyspace;
1:b7ae07e: import org.apache.cassandra.db.WindowsFailedSnapshotTracker;
1:07893d7: import org.apache.cassandra.dht.Murmur3Partitioner;
1:07893d7: import org.apache.cassandra.dht.Murmur3Partitioner.LongToken;
1:a991b64: import org.apache.cassandra.dht.OrderPreservingPartitioner.StringToken;
1:a991b64: import org.apache.cassandra.dht.Range;
1:a991b64: import org.apache.cassandra.dht.Token;
1:0e96e58: import org.apache.cassandra.exceptions.ConfigurationException;
1:debd8f0: import org.apache.cassandra.locator.IEndpointSnitch;
1:debd8f0: import org.apache.cassandra.locator.PropertyFileSnitch;
1:debd8f0: import org.apache.cassandra.locator.TokenMetadata;
1:31e3f61: import org.apache.cassandra.schema.KeyspaceParams;
1:b31845c: import org.apache.cassandra.schema.ReplicationParams;
1:7d6c876: import org.apache.cassandra.schema.SchemaKeyspace;
1:b7ae07e: import org.apache.cassandra.utils.FBUtilities;
1:7fd4228: 
1:7fd4228: import static org.junit.Assert.assertEquals;
1:5b52240: import static org.junit.Assert.assertTrue;
1:b7ae07e: import static org.junit.Assume.assumeTrue;
3:5b52240: 
1:018e82b: @RunWith(OrderedJUnit4ClassRunner.class)
1:5b52240: public class StorageServiceServerTest
4:360d9b6: {
1:debd8f0:     @BeforeClass
1:debd8f0:     public static void setUp() throws ConfigurationException
1:debd8f0:     {
1:9797511:         DatabaseDescriptor.daemonInitialization();
1:debd8f0:         IEndpointSnitch snitch = new PropertyFileSnitch();
1:debd8f0:         DatabaseDescriptor.setEndpointSnitch(snitch);
1:5ab1a34:         Keyspace.setInitialized();
1:debd8f0:     }
1:debd8f0: 
1:debd8f0:     @Test
1:9639f95:     public void testRegularMode() throws ConfigurationException
1:125b464:     {
1:438acfc:         SchemaLoader.mkdirs();
1:438acfc:         SchemaLoader.cleanup();
1:e987e3b:         StorageService.instance.initServer(0);
2:360d9b6:         for (String path : DatabaseDescriptor.getAllDataFileLocations())
1:125b464:         {
1:360d9b6:             // verify that storage directories are there.
1:360d9b6:             assertTrue(new File(path).exists());
1:7fd4228:         }
1:360d9b6:         // a proper test would be to call decommission here, but decommission() mixes both shutdown and datatransfer
1:360d9b6:         // calls.  This test is only interested in the shutdown-related items which a properly handled by just
1:360d9b6:         // stopping the client.
1:a2e2c03:         //StorageService.instance.decommission();
1:a2e2c03:         StorageService.instance.stopClient();
1:7fd4228:     }
1:125b464: 
1:125b464:     @Test
1:7fd4228:     public void testGetAllRangesEmpty()
1:7fd4228:     {
1:7fd4228:         List<Token> toks = Collections.emptyList();
1:125b464:         assertEquals(Collections.<Range<Token>>emptyList(), StorageService.instance.getAllRanges(toks));
1:0b68a77:     }
1:125b464: 
1:125b464:     @Test
1:ee9e38b:     public void testSnapshotWithFlush() throws IOException
1:0b68a77:     {
1:0b68a77:         // no need to insert extra data, even an "empty" database will have a little information in the system keyspace
1:ee9e38b:         StorageService.instance.takeSnapshot(UUID.randomUUID().toString());
1:4797b40:     }
1:125b464: 
1:b7ae07e:     private void checkTempFilePresence(File f, boolean exist)
1:b7ae07e:     {
1:b7ae07e:         for (int i = 0; i < 5; i++)
1:b7ae07e:         {
1:b7ae07e:             File subdir = new File(f, Integer.toString(i));
1:b7ae07e:             subdir.mkdir();
1:b7ae07e:             for (int j = 0; j < 5; j++)
1:b7ae07e:             {
1:b7ae07e:                 File subF = new File(subdir, Integer.toString(j));
1:b7ae07e:                 assert(exist ? subF.exists() : !subF.exists());
1:b7ae07e:             }
1:b7ae07e:         }
1:b7ae07e:     }
1:b7ae07e: 
1:b7ae07e:     @Test
1:b7ae07e:     public void testSnapshotFailureHandler() throws IOException
1:b7ae07e:     {
1:54836ec:         assumeTrue(FBUtilities.isWindows);
1:b7ae07e: 
1:b7ae07e:         // Initial "run" of Cassandra, nothing in failed snapshot file
1:b7ae07e:         WindowsFailedSnapshotTracker.deleteOldSnapshots();
1:b7ae07e: 
1:b7ae07e:         File f = new File(System.getenv("TEMP") + File.separator + Integer.toString(new Random().nextInt()));
1:b7ae07e:         f.mkdir();
1:b7ae07e:         f.deleteOnExit();
1:b7ae07e:         for (int i = 0; i < 5; i++)
1:b7ae07e:         {
1:b7ae07e:             File subdir = new File(f, Integer.toString(i));
1:b7ae07e:             subdir.mkdir();
1:b7ae07e:             for (int j = 0; j < 5; j++)
1:b7ae07e:                 new File(subdir, Integer.toString(j)).createNewFile();
1:b7ae07e:         }
1:b7ae07e: 
1:b7ae07e:         checkTempFilePresence(f, true);
1:b7ae07e: 
1:b7ae07e:         // Confirm deletion is recursive
1:b7ae07e:         for (int i = 0; i < 5; i++)
1:b7ae07e:             WindowsFailedSnapshotTracker.handleFailedSnapshot(new File(f, Integer.toString(i)));
1:b7ae07e: 
1:b7ae07e:         assert new File(WindowsFailedSnapshotTracker.TODELETEFILE).exists();
1:b7ae07e: 
1:b7ae07e:         // Simulate shutdown and restart of C* node, closing out the list of failed snapshots.
1:b7ae07e:         WindowsFailedSnapshotTracker.resetForTests();
1:b7ae07e: 
1:b7ae07e:         // Perform new run, mimicking behavior of C* at startup
1:b7ae07e:         WindowsFailedSnapshotTracker.deleteOldSnapshots();
1:b7ae07e:         checkTempFilePresence(f, false);
1:b7ae07e: 
1:b7ae07e:         // Check to make sure we don't delete non-temp, non-datafile locations
1:b7ae07e:         WindowsFailedSnapshotTracker.resetForTests();
1:b7ae07e:         PrintWriter tempPrinter = new PrintWriter(new FileWriter(WindowsFailedSnapshotTracker.TODELETEFILE, true));
1:b7ae07e:         tempPrinter.println(".safeDir");
1:b7ae07e:         tempPrinter.close();
1:b7ae07e: 
1:b7ae07e:         File protectedDir = new File(".safeDir");
1:b7ae07e:         protectedDir.mkdir();
1:b7ae07e:         File protectedFile = new File(protectedDir, ".safeFile");
1:b7ae07e:         protectedFile.createNewFile();
1:b7ae07e: 
1:b7ae07e:         WindowsFailedSnapshotTracker.handleFailedSnapshot(protectedDir);
1:b7ae07e:         WindowsFailedSnapshotTracker.deleteOldSnapshots();
1:b7ae07e: 
1:b7ae07e:         assert protectedDir.exists();
1:b7ae07e:         assert protectedFile.exists();
1:b7ae07e: 
1:b7ae07e:         protectedFile.delete();
1:b7ae07e:         protectedDir.delete();
1:b7ae07e:     }
1:b7ae07e: 
1:4797b40:     @Test
1:0bd5170:     public void testTableSnapshot() throws IOException
1:4797b40:     {
1:4797b40:         // no need to insert extra data, even an "empty" database will have a little information in the system keyspace
1:9797511:         StorageService.instance.takeTableSnapshot(SchemaConstants.SCHEMA_KEYSPACE_NAME, SchemaKeyspace.KEYSPACES, UUID.randomUUID().toString());
1:ee9e38b:     }
1:ee9e38b: 
1:ee9e38b:     @Test
1:ee9e38b:     public void testSnapshot() throws IOException
1:ee9e38b:     {
1:ee9e38b:         // no need to insert extra data, even an "empty" database will have a little information in the system keyspace
1:9797511:         StorageService.instance.takeSnapshot(UUID.randomUUID().toString(), SchemaConstants.SCHEMA_KEYSPACE_NAME);
1:0b68a77:     }
1:125b464: 
1:0b68a77:     @Test
1:125b464:     public void testPrimaryRangeForEndpointWithinDCWithNetworkTopologyStrategy() throws Exception
1:125b464:     {
1:125b464:         TokenMetadata metadata = StorageService.instance.getTokenMetadata();
1:125b464:         metadata.clearUnsafe();
1:125b464: 
1:125b464:         // DC1
1:125b464:         metadata.updateNormalToken(new StringToken("A"), InetAddress.getByName("127.0.0.1"));
1:125b464:         metadata.updateNormalToken(new StringToken("C"), InetAddress.getByName("127.0.0.2"));
1:125b464: 
1:125b464:         // DC2
1:125b464:         metadata.updateNormalToken(new StringToken("B"), InetAddress.getByName("127.0.0.4"));
1:125b464:         metadata.updateNormalToken(new StringToken("D"), InetAddress.getByName("127.0.0.5"));
1:debd8f0: 
1:125b464:         Map<String, String> configOptions = new HashMap<>();
1:125b464:         configOptions.put("DC1", "1");
1:125b464:         configOptions.put("DC2", "1");
1:b31845c:         configOptions.put(ReplicationParams.CLASS, "NetworkTopologyStrategy");
1:125b464: 
1:0e96e58:         Keyspace.clear("Keyspace1");
1:a89597d:         KeyspaceMetadata meta = KeyspaceMetadata.create("Keyspace1", KeyspaceParams.create(false, configOptions));
1:a89597d:         Schema.instance.setKeyspaceMetadata(meta);
1:125b464: 
1:125b464:         Collection<Range<Token>> primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name,
1:125b464:                                                                                                             InetAddress.getByName("127.0.0.1"));
1:125b464:         assertEquals(2, primaryRanges.size());
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("D"), new StringToken("A"))));
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("C"), new StringToken("D"))));
1:125b464: 
1:125b464:         primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name, InetAddress.getByName("127.0.0.2"));
1:125b464:         assertEquals(2, primaryRanges.size());
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("A"), new StringToken("B"))));
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("B"), new StringToken("C"))));
1:125b464: 
1:125b464:         primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name, InetAddress.getByName("127.0.0.4"));
1:125b464:         assertEquals(2, primaryRanges.size());
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("D"), new StringToken("A"))));
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("A"), new StringToken("B"))));
1:125b464: 
1:125b464:         primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name, InetAddress.getByName("127.0.0.5"));
1:125b464:         assertEquals(2, primaryRanges.size());
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("B"), new StringToken("C"))));
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("C"), new StringToken("D"))));
1:125b464:     }
1:125b464: 
1:125b464:     @Test
1:debd8f0:     public void testPrimaryRangesWithNetworkTopologyStrategy() throws Exception
1:debd8f0:     {
1:debd8f0:         TokenMetadata metadata = StorageService.instance.getTokenMetadata();
1:debd8f0:         metadata.clearUnsafe();
1:debd8f0:         // DC1
1:debd8f0:         metadata.updateNormalToken(new StringToken("A"), InetAddress.getByName("127.0.0.1"));
1:debd8f0:         metadata.updateNormalToken(new StringToken("C"), InetAddress.getByName("127.0.0.2"));
1:debd8f0:         // DC2
1:debd8f0:         metadata.updateNormalToken(new StringToken("B"), InetAddress.getByName("127.0.0.4"));
1:debd8f0:         metadata.updateNormalToken(new StringToken("D"), InetAddress.getByName("127.0.0.5"));
1:debd8f0: 
1:125b464:         Map<String, String> configOptions = new HashMap<>();
1:debd8f0:         configOptions.put("DC1", "1");
1:debd8f0:         configOptions.put("DC2", "1");
1:b31845c:         configOptions.put(ReplicationParams.CLASS, "NetworkTopologyStrategy");
1:debd8f0: 
1:0e96e58:         Keyspace.clear("Keyspace1");
1:a89597d:         KeyspaceMetadata meta = KeyspaceMetadata.create("Keyspace1", KeyspaceParams.create(false, configOptions));
1:a89597d:         Schema.instance.setKeyspaceMetadata(meta);
1:125b464: 
1:debd8f0:         Collection<Range<Token>> primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.1"));
1:debd8f0:         assert primaryRanges.size() == 1;
1:debd8f0:         assert primaryRanges.contains(new Range<Token>(new StringToken("D"), new StringToken("A")));
1:debd8f0: 
1:debd8f0:         primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.2"));
1:debd8f0:         assert primaryRanges.size() == 1;
1:debd8f0:         assert primaryRanges.contains(new Range<Token>(new StringToken("B"), new StringToken("C")));
1:c198b76: 
1:debd8f0:         primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.4"));
1:debd8f0:         assert primaryRanges.size() == 1;
1:debd8f0:         assert primaryRanges.contains(new Range<Token>(new StringToken("A"), new StringToken("B")));
1:debd8f0: 
1:debd8f0:         primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.5"));
1:debd8f0:         assert primaryRanges.size() == 1;
1:debd8f0:         assert primaryRanges.contains(new Range<Token>(new StringToken("C"), new StringToken("D")));
1:c198b76:     }
1:debd8f0: 
1:c198b76:     @Test
1:debd8f0:     public void testPrimaryRangesWithNetworkTopologyStrategyOneDCOnly() throws Exception
1:c198b76:     {
1:debd8f0:         TokenMetadata metadata = StorageService.instance.getTokenMetadata();
1:debd8f0:         metadata.clearUnsafe();
1:debd8f0:         // DC1
1:debd8f0:         metadata.updateNormalToken(new StringToken("A"), InetAddress.getByName("127.0.0.1"));
1:debd8f0:         metadata.updateNormalToken(new StringToken("C"), InetAddress.getByName("127.0.0.2"));
1:debd8f0:         // DC2
1:debd8f0:         metadata.updateNormalToken(new StringToken("B"), InetAddress.getByName("127.0.0.4"));
1:debd8f0:         metadata.updateNormalToken(new StringToken("D"), InetAddress.getByName("127.0.0.5"));
1:debd8f0: 
1:125b464:         Map<String, String> configOptions = new HashMap<>();
1:debd8f0:         configOptions.put("DC2", "2");
1:b31845c:         configOptions.put(ReplicationParams.CLASS, "NetworkTopologyStrategy");
1:debd8f0: 
1:0e96e58:         Keyspace.clear("Keyspace1");
1:a89597d:         KeyspaceMetadata meta = KeyspaceMetadata.create("Keyspace1", KeyspaceParams.create(false, configOptions));
1:a89597d:         Schema.instance.setKeyspaceMetadata(meta);
1:debd8f0: 
1:debd8f0:         // endpoints in DC1 should not have primary range
1:debd8f0:         Collection<Range<Token>> primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.1"));
1:debd8f0:         assert primaryRanges.isEmpty();
1:debd8f0: 
1:debd8f0:         primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.2"));
1:debd8f0:         assert primaryRanges.isEmpty();
1:debd8f0: 
1:debd8f0:         // endpoints in DC2 should have primary ranges which also cover DC1
1:debd8f0:         primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.4"));
1:debd8f0:         assert primaryRanges.size() == 2;
1:debd8f0:         assert primaryRanges.contains(new Range<Token>(new StringToken("D"), new StringToken("A")));
1:debd8f0:         assert primaryRanges.contains(new Range<Token>(new StringToken("A"), new StringToken("B")));
1:debd8f0: 
1:debd8f0:         primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.5"));
1:debd8f0:         assert primaryRanges.size() == 2;
1:debd8f0:         assert primaryRanges.contains(new Range<Token>(new StringToken("C"), new StringToken("D")));
1:debd8f0:         assert primaryRanges.contains(new Range<Token>(new StringToken("B"), new StringToken("C")));
1:debd8f0:     }
1:debd8f0: 
1:debd8f0:     @Test
1:125b464:     public void testPrimaryRangeForEndpointWithinDCWithNetworkTopologyStrategyOneDCOnly() throws Exception
1:debd8f0:     {
1:aa7794c:         TokenMetadata metadata = StorageService.instance.getTokenMetadata();
1:aa7794c:         metadata.clearUnsafe();
1:125b464:         // DC1
1:125b464:         metadata.updateNormalToken(new StringToken("A"), InetAddress.getByName("127.0.0.1"));
1:125b464:         metadata.updateNormalToken(new StringToken("C"), InetAddress.getByName("127.0.0.2"));
1:125b464:         // DC2
1:125b464:         metadata.updateNormalToken(new StringToken("B"), InetAddress.getByName("127.0.0.4"));
1:125b464:         metadata.updateNormalToken(new StringToken("D"), InetAddress.getByName("127.0.0.5"));
1:debd8f0: 
1:125b464:         Map<String, String> configOptions = new HashMap<>();
1:125b464:         configOptions.put("DC2", "2");
1:b31845c:         configOptions.put(ReplicationParams.CLASS, "NetworkTopologyStrategy");
1:aa7794c: 
1:0e96e58:         Keyspace.clear("Keyspace1");
1:a89597d:         KeyspaceMetadata meta = KeyspaceMetadata.create("Keyspace1", KeyspaceParams.create(false, configOptions));
1:a89597d:         Schema.instance.setKeyspaceMetadata(meta);
1:aa7794c: 
1:125b464:         // endpoints in DC1 should not have primary range
1:125b464:         Collection<Range<Token>> primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name, InetAddress.getByName("127.0.0.1"));
1:125b464:         assertTrue(primaryRanges.isEmpty());
1:aa7794c: 
1:125b464:         primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name,
1:125b464:                                                                                    InetAddress.getByName("127.0.0.2"));
1:125b464:         assertTrue(primaryRanges.isEmpty());
1:aa7794c: 
1:125b464:         // endpoints in DC2 should have primary ranges which also cover DC1
1:125b464:         primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name, InetAddress.getByName("127.0.0.4"));
1:125b464:         assertTrue(primaryRanges.size() == 2);
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("D"), new StringToken("A"))));
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("A"), new StringToken("B"))));
1:125b464: 
1:125b464:         primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name, InetAddress.getByName("127.0.0.5"));
1:125b464:         assertTrue(primaryRanges.size() == 2);
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("C"), new StringToken("D"))));
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("B"), new StringToken("C"))));
1:debd8f0:     }
1:125b464: 
1:debd8f0:     @Test
1:debd8f0:     public void testPrimaryRangesWithVnodes() throws Exception
1:debd8f0:     {
1:debd8f0:         TokenMetadata metadata = StorageService.instance.getTokenMetadata();
1:debd8f0:         metadata.clearUnsafe();
1:debd8f0:         // DC1
1:debd8f0:         Multimap<InetAddress, Token> dc1 = HashMultimap.create();
1:debd8f0:         dc1.put(InetAddress.getByName("127.0.0.1"), new StringToken("A"));
1:debd8f0:         dc1.put(InetAddress.getByName("127.0.0.1"), new StringToken("E"));
1:debd8f0:         dc1.put(InetAddress.getByName("127.0.0.1"), new StringToken("H"));
1:debd8f0:         dc1.put(InetAddress.getByName("127.0.0.2"), new StringToken("C"));
1:debd8f0:         dc1.put(InetAddress.getByName("127.0.0.2"), new StringToken("I"));
1:debd8f0:         dc1.put(InetAddress.getByName("127.0.0.2"), new StringToken("J"));
1:debd8f0:         metadata.updateNormalTokens(dc1);
1:debd8f0:         // DC2
1:debd8f0:         Multimap<InetAddress, Token> dc2 = HashMultimap.create();
1:debd8f0:         dc2.put(InetAddress.getByName("127.0.0.4"), new StringToken("B"));
1:debd8f0:         dc2.put(InetAddress.getByName("127.0.0.4"), new StringToken("G"));
1:debd8f0:         dc2.put(InetAddress.getByName("127.0.0.4"), new StringToken("L"));
1:debd8f0:         dc2.put(InetAddress.getByName("127.0.0.5"), new StringToken("D"));
1:debd8f0:         dc2.put(InetAddress.getByName("127.0.0.5"), new StringToken("F"));
1:debd8f0:         dc2.put(InetAddress.getByName("127.0.0.5"), new StringToken("K"));
1:debd8f0:         metadata.updateNormalTokens(dc2);
1:debd8f0: 
1:125b464:         Map<String, String> configOptions = new HashMap<>();
1:debd8f0:         configOptions.put("DC2", "2");
1:b31845c:         configOptions.put(ReplicationParams.CLASS, "NetworkTopologyStrategy");
1:debd8f0: 
1:aa7794c:         Keyspace.clear("Keyspace1");
1:a89597d:         KeyspaceMetadata meta = KeyspaceMetadata.create("Keyspace1", KeyspaceParams.create(false, configOptions));
1:a89597d:         Schema.instance.setKeyspaceMetadata(meta);
1:debd8f0: 
1:debd8f0:         // endpoints in DC1 should not have primary range
1:debd8f0:         Collection<Range<Token>> primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.1"));
1:debd8f0:         assert primaryRanges.isEmpty();
1:debd8f0: 
1:debd8f0:         primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.2"));
1:debd8f0:         assert primaryRanges.isEmpty();
1:debd8f0: 
1:debd8f0:         // endpoints in DC2 should have primary ranges which also cover DC1
1:debd8f0:         primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.4"));
1:debd8f0:         assert primaryRanges.size() == 4;
1:debd8f0:         assert primaryRanges.contains(new Range<Token>(new StringToken("A"), new StringToken("B")));
1:debd8f0:         assert primaryRanges.contains(new Range<Token>(new StringToken("F"), new StringToken("G")));
1:debd8f0:         assert primaryRanges.contains(new Range<Token>(new StringToken("K"), new StringToken("L")));
1:debd8f0:         // because /127.0.0.4 holds token "B" which is the next to token "A" from /127.0.0.1,
1:debd8f0:         // the node covers range (L, A]
1:debd8f0:         assert primaryRanges.contains(new Range<Token>(new StringToken("L"), new StringToken("A")));
1:debd8f0: 
1:debd8f0:         primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.5"));
1:debd8f0:         assert primaryRanges.size() == 8;
1:debd8f0:         assert primaryRanges.contains(new Range<Token>(new StringToken("C"), new StringToken("D")));
1:debd8f0:         assert primaryRanges.contains(new Range<Token>(new StringToken("E"), new StringToken("F")));
1:debd8f0:         assert primaryRanges.contains(new Range<Token>(new StringToken("J"), new StringToken("K")));
1:debd8f0:         // ranges from /127.0.0.1
1:debd8f0:         assert primaryRanges.contains(new Range<Token>(new StringToken("D"), new StringToken("E")));
1:debd8f0:         // the next token to "H" in DC2 is "K" in /127.0.0.5, so (G, H] goes to /127.0.0.5
1:debd8f0:         assert primaryRanges.contains(new Range<Token>(new StringToken("G"), new StringToken("H")));
1:debd8f0:         // ranges from /127.0.0.2
1:debd8f0:         assert primaryRanges.contains(new Range<Token>(new StringToken("B"), new StringToken("C")));
1:debd8f0:         assert primaryRanges.contains(new Range<Token>(new StringToken("H"), new StringToken("I")));
1:debd8f0:         assert primaryRanges.contains(new Range<Token>(new StringToken("I"), new StringToken("J")));
1:debd8f0:     }
1:125b464: 
1:debd8f0:     @Test
1:125b464:     public void testPrimaryRangeForEndpointWithinDCWithVnodes() throws Exception
1:aa7794c:     {
1:125b464:         TokenMetadata metadata = StorageService.instance.getTokenMetadata();
1:125b464:         metadata.clearUnsafe();
1:125b464: 
1:125b464:         // DC1
1:125b464:         Multimap<InetAddress, Token> dc1 = HashMultimap.create();
1:125b464:         dc1.put(InetAddress.getByName("127.0.0.1"), new StringToken("A"));
1:125b464:         dc1.put(InetAddress.getByName("127.0.0.1"), new StringToken("E"));
1:125b464:         dc1.put(InetAddress.getByName("127.0.0.1"), new StringToken("H"));
1:125b464:         dc1.put(InetAddress.getByName("127.0.0.2"), new StringToken("C"));
1:125b464:         dc1.put(InetAddress.getByName("127.0.0.2"), new StringToken("I"));
1:125b464:         dc1.put(InetAddress.getByName("127.0.0.2"), new StringToken("J"));
1:125b464:         metadata.updateNormalTokens(dc1);
1:125b464: 
1:125b464:         // DC2
1:125b464:         Multimap<InetAddress, Token> dc2 = HashMultimap.create();
1:125b464:         dc2.put(InetAddress.getByName("127.0.0.4"), new StringToken("B"));
1:125b464:         dc2.put(InetAddress.getByName("127.0.0.4"), new StringToken("G"));
1:125b464:         dc2.put(InetAddress.getByName("127.0.0.4"), new StringToken("L"));
1:125b464:         dc2.put(InetAddress.getByName("127.0.0.5"), new StringToken("D"));
1:125b464:         dc2.put(InetAddress.getByName("127.0.0.5"), new StringToken("F"));
1:125b464:         dc2.put(InetAddress.getByName("127.0.0.5"), new StringToken("K"));
1:125b464:         metadata.updateNormalTokens(dc2);
1:125b464: 
1:125b464:         Map<String, String> configOptions = new HashMap<>();
1:125b464:         configOptions.put("DC1", "1");
1:125b464:         configOptions.put("DC2", "2");
1:b31845c:         configOptions.put(ReplicationParams.CLASS, "NetworkTopologyStrategy");
1:125b464: 
1:125b464:         Keyspace.clear("Keyspace1");
1:a89597d:         KeyspaceMetadata meta = KeyspaceMetadata.create("Keyspace1", KeyspaceParams.create(false, configOptions));
1:a89597d:         Schema.instance.setKeyspaceMetadata(meta);
1:125b464: 
1:125b464:         // endpoints in DC1 should have primary ranges which also cover DC2
1:125b464:         Collection<Range<Token>> primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name, InetAddress.getByName("127.0.0.1"));
1:125b464:         assertEquals(8, primaryRanges.size());
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("J"), new StringToken("K"))));
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("K"), new StringToken("L"))));
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("L"), new StringToken("A"))));
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("C"), new StringToken("D"))));
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("D"), new StringToken("E"))));
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("E"), new StringToken("F"))));
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("F"), new StringToken("G"))));
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("G"), new StringToken("H"))));
1:125b464: 
1:125b464:         // endpoints in DC1 should have primary ranges which also cover DC2
1:125b464:         primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name, InetAddress.getByName("127.0.0.2"));
1:125b464:         assertEquals(4, primaryRanges.size());
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("B"), new StringToken("C"))));
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("A"), new StringToken("B"))));
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("H"), new StringToken("I"))));
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("I"), new StringToken("J"))));
1:125b464: 
1:125b464:         // endpoints in DC2 should have primary ranges which also cover DC1
1:125b464:         primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name, InetAddress.getByName("127.0.0.4"));
1:125b464:         assertEquals(4, primaryRanges.size());
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("A"), new StringToken("B"))));
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("F"), new StringToken("G"))));
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("K"), new StringToken("L"))));
1:125b464:         // because /127.0.0.4 holds token "B" which is the next to token "A" from /127.0.0.1,
1:125b464:         // the node covers range (L, A]
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("L"), new StringToken("A"))));
1:125b464: 
1:125b464:         primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name, InetAddress.getByName("127.0.0.5"));
1:125b464:         assertTrue(primaryRanges.size() == 8);
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("C"), new StringToken("D"))));
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("E"), new StringToken("F"))));
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("J"), new StringToken("K"))));
1:125b464:         // ranges from /127.0.0.1
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("D"), new StringToken("E"))));
1:125b464:         // the next token to "H" in DC2 is "K" in /127.0.0.5, so (G, H] goes to /127.0.0.5
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("G"), new StringToken("H"))));
1:125b464:         // ranges from /127.0.0.2
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("B"), new StringToken("C"))));
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("H"), new StringToken("I"))));
1:125b464:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("I"), new StringToken("J"))));
1:125b464:     }
1:125b464: 
1:aa7794c:     @Test
1:debd8f0:     public void testPrimaryRangesWithSimpleStrategy() throws Exception
1:debd8f0:     {
1:debd8f0:         TokenMetadata metadata = StorageService.instance.getTokenMetadata();
1:debd8f0:         metadata.clearUnsafe();
1:debd8f0: 
1:debd8f0:         metadata.updateNormalToken(new StringToken("A"), InetAddress.getByName("127.0.0.1"));
1:debd8f0:         metadata.updateNormalToken(new StringToken("B"), InetAddress.getByName("127.0.0.2"));
1:debd8f0:         metadata.updateNormalToken(new StringToken("C"), InetAddress.getByName("127.0.0.3"));
1:debd8f0: 
1:125b464:         Keyspace.clear("Keyspace1");
1:a89597d:         KeyspaceMetadata meta = KeyspaceMetadata.create("Keyspace1", KeyspaceParams.simpleTransient(2));
1:a89597d:         Schema.instance.setKeyspaceMetadata(meta);
1:debd8f0: 
1:debd8f0:         Collection<Range<Token>> primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.1"));
1:debd8f0:         assert primaryRanges.size() == 1;
1:debd8f0:         assert primaryRanges.contains(new Range<Token>(new StringToken("C"), new StringToken("A")));
1:debd8f0: 
1:debd8f0:         primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.2"));
1:debd8f0:         assert primaryRanges.size() == 1;
1:debd8f0:         assert primaryRanges.contains(new Range<Token>(new StringToken("A"), new StringToken("B")));
1:debd8f0: 
1:debd8f0:         primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.3"));
1:125b464:         assert primaryRanges.size() == 1;
1:125b464:         assert primaryRanges.contains(new Range<Token>(new StringToken("B"), new StringToken("C")));
1:125b464:     }
1:125b464: 
1:125b464:     /* Does not make much sense to use -local and -pr with simplestrategy, but just to prevent human errors */
1:125b464:     @Test
1:125b464:     public void testPrimaryRangeForEndpointWithinDCWithSimpleStrategy() throws Exception
1:125b464:     {
1:125b464:         TokenMetadata metadata = StorageService.instance.getTokenMetadata();
1:125b464:         metadata.clearUnsafe();
1:125b464: 
1:125b464:         metadata.updateNormalToken(new StringToken("A"), InetAddress.getByName("127.0.0.1"));
1:125b464:         metadata.updateNormalToken(new StringToken("B"), InetAddress.getByName("127.0.0.2"));
1:125b464:         metadata.updateNormalToken(new StringToken("C"), InetAddress.getByName("127.0.0.3"));
1:125b464: 
1:125b464:         Map<String, String> configOptions = new HashMap<>();
1:debd8f0:         configOptions.put("replication_factor", "2");
1:debd8f0: 
1:125b464:         Keyspace.clear("Keyspace1");
1:a89597d:         KeyspaceMetadata meta = KeyspaceMetadata.create("Keyspace1", KeyspaceParams.simpleTransient(2));
1:a89597d:         Schema.instance.setKeyspaceMetadata(meta);
1:125b464: 
1:125b464:         Collection<Range<Token>> primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name, InetAddress.getByName("127.0.0.1"));
1:debd8f0:         assert primaryRanges.size() == 1;
1:125b464:         assert primaryRanges.contains(new Range<Token>(new StringToken("C"), new StringToken("A")));
1:125b464: 
1:125b464:         primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name, InetAddress.getByName("127.0.0.2"));
1:125b464:         assert primaryRanges.size() == 1;
1:125b464:         assert primaryRanges.contains(new Range<Token>(new StringToken("A"), new StringToken("B")));
1:125b464: 
1:125b464:         primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name, InetAddress.getByName("127.0.0.3"));
1:125b464:         assert primaryRanges.size() == 1;
1:debd8f0:         assert primaryRanges.contains(new Range<Token>(new StringToken("B"), new StringToken("C")));
1:debd8f0:     }
1:125b464: 
1:7fd4228:     @Test
1:aa7794c:     public void testCreateRepairRangeFrom() throws Exception
1:360d9b6:     {
1:07893d7:         StorageService.instance.setPartitionerUnsafe(Murmur3Partitioner.instance);
1:aa7794c: 
1:125b464:         TokenMetadata metadata = StorageService.instance.getTokenMetadata();
1:125b464:         metadata.clearUnsafe();
1:4797b40: 
1:aa7794c:         metadata.updateNormalToken(new LongToken(1000L), InetAddress.getByName("127.0.0.1"));
1:aa7794c:         metadata.updateNormalToken(new LongToken(2000L), InetAddress.getByName("127.0.0.2"));
1:aa7794c:         metadata.updateNormalToken(new LongToken(3000L), InetAddress.getByName("127.0.0.3"));
1:aa7794c:         metadata.updateNormalToken(new LongToken(4000L), InetAddress.getByName("127.0.0.4"));
1:aa7794c: 
1:aa7794c:         Collection<Range<Token>> repairRangeFrom = StorageService.instance.createRepairRangeFrom("1500", "3700");
1:aa7794c:         assert repairRangeFrom.size() == 3;
1:aa7794c:         assert repairRangeFrom.contains(new Range<Token>(new LongToken(1500L), new LongToken(2000L)));
1:aa7794c:         assert repairRangeFrom.contains(new Range<Token>(new LongToken(2000L), new LongToken(3000L)));
1:aa7794c:         assert repairRangeFrom.contains(new Range<Token>(new LongToken(3000L), new LongToken(3700L)));
1:aa7794c: 
1:aa7794c:         repairRangeFrom = StorageService.instance.createRepairRangeFrom("500", "700");
1:aa7794c:         assert repairRangeFrom.size() == 1;
1:aa7794c:         assert repairRangeFrom.contains(new Range<Token>(new LongToken(500L), new LongToken(700L)));
1:aa7794c: 
1:aa7794c:         repairRangeFrom = StorageService.instance.createRepairRangeFrom("500", "1700");
1:aa7794c:         assert repairRangeFrom.size() == 2;
1:aa7794c:         assert repairRangeFrom.contains(new Range<Token>(new LongToken(500L), new LongToken(1000L)));
1:aa7794c:         assert repairRangeFrom.contains(new Range<Token>(new LongToken(1000L), new LongToken(1700L)));
1:aa7794c: 
1:aa7794c:         repairRangeFrom = StorageService.instance.createRepairRangeFrom("2500", "2300");
1:aa7794c:         assert repairRangeFrom.size() == 5;
1:aa7794c:         assert repairRangeFrom.contains(new Range<Token>(new LongToken(2500L), new LongToken(3000L)));
1:aa7794c:         assert repairRangeFrom.contains(new Range<Token>(new LongToken(3000L), new LongToken(4000L)));
1:aa7794c:         assert repairRangeFrom.contains(new Range<Token>(new LongToken(4000L), new LongToken(1000L)));
1:aa7794c:         assert repairRangeFrom.contains(new Range<Token>(new LongToken(1000L), new LongToken(2000L)));
1:aa7794c:         assert repairRangeFrom.contains(new Range<Token>(new LongToken(2000L), new LongToken(2300L)));
1:aa7794c: 
1:aa7794c:         repairRangeFrom = StorageService.instance.createRepairRangeFrom("2000", "3000");
1:aa7794c:         assert repairRangeFrom.size() == 1;
1:aa7794c:         assert repairRangeFrom.contains(new Range<Token>(new LongToken(2000L), new LongToken(3000L)));
1:aa7794c: 
1:aa7794c:         repairRangeFrom = StorageService.instance.createRepairRangeFrom("2000", "2000");
1:aa7794c:         assert repairRangeFrom.size() == 0;
1:aa7794c:     }
1:125b464: }
============================================================================
author:Robert Stupp
-------------------------------------------------------------------------------
commit:9797511
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.SchemaConstants;
/////////////////////////////////////////////////////////////////////////
1:         DatabaseDescriptor.daemonInitialization();
/////////////////////////////////////////////////////////////////////////
1:         StorageService.instance.takeTableSnapshot(SchemaConstants.SCHEMA_KEYSPACE_NAME, SchemaKeyspace.KEYSPACES, UUID.randomUUID().toString());
1:         StorageService.instance.takeSnapshot(UUID.randomUUID().toString(), SchemaConstants.SCHEMA_KEYSPACE_NAME);
commit:54836ec
/////////////////////////////////////////////////////////////////////////
1:         assumeTrue(FBUtilities.isWindows);
author:anubhavkale
-------------------------------------------------------------------------------
commit:ee9e38b
/////////////////////////////////////////////////////////////////////////
1:     public void testSnapshotWithFlush() throws IOException
1:         StorageService.instance.takeSnapshot(UUID.randomUUID().toString());
/////////////////////////////////////////////////////////////////////////
0:         StorageService.instance.takeTableSnapshot(SchemaKeyspace.NAME, SchemaKeyspace.KEYSPACES, UUID.randomUUID().toString());
1:     }
1: 
1:     @Test
1:     public void testSnapshot() throws IOException
1:     {
1:         // no need to insert extra data, even an "empty" database will have a little information in the system keyspace
0:         StorageService.instance.takeSnapshot(UUID.randomUUID().toString(), SchemaKeyspace.NAME);
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:b31845c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.schema.ReplicationParams;
/////////////////////////////////////////////////////////////////////////
1:         configOptions.put(ReplicationParams.CLASS, "NetworkTopologyStrategy");
/////////////////////////////////////////////////////////////////////////
1:         configOptions.put(ReplicationParams.CLASS, "NetworkTopologyStrategy");
/////////////////////////////////////////////////////////////////////////
1:         configOptions.put(ReplicationParams.CLASS, "NetworkTopologyStrategy");
/////////////////////////////////////////////////////////////////////////
1:         configOptions.put(ReplicationParams.CLASS, "NetworkTopologyStrategy");
/////////////////////////////////////////////////////////////////////////
1:         configOptions.put(ReplicationParams.CLASS, "NetworkTopologyStrategy");
/////////////////////////////////////////////////////////////////////////
1:         configOptions.put(ReplicationParams.CLASS, "NetworkTopologyStrategy");
commit:7d6c876
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.schema.SchemaKeyspace;
/////////////////////////////////////////////////////////////////////////
0:         StorageService.instance.takeColumnFamilySnapshot(SchemaKeyspace.NAME, SchemaKeyspace.KEYSPACES, "cf_snapshot");
commit:a89597d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.schema.KeyspaceMetadata;
/////////////////////////////////////////////////////////////////////////
1:         KeyspaceMetadata meta = KeyspaceMetadata.create("Keyspace1", KeyspaceParams.create(false, configOptions));
1:         Schema.instance.setKeyspaceMetadata(meta);
/////////////////////////////////////////////////////////////////////////
1:         KeyspaceMetadata meta = KeyspaceMetadata.create("Keyspace1", KeyspaceParams.create(false, configOptions));
1:         Schema.instance.setKeyspaceMetadata(meta);
/////////////////////////////////////////////////////////////////////////
1:         KeyspaceMetadata meta = KeyspaceMetadata.create("Keyspace1", KeyspaceParams.create(false, configOptions));
1:         Schema.instance.setKeyspaceMetadata(meta);
/////////////////////////////////////////////////////////////////////////
1:         KeyspaceMetadata meta = KeyspaceMetadata.create("Keyspace1", KeyspaceParams.create(false, configOptions));
1:         Schema.instance.setKeyspaceMetadata(meta);
/////////////////////////////////////////////////////////////////////////
1:         KeyspaceMetadata meta = KeyspaceMetadata.create("Keyspace1", KeyspaceParams.create(false, configOptions));
1:         Schema.instance.setKeyspaceMetadata(meta);
/////////////////////////////////////////////////////////////////////////
1:         KeyspaceMetadata meta = KeyspaceMetadata.create("Keyspace1", KeyspaceParams.create(false, configOptions));
1:         Schema.instance.setKeyspaceMetadata(meta);
/////////////////////////////////////////////////////////////////////////
1:         KeyspaceMetadata meta = KeyspaceMetadata.create("Keyspace1", KeyspaceParams.simpleTransient(2));
1:         Schema.instance.setKeyspaceMetadata(meta);
/////////////////////////////////////////////////////////////////////////
1:         KeyspaceMetadata meta = KeyspaceMetadata.create("Keyspace1", KeyspaceParams.simpleTransient(2));
1:         Schema.instance.setKeyspaceMetadata(meta);
commit:31e3f61
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.schema.KeyspaceParams;
/////////////////////////////////////////////////////////////////////////
0:         configOptions.put(KeyspaceParams.Replication.CLASS, "NetworkTopologyStrategy");
0:         KSMetaData meta = KSMetaData.create("Keyspace1", KeyspaceParams.create(false, configOptions));
/////////////////////////////////////////////////////////////////////////
0:         configOptions.put(KeyspaceParams.Replication.CLASS, "NetworkTopologyStrategy");
0:         KSMetaData meta = KSMetaData.create("Keyspace1", KeyspaceParams.create(false, configOptions));
/////////////////////////////////////////////////////////////////////////
0:         configOptions.put(KeyspaceParams.Replication.CLASS, "NetworkTopologyStrategy");
0:         KSMetaData meta = KSMetaData.create("Keyspace1", KeyspaceParams.create(false, configOptions));
/////////////////////////////////////////////////////////////////////////
0:         configOptions.put(KeyspaceParams.Replication.CLASS, "NetworkTopologyStrategy");
0:         KSMetaData meta = KSMetaData.create("Keyspace1", KeyspaceParams.create(false, configOptions));
/////////////////////////////////////////////////////////////////////////
0:         configOptions.put(KeyspaceParams.Replication.CLASS, "NetworkTopologyStrategy");
0:         KSMetaData meta = KSMetaData.create("Keyspace1", KeyspaceParams.create(false, configOptions));
/////////////////////////////////////////////////////////////////////////
0:         configOptions.put(KeyspaceParams.Replication.CLASS, "NetworkTopologyStrategy");
0:         KSMetaData meta = KSMetaData.create("Keyspace1", KeyspaceParams.create(false, configOptions));
/////////////////////////////////////////////////////////////////////////
0:         KSMetaData meta = KSMetaData.create("Keyspace1", KeyspaceParams.simpleTransient(2));
/////////////////////////////////////////////////////////////////////////
0:         KSMetaData meta = KSMetaData.create("Keyspace1", KeyspaceParams.simpleTransient(2));
commit:3e9d345
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.schema.LegacySchemaTables;
/////////////////////////////////////////////////////////////////////////
0:         StorageService.instance.takeColumnFamilySnapshot(SystemKeyspace.NAME, LegacySchemaTables.KEYSPACES, "cf_snapshot");
commit:611d1ba
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         StorageService.instance.takeColumnFamilySnapshot(SystemKeyspace.NAME, SystemKeyspace.SCHEMA_KEYSPACES_TABLE, "cf_snapshot");
commit:0e96e58
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.Keyspace;
0: import org.apache.cassandra.db.SystemKeyspace;
1: import org.apache.cassandra.exceptions.ConfigurationException;
/////////////////////////////////////////////////////////////////////////
0:         StorageService.instance.takeColumnFamilySnapshot(Keyspace.SYSTEM_KS, SystemKeyspace.SCHEMA_KEYSPACES_CF, "cf_snapshot");
/////////////////////////////////////////////////////////////////////////
1:         Keyspace.clear("Keyspace1");
0:         Schema.instance.setKeyspaceDefinition(meta);
/////////////////////////////////////////////////////////////////////////
1:         Keyspace.clear("Keyspace1");
0:         Schema.instance.setKeyspaceDefinition(meta);
/////////////////////////////////////////////////////////////////////////
1:         Keyspace.clear("Keyspace1");
0:         Schema.instance.setKeyspaceDefinition(meta);
/////////////////////////////////////////////////////////////////////////
1:         Keyspace.clear("Keyspace1");
0:         Schema.instance.setKeyspaceDefinition(meta);
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:0bd5170
/////////////////////////////////////////////////////////////////////////
1:     public void testTableSnapshot() throws IOException
0:         StorageService.instance.takeTableSnapshot(SchemaKeyspace.NAME, SchemaKeyspace.KEYSPACES, "cf_snapshot");
author:Joshua McKenzie
-------------------------------------------------------------------------------
commit:036ddaf
commit:b7ae07e
/////////////////////////////////////////////////////////////////////////
1: import java.io.FileWriter;
1: import java.io.PrintWriter;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.WindowsFailedSnapshotTracker;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.schema.LegacySchemaTables;
1: import org.apache.cassandra.utils.FBUtilities;
1: import static org.junit.Assume.assumeTrue;
/////////////////////////////////////////////////////////////////////////
1:     private void checkTempFilePresence(File f, boolean exist)
1:     {
1:         for (int i = 0; i < 5; i++)
1:         {
1:             File subdir = new File(f, Integer.toString(i));
1:             subdir.mkdir();
1:             for (int j = 0; j < 5; j++)
1:             {
1:                 File subF = new File(subdir, Integer.toString(j));
1:                 assert(exist ? subF.exists() : !subF.exists());
1:             }
1:         }
1:     }
1: 
1:     @Test
1:     public void testSnapshotFailureHandler() throws IOException
1:     {
0:         assumeTrue(FBUtilities.isWindows());
1: 
1:         // Initial "run" of Cassandra, nothing in failed snapshot file
1:         WindowsFailedSnapshotTracker.deleteOldSnapshots();
1: 
1:         File f = new File(System.getenv("TEMP") + File.separator + Integer.toString(new Random().nextInt()));
1:         f.mkdir();
1:         f.deleteOnExit();
1:         for (int i = 0; i < 5; i++)
1:         {
1:             File subdir = new File(f, Integer.toString(i));
1:             subdir.mkdir();
1:             for (int j = 0; j < 5; j++)
1:                 new File(subdir, Integer.toString(j)).createNewFile();
1:         }
1: 
1:         checkTempFilePresence(f, true);
1: 
1:         // Confirm deletion is recursive
1:         for (int i = 0; i < 5; i++)
1:             WindowsFailedSnapshotTracker.handleFailedSnapshot(new File(f, Integer.toString(i)));
1: 
1:         assert new File(WindowsFailedSnapshotTracker.TODELETEFILE).exists();
1: 
1:         // Simulate shutdown and restart of C* node, closing out the list of failed snapshots.
1:         WindowsFailedSnapshotTracker.resetForTests();
1: 
1:         // Perform new run, mimicking behavior of C* at startup
1:         WindowsFailedSnapshotTracker.deleteOldSnapshots();
1:         checkTempFilePresence(f, false);
1: 
1:         // Check to make sure we don't delete non-temp, non-datafile locations
1:         WindowsFailedSnapshotTracker.resetForTests();
1:         PrintWriter tempPrinter = new PrintWriter(new FileWriter(WindowsFailedSnapshotTracker.TODELETEFILE, true));
1:         tempPrinter.println(".safeDir");
1:         tempPrinter.close();
1: 
1:         File protectedDir = new File(".safeDir");
1:         protectedDir.mkdir();
1:         File protectedFile = new File(protectedDir, ".safeFile");
1:         protectedFile.createNewFile();
1: 
1:         WindowsFailedSnapshotTracker.handleFailedSnapshot(protectedDir);
1:         WindowsFailedSnapshotTracker.deleteOldSnapshots();
1: 
1:         assert protectedDir.exists();
1:         assert protectedFile.exists();
1: 
1:         protectedFile.delete();
1:         protectedDir.delete();
1:     }
1: 
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.dht.OrderPreservingPartitioner.StringToken;
1: import org.apache.cassandra.dht.Range;
1: import org.apache.cassandra.dht.Token;
0: import org.apache.cassandra.schema.LegacySchemaTables;
commit:3a2faf9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.exceptions.ConfigurationException;
commit:438acfc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.SchemaLoader;
/////////////////////////////////////////////////////////////////////////
1:         SchemaLoader.mkdirs();
1:         SchemaLoader.cleanup();
commit:a15c35b
/////////////////////////////////////////////////////////////////////////
author:Dave Brosius
-------------------------------------------------------------------------------
commit:ca41972
/////////////////////////////////////////////////////////////////////////
commit:9639f95
/////////////////////////////////////////////////////////////////////////
1:     public void testRegularMode() throws ConfigurationException
commit:c198b76
/////////////////////////////////////////////////////////////////////////
1:     
1:     @Test
0:     public void testGetOperationMode()
1:     {
0:     	String operationMode = StorageService.instance.getOperationMode();
0:     	assert operationMode.equals("STARTING");
1:     }
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:07893d7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.dht.OrderPreservingPartitioner.StringToken;
1: import org.apache.cassandra.dht.Murmur3Partitioner;
1: import org.apache.cassandra.dht.Murmur3Partitioner.LongToken;
/////////////////////////////////////////////////////////////////////////
1:         StorageService.instance.setPartitionerUnsafe(Murmur3Partitioner.instance);
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:42230c8
commit:47724e6
/////////////////////////////////////////////////////////////////////////
commit:debd8f0
/////////////////////////////////////////////////////////////////////////
1: import java.net.InetAddress;
1: import java.util.*;
1: import com.google.common.collect.HashMultimap;
1: import com.google.common.collect.Multimap;
1: import org.junit.BeforeClass;
0: import org.apache.cassandra.config.KSMetaData;
1: import org.apache.cassandra.config.Schema;
0: import org.apache.cassandra.dht.Range;
0: import org.apache.cassandra.dht.StringToken;
1: import org.apache.cassandra.locator.IEndpointSnitch;
1: import org.apache.cassandra.locator.PropertyFileSnitch;
1: import org.apache.cassandra.locator.TokenMetadata;
/////////////////////////////////////////////////////////////////////////
1:     @BeforeClass
1:     public static void setUp() throws ConfigurationException
1:     {
1:         IEndpointSnitch snitch = new PropertyFileSnitch();
1:         DatabaseDescriptor.setEndpointSnitch(snitch);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void testPrimaryRangesWithNetworkTopologyStrategy() throws Exception
1:     {
1:         TokenMetadata metadata = StorageService.instance.getTokenMetadata();
1:         metadata.clearUnsafe();
1:         // DC1
1:         metadata.updateNormalToken(new StringToken("A"), InetAddress.getByName("127.0.0.1"));
1:         metadata.updateNormalToken(new StringToken("C"), InetAddress.getByName("127.0.0.2"));
1:         // DC2
1:         metadata.updateNormalToken(new StringToken("B"), InetAddress.getByName("127.0.0.4"));
1:         metadata.updateNormalToken(new StringToken("D"), InetAddress.getByName("127.0.0.5"));
1: 
0:         Map<String, String> configOptions = new HashMap<String, String>();
1:         configOptions.put("DC1", "1");
1:         configOptions.put("DC2", "1");
1: 
0:         Table.clear("Keyspace1");
0:         KSMetaData meta = KSMetaData.newKeyspace("Keyspace1", "NetworkTopologyStrategy", configOptions, false);
0:         Schema.instance.setTableDefinition(meta);
1: 
1:         Collection<Range<Token>> primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.1"));
1:         assert primaryRanges.size() == 1;
1:         assert primaryRanges.contains(new Range<Token>(new StringToken("D"), new StringToken("A")));
1: 
1:         primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.2"));
1:         assert primaryRanges.size() == 1;
1:         assert primaryRanges.contains(new Range<Token>(new StringToken("B"), new StringToken("C")));
1: 
1:         primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.4"));
1:         assert primaryRanges.size() == 1;
1:         assert primaryRanges.contains(new Range<Token>(new StringToken("A"), new StringToken("B")));
1: 
1:         primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.5"));
1:         assert primaryRanges.size() == 1;
1:         assert primaryRanges.contains(new Range<Token>(new StringToken("C"), new StringToken("D")));
1:     }
1: 
1:     @Test
1:     public void testPrimaryRangesWithNetworkTopologyStrategyOneDCOnly() throws Exception
1:     {
1:         TokenMetadata metadata = StorageService.instance.getTokenMetadata();
1:         metadata.clearUnsafe();
1:         // DC1
1:         metadata.updateNormalToken(new StringToken("A"), InetAddress.getByName("127.0.0.1"));
1:         metadata.updateNormalToken(new StringToken("C"), InetAddress.getByName("127.0.0.2"));
1:         // DC2
1:         metadata.updateNormalToken(new StringToken("B"), InetAddress.getByName("127.0.0.4"));
1:         metadata.updateNormalToken(new StringToken("D"), InetAddress.getByName("127.0.0.5"));
1: 
0:         Map<String, String> configOptions = new HashMap<String, String>();
1:         configOptions.put("DC2", "2");
1: 
0:         Table.clear("Keyspace1");
0:         KSMetaData meta = KSMetaData.newKeyspace("Keyspace1", "NetworkTopologyStrategy", configOptions, false);
0:         Schema.instance.setTableDefinition(meta);
1: 
1:         // endpoints in DC1 should not have primary range
1:         Collection<Range<Token>> primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.1"));
1:         assert primaryRanges.isEmpty();
1: 
1:         primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.2"));
1:         assert primaryRanges.isEmpty();
1: 
1:         // endpoints in DC2 should have primary ranges which also cover DC1
1:         primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.4"));
1:         assert primaryRanges.size() == 2;
1:         assert primaryRanges.contains(new Range<Token>(new StringToken("D"), new StringToken("A")));
1:         assert primaryRanges.contains(new Range<Token>(new StringToken("A"), new StringToken("B")));
1: 
1:         primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.5"));
1:         assert primaryRanges.size() == 2;
1:         assert primaryRanges.contains(new Range<Token>(new StringToken("C"), new StringToken("D")));
1:         assert primaryRanges.contains(new Range<Token>(new StringToken("B"), new StringToken("C")));
1:     }
1: 
1:     @Test
1:     public void testPrimaryRangesWithVnodes() throws Exception
1:     {
1:         TokenMetadata metadata = StorageService.instance.getTokenMetadata();
1:         metadata.clearUnsafe();
1:         // DC1
1:         Multimap<InetAddress, Token> dc1 = HashMultimap.create();
1:         dc1.put(InetAddress.getByName("127.0.0.1"), new StringToken("A"));
1:         dc1.put(InetAddress.getByName("127.0.0.1"), new StringToken("E"));
1:         dc1.put(InetAddress.getByName("127.0.0.1"), new StringToken("H"));
1:         dc1.put(InetAddress.getByName("127.0.0.2"), new StringToken("C"));
1:         dc1.put(InetAddress.getByName("127.0.0.2"), new StringToken("I"));
1:         dc1.put(InetAddress.getByName("127.0.0.2"), new StringToken("J"));
1:         metadata.updateNormalTokens(dc1);
1:         // DC2
1:         Multimap<InetAddress, Token> dc2 = HashMultimap.create();
1:         dc2.put(InetAddress.getByName("127.0.0.4"), new StringToken("B"));
1:         dc2.put(InetAddress.getByName("127.0.0.4"), new StringToken("G"));
1:         dc2.put(InetAddress.getByName("127.0.0.4"), new StringToken("L"));
1:         dc2.put(InetAddress.getByName("127.0.0.5"), new StringToken("D"));
1:         dc2.put(InetAddress.getByName("127.0.0.5"), new StringToken("F"));
1:         dc2.put(InetAddress.getByName("127.0.0.5"), new StringToken("K"));
1:         metadata.updateNormalTokens(dc2);
1: 
0:         Map<String, String> configOptions = new HashMap<String, String>();
1:         configOptions.put("DC2", "2");
1: 
0:         Table.clear("Keyspace1");
0:         KSMetaData meta = KSMetaData.newKeyspace("Keyspace1", "NetworkTopologyStrategy", configOptions, false);
0:         Schema.instance.setTableDefinition(meta);
1: 
1:         // endpoints in DC1 should not have primary range
1:         Collection<Range<Token>> primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.1"));
1:         assert primaryRanges.isEmpty();
1: 
1:         primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.2"));
1:         assert primaryRanges.isEmpty();
1: 
1:         // endpoints in DC2 should have primary ranges which also cover DC1
1:         primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.4"));
1:         assert primaryRanges.size() == 4;
1:         assert primaryRanges.contains(new Range<Token>(new StringToken("A"), new StringToken("B")));
1:         assert primaryRanges.contains(new Range<Token>(new StringToken("F"), new StringToken("G")));
1:         assert primaryRanges.contains(new Range<Token>(new StringToken("K"), new StringToken("L")));
1:         // because /127.0.0.4 holds token "B" which is the next to token "A" from /127.0.0.1,
1:         // the node covers range (L, A]
1:         assert primaryRanges.contains(new Range<Token>(new StringToken("L"), new StringToken("A")));
1: 
1:         primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.5"));
1:         assert primaryRanges.size() == 8;
1:         assert primaryRanges.contains(new Range<Token>(new StringToken("C"), new StringToken("D")));
1:         assert primaryRanges.contains(new Range<Token>(new StringToken("E"), new StringToken("F")));
1:         assert primaryRanges.contains(new Range<Token>(new StringToken("J"), new StringToken("K")));
1:         // ranges from /127.0.0.1
1:         assert primaryRanges.contains(new Range<Token>(new StringToken("D"), new StringToken("E")));
1:         // the next token to "H" in DC2 is "K" in /127.0.0.5, so (G, H] goes to /127.0.0.5
1:         assert primaryRanges.contains(new Range<Token>(new StringToken("G"), new StringToken("H")));
1:         // ranges from /127.0.0.2
1:         assert primaryRanges.contains(new Range<Token>(new StringToken("B"), new StringToken("C")));
1:         assert primaryRanges.contains(new Range<Token>(new StringToken("H"), new StringToken("I")));
1:         assert primaryRanges.contains(new Range<Token>(new StringToken("I"), new StringToken("J")));
1:     }
1:     @Test
1:     public void testPrimaryRangesWithSimpleStrategy() throws Exception
1:     {
1:         TokenMetadata metadata = StorageService.instance.getTokenMetadata();
1:         metadata.clearUnsafe();
1: 
1:         metadata.updateNormalToken(new StringToken("A"), InetAddress.getByName("127.0.0.1"));
1:         metadata.updateNormalToken(new StringToken("B"), InetAddress.getByName("127.0.0.2"));
1:         metadata.updateNormalToken(new StringToken("C"), InetAddress.getByName("127.0.0.3"));
1: 
0:         Map<String, String> configOptions = new HashMap<String, String>();
1:         configOptions.put("replication_factor", "2");
1: 
0:         Table.clear("Keyspace1");
0:         KSMetaData meta = KSMetaData.newKeyspace("Keyspace1", "SimpleStrategy", configOptions, false);
0:         Schema.instance.setTableDefinition(meta);
1: 
1:         Collection<Range<Token>> primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.1"));
1:         assert primaryRanges.size() == 1;
1:         assert primaryRanges.contains(new Range<Token>(new StringToken("C"), new StringToken("A")));
1: 
1:         primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.2"));
1:         assert primaryRanges.size() == 1;
1:         assert primaryRanges.contains(new Range<Token>(new StringToken("A"), new StringToken("B")));
1: 
1:         primaryRanges = StorageService.instance.getPrimaryRangesForEndpoint(meta.name, InetAddress.getByName("127.0.0.3"));
1:         assert primaryRanges.size() == 1;
1:         assert primaryRanges.contains(new Range<Token>(new StringToken("B"), new StringToken("C")));
1:     }
author:Jimmy M?rdell
-------------------------------------------------------------------------------
commit:aa7794c
/////////////////////////////////////////////////////////////////////////
1: 
0: import org.apache.cassandra.dht.BigIntegerToken;
0: import org.apache.cassandra.dht.LongToken;
0: import org.apache.cassandra.dht.Murmur3Partitioner;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test
1:     public void testCreateRepairRangeFrom() throws Exception
1:     {
0:         StorageService.instance.setPartitionerUnsafe(new Murmur3Partitioner());
1: 
1:         TokenMetadata metadata = StorageService.instance.getTokenMetadata();
1:         metadata.clearUnsafe();
1: 
1:         metadata.updateNormalToken(new LongToken(1000L), InetAddress.getByName("127.0.0.1"));
1:         metadata.updateNormalToken(new LongToken(2000L), InetAddress.getByName("127.0.0.2"));
1:         metadata.updateNormalToken(new LongToken(3000L), InetAddress.getByName("127.0.0.3"));
1:         metadata.updateNormalToken(new LongToken(4000L), InetAddress.getByName("127.0.0.4"));
1: 
0:         Map<String, String> configOptions = new HashMap<String, String>();
0:         configOptions.put("replication_factor", "3");
1: 
1:         Keyspace.clear("Keyspace1");
0:         KSMetaData meta = KSMetaData.newKeyspace("Keyspace1", "SimpleStrategy", configOptions, false);
0:         Schema.instance.setKeyspaceDefinition(meta);
1: 
1:         Collection<Range<Token>> repairRangeFrom = StorageService.instance.createRepairRangeFrom("1500", "3700");
1:         assert repairRangeFrom.size() == 3;
1:         assert repairRangeFrom.contains(new Range<Token>(new LongToken(1500L), new LongToken(2000L)));
1:         assert repairRangeFrom.contains(new Range<Token>(new LongToken(2000L), new LongToken(3000L)));
1:         assert repairRangeFrom.contains(new Range<Token>(new LongToken(3000L), new LongToken(3700L)));
1: 
1:         repairRangeFrom = StorageService.instance.createRepairRangeFrom("500", "700");
1:         assert repairRangeFrom.size() == 1;
1:         assert repairRangeFrom.contains(new Range<Token>(new LongToken(500L), new LongToken(700L)));
1: 
1:         repairRangeFrom = StorageService.instance.createRepairRangeFrom("500", "1700");
1:         assert repairRangeFrom.size() == 2;
1:         assert repairRangeFrom.contains(new Range<Token>(new LongToken(500L), new LongToken(1000L)));
1:         assert repairRangeFrom.contains(new Range<Token>(new LongToken(1000L), new LongToken(1700L)));
1: 
1:         repairRangeFrom = StorageService.instance.createRepairRangeFrom("2500", "2300");
1:         assert repairRangeFrom.size() == 5;
1:         assert repairRangeFrom.contains(new Range<Token>(new LongToken(2500L), new LongToken(3000L)));
1:         assert repairRangeFrom.contains(new Range<Token>(new LongToken(3000L), new LongToken(4000L)));
1:         assert repairRangeFrom.contains(new Range<Token>(new LongToken(4000L), new LongToken(1000L)));
1:         assert repairRangeFrom.contains(new Range<Token>(new LongToken(1000L), new LongToken(2000L)));
1:         assert repairRangeFrom.contains(new Range<Token>(new LongToken(2000L), new LongToken(2300L)));
1: 
1:         repairRangeFrom = StorageService.instance.createRepairRangeFrom("2000", "3000");
1:         assert repairRangeFrom.size() == 1;
1:         assert repairRangeFrom.contains(new Range<Token>(new LongToken(2000L), new LongToken(3000L)));
1: 
1:         repairRangeFrom = StorageService.instance.createRepairRangeFrom("2000", "2000");
1:         assert repairRangeFrom.size() == 0;
1:     }
author:Paulo Motta
-------------------------------------------------------------------------------
commit:125b464
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.SchemaLoader;
1: import org.apache.cassandra.config.DatabaseDescriptor;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(Collections.<Range<Token>>emptyList(), StorageService.instance.getAllRanges(toks));
0:         StorageService.instance.takeSnapshot("snapshot");
/////////////////////////////////////////////////////////////////////////
1:     public void testPrimaryRangeForEndpointWithinDCWithNetworkTopologyStrategy() throws Exception
1:     {
1:         TokenMetadata metadata = StorageService.instance.getTokenMetadata();
1:         metadata.clearUnsafe();
1: 
1:         // DC1
1:         metadata.updateNormalToken(new StringToken("A"), InetAddress.getByName("127.0.0.1"));
1:         metadata.updateNormalToken(new StringToken("C"), InetAddress.getByName("127.0.0.2"));
1: 
1:         // DC2
1:         metadata.updateNormalToken(new StringToken("B"), InetAddress.getByName("127.0.0.4"));
1:         metadata.updateNormalToken(new StringToken("D"), InetAddress.getByName("127.0.0.5"));
1: 
1:         Map<String, String> configOptions = new HashMap<>();
1:         configOptions.put("DC1", "1");
1:         configOptions.put("DC2", "1");
1: 
1:         Keyspace.clear("Keyspace1");
0:         KSMetaData meta = KSMetaData.newKeyspace("Keyspace1", "NetworkTopologyStrategy", configOptions, false);
0:         Schema.instance.setKeyspaceDefinition(meta);
1: 
1:         Collection<Range<Token>> primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name,
1:                                                                                                             InetAddress.getByName("127.0.0.1"));
1:         assertEquals(2, primaryRanges.size());
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("D"), new StringToken("A"))));
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("C"), new StringToken("D"))));
1: 
1:         primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name, InetAddress.getByName("127.0.0.2"));
1:         assertEquals(2, primaryRanges.size());
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("A"), new StringToken("B"))));
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("B"), new StringToken("C"))));
1: 
1:         primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name, InetAddress.getByName("127.0.0.4"));
1:         assertEquals(2, primaryRanges.size());
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("D"), new StringToken("A"))));
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("A"), new StringToken("B"))));
1: 
1:         primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name, InetAddress.getByName("127.0.0.5"));
1:         assertEquals(2, primaryRanges.size());
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("B"), new StringToken("C"))));
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("C"), new StringToken("D"))));
1:     }
1: 
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:         Map<String, String> configOptions = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1:         Map<String, String> configOptions = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1:     public void testPrimaryRangeForEndpointWithinDCWithNetworkTopologyStrategyOneDCOnly() throws Exception
1:     {
1:         TokenMetadata metadata = StorageService.instance.getTokenMetadata();
1:         metadata.clearUnsafe();
1:         // DC1
1:         metadata.updateNormalToken(new StringToken("A"), InetAddress.getByName("127.0.0.1"));
1:         metadata.updateNormalToken(new StringToken("C"), InetAddress.getByName("127.0.0.2"));
1:         // DC2
1:         metadata.updateNormalToken(new StringToken("B"), InetAddress.getByName("127.0.0.4"));
1:         metadata.updateNormalToken(new StringToken("D"), InetAddress.getByName("127.0.0.5"));
1: 
1:         Map<String, String> configOptions = new HashMap<>();
1:         configOptions.put("DC2", "2");
1: 
1:         Keyspace.clear("Keyspace1");
0:         KSMetaData meta = KSMetaData.newKeyspace("Keyspace1", "NetworkTopologyStrategy", configOptions, false);
0:         Schema.instance.setKeyspaceDefinition(meta);
1: 
1:         // endpoints in DC1 should not have primary range
1:         Collection<Range<Token>> primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name, InetAddress.getByName("127.0.0.1"));
1:         assertTrue(primaryRanges.isEmpty());
1: 
1:         primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name,
1:                                                                                    InetAddress.getByName("127.0.0.2"));
1:         assertTrue(primaryRanges.isEmpty());
1: 
1:         // endpoints in DC2 should have primary ranges which also cover DC1
1:         primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name, InetAddress.getByName("127.0.0.4"));
1:         assertTrue(primaryRanges.size() == 2);
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("D"), new StringToken("A"))));
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("A"), new StringToken("B"))));
1: 
1:         primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name, InetAddress.getByName("127.0.0.5"));
1:         assertTrue(primaryRanges.size() == 2);
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("C"), new StringToken("D"))));
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("B"), new StringToken("C"))));
1:     }
1: 
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:         Map<String, String> configOptions = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test
1:     public void testPrimaryRangeForEndpointWithinDCWithVnodes() throws Exception
1:     {
1:         TokenMetadata metadata = StorageService.instance.getTokenMetadata();
1:         metadata.clearUnsafe();
1: 
1:         // DC1
1:         Multimap<InetAddress, Token> dc1 = HashMultimap.create();
1:         dc1.put(InetAddress.getByName("127.0.0.1"), new StringToken("A"));
1:         dc1.put(InetAddress.getByName("127.0.0.1"), new StringToken("E"));
1:         dc1.put(InetAddress.getByName("127.0.0.1"), new StringToken("H"));
1:         dc1.put(InetAddress.getByName("127.0.0.2"), new StringToken("C"));
1:         dc1.put(InetAddress.getByName("127.0.0.2"), new StringToken("I"));
1:         dc1.put(InetAddress.getByName("127.0.0.2"), new StringToken("J"));
1:         metadata.updateNormalTokens(dc1);
1: 
1:         // DC2
1:         Multimap<InetAddress, Token> dc2 = HashMultimap.create();
1:         dc2.put(InetAddress.getByName("127.0.0.4"), new StringToken("B"));
1:         dc2.put(InetAddress.getByName("127.0.0.4"), new StringToken("G"));
1:         dc2.put(InetAddress.getByName("127.0.0.4"), new StringToken("L"));
1:         dc2.put(InetAddress.getByName("127.0.0.5"), new StringToken("D"));
1:         dc2.put(InetAddress.getByName("127.0.0.5"), new StringToken("F"));
1:         dc2.put(InetAddress.getByName("127.0.0.5"), new StringToken("K"));
1:         metadata.updateNormalTokens(dc2);
1: 
1:         Map<String, String> configOptions = new HashMap<>();
1:         configOptions.put("DC1", "1");
1:         configOptions.put("DC2", "2");
1: 
1:         Keyspace.clear("Keyspace1");
0:         KSMetaData meta = KSMetaData.newKeyspace("Keyspace1", "NetworkTopologyStrategy", configOptions, false);
0:         Schema.instance.setKeyspaceDefinition(meta);
1: 
1:         // endpoints in DC1 should have primary ranges which also cover DC2
1:         Collection<Range<Token>> primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name, InetAddress.getByName("127.0.0.1"));
1:         assertEquals(8, primaryRanges.size());
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("J"), new StringToken("K"))));
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("K"), new StringToken("L"))));
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("L"), new StringToken("A"))));
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("C"), new StringToken("D"))));
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("D"), new StringToken("E"))));
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("E"), new StringToken("F"))));
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("F"), new StringToken("G"))));
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("G"), new StringToken("H"))));
1: 
1:         // endpoints in DC1 should have primary ranges which also cover DC2
1:         primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name, InetAddress.getByName("127.0.0.2"));
1:         assertEquals(4, primaryRanges.size());
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("B"), new StringToken("C"))));
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("A"), new StringToken("B"))));
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("H"), new StringToken("I"))));
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("I"), new StringToken("J"))));
1: 
1:         // endpoints in DC2 should have primary ranges which also cover DC1
1:         primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name, InetAddress.getByName("127.0.0.4"));
1:         assertEquals(4, primaryRanges.size());
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("A"), new StringToken("B"))));
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("F"), new StringToken("G"))));
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("K"), new StringToken("L"))));
1:         // because /127.0.0.4 holds token "B" which is the next to token "A" from /127.0.0.1,
1:         // the node covers range (L, A]
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("L"), new StringToken("A"))));
1: 
1:         primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name, InetAddress.getByName("127.0.0.5"));
1:         assertTrue(primaryRanges.size() == 8);
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("C"), new StringToken("D"))));
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("E"), new StringToken("F"))));
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("J"), new StringToken("K"))));
1:         // ranges from /127.0.0.1
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("D"), new StringToken("E"))));
1:         // the next token to "H" in DC2 is "K" in /127.0.0.5, so (G, H] goes to /127.0.0.5
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("G"), new StringToken("H"))));
1:         // ranges from /127.0.0.2
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("B"), new StringToken("C"))));
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("H"), new StringToken("I"))));
1:         assertTrue(primaryRanges.contains(new Range<Token>(new StringToken("I"), new StringToken("J"))));
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         Map<String, String> configOptions = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1: 
1:     /* Does not make much sense to use -local and -pr with simplestrategy, but just to prevent human errors */
1:     @Test
1:     public void testPrimaryRangeForEndpointWithinDCWithSimpleStrategy() throws Exception
1:     {
1:         TokenMetadata metadata = StorageService.instance.getTokenMetadata();
1:         metadata.clearUnsafe();
1: 
1:         metadata.updateNormalToken(new StringToken("A"), InetAddress.getByName("127.0.0.1"));
1:         metadata.updateNormalToken(new StringToken("B"), InetAddress.getByName("127.0.0.2"));
1:         metadata.updateNormalToken(new StringToken("C"), InetAddress.getByName("127.0.0.3"));
1: 
0:         Map<String, String> configOptions = new HashMap<>();
0:         configOptions.put("replication_factor", "2");
1: 
0:         Keyspace.clear("Keyspace1");
0:         KSMetaData meta = KSMetaData.newKeyspace("Keyspace1", "SimpleStrategy", configOptions, false);
0:         Schema.instance.setKeyspaceDefinition(meta);
1: 
1:         Collection<Range<Token>> primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name, InetAddress.getByName("127.0.0.1"));
1:         assert primaryRanges.size() == 1;
1:         assert primaryRanges.contains(new Range<Token>(new StringToken("C"), new StringToken("A")));
1: 
1:         primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name, InetAddress.getByName("127.0.0.2"));
1:         assert primaryRanges.size() == 1;
1:         assert primaryRanges.contains(new Range<Token>(new StringToken("A"), new StringToken("B")));
1: 
1:         primaryRanges = StorageService.instance.getPrimaryRangeForEndpointWithinDC(meta.name, InetAddress.getByName("127.0.0.3"));
1:         assert primaryRanges.size() == 1;
1:         assert primaryRanges.contains(new Range<Token>(new StringToken("B"), new StringToken("C")));
1:     }
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:5ab1a34
/////////////////////////////////////////////////////////////////////////
1:         Keyspace.setInitialized();
commit:7f2c3a8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.SystemTable;
/////////////////////////////////////////////////////////////////////////
0:         StorageService.instance.takeColumnFamilySnapshot(Table.SYSTEM_KS, SystemTable.SCHEMA_KEYSPACES_CF, "cf_snapshot");
commit:5c94432
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.Table;
/////////////////////////////////////////////////////////////////////////
0:         StorageService.instance.takeColumnFamilySnapshot(Table.SYSTEM_KS, "Schema", "cf_snapshot");
commit:4797b40
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test
0:     public void testColumnFamilySnapshot() throws IOException
1:     {
1:         // no need to insert extra data, even an "empty" database will have a little information in the system keyspace
0:         StorageService.instance.takeColumnFamilySnapshot("system", "Schema", "cf_snapshot");
1:     }
1: 
commit:e987e3b
/////////////////////////////////////////////////////////////////////////
1:         StorageService.instance.initServer(0);
commit:570ac26
/////////////////////////////////////////////////////////////////////////
0:         StorageService.instance.takeSnapshot("snapshot", new String[0]);
commit:49af30a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.ConfigurationException;
/////////////////////////////////////////////////////////////////////////
0:     public void testRegularMode() throws IOException, InterruptedException, ConfigurationException
commit:0b68a77
/////////////////////////////////////////////////////////////////////////
1:     @Test
0:     public void testSnapshot() throws IOException
1:     {
1:         // no need to insert extra data, even an "empty" database will have a little information in the system keyspace
0:         StorageService.instance.takeAllSnapshot(null);
1:     }
1: }
commit:7fd4228
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collections;
0: import java.util.List;
0: import org.apache.cassandra.dht.Token;
1: import static org.junit.Assert.assertEquals;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test
1:     public void testGetAllRangesEmpty()
1:     {
1:         List<Token> toks = Collections.emptyList();
0:         assertEquals(Collections.emptyList(), StorageService.instance.getAllRanges(toks));
1:     }
1: }
1: 
commit:5b52240
/////////////////////////////////////////////////////////////////////////
1: import org.junit.Test;
1: 
0: import org.apache.cassandra.CleanupHelper;
0: import org.apache.cassandra.config.DatabaseDescriptor;
1: 
0: import static org.junit.Assert.assertFalse;
1: import static org.junit.Assert.assertTrue;
1: 
1: public class StorageServiceServerTest
/////////////////////////////////////////////////////////////////////////
0: }
commit:a2e2c03
/////////////////////////////////////////////////////////////////////////
0:         StorageService.instance.initClient();
1:         StorageService.instance.stopClient();
/////////////////////////////////////////////////////////////////////////
0:         StorageService.instance.initServer();
/////////////////////////////////////////////////////////////////////////
1:         //StorageService.instance.decommission();
0:         StorageService.instance.stopClient();
commit:360d9b6
/////////////////////////////////////////////////////////////////////////
1: /*
1: * Licensed to the Apache Software Foundation (ASF) under one
1: * or more contributor license agreements.  See the NOTICE file
1: * distributed with this work for additional information
1: * regarding copyright ownership.  The ASF licenses this file
1: * to you under the Apache License, Version 2.0 (the
1: * "License"); you may not use this file except in compliance
1: * with the License.  You may obtain a copy of the License at
1: *
1: *    http://www.apache.org/licenses/LICENSE-2.0
1: *
1: * Unless required by applicable law or agreed to in writing,
1: * software distributed under the License is distributed on an
1: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1: * KIND, either express or implied.  See the License for the
1: * specific language governing permissions and limitations
1: * under the License.
1: */
0: 
1: package org.apache.cassandra.service;
0: 
0: import org.apache.cassandra.CleanupHelper;
0: import org.apache.cassandra.config.DatabaseDescriptor;
0: import org.apache.cassandra.net.NetPackageAccessor;
0: import org.junit.Test;
0: import static org.junit.Assert.assertTrue;
0: import static org.junit.Assert.assertFalse;
0: 
1: import java.io.File;
1: import java.io.IOException;
0: 
0: public class StorageServiceTest
1: {
0:     @Test
0:     public void testClientOnlyMode() throws IOException
1:     {
0:         CleanupHelper.mkdirs();
0:         CleanupHelper.cleanup();
0:         StorageService.instance().initClient();
0: 
0:         // verify that no storage directories were created.
1:         for (String path : DatabaseDescriptor.getAllDataFileLocations())
1:         {
0:             assertFalse(new File(path).exists());
0:         }
0:         StorageService.instance().stopClient();
0:         NetPackageAccessor.resetSelectorManager();
0:     }
0: 
0:     @Test
0:     public void testRegularMode() throws IOException, InterruptedException
1:     {
0:         CleanupHelper.mkdirs();
0:         CleanupHelper.cleanup();
0:         StorageService.instance().initServer();
1:         for (String path : DatabaseDescriptor.getAllDataFileLocations())
1:         {
1:             // verify that storage directories are there.
1:             assertTrue(new File(path).exists());
0:         }
1:         // a proper test would be to call decommission here, but decommission() mixes both shutdown and datatransfer
1:         // calls.  This test is only interested in the shutdown-related items which a properly handled by just
1:         // stopping the client.
0:         //StorageService.instance().decommission();
0:         StorageService.instance().stopClient();
0:         NetPackageAccessor.resetSelectorManager();
0:     }
0: }
commit:a7f0fb6
/////////////////////////////////////////////////////////////////////////
commit:d748648
/////////////////////////////////////////////////////////////////////////
0: /*
0: * Licensed to the Apache Software Foundation (ASF) under one
0: * or more contributor license agreements.  See the NOTICE file
0: * distributed with this work for additional information
0: * regarding copyright ownership.  The ASF licenses this file
0: * to you under the Apache License, Version 2.0 (the
0: * "License"); you may not use this file except in compliance
0: * with the License.  You may obtain a copy of the License at
0: *
0: *    http://www.apache.org/licenses/LICENSE-2.0
0: *
0: * Unless required by applicable law or agreed to in writing,
0: * software distributed under the License is distributed on an
0: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0: * KIND, either express or implied.  See the License for the
0: * specific language governing permissions and limitations
0: * under the License.
0: */
0: package org.apache.cassandra.service;
0: 
0: import org.junit.Test;
0: import org.junit.Assert;
0: import org.apache.cassandra.net.io.StreamContextManager;
0: 
0: import java.util.List;
0: import java.util.ArrayList;
0: 
0: public class StorageServiceTest {
0: 
0: 
0:     @Test
0:     public void testImpossibleCast() {
0:         List<StreamContextManager.StreamContext> streamContexts = new ArrayList<StreamContextManager.StreamContext>();
0:         try {
0:             StreamContextManager.StreamContext[] arr = (StreamContextManager.StreamContext[]) streamContexts.toArray();
0:             Assert.fail("expected ClassCastException from Object[] to StreamContextManager.StreamContext[]");
0: 
0:         } catch (ClassCastException e) {
0:             Assert.assertTrue(true);
0:         }
0:     }
0: 
0: 
0:     @Test
0:     public void testPossibleCast() {
0: 
0:         List<StreamContextManager.StreamContext> streamContexts = new ArrayList<StreamContextManager.StreamContext>();
0:         StreamContextManager.StreamContext[] contexts = streamContexts.toArray(new StreamContextManager.StreamContext[streamContexts.size()]);
0:         Assert.assertTrue(contexts.length == 0);
0: 
0:         StreamContextManager.StreamContext streamContext = new StreamContextManager.StreamContext("foofile", 0, "fooTable");
0:         streamContexts.add(streamContext);
0:         contexts = streamContexts.toArray(new StreamContextManager.StreamContext[streamContexts.size()]);
0:         Assert.assertTrue(contexts.length == 1);
0:     }
0: }
author:Brandon Williams
-------------------------------------------------------------------------------
commit:018e82b
/////////////////////////////////////////////////////////////////////////
1: import org.junit.runner.RunWith;
1: import org.apache.cassandra.OrderedJUnit4ClassRunner;
/////////////////////////////////////////////////////////////////////////
1: @RunWith(OrderedJUnit4ClassRunner.class)
commit:bf8c1ce
/////////////////////////////////////////////////////////////////////////
0: import org.junit.runner.RunWith;
0: import org.apache.cassandra.OrderedJUnit4ClassRunner;
/////////////////////////////////////////////////////////////////////////
0: @RunWith(OrderedJUnit4ClassRunner.class)
============================================================================