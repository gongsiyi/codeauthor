1:8f0d5a2: /*
1:8f0d5a2:  * Copyright (C) 2008 The Android Open Source Project
1:8f0d5a2:  *
1:8f0d5a2:  * Licensed under the Apache License, Version 2.0 (the "License");
1:8f0d5a2:  * you may not use this file except in compliance with the License.
1:8f0d5a2:  * You may obtain a copy of the License at
1:8f0d5a2:  *
1:8f0d5a2:  *      http://www.apache.org/licenses/LICENSE-2.0
1:8f0d5a2:  *
1:8f0d5a2:  * Unless required by applicable law or agreed to in writing, software
1:8f0d5a2:  * distributed under the License is distributed on an "AS IS" BASIS,
1:8f0d5a2:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:8f0d5a2:  * See the License for the specific language governing permissions and
1:8f0d5a2:  * limitations under the License.
1:8f0d5a2:  */
1:8f0d5a2: /*
1:8f0d5a2:  * This file originates from https://android.googlesource.com/platform/libcore/+/gingerbread/luni/src/main/java/java/util/TimSort.java
1:8f0d5a2:  * and has been modified to sort primitive long arrays instead of object arrays.
1:8f0d5a2:  */
1:8f0d5a2: //package java.util;
1:8f0d5a2: 
1:8f0d5a2: package org.apache.cassandra.utils;
1:8f0d5a2: 
1:8f0d5a2: import java.util.Arrays;
1:8f0d5a2: 
1:8f0d5a2: /**
1:8f0d5a2:  * A stable, adaptive, iterative mergesort that requires far fewer than
1:8f0d5a2:  * n lg(n) comparisons when running on partially sorted arrays, while
1:8f0d5a2:  * offering performance comparable to a traditional mergesort when run
1:8f0d5a2:  * on random arrays.  Like all proper mergesorts, this sort is stable and
1:8f0d5a2:  * runs O(n log n) time (worst case).  In the worst case, this sort requires
1:8f0d5a2:  * temporary storage space for n/2 object references; in the best case,
1:8f0d5a2:  * it requires only a small constant amount of space.
1:8f0d5a2:  *
1:8f0d5a2:  * This implementation was adapted from Tim Peters's list sort for
1:8f0d5a2:  * Python, which is described in detail here:
1:8f0d5a2:  *
1:8f0d5a2:  *   http://svn.python.org/projects/python/trunk/Objects/listsort.txt
1:8f0d5a2:  *
1:8f0d5a2:  * Tim's C code may be found here:
1:8f0d5a2:  *
1:8f0d5a2:  *   http://svn.python.org/projects/python/trunk/Objects/listobject.c
1:8f0d5a2:  *
1:8f0d5a2:  * The underlying techniques are described in this paper (and may have
1:8f0d5a2:  * even earlier origins):
1:8f0d5a2:  *
1:8f0d5a2:  *  "Optimistic Sorting and Information Theoretic Complexity"
1:8f0d5a2:  *  Peter McIlroy
1:8f0d5a2:  *  SODA (Fourth Annual ACM-SIAM Symposium on Discrete Algorithms),
1:8f0d5a2:  *  pp 467-474, Austin, Texas, 25-27 January 1993.
1:8f0d5a2:  *
1:8f0d5a2:  * While the API to this class consists solely of static methods, it is
1:8f0d5a2:  * (privately) instantiable; a TimSort instance holds the state of an ongoing
1:8f0d5a2:  * sort, assuming the input array is large enough to warrant the full-blown
1:8f0d5a2:  * TimSort. Small arrays are sorted in place, using a binary insertion sort.
1:8f0d5a2:  */
1:8f0d5a2: public final class LongTimSort {
1:8f0d5a2:     /**
1:8f0d5a2:      * This is the minimum sized sequence that will be merged.  Shorter
1:8f0d5a2:      * sequences will be lengthened by calling binarySort.  If the entire
1:8f0d5a2:      * array is less than this length, no merges will be performed.
1:8f0d5a2:      *
1:8f0d5a2:      * This constant should be a power of two.  It was 64 in Tim Peter's C
1:8f0d5a2:      * implementation, but 32 was empirically determined to work better in
1:8f0d5a2:      * this implementation.  In the unlikely event that you set this constant
1:8f0d5a2:      * to be a number that's not a power of two, you'll need to change the
1:8f0d5a2:      * {@link #minRunLength} computation.
1:8f0d5a2:      *
1:8f0d5a2:      * If you decrease this constant, you must change the stackLen
1:8f0d5a2:      * computation in the TimSort constructor, or you risk an
1:8f0d5a2:      * ArrayOutOfBounds exception.  See listsort.txt for a discussion
1:8f0d5a2:      * of the minimum stack length required as a function of the length
1:8f0d5a2:      * of the array being sorted and the minimum merge sequence length.
1:8f0d5a2:      */
1:8f0d5a2:     private static final int MIN_MERGE = 32;
1:8f0d5a2:     /**
1:8f0d5a2:      * The array being sorted.
1:8f0d5a2:      */
1:8f0d5a2:     private final long[] a;
1:8f0d5a2:     /**
1:8f0d5a2:      * The comparator for this sort.
1:8f0d5a2:      */
1:8f0d5a2:     private final LongComparator c;
1:8f0d5a2:     /**
1:8f0d5a2:      * When we get into galloping mode, we stay there until both runs win less
1:8f0d5a2:      * often than MIN_GALLOP consecutive times.
1:8f0d5a2:      */
1:8f0d5a2:     private static final int  MIN_GALLOP = 7;
1:8f0d5a2:     /**
1:8f0d5a2:      * This controls when we get *into* galloping mode.  It is initialized
1:8f0d5a2:      * to MIN_GALLOP.  The mergeLo and mergeHi methods nudge it higher for
1:8f0d5a2:      * random data, and lower for highly structured data.
1:8f0d5a2:      */
1:8f0d5a2:     private int minGallop = MIN_GALLOP;
1:8f0d5a2:     /**
1:8f0d5a2:      * Maximum initial size of tmp array, which is used for merging.  The array
1:8f0d5a2:      * can grow to accommodate demand.
1:8f0d5a2:      *
1:8f0d5a2:      * Unlike Tim's original C version, we do not allocate this much storage
1:8f0d5a2:      * when sorting smaller arrays.  This change was required for performance.
1:8f0d5a2:      */
1:8f0d5a2:     private static final int INITIAL_TMP_STORAGE_LENGTH = 256;
1:8f0d5a2:     /**
1:8f0d5a2:      * Temp storage for merges.
1:8f0d5a2:      */
1:8f0d5a2:     private long[] tmp;
1:8f0d5a2:     /**
1:8f0d5a2:      * A stack of pending runs yet to be merged.  Run i starts at
1:8f0d5a2:      * address base[i] and extends for len[i] elements.  It's always
1:8f0d5a2:      * true (so long as the indices are in bounds) that:
1:8f0d5a2:      *
1:8f0d5a2:      *     runBase[i] + runLen[i] == runBase[i + 1]
1:8f0d5a2:      *
1:8f0d5a2:      * so we could cut the storage for this, but it's a minor amount,
1:8f0d5a2:      * and keeping all the info explicit simplifies the code.
1:8f0d5a2:      */
1:8f0d5a2:     private int stackSize = 0;  // Number of pending runs on stack
1:8f0d5a2:     private final int[] runBase;
1:8f0d5a2:     private final int[] runLen;
1:8f0d5a2:     /**
1:8f0d5a2:      * Asserts have been placed in if-statements for performace. To enable them,
1:8f0d5a2:      * set this field to true and enable them in VM with a command line flag.
1:8f0d5a2:      * If you modify this class, please do test the asserts!
1:8f0d5a2:      */
1:8f0d5a2:     private static final boolean DEBUG = false;
1:8f0d5a2:     /**
1:8f0d5a2:      * Creates a TimSort instance to maintain the state of an ongoing sort.
1:8f0d5a2:      *
1:8f0d5a2:      * @param a the array to be sorted
1:8f0d5a2:      * @param c the comparator to determine the order of the sort
1:8f0d5a2:      */
1:8f0d5a2:     private LongTimSort(long[] a, LongComparator c) {
1:8f0d5a2:         this.a = a;
1:8f0d5a2:         this.c = c;
1:8f0d5a2:         // Allocate temp storage (which may be increased later if necessary)
1:8f0d5a2:         int len = a.length;
1:8f0d5a2:         @SuppressWarnings({"unchecked", "UnnecessaryLocalVariable"})
1:8f0d5a2:         long[] newArray = new long[len < 2 * INITIAL_TMP_STORAGE_LENGTH ?
1:8f0d5a2:                                    len >>> 1 : INITIAL_TMP_STORAGE_LENGTH];
1:8f0d5a2:         tmp = newArray;
1:8f0d5a2:         /*
1:8f0d5a2:          * Allocate runs-to-be-merged stack (which cannot be expanded).  The
1:8f0d5a2:          * stack length requirements are described in listsort.txt.  The C
1:8f0d5a2:          * version always uses the same stack length (85), but this was
1:8f0d5a2:          * measured to be too expensive when sorting "mid-sized" arrays (e.g.,
1:8f0d5a2:          * 100 elements) in Java.  Therefore, we use smaller (but sufficiently
1:8f0d5a2:          * large) stack lengths for smaller arrays.  The "magic numbers" in the
1:8f0d5a2:          * computation below must be changed if MIN_MERGE is decreased.  See
1:8f0d5a2:          * the MIN_MERGE declaration above for more information.
1:8f0d5a2:          */
1:8f0d5a2:         int stackLen = (len <    120  ?  5 :
1:8f0d5a2:                         len <   1542  ? 10 :
1:8f0d5a2:                         len < 119151  ? 19 : 40);
1:8f0d5a2:         runBase = new int[stackLen];
1:8f0d5a2:         runLen = new int[stackLen];
1:8f0d5a2:     }
1:8f0d5a2:     /*
1:8f0d5a2:      * The next two methods (which are package private and static) constitute
1:8f0d5a2:      * the entire API of this class.  Each of these methods obeys the contract
1:8f0d5a2:      * of the public method with the same signature in java.util.Arrays.
1:8f0d5a2:      */
1:8f0d5a2:     public static void sort(long[] a, LongComparator c) {
1:8f0d5a2:         sort(a, 0, a.length, c);
1:8f0d5a2:     }
1:8f0d5a2:     public static void sort(long[] a, int lo, int hi, LongComparator c) {
1:8f0d5a2:         if (c == null) {
1:8f0d5a2:             Arrays.sort(a, lo, hi);
1:8f0d5a2:             return;
1:8f0d5a2:         }
1:8f0d5a2:         rangeCheck(a.length, lo, hi);
1:8f0d5a2:         int nRemaining  = hi - lo;
1:8f0d5a2:         if (nRemaining < 2)
1:8f0d5a2:             return;  // Arrays of size 0 and 1 are always sorted
1:8f0d5a2:         // If array is small, do a "mini-TimSort" with no merges
1:8f0d5a2:         if (nRemaining < MIN_MERGE) {
1:8f0d5a2:             int initRunLen = countRunAndMakeAscending(a, lo, hi, c);
1:8f0d5a2:             binarySort(a, lo, hi, lo + initRunLen, c);
1:8f0d5a2:             return;
1:8f0d5a2:         }
1:8f0d5a2:         /**
1:8f0d5a2:          * March over the array once, left to right, finding natural runs,
1:8f0d5a2:          * extending short natural runs to minRun elements, and merging runs
1:8f0d5a2:          * to maintain stack invariant.
1:8f0d5a2:          */
1:8f0d5a2:         LongTimSort ts = new LongTimSort(a, c);
1:8f0d5a2:         int minRun = minRunLength(nRemaining);
1:8f0d5a2:         do {
1:8f0d5a2:             // Identify next run
1:8f0d5a2:             int runLen = countRunAndMakeAscending(a, lo, hi, c);
1:8f0d5a2:             // If run is short, extend to min(minRun, nRemaining)
1:8f0d5a2:             if (runLen < minRun) {
1:8f0d5a2:                 int force = nRemaining <= minRun ? nRemaining : minRun;
1:8f0d5a2:                 binarySort(a, lo, lo + force, lo + runLen, c);
1:8f0d5a2:                 runLen = force;
1:8f0d5a2:             }
1:8f0d5a2:             // Push run onto pending-run stack, and maybe merge
1:8f0d5a2:             ts.pushRun(lo, runLen);
1:8f0d5a2:             ts.mergeCollapse();
1:8f0d5a2:             // Advance to find next run
1:8f0d5a2:             lo += runLen;
1:8f0d5a2:             nRemaining -= runLen;
1:8f0d5a2:         } while (nRemaining != 0);
1:8f0d5a2:         // Merge all remaining runs to complete sort
1:8f0d5a2:         if (DEBUG) assert lo == hi;
1:8f0d5a2:         ts.mergeForceCollapse();
1:8f0d5a2:         if (DEBUG) assert ts.stackSize == 1;
1:8f0d5a2:     }
1:8f0d5a2:     /**
1:8f0d5a2:      * Sorts the specified portion of the specified array using a binary
1:8f0d5a2:      * insertion sort.  This is the best method for sorting small numbers
1:8f0d5a2:      * of elements.  It requires O(n log n) compares, but O(n^2) data
1:8f0d5a2:      * movement (worst case).
1:8f0d5a2:      *
1:8f0d5a2:      * If the initial part of the specified range is already sorted,
1:8f0d5a2:      * this method can take advantage of it: the method assumes that the
1:8f0d5a2:      * elements from index {@code lo}, inclusive, to {@code start},
1:8f0d5a2:      * exclusive are already sorted.
1:8f0d5a2:      *
1:8f0d5a2:      * @param a the array in which a range is to be sorted
1:8f0d5a2:      * @param lo the index of the first element in the range to be sorted
1:8f0d5a2:      * @param hi the index after the last element in the range to be sorted
1:8f0d5a2:      * @param start the index of the first element in the range that is
1:8f0d5a2:      *        not already known to be sorted (@code lo <= start <= hi}
1:8f0d5a2:      * @param c comparator to used for the sort
1:8f0d5a2:      */
1:8f0d5a2:     @SuppressWarnings("fallthrough")
1:8f0d5a2:     private static void binarySort(long[] a, int lo, int hi, int start,
1:8f0d5a2:                                        LongComparator c) {
1:8f0d5a2:         if (DEBUG) assert lo <= start && start <= hi;
1:8f0d5a2:         if (start == lo)
1:8f0d5a2:             start++;
1:8f0d5a2:         for ( ; start < hi; start++) {
1:8f0d5a2:             long pivot = a[start];
1:8f0d5a2:             // Set left (and right) to the index where a[start] (pivot) belongs
1:8f0d5a2:             int left = lo;
1:8f0d5a2:             int right = start;
1:8f0d5a2:             if (DEBUG) assert left <= right;
1:8f0d5a2:             /*
1:8f0d5a2:              * Invariants:
1:8f0d5a2:              *   pivot >= all in [lo, left).
1:8f0d5a2:              *   pivot <  all in [right, start).
1:8f0d5a2:              */
1:8f0d5a2:             while (left < right) {
1:8f0d5a2:                 int mid = (left + right) >>> 1;
1:8f0d5a2:                 if (c.compare(pivot, a[mid]) < 0)
1:8f0d5a2:                     right = mid;
1:8f0d5a2:                 else
1:8f0d5a2:                     left = mid + 1;
1:8f0d5a2:             }
1:8f0d5a2:             if (DEBUG) assert left == right;
1:8f0d5a2:             /*
1:8f0d5a2:              * The invariants still hold: pivot >= all in [lo, left) and
1:8f0d5a2:              * pivot < all in [left, start), so pivot belongs at left.  Note
1:8f0d5a2:              * that if there are elements equal to pivot, left points to the
1:8f0d5a2:              * first slot after them -- that's why this sort is stable.
1:8f0d5a2:              * Slide elements over to make room to make room for pivot.
1:8f0d5a2:              */
1:8f0d5a2:             int n = start - left;  // The number of elements to move
1:8f0d5a2:             // Switch is just an optimization for arraycopy in default case
1:8f0d5a2:             switch(n) {
1:8f0d5a2:                 case 2:  a[left + 2] = a[left + 1];
1:8f0d5a2:                 case 1:  a[left + 1] = a[left];
1:8f0d5a2:                     break;
1:8f0d5a2:                 default: System.arraycopy(a, left, a, left + 1, n);
1:8f0d5a2:             }
1:8f0d5a2:             a[left] = pivot;
1:8f0d5a2:         }
1:8f0d5a2:     }
1:8f0d5a2:     /**
1:8f0d5a2:      * Returns the length of the run beginning at the specified position in
1:8f0d5a2:      * the specified array and reverses the run if it is descending (ensuring
1:8f0d5a2:      * that the run will always be ascending when the method returns).
1:8f0d5a2:      *
1:8f0d5a2:      * A run is the longest ascending sequence with:
1:8f0d5a2:      *
1:8f0d5a2:      *    a[lo] <= a[lo + 1] <= a[lo + 2] <= ...
1:8f0d5a2:      *
1:8f0d5a2:      * or the longest descending sequence with:
1:8f0d5a2:      *
1:8f0d5a2:      *    a[lo] >  a[lo + 1] >  a[lo + 2] >  ...
1:8f0d5a2:      *
1:8f0d5a2:      * For its intended use in a stable mergesort, the strictness of the
1:8f0d5a2:      * definition of "descending" is needed so that the call can safely
1:8f0d5a2:      * reverse a descending sequence without violating stability.
1:8f0d5a2:      *
1:8f0d5a2:      * @param a the array in which a run is to be counted and possibly reversed
1:8f0d5a2:      * @param lo index of the first element in the run
1:8f0d5a2:      * @param hi index after the last element that may be contained in the run.
1:8f0d5a2:     It is required that @code{lo < hi}.
1:8f0d5a2:      * @param c the comparator to used for the sort
1:8f0d5a2:      * @return  the length of the run beginning at the specified position in
1:8f0d5a2:      *          the specified array
1:8f0d5a2:      */
1:8f0d5a2:     private static int countRunAndMakeAscending(long[] a, int lo, int hi,
1:8f0d5a2:                                                 LongComparator c) {
1:8f0d5a2:         if (DEBUG) assert lo < hi;
1:8f0d5a2:         int runHi = lo + 1;
1:8f0d5a2:         if (runHi == hi)
1:8f0d5a2:             return 1;
1:8f0d5a2:         // Find end of run, and reverse range if descending
1:8f0d5a2:         if (c.compare(a[runHi++], a[lo]) < 0) { // Descending
1:8f0d5a2:             while(runHi < hi && c.compare(a[runHi], a[runHi - 1]) < 0)
1:8f0d5a2:                 runHi++;
1:8f0d5a2:             reverseRange(a, lo, runHi);
1:8f0d5a2:         } else {                              // Ascending
1:8f0d5a2:             while (runHi < hi && c.compare(a[runHi], a[runHi - 1]) >= 0)
1:8f0d5a2:                 runHi++;
1:8f0d5a2:         }
1:8f0d5a2:         return runHi - lo;
1:8f0d5a2:     }
1:8f0d5a2:     /**
1:8f0d5a2:      * Reverse the specified range of the specified array.
1:8f0d5a2:      *
1:8f0d5a2:      * @param a the array in which a range is to be reversed
1:8f0d5a2:      * @param lo the index of the first element in the range to be reversed
1:8f0d5a2:      * @param hi the index after the last element in the range to be reversed
1:8f0d5a2:      */
1:8f0d5a2:     private static void reverseRange(long[] a, int lo, int hi) {
1:8f0d5a2:         hi--;
1:8f0d5a2:         while (lo < hi) {
1:8f0d5a2:             long t = a[lo];
1:8f0d5a2:             a[lo++] = a[hi];
1:8f0d5a2:             a[hi--] = t;
1:8f0d5a2:         }
1:8f0d5a2:     }
1:8f0d5a2:     /**
1:8f0d5a2:      * Returns the minimum acceptable run length for an array of the specified
1:8f0d5a2:      * length. Natural runs shorter than this will be extended with
1:8f0d5a2:      * {@link #binarySort}.
1:8f0d5a2:      *
1:8f0d5a2:      * Roughly speaking, the computation is:
1:8f0d5a2:      *
1:8f0d5a2:      *  If n < MIN_MERGE, return n (it's too small to bother with fancy stuff).
1:8f0d5a2:      *  Else if n is an exact power of 2, return MIN_MERGE/2.
1:8f0d5a2:      *  Else return an int k, MIN_MERGE/2 <= k <= MIN_MERGE, such that n/k
1:8f0d5a2:      *   is close to, but strictly less than, an exact power of 2.
1:8f0d5a2:      *
1:8f0d5a2:      * For the rationale, see listsort.txt.
1:8f0d5a2:      *
1:8f0d5a2:      * @param n the length of the array to be sorted
1:8f0d5a2:      * @return the length of the minimum run to be merged
1:8f0d5a2:      */
1:8f0d5a2:     private static int minRunLength(int n) {
1:8f0d5a2:         if (DEBUG) assert n >= 0;
1:8f0d5a2:         int r = 0;      // Becomes 1 if any 1 bits are shifted off
1:8f0d5a2:         while (n >= MIN_MERGE) {
1:8f0d5a2:             r |= (n & 1);
1:8f0d5a2:             n >>= 1;
1:8f0d5a2:         }
1:8f0d5a2:         return n + r;
1:8f0d5a2:     }
1:8f0d5a2:     /**
1:8f0d5a2:      * Pushes the specified run onto the pending-run stack.
1:8f0d5a2:      *
1:8f0d5a2:      * @param runBase index of the first element in the run
1:8f0d5a2:      * @param runLen  the number of elements in the run
1:8f0d5a2:      */
1:8f0d5a2:     private void pushRun(int runBase, int runLen) {
1:8f0d5a2:         this.runBase[stackSize] = runBase;
1:8f0d5a2:         this.runLen[stackSize] = runLen;
1:8f0d5a2:         stackSize++;
1:8f0d5a2:     }
1:8f0d5a2:     /**
1:8f0d5a2:      * Examines the stack of runs waiting to be merged and merges adjacent runs
1:8f0d5a2:      * until the stack invariants are reestablished:
1:8f0d5a2:      *
1:8f0d5a2:      *     1. runLen[i - 3] > runLen[i - 2] + runLen[i - 1]
1:8f0d5a2:      *     2. runLen[i - 2] > runLen[i - 1]
1:8f0d5a2:      *
1:8f0d5a2:      * This method is called each time a new run is pushed onto the stack,
1:8f0d5a2:      * so the invariants are guaranteed to hold for i < stackSize upon
1:8f0d5a2:      * entry to the method.
1:8f0d5a2:      */
1:8f0d5a2:     private void mergeCollapse() {
1:8f0d5a2:         while (stackSize > 1) {
1:8f0d5a2:             int n = stackSize - 2;
1:8f0d5a2:             if (n > 0 && runLen[n-1] <= runLen[n] + runLen[n+1]) {
1:8f0d5a2:                 if (runLen[n - 1] < runLen[n + 1])
1:8f0d5a2:                     n--;
1:8f0d5a2:                 mergeAt(n);
1:8f0d5a2:             } else if (runLen[n] <= runLen[n + 1]) {
1:8f0d5a2:                 mergeAt(n);
1:8f0d5a2:             } else {
1:8f0d5a2:                 break; // Invariant is established
1:8f0d5a2:             }
1:8f0d5a2:         }
1:8f0d5a2:     }
1:8f0d5a2:     /**
1:8f0d5a2:      * Merges all runs on the stack until only one remains.  This method is
1:8f0d5a2:      * called once, to complete the sort.
1:8f0d5a2:      */
1:8f0d5a2:     private void mergeForceCollapse() {
1:8f0d5a2:         while (stackSize > 1) {
1:8f0d5a2:             int n = stackSize - 2;
1:8f0d5a2:             if (n > 0 && runLen[n - 1] < runLen[n + 1])
1:8f0d5a2:                 n--;
1:8f0d5a2:             mergeAt(n);
1:8f0d5a2:         }
1:8f0d5a2:     }
1:8f0d5a2:     /**
1:8f0d5a2:      * Merges the two runs at stack indices i and i+1.  Run i must be
1:8f0d5a2:      * the penultimate or antepenultimate run on the stack.  In other words,
1:8f0d5a2:      * i must be equal to stackSize-2 or stackSize-3.
1:8f0d5a2:      *
1:8f0d5a2:      * @param i stack index of the first of the two runs to merge
1:8f0d5a2:      */
1:8f0d5a2:     private void mergeAt(int i) {
1:8f0d5a2:         if (DEBUG) assert stackSize >= 2;
1:8f0d5a2:         if (DEBUG) assert i >= 0;
1:8f0d5a2:         if (DEBUG) assert i == stackSize - 2 || i == stackSize - 3;
1:8f0d5a2:         int base1 = runBase[i];
1:8f0d5a2:         int len1 = runLen[i];
1:8f0d5a2:         int base2 = runBase[i + 1];
1:8f0d5a2:         int len2 = runLen[i + 1];
1:8f0d5a2:         if (DEBUG) assert len1 > 0 && len2 > 0;
1:8f0d5a2:         if (DEBUG) assert base1 + len1 == base2;
1:8f0d5a2:         /*
1:8f0d5a2:          * Record the length of the combined runs; if i is the 3rd-last
1:8f0d5a2:          * run now, also slide over the last run (which isn't involved
1:8f0d5a2:          * in this merge).  The current run (i+1) goes away in any case.
1:8f0d5a2:          */
1:8f0d5a2:         runLen[i] = len1 + len2;
1:8f0d5a2:         if (i == stackSize - 3) {
1:8f0d5a2:             runBase[i + 1] = runBase[i + 2];
1:8f0d5a2:             runLen[i + 1] = runLen[i + 2];
1:8f0d5a2:         }
1:8f0d5a2:         stackSize--;
1:8f0d5a2:         /*
1:8f0d5a2:          * Find where the first element of run2 goes in run1. Prior elements
1:8f0d5a2:          * in run1 can be ignored (because they're already in place).
1:8f0d5a2:          */
1:8f0d5a2:         int k = gallopRight(a[base2], a, base1, len1, 0, c);
1:8f0d5a2:         if (DEBUG) assert k >= 0;
1:8f0d5a2:         base1 += k;
1:8f0d5a2:         len1 -= k;
1:8f0d5a2:         if (len1 == 0)
1:8f0d5a2:             return;
1:8f0d5a2:         /*
1:8f0d5a2:          * Find where the last element of run1 goes in run2. Subsequent elements
1:8f0d5a2:          * in run2 can be ignored (because they're already in place).
1:8f0d5a2:          */
1:8f0d5a2:         len2 = gallopLeft(a[base1 + len1 - 1], a, base2, len2, len2 - 1, c);
1:8f0d5a2:         if (DEBUG) assert len2 >= 0;
1:8f0d5a2:         if (len2 == 0)
1:8f0d5a2:             return;
1:8f0d5a2:         // Merge remaining runs, using tmp array with min(len1, len2) elements
1:8f0d5a2:         if (len1 <= len2)
1:8f0d5a2:             mergeLo(base1, len1, base2, len2);
1:8f0d5a2:         else
1:8f0d5a2:             mergeHi(base1, len1, base2, len2);
1:8f0d5a2:     }
1:8f0d5a2:     /**
1:8f0d5a2:      * Locates the position at which to insert the specified key into the
1:8f0d5a2:      * specified sorted range; if the range contains an element equal to key,
1:8f0d5a2:      * returns the index of the leftmost equal element.
1:8f0d5a2:      *
1:8f0d5a2:      * @param key the key whose insertion point to search for
1:8f0d5a2:      * @param a the array in which to search
1:8f0d5a2:      * @param base the index of the first element in the range
1:8f0d5a2:      * @param len the length of the range; must be > 0
1:8f0d5a2:      * @param hint the index at which to begin the search, 0 <= hint < n.
1:8f0d5a2:      *     The closer hint is to the result, the faster this method will run.
1:8f0d5a2:      * @param c the comparator used to order the range, and to search
1:8f0d5a2:      * @return the int k,  0 <= k <= n such that a[b + k - 1] < key <= a[b + k],
1:8f0d5a2:      *    pretending that a[b - 1] is minus infinity and a[b + n] is infinity.
1:8f0d5a2:      *    In other words, key belongs at index b + k; or in other words,
1:8f0d5a2:      *    the first k elements of a should precede key, and the last n - k
1:8f0d5a2:      *    should follow it.
1:8f0d5a2:      */
1:8f0d5a2:     private static int gallopLeft(long key, long[] a, int base, int len, int hint,
1:8f0d5a2:                                   LongComparator c) {
1:8f0d5a2:         if (DEBUG) assert len > 0 && hint >= 0 && hint < len;
1:8f0d5a2:         int lastOfs = 0;
1:8f0d5a2:         int ofs = 1;
1:8f0d5a2:         if (c.compare(key, a[base + hint]) > 0) {
1:8f0d5a2:             // Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
1:8f0d5a2:             int maxOfs = len - hint;
1:8f0d5a2:             while (ofs < maxOfs && c.compare(key, a[base + hint + ofs]) > 0) {
1:8f0d5a2:                 lastOfs = ofs;
1:8f0d5a2:                 ofs = (ofs << 1) + 1;
1:8f0d5a2:                 if (ofs <= 0)   // int overflow
1:8f0d5a2:                     ofs = maxOfs;
1:8f0d5a2:             }
1:8f0d5a2:             if (ofs > maxOfs)
1:8f0d5a2:                 ofs = maxOfs;
1:8f0d5a2:             // Make offsets relative to base
1:8f0d5a2:             lastOfs += hint;
1:8f0d5a2:             ofs += hint;
1:8f0d5a2:         } else { // key <= a[base + hint]
1:8f0d5a2:             // Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
1:8f0d5a2:             final int maxOfs = hint + 1;
1:8f0d5a2:             while (ofs < maxOfs && c.compare(key, a[base + hint - ofs]) <= 0) {
1:8f0d5a2:                 lastOfs = ofs;
1:8f0d5a2:                 ofs = (ofs << 1) + 1;
1:8f0d5a2:                 if (ofs <= 0)   // int overflow
1:8f0d5a2:                     ofs = maxOfs;
1:8f0d5a2:             }
1:8f0d5a2:             if (ofs > maxOfs)
1:8f0d5a2:                 ofs = maxOfs;
1:8f0d5a2:             // Make offsets relative to base
1:8f0d5a2:             int tmp = lastOfs;
1:8f0d5a2:             lastOfs = hint - ofs;
1:8f0d5a2:             ofs = hint - tmp;
1:8f0d5a2:         }
1:8f0d5a2:         if (DEBUG) assert -1 <= lastOfs && lastOfs < ofs && ofs <= len;
1:8f0d5a2:         /*
1:8f0d5a2:          * Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
1:8f0d5a2:          * to the right of lastOfs but no farther right than ofs.  Do a binary
1:8f0d5a2:          * search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
1:8f0d5a2:          */
1:8f0d5a2:         lastOfs++;
1:8f0d5a2:         while (lastOfs < ofs) {
1:8f0d5a2:             int m = lastOfs + ((ofs - lastOfs) >>> 1);
1:8f0d5a2:             if (c.compare(key, a[base + m]) > 0)
1:8f0d5a2:                 lastOfs = m + 1;  // a[base + m] < key
1:8f0d5a2:             else
1:8f0d5a2:                 ofs = m;          // key <= a[base + m]
1:8f0d5a2:         }
1:8f0d5a2:         if (DEBUG) assert lastOfs == ofs;    // so a[base + ofs - 1] < key <= a[base + ofs]
1:8f0d5a2:         return ofs;
1:8f0d5a2:     }
1:8f0d5a2:     /**
1:8f0d5a2:      * Like gallopLeft, except that if the range contains an element equal to
1:8f0d5a2:      * key, gallopRight returns the index after the rightmost equal element.
1:8f0d5a2:      *
1:8f0d5a2:      * @param key the key whose insertion point to search for
1:8f0d5a2:      * @param a the array in which to search
1:8f0d5a2:      * @param base the index of the first element in the range
1:8f0d5a2:      * @param len the length of the range; must be > 0
1:8f0d5a2:      * @param hint the index at which to begin the search, 0 <= hint < n.
1:8f0d5a2:      *     The closer hint is to the result, the faster this method will run.
1:8f0d5a2:      * @param c the comparator used to order the range, and to search
1:8f0d5a2:      * @return the int k,  0 <= k <= n such that a[b + k - 1] <= key < a[b + k]
1:8f0d5a2:      */
1:8f0d5a2:     private static int gallopRight(long key, long[] a, int base, int len,
1:8f0d5a2:                                        int hint, LongComparator c) {
1:8f0d5a2:         if (DEBUG) assert len > 0 && hint >= 0 && hint < len;
1:8f0d5a2:         int ofs = 1;
1:8f0d5a2:         int lastOfs = 0;
1:8f0d5a2:         if (c.compare(key, a[base + hint]) < 0) {
1:8f0d5a2:             // Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
1:8f0d5a2:             int maxOfs = hint + 1;
1:8f0d5a2:             while (ofs < maxOfs && c.compare(key, a[base + hint - ofs]) < 0) {
1:8f0d5a2:                 lastOfs = ofs;
1:8f0d5a2:                 ofs = (ofs << 1) + 1;
1:8f0d5a2:                 if (ofs <= 0)   // int overflow
1:8f0d5a2:                     ofs = maxOfs;
1:8f0d5a2:             }
1:8f0d5a2:             if (ofs > maxOfs)
1:8f0d5a2:                 ofs = maxOfs;
1:8f0d5a2:             // Make offsets relative to b
1:8f0d5a2:             int tmp = lastOfs;
1:8f0d5a2:             lastOfs = hint - ofs;
1:8f0d5a2:             ofs = hint - tmp;
1:8f0d5a2:         } else { // a[b + hint] <= key
1:8f0d5a2:             // Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
1:8f0d5a2:             int maxOfs = len - hint;
1:8f0d5a2:             while (ofs < maxOfs && c.compare(key, a[base + hint + ofs]) >= 0) {
1:8f0d5a2:                 lastOfs = ofs;
1:8f0d5a2:                 ofs = (ofs << 1) + 1;
1:8f0d5a2:                 if (ofs <= 0)   // int overflow
1:8f0d5a2:                     ofs = maxOfs;
1:8f0d5a2:             }
1:8f0d5a2:             if (ofs > maxOfs)
1:8f0d5a2:                 ofs = maxOfs;
1:8f0d5a2:             // Make offsets relative to b
1:8f0d5a2:             lastOfs += hint;
1:8f0d5a2:             ofs += hint;
1:8f0d5a2:         }
1:8f0d5a2:         if (DEBUG) assert -1 <= lastOfs && lastOfs < ofs && ofs <= len;
1:8f0d5a2:         /*
1:8f0d5a2:          * Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
1:8f0d5a2:          * the right of lastOfs but no farther right than ofs.  Do a binary
1:8f0d5a2:          * search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
1:8f0d5a2:          */
1:8f0d5a2:         lastOfs++;
1:8f0d5a2:         while (lastOfs < ofs) {
1:8f0d5a2:             int m = lastOfs + ((ofs - lastOfs) >>> 1);
1:8f0d5a2:             if (c.compare(key, a[base + m]) < 0)
1:8f0d5a2:                 ofs = m;          // key < a[b + m]
1:8f0d5a2:             else
1:8f0d5a2:                 lastOfs = m + 1;  // a[b + m] <= key
1:8f0d5a2:         }
1:8f0d5a2:         if (DEBUG) assert lastOfs == ofs;    // so a[b + ofs - 1] <= key < a[b + ofs]
1:8f0d5a2:         return ofs;
1:8f0d5a2:     }
1:8f0d5a2:     /**
1:8f0d5a2:      * Merges two adjacent runs in place, in a stable fashion.  The first
1:8f0d5a2:      * element of the first run must be greater than the first element of the
1:8f0d5a2:      * second run (a[base1] > a[base2]), and the last element of the first run
1:8f0d5a2:      * (a[base1 + len1-1]) must be greater than all elements of the second run.
1:8f0d5a2:      *
1:8f0d5a2:      * For performance, this method should be called only when len1 <= len2;
1:8f0d5a2:      * its twin, mergeHi should be called if len1 >= len2.  (Either method
1:8f0d5a2:      * may be called if len1 == len2.)
1:8f0d5a2:      *
1:8f0d5a2:      * @param base1 index of first element in first run to be merged
1:8f0d5a2:      * @param len1  length of first run to be merged (must be > 0)
1:8f0d5a2:      * @param base2 index of first element in second run to be merged
1:8f0d5a2:      *        (must be aBase + aLen)
1:8f0d5a2:      * @param len2  length of second run to be merged (must be > 0)
1:8f0d5a2:      */
1:8f0d5a2:     private void mergeLo(int base1, int len1, int base2, int len2) {
1:8f0d5a2:         if (DEBUG) assert len1 > 0 && len2 > 0 && base1 + len1 == base2;
1:8f0d5a2:         // Copy first run into temp array
1:8f0d5a2:         long[] a = this.a; // For performance
1:8f0d5a2:         long[] tmp = ensureCapacity(len1);
1:8f0d5a2:         System.arraycopy(a, base1, tmp, 0, len1);
1:8f0d5a2:         int cursor1 = 0;       // Indexes into tmp array
1:8f0d5a2:         int cursor2 = base2;   // Indexes int a
1:8f0d5a2:         int dest = base1;      // Indexes int a
1:8f0d5a2:         // Move first element of second run and deal with degenerate cases
1:8f0d5a2:         a[dest++] = a[cursor2++];
1:8f0d5a2:         if (--len2 == 0) {
1:8f0d5a2:             System.arraycopy(tmp, cursor1, a, dest, len1);
1:8f0d5a2:             return;
1:8f0d5a2:         }
1:8f0d5a2:         if (len1 == 1) {
1:8f0d5a2:             System.arraycopy(a, cursor2, a, dest, len2);
1:8f0d5a2:             a[dest + len2] = tmp[cursor1]; // Last elt of run 1 to end of merge
1:8f0d5a2:             return;
1:8f0d5a2:         }
1:8f0d5a2:         LongComparator c = this.c;  // Use local variable for performance
1:8f0d5a2:         int minGallop = this.minGallop;    //  "    "       "     "      "
1:8f0d5a2:         outer:
1:8f0d5a2:         while (true) {
1:8f0d5a2:             int count1 = 0; // Number of times in a row that first run won
1:8f0d5a2:             int count2 = 0; // Number of times in a row that second run won
1:8f0d5a2:             /*
1:8f0d5a2:              * Do the straightforward thing until (if ever) one run starts
1:8f0d5a2:              * winning consistently.
1:8f0d5a2:              */
1:8f0d5a2:             do {
1:8f0d5a2:                 if (DEBUG) assert len1 > 1 && len2 > 0;
1:8f0d5a2:                 if (c.compare(a[cursor2], tmp[cursor1]) < 0) {
1:8f0d5a2:                     a[dest++] = a[cursor2++];
1:8f0d5a2:                     count2++;
1:8f0d5a2:                     count1 = 0;
1:8f0d5a2:                     if (--len2 == 0)
1:8f0d5a2:                         break outer;
1:8f0d5a2:                 } else {
1:8f0d5a2:                     a[dest++] = tmp[cursor1++];
1:8f0d5a2:                     count1++;
1:8f0d5a2:                     count2 = 0;
1:8f0d5a2:                     if (--len1 == 1)
1:8f0d5a2:                         break outer;
1:8f0d5a2:                 }
1:8f0d5a2:             } while ((count1 | count2) < minGallop);
1:8f0d5a2:             /*
1:8f0d5a2:              * One run is winning so consistently that galloping may be a
1:8f0d5a2:              * huge win. So try that, and continue galloping until (if ever)
1:8f0d5a2:              * neither run appears to be winning consistently anymore.
1:8f0d5a2:              */
1:8f0d5a2:             do {
1:8f0d5a2:                 if (DEBUG) assert len1 > 1 && len2 > 0;
1:8f0d5a2:                 count1 = gallopRight(a[cursor2], tmp, cursor1, len1, 0, c);
1:8f0d5a2:                 if (count1 != 0) {
1:8f0d5a2:                     System.arraycopy(tmp, cursor1, a, dest, count1);
1:8f0d5a2:                     dest += count1;
1:8f0d5a2:                     cursor1 += count1;
1:8f0d5a2:                     len1 -= count1;
1:8f0d5a2:                     if (len1 <= 1) // len1 == 1 || len1 == 0
1:8f0d5a2:                         break outer;
1:8f0d5a2:                 }
1:8f0d5a2:                 a[dest++] = a[cursor2++];
1:8f0d5a2:                 if (--len2 == 0)
1:8f0d5a2:                     break outer;
1:8f0d5a2:                 count2 = gallopLeft(tmp[cursor1], a, cursor2, len2, 0, c);
1:8f0d5a2:                 if (count2 != 0) {
1:8f0d5a2:                     System.arraycopy(a, cursor2, a, dest, count2);
1:8f0d5a2:                     dest += count2;
1:8f0d5a2:                     cursor2 += count2;
1:8f0d5a2:                     len2 -= count2;
1:8f0d5a2:                     if (len2 == 0)
1:8f0d5a2:                         break outer;
1:8f0d5a2:                 }
1:8f0d5a2:                 a[dest++] = tmp[cursor1++];
1:8f0d5a2:                 if (--len1 == 1)
1:8f0d5a2:                     break outer;
1:8f0d5a2:                 minGallop--;
1:8f0d5a2:             } while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);
1:8f0d5a2:             if (minGallop < 0)
1:8f0d5a2:                 minGallop = 0;
1:8f0d5a2:             minGallop += 2;  // Penalize for leaving gallop mode
1:8f0d5a2:         }  // End of "outer" loop
1:8f0d5a2:         this.minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field
1:8f0d5a2:         if (len1 == 1) {
1:8f0d5a2:             if (DEBUG) assert len2 > 0;
1:8f0d5a2:             System.arraycopy(a, cursor2, a, dest, len2);
1:8f0d5a2:             a[dest + len2] = tmp[cursor1]; //  Last elt of run 1 to end of merge
1:8f0d5a2:         } else if (len1 == 0) {
1:8f0d5a2:             throw new IllegalArgumentException(
1:8f0d5a2:                                               "Comparison method violates its general contract!");
1:8f0d5a2:         } else {
1:8f0d5a2:             if (DEBUG) assert len2 == 0;
1:8f0d5a2:             if (DEBUG) assert len1 > 1;
1:8f0d5a2:             System.arraycopy(tmp, cursor1, a, dest, len1);
1:8f0d5a2:         }
1:8f0d5a2:     }
1:8f0d5a2:     /**
1:8f0d5a2:      * Like mergeLo, except that this method should be called only if
1:8f0d5a2:      * len1 >= len2; mergeLo should be called if len1 <= len2.  (Either method
1:8f0d5a2:      * may be called if len1 == len2.)
1:8f0d5a2:      *
1:8f0d5a2:      * @param base1 index of first element in first run to be merged
1:8f0d5a2:      * @param len1  length of first run to be merged (must be > 0)
1:8f0d5a2:      * @param base2 index of first element in second run to be merged
1:8f0d5a2:      *        (must be aBase + aLen)
1:8f0d5a2:      * @param len2  length of second run to be merged (must be > 0)
1:8f0d5a2:      */
1:8f0d5a2:     private void mergeHi(int base1, int len1, int base2, int len2) {
1:8f0d5a2:         if (DEBUG) assert len1 > 0 && len2 > 0 && base1 + len1 == base2;
1:8f0d5a2:         // Copy second run into temp array
1:8f0d5a2:         long[] a = this.a; // For performance
1:8f0d5a2:         long[] tmp = ensureCapacity(len2);
1:8f0d5a2:         System.arraycopy(a, base2, tmp, 0, len2);
1:8f0d5a2:         int cursor1 = base1 + len1 - 1;  // Indexes into a
1:8f0d5a2:         int cursor2 = len2 - 1;          // Indexes into tmp array
1:8f0d5a2:         int dest = base2 + len2 - 1;     // Indexes into a
1:8f0d5a2:         // Move last element of first run and deal with degenerate cases
1:8f0d5a2:         a[dest--] = a[cursor1--];
1:8f0d5a2:         if (--len1 == 0) {
1:8f0d5a2:             System.arraycopy(tmp, 0, a, dest - (len2 - 1), len2);
1:8f0d5a2:             return;
1:8f0d5a2:         }
1:8f0d5a2:         if (len2 == 1) {
1:8f0d5a2:             dest -= len1;
1:8f0d5a2:             cursor1 -= len1;
1:8f0d5a2:             System.arraycopy(a, cursor1 + 1, a, dest + 1, len1);
1:8f0d5a2:             a[dest] = tmp[cursor2];
1:8f0d5a2:             return;
1:8f0d5a2:         }
1:8f0d5a2:         LongComparator c = this.c;  // Use local variable for performance
1:8f0d5a2:         int minGallop = this.minGallop;    //  "    "       "     "      "
1:8f0d5a2:         outer:
1:8f0d5a2:         while (true) {
1:8f0d5a2:             int count1 = 0; // Number of times in a row that first run won
1:8f0d5a2:             int count2 = 0; // Number of times in a row that second run won
1:8f0d5a2:             /*
1:8f0d5a2:              * Do the straightforward thing until (if ever) one run
1:8f0d5a2:              * appears to win consistently.
1:8f0d5a2:              */
1:8f0d5a2:             do {
1:8f0d5a2:                 if (DEBUG) assert len1 > 0 && len2 > 1;
1:8f0d5a2:                 if (c.compare(tmp[cursor2], a[cursor1]) < 0) {
1:8f0d5a2:                     a[dest--] = a[cursor1--];
1:8f0d5a2:                     count1++;
1:8f0d5a2:                     count2 = 0;
1:8f0d5a2:                     if (--len1 == 0)
1:8f0d5a2:                         break outer;
1:8f0d5a2:                 } else {
1:8f0d5a2:                     a[dest--] = tmp[cursor2--];
1:8f0d5a2:                     count2++;
1:8f0d5a2:                     count1 = 0;
1:8f0d5a2:                     if (--len2 == 1)
1:8f0d5a2:                         break outer;
1:8f0d5a2:                 }
1:8f0d5a2:             } while ((count1 | count2) < minGallop);
1:8f0d5a2:             /*
1:8f0d5a2:              * One run is winning so consistently that galloping may be a
1:8f0d5a2:              * huge win. So try that, and continue galloping until (if ever)
1:8f0d5a2:              * neither run appears to be winning consistently anymore.
1:8f0d5a2:              */
1:8f0d5a2:             do {
1:8f0d5a2:                 if (DEBUG) assert len1 > 0 && len2 > 1;
1:8f0d5a2:                 count1 = len1 - gallopRight(tmp[cursor2], a, base1, len1, len1 - 1, c);
1:8f0d5a2:                 if (count1 != 0) {
1:8f0d5a2:                     dest -= count1;
1:8f0d5a2:                     cursor1 -= count1;
1:8f0d5a2:                     len1 -= count1;
1:8f0d5a2:                     System.arraycopy(a, cursor1 + 1, a, dest + 1, count1);
1:8f0d5a2:                     if (len1 == 0)
1:8f0d5a2:                         break outer;
1:8f0d5a2:                 }
1:8f0d5a2:                 a[dest--] = tmp[cursor2--];
1:8f0d5a2:                 if (--len2 == 1)
1:8f0d5a2:                     break outer;
1:8f0d5a2:                 count2 = len2 - gallopLeft(a[cursor1], tmp, 0, len2, len2 - 1, c);
1:8f0d5a2:                 if (count2 != 0) {
1:8f0d5a2:                     dest -= count2;
1:8f0d5a2:                     cursor2 -= count2;
1:8f0d5a2:                     len2 -= count2;
1:8f0d5a2:                     System.arraycopy(tmp, cursor2 + 1, a, dest + 1, count2);
1:8f0d5a2:                     if (len2 <= 1)  // len2 == 1 || len2 == 0
1:8f0d5a2:                         break outer;
1:8f0d5a2:                 }
1:8f0d5a2:                 a[dest--] = a[cursor1--];
1:8f0d5a2:                 if (--len1 == 0)
1:8f0d5a2:                     break outer;
1:8f0d5a2:                 minGallop--;
1:8f0d5a2:             } while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);
1:8f0d5a2:             if (minGallop < 0)
1:8f0d5a2:                 minGallop = 0;
1:8f0d5a2:             minGallop += 2;  // Penalize for leaving gallop mode
1:8f0d5a2:         }  // End of "outer" loop
1:8f0d5a2:         this.minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field
1:8f0d5a2:         if (len2 == 1) {
1:8f0d5a2:             if (DEBUG) assert len1 > 0;
1:8f0d5a2:             dest -= len1;
1:8f0d5a2:             cursor1 -= len1;
1:8f0d5a2:             System.arraycopy(a, cursor1 + 1, a, dest + 1, len1);
1:8f0d5a2:             a[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
1:8f0d5a2:         } else if (len2 == 0) {
1:8f0d5a2:             throw new IllegalArgumentException(
1:8f0d5a2:                                               "Comparison method violates its general contract!");
1:8f0d5a2:         } else {
1:8f0d5a2:             if (DEBUG) assert len1 == 0;
1:8f0d5a2:             if (DEBUG) assert len2 > 0;
1:8f0d5a2:             System.arraycopy(tmp, 0, a, dest - (len2 - 1), len2);
1:8f0d5a2:         }
1:8f0d5a2:     }
1:8f0d5a2:     /**
1:8f0d5a2:      * Ensures that the external array tmp has at least the specified
1:8f0d5a2:      * number of elements, increasing its size if necessary.  The size
1:8f0d5a2:      * increases exponentially to ensure amortized linear time complexity.
1:8f0d5a2:      *
1:8f0d5a2:      * @param minCapacity the minimum required capacity of the tmp array
1:8f0d5a2:      * @return tmp, whether or not it grew
1:8f0d5a2:      */
1:8f0d5a2:     private long[] ensureCapacity(int minCapacity) {
1:8f0d5a2:         if (tmp.length < minCapacity) {
1:8f0d5a2:             // Compute smallest power of 2 > minCapacity
1:8f0d5a2:             int newSize = minCapacity;
1:8f0d5a2:             newSize |= newSize >> 1;
1:8f0d5a2:             newSize |= newSize >> 2;
1:8f0d5a2:             newSize |= newSize >> 4;
1:8f0d5a2:             newSize |= newSize >> 8;
1:8f0d5a2:             newSize |= newSize >> 16;
1:8f0d5a2:             newSize++;
1:8f0d5a2:             if (newSize < 0) // Not bloody likely!
1:8f0d5a2:                 newSize = minCapacity;
1:8f0d5a2:             else
1:8f0d5a2:                 newSize = Math.min(newSize, a.length >>> 1);
1:8f0d5a2:             @SuppressWarnings({"unchecked", "UnnecessaryLocalVariable"})
1:8f0d5a2:             long[] newArray = new long[newSize];
1:8f0d5a2:             tmp = newArray;
1:8f0d5a2:         }
1:8f0d5a2:         return tmp;
1:8f0d5a2:     }
1:8f0d5a2:     /**
1:8f0d5a2:      * Checks that fromIndex and toIndex are in range, and throws an
1:8f0d5a2:      * appropriate exception if they aren't.
1:8f0d5a2:      *
1:8f0d5a2:      * @param arrayLen the length of the array
1:8f0d5a2:      * @param fromIndex the index of the first element of the range
1:8f0d5a2:      * @param toIndex the index after the last element of the range
1:8f0d5a2:      * @throws IllegalArgumentException if fromIndex > toIndex
1:8f0d5a2:      * @throws ArrayIndexOutOfBoundsException if fromIndex < 0
1:8f0d5a2:      *         or toIndex > arrayLen
1:8f0d5a2:      */
1:8f0d5a2:     private static void rangeCheck(int arrayLen, int fromIndex, int toIndex) {
1:8f0d5a2:         if (fromIndex > toIndex)
1:8f0d5a2:             throw new IllegalArgumentException("fromIndex(" + fromIndex +
1:8f0d5a2:                                                ") > toIndex(" + toIndex+")");
1:8f0d5a2:         if (fromIndex < 0)
1:8f0d5a2:             throw new ArrayIndexOutOfBoundsException(fromIndex);
1:8f0d5a2:         if (toIndex > arrayLen)
1:8f0d5a2:             throw new ArrayIndexOutOfBoundsException(toIndex);
1:8f0d5a2:     }
1:8f0d5a2:     
1:8f0d5a2:     // addition to original file
1:8f0d5a2:     
1:8f0d5a2:     @FunctionalInterface
1:8f0d5a2:     public static interface LongComparator
1:8f0d5a2:     {
1:8f0d5a2:         int compare(long o1, long o2);
1:8f0d5a2:     }
1:8f0d5a2: }
============================================================================
author:Robert Stupp
-------------------------------------------------------------------------------
commit:8f0d5a2
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Copyright (C) 2008 The Android Open Source Project
1:  *
1:  * Licensed under the Apache License, Version 2.0 (the "License");
1:  * you may not use this file except in compliance with the License.
1:  * You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: /*
1:  * This file originates from https://android.googlesource.com/platform/libcore/+/gingerbread/luni/src/main/java/java/util/TimSort.java
1:  * and has been modified to sort primitive long arrays instead of object arrays.
1:  */
1: //package java.util;
1: 
1: package org.apache.cassandra.utils;
1: 
1: import java.util.Arrays;
1: 
1: /**
1:  * A stable, adaptive, iterative mergesort that requires far fewer than
1:  * n lg(n) comparisons when running on partially sorted arrays, while
1:  * offering performance comparable to a traditional mergesort when run
1:  * on random arrays.  Like all proper mergesorts, this sort is stable and
1:  * runs O(n log n) time (worst case).  In the worst case, this sort requires
1:  * temporary storage space for n/2 object references; in the best case,
1:  * it requires only a small constant amount of space.
1:  *
1:  * This implementation was adapted from Tim Peters's list sort for
1:  * Python, which is described in detail here:
1:  *
1:  *   http://svn.python.org/projects/python/trunk/Objects/listsort.txt
1:  *
1:  * Tim's C code may be found here:
1:  *
1:  *   http://svn.python.org/projects/python/trunk/Objects/listobject.c
1:  *
1:  * The underlying techniques are described in this paper (and may have
1:  * even earlier origins):
1:  *
1:  *  "Optimistic Sorting and Information Theoretic Complexity"
1:  *  Peter McIlroy
1:  *  SODA (Fourth Annual ACM-SIAM Symposium on Discrete Algorithms),
1:  *  pp 467-474, Austin, Texas, 25-27 January 1993.
1:  *
1:  * While the API to this class consists solely of static methods, it is
1:  * (privately) instantiable; a TimSort instance holds the state of an ongoing
1:  * sort, assuming the input array is large enough to warrant the full-blown
1:  * TimSort. Small arrays are sorted in place, using a binary insertion sort.
1:  */
1: public final class LongTimSort {
1:     /**
1:      * This is the minimum sized sequence that will be merged.  Shorter
1:      * sequences will be lengthened by calling binarySort.  If the entire
1:      * array is less than this length, no merges will be performed.
1:      *
1:      * This constant should be a power of two.  It was 64 in Tim Peter's C
1:      * implementation, but 32 was empirically determined to work better in
1:      * this implementation.  In the unlikely event that you set this constant
1:      * to be a number that's not a power of two, you'll need to change the
1:      * {@link #minRunLength} computation.
1:      *
1:      * If you decrease this constant, you must change the stackLen
1:      * computation in the TimSort constructor, or you risk an
1:      * ArrayOutOfBounds exception.  See listsort.txt for a discussion
1:      * of the minimum stack length required as a function of the length
1:      * of the array being sorted and the minimum merge sequence length.
1:      */
1:     private static final int MIN_MERGE = 32;
1:     /**
1:      * The array being sorted.
1:      */
1:     private final long[] a;
1:     /**
1:      * The comparator for this sort.
1:      */
1:     private final LongComparator c;
1:     /**
1:      * When we get into galloping mode, we stay there until both runs win less
1:      * often than MIN_GALLOP consecutive times.
1:      */
1:     private static final int  MIN_GALLOP = 7;
1:     /**
1:      * This controls when we get *into* galloping mode.  It is initialized
1:      * to MIN_GALLOP.  The mergeLo and mergeHi methods nudge it higher for
1:      * random data, and lower for highly structured data.
1:      */
1:     private int minGallop = MIN_GALLOP;
1:     /**
1:      * Maximum initial size of tmp array, which is used for merging.  The array
1:      * can grow to accommodate demand.
1:      *
1:      * Unlike Tim's original C version, we do not allocate this much storage
1:      * when sorting smaller arrays.  This change was required for performance.
1:      */
1:     private static final int INITIAL_TMP_STORAGE_LENGTH = 256;
1:     /**
1:      * Temp storage for merges.
1:      */
1:     private long[] tmp;
1:     /**
1:      * A stack of pending runs yet to be merged.  Run i starts at
1:      * address base[i] and extends for len[i] elements.  It's always
1:      * true (so long as the indices are in bounds) that:
1:      *
1:      *     runBase[i] + runLen[i] == runBase[i + 1]
1:      *
1:      * so we could cut the storage for this, but it's a minor amount,
1:      * and keeping all the info explicit simplifies the code.
1:      */
1:     private int stackSize = 0;  // Number of pending runs on stack
1:     private final int[] runBase;
1:     private final int[] runLen;
1:     /**
1:      * Asserts have been placed in if-statements for performace. To enable them,
1:      * set this field to true and enable them in VM with a command line flag.
1:      * If you modify this class, please do test the asserts!
1:      */
1:     private static final boolean DEBUG = false;
1:     /**
1:      * Creates a TimSort instance to maintain the state of an ongoing sort.
1:      *
1:      * @param a the array to be sorted
1:      * @param c the comparator to determine the order of the sort
1:      */
1:     private LongTimSort(long[] a, LongComparator c) {
1:         this.a = a;
1:         this.c = c;
1:         // Allocate temp storage (which may be increased later if necessary)
1:         int len = a.length;
1:         @SuppressWarnings({"unchecked", "UnnecessaryLocalVariable"})
1:         long[] newArray = new long[len < 2 * INITIAL_TMP_STORAGE_LENGTH ?
1:                                    len >>> 1 : INITIAL_TMP_STORAGE_LENGTH];
1:         tmp = newArray;
1:         /*
1:          * Allocate runs-to-be-merged stack (which cannot be expanded).  The
1:          * stack length requirements are described in listsort.txt.  The C
1:          * version always uses the same stack length (85), but this was
1:          * measured to be too expensive when sorting "mid-sized" arrays (e.g.,
1:          * 100 elements) in Java.  Therefore, we use smaller (but sufficiently
1:          * large) stack lengths for smaller arrays.  The "magic numbers" in the
1:          * computation below must be changed if MIN_MERGE is decreased.  See
1:          * the MIN_MERGE declaration above for more information.
1:          */
1:         int stackLen = (len <    120  ?  5 :
1:                         len <   1542  ? 10 :
1:                         len < 119151  ? 19 : 40);
1:         runBase = new int[stackLen];
1:         runLen = new int[stackLen];
1:     }
1:     /*
1:      * The next two methods (which are package private and static) constitute
1:      * the entire API of this class.  Each of these methods obeys the contract
1:      * of the public method with the same signature in java.util.Arrays.
1:      */
1:     public static void sort(long[] a, LongComparator c) {
1:         sort(a, 0, a.length, c);
1:     }
1:     public static void sort(long[] a, int lo, int hi, LongComparator c) {
1:         if (c == null) {
1:             Arrays.sort(a, lo, hi);
1:             return;
1:         }
1:         rangeCheck(a.length, lo, hi);
1:         int nRemaining  = hi - lo;
1:         if (nRemaining < 2)
1:             return;  // Arrays of size 0 and 1 are always sorted
1:         // If array is small, do a "mini-TimSort" with no merges
1:         if (nRemaining < MIN_MERGE) {
1:             int initRunLen = countRunAndMakeAscending(a, lo, hi, c);
1:             binarySort(a, lo, hi, lo + initRunLen, c);
1:             return;
1:         }
1:         /**
1:          * March over the array once, left to right, finding natural runs,
1:          * extending short natural runs to minRun elements, and merging runs
1:          * to maintain stack invariant.
1:          */
1:         LongTimSort ts = new LongTimSort(a, c);
1:         int minRun = minRunLength(nRemaining);
1:         do {
1:             // Identify next run
1:             int runLen = countRunAndMakeAscending(a, lo, hi, c);
1:             // If run is short, extend to min(minRun, nRemaining)
1:             if (runLen < minRun) {
1:                 int force = nRemaining <= minRun ? nRemaining : minRun;
1:                 binarySort(a, lo, lo + force, lo + runLen, c);
1:                 runLen = force;
1:             }
1:             // Push run onto pending-run stack, and maybe merge
1:             ts.pushRun(lo, runLen);
1:             ts.mergeCollapse();
1:             // Advance to find next run
1:             lo += runLen;
1:             nRemaining -= runLen;
1:         } while (nRemaining != 0);
1:         // Merge all remaining runs to complete sort
1:         if (DEBUG) assert lo == hi;
1:         ts.mergeForceCollapse();
1:         if (DEBUG) assert ts.stackSize == 1;
1:     }
1:     /**
1:      * Sorts the specified portion of the specified array using a binary
1:      * insertion sort.  This is the best method for sorting small numbers
1:      * of elements.  It requires O(n log n) compares, but O(n^2) data
1:      * movement (worst case).
1:      *
1:      * If the initial part of the specified range is already sorted,
1:      * this method can take advantage of it: the method assumes that the
1:      * elements from index {@code lo}, inclusive, to {@code start},
1:      * exclusive are already sorted.
1:      *
1:      * @param a the array in which a range is to be sorted
1:      * @param lo the index of the first element in the range to be sorted
1:      * @param hi the index after the last element in the range to be sorted
1:      * @param start the index of the first element in the range that is
1:      *        not already known to be sorted (@code lo <= start <= hi}
1:      * @param c comparator to used for the sort
1:      */
1:     @SuppressWarnings("fallthrough")
1:     private static void binarySort(long[] a, int lo, int hi, int start,
1:                                        LongComparator c) {
1:         if (DEBUG) assert lo <= start && start <= hi;
1:         if (start == lo)
1:             start++;
1:         for ( ; start < hi; start++) {
1:             long pivot = a[start];
1:             // Set left (and right) to the index where a[start] (pivot) belongs
1:             int left = lo;
1:             int right = start;
1:             if (DEBUG) assert left <= right;
1:             /*
1:              * Invariants:
1:              *   pivot >= all in [lo, left).
1:              *   pivot <  all in [right, start).
1:              */
1:             while (left < right) {
1:                 int mid = (left + right) >>> 1;
1:                 if (c.compare(pivot, a[mid]) < 0)
1:                     right = mid;
1:                 else
1:                     left = mid + 1;
1:             }
1:             if (DEBUG) assert left == right;
1:             /*
1:              * The invariants still hold: pivot >= all in [lo, left) and
1:              * pivot < all in [left, start), so pivot belongs at left.  Note
1:              * that if there are elements equal to pivot, left points to the
1:              * first slot after them -- that's why this sort is stable.
1:              * Slide elements over to make room to make room for pivot.
1:              */
1:             int n = start - left;  // The number of elements to move
1:             // Switch is just an optimization for arraycopy in default case
1:             switch(n) {
1:                 case 2:  a[left + 2] = a[left + 1];
1:                 case 1:  a[left + 1] = a[left];
1:                     break;
1:                 default: System.arraycopy(a, left, a, left + 1, n);
1:             }
1:             a[left] = pivot;
1:         }
1:     }
1:     /**
1:      * Returns the length of the run beginning at the specified position in
1:      * the specified array and reverses the run if it is descending (ensuring
1:      * that the run will always be ascending when the method returns).
1:      *
1:      * A run is the longest ascending sequence with:
1:      *
1:      *    a[lo] <= a[lo + 1] <= a[lo + 2] <= ...
1:      *
1:      * or the longest descending sequence with:
1:      *
1:      *    a[lo] >  a[lo + 1] >  a[lo + 2] >  ...
1:      *
1:      * For its intended use in a stable mergesort, the strictness of the
1:      * definition of "descending" is needed so that the call can safely
1:      * reverse a descending sequence without violating stability.
1:      *
1:      * @param a the array in which a run is to be counted and possibly reversed
1:      * @param lo index of the first element in the run
1:      * @param hi index after the last element that may be contained in the run.
1:     It is required that @code{lo < hi}.
1:      * @param c the comparator to used for the sort
1:      * @return  the length of the run beginning at the specified position in
1:      *          the specified array
1:      */
1:     private static int countRunAndMakeAscending(long[] a, int lo, int hi,
1:                                                 LongComparator c) {
1:         if (DEBUG) assert lo < hi;
1:         int runHi = lo + 1;
1:         if (runHi == hi)
1:             return 1;
1:         // Find end of run, and reverse range if descending
1:         if (c.compare(a[runHi++], a[lo]) < 0) { // Descending
1:             while(runHi < hi && c.compare(a[runHi], a[runHi - 1]) < 0)
1:                 runHi++;
1:             reverseRange(a, lo, runHi);
1:         } else {                              // Ascending
1:             while (runHi < hi && c.compare(a[runHi], a[runHi - 1]) >= 0)
1:                 runHi++;
1:         }
1:         return runHi - lo;
1:     }
1:     /**
1:      * Reverse the specified range of the specified array.
1:      *
1:      * @param a the array in which a range is to be reversed
1:      * @param lo the index of the first element in the range to be reversed
1:      * @param hi the index after the last element in the range to be reversed
1:      */
1:     private static void reverseRange(long[] a, int lo, int hi) {
1:         hi--;
1:         while (lo < hi) {
1:             long t = a[lo];
1:             a[lo++] = a[hi];
1:             a[hi--] = t;
1:         }
1:     }
1:     /**
1:      * Returns the minimum acceptable run length for an array of the specified
1:      * length. Natural runs shorter than this will be extended with
1:      * {@link #binarySort}.
1:      *
1:      * Roughly speaking, the computation is:
1:      *
1:      *  If n < MIN_MERGE, return n (it's too small to bother with fancy stuff).
1:      *  Else if n is an exact power of 2, return MIN_MERGE/2.
1:      *  Else return an int k, MIN_MERGE/2 <= k <= MIN_MERGE, such that n/k
1:      *   is close to, but strictly less than, an exact power of 2.
1:      *
1:      * For the rationale, see listsort.txt.
1:      *
1:      * @param n the length of the array to be sorted
1:      * @return the length of the minimum run to be merged
1:      */
1:     private static int minRunLength(int n) {
1:         if (DEBUG) assert n >= 0;
1:         int r = 0;      // Becomes 1 if any 1 bits are shifted off
1:         while (n >= MIN_MERGE) {
1:             r |= (n & 1);
1:             n >>= 1;
1:         }
1:         return n + r;
1:     }
1:     /**
1:      * Pushes the specified run onto the pending-run stack.
1:      *
1:      * @param runBase index of the first element in the run
1:      * @param runLen  the number of elements in the run
1:      */
1:     private void pushRun(int runBase, int runLen) {
1:         this.runBase[stackSize] = runBase;
1:         this.runLen[stackSize] = runLen;
1:         stackSize++;
1:     }
1:     /**
1:      * Examines the stack of runs waiting to be merged and merges adjacent runs
1:      * until the stack invariants are reestablished:
1:      *
1:      *     1. runLen[i - 3] > runLen[i - 2] + runLen[i - 1]
1:      *     2. runLen[i - 2] > runLen[i - 1]
1:      *
1:      * This method is called each time a new run is pushed onto the stack,
1:      * so the invariants are guaranteed to hold for i < stackSize upon
1:      * entry to the method.
1:      */
1:     private void mergeCollapse() {
1:         while (stackSize > 1) {
1:             int n = stackSize - 2;
1:             if (n > 0 && runLen[n-1] <= runLen[n] + runLen[n+1]) {
1:                 if (runLen[n - 1] < runLen[n + 1])
1:                     n--;
1:                 mergeAt(n);
1:             } else if (runLen[n] <= runLen[n + 1]) {
1:                 mergeAt(n);
1:             } else {
1:                 break; // Invariant is established
1:             }
1:         }
1:     }
1:     /**
1:      * Merges all runs on the stack until only one remains.  This method is
1:      * called once, to complete the sort.
1:      */
1:     private void mergeForceCollapse() {
1:         while (stackSize > 1) {
1:             int n = stackSize - 2;
1:             if (n > 0 && runLen[n - 1] < runLen[n + 1])
1:                 n--;
1:             mergeAt(n);
1:         }
1:     }
1:     /**
1:      * Merges the two runs at stack indices i and i+1.  Run i must be
1:      * the penultimate or antepenultimate run on the stack.  In other words,
1:      * i must be equal to stackSize-2 or stackSize-3.
1:      *
1:      * @param i stack index of the first of the two runs to merge
1:      */
1:     private void mergeAt(int i) {
1:         if (DEBUG) assert stackSize >= 2;
1:         if (DEBUG) assert i >= 0;
1:         if (DEBUG) assert i == stackSize - 2 || i == stackSize - 3;
1:         int base1 = runBase[i];
1:         int len1 = runLen[i];
1:         int base2 = runBase[i + 1];
1:         int len2 = runLen[i + 1];
1:         if (DEBUG) assert len1 > 0 && len2 > 0;
1:         if (DEBUG) assert base1 + len1 == base2;
1:         /*
1:          * Record the length of the combined runs; if i is the 3rd-last
1:          * run now, also slide over the last run (which isn't involved
1:          * in this merge).  The current run (i+1) goes away in any case.
1:          */
1:         runLen[i] = len1 + len2;
1:         if (i == stackSize - 3) {
1:             runBase[i + 1] = runBase[i + 2];
1:             runLen[i + 1] = runLen[i + 2];
1:         }
1:         stackSize--;
1:         /*
1:          * Find where the first element of run2 goes in run1. Prior elements
1:          * in run1 can be ignored (because they're already in place).
1:          */
1:         int k = gallopRight(a[base2], a, base1, len1, 0, c);
1:         if (DEBUG) assert k >= 0;
1:         base1 += k;
1:         len1 -= k;
1:         if (len1 == 0)
1:             return;
1:         /*
1:          * Find where the last element of run1 goes in run2. Subsequent elements
1:          * in run2 can be ignored (because they're already in place).
1:          */
1:         len2 = gallopLeft(a[base1 + len1 - 1], a, base2, len2, len2 - 1, c);
1:         if (DEBUG) assert len2 >= 0;
1:         if (len2 == 0)
1:             return;
1:         // Merge remaining runs, using tmp array with min(len1, len2) elements
1:         if (len1 <= len2)
1:             mergeLo(base1, len1, base2, len2);
1:         else
1:             mergeHi(base1, len1, base2, len2);
1:     }
1:     /**
1:      * Locates the position at which to insert the specified key into the
1:      * specified sorted range; if the range contains an element equal to key,
1:      * returns the index of the leftmost equal element.
1:      *
1:      * @param key the key whose insertion point to search for
1:      * @param a the array in which to search
1:      * @param base the index of the first element in the range
1:      * @param len the length of the range; must be > 0
1:      * @param hint the index at which to begin the search, 0 <= hint < n.
1:      *     The closer hint is to the result, the faster this method will run.
1:      * @param c the comparator used to order the range, and to search
1:      * @return the int k,  0 <= k <= n such that a[b + k - 1] < key <= a[b + k],
1:      *    pretending that a[b - 1] is minus infinity and a[b + n] is infinity.
1:      *    In other words, key belongs at index b + k; or in other words,
1:      *    the first k elements of a should precede key, and the last n - k
1:      *    should follow it.
1:      */
1:     private static int gallopLeft(long key, long[] a, int base, int len, int hint,
1:                                   LongComparator c) {
1:         if (DEBUG) assert len > 0 && hint >= 0 && hint < len;
1:         int lastOfs = 0;
1:         int ofs = 1;
1:         if (c.compare(key, a[base + hint]) > 0) {
1:             // Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
1:             int maxOfs = len - hint;
1:             while (ofs < maxOfs && c.compare(key, a[base + hint + ofs]) > 0) {
1:                 lastOfs = ofs;
1:                 ofs = (ofs << 1) + 1;
1:                 if (ofs <= 0)   // int overflow
1:                     ofs = maxOfs;
1:             }
1:             if (ofs > maxOfs)
1:                 ofs = maxOfs;
1:             // Make offsets relative to base
1:             lastOfs += hint;
1:             ofs += hint;
1:         } else { // key <= a[base + hint]
1:             // Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
1:             final int maxOfs = hint + 1;
1:             while (ofs < maxOfs && c.compare(key, a[base + hint - ofs]) <= 0) {
1:                 lastOfs = ofs;
1:                 ofs = (ofs << 1) + 1;
1:                 if (ofs <= 0)   // int overflow
1:                     ofs = maxOfs;
1:             }
1:             if (ofs > maxOfs)
1:                 ofs = maxOfs;
1:             // Make offsets relative to base
1:             int tmp = lastOfs;
1:             lastOfs = hint - ofs;
1:             ofs = hint - tmp;
1:         }
1:         if (DEBUG) assert -1 <= lastOfs && lastOfs < ofs && ofs <= len;
1:         /*
1:          * Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
1:          * to the right of lastOfs but no farther right than ofs.  Do a binary
1:          * search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
1:          */
1:         lastOfs++;
1:         while (lastOfs < ofs) {
1:             int m = lastOfs + ((ofs - lastOfs) >>> 1);
1:             if (c.compare(key, a[base + m]) > 0)
1:                 lastOfs = m + 1;  // a[base + m] < key
1:             else
1:                 ofs = m;          // key <= a[base + m]
1:         }
1:         if (DEBUG) assert lastOfs == ofs;    // so a[base + ofs - 1] < key <= a[base + ofs]
1:         return ofs;
1:     }
1:     /**
1:      * Like gallopLeft, except that if the range contains an element equal to
1:      * key, gallopRight returns the index after the rightmost equal element.
1:      *
1:      * @param key the key whose insertion point to search for
1:      * @param a the array in which to search
1:      * @param base the index of the first element in the range
1:      * @param len the length of the range; must be > 0
1:      * @param hint the index at which to begin the search, 0 <= hint < n.
1:      *     The closer hint is to the result, the faster this method will run.
1:      * @param c the comparator used to order the range, and to search
1:      * @return the int k,  0 <= k <= n such that a[b + k - 1] <= key < a[b + k]
1:      */
1:     private static int gallopRight(long key, long[] a, int base, int len,
1:                                        int hint, LongComparator c) {
1:         if (DEBUG) assert len > 0 && hint >= 0 && hint < len;
1:         int ofs = 1;
1:         int lastOfs = 0;
1:         if (c.compare(key, a[base + hint]) < 0) {
1:             // Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
1:             int maxOfs = hint + 1;
1:             while (ofs < maxOfs && c.compare(key, a[base + hint - ofs]) < 0) {
1:                 lastOfs = ofs;
1:                 ofs = (ofs << 1) + 1;
1:                 if (ofs <= 0)   // int overflow
1:                     ofs = maxOfs;
1:             }
1:             if (ofs > maxOfs)
1:                 ofs = maxOfs;
1:             // Make offsets relative to b
1:             int tmp = lastOfs;
1:             lastOfs = hint - ofs;
1:             ofs = hint - tmp;
1:         } else { // a[b + hint] <= key
1:             // Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
1:             int maxOfs = len - hint;
1:             while (ofs < maxOfs && c.compare(key, a[base + hint + ofs]) >= 0) {
1:                 lastOfs = ofs;
1:                 ofs = (ofs << 1) + 1;
1:                 if (ofs <= 0)   // int overflow
1:                     ofs = maxOfs;
1:             }
1:             if (ofs > maxOfs)
1:                 ofs = maxOfs;
1:             // Make offsets relative to b
1:             lastOfs += hint;
1:             ofs += hint;
1:         }
1:         if (DEBUG) assert -1 <= lastOfs && lastOfs < ofs && ofs <= len;
1:         /*
1:          * Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
1:          * the right of lastOfs but no farther right than ofs.  Do a binary
1:          * search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
1:          */
1:         lastOfs++;
1:         while (lastOfs < ofs) {
1:             int m = lastOfs + ((ofs - lastOfs) >>> 1);
1:             if (c.compare(key, a[base + m]) < 0)
1:                 ofs = m;          // key < a[b + m]
1:             else
1:                 lastOfs = m + 1;  // a[b + m] <= key
1:         }
1:         if (DEBUG) assert lastOfs == ofs;    // so a[b + ofs - 1] <= key < a[b + ofs]
1:         return ofs;
1:     }
1:     /**
1:      * Merges two adjacent runs in place, in a stable fashion.  The first
1:      * element of the first run must be greater than the first element of the
1:      * second run (a[base1] > a[base2]), and the last element of the first run
1:      * (a[base1 + len1-1]) must be greater than all elements of the second run.
1:      *
1:      * For performance, this method should be called only when len1 <= len2;
1:      * its twin, mergeHi should be called if len1 >= len2.  (Either method
1:      * may be called if len1 == len2.)
1:      *
1:      * @param base1 index of first element in first run to be merged
1:      * @param len1  length of first run to be merged (must be > 0)
1:      * @param base2 index of first element in second run to be merged
1:      *        (must be aBase + aLen)
1:      * @param len2  length of second run to be merged (must be > 0)
1:      */
1:     private void mergeLo(int base1, int len1, int base2, int len2) {
1:         if (DEBUG) assert len1 > 0 && len2 > 0 && base1 + len1 == base2;
1:         // Copy first run into temp array
1:         long[] a = this.a; // For performance
1:         long[] tmp = ensureCapacity(len1);
1:         System.arraycopy(a, base1, tmp, 0, len1);
1:         int cursor1 = 0;       // Indexes into tmp array
1:         int cursor2 = base2;   // Indexes int a
1:         int dest = base1;      // Indexes int a
1:         // Move first element of second run and deal with degenerate cases
1:         a[dest++] = a[cursor2++];
1:         if (--len2 == 0) {
1:             System.arraycopy(tmp, cursor1, a, dest, len1);
1:             return;
1:         }
1:         if (len1 == 1) {
1:             System.arraycopy(a, cursor2, a, dest, len2);
1:             a[dest + len2] = tmp[cursor1]; // Last elt of run 1 to end of merge
1:             return;
1:         }
1:         LongComparator c = this.c;  // Use local variable for performance
1:         int minGallop = this.minGallop;    //  "    "       "     "      "
1:         outer:
1:         while (true) {
1:             int count1 = 0; // Number of times in a row that first run won
1:             int count2 = 0; // Number of times in a row that second run won
1:             /*
1:              * Do the straightforward thing until (if ever) one run starts
1:              * winning consistently.
1:              */
1:             do {
1:                 if (DEBUG) assert len1 > 1 && len2 > 0;
1:                 if (c.compare(a[cursor2], tmp[cursor1]) < 0) {
1:                     a[dest++] = a[cursor2++];
1:                     count2++;
1:                     count1 = 0;
1:                     if (--len2 == 0)
1:                         break outer;
1:                 } else {
1:                     a[dest++] = tmp[cursor1++];
1:                     count1++;
1:                     count2 = 0;
1:                     if (--len1 == 1)
1:                         break outer;
1:                 }
1:             } while ((count1 | count2) < minGallop);
1:             /*
1:              * One run is winning so consistently that galloping may be a
1:              * huge win. So try that, and continue galloping until (if ever)
1:              * neither run appears to be winning consistently anymore.
1:              */
1:             do {
1:                 if (DEBUG) assert len1 > 1 && len2 > 0;
1:                 count1 = gallopRight(a[cursor2], tmp, cursor1, len1, 0, c);
1:                 if (count1 != 0) {
1:                     System.arraycopy(tmp, cursor1, a, dest, count1);
1:                     dest += count1;
1:                     cursor1 += count1;
1:                     len1 -= count1;
1:                     if (len1 <= 1) // len1 == 1 || len1 == 0
1:                         break outer;
1:                 }
1:                 a[dest++] = a[cursor2++];
1:                 if (--len2 == 0)
1:                     break outer;
1:                 count2 = gallopLeft(tmp[cursor1], a, cursor2, len2, 0, c);
1:                 if (count2 != 0) {
1:                     System.arraycopy(a, cursor2, a, dest, count2);
1:                     dest += count2;
1:                     cursor2 += count2;
1:                     len2 -= count2;
1:                     if (len2 == 0)
1:                         break outer;
1:                 }
1:                 a[dest++] = tmp[cursor1++];
1:                 if (--len1 == 1)
1:                     break outer;
1:                 minGallop--;
1:             } while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);
1:             if (minGallop < 0)
1:                 minGallop = 0;
1:             minGallop += 2;  // Penalize for leaving gallop mode
1:         }  // End of "outer" loop
1:         this.minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field
1:         if (len1 == 1) {
1:             if (DEBUG) assert len2 > 0;
1:             System.arraycopy(a, cursor2, a, dest, len2);
1:             a[dest + len2] = tmp[cursor1]; //  Last elt of run 1 to end of merge
1:         } else if (len1 == 0) {
1:             throw new IllegalArgumentException(
1:                                               "Comparison method violates its general contract!");
1:         } else {
1:             if (DEBUG) assert len2 == 0;
1:             if (DEBUG) assert len1 > 1;
1:             System.arraycopy(tmp, cursor1, a, dest, len1);
1:         }
1:     }
1:     /**
1:      * Like mergeLo, except that this method should be called only if
1:      * len1 >= len2; mergeLo should be called if len1 <= len2.  (Either method
1:      * may be called if len1 == len2.)
1:      *
1:      * @param base1 index of first element in first run to be merged
1:      * @param len1  length of first run to be merged (must be > 0)
1:      * @param base2 index of first element in second run to be merged
1:      *        (must be aBase + aLen)
1:      * @param len2  length of second run to be merged (must be > 0)
1:      */
1:     private void mergeHi(int base1, int len1, int base2, int len2) {
1:         if (DEBUG) assert len1 > 0 && len2 > 0 && base1 + len1 == base2;
1:         // Copy second run into temp array
1:         long[] a = this.a; // For performance
1:         long[] tmp = ensureCapacity(len2);
1:         System.arraycopy(a, base2, tmp, 0, len2);
1:         int cursor1 = base1 + len1 - 1;  // Indexes into a
1:         int cursor2 = len2 - 1;          // Indexes into tmp array
1:         int dest = base2 + len2 - 1;     // Indexes into a
1:         // Move last element of first run and deal with degenerate cases
1:         a[dest--] = a[cursor1--];
1:         if (--len1 == 0) {
1:             System.arraycopy(tmp, 0, a, dest - (len2 - 1), len2);
1:             return;
1:         }
1:         if (len2 == 1) {
1:             dest -= len1;
1:             cursor1 -= len1;
1:             System.arraycopy(a, cursor1 + 1, a, dest + 1, len1);
1:             a[dest] = tmp[cursor2];
1:             return;
1:         }
1:         LongComparator c = this.c;  // Use local variable for performance
1:         int minGallop = this.minGallop;    //  "    "       "     "      "
1:         outer:
1:         while (true) {
1:             int count1 = 0; // Number of times in a row that first run won
1:             int count2 = 0; // Number of times in a row that second run won
1:             /*
1:              * Do the straightforward thing until (if ever) one run
1:              * appears to win consistently.
1:              */
1:             do {
1:                 if (DEBUG) assert len1 > 0 && len2 > 1;
1:                 if (c.compare(tmp[cursor2], a[cursor1]) < 0) {
1:                     a[dest--] = a[cursor1--];
1:                     count1++;
1:                     count2 = 0;
1:                     if (--len1 == 0)
1:                         break outer;
1:                 } else {
1:                     a[dest--] = tmp[cursor2--];
1:                     count2++;
1:                     count1 = 0;
1:                     if (--len2 == 1)
1:                         break outer;
1:                 }
1:             } while ((count1 | count2) < minGallop);
1:             /*
1:              * One run is winning so consistently that galloping may be a
1:              * huge win. So try that, and continue galloping until (if ever)
1:              * neither run appears to be winning consistently anymore.
1:              */
1:             do {
1:                 if (DEBUG) assert len1 > 0 && len2 > 1;
1:                 count1 = len1 - gallopRight(tmp[cursor2], a, base1, len1, len1 - 1, c);
1:                 if (count1 != 0) {
1:                     dest -= count1;
1:                     cursor1 -= count1;
1:                     len1 -= count1;
1:                     System.arraycopy(a, cursor1 + 1, a, dest + 1, count1);
1:                     if (len1 == 0)
1:                         break outer;
1:                 }
1:                 a[dest--] = tmp[cursor2--];
1:                 if (--len2 == 1)
1:                     break outer;
1:                 count2 = len2 - gallopLeft(a[cursor1], tmp, 0, len2, len2 - 1, c);
1:                 if (count2 != 0) {
1:                     dest -= count2;
1:                     cursor2 -= count2;
1:                     len2 -= count2;
1:                     System.arraycopy(tmp, cursor2 + 1, a, dest + 1, count2);
1:                     if (len2 <= 1)  // len2 == 1 || len2 == 0
1:                         break outer;
1:                 }
1:                 a[dest--] = a[cursor1--];
1:                 if (--len1 == 0)
1:                     break outer;
1:                 minGallop--;
1:             } while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);
1:             if (minGallop < 0)
1:                 minGallop = 0;
1:             minGallop += 2;  // Penalize for leaving gallop mode
1:         }  // End of "outer" loop
1:         this.minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field
1:         if (len2 == 1) {
1:             if (DEBUG) assert len1 > 0;
1:             dest -= len1;
1:             cursor1 -= len1;
1:             System.arraycopy(a, cursor1 + 1, a, dest + 1, len1);
1:             a[dest] = tmp[cursor2];  // Move first elt of run2 to front of merge
1:         } else if (len2 == 0) {
1:             throw new IllegalArgumentException(
1:                                               "Comparison method violates its general contract!");
1:         } else {
1:             if (DEBUG) assert len1 == 0;
1:             if (DEBUG) assert len2 > 0;
1:             System.arraycopy(tmp, 0, a, dest - (len2 - 1), len2);
1:         }
1:     }
1:     /**
1:      * Ensures that the external array tmp has at least the specified
1:      * number of elements, increasing its size if necessary.  The size
1:      * increases exponentially to ensure amortized linear time complexity.
1:      *
1:      * @param minCapacity the minimum required capacity of the tmp array
1:      * @return tmp, whether or not it grew
1:      */
1:     private long[] ensureCapacity(int minCapacity) {
1:         if (tmp.length < minCapacity) {
1:             // Compute smallest power of 2 > minCapacity
1:             int newSize = minCapacity;
1:             newSize |= newSize >> 1;
1:             newSize |= newSize >> 2;
1:             newSize |= newSize >> 4;
1:             newSize |= newSize >> 8;
1:             newSize |= newSize >> 16;
1:             newSize++;
1:             if (newSize < 0) // Not bloody likely!
1:                 newSize = minCapacity;
1:             else
1:                 newSize = Math.min(newSize, a.length >>> 1);
1:             @SuppressWarnings({"unchecked", "UnnecessaryLocalVariable"})
1:             long[] newArray = new long[newSize];
1:             tmp = newArray;
1:         }
1:         return tmp;
1:     }
1:     /**
1:      * Checks that fromIndex and toIndex are in range, and throws an
1:      * appropriate exception if they aren't.
1:      *
1:      * @param arrayLen the length of the array
1:      * @param fromIndex the index of the first element of the range
1:      * @param toIndex the index after the last element of the range
1:      * @throws IllegalArgumentException if fromIndex > toIndex
1:      * @throws ArrayIndexOutOfBoundsException if fromIndex < 0
1:      *         or toIndex > arrayLen
1:      */
1:     private static void rangeCheck(int arrayLen, int fromIndex, int toIndex) {
1:         if (fromIndex > toIndex)
1:             throw new IllegalArgumentException("fromIndex(" + fromIndex +
1:                                                ") > toIndex(" + toIndex+")");
1:         if (fromIndex < 0)
1:             throw new ArrayIndexOutOfBoundsException(fromIndex);
1:         if (toIndex > arrayLen)
1:             throw new ArrayIndexOutOfBoundsException(toIndex);
1:     }
1:     
1:     // addition to original file
1:     
1:     @FunctionalInterface
1:     public static interface LongComparator
1:     {
1:         int compare(long o1, long o2);
1:     }
1: }
============================================================================