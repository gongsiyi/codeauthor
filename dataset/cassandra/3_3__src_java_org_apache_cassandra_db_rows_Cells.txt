1:a991b64: /*
1:a991b64:  * Licensed to the Apache Software Foundation (ASF) under one
1:a991b64:  * or more contributor license agreements.  See the NOTICE file
1:a991b64:  * distributed with this work for additional information
1:a991b64:  * regarding copyright ownership.  The ASF licenses this file
1:a991b64:  * to you under the Apache License, Version 2.0 (the
1:a991b64:  * "License"); you may not use this file except in compliance
1:a991b64:  * with the License.  You may obtain a copy of the License at
3:a991b64:  *
1:a991b64:  *     http://www.apache.org/licenses/LICENSE-2.0
1:a991b64:  *
1:a991b64:  * Unless required by applicable law or agreed to in writing, software
1:a991b64:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a991b64:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a991b64:  * See the License for the specific language governing permissions and
1:a991b64:  * limitations under the License.
3:a991b64:  */
1:a991b64: package org.apache.cassandra.db.rows;
12:a991b64: 
1:a991b64: import java.nio.ByteBuffer;
1:a991b64: import java.util.Comparator;
1:a991b64: import java.util.Iterator;
1:a991b64: 
1:a991b64: import org.apache.cassandra.config.ColumnDefinition;
1:0626be8: import org.apache.cassandra.db.Conflicts;
1:0626be8: import org.apache.cassandra.db.DeletionTime;
1:2457599: import org.apache.cassandra.db.partitions.PartitionStatisticsCollector;
1:a991b64: 
3:a991b64: /**
1:a991b64:  * Static methods to work on cells.
1:a991b64:  */
1:a991b64: public abstract class Cells
13:a991b64: {
1:a991b64:     private Cells() {}
1:a991b64: 
1:a991b64:     /**
1:2457599:      * Collect statistics ont a given cell.
1:a991b64:      *
1:2457599:      * @param cell the cell for which to collect stats.
1:2457599:      * @param collector the stats collector.
1:a991b64:      */
1:2457599:     public static void collectStats(Cell cell, PartitionStatisticsCollector collector)
1:a991b64:     {
1:2457599:         collector.update(cell);
1:a991b64: 
1:2457599:         if (cell.isCounterCell())
1:2457599:             collector.updateHasLegacyCounterShards(CounterCells.hasLegacyShards(cell));
13:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Reconciles/merges two cells, one being an update to an existing cell,
1:a991b64:      * yielding index updates if appropriate.
3:a991b64:      * <p>
1:a991b64:      * Note that this method assumes that the provided cells can meaningfully
1:a991b64:      * be reconciled together, that is that those cells are for the same row and same
1:a991b64:      * column (and same cell path if the column is complex).
1:a991b64:      * <p>
1:a991b64:      * Also note that which cell is provided as {@code existing} and which is
1:a991b64:      * provided as {@code update} matters for index updates.
1:a991b64:      *
1:a991b64:      * @param existing the pre-existing cell, the one that is updated. This can be
1:a991b64:      * {@code null} if this reconciliation correspond to an insertion.
1:a991b64:      * @param update the newly added cell, the update. This can be {@code null} out
1:a991b64:      * of convenience, in which case this function simply copy {@code existing} to
1:a991b64:      * {@code writer}.
1:a991b64:      * @param deletion the deletion time that applies to the cells being considered.
1:a991b64:      * This deletion time may delete both {@code existing} or {@code update}.
1:2457599:      * @param builder the row builder to which the result of the reconciliation is written.
1:a991b64:      * @param nowInSec the current time in seconds (which plays a role during reconciliation
1:a991b64:      * because deleted cells always have precedence on timestamp equality and deciding if a
1:a991b64:      * cell is a live or not depends on the current time due to expiring cells).
1:a991b64:      *
1:a991b64:      * @return the timestamp delta between existing and update, or {@code Long.MAX_VALUE} if one
1:a991b64:      * of them is {@code null} or deleted by {@code deletion}).
1:a991b64:      */
1:0626be8:     public static long reconcile(Cell existing,
1:a991b64:                                  Cell update,
1:a991b64:                                  DeletionTime deletion,
1:2457599:                                  Row.Builder builder,
1:0626be8:                                  int nowInSec)
1:a991b64:     {
1:2457599:         existing = existing == null || deletion.deletes(existing) ? null : existing;
1:2457599:         update = update == null || deletion.deletes(update) ? null : update;
1:a991b64:         if (existing == null || update == null)
1:a991b64:         {
1:a991b64:             if (update != null)
1:a991b64:             {
1:2457599:                 builder.addCell(update);
1:a991b64:             }
1:a991b64:             else if (existing != null)
1:a991b64:             {
1:2457599:                 builder.addCell(existing);
1:a991b64:             }
1:a991b64:             return Long.MAX_VALUE;
1:a991b64:         }
1:a991b64: 
1:a991b64:         Cell reconciled = reconcile(existing, update, nowInSec);
1:2457599:         builder.addCell(reconciled);
1:a991b64: 
1:2457599:         return Math.abs(existing.timestamp() - update.timestamp());
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Reconciles/merge two cells.
1:a991b64:      * <p>
1:a991b64:      * Note that this method assumes that the provided cells can meaningfully
1:a991b64:      * be reconciled together, that is that cell are for the same row and same
1:a991b64:      * column (and same cell path if the column is complex).
1:a991b64:      * <p>
1:a991b64:      * This method is commutative over it's cells arguments: {@code reconcile(a, b, n) == reconcile(b, a, n)}.
1:a991b64:      *
1:a991b64:      * @param c1 the first cell participating in the reconciliation.
1:a991b64:      * @param c2 the second cell participating in the reconciliation.
1:a991b64:      * @param nowInSec the current time in seconds (which plays a role during reconciliation
1:a991b64:      * because deleted cells always have precedence on timestamp equality and deciding if a
1:a991b64:      * cell is a live or not depends on the current time due to expiring cells).
1:a991b64:      *
1:a991b64:      * @return a cell corresponding to the reconciliation of {@code c1} and {@code c2}.
1:a991b64:      * For non-counter cells, this will always be either {@code c1} or {@code c2}, but for
1:a991b64:      * counter cells this can be a newly allocated cell.
1:a991b64:      */
1:a991b64:     public static Cell reconcile(Cell c1, Cell c2, int nowInSec)
1:a991b64:     {
1:a991b64:         if (c1 == null)
1:a991b64:             return c2 == null ? null : c2;
1:a991b64:         if (c2 == null)
1:a991b64:             return c1;
1:a991b64: 
1:a991b64:         if (c1.isCounterCell() || c2.isCounterCell())
1:a991b64:         {
1:2457599:             Conflicts.Resolution res = Conflicts.resolveCounter(c1.timestamp(),
1:a991b64:                                                                 c1.isLive(nowInSec),
1:a991b64:                                                                 c1.value(),
1:2457599:                                                                 c2.timestamp(),
1:a991b64:                                                                 c2.isLive(nowInSec),
1:a991b64:                                                                 c2.value());
1:a991b64: 
1:a991b64:             switch (res)
1:a991b64:             {
1:a991b64:                 case LEFT_WINS: return c1;
1:a991b64:                 case RIGHT_WINS: return c2;
1:a991b64:                 default:
1:a991b64:                     ByteBuffer merged = Conflicts.mergeCounterValues(c1.value(), c2.value());
1:2457599:                     long timestamp = Math.max(c1.timestamp(), c2.timestamp());
1:a991b64: 
1:a991b64:                     // We save allocating a new cell object if it turns out that one cell was
1:a991b64:                     // a complete superset of the other
1:2457599:                     if (merged == c1.value() && timestamp == c1.timestamp())
1:a991b64:                         return c1;
1:2457599:                     else if (merged == c2.value() && timestamp == c2.timestamp())
1:a991b64:                         return c2;
1:a991b64:                     else // merge clocks and timestamps.
1:2457599:                         return new BufferCell(c1.column(), timestamp, Cell.NO_TTL, Cell.NO_DELETION_TIME, merged, c1.path());
1:a991b64:             }
1:a991b64:         }
1:a991b64: 
1:2457599:         Conflicts.Resolution res = Conflicts.resolveRegular(c1.timestamp(),
1:a991b64:                                                             c1.isLive(nowInSec),
1:2457599:                                                             c1.localDeletionTime(),
1:a991b64:                                                             c1.value(),
1:2457599:                                                             c2.timestamp(),
1:a991b64:                                                             c2.isLive(nowInSec),
1:2457599:                                                             c2.localDeletionTime(),
1:a991b64:                                                             c2.value());
1:a991b64:         assert res != Conflicts.Resolution.MERGE;
1:a991b64:         return res == Conflicts.Resolution.LEFT_WINS ? c1 : c2;
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Computes the reconciliation of a complex column given its pre-existing
1:a991b64:      * cells and the ones it is updated with, and generating index update if
1:a991b64:      * appropriate.
1:a991b64:      * <p>
1:a991b64:      * Note that this method assumes that the provided cells can meaningfully
1:a991b64:      * be reconciled together, that is that the cells are for the same row and same
1:a991b64:      * complex column.
1:a991b64:      * <p>
1:a991b64:      * Also note that which cells is provided as {@code existing} and which are
1:a991b64:      * provided as {@code update} matters for index updates.
1:a991b64:      *
1:a991b64:      * @param column the complex column the cells are for.
1:a991b64:      * @param existing the pre-existing cells, the ones that are updated. This can be
1:a991b64:      * {@code null} if this reconciliation correspond to an insertion.
1:a991b64:      * @param update the newly added cells, the update. This can be {@code null} out
1:a991b64:      * of convenience, in which case this function simply copy the cells from
1:a991b64:      * {@code existing} to {@code writer}.
1:a991b64:      * @param deletion the deletion time that applies to the cells being considered.
1:a991b64:      * This deletion time may delete cells in both {@code existing} and {@code update}.
1:2457599:      * @param builder the row build to which the result of the reconciliation is written.
1:a991b64:      * @param nowInSec the current time in seconds (which plays a role during reconciliation
1:a991b64:      * because deleted cells always have precedence on timestamp equality and deciding if a
1:a991b64:      * cell is a live or not depends on the current time due to expiring cells).
1:a991b64:      *
1:a991b64:      * @return the smallest timestamp delta between corresponding cells from existing and update. A
1:a991b64:      * timestamp delta being computed as the difference between a cell from {@code update} and the
1:a991b64:      * cell in {@code existing} having the same cell path (if such cell exists). If the intersection
1:a991b64:      * of cells from {@code existing} and {@code update} having the same cell path is empty, this
1:a991b64:      * returns {@code Long.MAX_VALUE}.
1:a991b64:      */
1:0626be8:     public static long reconcileComplex(ColumnDefinition column,
1:a991b64:                                         Iterator<Cell> existing,
1:a991b64:                                         Iterator<Cell> update,
1:a991b64:                                         DeletionTime deletion,
1:2457599:                                         Row.Builder builder,
1:0626be8:                                         int nowInSec)
1:a991b64:     {
1:a991b64:         Comparator<CellPath> comparator = column.cellPathComparator();
1:a991b64:         Cell nextExisting = getNext(existing);
1:a991b64:         Cell nextUpdate = getNext(update);
1:a991b64:         long timeDelta = Long.MAX_VALUE;
1:a991b64:         while (nextExisting != null || nextUpdate != null)
1:a991b64:         {
1:a991b64:             int cmp = nextExisting == null ? 1
1:a991b64:                      : (nextUpdate == null ? -1
1:a991b64:                      : comparator.compare(nextExisting.path(), nextUpdate.path()));
1:a991b64:             if (cmp < 0)
1:a991b64:             {
1:0626be8:                 reconcile(nextExisting, null, deletion, builder, nowInSec);
1:a991b64:                 nextExisting = getNext(existing);
1:a991b64:             }
1:a991b64:             else if (cmp > 0)
1:a991b64:             {
1:0626be8:                 reconcile(null, nextUpdate, deletion, builder, nowInSec);
1:a991b64:                 nextUpdate = getNext(update);
1:a991b64:             }
1:a991b64:             else
1:a991b64:             {
1:0626be8:                 timeDelta = Math.min(timeDelta, reconcile(nextExisting, nextUpdate, deletion, builder, nowInSec));
1:a991b64:                 nextExisting = getNext(existing);
1:a991b64:                 nextUpdate = getNext(update);
1:a991b64:             }
1:a991b64:         }
1:a991b64:         return timeDelta;
1:a991b64:     }
1:a991b64: 
1:d40ac78:     /**
1:d40ac78:      * Adds to the builder a representation of the given existing cell that, when merged/reconciled with the given
1:d40ac78:      * update cell, produces the same result as merging the original with the update.
1:d40ac78:      * <p>
1:d40ac78:      * For simple cells that is either the original cell (if still live), or nothing (if shadowed).
1:d40ac78:      *
1:d40ac78:      * @param existing the pre-existing cell, the one that is updated.
1:d40ac78:      * @param update the newly added cell, the update. This can be {@code null} out
1:d40ac78:      * of convenience, in which case this function simply copy {@code existing} to
1:d40ac78:      * {@code writer}.
1:d40ac78:      * @param deletion the deletion time that applies to the cells being considered.
1:d40ac78:      * This deletion time may delete both {@code existing} or {@code update}.
1:d40ac78:      * @param builder the row builder to which the result of the filtering is written.
1:d40ac78:      * @param nowInSec the current time in seconds (which plays a role during reconciliation
1:d40ac78:      * because deleted cells always have precedence on timestamp equality and deciding if a
1:d40ac78:      * cell is a live or not depends on the current time due to expiring cells).
1:d40ac78:      */
1:d40ac78:     public static void addNonShadowed(Cell existing,
1:d40ac78:                                       Cell update,
1:d40ac78:                                       DeletionTime deletion,
1:d40ac78:                                       Row.Builder builder,
1:d40ac78:                                       int nowInSec)
1:d40ac78:     {
1:d40ac78:         if (deletion.deletes(existing))
1:d40ac78:             return;
1:d40ac78: 
1:d40ac78:         Cell reconciled = reconcile(existing, update, nowInSec);
1:d40ac78:         if (reconciled != update)
1:d40ac78:             builder.addCell(existing);
1:d40ac78:     }
1:d40ac78: 
1:d40ac78:     /**
1:d40ac78:      * Adds to the builder a representation of the given existing cell that, when merged/reconciled with the given
1:d40ac78:      * update cell, produces the same result as merging the original with the update.
1:d40ac78:      * <p>
1:d40ac78:      * For simple cells that is either the original cell (if still live), or nothing (if shadowed).
1:d40ac78:      *
1:d40ac78:      * @param column the complex column the cells are for.
1:d40ac78:      * @param existing the pre-existing cells, the ones that are updated.
1:d40ac78:      * @param update the newly added cells, the update. This can be {@code null} out
1:d40ac78:      * of convenience, in which case this function simply copy the cells from
1:d40ac78:      * {@code existing} to {@code writer}.
1:d40ac78:      * @param deletion the deletion time that applies to the cells being considered.
1:d40ac78:      * This deletion time may delete both {@code existing} or {@code update}.
1:d40ac78:      * @param builder the row builder to which the result of the filtering is written.
1:d40ac78:      * @param nowInSec the current time in seconds (which plays a role during reconciliation
1:d40ac78:      * because deleted cells always have precedence on timestamp equality and deciding if a
1:d40ac78:      * cell is a live or not depends on the current time due to expiring cells).
1:d40ac78:      */
1:d40ac78:     public static void addNonShadowedComplex(ColumnDefinition column,
1:d40ac78:                                              Iterator<Cell> existing,
1:d40ac78:                                              Iterator<Cell> update,
1:d40ac78:                                              DeletionTime deletion,
1:d40ac78:                                              Row.Builder builder,
1:d40ac78:                                              int nowInSec)
1:d40ac78:     {
1:d40ac78:         Comparator<CellPath> comparator = column.cellPathComparator();
1:d40ac78:         Cell nextExisting = getNext(existing);
1:d40ac78:         Cell nextUpdate = getNext(update);
1:d40ac78:         while (nextExisting != null)
1:d40ac78:         {
1:d40ac78:             int cmp = nextUpdate == null ? -1 : comparator.compare(nextExisting.path(), nextUpdate.path());
1:d40ac78:             if (cmp < 0)
1:d40ac78:             {
1:d40ac78:                 addNonShadowed(nextExisting, null, deletion, builder, nowInSec);
1:d40ac78:                 nextExisting = getNext(existing);
1:d40ac78:             }
1:d40ac78:             else if (cmp == 0)
1:d40ac78:             {
1:d40ac78:                 addNonShadowed(nextExisting, nextUpdate, deletion, builder, nowInSec);
1:d40ac78:                 nextExisting = getNext(existing);
1:d40ac78:                 nextUpdate = getNext(update);
1:d40ac78:             }
1:d40ac78:             else
1:d40ac78:             {
1:d40ac78:                 nextUpdate = getNext(update);
1:d40ac78:             }
1:d40ac78:         }
1:d40ac78:     }
1:d40ac78: 
1:a991b64:     private static Cell getNext(Iterator<Cell> iterator)
1:a991b64:     {
1:a991b64:         return iterator == null || !iterator.hasNext() ? null : iterator.next();
1:a991b64:     }
1:a991b64: }
============================================================================
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:d40ac78
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Adds to the builder a representation of the given existing cell that, when merged/reconciled with the given
1:      * update cell, produces the same result as merging the original with the update.
1:      * <p>
1:      * For simple cells that is either the original cell (if still live), or nothing (if shadowed).
1:      *
1:      * @param existing the pre-existing cell, the one that is updated.
1:      * @param update the newly added cell, the update. This can be {@code null} out
1:      * of convenience, in which case this function simply copy {@code existing} to
1:      * {@code writer}.
1:      * @param deletion the deletion time that applies to the cells being considered.
1:      * This deletion time may delete both {@code existing} or {@code update}.
1:      * @param builder the row builder to which the result of the filtering is written.
1:      * @param nowInSec the current time in seconds (which plays a role during reconciliation
1:      * because deleted cells always have precedence on timestamp equality and deciding if a
1:      * cell is a live or not depends on the current time due to expiring cells).
1:      */
1:     public static void addNonShadowed(Cell existing,
1:                                       Cell update,
1:                                       DeletionTime deletion,
1:                                       Row.Builder builder,
1:                                       int nowInSec)
1:     {
1:         if (deletion.deletes(existing))
1:             return;
1: 
1:         Cell reconciled = reconcile(existing, update, nowInSec);
1:         if (reconciled != update)
1:             builder.addCell(existing);
1:     }
1: 
1:     /**
1:      * Adds to the builder a representation of the given existing cell that, when merged/reconciled with the given
1:      * update cell, produces the same result as merging the original with the update.
1:      * <p>
1:      * For simple cells that is either the original cell (if still live), or nothing (if shadowed).
1:      *
1:      * @param column the complex column the cells are for.
1:      * @param existing the pre-existing cells, the ones that are updated.
1:      * @param update the newly added cells, the update. This can be {@code null} out
1:      * of convenience, in which case this function simply copy the cells from
1:      * {@code existing} to {@code writer}.
1:      * @param deletion the deletion time that applies to the cells being considered.
1:      * This deletion time may delete both {@code existing} or {@code update}.
1:      * @param builder the row builder to which the result of the filtering is written.
1:      * @param nowInSec the current time in seconds (which plays a role during reconciliation
1:      * because deleted cells always have precedence on timestamp equality and deciding if a
1:      * cell is a live or not depends on the current time due to expiring cells).
1:      */
1:     public static void addNonShadowedComplex(ColumnDefinition column,
1:                                              Iterator<Cell> existing,
1:                                              Iterator<Cell> update,
1:                                              DeletionTime deletion,
1:                                              Row.Builder builder,
1:                                              int nowInSec)
1:     {
1:         Comparator<CellPath> comparator = column.cellPathComparator();
1:         Cell nextExisting = getNext(existing);
1:         Cell nextUpdate = getNext(update);
1:         while (nextExisting != null)
1:         {
1:             int cmp = nextUpdate == null ? -1 : comparator.compare(nextExisting.path(), nextUpdate.path());
1:             if (cmp < 0)
1:             {
1:                 addNonShadowed(nextExisting, null, deletion, builder, nowInSec);
1:                 nextExisting = getNext(existing);
1:             }
1:             else if (cmp == 0)
1:             {
1:                 addNonShadowed(nextExisting, nextUpdate, deletion, builder, nowInSec);
1:                 nextExisting = getNext(existing);
1:                 nextUpdate = getNext(update);
1:             }
1:             else
1:             {
1:                 nextUpdate = getNext(update);
1:             }
1:         }
1:     }
1: 
author:Sam Tunnicliffe
-------------------------------------------------------------------------------
commit:0626be8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.Conflicts;
1: import org.apache.cassandra.db.DeletionTime;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public static long reconcile(Cell existing,
1:                                  int nowInSec)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public static long reconcileComplex(ColumnDefinition column,
1:                                         int nowInSec)
/////////////////////////////////////////////////////////////////////////
1:                 reconcile(nextExisting, null, deletion, builder, nowInSec);
1:                 reconcile(null, nextUpdate, deletion, builder, nowInSec);
1:                 timeDelta = Math.min(timeDelta, reconcile(nextExisting, nextUpdate, deletion, builder, nowInSec));
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:2457599
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.partitions.PartitionStatisticsCollector;
/////////////////////////////////////////////////////////////////////////
1:      * Collect statistics ont a given cell.
1:      * @param cell the cell for which to collect stats.
1:      * @param collector the stats collector.
1:     public static void collectStats(Cell cell, PartitionStatisticsCollector collector)
1:         collector.update(cell);
1:         if (cell.isCounterCell())
1:             collector.updateHasLegacyCounterShards(CounterCells.hasLegacyShards(cell));
/////////////////////////////////////////////////////////////////////////
1:      * @param builder the row builder to which the result of the reconciliation is written.
/////////////////////////////////////////////////////////////////////////
1:                                  Row.Builder builder,
1:         existing = existing == null || deletion.deletes(existing) ? null : existing;
1:         update = update == null || deletion.deletes(update) ? null : update;
/////////////////////////////////////////////////////////////////////////
1:                 builder.addCell(update);
1:                 builder.addCell(existing);
1:         builder.addCell(reconciled);
/////////////////////////////////////////////////////////////////////////
1:         return Math.abs(existing.timestamp() - update.timestamp());
0:             indexUpdater.maybeIndex(clustering, cell.timestamp(), cell.ttl(), DeletionTime.LIVE);
/////////////////////////////////////////////////////////////////////////
1:             Conflicts.Resolution res = Conflicts.resolveCounter(c1.timestamp(),
1:                                                                 c2.timestamp(),
/////////////////////////////////////////////////////////////////////////
1:                     long timestamp = Math.max(c1.timestamp(), c2.timestamp());
1:                     if (merged == c1.value() && timestamp == c1.timestamp())
1:                     else if (merged == c2.value() && timestamp == c2.timestamp())
1:                         return new BufferCell(c1.column(), timestamp, Cell.NO_TTL, Cell.NO_DELETION_TIME, merged, c1.path());
1:         Conflicts.Resolution res = Conflicts.resolveRegular(c1.timestamp(),
1:                                                             c1.localDeletionTime(),
1:                                                             c2.timestamp(),
1:                                                             c2.localDeletionTime(),
/////////////////////////////////////////////////////////////////////////
1:      * @param builder the row build to which the result of the reconciliation is written.
/////////////////////////////////////////////////////////////////////////
1:                                         Row.Builder builder,
/////////////////////////////////////////////////////////////////////////
0:                 reconcile(clustering, nextExisting, null, deletion, builder, nowInSec, indexUpdater);
0:                 reconcile(clustering, null, nextUpdate, deletion, builder, nowInSec, indexUpdater);
0:                 timeDelta = Math.min(timeDelta, reconcile(clustering, nextExisting, nextUpdate, deletion, builder, nowInSec, indexUpdater));
/////////////////////////////////////////////////////////////////////////
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.db.rows;
1: 
1: import java.nio.ByteBuffer;
1: import java.util.Comparator;
1: import java.util.Iterator;
1: 
1: import org.apache.cassandra.config.ColumnDefinition;
0: import org.apache.cassandra.db.*;
0: import org.apache.cassandra.db.context.CounterContext;
0: import org.apache.cassandra.db.index.SecondaryIndexManager;
0: import org.apache.cassandra.utils.ByteBufferUtil;
1: 
1: /**
1:  * Static methods to work on cells.
1:  */
1: public abstract class Cells
1: {
1:     private Cells() {}
1: 
1:     /**
0:      * Writes a tombstone cell to the provided writer.
1:      *
0:      * @param writer the {@code Row.Writer} to write the tombstone to.
0:      * @param column the column for the tombstone.
0:      * @param timestamp the timestamp for the tombstone.
0:      * @param localDeletionTime the local deletion time (in seconds) for the tombstone.
1:      */
0:     public static void writeTombstone(Row.Writer writer, ColumnDefinition column, long timestamp, int localDeletionTime)
1:     {
0:         writer.writeCell(column, false, ByteBufferUtil.EMPTY_BYTE_BUFFER, SimpleLivenessInfo.forDeletion(timestamp, localDeletionTime), null);
1:     }
1: 
1:     /**
0:      * Computes the difference between a cell and the result of merging this
0:      * cell to other cells.
1:      * <p>
0:      * This method is used when cells from multiple sources are merged and we want to
0:      * find for a given source if it was up to date for that cell, and if not, what
0:      * should be sent to the source to repair it.
1:      *
0:      * @param merged the cell that is the result of merging multiple source.
0:      * @param cell the cell from one of the source that has been merged to yied
0:      * {@code merged}.
0:      * @return {@code null} if the source having {@code cell} is up-to-date for that
0:      * cell, or a cell that applied to the source will "repair" said source otherwise.
1:      */
0:     public static Cell diff(Cell merged, Cell cell)
1:     {
0:         // Note that it's enough to check if merged is a counterCell. If it isn't and
0:         // cell is one, it means that merged is a tombstone with a greater timestamp
0:         // than cell, because that's the only case where reconciling a counter with
0:         // a tombstone don't yield a counter. If that's the case, the normal path will
0:         // return what it should.
0:         if (merged.isCounterCell())
1:         {
0:             if (merged.livenessInfo().supersedes(cell.livenessInfo()))
0:                 return merged;
1: 
0:             // Reconciliation never returns something with a timestamp strictly lower than its operand. This
0:             // means we're in the case where merged.timestamp() == cell.timestamp(). As 1) tombstones
0:             // always win over counters (CASSANDRA-7346) and 2) merged is a counter, it follows that cell
0:             // can't be a tombstone or merged would be one too.
0:             assert !cell.isTombstone();
1: 
0:             CounterContext.Relationship rel = CounterContext.instance().diff(merged.value(), cell.value());
0:             return (rel == CounterContext.Relationship.GREATER_THAN || rel == CounterContext.Relationship.DISJOINT) ? merged : null;
1:         }
0:         return merged.livenessInfo().supersedes(cell.livenessInfo()) ? merged : null;
1:     }
1: 
1:     /**
1:      * Reconciles/merges two cells, one being an update to an existing cell,
1:      * yielding index updates if appropriate.
1:      * <p>
1:      * Note that this method assumes that the provided cells can meaningfully
1:      * be reconciled together, that is that those cells are for the same row and same
1:      * column (and same cell path if the column is complex).
1:      * <p>
1:      * Also note that which cell is provided as {@code existing} and which is
1:      * provided as {@code update} matters for index updates.
1:      *
0:      * @param clustering the clustering for the row the cells to merge originate from.
0:      * This is only used for index updates, so this can be {@code null} if
0:      * {@code indexUpdater == SecondaryIndexManager.nullUpdater}.
1:      * @param existing the pre-existing cell, the one that is updated. This can be
1:      * {@code null} if this reconciliation correspond to an insertion.
1:      * @param update the newly added cell, the update. This can be {@code null} out
1:      * of convenience, in which case this function simply copy {@code existing} to
1:      * {@code writer}.
1:      * @param deletion the deletion time that applies to the cells being considered.
1:      * This deletion time may delete both {@code existing} or {@code update}.
0:      * @param writer the row writer to which the result of the reconciliation is written.
1:      * @param nowInSec the current time in seconds (which plays a role during reconciliation
1:      * because deleted cells always have precedence on timestamp equality and deciding if a
1:      * cell is a live or not depends on the current time due to expiring cells).
0:      * @param indexUpdater an index updater to which the result of the reconciliation is
0:      * signaled (if relevant, that is if the update is not simply ignored by the reconciliation).
0:      * This cannot be {@code null} but {@code SecondaryIndexManager.nullUpdater} can be passed.
1:      *
1:      * @return the timestamp delta between existing and update, or {@code Long.MAX_VALUE} if one
1:      * of them is {@code null} or deleted by {@code deletion}).
1:      */
0:     public static long reconcile(Clustering clustering,
0:                                  Cell existing,
1:                                  Cell update,
1:                                  DeletionTime deletion,
0:                                  Row.Writer writer,
0:                                  int nowInSec,
0:                                  SecondaryIndexManager.Updater indexUpdater)
1:     {
0:         existing = existing == null || deletion.deletes(existing.livenessInfo()) ? null : existing;
0:         update = update == null || deletion.deletes(update.livenessInfo()) ? null : update;
1:         if (existing == null || update == null)
1:         {
1:             if (update != null)
1:             {
0:                 // It's inefficient that we call maybeIndex (which is for primary key indexes) on every cell, but
0:                 // we'll need to fix that damn 2ndary index API to avoid that.
0:                 updatePKIndexes(clustering, update, nowInSec, indexUpdater);
0:                 indexUpdater.insert(clustering, update);
0:                 update.writeTo(writer);
1:             }
1:             else if (existing != null)
1:             {
0:                 existing.writeTo(writer);
1:             }
1:             return Long.MAX_VALUE;
1:         }
1: 
1:         Cell reconciled = reconcile(existing, update, nowInSec);
0:         reconciled.writeTo(writer);
1: 
0:         // Note that this test rely on reconcile returning either 'existing' or 'update'. That's not true for counters but we don't index them
0:         if (reconciled == update)
1:         {
0:             updatePKIndexes(clustering, update, nowInSec, indexUpdater);
0:             indexUpdater.update(clustering, existing, reconciled);
1:         }
0:         return Math.abs(existing.livenessInfo().timestamp() - update.livenessInfo().timestamp());
1:     }
1: 
0:     private static void updatePKIndexes(Clustering clustering, Cell cell, int nowInSec, SecondaryIndexManager.Updater indexUpdater)
1:     {
0:         if (indexUpdater != SecondaryIndexManager.nullUpdater && cell.isLive(nowInSec))
0:             indexUpdater.maybeIndex(clustering, cell.livenessInfo().timestamp(), cell.livenessInfo().ttl(), DeletionTime.LIVE);
1:     }
1: 
1:     /**
1:      * Reconciles/merge two cells.
1:      * <p>
1:      * Note that this method assumes that the provided cells can meaningfully
1:      * be reconciled together, that is that cell are for the same row and same
1:      * column (and same cell path if the column is complex).
1:      * <p>
1:      * This method is commutative over it's cells arguments: {@code reconcile(a, b, n) == reconcile(b, a, n)}.
1:      *
1:      * @param c1 the first cell participating in the reconciliation.
1:      * @param c2 the second cell participating in the reconciliation.
1:      * @param nowInSec the current time in seconds (which plays a role during reconciliation
1:      * because deleted cells always have precedence on timestamp equality and deciding if a
1:      * cell is a live or not depends on the current time due to expiring cells).
1:      *
1:      * @return a cell corresponding to the reconciliation of {@code c1} and {@code c2}.
1:      * For non-counter cells, this will always be either {@code c1} or {@code c2}, but for
1:      * counter cells this can be a newly allocated cell.
1:      */
1:     public static Cell reconcile(Cell c1, Cell c2, int nowInSec)
1:     {
1:         if (c1 == null)
1:             return c2 == null ? null : c2;
1:         if (c2 == null)
1:             return c1;
1: 
1:         if (c1.isCounterCell() || c2.isCounterCell())
1:         {
0:             Conflicts.Resolution res = Conflicts.resolveCounter(c1.livenessInfo().timestamp(),
1:                                                                 c1.isLive(nowInSec),
1:                                                                 c1.value(),
0:                                                                 c2.livenessInfo().timestamp(),
1:                                                                 c2.isLive(nowInSec),
1:                                                                 c2.value());
1: 
1:             switch (res)
1:             {
1:                 case LEFT_WINS: return c1;
1:                 case RIGHT_WINS: return c2;
1:                 default:
1:                     ByteBuffer merged = Conflicts.mergeCounterValues(c1.value(), c2.value());
0:                     LivenessInfo mergedInfo = c1.livenessInfo().mergeWith(c2.livenessInfo());
1: 
1:                     // We save allocating a new cell object if it turns out that one cell was
1:                     // a complete superset of the other
0:                     if (merged == c1.value() && mergedInfo == c1.livenessInfo())
1:                         return c1;
0:                     else if (merged == c2.value() && mergedInfo == c2.livenessInfo())
1:                         return c2;
1:                     else // merge clocks and timestamps.
0:                         return create(c1.column(), true, merged, mergedInfo, null);
1:             }
1:         }
1: 
0:         Conflicts.Resolution res = Conflicts.resolveRegular(c1.livenessInfo().timestamp(),
1:                                                             c1.isLive(nowInSec),
0:                                                             c1.livenessInfo().localDeletionTime(),
1:                                                             c1.value(),
0:                                                             c2.livenessInfo().timestamp(),
1:                                                             c2.isLive(nowInSec),
0:                                                             c2.livenessInfo().localDeletionTime(),
1:                                                             c2.value());
1:         assert res != Conflicts.Resolution.MERGE;
1:         return res == Conflicts.Resolution.LEFT_WINS ? c1 : c2;
1:     }
1: 
1:     /**
1:      * Computes the reconciliation of a complex column given its pre-existing
1:      * cells and the ones it is updated with, and generating index update if
1:      * appropriate.
1:      * <p>
1:      * Note that this method assumes that the provided cells can meaningfully
1:      * be reconciled together, that is that the cells are for the same row and same
1:      * complex column.
1:      * <p>
1:      * Also note that which cells is provided as {@code existing} and which are
1:      * provided as {@code update} matters for index updates.
1:      *
0:      * @param clustering the clustering for the row the cells to merge originate from.
0:      * This is only used for index updates, so this can be {@code null} if
0:      * {@code indexUpdater == SecondaryIndexManager.nullUpdater}.
1:      * @param column the complex column the cells are for.
1:      * @param existing the pre-existing cells, the ones that are updated. This can be
1:      * {@code null} if this reconciliation correspond to an insertion.
1:      * @param update the newly added cells, the update. This can be {@code null} out
1:      * of convenience, in which case this function simply copy the cells from
1:      * {@code existing} to {@code writer}.
1:      * @param deletion the deletion time that applies to the cells being considered.
1:      * This deletion time may delete cells in both {@code existing} and {@code update}.
0:      * @param writer the row writer to which the result of the reconciliation is written.
1:      * @param nowInSec the current time in seconds (which plays a role during reconciliation
1:      * because deleted cells always have precedence on timestamp equality and deciding if a
1:      * cell is a live or not depends on the current time due to expiring cells).
0:      * @param indexUpdater an index updater to which the result of the reconciliation is
0:      * signaled (if relevant, that is if the updates are not simply ignored by the reconciliation).
0:      * This cannot be {@code null} but {@code SecondaryIndexManager.nullUpdater} can be passed.
1:      *
1:      * @return the smallest timestamp delta between corresponding cells from existing and update. A
1:      * timestamp delta being computed as the difference between a cell from {@code update} and the
1:      * cell in {@code existing} having the same cell path (if such cell exists). If the intersection
1:      * of cells from {@code existing} and {@code update} having the same cell path is empty, this
1:      * returns {@code Long.MAX_VALUE}.
1:      */
0:     public static long reconcileComplex(Clustering clustering,
0:                                         ColumnDefinition column,
1:                                         Iterator<Cell> existing,
1:                                         Iterator<Cell> update,
1:                                         DeletionTime deletion,
0:                                         Row.Writer writer,
0:                                         int nowInSec,
0:                                         SecondaryIndexManager.Updater indexUpdater)
1:     {
1:         Comparator<CellPath> comparator = column.cellPathComparator();
1:         Cell nextExisting = getNext(existing);
1:         Cell nextUpdate = getNext(update);
1:         long timeDelta = Long.MAX_VALUE;
1:         while (nextExisting != null || nextUpdate != null)
1:         {
1:             int cmp = nextExisting == null ? 1
1:                      : (nextUpdate == null ? -1
1:                      : comparator.compare(nextExisting.path(), nextUpdate.path()));
1:             if (cmp < 0)
1:             {
0:                 reconcile(clustering, nextExisting, null, deletion, writer, nowInSec, indexUpdater);
1:                 nextExisting = getNext(existing);
1:             }
1:             else if (cmp > 0)
1:             {
0:                 reconcile(clustering, null, nextUpdate, deletion, writer, nowInSec, indexUpdater);
1:                 nextUpdate = getNext(update);
1:             }
1:             else
1:             {
0:                 timeDelta = Math.min(timeDelta, reconcile(clustering, nextExisting, nextUpdate, deletion, writer, nowInSec, indexUpdater));
1:                 nextExisting = getNext(existing);
1:                 nextUpdate = getNext(update);
1:             }
1:         }
1:         return timeDelta;
1:     }
1: 
1:     private static Cell getNext(Iterator<Cell> iterator)
1:     {
1:         return iterator == null || !iterator.hasNext() ? null : iterator.next();
1:     }
1: 
1:     /**
0:      * Creates a simple cell.
1:      * <p>
0:      * Note that in general cell objects are created by the container they are in and so this method should
0:      * only be used in a handful of cases when we know it's the right thing to do.
1:      *
0:      * @param column the column for the cell to create.
0:      * @param isCounter whether the create cell should be a counter one.
0:      * @param value the value for the cell.
0:      * @param info the liveness info for the cell.
0:      * @param path the cell path for the cell.
0:      * @return the newly allocated cell object.
1:      */
0:     public static Cell create(ColumnDefinition column, boolean isCounter, ByteBuffer value, LivenessInfo info, CellPath path)
1:     {
0:         return new SimpleCell(column, isCounter, value, info, path);
1:     }
1: 
0:     private static class SimpleCell extends AbstractCell
1:     {
0:         private final ColumnDefinition column;
0:         private final boolean isCounter;
0:         private final ByteBuffer value;
0:         private final LivenessInfo info;
0:         private final CellPath path;
1: 
0:         private SimpleCell(ColumnDefinition column, boolean isCounter, ByteBuffer value, LivenessInfo info, CellPath path)
1:         {
0:             this.column = column;
0:             this.isCounter = isCounter;
0:             this.value = value;
0:             this.info = info.takeAlias();
0:             this.path = path;
1:         }
1: 
0:         public ColumnDefinition column()
1:         {
0:             return column;
1:         }
1: 
0:         public boolean isCounterCell()
1:         {
0:             return isCounter;
1:         }
1: 
0:         public ByteBuffer value()
1:         {
0:             return value;
1:         }
1: 
0:         public LivenessInfo livenessInfo()
1:         {
0:             return info;
1:         }
1: 
0:         public CellPath path()
1:         {
0:             return path;
1:         }
1:     }
1: }
============================================================================