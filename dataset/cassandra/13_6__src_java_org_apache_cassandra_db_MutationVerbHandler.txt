1:07cf56f: /*
1:066ef58:  * Licensed to the Apache Software Foundation (ASF) under one
1:066ef58:  * or more contributor license agreements.  See the NOTICE file
1:066ef58:  * distributed with this work for additional information
1:066ef58:  * regarding copyright ownership.  The ASF licenses this file
1:066ef58:  * to you under the Apache License, Version 2.0 (the
1:066ef58:  * "License"); you may not use this file except in compliance
1:066ef58:  * with the License.  You may obtain a copy of the License at
1:066ef58:  *
1:066ef58:  *     http://www.apache.org/licenses/LICENSE-2.0
1:066ef58:  *
1:066ef58:  * Unless required by applicable law or agreed to in writing, software
1:066ef58:  * distributed under the License is distributed on an "AS IS" BASIS,
1:066ef58:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:066ef58:  * See the License for the specific language governing permissions and
1:066ef58:  * limitations under the License.
2:066ef58:  */
1:066ef58: package org.apache.cassandra.db;
1:a8b89fb: 
1:d016a08: import java.io.DataInputStream;
1:a8b89fb: import java.io.IOException;
1:b767bf7: import java.net.InetAddress;
6:a8b89fb: 
1:53a177a: import org.apache.cassandra.batchlog.LegacyBatchlogMigrator;
1:3bdcaa3: import org.apache.cassandra.exceptions.WriteTimeoutException;
1:d016a08: import org.apache.cassandra.io.util.FastByteArrayInputStream;
1:5a6f0b8: import org.apache.cassandra.net.*;
1:d7ff10d: import org.apache.cassandra.tracing.Tracing;
1:a8b89fb: 
1:6bbb13b: public class MutationVerbHandler implements IVerbHandler<Mutation>
1:3c43775: {
1:839a5ba:     private void reply(int id, InetAddress replyTo)
1:839a5ba:     {
1:839a5ba:         Tracing.trace("Enqueuing response to {}", replyTo);
1:839a5ba:         MessagingService.instance().sendReply(WriteResponse.createMessage(), id, replyTo);
1:839a5ba:     }
1:839a5ba: 
1:839a5ba:     private void failed()
1:839a5ba:     {
1:839a5ba:         Tracing.trace("Payload application resulted in WriteTimeout, not replying");
1:839a5ba:     }
1:839a5ba: 
1:c059a56:     public void doVerb(MessageIn<Mutation> message, int id)  throws IOException
1:5a6f0b8:     {
1:53a177a:         // Check if there were any forwarding headers in this message
1:53a177a:         byte[] from = message.parameters.get(Mutation.FORWARD_FROM);
1:53a177a:         InetAddress replyTo;
1:53a177a:         if (from == null)
1:53a177a:         {
1:53a177a:             replyTo = message.from;
1:53a177a:             byte[] forwardBytes = message.parameters.get(Mutation.FORWARD_TO);
1:53a177a:             if (forwardBytes != null)
1:53a177a:                 forwardToLocalNodes(message.payload, message.verb, forwardBytes, message.from);
1:53a177a:         }
1:53a177a:         else
1:53a177a:         {
1:53a177a:             replyTo = InetAddress.getByAddress(from);
1:53a177a:         }
1:d016a08: 
1:3bdcaa3:         try
1:3bdcaa3:         {
1:53a177a:             if (message.version < MessagingService.VERSION_30 && LegacyBatchlogMigrator.isLegacyBatchlogMutation(message.payload))
1:839a5ba:             {
1:53a177a:                 LegacyBatchlogMigrator.handleLegacyMutation(message.payload);
1:839a5ba:                 reply(id, replyTo);
1:839a5ba:             }
1:53a177a:             else
1:839a5ba:                 message.payload.applyFuture().thenAccept(o -> reply(id, replyTo)).exceptionally(wto -> {
1:839a5ba:                     failed();
1:839a5ba:                     return null;
1:839a5ba:                 });
1:3bdcaa3:         }
1:3bdcaa3:         catch (WriteTimeoutException wto)
1:3bdcaa3:         {
1:839a5ba:             failed();
1:3bdcaa3:         }
1:3c43775:     }
1:53a177a: 
1:d016a08:     /**
1:d016a08:      * Older version (< 1.0) will not send this message at all, hence we don't
1:d016a08:      * need to check the version of the data.
1:d016a08:      */
1:53a177a:     private static void forwardToLocalNodes(Mutation mutation, MessagingService.Verb verb, byte[] forwardBytes, InetAddress from) throws IOException
1:3c43775:     {
1:7aafe05:         try (DataInputStream in = new DataInputStream(new FastByteArrayInputStream(forwardBytes)))
1:5a6f0b8:         {
1:7aafe05:             int size = in.readInt();
1:7aafe05: 
1:7aafe05:             // tell the recipients who to send their ack to
1:7aafe05:             MessageOut<Mutation> message = new MessageOut<>(verb, mutation, Mutation.serializer).withParameter(Mutation.FORWARD_FROM, from.getAddress());
1:7aafe05:             // Send a message to each of the addresses on our Forward List
1:7aafe05:             for (int i = 0; i < size; i++)
1:7aafe05:             {
1:7aafe05:                 InetAddress address = CompactEndpointSerializationHelper.deserialize(in);
1:7aafe05:                 int id = in.readInt();
1:7aafe05:                 Tracing.trace("Enqueuing forwarded write to {}", address);
1:7aafe05:                 MessagingService.instance().sendOneWay(message, id, address);
1:3c43775:             }
1:7aafe05:         }
1:5a6f0b8:     }
1:5a6f0b8: }
============================================================================
author:Dave Brosius
-------------------------------------------------------------------------------
commit:087264f
/////////////////////////////////////////////////////////////////////////
author:Carl Yeksigian
-------------------------------------------------------------------------------
commit:839a5ba
/////////////////////////////////////////////////////////////////////////
0: import java.util.function.Consumer;
/////////////////////////////////////////////////////////////////////////
1:     private void reply(int id, InetAddress replyTo)
1:     {
1:         Tracing.trace("Enqueuing response to {}", replyTo);
1:         MessagingService.instance().sendReply(WriteResponse.createMessage(), id, replyTo);
1:     }
1: 
1:     private void failed()
1:     {
1:         Tracing.trace("Payload application resulted in WriteTimeout, not replying");
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             {
1:                 reply(id, replyTo);
1:             }
1:                 message.payload.applyFuture().thenAccept(o -> reply(id, replyTo)).exceptionally(wto -> {
1:                     failed();
1:                     return null;
1:                 });
1:             failed();
commit:3bdcaa3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.exceptions.WriteTimeoutException;
/////////////////////////////////////////////////////////////////////////
1:         try
1:         {
1:         }
1:         catch (WriteTimeoutException wto)
1:         {
0:             Tracing.trace("Payload application resulted in WriteTimeout, not replying");
1:         }
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:53a177a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.batchlog.LegacyBatchlogMigrator;
/////////////////////////////////////////////////////////////////////////
1:         // Check if there were any forwarding headers in this message
1:         byte[] from = message.parameters.get(Mutation.FORWARD_FROM);
1:         InetAddress replyTo;
1:         if (from == null)
1:         {
1:             replyTo = message.from;
1:             byte[] forwardBytes = message.parameters.get(Mutation.FORWARD_TO);
1:             if (forwardBytes != null)
1:                 forwardToLocalNodes(message.payload, message.verb, forwardBytes, message.from);
1:         }
1:         else
1:         {
1:             replyTo = InetAddress.getByAddress(from);
1:         }
1:             if (message.version < MessagingService.VERSION_30 && LegacyBatchlogMigrator.isLegacyBatchlogMutation(message.payload))
1:                 LegacyBatchlogMigrator.handleLegacyMutation(message.payload);
1:             else
0:                 message.payload.apply();
1: 
0:             MessagingService.instance().sendReply(WriteResponse.createMessage(), id, replyTo);
/////////////////////////////////////////////////////////////////////////
1:     private static void forwardToLocalNodes(Mutation mutation, MessagingService.Verb verb, byte[] forwardBytes, InetAddress from) throws IOException
commit:c059a56
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOError;
0:     private static final boolean TEST_FAIL_WRITES = System.getProperty("cassandra.test.fail_writes", "false").equalsIgnoreCase("true");
1:     public void doVerb(MessageIn<Mutation> message, int id)  throws IOException
/////////////////////////////////////////////////////////////////////////
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:3c43775
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.exceptions.WriteTimeoutException;
/////////////////////////////////////////////////////////////////////////
0:         try
1:         {
1:         }
0:         catch (WriteTimeoutException wto)
1:         {
0:             Tracing.trace("Payload application resulted in WriteTimeout, not replying");
1:         }
commit:7aafe05
/////////////////////////////////////////////////////////////////////////
1:         try (DataInputStream in = new DataInputStream(new FastByteArrayInputStream(forwardBytes)))
1:             int size = in.readInt();
1: 
1:             // tell the recipients who to send their ack to
1:             MessageOut<Mutation> message = new MessageOut<>(verb, mutation, Mutation.serializer).withParameter(Mutation.FORWARD_FROM, from.getAddress());
1:             // Send a message to each of the addresses on our Forward List
1:             for (int i = 0; i < size; i++)
1:             {
1:                 InetAddress address = CompactEndpointSerializationHelper.deserialize(in);
1:                 int id = in.readInt();
1:                 Tracing.trace("Enqueuing forwarded write to {}", address);
1:                 MessagingService.instance().sendOneWay(message, id, address);
1:             }
commit:ea6ec42
/////////////////////////////////////////////////////////////////////////
0:             rm.apply();
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:24d185d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:5556414
commit:b1d7405
/////////////////////////////////////////////////////////////////////////
0:             InetAddress replyTo;
0:                 replyTo = message.from;
/////////////////////////////////////////////////////////////////////////
0:         // tell the recipients who to send their ack to
0:         // Send a message to each of the addresses on our Forward List
0:             Tracing.trace("Enqueuing forwarded write to {}", address);
commit:7f2c3a8
/////////////////////////////////////////////////////////////////////////
0:                 if (forwardBytes != null)
commit:60d9c7f
/////////////////////////////////////////////////////////////////////////
0:         DataInputStream in = new DataInputStream(new FastByteArrayInputStream(forwardBytes));
0:         int size = in.readInt();
0:             InetAddress address = CompactEndpointSerializationHelper.deserialize(in);
0:             int id = in.readInt();
commit:1936648
/////////////////////////////////////////////////////////////////////////
0:     public void doVerb(MessageIn<RowMutation> message, int id)
/////////////////////////////////////////////////////////////////////////
0:             int id = dis.readInt();
commit:6adf52c
/////////////////////////////////////////////////////////////////////////
0:             logger.debug("Enqueuing response to {}", replyTo);
commit:36b40be
/////////////////////////////////////////////////////////////////////////
0:             logger.debug("Applying mutation");
/////////////////////////////////////////////////////////////////////////
0:             logger.debug("Sending response to {}", replyTo);
/////////////////////////////////////////////////////////////////////////
0:             logger.debug("Forwarding message to {}@{}", id, address);
commit:fd2ddb5
/////////////////////////////////////////////////////////////////////////
0:             WriteResponse response = new WriteResponse();
commit:a06be23
/////////////////////////////////////////////////////////////////////////
0: public class RowMutationVerbHandler implements IVerbHandler<RowMutation>
0:     public void doVerb(MessageIn<RowMutation> message, String id)
0:             RowMutation rm = message.payload;
0:             InetAddress replyTo = message.from;
0:             byte[] from = message.parameters.get(RowMutation.FORWARD_FROM);
0:             if (from == null)
0:                 byte[] forwardBytes = message.parameters.get(RowMutation.FORWARD_TO);
0:                 if (forwardBytes != null && message.version >= MessagingService.VERSION_11)
0:                     forwardToLocalNodes(rm, message.verb, forwardBytes, message.from);
0:                 replyTo = InetAddress.getByAddress(from);
commit:021ec71
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private void forwardToLocalNodes(RowMutation rm, MessagingService.Verb verb, byte[] forwardBytes, InetAddress from) throws IOException
commit:5d46a01
/////////////////////////////////////////////////////////////////////////
0:     public void doVerb(MessageIn message, String id)
commit:5a6f0b8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.net.*;
0: import org.apache.cassandra.service.StorageService;
/////////////////////////////////////////////////////////////////////////
0:             InetAddress replyTo = message.getFrom();
0:             byte[] from = message.getHeader(RowMutation.FORWARD_FROM);
0:             if (from != null)
1:             {
0:                 replyTo = InetAddress.getByAddress(from);
1:             }
0:             else
1:             {
0:                 byte[] forwardBytes = message.getHeader(RowMutation.FORWARD_TO);
0:                 if (forwardBytes != null && message.getVersion() >= MessagingService.VERSION_11)
0:                     forwardToLocalNodes(rm, message.getVerb(), forwardBytes, message.getFrom());
1:             }
0:               logger.debug(rm + " applied.  Sending response to " + id + "@" + replyTo);
0:             MessagingService.instance().sendReply(response.createMessage(), id, replyTo);
/////////////////////////////////////////////////////////////////////////
0:     private void forwardToLocalNodes(RowMutation rm, StorageService.Verb verb, byte[] forwardBytes, InetAddress from) throws IOException
0:         MessageOut<RowMutation> message = new MessageOut<RowMutation>(verb, rm, RowMutation.serializer()).withParameter(RowMutation.FORWARD_FROM, from.getAddress());
/////////////////////////////////////////////////////////////////////////
0:             MessagingService.instance().sendOneWay(message, id, address);
commit:d016a08
/////////////////////////////////////////////////////////////////////////
1: import java.io.DataInputStream;
1: import org.apache.cassandra.io.util.FastByteArrayInputStream;
0: import org.apache.cassandra.net.CompactEndpointSerializationHelper;
/////////////////////////////////////////////////////////////////////////
0:             if (forwardBytes != null && message.getVersion() >= MessagingService.VERSION_11)
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Older version (< 1.0) will not send this message at all, hence we don't
1:      * need to check the version of the data.
1:      */
0:     private void forwardToLocalNodes(Message message, byte[] forwardBytes) throws IOException
0:         DataInputStream dis = new DataInputStream(new FastByteArrayInputStream(forwardBytes));
0:         int size = dis.readInt();
1:         
0:         for (int i = 0; i < size; i++)
0:             // Send a message to each of the addresses on our Forward List
0:             InetAddress address = CompactEndpointSerializationHelper.deserialize(dis);
0:             String id = dis.readUTF();
0:                 logger_.debug("Forwarding message to " + address + " with= ID: " + id);
0:             MessagingService.instance().sendOneWay(messageCopy, id, address);
commit:3893f24
/////////////////////////////////////////////////////////////////////////
commit:be22ee4
/////////////////////////////////////////////////////////////////////////
0:                     RowMutation hintedMutation = RowMutation.hintFor(rm, addressBytes);
commit:6a0df02
/////////////////////////////////////////////////////////////////////////
commit:c5ee059
/////////////////////////////////////////////////////////////////////////
0:     public void doVerb(Message message, String id)
/////////////////////////////////////////////////////////////////////////
0:               logger_.debug(rm + " applied.  Sending response to " + id + "@" + message.getFrom());
0:             MessagingService.instance().sendReply(responseMessage, id, message.getFrom());
commit:fdb0b85
commit:7d567af
/////////////////////////////////////////////////////////////////////////
0:         message.removeHeader(RowMutation.FORWARD_HEADER);
/////////////////////////////////////////////////////////////////////////
0:             MessagingService.instance().sendOneWay(message, address);
commit:78c7a79
commit:fe57cc5
/////////////////////////////////////////////////////////////////////////
0:                     ByteBuffer addressBytes = ByteBufferUtil.readWithShortLength(dis);
commit:b2024a1
/////////////////////////////////////////////////////////////////////////
commit:f4b9e89
commit:37ec7d3
/////////////////////////////////////////////////////////////////////////
0:             MessagingService.instance().sendOneWay(responseMessage, message.getFrom());
/////////////////////////////////////////////////////////////////////////
0:             MessagingService.instance().sendOneWay(message, message.getFrom());
commit:e98eb1c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.net.IVerbHandler;
0: import org.apache.cassandra.net.Message;
0: import org.apache.cassandra.net.MessagingService;
commit:41b98c2
commit:a8b89fb
/////////////////////////////////////////////////////////////////////////
0: import java.io.ByteArrayInputStream;
0: import java.io.DataInputStream;
1: import java.io.IOException;
0: import java.net.UnknownHostException;
0: import org.apache.cassandra.net.IVerbHandler;
0: import org.apache.cassandra.net.Message;
0: import org.apache.cassandra.net.MessagingService;
/////////////////////////////////////////////////////////////////////////
1:         
0:             // Check if there were any forwarding headers in this message
0:             byte[] forwardBytes = message.getHeader(RowMutation.FORWARD_HEADER);
0:             if (forwardBytes != null)
0:                 forwardToLocalNodes(message, forwardBytes);
/////////////////////////////////////////////////////////////////////////
0:     }  
1:     
0:     private void forwardToLocalNodes(Message message, byte[] forwardBytes) throws UnknownHostException
0:     {
0:         // remove fwds from message to avoid infinite loop
0:         message.setHeader(RowMutation.FORWARD_HEADER, null);
1: 
0:         int bytesPerInetAddress = FBUtilities.getLocalAddress().getAddress().length;
0:         assert forwardBytes.length >= bytesPerInetAddress;
0:         assert forwardBytes.length % bytesPerInetAddress == 0;
1: 
0:         int offset = 0;
0:         byte[] addressBytes = new byte[bytesPerInetAddress];
1: 
0:         // Send a message to each of the addresses on our Forward List
0:         while (offset < forwardBytes.length)
0:         {
0:             System.arraycopy(forwardBytes, offset, addressBytes, 0, bytesPerInetAddress);
0:             InetAddress address = InetAddress.getByAddress(addressBytes);
1: 
0:             if (logger_.isDebugEnabled())
0:                 logger_.debug("Forwarding message to " + address);
1: 
0:             // Send the original message to the address specified by the FORWARD_HINT
0:             // Let the response go back to the coordinator
0:             MessagingService.instance.sendOneWay(message, message.getFrom());
1: 
0:             offset += bytesPerInetAddress;
0:         }
commit:f0104cd
/////////////////////////////////////////////////////////////////////////
0: import java.io.*;
0: 
0: 
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
0: 
0: import org.apache.cassandra.net.*;
0: import static com.google.common.base.Charsets.UTF_8;
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:af5e0b7
/////////////////////////////////////////////////////////////////////////
0: import java.io.ByteArrayInputStream;
0: import java.io.DataInputStream;
0: import java.io.IOException;
0: import java.net.UnknownHostException;
0: import org.apache.cassandra.net.IVerbHandler;
0: import org.apache.cassandra.net.Message;
0: import org.apache.cassandra.net.MessagingService;
/////////////////////////////////////////////////////////////////////////
0:         
0:             // Check if there were any forwarding headers in this message
0:             byte[] forwardBytes = message.getHeader(RowMutation.FORWARD_HEADER);
0:             if (forwardBytes != null)
0:                 forwardToLocalNodes(message, forwardBytes);
/////////////////////////////////////////////////////////////////////////
0:     }  
0:     
0:     private void forwardToLocalNodes(Message message, byte[] forwardBytes) throws UnknownHostException
0:     {
0:         // remove fwds from message to avoid infinite loop
0:         message.setHeader(RowMutation.FORWARD_HEADER, null);
0: 
0:         int bytesPerInetAddress = FBUtilities.getLocalAddress().getAddress().length;
0:         assert forwardBytes.length >= bytesPerInetAddress;
0:         assert forwardBytes.length % bytesPerInetAddress == 0;
0: 
0:         int offset = 0;
0:         byte[] addressBytes = new byte[bytesPerInetAddress];
0: 
0:         // Send a message to each of the addresses on our Forward List
0:         while (offset < forwardBytes.length)
0:         {
0:             System.arraycopy(forwardBytes, offset, addressBytes, 0, bytesPerInetAddress);
0:             InetAddress address = InetAddress.getByAddress(addressBytes);
0: 
0:             if (logger_.isDebugEnabled())
0:                 logger_.debug("Forwarding message to " + address);
0: 
0:             // Send the original message to the address specified by the FORWARD_HINT
0:             // Let the response go back to the coordinator
0:             MessagingService.instance.sendOneWay(message, message.getFrom());
0: 
0:             offset += bytesPerInetAddress;
0:         }
commit:2d9b4ba
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.base.Charsets;
0: 
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.ByteBufferUtil;
/////////////////////////////////////////////////////////////////////////
0:                         logger_.debug("Adding hint for " + InetAddress.getByName(ByteBufferUtil.string(addressBytes, Charsets.UTF_8)));
commit:e7a385a
/////////////////////////////////////////////////////////////////////////
0:                     ByteBuffer addressBytes = FBUtilities.readShortByteArray(dis);
0:                         logger_.debug("Adding hint for " + InetAddress.getByName(new String(addressBytes.array(),addressBytes.position()+addressBytes.arrayOffset(),addressBytes.remaining())));
commit:b24dc53
/////////////////////////////////////////////////////////////////////////
0:                         logger_.debug("Adding hint for " + InetAddress.getByAddress(addressBytes));
0:                     RowMutation hintedMutation = new RowMutation(Table.SYSTEM_TABLE, addressBytes);
0:                     hintedMutation.addHints(rm);
commit:8f1376b
/////////////////////////////////////////////////////////////////////////
0: import java.nio.ByteBuffer;
0: 
0: import org.apache.cassandra.utils.FBUtilities;
/////////////////////////////////////////////////////////////////////////
0:             if (hintedBytes != null)
0:                 assert hintedBytes.length > 0;
0:                 ByteBuffer bb = ByteBuffer.wrap(hintedBytes);
0:                 byte[] addressBytes = new byte[FBUtilities.getLocalAddress().getAddress().length];
0:                 while (bb.remaining() > 0)
0:                 {
0:                     bb.get(addressBytes);
0:                     InetAddress hint = InetAddress.getByAddress(addressBytes);
0:                     if (logger_.isDebugEnabled())
0:                         logger_.debug("Adding hint for " + hint);
0:                     RowMutation hintedMutation = new RowMutation(Table.SYSTEM_TABLE, rm.getTable());
0:                     hintedMutation.addHints(rm.key(), addressBytes);
0:                     hintedMutation.apply();
0:                 }
commit:2126f60
/////////////////////////////////////////////////////////////////////////
0:             MessagingService.instance.sendOneWay(responseMessage, message.getFrom());
commit:1cb0794
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         ByteArrayInputStream buffer = new ByteArrayInputStream(bytes);
0:             RowMutation rm = RowMutation.serializer().deserialize(new DataInputStream(buffer));
commit:0642a53
/////////////////////////////////////////////////////////////////////////
0:             Table.open(rm.getTable()).apply(rm, bytes, true);
commit:b767bf7
/////////////////////////////////////////////////////////////////////////
1: import java.net.InetAddress;
/////////////////////////////////////////////////////////////////////////
0:             	InetAddress hint = InetAddress.getByAddress(hintedBytes);
0:                 hintedMutation.addHints(rm.key(), hintedBytes);
commit:694a611
/////////////////////////////////////////////////////////////////////////
0:             	EndPoint hint = EndPoint.getByAddress(hintedBytes);
commit:5e9b35c
/////////////////////////////////////////////////////////////////////////
0:             MessagingService.instance().sendOneWay(responseMessage, message.getFrom());
commit:3a35bc9
/////////////////////////////////////////////////////////////////////////
0:                 RowMutation hintedMutation = new RowMutation(Table.SYSTEM_TABLE, rm.getTable());
0:             WriteResponse response = new WriteResponse(rm.getTable(), rm.key(), true);
commit:d293b77
/////////////////////////////////////////////////////////////////////////
0:         DataInputBuffer buffer = new DataInputBuffer();
0:         buffer.reset(bytes, bytes.length);
0:             RowMutation rm = RowMutation.serializer().deserialize(buffer);
/////////////////////////////////////////////////////////////////////////
0:             rm.apply();
commit:d7e4924
/////////////////////////////////////////////////////////////////////////
commit:066ef58
/////////////////////////////////////////////////////////////////////////
0: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: 
1: package org.apache.cassandra.db;
0: 
0: import java.io.*;
0: 
0: import org.apache.cassandra.io.DataInputBuffer;
0: import org.apache.cassandra.net.EndPoint;
0: import org.apache.cassandra.net.IVerbHandler;
0: import org.apache.cassandra.net.Message;
0: 
0: import org.apache.log4j.Logger;
0: 
0: import org.apache.cassandra.net.*;
0: 
0: /**
0:  * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com )
1:  */
0: 
0: public class RowMutationVerbHandler implements IVerbHandler
0: {
0:     protected static class RowMutationContext
0:     {
0:         protected Row row_ = new Row();
0:         protected DataInputBuffer buffer_ = new DataInputBuffer();
0:     }
0: 
0:     private static Logger logger_ = Logger.getLogger(RowMutationVerbHandler.class);
0:     /* We use this so that we can reuse the same row mutation context for the mutation. */
0:     private static ThreadLocal<RowMutationContext> tls_ = new InheritableThreadLocal<RowMutationContext>();
0: 
0:     public void doVerb(Message message)
0:     {
0:         byte[] bytes = message.getMessageBody();
0:         /* Obtain a Row Mutation Context from TLS */
0:         RowMutationContext rowMutationCtx = tls_.get();
0:         if ( rowMutationCtx == null )
0:         {
0:             rowMutationCtx = new RowMutationContext();
0:             tls_.set(rowMutationCtx);
0:         }
0: 
0:         rowMutationCtx.buffer_.reset(bytes, bytes.length);
0: 
0:         try
0:         {
0:             RowMutation rm = RowMutation.serializer().deserialize(rowMutationCtx.buffer_);
0:             if (logger_.isDebugEnabled())
0:               logger_.debug("Applying " + rm);
0: 
0:             /* Check if there were any hints in this message */
0:             byte[] hintedBytes = message.getHeader(RowMutation.HINT);
0:             if ( hintedBytes != null && hintedBytes.length > 0 )
0:             {
0:             	EndPoint hint = EndPoint.fromBytes(hintedBytes);
0:                 if (logger_.isDebugEnabled())
0:                   logger_.debug("Adding hint for " + hint);
0:                 /* add necessary hints to this mutation */
0:                 RowMutation hintedMutation = new RowMutation(Table.SYSTEM_TABLE, rm.table());
0:                 hintedMutation.addHints(rm.key(), hint.getHost());
0:                 hintedMutation.apply();
0:             }
0: 
0:             rowMutationCtx.row_.clear();
0:             rowMutationCtx.row_.setTable(rm.table());
0:             rowMutationCtx.row_.setKey(rm.key());
0:             rm.apply(rowMutationCtx.row_);
0: 
0:             WriteResponse response = new WriteResponse(rm.table(), rm.key(), true);
0:             Message responseMessage = WriteResponse.makeWriteResponseMessage(message, response);
0:             if (logger_.isDebugEnabled())
0:               logger_.debug(rm + " applied.  Sending response to " + message.getMessageId() + "@" + message.getFrom());
0:             MessagingService.getMessagingInstance().sendOneWay(responseMessage, message.getFrom());
0:         }
0:         catch (IOException e)
0:         {
0:             logger_.error("Error in row mutation", e);
0:         }
0:     }
0: }
commit:986cee6
/////////////////////////////////////////////////////////////////////////
0:                 hintedMutation.addHints(rm.key(), hint.getHost());
commit:0077af4
/////////////////////////////////////////////////////////////////////////
0:             if (logger_.isDebugEnabled())
0:               logger_.debug("Applying " + rm);
0:                 if (logger_.isDebugEnabled())
0:                   logger_.debug("Adding hint for " + hint);
/////////////////////////////////////////////////////////////////////////
0:             if (logger_.isDebugEnabled())
0:               logger_.debug(rm + " applied.  Sending response to " + message.getMessageId() + "@" + message.getFrom());
commit:5cdc75d
/////////////////////////////////////////////////////////////////////////
0:                 RowMutation hintedMutation = new RowMutation(Table.SYSTEM_TABLE, rm.table());
commit:bf660bb
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0:             rowMutationCtx.row_.setTable(rm.table());
0:             rowMutationCtx.row_.setKey(rm.key());
commit:735008d
/////////////////////////////////////////////////////////////////////////
0:             logger_.debug(rm + " applied.  Sending response to " + message.getMessageId() + "@" + message.getFrom());
commit:c129b6d
/////////////////////////////////////////////////////////////////////////
0:             logger_.debug("Mutation applied in " + (end - start) + "ms.  Sending response to " + message.getMessageId() + "@" + message.getFrom());
commit:49211d5
/////////////////////////////////////////////////////////////////////////
0:         byte[] bytes = message.getMessageBody();
commit:71739ef
commit:7b250fa
/////////////////////////////////////////////////////////////////////////
commit:ecfe313
/////////////////////////////////////////////////////////////////////////
0:         byte[] bytes = (byte[]) message.getMessageBody()[0];
/////////////////////////////////////////////////////////////////////////
0:             byte[] hintedBytes = message.getHeader(RowMutation.HINT);
/////////////////////////////////////////////////////////////////////////
0:             rowMutationCtx.row_.clear();
commit:21c1d6b
/////////////////////////////////////////////////////////////////////////
0: 
0:     private static Logger logger_ = Logger.getLogger(RowMutationVerbHandler.class);
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:         rowMutationCtx.buffer_.reset(bytes, bytes.length);
0: 
0:             RowMutation rm = RowMutation.serializer().deserialize(rowMutationCtx.buffer_);
0:             logger_.debug("Applying " + rm);
0: 
0:             byte[] hintedBytes = message.getHeader(RowMutationMessage.hint_);
0:                 logger_.debug("Adding hint for " + hint);
0:                 RowMutation hintedMutation = new RowMutation(rm.table(), HintedHandOffManager.key_);
0:                 hintedMutation.addHints(rm.key() + ":" + hint.getHost());
0:                 hintedMutation.apply();
0: 
0:             long start = System.currentTimeMillis();
0: 
0: 
0:             long end = System.currentTimeMillis();
0: 
0:             WriteResponse response = new WriteResponse(rm.table(), rm.key(), true);
0:             Message responseMessage = WriteResponse.makeWriteResponseMessage(message, response);
0:             logger_.debug("Mutation applied in " + (end - start) + "ms.  Sending response to " +  message.getFrom() + " for key :" + rm.key());
0:             MessagingService.getMessagingInstance().sendOneWay(responseMessage, message.getFrom());
0:         }
0:         catch(ColumnFamilyNotDefinedException ex)
0:             // TODO shouldn't this be checked before it's sent to us?
0:             logger_.warn("column family not defined, and no way to tell the client", ex);
0:         }
0:         catch (IOException e)
0:             logger_.error("Error in row mutation", e);
0:         }
commit:66dee7a
/////////////////////////////////////////////////////////////////////////
0:         byte[] bytes = (byte[]) message.getMessageBody()[0];
/////////////////////////////////////////////////////////////////////////
0:             byte[] hintedBytes = message.getHeader(RowMutation.HINT);
/////////////////////////////////////////////////////////////////////////
0:             rowMutationCtx.row_.clear();
commit:def1edd
/////////////////////////////////////////////////////////////////////////
0: 
0:     private static Logger logger_ = Logger.getLogger(RowMutationVerbHandler.class);
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:         rowMutationCtx.buffer_.reset(bytes, bytes.length);
0: 
0:             RowMutation rm = RowMutation.serializer().deserialize(rowMutationCtx.buffer_);
0:             logger_.debug("Applying " + rm);
0: 
0:             byte[] hintedBytes = message.getHeader(RowMutationMessage.hint_);
0:                 logger_.debug("Adding hint for " + hint);
0:                 RowMutation hintedMutation = new RowMutation(rm.table(), HintedHandOffManager.key_);
0:                 hintedMutation.addHints(rm.key() + ":" + hint.getHost());
0:                 hintedMutation.apply();
0: 
0:             long start = System.currentTimeMillis();
0: 
0: 
0:             long end = System.currentTimeMillis();
0: 
0:             WriteResponse response = new WriteResponse(rm.table(), rm.key(), true);
0:             Message responseMessage = WriteResponse.makeWriteResponseMessage(message, response);
0:             logger_.debug("Mutation applied in " + (end - start) + "ms.  Sending response to " +  message.getFrom() + " for key :" + rm.key());
0:             MessagingService.getMessagingInstance().sendOneWay(responseMessage, message.getFrom());
0:         }
0:         catch(ColumnFamilyNotDefinedException ex)
0:             // TODO shouldn't this be checked before it's sent to us?
0:             logger_.warn("column family not defined, and no way to tell the client", ex);
0:         }
0:         catch (IOException e)
0:             logger_.error("Error in row mutation", e);
0:         }
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:6bbb13b
/////////////////////////////////////////////////////////////////////////
1: public class MutationVerbHandler implements IVerbHandler<Mutation>
0:     private static final Logger logger = LoggerFactory.getLogger(MutationVerbHandler.class);
0:     public void doVerb(MessageIn<Mutation> message, int id)
0:             byte[] from = message.parameters.get(Mutation.FORWARD_FROM);
0:                 byte[] forwardBytes = message.parameters.get(Mutation.FORWARD_TO);
0:                     forwardToLocalNodes(message.payload, message.verb, forwardBytes, message.from);
0:             message.payload.apply();
0:             logger.error("Error in mutation", e);
/////////////////////////////////////////////////////////////////////////
0:     private void forwardToLocalNodes(Mutation mutation, MessagingService.Verb verb, byte[] forwardBytes, InetAddress from) throws IOException
0:         MessageOut<Mutation> message = new MessageOut<>(verb, mutation, Mutation.serializer).withParameter(Mutation.FORWARD_FROM, from.getAddress());
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:d7ff10d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.tracing.Tracing;
/////////////////////////////////////////////////////////////////////////
0:             Tracing.trace("Enqueuing response to {}", replyTo);
commit:07cdfd0
/////////////////////////////////////////////////////////////////////////
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
commit:2fd3268
/////////////////////////////////////////////////////////////////////////
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
commit:5a6e2b0
/////////////////////////////////////////////////////////////////////////
0:     private static final Logger logger = LoggerFactory.getLogger(RowMutationVerbHandler.class);
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
commit:910b663
/////////////////////////////////////////////////////////////////////////
0:     private static Logger logger = LoggerFactory.getLogger(RowMutationVerbHandler.class);
0:             if (logger.isDebugEnabled())
0:               logger.debug("Applying " + rm);
/////////////////////////////////////////////////////////////////////////
0:             if (logger.isDebugEnabled())
0:               logger.debug(rm + " applied.  Sending response to " + id + "@" + message.getFrom());
0:             logger.error("Error in row mutation", e);
/////////////////////////////////////////////////////////////////////////
0:             if (logger.isDebugEnabled())
0:                 logger.debug("Forwarding message to " + address + " with= ID: " + id);
commit:b1e6799
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         Message messageCopy = message.withHeaderRemoved(RowMutation.FORWARD_HEADER);
/////////////////////////////////////////////////////////////////////////
0:             MessagingService.instance().sendOneWay(messageCopy, address);
commit:b62b0ae
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                         logger_.debug("Adding hint for " + InetAddress.getByName(ByteBufferUtil.string(addressBytes)));
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:587cb58
/////////////////////////////////////////////////////////////////////////
0:         MessageOut<RowMutation> message = new MessageOut<RowMutation>(verb, rm, RowMutation.serializer).withParameter(RowMutation.FORWARD_FROM, from.getAddress());
author:Brandon Williams
-------------------------------------------------------------------------------
commit:01883da
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.util.FastByteArrayInputStream;
/////////////////////////////////////////////////////////////////////////
0:                 DataInputStream dis = new DataInputStream(new FastByteArrayInputStream(hintedBytes));
commit:127c028
/////////////////////////////////////////////////////////////////////////
0:         int bytesPerInetAddress = FBUtilities.getBroadcastAddress().getAddress().length;
commit:00ff744
/////////////////////////////////////////////////////////////////////////
0:                 DataInputStream dis = new DataInputStream(new ByteArrayInputStream(hintedBytes));
0:                 while (dis.available() > 0)
0:                     byte[] addressBytes = FBUtilities.readShortByteArray(dis);
0:                         logger_.debug("Adding hint for " + InetAddress.getByName(new String(addressBytes)));
commit:e766e15
/////////////////////////////////////////////////////////////////////////
0: import static com.google.common.base.Charsets.UTF_8;
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0:                 byte[] addressBytes = new byte[FBUtilities.getLocalAddress().getHostAddress().getBytes(UTF_8).length];
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:1ecdd7f
/////////////////////////////////////////////////////////////////////////
0:             RowMutation rm = RowMutation.fromBytes(message.getMessageBody(), message.getVersion());
commit:a8888d2
/////////////////////////////////////////////////////////////////////////
0:             RowMutation rm = RowMutation.fromBytes(message.getMessageBody());
/////////////////////////////////////////////////////////////////////////
0:             Table.open(rm.getTable()).apply(rm, true);
commit:434564d
/////////////////////////////////////////////////////////////////////////
0:                     RowMutation hintedMutation = new RowMutation(Table.SYSTEM_TABLE, rm.getTable().getBytes(FBUtilities.UTF8));
commit:0095f0c
/////////////////////////////////////////////////////////////////////////
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
0:     private static Logger logger_ = LoggerFactory.getLogger(RowMutationVerbHandler.class);
commit:89490e3
/////////////////////////////////////////////////////////////////////////
author:Johan Oskarsson
-------------------------------------------------------------------------------
commit:2c4ac98
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.concurrent.Stage;
0: import org.apache.cassandra.concurrent.StageManager;
/////////////////////////////////////////////////////////////////////////
0: 
0:             // repair-on-write (remote message)
0:             ReplicateOnWriteTask replicateOnWriteTask = new ReplicateOnWriteTask(rm);
0:             StageManager.getStage(Stage.REPLICATE_ON_WRITE).execute(replicateOnWriteTask);
author:Avinash Lakshman
-------------------------------------------------------------------------------
commit:964dd9b
/////////////////////////////////////////////////////////////////////////
0:     
0:     private static Logger logger_ = Logger.getLogger(RowMutationVerbHandler.class);     
0:     
0:         /* For DEBUG only. Printing queue length */                         
0:         logger_.info( "ROW MUTATION STAGE: " + StageManager.getStageTaskCount(StorageService.mutationStage_) );
0:         /* END DEBUG */
0:             
0:         byte[] bytes = (byte[])message.getMessageBody()[0];
/////////////////////////////////////////////////////////////////////////
0:                 
0:         rowMutationCtx.buffer_.reset(bytes, bytes.length);        
0:         
0:             RowMutationMessage rmMsg = RowMutationMessage.serializer().deserialize(rowMutationCtx.buffer_);
0:             RowMutation rm = rmMsg.getRowMutation();
0:             byte[] hintedBytes = message.getHeader(RowMutationMessage.hint_);            
0:                 try
0:                 {
0:                 	RowMutation hintedMutation = new RowMutation(rm.table(), HintedHandOffManager.key_);
0:                 	hintedMutation.addHints(rm.key() + ":" + hint.getHost());
0:                 	hintedMutation.apply();
0:                 }
0:                 catch ( ColumnFamilyNotDefinedException ex )
0:                 {
0:                     logger_.debug(LogUtil.throwableToString(ex));
0:                 }
0:             
0:             long start = System.currentTimeMillis(); 
0:             
0:             
0:             long end = System.currentTimeMillis();                       
0:             logger_.info("ROW MUTATION APPLY: " + (end - start) + " ms.");
0:             
0:             /*WriteResponseMessage writeResponseMessage = new WriteResponseMessage(rm.table(), rm.key(), true);
0:             Message response = message.getReply( StorageService.getLocalStorageEndPoint(), new Object[]{writeResponseMessage} );
0:             logger_.debug("Sending teh response to " +  message.getFrom() + " for key :" + rm.key());
0:             MessagingService.getMessagingInstance().sendOneWay(response, message.getFrom());  */                    
0:         }         
0:         catch( ColumnFamilyNotDefinedException ex )
0:             logger_.debug(LogUtil.throwableToString(ex));
0:         }        
0:         catch ( IOException e )
0:             logger_.debug(LogUtil.throwableToString(e));            
0:         }        
author:Prashant Malik
-------------------------------------------------------------------------------
commit:1f91e99
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: 
0: package org.apache.cassandra.db;
0: 
0: import java.util.*;
0: import java.util.concurrent.atomic.AtomicInteger;
0: import java.io.*;
0: 
0: import org.apache.cassandra.concurrent.StageManager;
0: import org.apache.cassandra.io.DataInputBuffer;
0: import org.apache.cassandra.net.EndPoint;
0: import org.apache.cassandra.net.IVerbHandler;
0: import org.apache.cassandra.net.Message;
0: import org.apache.cassandra.service.StorageService;
0: import org.apache.cassandra.utils.LogUtil;
0: import org.apache.log4j.Logger;
0: import org.apache.cassandra.service.*;
0: import org.apache.cassandra.utils.*;
0: import org.apache.cassandra.concurrent.*;
0: import org.apache.cassandra.net.*;
0: 
0: /**
0:  * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com )
0:  */
0: 
0: public class RowMutationVerbHandler implements IVerbHandler
0: {
0:     protected static class RowMutationContext
0:     {
0:         protected Row row_ = new Row();
0:         protected DataInputBuffer buffer_ = new DataInputBuffer();
0:     }
0:     
0:     private static Logger logger_ = Logger.getLogger(RowMutationVerbHandler.class);     
0:     /* We use this so that we can reuse the same row mutation context for the mutation. */
0:     private static ThreadLocal<RowMutationContext> tls_ = new InheritableThreadLocal<RowMutationContext>();
0:     
0:     public void doVerb(Message message)
0:     {
0:         /* For DEBUG only. Printing queue length */                         
0:         logger_.info( "ROW MUTATION STAGE: " + StageManager.getStageTaskCount(StorageService.mutationStage_) );
0:         /* END DEBUG */
0:             
0:         byte[] bytes = (byte[])message.getMessageBody()[0];
0:         /* Obtain a Row Mutation Context from TLS */
0:         RowMutationContext rowMutationCtx = tls_.get();
0:         if ( rowMutationCtx == null )
0:         {
0:             rowMutationCtx = new RowMutationContext();
0:             tls_.set(rowMutationCtx);
0:         }
0:                 
0:         rowMutationCtx.buffer_.reset(bytes, bytes.length);        
0:         
0:         try
0:         {
0:             RowMutationMessage rmMsg = RowMutationMessage.serializer().deserialize(rowMutationCtx.buffer_);
0:             RowMutation rm = rmMsg.getRowMutation();
0:             /* Check if there were any hints in this message */
0:             byte[] hintedBytes = message.getHeader(RowMutationMessage.hint_);            
0:             if ( hintedBytes != null && hintedBytes.length > 0 )
0:             {
0:             	EndPoint hint = EndPoint.fromBytes(hintedBytes);
0:                 /* add necessary hints to this mutation */
0:                 try
0:                 {
0:                 	RowMutation hintedMutation = new RowMutation(rm.table(), HintedHandOffManager.key_);
0:                 	hintedMutation.addHints(rm.key() + ":" + hint.getHost());
0:                 	hintedMutation.apply();
0:                 }
0:                 catch ( ColumnFamilyNotDefinedException ex )
0:                 {
0:                     logger_.debug(LogUtil.throwableToString(ex));
0:                 }
0:             }
0:             
0:             long start = System.currentTimeMillis(); 
0:             
0:             rowMutationCtx.row_.key(rm.key());
0:             rm.apply(rowMutationCtx.row_);
0:             
0:             long end = System.currentTimeMillis();                       
0:             logger_.info("ROW MUTATION APPLY: " + (end - start) + " ms.");
0:             
0:             /*WriteResponseMessage writeResponseMessage = new WriteResponseMessage(rm.table(), rm.key(), true);
0:             Message response = message.getReply( StorageService.getLocalStorageEndPoint(), new Object[]{writeResponseMessage} );
0:             logger_.debug("Sending teh response to " +  message.getFrom() + " for key :" + rm.key());
0:             MessagingService.getMessagingInstance().sendOneWay(response, message.getFrom());  */                    
0:         }         
0:         catch( ColumnFamilyNotDefinedException ex )
0:         {
0:             logger_.debug(LogUtil.throwableToString(ex));
0:         }        
0:         catch ( IOException e )
0:         {
0:             logger_.debug(LogUtil.throwableToString(e));            
0:         }        
0:     }
0: }
============================================================================