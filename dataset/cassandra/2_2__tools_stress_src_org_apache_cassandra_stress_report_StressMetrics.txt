1:e73633c: package org.apache.cassandra.stress.report;
1:e73633c: /*
1:e73633c:  *
1:e73633c:  * Licensed to the Apache Software Foundation (ASF) under one
1:e73633c:  * or more contributor license agreements.  See the NOTICE file
1:e73633c:  * distributed with this work for additional information
1:e73633c:  * regarding copyright ownership.  The ASF licenses this file
1:e73633c:  * to you under the Apache License, Version 2.0 (the
1:e73633c:  * "License"); you may not use this file except in compliance
1:e73633c:  * with the License.  You may obtain a copy of the License at
1:e73633c:  *
1:e73633c:  *   http://www.apache.org/licenses/LICENSE-2.0
1:e73633c:  *
1:e73633c:  * Unless required by applicable law or agreed to in writing,
1:e73633c:  * software distributed under the License is distributed on an
1:e73633c:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:e73633c:  * KIND, either express or implied.  See the License for the
1:e73633c:  * specific language governing permissions and limitations
1:e73633c:  * under the License.
1:e73633c:  *
1:e73633c:  */
1:e73633c: 
1:e73633c: 
1:e73633c: import static java.util.concurrent.TimeUnit.NANOSECONDS;
1:e73633c: 
1:e73633c: import java.io.FileNotFoundException;
1:e73633c: import java.util.ArrayDeque;
1:e73633c: import java.util.ArrayList;
1:e73633c: import java.util.Arrays;
1:e73633c: import java.util.List;
1:e73633c: import java.util.Map;
1:e73633c: import java.util.Map.Entry;
1:e73633c: import java.util.Queue;
1:e73633c: import java.util.TreeMap;
1:e73633c: import java.util.concurrent.Callable;
1:e73633c: import java.util.concurrent.CountDownLatch;
1:e73633c: import java.util.concurrent.TimeUnit;
1:e73633c: import java.util.concurrent.locks.LockSupport;
1:e73633c: 
1:e73633c: import org.HdrHistogram.Histogram;
1:e73633c: import org.HdrHistogram.HistogramLogWriter;
1:e73633c: import org.apache.cassandra.stress.StressAction.Consumer;
1:e73633c: import org.apache.cassandra.stress.StressAction.MeasurementSink;
1:e73633c: import org.apache.cassandra.stress.StressAction.OpMeasurement;
1:e73633c: import org.apache.cassandra.stress.settings.SettingsLog.Level;
1:e73633c: import org.apache.cassandra.stress.settings.StressSettings;
1:e73633c: import org.apache.cassandra.stress.util.JmxCollector;
1:f42e235: import org.apache.cassandra.stress.util.ResultLogger;
1:e73633c: import org.apache.cassandra.stress.util.JmxCollector.GcStats;
1:e73633c: import org.apache.cassandra.stress.util.Uncertainty;
1:e73633c: import org.apache.cassandra.utils.FBUtilities;
1:e73633c: import org.apache.commons.lang3.time.DurationFormatUtils;
1:e73633c: 
1:e73633c: public class StressMetrics implements MeasurementSink
3:e73633c: {
1:e73633c:     private final List<Consumer> consumers = new ArrayList<>();
1:f42e235:     private final ResultLogger output;
1:e73633c:     private final Thread thread;
1:e73633c:     private final Uncertainty rowRateUncertainty = new Uncertainty();
1:e73633c:     private final CountDownLatch stopped = new CountDownLatch(1);
1:e73633c:     private final Callable<JmxCollector.GcStats> gcStatsCollector;
1:e73633c:     private final HistogramLogWriter histogramWriter;
1:e73633c:     private final long epochNs = System.nanoTime();
1:e73633c:     private final long epochMs = System.currentTimeMillis();
1:e73633c: 
1:e73633c:     private volatile JmxCollector.GcStats totalGcStats = new GcStats(0);
1:e73633c: 
1:e73633c:     private volatile boolean stop = false;
1:e73633c:     private volatile boolean cancelled = false;
1:e73633c: 
1:e73633c: 
1:e73633c:     // collected data for intervals and summary
1:e73633c:     private final Map<String, TimingInterval> opTypeToCurrentTimingInterval = new TreeMap<>();
1:e73633c:     private final Map<String, TimingInterval> opTypeToSummaryTimingInterval = new TreeMap<>();
1:e73633c:     private final Queue<OpMeasurement> leftovers = new ArrayDeque<>();
1:e73633c:     private final TimingInterval totalCurrentInterval;
1:e73633c:     private final TimingInterval totalSummaryInterval;
1:e73633c: 
1:f42e235:     public StressMetrics(ResultLogger output, final long logIntervalMillis, StressSettings settings)
1:e73633c:     {
1:e73633c:         this.output = output;
1:e73633c:         if(settings.log.hdrFile != null)
1:e73633c:         {
1:e73633c:             try
1:e73633c:             {
1:e73633c:                 histogramWriter = new HistogramLogWriter(settings.log.hdrFile);
1:e73633c:                 histogramWriter.outputComment("Logging op latencies for Cassandra Stress");
1:e73633c:                 histogramWriter.outputLogFormatVersion();
1:e73633c:                 final long roundedEpoch = epochMs - (epochMs%1000);
1:e73633c:                 histogramWriter.outputBaseTime(roundedEpoch);
1:e73633c:                 histogramWriter.setBaseTime(roundedEpoch);
1:e73633c:                 histogramWriter.outputStartTime(roundedEpoch);
1:e73633c:                 histogramWriter.outputLegend();
2:e73633c:             }
1:e73633c:             catch (FileNotFoundException e)
1:e73633c:             {
1:e73633c:                 throw new IllegalArgumentException(e);
1:e73633c:             }
1:e73633c:         }
1:e73633c:         else
1:e73633c:         {
1:e73633c:             histogramWriter = null;
1:e73633c:         }
1:e73633c:         Callable<JmxCollector.GcStats> gcStatsCollector;
1:e73633c:         totalGcStats = new JmxCollector.GcStats(0);
1:e73633c:         try
1:e73633c:         {
1:e73633c:             gcStatsCollector = new JmxCollector(settings.node.resolveAllPermitted(settings), settings.port.jmxPort);
1:e73633c:         }
1:e73633c:         catch (Throwable t)
1:e73633c:         {
1:e73633c:             if (settings.log.level == Level.VERBOSE)
1:e73633c:             {
1:e73633c:                 t.printStackTrace();
1:e73633c:             }
1:e73633c:             System.err.println("Failed to connect over JMX; not collecting these stats");
1:f42e235:             gcStatsCollector = () -> totalGcStats;
1:e73633c:         }
1:e73633c:         this.gcStatsCollector = gcStatsCollector;
1:e73633c:         this.totalCurrentInterval = new TimingInterval(settings.rate.isFixed);
1:e73633c:         this.totalSummaryInterval = new TimingInterval(settings.rate.isFixed);
1:e73633c:         printHeader("", output);
1:e73633c:         thread = new Thread(() -> {
1:e73633c:             reportingLoop(logIntervalMillis);
1:e73633c:         });
1:e73633c:         thread.setName("StressMetrics");
1:e73633c:     }
1:e73633c:     public void start()
1:e73633c:     {
1:e73633c:         thread.start();
1:e73633c:     }
1:e73633c: 
1:e73633c:     public void waitUntilConverges(double targetUncertainty, int minMeasurements, int maxMeasurements) throws InterruptedException
1:e73633c:     {
1:e73633c:         rowRateUncertainty.await(targetUncertainty, minMeasurements, maxMeasurements);
1:e73633c:     }
1:e73633c: 
1:e73633c:     public void cancel()
1:e73633c:     {
1:e73633c:         cancelled = true;
1:e73633c:         stop = true;
1:e73633c:         thread.interrupt();
1:e73633c:         rowRateUncertainty.wakeAll();
1:e73633c:     }
1:e73633c: 
1:e73633c:     public void stop() throws InterruptedException
1:e73633c:     {
1:e73633c:         stop = true;
1:e73633c:         thread.interrupt();
1:e73633c:         stopped.await();
1:e73633c:     }
1:e73633c: 
1:e73633c: 
1:e73633c:     private void reportingLoop(final long logIntervalMillis)
1:e73633c:     {
1:e73633c:         // align report timing to the nearest second
1:e73633c:         final long currentTimeMs = System.currentTimeMillis();
1:e73633c:         final long startTimeMs = currentTimeMs - (currentTimeMs % 1000);
1:e73633c:         // reporting interval starts rounded to the second
1:e73633c:         long reportingStartNs = (System.nanoTime() - TimeUnit.MILLISECONDS.toNanos(currentTimeMs - startTimeMs));
1:e73633c:         final long parkIntervalNs = TimeUnit.MILLISECONDS.toNanos(logIntervalMillis);
1:e73633c:         try
1:e73633c:         {
1:e73633c:             while (!stop)
1:e73633c:             {
1:e73633c:                 final long wakupTarget = reportingStartNs + parkIntervalNs;
1:e73633c:                 sleepUntil(wakupTarget);
1:e73633c:                 if (stop)
1:e73633c:                 {
1:e73633c:                     break;
1:e73633c:                 }
1:e73633c:                 recordInterval(wakupTarget, parkIntervalNs);
1:e73633c:                 reportingStartNs += parkIntervalNs;
1:e73633c:             }
1:e73633c: 
1:e73633c:             final long end = System.nanoTime();
1:e73633c:             recordInterval(end, end - reportingStartNs);
1:e73633c:         }
1:e73633c:         catch (Exception e)
1:e73633c:         {
1:e73633c:             e.printStackTrace();
1:e73633c:             cancel();
1:e73633c:         }
1:e73633c:         finally
1:e73633c:         {
1:e73633c:             rowRateUncertainty.wakeAll();
1:e73633c:             stopped.countDown();
1:e73633c:         }
1:e73633c:     }
1:e73633c: 
1:e73633c: 
1:e73633c:     private void sleepUntil(final long until)
1:e73633c:     {
1:e73633c:         long parkFor;
1:e73633c:         while (!stop &&
1:e73633c:                (parkFor = until - System.nanoTime()) > 0)
1:e73633c:         {
1:e73633c:             LockSupport.parkNanos(parkFor);
1:e73633c:         }
1:e73633c:     }
1:e73633c: 
1:e73633c:     @Override
1:e73633c:     public void record(String opType, long intended, long started, long ended, long rowCnt, long partitionCnt, boolean err)
1:e73633c:     {
1:e73633c:         TimingInterval current = opTypeToCurrentTimingInterval.computeIfAbsent(opType, k -> new TimingInterval(totalCurrentInterval.isFixed));
1:e73633c:         record(current, intended, started, ended, rowCnt, partitionCnt, err);
1:e73633c:     }
1:e73633c: 
1:e73633c:     private void record(TimingInterval t, long intended, long started, long ended, long rowCnt, long partitionCnt, boolean err)
1:e73633c:     {
1:e73633c:         t.rowCount += rowCnt;
1:e73633c:         t.partitionCount += partitionCnt;
1:e73633c:         if (err)
1:e73633c:             t.errorCount++;
1:e73633c:         if (intended != 0) {
1:e73633c:             t.responseTime().recordValue(ended-intended);
1:e73633c:             t.waitTime().recordValue(started-intended);
1:e73633c:         }
1:e73633c:         final long sTime = ended-started;
1:e73633c:         t.serviceTime().recordValue(sTime);
1:e73633c:     }
1:e73633c: 
1:f42e235:     private void recordInterval(long intervalEnd, long parkIntervalNs)
1:e73633c:     {
1:e73633c: 
1:e73633c:         drainConsumerMeasurements(intervalEnd, parkIntervalNs);
1:e73633c: 
1:e73633c:         GcStats gcStats = null;
1:e73633c:         try
1:e73633c:         {
1:e73633c:             gcStats = gcStatsCollector.call();
1:e73633c:         }
1:e73633c:         catch (Exception e)
1:e73633c:         {
1:e73633c:             gcStats = new GcStats(0);
1:e73633c:         }
1:e73633c:         totalGcStats = JmxCollector.GcStats.aggregate(Arrays.asList(totalGcStats, gcStats));
1:e73633c: 
1:e73633c:         rowRateUncertainty.update(totalCurrentInterval.adjustedRowRate());
1:e73633c:         if (totalCurrentInterval.operationCount() != 0)
1:e73633c:         {
1:e73633c:             // if there's a single operation we only print the total
1:e73633c:             final boolean logPerOpSummaryLine = opTypeToCurrentTimingInterval.size() > 1;
1:e73633c: 
1:e73633c:             for (Map.Entry<String, TimingInterval> type : opTypeToCurrentTimingInterval.entrySet())
1:e73633c:             {
1:e73633c:                 final String opName = type.getKey();
1:e73633c:                 final TimingInterval opInterval = type.getValue();
1:e73633c:                 if (logPerOpSummaryLine)
1:e73633c:                 {
1:e73633c:                     printRow("", opName, opInterval, opTypeToSummaryTimingInterval.get(opName), gcStats, rowRateUncertainty, output);
1:e73633c:                 }
1:e73633c:                 logHistograms(opName, opInterval);
1:e73633c:                 opInterval.reset();
1:e73633c:             }
1:e73633c: 
1:e73633c:             printRow("", "total", totalCurrentInterval, totalSummaryInterval, gcStats, rowRateUncertainty, output);
1:e73633c:             totalCurrentInterval.reset();
1:e73633c:         }
1:e73633c:     }
1:e73633c: 
1:e73633c:     private void drainConsumerMeasurements(long intervalEnd, long parkIntervalNs)
1:e73633c:     {
1:e73633c:         // record leftover measurements if any
1:e73633c:         int leftoversSize = leftovers.size();
1:e73633c:         for (int i=0;i<leftoversSize;i++)
1:e73633c:         {
1:e73633c:             OpMeasurement last = leftovers.poll();
1:e73633c:             if (last.ended <= intervalEnd)
1:e73633c:             {
1:e73633c:                 record(last.opType, last.intended, last.started, last.ended, last.rowCnt, last.partitionCnt, last.err);
1:e73633c:                 // round robin-ish redistribution of leftovers
1:e73633c:                 consumers.get(i%consumers.size()).measurementsRecycling.offer(last);
1:e73633c:             }
1:e73633c:             else
1:e73633c:             {
1:e73633c:                 // no record for you! wait one interval!
1:e73633c:                 leftovers.offer(last);
1:e73633c:             }
1:e73633c:         }
1:e73633c:         // record interval collected measurements
1:e73633c:         for (Consumer c: consumers) {
1:e73633c:             Queue<OpMeasurement> in = c.measurementsReporting;
1:e73633c:             Queue<OpMeasurement> out = c.measurementsRecycling;
1:e73633c:             OpMeasurement last;
1:e73633c:             while ((last = in.poll()) != null)
1:e73633c:             {
1:e73633c:                 if (last.ended > intervalEnd)
1:e73633c:                 {
1:e73633c:                     // measurements for any given consumer are ordered, we stop when we stop.
1:e73633c:                     leftovers.add(last);
1:e73633c:                     break;
1:e73633c:                 }
1:e73633c:                 record(last.opType, last.intended, last.started, last.ended, last.rowCnt, last.partitionCnt, last.err);
1:e73633c:                 out.offer(last);
1:e73633c:             }
1:e73633c:         }
1:e73633c:         // set timestamps and summarize
1:e73633c:         for (Entry<String, TimingInterval> currPerOp : opTypeToCurrentTimingInterval.entrySet()) {
1:e73633c:             currPerOp.getValue().endNanos(intervalEnd);
1:e73633c:             currPerOp.getValue().startNanos(intervalEnd-parkIntervalNs);
1:e73633c:             TimingInterval summaryPerOp = opTypeToSummaryTimingInterval.computeIfAbsent(currPerOp.getKey(), k -> new TimingInterval(totalCurrentInterval.isFixed));
1:e73633c:             summaryPerOp.add(currPerOp.getValue());
1:e73633c:             totalCurrentInterval.add(currPerOp.getValue());
1:e73633c:         }
1:e73633c:         totalCurrentInterval.endNanos(intervalEnd);
1:e73633c:         totalCurrentInterval.startNanos(intervalEnd-parkIntervalNs);
1:e73633c: 
1:e73633c:         totalSummaryInterval.add(totalCurrentInterval);
1:e73633c:     }
1:e73633c: 
1:e73633c: 
1:e73633c:     private void logHistograms(String opName, TimingInterval opInterval)
1:e73633c:     {
1:e73633c:         if (histogramWriter == null)
1:e73633c:             return;
1:e73633c:         final long startNs = opInterval.startNanos();
1:e73633c:         final long endNs = opInterval.endNanos();
1:e73633c: 
1:e73633c:         logHistogram(opName + "-st", startNs, endNs, opInterval.serviceTime());
1:e73633c:         logHistogram(opName + "-rt", startNs, endNs, opInterval.responseTime());
1:e73633c:         logHistogram(opName + "-wt", startNs, endNs, opInterval.waitTime());
1:e73633c:     }
1:e73633c: 
1:e73633c:     private void logHistogram(String opName, final long startNs, final long endNs, final Histogram histogram)
1:e73633c:     {
1:e73633c:         if (histogram.getTotalCount() != 0)
1:e73633c:         {
1:e73633c:             histogram.setTag(opName);
1:e73633c:             final long relativeStartNs = startNs - epochNs;
1:e73633c:             final long startMs = (long) (1000 *((epochMs + NANOSECONDS.toMillis(relativeStartNs))/1000.0));
1:e73633c:             histogram.setStartTimeStamp(startMs);
1:e73633c:             final long relativeEndNs = endNs - epochNs;
1:e73633c:             final long endMs = (long) (1000 *((epochMs + NANOSECONDS.toMillis(relativeEndNs))/1000.0));
1:e73633c:             histogram.setEndTimeStamp(endMs);
1:e73633c:             histogramWriter.outputIntervalHistogram(histogram);
1:e73633c:         }
1:e73633c:     }
1:e73633c: 
1:e73633c: 
1:e73633c:     // PRINT FORMATTING
1:e73633c: 
1:e73633c:     public static final String HEADFORMAT = "%-10s%10s,%8s,%8s,%8s,%8s,%8s,%8s,%8s,%8s,%8s,%7s,%9s,%7s,%7s,%8s,%8s,%8s,%8s";
1:e73633c:     public static final String ROWFORMAT =  "%-10s%10d,%8.0f,%8.0f,%8.0f,%8.1f,%8.1f,%8.1f,%8.1f,%8.1f,%8.1f,%7.1f,%9.5f,%7d,%7.0f,%8.0f,%8.0f,%8.0f,%8.0f";
1:e73633c:     public static final String[] HEADMETRICS = new String[]{"type", "total ops","op/s","pk/s","row/s","mean","med",".95",".99",".999","max","time","stderr", "errors", "gc: #", "max ms", "sum ms", "sdv ms", "mb"};
1:e73633c:     public static final String HEAD = String.format(HEADFORMAT, (Object[]) HEADMETRICS);
1:e73633c: 
1:f42e235:     private static void printHeader(String prefix, ResultLogger output)
1:e73633c:     {
1:e73633c:         output.println(prefix + HEAD);
1:e73633c:     }
1:e73633c: 
1:f42e235:     private static void printRow(String prefix, String type, TimingInterval interval, TimingInterval total,
1:f42e235:                                  JmxCollector.GcStats gcStats, Uncertainty opRateUncertainty, ResultLogger output)
1:e73633c:     {
1:e73633c:         output.println(prefix + String.format(ROWFORMAT,
1:e73633c:                 type + ",",
1:e73633c:                 total.operationCount(),
1:e73633c:                 interval.opRate(),
1:e73633c:                 interval.partitionRate(),
1:e73633c:                 interval.rowRate(),
1:e73633c:                 interval.meanLatencyMs(),
1:e73633c:                 interval.medianLatencyMs(),
1:e73633c:                 interval.latencyAtPercentileMs(95.0),
1:e73633c:                 interval.latencyAtPercentileMs(99.0),
1:e73633c:                 interval.latencyAtPercentileMs(99.9),
1:e73633c:                 interval.maxLatencyMs(),
1:e73633c:                 total.runTimeMs() / 1000f,
1:e73633c:                 opRateUncertainty.getUncertainty(),
1:e73633c:                 interval.errorCount,
1:e73633c:                 gcStats.count,
1:e73633c:                 gcStats.maxms,
1:e73633c:                 gcStats.summs,
1:e73633c:                 gcStats.sdvms,
1:e73633c:                 gcStats.bytes / (1 << 20)
1:e73633c:         ));
1:e73633c:     }
1:e73633c: 
1:e73633c:     public void summarise()
1:e73633c:     {
1:e73633c:         output.println("\n");
1:e73633c:         output.println("Results:");
1:e73633c: 
1:e73633c:         TimingIntervals opHistory = new TimingIntervals(opTypeToSummaryTimingInterval);
1:e73633c:         TimingInterval history = this.totalSummaryInterval;
1:e73633c:         output.println(String.format("Op rate                   : %,8.0f op/s  %s", history.opRate(), opHistory.opRates()));
1:e73633c:         output.println(String.format("Partition rate            : %,8.0f pk/s  %s", history.partitionRate(), opHistory.partitionRates()));
1:e73633c:         output.println(String.format("Row rate                  : %,8.0f row/s %s", history.rowRate(), opHistory.rowRates()));
1:e73633c:         output.println(String.format("Latency mean              : %6.1f ms %s", history.meanLatencyMs(), opHistory.meanLatencies()));
1:e73633c:         output.println(String.format("Latency median            : %6.1f ms %s", history.medianLatencyMs(), opHistory.medianLatencies()));
1:e73633c:         output.println(String.format("Latency 95th percentile   : %6.1f ms %s", history.latencyAtPercentileMs(95.0), opHistory.latenciesAtPercentile(95.0)));
1:e73633c:         output.println(String.format("Latency 99th percentile   : %6.1f ms %s", history.latencyAtPercentileMs(99.0), opHistory.latenciesAtPercentile(99.0)));
1:e73633c:         output.println(String.format("Latency 99.9th percentile : %6.1f ms %s", history.latencyAtPercentileMs(99.9), opHistory.latenciesAtPercentile(99.9)));
1:e73633c:         output.println(String.format("Latency max               : %6.1f ms %s", history.maxLatencyMs(), opHistory.maxLatencies()));
1:e73633c:         output.println(String.format("Total partitions          : %,10d %s",   history.partitionCount, opHistory.partitionCounts()));
1:e73633c:         output.println(String.format("Total errors              : %,10d %s",   history.errorCount, opHistory.errorCounts()));
1:e73633c:         output.println(String.format("Total GC count            : %,1.0f", totalGcStats.count));
1:e73633c:         output.println(String.format("Total GC memory           : %s", FBUtilities.prettyPrintMemory((long)totalGcStats.bytes, true)));
1:e73633c:         output.println(String.format("Total GC time             : %,6.1f seconds", totalGcStats.summs / 1000));
1:e73633c:         output.println(String.format("Avg GC time               : %,6.1f ms", totalGcStats.summs / totalGcStats.count));
1:e73633c:         output.println(String.format("StdDev GC time            : %,6.1f ms", totalGcStats.sdvms));
1:e73633c:         output.println("Total operation time      : " + DurationFormatUtils.formatDuration(
1:e73633c:                 history.runTimeMs(), "HH:mm:ss", true));
1:e73633c:         output.println(""); // Newline is important here to separate the aggregates section from the END or the next stress iteration
1:e73633c:     }
1:e73633c: 
1:f42e235:     public static void summarise(List<String> ids, List<StressMetrics> summarise, ResultLogger out)
1:e73633c:     {
1:e73633c:         int idLen = 0;
1:e73633c:         for (String id : ids)
1:e73633c:             idLen = Math.max(id.length(), idLen);
1:e73633c:         String formatstr = "%" + idLen + "s, ";
1:e73633c:         printHeader(String.format(formatstr, "id"), out);
1:e73633c:         for (int i = 0 ; i < ids.size() ; i++)
1:e73633c:         {
1:e73633c:             for (Map.Entry<String, TimingInterval> type : summarise.get(i).opTypeToSummaryTimingInterval.entrySet())
1:e73633c:             {
1:e73633c:                 printRow(String.format(formatstr, ids.get(i)),
1:e73633c:                          type.getKey(),
1:e73633c:                          type.getValue(),
1:e73633c:                          type.getValue(),
1:e73633c:                          summarise.get(i).totalGcStats,
1:e73633c:                          summarise.get(i).rowRateUncertainty,
1:e73633c:                          out);
1:e73633c:             }
1:e73633c:             TimingInterval hist = summarise.get(i).totalSummaryInterval;
1:e73633c:             printRow(String.format(formatstr, ids.get(i)),
1:e73633c:                     "total",
1:e73633c:                     hist,
1:e73633c:                     hist,
1:e73633c:                     summarise.get(i).totalGcStats,
1:e73633c:                     summarise.get(i).rowRateUncertainty,
1:e73633c:                     out
1:e73633c:             );
1:e73633c:         }
1:e73633c:     }
1:e73633c: 
1:e73633c:     public boolean wasCancelled()
1:e73633c:     {
1:e73633c:         return cancelled;
1:e73633c:     }
1:e73633c: 
1:e73633c:     public void add(Consumer consumer)
1:e73633c:     {
1:e73633c:         consumers.add(consumer);
1:e73633c:     }
1:e73633c: 
1:e73633c:     public double opRate()
1:e73633c:     {
1:e73633c:         return totalSummaryInterval.opRate();
1:e73633c:     }
1:e73633c: }
============================================================================
author:Christopher Batey
-------------------------------------------------------------------------------
commit:f42e235
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.stress.util.ResultLogger;
/////////////////////////////////////////////////////////////////////////
1:     private final ResultLogger output;
/////////////////////////////////////////////////////////////////////////
1:     public StressMetrics(ResultLogger output, final long logIntervalMillis, StressSettings settings)
/////////////////////////////////////////////////////////////////////////
1:             gcStatsCollector = () -> totalGcStats;
/////////////////////////////////////////////////////////////////////////
1:     private void recordInterval(long intervalEnd, long parkIntervalNs)
/////////////////////////////////////////////////////////////////////////
1:     private static void printHeader(String prefix, ResultLogger output)
1:     private static void printRow(String prefix, String type, TimingInterval interval, TimingInterval total,
1:                                  JmxCollector.GcStats gcStats, Uncertainty opRateUncertainty, ResultLogger output)
/////////////////////////////////////////////////////////////////////////
1:     public static void summarise(List<String> ids, List<StressMetrics> summarise, ResultLogger out)
author:nitsanw
-------------------------------------------------------------------------------
commit:e73633c
/////////////////////////////////////////////////////////////////////////
1: package org.apache.cassandra.stress.report;
1: /*
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  *
1:  */
1: 
1: 
1: import static java.util.concurrent.TimeUnit.NANOSECONDS;
1: 
1: import java.io.FileNotFoundException;
0: import java.io.PrintStream;
1: import java.util.ArrayDeque;
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Map.Entry;
1: import java.util.Queue;
1: import java.util.TreeMap;
1: import java.util.concurrent.Callable;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.locks.LockSupport;
1: 
1: import org.HdrHistogram.Histogram;
1: import org.HdrHistogram.HistogramLogWriter;
1: import org.apache.cassandra.stress.StressAction.Consumer;
1: import org.apache.cassandra.stress.StressAction.MeasurementSink;
1: import org.apache.cassandra.stress.StressAction.OpMeasurement;
1: import org.apache.cassandra.stress.settings.SettingsLog.Level;
1: import org.apache.cassandra.stress.settings.StressSettings;
1: import org.apache.cassandra.stress.util.JmxCollector;
1: import org.apache.cassandra.stress.util.JmxCollector.GcStats;
1: import org.apache.cassandra.stress.util.Uncertainty;
1: import org.apache.cassandra.utils.FBUtilities;
1: import org.apache.commons.lang3.time.DurationFormatUtils;
1: 
1: public class StressMetrics implements MeasurementSink
1: {
1:     private final List<Consumer> consumers = new ArrayList<>();
0:     private final PrintStream output;
1:     private final Thread thread;
1:     private final Uncertainty rowRateUncertainty = new Uncertainty();
1:     private final CountDownLatch stopped = new CountDownLatch(1);
1:     private final Callable<JmxCollector.GcStats> gcStatsCollector;
1:     private final HistogramLogWriter histogramWriter;
1:     private final long epochNs = System.nanoTime();
1:     private final long epochMs = System.currentTimeMillis();
1: 
1:     private volatile JmxCollector.GcStats totalGcStats = new GcStats(0);
1: 
1:     private volatile boolean stop = false;
1:     private volatile boolean cancelled = false;
1: 
1: 
1:     // collected data for intervals and summary
1:     private final Map<String, TimingInterval> opTypeToCurrentTimingInterval = new TreeMap<>();
1:     private final Map<String, TimingInterval> opTypeToSummaryTimingInterval = new TreeMap<>();
1:     private final Queue<OpMeasurement> leftovers = new ArrayDeque<>();
1:     private final TimingInterval totalCurrentInterval;
1:     private final TimingInterval totalSummaryInterval;
1: 
0:     public StressMetrics(PrintStream output, final long logIntervalMillis, StressSettings settings)
1:     {
1:         this.output = output;
1:         if(settings.log.hdrFile != null)
1:         {
1:             try
1:             {
1:                 histogramWriter = new HistogramLogWriter(settings.log.hdrFile);
1:                 histogramWriter.outputComment("Logging op latencies for Cassandra Stress");
1:                 histogramWriter.outputLogFormatVersion();
1:                 final long roundedEpoch = epochMs - (epochMs%1000);
1:                 histogramWriter.outputBaseTime(roundedEpoch);
1:                 histogramWriter.setBaseTime(roundedEpoch);
1:                 histogramWriter.outputStartTime(roundedEpoch);
1:                 histogramWriter.outputLegend();
1:             }
1:             catch (FileNotFoundException e)
1:             {
1:                 throw new IllegalArgumentException(e);
1:             }
1:         }
1:         else
1:         {
1:             histogramWriter = null;
1:         }
1:         Callable<JmxCollector.GcStats> gcStatsCollector;
1:         totalGcStats = new JmxCollector.GcStats(0);
1:         try
1:         {
1:             gcStatsCollector = new JmxCollector(settings.node.resolveAllPermitted(settings), settings.port.jmxPort);
1:         }
1:         catch (Throwable t)
1:         {
1:             if (settings.log.level == Level.VERBOSE)
1:             {
1:                 t.printStackTrace();
1:             }
1:             System.err.println("Failed to connect over JMX; not collecting these stats");
0:             gcStatsCollector = new Callable<JmxCollector.GcStats>()
1:             {
0:                 public JmxCollector.GcStats call() throws Exception
1:                 {
0:                     return totalGcStats;
1:                 }
0:             };
1:         }
1:         this.gcStatsCollector = gcStatsCollector;
1:         this.totalCurrentInterval = new TimingInterval(settings.rate.isFixed);
1:         this.totalSummaryInterval = new TimingInterval(settings.rate.isFixed);
1:         printHeader("", output);
1:         thread = new Thread(() -> {
1:             reportingLoop(logIntervalMillis);
1:         });
1:         thread.setName("StressMetrics");
1:     }
1:     public void start()
1:     {
1:         thread.start();
1:     }
1: 
1:     public void waitUntilConverges(double targetUncertainty, int minMeasurements, int maxMeasurements) throws InterruptedException
1:     {
1:         rowRateUncertainty.await(targetUncertainty, minMeasurements, maxMeasurements);
1:     }
1: 
1:     public void cancel()
1:     {
1:         cancelled = true;
1:         stop = true;
1:         thread.interrupt();
1:         rowRateUncertainty.wakeAll();
1:     }
1: 
1:     public void stop() throws InterruptedException
1:     {
1:         stop = true;
1:         thread.interrupt();
1:         stopped.await();
1:     }
1: 
1: 
1:     private void reportingLoop(final long logIntervalMillis)
1:     {
1:         // align report timing to the nearest second
1:         final long currentTimeMs = System.currentTimeMillis();
1:         final long startTimeMs = currentTimeMs - (currentTimeMs % 1000);
1:         // reporting interval starts rounded to the second
1:         long reportingStartNs = (System.nanoTime() - TimeUnit.MILLISECONDS.toNanos(currentTimeMs - startTimeMs));
1:         final long parkIntervalNs = TimeUnit.MILLISECONDS.toNanos(logIntervalMillis);
1:         try
1:         {
1:             while (!stop)
1:             {
1:                 final long wakupTarget = reportingStartNs + parkIntervalNs;
1:                 sleepUntil(wakupTarget);
1:                 if (stop)
1:                 {
1:                     break;
1:                 }
1:                 recordInterval(wakupTarget, parkIntervalNs);
1:                 reportingStartNs += parkIntervalNs;
1:             }
1: 
1:             final long end = System.nanoTime();
1:             recordInterval(end, end - reportingStartNs);
1:         }
1:         catch (Exception e)
1:         {
1:             e.printStackTrace();
1:             cancel();
1:         }
1:         finally
1:         {
1:             rowRateUncertainty.wakeAll();
1:             stopped.countDown();
1:         }
1:     }
1: 
1: 
1:     private void sleepUntil(final long until)
1:     {
1:         long parkFor;
1:         while (!stop &&
1:                (parkFor = until - System.nanoTime()) > 0)
1:         {
1:             LockSupport.parkNanos(parkFor);
1:         }
1:     }
1: 
1:     @Override
1:     public void record(String opType, long intended, long started, long ended, long rowCnt, long partitionCnt, boolean err)
1:     {
1:         TimingInterval current = opTypeToCurrentTimingInterval.computeIfAbsent(opType, k -> new TimingInterval(totalCurrentInterval.isFixed));
1:         record(current, intended, started, ended, rowCnt, partitionCnt, err);
1:     }
1: 
1:     private void record(TimingInterval t, long intended, long started, long ended, long rowCnt, long partitionCnt, boolean err)
1:     {
1:         t.rowCount += rowCnt;
1:         t.partitionCount += partitionCnt;
1:         if (err)
1:             t.errorCount++;
1:         if (intended != 0) {
1:             t.responseTime().recordValue(ended-intended);
1:             t.waitTime().recordValue(started-intended);
1:         }
1:         final long sTime = ended-started;
1:         t.serviceTime().recordValue(sTime);
1:     }
1: 
0:     private void recordInterval(long intervalEnd, long parkIntervalNs) throws InterruptedException
1:     {
1: 
1:         drainConsumerMeasurements(intervalEnd, parkIntervalNs);
1: 
1:         GcStats gcStats = null;
1:         try
1:         {
1:             gcStats = gcStatsCollector.call();
1:         }
1:         catch (Exception e)
1:         {
1:             gcStats = new GcStats(0);
1:         }
1:         totalGcStats = JmxCollector.GcStats.aggregate(Arrays.asList(totalGcStats, gcStats));
1: 
1:         rowRateUncertainty.update(totalCurrentInterval.adjustedRowRate());
1:         if (totalCurrentInterval.operationCount() != 0)
1:         {
1:             // if there's a single operation we only print the total
1:             final boolean logPerOpSummaryLine = opTypeToCurrentTimingInterval.size() > 1;
1: 
1:             for (Map.Entry<String, TimingInterval> type : opTypeToCurrentTimingInterval.entrySet())
1:             {
1:                 final String opName = type.getKey();
1:                 final TimingInterval opInterval = type.getValue();
1:                 if (logPerOpSummaryLine)
1:                 {
1:                     printRow("", opName, opInterval, opTypeToSummaryTimingInterval.get(opName), gcStats, rowRateUncertainty, output);
1:                 }
1:                 logHistograms(opName, opInterval);
1:                 opInterval.reset();
1:             }
1: 
1:             printRow("", "total", totalCurrentInterval, totalSummaryInterval, gcStats, rowRateUncertainty, output);
1:             totalCurrentInterval.reset();
1:         }
1:     }
1: 
1:     private void drainConsumerMeasurements(long intervalEnd, long parkIntervalNs)
1:     {
1:         // record leftover measurements if any
1:         int leftoversSize = leftovers.size();
1:         for (int i=0;i<leftoversSize;i++)
1:         {
1:             OpMeasurement last = leftovers.poll();
1:             if (last.ended <= intervalEnd)
1:             {
1:                 record(last.opType, last.intended, last.started, last.ended, last.rowCnt, last.partitionCnt, last.err);
1:                 // round robin-ish redistribution of leftovers
1:                 consumers.get(i%consumers.size()).measurementsRecycling.offer(last);
1:             }
1:             else
1:             {
1:                 // no record for you! wait one interval!
1:                 leftovers.offer(last);
1:             }
1:         }
1:         // record interval collected measurements
1:         for (Consumer c: consumers) {
1:             Queue<OpMeasurement> in = c.measurementsReporting;
1:             Queue<OpMeasurement> out = c.measurementsRecycling;
1:             OpMeasurement last;
1:             while ((last = in.poll()) != null)
1:             {
1:                 if (last.ended > intervalEnd)
1:                 {
1:                     // measurements for any given consumer are ordered, we stop when we stop.
1:                     leftovers.add(last);
1:                     break;
1:                 }
1:                 record(last.opType, last.intended, last.started, last.ended, last.rowCnt, last.partitionCnt, last.err);
1:                 out.offer(last);
1:             }
1:         }
1:         // set timestamps and summarize
1:         for (Entry<String, TimingInterval> currPerOp : opTypeToCurrentTimingInterval.entrySet()) {
1:             currPerOp.getValue().endNanos(intervalEnd);
1:             currPerOp.getValue().startNanos(intervalEnd-parkIntervalNs);
1:             TimingInterval summaryPerOp = opTypeToSummaryTimingInterval.computeIfAbsent(currPerOp.getKey(), k -> new TimingInterval(totalCurrentInterval.isFixed));
1:             summaryPerOp.add(currPerOp.getValue());
1:             totalCurrentInterval.add(currPerOp.getValue());
1:         }
1:         totalCurrentInterval.endNanos(intervalEnd);
1:         totalCurrentInterval.startNanos(intervalEnd-parkIntervalNs);
1: 
1:         totalSummaryInterval.add(totalCurrentInterval);
1:     }
1: 
1: 
1:     private void logHistograms(String opName, TimingInterval opInterval)
1:     {
1:         if (histogramWriter == null)
1:             return;
1:         final long startNs = opInterval.startNanos();
1:         final long endNs = opInterval.endNanos();
1: 
1:         logHistogram(opName + "-st", startNs, endNs, opInterval.serviceTime());
1:         logHistogram(opName + "-rt", startNs, endNs, opInterval.responseTime());
1:         logHistogram(opName + "-wt", startNs, endNs, opInterval.waitTime());
1:     }
1: 
1:     private void logHistogram(String opName, final long startNs, final long endNs, final Histogram histogram)
1:     {
1:         if (histogram.getTotalCount() != 0)
1:         {
1:             histogram.setTag(opName);
1:             final long relativeStartNs = startNs - epochNs;
1:             final long startMs = (long) (1000 *((epochMs + NANOSECONDS.toMillis(relativeStartNs))/1000.0));
1:             histogram.setStartTimeStamp(startMs);
1:             final long relativeEndNs = endNs - epochNs;
1:             final long endMs = (long) (1000 *((epochMs + NANOSECONDS.toMillis(relativeEndNs))/1000.0));
1:             histogram.setEndTimeStamp(endMs);
1:             histogramWriter.outputIntervalHistogram(histogram);
1:         }
1:     }
1: 
1: 
1:     // PRINT FORMATTING
1: 
1:     public static final String HEADFORMAT = "%-10s%10s,%8s,%8s,%8s,%8s,%8s,%8s,%8s,%8s,%8s,%7s,%9s,%7s,%7s,%8s,%8s,%8s,%8s";
1:     public static final String ROWFORMAT =  "%-10s%10d,%8.0f,%8.0f,%8.0f,%8.1f,%8.1f,%8.1f,%8.1f,%8.1f,%8.1f,%7.1f,%9.5f,%7d,%7.0f,%8.0f,%8.0f,%8.0f,%8.0f";
1:     public static final String[] HEADMETRICS = new String[]{"type", "total ops","op/s","pk/s","row/s","mean","med",".95",".99",".999","max","time","stderr", "errors", "gc: #", "max ms", "sum ms", "sdv ms", "mb"};
1:     public static final String HEAD = String.format(HEADFORMAT, (Object[]) HEADMETRICS);
1: 
0:     private static void printHeader(String prefix, PrintStream output)
1:     {
1:         output.println(prefix + HEAD);
1:     }
1: 
0:     private static void printRow(String prefix, String type, TimingInterval interval, TimingInterval total, JmxCollector.GcStats gcStats, Uncertainty opRateUncertainty, PrintStream output)
1:     {
1:         output.println(prefix + String.format(ROWFORMAT,
1:                 type + ",",
1:                 total.operationCount(),
1:                 interval.opRate(),
1:                 interval.partitionRate(),
1:                 interval.rowRate(),
1:                 interval.meanLatencyMs(),
1:                 interval.medianLatencyMs(),
1:                 interval.latencyAtPercentileMs(95.0),
1:                 interval.latencyAtPercentileMs(99.0),
1:                 interval.latencyAtPercentileMs(99.9),
1:                 interval.maxLatencyMs(),
1:                 total.runTimeMs() / 1000f,
1:                 opRateUncertainty.getUncertainty(),
1:                 interval.errorCount,
1:                 gcStats.count,
1:                 gcStats.maxms,
1:                 gcStats.summs,
1:                 gcStats.sdvms,
1:                 gcStats.bytes / (1 << 20)
1:         ));
1:     }
1: 
1:     public void summarise()
1:     {
1:         output.println("\n");
1:         output.println("Results:");
1: 
1:         TimingIntervals opHistory = new TimingIntervals(opTypeToSummaryTimingInterval);
1:         TimingInterval history = this.totalSummaryInterval;
1:         output.println(String.format("Op rate                   : %,8.0f op/s  %s", history.opRate(), opHistory.opRates()));
1:         output.println(String.format("Partition rate            : %,8.0f pk/s  %s", history.partitionRate(), opHistory.partitionRates()));
1:         output.println(String.format("Row rate                  : %,8.0f row/s %s", history.rowRate(), opHistory.rowRates()));
1:         output.println(String.format("Latency mean              : %6.1f ms %s", history.meanLatencyMs(), opHistory.meanLatencies()));
1:         output.println(String.format("Latency median            : %6.1f ms %s", history.medianLatencyMs(), opHistory.medianLatencies()));
1:         output.println(String.format("Latency 95th percentile   : %6.1f ms %s", history.latencyAtPercentileMs(95.0), opHistory.latenciesAtPercentile(95.0)));
1:         output.println(String.format("Latency 99th percentile   : %6.1f ms %s", history.latencyAtPercentileMs(99.0), opHistory.latenciesAtPercentile(99.0)));
1:         output.println(String.format("Latency 99.9th percentile : %6.1f ms %s", history.latencyAtPercentileMs(99.9), opHistory.latenciesAtPercentile(99.9)));
1:         output.println(String.format("Latency max               : %6.1f ms %s", history.maxLatencyMs(), opHistory.maxLatencies()));
1:         output.println(String.format("Total partitions          : %,10d %s",   history.partitionCount, opHistory.partitionCounts()));
1:         output.println(String.format("Total errors              : %,10d %s",   history.errorCount, opHistory.errorCounts()));
1:         output.println(String.format("Total GC count            : %,1.0f", totalGcStats.count));
1:         output.println(String.format("Total GC memory           : %s", FBUtilities.prettyPrintMemory((long)totalGcStats.bytes, true)));
1:         output.println(String.format("Total GC time             : %,6.1f seconds", totalGcStats.summs / 1000));
1:         output.println(String.format("Avg GC time               : %,6.1f ms", totalGcStats.summs / totalGcStats.count));
1:         output.println(String.format("StdDev GC time            : %,6.1f ms", totalGcStats.sdvms));
1:         output.println("Total operation time      : " + DurationFormatUtils.formatDuration(
1:                 history.runTimeMs(), "HH:mm:ss", true));
1:         output.println(""); // Newline is important here to separate the aggregates section from the END or the next stress iteration
1:     }
1: 
0:     public static void summarise(List<String> ids, List<StressMetrics> summarise, PrintStream out)
1:     {
1:         int idLen = 0;
1:         for (String id : ids)
1:             idLen = Math.max(id.length(), idLen);
1:         String formatstr = "%" + idLen + "s, ";
1:         printHeader(String.format(formatstr, "id"), out);
1:         for (int i = 0 ; i < ids.size() ; i++)
1:         {
1:             for (Map.Entry<String, TimingInterval> type : summarise.get(i).opTypeToSummaryTimingInterval.entrySet())
1:             {
1:                 printRow(String.format(formatstr, ids.get(i)),
1:                          type.getKey(),
1:                          type.getValue(),
1:                          type.getValue(),
1:                          summarise.get(i).totalGcStats,
1:                          summarise.get(i).rowRateUncertainty,
1:                          out);
1:             }
1:             TimingInterval hist = summarise.get(i).totalSummaryInterval;
1:             printRow(String.format(formatstr, ids.get(i)),
1:                     "total",
1:                     hist,
1:                     hist,
1:                     summarise.get(i).totalGcStats,
1:                     summarise.get(i).rowRateUncertainty,
1:                     out
1:             );
1:         }
1:     }
1: 
1:     public boolean wasCancelled()
1:     {
1:         return cancelled;
1:     }
1: 
1:     public void add(Consumer consumer)
1:     {
1:         consumers.add(consumer);
1:     }
1: 
1:     public double opRate()
1:     {
1:         return totalSummaryInterval.opRate();
1:     }
1: }
============================================================================