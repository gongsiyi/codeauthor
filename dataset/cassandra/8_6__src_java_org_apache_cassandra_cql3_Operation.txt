1:31e669a: /*
1:31e669a:  * Licensed to the Apache Software Foundation (ASF) under one
1:31e669a:  * or more contributor license agreements.  See the NOTICE file
1:31e669a:  * distributed with this work for additional information
1:31e669a:  * regarding copyright ownership.  The ASF licenses this file
1:31e669a:  * to you under the Apache License, Version 2.0 (the
1:31e669a:  * "License"); you may not use this file except in compliance
1:31e669a:  * with the License.  You may obtain a copy of the License at
1:31e669a:  *
1:31e669a:  *     http://www.apache.org/licenses/LICENSE-2.0
1:31e669a:  *
1:31e669a:  * Unless required by applicable law or agreed to in writing, software
1:31e669a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:31e669a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:31e669a:  * See the License for the specific language governing permissions and
1:31e669a:  * limitations under the License.
1:31e669a:  */
1:31e669a: package org.apache.cassandra.cql3;
1:31e669a: 
1:91bdf7f: import java.util.List;
1:31e669a: 
1:b09d876: import org.apache.cassandra.config.CFMetaData;
1:b09d876: import org.apache.cassandra.config.ColumnDefinition;
1:cb5897f: import org.apache.cassandra.cql3.functions.Function;
1:a991b64: import org.apache.cassandra.db.DecoratedKey;
1:1be0bbf: import org.apache.cassandra.db.marshal.*;
1:31e669a: import org.apache.cassandra.exceptions.InvalidRequestException;
1:31e669a: 
1:31e669a: /**
1:31e669a:  * An UPDATE or DELETE operation.
1:31e669a:  *
1:31e669a:  * For UPDATE this includes:
1:31e669a:  *   - setting a constant
1:31e669a:  *   - counter operations
1:31e669a:  *   - collections operations
1:31e669a:  * and for DELETE:
1:31e669a:  *   - deleting a column
1:31e669a:  *   - deleting an element of collection column
1:31e669a:  *
1:31e669a:  * Fine grained operation are obtained from their raw counterpart (Operation.Raw, which
1:31e669a:  * correspond to a parsed, non-checked operation) by provided the receiver for the operation.
1:31e669a:  */
1:31e669a: public abstract class Operation
1:b09d876: {
1:362cc05:     // the column the operation applies to
1:362cc05:     public final ColumnDefinition column;
1:31e669a: 
1:31e669a:     // Term involved in the operation. In theory this should not be here since some operation
1:31e669a:     // may require none of more than one term, but most need 1 so it simplify things a bit.
1:31e669a:     protected final Term t;
1:31e669a: 
1:362cc05:     protected Operation(ColumnDefinition column, Term t)
1:31e669a:     {
1:362cc05:         assert column != null;
1:362cc05:         this.column = column;
1:31e669a:         this.t = t;
1:b09d876:     }
1:b09d876: 
1:89464ea:     public void addFunctionsTo(List<Function> functions)
1:b09d876:     {
1:89464ea:         if (t != null)
1:89464ea:             t.addFunctionsTo(functions);
1:b09d876:     }
1:b09d876: 
1:31e669a:     /**
1:31e669a:      * @return whether the operation requires a read of the previous value to be executed
1:31e669a:      * (only lists setterByIdx, discard and discardByIdx requires that).
1:31e669a:      */
1:31e669a:     public boolean requiresRead()
1:31e669a:     {
1:b09d876:         return false;
1:31e669a:     }
1:b09d876: 
1:31e669a:     /**
1:31e669a:      * Collects the column specification for the bind variables of this operation.
1:31e669a:      *
1:31e669a:      * @param boundNames the list of column specification where to collect the
1:31e669a:      * bind variables of this term in.
1:31e669a:      */
1:37e9bce:     public void collectMarkerSpecification(VariableSpecifications boundNames)
1:31e669a:     {
1:31e669a:         if (t != null)
1:31e669a:             t.collectMarkerSpecification(boundNames);
1:31e669a:     }
1:31e669a: 
1:31e669a:     /**
1:31e669a:      * Execute the operation.
1:31e669a:      *
1:a991b64:      * @param partitionKey partition key for the update.
1:31e669a:      * @param params parameters of the update.
1:31e669a:      */
1:2457599:     public abstract void execute(DecoratedKey partitionKey, UpdateParameters params) throws InvalidRequestException;
1:31e669a: 
1:31e669a:     /**
1:31e669a:      * A parsed raw UPDATE operation.
1:31e669a:      *
1:31e669a:      * This can be one of:
1:31e669a:      *   - Setting a value: c = v
1:31e669a:      *   - Setting an element of a collection: c[x] = v
1:44a9d8c:      *   - An addition/subtraction to a variable: c = c +/- v (where v can be a collection literal)
1:31e669a:      *   - An prepend operation: c = v + c
1:31e669a:      */
1:31e669a:     public interface RawUpdate
1:31e669a:     {
1:31e669a:         /**
1:31e669a:          * This method validates the operation (i.e. validate it is well typed)
1:31e669a:          * based on the specification of the receiver of the operation.
1:31e669a:          *
1:31e669a:          * It returns an Operation which can be though as post-preparation well-typed
1:31e669a:          * Operation.
1:31e669a:          *
1:677230d:          * @param receiver the column this operation applies to.
1:31e669a:          * @return the prepared update operation.
1:31e669a:          */
1:677230d:         public Operation prepare(CFMetaData cfm, ColumnDefinition receiver) throws InvalidRequestException;
1:31e669a: 
1:31e669a:         /**
1:31e669a:          * @return whether this operation can be applied alongside the {@code
1:31e669a:          * other} update (in the same UPDATE statement for the same column).
1:31e669a:          */
1:31e669a:         public boolean isCompatibleWith(RawUpdate other);
1:31e669a:     }
1:31e669a: 
1:31e669a:     /**
1:31e669a:      * A parsed raw DELETE operation.
1:31e669a:      *
1:31e669a:      * This can be one of:
1:31e669a:      *   - Deleting a column
1:31e669a:      *   - Deleting an element of a collection
1:31e669a:      */
1:31e669a:     public interface RawDeletion
1:31e669a:     {
1:31e669a:         /**
1:31e669a:          * The name of the column affected by this delete operation.
1:31e669a:          */
1:4ed0060:         public ColumnDefinition.Raw affectedColumn();
1:31e669a: 
1:31e669a:         /**
1:31e669a:          * This method validates the operation (i.e. validate it is well typed)
1:31e669a:          * based on the specification of the column affected by the operation (i.e the
1:31e669a:          * one returned by affectedColumn()).
1:31e669a:          *
1:31e669a:          * It returns an Operation which can be though as post-preparation well-typed
1:31e669a:          * Operation.
1:31e669a:          *
1:31e669a:          * @param receiver the "column" this operation applies to.
1:31e669a:          * @return the prepared delete operation.
1:31e669a:          */
1:677230d:         public Operation prepare(String keyspace, ColumnDefinition receiver, CFMetaData cfm) throws InvalidRequestException;
1:31e669a:     }
1:31e669a: 
1:31e669a:     public static class SetValue implements RawUpdate
1:31e669a:     {
1:31e669a:         private final Term.Raw value;
1:31e669a: 
1:31e669a:         public SetValue(Term.Raw value)
1:31e669a:         {
1:31e669a:             this.value = value;
1:31e669a:         }
1:31e669a: 
1:677230d:         public Operation prepare(CFMetaData cfm, ColumnDefinition receiver) throws InvalidRequestException
1:31e669a:         {
1:677230d:             Term v = value.prepare(cfm.ksName, receiver);
1:31e669a: 
1:7c920b0:             if (receiver.type instanceof CounterColumnType)
1:86e3012:                 throw new InvalidRequestException(String.format("Cannot set the value of counter column %s (counters can only be incremented/decremented, not set)", receiver.name));
1:7c920b0: 
1:677230d:             if (receiver.type.isCollection())
1:31e669a:             {
1:677230d:                 switch (((CollectionType) receiver.type).kind)
1:31e669a:                 {
1:31e669a:                     case LIST:
1:362cc05:                         return new Lists.Setter(receiver, v);
1:31e669a:                     case SET:
1:362cc05:                         return new Sets.Setter(receiver, v);
1:31e669a:                     case MAP:
1:362cc05:                         return new Maps.Setter(receiver, v);
1:677230d:                     default:
1:31e669a:                         throw new AssertionError();
1:31e669a:                 }
1:31e669a:             }
1:31e669a: 
1:677230d:             if (receiver.type.isUDT())
1:677230d:                 return new UserTypes.Setter(receiver, v);
1:31e669a: 
1:362cc05:             return new Constants.Setter(receiver, v);
1:31e669a:         }
1:31e669a: 
1:31e669a:         protected String toString(ColumnSpecification column)
1:31e669a:         {
1:31e669a:             return String.format("%s = %s", column, value);
1:31e669a:         }
1:31e669a: 
1:31e669a:         public boolean isCompatibleWith(RawUpdate other)
1:31e669a:         {
1:31e669a:             // We don't allow setting multiple time the same column, because 1)
1:31e669a:             // it's stupid and 2) the result would seem random to the user.
2:31e669a:             return false;
1:31e669a:         }
1:31e669a:     }
1:31e669a: 
1:31e669a:     public static class SetElement implements RawUpdate
1:31e669a:     {
1:31e669a:         private final Term.Raw selector;
1:31e669a:         private final Term.Raw value;
1:31e669a: 
1:31e669a:         public SetElement(Term.Raw selector, Term.Raw value)
2:91bdf7f:         {
1:31e669a:             this.selector = selector;
1:31e669a:             this.value = value;
1:31e669a:         }
1:31e669a: 
1:677230d:         public Operation prepare(CFMetaData cfm, ColumnDefinition receiver) throws InvalidRequestException
1:31e669a:         {
3:31e669a:             if (!(receiver.type instanceof CollectionType))
1:86e3012:                 throw new InvalidRequestException(String.format("Invalid operation (%s) for non collection column %s", toString(receiver), receiver.name));
1:ee55f36:             else if (!(receiver.type.isMultiCell()))
1:ee55f36:                 throw new InvalidRequestException(String.format("Invalid operation (%s) for frozen collection column %s", toString(receiver), receiver.name));
1:31e669a: 
2:31e669a:             switch (((CollectionType)receiver.type).kind)
1:31e669a:             {
1:31e669a:                 case LIST:
1:677230d:                     Term idx = selector.prepare(cfm.ksName, Lists.indexSpecOf(receiver));
1:677230d:                     Term lval = value.prepare(cfm.ksName, Lists.valueSpecOf(receiver));
1:362cc05:                     return new Lists.SetterByIndex(receiver, idx, lval);
1:31e669a:                 case SET:
1:86e3012:                     throw new InvalidRequestException(String.format("Invalid operation (%s) for set column %s", toString(receiver), receiver.name));
1:31e669a:                 case MAP:
1:677230d:                     Term key = selector.prepare(cfm.ksName, Maps.keySpecOf(receiver));
1:677230d:                     Term mval = value.prepare(cfm.ksName, Maps.valueSpecOf(receiver));
1:362cc05:                     return new Maps.SetterByKey(receiver, key, mval);
1:31e669a:             }
1:31e669a:             throw new AssertionError();
1:31e669a:         }
1:31e669a: 
1:31e669a:         protected String toString(ColumnSpecification column)
1:31e669a:         {
1:86e3012:             return String.format("%s[%s] = %s", column.name, selector, value);
1:31e669a:         }
1:31e669a: 
1:31e669a:         public boolean isCompatibleWith(RawUpdate other)
1:31e669a:         {
1:31e669a:             // TODO: we could check that the other operation is not setting the same element
1:31e669a:             // too (but since the index/key set may be a bind variables we can't always do it at this point)
1:31e669a:             return !(other instanceof SetValue);
1:31e669a:         }
1:31e669a:     }
1:31e669a: 
1:677230d:     public static class SetField implements RawUpdate
1:31e669a:     {
1:4ed0060:         private final FieldIdentifier field;
1:677230d:         private final Term.Raw value;
1:31e669a: 
1:4ed0060:         public SetField(FieldIdentifier field, Term.Raw value)
1:31e669a:         {
1:677230d:             this.field = field;
2:91bdf7f:             this.value = value;
1:31e669a:         }
1:31e669a: 
1:677230d:         public Operation prepare(CFMetaData cfm, ColumnDefinition receiver) throws InvalidRequestException
1:91bdf7f:         {
1:677230d:             if (!receiver.type.isUDT())
1:677230d:                 throw new InvalidRequestException(String.format("Invalid operation (%s) for non-UDT column %s", toString(receiver), receiver.name));
1:677230d:             else if (!receiver.type.isMultiCell())
1:677230d:                 throw new InvalidRequestException(String.format("Invalid operation (%s) for frozen UDT column %s", toString(receiver), receiver.name));
3:91bdf7f: 
1:4ed0060:             int fieldPosition = ((UserType) receiver.type).fieldPosition(field);
1:677230d:             if (fieldPosition == -1)
1:4ed0060:                 throw new InvalidRequestException(String.format("UDT column %s does not have a field named %s", receiver.name, field));
1:91bdf7f: 
1:677230d:             Term val = value.prepare(cfm.ksName, UserTypes.fieldSpecOf(receiver, fieldPosition));
1:4ed0060:             return new UserTypes.SetterByField(receiver, field, val);
2:91bdf7f:         }
1:91bdf7f: 
1:677230d:         protected String toString(ColumnSpecification column)
1:91bdf7f:         {
1:677230d:             return String.format("%s.%s = %s", column.name, field, value);
1:91bdf7f:         }
1:91bdf7f: 
1:677230d:         public boolean isCompatibleWith(RawUpdate other)
1:91bdf7f:         {
1:677230d:             if (other instanceof SetField)
1:677230d:                 return !((SetField) other).field.equals(field);
1:677230d:             else
1:677230d:                 return !(other instanceof SetValue);
1:91bdf7f:         }
1:91bdf7f:     }
1:91bdf7f: 
1:31e669a:     public static class Addition implements RawUpdate
1:31e669a:     {
1:31e669a:         private final Term.Raw value;
1:31e669a: 
1:31e669a:         public Addition(Term.Raw value)
1:31e669a:         {
1:31e669a:             this.value = value;
1:31e669a:         }
1:31e669a: 
1:677230d:         public Operation prepare(CFMetaData cfm, ColumnDefinition receiver) throws InvalidRequestException
1:31e669a:         {
1:677230d:             Term v = value.prepare(cfm.ksName, receiver);
1:31e669a: 
1:31e669a:             if (!(receiver.type instanceof CollectionType))
1:31e669a:             {
1:31e669a:                 if (!(receiver.type instanceof CounterColumnType))
1:86e3012:                     throw new InvalidRequestException(String.format("Invalid operation (%s) for non counter column %s", toString(receiver), receiver.name));
1:362cc05:                 return new Constants.Adder(receiver, v);
1:31e669a:             }
1:ee55f36:             else if (!(receiver.type.isMultiCell()))
1:ee55f36:                 throw new InvalidRequestException(String.format("Invalid operation (%s) for frozen collection column %s", toString(receiver), receiver.name));
1:31e669a: 
1:31e669a:             switch (((CollectionType)receiver.type).kind)
1:31e669a:             {
1:31e669a:                 case LIST:
1:362cc05:                     return new Lists.Appender(receiver, v);
1:31e669a:                 case SET:
1:362cc05:                     return new Sets.Adder(receiver, v);
1:31e669a:                 case MAP:
1:362cc05:                     return new Maps.Putter(receiver, v);
1:31e669a:             }
1:31e669a:             throw new AssertionError();
1:31e669a:         }
1:31e669a: 
1:31e669a:         protected String toString(ColumnSpecification column)
1:31e669a:         {
1:86e3012:             return String.format("%s = %s + %s", column.name, column.name, value);
1:31e669a:         }
1:31e669a: 
1:31e669a:         public boolean isCompatibleWith(RawUpdate other)
1:31e669a:         {
1:31e669a:             return !(other instanceof SetValue);
1:31e669a:         }
1:31e669a:     }
1:31e669a: 
1:31e669a:     public static class Substraction implements RawUpdate
1:31e669a:     {
1:31e669a:         private final Term.Raw value;
1:31e669a: 
1:31e669a:         public Substraction(Term.Raw value)
1:31e669a:         {
1:31e669a:             this.value = value;
1:31e669a:         }
1:31e669a: 
1:677230d:         public Operation prepare(CFMetaData cfm, ColumnDefinition receiver) throws InvalidRequestException
1:31e669a:         {
1:31e669a:             if (!(receiver.type instanceof CollectionType))
1:31e669a:             {
1:31e669a:                 if (!(receiver.type instanceof CounterColumnType))
1:86e3012:                     throw new InvalidRequestException(String.format("Invalid operation (%s) for non counter column %s", toString(receiver), receiver.name));
1:677230d:                 return new Constants.Substracter(receiver, value.prepare(cfm.ksName, receiver));
1:31e669a:             }
1:ee55f36:             else if (!(receiver.type.isMultiCell()))
1:ee55f36:                 throw new InvalidRequestException(String.format("Invalid operation (%s) for frozen collection column %s", toString(receiver), receiver.name));
1:31e669a: 
1:31e669a:             switch (((CollectionType)receiver.type).kind)
1:31e669a:             {
1:31e669a:                 case LIST:
1:677230d:                     return new Lists.Discarder(receiver, value.prepare(cfm.ksName, receiver));
1:31e669a:                 case SET:
1:677230d:                     return new Sets.Discarder(receiver, value.prepare(cfm.ksName, receiver));
1:31e669a:                 case MAP:
1:44a9d8c:                     // The value for a map subtraction is actually a set
1:1be0bbf:                     ColumnSpecification vr = new ColumnSpecification(receiver.ksName,
1:1be0bbf:                                                                      receiver.cfName,
1:1be0bbf:                                                                      receiver.name,
1:ee55f36:                                                                      SetType.getInstance(((MapType)receiver.type).getKeysType(), false));
1:677230d:                     return new Sets.Discarder(receiver, value.prepare(cfm.ksName, vr));
1:31e669a:             }
1:31e669a:             throw new AssertionError();
1:31e669a:         }
1:31e669a: 
1:31e669a:         protected String toString(ColumnSpecification column)
1:31e669a:         {
1:86e3012:             return String.format("%s = %s - %s", column.name, column.name, value);
1:31e669a:         }
1:31e669a: 
1:31e669a:         public boolean isCompatibleWith(RawUpdate other)
1:31e669a:         {
1:31e669a:             return !(other instanceof SetValue);
1:31e669a:         }
1:31e669a:     }
1:31e669a: 
1:31e669a:     public static class Prepend implements RawUpdate
1:31e669a:     {
1:31e669a:         private final Term.Raw value;
1:31e669a: 
1:31e669a:         public Prepend(Term.Raw value)
1:31e669a:         {
1:31e669a:             this.value = value;
1:31e669a:         }
1:31e669a: 
1:677230d:         public Operation prepare(CFMetaData cfm, ColumnDefinition receiver) throws InvalidRequestException
1:31e669a:         {
1:677230d:             Term v = value.prepare(cfm.ksName, receiver);
1:31e669a: 
1:31e669a:             if (!(receiver.type instanceof ListType))
1:86e3012:                 throw new InvalidRequestException(String.format("Invalid operation (%s) for non list column %s", toString(receiver), receiver.name));
1:ee55f36:             else if (!(receiver.type.isMultiCell()))
1:ee55f36:                 throw new InvalidRequestException(String.format("Invalid operation (%s) for frozen list column %s", toString(receiver), receiver.name));
1:31e669a: 
1:362cc05:             return new Lists.Prepender(receiver, v);
1:31e669a:         }
1:31e669a: 
1:31e669a:         protected String toString(ColumnSpecification column)
1:31e669a:         {
1:86e3012:             return String.format("%s = %s - %s", column.name, value, column.name);
1:31e669a:         }
1:31e669a: 
1:31e669a:         public boolean isCompatibleWith(RawUpdate other)
1:91bdf7f:         {
1:31e669a:             return !(other instanceof SetValue);
1:31e669a:         }
1:91bdf7f:     }
1:31e669a: 
1:31e669a:     public static class ColumnDeletion implements RawDeletion
1:31e669a:     {
1:4ed0060:         private final ColumnDefinition.Raw id;
1:31e669a: 
1:4ed0060:         public ColumnDeletion(ColumnDefinition.Raw id)
1:31e669a:         {
1:31e669a:             this.id = id;
1:31e669a:         }
1:31e669a: 
1:4ed0060:         public ColumnDefinition.Raw affectedColumn()
1:31e669a:         {
1:31e669a:             return id;
1:31e669a:         }
1:31e669a: 
1:677230d:         public Operation prepare(String keyspace, ColumnDefinition receiver, CFMetaData cfm) throws InvalidRequestException
1:31e669a:         {
1:31e669a:             // No validation, deleting a column is always "well typed"
1:362cc05:             return new Constants.Deleter(receiver);
1:31e669a:         }
1:31e669a:     }
1:31e669a: 
1:31e669a:     public static class ElementDeletion implements RawDeletion
1:31e669a:     {
1:4ed0060:         private final ColumnDefinition.Raw id;
1:31e669a:         private final Term.Raw element;
1:31e669a: 
1:4ed0060:         public ElementDeletion(ColumnDefinition.Raw id, Term.Raw element)
1:31e669a:         {
1:31e669a:             this.id = id;
1:31e669a:             this.element = element;
1:31e669a:         }
1:31e669a: 
1:4ed0060:         public ColumnDefinition.Raw affectedColumn()
1:31e669a:         {
1:31e669a:             return id;
1:31e669a:         }
1:31e669a: 
1:677230d:         public Operation prepare(String keyspace, ColumnDefinition receiver, CFMetaData cfm) throws InvalidRequestException
1:31e669a:         {
1:ee55f36:             if (!(receiver.type.isCollection()))
1:86e3012:                 throw new InvalidRequestException(String.format("Invalid deletion operation for non collection column %s", receiver.name));
1:ee55f36:             else if (!(receiver.type.isMultiCell()))
1:ee55f36:                 throw new InvalidRequestException(String.format("Invalid deletion operation for frozen collection column %s", receiver.name));
1:31e669a: 
1:31e669a:             switch (((CollectionType)receiver.type).kind)
1:31e669a:             {
1:31e669a:                 case LIST:
1:d63d07b:                     Term idx = element.prepare(keyspace, Lists.indexSpecOf(receiver));
1:362cc05:                     return new Lists.DiscarderByIndex(receiver, idx);
1:31e669a:                 case SET:
1:d63d07b:                     Term elt = element.prepare(keyspace, Sets.valueSpecOf(receiver));
1:bcf0ec6:                     return new Sets.ElementDiscarder(receiver, elt);
1:31e669a:                 case MAP:
1:d63d07b:                     Term key = element.prepare(keyspace, Maps.keySpecOf(receiver));
1:362cc05:                     return new Maps.DiscarderByKey(receiver, key);
1:31e669a:             }
1:31e669a:             throw new AssertionError();
1:31e669a:         }
1:31e669a:     }
1:91bdf7f: 
1:677230d:     public static class FieldDeletion implements RawDeletion
1:91bdf7f:     {
1:4ed0060:         private final ColumnDefinition.Raw id;
1:4ed0060:         private final FieldIdentifier field;
1:91bdf7f: 
1:4ed0060:         public FieldDeletion(ColumnDefinition.Raw id, FieldIdentifier field)
1:91bdf7f:         {
1:677230d:             this.id = id;
1:677230d:             this.field = field;
1:31e669a:         }
1:91bdf7f: 
1:4ed0060:         public ColumnDefinition.Raw affectedColumn()
1:91bdf7f:         {
1:677230d:             return id;
1:91bdf7f:         }
1:91bdf7f: 
1:677230d:         public Operation prepare(String keyspace, ColumnDefinition receiver, CFMetaData cfm) throws InvalidRequestException
1:91bdf7f:         {
1:677230d:             if (!receiver.type.isUDT())
1:677230d:                 throw new InvalidRequestException(String.format("Invalid field deletion operation for non-UDT column %s", receiver.name));
1:677230d:             else if (!receiver.type.isMultiCell())
1:677230d:                 throw new InvalidRequestException(String.format("Frozen UDT column %s does not support field deletions", receiver.name));
1:91bdf7f: 
1:4ed0060:             if (((UserType) receiver.type).fieldPosition(field) == -1)
1:4ed0060:                 throw new InvalidRequestException(String.format("UDT column %s does not have a field named %s", receiver.name, field));
1:91bdf7f: 
1:4ed0060:             return new UserTypes.DeleterByField(receiver, field);
1:91bdf7f:         }
1:91bdf7f:     }
1:91bdf7f: }
============================================================================
author:Dave Brosius
-------------------------------------------------------------------------------
commit:087264f
/////////////////////////////////////////////////////////////////////////
commit:0d30c8c
/////////////////////////////////////////////////////////////////////////
0:                     throw new InvalidRequestException(String.format("Invalid operation (%s) for non counter column %s", toString(receiver), receiver));
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:4ed0060
/////////////////////////////////////////////////////////////////////////
0: import java.nio.ByteBuffer;
/////////////////////////////////////////////////////////////////////////
1:         public ColumnDefinition.Raw affectedColumn();
/////////////////////////////////////////////////////////////////////////
1:         private final FieldIdentifier field;
1:         public SetField(FieldIdentifier field, Term.Raw value)
/////////////////////////////////////////////////////////////////////////
1:             int fieldPosition = ((UserType) receiver.type).fieldPosition(field);
1:                 throw new InvalidRequestException(String.format("UDT column %s does not have a field named %s", receiver.name, field));
1:             return new UserTypes.SetterByField(receiver, field, val);
/////////////////////////////////////////////////////////////////////////
1:         private final ColumnDefinition.Raw id;
1:         public ColumnDeletion(ColumnDefinition.Raw id)
1:         public ColumnDefinition.Raw affectedColumn()
/////////////////////////////////////////////////////////////////////////
1:         private final ColumnDefinition.Raw id;
1:         public ElementDeletion(ColumnDefinition.Raw id, Term.Raw element)
1:         public ColumnDefinition.Raw affectedColumn()
/////////////////////////////////////////////////////////////////////////
1:         private final ColumnDefinition.Raw id;
1:         private final FieldIdentifier field;
1:         public FieldDeletion(ColumnDefinition.Raw id, FieldIdentifier field)
1:         public ColumnDefinition.Raw affectedColumn()
/////////////////////////////////////////////////////////////////////////
1:             if (((UserType) receiver.type).fieldPosition(field) == -1)
1:                 throw new InvalidRequestException(String.format("UDT column %s does not have a field named %s", receiver.name, field));
1:             return new UserTypes.DeleterByField(receiver, field);
commit:2457599
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public abstract void execute(DecoratedKey partitionKey, UpdateParameters params) throws InvalidRequestException;
commit:a991b64
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.Clustering;
1: import org.apache.cassandra.db.DecoratedKey;
0: import org.apache.cassandra.db.rows.Row;
/////////////////////////////////////////////////////////////////////////
1:      * @param partitionKey partition key for the update.
0:      * @param clustering the clustering for the row on which the operation applies
0:      * @param writer the row update to which to add the updates generated by this operation.
0:     public abstract void execute(DecoratedKey partitionKey, Clustering clustering, Row.Writer writer, UpdateParameters params) throws InvalidRequestException;
commit:1be0bbf
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.marshal.*;
/////////////////////////////////////////////////////////////////////////
0:                 return new Constants.Substracter(receiver, value.prepare(keyspace, receiver));
0:                     return new Lists.Discarder(receiver, value.prepare(keyspace, receiver));
0:                     return new Sets.Discarder(receiver, value.prepare(keyspace, receiver));
0:                     // The value for a map substraction is actually a set
1:                     ColumnSpecification vr = new ColumnSpecification(receiver.ksName,
1:                                                                      receiver.cfName,
1:                                                                      receiver.name,
0:                                                                      SetType.getInstance(((MapType)receiver.type).keys));
0:                     return new Sets.Discarder(receiver, value.prepare(keyspace, vr));
commit:86e3012
/////////////////////////////////////////////////////////////////////////
1:                 throw new InvalidRequestException(String.format("Cannot set the value of counter column %s (counters can only be incremented/decremented, not set)", receiver.name));
/////////////////////////////////////////////////////////////////////////
1:                 throw new InvalidRequestException(String.format("Invalid operation (%s) for non collection column %s", toString(receiver), receiver.name));
/////////////////////////////////////////////////////////////////////////
1:                     throw new InvalidRequestException(String.format("Invalid operation (%s) for set column %s", toString(receiver), receiver.name));
/////////////////////////////////////////////////////////////////////////
1:             return String.format("%s[%s] = %s", column.name, selector, value);
/////////////////////////////////////////////////////////////////////////
1:                     throw new InvalidRequestException(String.format("Invalid operation (%s) for non counter column %s", toString(receiver), receiver.name));
/////////////////////////////////////////////////////////////////////////
1:             return String.format("%s = %s + %s", column.name, column.name, value);
/////////////////////////////////////////////////////////////////////////
1:                     throw new InvalidRequestException(String.format("Invalid operation (%s) for non counter column %s", toString(receiver), receiver.name));
/////////////////////////////////////////////////////////////////////////
1:             return String.format("%s = %s - %s", column.name, column.name, value);
/////////////////////////////////////////////////////////////////////////
1:                 throw new InvalidRequestException(String.format("Invalid operation (%s) for non list column %s", toString(receiver), receiver.name));
1:             return String.format("%s = %s - %s", column.name, value, column.name);
/////////////////////////////////////////////////////////////////////////
1:                 throw new InvalidRequestException(String.format("Invalid deletion operation for non collection column %s", receiver.name));
commit:b09d876
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.CFMetaData;
1: import org.apache.cassandra.config.ColumnDefinition;
/////////////////////////////////////////////////////////////////////////
0:     // Whether the colum operated on is a static column (on trunk, Operation stores the ColumnDefinition directly,
0:     // not just the column name, so we'll be able to remove that lookup and check ColumnDefinition.isStatic field
0:     // directly. But for 2.0, it's simpler that way).
0:     public boolean isStatic(CFMetaData cfm)
1:     {
0:         if (columnName == null)
1:             return false;
1: 
0:         ColumnDefinition def = cfm.getColumnDefinition(columnName.key);
0:         return def != null && def.type == ColumnDefinition.Type.STATIC;
1:     }
1: 
0:     protected ColumnNameBuilder maybeUpdatePrefix(CFMetaData cfm, ColumnNameBuilder prefix)
1:     {
0:         return isStatic(cfm) ? cfm.getStaticColumnNameBuilder() : prefix;
1:     }
1: 
commit:d63d07b
/////////////////////////////////////////////////////////////////////////
0:         public Operation prepare(String keyspace, ColumnDefinition receiver) throws InvalidRequestException;
/////////////////////////////////////////////////////////////////////////
0:         public Operation prepare(String keyspace, ColumnDefinition receiver) throws InvalidRequestException;
/////////////////////////////////////////////////////////////////////////
0:         public Operation prepare(String keyspace, ColumnDefinition receiver) throws InvalidRequestException
0:             Term v = value.prepare(keyspace, receiver);
/////////////////////////////////////////////////////////////////////////
0:         public Operation prepare(String keyspace, ColumnDefinition receiver) throws InvalidRequestException
/////////////////////////////////////////////////////////////////////////
0:                     Term idx = selector.prepare(keyspace, Lists.indexSpecOf(receiver));
0:                     Term lval = value.prepare(keyspace, Lists.valueSpecOf(receiver));
0:                     Term key = selector.prepare(keyspace, Maps.keySpecOf(receiver));
0:                     Term mval = value.prepare(keyspace, Maps.valueSpecOf(receiver));
/////////////////////////////////////////////////////////////////////////
0:         public Operation prepare(String keyspace, ColumnDefinition receiver) throws InvalidRequestException
0:             Term v = value.prepare(keyspace, receiver);
/////////////////////////////////////////////////////////////////////////
0:         public Operation prepare(String keyspace, ColumnDefinition receiver) throws InvalidRequestException
0:             Term v = value.prepare(keyspace, receiver);
/////////////////////////////////////////////////////////////////////////
0:         public Operation prepare(String keyspace, ColumnDefinition receiver) throws InvalidRequestException
0:             Term v = value.prepare(keyspace, receiver);
/////////////////////////////////////////////////////////////////////////
0:         public Operation prepare(String keyspace, ColumnDefinition receiver) throws InvalidRequestException
/////////////////////////////////////////////////////////////////////////
0:         public Operation prepare(String keyspace, ColumnDefinition receiver) throws InvalidRequestException
/////////////////////////////////////////////////////////////////////////
1:                     Term idx = element.prepare(keyspace, Lists.indexSpecOf(receiver));
1:                     Term elt = element.prepare(keyspace, Sets.valueSpecOf(receiver));
1:                     Term key = element.prepare(keyspace, Maps.keySpecOf(receiver));
commit:362cc05
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.composites.Composite;
/////////////////////////////////////////////////////////////////////////
1:     // the column the operation applies to
1:     public final ColumnDefinition column;
1:     protected Operation(ColumnDefinition column, Term t)
1:         assert column != null;
1:         this.column = column;
/////////////////////////////////////////////////////////////////////////
0:      * @param prefix the prefix that identify the CQL3 row this operation applies to.
0:     public abstract void execute(ByteBuffer rowKey, ColumnFamily cf, Composite prefix, UpdateParameters params) throws InvalidRequestException;
/////////////////////////////////////////////////////////////////////////
0:         public Operation prepare(ColumnDefinition receiver) throws InvalidRequestException;
/////////////////////////////////////////////////////////////////////////
1:                 return new Constants.Setter(receiver, v);
1:                     return new Lists.Setter(receiver, v);
1:                     return new Sets.Setter(receiver, v);
1:                     return new Maps.Setter(receiver, v);
/////////////////////////////////////////////////////////////////////////
1:                     return new Lists.SetterByIndex(receiver, idx, lval);
1:                     return new Maps.SetterByKey(receiver, key, mval);
/////////////////////////////////////////////////////////////////////////
1:                 return new Constants.Adder(receiver, v);
1:                     return new Lists.Appender(receiver, v);
1:                     return new Sets.Adder(receiver, v);
1:                     return new Maps.Putter(receiver, v);
/////////////////////////////////////////////////////////////////////////
0:                 return new Constants.Substracter(receiver, v);
0:                     return new Lists.Discarder(receiver, v);
0:                     return new Sets.Discarder(receiver, v);
/////////////////////////////////////////////////////////////////////////
1:             return new Lists.Prepender(receiver, v);
/////////////////////////////////////////////////////////////////////////
0:         public Operation prepare(ColumnDefinition receiver) throws InvalidRequestException
1:             return new Constants.Deleter(receiver);
/////////////////////////////////////////////////////////////////////////
0:         public Operation prepare(ColumnDefinition receiver) throws InvalidRequestException
/////////////////////////////////////////////////////////////////////////
1:                     return new Lists.DiscarderByIndex(receiver, idx);
0:                     return new Sets.Discarder(receiver, elt);
1:                     return new Maps.DiscarderByKey(receiver, key);
commit:c41eedf
commit:6fe83cd
commit:4c08800
/////////////////////////////////////////////////////////////////////////
0:                     return new Sets.Discarder(id, elt);
commit:5f5905d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.ColumnDefinition;
/////////////////////////////////////////////////////////////////////////
0:         public Operation prepare(ColumnDefinition receiver) throws InvalidRequestException;
/////////////////////////////////////////////////////////////////////////
0:         public Operation prepare(ColumnDefinition receiver) throws InvalidRequestException
/////////////////////////////////////////////////////////////////////////
0:                 return new Constants.Setter(receiver.kind == ColumnDefinition.Kind.COMPACT_VALUE ? null : receiver.name, v);
/////////////////////////////////////////////////////////////////////////
0:         public Operation prepare(ColumnDefinition receiver) throws InvalidRequestException
/////////////////////////////////////////////////////////////////////////
0:         public Operation prepare(ColumnDefinition receiver) throws InvalidRequestException
/////////////////////////////////////////////////////////////////////////
0:                 return new Constants.Adder(receiver.kind == ColumnDefinition.Kind.COMPACT_VALUE ? null : receiver.name, v);
/////////////////////////////////////////////////////////////////////////
0:         public Operation prepare(ColumnDefinition receiver) throws InvalidRequestException
/////////////////////////////////////////////////////////////////////////
0:                 return new Constants.Substracter(receiver.kind == ColumnDefinition.Kind.COMPACT_VALUE ? null : receiver.name, v);
/////////////////////////////////////////////////////////////////////////
0:         public Operation prepare(ColumnDefinition receiver) throws InvalidRequestException
commit:37e9bce
/////////////////////////////////////////////////////////////////////////
1:     public void collectMarkerSpecification(VariableSpecifications boundNames)
commit:7c920b0
/////////////////////////////////////////////////////////////////////////
1:             if (receiver.type instanceof CounterColumnType)
0:                 throw new InvalidRequestException(String.format("Cannot set the value of counter column %s (counters can only be incremented/decremented, not set)", receiver));
1: 
commit:31e669a
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.cql3;
1: 
0: import java.nio.ByteBuffer;
1: 
0: import org.apache.cassandra.db.ColumnFamily;
0: import org.apache.cassandra.db.marshal.CollectionType;
0: import org.apache.cassandra.db.marshal.CounterColumnType;
0: import org.apache.cassandra.db.marshal.ListType;
1: import org.apache.cassandra.exceptions.InvalidRequestException;
1: 
1: /**
1:  * An UPDATE or DELETE operation.
1:  *
1:  * For UPDATE this includes:
1:  *   - setting a constant
1:  *   - counter operations
1:  *   - collections operations
1:  * and for DELETE:
1:  *   - deleting a column
1:  *   - deleting an element of collection column
1:  *
1:  * Fine grained operation are obtained from their raw counterpart (Operation.Raw, which
1:  * correspond to a parsed, non-checked operation) by provided the receiver for the operation.
1:  */
1: public abstract class Operation
1: {
0:     // Name of the column the operation applies to
0:     public final ColumnIdentifier columnName;
1: 
1:     // Term involved in the operation. In theory this should not be here since some operation
1:     // may require none of more than one term, but most need 1 so it simplify things a bit.
1:     protected final Term t;
1: 
0:     protected Operation(ColumnIdentifier columnName, Term t)
1:     {
0:         this.columnName = columnName;
1:         this.t = t;
1:     }
1: 
1:     /**
1:      * @return whether the operation requires a read of the previous value to be executed
1:      * (only lists setterByIdx, discard and discardByIdx requires that).
1:      */
1:     public boolean requiresRead()
1:     {
1:         return false;
1:     }
1: 
1:     /**
1:      * Collects the column specification for the bind variables of this operation.
1:      *
1:      * @param boundNames the list of column specification where to collect the
1:      * bind variables of this term in.
1:      */
0:     public void collectMarkerSpecification(ColumnSpecification[] boundNames)
1:     {
1:         if (t != null)
1:             t.collectMarkerSpecification(boundNames);
1:     }
1: 
1:     /**
1:      * Execute the operation.
1:      *
0:      * @param rowKey row key for the update.
0:      * @param cf the column family to which to add the updates generated by this operation.
0:      * @param namePrefix the prefix that identify the CQL3 row this operation applies to (callers should not reuse
0:      * the ColumnNameBuilder they pass here).
1:      * @param params parameters of the update.
1:      */
0:     public abstract void execute(ByteBuffer rowKey, ColumnFamily cf, ColumnNameBuilder namePrefix, UpdateParameters params) throws InvalidRequestException;
1: 
1:     /**
1:      * A parsed raw UPDATE operation.
1:      *
1:      * This can be one of:
1:      *   - Setting a value: c = v
1:      *   - Setting an element of a collection: c[x] = v
0:      *   - An addition/substraction to a variable: c = c +/- v (where v can be a collection literal)
1:      *   - An prepend operation: c = v + c
1:      */
1:     public interface RawUpdate
1:     {
1:         /**
1:          * This method validates the operation (i.e. validate it is well typed)
1:          * based on the specification of the receiver of the operation.
1:          *
1:          * It returns an Operation which can be though as post-preparation well-typed
1:          * Operation.
1:          *
0:          * @param receiver the "column" this operation applies to. Note that
0:          * contrarly to the method of same name in Term.Raw, the receiver should always
0:          * be a true column.
1:          * @return the prepared update operation.
1:          */
0:         public Operation prepare(CFDefinition.Name receiver) throws InvalidRequestException;
1: 
1:         /**
1:          * @return whether this operation can be applied alongside the {@code
1:          * other} update (in the same UPDATE statement for the same column).
1:          */
1:         public boolean isCompatibleWith(RawUpdate other);
1:     }
1: 
1:     /**
1:      * A parsed raw DELETE operation.
1:      *
1:      * This can be one of:
1:      *   - Deleting a column
1:      *   - Deleting an element of a collection
1:      */
1:     public interface RawDeletion
1:     {
1:         /**
1:          * The name of the column affected by this delete operation.
1:          */
0:         public ColumnIdentifier affectedColumn();
1: 
1:         /**
1:          * This method validates the operation (i.e. validate it is well typed)
1:          * based on the specification of the column affected by the operation (i.e the
1:          * one returned by affectedColumn()).
1:          *
1:          * It returns an Operation which can be though as post-preparation well-typed
1:          * Operation.
1:          *
1:          * @param receiver the "column" this operation applies to.
1:          * @return the prepared delete operation.
1:          */
0:         public Operation prepare(ColumnSpecification receiver) throws InvalidRequestException;
1:     }
1: 
1:     public static class SetValue implements RawUpdate
1:     {
1:         private final Term.Raw value;
1: 
1:         public SetValue(Term.Raw value)
1:         {
1:             this.value = value;
1:         }
1: 
0:         public Operation prepare(CFDefinition.Name receiver) throws InvalidRequestException
1:         {
0:             Term v = value.prepare(receiver);
1: 
1:             if (!(receiver.type instanceof CollectionType))
0:                 return new Constants.Setter(receiver.kind == CFDefinition.Name.Kind.VALUE_ALIAS ? null : receiver.name, v);
1: 
1:             switch (((CollectionType)receiver.type).kind)
1:             {
1:                 case LIST:
0:                     return new Lists.Setter(receiver.name, v);
1:                 case SET:
0:                     return new Sets.Setter(receiver.name, v);
1:                 case MAP:
0:                     return new Maps.Setter(receiver.name, v);
1:             }
1:             throw new AssertionError();
1:         }
1: 
1:         protected String toString(ColumnSpecification column)
1:         {
1:             return String.format("%s = %s", column, value);
1:         }
1: 
1:         public boolean isCompatibleWith(RawUpdate other)
1:         {
1:             // We don't allow setting multiple time the same column, because 1)
1:             // it's stupid and 2) the result would seem random to the user.
1:             return false;
1:         }
1:     }
1: 
1:     public static class SetElement implements RawUpdate
1:     {
1:         private final Term.Raw selector;
1:         private final Term.Raw value;
1: 
1:         public SetElement(Term.Raw selector, Term.Raw value)
1:         {
1:             this.selector = selector;
1:             this.value = value;
1:         }
1: 
0:         public Operation prepare(CFDefinition.Name receiver) throws InvalidRequestException
1:         {
1:             if (!(receiver.type instanceof CollectionType))
0:                 throw new InvalidRequestException(String.format("Invalid operation (%s) for non collection column %s", toString(receiver), receiver));
1: 
1:             switch (((CollectionType)receiver.type).kind)
1:             {
1:                 case LIST:
0:                     Term idx = selector.prepare(Lists.indexSpecOf(receiver));
0:                     Term lval = value.prepare(Lists.valueSpecOf(receiver));
0:                     return new Lists.SetterByIndex(receiver.name, idx, lval);
1:                 case SET:
0:                     throw new InvalidRequestException(String.format("Invalid operation (%s) for set column %s", toString(receiver), receiver));
1:                 case MAP:
0:                     Term key = selector.prepare(Maps.keySpecOf(receiver));
0:                     Term mval = value.prepare(Maps.valueSpecOf(receiver));
0:                     return new Maps.SetterByKey(receiver.name, key, mval);
1:             }
1:             throw new AssertionError();
1:         }
1: 
1:         protected String toString(ColumnSpecification column)
1:         {
0:             return String.format("%s[%s] = %s", column, selector, value);
1:         }
1: 
1:         public boolean isCompatibleWith(RawUpdate other)
1:         {
1:             // TODO: we could check that the other operation is not setting the same element
1:             // too (but since the index/key set may be a bind variables we can't always do it at this point)
1:             return !(other instanceof SetValue);
1:         }
1:     }
1: 
1:     public static class Addition implements RawUpdate
1:     {
1:         private final Term.Raw value;
1: 
1:         public Addition(Term.Raw value)
1:         {
1:             this.value = value;
1:         }
1: 
0:         public Operation prepare(CFDefinition.Name receiver) throws InvalidRequestException
1:         {
0:             Term v = value.prepare(receiver);
1: 
1:             if (!(receiver.type instanceof CollectionType))
1:             {
1:                 if (!(receiver.type instanceof CounterColumnType))
0:                     throw new InvalidRequestException(String.format("Invalid operation for non counter column %s", toString(receiver), receiver));
0:                 return new Constants.Adder(receiver.kind == CFDefinition.Name.Kind.VALUE_ALIAS ? null : receiver.name, v);
1:             }
1: 
1:             switch (((CollectionType)receiver.type).kind)
1:             {
1:                 case LIST:
0:                     return new Lists.Appender(receiver.name, v);
1:                 case SET:
0:                     return new Sets.Adder(receiver.name, v);
1:                 case MAP:
0:                     return new Maps.Putter(receiver.name, v);
1:             }
1:             throw new AssertionError();
1:         }
1: 
1:         protected String toString(ColumnSpecification column)
1:         {
0:             return String.format("%s = %s + %s", column, column, value);
1:         }
1: 
1:         public boolean isCompatibleWith(RawUpdate other)
1:         {
1:             return !(other instanceof SetValue);
1:         }
1:     }
1: 
1:     public static class Substraction implements RawUpdate
1:     {
1:         private final Term.Raw value;
1: 
1:         public Substraction(Term.Raw value)
1:         {
1:             this.value = value;
1:         }
1: 
0:         public Operation prepare(CFDefinition.Name receiver) throws InvalidRequestException
1:         {
0:             Term v = value.prepare(receiver);
1: 
1:             if (!(receiver.type instanceof CollectionType))
1:             {
1:                 if (!(receiver.type instanceof CounterColumnType))
0:                     throw new InvalidRequestException(String.format("Invalid operation (%s) for non counter column %s", toString(receiver), receiver));
0:                 return new Constants.Substracter(receiver.kind == CFDefinition.Name.Kind.VALUE_ALIAS ? null : receiver.name, v);
1:             }
1: 
1:             switch (((CollectionType)receiver.type).kind)
1:             {
1:                 case LIST:
0:                     return new Lists.Discarder(receiver.name, v);
1:                 case SET:
0:                     return new Sets.Discarder(receiver.name, v);
1:                 case MAP:
0:                     throw new InvalidRequestException(String.format("Invalid operation (%s) for map column %s", toString(receiver), receiver));
1:             }
1:             throw new AssertionError();
1:         }
1: 
1:         protected String toString(ColumnSpecification column)
1:         {
0:             return String.format("%s = %s - %s", column, column, value);
1:         }
1: 
1:         public boolean isCompatibleWith(RawUpdate other)
1:         {
1:             return !(other instanceof SetValue);
1:         }
1:     }
1: 
1:     public static class Prepend implements RawUpdate
1:     {
1:         private final Term.Raw value;
1: 
1:         public Prepend(Term.Raw value)
1:         {
1:             this.value = value;
1:         }
1: 
0:         public Operation prepare(CFDefinition.Name receiver) throws InvalidRequestException
1:         {
0:             Term v = value.prepare(receiver);
1: 
1:             if (!(receiver.type instanceof ListType))
0:                 throw new InvalidRequestException(String.format("Invalid operation (%s) for non list column %s", toString(receiver), receiver));
1: 
0:             return new Lists.Prepender(receiver.name, v);
1:         }
1: 
1:         protected String toString(ColumnSpecification column)
1:         {
0:             return String.format("%s = %s - %s", column, value, column);
1:         }
1: 
1:         public boolean isCompatibleWith(RawUpdate other)
1:         {
1:             return !(other instanceof SetValue);
1:         }
1:     }
1: 
1:     public static class ColumnDeletion implements RawDeletion
1:     {
0:         private final ColumnIdentifier id;
1: 
0:         public ColumnDeletion(ColumnIdentifier id)
1:         {
1:             this.id = id;
1:         }
1: 
0:         public ColumnIdentifier affectedColumn()
1:         {
1:             return id;
1:         }
1: 
0:         public Operation prepare(ColumnSpecification receiver) throws InvalidRequestException
1:         {
1:             // No validation, deleting a column is always "well typed"
0:             return new Constants.Deleter(id, receiver.type instanceof CollectionType);
1:         }
1:     }
1: 
1:     public static class ElementDeletion implements RawDeletion
1:     {
0:         private final ColumnIdentifier id;
1:         private final Term.Raw element;
1: 
0:         public ElementDeletion(ColumnIdentifier id, Term.Raw element)
1:         {
1:             this.id = id;
1:             this.element = element;
1:         }
1: 
0:         public ColumnIdentifier affectedColumn()
1:         {
1:             return id;
1:         }
1: 
0:         public Operation prepare(ColumnSpecification receiver) throws InvalidRequestException
1:         {
1:             if (!(receiver.type instanceof CollectionType))
0:                 throw new InvalidRequestException(String.format("Invalid deletion operation for non collection column %s", receiver));
1: 
1:             switch (((CollectionType)receiver.type).kind)
1:             {
1:                 case LIST:
0:                     Term idx = element.prepare(Lists.indexSpecOf(receiver));
0:                     return new Lists.DiscarderByIndex(id, idx);
1:                 case SET:
0:                     Term elt = element.prepare(Sets.valueSpecOf(receiver));
0:                     return new Lists.Discarder(id, elt);
1:                 case MAP:
0:                     Term key = element.prepare(Maps.keySpecOf(receiver));
0:                     return new Maps.DiscarderByKey(id, key);
1:             }
1:             throw new AssertionError();
1:         }
1:     }
1: }
commit:2b62df2
/////////////////////////////////////////////////////////////////////////
commit:91bdf7f
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collections;
1: import java.util.List;
1: 
0: import org.apache.cassandra.db.marshal.CollectionType;
0: import org.apache.cassandra.thrift.InvalidRequestException;
1: 
0: public abstract class Operation
0:     public static enum Type { SET, COUNTER, FUNCTION }
0:     protected Operation(Type type)
0:     public abstract Iterable<Term> allTerms();
1: 
0:     public static class Set extends Operation
0:         public final Value value;
1: 
0:         public Set(Value value)
1:         {
0:             super(Type.SET);
1:             this.value = value;
1:         }
1: 
0:         @Override
0:         public String toString()
1:         {
0:             return " = " + value;
1:         }
1: 
0:         public List<Term> allTerms()
1:         {
0:             return value.asList();
1:         }
0:     public static class Counter extends Operation
0:         public final Term value;
0:         public final boolean isSubstraction;
1: 
0:         public Counter(Term value, boolean isSubstraction)
1:         {
0:             super(Type.COUNTER);
1:             this.value = value;
0:             this.isSubstraction = isSubstraction;
1:         }
1: 
0:         @Override
0:         public String toString()
1:         {
0:             return (isSubstraction ? "-" : "+") + "= " + value;
1:         }
1: 
0:         public Iterable<Term> allTerms()
1:         {
0:             return Collections.singletonList(value);
1:         }
1:     }
1: 
0:     public static class Function extends Operation
1:     {
0:         public final CollectionType.Function fct;
0:         public final List<Term> arguments;
1: 
0:         public Function(CollectionType.Function fct, List<Term> arguments)
1:         {
0:             super(Type.FUNCTION);
0:             this.fct = fct;
0:             this.arguments = arguments;
1:         }
1: 
0:         @Override
0:         public String toString()
1:         {
0:             return "." + fct + arguments;
1:         }
1: 
0:         public Iterable<Term> allTerms()
1:         {
0:             return arguments;
1:         }
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
0:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
commit:655ccc3
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
0: package org.apache.cassandra.cql3;
0: 
0: public class Operation
0: {
0:     public static enum Type { PLUS, MINUS }
0: 
0:     public final Type type;
0:     public final ColumnIdentifier ident;
0:     public final Term value;
0: 
0:     // unary operation
0:     public Operation(Term a)
0:     {
0:         this(null, null, a);
0:     }
0: 
0:     // binary operation
0:     public Operation(ColumnIdentifier a, Type type, Term b)
0:     {
0:         this.ident = a;
0:         this.type = type;
0:         this.value = b;
0:     }
0: 
0:     public boolean isUnary()
0:     {
0:         return type == null && ident == null;
0:     }
0: 
0:     public String toString()
0:     {
0:         return (isUnary())
0:                 ? String.format("UnaryOperation(%s)", value)
0:                 : String.format("BinaryOperation(%s, %s, %s)", ident, type, value);
0:     }
0: }
author:Benjamin Lerer
-------------------------------------------------------------------------------
commit:4edd9ed
commit:89464ea
/////////////////////////////////////////////////////////////////////////
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:     public void addFunctionsTo(List<Function> functions)
1:         if (t != null)
1:             t.addFunctionsTo(functions);
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:677230d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.CFMetaData;
/////////////////////////////////////////////////////////////////////////
1:          * @param receiver the column this operation applies to.
1:         public Operation prepare(CFMetaData cfm, ColumnDefinition receiver) throws InvalidRequestException;
/////////////////////////////////////////////////////////////////////////
1:         public Operation prepare(String keyspace, ColumnDefinition receiver, CFMetaData cfm) throws InvalidRequestException;
/////////////////////////////////////////////////////////////////////////
1:         public Operation prepare(CFMetaData cfm, ColumnDefinition receiver) throws InvalidRequestException
1:             Term v = value.prepare(cfm.ksName, receiver);
1:             if (receiver.type.isCollection())
1:                 switch (((CollectionType) receiver.type).kind)
0:                 {
0:                     case LIST:
0:                         return new Lists.Setter(receiver, v);
0:                     case SET:
0:                         return new Sets.Setter(receiver, v);
0:                     case MAP:
0:                         return new Maps.Setter(receiver, v);
1:                     default:
0:                         throw new AssertionError();
0:                 }
0: 
1:             if (receiver.type.isUDT())
1:                 return new UserTypes.Setter(receiver, v);
0: 
0:             return new Constants.Setter(receiver, v);
/////////////////////////////////////////////////////////////////////////
1:         public Operation prepare(CFMetaData cfm, ColumnDefinition receiver) throws InvalidRequestException
/////////////////////////////////////////////////////////////////////////
1:                     Term idx = selector.prepare(cfm.ksName, Lists.indexSpecOf(receiver));
1:                     Term lval = value.prepare(cfm.ksName, Lists.valueSpecOf(receiver));
1:                     Term key = selector.prepare(cfm.ksName, Maps.keySpecOf(receiver));
1:                     Term mval = value.prepare(cfm.ksName, Maps.valueSpecOf(receiver));
/////////////////////////////////////////////////////////////////////////
1:     public static class SetField implements RawUpdate
0:     {
0:         private final ColumnIdentifier.Raw field;
1:         private final Term.Raw value;
0: 
0:         public SetField(ColumnIdentifier.Raw field, Term.Raw value)
0:         {
1:             this.field = field;
0:             this.value = value;
0:         }
0: 
1:         public Operation prepare(CFMetaData cfm, ColumnDefinition receiver) throws InvalidRequestException
0:         {
1:             if (!receiver.type.isUDT())
1:                 throw new InvalidRequestException(String.format("Invalid operation (%s) for non-UDT column %s", toString(receiver), receiver.name));
1:             else if (!receiver.type.isMultiCell())
1:                 throw new InvalidRequestException(String.format("Invalid operation (%s) for frozen UDT column %s", toString(receiver), receiver.name));
0: 
0:             ColumnIdentifier fieldIdentifier = field.prepare(cfm);
0:             int fieldPosition = ((UserType) receiver.type).fieldPosition(fieldIdentifier);
1:             if (fieldPosition == -1)
0:                 throw new InvalidRequestException(String.format("UDT column %s does not have a field named %s", receiver.name, fieldIdentifier));
0: 
1:             Term val = value.prepare(cfm.ksName, UserTypes.fieldSpecOf(receiver, fieldPosition));
0:             return new UserTypes.SetterByField(receiver, fieldIdentifier, val);
0:         }
0: 
1:         protected String toString(ColumnSpecification column)
0:         {
1:             return String.format("%s.%s = %s", column.name, field, value);
0:         }
0: 
1:         public boolean isCompatibleWith(RawUpdate other)
0:         {
1:             if (other instanceof SetField)
1:                 return !((SetField) other).field.equals(field);
1:             else
1:                 return !(other instanceof SetValue);
0:         }
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:         public Operation prepare(CFMetaData cfm, ColumnDefinition receiver) throws InvalidRequestException
1:             Term v = value.prepare(cfm.ksName, receiver);
/////////////////////////////////////////////////////////////////////////
1:         public Operation prepare(CFMetaData cfm, ColumnDefinition receiver) throws InvalidRequestException
1:                 return new Constants.Substracter(receiver, value.prepare(cfm.ksName, receiver));
/////////////////////////////////////////////////////////////////////////
1:                     return new Lists.Discarder(receiver, value.prepare(cfm.ksName, receiver));
1:                     return new Sets.Discarder(receiver, value.prepare(cfm.ksName, receiver));
1:                     return new Sets.Discarder(receiver, value.prepare(cfm.ksName, vr));
/////////////////////////////////////////////////////////////////////////
1:         public Operation prepare(CFMetaData cfm, ColumnDefinition receiver) throws InvalidRequestException
1:             Term v = value.prepare(cfm.ksName, receiver);
/////////////////////////////////////////////////////////////////////////
1:         public Operation prepare(String keyspace, ColumnDefinition receiver, CFMetaData cfm) throws InvalidRequestException
/////////////////////////////////////////////////////////////////////////
1:         public Operation prepare(String keyspace, ColumnDefinition receiver, CFMetaData cfm) throws InvalidRequestException
/////////////////////////////////////////////////////////////////////////
0: 
1:     public static class FieldDeletion implements RawDeletion
0:     {
0:         private final ColumnIdentifier.Raw id;
0:         private final ColumnIdentifier.Raw field;
0: 
0:         public FieldDeletion(ColumnIdentifier.Raw id, ColumnIdentifier.Raw field)
0:         {
1:             this.id = id;
1:             this.field = field;
0:         }
0: 
0:         public ColumnIdentifier.Raw affectedColumn()
0:         {
1:             return id;
0:         }
0: 
1:         public Operation prepare(String keyspace, ColumnDefinition receiver, CFMetaData cfm) throws InvalidRequestException
0:         {
1:             if (!receiver.type.isUDT())
1:                 throw new InvalidRequestException(String.format("Invalid field deletion operation for non-UDT column %s", receiver.name));
1:             else if (!receiver.type.isMultiCell())
1:                 throw new InvalidRequestException(String.format("Frozen UDT column %s does not support field deletions", receiver.name));
0: 
0:             ColumnIdentifier fieldIdentifier = field.prepare(cfm);
0:             if (((UserType) receiver.type).fieldPosition(fieldIdentifier) == -1)
0:                 throw new InvalidRequestException(String.format("UDT column %s does not have a field named %s", receiver.name, fieldIdentifier));
0: 
0:             return new UserTypes.DeleterByField(receiver, fieldIdentifier);
0:         }
0:     }
commit:ee55f36
/////////////////////////////////////////////////////////////////////////
1:             if (!(receiver.type.isCollection()))
/////////////////////////////////////////////////////////////////////////
1:             else if (!(receiver.type.isMultiCell()))
1:                 throw new InvalidRequestException(String.format("Invalid operation (%s) for frozen collection column %s", toString(receiver), receiver.name));
/////////////////////////////////////////////////////////////////////////
1:             else if (!(receiver.type.isMultiCell()))
1:                 throw new InvalidRequestException(String.format("Invalid operation (%s) for frozen collection column %s", toString(receiver), receiver.name));
/////////////////////////////////////////////////////////////////////////
1:             else if (!(receiver.type.isMultiCell()))
1:                 throw new InvalidRequestException(String.format("Invalid operation (%s) for frozen collection column %s", toString(receiver), receiver.name));
/////////////////////////////////////////////////////////////////////////
1:                                                                      SetType.getInstance(((MapType)receiver.type).getKeysType(), false));
/////////////////////////////////////////////////////////////////////////
1:             else if (!(receiver.type.isMultiCell()))
1:                 throw new InvalidRequestException(String.format("Invalid operation (%s) for frozen list column %s", toString(receiver), receiver.name));
/////////////////////////////////////////////////////////////////////////
0:             if (!(receiver.type.isCollection()))
1:             else if (!(receiver.type.isMultiCell()))
1:                 throw new InvalidRequestException(String.format("Invalid deletion operation for frozen collection column %s", receiver.name));
commit:a446e80
commit:11e6571
/////////////////////////////////////////////////////////////////////////
0:         public ColumnIdentifier.Raw affectedColumn();
/////////////////////////////////////////////////////////////////////////
0:         public Operation prepare(ColumnSpecification receiver, CFMetaData cfm) throws InvalidRequestException;
/////////////////////////////////////////////////////////////////////////
0:         private final ColumnIdentifier.Raw id;
0:         public ColumnDeletion(ColumnIdentifier.Raw id)
0:         public ColumnIdentifier.Raw affectedColumn()
0:         public Operation prepare(ColumnSpecification receiver, CFMetaData cfm) throws InvalidRequestException
0:             return new Constants.Deleter(id.prepare(cfm), receiver.type instanceof CollectionType);
0:         private final ColumnIdentifier.Raw id;
0:         public ElementDeletion(ColumnIdentifier.Raw id, Term.Raw element)
0:         public ColumnIdentifier.Raw affectedColumn()
0:         public Operation prepare(ColumnSpecification receiver, CFMetaData cfm) throws InvalidRequestException
0:             ColumnIdentifier preparedId = id.prepare(cfm);
0:                     return new Lists.DiscarderByIndex(preparedId, idx);
0:                     return new Sets.Discarder(preparedId, elt);
0:                     return new Maps.DiscarderByKey(preparedId, key);
author:Sam Tunnicliffe
-------------------------------------------------------------------------------
commit:d9836e0
/////////////////////////////////////////////////////////////////////////
commit:cb5897f
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collections;
1: import org.apache.cassandra.cql3.functions.Function;
/////////////////////////////////////////////////////////////////////////
0:     public Iterable<Function> getFunctions()
0:     {
0:         return t != null ? t.getFunctions() : Collections.<Function>emptySet();
0:     }
0: 
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:1faca1c
commit:44a9d8c
/////////////////////////////////////////////////////////////////////////
1:      *   - An addition/subtraction to a variable: c = c +/- v (where v can be a collection literal)
/////////////////////////////////////////////////////////////////////////
1:                     // The value for a map subtraction is actually a set
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:bcf0ec6
/////////////////////////////////////////////////////////////////////////
1:                     return new Sets.ElementDiscarder(receiver, elt);
author:Robert Stupp
-------------------------------------------------------------------------------
commit:b4d7f3b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public boolean usesFunction(String ksName, String functionName)
0:     {
0:         return t != null && t.usesFunction(ksName, functionName);
0:     }
0: 
============================================================================