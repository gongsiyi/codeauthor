1:4d34917: /*
1:4d34917:  * Licensed to the Apache Software Foundation (ASF) under one
1:4d34917:  * or more contributor license agreements.  See the NOTICE file
1:4d34917:  * distributed with this work for additional information
1:4d34917:  * regarding copyright ownership.  The ASF licenses this file
1:4d34917:  * to you under the Apache License, Version 2.0 (the
1:4d34917:  * "License"); you may not use this file except in compliance
1:4d34917:  * with the License.  You may obtain a copy of the License at
1:4d34917:  *
1:4d34917:  *     http://www.apache.org/licenses/LICENSE-2.0
1:4d34917:  *
1:4d34917:  * Unless required by applicable law or agreed to in writing, software
1:4d34917:  * distributed under the License is distributed on an "AS IS" BASIS,
1:4d34917:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:4d34917:  * See the License for the specific language governing permissions and
1:4d34917:  * limitations under the License.
1:4d34917:  */
1:4d34917: package org.apache.cassandra.utils;
14:4d34917: 
1:4d34917: import java.io.IOException;
1:4d34917: import java.lang.reflect.Constructor;
1:4d34917: import java.lang.reflect.InvocationTargetException;
1:4d34917: import java.util.*;
1:4d34917: 
1:4d34917: import com.google.common.base.Joiner;
1:489a9e8: import org.apache.cassandra.utils.AbstractIterator;
1:4d34917: import com.google.common.collect.Iterators;
1:03f72ac: 
1:4d34917: import org.slf4j.Logger;
1:4d34917: import org.slf4j.LoggerFactory;
1:4d34917: import org.apache.cassandra.db.TypeSizes;
1:4d34917: import org.apache.cassandra.io.ISerializer;
1:4d34917: import org.apache.cassandra.io.IVersionedSerializer;
1:03f72ac: import org.apache.cassandra.io.util.DataInputPlus;
1:75508ec: import org.apache.cassandra.io.util.DataOutputPlus;
1:52ddfe4: import org.apache.cassandra.utils.AsymmetricOrdering.Op;
1:4d34917: 
1:52ddfe4: public class IntervalTree<C extends Comparable<? super C>, D, I extends Interval<C, D>> implements Iterable<I>
21:4d34917: {
1:4d34917:     private static final Logger logger = LoggerFactory.getLogger(IntervalTree.class);
1:4d34917: 
1:4d34917:     @SuppressWarnings("unchecked")
1:52ddfe4:     private static final IntervalTree EMPTY_TREE = new IntervalTree(null);
1:4d34917: 
1:4d34917:     private final IntervalNode head;
1:4d34917:     private final int count;
1:4d34917: 
1:52ddfe4:     protected IntervalTree(Collection<I> intervals)
1:4d34917:     {
1:4d34917:         this.head = intervals == null || intervals.isEmpty() ? null : new IntervalNode(intervals);
1:4d34917:         this.count = intervals == null ? 0 : intervals.size();
19:4d34917:     }
1:4d34917: 
1:52ddfe4:     public static <C extends Comparable<? super C>, D, I extends Interval<C, D>> IntervalTree<C, D, I> build(Collection<I> intervals)
1:4d34917:     {
2:4d34917:         if (intervals == null || intervals.isEmpty())
2:4d34917:             return emptyTree();
1:4d34917: 
1:52ddfe4:         return new IntervalTree<C, D, I>(intervals);
1:4d34917:     }
1:4d34917: 
1:52ddfe4:     public static <C extends Comparable<? super C>, D, I extends Interval<C, D>> Serializer<C, D, I> serializer(ISerializer<C> pointSerializer, ISerializer<D> dataSerializer, Constructor<I> constructor)
1:4d34917:     {
1:75508ec:         return new Serializer<>(pointSerializer, dataSerializer, constructor);
1:4d34917:     }
1:4d34917: 
1:4d34917:     @SuppressWarnings("unchecked")
1:52ddfe4:     public static <C extends Comparable<? super C>, D, I extends Interval<C, D>> IntervalTree<C, D, I> emptyTree()
1:4d34917:     {
1:1fab7b7:         return EMPTY_TREE;
1:4d34917:     }
1:4d34917: 
1:4d34917:     public int intervalCount()
1:4d34917:     {
1:4d34917:         return count;
1:4d34917:     }
1:4d34917: 
1:4d34917:     public boolean isEmpty()
1:4d34917:     {
1:4d34917:         return head == null;
1:4d34917:     }
1:4d34917: 
1:4d34917:     public C max()
1:4d34917:     {
1:4d34917:         if (head == null)
1:4d34917:             throw new IllegalStateException();
1:4d34917: 
1:4d34917:         return head.high;
1:4d34917:     }
1:4d34917: 
1:4d34917:     public C min()
1:4d34917:     {
1:4d34917:         if (head == null)
1:4d34917:             throw new IllegalStateException();
1:4d34917: 
1:4d34917:         return head.low;
1:4d34917:     }
1:4d34917: 
1:4d34917:     public List<D> search(Interval<C, D> searchInterval)
1:4d34917:     {
1:4d34917:         if (head == null)
1:4d34917:             return Collections.<D>emptyList();
1:4d34917: 
1:4d34917:         List<D> results = new ArrayList<D>();
1:4d34917:         head.searchInternal(searchInterval, results);
1:4d34917:         return results;
1:4d34917:     }
1:4d34917: 
1:4d34917:     public List<D> search(C point)
1:4d34917:     {
1:4d34917:         return search(Interval.<C, D>create(point, point, null));
1:4d34917:     }
1:4d34917: 
1:4d34917:     public Iterator<I> iterator()
1:4d34917:     {
1:4d34917:         if (head == null)
1:f4233eb:             return Collections.emptyIterator();
1:4d34917: 
1:4d34917:         return new TreeIterator(head);
1:4d34917:     }
1:4d34917: 
1:4d34917:     @Override
1:4d34917:     public String toString()
1:4d34917:     {
1:4d34917:         return "<" + Joiner.on(", ").join(this) + ">";
1:4d34917:     }
1:4d34917: 
1:4d34917:     @Override
1:4d34917:     public boolean equals(Object o)
1:4d34917:     {
1:4d34917:         if(!(o instanceof IntervalTree))
1:4d34917:             return false;
1:4d34917:         IntervalTree that = (IntervalTree)o;
1:4d34917:         return Iterators.elementsEqual(iterator(), that.iterator());
1:4d34917:     }
1:4d34917: 
1:4d34917:     @Override
1:4d34917:     public final int hashCode()
1:4d34917:     {
1:52ddfe4:         int result = 0;
1:4d34917:         for (Interval<C, D> interval : this)
1:4d34917:             result = 31 * result + interval.hashCode();
1:4d34917:         return result;
1:4d34917:     }
1:4d34917: 
1:4d34917:     private class IntervalNode
1:4d34917:     {
1:4d34917:         final C center;
1:4d34917:         final C low;
1:4d34917:         final C high;
1:4d34917: 
1:4d34917:         final List<I> intersectsLeft;
1:4d34917:         final List<I> intersectsRight;
1:4d34917: 
1:4d34917:         final IntervalNode left;
1:4d34917:         final IntervalNode right;
1:4d34917: 
1:4d34917:         public IntervalNode(Collection<I> toBisect)
1:4d34917:         {
1:4d34917:             assert !toBisect.isEmpty();
1:5262098:             logger.trace("Creating IntervalNode from {}", toBisect);
1:4d34917: 
1:4d34917:             // Building IntervalTree with one interval will be a reasonably
1:4d34917:             // common case for range tombstones, so it's worth optimizing
1:4d34917:             if (toBisect.size() == 1)
1:4d34917:             {
1:4d34917:                 I interval = toBisect.iterator().next();
1:4d34917:                 low = interval.min;
1:4d34917:                 center = interval.max;
1:4d34917:                 high = interval.max;
1:4d34917:                 List<I> l = Collections.singletonList(interval);
1:4d34917:                 intersectsLeft = l;
1:4d34917:                 intersectsRight = l;
1:4d34917:                 left = null;
1:4d34917:                 right = null;
1:4d34917:             }
6:4d34917:             else
1:4d34917:             {
1:4d34917:                 // Find min, median and max
1:4d34917:                 List<C> allEndpoints = new ArrayList<C>(toBisect.size() * 2);
1:4d34917:                 for (I interval : toBisect)
1:4d34917:                 {
1:4d34917:                     allEndpoints.add(interval.min);
1:4d34917:                     allEndpoints.add(interval.max);
1:4d34917:                 }
1:52ddfe4: 
1:52ddfe4:                 Collections.sort(allEndpoints);
1:4d34917: 
1:4d34917:                 low = allEndpoints.get(0);
1:4d34917:                 center = allEndpoints.get(toBisect.size());
1:4d34917:                 high = allEndpoints.get(allEndpoints.size() - 1);
1:4d34917: 
1:4d34917:                 // Separate interval in intersecting center, left of center and right of center
1:4d34917:                 List<I> intersects = new ArrayList<I>();
1:4d34917:                 List<I> leftSegment = new ArrayList<I>();
1:4d34917:                 List<I> rightSegment = new ArrayList<I>();
1:4d34917: 
1:4d34917:                 for (I candidate : toBisect)
1:4d34917:                 {
1:52ddfe4:                     if (candidate.max.compareTo(center) < 0)
1:4d34917:                         leftSegment.add(candidate);
1:52ddfe4:                     else if (candidate.min.compareTo(center) > 0)
1:4d34917:                         rightSegment.add(candidate);
1:4d34917:                     else
1:4d34917:                         intersects.add(candidate);
1:4d34917:                 }
1:4d34917: 
1:52ddfe4:                 intersectsLeft = Interval.<C, D>minOrdering().sortedCopy(intersects);
1:52ddfe4:                 intersectsRight = Interval.<C, D>maxOrdering().sortedCopy(intersects);
1:4d34917:                 left = leftSegment.isEmpty() ? null : new IntervalNode(leftSegment);
1:4d34917:                 right = rightSegment.isEmpty() ? null : new IntervalNode(rightSegment);
1:4d34917: 
1:4d34917:                 assert (intersects.size() + leftSegment.size() + rightSegment.size()) == toBisect.size() :
1:4d34917:                         "intersects (" + String.valueOf(intersects.size()) +
1:4d34917:                         ") + leftSegment (" + String.valueOf(leftSegment.size()) +
1:4d34917:                         ") + rightSegment (" + String.valueOf(rightSegment.size()) +
1:4d34917:                         ") != toBisect (" + String.valueOf(toBisect.size()) + ")";
1:4d34917:             }
1:4d34917:         }
1:4d34917: 
1:4d34917:         void searchInternal(Interval<C, D> searchInterval, List<D> results)
1:4d34917:         {
1:52ddfe4:             if (center.compareTo(searchInterval.min) < 0)
1:52ddfe4:             {
1:52ddfe4:                 int i = Interval.<C, D>maxOrdering().binarySearchAsymmetric(intersectsRight, searchInterval.min, Op.CEIL);
1:52ddfe4:                 if (i == intersectsRight.size() && high.compareTo(searchInterval.min) < 0)
1:84bfdf2:                     return;
1:84bfdf2: 
1:52ddfe4:                 while (i < intersectsRight.size())
1:52ddfe4:                     results.add(intersectsRight.get(i++).data);
1:52ddfe4: 
1:52ddfe4:                 if (right != null)
1:52ddfe4:                     right.searchInternal(searchInterval, results);
1:52ddfe4:             }
1:52ddfe4:             else if (center.compareTo(searchInterval.max) > 0)
1:52ddfe4:             {
1:52ddfe4:                 int j = Interval.<C, D>minOrdering().binarySearchAsymmetric(intersectsLeft, searchInterval.max, Op.HIGHER);
1:52ddfe4:                 if (j == 0 && low.compareTo(searchInterval.max) > 0)
2:52ddfe4:                     return;
1:52ddfe4: 
1:52ddfe4:                 for (int i = 0 ; i < j ; i++)
1:52ddfe4:                     results.add(intersectsLeft.get(i).data);
1:52ddfe4: 
1:52ddfe4:                 if (left != null)
1:52ddfe4:                     left.searchInternal(searchInterval, results);
1:52ddfe4:             }
1:52ddfe4:             else
1:4d34917:             {
1:4d34917:                 // Adds every interval contained in this node to the result set then search left and right for further
1:4d34917:                 // overlapping intervals
2:4d34917:                 for (Interval<C, D> interval : intersectsLeft)
3:4d34917:                     results.add(interval.data);
1:4d34917: 
2:4d34917:                 if (left != null)
2:4d34917:                     left.searchInternal(searchInterval, results);
2:4d34917:                 if (right != null)
2:4d34917:                     right.searchInternal(searchInterval, results);
1:4d34917:             }
1:4d34917:         }
1:4d34917:     }
1:4d34917: 
1:4d34917:     private class TreeIterator extends AbstractIterator<I>
1:4d34917:     {
1:4d34917:         private final Deque<IntervalNode> stack = new ArrayDeque<IntervalNode>();
1:4d34917:         private Iterator<I> current;
1:4d34917: 
1:4d34917:         TreeIterator(IntervalNode node)
1:4d34917:         {
1:4d34917:             super();
1:4d34917:             gotoMinOf(node);
1:4d34917:         }
1:4d34917: 
1:4d34917:         protected I computeNext()
1:4d34917:         {
1:0f5e780:             while (true)
1:0f5e780:             {
1:0f5e780:                 if (current != null && current.hasNext())
1:0f5e780:                     return current.next();
1:4d34917: 
1:0f5e780:                 IntervalNode node = stack.pollFirst();
1:0f5e780:                 if (node == null)
1:0f5e780:                     return endOfData();
1:4d34917: 
1:0f5e780:                 current = node.intersectsLeft.iterator();
1:4d34917: 
1:0f5e780:                 // We know this is the smaller not returned yet, but before doing
1:0f5e780:                 // its parent, we must do everyone on it's right.
1:0f5e780:                 gotoMinOf(node.right);
1:0f5e780:             }
1:4d34917:         }
1:4d34917: 
1:4d34917:         private void gotoMinOf(IntervalNode node)
1:4d34917:         {
1:4d34917:             while (node != null)
1:4d34917:             {
1:4d34917:                 stack.offerFirst(node);
1:4d34917:                 node = node.left;
1:4d34917:             }
1:4d34917: 
1:4d34917:         }
1:4d34917:     }
1:4d34917: 
1:52ddfe4:     public static class Serializer<C extends Comparable<? super C>, D, I extends Interval<C, D>> implements IVersionedSerializer<IntervalTree<C, D, I>>
1:4d34917:     {
1:4d34917:         private final ISerializer<C> pointSerializer;
1:4d34917:         private final ISerializer<D> dataSerializer;
1:4d34917:         private final Constructor<I> constructor;
1:4d34917: 
1:4d34917:         private Serializer(ISerializer<C> pointSerializer, ISerializer<D> dataSerializer, Constructor<I> constructor)
1:4d34917:         {
1:4d34917:             this.pointSerializer = pointSerializer;
1:4d34917:             this.dataSerializer = dataSerializer;
1:4d34917:             this.constructor = constructor;
1:4d34917:         }
1:4d34917: 
1:75508ec:         public void serialize(IntervalTree<C, D, I> it, DataOutputPlus out, int version) throws IOException
1:4d34917:         {
1:60d9c7f:             out.writeInt(it.count);
2:4d34917:             for (Interval<C, D> interval : it)
1:4d34917:             {
1:60d9c7f:                 pointSerializer.serialize(interval.min, out);
1:60d9c7f:                 pointSerializer.serialize(interval.max, out);
1:60d9c7f:                 dataSerializer.serialize(interval.data, out);
1:4d34917:             }
1:4d34917:         }
1:4d34917: 
1:4d34917:         /**
1:4d34917:          * Deserialize an IntervalTree whose keys use the natural ordering.
1:4d34917:          * Use deserialize(DataInput, int, Comparator) instead if the interval
1:4d34917:          * tree is to use a custom comparator, as the comparator is *not*
1:4d34917:          * serialized.
1:4d34917:          */
1:03f72ac:         public IntervalTree<C, D, I> deserialize(DataInputPlus in, int version) throws IOException
1:4d34917:         {
1:60d9c7f:             return deserialize(in, version, null);
1:4d34917:         }
1:4d34917: 
1:03f72ac:         public IntervalTree<C, D, I> deserialize(DataInputPlus in, int version, Comparator<C> comparator) throws IOException
1:4d34917:         {
1:4d34917:             try
1:4d34917:             {
1:60d9c7f:                 int count = in.readInt();
1:52ddfe4:                 List<I> intervals = new ArrayList<I>(count);
1:4d34917:                 for (int i = 0; i < count; i++)
1:4d34917:                 {
1:60d9c7f:                     C min = pointSerializer.deserialize(in);
1:60d9c7f:                     C max = pointSerializer.deserialize(in);
1:60d9c7f:                     D data = dataSerializer.deserialize(in);
1:4d34917:                     intervals.add(constructor.newInstance(min, max, data));
1:4d34917:                 }
1:52ddfe4:                 return new IntervalTree<C, D, I>(intervals);
1:4d34917:             }
1:01880a4:             catch (InstantiationException | InvocationTargetException | IllegalAccessException e)
1:4d34917:             {
3:4d34917:                 throw new RuntimeException(e);
1:4d34917:             }
1:4d34917:         }
1:4d34917: 
1:4d34917:         public long serializedSize(IntervalTree<C, D, I> it, int version)
1:4d34917:         {
1:03f72ac:             long size = TypeSizes.sizeof(0);
1:03f72ac:             for (Interval<C, D> interval : it)
1:03f72ac:             {
1:03f72ac:                 size += pointSerializer.serializedSize(interval.min);
1:03f72ac:                 size += pointSerializer.serializedSize(interval.max);
1:03f72ac:                 size += dataSerializer.serializedSize(interval.data);
1:03f72ac:             }
1:03f72ac:             return size;
1:4d34917:         }
1:4d34917:     }
1:4d34917: }
============================================================================
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:f4233eb
/////////////////////////////////////////////////////////////////////////
1:             return Collections.emptyIterator();
commit:60d9c7f
/////////////////////////////////////////////////////////////////////////
0:         public void serialize(IntervalTree<C, D, I> it, DataOutput out, int version) throws IOException
1:             out.writeInt(it.count);
1:                 pointSerializer.serialize(interval.min, out);
1:                 pointSerializer.serialize(interval.max, out);
1:                 dataSerializer.serialize(interval.data, out);
/////////////////////////////////////////////////////////////////////////
0:         public IntervalTree<C, D, I> deserialize(DataInput in, int version) throws IOException
1:             return deserialize(in, version, null);
0:         public IntervalTree<C, D, I> deserialize(DataInput in, int version, Comparator<C> comparator) throws IOException
1:                 int count = in.readInt();
1:                     C min = pointSerializer.deserialize(in);
1:                     C max = pointSerializer.deserialize(in);
1:                     D data = dataSerializer.deserialize(in);
commit:5262098
/////////////////////////////////////////////////////////////////////////
1:             logger.trace("Creating IntervalNode from {}", toBisect);
commit:84bfdf2
/////////////////////////////////////////////////////////////////////////
0:             if (comparePoints(searchInterval.max, low) < 0 || comparePoints(searchInterval.min, high) > 0)
1:                 return;
1: 
author:Robert Stupp
-------------------------------------------------------------------------------
commit:0f5e780
/////////////////////////////////////////////////////////////////////////
1:             while (true)
1:             {
1:                 if (current != null && current.hasNext())
1:                     return current.next();
1:                 IntervalNode node = stack.pollFirst();
1:                 if (node == null)
1:                     return endOfData();
1:                 current = node.intersectsLeft.iterator();
1:                 // We know this is the smaller not returned yet, but before doing
1:                 // its parent, we must do everyone on it's right.
1:                 gotoMinOf(node.right);
1:             }
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:489a9e8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.AbstractIterator;
commit:52ddfe4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.AsymmetricOrdering.Op;
1: public class IntervalTree<C extends Comparable<? super C>, D, I extends Interval<C, D>> implements Iterable<I>
1:     private static final IntervalTree EMPTY_TREE = new IntervalTree(null);
1:     protected IntervalTree(Collection<I> intervals)
0:     public static <C extends Comparable<? super C>, D, I extends Interval<C, D>> IntervalTree<C, D, I> build(Collection<I> intervals, Comparator<C> comparator)
1:         return new IntervalTree<C, D, I>(intervals);
1:     public static <C extends Comparable<? super C>, D, I extends Interval<C, D>> IntervalTree<C, D, I> build(Collection<I> intervals)
1:         return new IntervalTree<C, D, I>(intervals);
1:     public static <C extends Comparable<? super C>, D, I extends Interval<C, D>> Serializer<C, D, I> serializer(ISerializer<C> pointSerializer, ISerializer<D> dataSerializer, Constructor<I> constructor)
1:     public static <C extends Comparable<? super C>, D, I extends Interval<C, D>> IntervalTree<C, D, I> emptyTree()
/////////////////////////////////////////////////////////////////////////
1:         int result = 0;
/////////////////////////////////////////////////////////////////////////
1: 
1:                 Collections.sort(allEndpoints);
/////////////////////////////////////////////////////////////////////////
1:                     if (candidate.max.compareTo(center) < 0)
1:                     else if (candidate.min.compareTo(center) > 0)
1:                 intersectsLeft = Interval.<C, D>minOrdering().sortedCopy(intersects);
1:                 intersectsRight = Interval.<C, D>maxOrdering().sortedCopy(intersects);
/////////////////////////////////////////////////////////////////////////
1:             if (center.compareTo(searchInterval.min) < 0)
1:             {
1:                 int i = Interval.<C, D>maxOrdering().binarySearchAsymmetric(intersectsRight, searchInterval.min, Op.CEIL);
1:                 if (i == intersectsRight.size() && high.compareTo(searchInterval.min) < 0)
1:                     return;
1:                 while (i < intersectsRight.size())
1:                     results.add(intersectsRight.get(i++).data);
1: 
1:                 if (right != null)
1:                     right.searchInternal(searchInterval, results);
1:             }
1:             else if (center.compareTo(searchInterval.max) > 0)
1:             {
1:                 int j = Interval.<C, D>minOrdering().binarySearchAsymmetric(intersectsLeft, searchInterval.max, Op.HIGHER);
1:                 if (j == 0 && low.compareTo(searchInterval.max) > 0)
1:                     return;
1: 
1:                 for (int i = 0 ; i < j ; i++)
1:                     results.add(intersectsLeft.get(i).data);
1: 
1:                 if (left != null)
1:                     left.searchInternal(searchInterval, results);
1:             }
1:             else
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public static class Serializer<C extends Comparable<? super C>, D, I extends Interval<C, D>> implements IVersionedSerializer<IntervalTree<C, D, I>>
/////////////////////////////////////////////////////////////////////////
1:                 List<I> intervals = new ArrayList<I>(count);
/////////////////////////////////////////////////////////////////////////
0:                 return new IntervalTree<C, D, I>(intervals);
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:03f72ac
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.cassandra.io.util.DataInputPlus;
/////////////////////////////////////////////////////////////////////////
1:         public IntervalTree<C, D, I> deserialize(DataInputPlus in, int version) throws IOException
1:         public IntervalTree<C, D, I> deserialize(DataInputPlus in, int version, Comparator<C> comparator) throws IOException
/////////////////////////////////////////////////////////////////////////
1:             long size = TypeSizes.sizeof(0);
1:             for (Interval<C, D> interval : it)
1:             {
1:                 size += pointSerializer.serializedSize(interval.min);
1:                 size += pointSerializer.serializedSize(interval.max);
1:                 size += dataSerializer.serializedSize(interval.data);
1:             }
1:             return size;
author:Dave Brosius
-------------------------------------------------------------------------------
commit:01880a4
/////////////////////////////////////////////////////////////////////////
1:             catch (InstantiationException | InvocationTargetException | IllegalAccessException e)
commit:1fab7b7
/////////////////////////////////////////////////////////////////////////
1:         return EMPTY_TREE;
commit:7ea642c
/////////////////////////////////////////////////////////////////////////
author:belliottsmith
-------------------------------------------------------------------------------
commit:75508ec
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.DataOutputPlus;
/////////////////////////////////////////////////////////////////////////
1:         return new Serializer<>(pointSerializer, dataSerializer, constructor);
/////////////////////////////////////////////////////////////////////////
1:         public void serialize(IntervalTree<C, D, I> it, DataOutputPlus out, int version) throws IOException
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:b4e47bc
/////////////////////////////////////////////////////////////////////////
0:                 if (comparator != null)
commit:4d34917
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.utils;
1: 
0: import java.io.DataInput;
0: import java.io.DataOutput;
1: import java.io.IOException;
1: import java.lang.reflect.Constructor;
1: import java.lang.reflect.InvocationTargetException;
1: import java.util.*;
1: 
1: import com.google.common.base.Joiner;
0: import com.google.common.collect.AbstractIterator;
1: import com.google.common.collect.Iterators;
0: import com.google.common.collect.Ordering;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: import org.apache.cassandra.db.TypeSizes;
1: import org.apache.cassandra.io.ISerializer;
1: import org.apache.cassandra.io.IVersionedSerializer;
1: 
0: public class IntervalTree<C, D, I extends Interval<C, D>> implements Iterable<I>
1: {
1:     private static final Logger logger = LoggerFactory.getLogger(IntervalTree.class);
1: 
1:     @SuppressWarnings("unchecked")
0:     private static final IntervalTree EMPTY_TREE = new IntervalTree(null, null);
1: 
1:     private final IntervalNode head;
1:     private final int count;
0:     private final Comparator<C> comparator;
1: 
0:     final Ordering<I> minOrdering;
0:     final Ordering<I> maxOrdering;
1: 
0:     protected IntervalTree(Collection<I> intervals, Comparator<C> comparator)
1:     {
0:         this.comparator = comparator;
1: 
0:         final IntervalTree it = this;
0:         this.minOrdering = new Ordering<I>()
1:         {
0:             public int compare(I interval1, I interval2)
1:             {
0:                 return it.comparePoints(interval1.min, interval2.min);
1:             }
0:         };
0:         this.maxOrdering = new Ordering<I>()
1:         {
0:             public int compare(I interval1, I interval2)
1:             {
0:                 return it.comparePoints(interval1.max, interval2.max);
1:             }
0:         };
1: 
1:         this.head = intervals == null || intervals.isEmpty() ? null : new IntervalNode(intervals);
1:         this.count = intervals == null ? 0 : intervals.size();
1:     }
1: 
0:     public static <C, D, I extends Interval<C, D>> IntervalTree<C, D, I> build(Collection<I> intervals, Comparator<C> comparator)
1:     {
1:         if (intervals == null || intervals.isEmpty())
1:             return emptyTree();
1: 
0:         return new IntervalTree<C, D, I>(intervals, comparator);
1:     }
1: 
0:     public static <C extends Comparable<C>, D, I extends Interval<C, D>> IntervalTree<C, D, I> build(Collection<I> intervals)
1:     {
1:         if (intervals == null || intervals.isEmpty())
1:             return emptyTree();
1: 
0:         return new IntervalTree<C, D, I>(intervals, null);
1:     }
1: 
0:     public static <C, D, I extends Interval<C, D>> Serializer<C, D, I> serializer(ISerializer<C> pointSerializer, ISerializer<D> dataSerializer, Constructor<I> constructor)
1:     {
0:         return new Serializer(pointSerializer, dataSerializer, constructor);
1:     }
1: 
1:     @SuppressWarnings("unchecked")
0:     public static <C, D, I extends Interval<C, D>> IntervalTree<C, D, I> emptyTree()
1:     {
0:         return (IntervalTree<C, D, I>)EMPTY_TREE;
1:     }
1: 
0:     public Comparator<C> comparator()
1:     {
0:         return comparator;
1:     }
1: 
1:     public int intervalCount()
1:     {
1:         return count;
1:     }
1: 
1:     public boolean isEmpty()
1:     {
1:         return head == null;
1:     }
1: 
1:     public C max()
1:     {
1:         if (head == null)
1:             throw new IllegalStateException();
1: 
1:         return head.high;
1:     }
1: 
1:     public C min()
1:     {
1:         if (head == null)
1:             throw new IllegalStateException();
1: 
1:         return head.low;
1:     }
1: 
1:     public List<D> search(Interval<C, D> searchInterval)
1:     {
1:         if (head == null)
1:             return Collections.<D>emptyList();
1: 
1:         List<D> results = new ArrayList<D>();
1:         head.searchInternal(searchInterval, results);
1:         return results;
1:     }
1: 
1:     public List<D> search(C point)
1:     {
1:         return search(Interval.<C, D>create(point, point, null));
1:     }
1: 
1:     public Iterator<I> iterator()
1:     {
1:         if (head == null)
0:             return Iterators.<I>emptyIterator();
1: 
1:         return new TreeIterator(head);
1:     }
1: 
1:     @Override
1:     public String toString()
1:     {
1:         return "<" + Joiner.on(", ").join(this) + ">";
1:     }
1: 
1:     @Override
1:     public boolean equals(Object o)
1:     {
1:         if(!(o instanceof IntervalTree))
1:             return false;
1:         IntervalTree that = (IntervalTree)o;
1:         return Iterators.elementsEqual(iterator(), that.iterator());
1:     }
1: 
1:     @Override
1:     public final int hashCode()
1:     {
0:         int result = comparator.hashCode();
1:         for (Interval<C, D> interval : this)
1:             result = 31 * result + interval.hashCode();
1:         return result;
1:     }
1: 
0:     private int comparePoints(C point1, C point2)
1:     {
0:         if (comparator != null)
1:         {
0:             return comparator.compare(point1, point2);
1:         }
1:         else
1:         {
0:             assert point1 instanceof Comparable;
0:             assert point2 instanceof Comparable;
0:             return ((Comparable<C>)point1).compareTo(point2);
1:         }
1:     }
1: 
0:     private boolean encloses(Interval<C, D> enclosing, Interval<C, D> enclosed)
1:     {
0:         return comparePoints(enclosing.min, enclosed.min) <= 0
0:             && comparePoints(enclosing.max, enclosed.max) >= 0;
1:     }
1: 
0:     private boolean contains(Interval<C, D> interval, C point)
1:     {
0:         return comparePoints(interval.min, point) <= 0
0:             && comparePoints(interval.max, point) >= 0;
1:     }
1: 
0:     private boolean intersects(Interval<C, D> interval1, Interval<C, D> interval2)
1:     {
0:         return contains(interval1, interval2.min) || contains(interval1, interval2.max);
1:     }
1: 
1:     private class IntervalNode
1:     {
1:         final C center;
1:         final C low;
1:         final C high;
1: 
1:         final List<I> intersectsLeft;
1:         final List<I> intersectsRight;
1: 
1:         final IntervalNode left;
1:         final IntervalNode right;
1: 
1:         public IntervalNode(Collection<I> toBisect)
1:         {
1:             assert !toBisect.isEmpty();
0:             logger.debug("Creating IntervalNode from {}", toBisect);
1: 
1:             // Building IntervalTree with one interval will be a reasonably
1:             // common case for range tombstones, so it's worth optimizing
1:             if (toBisect.size() == 1)
1:             {
1:                 I interval = toBisect.iterator().next();
1:                 low = interval.min;
1:                 center = interval.max;
1:                 high = interval.max;
1:                 List<I> l = Collections.singletonList(interval);
1:                 intersectsLeft = l;
1:                 intersectsRight = l;
1:                 left = null;
1:                 right = null;
1:             }
1:             else
1:             {
1:                 // Find min, median and max
1:                 List<C> allEndpoints = new ArrayList<C>(toBisect.size() * 2);
1:                 for (I interval : toBisect)
1:                 {
0:                     assert (comparator == null ? ((Comparable)interval.min).compareTo(interval.max)
0:                                                : comparator.compare(interval.min, interval.max)) <= 0 : "Interval min > max";
1:                     allEndpoints.add(interval.min);
1:                     allEndpoints.add(interval.max);
1:                 }
0:                 if (comparator == null)
0:                     Collections.sort(allEndpoints, comparator);
1:                 else
0:                     Collections.sort((List<Comparable>)allEndpoints);
1: 
1:                 low = allEndpoints.get(0);
1:                 center = allEndpoints.get(toBisect.size());
1:                 high = allEndpoints.get(allEndpoints.size() - 1);
1: 
1:                 // Separate interval in intersecting center, left of center and right of center
1:                 List<I> intersects = new ArrayList<I>();
1:                 List<I> leftSegment = new ArrayList<I>();
1:                 List<I> rightSegment = new ArrayList<I>();
1: 
1:                 for (I candidate : toBisect)
1:                 {
0:                     if (comparePoints(candidate.max, center) < 0)
1:                         leftSegment.add(candidate);
0:                     else if (comparePoints(candidate.min, center) > 0)
1:                         rightSegment.add(candidate);
1:                     else
1:                         intersects.add(candidate);
1:                 }
1: 
0:                 intersectsLeft = minOrdering.sortedCopy(intersects);
0:                 intersectsRight = maxOrdering.reverse().sortedCopy(intersects);
1:                 left = leftSegment.isEmpty() ? null : new IntervalNode(leftSegment);
1:                 right = rightSegment.isEmpty() ? null : new IntervalNode(rightSegment);
1: 
1:                 assert (intersects.size() + leftSegment.size() + rightSegment.size()) == toBisect.size() :
1:                         "intersects (" + String.valueOf(intersects.size()) +
1:                         ") + leftSegment (" + String.valueOf(leftSegment.size()) +
1:                         ") + rightSegment (" + String.valueOf(rightSegment.size()) +
1:                         ") != toBisect (" + String.valueOf(toBisect.size()) + ")";
1:             }
1:         }
1: 
1:         void searchInternal(Interval<C, D> searchInterval, List<D> results)
1:         {
0:             if (contains(searchInterval, center))
1:             {
1:                 // Adds every interval contained in this node to the result set then search left and right for further
1:                 // overlapping intervals
1:                 for (Interval<C, D> interval : intersectsLeft)
1:                     results.add(interval.data);
1: 
1:                 if (left != null)
1:                     left.searchInternal(searchInterval, results);
1:                 if (right != null)
1:                     right.searchInternal(searchInterval, results);
1:             }
0:             else if (comparePoints(center, searchInterval.min) < 0)
1:             {
0:                 // Adds intervals i in intersects right as long as i.max >= searchInterval.min
0:                 // then search right
0:                 for (Interval<C, D> interval : intersectsRight)
1:                 {
0:                     if (comparePoints(interval.max, searchInterval.min) >= 0)
1:                         results.add(interval.data);
1:                     else
0:                         break;
1:                 }
1:                 if (right != null)
1:                     right.searchInternal(searchInterval, results);
1:             }
1:             else
1:             {
0:                 assert comparePoints(center, searchInterval.max) > 0;
0:                 // Adds intervals i in intersects left as long as i.min >= searchInterval.max
0:                 // then search left
1:                 for (Interval<C, D> interval : intersectsLeft)
1:                 {
0:                     if (comparePoints(interval.min, searchInterval.max) <= 0)
1:                         results.add(interval.data);
1:                     else
0:                         break;
1:                 }
1:                 if (left != null)
1:                     left.searchInternal(searchInterval, results);
1:             }
1:         }
1:     }
1: 
1:     private class TreeIterator extends AbstractIterator<I>
1:     {
1:         private final Deque<IntervalNode> stack = new ArrayDeque<IntervalNode>();
1:         private Iterator<I> current;
1: 
1:         TreeIterator(IntervalNode node)
1:         {
1:             super();
1:             gotoMinOf(node);
1:         }
1: 
1:         protected I computeNext()
1:         {
0:             if (current != null && current.hasNext())
0:                 return current.next();
1: 
0:             IntervalNode node = stack.pollFirst();
0:             if (node == null)
0:                 return endOfData();
1: 
0:             current = node.intersectsLeft.iterator();
1: 
0:             // We know this is the smaller not returned yet, but before doing
0:             // its parent, we must do everyone on it's right.
0:             gotoMinOf(node.right);
1: 
0:             return computeNext();
1:         }
1: 
1:         private void gotoMinOf(IntervalNode node)
1:         {
1:             while (node != null)
1:             {
1:                 stack.offerFirst(node);
1:                 node = node.left;
1:             }
1: 
1:         }
1:     }
1: 
0:     public static class Serializer<C, D, I extends Interval<C, D>> implements IVersionedSerializer<IntervalTree<C, D, I>>
1:     {
1:         private final ISerializer<C> pointSerializer;
1:         private final ISerializer<D> dataSerializer;
1:         private final Constructor<I> constructor;
1: 
1:         private Serializer(ISerializer<C> pointSerializer, ISerializer<D> dataSerializer, Constructor<I> constructor)
1:         {
1:             this.pointSerializer = pointSerializer;
1:             this.dataSerializer = dataSerializer;
1:             this.constructor = constructor;
1:         }
1: 
0:         public void serialize(IntervalTree<C, D, I> it, DataOutput dos, int version) throws IOException
1:         {
0:             dos.writeInt(it.count);
1:             for (Interval<C, D> interval : it)
1:             {
0:                 pointSerializer.serialize(interval.min, dos);
0:                 pointSerializer.serialize(interval.max, dos);
0:                 dataSerializer.serialize(interval.data, dos);
1:             }
1:         }
1: 
1:         /**
1:          * Deserialize an IntervalTree whose keys use the natural ordering.
1:          * Use deserialize(DataInput, int, Comparator) instead if the interval
1:          * tree is to use a custom comparator, as the comparator is *not*
1:          * serialized.
1:          */
0:         public IntervalTree<C, D, I> deserialize(DataInput dis, int version) throws IOException
1:         {
0:             return deserialize(dis, version, null);
1:         }
1: 
0:         public IntervalTree<C, D, I> deserialize(DataInput dis, int version, Comparator<C> comparator) throws IOException
1:         {
1:             try
1:             {
0:                 int count = dis.readInt();
0:                 List<Interval<C, D>> intervals = new ArrayList<Interval<C, D>>(count);
1:                 for (int i = 0; i < count; i++)
1:                 {
0:                     C min = pointSerializer.deserialize(dis);
0:                     C max = pointSerializer.deserialize(dis);
0:                     D data = dataSerializer.deserialize(dis);
1:                     intervals.add(constructor.newInstance(min, max, data));
1:                 }
0:                 return new IntervalTree(intervals, comparator);
1:             }
0:             catch (InstantiationException e)
1:             {
1:                 throw new RuntimeException(e);
1:             }
0:             catch (InvocationTargetException e)
1:             {
1:                 throw new RuntimeException(e);
1:             }
0:             catch (IllegalAccessException e)
1:             {
1:                 throw new RuntimeException(e);
1:             }
1:         }
1: 
0:         public long serializedSize(IntervalTree<C, D, I> it, TypeSizes typeSizes, int version)
1:         {
0:             long size = typeSizes.sizeof(0);
1:             for (Interval<C, D> interval : it)
1:             {
0:                 size += pointSerializer.serializedSize(interval.min, typeSizes);
0:                 size += pointSerializer.serializedSize(interval.max, typeSizes);
0:                 size += dataSerializer.serializedSize(interval.data, typeSizes);
1:             }
0:             return size;
1:         }
1: 
1:         public long serializedSize(IntervalTree<C, D, I> it, int version)
1:         {
0:             return serializedSize(it, TypeSizes.NATIVE, version);
1:         }
1:     }
1: }
============================================================================