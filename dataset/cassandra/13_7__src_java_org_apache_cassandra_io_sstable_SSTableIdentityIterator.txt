1:ee88039: /*
1:ee88039:  * Licensed to the Apache Software Foundation (ASF) under one
1:ee88039:  * or more contributor license agreements.  See the NOTICE file
1:ee88039:  * distributed with this work for additional information
1:ee88039:  * regarding copyright ownership.  The ASF licenses this file
1:ee88039:  * to you under the Apache License, Version 2.0 (the
1:ee88039:  * "License"); you may not use this file except in compliance
1:ee88039:  * with the License.  You may obtain a copy of the License at
1:07cdfd0:  *
1:07cf56f:  *     http://www.apache.org/licenses/LICENSE-2.0
3:07cdfd0:  *
1:07cf56f:  * Unless required by applicable law or agreed to in writing, software
1:07cf56f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:07cf56f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:07cf56f:  * See the License for the specific language governing permissions and
1:07cf56f:  * limitations under the License.
1:e771943:  */
1:07cf56f: package org.apache.cassandra.io.sstable;
1:1f7628c: 
1:0fe7942: import java.io.*;
1:a991b64: 
1:22fc25b: import org.apache.cassandra.config.CFMetaData;
1:84acd4a: import org.apache.cassandra.db.*;
1:a991b64: import org.apache.cassandra.db.rows.*;
1:0368e97: import org.apache.cassandra.io.sstable.format.SSTableReader;
1:d40ac78: import org.apache.cassandra.io.util.FileDataInput;
1:d389047: import org.apache.cassandra.io.util.RandomAccessReader;
1:d40ac78: import org.apache.cassandra.utils.ByteBufferUtil;
1:4d34917: 
1:d40ac78: public class SSTableIdentityIterator implements Comparable<SSTableIdentityIterator>, UnfilteredRowIterator
1:e771943: {
1:a991b64:     private final SSTableReader sstable;
1:7e4ef1c:     private final DecoratedKey key;
1:a991b64:     private final DeletionTime partitionLevelDeletion;
1:debb15e:     private final String filename;
1:9b10928: 
1:c481e8d:     protected final SSTableSimpleIterator iterator;
1:a991b64:     private final Row staticRow;
1:e771943: 
1:d40ac78:     public SSTableIdentityIterator(SSTableReader sstable, DecoratedKey key, DeletionTime partitionLevelDeletion,
1:d40ac78:             String filename, SSTableSimpleIterator iterator) throws IOException
1:22fc25b:     {
1:d40ac78:         super();
1:9b10928:         this.sstable = sstable;
1:a991b64:         this.key = key;
1:d40ac78:         this.partitionLevelDeletion = partitionLevelDeletion;
1:d40ac78:         this.filename = filename;
1:d40ac78:         this.iterator = iterator;
1:d40ac78:         this.staticRow = iterator.readStaticRow();
1:d40ac78:     }
1:3a005df: 
1:d40ac78:     public static SSTableIdentityIterator create(SSTableReader sstable, RandomAccessReader file, DecoratedKey key)
1:d40ac78:     {
1:9b10928:         try
1:9b10928:         {
1:d40ac78:             DeletionTime partitionLevelDeletion = DeletionTime.serializer.deserialize(file);
1:2457599:             SerializationHelper helper = new SerializationHelper(sstable.metadata, sstable.descriptor.version.correspondingMessagingVersion(), SerializationHelper.Flag.LOCAL);
1:d40ac78:             SSTableSimpleIterator iterator = SSTableSimpleIterator.create(sstable.metadata, file, sstable.header, helper, partitionLevelDeletion);
1:d40ac78:             return new SSTableIdentityIterator(sstable, key, partitionLevelDeletion, file.getPath(), iterator);
1:9b10928:         }
1:0fe7942:         catch (IOException e)
1:9b10928:         {
1:a991b64:             sstable.markSuspect();
1:d40ac78:             throw new CorruptSSTableException(e, file.getPath());
1:d40ac78:         }
1:d40ac78:     }
1:d40ac78: 
1:d40ac78:     public static SSTableIdentityIterator create(SSTableReader sstable, FileDataInput dfile, RowIndexEntry<?> indexEntry, DecoratedKey key, boolean tombstoneOnly)
1:d40ac78:     {
1:d40ac78:         try
1:d40ac78:         {
1:d40ac78:             dfile.seek(indexEntry.position);
1:d40ac78:             ByteBufferUtil.skipShortLength(dfile); // Skip partition key
1:d40ac78:             DeletionTime partitionLevelDeletion = DeletionTime.serializer.deserialize(dfile);
1:d40ac78:             SerializationHelper helper = new SerializationHelper(sstable.metadata, sstable.descriptor.version.correspondingMessagingVersion(), SerializationHelper.Flag.LOCAL);
1:d40ac78:             SSTableSimpleIterator iterator = tombstoneOnly
1:d40ac78:                     ? SSTableSimpleIterator.createTombstoneOnly(sstable.metadata, dfile, sstable.header, helper, partitionLevelDeletion)
1:d40ac78:                     : SSTableSimpleIterator.create(sstable.metadata, dfile, sstable.header, helper, partitionLevelDeletion);
1:d40ac78:             return new SSTableIdentityIterator(sstable, key, partitionLevelDeletion, dfile.getPath(), iterator);
1:d40ac78:         }
1:d40ac78:         catch (IOException e)
1:d40ac78:         {
1:d40ac78:             sstable.markSuspect();
1:d40ac78:             throw new CorruptSSTableException(e, dfile.getPath());
1:9b10928:         }
1:9b10928:     }
1:9b10928: 
1:a991b64:     public CFMetaData metadata()
1:a991b64:     {
1:a991b64:         return sstable.metadata;
1:a991b64:     }
1:a991b64: 
1:a991b64:     public PartitionColumns columns()
1:a991b64:     {
1:a991b64:         return metadata().partitionColumns();
1:a991b64:     }
1:a991b64: 
1:a991b64:     public boolean isReverseOrder()
1:a991b64:     {
1:a991b64:         return false;
1:a991b64:     }
1:a991b64: 
1:a991b64:     public DecoratedKey partitionKey()
1:4e17ac4:     {
1:72854b4:         return key;
1:9b10928:     }
1:22fc25b: 
1:a991b64:     public DeletionTime partitionLevelDeletion()
1:e771943:     {
1:a991b64:         return partitionLevelDeletion;
1:4e17ac4:     }
1:22fc25b: 
1:a991b64:     public Row staticRow()
1:a991b64:     {
1:a991b64:         return staticRow;
1:a991b64:     }
1:a991b64: 
1:d40ac78:     public boolean hasNext()
1:d40ac78:     {
1:d40ac78:         try
1:d40ac78:         {
1:d40ac78:             return iterator.hasNext();
1:d40ac78:         }
1:d40ac78:         catch (IndexOutOfBoundsException e)
1:d40ac78:         {
1:d40ac78:             sstable.markSuspect();
1:d40ac78:             throw new CorruptSSTableException(e, filename);
1:d40ac78:         }
1:d40ac78:         catch (IOError e)
1:d40ac78:         {
1:d40ac78:             if (e.getCause() instanceof IOException)
1:d40ac78:             {
1:d40ac78:                 sstable.markSuspect();
1:d40ac78:                 throw new CorruptSSTableException((Exception)e.getCause(), filename);
1:d40ac78:             }
1:d40ac78:             else
1:d40ac78:             {
1:d40ac78:                 throw e;
1:d40ac78:             }
1:d40ac78:         }
1:d40ac78:     }
1:d40ac78: 
1:d40ac78:     public Unfiltered next()
1:85cc390:     {
1:9b10928:         try
1:9b10928:         {
1:c481e8d:             return doCompute();
1:85cc390:         }
1:85cc390:         catch (IndexOutOfBoundsException e)
1:9b10928:         {
1:85cc390:             sstable.markSuspect();
1:85cc390:             throw new CorruptSSTableException(e, filename);
1:9b10928:         }
1:9b10928:         catch (IOError e)
1:9b10928:         {
1:9b10928:             if (e.getCause() instanceof IOException)
1:9b10928:             {
1:a991b64:                 sstable.markSuspect();
1:a991b64:                 throw new CorruptSSTableException((Exception)e.getCause(), filename);
1:9b10928:             }
1:9b10928:             else
1:e771943:             {
1:9b10928:                 throw e;
1:e771943:             }
1:e771943:         }
1:e771943:     }
1:debb15e: 
1:c481e8d:     protected Unfiltered doCompute()
1:c481e8d:     {
1:d40ac78:         return iterator.next();
1:c481e8d:     }
1:c481e8d: 
1:debb15e:     public void close()
1:e771943:     {
1:72854b4:         // creator is responsible for closing file when finished
1:e771943:     }
1:fbf32ca: 
1:72854b4:     public String getPath()
1:22fc25b:     {
1:a991b64:         return filename;
1:a991b64:     }
1:a991b64: 
1:c055ab9:     public EncodingStats stats()
1:a991b64:     {
1:a991b64:         // We could return sstable.header.stats(), but this may not be as accurate than the actual sstable stats (see
1:a991b64:         // SerializationHeader.make() for details) so we use the latter instead.
1:0d74c3e:         return new EncodingStats(sstable.getMinTimestamp(), sstable.getMinLocalDeletionTime(), sstable.getMinTTL());
1:22fc25b:     }
1:0fe7942: 
1:ee88039:     public int compareTo(SSTableIdentityIterator o)
2:a9bd531:     {
1:ee88039:         return key.compareTo(o.key);
1:22fc25b:     }
2:a9bd531: }
============================================================================
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:d40ac78
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.FileDataInput;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: public class SSTableIdentityIterator implements Comparable<SSTableIdentityIterator>, UnfilteredRowIterator
/////////////////////////////////////////////////////////////////////////
1:     public SSTableIdentityIterator(SSTableReader sstable, DecoratedKey key, DeletionTime partitionLevelDeletion,
1:             String filename, SSTableSimpleIterator iterator) throws IOException
1:         super();
1:         this.partitionLevelDeletion = partitionLevelDeletion;
1:         this.filename = filename;
1:         this.iterator = iterator;
1:         this.staticRow = iterator.readStaticRow();
1:     }
1:     public static SSTableIdentityIterator create(SSTableReader sstable, RandomAccessReader file, DecoratedKey key)
1:     {
1:             DeletionTime partitionLevelDeletion = DeletionTime.serializer.deserialize(file);
1:             SSTableSimpleIterator iterator = SSTableSimpleIterator.create(sstable.metadata, file, sstable.header, helper, partitionLevelDeletion);
1:             return new SSTableIdentityIterator(sstable, key, partitionLevelDeletion, file.getPath(), iterator);
1:             throw new CorruptSSTableException(e, file.getPath());
1:         }
1:     }
1: 
1:     public static SSTableIdentityIterator create(SSTableReader sstable, FileDataInput dfile, RowIndexEntry<?> indexEntry, DecoratedKey key, boolean tombstoneOnly)
1:     {
1:         try
1:         {
1:             dfile.seek(indexEntry.position);
1:             ByteBufferUtil.skipShortLength(dfile); // Skip partition key
1:             DeletionTime partitionLevelDeletion = DeletionTime.serializer.deserialize(dfile);
1:             SerializationHelper helper = new SerializationHelper(sstable.metadata, sstable.descriptor.version.correspondingMessagingVersion(), SerializationHelper.Flag.LOCAL);
1:             SSTableSimpleIterator iterator = tombstoneOnly
1:                     ? SSTableSimpleIterator.createTombstoneOnly(sstable.metadata, dfile, sstable.header, helper, partitionLevelDeletion)
1:                     : SSTableSimpleIterator.create(sstable.metadata, dfile, sstable.header, helper, partitionLevelDeletion);
1:             return new SSTableIdentityIterator(sstable, key, partitionLevelDeletion, dfile.getPath(), iterator);
1:         }
1:         catch (IOException e)
1:         {
1:             sstable.markSuspect();
1:             throw new CorruptSSTableException(e, dfile.getPath());
/////////////////////////////////////////////////////////////////////////
1:     public boolean hasNext()
1:     {
1:         try
1:         {
1:             return iterator.hasNext();
1:         }
1:         catch (IndexOutOfBoundsException e)
1:         {
1:             sstable.markSuspect();
1:             throw new CorruptSSTableException(e, filename);
1:         }
1:         catch (IOError e)
1:         {
1:             if (e.getCause() instanceof IOException)
1:             {
1:                 sstable.markSuspect();
1:                 throw new CorruptSSTableException((Exception)e.getCause(), filename);
1:             }
1:             else
1:             {
1:                 throw e;
1:             }
1:         }
1:     }
1: 
1:     public Unfiltered next()
/////////////////////////////////////////////////////////////////////////
1:         return iterator.next();
author:Alex Petrov
-------------------------------------------------------------------------------
commit:c481e8d
/////////////////////////////////////////////////////////////////////////
1:     protected final SSTableSimpleIterator iterator;
/////////////////////////////////////////////////////////////////////////
1:             return doCompute();
/////////////////////////////////////////////////////////////////////////
1:     protected Unfiltered doCompute()
1:     {
0:         return iterator.hasNext() ? iterator.next() : endOfData();
1:     }
1: 
commit:85cc390
/////////////////////////////////////////////////////////////////////////
1:         catch (IndexOutOfBoundsException e)
1:         {
1:             sstable.markSuspect();
1:             throw new CorruptSSTableException(e, filename);
1:         }
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:0d74c3e
/////////////////////////////////////////////////////////////////////////
1:         return new EncodingStats(sstable.getMinTimestamp(), sstable.getMinLocalDeletionTime(), sstable.getMinTTL());
commit:489a9e8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.AbstractIterator;
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:c055ab9
/////////////////////////////////////////////////////////////////////////
1:     public EncodingStats stats()
0:         return new EncodingStats(sstable.getMinTimestamp(), sstable.getMinLocalDeletionTime(), sstable.getMinTTL(), sstable.getAvgColumnSetPerRow());
commit:2457599
/////////////////////////////////////////////////////////////////////////
1:             SerializationHelper helper = new SerializationHelper(sstable.metadata, sstable.descriptor.version.correspondingMessagingVersion(), SerializationHelper.Flag.LOCAL);
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: 
0: import com.google.common.collect.AbstractIterator;
1: import org.apache.cassandra.db.rows.*;
0: public class SSTableIdentityIterator extends AbstractIterator<Unfiltered> implements Comparable<SSTableIdentityIterator>, UnfilteredRowIterator
1:     private final SSTableReader sstable;
1:     private final DeletionTime partitionLevelDeletion;
0:     private final SSTableSimpleIterator iterator;
1:     private final Row staticRow;
/////////////////////////////////////////////////////////////////////////
0:         this.filename = file.getPath();
1:         this.key = key;
0:             this.partitionLevelDeletion = DeletionTime.serializer.deserialize(file);
0:             SerializationHelper helper = new SerializationHelper(sstable.descriptor.version.correspondingMessagingVersion(), SerializationHelper.Flag.LOCAL);
0:             this.iterator = SSTableSimpleIterator.create(sstable.metadata, file, sstable.header, helper, partitionLevelDeletion);
0:             this.staticRow = iterator.readStaticRow();
1:             sstable.markSuspect();
1:     public CFMetaData metadata()
1:     {
1:         return sstable.metadata;
1:     }
1: 
1:     public PartitionColumns columns()
1:     {
1:         return metadata().partitionColumns();
1:     }
1: 
1:     public boolean isReverseOrder()
1:     {
1:         return false;
1:     }
1: 
1:     public DecoratedKey partitionKey()
1:     public DeletionTime partitionLevelDeletion()
1:         return partitionLevelDeletion;
1:     public Row staticRow()
1:     {
1:         return staticRow;
1:     }
1: 
0:     protected Unfiltered computeNext()
0:             return iterator.hasNext() ? iterator.next() : endOfData();
1:                 sstable.markSuspect();
1:                 throw new CorruptSSTableException((Exception)e.getCause(), filename);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return filename;
1:     }
1: 
0:     public RowStats stats()
1:     {
1:         // We could return sstable.header.stats(), but this may not be as accurate than the actual sstable stats (see
1:         // SerializationHeader.make() for details) so we use the latter instead.
0:         return new RowStats(sstable.getMinTimestamp(), sstable.getMinLocalDeletionTime(), sstable.getMinTTL(), sstable.getAvgColumnSetPerRow());
commit:a30d8bd
commit:c0f96e1
commit:9b10928
/////////////////////////////////////////////////////////////////////////
0:     // Not every SSTableIdentifyIterator is attached to a sstable, so this can be null.
0:     private final SSTableReader sstable;
1: 
/////////////////////////////////////////////////////////////////////////
1:         this.sstable = sstable;
/////////////////////////////////////////////////////////////////////////
1:             {
0:                 if (sstable != null)
0:                     sstable.markSuspect();
1:             }
1:             {
1:             }
/////////////////////////////////////////////////////////////////////////
1:         try
0:             Iterator<OnDiskAtom> iter = cf.metadata().getOnDiskIterator(in, columnCount, flag, expireBefore, dataVersion);
0:             while (iter.hasNext())
0:                 cf.addAtom(iter.next());
1: 
0:             if (validateColumns)
1:                 try
1:                 {
0:                     cf.metadata().validateColumns(cf);
1:                 }
0:                 catch (MarshalException e)
1:                 {
0:                     throw new RuntimeException("Error validating row " + key, e);
1:                 }
0:             return cf;
1:         }
1:         catch (IOError e)
1:         {
0:             // catch here b/c atomIterator is an AbstractIterator; hasNext reads the value
1:             if (e.getCause() instanceof IOException)
0:                 if (sstable != null)
0:                     sstable.markSuspect();
0:                 throw new CorruptSSTableException((IOException)e.getCause(), filename);
1:             }
1:             else
1:             {
1:                 throw e;
commit:8e172c8
/////////////////////////////////////////////////////////////////////////
0:             atomIterator = columnFamily.metadata().getOnDiskIterator(in, flag, expireBefore, dataVersion);
commit:88f65a1
/////////////////////////////////////////////////////////////////////////
0:             columnFamily.delete(DeletionTime.serializer.deserialize(in));
commit:6e81f81
/////////////////////////////////////////////////////////////////////////
0:             columnFamily.delete(DeletionTime.serializer.deserialize(inputWithTracker));
commit:fc8b76f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.serializers.MarshalException;
commit:e9c6742
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.type.MarshalException;
commit:3a005df
/////////////////////////////////////////////////////////////////////////
0: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public final ColumnSerializer.Flag flag;
0:     private final Iterator<OnDiskAtom> atomIterator;
/////////////////////////////////////////////////////////////////////////
0:         this(sstable.metadata, file, file.getPath(), key, dataStart, dataSize, checkData, sstable, ColumnSerializer.Flag.LOCAL);
0:     public SSTableIdentityIterator(CFMetaData metadata, DataInput file, String filename, DecoratedKey key, long dataStart, long dataSize, ColumnSerializer.Flag flag)
/////////////////////////////////////////////////////////////////////////
0:                                     ColumnSerializer.Flag flag)
/////////////////////////////////////////////////////////////////////////
1: 
0:             atomIterator = columnFamily.metadata().getOnDiskIterator(inputWithTracker, columnCount, dataVersion);
/////////////////////////////////////////////////////////////////////////
0:             OnDiskAtom atom = atomIterator.next();
0:         catch (IOError e)
0:             if (e.getCause() instanceof IOException)
0:                 throw new CorruptSSTableException((IOException)e.getCause(), filename);
0:             else
0:                 throw e;
commit:4d34917
/////////////////////////////////////////////////////////////////////////
0:     private final OnDiskAtom.Serializer atomSerializer;
0:     private final Descriptor.Version dataVersion;
1: 
/////////////////////////////////////////////////////////////////////////
0:         this.dataVersion = sstable == null ? Descriptor.Version.CURRENT : sstable.descriptor.version;
/////////////////////////////////////////////////////////////////////////
0:                 if (checkData && !sstable.descriptor.version.hasPromotedIndexes)
0:                         IndexHelper.defreezeBloomFilter(file, dataSize, sstable.descriptor.version.filterType);
/////////////////////////////////////////////////////////////////////////
0:             if (sstable != null && !sstable.descriptor.version.hasPromotedIndexes)
0:             columnFamily.delete(DeletionInfo.serializer().deserializeFromSSTable(inputWithTracker, dataVersion));
0:             atomSerializer = columnFamily.getOnDiskSerializer();
/////////////////////////////////////////////////////////////////////////
0:     public OnDiskAtom next()
0:             OnDiskAtom atom = atomSerializer.deserializeFromSSTable(inputWithTracker, flag, expireBefore, dataVersion);
0:                 atom.validateFields(columnFamily.metadata());
0:             return atom;
/////////////////////////////////////////////////////////////////////////
0:         columnFamily.serializer.deserializeColumnsFromSSTable(inputWithTracker, cf, columnCount, flag, expireBefore, dataVersion);
commit:c5649e0
commit:d4eaf3c
/////////////////////////////////////////////////////////////////////////
0:             if (sstable != null)
0:                 sstable.markSuspect();
commit:65c33fa
/////////////////////////////////////////////////////////////////////////
0:     // Must only be used against current file format
0:     // sstable may be null *if* checkData is false
0:     // If it is null, we assume the data is in the current file format
/////////////////////////////////////////////////////////////////////////
0:             if (sstable != null && !sstable.descriptor.hasPromotedIndexes)
commit:4e17ac4
/////////////////////////////////////////////////////////////////////////
0:                 if (checkData && !sstable.descriptor.hasPromotedIndexes)
/////////////////////////////////////////////////////////////////////////
0:             if (!sstable.descriptor.hasPromotedIndexes)
1:             {
0:                 IndexHelper.skipBloomFilter(inputWithTracker);
0:                 IndexHelper.skipIndex(inputWithTracker);
1:             }
commit:07cdfd0
/////////////////////////////////////////////////////////////////////////
1:  *
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
1:  *
commit:5a6e2b0
/////////////////////////////////////////////////////////////////////////
0:     private final long columnPosition;
0:     private final BytesReadTracker inputWithTracker; // tracks bytes read
commit:07cf56f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1: package org.apache.cassandra.io.sstable;
commit:e029b7d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.IColumnSerializer;
/////////////////////////////////////////////////////////////////////////
0:     public final IColumnSerializer.Flag flag;
/////////////////////////////////////////////////////////////////////////
0:         this(sstable.metadata, file, key, dataStart, dataSize, checkData, sstable, IColumnSerializer.Flag.LOCAL);
0:     public SSTableIdentityIterator(CFMetaData metadata, DataInput file, DecoratedKey<?> key, long dataStart, long dataSize, IColumnSerializer.Flag flag)
0:         this(metadata, file, key, dataStart, dataSize, false, null, flag);
0:     private SSTableIdentityIterator(CFMetaData metadata, DataInput input, DecoratedKey<?> key, long dataStart, long dataSize, boolean checkData, SSTableReader sstable, IColumnSerializer.Flag flag)
/////////////////////////////////////////////////////////////////////////
0:         this.flag = flag;
/////////////////////////////////////////////////////////////////////////
0:             IColumn column = columnFamily.getColumnSerializer().deserialize(inputWithTracker, flag, expireBefore);
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily.serializer().deserializeColumns(inputWithTracker, cf, columnCount, flag);
commit:e771943
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.marshal.MarshalException;
/////////////////////////////////////////////////////////////////////////
0:     private final boolean validateColumns;
1: 
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Used to iterate through the columns of a row.
0:      * @param sstable SSTable we are reading ffrom.
0:      * @param file Reading using this file.
0:      * @param key Key of this row.
0:      * @param dataStart Data for this row starts at this pos.
0:      * @param dataSize length of row data
0:      * @param checkData if true, do its best to deserialize and check the coherence of row data
0:      * @throws IOException
1:      */
0:     public SSTableIdentityIterator(SSTableReader sstable, BufferedRandomAccessFile file, DecoratedKey key, long dataStart, long dataSize, boolean checkData)
0:         this(sstable.metadata, file, key, dataStart, dataSize, checkData, sstable, false);
/////////////////////////////////////////////////////////////////////////
0:     private SSTableIdentityIterator(CFMetaData metadata, BufferedRandomAccessFile file, DecoratedKey key, long dataStart, long dataSize, boolean checkData, SSTableReader sstable, boolean fromRemote)
/////////////////////////////////////////////////////////////////////////
0:         this.validateColumns = checkData;
0:             if (checkData)
/////////////////////////////////////////////////////////////////////////
0:             IColumn column = columnFamily.getColumnSerializer().deserialize(file, null, fromRemote, expireBefore);
0:             if (validateColumns)
0:                 column.validateFields(columnFamily.metadata());
0:             return column;
0:         catch (MarshalException e)
1:         {
0:             throw new IOError(new IOException("Error validating row " + key, e));
1:         }
/////////////////////////////////////////////////////////////////////////
0:         if (validateColumns)
1:         {
0:             try
1:             {
0:                 cf.validateColumnFields();
1:             }
0:             catch (MarshalException e)
1:             {
0:                 throw new IOException("Error validating row " + key, e);
1:             }
1:         }
commit:22fc25b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.CFMetaData;
/////////////////////////////////////////////////////////////////////////
0:     public final boolean fromRemote;
/////////////////////////////////////////////////////////////////////////
0:         this(sstable.metadata, file, key, dataStart, dataSize, deserializeRowHeader, sstable, false);
1:     }
1: 
0:     public SSTableIdentityIterator(CFMetaData metadata, BufferedRandomAccessFile file, DecoratedKey key, long dataStart, long dataSize, boolean fromRemote)
0:     throws IOException
1:     {
0:         this(metadata, file, key, dataStart, dataSize, false, null, fromRemote);
1:     }
1: 
0:     // sstable may be null *if* deserializeRowHeader is false
0:     private SSTableIdentityIterator(CFMetaData metadata, BufferedRandomAccessFile file, DecoratedKey key, long dataStart, long dataSize, boolean deserializeRowHeader, SSTableReader sstable, boolean fromRemote)
0:     throws IOException
1:     {
0:         this.fromRemote = fromRemote;
/////////////////////////////////////////////////////////////////////////
0:             columnFamily = ColumnFamily.create(metadata);
/////////////////////////////////////////////////////////////////////////
0:             return columnFamily.getColumnSerializer().deserialize(file, null, fromRemote, expireBefore);
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily.serializer().deserializeColumns(file, cf, false, fromRemote);
author:Jake Luciani
-------------------------------------------------------------------------------
commit:0368e97
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.DatabaseDescriptor;
1: import org.apache.cassandra.io.sstable.format.SSTableReader;
0: import org.apache.cassandra.io.sstable.format.Version;
0: import org.apache.cassandra.io.util.FileDataInput;
0:     public class SSTableIdentityIterator implements Comparable<SSTableIdentityIterator>, OnDiskAtomIterator
/////////////////////////////////////////////////////////////////////////
0:     public SSTableIdentityIterator(SSTableReader sstable, RandomAccessReader file, DecoratedKey key)
0:         this(sstable, file, key, false);
/////////////////////////////////////////////////////////////////////////
0:     public SSTableIdentityIterator(SSTableReader sstable, RandomAccessReader file, DecoratedKey key, boolean checkData)
0:         this(sstable.metadata, file, file.getPath(), key, checkData, sstable, ColumnSerializer.Flag.LOCAL);
0:                                     FileDataInput in,
/////////////////////////////////////////////////////////////////////////
0:         Version dataVersion = sstable == null ? DatabaseDescriptor.getSSTableFormat().info.getLatestVersion() : sstable.descriptor.version;
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:cf9ae5f
commit:19444ea
/////////////////////////////////////////////////////////////////////////
0:             atomIterator = columnFamily.metadata().getOnDiskIterator(in, columnCount, flag, expireBefore, dataVersion);
commit:5cf381f
/////////////////////////////////////////////////////////////////////////
0:             columnFamily = ArrayBackedSortedColumns.factory.create(metadata);
commit:1f7628c
/////////////////////////////////////////////////////////////////////////
0:         Iterator<OnDiskAtom> iter = cf.metadata().getOnDiskIterator(in, columnCount, flag, expireBefore, dataVersion);
0:         while (iter.hasNext())
0:             cf.addAtom(iter.next());
1: 
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:a9bd531
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.columniterator.OnDiskAtomIterator;
0: public class SSTableIdentityIterator implements Comparable<SSTableIdentityIterator>, OnDiskAtomIterator
0:     private final DataInput in;
0:     public final long dataSize; // we [still] require this so compaction can tell if it's safe to read the row into memory
/////////////////////////////////////////////////////////////////////////
0:     public SSTableIdentityIterator(SSTableReader sstable, RandomAccessReader file, DecoratedKey key, long dataSize)
0:         this(sstable, file, key, dataSize, false);
/////////////////////////////////////////////////////////////////////////
0:     public SSTableIdentityIterator(SSTableReader sstable, RandomAccessReader file, DecoratedKey key, long dataSize, boolean checkData)
0:         this(sstable.metadata, file, file.getPath(), key, dataSize, checkData, sstable, ColumnSerializer.Flag.LOCAL);
0:                                     DataInput in,
0:         this.in = in;
/////////////////////////////////////////////////////////////////////////
0:             columnFamily.delete(DeletionInfo.serializer().deserializeFromSSTable(in, dataVersion));
0:             columnCount = dataVersion.hasRowSizeAndColumnCount ? in.readInt() : Integer.MAX_VALUE;
0:             atomIterator = columnFamily.metadata().getOnDiskIterator(in, columnCount, dataVersion);
/////////////////////////////////////////////////////////////////////////
0:         try
1:         {
0:             return atomIterator.hasNext();
1:         }
0:         catch (IOError e)
1:         {
0:             // catch here b/c atomIterator is an AbstractIterator; hasNext reads the value
0:             if (e.getCause() instanceof IOException)
0:                 throw new CorruptSSTableException((IOException)e.getCause(), filename);
0:             else
0:                 throw e;
1:         }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         if (in instanceof RandomAccessReader)
0:             RandomAccessReader file = (RandomAccessReader) in;
/////////////////////////////////////////////////////////////////////////
0:         columnFamily.serializer.deserializeColumnsFromSSTable(in, cf, columnCount, flag, expireBefore, dataVersion);
/////////////////////////////////////////////////////////////////////////
commit:7f2c3a8
/////////////////////////////////////////////////////////////////////////
commit:c48acd9
commit:302267e
/////////////////////////////////////////////////////////////////////////
0:                         IndexHelper.skipBloomFilter(file);
/////////////////////////////////////////////////////////////////////////
0:                         // skipping the old row-level BF should have left the file position ready to deserialize index
/////////////////////////////////////////////////////////////////////////
0:                 IndexHelper.skipBloomFilter(inputWithTracker);
commit:aa76394
/////////////////////////////////////////////////////////////////////////
0:             columnFamily = EmptyColumns.factory.create(metadata);
/////////////////////////////////////////////////////////////////////////
0:     public ColumnFamily getColumnFamilyWithColumns(ColumnFamily.Factory containerFactory) throws IOException
/////////////////////////////////////////////////////////////////////////
0:                 cf.metadata().validateColumns(cf);
commit:8a1b93d
/////////////////////////////////////////////////////////////////////////
0:     public ColumnFamily getColumnFamilyWithColumns(ISortedColumns.Factory containerFactory) throws IOException
0:         ColumnFamily cf = columnFamily.cloneMeShallow(containerFactory, false);
commit:501d713
/////////////////////////////////////////////////////////////////////////
commit:99605d9
/////////////////////////////////////////////////////////////////////////
commit:debb15e
/////////////////////////////////////////////////////////////////////////
1:     private final String filename;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         this(sstable.metadata, file, file.getPath(), key, dataStart, dataSize, checkData, sstable, IColumnSerializer.Flag.LOCAL);
0:     public SSTableIdentityIterator(CFMetaData metadata, DataInput file, String filename, DecoratedKey key, long dataStart, long dataSize, IColumnSerializer.Flag flag)
0:         this(metadata, file, filename, key, dataStart, dataSize, false, null, flag);
0:     private SSTableIdentityIterator(CFMetaData metadata,
0:                                     DataInput input,
0:                                     String filename,
0:                                     DecoratedKey key,
0:                                     long dataStart,
0:                                     long dataSize,
0:                                     boolean checkData,
0:                                     SSTableReader sstable,
0:                                     IColumnSerializer.Flag flag)
0:         assert !checkData || (sstable != null);
0:         this.filename = filename;
/////////////////////////////////////////////////////////////////////////
1: 
0:                         // deFreeze should have left the file position ready to deserialize index
/////////////////////////////////////////////////////////////////////////
0:             throw new CorruptSSTableException(e, filename);
/////////////////////////////////////////////////////////////////////////
0:             throw new CorruptSSTableException(e, filename);
0:         catch (MarshalException me)
0:             throw new CorruptSSTableException(me, filename);
/////////////////////////////////////////////////////////////////////////
1:     public void close()
/////////////////////////////////////////////////////////////////////////
0:                 throw new RuntimeException("Error validating row " + key, e);
/////////////////////////////////////////////////////////////////////////
0:         file.seek(columnPosition);
commit:5613f8f
commit:7e4ef1c
/////////////////////////////////////////////////////////////////////////
1:     private final DecoratedKey key;
/////////////////////////////////////////////////////////////////////////
0:     public SSTableIdentityIterator(SSTableReader sstable, RandomAccessReader file, DecoratedKey key, long dataStart, long dataSize)
/////////////////////////////////////////////////////////////////////////
0:     public SSTableIdentityIterator(SSTableReader sstable, RandomAccessReader file, DecoratedKey key, long dataStart, long dataSize, boolean checkData)
0:     public SSTableIdentityIterator(CFMetaData metadata, DataInput file, DecoratedKey key, long dataStart, long dataSize, IColumnSerializer.Flag flag)
0:     private SSTableIdentityIterator(CFMetaData metadata, DataInput input, DecoratedKey key, long dataStart, long dataSize, boolean checkData, SSTableReader sstable, IColumnSerializer.Flag flag)
/////////////////////////////////////////////////////////////////////////
0:     public DecoratedKey getKey()
commit:84acd4a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.*;
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = columnFamily.cloneMeShallow(ArrayBackedSortedColumns.factory(), false);
commit:a19f7f1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private final DecoratedKey<?> key;
/////////////////////////////////////////////////////////////////////////
0:     public SSTableIdentityIterator(SSTableReader sstable, RandomAccessReader file, DecoratedKey<?> key, long dataStart, long dataSize)
/////////////////////////////////////////////////////////////////////////
0:     public SSTableIdentityIterator(SSTableReader sstable, RandomAccessReader file, DecoratedKey<?> key, long dataStart, long dataSize, boolean checkData)
0:     public SSTableIdentityIterator(CFMetaData metadata, DataInput file, DecoratedKey<?> key, long dataStart, long dataSize, boolean fromRemote)
0:     private SSTableIdentityIterator(CFMetaData metadata, DataInput input, DecoratedKey<?> key, long dataStart, long dataSize, boolean checkData, SSTableReader sstable, boolean fromRemote)
/////////////////////////////////////////////////////////////////////////
0:     public DecoratedKey<?> getKey()
commit:fbf32ca
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.columniterator.ICountableColumnIterator;
0: public class SSTableIdentityIterator implements Comparable<SSTableIdentityIterator>, ICountableColumnIterator
/////////////////////////////////////////////////////////////////////////
0:     private final int columnCount;
/////////////////////////////////////////////////////////////////////////
1: 
0:     public int getColumnCount()
0:     {
0:         return columnCount;
0:     }
commit:b95a49c
/////////////////////////////////////////////////////////////////////////
0:             IColumn column = columnFamily.getColumnSerializer().deserialize(inputWithTracker, fromRemote, expireBefore);
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily.serializer().deserializeColumns(inputWithTracker, cf, columnCount, fromRemote);
commit:0fe7942
/////////////////////////////////////////////////////////////////////////
1: import java.io.*;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 if (dataStart + dataSize > file.length())
0:                     throw new IOException(String.format("dataSize of %s starting at %s would be larger than file %s length %s",
0:                                           dataSize, dataStart, file.getPath(), file.length()));
/////////////////////////////////////////////////////////////////////////
0:                     inputWithTracker.reset(0);
/////////////////////////////////////////////////////////////////////////
0:             columnPosition = dataStart + inputWithTracker.getBytesRead();
/////////////////////////////////////////////////////////////////////////
0:         return inputWithTracker.getBytesRead() < dataSize;
/////////////////////////////////////////////////////////////////////////
0:         if (!(input instanceof RandomAccessReader))
1: 
0:         ((RandomAccessReader) input).seek(dataStart);
0:         inputWithTracker.reset(0);
0:         while (inputWithTracker.getBytesRead() < dataSize)
0:             out.write(inputWithTracker.readByte());
0:         assert inputWithTracker.getBytesRead() == headerSize();
0:         // since we already read column count, just pass that value and continue deserialization
0:         ColumnFamily.serializer().deserializeColumns(inputWithTracker, cf, columnCount, false, fromRemote);
/////////////////////////////////////////////////////////////////////////
0:     private long headerSize()
0:     {
0:         return columnPosition - dataStart;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         if (!(input instanceof RandomAccessReader))
0: 
0:         RandomAccessReader file = (RandomAccessReader) input;
0:         try
0:         {
0:             file.seek(columnPosition);
1:         catch (IOException e)
0:         {
0:             throw new IOError(e);
0:         }
0:         inputWithTracker.reset(headerSize());
commit:d389047
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.RandomAccessReader;
/////////////////////////////////////////////////////////////////////////
0:     public SSTableIdentityIterator(SSTableReader sstable, RandomAccessReader file, DecoratedKey key, long dataStart, long dataSize)
/////////////////////////////////////////////////////////////////////////
0:     public SSTableIdentityIterator(SSTableReader sstable, RandomAccessReader file, DecoratedKey key, long dataStart, long dataSize, boolean checkData)
/////////////////////////////////////////////////////////////////////////
0:             if (input instanceof RandomAccessReader)
0:                 RandomAccessReader file = (RandomAccessReader) input;
/////////////////////////////////////////////////////////////////////////
0:             if (input instanceof RandomAccessReader)
0:                 RandomAccessReader file = (RandomAccessReader) input;
/////////////////////////////////////////////////////////////////////////
0:         if (input instanceof RandomAccessReader)
0:             RandomAccessReader file = (RandomAccessReader) input;
/////////////////////////////////////////////////////////////////////////
0:         if (input instanceof RandomAccessReader)
0:             RandomAccessReader file = (RandomAccessReader) input;
/////////////////////////////////////////////////////////////////////////
0:         if (input instanceof RandomAccessReader)
0:             RandomAccessReader file = (RandomAccessReader) input;
/////////////////////////////////////////////////////////////////////////
0:         if (input instanceof RandomAccessReader)
0:             RandomAccessReader file = (RandomAccessReader) input;
/////////////////////////////////////////////////////////////////////////
0:         if (input instanceof RandomAccessReader)
0:             RandomAccessReader file = (RandomAccessReader) input;
commit:ed18ee0
/////////////////////////////////////////////////////////////////////////
0: import java.io.DataInput;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.BytesReadTracker;
/////////////////////////////////////////////////////////////////////////
0:     private final DataInput input;
0:     private long columnPosition;
0: 
0:     private BytesReadTracker inputWithTracker; // tracks bytes read
/////////////////////////////////////////////////////////////////////////
0:     public SSTableIdentityIterator(CFMetaData metadata, DataInput file, DecoratedKey key, long dataStart, long dataSize, boolean fromRemote)
0:     private SSTableIdentityIterator(CFMetaData metadata, DataInput input, DecoratedKey key, long dataStart, long dataSize, boolean checkData, SSTableReader sstable, boolean fromRemote)
0:         this.input = input;
0:         this.inputWithTracker = new BytesReadTracker(input);
/////////////////////////////////////////////////////////////////////////
0:             if (input instanceof BufferedRandomAccessFile)
0:                 BufferedRandomAccessFile file = (BufferedRandomAccessFile) input;
0:                 if (checkData)
0:                 {
0:                     try
0:                     {
0:                         IndexHelper.defreezeBloomFilter(file, dataSize, sstable.descriptor.usesOldBloomFilter);
0:                     }
0:                     catch (Exception e)
0:                     {
0:                         if (e instanceof EOFException)
0:                             throw (EOFException) e;
0: 
0:                         logger.debug("Invalid bloom filter in {}; will rebuild it", sstable);
0:                         // deFreeze should have left the file position ready to deserialize index
0:                     }
0:                     try
0:                     {
0:                         IndexHelper.deserializeIndex(file);
0:                     }
0:                     catch (Exception e)
0:                     {
0:                         logger.debug("Invalid row summary in {}; will rebuild it", sstable);
0:                     }
0:                     file.seek(this.dataStart);
0:                 }
0:             IndexHelper.skipBloomFilter(inputWithTracker);
0:             IndexHelper.skipIndex(inputWithTracker);
0:             ColumnFamily.serializer().deserializeFromSSTableNoColumns(columnFamily, inputWithTracker);
0:             columnCount = inputWithTracker.readInt();
0: 
0:             if (input instanceof BufferedRandomAccessFile)
0:             {
0:                 BufferedRandomAccessFile file = (BufferedRandomAccessFile) input;
0:                 columnPosition = file.getFilePointer();
0:             }
/////////////////////////////////////////////////////////////////////////
0:         if (input instanceof BufferedRandomAccessFile)
0:         {
0:             BufferedRandomAccessFile file = (BufferedRandomAccessFile) input;
0:             return file.getFilePointer() < finishedAt;
0:         }
0:         else
0:         {
0:             return inputWithTracker.getBytesRead() < dataSize;
0:         }
0:             IColumn column = columnFamily.getColumnSerializer().deserialize(inputWithTracker, null, fromRemote, expireBefore);
/////////////////////////////////////////////////////////////////////////
0:         // if input is from file, then return that path, otherwise it's from streaming
0:         if (input instanceof BufferedRandomAccessFile)
0:         {
0:             BufferedRandomAccessFile file = (BufferedRandomAccessFile) input;
0:             return file.getPath();
0:         }
0:         else
0:         {
0:             throw new UnsupportedOperationException();
0:         }
0:         // only effective when input is from file
0:         if (input instanceof BufferedRandomAccessFile)
0:             BufferedRandomAccessFile file = (BufferedRandomAccessFile) input;
0:             file.seek(dataStart);
0:             while (file.getFilePointer() < finishedAt)
0:             {
0:                 out.write(file.readByte());
0:             }
0:         }
0:         else
0:         {
0:             throw new UnsupportedOperationException();
0:         if (input instanceof BufferedRandomAccessFile)
0:         {
0:             BufferedRandomAccessFile file = (BufferedRandomAccessFile) input;
0:             file.seek(columnPosition - 4); // seek to before column count int
0:             ColumnFamily.serializer().deserializeColumns(inputWithTracker, cf, false, fromRemote);
0:         }
0:         else
0:         {
0:             // since we already read column count, just pass that value and continue deserialization
0:             ColumnFamily.serializer().deserializeColumns(inputWithTracker, cf, columnCount, false, fromRemote);
0:         }
/////////////////////////////////////////////////////////////////////////
0:         // only effective when input is from file
0:         if (input instanceof BufferedRandomAccessFile)
0:             BufferedRandomAccessFile file = (BufferedRandomAccessFile) input;
0:             try
0:             {
0:                 file.seek(columnPosition);
0:             }
0:             catch (IOException e)
0:             {
0:                 throw new IOError(e);
0:             }
0:             inputWithTracker.reset();
0:         else
0:             throw new UnsupportedOperationException();
commit:f9259e4
commit:09a2667
/////////////////////////////////////////////////////////////////////////
0:     // Used by lazilyCompactedRow, so that we see the same things when deserializing the first and second time
0:     private final int expireBefore;
0: 
/////////////////////////////////////////////////////////////////////////
0:         this.expireBefore = (int)(System.currentTimeMillis() / 1000);
/////////////////////////////////////////////////////////////////////////
0:             return sstable.getColumnSerializer().deserialize(file, expireBefore);
commit:8863168
commit:fc4502a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.Filter;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public SSTableIdentityIterator(SSTableReader sstable, BufferedRandomAccessFile file, DecoratedKey key, long dataStart, long dataSize)
0:         this(sstable, file, key, dataStart, dataSize, false);
0:     public SSTableIdentityIterator(SSTableReader sstable, BufferedRandomAccessFile file, DecoratedKey key, long dataStart, long dataSize, boolean deserializeRowHeader)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             return sstable.getColumnSerializer().deserialize(file);
/////////////////////////////////////////////////////////////////////////
0:     public void echoData(DataOutput out) throws IOException
0:         while (file.getFilePointer() < finishedAt)
0:             out.write(file.readByte());
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily.serializer().deserializeColumns(file, cf);
/////////////////////////////////////////////////////////////////////////
commit:fad6615
commit:8097545
/////////////////////////////////////////////////////////////////////////
0: import java.io.EOFException;
/////////////////////////////////////////////////////////////////////////
0:                     IndexHelper.defreezeBloomFilter(file, dataSize, sstable.descriptor.usesOldBloomFilter);
0:                     if (e instanceof EOFException)
0:                         throw (EOFException) e;
0: 
0:                     logger.debug("Invalid bloom filter in {}; will rebuild it", sstable);
/////////////////////////////////////////////////////////////////////////
0:                     logger.debug("Invalid row summary in {}; will rebuild it", sstable);
commit:c280e20
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
0: 
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
0: import org.apache.cassandra.utils.Filter;
0:     private static final Logger logger = LoggerFactory.getLogger(SSTableIdentityIterator.class);
0: 
/////////////////////////////////////////////////////////////////////////
0:         this(sstable, file, key, dataStart, dataSize, false);
0:     }
0: 
0:     public SSTableIdentityIterator(SSTableReader sstable, BufferedRandomAccessFile file, DecoratedKey key, long dataStart, long dataSize, boolean deserializeRowHeader)
0:     throws IOException
0:     {
/////////////////////////////////////////////////////////////////////////
0:             if (deserializeRowHeader)
0:             {
0:                 try
0:                 {
0:                     IndexHelper.defreezeBloomFilter(file, sstable.descriptor.usesOldBloomFilter);
0:                 }
0:                 catch (Exception e)
0:                 {
0:                     logger.info("Invalid bloom filter in " + sstable + "; will rebuild it");
0:                     // deFreeze should have left the file position ready to deserialize index
0:                 }
0:                 try
0:                 {
0:                     IndexHelper.deserializeIndex(file);
0:                 }
0:                 catch (Exception e)
0:                 {
0:                     logger.info("Invalid row summary in " + sstable + "; will rebuild it");
0:                 }
0:                 file.seek(this.dataStart);
0:             }
0: 
commit:f840e42
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily.serializer().deserializeColumns(file, cf, false);
commit:e98eb1c
/////////////////////////////////////////////////////////////////////////
0: import java.io.DataOutput;
0: import java.io.IOError;
0: import java.io.IOException;
commit:ef25537
/////////////////////////////////////////////////////////////////////////
0: import java.io.DataOutput;
0: import java.io.IOError;
0: import java.io.IOException;
commit:ca9c207
/////////////////////////////////////////////////////////////////////////
0:     public final SSTableReader sstable;
0:     public final long dataSize;
0:     public final int columnCount;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:4dd8fa5
/////////////////////////////////////////////////////////////////////////
0:     public SSTableReader getSSTable()
0:     {
0:         return sstable;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0: }
commit:dee977a
/////////////////////////////////////////////////////////////////////////
0:             columnFamily = sstable.createColumnFamily();
commit:91e4b65
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.columniterator.IColumnIterator;
commit:72854b4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private final SSTableReader sstable;
0:     private final long dataStart;
0:     private final ColumnFamily columnFamily;
0:     private final int columnCount;
0:     private final long columnPosition;
0: 
/////////////////////////////////////////////////////////////////////////
0:             file.seek(this.dataStart);
0:             columnFamily = sstable.makeColumnFamily();
0:             ColumnFamily.serializer().deserializeFromSSTableNoColumns(columnFamily, file);
0:             columnCount = file.readInt();
0:             columnPosition = file.getFilePointer();
/////////////////////////////////////////////////////////////////////////
0:     public DecoratedKey getKey()
1:         return key;
0:     }
0: 
0:     public ColumnFamily getColumnFamily()
0:     {
0:         return columnFamily;
/////////////////////////////////////////////////////////////////////////
0:     public void close() throws IOException
0:     {
1:         // creator is responsible for closing file when finished
0:     }
0: 
1:     public String getPath()
0:     {
0:         return file.getPath();
0:     }
0: 
0:     public long getDataSize()
0:     {
0:         return dataSize;
0:     }
0: 
0:     public void echoData(DataOutput out) throws IOException
0:     {
0:         file.seek(dataStart);
0:         while (file.getFilePointer() < finishedAt)
0:         {
0:             out.write(file.readByte());
0:         }
0:     }
0: 
0:     public int getColumnCount()
0:     {
0:         return columnCount;
0:     }
0: 
0:     public ColumnFamily getColumnFamilyWithColumns() throws IOException
0:     {
0:         file.seek(columnPosition - 4); // seek to before column count int
0:         ColumnFamily cf = columnFamily.cloneMeShallow();
0:         ColumnFamily.serializer().deserializeColumns(file, cf);
0:         return cf;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         try
0:         {
0:             file.seek(columnPosition);
0:         }
0:         catch (IOException e)
0:         {
0:             throw new IOError(e);
0:         }
commit:9c06e53
/////////////////////////////////////////////////////////////////////////
0:     private final long dataSize;
/////////////////////////////////////////////////////////////////////////
0:     public SSTableIdentityIterator(SSTableReader sstable, BufferedRandomAccessFile file, DecoratedKey key, long dataStart, long dataSize)
/////////////////////////////////////////////////////////////////////////
0:     public long getDataSize()
commit:35db73c
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
0: public class SSTableIdentityIterator implements Comparable<SSTableIdentityIterator>, IColumnIterator
0:     private final int dataSize;
/////////////////////////////////////////////////////////////////////////
0:      * @param dataSize length of row data
0:     public SSTableIdentityIterator(SSTableReader sstable, BufferedRandomAccessFile file, DecoratedKey key, long dataStart, int dataSize)
0:         this.dataSize = dataSize;
0:         finishedAt = dataStart + dataSize;
/////////////////////////////////////////////////////////////////////////
0:     public int getDataSize()
0:     {
0:         return dataSize;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     public ColumnFamily getColumnFamily()
0:         ColumnFamily cf;
0:             file.seek(dataStart);
0:             IndexHelper.skipBloomFilter(file);
0:             IndexHelper.skipIndex(file);
0:             cf = sstable.makeColumnFamily();
0:             ColumnFamily.serializer().deserializeFromSSTableNoColumns(cf, file);
0: 
0:         return cf;
0:     }
0: 
0:     public int getColumnCount()
0:     {
0:         getColumnFamily(); // skips to column count
0:         try
0:         {
0:             return file.readInt();
0:         }
0:         catch (IOException e)
0:         {
0:             throw new IOError(e);
0:         }
0:     }
0: 
0:     public ColumnFamily getColumnFamilyWithColumns() throws IOException
0:     {
0:         ColumnFamily cf = getColumnFamily();
0:         ColumnFamily.serializer().deserializeColumns(file, cf);
0:         return cf;
0:     }
0: 
0:     public boolean hasNext()
0:     {
0:         return file.getFilePointer() < finishedAt;
0:     }
0: 
0:     public IColumn next()
0:     {
0:         try
0:         {
0:             return sstable.getColumnSerializer().deserialize(file);
0:         }
0:         catch (IOException e)
0:         {
0:             throw new IOError(e);
0:         }
0:     }
0: 
0:     public void remove()
0:     {
0:         throw new UnsupportedOperationException();
/////////////////////////////////////////////////////////////////////////
0:     public void reset()
0:     {
0:         getColumnCount();
0:     }
0: 
commit:ee88039
/////////////////////////////////////////////////////////////////////////
0: package org.apache.cassandra.io.sstable;
1: /*
0:  * 
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
0:  * 
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  * 
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  * 
0:  */
0: 
0: 
0: import java.io.*;
0: 
0: import org.apache.cassandra.db.ColumnFamily;
0: import org.apache.cassandra.db.DecoratedKey;
0: import org.apache.cassandra.db.IColumn;
0: import org.apache.cassandra.db.filter.IColumnIterator;
0: import org.apache.cassandra.io.util.BufferedRandomAccessFile;
0: 
0: import com.google.common.collect.AbstractIterator;
0: 
0: public class SSTableIdentityIterator extends AbstractIterator<IColumn> implements Comparable<SSTableIdentityIterator>, IColumnIterator
0: {
0:     private final DecoratedKey key;
0:     private final long finishedAt;
0:     private final BufferedRandomAccessFile file;
0:     private SSTableReader sstable;
0:     private long dataStart;
0: 
0:     /**
0:      * Used to iterate through the columns of a row.
0:      * @param sstable SSTable we are reading ffrom.
0:      * @param file Reading using this file.
0:      * @param key Key of this row.
0:      * @param dataStart Data for this row starts at this pos.
0:      * @param finishedAt Data for this row ends at this pos.
0:      * @throws IOException
0:      */
0:     public SSTableIdentityIterator(SSTableReader sstable, BufferedRandomAccessFile file, DecoratedKey key, long dataStart, long finishedAt)
0:     throws IOException
0:     {
0:         this.sstable = sstable;
0:         this.file = file;
0:         this.key = key;
0:         this.dataStart = dataStart;
0:         this.finishedAt = finishedAt;
0:     }
0: 
0:     public DecoratedKey getKey()
0:     {
0:         return key;
0:     }
0: 
0:     public String getPath()
0:     {
0:         return file.getPath();
0:     }
0: 
0:     public void echoData(DataOutput out) throws IOException
0:     {
0:         file.seek(dataStart);
0:         while (file.getFilePointer() < finishedAt)
0:         {
0:             out.write(file.readByte());
0:         }
0:     }
0: 
0:     // TODO r/m this and make compaction merge columns iteratively for CASSSANDRA-16
0:     public ColumnFamily getColumnFamily() throws IOException
0:     {
0:         file.seek(dataStart);
0:         IndexHelper.skipBloomFilter(file);
0:         IndexHelper.skipIndex(file);
0:         return ColumnFamily.serializer().deserializeFromSSTable(sstable, file);
0:     }
0: 
0:     protected IColumn computeNext()
0:     {
0:         try
0:         {
0:             assert file.getFilePointer() <= finishedAt;
0:             if (file.getFilePointer() == finishedAt)
0:             {
0:                 return endOfData();
0:             }
0: 
0:             return sstable.getColumnSerializer().deserialize(file);
0:         }
0:         catch (IOException e)
0:         {
0:             throw new RuntimeException(e);
0:         }
0:     }
0: 
1:     public int compareTo(SSTableIdentityIterator o)
0:     {
1:         return key.compareTo(o.key);
0:     }
0: 
0:     public void close() throws IOException
0:     {
0:     }
0: }
author:Dave Brosius
-------------------------------------------------------------------------------
commit:f1c9bc6
/////////////////////////////////////////////////////////////////////////
0:     public ColumnFamily getColumnFamilyWithColumns(ColumnFamily.Factory containerFactory)
commit:56f35db
/////////////////////////////////////////////////////////////////////////
author:Jason Brown
-------------------------------------------------------------------------------
commit:2130633
/////////////////////////////////////////////////////////////////////////
0:                         IndexHelper.skipSSTableBloomFilter(file, sstable.descriptor.version);
/////////////////////////////////////////////////////////////////////////
0:                 IndexHelper.skipSSTableBloomFilter(inputWithTracker, dataVersion);
commit:4c28cfb
/////////////////////////////////////////////////////////////////////////
0:                         IndexHelper.skipSSTableBloomFilter(file, dataVersion);
/////////////////////////////////////////////////////////////////////////
0:                 IndexHelper.skipSSTableBloomFilter(inputWithTracker, dataVersion);
commit:ae1f7be
commit:4f75875
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.FilterFactory;
/////////////////////////////////////////////////////////////////////////
0:                 if (checkData && !dataVersion.hasPromotedIndexes)
0:                         IndexHelper.defreezeBloomFilter(file, dataSize, dataVersion.filterType);
/////////////////////////////////////////////////////////////////////////
0:             if (sstable != null && !dataVersion.hasPromotedIndexes)
0:                 IndexHelper.skipBloomFilter(inputWithTracker, dataVersion.filterType);
commit:9297e7b
/////////////////////////////////////////////////////////////////////////
0:                         IndexHelper.skipBloomFilter(file);
/////////////////////////////////////////////////////////////////////////
0:                         // skipping the old row-level BF should have left the file position ready to deserialize index
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:587cb58
/////////////////////////////////////////////////////////////////////////
0:             ColumnFamily.serializer.deserializeFromSSTableNoColumns(columnFamily, inputWithTracker);
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily.serializer.deserializeColumns(inputWithTracker, cf, columnCount, flag);
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:d765b24
/////////////////////////////////////////////////////////////////////////
0:                         IndexHelper.defreezeBloomFilter(file, dataSize, sstable.descriptor.filterType);
commit:be7cbc8
commit:9483e14
/////////////////////////////////////////////////////////////////////////
0:             sstable.markSuspect();
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:ab5a8c7
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily.serializer().deserializeColumns(file, cf, false, false);
commit:c44cd01
commit:7ed395d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.util.PageCacheInformer;
0: import org.apache.cassandra.utils.PageCacheMetrics;
/////////////////////////////////////////////////////////////////////////
0:     public final PageCacheMetrics pageCacheMetrics;
0:     private boolean hasRowsInPageCache;
0:     private boolean hasColumnsInPageCache;
/////////////////////////////////////////////////////////////////////////
0:     public SSTableIdentityIterator(SSTableReader sstable, BufferedRandomAccessFile file, DecoratedKey key, long dataStart, long dataSize, PageCacheMetrics pageCacheMetrics)
0:         this(sstable, file, key, dataStart, dataSize, pageCacheMetrics, false);
0:     public SSTableIdentityIterator(SSTableReader sstable, BufferedRandomAccessFile file, DecoratedKey key, long dataStart, long dataSize, PageCacheMetrics pageCacheMetrics, boolean deserializeRowHeader)
/////////////////////////////////////////////////////////////////////////
0:         this.pageCacheMetrics = pageCacheMetrics;
0: 
0:         //Mark if any rows are in the pageCache
0:         hasRowsInPageCache = (pageCacheMetrics != null) && pageCacheMetrics.isRangeInCache(dataStart, finishedAt);
/////////////////////////////////////////////////////////////////////////
0:             long columnStartAt = file.getFilePointer();
0: 
0:             IColumn col = sstable.getColumnSerializer().deserialize(file);
0: 
0:             long columnEndAt = file.getFilePointer();
0: 
0:             if (pageCacheMetrics != null)
0:             {
0:                 col.setIsInPageCache(pageCacheMetrics.isRangeInCache(columnStartAt, columnEndAt));
0:             }
0: 
0:             return col;
0: 
/////////////////////////////////////////////////////////////////////////
0:     public void echoData(PageCacheInformer out) throws IOException
0: 
0:         if (pageCacheMetrics == null)
0:             while (file.getFilePointer() < finishedAt)
0:             {
0:                 out.write(file.readByte());
0:             }
0:         }
0:         else
0:         {
0:             // Since this is just a big opaque block of data we
0:             // Split into chunks >= pageSize
0:             int chunkSize = (int) (finishedAt - dataStart) / 128;
0: 
0:             chunkSize = chunkSize >= pageCacheMetrics.pageSize ? chunkSize : pageCacheMetrics.pageSize;
0: 
0:             long chunkStart = 0;
0:             long chunkEnd = 0;
0:             boolean isChunkInPageCache = false;
0: 
0:             while (file.getFilePointer() < finishedAt)
0:             {
0: 
0:                 // Mark chunks that have cached pages
0:                 // So we can migrate them
0:                 if (file.getFilePointer() >= chunkEnd)
0:                 {
0:                     if (isChunkInPageCache)
0:                     {
0:                         out.keepCacheWindow(out.getCurrentPosition() - chunkSize);
0:                     }
0: 
0:                     chunkStart = file.getFilePointer();
0:                     chunkEnd = chunkStart + chunkSize;
0: 
0:                     if(chunkEnd > finishedAt)
0:                         chunkEnd = finishedAt;
0: 
0:                     isChunkInPageCache = pageCacheMetrics.isRangeInCache(chunkStart, chunkEnd);
0:                 }
0: 
0: 
0:                 out.write(file.readByte());
0:             }
0: 
0:             if (isChunkInPageCache)
0:                 out.keepCacheWindow(out.getCurrentPosition() - (file.getFilePointer() - chunkStart));
/////////////////////////////////////////////////////////////////////////
0: 
0:         hasColumnsInPageCache = ColumnFamily.serializer().deserializeColumns(file, cf, pageCacheMetrics);
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:     public boolean hasRowsInPageCache()
0:     {
0:         return hasRowsInPageCache;
0:     }
0: 
0:     public boolean hasColumnsInPageCache()
0:     {
0:         return hasColumnsInPageCache;
0:     }
0: 
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:4e11242
============================================================================