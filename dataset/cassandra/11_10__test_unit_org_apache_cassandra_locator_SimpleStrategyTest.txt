1:88edbed: /*
1:a991b64:  * Licensed to the Apache Software Foundation (ASF) under one
1:a991b64:  * or more contributor license agreements.  See the NOTICE file
1:a991b64:  * distributed with this work for additional information
1:a991b64:  * regarding copyright ownership.  The ASF licenses this file
1:a991b64:  * to you under the Apache License, Version 2.0 (the
1:a991b64:  * "License"); you may not use this file except in compliance
1:a991b64:  * with the License.  You may obtain a copy of the License at
1:a991b64:  *
1:a991b64:  *     http://www.apache.org/licenses/LICENSE-2.0
1:a991b64:  *
1:a991b64:  * Unless required by applicable law or agreed to in writing, software
1:a991b64:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a991b64:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a991b64:  * See the License for the specific language governing permissions and
1:a991b64:  * limitations under the License.
1:a991b64:  */
1:296e15b: package org.apache.cassandra.locator;
1:d8755b3: 
1:b767bf7: import java.net.InetAddress;
1:b767bf7: import java.net.UnknownHostException;
1:34e241a: import java.util.ArrayList;
1:34e241a: import java.util.Collection;
1:34e241a: import java.util.HashSet;
1:34e241a: import java.util.List;
1:34e241a: 
1:d2a3827: import org.junit.BeforeClass;
1:34e241a: import org.junit.Test;
1:34e241a: 
1:438acfc: import org.apache.cassandra.SchemaLoader;
1:d2a3827: import org.apache.cassandra.config.Schema;
1:0e96e58: import org.apache.cassandra.db.Keyspace;
1:a991b64: import org.apache.cassandra.dht.IPartitioner;
1:a991b64: import org.apache.cassandra.dht.OrderPreservingPartitioner;
1:07893d7: import org.apache.cassandra.dht.OrderPreservingPartitioner.StringToken;
1:a991b64: import org.apache.cassandra.dht.RandomPartitioner.BigIntegerToken;
1:a991b64: import org.apache.cassandra.dht.Token;
1:a89597d: import org.apache.cassandra.schema.KeyspaceMetadata;
1:31e3f61: import org.apache.cassandra.schema.KeyspaceParams;
1:d2a3827: import org.apache.cassandra.service.PendingRangeCalculatorService;
1:34e241a: import org.apache.cassandra.service.StorageServiceAccessor;
1:b62b0ae: import org.apache.cassandra.utils.ByteBufferUtil;
1:a9e3fa1: 
1:a991b64: import static org.junit.Assert.assertEquals;
1:a991b64: import static org.junit.Assert.assertFalse;
1:a991b64: import static org.junit.Assert.assertTrue;
1:5d44703: 
1:d2a3827: public class SimpleStrategyTest
1:296e15b: {
1:d2a3827:     public static final String KEYSPACE1 = "SimpleStrategyTest";
1:d2a3827: 
1:d2a3827:     @BeforeClass
1:d2a3827:     public static void defineSchema() throws Exception
1:d2a3827:     {
1:d2a3827:         SchemaLoader.prepareServer();
1:31e3f61:         SchemaLoader.createKeyspace(KEYSPACE1, KeyspaceParams.simple(1));
1:d2a3827:     }
1:07cdfd0: 
1:296e15b:     @Test
1:0e96e58:     public void tryValidKeyspace()
1:00554e9:     {
1:d2a3827:         assert Keyspace.open(KEYSPACE1).getReplicationStrategy() != null;
1:00554e9:     }
1:d2a3827: 
1:3577fd8:     @Test
1:9639f95:     public void testBigIntegerEndpoints() throws UnknownHostException
1:847f3b0:     {
1:18b2a16:         List<Token> endpointTokens = new ArrayList<Token>();
1:296e15b:         List<Token> keyTokens = new ArrayList<Token>();
1:296e15b:         for (int i = 0; i < 5; i++) {
1:18b2a16:             endpointTokens.add(new BigIntegerToken(String.valueOf(10 * i)));
1:296e15b:             keyTokens.add(new BigIntegerToken(String.valueOf(10 * i + 5)));
1:296e15b:         }
1:df8a933:         verifyGetNaturalEndpoints(endpointTokens.toArray(new Token[0]), keyTokens.toArray(new Token[0]));
1:296e15b:     }
1:00554e9: 
1:296e15b:     @Test
1:9639f95:     public void testStringEndpoints() throws UnknownHostException
1:296e15b:     {
1:07893d7:         IPartitioner partitioner = OrderPreservingPartitioner.instance;
1:847f3b0: 
1:18b2a16:         List<Token> endpointTokens = new ArrayList<Token>();
1:296e15b:         List<Token> keyTokens = new ArrayList<Token>();
1:296e15b:         for (int i = 0; i < 5; i++) {
1:18b2a16:             endpointTokens.add(new StringToken(String.valueOf((char)('a' + i * 2))));
1:a991b64:             keyTokens.add(partitioner.getToken(ByteBufferUtil.bytes(String.valueOf((char) ('a' + i * 2 + 1)))));
1:296e15b:         }
1:df8a933:         verifyGetNaturalEndpoints(endpointTokens.toArray(new Token[0]), keyTokens.toArray(new Token[0]));
1:296e15b:     }
1:847f3b0: 
1:296e15b:     // given a list of endpoint tokens, and a set of key tokens falling between the endpoint tokens,
1:296e15b:     // make sure that the Strategy picks the right endpoints for the keys.
1:9639f95:     private void verifyGetNaturalEndpoints(Token[] endpointTokens, Token[] keyTokens) throws UnknownHostException
1:296e15b:     {
1:df8a933:         TokenMetadata tmd;
1:df8a933:         AbstractReplicationStrategy strategy;
1:a4e1182:         for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces())
1:296e15b:         {
1:df8a933:             tmd = new TokenMetadata();
1:0e96e58:             strategy = getStrategy(keyspaceName, tmd);
1:34e241a:             List<InetAddress> hosts = new ArrayList<InetAddress>();
1:34e241a:             for (int i = 0; i < endpointTokens.length; i++)
1:296e15b:             {
1:34e241a:                 InetAddress ep = InetAddress.getByName("127.0.0." + String.valueOf(i + 1));
1:34e241a:                 tmd.updateNormalToken(endpointTokens[i], ep);
1:34e241a:                 hosts.add(ep);
1:34e241a:             }
1:34e241a: 
1:34e241a:             for (int i = 0; i < keyTokens.length; i++)
1:34e241a:             {
1:df8a933:                 List<InetAddress> endpoints = strategy.getNaturalEndpoints(keyTokens[i]);
1:2f5f0c2:                 assertEquals(strategy.getReplicationFactor(), endpoints.size());
1:34e241a:                 List<InetAddress> correctEndpoints = new ArrayList<InetAddress>();
1:34e241a:                 for (int j = 0; j < endpoints.size(); j++)
1:34e241a:                     correctEndpoints.add(hosts.get((i + j + 1) % hosts.size()));
1:34e241a:                 assertEquals(new HashSet<InetAddress>(correctEndpoints), new HashSet<InetAddress>(endpoints));
1:296e15b:             }
1:296e15b:         }
2:df8a933:     }
1:c10813c: 
1:847f3b0:     @Test
1:9639f95:     public void testGetEndpointsDuringBootstrap() throws UnknownHostException
1:847f3b0:     {
1:3577fd8:         // the token difference will be RING_SIZE * 2.
1:3577fd8:         final int RING_SIZE = 10;
1:847f3b0:         TokenMetadata tmd = new TokenMetadata();
1:3577fd8:         TokenMetadata oldTmd = StorageServiceAccessor.setTokenMetadata(tmd);
1:847f3b0: 
1:18b2a16:         Token[] endpointTokens = new Token[RING_SIZE];
1:3577fd8:         Token[] keyTokens = new Token[RING_SIZE];
1:07cdfd0: 
1:3577fd8:         for (int i = 0; i < RING_SIZE; i++)
1:847f3b0:         {
1:18b2a16:             endpointTokens[i] = new BigIntegerToken(String.valueOf(RING_SIZE * 2 * i));
1:3577fd8:             keyTokens[i] = new BigIntegerToken(String.valueOf(RING_SIZE * 2 * i + RING_SIZE));
1:847f3b0:         }
1:07cdfd0: 
1:b767bf7:         List<InetAddress> hosts = new ArrayList<InetAddress>();
1:18b2a16:         for (int i = 0; i < endpointTokens.length; i++)
1:847f3b0:         {
1:b767bf7:             InetAddress ep = InetAddress.getByName("127.0.0." + String.valueOf(i + 1));
1:18b2a16:             tmd.updateNormalToken(endpointTokens[i], ep);
1:847f3b0:             hosts.add(ep);
1:847f3b0:         }
1:847f3b0: 
1:3577fd8:         // bootstrap at the end of the ring
1:3577fd8:         Token bsToken = new BigIntegerToken(String.valueOf(210));
1:18b2a16:         InetAddress bootstrapEndpoint = InetAddress.getByName("127.0.0.11");
1:18b2a16:         tmd.addBootstrapToken(bsToken, bootstrapEndpoint);
1:847f3b0: 
1:df8a933:         AbstractReplicationStrategy strategy = null;
1:a4e1182:         for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces())
1:847f3b0:         {
1:0e96e58:             strategy = getStrategy(keyspaceName, tmd);
1:847f3b0: 
1:1475d92:             PendingRangeCalculatorService.calculatePendingRanges(strategy, keyspaceName);
1:847f3b0: 
1:2f5f0c2:             int replicationFactor = strategy.getReplicationFactor();
1:847f3b0: 
1:847f3b0:             for (int i = 0; i < keyTokens.length; i++)
1:296e15b:             {
1:0e96e58:                 Collection<InetAddress> endpoints = tmd.getWriteEndpoints(keyTokens[i], keyspaceName, strategy.getNaturalEndpoints(keyTokens[i]));
1:18b2a16:                 assertTrue(endpoints.size() >= replicationFactor);
5:296e15b: 
1:3577fd8:                 for (int j = 0; j < replicationFactor; j++)
1:296e15b:                 {
1:847f3b0:                     //Check that the old nodes are definitely included
1:18b2a16:                     assertTrue(endpoints.contains(hosts.get((i + j + 1) % hosts.size())));
1:847f3b0:                 }
1:296e15b: 
1:18b2a16:                 // bootstrapEndpoint should be in the endpoints for i in MAX-RF to MAX, but not in any earlier ep.
1:3577fd8:                 if (i < RING_SIZE - replicationFactor)
1:18b2a16:                     assertFalse(endpoints.contains(bootstrapEndpoint));
1:c10813c:                 else
1:18b2a16:                     assertTrue(endpoints.contains(bootstrapEndpoint));
1:847f3b0:             }
1:847f3b0:         }
1:296e15b: 
1:3577fd8:         StorageServiceAccessor.setTokenMetadata(oldTmd);
1:296e15b:     }
1:296e15b: 
1:9639f95:     private AbstractReplicationStrategy getStrategy(String keyspaceName, TokenMetadata tmd)
2:df8a933:     {
1:a89597d:         KeyspaceMetadata ksmd = Schema.instance.getKSMetaData(keyspaceName);
2:df8a933:         return AbstractReplicationStrategy.createReplicationStrategy(
1:0e96e58:                                                                     keyspaceName,
1:31e3f61:                                                                     ksmd.params.replication.klass,
1:a991b64:                                                                     tmd,
1:a991b64:                                                                     new SimpleSnitch(),
1:31e3f61:                                                                     ksmd.params.replication.options);
1:296e15b:     }
1:296e15b: }
============================================================================
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:a4e1182
/////////////////////////////////////////////////////////////////////////
1:         for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces())
/////////////////////////////////////////////////////////////////////////
1:         for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces())
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:a89597d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.schema.KeyspaceMetadata;
/////////////////////////////////////////////////////////////////////////
1:         KeyspaceMetadata ksmd = Schema.instance.getKSMetaData(keyspaceName);
commit:31e3f61
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.schema.KeyspaceParams;
/////////////////////////////////////////////////////////////////////////
1:         SchemaLoader.createKeyspace(KEYSPACE1, KeyspaceParams.simple(1));
/////////////////////////////////////////////////////////////////////////
1:                                                                     ksmd.params.replication.klass,
1:                                                                     ksmd.params.replication.options);
commit:0e96e58
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.Keyspace;
/////////////////////////////////////////////////////////////////////////
1:     public void tryValidKeyspace()
0:         assert Keyspace.open("Keyspace1").getReplicationStrategy() != null;
/////////////////////////////////////////////////////////////////////////
0:         for (String keyspaceName : Schema.instance.getNonSystemKeyspaces())
1:             strategy = getStrategy(keyspaceName, tmd);
/////////////////////////////////////////////////////////////////////////
0:         for (String keyspaceName : Schema.instance.getNonSystemKeyspaces())
1:             strategy = getStrategy(keyspaceName, tmd);
0:             StorageService.calculatePendingRanges(strategy, keyspaceName);
1:                 Collection<InetAddress> endpoints = tmd.getWriteEndpoints(keyTokens[i], keyspaceName, strategy.getNaturalEndpoints(keyTokens[i]));
/////////////////////////////////////////////////////////////////////////
0:     private AbstractReplicationStrategy getStrategy(String keyspaceName, TokenMetadata tmd) throws ConfigurationException
0:         KSMetaData ksmd = Schema.instance.getKSMetaData(keyspaceName);
1:                 keyspaceName,
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.dht.IPartitioner;
1: import org.apache.cassandra.dht.OrderPreservingPartitioner;
1: import org.apache.cassandra.dht.RandomPartitioner.BigIntegerToken;
1: import org.apache.cassandra.dht.Token;
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertFalse;
1: import static org.junit.Assert.assertTrue;
/////////////////////////////////////////////////////////////////////////
1:             keyTokens.add(partitioner.getToken(ByteBufferUtil.bytes(String.valueOf((char) ('a' + i * 2 + 1)))));
/////////////////////////////////////////////////////////////////////////
0:                                                                     keyspaceName,
0:                                                                     ksmd.strategyClass,
1:                                                                     tmd,
1:                                                                     new SimpleSnitch(),
0:                                                                     ksmd.strategyOptions);
commit:5267112
/////////////////////////////////////////////////////////////////////////
commit:3a2faf9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.exceptions.ConfigurationException;
commit:438acfc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.SchemaLoader;
/////////////////////////////////////////////////////////////////////////
0: public class SimpleStrategyTest extends SchemaLoader
commit:07cdfd0
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
commit:b62b0ae
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.ByteBufferUtil;
/////////////////////////////////////////////////////////////////////////
0:             keyTokens.add(partitioner.getToken(ByteBufferUtil.bytes(String.valueOf((char)('a' + i * 2 + 1)))));
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:07893d7
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.dht.RandomPartitioner.BigIntegerToken;
1: import org.apache.cassandra.dht.OrderPreservingPartitioner.StringToken;
/////////////////////////////////////////////////////////////////////////
1:         IPartitioner partitioner = OrderPreservingPartitioner.instance;
author:lyubent
-------------------------------------------------------------------------------
commit:d2a3827
/////////////////////////////////////////////////////////////////////////
1: import org.junit.BeforeClass;
1: import org.apache.cassandra.config.Schema;
1: import org.apache.cassandra.service.PendingRangeCalculatorService;
1: public class SimpleStrategyTest
1:     public static final String KEYSPACE1 = "SimpleStrategyTest";
1: 
1:     @BeforeClass
1:     public static void defineSchema() throws Exception
1:     {
1:         SchemaLoader.prepareServer();
0:         SchemaLoader.createKeyspace(KEYSPACE1,
0:                                     SimpleStrategy.class,
0:                                     KSMetaData.optsWithRF(1));
1:     }
1: 
1:         assert Keyspace.open(KEYSPACE1).getReplicationStrategy() != null;
author:Dave Brosius
-------------------------------------------------------------------------------
commit:9639f95
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void testBigIntegerEndpoints() throws UnknownHostException
/////////////////////////////////////////////////////////////////////////
1:     public void testStringEndpoints() throws UnknownHostException
/////////////////////////////////////////////////////////////////////////
1:     private void verifyGetNaturalEndpoints(Token[] endpointTokens, Token[] keyTokens) throws UnknownHostException
/////////////////////////////////////////////////////////////////////////
1:     public void testGetEndpointsDuringBootstrap() throws UnknownHostException
/////////////////////////////////////////////////////////////////////////
1:     private AbstractReplicationStrategy getStrategy(String keyspaceName, TokenMetadata tmd)
author:Brandon Williams
-------------------------------------------------------------------------------
commit:1475d92
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.service.PendingRangeCalculatorService;
/////////////////////////////////////////////////////////////////////////
1:             PendingRangeCalculatorService.calculatePendingRanges(strategy, keyspaceName);
commit:713bba5
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.service.PendingRangeCalculatorService;
/////////////////////////////////////////////////////////////////////////
0:             PendingRangeCalculatorService.calculatePendingRanges(strategy, table);
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:7b532bc
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.Schema;
/////////////////////////////////////////////////////////////////////////
0:         for (String table : Schema.instance.getNonSystemTables())
/////////////////////////////////////////////////////////////////////////
0:         for (String table : Schema.instance.getNonSystemTables())
/////////////////////////////////////////////////////////////////////////
0:         KSMetaData ksmd = Schema.instance.getKSMetaData(table);
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:8c7bc2f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.KSMetaData;
/////////////////////////////////////////////////////////////////////////
0:         KSMetaData ksmd =  DatabaseDescriptor.getKSMetaData(table);
0:                 ksmd.strategyClass,
0:                 ksmd.strategyOptions);
commit:2f5f0c2
/////////////////////////////////////////////////////////////////////////
1:                 assertEquals(strategy.getReplicationFactor(), endpoints.size());
/////////////////////////////////////////////////////////////////////////
1:             int replicationFactor = strategy.getReplicationFactor();
commit:a9e3fa1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.CleanupHelper;
0: import org.apache.cassandra.config.ConfigurationException;
0: import static org.junit.Assert.*;
1: 
0: public class SimpleStrategyTest extends CleanupHelper
commit:ac4d016
/////////////////////////////////////////////////////////////////////////
0:         assert Table.open("Keyspace1").getReplicationStrategy() != null;
commit:6af5726
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.Table;
/////////////////////////////////////////////////////////////////////////
0:         assert Table.open("Keyspace1").replicationStrategy != null;
commit:e7a385a
/////////////////////////////////////////////////////////////////////////
0: import java.nio.ByteBuffer;
/////////////////////////////////////////////////////////////////////////
0:             keyTokens.add(partitioner.getToken(ByteBuffer.wrap(String.valueOf((char)('a' + i * 2 + 1)).getBytes())));
commit:00554e9
/////////////////////////////////////////////////////////////////////////
0:     public void tryValidTable()
1:     {
0:         assert StorageService.instance.getReplicationStrategy("Keyspace1") != null;
1:     }
1: 
0:     @Test(expected = AssertionError.class)
0:         StorageService.instance.getReplicationStrategy("SomeBogusTableThatDoesntExist");
commit:916c810
/////////////////////////////////////////////////////////////////////////
0: public class SimpleStrategyTest extends SchemaLoader
/////////////////////////////////////////////////////////////////////////
0:                 "org.apache.cassandra.locator.SimpleStrategy",
commit:d8755b3
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy strategy = new RackUnawareStrategy(tmd, new SimpleSnitch());
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy strategy = new RackUnawareStrategy(tmd, new SimpleSnitch());
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy strategy = new RackUnawareStrategy(tmd, new SimpleSnitch());
/////////////////////////////////////////////////////////////////////////
0:                 Collection<InetAddress> endpoints = tmd.getWriteEndpoints(keyTokens[i], table, strategy.getNaturalEndpoints(keyTokens[i], table));
commit:34e241a
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.Collection;
1: import java.util.HashSet;
1: import java.util.List;
1: 
1: import org.junit.Test;
1: 
0: import static org.junit.Assert.*;
0: import org.apache.cassandra.SchemaLoader;
0: import org.apache.cassandra.config.DatabaseDescriptor;
0: import org.apache.cassandra.dht.*;
0: import org.apache.cassandra.service.StorageService;
1: import org.apache.cassandra.service.StorageServiceAccessor;
/////////////////////////////////////////////////////////////////////////
0:         verifyGetNaturalEndpoints(tmd, strategy, endpointTokens.toArray(new Token[0]), keyTokens.toArray(new Token[0]));
/////////////////////////////////////////////////////////////////////////
0:         verifyGetNaturalEndpoints(tmd, strategy, endpointTokens.toArray(new Token[0]), keyTokens.toArray(new Token[0]));
0:     private void verifyGetNaturalEndpoints(TokenMetadata tmd, AbstractReplicationStrategy strategy, Token[] endpointTokens, Token[] keyTokens) throws UnknownHostException
0:         for (String table : DatabaseDescriptor.getNonSystemTables())
1:             List<InetAddress> hosts = new ArrayList<InetAddress>();
1:             for (int i = 0; i < endpointTokens.length; i++)
1:                 InetAddress ep = InetAddress.getByName("127.0.0." + String.valueOf(i + 1));
1:                 tmd.updateNormalToken(endpointTokens[i], ep);
1:                 hosts.add(ep);
1:             }
1: 
1:             for (int i = 0; i < keyTokens.length; i++)
1:             {
0:                 List<InetAddress> endpoints = strategy.getNaturalEndpoints(keyTokens[i], table);
0:                 assertEquals(DatabaseDescriptor.getReplicationFactor(table), endpoints.size());
1:                 List<InetAddress> correctEndpoints = new ArrayList<InetAddress>();
1:                 for (int j = 0; j < endpoints.size(); j++)
1:                     correctEndpoints.add(hosts.get((i + j + 1) % hosts.size()));
1:                 assertEquals(new HashSet<InetAddress>(correctEndpoints), new HashSet<InetAddress>(endpoints));
commit:18b2a16
/////////////////////////////////////////////////////////////////////////
1:         List<Token> endpointTokens = new ArrayList<Token>();
1:             endpointTokens.add(new BigIntegerToken(String.valueOf(10 * i)));
0:             testGetEndpoints(tmd, strategy, endpointTokens.toArray(new Token[0]), keyTokens.toArray(new Token[0]), table);
/////////////////////////////////////////////////////////////////////////
1:         List<Token> endpointTokens = new ArrayList<Token>();
1:             endpointTokens.add(new StringToken(String.valueOf((char)('a' + i * 2))));
0:             testGetEndpoints(tmd, strategy, endpointTokens.toArray(new Token[0]), keyTokens.toArray(new Token[0]), table);
0:     private void testGetEndpoints(TokenMetadata tmd, AbstractReplicationStrategy strategy, Token[] endpointTokens, Token[] keyTokens, String table) throws UnknownHostException
1:         for (int i = 0; i < endpointTokens.length; i++)
1:             tmd.updateNormalToken(endpointTokens[i], ep);
0:             List<InetAddress> endpoints = strategy.getNaturalEndpoints(keyTokens[i], table);
0:             assertEquals(DatabaseDescriptor.getReplicationFactor(table), endpoints.size());
0:             for (int j = 0; j < endpoints.size(); j++)
0:                 assertEquals(endpoints.get(j), hosts.get((i + j + 1) % hosts.size()));
/////////////////////////////////////////////////////////////////////////
1:         Token[] endpointTokens = new Token[RING_SIZE];
1:             endpointTokens[i] = new BigIntegerToken(String.valueOf(RING_SIZE * 2 * i));
0:         for (int i = 0; i < endpointTokens.length; i++)
0:             tmd.updateNormalToken(endpointTokens[i], ep);
1:         InetAddress bootstrapEndpoint = InetAddress.getByName("127.0.0.11");
1:         tmd.addBootstrapToken(bsToken, bootstrapEndpoint);
/////////////////////////////////////////////////////////////////////////
0:                 Collection<InetAddress> endpoints = strategy.getWriteEndpoints(keyTokens[i], table, strategy.getNaturalEndpoints(keyTokens[i], table));
1:                 assertTrue(endpoints.size() >= replicationFactor);
1:                     assertTrue(endpoints.contains(hosts.get((i + j + 1) % hosts.size())));
1:                 // bootstrapEndpoint should be in the endpoints for i in MAX-RF to MAX, but not in any earlier ep.
1:                     assertFalse(endpoints.contains(bootstrapEndpoint));
1:                     assertTrue(endpoints.contains(bootstrapEndpoint));
commit:c10813c
/////////////////////////////////////////////////////////////////////////
0:             tmd.updateNormalToken(endPointTokens[i], ep);
/////////////////////////////////////////////////////////////////////////
0:             tmd.updateNormalToken(endPointTokens[i], ep);
0:         tmd.addBootstrapToken(bsToken, bootstrapEndPoint);
0:         StorageService.calculatePendingRanges(tmd, strategy);
1: 
/////////////////////////////////////////////////////////////////////////
1:             else
0:                 assertFalse(endPoints.contains(bootstrapEndPoint));
commit:93c5afa
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy strategy = new RackUnawareStrategy(tmd, partitioner, 3);
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy strategy = new RackUnawareStrategy(tmd, partitioner, 3);
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy strategy = new RackUnawareStrategy(tmd, partitioner, 3);
commit:5d44703
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collection;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.service.StorageService;
1: 
/////////////////////////////////////////////////////////////////////////
0:         StorageService.updateBootstrapRanges(strategy, tmd, bsToken, bootstrapEndPoint);
0:             Collection<InetAddress> endPoints = strategy.getWriteEndpoints(keyTokens[i], strategy.getNaturalEndpoints(keyTokens[i]));
commit:0287d0d
/////////////////////////////////////////////////////////////////////////
0:         tmd.setBootstrapping(bootstrapEndPoint, true);
0:         tmd.update(bsToken, bootstrapEndPoint);
commit:924c7e5
/////////////////////////////////////////////////////////////////////////
0:     public void testBigIntegerEndpoints() throws UnknownHostException
/////////////////////////////////////////////////////////////////////////
0:         testGetEndpoints(tmd, strategy, endPointTokens.toArray(new Token[0]), keyTokens.toArray(new Token[0]));
0:     public void testStringEndpoints() throws UnknownHostException
/////////////////////////////////////////////////////////////////////////
0:         testGetEndpoints(tmd, strategy, endPointTokens.toArray(new Token[0]), keyTokens.toArray(new Token[0]));
0:     private void testGetEndpoints(TokenMetadata tmd, AbstractReplicationStrategy strategy, Token[] endPointTokens, Token[] keyTokens) throws UnknownHostException
/////////////////////////////////////////////////////////////////////////
0:             List<InetAddress> endPoints = strategy.getNaturalEndpoints(keyTokens[i]);
0:             assertEquals(3, endPoints.size());
0:             for (int j = 0; j < endPoints.size(); j++)
0:                 assertEquals(endPoints.get(j), hosts.get((i + j + 1) % hosts.size()));
0:     public void testGetEndpointsDuringBootstrap() throws UnknownHostException
/////////////////////////////////////////////////////////////////////////
0:             List<InetAddress> endPoints = strategy.getWriteEndpoints(keyTokens[i], strategy.getNaturalEndpoints(keyTokens[i]));
0:             assertTrue(endPoints.size() >= 3);
0:                 assertTrue(endPoints.contains(hosts.get((i + j + 1) % hosts.size())));
0:                 assertTrue(endPoints.contains(bootstrapEndPoint));
commit:b767bf7
/////////////////////////////////////////////////////////////////////////
1: import java.net.InetAddress;
1: import java.net.UnknownHostException;
0:     public void testBigIntegerStorageEndPoints() throws UnknownHostException
/////////////////////////////////////////////////////////////////////////
0:     public void testStringStorageEndPoints() throws UnknownHostException
/////////////////////////////////////////////////////////////////////////
0:     private void testGetStorageEndPoints(TokenMetadata tmd, AbstractReplicationStrategy strategy, Token[] endPointTokens, Token[] keyTokens) throws UnknownHostException
1:         List<InetAddress> hosts = new ArrayList<InetAddress>();
1:             InetAddress ep = InetAddress.getByName("127.0.0." + String.valueOf(i + 1));
0:             InetAddress[] endPoints = strategy.getReadStorageEndPoints(keyTokens[i]);
/////////////////////////////////////////////////////////////////////////
0:     public void testGetStorageEndPointsDuringBootstrap() throws UnknownHostException
/////////////////////////////////////////////////////////////////////////
0:         List<InetAddress> hosts = new ArrayList<InetAddress>();
0:             InetAddress ep = InetAddress.getByName("127.0.0." + String.valueOf(i + 1));
0:         InetAddress bootstrapEndPoint = InetAddress.getByName("127.0.0.6");
0:             InetAddress[] endPoints = strategy.getWriteStorageEndPoints(keyTokens[i], strategy.getReadStorageEndPoints(keyTokens[i]));
0:             List<InetAddress> endPointsList = Arrays.asList(endPoints);
commit:7dbbca6
/////////////////////////////////////////////////////////////////////////
0:             EndPoint[] endPoints = strategy.getWriteStorageEndPoints(keyTokens[i], strategy.getReadStorageEndPoints(keyTokens[i]));
commit:eb83251
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy strategy = new RackUnawareStrategy(tmd, partitioner, 3, 7000);
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy strategy = new RackUnawareStrategy(tmd, partitioner, 3, 7000);
/////////////////////////////////////////////////////////////////////////
0:     private void testGetStorageEndPoints(TokenMetadata tmd, AbstractReplicationStrategy strategy, Token[] endPointTokens, Token[] keyTokens)
/////////////////////////////////////////////////////////////////////////
0:             EndPoint[] endPoints = strategy.getReadStorageEndPoints(keyTokens[i]);
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy strategy = new RackUnawareStrategy(tmd, partitioner, 3, 7000);
/////////////////////////////////////////////////////////////////////////
0:             EndPoint[] endPoints = strategy.getWriteStorageEndPoints(keyTokens[i]);
commit:847f3b0
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.*;
1: 
0: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
0:             assertEquals(3, endPoints.length);
0:                 assertEquals(endPoints[j], hosts.get((i + j + 1) % hosts.size()));
1:     
1:     @Test
0:     public void testGetStorageEndPointsDuringBootstrap()
1:     {
1:         TokenMetadata tmd = new TokenMetadata();
0:         IPartitioner partitioner = new RandomPartitioner();
0:         IReplicaPlacementStrategy strategy = new RackUnawareStrategy(tmd, partitioner, 3, 7000);
1: 
0:         Token[] endPointTokens = new Token[5]; 
0:         Token[] keyTokens = new Token[5];
1:         
0:         for (int i = 0; i < 5; i++) 
1:         {
0:             endPointTokens[i] = new BigIntegerToken(String.valueOf(10 * i));
0:             keyTokens[i] = new BigIntegerToken(String.valueOf(10 * i + 5));
1:         }
1:         
0:         List<EndPoint> hosts = new ArrayList<EndPoint>();
0:         for (int i = 0; i < endPointTokens.length; i++)
1:         {
0:             EndPoint ep = new EndPoint("127.0.0." + String.valueOf(i + 1), 7001);
0:             tmd.update(endPointTokens[i], ep);
1:             hosts.add(ep);
1:         }
1:         
0:         //Add bootstrap node id=6
0:         Token bsToken = new BigIntegerToken(String.valueOf(25));
0:         EndPoint bootstrapEndPoint = new EndPoint("127.0.0.6", 7001);
0:         tmd.update(bsToken, bootstrapEndPoint, true);
1:         
1:         for (int i = 0; i < keyTokens.length; i++)
1:         {
0:             EndPoint[] endPoints = strategy.getStorageEndPointsForWrite(keyTokens[i]);
0:             assertTrue(endPoints.length >=3);
0:             List<EndPoint> endPointsList = Arrays.asList(endPoints);
1: 
0:             for (int j = 0; j < 3; j++)
1:             {
1:                 //Check that the old nodes are definitely included
0:                 assertTrue(endPointsList.contains(hosts.get((i + j + 1) % hosts.size())));   
1:             }
0:             // for 5, 15, 25 this should include bootstrap node
0:             if (i < 3)
0:                 assertTrue(endPointsList.contains(bootstrapEndPoint));
1:         }
1:     }
commit:e959b2c
/////////////////////////////////////////////////////////////////////////
0:             keyTokens.add(partitioner.getToken(String.valueOf((char)('a' + i * 2 + 1))));
commit:8a9c25a
/////////////////////////////////////////////////////////////////////////
0:             EndPoint[] endPoints = strategy.getStorageEndPoints(keyTokens[i]);
commit:70ce402
/////////////////////////////////////////////////////////////////////////
0:             EndPoint[] endPoints = strategy.getStorageEndPoints(keyTokens[i], 0);
commit:88edbed
/////////////////////////////////////////////////////////////////////////
1: /*
0: * Licensed to the Apache Software Foundation (ASF) under one
0: * or more contributor license agreements.  See the NOTICE file
0: * distributed with this work for additional information
0: * regarding copyright ownership.  The ASF licenses this file
0: * to you under the Apache License, Version 2.0 (the
0: * "License"); you may not use this file except in compliance
0: * with the License.  You may obtain a copy of the License at
0: *
0: *    http://www.apache.org/licenses/LICENSE-2.0
0: *
0: * Unless required by applicable law or agreed to in writing,
0: * software distributed under the License is distributed on an
0: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0: * KIND, either express or implied.  See the License for the
0: * specific language governing permissions and limitations
0: * under the License.
0: */
commit:ae70cea
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             EndPoint ep = new EndPoint("127.0.0." + String.valueOf(i + 1), 7001);
/////////////////////////////////////////////////////////////////////////
commit:97fc5cb
/////////////////////////////////////////////////////////////////////////
0: import org.junit.Test;
/////////////////////////////////////////////////////////////////////////
0:     // TODO fix these
0:     /*
/////////////////////////////////////////////////////////////////////////
0:     */
commit:bfb2e95
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             keyTokens.add(partitioner.getInitialToken(String.valueOf((char)('a' + i * 2 + 1))));
commit:296e15b
/////////////////////////////////////////////////////////////////////////
1: package org.apache.cassandra.locator;
1: 
0: import java.util.List;
0: import java.util.ArrayList;
0: import java.math.BigInteger;
1: 
0: import org.testng.annotations.Test;
0: import org.apache.cassandra.dht.IPartitioner;
0: import org.apache.cassandra.dht.RandomPartitioner;
0: import org.apache.cassandra.dht.BigIntegerToken;
0: import org.apache.cassandra.dht.Token;
0: import org.apache.cassandra.dht.OrderPreservingPartitioner;
0: import org.apache.cassandra.dht.StringToken;
0: import org.apache.cassandra.net.EndPoint;
1: 
0: public class RackUnawareStrategyTest
1: {
1:     @Test
0:     public void testBigIntegerStorageEndPoints()
1:     {
0:         TokenMetadata tmd = new TokenMetadata();
0:         IPartitioner partitioner = new RandomPartitioner();
0:         IReplicaPlacementStrategy strategy = new RackUnawareStrategy(tmd, partitioner, 3, 7000);
1: 
0:         List<Token> endPointTokens = new ArrayList<Token>();
1:         List<Token> keyTokens = new ArrayList<Token>();
1:         for (int i = 0; i < 5; i++) {
0:             endPointTokens.add(new BigIntegerToken(String.valueOf(10 * i)));
1:             keyTokens.add(new BigIntegerToken(String.valueOf(10 * i + 5)));
1:         }
0:         testGetStorageEndPoints(tmd, strategy, endPointTokens.toArray(new Token[0]), keyTokens.toArray(new Token[0]));
1:     }
1: 
1:     @Test
0:     public void testStringStorageEndPoints()
1:     {
0:         TokenMetadata tmd = new TokenMetadata();
0:         IPartitioner partitioner = new OrderPreservingPartitioner();
0:         IReplicaPlacementStrategy strategy = new RackUnawareStrategy(tmd, partitioner, 3, 7000);
1: 
0:         List<Token> endPointTokens = new ArrayList<Token>();
1:         List<Token> keyTokens = new ArrayList<Token>();
1:         for (int i = 0; i < 5; i++) {
0:             endPointTokens.add(new StringToken(String.valueOf((char)('a' + i * 2))));
0:             keyTokens.add(partitioner.getTokenForKey(String.valueOf((char)('a' + i * 2 + 1))));
1:         }
0:         testGetStorageEndPoints(tmd, strategy, endPointTokens.toArray(new Token[0]), keyTokens.toArray(new Token[0]));
1:     }
1: 
1:     // given a list of endpoint tokens, and a set of key tokens falling between the endpoint tokens,
1:     // make sure that the Strategy picks the right endpoints for the keys.
0:     private void testGetStorageEndPoints(TokenMetadata tmd, IReplicaPlacementStrategy strategy, Token[] endPointTokens, Token[] keyTokens)
1:     {
0:         List<EndPoint> hosts = new ArrayList<EndPoint>();
0:         for (int i = 0; i < endPointTokens.length; i++)
1:         {
0:             EndPoint ep = new EndPoint(String.valueOf(i), 7001);
0:             tmd.update(endPointTokens[i], ep);
0:             hosts.add(ep);
1:         }
1: 
0:         for (int i = 0; i < keyTokens.length; i++)
1:         {
0:             EndPoint[] endPoints = strategy.getStorageEndPoints(keyTokens[i]);
0:             assert endPoints.length == 3;
0:             for (int j = 0; j < endPoints.length; j++)
1:             {
0:                 assert endPoints[j] == hosts.get((i + j + 1) % hosts.size());
1:             }
1:         }
1:     }
1: }
author:Eric Evans
-------------------------------------------------------------------------------
commit:df8a933
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.ConfigurationException;
/////////////////////////////////////////////////////////////////////////
0:             throw new AssertionError("SS.createReplicationStrategy() should have thrown a RuntimeException.");
/////////////////////////////////////////////////////////////////////////
0:     public void testBigIntegerEndpoints() throws UnknownHostException, ConfigurationException
1:         verifyGetNaturalEndpoints(endpointTokens.toArray(new Token[0]), keyTokens.toArray(new Token[0]));
0:     public void testStringEndpoints() throws UnknownHostException, ConfigurationException
/////////////////////////////////////////////////////////////////////////
1:         verifyGetNaturalEndpoints(endpointTokens.toArray(new Token[0]), keyTokens.toArray(new Token[0]));
0:     private void verifyGetNaturalEndpoints(Token[] endpointTokens, Token[] keyTokens) throws UnknownHostException, ConfigurationException
1:         TokenMetadata tmd;
1:         AbstractReplicationStrategy strategy;
1:             tmd = new TokenMetadata();
0:             strategy = getStrategy(table, tmd);
/////////////////////////////////////////////////////////////////////////
1:                 List<InetAddress> endpoints = strategy.getNaturalEndpoints(keyTokens[i]);
/////////////////////////////////////////////////////////////////////////
0:     public void testGetEndpointsDuringBootstrap() throws UnknownHostException, ConfigurationException
/////////////////////////////////////////////////////////////////////////
1:         AbstractReplicationStrategy strategy = null;
0:             strategy = getStrategy(table, tmd);
0: 
0: 
0:                 Collection<InetAddress> endpoints = tmd.getWriteEndpoints(keyTokens[i], table, strategy.getNaturalEndpoints(keyTokens[i]));
/////////////////////////////////////////////////////////////////////////
0: 
0:     private AbstractReplicationStrategy getStrategyWithNewTokenMetadata(AbstractReplicationStrategy strategy, TokenMetadata newTmd) throws ConfigurationException
1:     {
1:         return AbstractReplicationStrategy.createReplicationStrategy(
0:                 strategy.table,
0:                 strategy.getClass().getName(),
0:                 newTmd,
0:                 strategy.snitch,
0:                 strategy.configOptions);
1:     }
0: 
0:     private AbstractReplicationStrategy getStrategy(String table, TokenMetadata tmd) throws ConfigurationException
1:     {
1:         return AbstractReplicationStrategy.createReplicationStrategy(
0:                 table,
0:                 "org.apache.cassandra.locator.RackUnawareStrategy",
0:                 tmd,
0:                 new SimpleSnitch(),
0:                 null);
1:     }
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:434564d
/////////////////////////////////////////////////////////////////////////
0:             keyTokens.add(partitioner.getToken(String.valueOf((char)('a' + i * 2 + 1)).getBytes()));
commit:7a75b63
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.SchemaLoader;
/////////////////////////////////////////////////////////////////////////
0: public class RackUnawareStrategyTest extends SchemaLoader
commit:3577fd8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.DatabaseDescriptor;
0: import org.apache.cassandra.gms.ApplicationState;
0: import org.apache.cassandra.service.StorageServiceAccessor;
/////////////////////////////////////////////////////////////////////////
0:     public void tryBogusTable()
0:     {
0:         AbstractReplicationStrategy rs = StorageService.instance.getReplicationStrategy("Keyspace1");
0:         assertNotNull(rs);
0:         try
0:         {
0:             rs = StorageService.instance.getReplicationStrategy("SomeBogusTableThatDoesntExist");
0:             throw new AssertionError("SS.getReplicationStrategy() should have thrown a RuntimeException.");
0:         }
0:         catch (RuntimeException ex)
0:         {
0:             // This exception should be thrown.
0:         }
0:     }
0: 
1:     @Test
0:         AbstractReplicationStrategy strategy = new RackUnawareStrategy(tmd, null);
/////////////////////////////////////////////////////////////////////////
0:         for (String table : DatabaseDescriptor.getNonSystemTables())
0:             testGetEndpoints(tmd, strategy, endPointTokens.toArray(new Token[0]), keyTokens.toArray(new Token[0]), table);
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy strategy = new RackUnawareStrategy(tmd, null);
/////////////////////////////////////////////////////////////////////////
0:         for (String table : DatabaseDescriptor.getNonSystemTables())
0:             testGetEndpoints(tmd, strategy, endPointTokens.toArray(new Token[0]), keyTokens.toArray(new Token[0]), table);
0:     private void testGetEndpoints(TokenMetadata tmd, AbstractReplicationStrategy strategy, Token[] endPointTokens, Token[] keyTokens, String table) throws UnknownHostException
/////////////////////////////////////////////////////////////////////////
0:             List<InetAddress> endPoints = strategy.getNaturalEndpoints(keyTokens[i], table);
0:             assertEquals(DatabaseDescriptor.getReplicationFactor(table), endPoints.size());
/////////////////////////////////////////////////////////////////////////
1:         // the token difference will be RING_SIZE * 2.
1:         final int RING_SIZE = 10;
1:         TokenMetadata oldTmd = StorageServiceAccessor.setTokenMetadata(tmd);
0:         AbstractReplicationStrategy strategy = new RackUnawareStrategy(tmd, null);
0:         Token[] endPointTokens = new Token[RING_SIZE];
1:         Token[] keyTokens = new Token[RING_SIZE];
1:         for (int i = 0; i < RING_SIZE; i++)
0:             endPointTokens[i] = new BigIntegerToken(String.valueOf(RING_SIZE * 2 * i));
1:             keyTokens[i] = new BigIntegerToken(String.valueOf(RING_SIZE * 2 * i + RING_SIZE));
/////////////////////////////////////////////////////////////////////////
0: 
1:         // bootstrap at the end of the ring
1:         Token bsToken = new BigIntegerToken(String.valueOf(210));
0:         InetAddress bootstrapEndPoint = InetAddress.getByName("127.0.0.11");
0:         for (String table : DatabaseDescriptor.getNonSystemTables())
0:             StorageService.calculatePendingRanges(strategy, table);
0:             int replicationFactor = DatabaseDescriptor.getReplicationFactor(table);
0:             for (int i = 0; i < keyTokens.length; i++)
0:                 Collection<InetAddress> endPoints = strategy.getWriteEndpoints(keyTokens[i], table, strategy.getNaturalEndpoints(keyTokens[i], table));
0:                 assertTrue(endPoints.size() >= replicationFactor);
0: 
1:                 for (int j = 0; j < replicationFactor; j++)
0:                 {
0:                     //Check that the old nodes are definitely included
0:                     assertTrue(endPoints.contains(hosts.get((i + j + 1) % hosts.size())));
0:                 }
0: 
0:                 // bootstrapEndPoint should be in the endPoints for i in MAX-RF to MAX, but not in any earlier ep.
1:                 if (i < RING_SIZE - replicationFactor)
0:                     assertFalse(endPoints.contains(bootstrapEndPoint));
0:                 else
0:                     assertTrue(endPoints.contains(bootstrapEndPoint));
0: 
1:         StorageServiceAccessor.setTokenMetadata(oldTmd);
commit:dcaf84e
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy strategy = new RackUnawareStrategy(tmd, 3);
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy strategy = new RackUnawareStrategy(tmd, 3);
/////////////////////////////////////////////////////////////////////////
0:         AbstractReplicationStrategy strategy = new RackUnawareStrategy(tmd, 3);
============================================================================