1:a991b64: /*
1:a991b64:  * Licensed to the Apache Software Foundation (ASF) under one
1:a991b64:  * or more contributor license agreements.  See the NOTICE file
1:a991b64:  * distributed with this work for additional information
1:a991b64:  * regarding copyright ownership.  The ASF licenses this file
1:a991b64:  * to you under the Apache License, Version 2.0 (the
1:a991b64:  * "License"); you may not use this file except in compliance
1:a991b64:  * with the License.  You may obtain a copy of the License at
1:a991b64:  *
1:a991b64:  *     http://www.apache.org/licenses/LICENSE-2.0
1:a991b64:  *
1:a991b64:  * Unless required by applicable law or agreed to in writing, software
1:a991b64:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a991b64:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a991b64:  * See the License for the specific language governing permissions and
1:a991b64:  * limitations under the License.
1:a991b64:  */
1:a991b64: package org.apache.cassandra.db;
18:a991b64: 
1:a991b64: import java.io.IOException;
1:1fe594d: import java.io.IOError;
1:1fe594d: import java.util.*;
1:1fe594d: 
1:1fe594d: import com.google.common.collect.Iterables;
1:1fe594d: import com.google.common.collect.PeekingIterator;
1:a991b64: 
1:a991b64: import org.slf4j.Logger;
1:a991b64: import org.slf4j.LoggerFactory;
1:a991b64: import org.apache.cassandra.config.CFMetaData;
1:a991b64: import org.apache.cassandra.db.rows.*;
1:03f72ac: import org.apache.cassandra.io.util.DataInputPlus;
1:4a00438: import org.apache.cassandra.io.util.FileDataInput;
1:a991b64: import org.apache.cassandra.net.MessagingService;
1:a991b64: 
1:a991b64: /**
1:a991b64:  * Helper class to deserialize Unfiltered object from disk efficiently.
1:a991b64:  *
1:a991b64:  * More precisely, this class is used by the low-level reader to ensure
1:a991b64:  * we don't do more work than necessary (i.e. we don't allocate/deserialize
1:a991b64:  * objects for things we don't care about).
1:a991b64:  */
1:a991b64: public abstract class UnfilteredDeserializer
14:a991b64: {
1:a991b64:     private static final Logger logger = LoggerFactory.getLogger(UnfilteredDeserializer.class);
1:f713be4: 
1:a991b64:     protected final CFMetaData metadata;
1:03f72ac:     protected final DataInputPlus in;
1:a991b64:     protected final SerializationHelper helper;
1:a991b64: 
1:a991b64:     protected UnfilteredDeserializer(CFMetaData metadata,
1:03f72ac:                                      DataInputPlus in,
1:a991b64:                                      SerializationHelper helper)
1:a991b64:     {
1:a991b64:         this.metadata = metadata;
1:a991b64:         this.in = in;
1:a991b64:         this.helper = helper;
14:a991b64:     }
1:a991b64: 
1:a991b64:     public static UnfilteredDeserializer create(CFMetaData metadata,
1:03f72ac:                                                 DataInputPlus in,
1:a991b64:                                                 SerializationHeader header,
1:a991b64:                                                 SerializationHelper helper,
1:a991b64:                                                 DeletionTime partitionDeletion,
1:a991b64:                                                 boolean readAllAsDynamic)
1:a991b64:     {
1:a991b64:         if (helper.version >= MessagingService.VERSION_30)
1:a991b64:             return new CurrentDeserializer(metadata, in, header, helper);
1:a991b64:         else
1:a991b64:             return new OldFormatDeserializer(metadata, in, helper, partitionDeletion, readAllAsDynamic);
1:a991b64:     }
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Whether or not there is more atom to read.
1:a991b64:      */
1:a991b64:     public abstract boolean hasNext() throws IOException;
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Compare the provided bound to the next atom to read on disk.
1:a991b64:      *
1:a991b64:      * This will not read/deserialize the whole atom but only what is necessary for the
1:a991b64:      * comparison. Whenever we know what to do with this atom (read it or skip it),
1:a991b64:      * readNext or skipNext should be called.
1:a991b64:      */
1:2cc26eb:     public abstract int compareNextTo(ClusteringBound bound) throws IOException;
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Returns whether the next atom is a row or not.
1:a991b64:      */
1:a991b64:     public abstract boolean nextIsRow() throws IOException;
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Returns whether the next atom is the static row or not.
1:a991b64:      */
1:a991b64:     public abstract boolean nextIsStatic() throws IOException;
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Returns the next atom.
1:a991b64:      */
1:a991b64:     public abstract Unfiltered readNext() throws IOException;
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Clears any state in this deserializer.
1:a991b64:      */
1:a991b64:     public abstract void clearState() throws IOException;
1:a991b64: 
1:a991b64:     /**
1:a991b64:      * Skips the next atom.
1:a991b64:      */
1:a991b64:     public abstract void skipNext() throws IOException;
1:4a00438: 
1:a991b64: 
1:4a00438:     /**
1:4a00438:      * For the legacy layout deserializer, we have to deal with the fact that a row can span multiple index blocks and that
1:4a00438:      * the call to hasNext() reads the next element upfront. We must take that into account when we check in AbstractSSTableIterator if
1:4a00438:      * we're past the end of an index block boundary as that check expect to account for only consumed data (that is, if hasNext has
1:4a00438:      * been called and made us cross an index boundary but neither readNext() or skipNext() as yet been called, we shouldn't consider
1:4a00438:      * the index block boundary crossed yet).
1:4a00438:      *
1:4a00438:      * TODO: we don't care about this for the current file format because a row can never span multiple index blocks (further, hasNext()
1:4a00438:      * only just basically read 2 bytes from disk in that case). So once we drop backward compatibility with pre-3.0 sstable, we should
1:4a00438:      * remove this.
1:4a00438:      */
1:4a00438:     public abstract long bytesReadForUnconsumedData();
1:4a00438: 
1:a991b64:     private static class CurrentDeserializer extends UnfilteredDeserializer
1:a991b64:     {
1:a991b64:         private final ClusteringPrefix.Deserializer clusteringDeserializer;
1:a991b64:         private final SerializationHeader header;
1:a991b64: 
2:a991b64:         private int nextFlags;
1:665f747:         private int nextExtendedFlags;
1:a991b64:         private boolean isReady;
2:a991b64:         private boolean isDone;
1:a991b64: 
1:2457599:         private final Row.Builder builder;
1:a991b64: 
1:a991b64:         private CurrentDeserializer(CFMetaData metadata,
1:03f72ac:                                     DataInputPlus in,
1:a991b64:                                     SerializationHeader header,
1:a991b64:                                     SerializationHelper helper)
1:a991b64:         {
1:a991b64:             super(metadata, in, helper);
1:a991b64:             this.header = header;
1:a991b64:             this.clusteringDeserializer = new ClusteringPrefix.Deserializer(metadata.comparator, in, header);
1:aa57626:             this.builder = BTreeRow.sortedBuilder();
1:a991b64:         }
1:a991b64: 
1:a991b64:         public boolean hasNext() throws IOException
1:a991b64:         {
1:a991b64:             if (isReady)
4:a991b64:                 return true;
1:a991b64: 
1:a991b64:             prepareNext();
1:a991b64:             return !isDone;
1:a991b64:         }
1:a991b64: 
1:a991b64:         private void prepareNext() throws IOException
1:a991b64:         {
2:a991b64:             if (isDone)
1:a991b64:                 return;
1:665f747: 
1:a991b64:             nextFlags = in.readUnsignedByte();
1:a991b64:             if (UnfilteredSerializer.isEndOfPartition(nextFlags))
1:a991b64:             {
2:a991b64:                 isDone = true;
1:a991b64:                 isReady = false;
1:a991b64:                 return;
1:a991b64:             }
1:a991b64: 
1:6584331:             nextExtendedFlags = UnfilteredSerializer.readExtendedFlags(in, nextFlags);
1:a991b64: 
1:665f747:             clusteringDeserializer.prepare(nextFlags, nextExtendedFlags);
1:a991b64:             isReady = true;
1:a991b64:         }
1:a991b64: 
1:2cc26eb:         public int compareNextTo(ClusteringBound bound) throws IOException
1:a991b64:         {
1:a991b64:             if (!isReady)
1:a991b64:                 prepareNext();
1:a991b64: 
2:a991b64:             assert !isDone;
1:a991b64: 
1:a991b64:             return clusteringDeserializer.compareNextTo(bound);
1:a991b64:         }
1:a991b64: 
1:a991b64:         public boolean nextIsRow() throws IOException
1:a991b64:         {
1:a991b64:             if (!isReady)
1:a991b64:                 prepareNext();
1:a991b64: 
1:a991b64:             return UnfilteredSerializer.kind(nextFlags) == Unfiltered.Kind.ROW;
1:a991b64:         }
1:a991b64: 
1:a991b64:         public boolean nextIsStatic() throws IOException
1:a991b64:         {
1:a991b64:             // This exists only for the sake of the OldFormatDeserializer
2:a991b64:             throw new UnsupportedOperationException();
1:a991b64:         }
1:a991b64: 
1:a991b64:         public Unfiltered readNext() throws IOException
1:a991b64:         {
1:a991b64:             isReady = false;
1:a991b64:             if (UnfilteredSerializer.kind(nextFlags) == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER)
1:a991b64:             {
1:2cc26eb:                 ClusteringBoundOrBoundary bound = clusteringDeserializer.deserializeNextBound();
1:2457599:                 return UnfilteredSerializer.serializer.deserializeMarkerBody(in, header, bound);
1:a991b64:             }
1:a991b64:             else
1:a991b64:             {
1:2457599:                 builder.newRow(clusteringDeserializer.deserializeNextClustering());
1:665f747:                 return UnfilteredSerializer.serializer.deserializeRowBody(in, header, helper, nextFlags, nextExtendedFlags, builder);
1:a991b64:             }
1:a991b64:         }
1:a991b64: 
1:a991b64:         public void skipNext() throws IOException
1:a991b64:         {
1:a991b64:             isReady = false;
1:6584331:             clusteringDeserializer.skipNext();
1:a991b64:             if (UnfilteredSerializer.kind(nextFlags) == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER)
1:a991b64:             {
1:6584331:                 UnfilteredSerializer.serializer.skipMarkerBody(in);
1:a991b64:             }
1:a991b64:             else
1:a991b64:             {
1:6584331:                 UnfilteredSerializer.serializer.skipRowBody(in);
1:a991b64:             }
1:a991b64:         }
1:a991b64: 
1:a991b64:         public void clearState()
1:a991b64:         {
1:a991b64:             isReady = false;
2:a991b64:             isDone = false;
1:a991b64:         }
1:4a00438: 
1:4a00438:         public long bytesReadForUnconsumedData()
1:4a00438:         {
1:4a00438:             // In theory, hasNext() does consume 2-3 bytes, but we don't care about this for the current file format so returning
1:4a00438:             // 0 to mean "do nothing".
1:4a00438:             return 0;
1:4a00438:         }
1:a991b64:     }
1:a991b64: 
1:a991b64:     public static class OldFormatDeserializer extends UnfilteredDeserializer
1:a991b64:     {
1:a991b64:         private final boolean readAllAsDynamic;
1:a991b64:         private boolean skipStatic;
1:a991b64: 
1:1fe594d:         // The next Unfiltered to return, computed by hasNext()
1:1fe594d:         private Unfiltered next;
1:1fe594d:         // A temporary storage for an unfiltered that isn't returned next but should be looked at just afterwards
1:1fe594d:         private Unfiltered saved;
1:a991b64: 
1:1fe594d:         private boolean isFirst = true;
1:a991b64: 
1:1fe594d:         // The Unfiltered as read from the old format input
1:1fe594d:         private final UnfilteredIterator iterator;
1:a991b64: 
1:4a00438:         // The position in the input after the last data consumption (readNext/skipNext).
1:4a00438:         private long lastConsumedPosition;
1:a991b64: 
1:a991b64:         private OldFormatDeserializer(CFMetaData metadata,
1:03f72ac:                                       DataInputPlus in,
1:a991b64:                                       SerializationHelper helper,
1:a991b64:                                       DeletionTime partitionDeletion,
1:a991b64:                                       boolean readAllAsDynamic)
1:a991b64:         {
1:a991b64:             super(metadata, in, helper);
1:1fe594d:             this.iterator = new UnfilteredIterator(partitionDeletion);
1:a991b64:             this.readAllAsDynamic = readAllAsDynamic;
1:4a00438:             this.lastConsumedPosition = currentPosition();
1:a991b64:         }
1:a991b64: 
1:a991b64:         public void setSkipStatic()
1:a991b64:         {
1:a991b64:             this.skipStatic = true;
1:a991b64:         }
1:a991b64: 
1:1fe594d:         private boolean isStatic(Unfiltered unfiltered)
1:1fe594d:         {
1:1fe594d:             return unfiltered.isRow() && ((Row)unfiltered).isStatic();
1:1fe594d:         }
1:1fe594d: 
1:a991b64:         public boolean hasNext() throws IOException
1:a991b64:         {
1:1fe594d:             try
1:a991b64:             {
2:1fe594d:                 while (next == null)
1:1fe594d:                 {
1:1fe594d:                     if (saved == null && !iterator.hasNext())
1:1fe594d:                         return false;
1:1fe594d: 
1:1fe594d:                     next = saved == null ? iterator.next() : saved;
1:1fe594d:                     saved = null;
1:1fe594d: 
1:1fe594d:                     // The sstable iterators assume that if there is one, the static row is the first thing this deserializer will return.
1:1fe594d:                     // However, in the old format, a range tombstone with an empty start would sort before any static cell. So we should
1:1fe594d:                     // detect that case and return the static parts first if necessary.
1:1fe594d:                     if (isFirst && iterator.hasNext() && isStatic(iterator.peek()))
1:1fe594d:                     {
1:1fe594d:                         saved = next;
1:1fe594d:                         next = iterator.next();
1:1fe594d:                     }
1:1fe594d:                     isFirst = false;
1:1fe594d: 
1:1fe594d:                     // When reading old tables, we sometimes want to skip static data (due to how staticly defined column of compact
1:1fe594d:                     // tables are handled).
1:1fe594d:                     if (skipStatic && isStatic(next))
2:1fe594d:                         next = null;
1:1fe594d:                 }
1:0f5e780:                 return true;
1:a991b64:             }
1:1fe594d:             catch (IOError e)
1:a991b64:             {
1:1fe594d:                 if (e.getCause() != null && e.getCause() instanceof IOException)
1:1fe594d:                     throw (IOException)e.getCause();
1:1fe594d:                 throw e;
1:a991b64:             }
1:a991b64:         }
1:a991b64: 
1:1fe594d:         private boolean isRow(LegacyLayout.LegacyAtom atom)
1:a991b64:         {
1:1fe594d:             if (atom.isCell())
1:1fe594d:                 return true;
1:1fe594d: 
1:1fe594d:             LegacyLayout.LegacyRangeTombstone tombstone = atom.asRangeTombstone();
1:1fe594d:             return tombstone.isCollectionTombstone() || tombstone.isRowDeletion(metadata);
1:a991b64:         }
1:a991b64: 
1:2cc26eb:         public int compareNextTo(ClusteringBound bound) throws IOException
1:a991b64:         {
1:1fe594d:             if (!hasNext())
1:1fe594d:                 throw new IllegalStateException();
1:1fe594d:             return metadata.comparator.compare(next.clustering(), bound);
1:a991b64:         }
1:a991b64: 
1:a991b64:         public boolean nextIsRow() throws IOException
1:a991b64:         {
1:1fe594d:             if (!hasNext())
1:1fe594d:                 throw new IllegalStateException();
1:1fe594d:             return next.isRow();
1:a991b64:         }
1:a991b64: 
1:a991b64:         public boolean nextIsStatic() throws IOException
1:a991b64:         {
1:1fe594d:             return nextIsRow() && ((Row)next).isStatic();
1:a991b64:         }
1:a991b64: 
1:4a00438:         private long currentPosition()
1:4a00438:         {
1:4a00438:             // We return a bogus value if the input is not file based, but check we never rely
1:4a00438:             // on that value in that case in bytesReadForUnconsumedData
1:4a00438:             return in instanceof FileDataInput ? ((FileDataInput)in).getFilePointer() : 0;
1:4a00438:         }
1:4a00438: 
1:a991b64:         public Unfiltered readNext() throws IOException
1:a991b64:         {
1:1fe594d:             if (!hasNext())
1:1fe594d:                 throw new IllegalStateException();
1:1fe594d:             Unfiltered toReturn = next;
1:1fe594d:             next = null;
1:4a00438:             lastConsumedPosition = currentPosition();
1:1fe594d:             return toReturn;
1:4a00438:         }
1:4a00438: 
1:a991b64:         public void skipNext() throws IOException
1:4a00438:         {
1:1fe594d:             if (!hasNext())
1:1fe594d:                 throw new UnsupportedOperationException();
1:1fe594d:             next = null;
1:4a00438:             lastConsumedPosition = currentPosition();
1:a991b64:         }
1:1fe594d: 
1:4a00438:         public long bytesReadForUnconsumedData()
1:1fe594d:         {
1:4a00438:             if (!(in instanceof FileDataInput))
1:4a00438:                 throw new AssertionError();
1:4a00438: 
1:4a00438:             return currentPosition() - lastConsumedPosition;
1:a991b64:         }
1:1fe594d: 
1:a991b64:         public void clearState()
1:a991b64:         {
1:1fe594d:             next = null;
1:1fe594d:             saved = null;
1:1fe594d:             iterator.clearState();
1:4a00438:             lastConsumedPosition = currentPosition();
1:1fe594d:         }
1:1fe594d: 
1:1fe594d:         // Groups atoms from the input into proper Unfiltered.
1:1fe594d:         // Note: this could use guava AbstractIterator except that we want to be able to clear
1:1fe594d:         // the internal state of the iterator so it's cleaner to do it ourselves.
1:1fe594d:         private class UnfilteredIterator implements PeekingIterator<Unfiltered>
1:1fe594d:         {
1:1fe594d:             private final AtomIterator atoms;
1:1fe594d:             private final LegacyLayout.CellGrouper grouper;
2:1fe594d:             private final TombstoneTracker tombstoneTracker;
1:1fe594d: 
1:1fe594d:             private Unfiltered next;
1:1fe594d: 
1:1fe594d:             private UnfilteredIterator(DeletionTime partitionDeletion)
1:1fe594d:             {
1:1fe594d:                 this.grouper = new LegacyLayout.CellGrouper(metadata, helper);
1:1fe594d:                 this.tombstoneTracker = new TombstoneTracker(partitionDeletion);
1:8120bcf:                 this.atoms = new AtomIterator();
1:1fe594d:             }
1:1fe594d: 
1:1fe594d:             public boolean hasNext()
1:1fe594d:             {
1:71bac92:                 // Note that we loop on next == null because TombstoneTracker.openNew() could return null below or the atom might be shadowed.
1:1fe594d:                 while (next == null)
1:1fe594d:                 {
1:1fe594d:                     if (atoms.hasNext())
1:1fe594d:                     {
1:1fe594d:                         // If a range tombstone closes strictly before the next row/RT, we need to return that close (or boundary) marker first.
1:1fe594d:                         if (tombstoneTracker.hasClosingMarkerBefore(atoms.peek()))
1:1fe594d:                         {
1:1fe594d:                             next = tombstoneTracker.popClosingMarker();
1:1fe594d:                         }
1:1fe594d:                         else
1:1fe594d:                         {
1:1fe594d:                             LegacyLayout.LegacyAtom atom = atoms.next();
1:71bac92:                             if (!tombstoneTracker.isShadowed(atom))
1:71bac92:                                 next = isRow(atom) ? readRow(atom) : tombstoneTracker.openNew(atom.asRangeTombstone());
1:1fe594d:                         }
1:1fe594d:                     }
1:1fe594d:                     else if (tombstoneTracker.hasOpenTombstones())
1:1fe594d:                     {
1:1fe594d:                         next = tombstoneTracker.popClosingMarker();
1:1fe594d:                     }
1:1fe594d:                     else
1:1fe594d:                     {
1:1fe594d:                         return false;
1:1fe594d:                     }
1:1fe594d:                 }
1:a991b64:                 return true;
1:1fe594d:             }
1:1fe594d: 
1:1fe594d:             private Unfiltered readRow(LegacyLayout.LegacyAtom first)
1:1fe594d:             {
1:1fe594d:                 LegacyLayout.CellGrouper grouper = first.isStatic()
1:1fe594d:                                                  ? LegacyLayout.CellGrouper.staticGrouper(metadata, helper)
1:1fe594d:                                                  : this.grouper;
1:1fe594d:                 grouper.reset();
1:1fe594d:                 grouper.addAtom(first);
1:1fe594d:                 // As long as atoms are part of the same row, consume them. Note that the call to addAtom() uses
1:1fe594d:                 // atoms.peek() so that the atom is only consumed (by next) if it's part of the row (addAtom returns true)
1:1fe594d:                 while (atoms.hasNext() && grouper.addAtom(atoms.peek()))
1:1fe594d:                 {
1:1fe594d:                     atoms.next();
1:1fe594d:                 }
1:1fe594d:                 return grouper.getRow();
1:1fe594d:             }
1:1fe594d: 
1:1fe594d:             public Unfiltered next()
1:1fe594d:             {
1:1fe594d:                 if (!hasNext())
1:1fe594d:                     throw new UnsupportedOperationException();
1:1fe594d:                 Unfiltered toReturn = next;
1:1fe594d:                 next = null;
1:1fe594d:                 return toReturn;
1:1fe594d:             }
1:1fe594d: 
1:1fe594d:             public Unfiltered peek()
1:1fe594d:             {
1:1fe594d:                 if (!hasNext())
1:1fe594d:                     throw new UnsupportedOperationException();
1:1fe594d:                 return next;
1:1fe594d:             }
1:1fe594d: 
1:1fe594d:             public void clearState()
1:1fe594d:             {
1:1fe594d:                 atoms.clearState();
1:1fe594d:                 tombstoneTracker.clearState();
1:1fe594d:                 next = null;
1:1fe594d:             }
1:1fe594d: 
1:1fe594d:             public void remove()
1:1fe594d:             {
1:1fe594d:                 throw new UnsupportedOperationException();
1:1fe594d:             }
1:1fe594d:         }
1:1fe594d: 
1:1fe594d:         // Wraps the input of the deserializer to provide an iterator (and skip shadowed atoms).
1:1fe594d:         // Note: this could use guava AbstractIterator except that we want to be able to clear
1:1fe594d:         // the internal state of the iterator so it's cleaner to do it ourselves.
1:1fe594d:         private class AtomIterator implements PeekingIterator<LegacyLayout.LegacyAtom>
1:1fe594d:         {
1:1fe594d:             private boolean isDone;
1:1fe594d:             private LegacyLayout.LegacyAtom next;
1:1fe594d: 
1:8120bcf:             private AtomIterator()
1:1fe594d:             {
1:1fe594d:             }
1:1fe594d: 
1:1fe594d:             public boolean hasNext()
1:1fe594d:             {
1:1fe594d:                 if (isDone)
1:1fe594d:                     return false;
1:1fe594d: 
1:71bac92:                 if (next == null)
1:1fe594d:                 {
1:1fe594d:                     next = readAtom();
1:1fe594d:                     if (next == null)
1:1fe594d:                     {
1:1fe594d:                         isDone = true;
1:1fe594d:                         return false;
1:1fe594d:                     }
1:1fe594d:                 }
1:1fe594d:                 return true;
1:1fe594d:             }
1:1fe594d: 
1:1fe594d:             private LegacyLayout.LegacyAtom readAtom()
1:1fe594d:             {
1:1fe594d:                 try
1:1fe594d:                 {
1:1fe594d:                     return LegacyLayout.readLegacyAtom(metadata, in, readAllAsDynamic);
1:1fe594d:                 }
1:1fe594d:                 catch (IOException e)
1:1fe594d:                 {
1:1fe594d:                     throw new IOError(e);
1:1fe594d:                 }
1:1fe594d:             }
1:1fe594d: 
1:1fe594d:             public LegacyLayout.LegacyAtom next()
1:1fe594d:             {
1:1fe594d:                 if (!hasNext())
1:1fe594d:                     throw new UnsupportedOperationException();
1:1fe594d:                 LegacyLayout.LegacyAtom toReturn = next;
1:1fe594d:                 next = null;
1:1fe594d:                 return toReturn;
1:1fe594d:             }
1:1fe594d: 
1:1fe594d:             public LegacyLayout.LegacyAtom peek()
1:1fe594d:             {
1:1fe594d:                 if (!hasNext())
1:1fe594d:                     throw new UnsupportedOperationException();
1:1fe594d:                 return next;
1:1fe594d:             }
1:1fe594d: 
1:1fe594d:             public void clearState()
1:1fe594d:             {
1:1fe594d:                 this.next = null;
1:1fe594d:                 this.isDone = false;
1:1fe594d:             }
1:1fe594d: 
1:1fe594d:             public void remove()
1:1fe594d:             {
1:1fe594d:                 throw new UnsupportedOperationException();
1:1fe594d:             }
1:1fe594d:         }
1:1fe594d: 
1:1fe594d:         /**
1:1fe594d:          * Tracks which range tombstones are open when deserializing the old format.
1:1fe594d:          */
1:1fe594d:         private class TombstoneTracker
1:1fe594d:         {
1:1fe594d:             private final DeletionTime partitionDeletion;
1:1fe594d: 
1:1fe594d:             // Open tombstones sorted by their closing bound (i.e. first tombstone is the first to close).
1:1fe594d:             // As we only track non-fully-shadowed ranges, the first range is necessarily the currently
1:1fe594d:             // open tombstone (the one with the higher timestamp).
1:1fe594d:             private final SortedSet<LegacyLayout.LegacyRangeTombstone> openTombstones;
1:1fe594d: 
1:1fe594d:             public TombstoneTracker(DeletionTime partitionDeletion)
1:1fe594d:             {
1:1fe594d:                 this.partitionDeletion = partitionDeletion;
1:1fe594d:                 this.openTombstones = new TreeSet<>((rt1, rt2) -> metadata.comparator.compare(rt1.stop.bound, rt2.stop.bound));
1:1fe594d:             }
1:1fe594d: 
1:1fe594d:             /**
1:1fe594d:              * Checks if the provided atom is fully shadowed by the open tombstones of this tracker (or the partition deletion).
1:1fe594d:              */
1:1fe594d:             public boolean isShadowed(LegacyLayout.LegacyAtom atom)
1:1fe594d:             {
1:71bac92:                 assert !hasClosingMarkerBefore(atom);
1:1fe594d:                 long timestamp = atom.isCell() ? atom.asCell().timestamp : atom.asRangeTombstone().deletionTime.markedForDeleteAt();
1:1fe594d: 
1:1fe594d:                 if (partitionDeletion.deletes(timestamp))
1:1fe594d:                     return true;
1:1fe594d: 
1:1fe594d:                 SortedSet<LegacyLayout.LegacyRangeTombstone> coveringTombstones = isRow(atom) ? openTombstones : openTombstones.tailSet(atom.asRangeTombstone());
1:1fe594d:                 return Iterables.any(coveringTombstones, tombstone -> tombstone.deletionTime.deletes(timestamp));
1:1fe594d:             }
1:1fe594d: 
1:1fe594d:             /**
1:1fe594d:              * Whether the currently open marker closes stricly before the provided row/RT.
1:1fe594d:              */
1:1fe594d:             public boolean hasClosingMarkerBefore(LegacyLayout.LegacyAtom atom)
1:1fe594d:             {
1:1fe594d:                 return !openTombstones.isEmpty()
1:1fe594d:                     && metadata.comparator.compare(openTombstones.first().stop.bound, atom.clustering()) < 0;
1:1fe594d:             }
1:1fe594d: 
1:1fe594d:             /**
1:1fe594d:              * Returns the unfiltered corresponding to closing the currently open marker (and update the tracker accordingly).
1:1fe594d:              */
1:1fe594d:             public Unfiltered popClosingMarker()
1:1fe594d:             {
1:1fe594d:                 assert !openTombstones.isEmpty();
1:1fe594d: 
1:1fe594d:                 Iterator<LegacyLayout.LegacyRangeTombstone> iter = openTombstones.iterator();
1:1fe594d:                 LegacyLayout.LegacyRangeTombstone first = iter.next();
1:1fe594d:                 iter.remove();
1:1fe594d: 
1:1fe594d:                 // If that was the last open tombstone, we just want to close it. Otherwise, we have a boundary with the
1:1fe594d:                 // next tombstone
1:1fe594d:                 if (!iter.hasNext())
1:1fe594d:                     return new RangeTombstoneBoundMarker(first.stop.bound, first.deletionTime);
1:1fe594d: 
1:1fe594d:                 LegacyLayout.LegacyRangeTombstone next = iter.next();
1:1fe594d:                 return RangeTombstoneBoundaryMarker.makeBoundary(false, first.stop.bound, first.stop.bound.invert(), first.deletionTime, next.deletionTime);
1:1fe594d:             }
1:1fe594d: 
1:1fe594d:             /**
1:1fe594d:              * Update the tracker given the provided newly open tombstone. This return the Unfiltered corresponding to the opening
1:1fe594d:              * of said tombstone: this can be a simple open mark, a boundary (if there was an open tombstone superseded by this new one)
1:1fe594d:              * or even null (if the new tombston start is supersedes by the currently open tombstone).
1:1fe594d:              *
1:1fe594d:              * Note that this method assume the added tombstone is not fully shadowed, i.e. that !isShadowed(tombstone). It also
1:1fe594d:              * assumes no opened tombstone closes before that tombstone (so !hasClosingMarkerBefore(tombstone)).
1:1fe594d:              */
1:1fe594d:             public Unfiltered openNew(LegacyLayout.LegacyRangeTombstone tombstone)
1:1fe594d:             {
1:1fe594d:                 if (openTombstones.isEmpty())
1:1fe594d:                 {
1:1fe594d:                     openTombstones.add(tombstone);
1:1fe594d:                     return new RangeTombstoneBoundMarker(tombstone.start.bound, tombstone.deletionTime);
1:1fe594d:                 }
1:1fe594d: 
1:1fe594d:                 Iterator<LegacyLayout.LegacyRangeTombstone> iter = openTombstones.iterator();
1:1fe594d:                 LegacyLayout.LegacyRangeTombstone first = iter.next();
1:1fe594d:                 if (tombstone.deletionTime.supersedes(first.deletionTime))
1:1fe594d:                 {
1:1fe594d:                     // We're supperseding the currently open tombstone, so we should produce a boundary that close the currently open
1:1fe594d:                     // one and open the new one. We should also add the tombstone, but if it stop after the first one, we should
1:1fe594d:                     // also remove that first tombstone as it won't be useful anymore.
1:1fe594d:                     if (metadata.comparator.compare(tombstone.stop.bound, first.stop.bound) >= 0)
1:1fe594d:                         iter.remove();
1:1fe594d: 
1:1fe594d:                     openTombstones.add(tombstone);
1:1fe594d:                     return RangeTombstoneBoundaryMarker.makeBoundary(false, tombstone.start.bound.invert(), tombstone.start.bound, first.deletionTime, tombstone.deletionTime);
1:1fe594d:                 }
1:1fe594d:                 else
1:1fe594d:                 {
1:1fe594d:                     // If the new tombstone don't supersedes the currently open tombstone, we don't have anything to return, we
1:1fe594d:                     // just add the new tombstone (because we know tombstone is not fully shadowed, this imply the new tombstone
1:1fe594d:                     // simply extend after the first one and we'll deal with it later)
1:1fe594d:                     assert metadata.comparator.compare(tombstone.start.bound, first.stop.bound) > 0;
1:1fe594d:                     openTombstones.add(tombstone);
1:1fe594d:                     return null;
1:1fe594d:                 }
1:1fe594d:             }
1:1fe594d: 
1:1fe594d:             public boolean hasOpenTombstones()
1:1fe594d:             {
1:1fe594d:                 return !openTombstones.isEmpty();
1:1fe594d:             }
1:1fe594d: 
1:1fe594d:             public void clearState()
1:1fe594d:             {
1:1fe594d:                 openTombstones.clear();
1:1fe594d:             }
1:1fe594d:         }
1:a991b64:     }
1:a991b64: }
============================================================================
author:Dave Brosius
-------------------------------------------------------------------------------
commit:22a9bf0
/////////////////////////////////////////////////////////////////////////
commit:8120bcf
/////////////////////////////////////////////////////////////////////////
1:                 this.atoms = new AtomIterator();
/////////////////////////////////////////////////////////////////////////
1:             private AtomIterator()
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:2cc26eb
/////////////////////////////////////////////////////////////////////////
1:     public abstract int compareNextTo(ClusteringBound bound) throws IOException;
/////////////////////////////////////////////////////////////////////////
1:         public int compareNextTo(ClusteringBound bound) throws IOException
/////////////////////////////////////////////////////////////////////////
1:                 ClusteringBoundOrBoundary bound = clusteringDeserializer.deserializeNextBound();
/////////////////////////////////////////////////////////////////////////
1:         public int compareNextTo(ClusteringBound bound) throws IOException
commit:71bac92
/////////////////////////////////////////////////////////////////////////
1:                 // Note that we loop on next == null because TombstoneTracker.openNew() could return null below or the atom might be shadowed.
/////////////////////////////////////////////////////////////////////////
1:                             if (!tombstoneTracker.isShadowed(atom))
1:                                 next = isRow(atom) ? readRow(atom) : tombstoneTracker.openNew(atom.asRangeTombstone());
/////////////////////////////////////////////////////////////////////////
1:                 if (next == null)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 assert !hasClosingMarkerBefore(atom);
author:Robert Stupp
-------------------------------------------------------------------------------
commit:0f5e780
/////////////////////////////////////////////////////////////////////////
1:                 return true;
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:4a00438
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.FileDataInput;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * For the legacy layout deserializer, we have to deal with the fact that a row can span multiple index blocks and that
1:      * the call to hasNext() reads the next element upfront. We must take that into account when we check in AbstractSSTableIterator if
1:      * we're past the end of an index block boundary as that check expect to account for only consumed data (that is, if hasNext has
1:      * been called and made us cross an index boundary but neither readNext() or skipNext() as yet been called, we shouldn't consider
1:      * the index block boundary crossed yet).
1:      *
1:      * TODO: we don't care about this for the current file format because a row can never span multiple index blocks (further, hasNext()
1:      * only just basically read 2 bytes from disk in that case). So once we drop backward compatibility with pre-3.0 sstable, we should
1:      * remove this.
1:      */
1:     public abstract long bytesReadForUnconsumedData();
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         public long bytesReadForUnconsumedData()
1:         {
1:             // In theory, hasNext() does consume 2-3 bytes, but we don't care about this for the current file format so returning
1:             // 0 to mean "do nothing".
1:             return 0;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         // The position in the input after the last data consumption (readNext/skipNext).
1:         private long lastConsumedPosition;
/////////////////////////////////////////////////////////////////////////
1:             this.lastConsumedPosition = currentPosition();
/////////////////////////////////////////////////////////////////////////
1:         private long currentPosition()
1:         {
1:             // We return a bogus value if the input is not file based, but check we never rely
1:             // on that value in that case in bytesReadForUnconsumedData
1:             return in instanceof FileDataInput ? ((FileDataInput)in).getFilePointer() : 0;
1:         }
1: 
1:             lastConsumedPosition = currentPosition();
/////////////////////////////////////////////////////////////////////////
1:             lastConsumedPosition = currentPosition();
1:         }
1: 
1:         public long bytesReadForUnconsumedData()
1:         {
1:             if (!(in instanceof FileDataInput))
1:                 throw new AssertionError();
1: 
1:             return currentPosition() - lastConsumedPosition;
/////////////////////////////////////////////////////////////////////////
1:             lastConsumedPosition = currentPosition();
commit:1fe594d
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOError;
1: import java.util.*;
1: 
1: import com.google.common.collect.Iterables;
1: import com.google.common.collect.PeekingIterator;
/////////////////////////////////////////////////////////////////////////
1:         // The next Unfiltered to return, computed by hasNext()
1:         private Unfiltered next;
1:         // A temporary storage for an unfiltered that isn't returned next but should be looked at just afterwards
1:         private Unfiltered saved;
1:         private boolean isFirst = true;
1:         // The Unfiltered as read from the old format input
1:         private final UnfilteredIterator iterator;
0:         // Tracks which tombstone are opened at any given point of the deserialization. Note that this
0:         // is directly populated by UnfilteredIterator.
/////////////////////////////////////////////////////////////////////////
1:             this.iterator = new UnfilteredIterator(partitionDeletion);
/////////////////////////////////////////////////////////////////////////
1:         private boolean isStatic(Unfiltered unfiltered)
1:         {
1:             return unfiltered.isRow() && ((Row)unfiltered).isStatic();
1:         }
1: 
1:             try
1:                 while (next == null)
1:                 {
1:                     if (saved == null && !iterator.hasNext())
1:                         return false;
1: 
1:                     next = saved == null ? iterator.next() : saved;
1:                     saved = null;
1: 
1:                     // The sstable iterators assume that if there is one, the static row is the first thing this deserializer will return.
1:                     // However, in the old format, a range tombstone with an empty start would sort before any static cell. So we should
1:                     // detect that case and return the static parts first if necessary.
1:                     if (isFirst && iterator.hasNext() && isStatic(iterator.peek()))
1:                     {
1:                         saved = next;
1:                         next = iterator.next();
1:                     }
1:                     isFirst = false;
1: 
1:                     // When reading old tables, we sometimes want to skip static data (due to how staticly defined column of compact
1:                     // tables are handled).
1:                     if (skipStatic && isStatic(next))
1:                         next = null;
1:                 }
1:             catch (IOError e)
1:                 if (e.getCause() != null && e.getCause() instanceof IOException)
1:                     throw (IOException)e.getCause();
1:                 throw e;
1:         private boolean isRow(LegacyLayout.LegacyAtom atom)
1:             if (atom.isCell())
1:                 return true;
1: 
1:             LegacyLayout.LegacyRangeTombstone tombstone = atom.asRangeTombstone();
1:             return tombstone.isCollectionTombstone() || tombstone.isRowDeletion(metadata);
1:             if (!hasNext())
1:                 throw new IllegalStateException();
1:             return metadata.comparator.compare(next.clustering(), bound);
1:             if (!hasNext())
1:                 throw new IllegalStateException();
1:             return next.isRow();
1:             return nextIsRow() && ((Row)next).isStatic();
1:             if (!hasNext())
1:                 throw new IllegalStateException();
1:             Unfiltered toReturn = next;
1:             next = null;
1:             return toReturn;
1:             if (!hasNext())
1:                 throw new UnsupportedOperationException();
1:             next = null;
1:             next = null;
1:             saved = null;
1:             iterator.clearState();
1:         }
1: 
1:         // Groups atoms from the input into proper Unfiltered.
1:         // Note: this could use guava AbstractIterator except that we want to be able to clear
1:         // the internal state of the iterator so it's cleaner to do it ourselves.
1:         private class UnfilteredIterator implements PeekingIterator<Unfiltered>
1:         {
1:             private final AtomIterator atoms;
1:             private final LegacyLayout.CellGrouper grouper;
1:             private final TombstoneTracker tombstoneTracker;
1: 
1:             private Unfiltered next;
1: 
1:             private UnfilteredIterator(DeletionTime partitionDeletion)
1:             {
1:                 this.grouper = new LegacyLayout.CellGrouper(metadata, helper);
1:                 this.tombstoneTracker = new TombstoneTracker(partitionDeletion);
0:                 this.atoms = new AtomIterator(tombstoneTracker);
1:             }
1: 
1:             public boolean hasNext()
1:             {
0:                 // Note that we loop on next == null because TombstoneTracker.openNew() could return null below.
1:                 while (next == null)
1:                 {
1:                     if (atoms.hasNext())
1:                     {
1:                         // If a range tombstone closes strictly before the next row/RT, we need to return that close (or boundary) marker first.
1:                         if (tombstoneTracker.hasClosingMarkerBefore(atoms.peek()))
1:                         {
1:                             next = tombstoneTracker.popClosingMarker();
1:                         }
1:                         else
1:                         {
1:                             LegacyLayout.LegacyAtom atom = atoms.next();
0:                             next = isRow(atom) ? readRow(atom) : tombstoneTracker.openNew(atom.asRangeTombstone());
1:                         }
1:                     }
1:                     else if (tombstoneTracker.hasOpenTombstones())
1:                     {
1:                         next = tombstoneTracker.popClosingMarker();
1:                     }
1:                     else
1:                     {
1:                         return false;
1:                     }
1:                 }
0:                 return next != null;
1:             }
1: 
1:             private Unfiltered readRow(LegacyLayout.LegacyAtom first)
1:             {
1:                 LegacyLayout.CellGrouper grouper = first.isStatic()
1:                                                  ? LegacyLayout.CellGrouper.staticGrouper(metadata, helper)
1:                                                  : this.grouper;
1:                 grouper.reset();
1:                 grouper.addAtom(first);
1:                 // As long as atoms are part of the same row, consume them. Note that the call to addAtom() uses
1:                 // atoms.peek() so that the atom is only consumed (by next) if it's part of the row (addAtom returns true)
1:                 while (atoms.hasNext() && grouper.addAtom(atoms.peek()))
1:                 {
1:                     atoms.next();
1:                 }
1:                 return grouper.getRow();
1:             }
1: 
1:             public Unfiltered next()
1:             {
1:                 if (!hasNext())
1:                     throw new UnsupportedOperationException();
1:                 Unfiltered toReturn = next;
1:                 next = null;
1:                 return toReturn;
1:             }
1: 
1:             public Unfiltered peek()
1:             {
1:                 if (!hasNext())
1:                     throw new UnsupportedOperationException();
1:                 return next;
1:             }
1: 
1:             public void clearState()
1:             {
1:                 atoms.clearState();
1:                 tombstoneTracker.clearState();
1:                 next = null;
1:             }
1: 
1:             public void remove()
1:             {
1:                 throw new UnsupportedOperationException();
1:             }
1:         }
1: 
1:         // Wraps the input of the deserializer to provide an iterator (and skip shadowed atoms).
1:         // Note: this could use guava AbstractIterator except that we want to be able to clear
1:         // the internal state of the iterator so it's cleaner to do it ourselves.
1:         private class AtomIterator implements PeekingIterator<LegacyLayout.LegacyAtom>
1:         {
1:             private final TombstoneTracker tombstoneTracker;
1:             private boolean isDone;
1:             private LegacyLayout.LegacyAtom next;
1: 
0:             private AtomIterator(TombstoneTracker tombstoneTracker)
1:             {
0:                 this.tombstoneTracker = tombstoneTracker;
1:             }
1: 
1:             public boolean hasNext()
1:             {
1:                 if (isDone)
1:                     return false;
1: 
1:                 while (next == null)
1:                 {
1:                     next = readAtom();
1:                     if (next == null)
1:                     {
1:                         isDone = true;
1:                         return false;
1:                     }
1: 
0:                     if (tombstoneTracker.isShadowed(next))
1:                         next = null;
1:                 }
1:                 return true;
1:             }
1: 
1:             private LegacyLayout.LegacyAtom readAtom()
1:             {
1:                 try
1:                 {
1:                     return LegacyLayout.readLegacyAtom(metadata, in, readAllAsDynamic);
1:                 }
1:                 catch (IOException e)
1:                 {
1:                     throw new IOError(e);
1:                 }
1:             }
1: 
1:             public LegacyLayout.LegacyAtom next()
1:             {
1:                 if (!hasNext())
1:                     throw new UnsupportedOperationException();
1:                 LegacyLayout.LegacyAtom toReturn = next;
1:                 next = null;
1:                 return toReturn;
1:             }
1: 
1:             public LegacyLayout.LegacyAtom peek()
1:             {
1:                 if (!hasNext())
1:                     throw new UnsupportedOperationException();
1:                 return next;
1:             }
1: 
1:             public void clearState()
1:             {
1:                 this.next = null;
1:                 this.isDone = false;
1:             }
1: 
1:             public void remove()
1:             {
1:                 throw new UnsupportedOperationException();
1:             }
1:         }
1: 
1:         /**
1:          * Tracks which range tombstones are open when deserializing the old format.
1:          */
1:         private class TombstoneTracker
1:         {
1:             private final DeletionTime partitionDeletion;
1: 
1:             // Open tombstones sorted by their closing bound (i.e. first tombstone is the first to close).
1:             // As we only track non-fully-shadowed ranges, the first range is necessarily the currently
1:             // open tombstone (the one with the higher timestamp).
1:             private final SortedSet<LegacyLayout.LegacyRangeTombstone> openTombstones;
1: 
1:             public TombstoneTracker(DeletionTime partitionDeletion)
1:             {
1:                 this.partitionDeletion = partitionDeletion;
1:                 this.openTombstones = new TreeSet<>((rt1, rt2) -> metadata.comparator.compare(rt1.stop.bound, rt2.stop.bound));
1:             }
1: 
1:             /**
1:              * Checks if the provided atom is fully shadowed by the open tombstones of this tracker (or the partition deletion).
1:              */
1:             public boolean isShadowed(LegacyLayout.LegacyAtom atom)
1:             {
1:                 long timestamp = atom.isCell() ? atom.asCell().timestamp : atom.asRangeTombstone().deletionTime.markedForDeleteAt();
1: 
1:                 if (partitionDeletion.deletes(timestamp))
1:                     return true;
1: 
1:                 SortedSet<LegacyLayout.LegacyRangeTombstone> coveringTombstones = isRow(atom) ? openTombstones : openTombstones.tailSet(atom.asRangeTombstone());
1:                 return Iterables.any(coveringTombstones, tombstone -> tombstone.deletionTime.deletes(timestamp));
1:             }
1: 
1:             /**
1:              * Whether the currently open marker closes stricly before the provided row/RT.
1:              */
1:             public boolean hasClosingMarkerBefore(LegacyLayout.LegacyAtom atom)
1:             {
1:                 return !openTombstones.isEmpty()
1:                     && metadata.comparator.compare(openTombstones.first().stop.bound, atom.clustering()) < 0;
1:             }
1: 
1:             /**
1:              * Returns the unfiltered corresponding to closing the currently open marker (and update the tracker accordingly).
1:              */
1:             public Unfiltered popClosingMarker()
1:             {
1:                 assert !openTombstones.isEmpty();
1: 
1:                 Iterator<LegacyLayout.LegacyRangeTombstone> iter = openTombstones.iterator();
1:                 LegacyLayout.LegacyRangeTombstone first = iter.next();
1:                 iter.remove();
1: 
1:                 // If that was the last open tombstone, we just want to close it. Otherwise, we have a boundary with the
1:                 // next tombstone
1:                 if (!iter.hasNext())
1:                     return new RangeTombstoneBoundMarker(first.stop.bound, first.deletionTime);
1: 
1:                 LegacyLayout.LegacyRangeTombstone next = iter.next();
1:                 return RangeTombstoneBoundaryMarker.makeBoundary(false, first.stop.bound, first.stop.bound.invert(), first.deletionTime, next.deletionTime);
1:             }
1: 
1:             /**
1:              * Update the tracker given the provided newly open tombstone. This return the Unfiltered corresponding to the opening
1:              * of said tombstone: this can be a simple open mark, a boundary (if there was an open tombstone superseded by this new one)
1:              * or even null (if the new tombston start is supersedes by the currently open tombstone).
1:              *
1:              * Note that this method assume the added tombstone is not fully shadowed, i.e. that !isShadowed(tombstone). It also
1:              * assumes no opened tombstone closes before that tombstone (so !hasClosingMarkerBefore(tombstone)).
1:              */
1:             public Unfiltered openNew(LegacyLayout.LegacyRangeTombstone tombstone)
1:             {
1:                 if (openTombstones.isEmpty())
1:                 {
1:                     openTombstones.add(tombstone);
1:                     return new RangeTombstoneBoundMarker(tombstone.start.bound, tombstone.deletionTime);
1:                 }
1: 
1:                 Iterator<LegacyLayout.LegacyRangeTombstone> iter = openTombstones.iterator();
1:                 LegacyLayout.LegacyRangeTombstone first = iter.next();
1:                 if (tombstone.deletionTime.supersedes(first.deletionTime))
1:                 {
1:                     // We're supperseding the currently open tombstone, so we should produce a boundary that close the currently open
1:                     // one and open the new one. We should also add the tombstone, but if it stop after the first one, we should
1:                     // also remove that first tombstone as it won't be useful anymore.
1:                     if (metadata.comparator.compare(tombstone.stop.bound, first.stop.bound) >= 0)
1:                         iter.remove();
1: 
1:                     openTombstones.add(tombstone);
1:                     return RangeTombstoneBoundaryMarker.makeBoundary(false, tombstone.start.bound.invert(), tombstone.start.bound, first.deletionTime, tombstone.deletionTime);
1:                 }
1:                 else
1:                 {
1:                     // If the new tombstone don't supersedes the currently open tombstone, we don't have anything to return, we
1:                     // just add the new tombstone (because we know tombstone is not fully shadowed, this imply the new tombstone
1:                     // simply extend after the first one and we'll deal with it later)
1:                     assert metadata.comparator.compare(tombstone.start.bound, first.stop.bound) > 0;
1:                     openTombstones.add(tombstone);
1:                     return null;
1:                 }
1:             }
1: 
1:             public boolean hasOpenTombstones()
1:             {
1:                 return !openTombstones.isEmpty();
1:             }
1: 
0:             private boolean formBoundary(LegacyLayout.LegacyRangeTombstone close, LegacyLayout.LegacyRangeTombstone open)
1:             {
0:                 return metadata.comparator.compare(close.stop.bound, open.start.bound) == 0;
1:             }
1: 
1:             public void clearState()
1:             {
1:                 openTombstones.clear();
1:             }
commit:6584331
/////////////////////////////////////////////////////////////////////////
1:             nextExtendedFlags = UnfilteredSerializer.readExtendedFlags(in, nextFlags);
/////////////////////////////////////////////////////////////////////////
1:             clusteringDeserializer.skipNext();
1:                 UnfilteredSerializer.serializer.skipMarkerBody(in);
1:                 UnfilteredSerializer.serializer.skipRowBody(in);
commit:665f747
/////////////////////////////////////////////////////////////////////////
1:         private int nextExtendedFlags;
/////////////////////////////////////////////////////////////////////////
0:             nextExtendedFlags = UnfilteredSerializer.isExtended(nextFlags) ? in.readUnsignedByte() : 0;
1: 
1:             clusteringDeserializer.prepare(nextFlags, nextExtendedFlags);
/////////////////////////////////////////////////////////////////////////
1:                 return UnfilteredSerializer.serializer.deserializeRowBody(in, header, helper, nextFlags, nextExtendedFlags, builder);
/////////////////////////////////////////////////////////////////////////
0:                 UnfilteredSerializer.serializer.skipRowBody(in, header, nextFlags, nextExtendedFlags);
commit:f713be4
/////////////////////////////////////////////////////////////////////////
0:             int cmp = metadata.comparator.compare(nextAtom.clustering(), bound);
0:             if (cmp != 0 || nextAtom.isCell() || !nextIsRow())
0:                 return cmp;
1: 
0:             // Comparing the clustering of the LegacyAtom to the bound work most of the time. There is the case
0:             // of LegacyRangeTombstone that are either a collectionTombstone or a rowDeletion. In those case, their
0:             // clustering will be the inclusive start of the row they are a tombstone for, which can be equal to
0:             // the slice bound. But we don't want to return equality because the LegacyTombstone should stand for
0:             // it's row and should sort accordingly. This matter particularly because SSTableIterator will skip
0:             // equal results for the start bound (see SSTableIterator.handlePreSliceData for details).
0:             return bound.isStart() ? 1 : -1;
commit:2457599
/////////////////////////////////////////////////////////////////////////
1:         private final Row.Builder builder;
/////////////////////////////////////////////////////////////////////////
0:             this.builder = ArrayBackedRow.sortedBuilder(helper.fetchedRegularColumns(header));
/////////////////////////////////////////////////////////////////////////
0:                 RangeTombstone.Bound bound = clusteringDeserializer.deserializeNextBound();
1:                 return UnfilteredSerializer.serializer.deserializeMarkerBody(in, header, bound);
1:                 builder.newRow(clusteringDeserializer.deserializeNextClustering());
0:                 return UnfilteredSerializer.serializer.deserializeRowBody(in, header, helper, nextFlags, builder);
/////////////////////////////////////////////////////////////////////////
0:                 UnfilteredSerializer.serializer.skipRowBody(in, header, nextFlags);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             return nextAtom != null || (!isDone && deserializeNextAtom());
/////////////////////////////////////////////////////////////////////////
0:                 // Nothing to do, deserializeNextAtom() changes nextAtom and it's then added to the grouper
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.db;
1: 
0: import java.io.DataInput;
1: import java.io.IOException;
1: 
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: import org.apache.cassandra.config.CFMetaData;
1: import org.apache.cassandra.db.rows.*;
1: import org.apache.cassandra.net.MessagingService;
1: 
1: /**
1:  * Helper class to deserialize Unfiltered object from disk efficiently.
1:  *
1:  * More precisely, this class is used by the low-level reader to ensure
1:  * we don't do more work than necessary (i.e. we don't allocate/deserialize
1:  * objects for things we don't care about).
1:  */
1: public abstract class UnfilteredDeserializer
1: {
1:     private static final Logger logger = LoggerFactory.getLogger(UnfilteredDeserializer.class);
1: 
1:     protected final CFMetaData metadata;
0:     protected final DataInput in;
1:     protected final SerializationHelper helper;
1: 
1:     protected UnfilteredDeserializer(CFMetaData metadata,
0:                                      DataInput in,
1:                                      SerializationHelper helper)
1:     {
1:         this.metadata = metadata;
1:         this.in = in;
1:         this.helper = helper;
1:     }
1: 
1:     public static UnfilteredDeserializer create(CFMetaData metadata,
0:                                                 DataInput in,
1:                                                 SerializationHeader header,
1:                                                 SerializationHelper helper,
1:                                                 DeletionTime partitionDeletion,
1:                                                 boolean readAllAsDynamic)
1:     {
1:         if (helper.version >= MessagingService.VERSION_30)
1:             return new CurrentDeserializer(metadata, in, header, helper);
1:         else
1:             return new OldFormatDeserializer(metadata, in, helper, partitionDeletion, readAllAsDynamic);
1:     }
1: 
1:     /**
1:      * Whether or not there is more atom to read.
1:      */
1:     public abstract boolean hasNext() throws IOException;
1: 
1:     /**
1:      * Compare the provided bound to the next atom to read on disk.
1:      *
1:      * This will not read/deserialize the whole atom but only what is necessary for the
1:      * comparison. Whenever we know what to do with this atom (read it or skip it),
1:      * readNext or skipNext should be called.
1:      */
0:     public abstract int compareNextTo(Slice.Bound bound) throws IOException;
1: 
1:     /**
1:      * Returns whether the next atom is a row or not.
1:      */
1:     public abstract boolean nextIsRow() throws IOException;
1: 
1:     /**
1:      * Returns whether the next atom is the static row or not.
1:      */
1:     public abstract boolean nextIsStatic() throws IOException;
1: 
1:     /**
1:      * Returns the next atom.
1:      */
1:     public abstract Unfiltered readNext() throws IOException;
1: 
1:     /**
1:      * Clears any state in this deserializer.
1:      */
1:     public abstract void clearState() throws IOException;
1: 
1:     /**
1:      * Skips the next atom.
1:      */
1:     public abstract void skipNext() throws IOException;
1: 
1:     private static class CurrentDeserializer extends UnfilteredDeserializer
1:     {
1:         private final ClusteringPrefix.Deserializer clusteringDeserializer;
1:         private final SerializationHeader header;
1: 
1:         private int nextFlags;
1:         private boolean isReady;
1:         private boolean isDone;
1: 
0:         private final ReusableRow row;
0:         private final RangeTombstoneMarker.Builder markerBuilder;
1: 
1:         private CurrentDeserializer(CFMetaData metadata,
0:                                     DataInput in,
1:                                     SerializationHeader header,
1:                                     SerializationHelper helper)
1:         {
1:             super(metadata, in, helper);
1:             this.header = header;
1:             this.clusteringDeserializer = new ClusteringPrefix.Deserializer(metadata.comparator, in, header);
0:             this.row = new ReusableRow(metadata.clusteringColumns().size(), header.columns().regulars, true, metadata.isCounter());
0:             this.markerBuilder = new RangeTombstoneMarker.Builder(metadata.clusteringColumns().size());
1:         }
1: 
1:         public boolean hasNext() throws IOException
1:         {
1:             if (isReady)
1:                 return true;
1: 
1:             prepareNext();
1:             return !isDone;
1:         }
1: 
1:         private void prepareNext() throws IOException
1:         {
1:             if (isDone)
1:                 return;
1: 
1:             nextFlags = in.readUnsignedByte();
1:             if (UnfilteredSerializer.isEndOfPartition(nextFlags))
1:             {
1:                 isDone = true;
1:                 isReady = false;
1:                 return;
1:             }
1: 
0:             clusteringDeserializer.prepare(nextFlags);
1:             isReady = true;
1:         }
1: 
0:         public int compareNextTo(Slice.Bound bound) throws IOException
1:         {
1:             if (!isReady)
1:                 prepareNext();
1: 
1:             assert !isDone;
1: 
1:             return clusteringDeserializer.compareNextTo(bound);
1:         }
1: 
1:         public boolean nextIsRow() throws IOException
1:         {
1:             if (!isReady)
1:                 prepareNext();
1: 
1:             return UnfilteredSerializer.kind(nextFlags) == Unfiltered.Kind.ROW;
1:         }
1: 
1:         public boolean nextIsStatic() throws IOException
1:         {
1:             // This exists only for the sake of the OldFormatDeserializer
1:             throw new UnsupportedOperationException();
1:         }
1: 
1:         public Unfiltered readNext() throws IOException
1:         {
1:             isReady = false;
1:             if (UnfilteredSerializer.kind(nextFlags) == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER)
1:             {
0:                 markerBuilder.reset();
0:                 RangeTombstone.Bound.Kind kind = clusteringDeserializer.deserializeNextBound(markerBuilder);
0:                 UnfilteredSerializer.serializer.deserializeMarkerBody(in, header, kind.isBoundary(), markerBuilder);
0:                 return markerBuilder.build();
1:             }
1:             else
1:             {
0:                 Row.Writer writer = row.writer();
0:                 clusteringDeserializer.deserializeNextClustering(writer);
0:                 UnfilteredSerializer.serializer.deserializeRowBody(in, header, helper, nextFlags, writer);
0:                 return row;
1:             }
1:         }
1: 
1:         public void skipNext() throws IOException
1:         {
1:             isReady = false;
0:             ClusteringPrefix.Kind kind = clusteringDeserializer.skipNext();
1:             if (UnfilteredSerializer.kind(nextFlags) == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER)
1:             {
0:                 UnfilteredSerializer.serializer.skipMarkerBody(in, header, kind.isBoundary());
1:             }
1:             else
1:             {
0:                 UnfilteredSerializer.serializer.skipRowBody(in, header, helper, nextFlags);
1:             }
1:         }
1: 
1:         public void clearState()
1:         {
1:             isReady = false;
1:             isDone = false;
1:         }
1:     }
1: 
1:     public static class OldFormatDeserializer extends UnfilteredDeserializer
1:     {
1:         private final boolean readAllAsDynamic;
1:         private boolean skipStatic;
1: 
1:         private int nextFlags;
1:         private boolean isDone;
0:         private boolean isStart = true;
1: 
0:         private final LegacyLayout.CellGrouper grouper;
0:         private LegacyLayout.LegacyAtom nextAtom;
1: 
0:         private boolean staticFinished;
0:         private LegacyLayout.LegacyAtom savedAtom;
1: 
0:         private final LegacyLayout.TombstoneTracker tombstoneTracker;
1: 
0:         private RangeTombstoneMarker closingMarker;
1: 
1:         private OldFormatDeserializer(CFMetaData metadata,
0:                                       DataInput in,
1:                                       SerializationHelper helper,
1:                                       DeletionTime partitionDeletion,
1:                                       boolean readAllAsDynamic)
1:         {
1:             super(metadata, in, helper);
1:             this.readAllAsDynamic = readAllAsDynamic;
0:             this.grouper = new LegacyLayout.CellGrouper(metadata, helper);
0:             this.tombstoneTracker = new LegacyLayout.TombstoneTracker(metadata, partitionDeletion);
1:         }
1: 
1:         public void setSkipStatic()
1:         {
1:             this.skipStatic = true;
1:         }
1: 
1:         public boolean hasNext() throws IOException
1:         {
0:             if (nextAtom != null)
1:                 return true;
1: 
1:             if (isDone)
0:                 return false;
1: 
0:             return deserializeNextAtom();
1:         }
1: 
0:         private boolean deserializeNextAtom() throws IOException
1:         {
0:             if (staticFinished && savedAtom != null)
1:             {
0:                 nextAtom = savedAtom;
0:                 savedAtom = null;
1:                 return true;
1:             }
1: 
0:             while (true)
1:             {
0:                 nextAtom = LegacyLayout.readLegacyAtom(metadata, in, readAllAsDynamic);
0:                 if (nextAtom == null)
1:                 {
1:                     isDone = true;
0:                     return false;
1:                 }
0:                 else if (tombstoneTracker.isShadowed(nextAtom))
1:                 {
0:                     // We don't want to return shadowed data because that would fail the contract
0:                     // of UnfilteredRowIterator. However the old format could have shadowed data, so filter it here.
0:                     nextAtom = null;
0:                     continue;
1:                 }
1: 
0:                 tombstoneTracker.update(nextAtom);
1: 
0:                 // For static compact tables, the "column_metadata" columns are supposed to be static, but in the old
0:                 // format they are intermingled with other columns. We deal with that with 2 different strategy:
0:                 //  1) for thrift queries, we basically consider everything as a "dynamic" cell. This is ok because
0:                 //     that's basically what we end up with on ThriftResultsMerger has done its thing.
0:                 //  2) otherwise, we make sure to extract the "static" columns first (see AbstractSSTableIterator.readStaticRow
0:                 //     and SSTableSimpleIterator.readStaticRow) as a first pass. So, when we do a 2nd pass for dynamic columns
0:                 //     (which in practice we only do for compactions), we want to ignore those extracted static columns.
0:                 if (skipStatic && metadata.isStaticCompactTable() && nextAtom.isCell())
1:                 {
0:                     LegacyLayout.LegacyCell cell = nextAtom.asCell();
0:                     if (cell.name.column.isStatic())
1:                     {
0:                         nextAtom = null;
0:                         continue;
1:                     }
1:                 }
1: 
0:                 // We want to fetch the static row as the first thing this deserializer return.
0:                 // However, in practice, it's possible to have range tombstone before the static row cells
0:                 // if that tombstone has an empty start. So if we do, we save it initially so we can get
0:                 // to the static parts (if there is any).
0:                 if (isStart)
1:                 {
0:                     isStart = false;
0:                     if (!nextAtom.isCell())
1:                     {
0:                         LegacyLayout.LegacyRangeTombstone tombstone = nextAtom.asRangeTombstone();
0:                         if (tombstone.start.bound.size() == 0)
1:                         {
0:                             savedAtom = tombstone;
0:                             nextAtom = LegacyLayout.readLegacyAtom(metadata, in, readAllAsDynamic);
0:                             if (nextAtom == null)
1:                             {
0:                                 // That was actually the only atom so use it after all
0:                                 nextAtom = savedAtom;
0:                                 savedAtom = null;
1:                             }
0:                             else if (!nextAtom.isStatic())
1:                             {
0:                                 // We don't have anything static. So we do want to send first
0:                                 // the saved atom, so switch
0:                                 LegacyLayout.LegacyAtom atom = nextAtom;
0:                                 nextAtom = savedAtom;
0:                                 savedAtom = atom;
1:                             }
1:                         }
1:                     }
1:                 }
1: 
1:                 return true;
1:             }
1:         }
1: 
0:         private void checkReady() throws IOException
1:         {
0:             if (nextAtom == null)
0:                 hasNext();
1:             assert !isDone;
1:         }
1: 
0:         public int compareNextTo(Slice.Bound bound) throws IOException
1:         {
0:             checkReady();
0:             return metadata.comparator.compare(nextAtom, bound);
1:         }
1: 
1:         public boolean nextIsRow() throws IOException
1:         {
0:             checkReady();
0:             if (nextAtom.isCell())
1:                 return true;
1: 
0:             LegacyLayout.LegacyRangeTombstone tombstone = nextAtom.asRangeTombstone();
0:             return tombstone.isCollectionTombstone() || tombstone.isRowDeletion(metadata);
1:         }
1: 
1:         public boolean nextIsStatic() throws IOException
1:         {
0:             checkReady();
0:             return nextAtom.isStatic();
1:         }
1: 
1:         public Unfiltered readNext() throws IOException
1:         {
0:             if (!nextIsRow())
1:             {
0:                 LegacyLayout.LegacyRangeTombstone tombstone = nextAtom.asRangeTombstone();
0:                 // TODO: this is actually more complex, we can have repeated markers etc....
0:                 if (closingMarker == null)
1:                     throw new UnsupportedOperationException();
0:                 closingMarker = new RangeTombstoneBoundMarker(tombstone.stop.bound, tombstone.deletionTime);
0:                 return new RangeTombstoneBoundMarker(tombstone.start.bound, tombstone.deletionTime);
1:             }
1: 
0:             LegacyLayout.CellGrouper grouper = nextAtom.isStatic()
0:                                              ? LegacyLayout.CellGrouper.staticGrouper(metadata, helper)
0:                                              : this.grouper;
1: 
0:             grouper.reset();
0:             grouper.addAtom(nextAtom);
0:             while (deserializeNextAtom() && grouper.addAtom(nextAtom))
1:             {
1:             }
1: 
0:             // if this was the first static row, we're done with it. Otherwise, we're also done with static.
0:             staticFinished = true;
0:             return grouper.getRow();
1:         }
1: 
1:         public void skipNext() throws IOException
1:         {
0:             readNext();
1:         }
1: 
1:         public void clearState()
1:         {
1:             isDone = false;
0:             nextAtom = null;
1:         }
1:     }
1: }
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:aa57626
/////////////////////////////////////////////////////////////////////////
1:             this.builder = BTreeRow.sortedBuilder();
commit:e51f83b
/////////////////////////////////////////////////////////////////////////
0:             this.builder = BTreeRow.sortedBuilder(helper.fetchedRegularColumns(header));
commit:639d4b2
/////////////////////////////////////////////////////////////////////////
0:             this.builder = BTreeBackedRow.sortedBuilder(helper.fetchedRegularColumns(header));
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:03f72ac
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.util.DataInputPlus;
/////////////////////////////////////////////////////////////////////////
1:     protected final DataInputPlus in;
1:                                      DataInputPlus in,
/////////////////////////////////////////////////////////////////////////
1:                                                 DataInputPlus in,
/////////////////////////////////////////////////////////////////////////
1:                                     DataInputPlus in,
/////////////////////////////////////////////////////////////////////////
1:                                       DataInputPlus in,
============================================================================