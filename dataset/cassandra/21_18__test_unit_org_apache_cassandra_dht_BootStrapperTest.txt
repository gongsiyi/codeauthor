1:0c5cd14: /*
1:0c5cd14:  * Licensed to the Apache Software Foundation (ASF) under one
1:0c5cd14:  * or more contributor license agreements.  See the NOTICE file
1:0c5cd14:  * distributed with this work for additional information
1:0c5cd14:  * regarding copyright ownership.  The ASF licenses this file
1:0c5cd14:  * to you under the Apache License, Version 2.0 (the
1:0c5cd14:  * "License"); you may not use this file except in compliance
1:0c5cd14:  * with the License.  You may obtain a copy of the License at
1:0c5cd14:  *
1:a991b64:  *     http://www.apache.org/licenses/LICENSE-2.0
1:0c5cd14:  *
1:a991b64:  * Unless required by applicable law or agreed to in writing, software
1:a991b64:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a991b64:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a991b64:  * See the License for the specific language governing permissions and
1:a991b64:  * limitations under the License.
2:0c5cd14:  */
1:0c5cd14: package org.apache.cassandra.dht;
7:0c5cd14: 
1:4856460: import static org.junit.Assert.assertEquals;
1:9a3fa88: import static org.junit.Assert.fail;
1:128cb03: 
1:b767bf7: import java.net.InetAddress;
1:b767bf7: import java.net.UnknownHostException;
1:242fa02: import java.util.Collection;
1:2deee7a: import java.util.HashSet;
1:4856460: import java.util.List;
1:a08630f: import java.util.Map;
1:4856460: import java.util.Set;
1:f2c5ad7: import java.util.UUID;
1:4856460: 
1:9a3fa88: import com.google.common.collect.Lists;
1:b767bf7: 
1:d97695b: import org.apache.commons.math3.stat.descriptive.SummaryStatistics;
1:0c5cd14: 
1:9a3fa88: import org.junit.AfterClass;
1:d2a3827: import org.junit.BeforeClass;
1:0c5cd14: import org.junit.Test;
1:018e82b: import org.junit.runner.RunWith;
1:89fbc1b: 
1:018e82b: import org.apache.cassandra.OrderedJUnit4ClassRunner;
1:438acfc: import org.apache.cassandra.SchemaLoader;
1:690fbf3: import org.apache.cassandra.config.DatabaseDescriptor;
1:7b532bc: import org.apache.cassandra.config.Schema;
1:0e96e58: import org.apache.cassandra.db.Keyspace;
1:9a3fa88: import org.apache.cassandra.dht.tokenallocator.TokenAllocation;
1:d2a3827: import org.apache.cassandra.exceptions.ConfigurationException;
1:a08630f: import org.apache.cassandra.gms.IFailureDetectionEventListener;
1:a08630f: import org.apache.cassandra.gms.IFailureDetector;
1:9b0adf2: import org.apache.cassandra.locator.IEndpointSnitch;
1:9b0adf2: import org.apache.cassandra.locator.RackInferringSnitch;
1:4856460: import org.apache.cassandra.locator.TokenMetadata;
1:9b0adf2: import org.apache.cassandra.schema.KeyspaceParams;
1:4856460: import org.apache.cassandra.service.StorageService;
1:a08630f: import org.apache.cassandra.utils.FBUtilities;
1:4856460: 
1:018e82b: @RunWith(OrderedJUnit4ClassRunner.class)
1:a08630f: public class BootStrapperTest
1:a08630f: {
1:9a3fa88:     static IPartitioner oldPartitioner;
1:0789a58: 
1:d2a3827:     @BeforeClass
1:cd8a98a:     public static void setup() throws ConfigurationException
1:a08630f:     {
1:9797511:         DatabaseDescriptor.daemonInitialization();
1:0a08525:         oldPartitioner = StorageService.instance.setPartitionerUnsafe(Murmur3Partitioner.instance);
1:d2a3827:         SchemaLoader.startGossiper();
1:d2a3827:         SchemaLoader.prepareServer();
1:d2a3827:         SchemaLoader.schemaDefinition("BootStrapperTest");
1:2954b18:     }
1:a08630f: 
1:9a3fa88:     @AfterClass
1:9a3fa88:     public static void tearDown()
1:2954b18:     {
1:0a08525:         DatabaseDescriptor.setPartitionerUnsafe(oldPartitioner);
1:2954b18:     }
1:a08630f: 
2:2954b18:     @Test
1:b767bf7:     public void testSourceTargetComputation() throws UnknownHostException
1:2954b18:     {
1:3577fd8:         final int[] clusterSizes = new int[] { 1, 3, 5, 10, 100};
1:a4e1182:         for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces())
1:2954b18:         {
1:0e96e58:             int replicationFactor = Keyspace.open(keyspaceName).getReplicationStrategy().getReplicationFactor();
1:3577fd8:             for (int clusterSize : clusterSizes)
1:3577fd8:                 if (clusterSize >= replicationFactor)
1:0e96e58:                     testSourceTargetComputation(keyspaceName, clusterSize, replicationFactor);
1:2954b18:         }
1:a2e2c03:     }
1:a08630f: 
1:0e96e58:     private RangeStreamer testSourceTargetComputation(String keyspaceName, int numOldNodes, int replicationFactor) throws UnknownHostException
3:0c5cd14:     {
1:a2e2c03:         StorageService ss = StorageService.instance;
1:0a08525:         TokenMetadata tmd = ss.getTokenMetadata();
1:a08630f: 
1:4856460:         generateFakeEndpoints(numOldNodes);
1:0a08525:         Token myToken = tmd.partitioner.getRandomToken();
1:a08630f:         InetAddress myEndpoint = InetAddress.getByName("127.0.0.1");
1:a08630f: 
1:3678daa:         assertEquals(numOldNodes, tmd.sortedTokens().size());
1:a018bcb:         RangeStreamer s = new RangeStreamer(tmd, null, myEndpoint, "Bootstrap", true, DatabaseDescriptor.getEndpointSnitch(), new StreamStateStore(), false);
1:4856460:         IFailureDetector mockFailureDetector = new IFailureDetector()
1:4856460:         {
1:4856460:             public boolean isAlive(InetAddress ep)
1:4856460:             {
1:4856460:                 return true;
1:a08630f:             }
1:a08630f: 
1:4856460:             public void interpret(InetAddress ep) { throw new UnsupportedOperationException(); }
1:4856460:             public void report(InetAddress ep) { throw new UnsupportedOperationException(); }
1:4856460:             public void registerFailureDetectionEventListener(IFailureDetectionEventListener listener) { throw new UnsupportedOperationException(); }
1:4856460:             public void unregisterFailureDetectionEventListener(IFailureDetectionEventListener listener) { throw new UnsupportedOperationException(); }
1:2d71320:             public void remove(InetAddress ep) { throw new UnsupportedOperationException(); }
1:190e27b:             public void forceConviction(InetAddress ep) { throw new UnsupportedOperationException(); }
1:4856460:         };
1:2deee7a:         s.addSourceFilter(new RangeStreamer.FailureDetectorSourceFilter(mockFailureDetector));
1:0e96e58:         s.addRanges(keyspaceName, Keyspace.open(keyspaceName).getReplicationStrategy().getPendingAddressRanges(tmd, myToken, myEndpoint));
1:4856460: 
1:0e96e58:         Collection<Map.Entry<InetAddress, Collection<Range<Token>>>> toFetch = s.toFetch().get(keyspaceName);
1:4856460: 
1:2deee7a:         // Check we get get RF new ranges in total
1:690fbf3:         Set<Range<Token>> ranges = new HashSet<>();
1:2deee7a:         for (Map.Entry<InetAddress, Collection<Range<Token>>> e : toFetch)
1:2deee7a:             ranges.addAll(e.getValue());
1:4856460: 
1:2deee7a:         assertEquals(replicationFactor, ranges.size());
1:4856460: 
1:3577fd8:         // there isn't any point in testing the size of these collections for any specific size.  When a random partitioner
1:3577fd8:         // is used, they will vary.
1:2deee7a:         assert toFetch.iterator().next().getValue().size() > 0;
1:2deee7a:         assert !toFetch.iterator().next().getKey().equals(myEndpoint);
1:f16becf:         return s;
1:4856460:     }
1:4856460: 
1:4856460:     private void generateFakeEndpoints(int numOldNodes) throws UnknownHostException
1:4856460:     {
1:9a3fa88:         generateFakeEndpoints(StorageService.instance.getTokenMetadata(), numOldNodes, 1);
1:4856460:     }
1:4856460: 
1:9a3fa88:     private void generateFakeEndpoints(TokenMetadata tmd, int numOldNodes, int numVNodes) throws UnknownHostException
1:0c5cd14:     {
1:4856460:         tmd.clearUnsafe();
1:9b0adf2:         generateFakeEndpoints(tmd, numOldNodes, numVNodes, "0", "0");
1:9b0adf2:     }
1:9b0adf2: 
1:9b0adf2:     private void generateFakeEndpoints(TokenMetadata tmd, int numOldNodes, int numVNodes, String dc, String rack) throws UnknownHostException
1:9b0adf2:     {
1:0a08525:         IPartitioner p = tmd.partitioner;
1:2954b18: 
1:4856460:         for (int i = 1; i <= numOldNodes; i++)
1:2954b18:         {
1:4856460:             // leave .1 for myEndpoint
1:9b0adf2:             InetAddress addr = InetAddress.getByName("127." + dc + "." + rack + "." + (i + 1));
1:9a3fa88:             List<Token> tokens = Lists.newArrayListWithCapacity(numVNodes);
1:9a3fa88:             for (int j = 0; j < numVNodes; ++j)
1:9a3fa88:                 tokens.add(p.getRandomToken());
1:4856460:             
1:9a3fa88:             tmd.updateNormalTokens(tokens, addr);
1:4856460:         }
4:0c5cd14:     }
1:0c5cd14:     
1:2954b18:     @Test
1:9a3fa88:     public void testAllocateTokens() throws UnknownHostException
1:4856460:     {
1:2954b18:         int vn = 16;
1:9a3fa88:         String ks = "BootStrapperTestKeyspace3";
1:9b0adf2:         TokenMetadata tm = new TokenMetadata();
1:9a3fa88:         generateFakeEndpoints(tm, 10, vn);
1:9a3fa88:         InetAddress addr = FBUtilities.getBroadcastAddress();
1:2954b18:         allocateTokensForNode(vn, ks, tm, addr);
1:2954b18:     }
1:2954b18: 
1:9b0adf2:     public void testAllocateTokensNetworkStrategy(int rackCount, int replicas) throws UnknownHostException
1:9b0adf2:     {
1:9b0adf2:         IEndpointSnitch oldSnitch = DatabaseDescriptor.getEndpointSnitch();
1:9b0adf2:         try
1:9b0adf2:         {
1:9b0adf2:             DatabaseDescriptor.setEndpointSnitch(new RackInferringSnitch());
1:9b0adf2:             int vn = 16;
1:9b0adf2:             String ks = "BootStrapperTestNTSKeyspace" + rackCount + replicas;
1:9b0adf2:             String dc = "1";
1:f2c5ad7: 
1:f2c5ad7:             // Register peers with expected DC for NetworkTopologyStrategy.
1:f2c5ad7:             TokenMetadata metadata = StorageService.instance.getTokenMetadata();
1:f2c5ad7:             metadata.clearUnsafe();
1:f2c5ad7:             metadata.updateHostId(UUID.randomUUID(), InetAddress.getByName("127.1.0.99"));
1:f2c5ad7:             metadata.updateHostId(UUID.randomUUID(), InetAddress.getByName("127.15.0.99"));
1:f2c5ad7: 
1:9b0adf2:             SchemaLoader.createKeyspace(ks, KeyspaceParams.nts(dc, replicas, "15", 15), SchemaLoader.standardCFMD(ks, "Standard1"));
1:85ac06c:             TokenMetadata tm = StorageService.instance.getTokenMetadata();
1:9b0adf2:             tm.clearUnsafe();
1:9b0adf2:             for (int i = 0; i < rackCount; ++i)
1:9b0adf2:                 generateFakeEndpoints(tm, 10, vn, dc, Integer.toString(i));
1:9b0adf2:             InetAddress addr = InetAddress.getByName("127." + dc + ".0.99");
1:9b0adf2:             allocateTokensForNode(vn, ks, tm, addr);
1:9b0adf2:             // Note: Not matching replication factor in second datacentre, but this should not affect us.
1:9b0adf2:         } finally {
1:9b0adf2:             DatabaseDescriptor.setEndpointSnitch(oldSnitch);
1:9b0adf2:         }
1:9b0adf2:     }
1:9b0adf2: 
1:9b0adf2:     @Test
1:9b0adf2:     public void testAllocateTokensNetworkStrategyOneRack() throws UnknownHostException
1:9b0adf2:     {
1:9b0adf2:         testAllocateTokensNetworkStrategy(1, 3);
1:9b0adf2:     }
1:9b0adf2: 
1:9b0adf2:     @Test(expected = ConfigurationException.class)
1:9b0adf2:     public void testAllocateTokensNetworkStrategyTwoRacks() throws UnknownHostException
1:9b0adf2:     {
1:9b0adf2:         testAllocateTokensNetworkStrategy(2, 3);
1:9b0adf2:     }
1:9b0adf2: 
1:9b0adf2:     @Test
1:9b0adf2:     public void testAllocateTokensNetworkStrategyThreeRacks() throws UnknownHostException
1:9b0adf2:     {
1:9b0adf2:         testAllocateTokensNetworkStrategy(3, 3);
1:9b0adf2:     }
1:9b0adf2: 
1:9b0adf2:     @Test
1:9b0adf2:     public void testAllocateTokensNetworkStrategyFiveRacks() throws UnknownHostException
1:9b0adf2:     {
1:9b0adf2:         testAllocateTokensNetworkStrategy(5, 3);
1:9b0adf2:     }
1:9b0adf2: 
1:9b0adf2:     @Test
1:9b0adf2:     public void testAllocateTokensNetworkStrategyOneRackOneReplica() throws UnknownHostException
1:9b0adf2:     {
1:9b0adf2:         testAllocateTokensNetworkStrategy(1, 1);
1:9b0adf2:     }
1:9b0adf2: 
1:9a3fa88:     private void allocateTokensForNode(int vn, String ks, TokenMetadata tm, InetAddress addr)
1:2954b18:     {
1:85ac06c:         SummaryStatistics os = TokenAllocation.replicatedOwnershipStats(tm.cloneOnlyTokenMap(), Keyspace.open(ks).getReplicationStrategy(), addr);
1:9a3fa88:         Collection<Token> tokens = BootStrapper.allocateTokens(tm, addr, ks, vn);
1:9a3fa88:         assertEquals(vn, tokens.size());
1:9a3fa88:         tm.updateNormalTokens(tokens, addr);
1:85ac06c:         SummaryStatistics ns = TokenAllocation.replicatedOwnershipStats(tm.cloneOnlyTokenMap(), Keyspace.open(ks).getReplicationStrategy(), addr);
1:9a3fa88:         verifyImprovement(os, ns);
1:2954b18:     }
1:2954b18: 
1:9a3fa88:     private void verifyImprovement(SummaryStatistics os, SummaryStatistics ns)
1:2954b18:     {
1:9a3fa88:         if (ns.getStandardDeviation() > os.getStandardDeviation())
1:2954b18:         {
1:9a3fa88:             fail(String.format("Token allocation unexpectedly increased standard deviation.\nStats before:\n%s\nStats after:\n%s", os, ns));
1:2954b18:         }
1:2954b18:     }
1:2954b18: 
1:2954b18:     
1:2954b18:     @Test
1:9a3fa88:     public void testAllocateTokensMultipleKeyspaces() throws UnknownHostException
1:2954b18:     {
1:9a3fa88:         // TODO: This scenario isn't supported very well. Investigate a multi-keyspace version of the algorithm.
2:9a3fa88:         int vn = 16;
1:9a3fa88:         String ks3 = "BootStrapperTestKeyspace4"; // RF = 3
1:9a3fa88:         String ks2 = "BootStrapperTestKeyspace5"; // RF = 2
1:2954b18: 
1:2954b18:         TokenMetadata tm = new TokenMetadata();
1:9a3fa88:         generateFakeEndpoints(tm, 10, vn);
1:2954b18:         
1:9a3fa88:         InetAddress dcaddr = FBUtilities.getBroadcastAddress();
1:9a3fa88:         SummaryStatistics os3 = TokenAllocation.replicatedOwnershipStats(tm, Keyspace.open(ks3).getReplicationStrategy(), dcaddr);
1:9a3fa88:         SummaryStatistics os2 = TokenAllocation.replicatedOwnershipStats(tm, Keyspace.open(ks2).getReplicationStrategy(), dcaddr);
1:9a3fa88:         String cks = ks3;
1:9a3fa88:         String nks = ks2;
1:9a3fa88:         for (int i=11; i<=20; ++i)
1:0c5cd14:         {
1:9a3fa88:             allocateTokensForNode(vn, cks, tm, InetAddress.getByName("127.0.0." + (i + 1)));
1:9a3fa88:             String t = cks; cks = nks; nks = t;
1:2954b18:         }
1:0c5cd14:         
1:9a3fa88:         SummaryStatistics ns3 = TokenAllocation.replicatedOwnershipStats(tm, Keyspace.open(ks3).getReplicationStrategy(), dcaddr);
1:9a3fa88:         SummaryStatistics ns2 = TokenAllocation.replicatedOwnershipStats(tm, Keyspace.open(ks2).getReplicationStrategy(), dcaddr);
1:9a3fa88:         verifyImprovement(os3, ns3);
1:9a3fa88:         verifyImprovement(os2, ns2);
1:0c5cd14:     }
1:0c5cd14: }
============================================================================
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:49b0805
commit:af60ca9
commit:0a08525
/////////////////////////////////////////////////////////////////////////
1:         oldPartitioner = StorageService.instance.setPartitionerUnsafe(Murmur3Partitioner.instance);
/////////////////////////////////////////////////////////////////////////
1:         DatabaseDescriptor.setPartitionerUnsafe(oldPartitioner);
/////////////////////////////////////////////////////////////////////////
1:         TokenMetadata tmd = ss.getTokenMetadata();
1:         Token myToken = tmd.partitioner.getRandomToken();
/////////////////////////////////////////////////////////////////////////
1:         IPartitioner p = tmd.partitioner;
commit:0e96e58
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.Keyspace;
/////////////////////////////////////////////////////////////////////////
0:         for (String keyspaceName : Schema.instance.getNonSystemKeyspaces())
1:             int replicationFactor = Keyspace.open(keyspaceName).getReplicationStrategy().getReplicationFactor();
1:                     testSourceTargetComputation(keyspaceName, clusterSize, replicationFactor);
1:     private RangeStreamer testSourceTargetComputation(String keyspaceName, int numOldNodes, int replicationFactor) throws UnknownHostException
/////////////////////////////////////////////////////////////////////////
1:         s.addRanges(keyspaceName, Keyspace.open(keyspaceName).getReplicationStrategy().getPendingAddressRanges(tmd, myToken, myEndpoint));
1:         Collection<Map.Entry<InetAddress, Collection<Range<Token>>>> toFetch = s.toFetch().get(keyspaceName);
author:Dikang Gu
-------------------------------------------------------------------------------
commit:85ac06c
/////////////////////////////////////////////////////////////////////////
1:             TokenMetadata tm = StorageService.instance.getTokenMetadata();
/////////////////////////////////////////////////////////////////////////
1:         SummaryStatistics os = TokenAllocation.replicatedOwnershipStats(tm.cloneOnlyTokenMap(), Keyspace.open(ks).getReplicationStrategy(), addr);
1:         SummaryStatistics ns = TokenAllocation.replicatedOwnershipStats(tm.cloneOnlyTokenMap(), Keyspace.open(ks).getReplicationStrategy(), addr);
author:Jeff Jirsa
-------------------------------------------------------------------------------
commit:0240411
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:cd8a98a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public static void setup() throws ConfigurationException
/////////////////////////////////////////////////////////////////////////
commit:d45f323
author:Nachiket Patil
-------------------------------------------------------------------------------
commit:f2c5ad7
/////////////////////////////////////////////////////////////////////////
1: import java.util.UUID;
/////////////////////////////////////////////////////////////////////////
0:     public static void setup() throws Exception
/////////////////////////////////////////////////////////////////////////
1: 
1:             // Register peers with expected DC for NetworkTopologyStrategy.
1:             TokenMetadata metadata = StorageService.instance.getTokenMetadata();
1:             metadata.clearUnsafe();
1:             metadata.updateHostId(UUID.randomUUID(), InetAddress.getByName("127.1.0.99"));
1:             metadata.updateHostId(UUID.randomUUID(), InetAddress.getByName("127.15.0.99"));
1: 
author:Robert Stupp
-------------------------------------------------------------------------------
commit:9797511
/////////////////////////////////////////////////////////////////////////
1:         DatabaseDescriptor.daemonInitialization();
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:de1a96c
commit:a4e1182
/////////////////////////////////////////////////////////////////////////
1:         for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces())
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:9b0adf2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.locator.IEndpointSnitch;
1: import org.apache.cassandra.locator.RackInferringSnitch;
1: import org.apache.cassandra.schema.KeyspaceParams;
/////////////////////////////////////////////////////////////////////////
1:         generateFakeEndpoints(tmd, numOldNodes, numVNodes, "0", "0");
1:     }
1: 
1:     private void generateFakeEndpoints(TokenMetadata tmd, int numOldNodes, int numVNodes, String dc, String rack) throws UnknownHostException
1:     {
1:             InetAddress addr = InetAddress.getByName("127." + dc + "." + rack + "." + (i + 1));
/////////////////////////////////////////////////////////////////////////
1:     public void testAllocateTokensNetworkStrategy(int rackCount, int replicas) throws UnknownHostException
1:     {
1:         IEndpointSnitch oldSnitch = DatabaseDescriptor.getEndpointSnitch();
1:         try
1:         {
1:             DatabaseDescriptor.setEndpointSnitch(new RackInferringSnitch());
1:             int vn = 16;
1:             String ks = "BootStrapperTestNTSKeyspace" + rackCount + replicas;
1:             String dc = "1";
1:             SchemaLoader.createKeyspace(ks, KeyspaceParams.nts(dc, replicas, "15", 15), SchemaLoader.standardCFMD(ks, "Standard1"));
1:             TokenMetadata tm = new TokenMetadata();
1:             tm.clearUnsafe();
1:             for (int i = 0; i < rackCount; ++i)
1:                 generateFakeEndpoints(tm, 10, vn, dc, Integer.toString(i));
1:             InetAddress addr = InetAddress.getByName("127." + dc + ".0.99");
1:             allocateTokensForNode(vn, ks, tm, addr);
1:             // Note: Not matching replication factor in second datacentre, but this should not affect us.
1:         } finally {
1:             DatabaseDescriptor.setEndpointSnitch(oldSnitch);
1:         }
1:     }
1: 
1:     @Test
1:     public void testAllocateTokensNetworkStrategyOneRack() throws UnknownHostException
1:     {
1:         testAllocateTokensNetworkStrategy(1, 3);
1:     }
1: 
1:     @Test(expected = ConfigurationException.class)
1:     public void testAllocateTokensNetworkStrategyTwoRacks() throws UnknownHostException
1:     {
1:         testAllocateTokensNetworkStrategy(2, 3);
1:     }
1: 
1:     @Test
1:     public void testAllocateTokensNetworkStrategyThreeRacks() throws UnknownHostException
1:     {
1:         testAllocateTokensNetworkStrategy(3, 3);
1:     }
1: 
1:     @Test
1:     public void testAllocateTokensNetworkStrategyFiveRacks() throws UnknownHostException
1:     {
1:         testAllocateTokensNetworkStrategy(5, 3);
1:     }
1: 
1:     @Test
1:     public void testAllocateTokensNetworkStrategyOneRackOneReplica() throws UnknownHostException
1:     {
1:         testAllocateTokensNetworkStrategy(1, 1);
1:     }
1: 
commit:2954b18
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.locator.IEndpointSnitch;
0: import org.apache.cassandra.locator.RackInferringSnitch;
0: import org.apache.cassandra.schema.KeyspaceParams;
/////////////////////////////////////////////////////////////////////////
0:         generateFakeEndpoints(tmd, numOldNodes, numVNodes, "0", "0");
1:     }
1: 
0:     private void generateFakeEndpoints(TokenMetadata tmd, int numOldNodes, int numVNodes, String dc, String rack) throws UnknownHostException
1:     {
0:             InetAddress addr = InetAddress.getByName("127." + dc + "." + rack + "." + (i + 1));
/////////////////////////////////////////////////////////////////////////
0:     public void testAllocateTokensNetworkStrategy(int rackCount, int replicas) throws UnknownHostException
1:     {
0:         IEndpointSnitch oldSnitch = DatabaseDescriptor.getEndpointSnitch();
0:         try
1:         {
0:             DatabaseDescriptor.setEndpointSnitch(new RackInferringSnitch());
1:             int vn = 16;
0:             String ks = "BootStrapperTestNTSKeyspace" + rackCount + replicas;
0:             String dc = "1";
0:             SchemaLoader.createKeyspace(ks, KeyspaceParams.nts(dc, replicas, "15", 15), SchemaLoader.standardCFMD(ks, "Standard1"));
1:             TokenMetadata tm = new TokenMetadata();
0:             tm.clearUnsafe();
0:             for (int i = 0; i < rackCount; ++i)
0:                 generateFakeEndpoints(tm, 10, vn, dc, Integer.toString(i));
0:             InetAddress addr = InetAddress.getByName("127." + dc + ".0.99");
1:             allocateTokensForNode(vn, ks, tm, addr);
0:             // Note: Not matching replication factor in second datacentre, but this should not affect us.
0:         } finally {
0:             DatabaseDescriptor.setEndpointSnitch(oldSnitch);
1:         }
1:     }
1: 
1:     @Test
0:     public void testAllocateTokensNetworkStrategyOneRack() throws UnknownHostException
1:     {
0:         testAllocateTokensNetworkStrategy(1, 3);
1:     }
1: 
0:     @Test(expected = ConfigurationException.class)
0:     public void testAllocateTokensNetworkStrategyTwoRacks() throws UnknownHostException
1:     {
0:         testAllocateTokensNetworkStrategy(2, 3);
1:     }
1: 
1:     @Test
0:     public void testAllocateTokensNetworkStrategyThreeRacks() throws UnknownHostException
1:     {
0:         testAllocateTokensNetworkStrategy(3, 3);
1:     }
1: 
1:     @Test
0:     public void testAllocateTokensNetworkStrategyFiveRacks() throws UnknownHostException
1:     {
0:         testAllocateTokensNetworkStrategy(5, 3);
1:     }
1: 
1:     @Test
0:     public void testAllocateTokensNetworkStrategyOneRackOneReplica() throws UnknownHostException
1:     {
0:         testAllocateTokensNetworkStrategy(1, 1);
1:     }
1: 
commit:69f77cb
/////////////////////////////////////////////////////////////////////////
0:         oldPartitioner = StorageService.instance.setPartitionerUnsafe(Murmur3Partitioner.instance);
/////////////////////////////////////////////////////////////////////////
0:         DatabaseDescriptor.setPartitionerUnsafe(oldPartitioner);
/////////////////////////////////////////////////////////////////////////
0:         TokenMetadata tmd = ss.getTokenMetadata();
0:         Token myToken = tmd.partitioner.getRandomToken();
/////////////////////////////////////////////////////////////////////////
0:         IPartitioner p = tmd.partitioner;
commit:ad84e4d
/////////////////////////////////////////////////////////////////////////
0:         IPartitioner p = StorageService.getPartitioner();
author:Paulo Motta
-------------------------------------------------------------------------------
commit:a018bcb
/////////////////////////////////////////////////////////////////////////
1:         RangeStreamer s = new RangeStreamer(tmd, null, myEndpoint, "Bootstrap", true, DatabaseDescriptor.getEndpointSnitch(), new StreamStateStore(), false);
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:a22ce89
/////////////////////////////////////////////////////////////////////////
0:         oldPartitioner = DatabaseDescriptor.getPartitioner();
0:         DatabaseDescriptor.setPartitioner(Murmur3Partitioner.instance);
/////////////////////////////////////////////////////////////////////////
0:         DatabaseDescriptor.setPartitioner(oldPartitioner);
/////////////////////////////////////////////////////////////////////////
0:         Token myToken = StorageService.getPartitioner().getRandomToken();
0:         TokenMetadata tmd = ss.getTokenMetadata();
/////////////////////////////////////////////////////////////////////////
0:         IPartitioner p = StorageService.getPartitioner();
commit:26d1b68
commit:b3ae77d
/////////////////////////////////////////////////////////////////////////
commit:e26b726
/////////////////////////////////////////////////////////////////////////
commit:e987e3b
/////////////////////////////////////////////////////////////////////////
0:         StorageService.instance.initServer(0);
commit:9fa7a32
/////////////////////////////////////////////////////////////////////////
0:             ss.onChange(bootstrapAddrs[i], ApplicationState.STATUS, StorageService.instance.valueFactory.bootstrapping(token));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(bootstrapAddrs[2], ApplicationState.STATUS, StorageService.instance.valueFactory.normal(token));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(myEndpoint, ApplicationState.STATUS, StorageService.instance.valueFactory.bootstrapping(fakeToken));
commit:2f5f0c2
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.Table;
/////////////////////////////////////////////////////////////////////////
0:             int replicationFactor = Table.open(table).getReplicationStrategy().getReplicationFactor();
commit:89fbc1b
/////////////////////////////////////////////////////////////////////////
1: 
0: import org.apache.cassandra.gms.ApplicationState;
/////////////////////////////////////////////////////////////////////////
0:             ss.onChange(bootstrapAddrs[i], ApplicationState.STATUS, StorageService.valueFactory.bootstrapping(token));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(bootstrapAddrs[2], ApplicationState.STATUS, StorageService.valueFactory.normal(token));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(myEndpoint, ApplicationState.STATUS, StorageService.valueFactory.bootstrapping(fakeToken));
commit:629fa9e
/////////////////////////////////////////////////////////////////////////
0:             ss.onChange(bootstrapAddrs[i], ApplicationState.STATE_MOVE, StorageService.stateFactory.bootstrapping(token));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(bootstrapAddrs[2], ApplicationState.STATE_MOVE, StorageService.stateFactory.normal(token));
/////////////////////////////////////////////////////////////////////////
0:         Token fakeToken = StorageService.getPartitioner().midpoint(range5.left, range5.right);
0:         ss.onChange(myEndpoint, ApplicationState.STATE_MOVE, StorageService.stateFactory.bootstrapping(fakeToken));
commit:0789a58
/////////////////////////////////////////////////////////////////////////
0:         generateFakeEndpoints(5);
0:         InetAddress two = InetAddress.getByName("127.0.0.2");
0:         InetAddress three = InetAddress.getByName("127.0.0.3");
0:         InetAddress four = InetAddress.getByName("127.0.0.4");
0:         InetAddress five = InetAddress.getByName("127.0.0.5");
1: 
0:         load.put(four, 4.0);
0:         load.put(five, 5.0);
0:         assert five.equals(source) : five + " != " + source;
0:         Range range5 = ss.getPrimaryRangeForEndpoint(five);
0:         Token fakeToken = ((IPartitioner)StorageService.getPartitioner()).midpoint(range5.left, range5.right);
0:         assert range5.contains(fakeToken);
0:         InetAddress source4 = BootStrapper.getBootstrapSource(tmd, load);
0:         assert four.equals(source4) : four + " != " + source4;
commit:18b2a16
/////////////////////////////////////////////////////////////////////////
0:         Range range3 = ss.getPrimaryRangeForEndpoint(three);
commit:30f0216
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         Token fakeToken = ((IPartitioner)StorageService.getPartitioner()).midpoint(range3.left, range3.right);
commit:a2e2c03
/////////////////////////////////////////////////////////////////////////
1:         StorageService ss = StorageService.instance;
/////////////////////////////////////////////////////////////////////////
0:         StorageService ss = StorageService.instance;
/////////////////////////////////////////////////////////////////////////
0:         TokenMetadata tmd = StorageService.instance.getTokenMetadata();
/////////////////////////////////////////////////////////////////////////
1: }
commit:720c49a
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(myEndpoint, StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_BOOTSTRAPPING + StorageService.Delimiter + ss.getPartitioner().getTokenFactory().toString(fakeToken)));
commit:c10813c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.gms.ApplicationState;
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(myEndpoint, StorageService.STATE_BOOTSTRAPPING, new ApplicationState(ss.getPartitioner().getTokenFactory().toString(fakeToken)));
0:         tmd = ss.getTokenMetadata();
/////////////////////////////////////////////////////////////////////////
0:             tmd.updateNormalToken(p.getRandomToken(), InetAddress.getByName("127.0.0." + (i + 1)));
commit:4a6b002
/////////////////////////////////////////////////////////////////////////
0:             tmd.update(p.getRandomToken(), InetAddress.getByName("127.0.0." + (i + 1)));
commit:5d44703
/////////////////////////////////////////////////////////////////////////
0:         StorageService.updateBootstrapRanges(StorageService.instance().getReplicationStrategy(), tmd, fakeToken, myEndpoint);
commit:a08630f
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.util.HashMap;
1: import java.util.Map;
0: import com.google.common.collect.Multimap;
1: import org.apache.cassandra.gms.IFailureDetectionEventListener;
1: import org.apache.cassandra.gms.IFailureDetector;
1: import org.apache.cassandra.utils.FBUtilities;
1: public class BootStrapperTest
1: {
0:     @Test
0:     public void testGuessToken() throws IOException
1:     {
0:         StorageService ss = StorageService.instance();
1: 
0:         generateFakeEndpoints(3);
1: 
0:         InetAddress one = InetAddress.getByName("127.0.0.2");
0:         InetAddress two = InetAddress.getByName("127.0.0.3");
0:         InetAddress three = InetAddress.getByName("127.0.0.4");
0:         Map<InetAddress, Double> load = new HashMap<InetAddress, Double>();
0:         load.put(one, 1.0);
0:         load.put(two, 2.0);
0:         load.put(three, 3.0);
1: 
0:         TokenMetadata tmd = ss.getTokenMetadata();
0:         InetAddress source = BootStrapper.getBootstrapSource(tmd, load);
0:         assert three.equals(source);
1: 
1:         InetAddress myEndpoint = InetAddress.getByName("127.0.0.1");
0:         tmd.setBootstrapping(myEndpoint, true);
0:         Range range3 = ss.getPrimaryRangeForEndPoint(three);
0:         Token fakeToken = ((IPartitioner)StorageService.getPartitioner()).midpoint(range3.left(), range3.right());
0:         assert range3.contains(fakeToken);
0:         tmd.update(fakeToken, myEndpoint);
1: 
0:         InetAddress source2 = BootStrapper.getBootstrapSource(tmd, load);
0:         assert two.equals(source2) : source2;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             // TODO use this when #519 is fixed
0:             // tmd.update(p.getRandomToken(), InetAddress.getByName("127.0.0." + (i + 1)));
0:             tmd.update(p.getToken(FBUtilities.bytesToHex(FBUtilities.toByteArray(i * 13))), InetAddress.getByName("127.0.0." + (i + 1)));
commit:e946c63
/////////////////////////////////////////////////////////////////////////
0:         Token myToken = StorageService.getPartitioner().getRandomToken();
/////////////////////////////////////////////////////////////////////////
0:             tmd.update(p.getRandomToken(), InetAddress.getByName("127.0.0." + (i + 1)));
commit:3678daa
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(numOldNodes, tmd.sortedTokens().size());
commit:242fa02
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collection;
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.collect.Multimap;
/////////////////////////////////////////////////////////////////////////
0:         Multimap<Range, InetAddress> res = b.getRangesWithSources();
0:         for (Map.Entry<Range, Collection<InetAddress>> e : res.asMap().entrySet())
/////////////////////////////////////////////////////////////////////////
0:         Multimap<InetAddress, Range> temp = BootStrapper.getWorkMap(res, mockFailureDetector);
0:         assertEquals(1, temp.asMap().values().iterator().next().size());
commit:128cb03
/////////////////////////////////////////////////////////////////////////
0:         StorageService ss = StorageService.instance();
1: 
0:         assertEquals(numOldNodes, tmd.cloneTokenEndPointMap().size());
commit:4856460
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
0: import java.util.Map;
1: import java.util.Set;
0: import org.apache.commons.lang.StringUtils;
1: import static org.junit.Assert.assertEquals;
1: import org.apache.cassandra.locator.TokenMetadata;
1: import org.apache.cassandra.service.StorageService;
0: import org.apache.cassandra.gms.IFailureDetector;
0: import org.apache.cassandra.gms.IFailureDetectionEventListener;
1: 
0:         testSourceTargetComputation(1);
0:         testSourceTargetComputation(3);
0:         testSourceTargetComputation(100);
0:     private void testSourceTargetComputation(int numOldNodes) throws UnknownHostException
1:         generateFakeEndpoints(numOldNodes);
1:         
0:         Token myToken = StorageService.getPartitioner().getDefaultToken();
0:         InetAddress myEndpoint = InetAddress.getByName("127.0.0.1");
1:  
0:         StorageService ss = StorageService.instance();
0:         ss.updateTokenMetadataUnsafe(myToken, myEndpoint);
1: 
0:         TokenMetadata tmd = ss.getTokenMetadata();
0:         assertEquals(numOldNodes + 1, tmd.cloneTokenEndPointMap().size());
0:         BootStrapper b = new BootStrapper(ss.getReplicationStrategy(), myEndpoint, myToken, tmd);
0:         Map<Range, Set<InetAddress>> res = b.getRangesWithSources();
1:         
0:         int transferCount = 0;
0:         for (Map.Entry<Range, Set<InetAddress>> e : res.entrySet())
0:             assert e.getValue() != null && e.getValue().size() > 0 : StringUtils.join(e.getValue(), ", ");
0:             transferCount++;
1: 
0:         /* Only 1 transfer from old node to new node */
0:         assertEquals(1, transferCount);
1:         IFailureDetector mockFailureDetector = new IFailureDetector()
1:         {
1:             public boolean isAlive(InetAddress ep)
1:             {
1:                 return true;
1:             }
1: 
1:             public void interpret(InetAddress ep) { throw new UnsupportedOperationException(); }
1:             public void report(InetAddress ep) { throw new UnsupportedOperationException(); }
1:             public void registerFailureDetectionEventListener(IFailureDetectionEventListener listener) { throw new UnsupportedOperationException(); }
1:             public void unregisterFailureDetectionEventListener(IFailureDetectionEventListener listener) { throw new UnsupportedOperationException(); }
1:         };
0:         Map<InetAddress, List<Range>> temp = BootStrapper.getWorkMap(res, mockFailureDetector);
0:         assertEquals(1, temp.keySet().size());
0:         assertEquals(1, temp.values().iterator().next().size());
0:         assert !temp.keySet().iterator().next().equals(myEndpoint);
1:     }
1: 
1:     private void generateFakeEndpoints(int numOldNodes) throws UnknownHostException
1:     {
0:         TokenMetadata tmd = StorageService.instance().getTokenMetadata();
1:         tmd.clearUnsafe();
0:         IPartitioner<?> p = StorageService.getPartitioner();
1: 
1:         for (int i = 1; i <= numOldNodes; i++)
1:         {
1:             // leave .1 for myEndpoint
0:             tmd.update(p.getDefaultToken(), InetAddress.getByName("127.0.0." + (i + 1)));
1:         }
commit:924c7e5
/////////////////////////////////////////////////////////////////////////
0: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
0:         BootStrapper b = new BootStrapper(Arrays.asList(newEndPoint), newToken );
commit:b767bf7
/////////////////////////////////////////////////////////////////////////
1: import java.net.InetAddress;
1: import java.net.UnknownHostException;
1: 
1:     public void testSourceTargetComputation() throws UnknownHostException
0:         InetAddress newEndPoint = InetAddress.getByName("1.2.3.10");
0:         BootStrapper b = new BootStrapper(new InetAddress[]{newEndPoint}, newToken );
/////////////////////////////////////////////////////////////////////////
0:         Map<InetAddress, Map<InetAddress,List<Range>>> temp = LeaveJoinProtocolHelper.getWorkMap(res);
0:         Map<InetAddress,Map<InetAddress,List<Range>>> res2 = LeaveJoinProtocolHelper.filterRangesForTargetEndPoint(temp, newEndPoint);
0:         assertTrue(((Map<InetAddress,List<Range>>)res2.values().toArray()[0]).containsKey(newEndPoint));
0:     private IPartitioner generateOldTokens(int numOldNodes) throws UnknownHostException
0:             InetAddress e = InetAddress.getByName("127.0.0." + i);
commit:d309c5d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         StorageService.instance().updateTokenMetadataUnsafe(newToken, newEndPoint);
/////////////////////////////////////////////////////////////////////////
0:             StorageService.instance().updateTokenMetadataUnsafe(t, e);
commit:0c5cd14
/////////////////////////////////////////////////////////////////////////
1: /*
1: * Licensed to the Apache Software Foundation (ASF) under one
1: * or more contributor license agreements.  See the NOTICE file
1: * distributed with this work for additional information
1: * regarding copyright ownership.  The ASF licenses this file
1: * to you under the Apache License, Version 2.0 (the
1: * "License"); you may not use this file except in compliance
1: * with the License.  You may obtain a copy of the License at
1: *
0: *    http://www.apache.org/licenses/LICENSE-2.0
1: *
0: * Unless required by applicable law or agreed to in writing,
0: * software distributed under the License is distributed on an
0: * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0: * KIND, either express or implied.  See the License for the
0: * specific language governing permissions and limitations
0: * under the License.
1: */
1: package org.apache.cassandra.dht;
1: 
0: import static org.junit.Assert.*;
1: 
0: import java.util.List;
0: import java.util.Map;
1: 
0: import org.apache.cassandra.locator.TokenMetadata;
0: import org.apache.cassandra.net.EndPoint;
0: import org.apache.cassandra.service.StorageService;
1: import org.junit.Test;
1: 
0: public class BootStrapperTest {
0:     @Test
0:     public void testSourceTargetComputation() 
1:     {
0:         int numOldNodes = 3;
0:         IPartitioner p = generateOldTokens(numOldNodes);
1:         
0:         Token newToken = p.getDefaultToken();
0:         EndPoint newEndPoint = new EndPoint("1.2.3.10",100);
1:  
0:         /* New token needs to be part of the map for the algorithm
0:          * to calculate the ranges correctly
1:          */
0:         StorageService.instance().updateTokenMetadata(newToken, newEndPoint);
1: 
0:         BootStrapper b = new BootStrapper(new EndPoint[]{newEndPoint}, newToken );
0:         Map<Range,List<BootstrapSourceTarget>> res = b.getRangesWithSourceTarget();
1:         
0:         int transferCount = 0;
0:         for ( Map.Entry<Range, List<BootstrapSourceTarget>> e: res.entrySet())
1:         {
0:             if (e.getValue() != null && e.getValue().size() >0)
1:             {
0:                 transferCount++;
1:             }
1:         }
0:         /* Only 1 transfer from old node to new node */
0:         assertEquals(1, transferCount);
0:         Map<EndPoint, Map<EndPoint,List<Range>>> temp = LeaveJoinProtocolHelper.getWorkMap(res);
0:         assertEquals(1, temp.keySet().size());
0:         assertEquals(1, temp.entrySet().size());
1: 
0:         Map<EndPoint,Map<EndPoint,List<Range>>> res2 = LeaveJoinProtocolHelper.filterRangesForTargetEndPoint(temp, newEndPoint);
0:         /* After filtering, still only 1 transfer */
0:         assertEquals(1, res2.keySet().size());
0:         assertEquals(1, res2.entrySet().size());
0:         assertTrue(((Map<EndPoint,List<Range>>)res2.values().toArray()[0]).containsKey(newEndPoint));
1:     }
1: 
0:     private IPartitioner generateOldTokens(int numOldNodes)
1:     {
0:         IPartitioner p = new RandomPartitioner();
0:         for (int i = 0 ; i< numOldNodes; i++)
1:         {
0:             EndPoint e  = new EndPoint("127.0.0."+i, 100);
0:             Token t = p.getDefaultToken();
0:             StorageService.instance().updateTokenMetadata(t, e);
1:         }
0:         return p;
1:     }
1: }
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:d97695b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.commons.math3.stat.descriptive.SummaryStatistics;
commit:690fbf3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.DatabaseDescriptor;
/////////////////////////////////////////////////////////////////////////
0:         RangeStreamer s = new RangeStreamer(tmd, null, myEndpoint, "Bootstrap", true, DatabaseDescriptor.getEndpointSnitch(), new StreamStateStore());
/////////////////////////////////////////////////////////////////////////
1:         Set<Range<Token>> ranges = new HashSet<>();
commit:5151169
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         RangeStreamer s = new RangeStreamer(tmd, myEndpoint, "Bootstrap");
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:a991b64
/////////////////////////////////////////////////////////////////////////
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
commit:15ae2f6
commit:438acfc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.SchemaLoader;
/////////////////////////////////////////////////////////////////////////
0: public class BootStrapperTest extends SchemaLoader
commit:07cdfd0
/////////////////////////////////////////////////////////////////////////
0: 
0:         InetAddress[] addrs = new InetAddress[]
0:             InetAddress.getByName("127.0.0.2"),
0:             InetAddress.getByName("127.0.0.3"),
0:             InetAddress.getByName("127.0.0.4"),
0:             InetAddress.getByName("127.0.0.5"),
0:             InetAddress.getByName("127.0.0.12"),
0:             InetAddress.getByName("127.0.0.13"),
0:             InetAddress.getByName("127.0.0.14"),
0:             InetAddress.getByName("127.0.0.15"),
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:         catch (RuntimeException ex)
0: 
commit:2fd3268
/////////////////////////////////////////////////////////////////////////
0: 
0:         InetAddress[] addrs = new InetAddress[]
0:             InetAddress.getByName("127.0.0.2"),
0:             InetAddress.getByName("127.0.0.3"),
0:             InetAddress.getByName("127.0.0.4"),
0:             InetAddress.getByName("127.0.0.5"),
0:             InetAddress.getByName("127.0.0.12"),
0:             InetAddress.getByName("127.0.0.13"),
0:             InetAddress.getByName("127.0.0.14"),
0:             InetAddress.getByName("127.0.0.15"),
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:         catch (RuntimeException ex)
0: 
commit:2deee7a
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
0: import java.util.Set;
0: import org.junit.Test;
0: 
0: import org.apache.cassandra.streaming.OperationType;
0: import static org.junit.Assert.assertEquals;
0: 
/////////////////////////////////////////////////////////////////////////
0:         RangeStreamer s = new RangeStreamer(tmd, myEndpoint, OperationType.BOOTSTRAP);
/////////////////////////////////////////////////////////////////////////
1:         s.addSourceFilter(new RangeStreamer.FailureDetectorSourceFilter(mockFailureDetector));
0:         s.addRanges(table, Table.open(table).getReplicationStrategy().getPendingAddressRanges(tmd, myToken, myEndpoint));
0: 
0:         Collection<Map.Entry<InetAddress, Collection<Range<Token>>>> toFetch = s.toFetch().get(table);
0: 
1:         // Check we get get RF new ranges in total
0:         Set<Range<Token>> ranges = new HashSet<Range<Token>>();
1:         for (Map.Entry<InetAddress, Collection<Range<Token>>> e : toFetch)
1:             ranges.addAll(e.getValue());
0: 
1:         assertEquals(replicationFactor, ranges.size());
0: 
1:         assert toFetch.iterator().next().getValue().size() > 0;
1:         assert !toFetch.iterator().next().getKey().equals(myEndpoint);
commit:554223b
/////////////////////////////////////////////////////////////////////////
0:             Range<Token> range = ss.getPrimaryRangeForEndpoint(bootstrapSource);
/////////////////////////////////////////////////////////////////////////
0:         Range<Token> range = ss.getPrimaryRangeForEndpoint(addrs[2]);
/////////////////////////////////////////////////////////////////////////
0:         Range<Token> range5 = ss.getPrimaryRangeForEndpoint(five);
/////////////////////////////////////////////////////////////////////////
0:         Multimap<Range<Token>, InetAddress> res = b.getRangesWithSources(table);
0:         for (Map.Entry<Range<Token>, Collection<InetAddress>> e : res.asMap().entrySet())
/////////////////////////////////////////////////////////////////////////
0:         Multimap<InetAddress, Range<Token>> temp = BootStrapper.getWorkMap(res, mockFailureDetector);
author:branimir
-------------------------------------------------------------------------------
commit:9a3fa88
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.fail;
0: 
0: import java.util.List;
0: import java.util.Set;
1: import com.google.common.collect.Lists;
0: 
0: import org.apache.commons.math.stat.descriptive.SummaryStatistics;
0: 
1: import org.junit.AfterClass;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.dht.tokenallocator.TokenAllocation;
0: import org.apache.cassandra.utils.FBUtilities;
1:     static IPartitioner oldPartitioner;
0: 
0:         oldPartitioner = DatabaseDescriptor.getPartitioner();
0:         DatabaseDescriptor.setPartitioner(Murmur3Partitioner.instance);
1:     @AfterClass
1:     public static void tearDown()
0:     {
0:         DatabaseDescriptor.setPartitioner(oldPartitioner);
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:         generateFakeEndpoints(StorageService.instance.getTokenMetadata(), numOldNodes, 1);
0:     }
0: 
1:     private void generateFakeEndpoints(TokenMetadata tmd, int numOldNodes, int numVNodes) throws UnknownHostException
0:     {
0:             InetAddress addr = InetAddress.getByName("127.0.0." + (i + 1));
1:             List<Token> tokens = Lists.newArrayListWithCapacity(numVNodes);
1:             for (int j = 0; j < numVNodes; ++j)
1:                 tokens.add(p.getRandomToken());
0:             
1:             tmd.updateNormalTokens(tokens, addr);
0:     
0:     @Test
1:     public void testAllocateTokens() throws UnknownHostException
0:     {
1:         int vn = 16;
1:         String ks = "BootStrapperTestKeyspace3";
0:         TokenMetadata tm = new TokenMetadata();
1:         generateFakeEndpoints(tm, 10, vn);
1:         InetAddress addr = FBUtilities.getBroadcastAddress();
0:         allocateTokensForNode(vn, ks, tm, addr);
0:     }
0: 
1:     private void allocateTokensForNode(int vn, String ks, TokenMetadata tm, InetAddress addr)
0:     {
0:         SummaryStatistics os = TokenAllocation.replicatedOwnershipStats(tm, Keyspace.open(ks).getReplicationStrategy(), addr);
1:         Collection<Token> tokens = BootStrapper.allocateTokens(tm, addr, ks, vn);
1:         assertEquals(vn, tokens.size());
1:         tm.updateNormalTokens(tokens, addr);
0:         SummaryStatistics ns = TokenAllocation.replicatedOwnershipStats(tm, Keyspace.open(ks).getReplicationStrategy(), addr);
1:         verifyImprovement(os, ns);
0:     }
0: 
1:     private void verifyImprovement(SummaryStatistics os, SummaryStatistics ns)
0:     {
1:         if (ns.getStandardDeviation() > os.getStandardDeviation())
0:         {
1:             fail(String.format("Token allocation unexpectedly increased standard deviation.\nStats before:\n%s\nStats after:\n%s", os, ns));
0:         }
0:     }
0: 
0:     
0:     @Test
1:     public void testAllocateTokensMultipleKeyspaces() throws UnknownHostException
0:     {
1:         // TODO: This scenario isn't supported very well. Investigate a multi-keyspace version of the algorithm.
1:         int vn = 16;
1:         String ks3 = "BootStrapperTestKeyspace4"; // RF = 3
1:         String ks2 = "BootStrapperTestKeyspace5"; // RF = 2
0: 
0:         TokenMetadata tm = new TokenMetadata();
1:         generateFakeEndpoints(tm, 10, vn);
0:         
1:         InetAddress dcaddr = FBUtilities.getBroadcastAddress();
1:         SummaryStatistics os3 = TokenAllocation.replicatedOwnershipStats(tm, Keyspace.open(ks3).getReplicationStrategy(), dcaddr);
1:         SummaryStatistics os2 = TokenAllocation.replicatedOwnershipStats(tm, Keyspace.open(ks2).getReplicationStrategy(), dcaddr);
1:         String cks = ks3;
1:         String nks = ks2;
1:         for (int i=11; i<=20; ++i)
0:         {
1:             allocateTokensForNode(vn, cks, tm, InetAddress.getByName("127.0.0." + (i + 1)));
1:             String t = cks; cks = nks; nks = t;
0:         }
0:         
1:         SummaryStatistics ns3 = TokenAllocation.replicatedOwnershipStats(tm, Keyspace.open(ks3).getReplicationStrategy(), dcaddr);
1:         SummaryStatistics ns2 = TokenAllocation.replicatedOwnershipStats(tm, Keyspace.open(ks2).getReplicationStrategy(), dcaddr);
1:         verifyImprovement(os3, ns3);
1:         verifyImprovement(os2, ns2);
0:     }
author:Joshua McKenzie
-------------------------------------------------------------------------------
commit:49768fe
author:lyubent
-------------------------------------------------------------------------------
commit:d2a3827
/////////////////////////////////////////////////////////////////////////
1: import org.junit.BeforeClass;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.exceptions.ConfigurationException;
/////////////////////////////////////////////////////////////////////////
0: public class BootStrapperTest
1:     @BeforeClass
0:     public static void setup() throws ConfigurationException
0:     {
1:         SchemaLoader.startGossiper();
1:         SchemaLoader.prepareServer();
1:         SchemaLoader.schemaDefinition("BootStrapperTest");
0:     }
0: 
author:Dave Brosius
-------------------------------------------------------------------------------
commit:997ab95
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:56f35db
/////////////////////////////////////////////////////////////////////////
commit:5c5fe91
/////////////////////////////////////////////////////////////////////////
commit:f650d3e
/////////////////////////////////////////////////////////////////////////
author:Brandon Williams
-------------------------------------------------------------------------------
commit:018e82b
/////////////////////////////////////////////////////////////////////////
1: import org.junit.runner.RunWith;
1: import org.apache.cassandra.OrderedJUnit4ClassRunner;
/////////////////////////////////////////////////////////////////////////
1: @RunWith(OrderedJUnit4ClassRunner.class)
commit:bf8c1ce
/////////////////////////////////////////////////////////////////////////
0: import org.junit.runner.RunWith;
0: import org.apache.cassandra.OrderedJUnit4ClassRunner;
/////////////////////////////////////////////////////////////////////////
0: @RunWith(OrderedJUnit4ClassRunner.class)
commit:91f36f6
/////////////////////////////////////////////////////////////////////////
commit:b475bc6
/////////////////////////////////////////////////////////////////////////
0:             Gossiper.instance.initializeNodeUnsafe(addrs[i], UUID.randomUUID(), 1);
0:             Gossiper.instance.initializeNodeUnsafe(bootstrapAddrs[i], UUID.randomUUID(), 1);
/////////////////////////////////////////////////////////////////////////
0:             Gossiper.instance.injectApplicationState(bootstrapAddrs[i], ApplicationState.TOKENS, ss.valueFactory.tokens(Collections.singleton(token)));
0:                         StorageService.instance.valueFactory.bootstrapping(Collections.<Token>singleton(token)));
/////////////////////////////////////////////////////////////////////////
0:                     StorageService.instance.valueFactory.normal(Collections.singleton(token)));
/////////////////////////////////////////////////////////////////////////
0:         Gossiper.instance.injectApplicationState(myEndpoint, ApplicationState.TOKENS, ss.valueFactory.tokens(Collections.singleton(fakeToken)));
0:                     StorageService.instance.valueFactory.bootstrapping(Collections.<Token>singleton(fakeToken)));
commit:877a8ca
/////////////////////////////////////////////////////////////////////////
0:             // also make bootstrapping nodes present in gossip
0:             Gossiper.instance.initializeNodeUnsafe(bootstrapAddrs[i], 1);
commit:f0ea699
commit:190e27b
/////////////////////////////////////////////////////////////////////////
1:             public void forceConviction(InetAddress ep) { throw new UnsupportedOperationException(); }
commit:048a4ab
/////////////////////////////////////////////////////////////////////////
0:             public void clear(InetAddress ep) { throw new UnsupportedOperationException(); }
commit:127c028
/////////////////////////////////////////////////////////////////////////
0:         assert BootStrapper.getBootstrapTokenFrom(FBUtilities.getBroadcastAddress()) != null;
author:Eric Evans
-------------------------------------------------------------------------------
commit:66b96ee
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collections;
/////////////////////////////////////////////////////////////////////////
0:                         StorageService.instance.valueFactory.bootstrapping(Collections.<Token>singleton(token), bootstrapHostIds[i]));
/////////////////////////////////////////////////////////////////////////
0:                     StorageService.instance.valueFactory.normal(Collections.singleton(token), bootstrapHostIds[2]));
/////////////////////////////////////////////////////////////////////////
0:                     StorageService.instance.valueFactory.bootstrapping(Collections.<Token>singleton(fakeToken), UUID.randomUUID()));
commit:ad685c4
/////////////////////////////////////////////////////////////////////////
0: import java.util.UUID;
/////////////////////////////////////////////////////////////////////////
0:         UUID[] bootstrapHostIds = new UUID[]
0:         {
0:             UUID.randomUUID(),
0:             UUID.randomUUID(),
0:             UUID.randomUUID(),
0:             UUID.randomUUID(),
0:         };
/////////////////////////////////////////////////////////////////////////
0:             ss.onChange(bootstrapAddrs[i],
0:                         ApplicationState.STATUS,
0:                         StorageService.instance.valueFactory.bootstrapping(token, bootstrapHostIds[i]));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(bootstrapAddrs[2],
0:                     ApplicationState.STATUS,
0:                     StorageService.instance.valueFactory.normal(token, bootstrapHostIds[2]));
/////////////////////////////////////////////////////////////////////////
0:         ss.onChange(myEndpoint,
0:                     ApplicationState.STATUS,
0:                     StorageService.instance.valueFactory.bootstrapping(fakeToken, UUID.randomUUID()));
author:Vijay Parthasarathy
-------------------------------------------------------------------------------
commit:f16becf
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.CountDownLatch;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.gms.Gossiper;
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.*;
0: 
/////////////////////////////////////////////////////////////////////////
0:         {
0:             Gossiper.instance.initializeNodeUnsafe(addrs[i], 1);
0:         }
/////////////////////////////////////////////////////////////////////////
0:     private RangeStreamer testSourceTargetComputation(String table, int numOldNodes, int replicationFactor) throws UnknownHostException
/////////////////////////////////////////////////////////////////////////
1:         return s;
0:     }
0: 
0:     @Test
0:     public void testException() throws UnknownHostException
0:     {
0:         String table = Schema.instance.getNonSystemTables().iterator().next();
0:         int replicationFactor = Table.open(table).getReplicationStrategy().getReplicationFactor();
0:         RangeStreamer streamer = testSourceTargetComputation(table, replicationFactor, replicationFactor);
0:         streamer.latch = new CountDownLatch(4);
0:         streamer.convict(streamer.toFetch().get(table).iterator().next().getKey(), Double.MAX_VALUE);
0:         assertNotNull("Exception message not set, test failed", streamer.exceptionMessage);
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:7b532bc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.config.Schema;
/////////////////////////////////////////////////////////////////////////
0:         for (String table : Schema.instance.getNonSystemTables())
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:4dc9d56
/////////////////////////////////////////////////////////////////////////
0:     
0:     @Test
0:     public void testMulitipleAutomaticBootstraps() throws IOException
0:     {
0:         StorageService ss = StorageService.instance;
0:         generateFakeEndpoints(5);
0:         InetAddress[] addrs = new InetAddress[] 
0:         {
0:             InetAddress.getByName("127.0.0.2"),  
0:             InetAddress.getByName("127.0.0.3"),  
0:             InetAddress.getByName("127.0.0.4"),  
0:             InetAddress.getByName("127.0.0.5"),  
0:         };
0:         InetAddress[] bootstrapAddrs = new InetAddress[]
0:         {
0:             InetAddress.getByName("127.0.0.12"),  
0:             InetAddress.getByName("127.0.0.13"),  
0:             InetAddress.getByName("127.0.0.14"),  
0:             InetAddress.getByName("127.0.0.15"),  
0:         };
0:         Map<InetAddress, Double> load = new HashMap<InetAddress, Double>();
0:         for (int i = 0; i < addrs.length; i++)
0:             load.put(addrs[i], (double)i+2);
0:         
0:         // give every node a bootstrap source.
0:         for (int i = 3; i >=0; i--)
0:         {
0:             InetAddress bootstrapSource = BootStrapper.getBootstrapSource(ss.getTokenMetadata(), load);
0:             assert bootstrapSource != null;
0:             assert bootstrapSource.equals(addrs[i]) : String.format("expected %s but got %s for %d", addrs[i], bootstrapSource, i);
0:             assert !ss.getTokenMetadata().getBootstrapTokens().containsValue(bootstrapSource);
0:             
0:             Range range = ss.getPrimaryRangeForEndpoint(bootstrapSource);
0:             Token token = StorageService.getPartitioner().midpoint(range.left, range.right);
0:             assert range.contains(token);
0:             ss.onChange(bootstrapAddrs[i], StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_BOOTSTRAPPING + StorageService.Delimiter + StorageService.getPartitioner().getTokenFactory().toString(token)));
0:         }
0:         
0:         // any further attempt to bootsrtap should fail since every node in the cluster is splitting.
0:         try
0:         {
0:             BootStrapper.getBootstrapSource(ss.getTokenMetadata(), load);
0:             throw new AssertionError("This bootstrap should have failed.");
0:         }
0:         catch (RuntimeException ex) 
0:         {
0:             // success!
0:         }
0:         
0:         // indicate that one of the nodes is done. see if the node it was bootstrapping from is still available.
0:         Range range = ss.getPrimaryRangeForEndpoint(addrs[2]);
0:         Token token = StorageService.getPartitioner().midpoint(range.left, range.right);
0:         ss.onChange(bootstrapAddrs[2], StorageService.MOVE_STATE, new ApplicationState(StorageService.STATE_NORMAL + StorageService.Delimiter + StorageService.getPartitioner().getTokenFactory().toString(token)));
0:         load.put(bootstrapAddrs[2], 0d);
0:         InetAddress addr = BootStrapper.getBootstrapSource(ss.getTokenMetadata(), load);
0:         assert addr != null && addr.equals(addrs[2]);
0:     }
commit:fb7b286
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.CleanupHelper;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.FBUtilities;
0: public class BootStrapperTest extends CleanupHelper
0:     public void testTokenRoundtrip() throws Exception
0:     {
0:         StorageService.instance.initServer();
0:         // fetch a bootstrap token from the local node
0:         assert BootStrapper.getBootstrapTokenFrom(FBUtilities.getLocalAddress()) != null;
0:     }
0: 
0:     @Test
commit:3577fd8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.DatabaseDescriptor;
/////////////////////////////////////////////////////////////////////////
1:         final int[] clusterSizes = new int[] { 1, 3, 5, 10, 100};
0:         for (String table : DatabaseDescriptor.getNonSystemTables())
0:         {
0:             int replicationFactor = DatabaseDescriptor.getReplicationFactor(table);
1:             for (int clusterSize : clusterSizes)
1:                 if (clusterSize >= replicationFactor)
0:                     testSourceTargetComputation(table, clusterSize, replicationFactor);
0:         }
0:     private void testSourceTargetComputation(String table, int numOldNodes, int replicationFactor) throws UnknownHostException
/////////////////////////////////////////////////////////////////////////
0:         BootStrapper b = new BootStrapper(myEndpoint, myToken, tmd);
0:         Multimap<Range, InetAddress> res = b.getRangesWithSources(table);
/////////////////////////////////////////////////////////////////////////
0:         assertEquals(replicationFactor, transferCount);
/////////////////////////////////////////////////////////////////////////
1:         // there isn't any point in testing the size of these collections for any specific size.  When a random partitioner
1:         // is used, they will vary.
0:         assert temp.keySet().size() > 0;
0:         assert temp.asMap().values().iterator().next().size() > 0;
author:Laine Jaakko Olavi
-------------------------------------------------------------------------------
commit:2d71320
/////////////////////////////////////////////////////////////////////////
1:             public void remove(InetAddress ep) { throw new UnsupportedOperationException(); }
============================================================================