11:88f65a1: /*
1:88f65a1:  * Licensed to the Apache Software Foundation (ASF) under one
1:88f65a1:  * or more contributor license agreements.  See the NOTICE file
1:88f65a1:  * distributed with this work for additional information
1:88f65a1:  * regarding copyright ownership.  The ASF licenses this file
1:88f65a1:  * to you under the Apache License, Version 2.0 (the
1:88f65a1:  * "License"); you may not use this file except in compliance
1:88f65a1:  * with the License.  You may obtain a copy of the License at
6:88f65a1:  *
1:88f65a1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:88f65a1:  *
1:88f65a1:  * Unless required by applicable law or agreed to in writing, software
1:88f65a1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:88f65a1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:88f65a1:  * See the License for the specific language governing permissions and
1:88f65a1:  * limitations under the License.
15:88f65a1:  */
1:88f65a1: package org.apache.cassandra.db;
32:88f65a1: 
1:88f65a1: import java.nio.ByteBuffer;
1:88f65a1: import java.util.Arrays;
1:1e978df: import java.util.Collections;
1:88f65a1: import java.util.Iterator;
1:88f65a1: 
1:489a9e8: import org.apache.cassandra.utils.AbstractIterator;
1:74258e2: import com.google.common.collect.Iterators;
1:88f65a1: 
1:4b54b8a: import org.apache.cassandra.cache.IMeasurableMemory;
1:a991b64: import org.apache.cassandra.db.rows.*;
1:4b54b8a: import org.apache.cassandra.utils.ObjectSizes;
1:a14a01c: import org.apache.cassandra.utils.memory.AbstractAllocator;
1:88f65a1: 
5:88f65a1: /**
1:88f65a1:  * Data structure holding the range tombstones of a ColumnFamily.
1:88f65a1:  * <p>
1:88f65a1:  * This is essentially a sorted list of non-overlapping (tombstone) ranges.
1:88f65a1:  * <p>
1:88f65a1:  * A range tombstone has 4 elements: the start and end of the range covered,
1:88f65a1:  * and the deletion infos (markedAt timestamp and local deletion time). The
1:88f65a1:  * markedAt timestamp is what define the priority of 2 overlapping tombstones.
1:6b7db8a:  * That is, given 2 tombstones {@code [0, 10]@t1 and [5, 15]@t2, then if t2 > t1} (and
1:88f65a1:  * are the tombstones markedAt values), the 2nd tombstone take precedence over
1:88f65a1:  * the first one on [5, 10]. If such tombstones are added to a RangeTombstoneList,
1:88f65a1:  * the range tombstone list will store them as [[0, 5]@t1, [5, 15]@t2].
1:88f65a1:  * <p>
1:88f65a1:  * The only use of the local deletion time is to know when a given tombstone can
1:88f65a1:  * be purged, which will be done by the purge() method.
1:88f65a1:  */
1:4b54b8a: public class RangeTombstoneList implements Iterable<RangeTombstone>, IMeasurableMemory
44:88f65a1: {
1:4b54b8a:     private static long EMPTY_SIZE = ObjectSizes.measure(new RangeTombstoneList(null, 0));
1:362cc05: 
1:a991b64:     private final ClusteringComparator comparator;
1:88f65a1: 
1:88f65a1:     // Note: we don't want to use a List for the markedAts and delTimes to avoid boxing. We could
1:88f65a1:     // use a List for starts and ends, but having arrays everywhere is almost simpler.
1:2cc26eb:     private ClusteringBound[] starts;
1:2cc26eb:     private ClusteringBound[] ends;
1:88f65a1:     private long[] markedAts;
1:88f65a1:     private int[] delTimes;
1:88f65a1: 
1:4b54b8a:     private long boundaryHeapSize;
1:88f65a1:     private int size;
1:88f65a1: 
1:2cc26eb:     private RangeTombstoneList(ClusteringComparator comparator, ClusteringBound[] starts, ClusteringBound[] ends, long[] markedAts, int[] delTimes, long boundaryHeapSize, int size)
1:362cc05:     {
1:88f65a1:         assert starts.length == ends.length && starts.length == markedAts.length && starts.length == delTimes.length;
1:88f65a1:         this.comparator = comparator;
1:88f65a1:         this.starts = starts;
1:88f65a1:         this.ends = ends;
1:88f65a1:         this.markedAts = markedAts;
1:88f65a1:         this.delTimes = delTimes;
1:88f65a1:         this.size = size;
1:4b54b8a:         this.boundaryHeapSize = boundaryHeapSize;
1:74258e2:     }
1:a991b64: 
1:a991b64:     public RangeTombstoneList(ClusteringComparator comparator, int capacity)
1:7895273:     {
1:2cc26eb:         this(comparator, new ClusteringBound[capacity], new ClusteringBound[capacity], new long[capacity], new int[capacity], 0, 0);
1:74258e2:     }
1:88f65a1: 
1:88f65a1:     public boolean isEmpty()
1:5bd37b9:     {
1:88f65a1:         return size == 0;
1:362cc05:     }
1:88f65a1: 
1:88f65a1:     public int size()
1:74258e2:     {
2:88f65a1:         return size;
44:88f65a1:     }
1:88f65a1: 
1:a991b64:     public ClusteringComparator comparator()
1:4768daa:     {
1:88f65a1:         return comparator;
1:88f65a1:     }
1:88f65a1: 
1:88f65a1:     public RangeTombstoneList copy()
1:88f65a1:     {
1:88f65a1:         return new RangeTombstoneList(comparator,
1:88f65a1:                                       Arrays.copyOf(starts, size),
1:88f65a1:                                       Arrays.copyOf(ends, size),
1:88f65a1:                                       Arrays.copyOf(markedAts, size),
1:88f65a1:                                       Arrays.copyOf(delTimes, size),
1:a14a01c:                                       boundaryHeapSize, size);
1:88f65a1:     }
1:88f65a1: 
1:a14a01c:     public RangeTombstoneList copy(AbstractAllocator allocator)
1:88f65a1:     {
1:a14a01c:         RangeTombstoneList copy =  new RangeTombstoneList(comparator,
1:2cc26eb:                                                           new ClusteringBound[size],
1:2cc26eb:                                                           new ClusteringBound[size],
1:a991b64:                                                           Arrays.copyOf(markedAts, size),
1:a991b64:                                                           Arrays.copyOf(delTimes, size),
1:a991b64:                                                           boundaryHeapSize, size);
1:88f65a1: 
1:88f65a1: 
5:88f65a1:         for (int i = 0; i < size; i++)
1:88f65a1:         {
1:a991b64:             copy.starts[i] = clone(starts[i], allocator);
1:a991b64:             copy.ends[i] = clone(ends[i], allocator);
1:88f65a1:         }
1:88f65a1: 
1:a14a01c:         return copy;
1:88f65a1:     }
1:88f65a1: 
1:2cc26eb:     private static ClusteringBound clone(ClusteringBound bound, AbstractAllocator allocator)
1:a991b64:     {
1:a991b64:         ByteBuffer[] values = new ByteBuffer[bound.size()];
1:a991b64:         for (int i = 0; i < values.length; i++)
1:a991b64:             values[i] = allocator.clone(bound.get(i));
1:2cc26eb:         return new ClusteringBound(bound.kind(), values);
1:a991b64:     }
1:a991b64: 
1:88f65a1:     public void add(RangeTombstone tombstone)
1:88f65a1:     {
1:a991b64:         add(tombstone.deletedSlice().start(),
1:a991b64:             tombstone.deletedSlice().end(),
1:a991b64:             tombstone.deletionTime().markedForDeleteAt(),
1:a991b64:             tombstone.deletionTime().localDeletionTime());
1:88f65a1:     }
1:88f65a1: 
1:88f65a1:     /**
1:88f65a1:      * Adds a new range tombstone.
1:7895273:      *
1:88f65a1:      * This method will be faster if the new tombstone sort after all the currently existing ones (this is a common use case),
1:88f65a1:      * but it doesn't assume it.
1:88f65a1:      */
1:2cc26eb:     public void add(ClusteringBound start, ClusteringBound end, long markedAt, int delTime)
1:88f65a1:     {
1:88f65a1:         if (isEmpty())
1:88f65a1:         {
1:88f65a1:             addInternal(0, start, end, markedAt, delTime);
1:4768daa:             return;
1:88f65a1:         }
1:88f65a1: 
1:4768daa:         int c = comparator.compare(ends[size-1], start);
1:88f65a1: 
1:88f65a1:         // Fast path if we add in sorted order
1:7813dee:         if (c <= 0)
1:a991b64:         {
1:4768daa:             addInternal(size, start, end, markedAt, delTime);
1:88f65a1:         }
13:88f65a1:         else
1:88f65a1:         {
1:4768daa:             // Note: insertFrom expect i to be the insertion point in term of interval ends
1:4768daa:             int pos = Arrays.binarySearch(ends, 0, size, start, comparator);
1:7813dee:             insertFrom((pos >= 0 ? pos+1 : -pos-1), start, end, markedAt, delTime);
1:88f65a1:         }
1:4b54b8a:         boundaryHeapSize += start.unsharedHeapSize() + end.unsharedHeapSize();
1:88f65a1:     }
1:88f65a1: 
1:88f65a1:     /**
1:88f65a1:      * Adds all the range tombstones of {@code tombstones} to this RangeTombstoneList.
1:88f65a1:      */
1:88f65a1:     public void addAll(RangeTombstoneList tombstones)
1:88f65a1:     {
1:88f65a1:         if (tombstones.isEmpty())
1:4768daa:             return;
1:88f65a1: 
1:88f65a1:         if (isEmpty())
1:88f65a1:         {
1:88f65a1:             copyArrays(tombstones, this);
8:88f65a1:             return;
1:88f65a1:         }
1:88f65a1: 
1:88f65a1:         /*
1:88f65a1:          * We basically have 2 techniques we can use here: either we repeatedly call add() on tombstones values,
1:4768daa:          * or we do a merge of both (sorted) lists. If this lists is bigger enough than the one we add, then
1:88f65a1:          * calling add() will be faster, otherwise it's merging that will be faster.
1:5bd37b9:          *
1:88f65a1:          * Let's note that during memtables updates, it might not be uncommon that a new update has only a few range
1:4768daa:          * tombstones, while the CF we're adding it to (the one in the memtable) has many. In that case, using add() is
1:88f65a1:          * likely going to be faster.
1:5bd37b9:          *
1:88f65a1:          * In other cases however, like when diffing responses from multiple nodes, the tombstone lists we "merge" will
1:88f65a1:          * be likely sized, so using add() might be a bit inefficient.
1:88f65a1:          *
1:88f65a1:          * Roughly speaking (this ignore the fact that updating an element is not exactly constant but that's not a big
1:88f65a1:          * deal), if n is the size of this list and m is tombstones size, merging is O(n+m) while using add() is O(m*log(n)).
1:88f65a1:          *
1:88f65a1:          * But let's not crank up a logarithm computation for that. Long story short, merging will be a bad choice only
1:88f65a1:          * if this list size is lot bigger that the other one, so let's keep it simple.
1:88f65a1:          */
1:88f65a1:         if (size > 10 * tombstones.size)
1:88f65a1:         {
3:88f65a1:             for (int i = 0; i < tombstones.size; i++)
1:88f65a1:                 add(tombstones.starts[i], tombstones.ends[i], tombstones.markedAts[i], tombstones.delTimes[i]);
1:88f65a1:         }
1:88f65a1:         else
1:88f65a1:         {
1:88f65a1:             int i = 0;
2:88f65a1:             int j = 0;
1:88f65a1:             while (i < size && j < tombstones.size)
1:88f65a1:             {
1:a991b64:                 if (comparator.compare(tombstones.starts[j], ends[i]) < 0)
1:88f65a1:                 {
1:4768daa:                     insertFrom(i, tombstones.starts[j], tombstones.ends[j], tombstones.markedAts[j], tombstones.delTimes[j]);
1:88f65a1:                     j++;
1:88f65a1:                 }
1:88f65a1:                 else
1:88f65a1:                 {
4:4768daa:                     i++;
1:4768daa:                 }
1:4768daa:             }
1:4768daa:             // Addds the remaining ones from tombstones if any (note that addInternal will increment size if relevant).
1:88f65a1:             for (; j < tombstones.size; j++)
1:4768daa:                 addInternal(size, tombstones.starts[j], tombstones.ends[j], tombstones.markedAts[j], tombstones.delTimes[j]);
1:4768daa:         }
1:88f65a1:     }
1:4768daa: 
1:88f65a1:     /**
1:88f65a1:      * Returns whether the given name/timestamp pair is deleted by one of the tombstone
1:88f65a1:      * of this RangeTombstoneList.
1:88f65a1:      */
1:a991b64:     public boolean isDeleted(Clustering clustering, Cell cell)
1:4768daa:     {
1:a991b64:         int idx = searchInternal(clustering, 0, size);
1:6858dd3:         // No matter what the counter cell's timestamp is, a tombstone always takes precedence. See CASSANDRA-7346.
1:2457599:         return idx >= 0 && (cell.isCounterCell() || markedAts[idx] >= cell.timestamp());
1:88f65a1:     }
1:4768daa: 
1:88f65a1:     /**
1:88f65a1:      * Returns the DeletionTime for the tombstone overlapping {@code name} (there can't be more than one),
1:88f65a1:      * or null if {@code name} is not covered by any tombstone.
1:88f65a1:      */
1:a991b64:     public DeletionTime searchDeletionTime(Clustering name)
1:74258e2:     {
1:a991b64:         int idx = searchInternal(name, 0, size);
1:2457599:         return idx < 0 ? null : new DeletionTime(markedAts[idx], delTimes[idx]);
1:88f65a1:     }
1:4768daa: 
1:a991b64:     public RangeTombstone search(Clustering name)
1:74258e2:     {
1:a991b64:         int idx = searchInternal(name, 0, size);
1:74258e2:         return idx < 0 ? null : rangeTombstone(idx);
1:74258e2:     }
1:74258e2: 
1:74258e2:     /*
1:74258e2:      * Return is the index of the range covering name if name is covered. If the return idx is negative,
1:74258e2:      * no range cover name and -idx-1 is the index of the first range whose start is greater than name.
1:1e978df:      *
1:1e978df:      * Note that bounds are not in the range if they fall on its boundary.
1:74258e2:      */
1:a991b64:     private int searchInternal(ClusteringPrefix name, int startIdx, int endIdx)
1:88f65a1:     {
1:88f65a1:         if (isEmpty())
1:88f65a1:             return -1;
1:88f65a1: 
1:a991b64:         int pos = Arrays.binarySearch(starts, startIdx, endIdx, name, comparator);
2:88f65a1:         if (pos >= 0)
1:88f65a1:         {
1:1e978df:             // Equality only happens for bounds (as used by forward/reverseIterator), and bounds are equal only if they
1:1e978df:             // are the same or complementary, in either case the bound itself is not part of the range.
1:1e978df:             return -pos - 1;
1:88f65a1:         }
1:4768daa:         else
1:88f65a1:         {
1:88f65a1:             // We potentially intersect the range before our "insertion point"
1:88f65a1:             int idx = -pos-2;
1:88f65a1:             if (idx < 0)
1:88f65a1:                 return -1;
1:88f65a1: 
1:1e978df:             return comparator.compare(name, ends[idx]) < 0 ? idx : -idx-2;
1:88f65a1:         }
1:88f65a1:     }
1:88f65a1: 
1:88f65a1:     public int dataSize()
1:88f65a1:     {
1:03f72ac:         int dataSize = TypeSizes.sizeof(size);
1:88f65a1:         for (int i = 0; i < size; i++)
1:88f65a1:         {
1:362cc05:             dataSize += starts[i].dataSize() + ends[i].dataSize();
1:03f72ac:             dataSize += TypeSizes.sizeof(markedAts[i]);
1:03f72ac:             dataSize += TypeSizes.sizeof(delTimes[i]);
1:88f65a1:         }
1:88f65a1:         return dataSize;
1:88f65a1:     }
1:88f65a1: 
1:2457599:     public long maxMarkedAt()
1:2457599:     {
1:2457599:         long max = Long.MIN_VALUE;
1:2457599:         for (int i = 0; i < size; i++)
1:2457599:             max = Math.max(max, markedAts[i]);
1:2457599:         return max;
1:2457599:     }
1:2457599: 
1:c055ab9:     public void collectStats(EncodingStats.Collector collector)
1:2457599:     {
1:2457599:         for (int i = 0; i < size; i++)
1:2457599:         {
1:2457599:             collector.updateTimestamp(markedAts[i]);
1:2457599:             collector.updateLocalDeletionTime(delTimes[i]);
1:2457599:         }
1:2457599:     }
1:2457599: 
1:37130b5:     public void updateAllTimestamp(long timestamp)
1:37130b5:     {
1:37130b5:         for (int i = 0; i < size; i++)
1:37130b5:             markedAts[i] = timestamp;
1:37130b5:     }
1:37130b5: 
1:74258e2:     private RangeTombstone rangeTombstone(int idx)
1:a991b64:     {
1:2457599:         return new RangeTombstone(Slice.make(starts[idx], ends[idx]), new DeletionTime(markedAts[idx], delTimes[idx]));
1:a991b64:     }
1:a991b64: 
1:2cc26eb:     private RangeTombstone rangeTombstoneWithNewStart(int idx, ClusteringBound newStart)
1:a991b64:     {
1:2457599:         return new RangeTombstone(Slice.make(newStart, ends[idx]), new DeletionTime(markedAts[idx], delTimes[idx]));
1:a991b64:     }
1:a991b64: 
1:2cc26eb:     private RangeTombstone rangeTombstoneWithNewEnd(int idx, ClusteringBound newEnd)
1:a991b64:     {
1:2457599:         return new RangeTombstone(Slice.make(starts[idx], newEnd), new DeletionTime(markedAts[idx], delTimes[idx]));
1:a991b64:     }
1:a991b64: 
1:2cc26eb:     private RangeTombstone rangeTombstoneWithNewBounds(int idx, ClusteringBound newStart, ClusteringBound newEnd)
1:74258e2:     {
1:2457599:         return new RangeTombstone(Slice.make(newStart, newEnd), new DeletionTime(markedAts[idx], delTimes[idx]));
1:74258e2:     }
1:74258e2: 
1:88f65a1:     public Iterator<RangeTombstone> iterator()
1:88f65a1:     {
1:a991b64:         return iterator(false);
1:88f65a1:     }
1:88f65a1: 
1:a991b64:     public Iterator<RangeTombstone> iterator(boolean reversed)
1:88f65a1:     {
1:a991b64:         return reversed
1:a991b64:              ? new AbstractIterator<RangeTombstone>()
1:a991b64:              {
1:a991b64:                  private int idx = size - 1;
1:a991b64: 
1:a991b64:                  protected RangeTombstone computeNext()
1:a991b64:                  {
1:a991b64:                      if (idx < 0)
1:a991b64:                          return endOfData();
1:a991b64: 
1:a991b64:                      return rangeTombstone(idx--);
1:a991b64:                  }
1:a991b64:              }
1:a991b64:              : new AbstractIterator<RangeTombstone>()
1:a991b64:              {
1:a991b64:                  private int idx;
1:a991b64: 
1:a991b64:                  protected RangeTombstone computeNext()
1:a991b64:                  {
1:a991b64:                      if (idx >= size)
1:a991b64:                          return endOfData();
1:a991b64: 
1:a991b64:                      return rangeTombstone(idx++);
1:a991b64:                  }
1:a991b64:              };
1:a991b64:     }
1:a991b64: 
1:a991b64:     public Iterator<RangeTombstone> iterator(final Slice slice, boolean reversed)
1:a991b64:     {
1:a991b64:         return reversed ? reverseIterator(slice) : forwardIterator(slice);
1:a991b64:     }
1:a991b64: 
1:a991b64:     private Iterator<RangeTombstone> forwardIterator(final Slice slice)
1:a991b64:     {
1:2cc26eb:         int startIdx = slice.start() == ClusteringBound.BOTTOM ? 0 : searchInternal(slice.start(), 0, size);
1:74258e2:         final int start = startIdx < 0 ? -startIdx-1 : startIdx;
1:74258e2: 
1:a991b64:         if (start >= size)
1:1e978df:             return Collections.emptyIterator();
1:74258e2: 
1:2cc26eb:         int finishIdx = slice.end() == ClusteringBound.TOP ? size - 1 : searchInternal(slice.end(), start, size);
1:a991b64:         // if stopIdx is the first range after 'slice.end()' we care only until the previous range
1:74258e2:         final int finish = finishIdx < 0 ? -finishIdx-2 : finishIdx;
1:74258e2: 
1:74258e2:         if (start > finish)
1:1e978df:             return Collections.emptyIterator();
1:a991b64: 
1:a991b64:         if (start == finish)
1:a991b64:         {
1:a991b64:             // We want to make sure the range are stricly included within the queried slice as this
1:a991b64:             // make it easier to combine things when iterating over successive slices.
1:2cc26eb:             ClusteringBound s = comparator.compare(starts[start], slice.start()) < 0 ? slice.start() : starts[start];
1:2cc26eb:             ClusteringBound e = comparator.compare(slice.end(), ends[start]) < 0 ? slice.end() : ends[start];
1:a991b64:             return Iterators.<RangeTombstone>singletonIterator(rangeTombstoneWithNewBounds(start, s, e));
1:a991b64:         }
1:74258e2: 
1:74258e2:         return new AbstractIterator<RangeTombstone>()
1:74258e2:         {
1:74258e2:             private int idx = start;
1:74258e2: 
1:74258e2:             protected RangeTombstone computeNext()
1:74258e2:             {
1:74258e2:                 if (idx >= size || idx > finish)
1:74258e2:                     return endOfData();
1:74258e2: 
1:a991b64:                 // We want to make sure the range are stricly included within the queried slice as this
1:a991b64:                 // make it easier to combine things when iterating over successive slices. This means that
1:a991b64:                 // for the first and last range we might have to "cut" the range returned.
1:a991b64:                 if (idx == start && comparator.compare(starts[idx], slice.start()) < 0)
1:a991b64:                     return rangeTombstoneWithNewStart(idx++, slice.start());
1:a991b64:                 if (idx == finish && comparator.compare(slice.end(), ends[idx]) < 0)
1:a991b64:                     return rangeTombstoneWithNewEnd(idx++, slice.end());
1:a991b64:                 return rangeTombstone(idx++);
1:88f65a1:             }
1:74258e2:         };
1:88f65a1:     }
1:74258e2: 
1:a991b64:     private Iterator<RangeTombstone> reverseIterator(final Slice slice)
1:88f65a1:     {
1:2cc26eb:         int startIdx = slice.end() == ClusteringBound.TOP ? size - 1 : searchInternal(slice.end(), 0, size);
1:a991b64:         // if startIdx is the first range after 'slice.end()' we care only until the previous range
1:a991b64:         final int start = startIdx < 0 ? -startIdx-2 : startIdx;
1:88f65a1: 
1:1e978df:         if (start < 0)
1:1e978df:             return Collections.emptyIterator();
1:88f65a1: 
1:2cc26eb:         int finishIdx = slice.start() == ClusteringBound.BOTTOM ? 0 : searchInternal(slice.start(), 0, start + 1);  // include same as finish
1:a991b64:         // if stopIdx is the first range after 'slice.end()' we care only until the previous range
1:a991b64:         final int finish = finishIdx < 0 ? -finishIdx-1 : finishIdx;
1:a991b64: 
1:a991b64:         if (start < finish)
1:1e978df:             return Collections.emptyIterator();
1:a991b64: 
1:a991b64:         if (start == finish)
1:88f65a1:         {
1:a991b64:             // We want to make sure the range are stricly included within the queried slice as this
1:a991b64:             // make it easier to combine things when iterator over successive slices.
1:2cc26eb:             ClusteringBound s = comparator.compare(starts[start], slice.start()) < 0 ? slice.start() : starts[start];
1:2cc26eb:             ClusteringBound e = comparator.compare(slice.end(), ends[start]) < 0 ? slice.end() : ends[start];
1:a991b64:             return Iterators.<RangeTombstone>singletonIterator(rangeTombstoneWithNewBounds(start, s, e));
1:88f65a1:         }
1:a991b64: 
1:a991b64:         return new AbstractIterator<RangeTombstone>()
1:a991b64:         {
1:a991b64:             private int idx = start;
1:88f65a1: 
1:a991b64:             protected RangeTombstone computeNext()
1:88f65a1:             {
1:a991b64:                 if (idx < 0 || idx < finish)
1:a991b64:                     return endOfData();
1:a991b64:                 // We want to make sure the range are stricly included within the queried slice as this
1:a991b64:                 // make it easier to combine things when iterator over successive slices. This means that
1:a991b64:                 // for the first and last range we might have to "cut" the range returned.
1:a991b64:                 if (idx == start && comparator.compare(slice.end(), ends[idx]) < 0)
1:a991b64:                     return rangeTombstoneWithNewEnd(idx--, slice.end());
1:a991b64:                 if (idx == finish && comparator.compare(starts[idx], slice.start()) < 0)
1:a991b64:                     return rangeTombstoneWithNewStart(idx--, slice.start());
1:1e978df:                 return rangeTombstone(idx--);
1:a991b64:             }
1:a991b64:         };
1:88f65a1:     }
1:88f65a1: 
1:88f65a1:     @Override
1:88f65a1:     public boolean equals(Object o)
1:88f65a1:     {
1:88f65a1:         if(!(o instanceof RangeTombstoneList))
4:88f65a1:             return false;
1:88f65a1:         RangeTombstoneList that = (RangeTombstoneList)o;
1:88f65a1:         if (size != that.size)
1:88f65a1:             return false;
1:88f65a1: 
1:88f65a1:         for (int i = 0; i < size; i++)
1:88f65a1:         {
1:88f65a1:             if (!starts[i].equals(that.starts[i]))
1:88f65a1:                 return false;
1:88f65a1:             if (!ends[i].equals(that.ends[i]))
1:88f65a1:                 return false;
1:88f65a1:             if (markedAts[i] != that.markedAts[i])
1:88f65a1:                 return false;
1:88f65a1:             if (delTimes[i] != that.delTimes[i])
1:88f65a1:                 return false;
1:88f65a1:         }
2:88f65a1:         return true;
1:88f65a1:     }
1:88f65a1: 
1:88f65a1:     @Override
1:88f65a1:     public final int hashCode()
1:88f65a1:     {
1:88f65a1:         int result = size;
1:88f65a1:         for (int i = 0; i < size; i++)
1:88f65a1:         {
1:88f65a1:             result += starts[i].hashCode() + ends[i].hashCode();
1:88f65a1:             result += (int)(markedAts[i] ^ (markedAts[i] >>> 32));
1:88f65a1:             result += delTimes[i];
1:88f65a1:         }
1:88f65a1:         return result;
1:88f65a1:     }
1:88f65a1: 
1:88f65a1:     private static void copyArrays(RangeTombstoneList src, RangeTombstoneList dst)
1:88f65a1:     {
1:88f65a1:         dst.grow(src.size);
1:88f65a1:         System.arraycopy(src.starts, 0, dst.starts, 0, src.size);
1:88f65a1:         System.arraycopy(src.ends, 0, dst.ends, 0, src.size);
1:88f65a1:         System.arraycopy(src.markedAts, 0, dst.markedAts, 0, src.size);
1:88f65a1:         System.arraycopy(src.delTimes, 0, dst.delTimes, 0, src.size);
1:88f65a1:         dst.size = src.size;
1:4b54b8a:         dst.boundaryHeapSize = src.boundaryHeapSize;
1:88f65a1:     }
1:88f65a1: 
1:88f65a1:     /*
1:7895273:      * Inserts a new element starting at index i. This method assumes that:
1:7813dee:      *    ends[i-1] <= start < ends[i]
1:7813dee:      * (note that start can be equal to ends[i-1] in the case where we have a boundary, i.e. for instance
1:7813dee:      * ends[i-1] is the exclusive end of X and start is the inclusive start of X).
1:7895273:      *
1:7895273:      * A RangeTombstoneList is a list of range [s_0, e_0]...[s_n, e_n] such that:
1:7813dee:      *   - s_i is a start bound and e_i is a end bound
1:7813dee:      *   - s_i < e_i
1:7813dee:      *   - e_i <= s_i+1
1:a991b64:      * Basically, range are non overlapping and in order.
1:88f65a1:      */
1:2cc26eb:     private void insertFrom(int i, ClusteringBound start, ClusteringBound end, long markedAt, int delTime)
1:7895273:     {
1:4768daa:         while (i < size)
1:7895273:         {
1:a991b64:             assert start.isStart() && end.isEnd();
1:7813dee:             assert i == 0 || comparator.compare(ends[i-1], start) <= 0;
1:a991b64:             assert comparator.compare(start, ends[i]) < 0;
1:7895273: 
1:a991b64:             if (Slice.isEmpty(comparator, start, end))
1:a991b64:                 return;
1:7895273: 
1:4768daa:             // Do we overwrite the current element?
1:7895273:             if (markedAt > markedAts[i])
1:7895273:             {
1:4768daa:                 // We do overwrite.
1:5bd37b9: 
1:4768daa:                 // First deal with what might come before the newly added one.
1:4768daa:                 if (comparator.compare(starts[i], start) < 0)
1:5bd37b9:                 {
1:2cc26eb:                     ClusteringBound newEnd = start.invert();
1:a991b64:                     if (!Slice.isEmpty(comparator, starts[i], newEnd))
1:a991b64:                     {
1:de73b5c:                         addInternal(i, starts[i], newEnd, markedAts[i], delTimes[i]);
1:a991b64:                         i++;
1:a991b64:                         setInternal(i, start, ends[i], markedAts[i], delTimes[i]);
1:a991b64:                     }
1:7895273:                 }
1:5bd37b9: 
1:4768daa:                 // now, start <= starts[i]
1:4768daa: 
1:a991b64:                 // Does the new element stops before the current one,
1:7895273:                 int endCmp = comparator.compare(end, starts[i]);
1:a991b64:                 if (endCmp < 0)
1:5bd37b9:                 {
1:a991b64:                     // Here start <= starts[i] and end < starts[i]
1:a991b64:                     // This means the current element is before the current one.
1:a991b64:                     addInternal(i, start, end, markedAt, delTime);
1:7895273:                     return;
1:7895273:                 }
1:4768daa: 
1:4768daa:                 // Do we overwrite the current element fully?
1:4768daa:                 int cmp = comparator.compare(ends[i], end);
1:4768daa:                 if (cmp <= 0)
1:5bd37b9:                 {
1:4768daa:                     // We do overwrite fully:
1:e338d2f:                     // update the current element until it's end and continue on with the next element (with the new inserted start == current end).
1:4768daa: 
1:e338d2f:                     // If we're on the last element, or if we stop before the next start, we set the current element and are done
1:e338d2f:                     // Note that the comparison below is inclusive: if a end equals a start, this means they form a boundary, or
1:e338d2f:                     // in other words that they are for the same element but one is inclusive while the other exclusive. In which case we know
1:e338d2f:                     // we're good with the next element
1:e338d2f:                     if (i == size-1 || comparator.compare(end, starts[i+1]) <= 0)
1:4768daa:                     {
1:a991b64:                         setInternal(i, start, end, markedAt, delTime);
1:5bd37b9:                         return;
1:a991b64:                     }
1:4768daa: 
1:a991b64:                     setInternal(i, start, starts[i+1].invert(), markedAt, delTime);
1:a991b64:                     start = starts[i+1];
1:7895273:                     i++;
1:7895273:                 }
1:7895273:                 else
1:4768daa:                 {
1:a991b64:                     // We don't overwrite fully. Insert the new interval, and then update the now next
1:4768daa:                     // one to reflect the not overwritten parts. We're then done.
1:7895273:                     addInternal(i, start, end, markedAt, delTime);
1:5bd37b9:                     i++;
1:2cc26eb:                     ClusteringBound newStart = end.invert();
1:a991b64:                     if (!Slice.isEmpty(comparator, newStart, ends[i]))
1:a991b64:                     {
1:a991b64:                         setInternal(i, newStart, ends[i], markedAts[i], delTimes[i]);
1:a991b64:                     }
1:4768daa:                     return;
1:5bd37b9:                 }
1:5bd37b9:             }
1:5bd37b9:             else
1:4768daa:             {
1:4768daa:                 // we don't overwrite the current element
1:4768daa: 
1:4768daa:                 // If the new interval starts before the current one, insert that new interval
1:4768daa:                 if (comparator.compare(start, starts[i]) < 0)
1:4768daa:                 {
1:e338d2f:                     // If we stop before the start of the current element, just insert the new interval and we're done;
1:e338d2f:                     // otherwise insert until the beginning of the current element
1:e338d2f:                     if (comparator.compare(end, starts[i]) <= 0)
1:4768daa:                     {
1:5bd37b9:                         addInternal(i, start, end, markedAt, delTime);
1:4768daa:                         return;
1:5bd37b9:                     }
1:2cc26eb:                     ClusteringBound newEnd = starts[i].invert();
1:a991b64:                     if (!Slice.isEmpty(comparator, start, newEnd))
1:a991b64:                     {
1:a991b64:                         addInternal(i, start, newEnd, markedAt, delTime);
1:a991b64:                         i++;
1:a991b64:                     }
1:4768daa:                 }
1:4768daa: 
1:4768daa:                 // After that, we're overwritten on the current element but might have
1:4768daa:                 // some residual parts after ...
1:4768daa: 
1:4768daa:                 // ... unless we don't extend beyond it.
1:4768daa:                 if (comparator.compare(end, ends[i]) <= 0)
1:4768daa:                     return;
1:4768daa: 
1:a991b64:                 start = ends[i].invert();
1:4768daa:                 i++;
1:4768daa:             }
1:4768daa:         }
1:88f65a1: 
1:4768daa:         // If we got there, then just insert the remainder at the end
4:4768daa:         addInternal(i, start, end, markedAt, delTime);
1:4768daa:     }
1:88f65a1: 
1:88f65a1:     private int capacity()
1:88f65a1:     {
1:88f65a1:         return starts.length;
1:88f65a1:     }
1:88f65a1: 
1:88f65a1:     /*
1:88f65a1:      * Adds the new tombstone at index i, growing and/or moving elements to make room for it.
1:88f65a1:      */
1:2cc26eb:     private void addInternal(int i, ClusteringBound start, ClusteringBound end, long markedAt, int delTime)
1:88f65a1:     {
1:7895273:         assert i >= 0;
1:7895273: 
1:88f65a1:         if (size == capacity())
1:88f65a1:             growToFree(i);
1:88f65a1:         else if (i < size)
1:88f65a1:             moveElements(i);
1:7895273: 
1:7895273:         setInternal(i, start, end, markedAt, delTime);
1:88f65a1:         size++;
1:7895273:     }
1:7895273: 
1:88f65a1:     /*
1:88f65a1:      * Grow the arrays, leaving index i "free" in the process.
1:88f65a1:      */
1:88f65a1:     private void growToFree(int i)
1:88f65a1:     {
1:88f65a1:         int newLength = (capacity() * 3) / 2 + 1;
1:88f65a1:         grow(i, newLength);
1:5bd37b9:     }
1:5bd37b9: 
1:88f65a1:     /*
1:88f65a1:      * Grow the arrays to match newLength capacity.
1:88f65a1:      */
1:88f65a1:     private void grow(int newLength)
1:88f65a1:     {
1:88f65a1:         if (capacity() < newLength)
1:88f65a1:             grow(-1, newLength);
1:88f65a1:     }
1:5bd37b9: 
1:88f65a1:     private void grow(int i, int newLength)
1:88f65a1:     {
1:88f65a1:         starts = grow(starts, size, newLength, i);
1:88f65a1:         ends = grow(ends, size, newLength, i);
1:88f65a1:         markedAts = grow(markedAts, size, newLength, i);
1:88f65a1:         delTimes = grow(delTimes, size, newLength, i);
1:88f65a1:     }
1:5bd37b9: 
1:2cc26eb:     private static ClusteringBound[] grow(ClusteringBound[] a, int size, int newLength, int i)
1:88f65a1:     {
1:88f65a1:         if (i < 0 || i >= size)
1:88f65a1:             return Arrays.copyOf(a, newLength);
1:88f65a1: 
1:2cc26eb:         ClusteringBound[] newA = new ClusteringBound[newLength];
1:88f65a1:         System.arraycopy(a, 0, newA, 0, i);
1:88f65a1:         System.arraycopy(a, i, newA, i+1, size - i);
1:88f65a1:         return newA;
1:88f65a1:     }
1:88f65a1: 
1:88f65a1:     private static long[] grow(long[] a, int size, int newLength, int i)
1:88f65a1:     {
1:88f65a1:         if (i < 0 || i >= size)
1:88f65a1:             return Arrays.copyOf(a, newLength);
1:88f65a1: 
1:88f65a1:         long[] newA = new long[newLength];
1:88f65a1:         System.arraycopy(a, 0, newA, 0, i);
1:88f65a1:         System.arraycopy(a, i, newA, i+1, size - i);
1:88f65a1:         return newA;
1:88f65a1:     }
1:88f65a1: 
1:88f65a1:     private static int[] grow(int[] a, int size, int newLength, int i)
1:88f65a1:     {
1:88f65a1:         if (i < 0 || i >= size)
1:88f65a1:             return Arrays.copyOf(a, newLength);
1:88f65a1: 
1:88f65a1:         int[] newA = new int[newLength];
1:88f65a1:         System.arraycopy(a, 0, newA, 0, i);
1:88f65a1:         System.arraycopy(a, i, newA, i+1, size - i);
1:88f65a1:         return newA;
1:88f65a1:     }
1:88f65a1: 
1:88f65a1:     /*
1:88f65a1:      * Move elements so that index i is "free", assuming the arrays have at least one free slot at the end.
1:88f65a1:      */
1:88f65a1:     private void moveElements(int i)
1:88f65a1:     {
1:88f65a1:         if (i >= size)
1:4768daa:             return;
1:88f65a1: 
1:88f65a1:         System.arraycopy(starts, i, starts, i+1, size - i);
1:88f65a1:         System.arraycopy(ends, i, ends, i+1, size - i);
1:88f65a1:         System.arraycopy(markedAts, i, markedAts, i+1, size - i);
1:88f65a1:         System.arraycopy(delTimes, i, delTimes, i+1, size - i);
1:4b54b8a:         // we set starts[i] to null to indicate the position is now empty, so that we update boundaryHeapSize
1:4b54b8a:         // when we set it
1:4b54b8a:         starts[i] = null;
1:88f65a1:     }
1:88f65a1: 
1:2cc26eb:     private void setInternal(int i, ClusteringBound start, ClusteringBound end, long markedAt, int delTime)
1:88f65a1:     {
1:4b54b8a:         if (starts[i] != null)
1:4b54b8a:             boundaryHeapSize -= starts[i].unsharedHeapSize() + ends[i].unsharedHeapSize();
1:88f65a1:         starts[i] = start;
2:88f65a1:         ends[i] = end;
2:88f65a1:         markedAts[i] = markedAt;
2:88f65a1:         delTimes[i] = delTime;
1:4b54b8a:         boundaryHeapSize += start.unsharedHeapSize() + end.unsharedHeapSize();
1:88f65a1:     }
1:88f65a1: 
2:6e81f81:     @Override
1:4b54b8a:     public long unsharedHeapSize()
1:88f65a1:     {
1:4b54b8a:         return EMPTY_SIZE
1:4b54b8a:                 + boundaryHeapSize
1:4b54b8a:                 + ObjectSizes.sizeOfArray(starts)
1:4b54b8a:                 + ObjectSizes.sizeOfArray(ends)
1:4b54b8a:                 + ObjectSizes.sizeOfArray(markedAts)
1:4b54b8a:                 + ObjectSizes.sizeOfArray(delTimes);
1:88f65a1:     }
1:88f65a1: }
============================================================================
author:Dave Brosius
-------------------------------------------------------------------------------
commit:de73b5c
/////////////////////////////////////////////////////////////////////////
1:                         addInternal(i, starts[i], newEnd, markedAts[i], delTimes[i]);
commit:6b7db8a
/////////////////////////////////////////////////////////////////////////
1:  * That is, given 2 tombstones {@code [0, 10]@t1 and [5, 15]@t2, then if t2 > t1} (and
commit:3ca9576
/////////////////////////////////////////////////////////////////////////
commit:6f217f7
/////////////////////////////////////////////////////////////////////////
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:2cc26eb
/////////////////////////////////////////////////////////////////////////
1:     private ClusteringBound[] starts;
1:     private ClusteringBound[] ends;
1:     private RangeTombstoneList(ClusteringComparator comparator, ClusteringBound[] starts, ClusteringBound[] ends, long[] markedAts, int[] delTimes, long boundaryHeapSize, int size)
/////////////////////////////////////////////////////////////////////////
1:         this(comparator, new ClusteringBound[capacity], new ClusteringBound[capacity], new long[capacity], new int[capacity], 0, 0);
/////////////////////////////////////////////////////////////////////////
1:                                                           new ClusteringBound[size],
1:                                                           new ClusteringBound[size],
/////////////////////////////////////////////////////////////////////////
1:     private static ClusteringBound clone(ClusteringBound bound, AbstractAllocator allocator)
1:         return new ClusteringBound(bound.kind(), values);
/////////////////////////////////////////////////////////////////////////
1:     public void add(ClusteringBound start, ClusteringBound end, long markedAt, int delTime)
/////////////////////////////////////////////////////////////////////////
1:     private RangeTombstone rangeTombstoneWithNewStart(int idx, ClusteringBound newStart)
1:     private RangeTombstone rangeTombstoneWithNewEnd(int idx, ClusteringBound newEnd)
1:     private RangeTombstone rangeTombstoneWithNewBounds(int idx, ClusteringBound newStart, ClusteringBound newEnd)
/////////////////////////////////////////////////////////////////////////
1:         int startIdx = slice.start() == ClusteringBound.BOTTOM ? 0 : searchInternal(slice.start(), 0, size);
1:         int finishIdx = slice.end() == ClusteringBound.TOP ? size - 1 : searchInternal(slice.end(), start, size);
/////////////////////////////////////////////////////////////////////////
1:             ClusteringBound s = comparator.compare(starts[start], slice.start()) < 0 ? slice.start() : starts[start];
1:             ClusteringBound e = comparator.compare(slice.end(), ends[start]) < 0 ? slice.end() : ends[start];
/////////////////////////////////////////////////////////////////////////
1:         int startIdx = slice.end() == ClusteringBound.TOP ? size - 1 : searchInternal(slice.end(), 0, size);
1:         int finishIdx = slice.start() == ClusteringBound.BOTTOM ? 0 : searchInternal(slice.start(), 0, start + 1);  // include same as finish
/////////////////////////////////////////////////////////////////////////
1:             ClusteringBound s = comparator.compare(starts[start], slice.start()) < 0 ? slice.start() : starts[start];
1:             ClusteringBound e = comparator.compare(slice.end(), ends[start]) < 0 ? slice.end() : ends[start];
/////////////////////////////////////////////////////////////////////////
1:     private void insertFrom(int i, ClusteringBound start, ClusteringBound end, long markedAt, int delTime)
/////////////////////////////////////////////////////////////////////////
1:                     ClusteringBound newEnd = start.invert();
/////////////////////////////////////////////////////////////////////////
1:                     ClusteringBound newStart = end.invert();
/////////////////////////////////////////////////////////////////////////
1:                     ClusteringBound newEnd = starts[i].invert();
/////////////////////////////////////////////////////////////////////////
1:     private void addInternal(int i, ClusteringBound start, ClusteringBound end, long markedAt, int delTime)
/////////////////////////////////////////////////////////////////////////
1:     private static ClusteringBound[] grow(ClusteringBound[] a, int size, int newLength, int i)
1:         ClusteringBound[] newA = new ClusteringBound[newLength];
/////////////////////////////////////////////////////////////////////////
1:     private void setInternal(int i, ClusteringBound start, ClusteringBound end, long markedAt, int delTime)
commit:1e978df
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collections;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * Note that bounds are not in the range if they fall on its boundary.
/////////////////////////////////////////////////////////////////////////
1:             // Equality only happens for bounds (as used by forward/reverseIterator), and bounds are equal only if they
1:             // are the same or complementary, in either case the bound itself is not part of the range.
1:             return -pos - 1;
/////////////////////////////////////////////////////////////////////////
1:             return comparator.compare(name, ends[idx]) < 0 ? idx : -idx-2;
/////////////////////////////////////////////////////////////////////////
1:             return Collections.emptyIterator();
1:             return Collections.emptyIterator();
/////////////////////////////////////////////////////////////////////////
0:         int startIdx = slice.end() == Slice.Bound.TOP ? size - 1 : searchInternal(slice.end(), 0, size);
1:         if (start < 0)
1:             return Collections.emptyIterator();
0:         int finishIdx = slice.start() == Slice.Bound.BOTTOM ? 0 : searchInternal(slice.start(), 0, start + 1);  // include same as finish
1:             return Collections.emptyIterator();
/////////////////////////////////////////////////////////////////////////
1:                 return rangeTombstone(idx--);
/////////////////////////////////////////////////////////////////////////
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:220f253
commit:e338d2f
/////////////////////////////////////////////////////////////////////////
1:                     // update the current element until it's end and continue on with the next element (with the new inserted start == current end).
1:                     // If we're on the last element, or if we stop before the next start, we set the current element and are done
1:                     // Note that the comparison below is inclusive: if a end equals a start, this means they form a boundary, or
1:                     // in other words that they are for the same element but one is inclusive while the other exclusive. In which case we know
1:                     // we're good with the next element
1:                     if (i == size-1 || comparator.compare(end, starts[i+1]) <= 0)
/////////////////////////////////////////////////////////////////////////
1:                     // If we stop before the start of the current element, just insert the new interval and we're done;
1:                     // otherwise insert until the beginning of the current element
1:                     if (comparator.compare(end, starts[i]) <= 0)
/////////////////////////////////////////////////////////////////////////
commit:c055ab9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void collectStats(EncodingStats.Collector collector)
commit:2457599
/////////////////////////////////////////////////////////////////////////
1:         return idx >= 0 && (cell.isCounterCell() || markedAts[idx] >= cell.timestamp());
/////////////////////////////////////////////////////////////////////////
1:         return idx < 0 ? null : new DeletionTime(markedAts[idx], delTimes[idx]);
/////////////////////////////////////////////////////////////////////////
1:     public long maxMarkedAt()
1:     {
1:         long max = Long.MIN_VALUE;
1:         for (int i = 0; i < size; i++)
1:             max = Math.max(max, markedAts[i]);
1:         return max;
1:     }
1: 
0:     public void collectStats(RowStats.Collector collector)
1:     {
1:         for (int i = 0; i < size; i++)
1:         {
1:             collector.updateTimestamp(markedAts[i]);
1:             collector.updateLocalDeletionTime(delTimes[i]);
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         return new RangeTombstone(Slice.make(starts[idx], ends[idx]), new DeletionTime(markedAts[idx], delTimes[idx]));
1:         return new RangeTombstone(Slice.make(newStart, ends[idx]), new DeletionTime(markedAts[idx], delTimes[idx]));
1:         return new RangeTombstone(Slice.make(starts[idx], newEnd), new DeletionTime(markedAts[idx], delTimes[idx]));
1:         return new RangeTombstone(Slice.make(newStart, newEnd), new DeletionTime(markedAts[idx], delTimes[idx]));
commit:7813dee
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.ByteBufferUtil;
/////////////////////////////////////////////////////////////////////////
1:         if (c <= 0)
/////////////////////////////////////////////////////////////////////////
1:             insertFrom((pos >= 0 ? pos+1 : -pos-1), start, end, markedAt, delTime);
/////////////////////////////////////////////////////////////////////////
1:      *    ends[i-1] <= start < ends[i]
1:      * (note that start can be equal to ends[i-1] in the case where we have a boundary, i.e. for instance
1:      * ends[i-1] is the exclusive end of X and start is the inclusive start of X).
1:      *   - s_i is a start bound and e_i is a end bound
1:      *   - s_i < e_i
1:      *   - e_i <= s_i+1
/////////////////////////////////////////////////////////////////////////
1:             assert i == 0 || comparator.compare(ends[i-1], start) <= 0;
commit:a991b64
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.db.rows.*;
/////////////////////////////////////////////////////////////////////////
1:     private final ClusteringComparator comparator;
0:     private Slice.Bound[] starts;
0:     private Slice.Bound[] ends;
0:     private RangeTombstoneList(ClusteringComparator comparator, Slice.Bound[] starts, Slice.Bound[] ends, long[] markedAts, int[] delTimes, long boundaryHeapSize, int size)
/////////////////////////////////////////////////////////////////////////
1:     public RangeTombstoneList(ClusteringComparator comparator, int capacity)
0:         this(comparator, new Slice.Bound[capacity], new Slice.Bound[capacity], new long[capacity], new int[capacity], 0, 0);
/////////////////////////////////////////////////////////////////////////
1:     public ClusteringComparator comparator()
/////////////////////////////////////////////////////////////////////////
0:                                                           new Slice.Bound[size],
0:                                                           new Slice.Bound[size],
1:                                                           Arrays.copyOf(markedAts, size),
1:                                                           Arrays.copyOf(delTimes, size),
1:                                                           boundaryHeapSize, size);
1:             copy.starts[i] = clone(starts[i], allocator);
1:             copy.ends[i] = clone(ends[i], allocator);
0:     private static Slice.Bound clone(Slice.Bound bound, AbstractAllocator allocator)
1:     {
1:         ByteBuffer[] values = new ByteBuffer[bound.size()];
1:         for (int i = 0; i < values.length; i++)
1:             values[i] = allocator.clone(bound.get(i));
0:         return new Slice.Bound(bound.kind(), values);
1:     }
1: 
1:         add(tombstone.deletedSlice().start(),
1:             tombstone.deletedSlice().end(),
1:             tombstone.deletionTime().markedForDeleteAt(),
1:             tombstone.deletionTime().localDeletionTime());
/////////////////////////////////////////////////////////////////////////
0:     public void add(Slice.Bound start, Slice.Bound end, long markedAt, int delTime)
/////////////////////////////////////////////////////////////////////////
1:                 if (comparator.compare(tombstones.starts[j], ends[i]) < 0)
/////////////////////////////////////////////////////////////////////////
1:     public boolean isDeleted(Clustering clustering, Cell cell)
1:         int idx = searchInternal(clustering, 0, size);
0:         return idx >= 0 && (cell.isCounterCell() || markedAts[idx] >= cell.livenessInfo().timestamp());
1:     public DeletionTime searchDeletionTime(Clustering name)
1:         int idx = searchInternal(name, 0, size);
0:         return idx < 0 ? null : new SimpleDeletionTime(markedAts[idx], delTimes[idx]);
1:     public RangeTombstone search(Clustering name)
1:         int idx = searchInternal(name, 0, size);
/////////////////////////////////////////////////////////////////////////
1:     private int searchInternal(ClusteringPrefix name, int startIdx, int endIdx)
1:         int pos = Arrays.binarySearch(starts, startIdx, endIdx, name, comparator);
0:             return pos;
/////////////////////////////////////////////////////////////////////////
0:         return new RangeTombstone(Slice.make(starts[idx], ends[idx]), new SimpleDeletionTime(markedAts[idx], delTimes[idx]));
1:     }
1: 
0:     private RangeTombstone rangeTombstoneWithNewStart(int idx, Slice.Bound newStart)
1:     {
0:         return new RangeTombstone(Slice.make(newStart, ends[idx]), new SimpleDeletionTime(markedAts[idx], delTimes[idx]));
1:     }
1: 
0:     private RangeTombstone rangeTombstoneWithNewEnd(int idx, Slice.Bound newEnd)
1:     {
0:         return new RangeTombstone(Slice.make(starts[idx], newEnd), new SimpleDeletionTime(markedAts[idx], delTimes[idx]));
1:     }
1: 
0:     private RangeTombstone rangeTombstoneWithNewBounds(int idx, Slice.Bound newStart, Slice.Bound newEnd)
1:     {
0:         return new RangeTombstone(Slice.make(newStart, newEnd), new SimpleDeletionTime(markedAts[idx], delTimes[idx]));
1:         return iterator(false);
1:     public Iterator<RangeTombstone> iterator(boolean reversed)
1:         return reversed
1:              ? new AbstractIterator<RangeTombstone>()
1:              {
1:                  private int idx = size - 1;
1: 
1:                  protected RangeTombstone computeNext()
1:                  {
1:                      if (idx < 0)
1:                          return endOfData();
1: 
1:                      return rangeTombstone(idx--);
1:                  }
1:              }
1:              : new AbstractIterator<RangeTombstone>()
1:              {
1:                  private int idx;
1: 
1:                  protected RangeTombstone computeNext()
1:                  {
1:                      if (idx >= size)
1:                          return endOfData();
1: 
1:                      return rangeTombstone(idx++);
1:                  }
1:              };
1:     }
1: 
1:     public Iterator<RangeTombstone> iterator(final Slice slice, boolean reversed)
1:     {
1:         return reversed ? reverseIterator(slice) : forwardIterator(slice);
1:     }
1: 
1:     private Iterator<RangeTombstone> forwardIterator(final Slice slice)
1:     {
0:         int startIdx = slice.start() == Slice.Bound.BOTTOM ? 0 : searchInternal(slice.start(), 0, size);
0:         int finishIdx = slice.end() == Slice.Bound.TOP ? size - 1 : searchInternal(slice.end(), start, size);
1:         // if stopIdx is the first range after 'slice.end()' we care only until the previous range
1: 
1:         if (start == finish)
1:         {
1:             // We want to make sure the range are stricly included within the queried slice as this
1:             // make it easier to combine things when iterating over successive slices.
0:             Slice.Bound s = comparator.compare(starts[start], slice.start()) < 0 ? slice.start() : starts[start];
0:             Slice.Bound e = comparator.compare(slice.end(), ends[start]) < 0 ? slice.end() : ends[start];
1:             return Iterators.<RangeTombstone>singletonIterator(rangeTombstoneWithNewBounds(start, s, e));
1:         }
/////////////////////////////////////////////////////////////////////////
1:                 // We want to make sure the range are stricly included within the queried slice as this
1:                 // make it easier to combine things when iterating over successive slices. This means that
1:                 // for the first and last range we might have to "cut" the range returned.
1:                 if (idx == start && comparator.compare(starts[idx], slice.start()) < 0)
1:                     return rangeTombstoneWithNewStart(idx++, slice.start());
1:                 if (idx == finish && comparator.compare(slice.end(), ends[idx]) < 0)
1:                     return rangeTombstoneWithNewEnd(idx++, slice.end());
1:     private Iterator<RangeTombstone> reverseIterator(final Slice slice)
0:         int startIdx = slice.end() == Slice.Bound.TOP ? 0 : searchInternal(slice.end(), 0, size);
1:         // if startIdx is the first range after 'slice.end()' we care only until the previous range
1:         final int start = startIdx < 0 ? -startIdx-2 : startIdx;
1:         if (start >= size)
0:             return Iterators.<RangeTombstone>emptyIterator();
0:         int finishIdx = slice.start() == Slice.Bound.BOTTOM ? 0 : searchInternal(slice.start(), 0, start);
1:         // if stopIdx is the first range after 'slice.end()' we care only until the previous range
1:         final int finish = finishIdx < 0 ? -finishIdx-1 : finishIdx;
1: 
1:         if (start < finish)
0:             return Iterators.<RangeTombstone>emptyIterator();
1: 
1:         if (start == finish)
1:             // We want to make sure the range are stricly included within the queried slice as this
1:             // make it easier to combine things when iterator over successive slices.
0:             Slice.Bound s = comparator.compare(starts[start], slice.start()) < 0 ? slice.start() : starts[start];
0:             Slice.Bound e = comparator.compare(slice.end(), ends[start]) < 0 ? slice.end() : ends[start];
1:             return Iterators.<RangeTombstone>singletonIterator(rangeTombstoneWithNewBounds(start, s, e));
1:         return new AbstractIterator<RangeTombstone>()
1:             private int idx = start;
1:             protected RangeTombstone computeNext()
1:             {
1:                 if (idx < 0 || idx < finish)
1:                     return endOfData();
1: 
1:                 // We want to make sure the range are stricly included within the queried slice as this
1:                 // make it easier to combine things when iterator over successive slices. This means that
1:                 // for the first and last range we might have to "cut" the range returned.
1:                 if (idx == start && comparator.compare(slice.end(), ends[idx]) < 0)
1:                     return rangeTombstoneWithNewEnd(idx--, slice.end());
1:                 if (idx == finish && comparator.compare(starts[idx], slice.start()) < 0)
1:                     return rangeTombstoneWithNewStart(idx--, slice.start());
1:                 return rangeTombstone(idx++);
1:             }
1:         };
/////////////////////////////////////////////////////////////////////////
0:      *    ends[i-1] < start < ends[i]
0:      * (note that we cannot have start == end since both will at least have a different bound "kind")
0:      *   - e_i < s_i+1
1:      * Basically, range are non overlapping and in order.
0:     private void insertFrom(int i, Slice.Bound start, Slice.Bound end, long markedAt, int delTime)
1:             assert start.isStart() && end.isEnd();
0:             assert i == 0 || comparator.compare(ends[i-1], start) < 0;
1:             assert comparator.compare(start, ends[i]) < 0;
1:             if (Slice.isEmpty(comparator, start, end))
1:                 return;
/////////////////////////////////////////////////////////////////////////
0:                     Slice.Bound newEnd = start.invert();
1:                     if (!Slice.isEmpty(comparator, starts[i], newEnd))
1:                     {
0:                         addInternal(i, starts[i], start.invert(), markedAts[i], delTimes[i]);
1:                         i++;
1:                         setInternal(i, start, ends[i], markedAts[i], delTimes[i]);
1:                     }
1:                 // Does the new element stops before the current one,
1:                 if (endCmp < 0)
1:                     // Here start <= starts[i] and end < starts[i]
1:                     // This means the current element is before the current one.
1:                     addInternal(i, start, end, markedAt, delTime);
/////////////////////////////////////////////////////////////////////////
0:                     // Otherwise, the new element overwite until the min(end, next start)
0:                     if (comparator.compare(end, starts[i+1]) < 0)
1:                     {
1:                         setInternal(i, start, end, markedAt, delTime);
0:                         // We have fully handled the new element so we're done
1:                     }
1:                     setInternal(i, start, starts[i+1].invert(), markedAt, delTime);
1:                     start = starts[i+1];
1:                     // We don't overwrite fully. Insert the new interval, and then update the now next
0:                     Slice.Bound newStart = end.invert();
1:                     if (!Slice.isEmpty(comparator, newStart, ends[i]))
1:                     {
1:                         setInternal(i, newStart, ends[i], markedAts[i], delTimes[i]);
1:                     }
/////////////////////////////////////////////////////////////////////////
0:                     if (comparator.compare(end, starts[i]) < 0)
0:                     Slice.Bound newEnd = starts[i].invert();
1:                     if (!Slice.isEmpty(comparator, start, newEnd))
1:                     {
1:                         addInternal(i, start, newEnd, markedAt, delTime);
1:                         i++;
1:                     }
/////////////////////////////////////////////////////////////////////////
1:                 start = ends[i].invert();
/////////////////////////////////////////////////////////////////////////
0:     private void addInternal(int i, Slice.Bound start, Slice.Bound end, long markedAt, int delTime)
/////////////////////////////////////////////////////////////////////////
0:     private static Slice.Bound[] grow(Slice.Bound[] a, int size, int newLength, int i)
0:         Slice.Bound[] newA = new Slice.Bound[newLength];
/////////////////////////////////////////////////////////////////////////
0:     private void setInternal(int i, Slice.Bound start, Slice.Bound end, long markedAt, int delTime)
/////////////////////////////////////////////////////////////////////////
0:     // TODO: This should be moved someplace else as it shouldn't be used directly: some ranges might become
0:     // complex deletion times. We'll also only need this for backward compatibility, this isn't used otherwise.
0:         private final LegacyLayout layout;
0:         public Serializer(LegacyLayout layout)
0:             this.layout = layout;
0:             // TODO
0:             throw new UnsupportedOperationException();
0:             //if (tombstones == null)
0:             //{
0:             //    out.writeInt(0);
0:             //    return;
0:             //}
0:             //out.writeInt(tombstones.size);
0:             //for (int i = 0; i < tombstones.size; i++)
0:             //{
0:             //    layout.serializer().serialize(tombstones.starts[i], out);
0:             //    layout.serializer().serialize(tombstones.ends[i], out);
0:             //    out.writeInt(tombstones.delTimes[i]);
0:             //    out.writeLong(tombstones.markedAts[i]);
0:             //}
0:             // TODO
0:             throw new UnsupportedOperationException();
0:             //int size = in.readInt();
0:             //if (size == 0)
0:             //    return null;
0:             //RangeTombstoneList tombstones = new RangeTombstoneList(layout, size);
0:             //for (int i = 0; i < size; i++)
0:             //{
0:             //    Slice.Bound start = layout.serializer().deserialize(in);
0:             //    Slice.Bound end = layout.serializer().deserialize(in);
0:             //    int delTime =  in.readInt();
0:             //    long markedAt = in.readLong();
0:             //    if (version >= MessagingService.VERSION_20)
0:             //    {
0:             //        tombstones.setInternal(i, start, end, markedAt, delTime);
0:             //    }
0:             //    else
0:             //    {
0:             //        /*
0:             //         * The old implementation used to have range sorted by left value, but with potentially
0:             //         * overlapping range. So we need to use the "slow" path.
0:             //         */
0:             //        tombstones.add(start, end, markedAt, delTime);
0:             //    }
0:             //}
1: 
0:             //// The "slow" path take care of updating the size, but not the fast one
0:             //if (version >= MessagingService.VERSION_20)
0:             //    tombstones.size = size;
0:             //return tombstones;
0:             // TODO
0:             throw new UnsupportedOperationException();
0:             //if (tombstones == null)
0:             //    return typeSizes.sizeof(0);
0:             //long size = typeSizes.sizeof(tombstones.size);
0:             //for (int i = 0; i < tombstones.size; i++)
0:             //{
0:             //    size += type.serializer().serializedSize(tombstones.starts[i], typeSizes);
0:             //    size += type.serializer().serializedSize(tombstones.ends[i], typeSizes);
0:             //    size += typeSizes.sizeof(tombstones.delTimes[i]);
0:             //    size += typeSizes.sizeof(tombstones.markedAts[i]);
0:             //}
0:             //return size;
/////////////////////////////////////////////////////////////////////////
commit:302eb46
commit:e1a67a4
commit:7895273
/////////////////////////////////////////////////////////////////////////
0:             insertFrom((pos >= 0 ? pos : -pos-1), start, end, markedAt, delTime);
/////////////////////////////////////////////////////////////////////////
0:                 if (comparator.compare(tombstones.starts[j], ends[i]) <= 0)
/////////////////////////////////////////////////////////////////////////
1:      * Inserts a new element starting at index i. This method assumes that:
0:      *    ends[i-1] <= start <= ends[i]
1:      *
1:      * A RangeTombstoneList is a list of range [s_0, e_0]...[s_n, e_n] such that:
0:      *   - s_i <= e_i
0:      *   - e_i <= s_i+1
0:      *   - if s_i == e_i and e_i == s_i+1 then s_i+1 < e_i+1
0:      * Basically, range are non overlapping except for their bound and in order. And while
0:      * we allow ranges with the same value for the start and end, we don't allow repeating
0:      * such range (so we can't have [0, 0][0, 0] even though it would respect the first 2
0:      * conditions).
1:      *
0:             assert i == 0 || comparator.compare(ends[i-1], start) <= 0;
1: 
0:             int c = comparator.compare(start, ends[i]);
0:             assert c <= 0;
0:             if (c == 0)
1:             {
0:                 // If start == ends[i], then we can insert from the next one (basically the new element
0:                 // really start at the next element), except for the case where starts[i] == ends[i].
0:                 // In this latter case, if we were to move to next element, we could end up with ...[x, x][x, x]...
0:                 if (comparator.compare(starts[i], ends[i]) == 0)
1:                 {
0:                     // The current element cover a single value which is equal to the start of the inserted
0:                     // element. If the inserted element overwrites the current one, just remove the current
0:                     // (it's included in what we insert) and proceed with the insert.
1:                     if (markedAt > markedAts[i])
1:                     {
0:                         removeInternal(i);
0:                         continue;
1:                     }
1: 
0:                     // Otherwise (the current singleton interval override the new one), we want to leave the
0:                     // current element and move to the next, unless start == end since that means the new element
0:                     // is in fact fully covered by the current one (so we're done)
0:                     if (comparator.compare(start, end) == 0)
1:                         return;
1:                 }
1:                 i++;
0:                 continue;
1:             }
/////////////////////////////////////////////////////////////////////////
0:                 // Does the new element stops before/at the current one,
1:                 int endCmp = comparator.compare(end, starts[i]);
0:                 if (endCmp <= 0)
0:                     // Here start <= starts[i] and end <= starts[i]
0:                     // This means the current element is before the current one. However, one special
0:                     // case is if end == starts[i] and starts[i] == ends[i]. In that case,
0:                     // the new element entirely overwrite the current one and we can just overwrite
0:                     if (endCmp == 0 && comparator.compare(starts[i], ends[i]) == 0)
1:                         setInternal(i, start, end, markedAt, delTime);
1:                     else
1:                         addInternal(i, start, end, markedAt, delTime);
/////////////////////////////////////////////////////////////////////////
0:     private void removeInternal(int i)
1:     {
1:         assert i >= 0;
1: 
0:         System.arraycopy(starts, i+1, starts, i, size - i - 1);
0:         System.arraycopy(ends, i+1, ends, i, size - i - 1);
0:         System.arraycopy(markedAts, i+1, markedAts, i, size - i - 1);
0:         System.arraycopy(delTimes, i+1, delTimes, i, size - i - 1);
1: 
0:         --size;
0:         starts[size] = null;
0:         ends[size] = null;
1:     }
1: 
commit:5bd37b9
/////////////////////////////////////////////////////////////////////////
0:             insertFrom((pos >= 0 ? pos : -pos-1), start, end, markedAt, delTime);
/////////////////////////////////////////////////////////////////////////
0:                 if (comparator.compare(tombstones.starts[j], ends[i]) <= 0)
/////////////////////////////////////////////////////////////////////////
0:      * Inserts a new element starting at index i. This method assumes that:
0:      *    ends[i-1] <= start <= ends[i]
1:      *
0:      * A RangeTombstoneList is a list of range [s_0, e_0]...[s_n, e_n] such that:
0:      *   - s_i <= e_i
0:      *   - e_i <= s_i+1
0:      *   - if s_i == e_i and e_i == s_i+1 then s_i+1 < e_i+1
0:      * Basically, range are non overlapping except for their bound and in order. And while
0:      * we allow ranges with the same value for the start and end, we don't allow repeating
0:      * such range (so we can't have [0, 0][0, 0] even though it would respect the first 2
0:      * conditions).
1:      *
0:             assert i == 0 || comparator.compare(ends[i-1], start) <= 0;
1: 
0:             int c = comparator.compare(start, ends[i]);
0:             assert c <= 0;
0:             if (c == 0)
1:             {
0:                 // If start == ends[i], then we can insert from the next one (basically the new element
0:                 // really start at the next element), except for the case where starts[i] == ends[i].
0:                 // In this latter case, if we were to move to next element, we could end up with ...[x, x][x, x]...
0:                 if (comparator.compare(starts[i], ends[i]) == 0)
1:                 {
0:                     // The current element cover a single value which is equal to the start of the inserted
0:                     // element. If the inserted element overwrites the current one, just remove the current
0:                     // (it's included in what we insert) and proceed with the insert.
0:                     if (markedAt > markedAts[i])
1:                     {
0:                         removeInternal(i);
0:                         continue;
1:                     }
1: 
0:                     // Otherwise (the current singleton interval override the new one), we want to leave the
0:                     // current element and move to the next, unless start == end since that means the new element
0:                     // is in fact fully covered by the current one (so we're done)
0:                     if (comparator.compare(start, end) == 0)
1:                         return;
1:                 }
1:                 i++;
0:                 continue;
1:             }
/////////////////////////////////////////////////////////////////////////
0:                 // Does the new element stops before/at the current one,
0:                 int endCmp = comparator.compare(end, starts[i]);
0:                 if (endCmp <= 0)
0:                     // Here start <= starts[i] and end <= starts[i]
0:                     // This means the current element is before the current one. However, one special
0:                     // case is if end == starts[i] and starts[i] == ends[i]. In that case,
0:                     // the new element entirely overwrite the current one and we can just overwrite
0:                     if (endCmp == 0 && comparator.compare(starts[i], ends[i]) == 0)
0:                         setInternal(i, start, end, markedAt, delTime);
1:                     else
1:                         addInternal(i, start, end, markedAt, delTime);
/////////////////////////////////////////////////////////////////////////
0:     private void removeInternal(int i)
1:     {
0:         assert i >= 0;
1: 
0:         System.arraycopy(starts, i+1, starts, i, size - i - 1);
0:         System.arraycopy(ends, i+1, ends, i, size - i - 1);
0:         System.arraycopy(markedAts, i+1, markedAts, i, size - i - 1);
0:         System.arraycopy(delTimes, i+1, delTimes, i, size - i - 1);
1: 
0:         --size;
0:         starts[size] = null;
0:         ends[size] = null;
1:     }
1: 
commit:74258e2
/////////////////////////////////////////////////////////////////////////
1: import com.google.common.collect.Iterators;
/////////////////////////////////////////////////////////////////////////
0:         int idx = searchInternal(name, 0);
/////////////////////////////////////////////////////////////////////////
0:     public DeletionTime searchDeletionTime(Composite name)
1:     {
0:         int idx = searchInternal(name, 0);
0:     public RangeTombstone search(Composite name)
1:     {
0:         int idx = searchInternal(name, 0);
1:         return idx < 0 ? null : rangeTombstone(idx);
1:     }
1: 
1:     /*
1:      * Return is the index of the range covering name if name is covered. If the return idx is negative,
1:      * no range cover name and -idx-1 is the index of the first range whose start is greater than name.
1:      */
0:     private int searchInternal(Composite name, int startIdx)
0:         int pos = Arrays.binarySearch(starts, startIdx, size, name, comparator);
/////////////////////////////////////////////////////////////////////////
0:             return comparator.compare(name, ends[idx]) <= 0 ? idx : -idx-2;
/////////////////////////////////////////////////////////////////////////
1:     private RangeTombstone rangeTombstone(int idx)
1:     {
0:         return new RangeTombstone(starts[idx], ends[idx], markedAts[idx], delTimes[idx]);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:                 return rangeTombstone(idx++);
1:             }
1:         };
1:     }
1: 
0:     public Iterator<RangeTombstone> iterator(Composite from, Composite till)
1:     {
0:         int startIdx = from.isEmpty() ? 0 : searchInternal(from, 0);
1:         final int start = startIdx < 0 ? -startIdx-1 : startIdx;
1: 
0:         if (start >= size)
0:             return Iterators.<RangeTombstone>emptyIterator();
1: 
0:         int finishIdx = till.isEmpty() ? size : searchInternal(till, start);
0:         // if stopIdx is the first range after 'till' we care only until the previous range
1:         final int finish = finishIdx < 0 ? -finishIdx-2 : finishIdx;
1: 
0:         // Note: the following is true because we know 'from' is before 'till' in sorted order.
1:         if (start > finish)
0:             return Iterators.<RangeTombstone>emptyIterator();
0:         else if (start == finish)
0:             return Iterators.<RangeTombstone>singletonIterator(rangeTombstone(start));
1: 
1:         return new AbstractIterator<RangeTombstone>()
1:         {
1:             private int idx = start;
1: 
1:             protected RangeTombstone computeNext()
1:             {
1:                 if (idx >= size || idx > finish)
1:                     return endOfData();
1: 
0:                 return rangeTombstone(idx++);
commit:362cc05
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.composites.CType;
0: import org.apache.cassandra.db.composites.Composite;
/////////////////////////////////////////////////////////////////////////
0:     private final Comparator<Composite> comparator;
0:     private Composite[] starts;
0:     private Composite[] ends;
0:     private RangeTombstoneList(Comparator<Composite> comparator, Composite[] starts, Composite[] ends, long[] markedAts, int[] delTimes, int size)
/////////////////////////////////////////////////////////////////////////
0:     public RangeTombstoneList(Comparator<Composite> comparator, int capacity)
0:         this(comparator, new Composite[capacity], new Composite[capacity], new long[capacity], new int[capacity], 0);
/////////////////////////////////////////////////////////////////////////
0:     public Comparator<Composite> comparator()
/////////////////////////////////////////////////////////////////////////
0:     public void add(Composite start, Composite end, long markedAt, int delTime)
/////////////////////////////////////////////////////////////////////////
0:     public boolean isDeleted(Composite name, long timestamp)
/////////////////////////////////////////////////////////////////////////
0:     public DeletionTime search(Composite name) {
0:     private int searchInternal(Composite name)
/////////////////////////////////////////////////////////////////////////
1:             dataSize += starts[i].dataSize() + ends[i].dataSize();
/////////////////////////////////////////////////////////////////////////
0:     private void insertFrom(int i, Composite start, Composite end, long markedAt, int delTime)
/////////////////////////////////////////////////////////////////////////
0:     private void addInternal(int i, Composite start, Composite end, long markedAt, int delTime)
/////////////////////////////////////////////////////////////////////////
0:     private static Composite[] grow(Composite[] a, int size, int newLength, int i)
0:         Composite[] newA = new Composite[newLength];
/////////////////////////////////////////////////////////////////////////
0:     private void setInternal(int i, Composite start, Composite end, long markedAt, int delTime)
/////////////////////////////////////////////////////////////////////////
0:         private final CType type;
1: 
0:         public Serializer(CType type)
1:         {
0:             this.type = type;
1:         }
/////////////////////////////////////////////////////////////////////////
0:                 type.serializer().serialize(tombstones.starts[i], out);
0:                 type.serializer().serialize(tombstones.ends[i], out);
0:             RangeTombstoneList tombstones = new RangeTombstoneList(type, size);
0:                 Composite start = type.serializer().deserialize(in);
0:                 Composite end = type.serializer().deserialize(in);
/////////////////////////////////////////////////////////////////////////
0:                 size += type.serializer().serializedSize(tombstones.starts[i], typeSizes);
0:                 size += type.serializer().serializedSize(tombstones.ends[i], typeSizes);
/////////////////////////////////////////////////////////////////////////
0:         public boolean isDeleted(Composite name, long timestamp)
commit:322f9a9
commit:4768daa
/////////////////////////////////////////////////////////////////////////
1:         int c = comparator.compare(ends[size-1], start);
1:             addInternal(size, start, end, markedAt, delTime);
1:             // Note: insertFrom expect i to be the insertion point in term of interval ends
1:             int pos = Arrays.binarySearch(ends, 0, size, start, comparator);
0:             insertFrom((pos >= 0 ? pos+1 : -pos-1), start, end, markedAt, delTime);
/////////////////////////////////////////////////////////////////////////
1:          * or we do a merge of both (sorted) lists. If this lists is bigger enough than the one we add, then
1:          * tombstones, while the CF we're adding it to (the one in the memtable) has many. In that case, using add() is
/////////////////////////////////////////////////////////////////////////
0:                 if (comparator.compare(tombstones.starts[j], ends[i]) < 0)
1:                     insertFrom(i, tombstones.starts[j], tombstones.ends[j], tombstones.markedAts[j], tombstones.delTimes[j]);
/////////////////////////////////////////////////////////////////////////
1:             // Addds the remaining ones from tombstones if any (note that addInternal will increment size if relevant).
1:                 addInternal(size, tombstones.starts[j], tombstones.ends[j], tombstones.markedAts[j], tombstones.delTimes[j]);
/////////////////////////////////////////////////////////////////////////
0:      * Inserts a new element starting at index i. This method assumes that i is the insertion point
0:      * in term of intervals for start:
0:      *    ends[i-1] <= start < ends[i]
1:         while (i < size)
0:             assert i == 0 || comparator.compare(start, ends[i-1]) >= 0;
0:             assert i >= size || comparator.compare(start, ends[i]) < 0;
1:             // Do we overwrite the current element?
0:             if (markedAt > markedAts[i])
1:                 // We do overwrite.
1: 
1:                 // First deal with what might come before the newly added one.
1:                 if (comparator.compare(starts[i], start) < 0)
1:                 {
0:                     addInternal(i, starts[i], start, markedAts[i], delTimes[i]);
1:                     i++;
0:                     // We don't need to do the following line, but in spirit that's what we want to do
0:                     // setInternal(i, start, ends[i], markedAts, delTime])
1:                 }
1: 
1:                 // now, start <= starts[i]
1: 
0:                 // If the new element stops before the current one, insert it and
0:                 // we're done
0:                 if (comparator.compare(end, starts[i]) <= 0)
1:                 {
1:                     addInternal(i, start, end, markedAt, delTime);
1:                     return;
1:                 }
1: 
1:                 // Do we overwrite the current element fully?
1:                 int cmp = comparator.compare(ends[i], end);
1:                 if (cmp <= 0)
1:                 {
1:                     // We do overwrite fully:
0:                     // update the current element until it's end and continue
0:                     // on with the next element (with the new inserted start == current end).
1: 
0:                     // If we're on the last element, we can optimize
0:                     if (i == size-1)
1:                     {
0:                         setInternal(i, start, end, markedAt, delTime);
1:                         return;
1:                     }
1: 
0:                     setInternal(i, start, ends[i], markedAt, delTime);
0:                     if (cmp == 0)
1:                         return;
1: 
0:                     start = ends[i];
1:                     i++;
1:                 }
1:                 else
1:                 {
0:                     // We don't ovewrite fully. Insert the new interval, and then update the now next
1:                     // one to reflect the not overwritten parts. We're then done.
1:                     addInternal(i, start, end, markedAt, delTime);
1:                     i++;
0:                     setInternal(i, end, ends[i], markedAts[i], delTimes[i]);
1:                     return;
1:                 }
1:                 // we don't overwrite the current element
1: 
1:                 // If the new interval starts before the current one, insert that new interval
1:                 if (comparator.compare(start, starts[i]) < 0)
1:                 {
0:                     // If we stop before the start of the current element, just insert the new
0:                     // interval and we're done; otherwise insert until the beginning of the
0:                     // current element
0:                     if (comparator.compare(end, starts[i]) <= 0)
1:                     {
1:                         addInternal(i, start, end, markedAt, delTime);
1:                         return;
1:                     }
0:                     addInternal(i, start, starts[i], markedAt, delTime);
1:                     i++;
1:                 }
1: 
1:                 // After that, we're overwritten on the current element but might have
1:                 // some residual parts after ...
1: 
1:                 // ... unless we don't extend beyond it.
1:                 if (comparator.compare(end, ends[i]) <= 0)
1:                     return;
1: 
0:                 start = ends[i];
1:                 i++;
1:         // If we got there, then just insert the remainder at the end
1:         addInternal(i, start, end, markedAt, delTime);
commit:b4bcdfc
/////////////////////////////////////////////////////////////////////////
0:                     if (comparator.compare(name, ends[idx]) <= 0)
commit:37130b5
/////////////////////////////////////////////////////////////////////////
1:     public void updateAllTimestamp(long timestamp)
1:     {
1:         for (int i = 0; i < size; i++)
1:             markedAts[i] = timestamp;
1:     }
1: 
commit:4df6c28
commit:f5b224c
/////////////////////////////////////////////////////////////////////////
0:             // Addds the remaining ones from tombstones if any (not that insertFrom will increment size if relevant).
0:                 insertFrom(size - 1, tombstones.starts[j], tombstones.ends[j], tombstones.markedAts[j], tombstones.delTimes[j]);
/////////////////////////////////////////////////////////////////////////
0:      *   - starts[i] <= start
/////////////////////////////////////////////////////////////////////////
0:          *  - s < e_i && e <= e_i: we're fully contained in i.
0:          *  - s < e_i && e > e_i: we rewrite X to X1=[s, e_i]@t + X2=[e_i, e]@t. X1 is fully contained
0:          *  - s >= e_i: we're in the insertAfter() case for i.
0:         if (comparator.compare(start, ends[i]) < 0)
commit:88f65a1
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.db;
1: 
0: import java.io.DataInput;
0: import java.io.DataOutput;
0: import java.io.IOException;
1: import java.nio.ByteBuffer;
1: import java.util.Arrays;
0: import java.util.Comparator;
1: import java.util.Iterator;
1: 
0: import com.google.common.annotations.VisibleForTesting;
0: import com.google.common.collect.AbstractIterator;
1: 
0: import org.apache.cassandra.db.marshal.AbstractType;
0: import org.apache.cassandra.io.IVersionedSerializer;
0: import org.apache.cassandra.net.MessagingService;
0: import org.apache.cassandra.utils.ByteBufferUtil;
1: 
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * Data structure holding the range tombstones of a ColumnFamily.
1:  * <p>
1:  * This is essentially a sorted list of non-overlapping (tombstone) ranges.
1:  * <p>
1:  * A range tombstone has 4 elements: the start and end of the range covered,
1:  * and the deletion infos (markedAt timestamp and local deletion time). The
1:  * markedAt timestamp is what define the priority of 2 overlapping tombstones.
0:  * That is, given 2 tombstones [0, 10]@t1 and [5, 15]@t2, then if t2 > t1 (and
1:  * are the tombstones markedAt values), the 2nd tombstone take precedence over
1:  * the first one on [5, 10]. If such tombstones are added to a RangeTombstoneList,
1:  * the range tombstone list will store them as [[0, 5]@t1, [5, 15]@t2].
1:  * <p>
1:  * The only use of the local deletion time is to know when a given tombstone can
1:  * be purged, which will be done by the purge() method.
1:  */
0: public class RangeTombstoneList implements Iterable<RangeTombstone>
1: {
0:     private static final Logger logger = LoggerFactory.getLogger(RangeTombstoneList.class);
1: 
0:     public static final Serializer serializer = new Serializer();
1: 
0:     private final Comparator<ByteBuffer> comparator;
1: 
1:     // Note: we don't want to use a List for the markedAts and delTimes to avoid boxing. We could
1:     // use a List for starts and ends, but having arrays everywhere is almost simpler.
0:     private ByteBuffer[] starts;
0:     private ByteBuffer[] ends;
1:     private long[] markedAts;
1:     private int[] delTimes;
1: 
1:     private int size;
1: 
0:     private RangeTombstoneList(Comparator<ByteBuffer> comparator, ByteBuffer[] starts, ByteBuffer[] ends, long[] markedAts, int[] delTimes, int size)
1:     {
1:         assert starts.length == ends.length && starts.length == markedAts.length && starts.length == delTimes.length;
1:         this.comparator = comparator;
1:         this.starts = starts;
1:         this.ends = ends;
1:         this.markedAts = markedAts;
1:         this.delTimes = delTimes;
1:         this.size = size;
1:     }
1: 
0:     public RangeTombstoneList(Comparator<ByteBuffer> comparator, int capacity)
1:     {
0:         this(comparator, new ByteBuffer[capacity], new ByteBuffer[capacity], new long[capacity], new int[capacity], 0);
1:     }
1: 
1:     public boolean isEmpty()
1:     {
1:         return size == 0;
1:     }
1: 
1:     public int size()
1:     {
1:         return size;
1:     }
1: 
0:     public Comparator<ByteBuffer> comparator()
1:     {
1:         return comparator;
1:     }
1: 
1:     public RangeTombstoneList copy()
1:     {
1:         return new RangeTombstoneList(comparator,
1:                                       Arrays.copyOf(starts, size),
1:                                       Arrays.copyOf(ends, size),
1:                                       Arrays.copyOf(markedAts, size),
1:                                       Arrays.copyOf(delTimes, size),
0:                                       size);
1:     }
1: 
1:     public void add(RangeTombstone tombstone)
1:     {
0:         add(tombstone.min, tombstone.max, tombstone.data.markedForDeleteAt, tombstone.data.localDeletionTime);
1:     }
1: 
1:     /**
1:      * Adds a new range tombstone.
1:      *
1:      * This method will be faster if the new tombstone sort after all the currently existing ones (this is a common use case), 
1:      * but it doesn't assume it.
1:      */
0:     public void add(ByteBuffer start, ByteBuffer end, long markedAt, int delTime)
1:     {
1:         if (isEmpty())
1:         {
1:             addInternal(0, start, end, markedAt, delTime);
1:             return;
1:         }
1: 
0:         int c = comparator.compare(starts[size-1], start);
1: 
1:         // Fast path if we add in sorted order
0:         if (c <= 0)
1:         {
0:             // Note that we may still overlap the last range
0:             insertFrom(size-1, start, end, markedAt, delTime);
1:         }
1:         else
1:         {
0:             int pos = Arrays.binarySearch(starts, 0, size, start, comparator);
1:             if (pos >= 0)
0:                 insertFrom(pos, start, end, markedAt, delTime);
1:             else
0:                 // Insertion point (-pos-1) is such start < start[-pos-1], so we should insert from the previous
0:                 insertFrom(-pos-2, start, end, markedAt, delTime);
1:         }
1:     }
1: 
1:     /**
1:      * Adds all the range tombstones of {@code tombstones} to this RangeTombstoneList.
1:      */
1:     public void addAll(RangeTombstoneList tombstones)
1:     {
1:         if (tombstones.isEmpty())
1:             return;
1: 
1:         if (isEmpty())
1:         {
1:             copyArrays(tombstones, this);
1:             return;
1:         }
1: 
1:         /*
1:          * We basically have 2 techniques we can use here: either we repeatedly call add() on tombstones values,
0:          * or we do a merge of both (sorted) lists. If this lists is bigger enough than the one we add, the
1:          * calling add() will be faster, otherwise it's merging that will be faster.
1:          *
1:          * Let's note that during memtables updates, it might not be uncommon that a new update has only a few range
0:          * tombstones, while the CF we're adding it to (the on in the memtable) has many. In that case, using add() is
1:          * likely going to be faster.
1:          *
1:          * In other cases however, like when diffing responses from multiple nodes, the tombstone lists we "merge" will
1:          * be likely sized, so using add() might be a bit inefficient.
1:          *
1:          * Roughly speaking (this ignore the fact that updating an element is not exactly constant but that's not a big
1:          * deal), if n is the size of this list and m is tombstones size, merging is O(n+m) while using add() is O(m*log(n)).
1:          *
1:          * But let's not crank up a logarithm computation for that. Long story short, merging will be a bad choice only
1:          * if this list size is lot bigger that the other one, so let's keep it simple.
1:          */
1:         if (size > 10 * tombstones.size)
1:         {
1:             for (int i = 0; i < tombstones.size; i++)
1:                 add(tombstones.starts[i], tombstones.ends[i], tombstones.markedAts[i], tombstones.delTimes[i]);
1:         }
1:         else
1:         {
1:             int i = 0;
1:             int j = 0;
1:             while (i < size && j < tombstones.size)
1:             {
0:                 if (comparator.compare(tombstones.starts[j], starts[i]) < 0)
1:                 {
0:                     insertFrom(i-1, tombstones.starts[j], tombstones.ends[j], tombstones.markedAts[j], tombstones.delTimes[j]);
1:                     j++;
1:                 }
1:                 else
1:                 {
0:                     i++;
1:                 }
1:             }
1:             for (; j < tombstones.size; j++)
0:                 insertFrom((i++) - 1, tombstones.starts[j], tombstones.ends[j], tombstones.markedAts[j], tombstones.delTimes[j]);
1:         }
1:     }
1: 
1:     /**
1:      * Returns whether the given name/timestamp pair is deleted by one of the tombstone
1:      * of this RangeTombstoneList.
1:      */
0:     public boolean isDeleted(ByteBuffer name, long timestamp)
1:     {
0:         int idx = searchInternal(name);
0:         return idx >= 0 && markedAts[idx] >= timestamp;
1:     }
1: 
1:     /**
0:      * Returns a new {@link InOrderTester}.
1:      */
0:     InOrderTester inOrderTester()
1:     {
0:         return new InOrderTester();
1:     }
1: 
1:     /**
1:      * Returns the DeletionTime for the tombstone overlapping {@code name} (there can't be more than one),
1:      * or null if {@code name} is not covered by any tombstone.
1:      */
0:     public DeletionTime search(ByteBuffer name) {
0:         int idx = searchInternal(name);
0:         return idx < 0 ? null : new DeletionTime(markedAts[idx], delTimes[idx]);
1:     }
1: 
0:     private int searchInternal(ByteBuffer name)
1:     {
1:         if (isEmpty())
1:             return -1;
1: 
0:         int pos = Arrays.binarySearch(starts, 0, size, name, comparator);
1:         if (pos >= 0)
1:         {
0:             // We're exactly on an interval start. The one subtility is that we need to check if
0:             // the previous is not equal to us and doesn't have a higher marked at
0:             if (pos > 0 && comparator.compare(name, ends[pos-1]) == 0 && markedAts[pos-1] > markedAts[pos])
0:                 return pos-1;
1:             else
0:                 return pos;
1:         }
1:         else
1:         {
1:             // We potentially intersect the range before our "insertion point"
1:             int idx = -pos-2;
1:             if (idx < 0)
1:                 return -1;
1: 
0:             return comparator.compare(name, ends[idx]) <= 0 ? idx : -1;
1:         }
1:     }
1: 
1:     public int dataSize()
1:     {
0:         int dataSize = TypeSizes.NATIVE.sizeof(size);
1:         for (int i = 0; i < size; i++)
1:         {
0:             dataSize += starts[i].remaining() + ends[i].remaining();
0:             dataSize += TypeSizes.NATIVE.sizeof(markedAts[i]);
0:             dataSize += TypeSizes.NATIVE.sizeof(delTimes[i]);
1:         }
1:         return dataSize;
1:     }
1: 
0:     public long minMarkedAt()
1:     {
0:         long min = Long.MAX_VALUE;
1:         for (int i = 0; i < size; i++)
0:             min = Math.min(min, markedAts[i]);
0:         return min;
1:     }
1: 
0:     public long maxMarkedAt()
1:     {
0:         long max = Long.MIN_VALUE;
1:         for (int i = 0; i < size; i++)
0:             max = Math.max(max, markedAts[i]);
0:         return max;
1:     }
1: 
1:     /**
0:      * Removes all range tombstones whose local deletion time is older than gcBefore.
1:      */
0:     public void purge(int gcBefore)
1:     {
1:         int j = 0;
1:         for (int i = 0; i < size; i++)
1:         {
0:             if (delTimes[i] >= gcBefore)
0:                 setInternal(j++, starts[i], ends[i], markedAts[i], delTimes[i]);
1:         }
0:         size = j;
1:     }
1: 
1:     /**
0:      * Returns whether {@code purge(gcBefore)} would remove something or not.
1:      */
0:     public boolean hasIrrelevantData(int gcBefore)
1:     {
1:         for (int i = 0; i < size; i++)
1:         {
0:             if (delTimes[i] < gcBefore)
1:                 return true;
1:         }
1:         return false;
1:     }
1: 
1:     public Iterator<RangeTombstone> iterator()
1:     {
0:         return new AbstractIterator<RangeTombstone>()
1:         {
0:             private int idx;
1: 
0:             protected RangeTombstone computeNext()
1:             {
0:                 if (idx >= size)
0:                     return endOfData();
1: 
0:                 RangeTombstone t = new RangeTombstone(starts[idx], ends[idx], markedAts[idx], delTimes[idx]);
0:                 idx++;
0:                 return t;
1:             }
0:         };
1:     }
1: 
1:     @Override
1:     public boolean equals(Object o)
1:     {
1:         if(!(o instanceof RangeTombstoneList))
1:             return false;
1:         RangeTombstoneList that = (RangeTombstoneList)o;
1:         if (size != that.size)
1:             return false;
1: 
1:         for (int i = 0; i < size; i++)
1:         {
1:             if (!starts[i].equals(that.starts[i]))
1:                 return false;
1:             if (!ends[i].equals(that.ends[i]))
1:                 return false;
1:             if (markedAts[i] != that.markedAts[i])
1:                 return false;
1:             if (delTimes[i] != that.delTimes[i])
1:                 return false;
1:         }
1:         return true;
1:     }
1: 
1:     @Override
1:     public final int hashCode()
1:     {
1:         int result = size;
1:         for (int i = 0; i < size; i++)
1:         {
1:             result += starts[i].hashCode() + ends[i].hashCode();
1:             result += (int)(markedAts[i] ^ (markedAts[i] >>> 32));
1:             result += delTimes[i];
1:         }
1:         return result;
1:     }
1: 
1:     private static void copyArrays(RangeTombstoneList src, RangeTombstoneList dst)
1:     {
1:         dst.grow(src.size);
1:         System.arraycopy(src.starts, 0, dst.starts, 0, src.size);
1:         System.arraycopy(src.ends, 0, dst.ends, 0, src.size);
1:         System.arraycopy(src.markedAts, 0, dst.markedAts, 0, src.size);
1:         System.arraycopy(src.delTimes, 0, dst.delTimes, 0, src.size);
1:         dst.size = src.size;
1:     }
1: 
1:     /*
0:      * Inserts a new element whose start should be inserted at index i. This method
0:      * assumes that:
0:      *   - starts[i] <= start.
0:      *   - start < starts[i+1] or there is no i+1 element.
1:      */
0:     private void insertFrom(int i, ByteBuffer start, ByteBuffer end, long markedAt, int delTime)
1:     {
0:         if (i < 0)
1:         {
0:             insertAfter(i, start, end, markedAt, delTime);
1:             return;
1:         }
1: 
1:         /*
0:          * We have elt(i) = [s_i, e_i]@t_i and want to insert X = [s, e]@t, knowing that s_i < s < s_i+1.
0:          * We can have 3 cases:
0:          *  - s <= e_i && e <= e_i: we're fully contained in i.
0:          *  - s <= e_i && e > e_i: we rewrite X to X1=[s, e_i]@t + X2=[e_i, e]@t. X1 is fully contained
0:          *             in i and X2 is the insertAfter() case for i.
0:          *  - s > e_i: we're in the insertAfter() case for i.
1:          */
0:         if (comparator.compare(start, ends[i]) <= 0)
1:         {
0:             if (comparator.compare(end, ends[i]) <= 0)
1:             {
0:                 update(i, start, end, markedAt, delTime);
1:             }
1:             else
1:             {
0:                 insertAfter(i, ends[i], end, markedAt, delTime);
0:                 update(i, start, ends[i], markedAt, delTime);
1:             }
1:         }
1:         else
1:         {
0:             insertAfter(i, start, end, markedAt, delTime);
1:         }
1:     }
1: 
1:     /*
0:      * Inserts a new element knowing that the new element start strictly after
0:      * the one at index i, i.e that:
0:      *   - ends[i] <= start (or i == -1)
1:      */
0:     private void insertAfter(int i, ByteBuffer start, ByteBuffer end, long markedAt, int delTime)
1:     {
0:         if (i == size - 1)
1:         {
0:             addInternal(i+1, start, end, markedAt, delTime);
1:             return;
1:         }
1: 
1:         /*
0:          * We have the following intervals:
0:          *           i            i+1
0:          *   ..., [s1, e1]@t1, [s2, e2]@t2, ...
1:          *
0:          * And we want to insert X = [s, e]@t, knowing that e1 <= s.
0:          * We can have 2 cases:
0:          *  - s < s2: we rewrite X to X1=[s, s2]@t + X2=[s2, e]@t. X2 meet the weakInsertFrom() condition
0:          *            for i+1, and X1 is a new element between i and i+1.
0:          *  - s2 <= s: we're in the weakInsertFrom() case for i+1.
1:          */
0:         if (comparator.compare(start, starts[i+1]) < 0)
1:         {
1:             /*
0:              * If it happens the new element is fully before the current one, we insert it and
0:              * we're done
1:              */
0:             if (comparator.compare(end, starts[i+1]) <= 0)
1:             {
0:                 addInternal(i+1, start, end, markedAt, delTime);
1:                 return;
1:             }
1: 
0:             weakInsertFrom(i+1, starts[i+1], end, markedAt, delTime);
0:             addInternal(i+1, start, starts[i+1], markedAt, delTime);
1:         }
1:         else
1:         {
0:             weakInsertFrom(i+1, start, end, markedAt, delTime);
1:         }
1:     }
1: 
1:     /*
0:      * Weak version of insertFrom that only assumes the new element starts after index i,
0:      * but without knowing about the 2nd condition, i.e. this only assume that:
0:      *   - starts[i] <= start
1:      */
0:     private void weakInsertFrom(int i, ByteBuffer start, ByteBuffer end, long markedAt, int delTime)
1:     {
1:         /*
0:          * Either start is before the next element start, and we're in fact in the insertFrom()
0:          * case, or it's not and it's an weakInsertFrom for the next index.
1:          */
0:         if (i == size - 1 || comparator.compare(start, starts[i+1]) < 0)
0:             insertFrom(i, start, end, markedAt, delTime);
1:         else
0:             weakInsertFrom(i+1, start, end, markedAt, delTime);
1:     }
1: 
1:     /*
0:      * Update index i with new element, assuming that new element is contained in the element i,
0:      * i.e that:
0:      *   - starts[i] <= s
0:      *   - e <= end[i]
1:      */
0:     private void update(int i, ByteBuffer start, ByteBuffer end, long markedAt, int delTime)
1:     {
1:         /*
0:          * If the new markedAt is lower than the one of i, we can ignore the
0:          * new element, otherwise we split the current element.
1:          */
0:         if (markedAts[i] < markedAt)
1:         {
0:             if (comparator.compare(ends[i], end) != 0)
0:                 addInternal(i+1, end, ends[i], markedAts[i], delTimes[i]);
1: 
0:             if (comparator.compare(starts[i], start) == 0)
1:             {
1:                 markedAts[i] = markedAt;
1:                 delTimes[i] = delTime;
1:                 ends[i] = end;
1:             }
1:             else
1:             {
0:                 addInternal(i+1, start, end, markedAt, delTime);
0:                 ends[i] = start;
1:             }
1:         }
1:     }
1: 
1:     private int capacity()
1:     {
1:         return starts.length;
1:     }
1: 
1:     /*
1:      * Adds the new tombstone at index i, growing and/or moving elements to make room for it.
1:      */
0:     private void addInternal(int i, ByteBuffer start, ByteBuffer end, long markedAt, int delTime)
1:     {
0:         assert i >= 0;
1: 
1:         if (size == capacity())
1:             growToFree(i);
1:         else if (i < size)
1:             moveElements(i);
1: 
0:         setInternal(i, start, end, markedAt, delTime);
1:         size++;
1:     }
1: 
1:     /*
1:      * Grow the arrays, leaving index i "free" in the process.
1:      */
1:     private void growToFree(int i)
1:     {
1:         int newLength = (capacity() * 3) / 2 + 1;
1:         grow(i, newLength);
1:     }
1: 
1:     /*
1:      * Grow the arrays to match newLength capacity.
1:      */
1:     private void grow(int newLength)
1:     {
1:         if (capacity() < newLength)
1:             grow(-1, newLength);
1:     }
1: 
1:     private void grow(int i, int newLength)
1:     {
1:         starts = grow(starts, size, newLength, i);
1:         ends = grow(ends, size, newLength, i);
1:         markedAts = grow(markedAts, size, newLength, i);
1:         delTimes = grow(delTimes, size, newLength, i);
1:     }
1: 
0:     private static ByteBuffer[] grow(ByteBuffer[] a, int size, int newLength, int i)
1:     {
1:         if (i < 0 || i >= size)
1:             return Arrays.copyOf(a, newLength);
1: 
0:         ByteBuffer[] newA = new ByteBuffer[newLength];
1:         System.arraycopy(a, 0, newA, 0, i);
1:         System.arraycopy(a, i, newA, i+1, size - i);
1:         return newA;
1:     }
1: 
1:     private static long[] grow(long[] a, int size, int newLength, int i)
1:     {
1:         if (i < 0 || i >= size)
1:             return Arrays.copyOf(a, newLength);
1: 
1:         long[] newA = new long[newLength];
1:         System.arraycopy(a, 0, newA, 0, i);
1:         System.arraycopy(a, i, newA, i+1, size - i);
1:         return newA;
1:     }
1: 
1:     private static int[] grow(int[] a, int size, int newLength, int i)
1:     {
1:         if (i < 0 || i >= size)
1:             return Arrays.copyOf(a, newLength);
1: 
1:         int[] newA = new int[newLength];
1:         System.arraycopy(a, 0, newA, 0, i);
1:         System.arraycopy(a, i, newA, i+1, size - i);
1:         return newA;
1:     }
1: 
1:     /*
1:      * Move elements so that index i is "free", assuming the arrays have at least one free slot at the end.
1:      */
1:     private void moveElements(int i)
1:     {
1:         if (i >= size)
1:             return;
1: 
1:         System.arraycopy(starts, i, starts, i+1, size - i);
1:         System.arraycopy(ends, i, ends, i+1, size - i);
1:         System.arraycopy(markedAts, i, markedAts, i+1, size - i);
1:         System.arraycopy(delTimes, i, delTimes, i+1, size - i);
1:     }
1: 
0:     private void setInternal(int i, ByteBuffer start, ByteBuffer end, long markedAt, int delTime)
1:     {
1:         starts[i] = start;
1:         ends[i] = end;
1:         markedAts[i] = markedAt;
1:         delTimes[i] = delTime;
1:     }
1: 
0:     public static class Serializer implements IVersionedSerializer<RangeTombstoneList>
1:     {
0:         private Serializer() {}
1: 
0:         public void serialize(RangeTombstoneList tombstones, DataOutput out, int version) throws IOException
1:         {
0:             if (tombstones == null)
1:             {
0:                 out.writeInt(0);
1:                 return;
1:             }
1: 
0:             out.writeInt(tombstones.size);
1:             for (int i = 0; i < tombstones.size; i++)
1:             {
0:                 ByteBufferUtil.writeWithShortLength(tombstones.starts[i], out);
0:                 ByteBufferUtil.writeWithShortLength(tombstones.ends[i], out);
0:                 out.writeInt(tombstones.delTimes[i]);
0:                 out.writeLong(tombstones.markedAts[i]);
1:             }
1:         }
1: 
1:         /*
0:          * RangeTombstoneList depends on the column family comparator, but it is not serialized.
0:          * Thus deserialize(DataInput, int, Comparator<ByteBuffer>) should be used instead of this method.
1:          */
0:         public RangeTombstoneList deserialize(DataInput in, int version) throws IOException
1:         {
0:             throw new UnsupportedOperationException();
1:         }
1: 
0:         public RangeTombstoneList deserialize(DataInput in, int version, Comparator<ByteBuffer> comparator) throws IOException
1:         {
0:             int size = in.readInt();
0:             if (size == 0)
0:                 return null;
1: 
0:             RangeTombstoneList tombstones = new RangeTombstoneList(comparator, size);
1: 
1:             for (int i = 0; i < size; i++)
1:             {
0:                 ByteBuffer start = ByteBufferUtil.readWithShortLength(in);
0:                 ByteBuffer end = ByteBufferUtil.readWithShortLength(in);
0:                 int delTime =  in.readInt();
0:                 long markedAt = in.readLong();
1: 
0:                 if (version >= MessagingService.VERSION_20)
1:                 {
0:                     tombstones.setInternal(i, start, end, markedAt, delTime);
1:                 }
1:                 else
1:                 {
1:                     /*
0:                      * The old implementation used to have range sorted by left value, but with potentially
0:                      * overlapping range. So we need to use the "slow" path.
1:                      */
0:                     tombstones.add(start, end, markedAt, delTime);
1:                 }
1:             }
1: 
0:             // The "slow" path take care of updating the size, but not the fast one
0:             if (version >= MessagingService.VERSION_20)
0:                 tombstones.size = size;
0:             return tombstones;
1:         }
1: 
0:         public long serializedSize(RangeTombstoneList tombstones, TypeSizes typeSizes, int version)
1:         {
0:             if (tombstones == null)
0:                 return typeSizes.sizeof(0);
1: 
0:             long size = typeSizes.sizeof(tombstones.size);
1:             for (int i = 0; i < tombstones.size; i++)
1:             {
0:                 int startSize = tombstones.starts[i].remaining();
0:                 size += typeSizes.sizeof((short)startSize) + startSize;
0:                 int endSize = tombstones.ends[i].remaining();
0:                 size += typeSizes.sizeof((short)endSize) + endSize;
0:                 size += typeSizes.sizeof(tombstones.delTimes[i]);
0:                 size += typeSizes.sizeof(tombstones.markedAts[i]);
1:             }
1:             return size;
1:         }
1: 
0:         public long serializedSize(RangeTombstoneList tombstones, int version)
1:         {
0:             return serializedSize(tombstones, TypeSizes.NATIVE, version);
1:         }
1:     }
1: 
1:     /**
0:      * This object allow testing whether a given column (name/timestamp) is deleted
0:      * or not by this RangeTombstoneList, assuming that the column given to this
0:      * object are passed in (comparator) sorted order.
1:      *
0:      * This is more efficient that calling RangeTombstoneList.isDeleted() repeatedly
0:      * in that case since we're able to take the sorted nature of the RangeTombstoneList
0:      * into account.
1:      */
0:     public class InOrderTester
1:     {
0:         private int idx;
1: 
0:         public boolean isDeleted(ByteBuffer name, long timestamp)
1:         {
0:             while (idx < size)
1:             {
0:                 int cmp = comparator.compare(name, starts[idx]);
0:                 if (cmp == 0)
1:                 {
0:                     // As for searchInternal, we need to check the previous end
0:                     if (idx > 0 && comparator.compare(name, ends[idx-1]) == 0 && markedAts[idx-1] > markedAts[idx])
0:                         return markedAts[idx-1] >= timestamp;
1:                     else
0:                         return markedAts[idx] >= timestamp;
1:                 }
0:                 else if (cmp < 0)
1:                 {
1:                     return false;
1:                 }
1:                 else
1:                 {
0:                     if (comparator.compare(name, ends[idx]) < 0)
0:                         return markedAts[idx] >= timestamp;
1:                     else
0:                         idx++;
1:                 }
1:             }
1:             return false;
1:         }
1:     }
1: }
commit:6e81f81
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: package org.apache.cassandra.db;
0: 
0: import java.io.DataInput;
0: import java.io.DataOutput;
0: import java.io.IOException;
0: import java.nio.ByteBuffer;
0: import java.util.Arrays;
0: import java.util.Comparator;
0: import java.util.Iterator;
0: 
0: import com.google.common.annotations.VisibleForTesting;
0: import com.google.common.collect.AbstractIterator;
0: 
0: import org.apache.cassandra.db.marshal.AbstractType;
0: import org.apache.cassandra.io.IVersionedSerializer;
0: import org.apache.cassandra.net.MessagingService;
0: import org.apache.cassandra.utils.ByteBufferUtil;
0: 
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
0: 
0: /**
0:  * Data structure holding the range tombstones of a ColumnFamily.
0:  * <p>
0:  * This is essentially a sorted list of non-overlapping (tombstone) ranges.
0:  * <p>
0:  * A range tombstone has 4 elements: the start and end of the range covered,
0:  * and the deletion infos (markedAt timestamp and local deletion time). The
0:  * markedAt timestamp is what define the priority of 2 overlapping tombstones.
0:  * That is, given 2 tombstones [0, 10]@t1 and [5, 15]@t2, then if t2 > t1 (and
0:  * are the tombstones markedAt values), the 2nd tombstone take precedence over
0:  * the first one on [5, 10]. If such tombstones are added to a RangeTombstoneList,
0:  * the range tombstone list will store them as [[0, 5]@t1, [5, 15]@t2].
0:  * <p>
0:  * The only use of the local deletion time is to know when a given tombstone can
0:  * be purged, which will be done by the purge() method.
0:  */
0: public class RangeTombstoneList implements Iterable<RangeTombstone>
0: {
0:     private static final Logger logger = LoggerFactory.getLogger(RangeTombstoneList.class);
0: 
0:     public static final Serializer serializer = new Serializer();
0: 
0:     private final Comparator<ByteBuffer> comparator;
0: 
0:     // Note: we don't want to use a List for the markedAts and delTimes to avoid boxing. We could
0:     // use a List for starts and ends, but having arrays everywhere is almost simpler.
0:     private ByteBuffer[] starts;
0:     private ByteBuffer[] ends;
0:     private long[] markedAts;
0:     private int[] delTimes;
0: 
0:     private int size;
0: 
0:     private RangeTombstoneList(Comparator<ByteBuffer> comparator, ByteBuffer[] starts, ByteBuffer[] ends, long[] markedAts, int[] delTimes, int size)
0:     {
0:         assert starts.length == ends.length && starts.length == markedAts.length && starts.length == delTimes.length;
0:         this.comparator = comparator;
0:         this.starts = starts;
0:         this.ends = ends;
0:         this.markedAts = markedAts;
0:         this.delTimes = delTimes;
0:         this.size = size;
0:     }
0: 
0:     public RangeTombstoneList(Comparator<ByteBuffer> comparator, int capacity)
0:     {
0:         this(comparator, new ByteBuffer[capacity], new ByteBuffer[capacity], new long[capacity], new int[capacity], 0);
0:     }
0: 
0:     public boolean isEmpty()
0:     {
0:         return size == 0;
0:     }
0: 
0:     public int size()
0:     {
0:         return size;
0:     }
0: 
0:     public Comparator<ByteBuffer> comparator()
0:     {
0:         return comparator;
0:     }
0: 
0:     public RangeTombstoneList copy()
0:     {
0:         return new RangeTombstoneList(comparator,
0:                                       Arrays.copyOf(starts, size),
0:                                       Arrays.copyOf(ends, size),
0:                                       Arrays.copyOf(markedAts, size),
0:                                       Arrays.copyOf(delTimes, size),
0:                                       size);
0:     }
0: 
0:     public void add(RangeTombstone tombstone)
0:     {
0:         add(tombstone.min, tombstone.max, tombstone.data.markedForDeleteAt, tombstone.data.localDeletionTime);
0:     }
0: 
0:     /**
0:      * Adds a new range tombstone.
0:      *
0:      * This method will be faster if the new tombstone sort after all the currently existing ones (this is a common use case), 
0:      * but it doesn't assume it.
0:      */
0:     public void add(ByteBuffer start, ByteBuffer end, long markedAt, int delTime)
0:     {
0:         if (isEmpty())
0:         {
0:             addInternal(0, start, end, markedAt, delTime);
0:             return;
0:         }
0: 
0:         int c = comparator.compare(starts[size-1], start);
0: 
0:         // Fast path if we add in sorted order
0:         if (c <= 0)
0:         {
0:             // Note that we may still overlap the last range
0:             insertFrom(size-1, start, end, markedAt, delTime);
0:         }
0:         else
0:         {
0:             int pos = Arrays.binarySearch(starts, 0, size, start, comparator);
0:             if (pos >= 0)
0:                 insertFrom(pos, start, end, markedAt, delTime);
0:             else
0:                 // Insertion point (-pos-1) is such start < start[-pos-1], so we should insert from the previous
0:                 insertFrom(-pos-2, start, end, markedAt, delTime);
0:         }
0:     }
0: 
0:     /**
0:      * Adds all the range tombstones of {@code tombstones} to this RangeTombstoneList.
0:      */
0:     public void addAll(RangeTombstoneList tombstones)
0:     {
0:         if (tombstones.isEmpty())
0:             return;
0: 
0:         if (isEmpty())
0:         {
0:             copyArrays(tombstones, this);
0:             return;
0:         }
0: 
0:         /*
0:          * We basically have 2 techniques we can use here: either we repeatedly call add() on tombstones values,
0:          * or we do a merge of both (sorted) lists. If this lists is bigger enough than the one we add, the
0:          * calling add() will be faster, otherwise it's merging that will be faster.
0:          *
0:          * Let's note that during memtables updates, it might not be uncommon that a new update has only a few range
0:          * tombstones, while the CF we're adding it to (the on in the memtable) has many. In that case, using add() is
0:          * likely going to be faster.
0:          *
0:          * In other cases however, like when diffing responses from multiple nodes, the tombstone lists we "merge" will
0:          * be likely sized, so using add() might be a bit inefficient.
0:          *
0:          * Roughly speaking (this ignore the fact that updating an element is not exactly constant but that's not a big
0:          * deal), if n is the size of this list and m is tombstones size, merging is O(n+m) while using add() is O(m*log(n)).
0:          *
0:          * But let's not crank up a logarithm computation for that. Long story short, merging will be a bad choice only
0:          * if this list size is lot bigger that the other one, so let's keep it simple.
0:          */
0:         if (size > 10 * tombstones.size)
0:         {
0:             for (int i = 0; i < tombstones.size; i++)
0:                 add(tombstones.starts[i], tombstones.ends[i], tombstones.markedAts[i], tombstones.delTimes[i]);
0:         }
0:         else
0:         {
0:             int i = 0;
0:             int j = 0;
0:             while (i < size && j < tombstones.size)
0:             {
0:                 if (comparator.compare(tombstones.starts[j], starts[i]) < 0)
0:                 {
0:                     insertFrom(i-1, tombstones.starts[j], tombstones.ends[j], tombstones.markedAts[j], tombstones.delTimes[j]);
0:                     j++;
0:                 }
0:                 else
0:                 {
0:                     i++;
0:                 }
0:             }
0:             for (; j < tombstones.size; j++)
0:                 insertFrom((i++) - 1, tombstones.starts[j], tombstones.ends[j], tombstones.markedAts[j], tombstones.delTimes[j]);
0:         }
0:     }
0: 
0:     /**
0:      * Returns whether the given name/timestamp pair is deleted by one of the tombstone
0:      * of this RangeTombstoneList.
0:      */
0:     public boolean isDeleted(ByteBuffer name, long timestamp)
0:     {
0:         int idx = searchInternal(name);
0:         return idx >= 0 && markedAts[idx] >= timestamp;
0:     }
0: 
0:     /**
0:      * Returns the DeletionTime for the tombstone overlapping {@code name} (there can't be more than one),
0:      * or null if {@code name} is not covered by any tombstone.
0:      */
0:     public DeletionTime search(ByteBuffer name)
0:     {
0:         int idx = searchInternal(name);
0:         return idx < 0 ? null : new DeletionTime(markedAts[idx], delTimes[idx]);
0:     }
0: 
0:     private int searchInternal(ByteBuffer name)
0:     {
0:         if (isEmpty())
0:             return -1;
0: 
0:         int pos = Arrays.binarySearch(starts, 0, size, name, comparator);
0:         if (pos >= 0)
0:         {
0:             // We're exactly on an interval start. The one subtility is that we need to check if
0:             // the previous is not equal to us and doesn't have a higher marked at
0:             if (pos > 0 && comparator.compare(name, ends[pos-1]) == 0 && markedAts[pos-1] > markedAts[pos])
0:                 return pos-1;
0:             else
0:                 return pos;
0:         }
0:         else
0:         {
0:             // We potentially intersect the range before our "insertion point"
0:             int idx = -pos-2;
0:             if (idx < 0)
0:                 return -1;
0: 
0:             return comparator.compare(name, ends[idx]) <= 0 ? idx : -1;
0:         }
0:     }
0: 
0:     public int dataSize()
0:     {
0:         int dataSize = TypeSizes.NATIVE.sizeof(size);
0:         for (int i = 0; i < size; i++)
0:         {
0:             dataSize += starts[i].remaining() + ends[i].remaining();
0:             dataSize += TypeSizes.NATIVE.sizeof(markedAts[i]);
0:             dataSize += TypeSizes.NATIVE.sizeof(delTimes[i]);
0:         }
0:         return dataSize;
0:     }
0: 
0:     public long minMarkedAt()
0:     {
0:         long min = Long.MAX_VALUE;
0:         for (int i = 0; i < size; i++)
0:             min = Math.min(min, markedAts[i]);
0:         return min;
0:     }
0: 
0:     public long maxMarkedAt()
0:     {
0:         long max = Long.MIN_VALUE;
0:         for (int i = 0; i < size; i++)
0:             max = Math.max(max, markedAts[i]);
0:         return max;
0:     }
0: 
0:     /**
0:      * Removes all range tombstones whose local deletion time is older than gcBefore.
0:      */
0:     public void purge(int gcBefore)
0:     {
0:         int j = 0;
0:         for (int i = 0; i < size; i++)
0:         {
0:             if (delTimes[i] >= gcBefore)
0:                 setInternal(j++, starts[i], ends[i], markedAts[i], delTimes[i]);
0:         }
0:         size = j;
0:     }
0: 
0:     /**
0:      * Returns whether {@code purge(gcBefore)} would remove something or not.
0:      */
0:     public boolean hasIrrelevantData(int gcBefore)
0:     {
0:         for (int i = 0; i < size; i++)
0:         {
0:             if (delTimes[i] < gcBefore)
0:                 return true;
0:         }
0:         return false;
0:     }
0: 
0:     public Iterator<RangeTombstone> iterator()
0:     {
0:         return new AbstractIterator<RangeTombstone>()
0:         {
0:             private int idx;
0: 
0:             protected RangeTombstone computeNext()
0:             {
0:                 if (idx >= size)
0:                     return endOfData();
0: 
0:                 RangeTombstone t = new RangeTombstone(starts[idx], ends[idx], markedAts[idx], delTimes[idx]);
0:                 idx++;
0:                 return t;
0:             }
0:         };
0:     }
0: 
1:     @Override
0:     public boolean equals(Object o)
0:     {
0:         if(!(o instanceof RangeTombstoneList))
0:             return false;
0:         RangeTombstoneList that = (RangeTombstoneList)o;
0:         if (size != that.size)
0:             return false;
0: 
0:         for (int i = 0; i < size; i++)
0:         {
0:             if (!starts[i].equals(that.starts[i]))
0:                 return false;
0:             if (!ends[i].equals(that.ends[i]))
0:                 return false;
0:             if (markedAts[i] != that.markedAts[i])
0:                 return false;
0:             if (delTimes[i] != that.delTimes[i])
0:                 return false;
0:         }
0:         return true;
0:     }
0: 
1:     @Override
0:     public final int hashCode()
0:     {
0:         int result = size;
0:         for (int i = 0; i < size; i++)
0:         {
0:             result += starts[i].hashCode() + ends[i].hashCode();
0:             result += (int)(markedAts[i] ^ (markedAts[i] >>> 32));
0:             result += delTimes[i];
0:         }
0:         return result;
0:     }
0: 
0:     private static void copyArrays(RangeTombstoneList src, RangeTombstoneList dst)
0:     {
0:         dst.grow(src.size);
0:         System.arraycopy(src.starts, 0, dst.starts, 0, src.size);
0:         System.arraycopy(src.ends, 0, dst.ends, 0, src.size);
0:         System.arraycopy(src.markedAts, 0, dst.markedAts, 0, src.size);
0:         System.arraycopy(src.delTimes, 0, dst.delTimes, 0, src.size);
0:         dst.size = src.size;
0:     }
0: 
0:     /*
0:      * Inserts a new element whose start should be inserted at index i. This method
0:      * assumes that:
0:      *   - starts[i] <= start.
0:      *   - start < starts[i+1] or there is no i+1 element.
0:      */
0:     private void insertFrom(int i, ByteBuffer start, ByteBuffer end, long markedAt, int delTime)
0:     {
0:         if (i < 0)
0:         {
0:             insertAfter(i, start, end, markedAt, delTime);
0:             return;
0:         }
0: 
0:         /*
0:          * We have elt(i) = [s_i, e_i]@t_i and want to insert X = [s, e]@t, knowing that s_i < s < s_i+1.
0:          * We can have 3 cases:
0:          *  - s <= e_i && e <= e_i: we're fully contained in i.
0:          *  - s <= e_i && e > e_i: we rewrite X to X1=[s, e_i]@t + X2=[e_i, e]@t. X1 is fully contained
0:          *             in i and X2 is the insertAfter() case for i.
0:          *  - s > e_i: we're in the insertAfter() case for i.
0:          */
0:         if (comparator.compare(start, ends[i]) <= 0)
0:         {
0:             if (comparator.compare(end, ends[i]) <= 0)
0:             {
0:                 update(i, start, end, markedAt, delTime);
0:             }
0:             else
0:             {
0:                 insertAfter(i, ends[i], end, markedAt, delTime);
0:                 update(i, start, ends[i], markedAt, delTime);
0:             }
0:         }
0:         else
0:         {
0:             insertAfter(i, start, end, markedAt, delTime);
0:         }
0:     }
0: 
0:     /*
0:      * Inserts a new element knowing that the new element start strictly after
0:      * the one at index i, i.e that:
0:      *   - ends[i] <= start (or i == -1)
0:      */
0:     private void insertAfter(int i, ByteBuffer start, ByteBuffer end, long markedAt, int delTime)
0:     {
0:         if (i == size - 1)
0:         {
0:             addInternal(i+1, start, end, markedAt, delTime);
0:             return;
0:         }
0: 
0:         /*
0:          * We have the following intervals:
0:          *           i            i+1
0:          *   ..., [s1, e1]@t1, [s2, e2]@t2, ...
0:          *
0:          * And we want to insert X = [s, e]@t, knowing that e1 <= s.
0:          * We can have 2 cases:
0:          *  - s < s2: we rewrite X to X1=[s, s2]@t + X2=[s2, e]@t. X2 meet the weakInsertFrom() condition
0:          *            for i+1, and X1 is a new element between i and i+1.
0:          *  - s2 <= s: we're in the weakInsertFrom() case for i+1.
0:          */
0:         if (comparator.compare(start, starts[i+1]) < 0)
0:         {
0:             /*
0:              * If it happens the new element is fully before the current one, we insert it and
0:              * we're done
0:              */
0:             if (comparator.compare(end, starts[i+1]) <= 0)
0:             {
0:                 addInternal(i+1, start, end, markedAt, delTime);
0:                 return;
0:             }
0: 
0:             weakInsertFrom(i+1, starts[i+1], end, markedAt, delTime);
0:             addInternal(i+1, start, starts[i+1], markedAt, delTime);
0:         }
0:         else
0:         {
0:             weakInsertFrom(i+1, start, end, markedAt, delTime);
0:         }
0:     }
0: 
0:     /*
0:      * Weak version of insertFrom that only assumes the new element starts after index i,
0:      * but without knowing about the 2nd condition, i.e. this only assume that:
0:      *   - starts[i] <= start
0:      */
0:     private void weakInsertFrom(int i, ByteBuffer start, ByteBuffer end, long markedAt, int delTime)
0:     {
0:         /*
0:          * Either start is before the next element start, and we're in fact in the insertFrom()
0:          * case, or it's not and it's an weakInsertFrom for the next index.
0:          */
0:         if (i == size - 1 || comparator.compare(start, starts[i+1]) < 0)
0:             insertFrom(i, start, end, markedAt, delTime);
0:         else
0:             weakInsertFrom(i+1, start, end, markedAt, delTime);
0:     }
0: 
0:     /*
0:      * Update index i with new element, assuming that new element is contained in the element i,
0:      * i.e that:
0:      *   - starts[i] <= s
0:      *   - e <= end[i]
0:      */
0:     private void update(int i, ByteBuffer start, ByteBuffer end, long markedAt, int delTime)
0:     {
0:         /*
0:          * If the new markedAt is lower than the one of i, we can ignore the
0:          * new element, otherwise we split the current element.
0:          */
0:         if (markedAts[i] < markedAt)
0:         {
0:             if (comparator.compare(ends[i], end) != 0)
0:                 addInternal(i+1, end, ends[i], markedAts[i], delTimes[i]);
0: 
0:             if (comparator.compare(starts[i], start) == 0)
0:             {
0:                 markedAts[i] = markedAt;
0:                 delTimes[i] = delTime;
0:                 ends[i] = end;
0:             }
0:             else
0:             {
0:                 addInternal(i+1, start, end, markedAt, delTime);
0:                 ends[i] = start;
0:             }
0:         }
0:     }
0: 
0:     private int capacity()
0:     {
0:         return starts.length;
0:     }
0: 
0:     /*
0:      * Adds the new tombstone at index i, growing and/or moving elements to make room for it.
0:      */
0:     private void addInternal(int i, ByteBuffer start, ByteBuffer end, long markedAt, int delTime)
0:     {
0:         assert i >= 0;
0: 
0:         if (size == capacity())
0:             growToFree(i);
0:         else if (i < size)
0:             moveElements(i);
0: 
0:         setInternal(i, start, end, markedAt, delTime);
0:         size++;
0:     }
0: 
0:     /*
0:      * Grow the arrays, leaving index i "free" in the process.
0:      */
0:     private void growToFree(int i)
0:     {
0:         int newLength = (capacity() * 3) / 2 + 1;
0:         grow(i, newLength);
0:     }
0: 
0:     /*
0:      * Grow the arrays to match newLength capacity.
0:      */
0:     private void grow(int newLength)
0:     {
0:         if (capacity() < newLength)
0:             grow(-1, newLength);
0:     }
0: 
0:     private void grow(int i, int newLength)
0:     {
0:         starts = grow(starts, size, newLength, i);
0:         ends = grow(ends, size, newLength, i);
0:         markedAts = grow(markedAts, size, newLength, i);
0:         delTimes = grow(delTimes, size, newLength, i);
0:     }
0: 
0:     private static ByteBuffer[] grow(ByteBuffer[] a, int size, int newLength, int i)
0:     {
0:         if (i < 0 || i >= size)
0:             return Arrays.copyOf(a, newLength);
0: 
0:         ByteBuffer[] newA = new ByteBuffer[newLength];
0:         System.arraycopy(a, 0, newA, 0, i);
0:         System.arraycopy(a, i, newA, i+1, size - i);
0:         return newA;
0:     }
0: 
0:     private static long[] grow(long[] a, int size, int newLength, int i)
0:     {
0:         if (i < 0 || i >= size)
0:             return Arrays.copyOf(a, newLength);
0: 
0:         long[] newA = new long[newLength];
0:         System.arraycopy(a, 0, newA, 0, i);
0:         System.arraycopy(a, i, newA, i+1, size - i);
0:         return newA;
0:     }
0: 
0:     private static int[] grow(int[] a, int size, int newLength, int i)
0:     {
0:         if (i < 0 || i >= size)
0:             return Arrays.copyOf(a, newLength);
0: 
0:         int[] newA = new int[newLength];
0:         System.arraycopy(a, 0, newA, 0, i);
0:         System.arraycopy(a, i, newA, i+1, size - i);
0:         return newA;
0:     }
0: 
0:     /*
0:      * Move elements so that index i is "free", assuming the arrays have at least one free slot at the end.
0:      */
0:     private void moveElements(int i)
0:     {
0:         if (i >= size)
0:             return;
0: 
0:         System.arraycopy(starts, i, starts, i+1, size - i);
0:         System.arraycopy(ends, i, ends, i+1, size - i);
0:         System.arraycopy(markedAts, i, markedAts, i+1, size - i);
0:         System.arraycopy(delTimes, i, delTimes, i+1, size - i);
0:     }
0: 
0:     private void setInternal(int i, ByteBuffer start, ByteBuffer end, long markedAt, int delTime)
0:     {
0:         starts[i] = start;
0:         ends[i] = end;
0:         markedAts[i] = markedAt;
0:         delTimes[i] = delTime;
0:     }
0: 
0:     public static class Serializer implements IVersionedSerializer<RangeTombstoneList>
0:     {
0:         private Serializer() {}
0: 
0:         public void serialize(RangeTombstoneList tombstones, DataOutput out, int version) throws IOException
0:         {
0:             if (tombstones == null)
0:             {
0:                 out.writeInt(0);
0:                 return;
0:             }
0: 
0:             out.writeInt(tombstones.size);
0:             for (int i = 0; i < tombstones.size; i++)
0:             {
0:                 ByteBufferUtil.writeWithShortLength(tombstones.starts[i], out);
0:                 ByteBufferUtil.writeWithShortLength(tombstones.ends[i], out);
0:                 out.writeInt(tombstones.delTimes[i]);
0:                 out.writeLong(tombstones.markedAts[i]);
0:             }
0:         }
0: 
0:         /*
0:          * RangeTombstoneList depends on the column family comparator, but it is not serialized.
0:          * Thus deserialize(DataInput, int, Comparator<ByteBuffer>) should be used instead of this method.
0:          */
0:         public RangeTombstoneList deserialize(DataInput in, int version) throws IOException
0:         {
0:             throw new UnsupportedOperationException();
0:         }
0: 
0:         public RangeTombstoneList deserialize(DataInput in, int version, Comparator<ByteBuffer> comparator) throws IOException
0:         {
0:             int size = in.readInt();
0:             if (size == 0)
0:                 return null;
0: 
0:             RangeTombstoneList tombstones = new RangeTombstoneList(comparator, size);
0: 
0:             for (int i = 0; i < size; i++)
0:             {
0:                 ByteBuffer start = ByteBufferUtil.readWithShortLength(in);
0:                 ByteBuffer end = ByteBufferUtil.readWithShortLength(in);
0:                 int delTime =  in.readInt();
0:                 long markedAt = in.readLong();
0: 
0:                 /*
0:                  * The previous implementation of this wasn't guaranteeing that range were not overlapping (only
0:                  * that they were sorted by starting bound). So we can't just use setInternal (but we will be
0:                  * able to in 2.0). Not a big deal though, add() is pretty fast, especially given that the
0:                  * start is sorted.
0:                  */
0:                 tombstones.add(start, end, markedAt, delTime);
0:             }
0:             return tombstones;
0:         }
0: 
0:         public long serializedSize(RangeTombstoneList tombstones, TypeSizes typeSizes, int version)
0:         {
0:             if (tombstones == null)
0:                 return typeSizes.sizeof(0);
0: 
0:             long size = typeSizes.sizeof(tombstones.size);
0:             for (int i = 0; i < tombstones.size; i++)
0:             {
0:                 int startSize = tombstones.starts[i].remaining();
0:                 size += typeSizes.sizeof((short)startSize) + startSize;
0:                 int endSize = tombstones.ends[i].remaining();
0:                 size += typeSizes.sizeof((short)endSize) + endSize;
0:                 size += typeSizes.sizeof(tombstones.delTimes[i]);
0:                 size += typeSizes.sizeof(tombstones.markedAts[i]);
0:             }
0:             return size;
0:         }
0: 
0:         public long serializedSize(RangeTombstoneList tombstones, int version)
0:         {
0:             return serializedSize(tombstones, TypeSizes.NATIVE, version);
0:         }
0:     }
0: }
author:Ariel Weisberg
-------------------------------------------------------------------------------
commit:1db386e
/////////////////////////////////////////////////////////////////////////
commit:03f72ac
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
0: import org.apache.cassandra.io.util.DataInputPlus;
/////////////////////////////////////////////////////////////////////////
1:         int dataSize = TypeSizes.sizeof(size);
1:             dataSize += TypeSizes.sizeof(markedAts[i]);
1:             dataSize += TypeSizes.sizeof(delTimes[i]);
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:         public RangeTombstoneList deserialize(DataInputPlus in, int version) throws IOException
/////////////////////////////////////////////////////////////////////////
0:         public long serializedSize(RangeTombstoneList tombstones, int version)
0:             //    return TypeSizes.sizeof(0);
0:             //long size = TypeSizes.sizeof(tombstones.size);
0:             //    size += TypeSizes.sizeof(tombstones.delTimes[i]);
0:             //    size += TypeSizes.sizeof(tombstones.markedAts[i]);
commit:173f255
/////////////////////////////////////////////////////////////////////////
0:      * This method will be faster if the new tombstone sort after all the currently existing ones (this is a common use case),
/////////////////////////////////////////////////////////////////////////
0:         if (c < 0)
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:489a9e8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.AbstractIterator;
author:Carl Yeksigian
-------------------------------------------------------------------------------
commit:922a2c4
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Evaluates a diff between superset (known to be all merged tombstones) and this list for read repair
0:      *
0:      * @return null if there is no difference
0:      */
0:     public RangeTombstoneList diff(RangeTombstoneList superset)
0:     {
0:         if (isEmpty())
0:             return superset;
0: 
0:         assert size <= superset.size;
0: 
0:         RangeTombstoneList diff = null;
0: 
0:         int j = 0; // index to iterate through our own list
0:         for (int i = 0; i < superset.size; i++)
0:         {
0:             boolean sameStart = j < size && starts[j].equals(superset.starts[i]);
0:             // don't care about local deletion time here. for RR it doesn't makes sense
0:             if (!sameStart
0:                 || !ends[j].equals(superset.ends[i])
0:                 || markedAts[j] != superset.markedAts[i])
0:             {
0:                 if (diff == null)
0:                     diff = new RangeTombstoneList(comparator, Math.min(8, superset.size - i));
0:                 diff.add(superset.starts[i], superset.ends[i], superset.markedAts[i], superset.delTimes[i]);
0: 
0:                 if (sameStart)
0:                     j++;
0:             }
0:             else
0:             {
0:                 j++;
0:             }
0:         }
0: 
0:         return diff;
0:     }
0: 
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:d4c1e9c
author:Philo Yang
-------------------------------------------------------------------------------
commit:f0893f5
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:             // we can assume that this list is a subset of the superset list
0:             while (j < size && comparator.compare(starts[j], superset.starts[i]) < 0)
0:                 j++;
0: 
0:             if (j >= size)
0:             {
0:                 // we're at the end of our own list, add the remainder of the superset to the diff
0:                 if (i < superset.size)
0:                 {
0:                     if (diff == null)
0:                         diff = new RangeTombstoneList(comparator, superset.size - i);
0: 
0:                     for(int k = i; k < superset.size; k++)
0:                         diff.add(superset.starts[k], superset.ends[k], superset.markedAts[k], superset.delTimes[k]);
0:                 }
0:                 return diff;
0:             }
0: 
0:             // we don't care about local deletion time here, because it doesn't matter for read repair
0:             if (!starts[j].equals(superset.starts[i])
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:6858dd3
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.composites.CellName;
/////////////////////////////////////////////////////////////////////////
0:     public boolean isDeleted(Cell cell)
0:         int idx = searchInternal(cell.name(), 0);
1:         // No matter what the counter cell's timestamp is, a tombstone always takes precedence. See CASSANDRA-7346.
0:         return idx >= 0 && (cell instanceof CounterCell || markedAts[idx] >= cell.timestamp());
/////////////////////////////////////////////////////////////////////////
0:         public boolean isDeleted(Cell cell)
0:             CellName name = cell.name();
0:             long timestamp = cell.timestamp();
0: 
0: 
0:                 if (cmp < 0)
0:                     return false;
0:                 }
0:                 else if (cmp == 0)
0:                 {
0:                     // No matter what the counter cell's timestamp is, a tombstone always takes precedence. See CASSANDRA-7346.
0:                     if (cell instanceof CounterCell)
0:                         return true;
0: 
0:                         return markedAts[idx] >= timestamp || cell instanceof CounterCell;
0: 
author:Jake Luciani
-------------------------------------------------------------------------------
commit:4f381a2
/////////////////////////////////////////////////////////////////////////
0:             assert !(starts[i] instanceof AbstractNativeCell || ends[i] instanceof AbstractNativeCell); //this should never happen
0: 
commit:a14a01c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.utils.memory.AbstractAllocator;
0: import org.apache.cassandra.utils.memory.HeapPool;
/////////////////////////////////////////////////////////////////////////
1:     public RangeTombstoneList copy(AbstractAllocator allocator)
0:     {
1:         RangeTombstoneList copy =  new RangeTombstoneList(comparator,
0:                                       new Composite[size],
0:                                       new Composite[size],
0:                                       Arrays.copyOf(markedAts, size),
0:                                       Arrays.copyOf(delTimes, size),
1:                                       boundaryHeapSize, size);
0: 
0: 
0:         for (int i = 0; i < size; i++)
0:         {
0:             copy.starts[i] = starts[i].copy(null, allocator);
0:             copy.ends[i] = ends[i].copy(null, allocator);
0:         }
0: 
1:         return copy;
0:     }
0: 
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:a2e7435
/////////////////////////////////////////////////////////////////////////
0: import java.nio.ByteBuffer;
0: import java.security.MessageDigest;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     
0:     /**
0:      * Evaluates a diff between superset (known to be all merged tombstones) and this list for read repair
0:      *
0:      * @return null if there is no difference
0:      */
0:     public RangeTombstoneList diff(RangeTombstoneList superset)
0:     {
0:         if (isEmpty())
0:             return superset;
0: 
0:         assert size <= superset.size;
0: 
0:         RangeTombstoneList diff = null;
0: 
0:         int j = 0; // index to iterate through our own list
0:         for (int i = 0; i < superset.size; i++)
0:         {
0:             boolean sameStart = j < size && starts[j].equals(superset.starts[i]);
0:             // don't care about local deletion time here. for RR it doesn't makes sense
0:             if (!sameStart
0:                 || !ends[j].equals(superset.ends[i])
0:                 || markedAts[j] != superset.markedAts[i])
0:             {
0:                 if (diff == null)
0:                     diff = new RangeTombstoneList(comparator, Math.min(8, superset.size - i));
0:                 diff.add(superset.starts[i], superset.ends[i], superset.markedAts[i], superset.delTimes[i]);
0: 
0:                 if (sameStart)
0:                     j++;
0:             }
0:             else
0:             {
0:                 j++;
0:             }
0:         }
0: 
0:         return diff;
0:     }
0:     
0:     /**
0:      * Calculates digest for triggering read repair on mismatch
0:      */
0:     public void updateDigest(MessageDigest digest)
0:     {
0:         ByteBuffer longBuffer = ByteBuffer.allocate(8);
0:         for (int i = 0; i < size; i++)
0:         {
0:             for (int j = 0; j < starts[i].size(); j++)
0:                 digest.update(starts[i].get(j).duplicate());
0:             for (int j = 0; j < ends[i].size(); j++)
0:                 digest.update(ends[i].get(j).duplicate());
0: 
0:             longBuffer.putLong(0, markedAts[i]);
0:             digest.update(longBuffer.array(), 0, 8);
0:         }
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         
/////////////////////////////////////////////////////////////////////////
0: 
commit:4b54b8a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.cache.IMeasurableMemory;
1: import org.apache.cassandra.utils.ObjectSizes;
/////////////////////////////////////////////////////////////////////////
1: public class RangeTombstoneList implements Iterable<RangeTombstone>, IMeasurableMemory
1:     private static long EMPTY_SIZE = ObjectSizes.measure(new RangeTombstoneList(null, 0));
0: 
/////////////////////////////////////////////////////////////////////////
1:     private long boundaryHeapSize;
0:     private RangeTombstoneList(Comparator<Composite> comparator, Composite[] starts, Composite[] ends, long[] markedAts, int[] delTimes, long boundaryHeapSize, int size)
/////////////////////////////////////////////////////////////////////////
1:         this.boundaryHeapSize = boundaryHeapSize;
0:         this(comparator, new Composite[capacity], new Composite[capacity], new long[capacity], new int[capacity], 0, 0);
/////////////////////////////////////////////////////////////////////////
0:                                       boundaryHeapSize, size);
/////////////////////////////////////////////////////////////////////////
1:         boundaryHeapSize += start.unsharedHeapSize() + end.unsharedHeapSize();
/////////////////////////////////////////////////////////////////////////
1:         dst.boundaryHeapSize = src.boundaryHeapSize;
/////////////////////////////////////////////////////////////////////////
1:         // we set starts[i] to null to indicate the position is now empty, so that we update boundaryHeapSize
1:         // when we set it
1:         starts[i] = null;
1:         if (starts[i] != null)
1:             boundaryHeapSize -= starts[i].unsharedHeapSize() + ends[i].unsharedHeapSize();
1:         boundaryHeapSize += start.unsharedHeapSize() + end.unsharedHeapSize();
0:     }
0: 
0:     @Override
1:     public long unsharedHeapSize()
0:     {
1:         return EMPTY_SIZE
1:                 + boundaryHeapSize
1:                 + ObjectSizes.sizeOfArray(starts)
1:                 + ObjectSizes.sizeOfArray(ends)
1:                 + ObjectSizes.sizeOfArray(markedAts)
1:                 + ObjectSizes.sizeOfArray(delTimes);
commit:3edb62b
/////////////////////////////////////////////////////////////////////////
0:     public boolean hasPurgeableTombstones(int gcBefore)
author:belliottsmith
-------------------------------------------------------------------------------
commit:75508ec
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.util.DataOutputPlus;
/////////////////////////////////////////////////////////////////////////
0:         public void serialize(RangeTombstoneList tombstones, DataOutputPlus out, int version) throws IOException
============================================================================