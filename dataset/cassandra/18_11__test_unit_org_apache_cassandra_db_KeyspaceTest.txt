1:066ef58: /**
1:066ef58:  * Licensed to the Apache Software Foundation (ASF) under one
1:066ef58:  * or more contributor license agreements.  See the NOTICE file
1:066ef58:  * distributed with this work for additional information
1:066ef58:  * regarding copyright ownership.  The ASF licenses this file
1:066ef58:  * to you under the Apache License, Version 2.0 (the
1:066ef58:  * "License"); you may not use this file except in compliance
1:066ef58:  * with the License.  You may obtain a copy of the License at
1:066ef58:  *
1:066ef58:  *     http://www.apache.org/licenses/LICENSE-2.0
1:066ef58:  *
1:066ef58:  * Unless required by applicable law or agreed to in writing, software
1:066ef58:  * distributed under the License is distributed on an "AS IS" BASIS,
1:066ef58:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:066ef58:  * See the License for the specific language governing permissions and
1:066ef58:  * limitations under the License.
1:0ad499e:  */
1:07cdfd0: 
1:066ef58: package org.apache.cassandra.db;
1:07cdfd0: 
1:d08e34a: import java.nio.ByteBuffer;
1:066ef58: import java.util.*;
1:07cdfd0: 
1:a991b64: import org.apache.cassandra.Util;
1:a991b64: import org.apache.cassandra.cql3.CQLTester;
1:a991b64: import org.apache.cassandra.cql3.ColumnIdentifier;
1:a991b64: import org.apache.cassandra.db.rows.Cell;
1:a991b64: import org.apache.cassandra.db.rows.Row;
1:a991b64: import org.apache.cassandra.db.rows.RowIterator;
1:a991b64: import org.apache.cassandra.db.compaction.CompactionManager;
1:a991b64: import org.apache.cassandra.db.filter.*;
1:a991b64: import org.apache.cassandra.db.partitions.PartitionIterator;
1:0368e97: import org.apache.cassandra.io.sstable.format.SSTableReader;
1:a991b64: import org.apache.cassandra.metrics.ClearableHistogram;
1:a991b64: import org.apache.cassandra.utils.ByteBufferUtil;
1:a991b64: import org.apache.cassandra.utils.FBUtilities;
1:066ef58: import org.junit.Test;
1:07cdfd0: 
1:83a43f1: import static org.junit.Assert.*;
1:07cdfd0: 
1:07cdfd0: 
1:a991b64: public class KeyspaceTest extends CQLTester
1:d08e34a: {
1:7d2115b:     @Test
1:8203a6c:     public void testGetRowNoColumns() throws Throwable
1:d2a3827:     {
1:a991b64:         String tableName = createTable("CREATE TABLE %s (a text, b int, c int, PRIMARY KEY (a, b))");
1:07cdfd0: 
1:a991b64:         execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", "0", 0, 0);
1:07cdfd0: 
1:a991b64:         final ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(tableName);
1:a991b64: 
1:a991b64:         for (int round = 0; round < 2; round++)
1:46ea05f:         {
1:a991b64:             // slice with limit 0
1:a991b64:             Util.assertEmpty(Util.cmd(cfs, "0").columns("c").withLimit(0).build());
1:07cdfd0: 
1:a991b64:             // slice with nothing in between the bounds
1:a991b64:             Util.assertEmpty(Util.cmd(cfs, "0").columns("c").fromIncl(1).toIncl(1).build());
1:07cdfd0: 
1:a991b64:             // fetch a non-existent name
1:a991b64:             Util.assertEmpty(Util.cmd(cfs, "0").columns("c").includeRow(1).build());
1:07cdfd0: 
1:a991b64:             if (round == 0)
1:a991b64:                 cfs.forceBlockingFlush();
1:a991b64:         }
1:d2a3827:     }
1:07cdfd0: 
1:0ad499e:     @Test
1:066ef58:     public void testGetRowSingleColumn() throws Throwable
1:0ad499e:     {
1:a991b64:         String tableName = createTable("CREATE TABLE %s (a text, b int, c int, PRIMARY KEY (a, b))");
1:07cdfd0: 
1:a991b64:         for (int i = 0; i < 2; i++)
1:a991b64:             execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", "0", i, i);
1:a991b64: 
1:a991b64:         final ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(tableName);
1:07cdfd0: 
1:a991b64:         for (int round = 0; round < 2; round++)
1:0ad499e:         {
1:a991b64:             // slice with limit 1
1:a991b64:             Row row = Util.getOnlyRow(Util.cmd(cfs, "0").columns("c").withLimit(1).build());
1:a991b64:             assertEquals(ByteBufferUtil.bytes(0), row.getCell(cfs.metadata.getColumnDefinition(new ColumnIdentifier("c", false))).value());
1:a991b64: 
1:a991b64:             // fetch each row by name
1:a991b64:             for (int i = 0; i < 2; i++)
1:0ad499e:             {
1:a991b64:                 row = Util.getOnlyRow(Util.cmd(cfs, "0").columns("c").includeRow(i).build());
1:a991b64:                 assertEquals(ByteBufferUtil.bytes(i), row.getCell(cfs.metadata.getColumnDefinition(new ColumnIdentifier("c", false))).value());
1:0ad499e:             }
1:a991b64: 
1:a991b64:             // fetch each row by slice
1:a991b64:             for (int i = 0; i < 2; i++)
1:a991b64:             {
1:a991b64:                 row = Util.getOnlyRow(Util.cmd(cfs, "0").columns("c").fromIncl(i).toIncl(i).build());
1:a991b64:                 assertEquals(ByteBufferUtil.bytes(i), row.getCell(cfs.metadata.getColumnDefinition(new ColumnIdentifier("c", false))).value());
1:a991b64:             }
1:a991b64: 
1:a991b64:             if (round == 0)
1:a991b64:                 cfs.forceBlockingFlush();
1:a991b64:         }
1:0ad499e:     }
1:07cdfd0: 
1:0ad499e:     @Test
1:a991b64:     public void testGetSliceBloomFilterFalsePositive() throws Throwable
1:0ad499e:     {
1:a991b64:         String tableName = createTable("CREATE TABLE %s (a text, b int, c int, PRIMARY KEY (a, b))");
1:07cdfd0: 
1:a991b64:         execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", "1", 1, 1);
1:2fd3268: 
1:a991b64:         final ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(tableName);
1:2fd3268: 
1:a991b64:         // check empty reads on the partitions before and after the existing one
1:a991b64:         for (String key : new String[]{"0", "2"})
1:a991b64:             Util.assertEmpty(Util.cmd(cfs, key).build());
1:a991b64: 
1:a991b64:         cfs.forceBlockingFlush();
1:a991b64: 
1:a991b64:         for (String key : new String[]{"0", "2"})
1:a991b64:             Util.assertEmpty(Util.cmd(cfs, key).build());
1:a991b64: 
1:ad8cad7:         Collection<SSTableReader> sstables = cfs.getLiveSSTables();
1:a991b64:         assertEquals(1, sstables.size());
1:a991b64:         sstables.iterator().next().forceFilterFailures();
1:a991b64: 
1:a991b64:         for (String key : new String[]{"0", "2"})
1:a991b64:             Util.assertEmpty(Util.cmd(cfs, key).build());
1:0ad499e:     }
1:2fd3268: 
1:a991b64:     private static void assertRowsInSlice(ColumnFamilyStore cfs, String key, int sliceStart, int sliceEnd, int limit, boolean reversed, String columnValuePrefix)
1:0ad499e:     {
1:2f41243:         Clustering startClustering = Clustering.make(ByteBufferUtil.bytes(sliceStart));
1:2f41243:         Clustering endClustering = Clustering.make(ByteBufferUtil.bytes(sliceEnd));
1:a991b64:         Slices slices = Slices.with(cfs.getComparator(), Slice.make(startClustering, endClustering));
1:a991b64:         ClusteringIndexSliceFilter filter = new ClusteringIndexSliceFilter(slices, reversed);
1:4beb54d:         SinglePartitionReadCommand command = singlePartitionSlice(cfs, key, filter, limit);
1:2fd3268: 
1:557bbbc:         try (ReadExecutionController executionController = command.executionController();
1:557bbbc:              PartitionIterator iterator = command.executeInternal(executionController))
1:a991b64:         {
1:a991b64:             try (RowIterator rowIterator = iterator.next())
1:a991b64:             {
1:a991b64:                 if (reversed)
1:a991b64:                 {
1:a991b64:                     for (int i = sliceEnd; i >= sliceStart; i--)
1:a991b64:                     {
1:a991b64:                         Row row = rowIterator.next();
1:a991b64:                         Cell cell = row.getCell(cfs.metadata.getColumnDefinition(new ColumnIdentifier("c", false)));
1:a991b64:                         assertEquals(ByteBufferUtil.bytes(columnValuePrefix + i), cell.value());
1:a991b64:                     }
1:a991b64:                 }
1:a991b64:                 else
1:a991b64:                 {
1:a991b64:                     for (int i = sliceStart; i <= sliceEnd; i++)
1:a991b64:                     {
1:a991b64:                         Row row = rowIterator.next();
1:a991b64:                         Cell cell = row.getCell(cfs.metadata.getColumnDefinition(new ColumnIdentifier("c", false)));
1:a991b64:                         assertEquals(ByteBufferUtil.bytes(columnValuePrefix + i), cell.value());
1:a991b64:                     }
1:a991b64:                 }
1:a991b64:                 assertFalse(rowIterator.hasNext());
1:a991b64:             }
1:a991b64:         }
1:0ad499e:     }
1:2fd3268: 
1:d08e34a:     @Test
1:57f0725:     public void testGetSliceWithCutoff() throws Throwable
1:0ad499e:     {
1:7d2115b:         // tests slicing against data from one row in a memtable and then flushed to an sstable
1:a991b64:         String tableName = createTable("CREATE TABLE %s (a text, b int, c text, PRIMARY KEY (a, b))");
1:a991b64:         String prefix = "omg!thisisthevalue!";
1:2fd3268: 
1:7d2115b:         for (int i = 0; i < 300; i++)
1:a991b64:             execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", "0", i, prefix + i);
1:a991b64: 
1:a991b64:         final ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(tableName);
1:2fd3268: 
1:a991b64:         for (int round = 0; round < 2; round++)
1:0ad499e:         {
1:a991b64:             assertRowsInSlice(cfs, "0", 96, 99, 4, false, prefix);
1:a991b64:             assertRowsInSlice(cfs, "0", 96, 99, 4, true, prefix);
1:2fd3268: 
1:a991b64:             assertRowsInSlice(cfs, "0", 100, 103, 4, false, prefix);
1:a991b64:             assertRowsInSlice(cfs, "0", 100, 103, 4, true, prefix);
1:2fd3268: 
1:a991b64:             assertRowsInSlice(cfs, "0", 0, 99, 100, false, prefix);
1:a991b64:             assertRowsInSlice(cfs, "0", 288, 299, 12, true, prefix);
1:2fd3268: 
1:a991b64:             if (round == 0)
1:a991b64:                 cfs.forceBlockingFlush();
1:a991b64:         }
1:0ad499e:     }
1:2fd3268: 
1:57f0725:     @Test
1:a991b64:     public void testReversedWithFlushing() throws Throwable
1:410134e:     {
1:a991b64:         String tableName = createTable("CREATE TABLE %s (a text, b int, c int, PRIMARY KEY (a, b)) WITH CLUSTERING ORDER BY (b DESC)");
1:a991b64:         final ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(tableName);
1:2fd3268: 
1:d08e34a:         for (int i = 0; i < 10; i++)
1:a991b64:             execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", "0", i, i);
1:2fd3268: 
1:d08e34a:         cfs.forceBlockingFlush();
1:2fd3268: 
1:d08e34a:         for (int i = 10; i < 20; i++)
1:410134e:         {
1:a991b64:             execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", "0", i, i);
1:2fd3268: 
1:a991b64:             PartitionColumns columns = PartitionColumns.of(cfs.metadata.getColumnDefinition(new ColumnIdentifier("c", false)));
1:a991b64:             ClusteringIndexSliceFilter filter = new ClusteringIndexSliceFilter(Slices.ALL, false);
1:4beb54d:             SinglePartitionReadCommand command = singlePartitionSlice(cfs, "0", filter, null);
1:557bbbc:             try (ReadExecutionController executionController = command.executionController();
1:557bbbc:                  PartitionIterator iterator = command.executeInternal(executionController))
1:a991b64:             {
1:a991b64:                 try (RowIterator rowIterator = iterator.next())
1:a991b64:                 {
1:a991b64:                     Row row = rowIterator.next();
1:a991b64:                     Cell cell = row.getCell(cfs.metadata.getColumnDefinition(new ColumnIdentifier("c", false)));
1:a991b64:                     assertEquals(ByteBufferUtil.bytes(i), cell.value());
1:a991b64:                 }
1:a991b64:             }
1:0ad499e:         }
1:4881221:     }
1:2fd3268: 
1:a991b64:     private static void assertRowsInResult(ColumnFamilyStore cfs, SinglePartitionReadCommand command, int ... columnValues)
1:a991b64:     {
1:557bbbc:         try (ReadExecutionController executionController = command.executionController();
1:557bbbc:              PartitionIterator iterator = command.executeInternal(executionController))
1:410134e:         {
1:a991b64:             if (columnValues.length == 0)
1:a991b64:             {
1:a991b64:                 if (iterator.hasNext())
1:a991b64:                     fail("Didn't expect any results, but got rows starting with: " + iterator.next().next().toString(cfs.metadata));
1:a991b64:                 return;
1:a991b64:             }
1:d2a3827: 
1:a991b64:             try (RowIterator rowIterator = iterator.next())
1:a991b64:             {
1:a991b64:                 for (int expected : columnValues)
1:a991b64:                 {
1:a991b64:                     Row row = rowIterator.next();
1:a991b64:                     Cell cell = row.getCell(cfs.metadata.getColumnDefinition(new ColumnIdentifier("c", false)));
1:a991b64:                     assertEquals(
1:a991b64:                             String.format("Expected %s, but got %s", ByteBufferUtil.bytesToHex(ByteBufferUtil.bytes(expected)), ByteBufferUtil.bytesToHex(cell.value())),
1:a991b64:                             ByteBufferUtil.bytes(expected), cell.value());
1:a991b64:                 }
1:a991b64:                 assertFalse(rowIterator.hasNext());
1:a991b64:             }
1:a991b64:         }
1:a991b64:     }
1:d2a3827: 
1:a991b64:     private static ClusteringIndexSliceFilter slices(ColumnFamilyStore cfs, Integer sliceStart, Integer sliceEnd, boolean reversed)
1:a991b64:     {
1:2cc26eb:         ClusteringBound startBound = sliceStart == null
1:2cc26eb:                                    ? ClusteringBound.BOTTOM
1:2cc26eb:                                    : ClusteringBound.create(ClusteringPrefix.Kind.INCL_START_BOUND, new ByteBuffer[]{ByteBufferUtil.bytes(sliceStart)});
1:2cc26eb:         ClusteringBound endBound = sliceEnd == null
1:2cc26eb:                                  ? ClusteringBound.TOP
1:2cc26eb:                                  : ClusteringBound.create(ClusteringPrefix.Kind.INCL_END_BOUND, new ByteBuffer[]{ByteBufferUtil.bytes(sliceEnd)});
1:a991b64:         Slices slices = Slices.with(cfs.getComparator(), Slice.make(startBound, endBound));
1:a991b64:         return new ClusteringIndexSliceFilter(slices, reversed);
1:a991b64:     }
1:a991b64: 
1:4beb54d:     private static SinglePartitionReadCommand singlePartitionSlice(ColumnFamilyStore cfs, String key, ClusteringIndexSliceFilter filter, Integer rowLimit)
1:a991b64:     {
1:a991b64:         DataLimits limit = rowLimit == null
1:a991b64:                          ? DataLimits.NONE
1:a991b64:                          : DataLimits.cqlLimits(rowLimit);
1:4beb54d:         return SinglePartitionReadCommand.create(
1:a991b64:                 cfs.metadata, FBUtilities.nowInSeconds(), ColumnFilter.all(cfs.metadata), RowFilter.NONE, limit, Util.dk(key), filter);
1:410134e:     }
1:d2a3827: 
1:8203a6c:     @Test
1:066ef58:     public void testGetSliceFromBasic() throws Throwable
1:410134e:     {
1:57f0725:         // tests slicing against data from one row in a memtable and then flushed to an sstable
1:a991b64:         String tableName = createTable("CREATE TABLE %s (a text, b int, c int, PRIMARY KEY (a, b))");
1:a991b64:         final ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(tableName);
1:ecaa6cd: 
1:a991b64:         for (int i = 1; i < 10; i++)
1:410134e:         {
1:a991b64:             if (i == 6 || i == 8)
1:a991b64:                 continue;
1:a991b64:             execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", "0", i, i);
1:a991b64:         }
1:0ad499e: 
1:a991b64:         execute("DELETE FROM %s WHERE a = ? AND b = ?", "0", 4);
1:0ad499e: 
1:a991b64:         for (int round = 0; round < 2; round++)
1:a991b64:         {
1:0ad499e: 
1:a991b64:             ClusteringIndexSliceFilter filter = slices(cfs, 5, null, false);
1:4beb54d:             SinglePartitionReadCommand command = singlePartitionSlice(cfs, "0", filter, 2);
1:a991b64:             assertRowsInResult(cfs, command, 5, 7);
1:0ad499e: 
1:a991b64:             command = singlePartitionSlice(cfs, "0", slices(cfs, 4, null, false), 2);
1:a991b64:             assertRowsInResult(cfs, command, 5, 7);
1:0ad499e: 
1:a991b64:             command = singlePartitionSlice(cfs, "0", slices(cfs, null, 5, true), 2);
1:a991b64:             assertRowsInResult(cfs, command, 5, 3);
1:aa76394: 
1:a991b64:             command = singlePartitionSlice(cfs, "0", slices(cfs, null, 6, true), 2);
1:a991b64:             assertRowsInResult(cfs, command, 5, 3);
1:4881221: 
1:a991b64:             command = singlePartitionSlice(cfs, "0", slices(cfs, null, 6, true), 2);
1:a991b64:             assertRowsInResult(cfs, command, 5, 3);
1:4881221: 
1:a991b64:             command = singlePartitionSlice(cfs, "0", slices(cfs, null, null, true), 2);
1:a991b64:             assertRowsInResult(cfs, command, 9, 7);
1:a991b64: 
1:a991b64:             command = singlePartitionSlice(cfs, "0", slices(cfs, 95, null, false), 2);
1:a991b64:             assertRowsInResult(cfs, command);
1:a991b64: 
1:a991b64:             command = singlePartitionSlice(cfs, "0", slices(cfs, null, 0, true), 2);
1:a991b64:             assertRowsInResult(cfs, command);
1:a991b64: 
1:a991b64:             if (round == 0)
1:a991b64:                 cfs.forceBlockingFlush();
1:a991b64:         }
1:410134e:     }
1:410134e: 
6:066ef58:     @Test
1:4881221:     public void testGetSliceWithExpiration() throws Throwable
1:4881221:     {
1:4881221:         // tests slicing against data from one row with expiring column in a memtable and then flushed to an sstable
1:a991b64:         String tableName = createTable("CREATE TABLE %s (a text, b int, c int, PRIMARY KEY (a, b))");
1:a991b64:         final ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(tableName);
1:4881221: 
1:a991b64:         execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", "0", 0, 0);
1:a991b64:         execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?) USING TTL 60", "0", 1, 1);
1:a991b64:         execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", "0", 2, 2);
1:4881221: 
1:a991b64:         for (int round = 0; round < 2; round++)
1:4881221:         {
1:4beb54d:             SinglePartitionReadCommand command = singlePartitionSlice(cfs, "0", slices(cfs, null, null, false), 2);
1:a991b64:             assertRowsInResult(cfs, command, 0, 1);
1:4881221: 
1:a991b64:             command = singlePartitionSlice(cfs, "0", slices(cfs, 1, null, false), 1);
1:a991b64:             assertRowsInResult(cfs, command, 1);
1:4881221: 
1:a991b64:             if (round == 0)
1:a991b64:                 cfs.forceBlockingFlush();
1:a991b64:         }
1:4881221:     }
1:4881221: 
1:4881221:     @Test
1:066ef58:     public void testGetSliceFromAdvanced() throws Throwable
1:4881221:     {
2:066ef58:         // tests slicing against data from one row spread across two sstables
1:a991b64:         String tableName = createTable("CREATE TABLE %s (a text, b int, c int, PRIMARY KEY (a, b))");
1:a991b64:         final ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(tableName);
1:410134e: 
1:a991b64:         for (int i = 1; i < 7; i++)
1:a991b64:             execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", "0", i, i);
1:410134e: 
1:a991b64:         cfs.forceBlockingFlush();
1:410134e: 
1:a991b64:         // overwrite three rows with -1
1:a991b64:         for (int i = 1; i < 4; i++)
1:a991b64:             execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", "0", i, -1);
1:a991b64: 
1:a991b64:         for (int round = 0; round < 2; round++)
1:46ea05f:         {
1:4beb54d:             SinglePartitionReadCommand command = singlePartitionSlice(cfs, "0", slices(cfs, 2, null, false), 3);
1:a991b64:             assertRowsInResult(cfs, command, -1, -1, 4);
1:410134e: 
1:a991b64:             if (round == 0)
1:a991b64:                 cfs.forceBlockingFlush();
1:a991b64:         }
1:410134e:     }
1:410134e: 
1:066ef58:     @Test
1:066ef58:     public void testGetSliceFromLarge() throws Throwable
1:d08e34a:     {
1:a991b64:         // tests slicing against 1000 rows in an sstable
1:a991b64:         String tableName = createTable("CREATE TABLE %s (a text, b int, c int, PRIMARY KEY (a, b))");
1:a991b64:         final ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(tableName);
1:87ea405: 
1:a991b64:         for (int i = 1000; i < 2000; i++)
1:a991b64:             execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", "0", i, i);
1:a991b64: 
1:a991b64:         cfs.forceBlockingFlush();
1:a991b64: 
1:a991b64:         validateSliceLarge(cfs);
1:87ea405: 
1:1dd5f60:         // compact so we have a big row with more than the minimum index count
1:ad8cad7:         if (cfs.getLiveSSTables().size() > 1)
1:a991b64:             CompactionManager.instance.performMaximal(cfs, false);
1:a991b64: 
1:87ea405:         // verify that we do indeed have multiple index entries
1:ad8cad7:         SSTableReader sstable = cfs.getLiveSSTables().iterator().next();
1:a991b64:         RowIndexEntry indexEntry = sstable.getPosition(Util.dk("0"), SSTableReader.Operator.EQ);
1:ef5bbed:         assert indexEntry.columnsIndexCount() > 2;
1:8358669: 
1:a991b64:         validateSliceLarge(cfs);
1:410134e:     }
1:8358669: 
1:066ef58:     @Test
1:a991b64:     public void testLimitSSTables() throws Throwable
1:d08e34a:     {
1:a991b64:         String tableName = createTable("CREATE TABLE %s (a text, b int, c int, PRIMARY KEY (a, b))");
1:a991b64:         final ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(tableName);
1:0ad499e:         cfs.disableAutoCompaction();
1:0ad499e: 
1:a991b64:         for (int j = 0; j < 10; j++)
1:a991b64:         {
1:a991b64:             for (int i = 1000 + (j*100); i < 1000 + ((j+1)*100); i++)
1:a991b64:                 execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?) USING TIMESTAMP ?", "0", i, i, (long)i);
1:a991b64: 
1:a991b64:             cfs.forceBlockingFlush();
1:a991b64:         }
1:a991b64: 
1:a991b64:         ((ClearableHistogram)cfs.metric.sstablesPerReadHistogram.cf).clear();
1:a991b64: 
1:4beb54d:         SinglePartitionReadCommand command = singlePartitionSlice(cfs, "0", slices(cfs, null, 1499, false), 1000);
1:a991b64:         int[] expectedValues = new int[500];
1:a991b64:         for (int i = 0; i < 500; i++)
1:a991b64:             expectedValues[i] = i + 1000;
1:a991b64:         assertRowsInResult(cfs, command, expectedValues);
1:a991b64: 
1:a991b64:         assertEquals(5, cfs.metric.sstablesPerReadHistogram.cf.getSnapshot().getMax(), 0.1);
1:a991b64:         ((ClearableHistogram)cfs.metric.sstablesPerReadHistogram.cf).clear();
1:a991b64: 
1:a991b64:         command = singlePartitionSlice(cfs, "0", slices(cfs, 1500, 2000, false), 1000);
1:a991b64:         for (int i = 0; i < 500; i++)
1:a991b64:             expectedValues[i] = i + 1500;
1:a991b64:         assertRowsInResult(cfs, command, expectedValues);
1:a991b64: 
1:a991b64:         assertEquals(5, cfs.metric.sstablesPerReadHistogram.cf.getSnapshot().getMax(), 0.1);
1:a991b64:         ((ClearableHistogram)cfs.metric.sstablesPerReadHistogram.cf).clear();
1:a991b64: 
1:a991b64:         // reverse
1:a991b64:         command = singlePartitionSlice(cfs, "0", slices(cfs, 1500, 2000, true), 1000);
1:a991b64:         for (int i = 0; i < 500; i++)
1:a991b64:             expectedValues[i] = 1999 - i;
1:a991b64:         assertRowsInResult(cfs, command, expectedValues);
1:a991b64:     }
1:a991b64: 
1:a991b64:     @Test
1:a991b64:     public void testLimitSSTablesComposites() throws Throwable
1:a991b64:     {
1:a991b64:         // creates 10 sstables, composite columns like this:
1:a991b64:         // ---------------------
1:a991b64:         // k   |a0:0|a1:1|..|a9:9
1:a991b64:         // ---------------------
1:a991b64:         // ---------------------
1:a991b64:         // k   |a0:10|a1:11|..|a9:19
1:a991b64:         // ---------------------
1:a991b64:         // ...
1:a991b64:         // ---------------------
1:a991b64:         // k   |a0:90|a1:91|..|a9:99
1:a991b64:         // ---------------------
1:a991b64:         // then we slice out col1 = a5 and col2 > 85 -> which should let us just check 2 sstables and get 2 columns
1:a991b64:         String tableName = createTable("CREATE TABLE %s (a text, b text, c int, d int, PRIMARY KEY (a, b, c))");
1:a991b64:         final ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(tableName);
1:a991b64:         cfs.disableAutoCompaction();
1:a991b64: 
2:0ad499e:         for (int j = 0; j < 10; j++)
1:0ad499e:         {
1:0ad499e:             for (int i = 0; i < 10; i++)
1:a991b64:                 execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", "0", "a" + i, j * 10 + i, 0);
1:a991b64: 
1:0ad499e:             cfs.forceBlockingFlush();
1:0ad499e:         }
1:a991b64: 
1:8896a70:         ((ClearableHistogram)cfs.metric.sstablesPerReadHistogram.cf).clear();
1:a991b64:         assertRows(execute("SELECT * FROM %s WHERE a = ? AND (b, c) >= (?, ?) AND (b) <= (?) LIMIT 1000", "0", "a5", 85, "a5"),
1:a991b64:                 row("0", "a5", 85, 0),
1:a991b64:                 row("0", "a5", 95, 0));
1:8896a70:         assertEquals(2, cfs.metric.sstablesPerReadHistogram.cf.getSnapshot().getMax(), 0.1);
1:0ad499e:     }
1:0ad499e: 
1:a991b64:     private void validateSliceLarge(ColumnFamilyStore cfs)
1:0ad499e:     {
1:a991b64:         ClusteringIndexSliceFilter filter = slices(cfs, 1000, null, false);
1:4beb54d:         SinglePartitionReadCommand command = SinglePartitionReadCommand.create(
1:a991b64:                 cfs.metadata, FBUtilities.nowInSeconds(), ColumnFilter.all(cfs.metadata), RowFilter.NONE, DataLimits.cqlLimits(3), Util.dk("0"), filter);
1:a991b64:         assertRowsInResult(cfs, command, 1000, 1001, 1002);
1:8358669: 
1:a991b64:         filter = slices(cfs, 1195, null, false);
1:4beb54d:         command = SinglePartitionReadCommand.create(
1:a991b64:                 cfs.metadata, FBUtilities.nowInSeconds(), ColumnFilter.all(cfs.metadata), RowFilter.NONE, DataLimits.cqlLimits(3), Util.dk("0"), filter);
1:a991b64:         assertRowsInResult(cfs, command, 1195, 1196, 1197);
1:8358669: 
1:a991b64:         filter = slices(cfs, null, 1996, true);
1:4beb54d:         command = SinglePartitionReadCommand.create(
1:a991b64:                 cfs.metadata, FBUtilities.nowInSeconds(), ColumnFilter.all(cfs.metadata), RowFilter.NONE, DataLimits.cqlLimits(1000), Util.dk("0"), filter);
1:a991b64:         int[] expectedValues = new int[997];
1:a991b64:         for (int i = 0, v = 1996; v >= 1000; i++, v--)
1:a991b64:             expectedValues[i] = v;
1:a991b64:         assertRowsInResult(cfs, command, expectedValues);
4:8358669: 
1:a991b64:         filter = slices(cfs, 1990, null, false);
1:4beb54d:         command = SinglePartitionReadCommand.create(
1:a991b64:                 cfs.metadata, FBUtilities.nowInSeconds(), ColumnFilter.all(cfs.metadata), RowFilter.NONE, DataLimits.cqlLimits(3), Util.dk("0"), filter);
1:a991b64:         assertRowsInResult(cfs, command, 1990, 1991, 1992);
1:8358669: 
1:a991b64:         filter = slices(cfs, null, null, true);
1:4beb54d:         command = SinglePartitionReadCommand.create(
1:a991b64:                 cfs.metadata, FBUtilities.nowInSeconds(), ColumnFilter.all(cfs.metadata), RowFilter.NONE, DataLimits.cqlLimits(3), Util.dk("0"), filter);
1:a991b64:         assertRowsInResult(cfs, command, 1999, 1998, 1997);
1:8358669: 
1:a991b64:         filter = slices(cfs, null, 9000, true);
1:4beb54d:         command = SinglePartitionReadCommand.create(
1:a991b64:                 cfs.metadata, FBUtilities.nowInSeconds(), ColumnFilter.all(cfs.metadata), RowFilter.NONE, DataLimits.cqlLimits(3), Util.dk("0"), filter);
1:a991b64:         assertRowsInResult(cfs, command, 1999, 1998, 1997);
1:8358669: 
1:a991b64:         filter = slices(cfs, 9000, null, false);
1:4beb54d:         command = SinglePartitionReadCommand.create(
1:a991b64:                 cfs.metadata, FBUtilities.nowInSeconds(), ColumnFilter.all(cfs.metadata), RowFilter.NONE, DataLimits.cqlLimits(3), Util.dk("0"), filter);
1:a991b64:         assertRowsInResult(cfs, command);
1:0ad499e:     }
1:410134e: }
============================================================================
author:Branimir Lambov
-------------------------------------------------------------------------------
commit:2cc26eb
/////////////////////////////////////////////////////////////////////////
1:         ClusteringBound startBound = sliceStart == null
1:                                    ? ClusteringBound.BOTTOM
1:                                    : ClusteringBound.create(ClusteringPrefix.Kind.INCL_START_BOUND, new ByteBuffer[]{ByteBufferUtil.bytes(sliceStart)});
1:         ClusteringBound endBound = sliceEnd == null
1:                                  ? ClusteringBound.TOP
1:                                  : ClusteringBound.create(ClusteringPrefix.Kind.INCL_END_BOUND, new ByteBuffer[]{ByteBufferUtil.bytes(sliceEnd)});
author:Robert Stupp
-------------------------------------------------------------------------------
commit:ef5bbed
/////////////////////////////////////////////////////////////////////////
1:         assert indexEntry.columnsIndexCount() > 2;
author:Benedict Elliott Smith
-------------------------------------------------------------------------------
commit:2f41243
/////////////////////////////////////////////////////////////////////////
1:         Clustering startClustering = Clustering.make(ByteBufferUtil.bytes(sliceStart));
1:         Clustering endClustering = Clustering.make(ByteBufferUtil.bytes(sliceEnd));
commit:ad8cad7
/////////////////////////////////////////////////////////////////////////
1:         Collection<SSTableReader> sstables = cfs.getLiveSSTables();
/////////////////////////////////////////////////////////////////////////
1:         if (cfs.getLiveSSTables().size() > 1)
1:         SSTableReader sstable = cfs.getLiveSSTables().iterator().next();
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:b1f2d14
commit:4beb54d
/////////////////////////////////////////////////////////////////////////
1:         SinglePartitionReadCommand command = singlePartitionSlice(cfs, key, filter, limit);
/////////////////////////////////////////////////////////////////////////
1:             SinglePartitionReadCommand command = singlePartitionSlice(cfs, "0", filter, null);
/////////////////////////////////////////////////////////////////////////
1:     private static SinglePartitionReadCommand singlePartitionSlice(ColumnFamilyStore cfs, String key, ClusteringIndexSliceFilter filter, Integer rowLimit)
1:         return SinglePartitionReadCommand.create(
/////////////////////////////////////////////////////////////////////////
1:             SinglePartitionReadCommand command = singlePartitionSlice(cfs, "0", filter, 2);
/////////////////////////////////////////////////////////////////////////
1:             SinglePartitionReadCommand command = singlePartitionSlice(cfs, "0", slices(cfs, null, null, false), 2);
/////////////////////////////////////////////////////////////////////////
1:             SinglePartitionReadCommand command = singlePartitionSlice(cfs, "0", slices(cfs, 2, null, false), 3);
/////////////////////////////////////////////////////////////////////////
1:         SinglePartitionReadCommand command = singlePartitionSlice(cfs, "0", slices(cfs, null, 1499, false), 1000);
/////////////////////////////////////////////////////////////////////////
1:         SinglePartitionReadCommand command = SinglePartitionReadCommand.create(
1:         command = SinglePartitionReadCommand.create(
1:         command = SinglePartitionReadCommand.create(
/////////////////////////////////////////////////////////////////////////
1:         command = SinglePartitionReadCommand.create(
1:         command = SinglePartitionReadCommand.create(
1:         command = SinglePartitionReadCommand.create(
1:         command = SinglePartitionReadCommand.create(
commit:2457599
/////////////////////////////////////////////////////////////////////////
0:         Clustering startClustering = new Clustering(ByteBufferUtil.bytes(sliceStart));
0:         Clustering endClustering = new Clustering(ByteBufferUtil.bytes(sliceEnd));
commit:a991b64
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.Util;
1: import org.apache.cassandra.cql3.CQLTester;
1: import org.apache.cassandra.cql3.ColumnIdentifier;
1: import org.apache.cassandra.db.rows.Cell;
1: import org.apache.cassandra.db.rows.Row;
1: import org.apache.cassandra.db.rows.RowIterator;
1: import org.apache.cassandra.db.compaction.CompactionManager;
1: import org.apache.cassandra.db.filter.*;
1: import org.apache.cassandra.db.partitions.PartitionIterator;
1: import org.apache.cassandra.metrics.ClearableHistogram;
1: import org.apache.cassandra.utils.ByteBufferUtil;
1: import org.apache.cassandra.utils.FBUtilities;
1: public class KeyspaceTest extends CQLTester
1:         String tableName = createTable("CREATE TABLE %s (a text, b int, c int, PRIMARY KEY (a, b))");
1:         execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", "0", 0, 0);
1:         final ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(tableName);
1: 
1:         for (int round = 0; round < 2; round++)
1:             // slice with limit 0
1:             Util.assertEmpty(Util.cmd(cfs, "0").columns("c").withLimit(0).build());
1:             // slice with nothing in between the bounds
1:             Util.assertEmpty(Util.cmd(cfs, "0").columns("c").fromIncl(1).toIncl(1).build());
1:             // fetch a non-existent name
1:             Util.assertEmpty(Util.cmd(cfs, "0").columns("c").includeRow(1).build());
1:             if (round == 0)
1:                 cfs.forceBlockingFlush();
1:         }
1:         String tableName = createTable("CREATE TABLE %s (a text, b int, c int, PRIMARY KEY (a, b))");
1:         for (int i = 0; i < 2; i++)
1:             execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", "0", i, i);
1:         final ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(tableName);
1: 
1:         for (int round = 0; round < 2; round++)
1:             // slice with limit 1
1:             Row row = Util.getOnlyRow(Util.cmd(cfs, "0").columns("c").withLimit(1).build());
1:             assertEquals(ByteBufferUtil.bytes(0), row.getCell(cfs.metadata.getColumnDefinition(new ColumnIdentifier("c", false))).value());
1: 
1:             // fetch each row by name
1:             for (int i = 0; i < 2; i++)
1:                 row = Util.getOnlyRow(Util.cmd(cfs, "0").columns("c").includeRow(i).build());
1:                 assertEquals(ByteBufferUtil.bytes(i), row.getCell(cfs.metadata.getColumnDefinition(new ColumnIdentifier("c", false))).value());
1: 
1:             // fetch each row by slice
1:             for (int i = 0; i < 2; i++)
1:             {
1:                 row = Util.getOnlyRow(Util.cmd(cfs, "0").columns("c").fromIncl(i).toIncl(i).build());
1:                 assertEquals(ByteBufferUtil.bytes(i), row.getCell(cfs.metadata.getColumnDefinition(new ColumnIdentifier("c", false))).value());
1:             }
1: 
1:             if (round == 0)
1:                 cfs.forceBlockingFlush();
1:         }
1:     public void testGetSliceBloomFilterFalsePositive() throws Throwable
1:         String tableName = createTable("CREATE TABLE %s (a text, b int, c int, PRIMARY KEY (a, b))");
1:         execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", "1", 1, 1);
1:         final ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(tableName);
1:         // check empty reads on the partitions before and after the existing one
1:         for (String key : new String[]{"0", "2"})
1:             Util.assertEmpty(Util.cmd(cfs, key).build());
1: 
1:         cfs.forceBlockingFlush();
1: 
1:         for (String key : new String[]{"0", "2"})
1:             Util.assertEmpty(Util.cmd(cfs, key).build());
1: 
0:         Collection<SSTableReader> sstables = cfs.getSSTables();
1:         assertEquals(1, sstables.size());
1:         sstables.iterator().next().forceFilterFailures();
1: 
1:         for (String key : new String[]{"0", "2"})
1:             Util.assertEmpty(Util.cmd(cfs, key).build());
1:     private static void assertRowsInSlice(ColumnFamilyStore cfs, String key, int sliceStart, int sliceEnd, int limit, boolean reversed, String columnValuePrefix)
0:         Clustering startClustering = new SimpleClustering(ByteBufferUtil.bytes(sliceStart));
0:         Clustering endClustering = new SimpleClustering(ByteBufferUtil.bytes(sliceEnd));
1:         Slices slices = Slices.with(cfs.getComparator(), Slice.make(startClustering, endClustering));
1:         ClusteringIndexSliceFilter filter = new ClusteringIndexSliceFilter(slices, reversed);
0:         SinglePartitionSliceCommand command = singlePartitionSlice(cfs, key, filter, limit);
0:         try (ReadOrderGroup orderGroup = command.startOrderGroup(); PartitionIterator iterator = command.executeInternal(orderGroup))
1:         {
1:             try (RowIterator rowIterator = iterator.next())
1:             {
1:                 if (reversed)
1:                 {
1:                     for (int i = sliceEnd; i >= sliceStart; i--)
1:                     {
1:                         Row row = rowIterator.next();
1:                         Cell cell = row.getCell(cfs.metadata.getColumnDefinition(new ColumnIdentifier("c", false)));
1:                         assertEquals(ByteBufferUtil.bytes(columnValuePrefix + i), cell.value());
1:                     }
1:                 }
1:                 else
1:                 {
1:                     for (int i = sliceStart; i <= sliceEnd; i++)
1:                     {
1:                         Row row = rowIterator.next();
1:                         Cell cell = row.getCell(cfs.metadata.getColumnDefinition(new ColumnIdentifier("c", false)));
1:                         assertEquals(ByteBufferUtil.bytes(columnValuePrefix + i), cell.value());
1:                     }
1:                 }
1:                 assertFalse(rowIterator.hasNext());
1:             }
1:         }
1:         String tableName = createTable("CREATE TABLE %s (a text, b int, c text, PRIMARY KEY (a, b))");
1:         String prefix = "omg!thisisthevalue!";
1:             execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", "0", i, prefix + i);
1:         final ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(tableName);
1: 
1:         for (int round = 0; round < 2; round++)
1:             assertRowsInSlice(cfs, "0", 96, 99, 4, false, prefix);
1:             assertRowsInSlice(cfs, "0", 96, 99, 4, true, prefix);
1:             assertRowsInSlice(cfs, "0", 100, 103, 4, false, prefix);
1:             assertRowsInSlice(cfs, "0", 100, 103, 4, true, prefix);
1:             assertRowsInSlice(cfs, "0", 0, 99, 100, false, prefix);
1:             assertRowsInSlice(cfs, "0", 288, 299, 12, true, prefix);
1:             if (round == 0)
1:                 cfs.forceBlockingFlush();
1:         }
1:     public void testReversedWithFlushing() throws Throwable
1:         String tableName = createTable("CREATE TABLE %s (a text, b int, c int, PRIMARY KEY (a, b)) WITH CLUSTERING ORDER BY (b DESC)");
1:         final ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(tableName);
1:             execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", "0", i, i);
1:             execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", "0", i, i);
1:             PartitionColumns columns = PartitionColumns.of(cfs.metadata.getColumnDefinition(new ColumnIdentifier("c", false)));
1:             ClusteringIndexSliceFilter filter = new ClusteringIndexSliceFilter(Slices.ALL, false);
0:             SinglePartitionSliceCommand command = singlePartitionSlice(cfs, "0", filter, null);
0:             try (ReadOrderGroup orderGroup = command.startOrderGroup(); PartitionIterator iterator = command.executeInternal(orderGroup))
1:             {
1:                 try (RowIterator rowIterator = iterator.next())
1:                 {
1:                     Row row = rowIterator.next();
1:                     Cell cell = row.getCell(cfs.metadata.getColumnDefinition(new ColumnIdentifier("c", false)));
1:                     assertEquals(ByteBufferUtil.bytes(i), cell.value());
1:                 }
1:             }
1:     private static void assertRowsInResult(ColumnFamilyStore cfs, SinglePartitionReadCommand command, int ... columnValues)
0:         try (ReadOrderGroup orderGroup = command.startOrderGroup(); PartitionIterator iterator = command.executeInternal(orderGroup))
1:         {
1:             if (columnValues.length == 0)
1:             {
1:                 if (iterator.hasNext())
1:                     fail("Didn't expect any results, but got rows starting with: " + iterator.next().next().toString(cfs.metadata));
1:                 return;
1:             }
1:             try (RowIterator rowIterator = iterator.next())
1:             {
1:                 for (int expected : columnValues)
1:                 {
1:                     Row row = rowIterator.next();
1:                     Cell cell = row.getCell(cfs.metadata.getColumnDefinition(new ColumnIdentifier("c", false)));
1:                     assertEquals(
1:                             String.format("Expected %s, but got %s", ByteBufferUtil.bytesToHex(ByteBufferUtil.bytes(expected)), ByteBufferUtil.bytesToHex(cell.value())),
1:                             ByteBufferUtil.bytes(expected), cell.value());
1:                 }
1:                 assertFalse(rowIterator.hasNext());
1:             }
1:         }
1:     }
1:     private static ClusteringIndexSliceFilter slices(ColumnFamilyStore cfs, Integer sliceStart, Integer sliceEnd, boolean reversed)
1:     {
0:         Slice.Bound startBound = sliceStart == null
0:                                ? Slice.Bound.BOTTOM
0:                                : Slice.Bound.create(ClusteringPrefix.Kind.INCL_START_BOUND, new ByteBuffer[]{ByteBufferUtil.bytes(sliceStart)});
0:         Slice.Bound endBound = sliceEnd == null
0:                              ? Slice.Bound.TOP
0:                              : Slice.Bound.create(ClusteringPrefix.Kind.INCL_END_BOUND, new ByteBuffer[]{ByteBufferUtil.bytes(sliceEnd)});
1:         Slices slices = Slices.with(cfs.getComparator(), Slice.make(startBound, endBound));
1:         return new ClusteringIndexSliceFilter(slices, reversed);
1:     }
1: 
0:     private static SinglePartitionSliceCommand singlePartitionSlice(ColumnFamilyStore cfs, String key, ClusteringIndexSliceFilter filter, Integer rowLimit)
1:     {
1:         DataLimits limit = rowLimit == null
1:                          ? DataLimits.NONE
1:                          : DataLimits.cqlLimits(rowLimit);
0:         return new SinglePartitionSliceCommand(
1:                 cfs.metadata, FBUtilities.nowInSeconds(), ColumnFilter.all(cfs.metadata), RowFilter.NONE, limit, Util.dk(key), filter);
1:         String tableName = createTable("CREATE TABLE %s (a text, b int, c int, PRIMARY KEY (a, b))");
1:         final ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(tableName);
1:         for (int i = 1; i < 10; i++)
1:             if (i == 6 || i == 8)
1:                 continue;
1:             execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", "0", i, i);
1:         }
1:         execute("DELETE FROM %s WHERE a = ? AND b = ?", "0", 4);
1:         for (int round = 0; round < 2; round++)
1:         {
1:             ClusteringIndexSliceFilter filter = slices(cfs, 5, null, false);
0:             SinglePartitionSliceCommand command = singlePartitionSlice(cfs, "0", filter, 2);
1:             assertRowsInResult(cfs, command, 5, 7);
1:             command = singlePartitionSlice(cfs, "0", slices(cfs, 4, null, false), 2);
1:             assertRowsInResult(cfs, command, 5, 7);
1:             command = singlePartitionSlice(cfs, "0", slices(cfs, null, 5, true), 2);
1:             assertRowsInResult(cfs, command, 5, 3);
1:             command = singlePartitionSlice(cfs, "0", slices(cfs, null, 6, true), 2);
1:             assertRowsInResult(cfs, command, 5, 3);
1:             command = singlePartitionSlice(cfs, "0", slices(cfs, null, 6, true), 2);
1:             assertRowsInResult(cfs, command, 5, 3);
1:             command = singlePartitionSlice(cfs, "0", slices(cfs, null, null, true), 2);
1:             assertRowsInResult(cfs, command, 9, 7);
1: 
1:             command = singlePartitionSlice(cfs, "0", slices(cfs, 95, null, false), 2);
1:             assertRowsInResult(cfs, command);
1: 
1:             command = singlePartitionSlice(cfs, "0", slices(cfs, null, 0, true), 2);
1:             assertRowsInResult(cfs, command);
1: 
1:             if (round == 0)
1:                 cfs.forceBlockingFlush();
1:         }
1:         String tableName = createTable("CREATE TABLE %s (a text, b int, c int, PRIMARY KEY (a, b))");
1:         final ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(tableName);
1:         execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", "0", 0, 0);
1:         execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?) USING TTL 60", "0", 1, 1);
1:         execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", "0", 2, 2);
1:         for (int round = 0; round < 2; round++)
0:             SinglePartitionSliceCommand command = singlePartitionSlice(cfs, "0", slices(cfs, null, null, false), 2);
1:             assertRowsInResult(cfs, command, 0, 1);
1:             command = singlePartitionSlice(cfs, "0", slices(cfs, 1, null, false), 1);
1:             assertRowsInResult(cfs, command, 1);
1:             if (round == 0)
1:                 cfs.forceBlockingFlush();
1:         }
1:         String tableName = createTable("CREATE TABLE %s (a text, b int, c int, PRIMARY KEY (a, b))");
1:         final ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(tableName);
1:         for (int i = 1; i < 7; i++)
1:             execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", "0", i, i);
1:         cfs.forceBlockingFlush();
1:         // overwrite three rows with -1
1:         for (int i = 1; i < 4; i++)
1:             execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", "0", i, -1);
1: 
1:         for (int round = 0; round < 2; round++)
0:             SinglePartitionSliceCommand command = singlePartitionSlice(cfs, "0", slices(cfs, 2, null, false), 3);
1:             assertRowsInResult(cfs, command, -1, -1, 4);
1:             if (round == 0)
1:                 cfs.forceBlockingFlush();
1:         }
1:         // tests slicing against 1000 rows in an sstable
1:         String tableName = createTable("CREATE TABLE %s (a text, b int, c int, PRIMARY KEY (a, b))");
1:         final ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(tableName);
1:         for (int i = 1000; i < 2000; i++)
1:             execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?)", "0", i, i);
1: 
1:         cfs.forceBlockingFlush();
1: 
1:         validateSliceLarge(cfs);
0:         if (cfs.getSSTables().size() > 1)
1:             CompactionManager.instance.performMaximal(cfs, false);
1: 
0:         SSTableReader sstable = cfs.getSSTables().iterator().next();
1:         RowIndexEntry indexEntry = sstable.getPosition(Util.dk("0"), SSTableReader.Operator.EQ);
1:         validateSliceLarge(cfs);
1:     public void testLimitSSTables() throws Throwable
1:         String tableName = createTable("CREATE TABLE %s (a text, b int, c int, PRIMARY KEY (a, b))");
1:         final ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(tableName);
1:         for (int j = 0; j < 10; j++)
1:         {
1:             for (int i = 1000 + (j*100); i < 1000 + ((j+1)*100); i++)
1:                 execute("INSERT INTO %s (a, b, c) VALUES (?, ?, ?) USING TIMESTAMP ?", "0", i, i, (long)i);
1: 
1:             cfs.forceBlockingFlush();
1:         }
1: 
1:         ((ClearableHistogram)cfs.metric.sstablesPerReadHistogram.cf).clear();
1: 
0:         SinglePartitionSliceCommand command = singlePartitionSlice(cfs, "0", slices(cfs, null, 1499, false), 1000);
1:         int[] expectedValues = new int[500];
1:         for (int i = 0; i < 500; i++)
1:             expectedValues[i] = i + 1000;
1:         assertRowsInResult(cfs, command, expectedValues);
1: 
1:         assertEquals(5, cfs.metric.sstablesPerReadHistogram.cf.getSnapshot().getMax(), 0.1);
1:         ((ClearableHistogram)cfs.metric.sstablesPerReadHistogram.cf).clear();
1: 
1:         command = singlePartitionSlice(cfs, "0", slices(cfs, 1500, 2000, false), 1000);
1:         for (int i = 0; i < 500; i++)
1:             expectedValues[i] = i + 1500;
1:         assertRowsInResult(cfs, command, expectedValues);
1: 
1:         assertEquals(5, cfs.metric.sstablesPerReadHistogram.cf.getSnapshot().getMax(), 0.1);
1:         ((ClearableHistogram)cfs.metric.sstablesPerReadHistogram.cf).clear();
1: 
1:         // reverse
1:         command = singlePartitionSlice(cfs, "0", slices(cfs, 1500, 2000, true), 1000);
1:         for (int i = 0; i < 500; i++)
1:             expectedValues[i] = 1999 - i;
1:         assertRowsInResult(cfs, command, expectedValues);
1:     }
1: 
1:     @Test
1:     public void testLimitSSTablesComposites() throws Throwable
1:     {
1:         // creates 10 sstables, composite columns like this:
1:         // ---------------------
1:         // k   |a0:0|a1:1|..|a9:9
1:         // ---------------------
1:         // ---------------------
1:         // k   |a0:10|a1:11|..|a9:19
1:         // ---------------------
1:         // ...
1:         // ---------------------
1:         // k   |a0:90|a1:91|..|a9:99
1:         // ---------------------
1:         // then we slice out col1 = a5 and col2 > 85 -> which should let us just check 2 sstables and get 2 columns
1:         String tableName = createTable("CREATE TABLE %s (a text, b text, c int, d int, PRIMARY KEY (a, b, c))");
1:         final ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(tableName);
1:         cfs.disableAutoCompaction();
1: 
1:                 execute("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", "0", "a" + i, j * 10 + i, 0);
1: 
1: 
1:         assertRows(execute("SELECT * FROM %s WHERE a = ? AND (b, c) >= (?, ?) AND (b) <= (?) LIMIT 1000", "0", "a5", 85, "a5"),
1:                 row("0", "a5", 85, 0),
1:                 row("0", "a5", 95, 0));
1:     private void validateSliceLarge(ColumnFamilyStore cfs)
1:         ClusteringIndexSliceFilter filter = slices(cfs, 1000, null, false);
0:         SinglePartitionSliceCommand command = new SinglePartitionSliceCommand(
1:                 cfs.metadata, FBUtilities.nowInSeconds(), ColumnFilter.all(cfs.metadata), RowFilter.NONE, DataLimits.cqlLimits(3), Util.dk("0"), filter);
1:         assertRowsInResult(cfs, command, 1000, 1001, 1002);
1:         filter = slices(cfs, 1195, null, false);
0:         command = new SinglePartitionSliceCommand(
1:                 cfs.metadata, FBUtilities.nowInSeconds(), ColumnFilter.all(cfs.metadata), RowFilter.NONE, DataLimits.cqlLimits(3), Util.dk("0"), filter);
1:         assertRowsInResult(cfs, command, 1195, 1196, 1197);
1:         filter = slices(cfs, null, 1996, true);
0:         command = new SinglePartitionSliceCommand(
1:                 cfs.metadata, FBUtilities.nowInSeconds(), ColumnFilter.all(cfs.metadata), RowFilter.NONE, DataLimits.cqlLimits(1000), Util.dk("0"), filter);
1:         int[] expectedValues = new int[997];
1:         for (int i = 0, v = 1996; v >= 1000; i++, v--)
1:             expectedValues[i] = v;
1:         assertRowsInResult(cfs, command, expectedValues);
1:         filter = slices(cfs, 1990, null, false);
0:         command = new SinglePartitionSliceCommand(
1:                 cfs.metadata, FBUtilities.nowInSeconds(), ColumnFilter.all(cfs.metadata), RowFilter.NONE, DataLimits.cqlLimits(3), Util.dk("0"), filter);
1:         assertRowsInResult(cfs, command, 1990, 1991, 1992);
1:         filter = slices(cfs, null, null, true);
0:         command = new SinglePartitionSliceCommand(
1:                 cfs.metadata, FBUtilities.nowInSeconds(), ColumnFilter.all(cfs.metadata), RowFilter.NONE, DataLimits.cqlLimits(3), Util.dk("0"), filter);
1:         assertRowsInResult(cfs, command, 1999, 1998, 1997);
1:         filter = slices(cfs, null, 9000, true);
0:         command = new SinglePartitionSliceCommand(
1:                 cfs.metadata, FBUtilities.nowInSeconds(), ColumnFilter.all(cfs.metadata), RowFilter.NONE, DataLimits.cqlLimits(3), Util.dk("0"), filter);
1:         assertRowsInResult(cfs, command, 1999, 1998, 1997);
1:         filter = slices(cfs, 9000, null, false);
0:         command = new SinglePartitionSliceCommand(
1:                 cfs.metadata, FBUtilities.nowInSeconds(), ColumnFilter.all(cfs.metadata), RowFilter.NONE, DataLimits.cqlLimits(3), Util.dk("0"), filter);
1:         assertRowsInResult(cfs, command);
commit:e50d6af
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             cf.addColumn(new Cell(cellname((long)i), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0));
/////////////////////////////////////////////////////////////////////////
0:             cf.addColumn(new Cell(cellname((long)i), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0));
/////////////////////////////////////////////////////////////////////////
0:         for (Cell c : cf.getSortedColumns())
/////////////////////////////////////////////////////////////////////////
0:         for (Cell c : cf.getSortedColumns())
/////////////////////////////////////////////////////////////////////////
0:         for (Cell c : cf.getSortedColumns())
/////////////////////////////////////////////////////////////////////////
0:         for (Cell c : cf)
/////////////////////////////////////////////////////////////////////////
0:         Cell[] cells = cf.getSortedColumns().toArray(new Cell[0]);
0:             Cell cell = cells[i - 1000];
0:             assertEquals(ByteBufferUtil.string(cell.name().toByteBuffer()), expectedName);
0:             assertEquals(ByteBufferUtil.string(cell.value()), ("v" + i));
/////////////////////////////////////////////////////////////////////////
0:         Collection<Cell> cells = container == null ? new TreeSet<Cell>() : container.getSortedColumns();
0:         for (Cell cell : cells)
0:             L.add(Util.string(cell.name().toByteBuffer()));
/////////////////////////////////////////////////////////////////////////
0:         String[] la = L.toArray(new String[cells.size()]);
0:                                 ((container == null) ? "" : CellNames.getColumnsString(container.getComparator(), cells)),
/////////////////////////////////////////////////////////////////////////
0:     public static void assertColumn(Cell cell, String value, long timestamp)
0:         assertNotNull(cell);
0:         assertEquals(0, ByteBufferUtil.compareUnsigned(cell.value(), ByteBufferUtil.bytes(value)));
0:         assertEquals(timestamp, cell.timestamp());
commit:362cc05
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.composites.*;
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.cassandra.Util.getBytes;
0: import static org.apache.cassandra.Util.cellname;
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(Util.namesQueryFilter(cfStore, TEST_KEY));
0:                 cf = cfStore.getColumnFamily(QueryFilter.getSliceFilter(TEST_KEY, "Standard3", Composites.EMPTY, Composites.EMPTY, false, 0, System.currentTimeMillis()));
0:                 cf = cfStore.getColumnFamily(Util.namesQueryFilter(cfStore, TEST_KEY, "col99"));
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(Util.namesQueryFilter(cfStore, TEST_KEY, "col1"));
0:                 cf = cfStore.getColumnFamily(Util.namesQueryFilter(cfStore, TEST_KEY, "col3"));
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, cellname("b"), cellname("c"), false, 100, System.currentTimeMillis());
0:         cf = cfStore.getColumnFamily(key, cellname("b"), cellname("b"), false, 100, System.currentTimeMillis());
0:         cf = cfStore.getColumnFamily(key, cellname("b"), cellname("c"), false, 1, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, cellname("col096"), cellname("col099"), false, 4, System.currentTimeMillis());
0:                 cf = cfStore.getColumnFamily(ROW, cellname("col099"), cellname("col096"), true, 4, System.currentTimeMillis());
0:                 cf = cfStore.getColumnFamily(ROW, cellname("col100"), cellname("col103"), false, 4, System.currentTimeMillis());
0:                 cf = cfStore.getColumnFamily(ROW, cellname("col103"), cellname("col100"), true, 4, System.currentTimeMillis());
0:                 cf = cfStore.getColumnFamily(ROW, Composites.EMPTY, cellname("col099"), false, 100, System.currentTimeMillis());
0:                 cf = cfStore.getColumnFamily(ROW, Composites.EMPTY, cellname("col288"), true, 12, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:             cf.addColumn(new Column(cellname((long)i), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0));
/////////////////////////////////////////////////////////////////////////
0:             cf.addColumn(new Column(cellname((long)i), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0));
0:             cf = cfs.getColumnFamily(ROW, Composites.EMPTY, Composites.EMPTY, true, 1, System.currentTimeMillis());
0:             assertEquals(i, cf.getColumnNames().iterator().next().toByteBuffer().getLong());
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(Util.dk("a"), Composites.EMPTY, Composites.EMPTY, false, 1, System.currentTimeMillis());
0:         cf = cfStore.getColumnFamily(Util.dk("z"), Composites.EMPTY, Composites.EMPTY, false, 1, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         rm.delete("Standard1", cellname("col4"), 2L);
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, cellname("col5"), Composites.EMPTY, false, 2, System.currentTimeMillis());
0:                 cf = cfStore.getColumnFamily(ROW, cellname("col4"), Composites.EMPTY, false, 2, System.currentTimeMillis());
0:                 cf = cfStore.getColumnFamily(ROW, cellname("col5"), Composites.EMPTY, true, 2, System.currentTimeMillis());
0:                 cf = cfStore.getColumnFamily(ROW, cellname("col6"), Composites.EMPTY, true, 2, System.currentTimeMillis());
0:                 cf = cfStore.getColumnFamily(ROW, Composites.EMPTY, Composites.EMPTY, true, 2, System.currentTimeMillis());
0:                 cf = cfStore.getColumnFamily(ROW, cellname("col95"), Composites.EMPTY, false, 2, System.currentTimeMillis());
0:                 cf = cfStore.getColumnFamily(ROW, cellname("col0"), Composites.EMPTY, true, 2, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, Composites.EMPTY, Composites.EMPTY, false, 2, System.currentTimeMillis());
0:                 cf = cfStore.getColumnFamily(ROW, cellname("col2"), Composites.EMPTY, false, 1, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, cellname("col2"), Composites.EMPTY, false, 3, System.currentTimeMillis());
0:                 ByteBuffer col = cf.getColumn(cellname("col2")).value();
0:                 col = cf.getColumn(cellname("col3")).value();
0:                 col = cf.getColumn(cellname("col4")).value();
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = cfStore.getColumnFamily(key, Composites.EMPTY, cellname("col1499"), false, 1000, System.currentTimeMillis());
0:             assertEquals(ByteBufferUtil.string(c.name.toByteBuffer()), "col" + (1000 + i++));
0:         cf = cfStore.getColumnFamily(key, cellname("col1500"), cellname("col2000"), false, 1000, System.currentTimeMillis());
0:             assertEquals(ByteBufferUtil.string(c.name.toByteBuffer()), "col"+(1000 + i++));
0:         cf = cfStore.getColumnFamily(key, cellname("col2000"), cellname("col1500"), true, 1000, System.currentTimeMillis());
0:             assertEquals(ByteBufferUtil.string(c.name.toByteBuffer()), "col"+(1000 + i++));
/////////////////////////////////////////////////////////////////////////
0:         CellNameType type = cfs.getComparator();
0:                 CellName colName = type.makeCellName(ByteBufferUtil.bytes("a" + i), ByteBufferUtil.bytes(j*10 + i));
0:         Composite start = type.builder().add(ByteBufferUtil.bytes("a5")).add(ByteBufferUtil.bytes(85)).build();
0:         Composite finish = type.builder().add(ByteBufferUtil.bytes("a5")).build().end();
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, cellname("col1000"), Composites.EMPTY, false, 3, System.currentTimeMillis());
0:         col = cf.getColumn(cellname("col1000")).value();
0:         col = cf.getColumn(cellname("col1001")).value();
0:         col = cf.getColumn(cellname("col1002")).value();
0:         cf = cfStore.getColumnFamily(key, cellname("col1195"), Composites.EMPTY, false, 3, System.currentTimeMillis());
0:         col = cf.getColumn(cellname("col1195")).value();
0:         col = cf.getColumn(cellname("col1196")).value();
0:         col = cf.getColumn(cellname("col1197")).value();
0:         cf = cfStore.getColumnFamily(key, cellname("col1996"), Composites.EMPTY, true, 1000, System.currentTimeMillis());
0:             assertEquals(ByteBufferUtil.string(column.name().toByteBuffer()), expectedName);
0:         cf = cfStore.getColumnFamily(key, cellname("col1990"), Composites.EMPTY, false, 3, System.currentTimeMillis());
0:         col = cf.getColumn(cellname("col1990")).value();
0:         col = cf.getColumn(cellname("col1991")).value();
0:         col = cf.getColumn(cellname("col1992")).value();
0:         cf = cfStore.getColumnFamily(key, Composites.EMPTY, Composites.EMPTY, true, 3, System.currentTimeMillis());
0:         col = cf.getColumn(cellname("col1997")).value();
0:         col = cf.getColumn(cellname("col1998")).value();
0:         col = cf.getColumn(cellname("col1999")).value();
0:         cf = cfStore.getColumnFamily(key, cellname("col9000"), Composites.EMPTY, true, 3, System.currentTimeMillis());
0:         cf = cfStore.getColumnFamily(key, cellname("col9000"), Composites.EMPTY, false, 3, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:             L.add(Util.string(column.name().toByteBuffer()));
/////////////////////////////////////////////////////////////////////////
0:                                 ((container == null) ? "" : CellNames.getColumnsString(container.getComparator(), columns)),
0:         assertColumn(cf.getColumn(cellname(name)), value, timestamp);
commit:3a005df
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(TEST_KEY, "Standard3", new TreeSet<ByteBuffer>()));
0:                 cf = cfStore.getColumnFamily(QueryFilter.getSliceFilter(TEST_KEY, "Standard3", ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 0));
0:                 cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(TEST_KEY, "Standard3", ByteBufferUtil.bytes("col99")));
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(TEST_KEY, "Standard1", ByteBufferUtil.bytes("col1")));
0:                 cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(TEST_KEY, "Standard1", ByteBufferUtil.bytes("col3")));
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes("b"), ByteBufferUtil.bytes("c"), false, 100);
0:         cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes("b"), ByteBufferUtil.bytes("b"), false, 100);
0:         cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes("b"), ByteBufferUtil.bytes("c"), false, 1);
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.bytes("col096"), ByteBufferUtil.bytes("col099"), false, 4);
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.bytes("col099"), ByteBufferUtil.bytes("col096"), true, 4);
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.bytes("col100"), ByteBufferUtil.bytes("col103"), false, 4);
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.bytes("col103"), ByteBufferUtil.bytes("col100"), true, 4);
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.bytes("col099"), false, 100);
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.bytes("col288"), true, 12);
/////////////////////////////////////////////////////////////////////////
0:             cf = cfs.getColumnFamily(ROW, ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, true, 1);
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(Util.dk("a"), ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 1);
0:         cf = cfStore.getColumnFamily(Util.dk("z"), ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 1);
/////////////////////////////////////////////////////////////////////////
0:         rm.delete("Standard1", ByteBufferUtil.bytes("col4"), 2L);
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.bytes("col5"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 2);
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.bytes("col4"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 2);
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.bytes("col5"), ByteBufferUtil.EMPTY_BYTE_BUFFER, true, 2);
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.bytes("col6"), ByteBufferUtil.EMPTY_BYTE_BUFFER, true, 2);
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, true, 2);
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.bytes("col95"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 2);
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.bytes("col0"), ByteBufferUtil.EMPTY_BYTE_BUFFER, true, 2);
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 2);
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.bytes("col2"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 1);
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.bytes("col2"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 3);
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes("col1000"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 3);
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes("col1195"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 3);
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes("col1996"), ByteBufferUtil.EMPTY_BYTE_BUFFER, true, 1000);
0:         Column[] columns = cf.getSortedColumns().toArray(new Column[0]);
0:             Column column = columns[i - 1000];
0:         cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes("col1990"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 3);
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, true, 3);
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes("col9000"), ByteBufferUtil.EMPTY_BYTE_BUFFER, true, 3);
0:         cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes("col9000"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 3);
0:     public static void assertColumns(ColumnFamily container, String... columnNames)
0:         Collection<Column> columns = container == null ? new TreeSet<Column>() : container.getSortedColumns();
0:         for (Column column : columns)
/////////////////////////////////////////////////////////////////////////
0:     public static void assertColumn(Column column, String value, long timestamp)
commit:d1171dd
/////////////////////////////////////////////////////////////////////////
commit:15ae2f6
commit:438acfc
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.SchemaLoader;
/////////////////////////////////////////////////////////////////////////
0: public class TableTest extends SchemaLoader
commit:4e17ac4
/////////////////////////////////////////////////////////////////////////
0:         RowIndexEntry indexEntry = sstable.getPosition(key, SSTableReader.Operator.EQ);
0:         assert indexEntry.columnsIndex().size() > 2;
commit:07cdfd0
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:         ByteBuffer col;
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
commit:2fd3268
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:         ByteBuffer col;
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
commit:1ecabe6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         RandomAccessReader file = sstable.openDataReader(false);
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:557bbbc
/////////////////////////////////////////////////////////////////////////
1:         try (ReadExecutionController executionController = command.executionController();
1:              PartitionIterator iterator = command.executeInternal(executionController))
/////////////////////////////////////////////////////////////////////////
1:             try (ReadExecutionController executionController = command.executionController();
1:                  PartitionIterator iterator = command.executeInternal(executionController))
/////////////////////////////////////////////////////////////////////////
1:         try (ReadExecutionController executionController = command.executionController();
1:              PartitionIterator iterator = command.executeInternal(executionController))
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:5de72e5
/////////////////////////////////////////////////////////////////////////
0:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARDCOMPOSITE2, compositeMaxMin));
author:Marcus Eriksson
-------------------------------------------------------------------------------
commit:910170c
/////////////////////////////////////////////////////////////////////////
0:             CompactionManager.instance.performMaximal(cfStore, false);
author:T Jake Luciani
-------------------------------------------------------------------------------
commit:8896a70
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.metrics.ClearableHistogram;
/////////////////////////////////////////////////////////////////////////
0:         ((ClearableHistogram)cfStore.metric.sstablesPerReadHistogram.cf).clear();
0:         assertEquals(cfStore.metric.sstablesPerReadHistogram.cf.getSnapshot().getMax(), 5, 0.1);
0:         ((ClearableHistogram)cfStore.metric.sstablesPerReadHistogram.cf).clear();
0:         assertEquals(cfStore.metric.sstablesPerReadHistogram.cf.getSnapshot().getMax(), 5, 0.1);
/////////////////////////////////////////////////////////////////////////
0:         ((ClearableHistogram)cfStore.metric.sstablesPerReadHistogram.cf).clear();
0:         assertEquals(cfStore.metric.sstablesPerReadHistogram.cf.getSnapshot().getMax(), 5, 0.1);
/////////////////////////////////////////////////////////////////////////
1:         ((ClearableHistogram)cfs.metric.sstablesPerReadHistogram.cf).clear();
1:         assertEquals(2, cfs.metric.sstablesPerReadHistogram.cf.getSnapshot().getMax(), 0.1);
commit:3787d6c
/////////////////////////////////////////////////////////////////////////
0:                 assertEquals(ByteBufferUtil.string(col), "valx");
0:                 assertEquals(ByteBufferUtil.string(col), "valx");
0:                 assertEquals(ByteBufferUtil.string(col), "val4");
/////////////////////////////////////////////////////////////////////////
0:         assertEquals(ByteBufferUtil.string(col), "v1000");
0:         assertEquals(ByteBufferUtil.string(col), "v1001");
0:         assertEquals(ByteBufferUtil.string(col), "v1002");
0:         assertEquals(ByteBufferUtil.string(col), "v1195");
0:         assertEquals(ByteBufferUtil.string(col), "v1196");
0:         assertEquals(ByteBufferUtil.string(col), "v1197");
/////////////////////////////////////////////////////////////////////////
0:             assertEquals(ByteBufferUtil.string(column.name()), expectedName);
0:             assertEquals(ByteBufferUtil.string(column.value()), ("v" + i));
0:         assertEquals(ByteBufferUtil.string(col), "v1990");
0:         assertEquals(ByteBufferUtil.string(col), "v1991");
0:         assertEquals(ByteBufferUtil.string(col), "v1992");
0:         assertEquals(ByteBufferUtil.string(col), "v1997");
0:         assertEquals(ByteBufferUtil.string(col), "v1998");
0:         assertEquals(ByteBufferUtil.string(col), "v1999");
/////////////////////////////////////////////////////////////////////////
0:                 assertEquals(ByteBufferUtil.string(val), "val1");
/////////////////////////////////////////////////////////////////////////
0:             L.add(ByteBufferUtil.string(column.name()));
author:Jake Luciani
-------------------------------------------------------------------------------
commit:0368e97
/////////////////////////////////////////////////////////////////////////
1: import org.apache.cassandra.io.sstable.format.SSTableReader;
/////////////////////////////////////////////////////////////////////////
author:lyubent
-------------------------------------------------------------------------------
commit:b453f08
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:             rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:             rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe();
0:         rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:         rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:             rm.applyUnsafe();
/////////////////////////////////////////////////////////////////////////
0:                 rm.applyUnsafe();
commit:d2a3827
/////////////////////////////////////////////////////////////////////////
0: import org.junit.BeforeClass;
0: import org.apache.cassandra.config.CFMetaData;
0: import org.apache.cassandra.config.KSMetaData;
0: import org.apache.cassandra.db.marshal.AbstractType;
0: import org.apache.cassandra.db.marshal.BytesType;
0: import org.apache.cassandra.db.marshal.CompositeType;
0: import org.apache.cassandra.db.marshal.IntegerType;
0: import org.apache.cassandra.exceptions.ConfigurationException;
0: import org.apache.cassandra.locator.SimpleStrategy;
/////////////////////////////////////////////////////////////////////////
0: public class KeyspaceTest
0:     private static final String KEYSPACE1 = "Keyspace1";
0:     private static final String CF_STANDARD1 = "Standard1";
0:     private static final String CF_STANDARD2 = "Standard2";
0:     private static final String CF_STANDARDLONG = "StandardLong1";
0:     private static final String CF_STANDARDCOMPOSITE2 = "StandardComposite2";
1: 
0:     private static final String KEYSPACE2 = "Keyspace2";
0:     private static final String CF_STANDARD3 = "Standard3";
1: 
0:     @BeforeClass
0:     public static void defineSchema() throws ConfigurationException
1:     {
0:         SchemaLoader.prepareServer();
0:         AbstractType<?> compositeMaxMin = CompositeType.getInstance(Arrays.asList(new AbstractType<?>[]{BytesType.instance, IntegerType.instance}));
0:         SchemaLoader.createKeyspace(KEYSPACE1,
0:                                     SimpleStrategy.class,
0:                                     KSMetaData.optsWithRF(1),
0:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD1),
0:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD2),
0:                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARDLONG),
0:                                     CFMetaData.denseCFMetaData(KEYSPACE1, CF_STANDARDCOMPOSITE2, compositeMaxMin));
0:         SchemaLoader.createKeyspace(KEYSPACE2,
0:                                     SimpleStrategy.class,
0:                                     KSMetaData.optsWithRF(1),
0:                                     SchemaLoader.standardCFMD(KEYSPACE2, CF_STANDARD3));
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         final Keyspace keyspace = Keyspace.open(KEYSPACE2);
0:         ColumnFamily cf = ArrayBackedSortedColumns.factory.create(KEYSPACE2, "Standard3");
0:         Mutation rm = new Mutation(KEYSPACE2, TEST_KEY.getKey(), cf);
/////////////////////////////////////////////////////////////////////////
0:         final Keyspace keyspace = Keyspace.open(KEYSPACE1);
0:         ColumnFamily cf = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "Standard1");
0:         Mutation rm = new Mutation(KEYSPACE1, TEST_KEY.getKey(), cf);
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey key = TEST_SLICE_KEY;
0:         Keyspace keyspace = Keyspace.open(KEYSPACE1);
0:         ColumnFamily cf = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "Standard1");
0:         Mutation rm = new Mutation(KEYSPACE1, key.getKey(), cf);
/////////////////////////////////////////////////////////////////////////
0:         Keyspace keyspace = Keyspace.open(KEYSPACE1);
0:         ColumnFamily cf = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "Standard2");
0:         Mutation rm = new Mutation(KEYSPACE1, ByteBufferUtil.bytes("row1000"), cf);
/////////////////////////////////////////////////////////////////////////
0:         final Keyspace keyspace = Keyspace.open(KEYSPACE1);
0:         ColumnFamily cf = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "Standard1");
0:         Mutation rm = new Mutation(KEYSPACE1, ROW.getKey(), cf);
/////////////////////////////////////////////////////////////////////////
0:         final Keyspace keyspace = Keyspace.open(KEYSPACE1);
0:             ColumnFamily cf = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "StandardLong1");
0:             Mutation rm = new Mutation(KEYSPACE1, ROW.getKey(), cf);
/////////////////////////////////////////////////////////////////////////
0:             ColumnFamily cf = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "StandardLong1");
0:             Mutation rm = new Mutation(KEYSPACE1, ROW.getKey(), cf);
/////////////////////////////////////////////////////////////////////////
0:         final Keyspace keyspace = Keyspace.open(KEYSPACE1);
0:         ColumnFamily cf = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "Standard1");
0:         Mutation rm = new Mutation(KEYSPACE1, ROW.getKey(), cf);
0:         rm = new Mutation(KEYSPACE1, ROW.getKey());
/////////////////////////////////////////////////////////////////////////
0:         final Keyspace keyspace = Keyspace.open(KEYSPACE1);
0:         ColumnFamily cf = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "Standard1");
0:         Mutation rm = new Mutation(KEYSPACE1, ROW.getKey(), cf);
/////////////////////////////////////////////////////////////////////////
0:         final Keyspace keyspace = Keyspace.open(KEYSPACE1);
0:         ColumnFamily cf = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "Standard1");
0:         Mutation rm = new Mutation(KEYSPACE1, ROW.getKey(), cf);
0:         cf = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "Standard1");
0:         rm = new Mutation(KEYSPACE1, ROW.getKey(), cf);
/////////////////////////////////////////////////////////////////////////
0:         Keyspace keyspace = Keyspace.open(KEYSPACE1);
0:         ColumnFamily cf = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "Standard1");
0:         Mutation rm = new Mutation(KEYSPACE1, key.getKey(), cf);
/////////////////////////////////////////////////////////////////////////
0:         Keyspace keyspace = Keyspace.open(KEYSPACE1);
0:             ColumnFamily cf = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "Standard1");
0:             Mutation rm = new Mutation(KEYSPACE1, key.getKey(), cf);
/////////////////////////////////////////////////////////////////////////
0:         Keyspace keyspace = Keyspace.open(KEYSPACE1);
/////////////////////////////////////////////////////////////////////////
0:                 Mutation rm = new Mutation(KEYSPACE1, key.getKey());
author:Brandon Williams
-------------------------------------------------------------------------------
commit:ae0f634
/////////////////////////////////////////////////////////////////////////
0:         cfStore.metric.sstablesPerReadHistogram.cf.clear();
0:         assertEquals(cfStore.metric.sstablesPerReadHistogram.cf.max(), 5, 0.1);
0:         cfStore.metric.sstablesPerReadHistogram.cf.clear();
0:         assertEquals(cfStore.metric.sstablesPerReadHistogram.cf.max(), 5, 0.1);
/////////////////////////////////////////////////////////////////////////
0:         cfStore.metric.sstablesPerReadHistogram.cf.clear();
0:         assertEquals(cfStore.metric.sstablesPerReadHistogram.cf.max(), 5, 0.1);
/////////////////////////////////////////////////////////////////////////
0:         cfs.metric.sstablesPerReadHistogram.cf.clear();
0:         assertEquals(2, cfs.metric.sstablesPerReadHistogram.cf.max(), 0.1);
commit:5b8ac8c
/////////////////////////////////////////////////////////////////////////
0:         cfStore.metric.sstablesPerReadHistogram.cf.clear();
0:         assertEquals(cfStore.metric.sstablesPerReadHistogram.cf.max(), 5, 0.1);
0:         cfStore.metric.sstablesPerReadHistogram.cf.clear();
0:         assertEquals(cfStore.metric.sstablesPerReadHistogram.cf.max(), 5, 0.1);
/////////////////////////////////////////////////////////////////////////
0:         cfStore.metric.sstablesPerReadHistogram.cf.clear();
0:         assertEquals(cfStore.metric.sstablesPerReadHistogram.cf.max(), 5, 0.1);
/////////////////////////////////////////////////////////////////////////
0:         cfs.metric.sstablesPerReadHistogram.cf.clear();
0:         assertEquals(2, cfs.metric.sstablesPerReadHistogram.cf.max(), 0.1);
commit:d12184d
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace2", TEST_KEY.key, cf);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", TEST_KEY.key, cf);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", key.key, cf);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes("row1000"), cf);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", ROW.key, cf);
/////////////////////////////////////////////////////////////////////////
0:             RowMutation rm = new RowMutation("Keyspace1", ROW.key, cf);
/////////////////////////////////////////////////////////////////////////
0:             RowMutation rm = new RowMutation("Keyspace1", ROW.key, cf);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", ROW.key, cf);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", ROW.key, cf);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", ROW.key, cf);
0:         rm = new RowMutation("Keyspace1", ROW.key, cf);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", key.key, cf);
commit:ecaa6cd
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace2", TEST_KEY.key);
0:         rm.add(cf);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", TEST_KEY.key);
0:         rm.add(cf);
/////////////////////////////////////////////////////////////////////////
0:     	RowMutation rm = new RowMutation("Keyspace1", key.key);
0:         rm.add(cf);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes("row1000"));
0:         rm.add(cf);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", ROW.key);
0:         rm.add(cf);
/////////////////////////////////////////////////////////////////////////
0:             RowMutation rm = new RowMutation("Keyspace1", ROW.key);
0:             rm.add(cf);
/////////////////////////////////////////////////////////////////////////
0:             RowMutation rm = new RowMutation("Keyspace1", ROW.key);
0:             rm.add(cf);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", ROW.key);
/////////////////////////////////////////////////////////////////////////
0:         rm.add(cf);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", ROW.key);
1: 
0:         rm.add(cf);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", ROW.key);
/////////////////////////////////////////////////////////////////////////
0:         rm.add(cf);
0:         rm = new RowMutation("Keyspace1", ROW.key);
0:         rm.add(cf);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", key.key);
0:         rm.add(cf);
author:Pavel Yaskevich
-------------------------------------------------------------------------------
commit:8541cca
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation("Keyspace2", TEST_KEY.getKey(), cf);
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation("Keyspace1", TEST_KEY.getKey(), cf);
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation("Keyspace1", key.getKey(), cf);
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation("Keyspace1", ROW.getKey(), cf);
/////////////////////////////////////////////////////////////////////////
0:             cf.addColumn(new BufferCell(cellname((long)i), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0));
0:             Mutation rm = new Mutation("Keyspace1", ROW.getKey(), cf);
/////////////////////////////////////////////////////////////////////////
0:             cf.addColumn(new BufferCell(cellname((long)i), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0));
0:             Mutation rm = new Mutation("Keyspace1", ROW.getKey(), cf);
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation("Keyspace1", ROW.getKey(), cf);
0:         rm = new Mutation("Keyspace1", ROW.getKey());
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation("Keyspace1", ROW.getKey(), cf);
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation("Keyspace1", ROW.getKey(), cf);
/////////////////////////////////////////////////////////////////////////
0:         rm = new Mutation("Keyspace1", ROW.getKey(), cf);
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation("Keyspace1", key.getKey(), cf);
/////////////////////////////////////////////////////////////////////////
0:             Mutation rm = new Mutation("Keyspace1", key.getKey(), cf);
/////////////////////////////////////////////////////////////////////////
0:             assertEquals(ByteBufferUtil.string(c.name().toByteBuffer()), "col" + (1000 + i++));
/////////////////////////////////////////////////////////////////////////
0:             assertEquals(ByteBufferUtil.string(c.name().toByteBuffer()), "col"+(1000 + i++));
/////////////////////////////////////////////////////////////////////////
0:             assertEquals(ByteBufferUtil.string(c.name().toByteBuffer()), "col"+(1000 + i++));
/////////////////////////////////////////////////////////////////////////
0:                 Mutation rm = new Mutation("Keyspace1", key.getKey());
author:Dave Brosius
-------------------------------------------------------------------------------
commit:9639f95
/////////////////////////////////////////////////////////////////////////
commit:83a43f1
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.*;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public void testReversedWithFlushing()
/////////////////////////////////////////////////////////////////////////
0:     private void validateGetSliceNoMatch(Keyspace keyspace)
/////////////////////////////////////////////////////////////////////////
0:     public void testLimitSSTables() throws CharacterCodingException
/////////////////////////////////////////////////////////////////////////
0:     public void testLimitSSTablesComposites()
commit:f650d3e
/////////////////////////////////////////////////////////////////////////
author:Aleksey Yeschenko
-------------------------------------------------------------------------------
commit:5204575
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = ArrayBackedSortedColumns.factory.create("Keyspace2", "Standard3");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = ArrayBackedSortedColumns.factory.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = ArrayBackedSortedColumns.factory.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = ArrayBackedSortedColumns.factory.create("Keyspace1", "Standard2");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = ArrayBackedSortedColumns.factory.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:             ColumnFamily cf = ArrayBackedSortedColumns.factory.create("Keyspace1", "StandardLong1");
/////////////////////////////////////////////////////////////////////////
0:             ColumnFamily cf = ArrayBackedSortedColumns.factory.create("Keyspace1", "StandardLong1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = ArrayBackedSortedColumns.factory.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = ArrayBackedSortedColumns.factory.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = ArrayBackedSortedColumns.factory.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         cf = ArrayBackedSortedColumns.factory.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = ArrayBackedSortedColumns.factory.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:             ColumnFamily cf = ArrayBackedSortedColumns.factory.create("Keyspace1", "Standard1");
commit:6bbb13b
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation("Keyspace2", TEST_KEY.key, cf);
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation("Keyspace1", TEST_KEY.key, cf);
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation("Keyspace1", key.key, cf);
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation("Keyspace1", ByteBufferUtil.bytes("row1000"), cf);
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation("Keyspace1", ROW.key, cf);
/////////////////////////////////////////////////////////////////////////
0:             Mutation rm = new Mutation("Keyspace1", ROW.key, cf);
/////////////////////////////////////////////////////////////////////////
0:             Mutation rm = new Mutation("Keyspace1", ROW.key, cf);
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation("Keyspace1", ROW.key, cf);
0:         rm = new Mutation("Keyspace1", ROW.key);
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation("Keyspace1", ROW.key, cf);
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation("Keyspace1", ROW.key, cf);
/////////////////////////////////////////////////////////////////////////
0:         rm = new Mutation("Keyspace1", ROW.key, cf);
/////////////////////////////////////////////////////////////////////////
0:         Mutation rm = new Mutation("Keyspace1", key.key, cf);
/////////////////////////////////////////////////////////////////////////
0:             Mutation rm = new Mutation("Keyspace1", key.key, cf);
/////////////////////////////////////////////////////////////////////////
0:                 Mutation rm = new Mutation("Keyspace1", key.key);
commit:bffd9ea
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.lang3.StringUtils;
commit:0e96e58
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.config.DatabaseDescriptor;
/////////////////////////////////////////////////////////////////////////
0: public class KeyspaceTest extends SchemaLoader
/////////////////////////////////////////////////////////////////////////
0:         final Keyspace keyspace = Keyspace.open("Keyspace2");
0:         final ColumnFamilyStore cfStore = keyspace.getColumnFamilyStore("Standard3");
/////////////////////////////////////////////////////////////////////////
0:         reTest(keyspace.getColumnFamilyStore("Standard3"), verify);
0:         final Keyspace keyspace = Keyspace.open("Keyspace1");
0:         final ColumnFamilyStore cfStore = keyspace.getColumnFamilyStore("Standard1");
/////////////////////////////////////////////////////////////////////////
0:         reTest(keyspace.getColumnFamilyStore("Standard1"), verify);
0:     	Keyspace keyspace = Keyspace.open("Keyspace1");
0:         ColumnFamilyStore cfStore = keyspace.getColumnFamilyStore("Standard1");
/////////////////////////////////////////////////////////////////////////
0:         Keyspace keyspace = Keyspace.open("Keyspace1");
0:         validateGetSliceNoMatch(keyspace);
0:         keyspace.getColumnFamilyStore("Standard2").forceBlockingFlush();
0:         validateGetSliceNoMatch(keyspace);
0:         Collection<SSTableReader> ssTables = keyspace.getColumnFamilyStore("Standard2").getSSTables();
0:         validateGetSliceNoMatch(keyspace);
0:         final Keyspace keyspace = Keyspace.open("Keyspace1");
0:         final ColumnFamilyStore cfStore = keyspace.getColumnFamilyStore("Standard1");
/////////////////////////////////////////////////////////////////////////
0:         reTest(keyspace.getColumnFamilyStore("Standard1"), verify);
0:         final Keyspace keyspace = Keyspace.open("Keyspace1");
0:         final ColumnFamilyStore cfs = keyspace.getColumnFamilyStore("StandardLong1");
/////////////////////////////////////////////////////////////////////////
0:     private void validateGetSliceNoMatch(Keyspace keyspace) throws IOException
0:         ColumnFamilyStore cfStore = keyspace.getColumnFamilyStore("Standard2");
/////////////////////////////////////////////////////////////////////////
0:         final Keyspace keyspace = Keyspace.open("Keyspace1");
0:         final ColumnFamilyStore cfStore = keyspace.getColumnFamilyStore("Standard1");
/////////////////////////////////////////////////////////////////////////
0:         reTest(keyspace.getColumnFamilyStore("Standard1"), verify);
0:         final Keyspace keyspace = Keyspace.open("Keyspace1");
0:         final ColumnFamilyStore cfStore = keyspace.getColumnFamilyStore("Standard1");
/////////////////////////////////////////////////////////////////////////
0:         reTest(keyspace.getColumnFamilyStore("Standard1"), verify);
0:         final Keyspace keyspace = Keyspace.open("Keyspace1");
0:         final ColumnFamilyStore cfStore = keyspace.getColumnFamilyStore("Standard1");
/////////////////////////////////////////////////////////////////////////
0:         reTest(keyspace.getColumnFamilyStore("Standard1"), verify);
0:         Keyspace keyspace = Keyspace.open("Keyspace1");
0:         ColumnFamilyStore cfStore = keyspace.getColumnFamilyStore("Standard1");
/////////////////////////////////////////////////////////////////////////
0:         Keyspace keyspace = Keyspace.open("Keyspace1");
0:         ColumnFamilyStore cfStore = keyspace.getColumnFamilyStore("Standard1");
/////////////////////////////////////////////////////////////////////////
0:         Keyspace keyspace = Keyspace.open("Keyspace1");
0:         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore("StandardComposite2");
commit:1f7628c
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(TEST_KEY,
0:                                                                         "Standard3",
0:                                                                         new TreeSet<ByteBuffer>(),
0:                                                                         System.currentTimeMillis()));
0:                 cf = cfStore.getColumnFamily(QueryFilter.getSliceFilter(TEST_KEY,
0:                                                                         "Standard3",
0:                                                                         ByteBufferUtil.EMPTY_BYTE_BUFFER,
0:                                                                         ByteBufferUtil.EMPTY_BYTE_BUFFER,
0:                                                                         false,
0:                                                                         0,
0:                                                                         System.currentTimeMillis()));
0:                 cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(TEST_KEY,
0:                                                                         "Standard3",
0:                                                                         ByteBufferUtil.bytes("col99"),
0:                                                                         System.currentTimeMillis()));
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(TEST_KEY,
0:                                                                         "Standard1",
0:                                                                         ByteBufferUtil.bytes("col1"),
0:                                                                         System.currentTimeMillis()));
0:                 cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(TEST_KEY,
0:                                                                         "Standard1",
0:                                                                         ByteBufferUtil.bytes("col3"),
0:                                                                         System.currentTimeMillis()));
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes("b"), ByteBufferUtil.bytes("c"), false, 100, System.currentTimeMillis());
0:         cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes("b"), ByteBufferUtil.bytes("b"), false, 100, System.currentTimeMillis());
0:         cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes("b"), ByteBufferUtil.bytes("c"), false, 1, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.bytes("col096"), ByteBufferUtil.bytes("col099"), false, 4, System.currentTimeMillis());
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.bytes("col099"), ByteBufferUtil.bytes("col096"), true, 4, System.currentTimeMillis());
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.bytes("col100"), ByteBufferUtil.bytes("col103"), false, 4, System.currentTimeMillis());
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.bytes("col103"), ByteBufferUtil.bytes("col100"), true, 4, System.currentTimeMillis());
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.bytes("col099"), false, 100, System.currentTimeMillis());
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.bytes("col288"), true, 12, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:             cf = cfs.getColumnFamily(ROW, ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, true, 1, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(Util.dk("a"), ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 1, System.currentTimeMillis());
0:         cf = cfStore.getColumnFamily(Util.dk("z"), ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 1, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.bytes("col5"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 2, System.currentTimeMillis());
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.bytes("col4"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 2, System.currentTimeMillis());
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.bytes("col5"), ByteBufferUtil.EMPTY_BYTE_BUFFER, true, 2, System.currentTimeMillis());
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.bytes("col6"), ByteBufferUtil.EMPTY_BYTE_BUFFER, true, 2, System.currentTimeMillis());
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, true, 2, System.currentTimeMillis());
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.bytes("col95"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 2, System.currentTimeMillis());
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.bytes("col0"), ByteBufferUtil.EMPTY_BYTE_BUFFER, true, 2, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 2, System.currentTimeMillis());
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.bytes("col2"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 1, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, ByteBufferUtil.bytes("col2"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 3, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes(""), ByteBufferUtil.bytes("col1499"), false, 1000, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes("col1500"), ByteBufferUtil.bytes("col2000"), false, 1000, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes("col2000"), ByteBufferUtil.bytes("col1500"), true, 1000, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = cfs.getColumnFamily(key, start, finish, false, 1000, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes("col1000"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 3, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes("col1195"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 3, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes("col1996"), ByteBufferUtil.EMPTY_BYTE_BUFFER, true, 1000, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes("col1990"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 3, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, true, 3, System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes("col9000"), ByteBufferUtil.EMPTY_BYTE_BUFFER, true, 3, System.currentTimeMillis());
0:         cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes("col9000"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 3, System.currentTimeMillis());
author:Jonathan Ellis
-------------------------------------------------------------------------------
commit:0ad499e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.cql3.QueryProcessor;
0: import org.apache.cassandra.cql3.Relation;
0: import org.apache.cassandra.db.marshal.BytesType;
0: import org.apache.cassandra.db.marshal.CompositeType;
0: import org.apache.cassandra.db.marshal.IntegerType;
0: import static org.junit.Assert.assertEquals;
/////////////////////////////////////////////////////////////////////////
1:     @Test
0:     public void testLimitSSTables() throws CharacterCodingException, InterruptedException
1:     {
0:         Table table = Table.open("Keyspace1");
0:         ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
0:         cfStore.disableAutoCompaction();
0:         DecoratedKey key = Util.dk("row_maxmin");
1:         for (int j = 0; j < 10; j++)
1:         {
0:             ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
0:             for (int i = 1000 + (j*100); i < 1000 + ((j+1)*100); i++)
1:             {
0:                 cf.addColumn(column("col" + i, ("v" + i), i));
1:             }
0:             RowMutation rm = new RowMutation("Keyspace1", key.key, cf);
0:             rm.apply();
0:             cfStore.forceBlockingFlush();
1:         }
0:         cfStore.metric.sstablesPerReadHistogram.clear();
0:         ColumnFamily cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes(""), ByteBufferUtil.bytes("col1499"), false, 1000);
0:         assertEquals(cfStore.metric.sstablesPerReadHistogram.max(), 5, 0.1);
0:         int i = 0;
0:         for (Column c : cf.getSortedColumns())
1:         {
0:             assertEquals(ByteBufferUtil.string(c.name), "col" + (1000 + i++));
1:         }
0:         assertEquals(i, 500);
0:         cfStore.metric.sstablesPerReadHistogram.clear();
0:         cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes("col1500"), ByteBufferUtil.bytes("col2000"), false, 1000);
0:         assertEquals(cfStore.metric.sstablesPerReadHistogram.max(), 5, 0.1);
1: 
0:         for (Column c : cf.getSortedColumns())
1:         {
0:             assertEquals(ByteBufferUtil.string(c.name), "col"+(1000 + i++));
1:         }
0:         assertEquals(i, 1000);
1: 
0:         // reverse
0:         cfStore.metric.sstablesPerReadHistogram.clear();
0:         cf = cfStore.getColumnFamily(key, ByteBufferUtil.bytes("col2000"), ByteBufferUtil.bytes("col1500"), true, 1000);
0:         assertEquals(cfStore.metric.sstablesPerReadHistogram.max(), 5, 0.1);
0:         i = 500;
0:         for (Column c : cf.getSortedColumns())
1:         {
0:             assertEquals(ByteBufferUtil.string(c.name), "col"+(1000 + i++));
1:         }
0:         assertEquals(i, 1000);
1: 
1:     }
1: 
1:     @Test
0:     public void testLimitSSTablesComposites() throws CharacterCodingException, ExecutionException, InterruptedException
1:     {
0:         /*
0:         creates 10 sstables, composite columns like this:
0:         ---------------------
0:         k   |a0:0|a1:1|..|a9:9
0:         ---------------------
0:         ---------------------
0:         k   |a0:10|a1:11|..|a9:19
0:         ---------------------
0:         ...
0:         ---------------------
0:         k   |a0:90|a1:91|..|a9:99
0:         ---------------------
0:         then we slice out col1 = a5 and col2 > 85 -> which should let us just check 2 sstables and get 2 columns
1:          */
0:         Table table = Table.open("Keyspace1");
1: 
0:         ColumnFamilyStore cfs = table.getColumnFamilyStore("StandardComposite2");
1:         cfs.disableAutoCompaction();
1: 
0:         CompositeType ct = CompositeType.getInstance(BytesType.instance, IntegerType.instance);
0:         DecoratedKey key = Util.dk("k");
1:         for (int j = 0; j < 10; j++)
1:         {
1:             for (int i = 0; i < 10; i++)
1:             {
0:                 RowMutation rm = new RowMutation("Keyspace1", key.key);
0:                 ByteBuffer colName = ct.builder().add(ByteBufferUtil.bytes("a" + i)).add(ByteBufferUtil.bytes(j*10 + i)).build();
0:                 rm.add("StandardComposite2", colName, ByteBufferUtil.EMPTY_BYTE_BUFFER, 0);
0:                 rm.apply();
1:             }
1:             cfs.forceBlockingFlush();
1:         }
0:         ByteBuffer start = ct.builder().add(ByteBufferUtil.bytes("a5")).add(ByteBufferUtil.bytes(85)).build();
0:         ByteBuffer finish = ct.builder().add(ByteBufferUtil.bytes("a5")).buildAsEndOfRange();
0:         cfs.metric.sstablesPerReadHistogram.clear();
0:         ColumnFamily cf = cfs.getColumnFamily(key, start, finish, false, 1000);
0:         int colCount = 0;
0:         for (Column c : cf)
0:             colCount++;
0:         assertEquals(2, colCount);
0:         assertEquals(2, cfs.metric.sstablesPerReadHistogram.max(), 0.1);
1:     }
1: 
commit:aa76394
/////////////////////////////////////////////////////////////////////////
0: import com.google.common.collect.Iterables;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace2", "Standard3");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard2");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:             ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "StandardLong1");
/////////////////////////////////////////////////////////////////////////
0:             ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "StandardLong1");
0:             assertEquals(1, Iterables.size(cf.getColumnNames()));
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = TreeMapBackedSortedColumns.factory.create("Keyspace1", "Standard1");
commit:a9b075d
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace2", TEST_KEY.key, cf);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", TEST_KEY.key, cf);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", key.key, cf);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes("row1000"), cf);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", ROW.key, cf);
/////////////////////////////////////////////////////////////////////////
0:             RowMutation rm = new RowMutation("Keyspace1", ROW.key, cf);
/////////////////////////////////////////////////////////////////////////
0:             RowMutation rm = new RowMutation("Keyspace1", ROW.key, cf);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", ROW.key, cf);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", ROW.key, cf);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", ROW.key, cf);
0:         rm = new RowMutation("Keyspace1", ROW.key, cf);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", key.key, cf);
commit:4881221
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.cassandra.Util.expiringColumn;
/////////////////////////////////////////////////////////////////////////
1:     public void testGetSliceWithExpiration() throws Throwable
1:     {
1:         // tests slicing against data from one row with expiring column in a memtable and then flushed to an sstable
0:         final Table table = Table.open("Keyspace1");
0:         final ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
0:         final DecoratedKey ROW = Util.dk("row5");
1: 
0:         RowMutation rm = new RowMutation("Keyspace1", ROW.key);
0:         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
0:         cf.addColumn(column("col1", "val1", 1L));
0:         cf.addColumn(expiringColumn("col2", "val2", 1L, 1));
0:         cf.addColumn(column("col3", "val3", 1L));
1: 
0:         rm.add(cf);
0:         rm.apply();
0:         cfStore.forceBlockingFlush();
1: 
0:         Runnable verify = new WrappedRunnable()
1:         {
0:             public void runMayThrow() throws Exception
1:             {
0:                 ColumnFamily cf;
1: 
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 2);
0:                 assertColumns(cf, "col1", "col2");
0:                 assertColumns(ColumnFamilyStore.removeDeleted(cf, Integer.MAX_VALUE), "col1");
1: 
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col2"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 1);
0:                 assertColumns(cf, "col2");
0:                 assertColumns(ColumnFamilyStore.removeDeleted(cf, Integer.MAX_VALUE));
1:             }
0:         };
1: 
0:         reTest(table.getColumnFamilyStore("Standard1"), verify);
1:     }
1: 
1:     @Test
commit:9392edf
/////////////////////////////////////////////////////////////////////////
0:                 : String.format("Columns [%s])] is not expected [%s]",
/////////////////////////////////////////////////////////////////////////
commit:58df830
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.marshal.Int32Type;
/////////////////////////////////////////////////////////////////////////
0:         SuperColumn sc = new SuperColumn(ByteBufferUtil.bytes("sc1"), Int32Type.instance);
commit:d389047
/////////////////////////////////////////////////////////////////////////
0: import java.io.File;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.util.RandomAccessReader;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         RandomAccessReader file = RandomAccessReader.open(new File(sstable.getFilename()));
commit:e70e733
/////////////////////////////////////////////////////////////////////////
0:             CompactionManager.instance.performMaximal(cfStore);
commit:00fd00d
commit:410134e
/////////////////////////////////////////////////////////////////////////
0:         assertColumns((IColumnContainer)cf, columnNames);
1:     }
1: 
0:     public static void assertSubColumns(ColumnFamily cf, String scName, String... columnNames)
1:     {
0:         IColumnContainer sc = cf == null ? null : ((IColumnContainer)cf.getColumn(ByteBufferUtil.bytes(scName)));
0:         assertColumns(sc, columnNames);
1:     }
1: 
0:     public static void assertColumns(IColumnContainer container, String... columnNames)
1:     {
0:         Collection<IColumn> columns = container == null
0:                                       ? new TreeSet<IColumn>()
0:                                       : (container instanceof ColumnFamily) ? ((ColumnFamily) container).getSortedColumns()
0:                                       : ((SuperColumn) container).getSubColumns();
/////////////////////////////////////////////////////////////////////////
0:                                 ((container == null) ? "" : container.getComparator().getColumnsString(columns)),
0:     public static void assertColumn(ColumnFamily cf, String name, String value, long timestamp)
1:     {
0:         assertColumn(cf.getColumn(ByteBufferUtil.bytes(name)), value, timestamp);
1:     }
1: 
0:     public static void assertSubColumn(ColumnFamily cf, String scName, String name, String value, long timestamp)
1:     {
0:         SuperColumn sc = (SuperColumn)cf.getColumn(ByteBufferUtil.bytes(scName));
0:         assertColumn(sc.getSubColumn(ByteBufferUtil.bytes(name)), value, timestamp);
1:     }
1: 
0:     public static void assertColumn(IColumn column, String value, long timestamp)
1:     {
0:         assertNotNull(column);
0:         assertEquals(0, ByteBufferUtil.compareUnsigned(column.value(), ByteBufferUtil.bytes(value)));
0:         assertEquals(timestamp, column.timestamp());
1:     }
1: 
1: 
commit:3c4687c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.compaction.CompactionManager;
commit:87ea405
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         // verify that we do indeed have multiple index entries
/////////////////////////////////////////////////////////////////////////
1: 
commit:46ea05f
/////////////////////////////////////////////////////////////////////////
0: import java.nio.charset.CharacterCodingException;
/////////////////////////////////////////////////////////////////////////
0:             try
1:             {
0:                 L.add(ByteBufferUtil.string(column.name()));
0:             }
0:             catch (CharacterCodingException e)
1:             {
0:                 throw new AssertionError(e);
0:             }
commit:fe57cc5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         assert ByteBufferUtil.readWithShortLength(file).equals(key.key);
commit:154eec9
/////////////////////////////////////////////////////////////////////////
0:             cf.addColumn(new Column(ByteBufferUtil.bytes((long)i), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0));
/////////////////////////////////////////////////////////////////////////
0:             cf.addColumn(new Column(ByteBufferUtil.bytes((long)i), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0));
commit:43d330d
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(QueryFilter.getSliceFilter(TEST_KEY, new QueryPath("Standard3"), ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 0));
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.bytes("col099"), false, 100);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.bytes("col288"), true, 12);
/////////////////////////////////////////////////////////////////////////
0:             cf.addColumn(new Column(FBUtilities.toByteBuffer((long)i), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0));
/////////////////////////////////////////////////////////////////////////
0:             cf.addColumn(new Column(FBUtilities.toByteBuffer((long)i), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0));
0:             cf = cfs.getColumnFamily(ROW, new QueryPath("StandardLong1"), ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, true, 1);
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(Util.dk("a"), new QueryPath("Standard2"), ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 1);
0:         cf = cfStore.getColumnFamily(Util.dk("z"), new QueryPath("Standard2"), ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 1);
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col5"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col4"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col5"), ByteBufferUtil.EMPTY_BYTE_BUFFER, true, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col6"), ByteBufferUtil.EMPTY_BYTE_BUFFER, true, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, true, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col95"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col0"), ByteBufferUtil.EMPTY_BYTE_BUFFER, true, 2);
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col2"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 3);
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.bytes("col1000"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 3);
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.bytes("col1195"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 3);
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.bytes("col1996"), ByteBufferUtil.EMPTY_BYTE_BUFFER, true, 1000);
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.bytes("col1990"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 3);
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, true, 3);
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.bytes("col9000"), ByteBufferUtil.EMPTY_BYTE_BUFFER, true, 3);
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.bytes("col9000"), ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 3);
/////////////////////////////////////////////////////////////////////////
0:                 ColumnFamily cf = cfStore.getColumnFamily(ROW, new QueryPath("Super1"), ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 10);
commit:8358669
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.ByteBufferUtil;
1: 
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(TEST_KEY, new QueryPath("Standard3"), ByteBufferUtil.bytes("col99")));
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(TEST_KEY, new QueryPath("Standard1"), ByteBufferUtil.bytes("col1")));
0:                 cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(TEST_KEY, new QueryPath("Standard1"), ByteBufferUtil.bytes("col3")));
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.bytes("b"), ByteBufferUtil.bytes("c"), false, 100);
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.bytes("b"), ByteBufferUtil.bytes("b"), false, 100);
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.bytes("b"), ByteBufferUtil.bytes("c"), false, 1);
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.bytes("c"), ByteBufferUtil.bytes("b"), false, 1);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes("row1000"));
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col096"), ByteBufferUtil.bytes("col099"), false, 4);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col099"), ByteBufferUtil.bytes("col096"), true, 4);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col100"), ByteBufferUtil.bytes("col103"), false, 4);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col103"), ByteBufferUtil.bytes("col100"), true, 4);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), FBUtilities.EMPTY_BYTE_BUFFER, ByteBufferUtil.bytes("col099"), false, 100);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), FBUtilities.EMPTY_BYTE_BUFFER, ByteBufferUtil.bytes("col288"), true, 12);
/////////////////////////////////////////////////////////////////////////
0:         rm.delete(new QueryPath("Standard1", null, ByteBufferUtil.bytes("col4")), 2L);
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col5"), FBUtilities.EMPTY_BYTE_BUFFER, false, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col4"), FBUtilities.EMPTY_BYTE_BUFFER, false, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col5"), FBUtilities.EMPTY_BYTE_BUFFER, true, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col6"), FBUtilities.EMPTY_BYTE_BUFFER, true, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col95"), FBUtilities.EMPTY_BYTE_BUFFER, false, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col0"), FBUtilities.EMPTY_BYTE_BUFFER, true, 2);
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col2"), FBUtilities.EMPTY_BYTE_BUFFER, false, 3);
1:                 
0:                 ByteBuffer col = cf.getColumn(ByteBufferUtil.bytes("col2")).value();
0:                 assertEquals(new String(col.array(),col.position(),col.remaining()), "valx");
1:                 
0:                 col = cf.getColumn(ByteBufferUtil.bytes("col3")).value();
0:                 assertEquals(new String(col.array(),col.position(),col.remaining()), "valx");
1:                 
0:                 col = cf.getColumn(ByteBufferUtil.bytes("col4")).value();
0:                 assertEquals(new String(col.array(),col.position(),col.remaining()), "val4");                              
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.bytes("col1000"), FBUtilities.EMPTY_BYTE_BUFFER, false, 3);
1:         
0:         ByteBuffer col; 
0:         col = cf.getColumn(ByteBufferUtil.bytes("col1000")).value();
0:         assertEquals(new String(col.array(),col.position(),col.remaining()), "v1000");
0:         col = cf.getColumn(ByteBufferUtil.bytes("col1001")).value();
0:         assertEquals(new String(col.array(),col.position(),col.remaining()), "v1001");
0:         col = cf.getColumn(ByteBufferUtil.bytes("col1002")).value();
0:         assertEquals(new String(col.array(),col.position(),col.remaining()), "v1002");
1:         
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.bytes("col1195"), FBUtilities.EMPTY_BYTE_BUFFER, false, 3);
1:         
0:         col = cf.getColumn(ByteBufferUtil.bytes("col1195")).value();
0:         assertEquals(new String(col.array(),col.position(),col.remaining()), "v1195");
0:         col = cf.getColumn(ByteBufferUtil.bytes("col1196")).value();
0:         assertEquals(new String(col.array(),col.position(),col.remaining()), "v1196");
0:         col = cf.getColumn(ByteBufferUtil.bytes("col1197")).value();
0:         assertEquals(new String(col.array(),col.position(),col.remaining()), "v1197");
1:         
1:        
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.bytes("col1996"), FBUtilities.EMPTY_BYTE_BUFFER, true, 1000);
0:             assertEquals(new String(column.name().array(), column.name().position(),column.name().remaining()), expectedName); 
0:             assertEquals(new String(column.value().array(), column.value().position(),column.value().remaining()), ("v" + i));
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.bytes("col1990"), FBUtilities.EMPTY_BYTE_BUFFER, false, 3);
0:         col = cf.getColumn(ByteBufferUtil.bytes("col1990")).value();
0:         assertEquals(new String(col.array(),col.position(),col.remaining()), "v1990");
0:         col = cf.getColumn(ByteBufferUtil.bytes("col1991")).value();
0:         assertEquals(new String(col.array(),col.position(),col.remaining()), "v1991");
0:         col = cf.getColumn(ByteBufferUtil.bytes("col1992")).value();
0:         assertEquals(new String(col.array(),col.position(),col.remaining()), "v1992");
1:         
0:         col = cf.getColumn(ByteBufferUtil.bytes("col1997")).value();
0:         assertEquals(new String(col.array(),col.position(),col.remaining()), "v1997");
0:         col = cf.getColumn(ByteBufferUtil.bytes("col1998")).value();
0:         assertEquals(new String(col.array(),col.position(),col.remaining()), "v1998");
0:         col = cf.getColumn(ByteBufferUtil.bytes("col1999")).value();
0:         assertEquals(new String(col.array(),col.position(),col.remaining()), "v1999");
1:         
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.bytes("col9000"), FBUtilities.EMPTY_BYTE_BUFFER, true, 3);
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.bytes("col9000"),FBUtilities.EMPTY_BYTE_BUFFER, false, 3);
/////////////////////////////////////////////////////////////////////////
0:         SuperColumn sc = new SuperColumn(ByteBufferUtil.bytes("sc1"), LongType.instance);
0:         sc.addColumn(new Column(getBytes(1), ByteBufferUtil.bytes("val1"), 1L));
/////////////////////////////////////////////////////////////////////////
0:                 
0:                 ByteBuffer val = cf.getColumn(ByteBufferUtil.bytes("sc1")).getSubColumn(getBytes(1)).value();
0:                 
0:                 assertEquals(new String(val.array(),val.position(),val.remaining()), "val1");
/////////////////////////////////////////////////////////////////////////
0:             L.add(new String(column.name().array(),column.name().position(),column.name().remaining()));
commit:187761a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             cf.addColumn(new Column(FBUtilities.toByteBuffer((long)i), FBUtilities.EMPTY_BYTE_BUFFER, 0));
/////////////////////////////////////////////////////////////////////////
0:             cf.addColumn(new Column(FBUtilities.toByteBuffer((long)i), FBUtilities.EMPTY_BYTE_BUFFER, 0));
commit:e7a385a
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(TEST_KEY, new QueryPath("Standard3"), new TreeSet<ByteBuffer>()));
0:                 cf = cfStore.getColumnFamily(QueryFilter.getSliceFilter(TEST_KEY, new QueryPath("Standard3"), FBUtilities.EMPTY_BYTE_BUFFER, FBUtilities.EMPTY_BYTE_BUFFER, false, 0));
0:                 cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(TEST_KEY, new QueryPath("Standard3"), ByteBuffer.wrap("col99".getBytes())));
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(TEST_KEY, new QueryPath("Standard1"), ByteBuffer.wrap("col1".getBytes())));
0:                 cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(TEST_KEY, new QueryPath("Standard1"), ByteBuffer.wrap("col3".getBytes())));
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBuffer.wrap("b".getBytes()), ByteBuffer.wrap("c".getBytes()), false, 100);
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBuffer.wrap("b".getBytes()), ByteBuffer.wrap("b".getBytes()), false, 100);
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBuffer.wrap("b".getBytes()), ByteBuffer.wrap("c".getBytes()), false, 1);
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBuffer.wrap("c".getBytes()), ByteBuffer.wrap("b".getBytes()), false, 1);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", ByteBuffer.wrap("row1000".getBytes()));
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBuffer.wrap("col096".getBytes()), ByteBuffer.wrap("col099".getBytes()), false, 4);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBuffer.wrap("col099".getBytes()), ByteBuffer.wrap("col096".getBytes()), true, 4);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBuffer.wrap("col100".getBytes()), ByteBuffer.wrap("col103".getBytes()), false, 4);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBuffer.wrap("col103".getBytes()), ByteBuffer.wrap("col100".getBytes()), true, 4);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), FBUtilities.EMPTY_BYTE_BUFFER, ByteBuffer.wrap("col099".getBytes()), false, 100);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), FBUtilities.EMPTY_BYTE_BUFFER, ByteBuffer.wrap("col288".getBytes()), true, 12);
/////////////////////////////////////////////////////////////////////////
0:             cf.addColumn(new Column(FBUtilities.toByteArray((long)i), FBUtilities.EMPTY_BYTE_BUFFER, 0));
/////////////////////////////////////////////////////////////////////////
0:             cf.addColumn(new Column(FBUtilities.toByteArray((long)i), FBUtilities.EMPTY_BYTE_BUFFER, 0));
0:             cf = cfs.getColumnFamily(ROW, new QueryPath("StandardLong1"), FBUtilities.EMPTY_BYTE_BUFFER, FBUtilities.EMPTY_BYTE_BUFFER, true, 1);
0:             assertEquals(i, cf.getColumnNames().iterator().next().getLong());
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(Util.dk("a"), new QueryPath("Standard2"), FBUtilities.EMPTY_BYTE_BUFFER, FBUtilities.EMPTY_BYTE_BUFFER, false, 1);
0:         cf = cfStore.getColumnFamily(Util.dk("z"), new QueryPath("Standard2"), FBUtilities.EMPTY_BYTE_BUFFER, FBUtilities.EMPTY_BYTE_BUFFER, false, 1);
/////////////////////////////////////////////////////////////////////////
0:         rm.delete(new QueryPath("Standard1", null, ByteBuffer.wrap("col4".getBytes())), 2L);
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBuffer.wrap("col5".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER, false, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBuffer.wrap("col4".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER, false, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBuffer.wrap("col5".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER, true, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBuffer.wrap("col6".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER, true, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), FBUtilities.EMPTY_BYTE_BUFFER, FBUtilities.EMPTY_BYTE_BUFFER, true, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBuffer.wrap("col95".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER, false, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBuffer.wrap("col0".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER, true, 2);
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBuffer.wrap("col2".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER, false, 3);
0:                 assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col2".getBytes())).value().array()), "valx");
0:                 assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col3".getBytes())).value().array()), "valx");
0:                 assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col4".getBytes())).value().array()), "val4");
/////////////////////////////////////////////////////////////////////////
0:         assert FBUtilities.readShortByteArray(file).equals(key.key);
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBuffer.wrap("col1000".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER, false, 3);
0:         assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col1000".getBytes())).value().array()), "v1000");
0:         assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col1001".getBytes())).value().array()), "v1001");
0:         assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col1002".getBytes())).value().array()), "v1002");
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBuffer.wrap("col1195".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER, false, 3);
0:         assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col1195".getBytes())).value().array()), "v1195");
0:         assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col1196".getBytes())).value().array()), "v1196");
0:         assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col1197".getBytes())).value().array()), "v1197");
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBuffer.wrap("col1996".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER, true, 1000);
0:             assert Arrays.equals(column.name().array(), expectedName.getBytes()) : cfStore.getComparator().getString(column.name()) + " is not " + expectedName;
0:             assert Arrays.equals(column.value().array(), ("v" + i).getBytes());
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBuffer.wrap("col1990".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER, false, 3);
0:         assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col1990".getBytes())).value().array()), "v1990");
0:         assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col1991".getBytes())).value().array()), "v1991");
0:         assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col1992".getBytes())).value().array()), "v1992");
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), FBUtilities.EMPTY_BYTE_BUFFER, FBUtilities.EMPTY_BYTE_BUFFER, true, 3);
0:         assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col1999".getBytes())).value().array()), "v1999");
0:         assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col1998".getBytes())).value().array()), "v1998");
0:         assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col1997".getBytes())).value().array()), "v1997");
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBuffer.wrap("col9000".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER, true, 3);
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBuffer.wrap("col9000".getBytes()),FBUtilities.EMPTY_BYTE_BUFFER, false, 3);
/////////////////////////////////////////////////////////////////////////
0:         SuperColumn sc = new SuperColumn(ByteBuffer.wrap("sc1".getBytes()), LongType.instance);
0:         sc.addColumn(new Column(getBytes(1), ByteBuffer.wrap("val1".getBytes()), 1L));
/////////////////////////////////////////////////////////////////////////
0:                 ColumnFamily cf = cfStore.getColumnFamily(ROW, new QueryPath("Super1"), FBUtilities.EMPTY_BYTE_BUFFER, FBUtilities.EMPTY_BYTE_BUFFER, false, 10);
0:                 assertEquals(new String(cf.getColumn(ByteBuffer.wrap("sc1".getBytes())).getSubColumn(getBytes(1)).value().array()), "val1");
/////////////////////////////////////////////////////////////////////////
0:             L.add(new String(column.name().array()));
commit:9d32382
/////////////////////////////////////////////////////////////////////////
0:         cf.addColumn(column("col1","val1", 1L));
/////////////////////////////////////////////////////////////////////////
0:         cf.addColumn(column("col1","val1", 1L));
0:         cf.addColumn(column("col2","val2", 1L));
0:         cf.addColumn(column("col3","val3", 1L));
/////////////////////////////////////////////////////////////////////////
0:         cf.addColumn(column("a", "val1", 1L));
0:         cf.addColumn(column("b", "val2", 1L));
0:         cf.addColumn(column("c", "val3", 1L));
/////////////////////////////////////////////////////////////////////////
0:         cf.addColumn(column("col1", "val1", 1));
/////////////////////////////////////////////////////////////////////////
0:             cf.addColumn(column("col" + fmt.format(i), "omg!thisisthevalue!"+i, 1L));
/////////////////////////////////////////////////////////////////////////
0:             cf.addColumn(new Column(FBUtilities.toByteArray((long)i), ArrayUtils.EMPTY_BYTE_ARRAY, 0));
/////////////////////////////////////////////////////////////////////////
0:             cf.addColumn(new Column(FBUtilities.toByteArray((long)i), ArrayUtils.EMPTY_BYTE_ARRAY, 0));
/////////////////////////////////////////////////////////////////////////
0:         cf.addColumn(column("col1", "val1", 1L));
0:         cf.addColumn(column("col3", "val3", 1L));
0:         cf.addColumn(column("col4", "val4", 1L));
0:         cf.addColumn(column("col5", "val5", 1L));
0:         cf.addColumn(column("col7", "val7", 1L));
0:         cf.addColumn(column("col9", "val9", 1L));
0:         rm.delete(new QueryPath("Standard1", null, "col4".getBytes()), 2L);
/////////////////////////////////////////////////////////////////////////
0:         cf.addColumn(column("col1", "val1", 1L));
0:         cf.addColumn(column("col2", "val2", 1L));
0:         cf.addColumn(column("col3", "val3", 1L));
0:         cf.addColumn(column("col4", "val4", 1L));
0:         cf.addColumn(column("col5", "val5", 1L));
0:         cf.addColumn(column("col6", "val6", 1L));
0:         cf.addColumn(column("col1", "valx", 2L));
0:         cf.addColumn(column("col2", "valx", 2L));
0:         cf.addColumn(column("col3", "valx", 2L));
/////////////////////////////////////////////////////////////////////////
0:             cf.addColumn(column("col" + i, ("v" + i), 1L));
/////////////////////////////////////////////////////////////////////////
0:         SuperColumn sc = new SuperColumn("sc1".getBytes(), LongType.instance);
0:         sc.addColumn(new Column(getBytes(1), "val1".getBytes(), 1L));
commit:e34283c
/////////////////////////////////////////////////////////////////////////
0:         SSTableReader.readRowSize(file, sstable.descriptor);
commit:72770ac
/////////////////////////////////////////////////////////////////////////
0:             CompactionManager.instance.performMajor(cfStore);
commit:d08e34a
/////////////////////////////////////////////////////////////////////////
1: import java.nio.ByteBuffer;
0: import java.util.concurrent.ExecutionException;
/////////////////////////////////////////////////////////////////////////
1:     @Test
0:     public void testReversedWithFlushing() throws IOException, ExecutionException, InterruptedException
1:     {
0:         final Table table = Table.open("Keyspace1");
0:         final ColumnFamilyStore cfs = table.getColumnFamilyStore("StandardLong1");
0:         final DecoratedKey ROW = Util.dk("row4");
0: 
1:         for (int i = 0; i < 10; i++)
1:         {
0:             RowMutation rm = new RowMutation("Keyspace1", ROW.key);
0:             ColumnFamily cf = ColumnFamily.create("Keyspace1", "StandardLong1");
0:             cf.addColumn(new Column(FBUtilities.toByteArray((long)i), ArrayUtils.EMPTY_BYTE_ARRAY, new TimestampClock(0)));
0:             rm.add(cf);
0:             rm.apply();
0:         }
0: 
1:         cfs.forceBlockingFlush();
0: 
1:         for (int i = 10; i < 20; i++)
1:         {
0:             RowMutation rm = new RowMutation("Keyspace1", ROW.key);
0:             ColumnFamily cf = ColumnFamily.create("Keyspace1", "StandardLong1");
0:             cf.addColumn(new Column(FBUtilities.toByteArray((long)i), ArrayUtils.EMPTY_BYTE_ARRAY, new TimestampClock(0)));
0:             rm.add(cf);
0:             rm.apply();
0: 
0:             cf = cfs.getColumnFamily(ROW, new QueryPath("StandardLong1"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, true, 1);
0:             assertEquals(1, cf.getColumnNames().size());
0:             assertEquals(i, ByteBuffer.wrap(cf.getColumnNames().iterator().next()).getLong());
0:         }
0:     }
0: 
commit:b2a8d89
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(QueryFilter.getSliceFilter(TEST_KEY, new QueryPath("Standard3"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, false, 0));
/////////////////////////////////////////////////////////////////////////
0:                 : String.format("Columns [%s(as string: %s)])] is not expected [%s]",
0:                                 StringUtils.join(columnNames1, ","));
commit:4fb3d18
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         List<String> names = new ArrayList<String>(columnNames.length);
0:         names.addAll(Arrays.asList(columnNames));
0:         String[] columnNames1 = names.toArray(new String[0]);
/////////////////////////////////////////////////////////////////////////
0:         assert Arrays.equals(la, columnNames1)
0:                                 StringUtils.join(columnNames1, ","),
0:                                 SliceFromReadCommand.getBitmaskDescription(null));
0: 
0: 
commit:aadfa6a
/////////////////////////////////////////////////////////////////////////
0:         long position = sstable.getPosition(key, SSTableReader.Operator.EQ);
commit:9c06e53
/////////////////////////////////////////////////////////////////////////
0:         SSTableReader.readRowSize(file, sstable.getDescriptor());
commit:f0a3969
/////////////////////////////////////////////////////////////////////////
0:         long position = sstable.getPosition(key);
0:         file.seek(position);
commit:242b717
/////////////////////////////////////////////////////////////////////////
0:         SuperColumn sc = new SuperColumn("sc1".getBytes(), LongType.instance, ClockType.Timestamp);
commit:cba59a8
/////////////////////////////////////////////////////////////////////////
0:         cf.addColumn(column("col1","val1", new TimestampClock(1L)));
/////////////////////////////////////////////////////////////////////////
0:         cf.addColumn(column("col1","val1", new TimestampClock(1L)));
0:         cf.addColumn(column("col2","val2", new TimestampClock(1L)));
0:         cf.addColumn(column("col3","val3", new TimestampClock(1L)));
/////////////////////////////////////////////////////////////////////////
0:         cf.addColumn(column("a", "val1", new TimestampClock(1L)));
0:         cf.addColumn(column("b", "val2", new TimestampClock(1L)));
0:         cf.addColumn(column("c", "val3", new TimestampClock(1L)));
/////////////////////////////////////////////////////////////////////////
0:         cf.addColumn(column("col1", "val1", new TimestampClock(1)));
/////////////////////////////////////////////////////////////////////////
0:             cf.addColumn(column("col" + fmt.format(i), "omg!thisisthevalue!"+i, new TimestampClock(1L)));
/////////////////////////////////////////////////////////////////////////
0:             cf.addColumn(column("col" + fmt.format(i), "omg!thisisthevalue!"+i, new TimestampClock(1L)));
/////////////////////////////////////////////////////////////////////////
0:         cf.addColumn(column("col1", "val1", new TimestampClock(1L)));
0:         cf.addColumn(column("col3", "val3", new TimestampClock(1L)));
0:         cf.addColumn(column("col4", "val4", new TimestampClock(1L)));
0:         cf.addColumn(column("col5", "val5", new TimestampClock(1L)));
0:         cf.addColumn(column("col7", "val7", new TimestampClock(1L)));
0:         cf.addColumn(column("col9", "val9", new TimestampClock(1L)));
0:         rm.delete(new QueryPath("Standard1", null, "col4".getBytes()), new TimestampClock(2L));
/////////////////////////////////////////////////////////////////////////
0:         cf.addColumn(column("col1", "val1", new TimestampClock(1L)));
0:         cf.addColumn(column("col2", "val2", new TimestampClock(1L)));
0:         cf.addColumn(column("col3", "val3", new TimestampClock(1L)));
0:         cf.addColumn(column("col4", "val4", new TimestampClock(1L)));
0:         cf.addColumn(column("col5", "val5", new TimestampClock(1L)));
0:         cf.addColumn(column("col6", "val6", new TimestampClock(1L)));
0:         cf.addColumn(column("col1", "valx", new TimestampClock(2L)));
0:         cf.addColumn(column("col2", "valx", new TimestampClock(2L)));
0:         cf.addColumn(column("col3", "valx", new TimestampClock(2L)));
/////////////////////////////////////////////////////////////////////////
0:             cf.addColumn(column("col" + i, ("v" + i), new TimestampClock(1L)));
/////////////////////////////////////////////////////////////////////////
0:         SuperColumn sc = new SuperColumn("sc1".getBytes(), new LongType(), ClockType.Timestamp);
0:         sc.addColumn(new Column(getBytes(1), "val1".getBytes(), new TimestampClock(1L)));
commit:bf98ec9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.filter.QueryFilter;
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(TEST_KEY, new QueryPath("Standard3"), new TreeSet<byte[]>()));
0:                 cf = cfStore.getColumnFamily(QueryFilter.getSliceFilter(TEST_KEY, new QueryPath("Standard3"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, null, false, 0));
0:                 cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(TEST_KEY, new QueryPath("Standard3"), "col99".getBytes()));
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(TEST_KEY, new QueryPath("Standard1"), "col1".getBytes()));
0:                 cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(TEST_KEY, new QueryPath("Standard1"), "col3".getBytes()));
commit:9f7ceae
/////////////////////////////////////////////////////////////////////////
0:         ssTables.iterator().next().forceFilterFailures();
commit:86eaf90
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.sstable.IndexHelper;
0: import org.apache.cassandra.io.sstable.SSTable;
0: import org.apache.cassandra.io.sstable.SSTableReader;
commit:7d2115b
/////////////////////////////////////////////////////////////////////////
0: import java.io.UnsupportedEncodingException;
0: import org.apache.commons.collections.CollectionUtils;
0: import org.apache.commons.collections.Predicate;
0: import org.apache.commons.collections.PredicateUtils;
/////////////////////////////////////////////////////////////////////////
1:     @Test
0:     public void testGetSliceWithBitmasks() throws Throwable
0:     {
1:         // tests slicing against data from one row in a memtable and then flushed to an sstable
0:         final Table table = Table.open("Keyspace1");
0:         final ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
0:         final String ROW = "row-bitmasktest";
0:         final NumberFormat fmt = new DecimalFormat("000");
0: 
0:         RowMutation rm = new RowMutation("Keyspace1", ROW);
0:         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
0:         // at this rate, we're getting 78-79 cos/block, assuming the blocks are set to be about 4k.
0:         // so if we go to 300, we'll get at least 4 blocks, which is plenty for testing.
1:         for (int i = 0; i < 300; i++)
0:             cf.addColumn(column("col" + fmt.format(i), "omg!thisisthevalue!"+i, 1L));
0:         rm.add(cf);
0:         rm.apply();
0: 
0:         Runnable verify = new WrappedRunnable()
0:         {
0:             public void runMayThrow() throws Exception
0:             {
0:                 ColumnFamily cf;
0: 
0:                 // blocks are partitioned like this: 000-097, 098-193, 194-289, 290-299, assuming a 4k column index size.
0:                 assert DatabaseDescriptor.getColumnIndexSize() == 4096 : "Unexpected column index size, block boundaries won't be where tests expect them.";
0: 
0:                 for (String[] bitmaskTests: new String[][] { {}, {"test one", "test two" }, { new String(new byte[] { 0, 1, 0x20, (byte) 0xff }) } })
0:                 {
0:                     ArrayList<byte[]> bitmasks = new ArrayList<byte[]>(bitmaskTests.length);
0: 
0:                     // test forward, spanning a segment.
0:                     cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col096".getBytes(), "col099".getBytes(), bitmasks, false, 4);
0:                     assertBitmaskedColumns(cf, bitmasks, "col096", "col097", "col098", "col099");
0: 
0:                     // test reversed, spanning a segment.
0:                     cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col099".getBytes(), "col096".getBytes(), bitmasks, true, 4);
0:                     assertBitmaskedColumns(cf, bitmasks, "col096", "col097", "col098", "col099");
0: 
0:                     // test forward, within a segment.
0:                     cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col100".getBytes(), "col103".getBytes(), bitmasks, false, 4);
0:                     assertBitmaskedColumns(cf, bitmasks, "col100", "col101", "col102", "col103");
0: 
0:                     // test reversed, within a segment.
0:                     cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col103".getBytes(), "col100".getBytes(), bitmasks, true, 4);
0:                     assertBitmaskedColumns(cf, bitmasks, "col100", "col101", "col102", "col103");
0: 
0:                     // test forward from beginning, spanning a segment.
0:                     String[] strCols = new String[100]; // col000-col099
0:                     for (int i = 0; i < 100; i++)
0:                         strCols[i] = "col" + fmt.format(i);
0:                     cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "".getBytes(), "col099".getBytes(), bitmasks, false, 100);
0:                     assertBitmaskedColumns(cf, bitmasks, strCols);
0: 
0:                     // test reversed, from end, spanning a segment.
0:                     cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "".getBytes(), "col288".getBytes(), bitmasks, true, 12);
0:                     assertBitmaskedColumns(cf, bitmasks, "col288", "col289", "col290", "col291", "col292", "col293", "col294", "col295", "col296", "col297", "col298", "col299");
0:                 }
0:             }
0:         };
0: 
0:         reTest(table.getColumnFamilyStore("Standard1"), verify);
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         assertBitmaskedColumnsNameArray(cf, null, columnNames);
0:     }
0: 
0:     public static void assertBitmaskedColumns(ColumnFamily cf, List<byte[]> bitmasks, String... unfilteredColumnNames)
0:     {
0:         assertBitmaskedColumnsNameArray(cf, bitmasks, unfilteredColumnNames);
0:     }
0: 
0:     public static void assertBitmaskedColumnsNameArray(ColumnFamily cf, List<byte[]> bitmasks, String[] unfilteredColumnNames)
0:     {
0: 
0:         List<String> names = new ArrayList<String>(unfilteredColumnNames.length);
0: 
0:         names.addAll(Arrays.asList(unfilteredColumnNames));
0: 
0:         if (bitmasks != null && bitmasks.size() > 0)
0:         {
0:             List<Predicate> predicates = new ArrayList<Predicate>(bitmasks.size());
0:             for (final byte[] bitmask: bitmasks)
0:             {
0:                 predicates.add(new Predicate()
0:                 {
0:                     public boolean evaluate(Object o)
0:                     {
0:                         try
0:                         {
0:                             return SliceQueryFilter.matchesBitmask(bitmask, o.toString().getBytes("UTF-8"));
0:                         }
0:                         catch (UnsupportedEncodingException e)
0:                         {
0:                             return false;
0:                         }
0:                     }
0:                 });
0:             }
0: 
0:             CollectionUtils.filter(names, PredicateUtils.anyPredicate(predicates));
0:         }
0: 
0:         String[] columnNames = names.toArray(new String[0]);
0:         String[] la = L.toArray(new String[columns.size()]);
0:         StringBuffer lasb = new StringBuffer();
0:         for (String l: la)
0:         {
0:             lasb.append(l);
0:             lasb.append(", ");
0:         }
0: 
0:         assert Arrays.equals(la, columnNames)
0:                 : String.format("Columns [%s(as string: %s)])] is not expected [%s] (bitmasks %s)",
0:                                 ((cf == null) ? "" : cf.getComparator().getColumnsString(columns)),
0:                                 lasb.toString(),
0:                                 StringUtils.join(columnNames, ","),
0:                                 SliceFromReadCommand.getBitmaskDescription(bitmasks));
0:                                 
commit:b2c2a60
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.SSTable;
/////////////////////////////////////////////////////////////////////////
0:         SSTable.PositionSize info = sstable.getPosition(decKey);
0:         file.seek(info.position);
commit:6b1e0a4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.WrappedRunnable;
/////////////////////////////////////////////////////////////////////////
0:     public static void reTest(ColumnFamilyStore cfs, Runnable verify) throws Exception
/////////////////////////////////////////////////////////////////////////
0:         Runnable verify = new WrappedRunnable()
0:             public void runMayThrow() throws Exception
/////////////////////////////////////////////////////////////////////////
0:         Runnable verify = new WrappedRunnable()
0:             public void runMayThrow() throws Exception
/////////////////////////////////////////////////////////////////////////
0:         Runnable verify = new WrappedRunnable()
0:             public void runMayThrow() throws Exception
/////////////////////////////////////////////////////////////////////////
0:         Runnable verify = new WrappedRunnable()
0:             public void runMayThrow() throws Exception
/////////////////////////////////////////////////////////////////////////
0:         Runnable verify = new WrappedRunnable()
0:             public void runMayThrow() throws Exception
/////////////////////////////////////////////////////////////////////////
0:         Runnable verify = new WrappedRunnable()
0:             public void runMayThrow() throws Exception
commit:dc6e4fe
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.util.BufferedRandomAccessFile;
commit:453c817
/////////////////////////////////////////////////////////////////////////
0:             CompactionManager.instance.submitMajor(cfStore).get();
commit:994487d
/////////////////////////////////////////////////////////////////////////
commit:57f0725
/////////////////////////////////////////////////////////////////////////
0: import java.text.DecimalFormat;
0: import java.text.NumberFormat;
0: import org.apache.cassandra.config.DatabaseDescriptor;
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void testGetSliceWithCutoff() throws Throwable
0:     {
1:         // tests slicing against data from one row in a memtable and then flushed to an sstable
0:         final Table table = Table.open("Keyspace1");
0:         final ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
0:         final String ROW = "row4";
0:         final NumberFormat fmt = new DecimalFormat("000");
0: 
0:         RowMutation rm = new RowMutation("Keyspace1", ROW);
0:         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
0:         // at this rate, we're getting 78-79 cos/block, assuming the blocks are set to be about 4k.
0:         // so if we go to 300, we'll get at least 4 blocks, which is plenty for testing.
0:         for (int i = 0; i < 300; i++)
0:             cf.addColumn(column("col" + fmt.format(i), "omg!thisisthevalue!"+i, 1L));
0:         rm.add(cf);
0:         rm.apply();
0: 
0:         Runner verify = new Runner()
0:         {
0:             public void run() throws Exception
0:             {
0:                 ColumnFamily cf;
0: 
0:                 // blocks are partitioned like this: 000-097, 098-193, 194-289, 290-299, assuming a 4k column index size.
0:                 assert DatabaseDescriptor.getColumnIndexSize() == 4096 : "Unexpected column index size, block boundaries won't be where tests expect them.";
0: 
0:                 // test forward, spanning a segment.
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col096".getBytes(), "col099".getBytes(), false, 4);
0:                 assertColumns(cf, "col096", "col097", "col098", "col099");
0: 
0:                 // test reversed, spanning a segment.
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col099".getBytes(), "col096".getBytes(), true, 4);
0:                 assertColumns(cf, "col096", "col097", "col098", "col099");
0: 
0:                 // test forward, within a segment.
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col100".getBytes(), "col103".getBytes(), false, 4);
0:                 assertColumns(cf, "col100", "col101", "col102", "col103");
0: 
0:                 // test reversed, within a segment.
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col103".getBytes(), "col100".getBytes(), true, 4);
0:                 assertColumns(cf, "col100", "col101", "col102", "col103");
0: 
0:                 // test forward from beginning, spanning a segment.
0:                 String[] strCols = new String[100]; // col000-col099
0:                 for (int i = 0; i < 100; i++)
0:                     strCols[i] = "col" + fmt.format(i);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "".getBytes(), "col099".getBytes(), false, 100);
0:                 assertColumns(cf, strCols);
0: 
0:                 // test reversed, from end, spanning a segment.
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "".getBytes(), "col288".getBytes(), true, 12);
0:                 assertColumns(cf, "col288", "col289", "col290", "col291", "col292", "col293", "col294", "col295", "col296", "col297", "col298", "col299");
0:             }
0:         };
0: 
0:         reTest(table.getColumnFamilyStore("Standard1"), verify);
0:     }
0: 
commit:67ae1ee
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey decKey = sstable.getPartitioner().decorateKey(key);
0:         long position = sstable.getPosition(decKey);
commit:e849e97
/////////////////////////////////////////////////////////////////////////
0:     public interface Runner
0:     public static void reTest(ColumnFamilyStore cfs, Runner verify) throws Exception
commit:fe28c47
/////////////////////////////////////////////////////////////////////////
0:             cfStore.doCompaction(2, cfStore.getSSTables().size());
commit:6b7a1c3
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(new SliceQueryFilter(TEST_KEY, new QueryPath("Standard3"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, false, 0));
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "b".getBytes(), "c".getBytes(), false, 100);
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "b".getBytes(), "b".getBytes(), false, 100);
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "b".getBytes(), "c".getBytes(), false, 1);
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "c".getBytes(), "b".getBytes(), false, 1);
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily("a", new QueryPath("Standard2"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, false, 1);
0:         cf = cfStore.getColumnFamily("z", new QueryPath("Standard2"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, false, 1);
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col5".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, false, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col4".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, false, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col5".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col6".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, true, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col95".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, false, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col0".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 2);
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col2".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, false, 3);
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "col1000".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, false, 3);
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "col1195".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, false, 3);
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "col1996".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 1000);
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "col1990".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, false, 3);
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, true, 3);
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "col9000".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 3);
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "col9000".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, false, 3);
/////////////////////////////////////////////////////////////////////////
0:                 ColumnFamily cf = cfStore.getColumnFamily(ROW, new QueryPath("Super1"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, false, 10);
commit:d221a41
/////////////////////////////////////////////////////////////////////////
0: 
0:                 cf = cfStore.getColumnFamily(new NamesQueryFilter(TEST_KEY, new QueryPath("Standard3"), "col99".getBytes()));
0:                 assertColumns(cf);
/////////////////////////////////////////////////////////////////////////
0: 
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "col9000".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, false, 3);
0:         assertColumns(cf, "col1997", "col1998", "col1999");
0: 
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "col9000".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 3);
0:         assertColumns(cf);
commit:00190bf
/////////////////////////////////////////////////////////////////////////
0:     private void reTest(ColumnFamilyStore cfs, Runner verify) throws Exception
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace2", TEST_KEY);
0:         ColumnFamily cf = ColumnFamily.create("Keyspace2", "Standard3");
0:         cf.addColumn(column("col1","val1", 1L));
0:         rm.add(cf);
0:         rm.apply();
0: 
/////////////////////////////////////////////////////////////////////////
0:         reTest(table.getColumnFamilyStore("Standard3"), verify);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", TEST_KEY);
0:         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
0:         cf.addColumn(column("col1","val1", 1L));
0:         cf.addColumn(column("col2","val2", 1L));
0:         cf.addColumn(column("col3","val3", 1L));
0:         rm.add(cf);
0:         rm.apply();
0: 
/////////////////////////////////////////////////////////////////////////
0:         reTest(table.getColumnFamilyStore("Standard1"), verify);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", ROW);
0:         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
0:         cf.addColumn(column("col1", "val1", 1L));
0:         cf.addColumn(column("col3", "val3", 1L));
0:         cf.addColumn(column("col4", "val4", 1L));
0:         cf.addColumn(column("col5", "val5", 1L));
0:         cf.addColumn(column("col7", "val7", 1L));
0:         cf.addColumn(column("col9", "val9", 1L));
0:         rm.add(cf);
0:         rm.apply();
0: 
0:         rm = new RowMutation("Keyspace1", ROW);
0:         rm.delete(new QueryPath("Standard1", null, "col4".getBytes()), 2L);
0:         rm.apply();
/////////////////////////////////////////////////////////////////////////
0:         reTest(table.getColumnFamilyStore("Standard1"), verify);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", ROW);
0:         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
0:         cf.addColumn(column("col1", "val1", 1L));
0:         cf.addColumn(column("col2", "val2", 1L));
0:         cf.addColumn(column("col3", "val3", 1L));
0:         cf.addColumn(column("col4", "val4", 1L));
0:         cf.addColumn(column("col5", "val5", 1L));
0:         cf.addColumn(column("col6", "val6", 1L));
0:         rm.add(cf);
0:         rm.apply();
0:         cfStore.forceBlockingFlush();
0: 
0:         rm = new RowMutation("Keyspace1", ROW);
0:         cf = ColumnFamily.create("Keyspace1", "Standard1");
0:         cf.addColumn(column("col1", "valx", 2L));
0:         cf.addColumn(column("col2", "valx", 2L));
0:         cf.addColumn(column("col3", "valx", 2L));
0:         rm.add(cf);
0:         rm.apply();
/////////////////////////////////////////////////////////////////////////
0:         reTest(table.getColumnFamilyStore("Standard1"), verify);
/////////////////////////////////////////////////////////////////////////
0: 
0:         RowMutation rm = new RowMutation("Keyspace1", ROW);
0:         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Super1");
0:         SuperColumn sc = new SuperColumn("sc1".getBytes(), new LongType());
0:         sc.addColumn(new Column(getBytes(1), "val1".getBytes(), 1L));
0:         cf.addColumn(sc);
0:         rm.add(cf);
0:         rm.apply();
/////////////////////////////////////////////////////////////////////////
0:         reTest(table.getColumnFamilyStore("Standard1"), verify);
commit:1dd5f60
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.BufferedRandomAccessFile;
0: import org.apache.cassandra.io.IndexHelper;
/////////////////////////////////////////////////////////////////////////
0:         String key = "row3";
0:         RowMutation rm = new RowMutation("Keyspace1", key);
/////////////////////////////////////////////////////////////////////////
0:         validateSliceLarge(cfStore);
1:         // compact so we have a big row with more than the minimum index count
0:         if (cfStore.getSSTables().size() > 1)
0:         {
0:             cfStore.doCompaction(cfStore.getSSTables().size());
0:         }
0:         SSTableReader sstable = cfStore.getSSTables().iterator().next();
0:         long position = sstable.getPosition(key);
0:         BufferedRandomAccessFile file = new BufferedRandomAccessFile(sstable.getFilename(), "r");
0:         file.seek(position);
0:         assert file.readUTF().equals(key);
0:         file.readInt();
0:         IndexHelper.skipBloomFilter(file);
0:         ArrayList<IndexHelper.IndexInfo> indexes = IndexHelper.deserializeIndex(file);
0:         assert indexes.size() > 2;
0:         validateSliceLarge(cfStore);
0:     }
0: 
0:     private void validateSliceLarge(ColumnFamilyStore cfStore) throws IOException
0:     {
0:         String key = "row3";
0:         ColumnFamily cf;
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "col1000".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 3);
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "col1195".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 3);
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "col1996".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, false, 1000);
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "col1990".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 3);
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, false, 3);
commit:a9c6a1e
/////////////////////////////////////////////////////////////////////////
commit:b3b9cd8
/////////////////////////////////////////////////////////////////////////
0:             cf.addColumn(column("col" + i, ("v" + i), 1L));
0:         assertEquals(new String(cf.getColumn("col1000".getBytes()).value()), "v1000");
0:         assertEquals(new String(cf.getColumn("col1001".getBytes()).value()), "v1001");
0:         assertEquals(new String(cf.getColumn("col1002".getBytes()).value()), "v1002");
0:         assertEquals(new String(cf.getColumn("col1195".getBytes()).value()), "v1195");
0:         assertEquals(new String(cf.getColumn("col1196".getBytes()).value()), "v1196");
0:         assertEquals(new String(cf.getColumn("col1197".getBytes()).value()), "v1197");
0:         cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col1996".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, false, 1000);
0:         IColumn[] columns = cf.getSortedColumns().toArray(new IColumn[0]);
0:         for (int i = 1000; i < 1996; i++)
0:         {
0:             String expectedName = "col" + i;
0:             IColumn column = columns[i - 1000];
0:             assert Arrays.equals(column.name(), expectedName.getBytes()) : cfStore.getComparator().getString(column.name()) + " is not " + expectedName;
0:             assert Arrays.equals(column.value(), ("v" + i).getBytes());
0:         }
0:         assertEquals(new String(cf.getColumn("col1990".getBytes()).value()), "v1990");
0:         assertEquals(new String(cf.getColumn("col1991".getBytes()).value()), "v1991");
0:         assertEquals(new String(cf.getColumn("col1992".getBytes()).value()), "v1992");
0:         assertEquals(new String(cf.getColumn("col1999".getBytes()).value()), "v1999");
0:         assertEquals(new String(cf.getColumn("col1998".getBytes()).value()), "v1998");
0:         assertEquals(new String(cf.getColumn("col1997".getBytes()).value()), "v1997");
commit:8203a6c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.filter.SliceQueryFilter;
/////////////////////////////////////////////////////////////////////////
0: 
1:     @Test
1:     public void testGetRowNoColumns() throws Throwable
0:     {
0:         final Table table = Table.open("Keyspace2");
0:         final ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard3");
0: 
0:         Runner setup = new Runner()
0:         {
0:             public void run() throws Exception
0:             {
0:                 RowMutation rm = makeSimpleRowMutation();
0:                 rm.apply();
0:             }
0:         };
0:         Runner verify = new Runner()
0:         {
0:             public void run() throws Exception
0:             {
0:                 ColumnFamily cf;
0: 
0:                 cf = cfStore.getColumnFamily(new NamesQueryFilter(TEST_KEY, new QueryPath("Standard3"), new TreeSet<byte[]>()));
0:                 assertColumns(cf);
0: 
0:                 cf = cfStore.getColumnFamily(new SliceQueryFilter(TEST_KEY, new QueryPath("Standard3"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, true, 0));
0:                 assertColumns(cf);
0:             }
0:         };
0:         reTest(setup, table.getColumnFamilyStore("Standard3"), verify);
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", TEST_KEY);
commit:9164940
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, false, 2);
0:                 assertColumns(cf, "col7", "col9");
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:         cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, false, 3);
0:         assertColumns(cf, "col1997", "col1998", "col1999");
0:         assertEquals(new String(cf.getColumn("col1999".getBytes()).value()), "vvvvvvvvvvvvvvvv1999");
0:         assertEquals(new String(cf.getColumn("col1998".getBytes()).value()), "vvvvvvvvvvvvvvvv1998");
0:         assertEquals(new String(cf.getColumn("col1997".getBytes()).value()), "vvvvvvvvvvvvvvvv1997");
commit:066ef58
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
0: 
1: package org.apache.cassandra.db;
0: 
1: import java.util.*;
0: import java.io.IOException;
0: 
0: import org.apache.commons.lang.StringUtils;
0: import org.apache.commons.lang.ArrayUtils;
1: import org.junit.Test;
0: 
0: import static junit.framework.Assert.*;
0: import org.apache.cassandra.CleanupHelper;
0: import static org.apache.cassandra.Util.column;
0: import static org.apache.cassandra.Util.getBytes;
0: import org.apache.cassandra.db.filter.NamesQueryFilter;
0: import org.apache.cassandra.db.filter.QueryPath;
0: import org.apache.cassandra.db.marshal.LongType;
0: import org.apache.cassandra.io.SSTableReader;
0: 
0: public class TableTest extends CleanupHelper
0: {
0:     private static final String KEY2 = "key2";
0:     private static final String TEST_KEY = "key1";
0: 
0:     interface Runner
0:     {
0:         public void run() throws Exception;
0:     }
0: 
0:     private void reTest(Runner setup, ColumnFamilyStore cfs, Runner verify) throws Exception
0:     {
0:         setup.run();
0:         verify.run();
0:         cfs.forceBlockingFlush();
0:         verify.run();
0:     }
0: 
1:     @Test
0:     public void testOpen() throws Throwable {
0:         Table table = Table.open("Mailbox");
0:         Row row = table.get("35300190:1");
0:         assertNotNull(row);
0:     }
0:     
1:     @Test
1:     public void testGetRowSingleColumn() throws Throwable
0:     {
0:         final Table table = Table.open("Keyspace1");
0:         final ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
0: 
0:         Runner setup = new Runner()
0:         {
0:             public void run() throws Exception
0:             {
0:                 RowMutation rm = makeSimpleRowMutation();
0:                 rm.apply();
0:             }
0:         };
0:         Runner verify = new Runner()
0:         {
0:             public void run() throws Exception
0:             {
0:                 ColumnFamily cf;
0: 
0:                 cf = cfStore.getColumnFamily(new NamesQueryFilter(TEST_KEY, new QueryPath("Standard1"), "col1".getBytes()));
0:                 assertColumns(cf, "col1");
0: 
0:                 cf = cfStore.getColumnFamily(new NamesQueryFilter(TEST_KEY, new QueryPath("Standard1"), "col3".getBytes()));
0:                 assertColumns(cf, "col3");
0:             }
0:         };
0:         reTest(setup, table.getColumnFamilyStore("Standard1"), verify);
0:     }
0:             
1:     @Test
0:     public void testGetRowSliceByRange() throws Throwable
0:     {
0:     	String key = TEST_KEY+"slicerow";
0:     	Table table = Table.open("Keyspace1");
0:         ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
0:     	RowMutation rm = new RowMutation("Keyspace1", key);
0:         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
0:         // First write "a", "b", "c"
0:         cf.addColumn(column("a", "val1", 1L));
0:         cf.addColumn(column("b", "val2", 1L));
0:         cf.addColumn(column("c", "val3", 1L));
0:         rm.add(cf);
0:         rm.apply();
0:         
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "b".getBytes(), "c".getBytes(), true, 100);
0:         assertEquals(2, cf.getColumnCount());
0:         
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "b".getBytes(), "b".getBytes(), true, 100);
0:         assertEquals(1, cf.getColumnCount());
0:         
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "b".getBytes(), "c".getBytes(), true, 1);
0:         assertEquals(1, cf.getColumnCount());
0:         
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "c".getBytes(), "b".getBytes(), true, 1);
0:         assertNull(cf);
0:     }
0: 
0:     private RowMutation makeSimpleRowMutation()
0:     {
0:         RowMutation rm = new RowMutation("Keyspace1",TEST_KEY);
0:         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
0:         cf.addColumn(column("col1","val1", 1L));
0:         cf.addColumn(column("col2","val2", 1L));
0:         cf.addColumn(column("col3","val3", 1L));
0:         rm.add(cf);
0:         return rm;
0:     }
0: 
1:     @Test
0:     public void testGetSliceNoMatch() throws Throwable
0:     {
0:         Table table = Table.open("Keyspace1");
0:         RowMutation rm = new RowMutation("Keyspace1", "row1000");
0:         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard2");
0:         cf.addColumn(column("col1", "val1", 1));
0:         rm.add(cf);
0:         rm.apply();
0: 
0:         validateGetSliceNoMatch(table);
0:         table.getColumnFamilyStore("Standard2").forceBlockingFlush();
0:         validateGetSliceNoMatch(table);
0: 
0:         Collection<SSTableReader> ssTables = table.getColumnFamilyStore("Standard2").getSSTables();
0:         assertEquals(1, ssTables.size());
0:         ssTables.iterator().next().forceBloomFilterFailures();
0:         validateGetSliceNoMatch(table);
0:     }
0: 
0:     private void validateGetSliceNoMatch(Table table) throws IOException
0:     {
0:         ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard2");
0:         ColumnFamily cf;
0: 
0:         // key before the rows that exists
0:         cf = cfStore.getColumnFamily("a", new QueryPath("Standard2"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, true, 1);
0:         assertColumns(cf);
0: 
0:         // key after the rows that exist
0:         cf = cfStore.getColumnFamily("z", new QueryPath("Standard2"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, true, 1);
0:         assertColumns(cf);
0:     }
0: 
1:     @Test
1:     public void testGetSliceFromBasic() throws Throwable
0:     {
0:         // tests slicing against data from one row in a memtable and then flushed to an sstable
0:         final Table table = Table.open("Keyspace1");
0:         final ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
0:         final String ROW = "row1";
0:         Runner setup = new Runner()
0:         {
0:             public void run() throws Exception
0:             {
0:                 RowMutation rm = new RowMutation("Keyspace1", ROW);
0:                 ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
0:                 cf.addColumn(column("col1", "val1", 1L));
0:                 cf.addColumn(column("col3", "val3", 1L));
0:                 cf.addColumn(column("col4", "val4", 1L));
0:                 cf.addColumn(column("col5", "val5", 1L));
0:                 cf.addColumn(column("col7", "val7", 1L));
0:                 cf.addColumn(column("col9", "val9", 1L));
0:                 rm.add(cf);
0:                 rm.apply();
0: 
0:                 rm = new RowMutation("Keyspace1", ROW);
0:                 rm.delete(new QueryPath("Standard1", null, "col4".getBytes()), 2L);
0:                 rm.apply();
0:             }
0:         };
0: 
0:         Runner verify = new Runner()
0:         {
0:             public void run() throws Exception
0:             {
0:                 Row result;
0:                 ColumnFamily cf;
0: 
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col5".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 2);
0:                 assertColumns(cf, "col5", "col7");
0: 
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col4".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 2);
0:                 assertColumns(cf, "col4", "col5", "col7");
0:                 assertColumns(ColumnFamilyStore.removeDeleted(cf, Integer.MAX_VALUE), "col5", "col7");
0: 
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col5".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, false, 2);
0:                 assertColumns(cf, "col3", "col4", "col5");
0: 
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col6".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, false, 2);
0:                 assertColumns(cf, "col3", "col4", "col5");
0: 
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col95".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 2);
0:                 assertColumns(cf);
0: 
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col0".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, false, 2);
0:                 assertColumns(cf);
0:             }
0:         };
0: 
0:         reTest(setup, table.getColumnFamilyStore("Standard1"), verify);
0:     }
0: 
1:     @Test
1:     public void testGetSliceFromAdvanced() throws Throwable
0:     {
1:         // tests slicing against data from one row spread across two sstables
0:         final Table table = Table.open("Keyspace1");
0:         final ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
0:         final String ROW = "row2";
0:         Runner setup = new Runner()
0:         {
0:             public void run() throws Exception
0:             {
0:                 RowMutation rm = new RowMutation("Keyspace1", ROW);
0:                 ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
0:                 cf.addColumn(column("col1", "val1", 1L));
0:                 cf.addColumn(column("col2", "val2", 1L));
0:                 cf.addColumn(column("col3", "val3", 1L));
0:                 cf.addColumn(column("col4", "val4", 1L));
0:                 cf.addColumn(column("col5", "val5", 1L));
0:                 cf.addColumn(column("col6", "val6", 1L));
0:                 rm.add(cf);
0:                 rm.apply();
0:                 cfStore.forceBlockingFlush();
0: 
0:                 rm = new RowMutation("Keyspace1", ROW);
0:                 cf = ColumnFamily.create("Keyspace1", "Standard1");
0:                 cf.addColumn(column("col1", "valx", 2L));
0:                 cf.addColumn(column("col2", "valx", 2L));
0:                 cf.addColumn(column("col3", "valx", 2L));
0:                 rm.add(cf);
0:                 rm.apply();
0:             }
0:         };
0: 
0:         Runner verify = new Runner()
0:         {
0:             public void run() throws Exception
0:             {
0:                 ColumnFamily cf;
0: 
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col2".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 3);
0:                 assertColumns(cf, "col2", "col3", "col4");
0:                 assertEquals(new String(cf.getColumn("col2".getBytes()).value()), "valx");
0:                 assertEquals(new String(cf.getColumn("col3".getBytes()).value()), "valx");
0:                 assertEquals(new String(cf.getColumn("col4".getBytes()).value()), "val4");
0:             }
0:         };
0: 
0:         reTest(setup, table.getColumnFamilyStore("Standard1"), verify);
0:     }
0: 
1:     @Test
1:     public void testGetSliceFromLarge() throws Throwable
0:     {
0:         // tests slicing against 1000 columns in an sstable
0:         Table table = Table.open("Keyspace1");
0:         ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
0:         String ROW = "row3";
0:         RowMutation rm = new RowMutation("Keyspace1", ROW);
0:         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
0:         for (int i = 1000; i < 2000; i++)
0:             cf.addColumn(column("col" + i, ("vvvvvvvvvvvvvvvv" + i), 1L));
0:         rm.add(cf);
0:         rm.apply();
0:         cfStore.forceBlockingFlush();
0: 
0:         cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col1000".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 3);
0:         assertColumns(cf, "col1000", "col1001", "col1002");
0:         assertEquals(new String(cf.getColumn("col1000".getBytes()).value()), "vvvvvvvvvvvvvvvv1000");
0:         assertEquals(new String(cf.getColumn("col1001".getBytes()).value()), "vvvvvvvvvvvvvvvv1001");
0:         assertEquals(new String(cf.getColumn("col1002".getBytes()).value()), "vvvvvvvvvvvvvvvv1002");
0: 
0:         cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col1195".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 3);
0:         assertColumns(cf, "col1195", "col1196", "col1197");
0:         assertEquals(new String(cf.getColumn("col1195".getBytes()).value()), "vvvvvvvvvvvvvvvv1195");
0:         assertEquals(new String(cf.getColumn("col1196".getBytes()).value()), "vvvvvvvvvvvvvvvv1196");
0:         assertEquals(new String(cf.getColumn("col1197".getBytes()).value()), "vvvvvvvvvvvvvvvv1197");
0: 
0:         cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col1196".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, false, 3);
0:         assertColumns(cf, "col1194", "col1195", "col1196");
0:         assertEquals(new String(cf.getColumn("col1194".getBytes()).value()), "vvvvvvvvvvvvvvvv1194");
0:         assertEquals(new String(cf.getColumn("col1195".getBytes()).value()), "vvvvvvvvvvvvvvvv1195");
0:         assertEquals(new String(cf.getColumn("col1196".getBytes()).value()), "vvvvvvvvvvvvvvvv1196");
0: 
0:         cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col1990".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 3);
0:         assertColumns(cf, "col1990", "col1991", "col1992");
0:         assertEquals(new String(cf.getColumn("col1990".getBytes()).value()), "vvvvvvvvvvvvvvvv1990");
0:         assertEquals(new String(cf.getColumn("col1991".getBytes()).value()), "vvvvvvvvvvvvvvvv1991");
0:         assertEquals(new String(cf.getColumn("col1992".getBytes()).value()), "vvvvvvvvvvvvvvvv1992");
0:     }
0: 
1:     @Test
0:     public void testGetSliceFromSuperBasic() throws Throwable
0:     {
1:         // tests slicing against data from one row spread across two sstables
0:         final Table table = Table.open("Keyspace1");
0:         final ColumnFamilyStore cfStore = table.getColumnFamilyStore("Super1");
0:         final String ROW = "row2";
0:         Runner setup = new Runner()
0:         {
0:             public void run() throws Exception
0:             {
0:                 RowMutation rm = new RowMutation("Keyspace1", ROW);
0:                 ColumnFamily cf = ColumnFamily.create("Keyspace1", "Super1");
0:                 SuperColumn sc = new SuperColumn("sc1".getBytes(), new LongType());
0:                 sc.addColumn(new Column(getBytes(1), "val1".getBytes(), 1L));
0:                 cf.addColumn(sc);
0:                 rm.add(cf);
0:                 rm.apply();
0:             }
0:         };
0: 
0:         Runner verify = new Runner()
0:         {
0:             public void run() throws Exception
0:             {
0:                 ColumnFamily cf = cfStore.getColumnFamily(ROW, new QueryPath("Super1"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, true, 10);
0:                 assertColumns(cf, "sc1");
0:                 assertEquals(new String(cf.getColumn("sc1".getBytes()).getSubColumn(getBytes(1)).value()), "val1");
0:             }
0:         };
0: 
0:         reTest(setup, table.getColumnFamilyStore("Standard1"), verify);
0:     }
0: 
0:     public static void assertColumns(ColumnFamily cf, String... columnNames)
0:     {
0:         Collection<IColumn> columns = cf == null ? new TreeSet<IColumn>() : cf.getSortedColumns();
0:         List<String> L = new ArrayList<String>();
0:         for (IColumn column : columns)
0:         {
0:             L.add(new String(column.name()));
0:         }
0:         assert Arrays.equals(L.toArray(new String[columns.size()]), columnNames)
0:                 : "Columns [" + ((cf == null) ? "" : cf.getComparator().getColumnsString(columns)) + "]"
0:                   + " is not expected [" + StringUtils.join(columnNames, ",") + "]";
0:     }
0: }
commit:572b5f8
/////////////////////////////////////////////////////////////////////////
0:         final Table table = Table.open("Keyspace1");
/////////////////////////////////////////////////////////////////////////
0:     	Table table = Table.open("Keyspace1");
0:     	RowMutation rm = new RowMutation("Keyspace1", key);
0:         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1",TEST_KEY);
0:         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         Table table = Table.open("Keyspace1");
0:         RowMutation rm = new RowMutation("Keyspace1", "row1000");
0:         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard2");
/////////////////////////////////////////////////////////////////////////
0:         final Table table = Table.open("Keyspace1");
0:                 RowMutation rm = new RowMutation("Keyspace1", ROW);
0:                 ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:                 rm = new RowMutation("Keyspace1", ROW);
/////////////////////////////////////////////////////////////////////////
0:         final Table table = Table.open("Keyspace1");
0:                 RowMutation rm = new RowMutation("Keyspace1", ROW);
0:                 ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:                 rm = new RowMutation("Keyspace1", ROW);
0:                 cf = ColumnFamily.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         Table table = Table.open("Keyspace1");
0:         RowMutation rm = new RowMutation("Keyspace1", ROW);
0:         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         final Table table = Table.open("Keyspace1");
0:                 RowMutation rm = new RowMutation("Keyspace1", ROW);
0:                 ColumnFamily cf = ColumnFamily.create("Keyspace1", "Super1");
commit:b866f81
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.marshal.LongType;
/////////////////////////////////////////////////////////////////////////
0:                 SuperColumn sc = new SuperColumn("sc1".getBytes(), new LongType());
commit:986cee6
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.lang.ArrayUtils;
0: import static org.apache.cassandra.Util.getBytes;
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(new NamesQueryFilter(TEST_KEY, new QueryPath("Standard1"), "col1".getBytes()));
0:                 cf = cfStore.getColumnFamily(new NamesQueryFilter(TEST_KEY, new QueryPath("Standard1"), "col3".getBytes()));
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "b".getBytes(), "c".getBytes(), true, 100);
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "b".getBytes(), "b".getBytes(), true, 100);
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "b".getBytes(), "c".getBytes(), true, 1);
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "c".getBytes(), "b".getBytes(), true, 1);
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily("a", new QueryPath("Standard2"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, true, 1);
0:         cf = cfStore.getColumnFamily("z", new QueryPath("Standard2"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, true, 1);
/////////////////////////////////////////////////////////////////////////
0:                 rm.delete(new QueryPath("Standard1", null, "col4".getBytes()), 2L);
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col5".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col4".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col5".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, false, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col6".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, false, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col95".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col0".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, false, 2);
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col2".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 3);
0:                 assertEquals(new String(cf.getColumn("col2".getBytes()).value()), "valx");
0:                 assertEquals(new String(cf.getColumn("col3".getBytes()).value()), "valx");
0:                 assertEquals(new String(cf.getColumn("col4".getBytes()).value()), "val4");
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col1000".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 3);
0:         assertEquals(new String(cf.getColumn("col1000".getBytes()).value()), "vvvvvvvvvvvvvvvv1000");
0:         assertEquals(new String(cf.getColumn("col1001".getBytes()).value()), "vvvvvvvvvvvvvvvv1001");
0:         assertEquals(new String(cf.getColumn("col1002".getBytes()).value()), "vvvvvvvvvvvvvvvv1002");
0:         cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col1195".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 3);
0:         assertEquals(new String(cf.getColumn("col1195".getBytes()).value()), "vvvvvvvvvvvvvvvv1195");
0:         assertEquals(new String(cf.getColumn("col1196".getBytes()).value()), "vvvvvvvvvvvvvvvv1196");
0:         assertEquals(new String(cf.getColumn("col1197".getBytes()).value()), "vvvvvvvvvvvvvvvv1197");
0:         cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col1196".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, false, 3);
0:         assertEquals(new String(cf.getColumn("col1194".getBytes()).value()), "vvvvvvvvvvvvvvvv1194");
0:         assertEquals(new String(cf.getColumn("col1195".getBytes()).value()), "vvvvvvvvvvvvvvvv1195");
0:         assertEquals(new String(cf.getColumn("col1196".getBytes()).value()), "vvvvvvvvvvvvvvvv1196");
0:         cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col1990".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 3);
0:         assertEquals(new String(cf.getColumn("col1990".getBytes()).value()), "vvvvvvvvvvvvvvvv1990");
0:         assertEquals(new String(cf.getColumn("col1991".getBytes()).value()), "vvvvvvvvvvvvvvvv1991");
0:         assertEquals(new String(cf.getColumn("col1992".getBytes()).value()), "vvvvvvvvvvvvvvvv1992");
/////////////////////////////////////////////////////////////////////////
0:                 SuperColumn sc = new SuperColumn("sc1".getBytes());
0:                 sc.addColumn(new Column(getBytes(1), "val1".getBytes(), 1L));
/////////////////////////////////////////////////////////////////////////
0:                 ColumnFamily cf = cfStore.getColumnFamily(ROW, new QueryPath("Super1"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, true, 10);
0:                 assertEquals(new String(cf.getColumn("sc1".getBytes()).getSubColumn(getBytes(1)).value()), "val1");
0:     public static void assertColumns(ColumnFamily cf, String... columnNames)
0:         Collection<IColumn> columns = cf == null ? new TreeSet<IColumn>() : cf.getSortedColumns();
0:             L.add(new String(column.name()));
0:                 : "Columns [" + ((cf == null) ? "" : cf.getComparator().getColumnsString(columns)) + "]"
0:                   + " is not expected [" + StringUtils.join(columnNames, ",") + "]";
commit:7435fc8
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.cassandra.Util.column;
/////////////////////////////////////////////////////////////////////////
0:         cf.addColumn(column("a", "val1", 1L));
0:         cf.addColumn(column("b", "val2", 1L));
0:         cf.addColumn(column("c", "val3", 1L));
/////////////////////////////////////////////////////////////////////////
0:         cf.addColumn(column("col1","val1", 1L));
0:         cf.addColumn(column("col2","val2", 1L));
0:         cf.addColumn(column("col3","val3", 1L));
/////////////////////////////////////////////////////////////////////////
0:         cf.addColumn(column("col1", "val1", 1));
/////////////////////////////////////////////////////////////////////////
0:                 cf.addColumn(column("col1", "val1", 1L));
0:                 cf.addColumn(column("col3", "val3", 1L));
0:                 cf.addColumn(column("col4", "val4", 1L));
0:                 cf.addColumn(column("col5", "val5", 1L));
0:                 cf.addColumn(column("col7", "val7", 1L));
0:                 cf.addColumn(column("col9", "val9", 1L));
/////////////////////////////////////////////////////////////////////////
0:                 cf.addColumn(column("col1", "val1", 1L));
0:                 cf.addColumn(column("col2", "val2", 1L));
0:                 cf.addColumn(column("col3", "val3", 1L));
0:                 cf.addColumn(column("col4", "val4", 1L));
0:                 cf.addColumn(column("col5", "val5", 1L));
0:                 cf.addColumn(column("col6", "val6", 1L));
0:                 cf.addColumn(column("col1", "valx", 2L));
0:                 cf.addColumn(column("col2", "valx", 2L));
0:                 cf.addColumn(column("col3", "valx", 2L));
/////////////////////////////////////////////////////////////////////////
0:             cf.addColumn(column("col" + i, ("vvvvvvvvvvvvvvvv" + i), 1L));
/////////////////////////////////////////////////////////////////////////
0:                 sc.addColumn(column("col1", "val1", 1L));
commit:ff764ff
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "b", "c", true, 100);
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "b", "b", true, 100);
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "b", "c", true, 1);
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "c", "b", true, 1);
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily("a", new QueryPath("Standard2"), "", "", true, 1);
0:         cf = cfStore.getColumnFamily("z", new QueryPath("Standard2"), "", "", true, 1);
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col5", "", true, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col4", "", true, 2);
0:                 assertColumns(cf, "col4", "col5", "col7");
0:                 assertColumns(ColumnFamilyStore.removeDeleted(cf, Integer.MAX_VALUE), "col5", "col7");
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col5", "", false, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col6", "", false, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col95", "", true, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col0", "", false, 2);
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col2", "", true, 3);
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col1000", "", true, 3);
0:         cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col1195", "", true, 3);
0:         cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col1196", "", false, 3);
0:         cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col1990", "", true, 3);
/////////////////////////////////////////////////////////////////////////
0:                 ColumnFamily cf = cfStore.getColumnFamily(ROW, new QueryPath("Super1"), "", "", true, 10);
commit:f2da00f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.filter.QueryPath;
/////////////////////////////////////////////////////////////////////////
0:         final ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
0: 
/////////////////////////////////////////////////////////////////////////
0:                 ColumnFamily cf;
0:                 cf = cfStore.getColumnFamily(new NamesQueryFilter(TEST_KEY, new QueryPath("Standard1"), "col1"));
0:                 assertColumns(cf, "col1");
0:                 cf = cfStore.getColumnFamily(new NamesQueryFilter(TEST_KEY, new QueryPath("Standard1"), "col3"));
0:                 assertColumns(cf, "col3");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
0:     	RowMutation rm = new RowMutation("Table1", key);
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "b", "c", true, 0, 100);
0:         assertEquals(2, cf.getColumnCount());
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "b", "b", true, 0, 100);
0:         assertEquals(1, cf.getColumnCount());
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "b", "c", true, 0, 1);
0:         assertEquals(1, cf.getColumnCount());
0:         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "c", "b", true, 0, 1);
0:         assertNull(cf);
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard2");
0:         cf = cfStore.getColumnFamily("a", new QueryPath("Standard2"), "", "", true, 0, 1);
0:         cf = cfStore.getColumnFamily("z", new QueryPath("Standard2"), "", "", true, 0, 1);
/////////////////////////////////////////////////////////////////////////
0:         final ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
/////////////////////////////////////////////////////////////////////////
0:                 rm.delete(new QueryPath("Standard1", null, "col4"), 2L);
/////////////////////////////////////////////////////////////////////////
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col5", "", true, 0, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col4", "", true, 0, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col5", "", false, 0, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col6", "", false, 0, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col95", "", true, 0, 2);
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col0", "", false, 0, 2);
/////////////////////////////////////////////////////////////////////////
0:         final ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
/////////////////////////////////////////////////////////////////////////
0:                 cfStore.forceBlockingFlush();
/////////////////////////////////////////////////////////////////////////
0:                 ColumnFamily cf;
0:                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col2", "", true, 0, 3);
0:                 assertColumns(cf, "col2", "col3", "col4");
0:                 assertEquals(new String(cf.getColumn("col2").value()), "valx");
0:                 assertEquals(new String(cf.getColumn("col3").value()), "valx");
0:                 assertEquals(new String(cf.getColumn("col4").value()), "val4");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
/////////////////////////////////////////////////////////////////////////
0:         cfStore.forceBlockingFlush();
0:         cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col1000", "", true, 0, 3);
0:         assertColumns(cf, "col1000", "col1001", "col1002");
0:         assertEquals(new String(cf.getColumn("col1000").value()), "vvvvvvvvvvvvvvvv1000");
0:         assertEquals(new String(cf.getColumn("col1001").value()), "vvvvvvvvvvvvvvvv1001");
0:         assertEquals(new String(cf.getColumn("col1002").value()), "vvvvvvvvvvvvvvvv1002");
0:         cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col1195", "", true, 0, 3);
0:         assertColumns(cf, "col1195", "col1196", "col1197");
0:         assertEquals(new String(cf.getColumn("col1195").value()), "vvvvvvvvvvvvvvvv1195");
0:         assertEquals(new String(cf.getColumn("col1196").value()), "vvvvvvvvvvvvvvvv1196");
0:         assertEquals(new String(cf.getColumn("col1197").value()), "vvvvvvvvvvvvvvvv1197");
0:         cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col1195", "", true, 10, 3);
0:         assertColumns(cf, "col1205", "col1206", "col1207");
0:         assertEquals(new String(cf.getColumn("col1205").value()), "vvvvvvvvvvvvvvvv1205");
0:         assertEquals(new String(cf.getColumn("col1206").value()), "vvvvvvvvvvvvvvvv1206");
0:         assertEquals(new String(cf.getColumn("col1207").value()), "vvvvvvvvvvvvvvvv1207");
0:         cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col1196", "", false, 0, 3);
0:         assertColumns(cf, "col1194", "col1195", "col1196");
0:         assertEquals(new String(cf.getColumn("col1194").value()), "vvvvvvvvvvvvvvvv1194");
0:         assertEquals(new String(cf.getColumn("col1195").value()), "vvvvvvvvvvvvvvvv1195");
0:         assertEquals(new String(cf.getColumn("col1196").value()), "vvvvvvvvvvvvvvvv1196");
0:         cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col1196", "", false, 10, 3);
0:         assertColumns(cf, "col1184", "col1185", "col1186");
0:         assertEquals(new String(cf.getColumn("col1184").value()), "vvvvvvvvvvvvvvvv1184");
0:         assertEquals(new String(cf.getColumn("col1185").value()), "vvvvvvvvvvvvvvvv1185");
0:         assertEquals(new String(cf.getColumn("col1186").value()), "vvvvvvvvvvvvvvvv1186");
0:         cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col1990", "", true, 0, 3);
0:         assertColumns(cf, "col1990", "col1991", "col1992");
0:         assertEquals(new String(cf.getColumn("col1990").value()), "vvvvvvvvvvvvvvvv1990");
0:         assertEquals(new String(cf.getColumn("col1991").value()), "vvvvvvvvvvvvvvvv1991");
0:         assertEquals(new String(cf.getColumn("col1992").value()), "vvvvvvvvvvvvvvvv1992");
/////////////////////////////////////////////////////////////////////////
0:         final ColumnFamilyStore cfStore = table.getColumnFamilyStore("Super1");
/////////////////////////////////////////////////////////////////////////
0:                 ColumnFamily cf = cfStore.getColumnFamily(ROW, new QueryPath("Super1"), "", "", true, 0, 10);
0:                 assertColumns(cf, "sc1");
0:                 assertEquals(new String(cf.getColumn("sc1").getSubColumn("col1").value()), "val1");
commit:dd4f4be
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.db.filter.NamesQueryFilter;
/////////////////////////////////////////////////////////////////////////
0:                 result = table.getRow(TEST_KEY, new NamesQueryFilter(TEST_KEY, "Standard1", "col1"));
0:                 result = table.getRow(TEST_KEY, new NamesQueryFilter(TEST_KEY, "Standard1", "col3"));
/////////////////////////////////////////////////////////////////////////
0:         SortedSet<IColumn> columns = columnFamily == null ? new TreeSet<IColumn>() : columnFamily.getAllColumns();
commit:23fa1bc
/////////////////////////////////////////////////////////////////////////
0:         Row result = table.getRow(key, "Standard1", "b", "c", true, 0, 100);
0:         result = table.getRow(key, "Standard1", "b", "b", true, 0, 100);
0:         result = table.getRow(key, "Standard1", "b", "c", true, 0, 1);
0:         result = table.getRow(key, "Standard1", "c", "b", true, 0, 1);
0:         assertNull(result.getColumnFamily("Standard1"));
/////////////////////////////////////////////////////////////////////////
0:         result = table.getRow("a", "Standard2", "", "", true, 0, 1);
0:         result = table.getRow("z", "Standard2", "", "", true, 0, 1);
/////////////////////////////////////////////////////////////////////////
0:                 result = table.getRow(ROW, "Standard1", "col5", "", true, 0, 2);
0:                 result = table.getRow(ROW, "Standard1", "col4", "", true, 0, 2);
0:                 result = table.getRow(ROW, "Standard1", "col5", "", false, 0, 2);
0:                 result = table.getRow(ROW, "Standard1", "col6", "", false, 0, 2);
0:                 result = table.getRow(ROW, "Standard1", "col95", "", true, 0, 2);
0:                 result = table.getRow(ROW, "Standard1", "col0", "", false, 0, 2);
/////////////////////////////////////////////////////////////////////////
0:                 result = table.getRow(ROW, "Standard1", "col2", "", true, 0, 3);
/////////////////////////////////////////////////////////////////////////
0:         result = table.getRow(ROW, "Standard1", "col1000", "", true, 0, 3);
0:         result = table.getRow(ROW, "Standard1", "col1195", "", true, 0, 3);
0:         result = table.getRow(ROW, "Standard1", "col1195", "", true, 10, 3);
0:         result = table.getRow(ROW, "Standard1", "col1196", "", false, 0, 3);
0:         result = table.getRow(ROW, "Standard1", "col1196", "", false, 10, 3);
0:         result = table.getRow(ROW, "Standard1", "col1990", "", true, 0, 3);
/////////////////////////////////////////////////////////////////////////
0:                 result = table.getRow(ROW, "Super1", "", "", true, 0, 10);
commit:d6c0b0f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.io.SSTableReader;
/////////////////////////////////////////////////////////////////////////
0:         Collection<SSTableReader> ssTables = table.getColumnFamilyStore("Standard2").getSSTables();
commit:cdd8b17
/////////////////////////////////////////////////////////////////////////
0:         result = table.getSliceFrom("a", "Standard2:", true, 0, 1);
0:         result = table.getSliceFrom("z", "Standard2:", true, 0, 1);
/////////////////////////////////////////////////////////////////////////
0:                 result = table.getSliceFrom(ROW, "Standard1:col5", true, 0, 2);
0:                 result = table.getSliceFrom(ROW, "Standard1:col4", true, 0, 2);
0:                 assertColumns(cf, "col5", "col7");
0:                 result = table.getSliceFrom(ROW, "Standard1:col5", false, 0, 2);
0:                 result = table.getSliceFrom(ROW, "Standard1:col6", false, 0, 2);
0:                 result = table.getSliceFrom(ROW, "Standard1:col95", true, 0, 2);
0:                 result = table.getSliceFrom(ROW, "Standard1:col0", false, 0, 2);
/////////////////////////////////////////////////////////////////////////
0:                 result = table.getSliceFrom(ROW, "Standard1:col2", true, 0, 3);
/////////////////////////////////////////////////////////////////////////
0:         result = table.getSliceFrom(ROW, "Standard1:col1000", true, 0, 3);
0:         result = table.getSliceFrom(ROW, "Standard1:col1195", true, 0, 3);
0:         result = table.getSliceFrom(ROW, "Standard1:col1195", true, 10, 3);
0:         cfres = result.getColumnFamily("Standard1");
0:         assertColumns(cfres, "col1205", "col1206", "col1207");
0:         assertEquals(new String(cfres.getColumn("col1205").value()), "vvvvvvvvvvvvvvvv1205");
0:         assertEquals(new String(cfres.getColumn("col1206").value()), "vvvvvvvvvvvvvvvv1206");
0:         assertEquals(new String(cfres.getColumn("col1207").value()), "vvvvvvvvvvvvvvvv1207");
0: 
0:         result = table.getSliceFrom(ROW, "Standard1:col1196", false, 0, 3);
0:         result = table.getSliceFrom(ROW, "Standard1:col1196", false, 10, 3);
0:         cfres = result.getColumnFamily("Standard1");
0:         assertColumns(cfres, "col1184", "col1185", "col1186");
0:         assertEquals(new String(cfres.getColumn("col1184").value()), "vvvvvvvvvvvvvvvv1184");
0:         assertEquals(new String(cfres.getColumn("col1185").value()), "vvvvvvvvvvvvvvvv1185");
0:         assertEquals(new String(cfres.getColumn("col1186").value()), "vvvvvvvvvvvvvvvv1186");
0: 
0:         result = table.getSliceFrom(ROW, "Standard1:col1990", true, 0, 3);
/////////////////////////////////////////////////////////////////////////
0:                 result = table.getSliceFrom(ROW, "Super1:", true, 0, 10);
commit:6342512
/////////////////////////////////////////////////////////////////////////
0:             
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         result = table.getSliceFrom("a", "Standard2:", true, 0);
0:         result = table.getSliceFrom("z", "Standard2:", true, 0);
/////////////////////////////////////////////////////////////////////////
0:     @Test
0:     public void testGetSliceFromSuperBasic() throws Throwable
0:     {
0:         // tests slicing against data from one row spread across two sstables
0:         final Table table = Table.open("Table1");
0:         final String ROW = "row2";
0:         Runner setup = new Runner()
0:         {
0:             public void run() throws Exception
0:             {
0:                 RowMutation rm = new RowMutation("Table1", ROW);
0:                 ColumnFamily cf = ColumnFamily.create("Table1", "Super1");
0:                 SuperColumn sc = new SuperColumn("sc1");
0:                 sc.addColumn(new Column("col1", "val1".getBytes(), 1L));
0:                 cf.addColumn(sc);
0:                 rm.add(cf);
0:                 rm.apply();
0:             }
0:         };
0: 
0:         Runner verify = new Runner()
0:         {
0:             public void run() throws Exception
0:             {
0:                 Row result;
0:                 ColumnFamily cfres;
0: 
0:                 result = table.getSliceFrom(ROW, "Super1:", true, 10);
0:                 cfres = result.getColumnFamily("Super1");
0:                 assertColumns(cfres, "sc1");
0:                 assertEquals(new String(cfres.getColumn("sc1").getSubColumn("col1").value()), "val1");
0:             }
0:         };
0: 
0:         reTest(setup, table.getColumnFamilyStore("Standard1"), verify);
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
commit:f9a1343
/////////////////////////////////////////////////////////////////////////
0: import java.util.*;
/////////////////////////////////////////////////////////////////////////
0:         Collection<SSTable> ssTables = table.getColumnFamilyStore("Standard2").getSSTables();
0:         ssTables.iterator().next().forceBloomFilterFailures();
commit:2f322a8
/////////////////////////////////////////////////////////////////////////
0:         SSTable.get(ssTables.iterator().next()).forceBloomFilterFailures();
commit:509cbb8
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ExecutionException;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         final Table table = Table.open("Table1");
/////////////////////////////////////////////////////////////////////////
0:         final Table table = Table.open("Table1");
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Table1",KEY2);
/////////////////////////////////////////////////////////////////////////
0:         rm = new RowMutation("Table1", KEY2);
/////////////////////////////////////////////////////////////////////////
0:     	Table table = Table.open("Table1");
0:     	RowMutation rm = new RowMutation("Table1",key);
/////////////////////////////////////////////////////////////////////////
0:         Table table = Table.open("Table1");
0:         RowMutation rm = new RowMutation("Table1",TEST_KEY);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Table1",TEST_KEY);
/////////////////////////////////////////////////////////////////////////
0:         Table table = Table.open("Table1");
0:         RowMutation rm = new RowMutation("Table1", "row1000");
/////////////////////////////////////////////////////////////////////////
0:         final Table table = Table.open("Table1");
0:                 RowMutation rm = new RowMutation("Table1", ROW);
/////////////////////////////////////////////////////////////////////////
0:                 rm = new RowMutation("Table1", ROW);
/////////////////////////////////////////////////////////////////////////
0:         final Table table = Table.open("Table1");
0:                 RowMutation rm = new RowMutation("Table1", ROW);
/////////////////////////////////////////////////////////////////////////
0:                 rm = new RowMutation("Table1", ROW);
/////////////////////////////////////////////////////////////////////////
0:         Table table = Table.open("Table1");
0:         RowMutation rm = new RowMutation("Table1", ROW);
commit:3673e28
/////////////////////////////////////////////////////////////////////////
0:     interface Runner
0:     {
0:         public void run() throws Exception;
0:     }
0: 
0:     private void reTest(Runner setup, ColumnFamilyStore cfs, Runner verify) throws Exception
0:     {
0:         setup.run();
0:         verify.run();
0:         cfs.forceBlockingFlush();
0:         verify.run();
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         final Table table = Table.open(TABLE_NAME);
0:         Runner setup = new Runner()
0:         {
0:             public void run() throws Exception
0:             {
0:                 RowMutation rm = makeSimpleRowMutation();
0:                 rm.apply();
0:             }
0:         };
0:         Runner verify = new Runner()
0:         {
0:             public void run() throws Exception
0:             {
0:                 Row result;
0: 
0:                 result = table.getRow(TEST_KEY, "Standard1:col1");
0:                 assertColumns(result.getColumnFamily("Standard1"), "col1");
0: 
0:                 result = table.getRow(TEST_KEY, "Standard1:col3");
0:                 assertColumns(result.getColumnFamily("Standard1"), "col3");
0:             }
0:         };
0:         reTest(setup, table.getColumnFamilyStore("Standard1"), verify);
0:         final Table table = Table.open(TABLE_NAME);
0:         Runner setup = new Runner()
0:         {
0:             public void run() throws Exception
0:             {
0:                 RowMutation rm = makeSimpleRowMutation(); //inserts col1, col2, col3
0:                 rm.apply();
0:             }
0:         };
0:         Runner verify = new Runner()
0:         {
0:             public void run() throws Exception
0:             {
0:                 Row result = table.getRow(TEST_KEY, "Standard1", 0, 2);
0:                 ColumnFamily cres = result.getColumnFamily("Standard1");
0:                 assertNotNull(cres);
0:                 assertEquals(cres.getColumnCount(), 2);
0:                 // should have col1 and col2
0:                 assertNotNull(cres.getColumn("col1"));
0:                 assertNotNull(cres.getColumn("col2"));
0:                 result = table.getRow(TEST_KEY, "Standard1", 1, 2);
0:                 cres = result.getColumnFamily("Standard1");
0:                 assertNotNull(cres);
0:                 assertEquals(2, cres.getColumnCount());
0:                 // offset is 1, so we should have col2 and col3
0:                 assertNotNull(cres.getColumn("col2"));
0:                 assertNotNull(cres.getColumn("col3"));
0:             }
0:         };
0:         reTest(setup, table.getColumnFamilyStore("Standard1"), verify);
/////////////////////////////////////////////////////////////////////////
0:         final Table table = Table.open(TABLE_NAME);
0:         final String ROW = "row1";
0:         Runner setup = new Runner()
0:         {
0:             public void run() throws Exception
0:             {
0:                 RowMutation rm = new RowMutation(TABLE_NAME, ROW);
0:                 ColumnFamily cf = ColumnFamily.create("Table1", "Standard1");
0:                 cf.addColumn(new Column("col1", "val1".getBytes(), 1L));
0:                 cf.addColumn(new Column("col3", "val3".getBytes(), 1L));
0:                 cf.addColumn(new Column("col4", "val4".getBytes(), 1L));
0:                 cf.addColumn(new Column("col5", "val5".getBytes(), 1L));
0:                 cf.addColumn(new Column("col7", "val7".getBytes(), 1L));
0:                 cf.addColumn(new Column("col9", "val9".getBytes(), 1L));
0:                 rm.add(cf);
0:                 rm.apply();
0:                 rm = new RowMutation(TABLE_NAME, ROW);
0:                 rm.delete("Standard1:col4", 2L);
0:                 rm.apply();
0:             }
0:         };
0: 
0:         Runner verify = new Runner()
0:         {
0:             public void run() throws Exception
0:             {
0:                 Row result;
0:                 ColumnFamily cf;
0: 
0:                 result = table.getSliceFrom(ROW, "Standard1:col5", true, 2);
0:                 cf = result.getColumnFamily("Standard1");
0:                 assertColumns(cf, "col5", "col7");
0: 
0:                 result = table.getSliceFrom(ROW, "Standard1:col4", true, 2);
0:                 cf = result.getColumnFamily("Standard1");
0:                 assertColumns(cf, "col4", "col5", "col7");
0: 
0:                 result = table.getSliceFrom(ROW, "Standard1:col5", false, 2);
0:                 cf = result.getColumnFamily("Standard1");
0:                 assertColumns(cf, "col3", "col4", "col5");
0: 
0:                 result = table.getSliceFrom(ROW, "Standard1:col6", false, 2);
0:                 cf = result.getColumnFamily("Standard1");
0:                 assertColumns(cf, "col3", "col4", "col5");
0: 
0:                 result = table.getSliceFrom(ROW, "Standard1:col95", true, 2);
0:                 cf = result.getColumnFamily("Standard1");
0:                 assertColumns(cf);
0: 
0:                 result = table.getSliceFrom(ROW, "Standard1:col0", false, 2);
0:                 cf = result.getColumnFamily("Standard1");
0:                 assertColumns(cf);
0:             }
0:         };
0: 
0:         reTest(setup, table.getColumnFamilyStore("Standard1"), verify);
0:         final Table table = Table.open(TABLE_NAME);
0:         final String ROW = "row2";
0:         Runner setup = new Runner()
0:         {
0:             public void run() throws Exception
0:             {
0:                 RowMutation rm = new RowMutation(TABLE_NAME, ROW);
0:                 ColumnFamily cf = ColumnFamily.create("Table1", "Standard1");
0:                 cf.addColumn(new Column("col1", "val1".getBytes(), 1L));
0:                 cf.addColumn(new Column("col2", "val2".getBytes(), 1L));
0:                 cf.addColumn(new Column("col3", "val3".getBytes(), 1L));
0:                 cf.addColumn(new Column("col4", "val4".getBytes(), 1L));
0:                 cf.addColumn(new Column("col5", "val5".getBytes(), 1L));
0:                 cf.addColumn(new Column("col6", "val6".getBytes(), 1L));
0:                 rm.add(cf);
0:                 rm.apply();
0:                 table.getColumnFamilyStore("Standard1").forceBlockingFlush();
0:                 rm = new RowMutation(TABLE_NAME, ROW);
0:                 cf = ColumnFamily.create("Table1", "Standard1");
0:                 cf.addColumn(new Column("col1", "valx".getBytes(), 2L));
0:                 cf.addColumn(new Column("col2", "valx".getBytes(), 2L));
0:                 cf.addColumn(new Column("col3", "valx".getBytes(), 2L));
0:                 rm.add(cf);
0:                 rm.apply();
0:             }
0:         };
0: 
0:         Runner verify = new Runner()
0:         {
0:             public void run() throws Exception
0:             {
0:                 Row result;
0:                 ColumnFamily cfres;
0: 
0:                 result = table.getSliceFrom(ROW, "Standard1:col2", true, 3);
0:                 cfres = result.getColumnFamily("Standard1");
0:                 assertColumns(cfres, "col2", "col3", "col4");
0:                 assertEquals(new String(cfres.getColumn("col2").value()), "valx");
0:                 assertEquals(new String(cfres.getColumn("col3").value()), "valx");
0:                 assertEquals(new String(cfres.getColumn("col4").value()), "val4");
0:             }
0:         };
0: 
0:         reTest(setup, table.getColumnFamilyStore("Standard1"), verify);
/////////////////////////////////////////////////////////////////////////
commit:9aeef94
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = ColumnFamily.create("Table1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         cf = ColumnFamily.create("Table1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = ColumnFamily.create("Table1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = ColumnFamily.create("Table1", "Super1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = ColumnFamily.create("Table1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = ColumnFamily.create("Table1", "Standard2");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = ColumnFamily.create("Table1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = ColumnFamily.create("Table1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         cf = ColumnFamily.create("Table1", "Standard1");
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = ColumnFamily.create("Table1", "Standard1");
commit:a0c2b2a
/////////////////////////////////////////////////////////////////////////
0:     public static void assertColumns(ColumnFamily columnFamily, String... columnNames)
commit:72e6eea
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import org.apache.commons.lang.StringUtils;
0: import org.apache.cassandra.io.SSTable;
/////////////////////////////////////////////////////////////////////////
0:         ColumnFamily cf = new ColumnFamily("Standard1", "Standard");
/////////////////////////////////////////////////////////////////////////
0:     public void testGetSliceNoMatch() throws Throwable
0:     {
0:         Table table = Table.open(TABLE_NAME);
0:         RowMutation rm = new RowMutation(TABLE_NAME, "row1000");
0:         ColumnFamily cf = new ColumnFamily("Standard2", "Standard");
0:         cf.addColumn(new Column("col1", "val1".getBytes(), 1));
0:         rm.add(cf);
0:         rm.apply();
0: 
0:         validateGetSliceNoMatch(table);
0:         table.getColumnFamilyStore("Standard2").forceBlockingFlush();
0:         validateGetSliceNoMatch(table);
0: 
0:         SortedSet<String> ssTables = table.getColumnFamilyStore("Standard2").getSSTableFilenames();
0:         assertEquals(1, ssTables.size());
0:         SSTable.forceBloomFilterFailures(ssTables.iterator().next());
0:         validateGetSliceNoMatch(table);
0:     }
0: 
0:     private void validateGetSliceNoMatch(Table table) throws IOException
0:     {
0:         Row result;
0:         ColumnFamily cf;
0: 
0:         // key before the rows that exists
0:         result = table.getSliceFrom("a", "Standard2", true, 0);
0:         cf = result.getColumnFamily("Standard2");
0:         assertColumns(cf);
0: 
0:         // key after the rows that exist
0:         result = table.getSliceFrom("z", "Standard2", true, 0);
0:         cf = result.getColumnFamily("Standard2");
0:         assertColumns(cf);
0:     }
0: 
0:     @Test
0:         // tests slicing against data from one row in a memtable and then flushed to an sstable
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:         // tests slicing against data from one row spread across two sstables
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:         // tests slicing against 1000 columns in an sstable
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private void assertColumns(ColumnFamily columnFamily, String... columnNames)
/////////////////////////////////////////////////////////////////////////
0:         assert Arrays.equals(L.toArray(new String[columns.size()]), columnNames)
0:                 : "Columns [" + StringUtils.join(columns, ", ") + "] is not expected [" + StringUtils.join(columnNames, ", ") + "]";
/////////////////////////////////////////////////////////////////////////
0:         assertEquals(new String(cfres.getColumn("col4").value()), "val4");
commit:30b1f5f
/////////////////////////////////////////////////////////////////////////
0:     @Test
0:     public void testGetSliceFromLarge() throws Throwable
0:     {
0:         Table table = Table.open(TABLE_NAME);
0:         String ROW = "row3";
0:         RowMutation rm = new RowMutation(TABLE_NAME, ROW);
0:         ColumnFamily cf = new ColumnFamily("Standard1", "Standard");
0:         for (int i = 1000; i < 2000; i++)
0:             cf.addColumn(new Column("col" + i, ("vvvvvvvvvvvvvvvv" + i).getBytes(), 1L));
0:         rm.add(cf);
0:         rm.apply();
0:         // flush to disk
0:         table.getColumnFamilyStore("Standard1").forceBlockingFlush();
0: 
0:         Row result;
0:         ColumnFamily cfres;
0:         result = table.getSliceFrom(ROW, "Standard1:col1000", true, 3);
0:         cfres = result.getColumnFamily("Standard1");
0:         assertColumns(cfres, "col1000", "col1001", "col1002");
0:         assertEquals(new String(cfres.getColumn("col1000").value()), "vvvvvvvvvvvvvvvv1000");
0:         assertEquals(new String(cfres.getColumn("col1001").value()), "vvvvvvvvvvvvvvvv1001");
0:         assertEquals(new String(cfres.getColumn("col1002").value()), "vvvvvvvvvvvvvvvv1002");
0: 
0:         result = table.getSliceFrom(ROW, "Standard1:col1195", true, 3);
0:         cfres = result.getColumnFamily("Standard1");
0:         assertColumns(cfres, "col1195", "col1196", "col1197");
0:         assertEquals(new String(cfres.getColumn("col1195").value()), "vvvvvvvvvvvvvvvv1195");
0:         assertEquals(new String(cfres.getColumn("col1196").value()), "vvvvvvvvvvvvvvvv1196");
0:         assertEquals(new String(cfres.getColumn("col1197").value()), "vvvvvvvvvvvvvvvv1197");
0: 
0:         result = table.getSliceFrom(ROW, "Standard1:col1196", false, 3);
0:         cfres = result.getColumnFamily("Standard1");
0:         assertColumns(cfres, "col1194", "col1195", "col1196");
0:         assertEquals(new String(cfres.getColumn("col1194").value()), "vvvvvvvvvvvvvvvv1194");
0:         assertEquals(new String(cfres.getColumn("col1195").value()), "vvvvvvvvvvvvvvvv1195");
0:         assertEquals(new String(cfres.getColumn("col1196").value()), "vvvvvvvvvvvvvvvv1196");
0: 
0:         result = table.getSliceFrom(ROW, "Standard1:col1990", true, 3);
0:         cfres = result.getColumnFamily("Standard1");
0:         assertColumns(cfres, "col1990", "col1991", "col1992");
0:         assertEquals(new String(cfres.getColumn("col1990").value()), "vvvvvvvvvvvvvvvv1990");
0:         assertEquals(new String(cfres.getColumn("col1991").value()), "vvvvvvvvvvvvvvvv1991");
0:         assertEquals(new String(cfres.getColumn("col1992").value()), "vvvvvvvvvvvvvvvv1992");
0:     }
0: 
commit:4ac9118
/////////////////////////////////////////////////////////////////////////
0: import java.util.SortedSet;
0: import java.util.Arrays;
0: import java.util.List;
0: import java.util.ArrayList;
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:     @Test
0:     public void testGetSliceFromBasic() throws Throwable
0:     {
0:         Table table = Table.open(TABLE_NAME);
0:         String ROW = "row1";
0:         RowMutation rm = new RowMutation(TABLE_NAME, ROW);
0:         ColumnFamily cf = new ColumnFamily("Standard1", "Standard");
0:         cf.addColumn(new Column("col1", "val1".getBytes(), 1L));
0:         cf.addColumn(new Column("col3", "val3".getBytes(), 1L));
0:         cf.addColumn(new Column("col4", "val4".getBytes(), 1L));
0:         cf.addColumn(new Column("col5", "val5".getBytes(), 1L));
0:         cf.addColumn(new Column("col7", "val7".getBytes(), 1L));
0:         cf.addColumn(new Column("col9", "val9".getBytes(), 1L));
0:         rm.add(cf);
0:         rm.apply();
0:         
0:         rm = new RowMutation(TABLE_NAME, ROW);
0:         rm.delete("Standard1:col4", 2L);
0:         rm.apply();
0:         validateGetSliceFromBasic(table, ROW);
0:         
0:         // flush to disk
0:         table.getColumnFamilyStore("Standard1").forceBlockingFlush();
0:         validateGetSliceFromBasic(table, ROW);        
0:     }
0: 
0:     @Test
0:     public void testGetSliceFromAdvanced() throws Throwable
0:     {
0:         Table table = Table.open(TABLE_NAME);
0:         String ROW = "row2";
0:         RowMutation rm = new RowMutation(TABLE_NAME, ROW);
0:         ColumnFamily cf = new ColumnFamily("Standard1", "Standard");
0:         cf.addColumn(new Column("col1", "val1".getBytes(), 1L));
0:         cf.addColumn(new Column("col2", "val2".getBytes(), 1L));
0:         cf.addColumn(new Column("col3", "val3".getBytes(), 1L));
0:         cf.addColumn(new Column("col4", "val4".getBytes(), 1L));
0:         cf.addColumn(new Column("col5", "val5".getBytes(), 1L));
0:         cf.addColumn(new Column("col6", "val6".getBytes(), 1L));
0:         rm.add(cf);
0:         rm.apply();
0:         // flush to disk
0:         table.getColumnFamilyStore("Standard1").forceBlockingFlush();
0:         
0:         rm = new RowMutation(TABLE_NAME, ROW);
0:         cf = new ColumnFamily("Standard1", "Standard");
0:         cf.addColumn(new Column("col1", "valx".getBytes(), 2L));
0:         cf.addColumn(new Column("col2", "valx".getBytes(), 2L));
0:         cf.addColumn(new Column("col3", "valx".getBytes(), 2L));
0:         rm.add(cf);
0:         rm.apply();
0:         validateGetSliceFromAdvanced(table, ROW);
0:         
0:         // flush to disk
0:         table.getColumnFamilyStore("Standard1").forceBlockingFlush();
0:         validateGetSliceFromAdvanced(table, ROW);
0:     }
0: 
0:     private void assertColumns(ColumnFamily columnFamily, String... columnFamilyNames)
0:     {
0:         assertNotNull(columnFamily);
0:         SortedSet<IColumn> columns = columnFamily.getAllColumns();
0:         List<String> L = new ArrayList<String>();
0:         for (IColumn column : columns)
0:         {
0:             L.add(column.name());
0:         }
0:         assert Arrays.equals(L.toArray(new String[columns.size()]), columnFamilyNames);
0:     }
0: 
0:     private void validateGetSliceFromAdvanced(Table table, String row) throws Throwable
0:     {
0:         Row result;
0:         ColumnFamily cfres;
0: 
0:         result = table.getSliceFrom(row, "Standard1:col2", true, 3);
0:         cfres = result.getColumnFamily("Standard1");
0:         assertColumns(cfres, "col2", "col3", "col4");
0:         assertEquals(new String(cfres.getColumn("col2").value()), "valx");
0:         assertEquals(new String(cfres.getColumn("col3").value()), "valx");
0:         assertEquals(new String(cfres.getColumn("col4").value()), "val4");        
0:     }
0: 
0:     private void validateGetSliceFromBasic(Table table, String row) throws Throwable
0:     {
0:         Row result;
0:         ColumnFamily cf;
0: 
0:         result = table.getSliceFrom(row, "Standard1:col5", true, 2);
0:         cf = result.getColumnFamily("Standard1");
0:         assertColumns(cf, "col5", "col7");
0: 
0:         result = table.getSliceFrom(row, "Standard1:col4", true, 2);
0:         cf = result.getColumnFamily("Standard1");
0:         assertColumns(cf, "col4", "col5", "col7");
0: 
0:         result = table.getSliceFrom(row, "Standard1:col5", false, 2);
0:         cf = result.getColumnFamily("Standard1");
0:         assertColumns(cf, "col3", "col4", "col5");
0: 
0:         result = table.getSliceFrom(row, "Standard1:col6", false, 2);
0:         cf = result.getColumnFamily("Standard1");
0:         assertColumns(cf, "col3", "col4", "col5");
0: 
0:         result = table.getSliceFrom(row, "Standard1:col95", true, 2);
0:         cf = result.getColumnFamily("Standard1");
0:         assertColumns(cf);
0: 
0:         result = table.getSliceFrom(row, "Standard1:col0", false, 2);
0:         cf = result.getColumnFamily("Standard1");
0:         assertColumns(cf);
0:     }
commit:20f7d03
/////////////////////////////////////////////////////////////////////////
0:     public void testGetRowSliceByRange() throws Throwable
0:     {
0:     	String key = TEST_KEY+"slicerow";
0:     	Table table = Table.open(TABLE_NAME);
0:     	RowMutation rm = new RowMutation(TABLE_NAME,key);
0:         ColumnFamily cf = new ColumnFamily("Standard1","Standard");
0:         // First write "a", "b", "c"
0:         cf.addColumn(new Column("a", "val1".getBytes(), 1L));
0:         cf.addColumn(new Column("b", "val2".getBytes(), 1L));
0:         cf.addColumn(new Column("c", "val3".getBytes(), 1L));
0:         rm.add(cf);
0:         rm.apply();
0:         
0:         Row result = table.getRow(key, "Standard1", "b", "c",-1);
0:         assertEquals(2, result.getColumnFamily("Standard1").getColumnCount());
0:         
0:         result = table.getRow(key, "Standard1", "b", "b", 50);
0:         assertEquals(1, result.getColumnFamily("Standard1").getColumnCount());
0:         
0:         result = table.getRow(key, "Standard1", "b", "c",1);
0:         assertEquals(1, result.getColumnFamily("Standard1").getColumnCount());
0:         
0:         result = table.getRow(key, "Standard1", "c", "b",1);
0:         assertEquals(0, result.getColumnFamily("Standard1").getColumnCount());
0:         
0:     }
0:     
0:     @Test
commit:97fc5cb
/////////////////////////////////////////////////////////////////////////
0: import org.junit.Test;
0: import static junit.framework.Assert.*;
0: import org.apache.cassandra.CleanupHelper;
0: 
0: public class TableTest extends CleanupHelper
0: {
commit:362f287
/////////////////////////////////////////////////////////////////////////
0:         sc1.addColumn(new Column("col1","val1".getBytes(), 1L));
0:         sc1.addColumn(new Column("col2","val2".getBytes(), 1L));
0:         sc2.addColumn(new Column("col3","val3".getBytes(), 1L));
0:         sc2.addColumn(new Column("col4","val4".getBytes(), 1L));
commit:afd3c27
commit:3c6fcf8
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: 
0: package org.apache.cassandra.db;
0: 
0: import org.apache.cassandra.ServerTest;
0: import org.testng.annotations.Test;
0: import static org.testng.Assert.*;
0: 
0: public class TableTest extends ServerTest{
0:     private static final String KEY2 = "key2";
0:     private static final String TEST_KEY = "key1";
0:     private static final String TABLE_NAME = "Table1";
0: 
0:     @Test
0:     public void testOpen() throws Throwable {
0:         Table table = Table.open("Mailbox");
0:         Row row = table.get("35300190:1");
0:         assertNotNull(row);
0:     }
0:     
0:     @Test
0:     public void testGetRowSingleColumn() throws Throwable
0:     {
0:         Table table = Table.open(TABLE_NAME);
0:         RowMutation rm = makeSimpleRowMutation();
0:         rm.apply();
0:         Row result = table.getRow(TEST_KEY, "Standard1:col1");
0:         ColumnFamily cres = result.getColumnFamily("Standard1");
0:         assertNotNull(cres);
0:         assertEquals(1, cres.getColumnCount());
0:         assertNotNull(cres.getColumn("col1"));
0:     }
0:     
0:     @Test
0:     public void testGetRowOffsetCount() throws Throwable
0:     {
0:         Table table = Table.open(TABLE_NAME);
0:         
0:         RowMutation rm = makeSimpleRowMutation(); //inserts col1, col2, col3
0: 
0:         
0:         rm.apply();
0:         Row result = table.getRow(TEST_KEY, "Standard1", 0, 2);
0:         ColumnFamily cres = result.getColumnFamily("Standard1");
0:         assertNotNull(cres);
0:         assertEquals(cres.getColumnCount(), 2);
0:         // should have col1 and col2
0:         assertNotNull(cres.getColumn("col1"));
0:         assertNotNull(cres.getColumn("col2"));
0: 
0:         result = table.getRow(TEST_KEY, "Standard1", 1, 2);
0:         cres = result.getColumnFamily("Standard1");
0:         assertNotNull(cres);
0:         assertEquals(2, cres.getColumnCount());
0:         // offset is 1, so we should have col2 and col3
0:         assertNotNull(cres.getColumn("col2"));
0:         assertNotNull(cres.getColumn("col3"));
0:     }
0:     
0:     @Test
0:     public void testGetRowOffsetCountFromDisk() throws Throwable
0:     {
0:         Table table = Table.open("Table1");
0:         
0:         RowMutation rm = new RowMutation(TABLE_NAME,KEY2);
0:         ColumnFamily cf = new ColumnFamily("Standard1","Standard");
0:         // First write 5, 6
0:         cf.addColumn(new Column("col5", "val5".getBytes(), 1L));
0:         cf.addColumn(new Column("col6", "val6".getBytes(), 1L));
0:         rm.add(cf);
0: 
0:         rm.apply();
0:         Row result = table.getRow(KEY2, "Standard1:col5");
0:         ColumnFamily cres = result.getColumnFamily("Standard1");
0:         assertNotNull(cres.getColumn("col5"));
0: 
0:         table.getColumnFamilyStore("Standard1").forceBlockingFlush();
0:         // Flushed memtable to disk, we're now inserting into a new memtable
0: 
0:         rm = new RowMutation(TABLE_NAME, KEY2);
0:         cf = new ColumnFamily("Standard1","Standard");
0:         // now write 7, 8, 4 into new memtable
0:         cf.addColumn(new Column("col7", "val7".getBytes(), 1L));
0:         cf.addColumn(new Column("col8", "val8".getBytes(), 1L));
0:         cf.addColumn(new Column("col4", "val4".getBytes(), 1L));
0:         rm.add(cf);
0:         rm.apply();
0: 
0:         // Check col5 is still around
0:         result = table.getRow(KEY2, "Standard1:col5");
0:         cres = result.getColumnFamily("Standard1");
0:         assertNotNull(cres.getColumn("col5"));
0: 
0:         // Read back 3 cols from start -- should see 4,5,6 NOT 4,7,8
0:         result = table.getRow(KEY2, "Standard1", 0, 3);
0:         cres = result.getColumnFamily("Standard1");
0:         assertNotNull(cres);
0:         assertEquals(cres.getColumnCount(), 3);
0: 
0:         // Should have col4, col5, and col6
0:         assertNotNull(cres.getColumn("col4"));
0:         assertNotNull(cres.getColumn("col5"));
0:         assertNotNull(cres.getColumn("col6"));
0:         // not 8
0:         assertNull(cres.getColumn("col8"));
0:     }
0:     
0:     @Test
0:     public void testGetRowSuperColumnOffsetCount() throws Throwable
0:     {
0:         Table table = Table.open(TABLE_NAME);
0:         
0:         RowMutation rm = new RowMutation(TABLE_NAME,TEST_KEY);
0:         ColumnFamily cf = new ColumnFamily("Super1","Super");
0:         SuperColumn sc1 = new SuperColumn("sc1");
0:         sc1.addColumn("col1", new Column("col1","val1".getBytes(), 1L));
0:         sc1.addColumn("col2", new Column("col2","val2".getBytes(), 1L));
0:         SuperColumn sc2 = new SuperColumn("sc2");
0:         sc2.addColumn("col3", new Column("col3","val3".getBytes(), 1L));
0:         sc2.addColumn("col4", new Column("col4","val4".getBytes(), 1L));
0:         cf.addColumn(sc1);
0:         cf.addColumn(sc2);
0:         rm.add(cf);
0:         
0:         rm.apply();
0:         //Slicing top level columns of a supercolumn
0:         Row result = table.getRow(TEST_KEY, "Super1", 0, 2);
0:         ColumnFamily cres = result.getColumnFamily("Super1");
0:         assertNotNull(cres);
0:         assertEquals(cres.getAllColumns().size(), 2); //2 supercolumns
0:         assertEquals(cres.getColumnCount(),2+4); //2 cols, 2 subcols each
0:         // should have col1 ... col4
0:         assertNotNull(cres.getColumn("sc1").getSubColumn("col1"));
0:         assertNotNull(cres.getColumn("sc1").getSubColumn("col2"));
0:         assertNotNull(cres.getColumn("sc2").getSubColumn("col3"));
0:         assertNotNull(cres.getColumn("sc2").getSubColumn("col4"));
0: 
0:         
0:         result = table.getRow(TEST_KEY, "Super1:sc1", 1, 2); //get at most 2, but only 1 column will be available
0:         cres = result.getColumnFamily("Super1");
0:         assertNotNull(cres);
0:         assertEquals(cres.getAllColumns().size(), 1); //only 1 top level column. sc1 has only 2 subcolumns
0:         assertEquals(cres.getColumnCount(), 2); //getObjectCount: 1 for the column, and 1 for subcolumn
0:         
0:         assertNotNull(cres.getColumn("sc1").getSubColumn("col2"));
0:         assertNull(cres.getColumn("sc2"));       
0:     }
0: 
0:     private RowMutation makeSimpleRowMutation()
0:     {
0:         RowMutation rm = new RowMutation(TABLE_NAME,TEST_KEY);
0:         ColumnFamily cf = new ColumnFamily("Standard1","Standard");
0:         cf.addColumn(new Column("col1","val1".getBytes(), 1L));
0:         cf.addColumn(new Column("col2","val2".getBytes(), 1L));
0:         cf.addColumn(new Column("col3","val3".getBytes(), 1L));
0:         rm.add(cf);
0:         return rm;
0:     }
0: }
commit:7e648c8
/////////////////////////////////////////////////////////////////////////
0: package org.apache.cassandra.db;
0: 
0: import org.testng.annotations.Test;
0: 
0: import java.io.IOException;
0: 
0: import org.apache.cassandra.service.StorageService;
0: 
0: public class TableTest {
0:     @Test
0:     public void testOpen() throws Throwable {
0:         Table table = Table.open("Mailbox");
0:         Row row = table.get("35300190:1");
0:     }
0: }
commit:7a6f421
/////////////////////////////////////////////////////////////////////////
commit:a996c82
/////////////////////////////////////////////////////////////////////////
0: package org.apache.cassandra.db;
0: 
0: import org.testng.annotations.Test;
0: 
0: import java.io.IOException;
0: 
0: import org.apache.cassandra.service.StorageService;
0: 
0: public class TableTest {
0:     @Test
0:     public void testOpen() throws Throwable {
0:         Table table = Table.open("Mailbox");
0:         Row row = table.get("35300190:1");
0:     }
0: }
author:Yuki Morishita
-------------------------------------------------------------------------------
commit:dda7aee
/////////////////////////////////////////////////////////////////////////
0:         cf.addColumn(expiringColumn("col2", "val2", 1L, 60)); // long enough not to be tombstoned
commit:8801883
/////////////////////////////////////////////////////////////////////////
0:         cf.addColumn(expiringColumn("col2", "val2", 1L, 60)); // long enough not to be tombstoned
author:Johan Oskarsson
-------------------------------------------------------------------------------
commit:7860b13
/////////////////////////////////////////////////////////////////////////
0:         SuperColumn sc = new SuperColumn("sc1".getBytes(), LongType.instance, ClockType.Timestamp, null);
author:Gary Dusbabek
-------------------------------------------------------------------------------
commit:434564d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.Util;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.cassandra.utils.FBUtilities;
0:     private static final DecoratedKey KEY2 = Util.dk("key2");
0:     private static final DecoratedKey TEST_KEY = Util.dk("key1");
0:     private static final DecoratedKey TEST_SLICE_KEY = Util.dk("key1-slicerange");
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace2", TEST_KEY.key);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", TEST_KEY.key);
/////////////////////////////////////////////////////////////////////////
0:     	DecoratedKey key = TEST_SLICE_KEY;
0:     	RowMutation rm = new RowMutation("Keyspace1", key.key);
/////////////////////////////////////////////////////////////////////////
0:         RowMutation rm = new RowMutation("Keyspace1", "row1000".getBytes());
/////////////////////////////////////////////////////////////////////////
0:         final DecoratedKey ROW = Util.dk("row4");
0:         RowMutation rm = new RowMutation("Keyspace1", ROW.key);
/////////////////////////////////////////////////////////////////////////
0:         final DecoratedKey ROW = Util.dk("row-bitmasktest");
0:         RowMutation rm = new RowMutation("Keyspace1", ROW.key);
/////////////////////////////////////////////////////////////////////////
0:         cf = cfStore.getColumnFamily(Util.dk("a"), new QueryPath("Standard2"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, false, 1);
0:         cf = cfStore.getColumnFamily(Util.dk("z"), new QueryPath("Standard2"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, false, 1);
/////////////////////////////////////////////////////////////////////////
0:         final DecoratedKey ROW = Util.dk("row1");
0:         RowMutation rm = new RowMutation("Keyspace1", ROW.key);
/////////////////////////////////////////////////////////////////////////
0:         rm = new RowMutation("Keyspace1", ROW.key);
/////////////////////////////////////////////////////////////////////////
0:         final DecoratedKey ROW = Util.dk("row2");
0:         RowMutation rm = new RowMutation("Keyspace1", ROW.key);
/////////////////////////////////////////////////////////////////////////
0:         rm = new RowMutation("Keyspace1", ROW.key);
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey key = Util.dk("row3");
0:         RowMutation rm = new RowMutation("Keyspace1", key.key);
/////////////////////////////////////////////////////////////////////////
0:         SSTable.PositionSize info = sstable.getPosition(key);
0:         assert Arrays.equals(FBUtilities.readShortByteArray(file), key.key);
/////////////////////////////////////////////////////////////////////////
0:         DecoratedKey key = Util.dk("row3");
/////////////////////////////////////////////////////////////////////////
0:         final DecoratedKey ROW = Util.dk("row2");
0:         RowMutation rm = new RowMutation("Keyspace1", ROW.key);
============================================================================