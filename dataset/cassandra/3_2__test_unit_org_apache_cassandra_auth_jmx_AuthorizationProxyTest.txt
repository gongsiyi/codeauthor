1:7b0c716: /*
1:7b0c716:  * Licensed to the Apache Software Foundation (ASF) under one
1:7b0c716:  * or more contributor license agreements.  See the NOTICE file
1:7b0c716:  * distributed with this work for additional information
1:7b0c716:  * regarding copyright ownership.  The ASF licenses this file
1:7b0c716:  * to you under the Apache License, Version 2.0 (the
1:7b0c716:  * "License"); you may not use this file except in compliance
1:7b0c716:  * with the License.  You may obtain a copy of the License at
1:7b0c716:  *
1:7b0c716:  *     http://www.apache.org/licenses/LICENSE-2.0
1:7b0c716:  *
1:7b0c716:  * Unless required by applicable law or agreed to in writing, software
1:7b0c716:  * distributed under the License is distributed on an "AS IS" BASIS,
1:7b0c716:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7b0c716:  * See the License for the specific language governing permissions and
1:7b0c716:  * limitations under the License.
1:7b0c716:  */
1:7b0c716: 
1:7b0c716: package org.apache.cassandra.auth.jmx;
1:7b0c716: 
1:7b0c716: import java.util.*;
1:7b0c716: import java.util.concurrent.atomic.AtomicBoolean;
1:7b0c716: import java.util.function.Function;
1:7b0c716: import java.util.function.Supplier;
1:7b0c716: import java.util.stream.Collectors;
1:7b0c716: import javax.management.MalformedObjectNameException;
1:7b0c716: import javax.management.ObjectName;
1:7b0c716: import javax.security.auth.Subject;
1:7b0c716: 
1:7b0c716: import com.google.common.collect.ImmutableMap;
1:7b0c716: import com.google.common.collect.ImmutableSet;
1:9797511: import org.junit.BeforeClass;
1:7b0c716: import org.junit.Test;
1:7b0c716: 
1:7b0c716: import org.apache.cassandra.auth.*;
1:9797511: import org.apache.cassandra.config.DatabaseDescriptor;
1:7b0c716: 
1:7b0c716: import static org.junit.Assert.assertEquals;
1:7b0c716: import static org.junit.Assert.assertFalse;
1:7b0c716: import static org.junit.Assert.assertTrue;
1:7b0c716: import static org.junit.Assert.fail;
1:7b0c716: 
1:7b0c716: public class AuthorizationProxyTest
1:7b0c716: {
1:9797511:     @BeforeClass
1:9797511:     public static void setup() throws Exception
1:9797511:     {
1:9797511:         DatabaseDescriptor.daemonInitialization();
1:9797511:     }
1:9797511: 
1:7b0c716:     JMXResource osBean = JMXResource.mbean("java.lang:type=OperatingSystem");
1:7b0c716:     JMXResource runtimeBean = JMXResource.mbean("java.lang:type=Runtime");
1:7b0c716:     JMXResource threadingBean = JMXResource.mbean("java.lang:type=Threading");
1:7b0c716:     JMXResource javaLangWildcard = JMXResource.mbean("java.lang:type=*");
1:7b0c716: 
1:7b0c716:     JMXResource hintsBean = JMXResource.mbean("org.apache.cassandra.hints:type=HintsService");
1:7b0c716:     JMXResource batchlogBean = JMXResource.mbean("org.apache.cassandra.db:type=BatchlogManager");
1:7b0c716:     JMXResource customBean = JMXResource.mbean("org.apache.cassandra:type=CustomBean,property=foo");
1:7b0c716:     Set<ObjectName> allBeans = objectNames(osBean, runtimeBean, threadingBean, hintsBean, batchlogBean, customBean);
1:7b0c716: 
1:7b0c716:     RoleResource role1 = RoleResource.role("r1");
1:7b0c716: 
1:7b0c716:     @Test
1:7b0c716:     public void roleHasRequiredPermission() throws Throwable
1:7b0c716:     {
1:7b0c716:         Map<RoleResource, Set<PermissionDetails>> permissions =
1:7b0c716:             ImmutableMap.of(role1, Collections.singleton(permission(role1, osBean, Permission.SELECT)));
1:7b0c716: 
1:7b0c716:         AuthorizationProxy proxy = new ProxyBuilder().isSuperuser((role) -> false)
1:7b0c716:                                                      .getPermissions(permissions::get)
1:7b0c716:                                                      .isAuthzRequired(() -> true)
1:7b0c716:                                                      .build();
1:7b0c716: 
1:7b0c716:         assertTrue(proxy.authorize(subject(role1.getRoleName()),
1:7b0c716:                                    "getAttribute",
1:7b0c716:                                    new Object[]{ objectName(osBean), "arch" }));
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     @Test
1:7b0c716:     public void roleDoesNotHaveRequiredPermission() throws Throwable
1:7b0c716:     {
1:7b0c716:         Map<RoleResource, Set<PermissionDetails>> permissions =
1:7b0c716:             ImmutableMap.of(role1, Collections.singleton(permission(role1, osBean, Permission.AUTHORIZE)));
1:7b0c716: 
1:7b0c716:         AuthorizationProxy proxy = new ProxyBuilder().isSuperuser((role) -> false)
1:7b0c716:                                                      .getPermissions(permissions::get)
1:7b0c716:                                                      .isAuthzRequired(() -> true).build();
1:7b0c716: 
1:7b0c716:         assertFalse(proxy.authorize(subject(role1.getRoleName()),
1:7b0c716:                                     "setAttribute",
1:7b0c716:                                     new Object[]{ objectName(osBean), "arch" }));
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     @Test
1:7b0c716:     public void roleHasRequiredPermissionOnRootResource() throws Throwable
1:7b0c716:     {
1:7b0c716:         Map<RoleResource, Set<PermissionDetails>> permissions =
1:7b0c716:             ImmutableMap.of(role1, Collections.singleton(permission(role1, JMXResource.root(), Permission.SELECT)));
1:7b0c716: 
1:7b0c716:         AuthorizationProxy proxy = new ProxyBuilder().isSuperuser((role) -> false)
1:7b0c716:                                                      .getPermissions(permissions::get)
1:7b0c716:                                                      .isAuthzRequired(() -> true)
1:7b0c716:                                                      .build();
1:7b0c716: 
1:7b0c716:         assertTrue(proxy.authorize(subject(role1.getRoleName()),
1:7b0c716:                                    "getAttribute",
1:7b0c716:                                    new Object[]{ objectName(osBean), "arch" }));
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     @Test
1:7b0c716:     public void roleHasOtherPermissionOnRootResource() throws Throwable
1:7b0c716:     {
1:7b0c716:         Map<RoleResource, Set<PermissionDetails>> permissions =
1:7b0c716:             ImmutableMap.of(role1, Collections.singleton(permission(role1, JMXResource.root(), Permission.AUTHORIZE)));
1:7b0c716: 
1:7b0c716:         AuthorizationProxy proxy = new ProxyBuilder().isSuperuser((role) -> false)
1:7b0c716:                                                      .getPermissions(permissions::get)
1:7b0c716:                                                      .isAuthzRequired(() -> true)
1:7b0c716:                                                      .build();
1:7b0c716: 
1:7b0c716:         assertFalse(proxy.authorize(subject(role1.getRoleName()),
1:7b0c716:                                     "invoke",
1:7b0c716:                                     new Object[]{ objectName(osBean), "bogusMethod" }));
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     @Test
1:7b0c716:     public void roleHasNoPermissions() throws Throwable
1:7b0c716:     {
1:7b0c716:         AuthorizationProxy proxy = new ProxyBuilder().isSuperuser((role) -> false)
1:7b0c716:                                                      .getPermissions((role) -> Collections.emptySet())
1:7b0c716:                                                      .isAuthzRequired(() -> true)
1:7b0c716:                                                      .build();
1:7b0c716: 
1:7b0c716:         assertFalse(proxy.authorize(subject(role1.getRoleName()),
1:7b0c716:                                     "getAttribute",
1:7b0c716:                                     new Object[]{ objectName(osBean), "arch" }));
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     @Test
1:7b0c716:     public void roleHasNoPermissionsButIsSuperuser() throws Throwable
1:7b0c716:     {
1:7b0c716:         AuthorizationProxy proxy = new ProxyBuilder().isSuperuser((role) -> true)
1:7b0c716:                                                      .getPermissions((role) -> Collections.emptySet())
1:7b0c716:                                                      .isAuthzRequired(() -> true)
1:7b0c716:                                                      .build();
1:7b0c716: 
1:7b0c716:         assertTrue(proxy.authorize(subject(role1.getRoleName()),
1:7b0c716:                                    "getAttribute",
1:7b0c716:                                    new Object[]{ objectName(osBean), "arch" }));
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     @Test
1:7b0c716:     public void roleHasNoPermissionsButAuthzNotRequired() throws Throwable
1:7b0c716:     {
1:7b0c716:         AuthorizationProxy proxy = new ProxyBuilder().isSuperuser((role) -> false)
1:7b0c716:                                                      .getPermissions((role) -> Collections.emptySet())
1:7b0c716:                                                      .isAuthzRequired(() -> false)
1:7b0c716:                                                      .build();
1:7b0c716: 
1:7b0c716:         assertTrue(proxy.authorize(subject(role1.getRoleName()),
1:7b0c716:                                    "getAttribute",
1:7b0c716:                                    new Object[]{ objectName(osBean), "arch" }));
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     @Test
1:7b0c716:     public void authorizeWhenSubjectIsNull() throws Throwable
1:7b0c716:     {
1:7b0c716:         // a null subject indicates that the action is being performed by the
1:7b0c716:         // connector itself, so we always authorize it
1:7b0c716:         // Verify that the superuser status is never tested as the request returns early
1:7b0c716:         // due to the null Subject
1:7b0c716:         // Also, hardcode the permissions provider to return an empty set, so we know that
1:7b0c716:         // can be doubly sure that it's the null Subject which causes the authz to succeed
1:7b0c716:         final AtomicBoolean suStatusChecked = new AtomicBoolean(false);
1:7b0c716:         AuthorizationProxy proxy = new ProxyBuilder().getPermissions((role) -> Collections.emptySet())
1:7b0c716:                                                      .isAuthzRequired(() -> true)
1:7b0c716:                                                      .isSuperuser((role) ->
1:7b0c716:                                                                   {
1:7b0c716:                                                                       suStatusChecked.set(true);
1:7b0c716:                                                                       return false;
1:7b0c716:                                                                   })
1:7b0c716:                                                      .build();
1:7b0c716: 
1:7b0c716:         assertTrue(proxy.authorize(null,
1:7b0c716:                                    "getAttribute",
1:7b0c716:                                    new Object[]{ objectName(osBean), "arch" }));
1:7b0c716:         assertFalse(suStatusChecked.get());
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     @Test
1:7b0c716:     public void rejectWhenSubjectNotAuthenticated() throws Throwable
1:7b0c716:     {
1:7b0c716:         // Access is denied to a Subject without any associated Principals
1:7b0c716:         // Verify that the superuser status is never tested as the request is rejected early
1:7b0c716:         // due to the Subject
1:7b0c716:         final AtomicBoolean suStatusChecked = new AtomicBoolean(false);
1:7b0c716:         AuthorizationProxy proxy = new ProxyBuilder().isAuthzRequired(() -> true)
1:7b0c716:                                                      .isSuperuser((role) ->
1:7b0c716:                                                                   {
1:7b0c716:                                                                       suStatusChecked.set(true);
1:7b0c716:                                                                       return true;
1:7b0c716:                                                                   })
1:7b0c716:                                                      .build();
1:7b0c716:         assertFalse(proxy.authorize(new Subject(),
1:7b0c716:                                     "getAttribute",
1:7b0c716:                                     new Object[]{ objectName(osBean), "arch" }));
1:7b0c716:         assertFalse(suStatusChecked.get());
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     @Test
1:7b0c716:     public void authorizeWhenWildcardGrantCoversExactTarget() throws Throwable
1:7b0c716:     {
1:7b0c716:         Map<RoleResource, Set<PermissionDetails>> permissions =
1:7b0c716:             ImmutableMap.of(role1, Collections.singleton(permission(role1, javaLangWildcard, Permission.SELECT)));
1:7b0c716: 
1:7b0c716:         AuthorizationProxy proxy = new ProxyBuilder().isAuthzRequired(() -> true)
1:7b0c716:                                                      .isSuperuser((role) -> false)
1:7b0c716:                                                      .getPermissions(permissions::get)
1:7b0c716:                                                      .build();
1:7b0c716: 
1:7b0c716:         assertTrue(proxy.authorize(subject(role1.getRoleName()),
1:7b0c716:                                    "getAttribute",
1:7b0c716:                                    new Object[]{ objectName(osBean), "arch" }));
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     @Test
1:7b0c716:     public void rejectWhenWildcardGrantDoesNotCoverExactTarget() throws Throwable
1:7b0c716:     {
1:7b0c716:         Map<RoleResource, Set<PermissionDetails>> permissions =
1:7b0c716:             ImmutableMap.of(role1, Collections.singleton(permission(role1, javaLangWildcard, Permission.SELECT)));
1:7b0c716: 
1:7b0c716:         AuthorizationProxy proxy = new ProxyBuilder().isAuthzRequired(() -> true)
1:7b0c716:                                                      .isSuperuser((role) -> false)
1:7b0c716:                                                      .getPermissions(permissions::get)
1:7b0c716:                                                      .build();
1:7b0c716: 
1:7b0c716:         assertFalse(proxy.authorize(subject(role1.getRoleName()),
1:7b0c716:                                     "getAttribute",
1:7b0c716:                                     new Object[]{ objectName(customBean), "arch" }));
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     @Test
1:7b0c716:     public void authorizeWhenWildcardGrantCoversWildcardTarget() throws Throwable
1:7b0c716:     {
1:7b0c716:         Map<RoleResource, Set<PermissionDetails>> permissions =
1:7b0c716:             ImmutableMap.of(role1, Collections.singleton(permission(role1, javaLangWildcard, Permission.DESCRIBE)));
1:7b0c716: 
1:7b0c716:         AuthorizationProxy proxy = new ProxyBuilder().isAuthzRequired(() -> true)
1:7b0c716:                                                      .isSuperuser((role) -> false)
1:7b0c716:                                                      .getPermissions(permissions::get)
1:7b0c716:                                                      .queryNames(matcher(allBeans))
1:7b0c716:                                                      .build();
1:7b0c716: 
1:7b0c716:         assertTrue(proxy.authorize(subject(role1.getRoleName()),
1:7b0c716:                                    "queryNames",
1:7b0c716:                                    new Object[]{ objectName(javaLangWildcard), null }));
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     @Test
1:7b0c716:     public void rejectWhenWildcardGrantIsDisjointWithWildcardTarget() throws Throwable
1:7b0c716:     {
1:7b0c716:         JMXResource customWildcard = JMXResource.mbean("org.apache.cassandra:*");
1:7b0c716:         Map<RoleResource, Set<PermissionDetails>> permissions =
1:7b0c716:             ImmutableMap.of(role1, Collections.singleton(permission(role1, customWildcard, Permission.DESCRIBE)));
1:7b0c716: 
1:7b0c716:         AuthorizationProxy proxy = new ProxyBuilder().isAuthzRequired(() -> true)
1:7b0c716:                                                      .isSuperuser((role) -> false)
1:7b0c716:                                                      .getPermissions(permissions::get)
1:7b0c716:                                                      .queryNames(matcher(allBeans))
1:7b0c716:                                                      .build();
1:7b0c716: 
1:7b0c716:         // the grant on org.apache.cassandra:* shouldn't permit us to invoke queryNames with java.lang:*
1:7b0c716:         assertFalse(proxy.authorize(subject(role1.getRoleName()),
1:7b0c716:                                     "queryNames",
1:7b0c716:                                     new Object[]{ objectName(javaLangWildcard), null }));
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     @Test
1:7b0c716:     public void rejectWhenWildcardGrantIntersectsWithWildcardTarget() throws Throwable
1:7b0c716:     {
1:7b0c716:         // in this test, permissions are granted on org.apache.cassandra:type=CustomBean,property=*
1:7b0c716:         // and all beans in the org.apache.cassandra.hints domain, but
1:7b0c716:         // but the target of the invocation is org.apache.cassandra*:*
1:7b0c716:         // i.e. the subject has permissions on all CustomBeans and on the HintsService bean, but is
1:7b0c716:         // attempting to query all names in the org.apache.cassandra* domain. The operation should
1:7b0c716:         // be rejected as the permissions don't cover all known beans matching that domain, due to
1:7b0c716:         // the BatchLogManager bean.
1:7b0c716: 
1:7b0c716:         JMXResource allCustomBeans = JMXResource.mbean("org.apache.cassandra:type=CustomBean,property=*");
1:7b0c716:         JMXResource allHintsBeans = JMXResource.mbean("org.apache.cassandra.hints:*");
1:7b0c716:         ObjectName allCassandraBeans = ObjectName.getInstance("org.apache.cassandra*:*");
1:7b0c716: 
1:7b0c716:         Map<RoleResource, Set<PermissionDetails>> permissions =
1:7b0c716:             ImmutableMap.of(role1, ImmutableSet.of(permission(role1, allCustomBeans, Permission.DESCRIBE),
1:7b0c716:                                                    permission(role1, allHintsBeans, Permission.DESCRIBE)));
1:7b0c716: 
1:7b0c716:         AuthorizationProxy proxy = new ProxyBuilder().isAuthzRequired(() -> true)
1:7b0c716:                                                      .isSuperuser((role) -> false)
1:7b0c716:                                                      .getPermissions(permissions::get)
1:7b0c716:                                                      .queryNames(matcher(allBeans))
1:7b0c716:                                                      .build();
1:7b0c716: 
1:7b0c716:         // the grant on org.apache.cassandra:* shouldn't permit us to invoke queryNames with java.lang:*
1:7b0c716:         assertFalse(proxy.authorize(subject(role1.getRoleName()),
1:7b0c716:                                     "queryNames",
1:7b0c716:                                     new Object[]{ allCassandraBeans, null }));
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     @Test
1:7b0c716:     public void authorizeOnTargetWildcardWithPermissionOnRoot() throws Throwable
1:7b0c716:     {
1:7b0c716:         Map<RoleResource, Set<PermissionDetails>> permissions =
1:7b0c716:             ImmutableMap.of(role1, Collections.singleton(permission(role1, JMXResource.root(), Permission.SELECT)));
1:7b0c716: 
1:7b0c716:         AuthorizationProxy proxy = new ProxyBuilder().isAuthzRequired(() -> true)
1:7b0c716:                                                      .isSuperuser((role) -> false)
1:7b0c716:                                                      .getPermissions(permissions::get)
1:7b0c716:                                                      .build();
1:7b0c716: 
1:7b0c716:         assertTrue(proxy.authorize(subject(role1.getRoleName()),
1:7b0c716:                                    "getAttribute",
1:7b0c716:                                    new Object[]{ objectName(javaLangWildcard), "arch" }));
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     @Test
1:7b0c716:     public void rejectInvocationOfUnknownMethod() throws Throwable
1:7b0c716:     {
1:7b0c716:         // Grant ALL permissions on the root resource, so we know that it's
1:7b0c716:         // the unknown method that causes the authz rejection. Of course, this
1:7b0c716:         // isn't foolproof but it's something.
1:7b0c716:         Set<PermissionDetails> allPerms = Permission.ALL.stream()
1:7b0c716:                                                         .map(perm -> permission(role1, JMXResource.root(), perm))
1:7b0c716:                                                         .collect(Collectors.toSet());
1:7b0c716:         Map<RoleResource, Set<PermissionDetails>> permissions = ImmutableMap.of(role1, allPerms);
1:7b0c716:         AuthorizationProxy proxy = new ProxyBuilder().isAuthzRequired(() -> true)
1:7b0c716:                                                      .isSuperuser((role) -> false)
1:7b0c716:                                                      .getPermissions(permissions::get)
1:7b0c716:                                                      .build();
1:7b0c716: 
1:7b0c716:         assertFalse(proxy.authorize(subject(role1.getRoleName()),
1:7b0c716:                                     "unKnownMethod",
1:7b0c716:                                     new Object[] { ObjectName.getInstance(osBean.getObjectName()) }));
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     @Test
1:7b0c716:     public void rejectInvocationOfBlacklistedMethods() throws Throwable
1:7b0c716:     {
1:7b0c716:         String[] methods = { "createMBean",
1:7b0c716:                              "deserialize",
1:7b0c716:                              "getClassLoader",
1:7b0c716:                              "getClassLoaderFor",
1:7b0c716:                              "instantiate",
1:7b0c716:                              "registerMBean",
1:7b0c716:                              "unregisterMBean" };
1:7b0c716: 
1:7b0c716:         // Hardcode the superuser status check to return true, so any allowed method can be invoked.
1:7b0c716:         AuthorizationProxy proxy = new ProxyBuilder().isAuthzRequired(() -> true)
1:7b0c716:                                                      .isSuperuser((role) -> true)
1:7b0c716:                                                      .build();
1:7b0c716: 
1:7b0c716:         for (String method : methods)
1:7b0c716:             // the arguments array isn't significant, so it can just be empty
1:7b0c716:             assertFalse(proxy.authorize(subject(role1.getRoleName()), method, new Object[0]));
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     @Test
1:7b0c716:     public void authorizeMethodsWithoutMBeanArgumentIfPermissionsGranted() throws Throwable
1:7b0c716:     {
1:7b0c716:         // Certain methods on MBeanServer don't take an ObjectName as their first argument.
1:7b0c716:         // These methods are characterised by AuthorizationProxy as being concerned with
1:7b0c716:         // the MBeanServer itself, as opposed to a specific managed bean. Of these methods,
1:7b0c716:         // only those considered "descriptive" are allowed to be invoked by remote users.
1:7b0c716:         // These require the DESCRIBE permission on the root JMXResource.
1:7b0c716:         testNonMbeanMethods(true);
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     @Test
1:7b0c716:     public void rejectMethodsWithoutMBeanArgumentIfPermissionsNotGranted() throws Throwable
1:7b0c716:     {
1:7b0c716:         testNonMbeanMethods(false);
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     @Test
1:7b0c716:     public void rejectWhenAuthSetupIsNotComplete() throws Throwable
1:7b0c716:     {
1:7b0c716:         // IAuthorizer & IRoleManager should not be considered ready to use until
1:7b0c716:         // we know that auth setup has completed. So, even though the IAuthorizer
1:7b0c716:         // would theoretically grant access, the auth proxy should deny it if setup
1:7b0c716:         // hasn't finished.
1:7b0c716: 
1:7b0c716:         Map<RoleResource, Set<PermissionDetails>> permissions =
1:7b0c716:         ImmutableMap.of(role1, Collections.singleton(permission(role1, osBean, Permission.SELECT)));
1:7b0c716: 
1:7b0c716:         // verify that access is granted when setup is complete
1:7b0c716:         AuthorizationProxy proxy = new ProxyBuilder().isSuperuser((role) -> false)
1:7b0c716:                                                      .getPermissions(permissions::get)
1:7b0c716:                                                      .isAuthzRequired(() -> true)
1:7b0c716:                                                      .isAuthSetupComplete(() -> true)
1:7b0c716:                                                      .build();
1:7b0c716: 
1:7b0c716:         assertTrue(proxy.authorize(subject(role1.getRoleName()),
1:7b0c716:                                    "getAttribute",
1:7b0c716:                                    new Object[]{ objectName(osBean), "arch" }));
1:7b0c716: 
1:7b0c716:         // and denied when it isn't
1:7b0c716:         proxy = new ProxyBuilder().isSuperuser((role) -> false)
1:7b0c716:                                   .getPermissions(permissions::get)
1:7b0c716:                                   .isAuthzRequired(() -> true)
1:7b0c716:                                   .isAuthSetupComplete(() -> false)
1:7b0c716:                                   .build();
1:7b0c716: 
1:7b0c716:         assertFalse(proxy.authorize(subject(role1.getRoleName()),
1:7b0c716:                                    "getAttribute",
1:7b0c716:                                    new Object[]{ objectName(osBean), "arch" }));
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     private void testNonMbeanMethods(boolean withPermission)
1:7b0c716:     {
1:7b0c716:         String[] methods = { "getDefaultDomain",
1:7b0c716:                              "getDomains",
1:7b0c716:                              "getMBeanCount",
1:7b0c716:                              "hashCode",
1:7b0c716:                              "queryMBeans",
1:7b0c716:                              "queryNames",
1:7b0c716:                              "toString" };
1:7b0c716: 
1:7b0c716: 
1:7b0c716:         ProxyBuilder builder = new ProxyBuilder().isAuthzRequired(() -> true).isSuperuser((role) -> false);
1:7b0c716:         if (withPermission)
1:7b0c716:         {
1:7b0c716:             Map<RoleResource, Set<PermissionDetails>> permissions =
1:7b0c716:                 ImmutableMap.of(role1, ImmutableSet.of(permission(role1, JMXResource.root(), Permission.DESCRIBE)));
1:7b0c716:             builder.getPermissions(permissions::get);
1:7b0c716:         }
1:7b0c716:         else
1:7b0c716:         {
1:7b0c716:             builder.getPermissions((role) -> Collections.emptySet());
1:7b0c716:         }
1:7b0c716:         AuthorizationProxy proxy = builder.build();
1:7b0c716: 
1:7b0c716:         for (String method : methods)
1:7b0c716:             assertEquals(withPermission, proxy.authorize(subject(role1.getRoleName()), method, new Object[]{ null }));
1:7b0c716: 
1:7b0c716:         // non-whitelisted methods should be rejected regardless.
1:7b0c716:         // This isn't exactly comprehensive, but it's better than nothing
1:7b0c716:         String[] notAllowed = { "fooMethod", "barMethod", "bazMethod" };
1:7b0c716:         for (String method : notAllowed)
1:7b0c716:             assertFalse(proxy.authorize(subject(role1.getRoleName()), method, new Object[]{ null }));
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     // provides a simple matching function which can be substituted for the proxy's queryMBeans
1:7b0c716:     // utility (which by default just delegates to the MBeanServer)
1:7b0c716:     // This function just iterates over a supplied set of ObjectNames and filters out those
1:7b0c716:     // to which the target name *doesn't* apply
1:7b0c716:     private static Function<ObjectName, Set<ObjectName>> matcher(Set<ObjectName> allBeans)
1:7b0c716:     {
1:7b0c716:         return (target) -> allBeans.stream()
1:7b0c716:                                    .filter(target::apply)
1:7b0c716:                                    .collect(Collectors.toSet());
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     private static PermissionDetails permission(RoleResource grantee, IResource resource, Permission permission)
1:7b0c716:     {
1:7b0c716:         return new PermissionDetails(grantee.getRoleName(), resource, permission);
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     private static Subject subject(String roleName)
1:7b0c716:     {
1:7b0c716:         Subject subject = new Subject();
1:7b0c716:         subject.getPrincipals().add(new CassandraPrincipal(roleName));
1:7b0c716:         return subject;
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     private static ObjectName objectName(JMXResource resource) throws MalformedObjectNameException
1:7b0c716:     {
1:7b0c716:         return ObjectName.getInstance(resource.getObjectName());
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     private static Set<ObjectName> objectNames(JMXResource... resource)
1:7b0c716:     {
1:7b0c716:         Set<ObjectName> names = new HashSet<>();
1:7b0c716:         try
1:7b0c716:         {
1:7b0c716:             for (JMXResource r : resource)
1:7b0c716:                 names.add(objectName(r));
1:7b0c716:         }
1:7b0c716:         catch (MalformedObjectNameException e)
1:7b0c716:         {
1:7b0c716:             fail("JMXResource returned invalid object name: " + e.getMessage());
1:7b0c716:         }
1:7b0c716:         return names;
1:7b0c716:     }
1:7b0c716: 
1:7b0c716:     public static class ProxyBuilder
1:7b0c716:     {
1:7b0c716:         Function<RoleResource, Set<PermissionDetails>> getPermissions;
1:7b0c716:         Function<ObjectName, Set<ObjectName>> queryNames;
1:7b0c716:         Function<RoleResource, Boolean> isSuperuser;
1:7b0c716:         Supplier<Boolean> isAuthzRequired;
1:7b0c716:         Supplier<Boolean> isAuthSetupComplete = () -> true;
1:7b0c716: 
1:7b0c716:         AuthorizationProxy build()
1:7b0c716:         {
1:7b0c716:             InjectableAuthProxy proxy = new InjectableAuthProxy();
1:7b0c716: 
1:7b0c716:             if (getPermissions != null)
1:7b0c716:                 proxy.setGetPermissions(getPermissions);
1:7b0c716: 
1:7b0c716:             if (queryNames != null)
1:7b0c716:                 proxy.setQueryNames(queryNames);
1:7b0c716: 
1:7b0c716:             if (isSuperuser != null)
1:7b0c716:                 proxy.setIsSuperuser(isSuperuser);
1:7b0c716: 
1:7b0c716:             if (isAuthzRequired != null)
1:7b0c716:                 proxy.setIsAuthzRequired(isAuthzRequired);
1:7b0c716: 
1:7b0c716:             proxy.setIsAuthSetupComplete(isAuthSetupComplete);
1:7b0c716: 
1:7b0c716:             return proxy;
1:7b0c716:         }
1:7b0c716: 
1:7b0c716:         ProxyBuilder getPermissions(Function<RoleResource, Set<PermissionDetails>> f)
1:7b0c716:         {
1:7b0c716:             getPermissions = f;
1:7b0c716:             return this;
1:7b0c716:         }
1:7b0c716: 
1:7b0c716:         ProxyBuilder queryNames(Function<ObjectName, Set<ObjectName>> f)
1:7b0c716:         {
1:7b0c716:             queryNames = f;
1:7b0c716:             return this;
1:7b0c716:         }
1:7b0c716: 
1:7b0c716:         ProxyBuilder isSuperuser(Function<RoleResource, Boolean> f)
1:7b0c716:         {
1:7b0c716:             isSuperuser = f;
1:7b0c716:             return this;
1:7b0c716:         }
1:7b0c716: 
1:7b0c716:         ProxyBuilder isAuthzRequired(Supplier<Boolean> s)
1:7b0c716:         {
1:7b0c716:             isAuthzRequired = s;
1:7b0c716:             return this;
1:7b0c716:         }
1:7b0c716: 
1:7b0c716:         ProxyBuilder isAuthSetupComplete(Supplier<Boolean> s)
1:7b0c716:         {
1:7b0c716:             isAuthSetupComplete = s;
1:7b0c716:             return this;
1:7b0c716:         }
1:7b0c716: 
1:7b0c716:         private static class InjectableAuthProxy extends AuthorizationProxy
1:7b0c716:         {
1:7b0c716:             void setGetPermissions(Function<RoleResource, Set<PermissionDetails>> f)
1:7b0c716:             {
1:7b0c716:                 this.getPermissions = f;
1:7b0c716:             }
1:7b0c716: 
1:7b0c716:             void setQueryNames(Function<ObjectName, Set<ObjectName>> f)
1:7b0c716:             {
1:7b0c716:                 this.queryNames = f;
1:7b0c716:             }
1:7b0c716: 
1:7b0c716:             void setIsSuperuser(Function<RoleResource, Boolean> f)
1:7b0c716:             {
1:7b0c716:                 this.isSuperuser = f;
1:7b0c716:             }
1:7b0c716: 
1:7b0c716:             void setIsAuthzRequired(Supplier<Boolean> s)
1:7b0c716:             {
1:7b0c716:                 this.isAuthzRequired = s;
1:7b0c716:             }
1:7b0c716: 
1:7b0c716:             void setIsAuthSetupComplete(Supplier<Boolean> s)
1:7b0c716:             {
1:7b0c716:                 this.isAuthSetupComplete = s;
1:7b0c716:             }
1:7b0c716:         }
1:7b0c716:     }
1:7b0c716: }
============================================================================
author:Robert Stupp
-------------------------------------------------------------------------------
commit:9797511
/////////////////////////////////////////////////////////////////////////
1: import org.junit.BeforeClass;
1: import org.apache.cassandra.config.DatabaseDescriptor;
/////////////////////////////////////////////////////////////////////////
1:     @BeforeClass
1:     public static void setup() throws Exception
1:     {
1:         DatabaseDescriptor.daemonInitialization();
1:     }
1: 
author:Dave Brosius
-------------------------------------------------------------------------------
commit:087264f
/////////////////////////////////////////////////////////////////////////
author:Sam Tunnicliffe
-------------------------------------------------------------------------------
commit:7b0c716
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.cassandra.auth.jmx;
1: 
1: import java.util.*;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: import java.util.function.Function;
1: import java.util.function.Supplier;
1: import java.util.stream.Collectors;
1: import javax.management.MalformedObjectNameException;
1: import javax.management.ObjectName;
0: import javax.management.remote.JMXPrincipal;
1: import javax.security.auth.Subject;
1: 
1: import com.google.common.collect.ImmutableMap;
1: import com.google.common.collect.ImmutableSet;
1: import org.junit.Test;
1: 
1: import org.apache.cassandra.auth.*;
1: 
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertFalse;
1: import static org.junit.Assert.assertTrue;
1: import static org.junit.Assert.fail;
1: 
1: public class AuthorizationProxyTest
1: {
1:     JMXResource osBean = JMXResource.mbean("java.lang:type=OperatingSystem");
1:     JMXResource runtimeBean = JMXResource.mbean("java.lang:type=Runtime");
1:     JMXResource threadingBean = JMXResource.mbean("java.lang:type=Threading");
1:     JMXResource javaLangWildcard = JMXResource.mbean("java.lang:type=*");
1: 
1:     JMXResource hintsBean = JMXResource.mbean("org.apache.cassandra.hints:type=HintsService");
1:     JMXResource batchlogBean = JMXResource.mbean("org.apache.cassandra.db:type=BatchlogManager");
1:     JMXResource customBean = JMXResource.mbean("org.apache.cassandra:type=CustomBean,property=foo");
1:     Set<ObjectName> allBeans = objectNames(osBean, runtimeBean, threadingBean, hintsBean, batchlogBean, customBean);
1: 
1:     RoleResource role1 = RoleResource.role("r1");
1: 
1:     @Test
1:     public void roleHasRequiredPermission() throws Throwable
1:     {
1:         Map<RoleResource, Set<PermissionDetails>> permissions =
1:             ImmutableMap.of(role1, Collections.singleton(permission(role1, osBean, Permission.SELECT)));
1: 
1:         AuthorizationProxy proxy = new ProxyBuilder().isSuperuser((role) -> false)
1:                                                      .getPermissions(permissions::get)
1:                                                      .isAuthzRequired(() -> true)
1:                                                      .build();
1: 
1:         assertTrue(proxy.authorize(subject(role1.getRoleName()),
1:                                    "getAttribute",
1:                                    new Object[]{ objectName(osBean), "arch" }));
1:     }
1: 
1:     @Test
1:     public void roleDoesNotHaveRequiredPermission() throws Throwable
1:     {
1:         Map<RoleResource, Set<PermissionDetails>> permissions =
1:             ImmutableMap.of(role1, Collections.singleton(permission(role1, osBean, Permission.AUTHORIZE)));
1: 
1:         AuthorizationProxy proxy = new ProxyBuilder().isSuperuser((role) -> false)
1:                                                      .getPermissions(permissions::get)
1:                                                      .isAuthzRequired(() -> true).build();
1: 
1:         assertFalse(proxy.authorize(subject(role1.getRoleName()),
1:                                     "setAttribute",
1:                                     new Object[]{ objectName(osBean), "arch" }));
1:     }
1: 
1:     @Test
1:     public void roleHasRequiredPermissionOnRootResource() throws Throwable
1:     {
1:         Map<RoleResource, Set<PermissionDetails>> permissions =
1:             ImmutableMap.of(role1, Collections.singleton(permission(role1, JMXResource.root(), Permission.SELECT)));
1: 
1:         AuthorizationProxy proxy = new ProxyBuilder().isSuperuser((role) -> false)
1:                                                      .getPermissions(permissions::get)
1:                                                      .isAuthzRequired(() -> true)
1:                                                      .build();
1: 
1:         assertTrue(proxy.authorize(subject(role1.getRoleName()),
1:                                    "getAttribute",
1:                                    new Object[]{ objectName(osBean), "arch" }));
1:     }
1: 
1:     @Test
1:     public void roleHasOtherPermissionOnRootResource() throws Throwable
1:     {
1:         Map<RoleResource, Set<PermissionDetails>> permissions =
1:             ImmutableMap.of(role1, Collections.singleton(permission(role1, JMXResource.root(), Permission.AUTHORIZE)));
1: 
1:         AuthorizationProxy proxy = new ProxyBuilder().isSuperuser((role) -> false)
1:                                                      .getPermissions(permissions::get)
1:                                                      .isAuthzRequired(() -> true)
1:                                                      .build();
1: 
1:         assertFalse(proxy.authorize(subject(role1.getRoleName()),
1:                                     "invoke",
1:                                     new Object[]{ objectName(osBean), "bogusMethod" }));
1:     }
1: 
1:     @Test
1:     public void roleHasNoPermissions() throws Throwable
1:     {
1:         AuthorizationProxy proxy = new ProxyBuilder().isSuperuser((role) -> false)
1:                                                      .getPermissions((role) -> Collections.emptySet())
1:                                                      .isAuthzRequired(() -> true)
1:                                                      .build();
1: 
1:         assertFalse(proxy.authorize(subject(role1.getRoleName()),
1:                                     "getAttribute",
1:                                     new Object[]{ objectName(osBean), "arch" }));
1:     }
1: 
1:     @Test
1:     public void roleHasNoPermissionsButIsSuperuser() throws Throwable
1:     {
1:         AuthorizationProxy proxy = new ProxyBuilder().isSuperuser((role) -> true)
1:                                                      .getPermissions((role) -> Collections.emptySet())
1:                                                      .isAuthzRequired(() -> true)
1:                                                      .build();
1: 
1:         assertTrue(proxy.authorize(subject(role1.getRoleName()),
1:                                    "getAttribute",
1:                                    new Object[]{ objectName(osBean), "arch" }));
1:     }
1: 
1:     @Test
1:     public void roleHasNoPermissionsButAuthzNotRequired() throws Throwable
1:     {
1:         AuthorizationProxy proxy = new ProxyBuilder().isSuperuser((role) -> false)
1:                                                      .getPermissions((role) -> Collections.emptySet())
1:                                                      .isAuthzRequired(() -> false)
1:                                                      .build();
1: 
1:         assertTrue(proxy.authorize(subject(role1.getRoleName()),
1:                                    "getAttribute",
1:                                    new Object[]{ objectName(osBean), "arch" }));
1:     }
1: 
1:     @Test
1:     public void authorizeWhenSubjectIsNull() throws Throwable
1:     {
1:         // a null subject indicates that the action is being performed by the
1:         // connector itself, so we always authorize it
1:         // Verify that the superuser status is never tested as the request returns early
1:         // due to the null Subject
1:         // Also, hardcode the permissions provider to return an empty set, so we know that
1:         // can be doubly sure that it's the null Subject which causes the authz to succeed
1:         final AtomicBoolean suStatusChecked = new AtomicBoolean(false);
1:         AuthorizationProxy proxy = new ProxyBuilder().getPermissions((role) -> Collections.emptySet())
1:                                                      .isAuthzRequired(() -> true)
1:                                                      .isSuperuser((role) ->
1:                                                                   {
1:                                                                       suStatusChecked.set(true);
1:                                                                       return false;
1:                                                                   })
1:                                                      .build();
1: 
1:         assertTrue(proxy.authorize(null,
1:                                    "getAttribute",
1:                                    new Object[]{ objectName(osBean), "arch" }));
1:         assertFalse(suStatusChecked.get());
1:     }
1: 
1:     @Test
1:     public void rejectWhenSubjectNotAuthenticated() throws Throwable
1:     {
1:         // Access is denied to a Subject without any associated Principals
1:         // Verify that the superuser status is never tested as the request is rejected early
1:         // due to the Subject
1:         final AtomicBoolean suStatusChecked = new AtomicBoolean(false);
1:         AuthorizationProxy proxy = new ProxyBuilder().isAuthzRequired(() -> true)
1:                                                      .isSuperuser((role) ->
1:                                                                   {
1:                                                                       suStatusChecked.set(true);
1:                                                                       return true;
1:                                                                   })
1:                                                      .build();
1:         assertFalse(proxy.authorize(new Subject(),
1:                                     "getAttribute",
1:                                     new Object[]{ objectName(osBean), "arch" }));
1:         assertFalse(suStatusChecked.get());
1:     }
1: 
1:     @Test
1:     public void authorizeWhenWildcardGrantCoversExactTarget() throws Throwable
1:     {
1:         Map<RoleResource, Set<PermissionDetails>> permissions =
1:             ImmutableMap.of(role1, Collections.singleton(permission(role1, javaLangWildcard, Permission.SELECT)));
1: 
1:         AuthorizationProxy proxy = new ProxyBuilder().isAuthzRequired(() -> true)
1:                                                      .isSuperuser((role) -> false)
1:                                                      .getPermissions(permissions::get)
1:                                                      .build();
1: 
1:         assertTrue(proxy.authorize(subject(role1.getRoleName()),
1:                                    "getAttribute",
1:                                    new Object[]{ objectName(osBean), "arch" }));
1:     }
1: 
1:     @Test
1:     public void rejectWhenWildcardGrantDoesNotCoverExactTarget() throws Throwable
1:     {
1:         Map<RoleResource, Set<PermissionDetails>> permissions =
1:             ImmutableMap.of(role1, Collections.singleton(permission(role1, javaLangWildcard, Permission.SELECT)));
1: 
1:         AuthorizationProxy proxy = new ProxyBuilder().isAuthzRequired(() -> true)
1:                                                      .isSuperuser((role) -> false)
1:                                                      .getPermissions(permissions::get)
1:                                                      .build();
1: 
1:         assertFalse(proxy.authorize(subject(role1.getRoleName()),
1:                                     "getAttribute",
1:                                     new Object[]{ objectName(customBean), "arch" }));
1:     }
1: 
1:     @Test
1:     public void authorizeWhenWildcardGrantCoversWildcardTarget() throws Throwable
1:     {
1:         Map<RoleResource, Set<PermissionDetails>> permissions =
1:             ImmutableMap.of(role1, Collections.singleton(permission(role1, javaLangWildcard, Permission.DESCRIBE)));
1: 
1:         AuthorizationProxy proxy = new ProxyBuilder().isAuthzRequired(() -> true)
1:                                                      .isSuperuser((role) -> false)
1:                                                      .getPermissions(permissions::get)
1:                                                      .queryNames(matcher(allBeans))
1:                                                      .build();
1: 
1:         assertTrue(proxy.authorize(subject(role1.getRoleName()),
1:                                    "queryNames",
1:                                    new Object[]{ objectName(javaLangWildcard), null }));
1:     }
1: 
1:     @Test
1:     public void rejectWhenWildcardGrantIsDisjointWithWildcardTarget() throws Throwable
1:     {
1:         JMXResource customWildcard = JMXResource.mbean("org.apache.cassandra:*");
1:         Map<RoleResource, Set<PermissionDetails>> permissions =
1:             ImmutableMap.of(role1, Collections.singleton(permission(role1, customWildcard, Permission.DESCRIBE)));
1: 
1:         AuthorizationProxy proxy = new ProxyBuilder().isAuthzRequired(() -> true)
1:                                                      .isSuperuser((role) -> false)
1:                                                      .getPermissions(permissions::get)
1:                                                      .queryNames(matcher(allBeans))
1:                                                      .build();
1: 
1:         // the grant on org.apache.cassandra:* shouldn't permit us to invoke queryNames with java.lang:*
1:         assertFalse(proxy.authorize(subject(role1.getRoleName()),
1:                                     "queryNames",
1:                                     new Object[]{ objectName(javaLangWildcard), null }));
1:     }
1: 
1:     @Test
1:     public void rejectWhenWildcardGrantIntersectsWithWildcardTarget() throws Throwable
1:     {
1:         // in this test, permissions are granted on org.apache.cassandra:type=CustomBean,property=*
1:         // and all beans in the org.apache.cassandra.hints domain, but
1:         // but the target of the invocation is org.apache.cassandra*:*
1:         // i.e. the subject has permissions on all CustomBeans and on the HintsService bean, but is
1:         // attempting to query all names in the org.apache.cassandra* domain. The operation should
1:         // be rejected as the permissions don't cover all known beans matching that domain, due to
1:         // the BatchLogManager bean.
1: 
1:         JMXResource allCustomBeans = JMXResource.mbean("org.apache.cassandra:type=CustomBean,property=*");
1:         JMXResource allHintsBeans = JMXResource.mbean("org.apache.cassandra.hints:*");
1:         ObjectName allCassandraBeans = ObjectName.getInstance("org.apache.cassandra*:*");
1: 
1:         Map<RoleResource, Set<PermissionDetails>> permissions =
1:             ImmutableMap.of(role1, ImmutableSet.of(permission(role1, allCustomBeans, Permission.DESCRIBE),
1:                                                    permission(role1, allHintsBeans, Permission.DESCRIBE)));
1: 
1:         AuthorizationProxy proxy = new ProxyBuilder().isAuthzRequired(() -> true)
1:                                                      .isSuperuser((role) -> false)
1:                                                      .getPermissions(permissions::get)
1:                                                      .queryNames(matcher(allBeans))
1:                                                      .build();
1: 
1:         // the grant on org.apache.cassandra:* shouldn't permit us to invoke queryNames with java.lang:*
1:         assertFalse(proxy.authorize(subject(role1.getRoleName()),
1:                                     "queryNames",
1:                                     new Object[]{ allCassandraBeans, null }));
1:     }
1: 
1:     @Test
1:     public void authorizeOnTargetWildcardWithPermissionOnRoot() throws Throwable
1:     {
1:         Map<RoleResource, Set<PermissionDetails>> permissions =
1:             ImmutableMap.of(role1, Collections.singleton(permission(role1, JMXResource.root(), Permission.SELECT)));
1: 
1:         AuthorizationProxy proxy = new ProxyBuilder().isAuthzRequired(() -> true)
1:                                                      .isSuperuser((role) -> false)
1:                                                      .getPermissions(permissions::get)
1:                                                      .build();
1: 
1:         assertTrue(proxy.authorize(subject(role1.getRoleName()),
1:                                    "getAttribute",
1:                                    new Object[]{ objectName(javaLangWildcard), "arch" }));
1:     }
1: 
1:     @Test
1:     public void rejectInvocationOfUnknownMethod() throws Throwable
1:     {
1:         // Grant ALL permissions on the root resource, so we know that it's
1:         // the unknown method that causes the authz rejection. Of course, this
1:         // isn't foolproof but it's something.
1:         Set<PermissionDetails> allPerms = Permission.ALL.stream()
1:                                                         .map(perm -> permission(role1, JMXResource.root(), perm))
1:                                                         .collect(Collectors.toSet());
1:         Map<RoleResource, Set<PermissionDetails>> permissions = ImmutableMap.of(role1, allPerms);
1:         AuthorizationProxy proxy = new ProxyBuilder().isAuthzRequired(() -> true)
1:                                                      .isSuperuser((role) -> false)
1:                                                      .getPermissions(permissions::get)
1:                                                      .build();
1: 
1:         assertFalse(proxy.authorize(subject(role1.getRoleName()),
1:                                     "unKnownMethod",
1:                                     new Object[] { ObjectName.getInstance(osBean.getObjectName()) }));
1:     }
1: 
1:     @Test
1:     public void rejectInvocationOfBlacklistedMethods() throws Throwable
1:     {
1:         String[] methods = { "createMBean",
1:                              "deserialize",
1:                              "getClassLoader",
1:                              "getClassLoaderFor",
1:                              "instantiate",
1:                              "registerMBean",
1:                              "unregisterMBean" };
1: 
1:         // Hardcode the superuser status check to return true, so any allowed method can be invoked.
1:         AuthorizationProxy proxy = new ProxyBuilder().isAuthzRequired(() -> true)
1:                                                      .isSuperuser((role) -> true)
1:                                                      .build();
1: 
1:         for (String method : methods)
1:             // the arguments array isn't significant, so it can just be empty
1:             assertFalse(proxy.authorize(subject(role1.getRoleName()), method, new Object[0]));
1:     }
1: 
1:     @Test
1:     public void authorizeMethodsWithoutMBeanArgumentIfPermissionsGranted() throws Throwable
1:     {
1:         // Certain methods on MBeanServer don't take an ObjectName as their first argument.
1:         // These methods are characterised by AuthorizationProxy as being concerned with
1:         // the MBeanServer itself, as opposed to a specific managed bean. Of these methods,
1:         // only those considered "descriptive" are allowed to be invoked by remote users.
1:         // These require the DESCRIBE permission on the root JMXResource.
1:         testNonMbeanMethods(true);
1:     }
1: 
1:     @Test
1:     public void rejectMethodsWithoutMBeanArgumentIfPermissionsNotGranted() throws Throwable
1:     {
1:         testNonMbeanMethods(false);
1:     }
1: 
1:     @Test
1:     public void rejectWhenAuthSetupIsNotComplete() throws Throwable
1:     {
1:         // IAuthorizer & IRoleManager should not be considered ready to use until
1:         // we know that auth setup has completed. So, even though the IAuthorizer
1:         // would theoretically grant access, the auth proxy should deny it if setup
1:         // hasn't finished.
1: 
1:         Map<RoleResource, Set<PermissionDetails>> permissions =
1:         ImmutableMap.of(role1, Collections.singleton(permission(role1, osBean, Permission.SELECT)));
1: 
1:         // verify that access is granted when setup is complete
1:         AuthorizationProxy proxy = new ProxyBuilder().isSuperuser((role) -> false)
1:                                                      .getPermissions(permissions::get)
1:                                                      .isAuthzRequired(() -> true)
1:                                                      .isAuthSetupComplete(() -> true)
1:                                                      .build();
1: 
1:         assertTrue(proxy.authorize(subject(role1.getRoleName()),
1:                                    "getAttribute",
1:                                    new Object[]{ objectName(osBean), "arch" }));
1: 
1:         // and denied when it isn't
1:         proxy = new ProxyBuilder().isSuperuser((role) -> false)
1:                                   .getPermissions(permissions::get)
1:                                   .isAuthzRequired(() -> true)
1:                                   .isAuthSetupComplete(() -> false)
1:                                   .build();
1: 
1:         assertFalse(proxy.authorize(subject(role1.getRoleName()),
1:                                    "getAttribute",
1:                                    new Object[]{ objectName(osBean), "arch" }));
1:     }
1: 
1:     private void testNonMbeanMethods(boolean withPermission)
1:     {
1:         String[] methods = { "getDefaultDomain",
1:                              "getDomains",
1:                              "getMBeanCount",
1:                              "hashCode",
1:                              "queryMBeans",
1:                              "queryNames",
1:                              "toString" };
1: 
1: 
1:         ProxyBuilder builder = new ProxyBuilder().isAuthzRequired(() -> true).isSuperuser((role) -> false);
1:         if (withPermission)
1:         {
1:             Map<RoleResource, Set<PermissionDetails>> permissions =
1:                 ImmutableMap.of(role1, ImmutableSet.of(permission(role1, JMXResource.root(), Permission.DESCRIBE)));
1:             builder.getPermissions(permissions::get);
1:         }
1:         else
1:         {
1:             builder.getPermissions((role) -> Collections.emptySet());
1:         }
1:         AuthorizationProxy proxy = builder.build();
1: 
1:         for (String method : methods)
1:             assertEquals(withPermission, proxy.authorize(subject(role1.getRoleName()), method, new Object[]{ null }));
1: 
1:         // non-whitelisted methods should be rejected regardless.
1:         // This isn't exactly comprehensive, but it's better than nothing
1:         String[] notAllowed = { "fooMethod", "barMethod", "bazMethod" };
1:         for (String method : notAllowed)
1:             assertFalse(proxy.authorize(subject(role1.getRoleName()), method, new Object[]{ null }));
1:     }
1: 
1:     // provides a simple matching function which can be substituted for the proxy's queryMBeans
1:     // utility (which by default just delegates to the MBeanServer)
1:     // This function just iterates over a supplied set of ObjectNames and filters out those
1:     // to which the target name *doesn't* apply
1:     private static Function<ObjectName, Set<ObjectName>> matcher(Set<ObjectName> allBeans)
1:     {
1:         return (target) -> allBeans.stream()
1:                                    .filter(target::apply)
1:                                    .collect(Collectors.toSet());
1:     }
1: 
1:     private static PermissionDetails permission(RoleResource grantee, IResource resource, Permission permission)
1:     {
1:         return new PermissionDetails(grantee.getRoleName(), resource, permission);
1:     }
1: 
1:     private static Subject subject(String roleName)
1:     {
1:         Subject subject = new Subject();
1:         subject.getPrincipals().add(new CassandraPrincipal(roleName));
1:         return subject;
1:     }
1: 
1:     private static ObjectName objectName(JMXResource resource) throws MalformedObjectNameException
1:     {
1:         return ObjectName.getInstance(resource.getObjectName());
1:     }
1: 
1:     private static Set<ObjectName> objectNames(JMXResource... resource)
1:     {
1:         Set<ObjectName> names = new HashSet<>();
1:         try
1:         {
1:             for (JMXResource r : resource)
1:                 names.add(objectName(r));
1:         }
1:         catch (MalformedObjectNameException e)
1:         {
1:             fail("JMXResource returned invalid object name: " + e.getMessage());
1:         }
1:         return names;
1:     }
1: 
1:     public static class ProxyBuilder
1:     {
1:         Function<RoleResource, Set<PermissionDetails>> getPermissions;
1:         Function<ObjectName, Set<ObjectName>> queryNames;
1:         Function<RoleResource, Boolean> isSuperuser;
1:         Supplier<Boolean> isAuthzRequired;
1:         Supplier<Boolean> isAuthSetupComplete = () -> true;
1: 
1:         AuthorizationProxy build()
1:         {
1:             InjectableAuthProxy proxy = new InjectableAuthProxy();
1: 
1:             if (getPermissions != null)
1:                 proxy.setGetPermissions(getPermissions);
1: 
1:             if (queryNames != null)
1:                 proxy.setQueryNames(queryNames);
1: 
1:             if (isSuperuser != null)
1:                 proxy.setIsSuperuser(isSuperuser);
1: 
1:             if (isAuthzRequired != null)
1:                 proxy.setIsAuthzRequired(isAuthzRequired);
1: 
1:             proxy.setIsAuthSetupComplete(isAuthSetupComplete);
1: 
1:             return proxy;
1:         }
1: 
1:         ProxyBuilder getPermissions(Function<RoleResource, Set<PermissionDetails>> f)
1:         {
1:             getPermissions = f;
1:             return this;
1:         }
1: 
1:         ProxyBuilder queryNames(Function<ObjectName, Set<ObjectName>> f)
1:         {
1:             queryNames = f;
1:             return this;
1:         }
1: 
1:         ProxyBuilder isSuperuser(Function<RoleResource, Boolean> f)
1:         {
1:             isSuperuser = f;
1:             return this;
1:         }
1: 
1:         ProxyBuilder isAuthzRequired(Supplier<Boolean> s)
1:         {
1:             isAuthzRequired = s;
1:             return this;
1:         }
1: 
1:         ProxyBuilder isAuthSetupComplete(Supplier<Boolean> s)
1:         {
1:             isAuthSetupComplete = s;
1:             return this;
1:         }
1: 
1:         private static class InjectableAuthProxy extends AuthorizationProxy
1:         {
1:             void setGetPermissions(Function<RoleResource, Set<PermissionDetails>> f)
1:             {
1:                 this.getPermissions = f;
1:             }
1: 
1:             void setQueryNames(Function<ObjectName, Set<ObjectName>> f)
1:             {
1:                 this.queryNames = f;
1:             }
1: 
1:             void setIsSuperuser(Function<RoleResource, Boolean> f)
1:             {
1:                 this.isSuperuser = f;
1:             }
1: 
1:             void setIsAuthzRequired(Supplier<Boolean> s)
1:             {
1:                 this.isAuthzRequired = s;
1:             }
1: 
1:             void setIsAuthSetupComplete(Supplier<Boolean> s)
1:             {
1:                 this.isAuthSetupComplete = s;
1:             }
1:         }
1:     }
1: }
============================================================================