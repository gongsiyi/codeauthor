1:9872b74: /*
1:9872b74:  * Licensed to the Apache Software Foundation (ASF) under one
1:9872b74:  * or more contributor license agreements.  See the NOTICE file
1:9872b74:  * distributed with this work for additional information
1:9872b74:  * regarding copyright ownership.  The ASF licenses this file
1:9872b74:  * to you under the Apache License, Version 2.0 (the
1:9872b74:  * "License"); you may not use this file except in compliance
1:9872b74:  * with the License.  You may obtain a copy of the License at
1:9872b74:  *
1:9872b74:  *     http://www.apache.org/licenses/LICENSE-2.0
1:9872b74:  *
1:9872b74:  * Unless required by applicable law or agreed to in writing, software
1:9872b74:  * distributed under the License is distributed on an "AS IS" BASIS,
1:9872b74:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:9872b74:  * See the License for the specific language governing permissions and
1:9872b74:  * limitations under the License.
1:9872b74:  */
1:9872b74: package org.apache.cassandra.transport;
1:9872b74: 
1:9872b74: import java.nio.ByteBuffer;
1:9872b74: import java.util.*;
1:9872b74: 
1:9872b74: import io.netty.buffer.Unpooled;
1:9872b74: import io.netty.buffer.ByteBuf;
1:9872b74: 
1:e0adc16: import org.junit.BeforeClass;
1:9872b74: import org.junit.Test;
1:e0adc16: 
1:e0adc16: import org.apache.cassandra.Util;
1:e0adc16: import org.apache.cassandra.config.DatabaseDescriptor;
1:9872b74: import org.apache.cassandra.cql3.*;
1:e0adc16: import org.apache.cassandra.db.ConsistencyLevel;
1:9872b74: import org.apache.cassandra.db.marshal.*;
1:9872b74: import org.apache.cassandra.serializers.CollectionSerializer;
1:e0adc16: import org.apache.cassandra.service.pager.PagingState;
1:9872b74: import org.apache.cassandra.transport.Event.TopologyChange;
1:9872b74: import org.apache.cassandra.transport.Event.SchemaChange;
1:9872b74: import org.apache.cassandra.transport.Event.StatusChange;
1:9872b74: import org.apache.cassandra.utils.FBUtilities;
1:9872b74: import org.apache.cassandra.utils.Pair;
1:9872b74: 
1:9872b74: import static org.junit.Assert.assertEquals;
1:9872b74: import static org.apache.cassandra.utils.ByteBufferUtil.bytes;
1:e0adc16: import static org.junit.Assert.assertNotNull;
1:dca37a6: import static org.junit.Assert.assertNotSame;
1:9872b74: 
1:9872b74: /**
1:9872b74:  * Serialization/deserialization tests for protocol objects and messages.
1:9872b74:  */
1:9872b74: public class SerDeserTest
1:9872b74: {
1:e0adc16:     @BeforeClass
1:e0adc16:     public static void setupDD()
1:e0adc16:     {
1:e0adc16:         // required for making the paging state
1:e0adc16:         DatabaseDescriptor.daemonInitialization();
1:e0adc16:     }
1:e0adc16: 
1:9872b74:     @Test
1:9872b74:     public void collectionSerDeserTest() throws Exception
1:9872b74:     {
1:e0adc16:         for (ProtocolVersion version : ProtocolVersion.SUPPORTED)
1:e0adc16:             collectionSerDeserTest(version);
1:9872b74:     }
1:4ed0060: 
1:e0adc16:     public void collectionSerDeserTest(ProtocolVersion version) throws Exception
1:9872b74:     {
1:9872b74:         // Lists
1:ee55f36:         ListType<?> lt = ListType.getInstance(Int32Type.instance, true);
1:9872b74:         List<Integer> l = Arrays.asList(2, 6, 1, 9);
1:9872b74: 
1:9872b74:         List<ByteBuffer> lb = new ArrayList<>(l.size());
1:9872b74:         for (Integer i : l)
1:9872b74:             lb.add(Int32Type.instance.decompose(i));
1:9872b74: 
1:9872b74:         assertEquals(l, lt.getSerializer().deserializeForNativeProtocol(CollectionSerializer.pack(lb, lb.size(), version), version));
1:9872b74: 
1:9872b74:         // Sets
1:ee55f36:         SetType<?> st = SetType.getInstance(UTF8Type.instance, true);
1:9872b74:         Set<String> s = new LinkedHashSet<>();
1:9872b74:         s.addAll(Arrays.asList("bar", "foo", "zee"));
1:9872b74: 
1:9872b74:         List<ByteBuffer> sb = new ArrayList<>(s.size());
1:9872b74:         for (String t : s)
1:9872b74:             sb.add(UTF8Type.instance.decompose(t));
1:9872b74: 
1:9872b74:         assertEquals(s, st.getSerializer().deserializeForNativeProtocol(CollectionSerializer.pack(sb, sb.size(), version), version));
1:9872b74: 
1:9872b74:         // Maps
1:ee55f36:         MapType<?, ?> mt = MapType.getInstance(UTF8Type.instance, LongType.instance, true);
1:9872b74:         Map<String, Long> m = new LinkedHashMap<>();
1:9872b74:         m.put("bar", 12L);
1:9872b74:         m.put("foo", 42L);
1:9872b74:         m.put("zee", 14L);
1:9872b74: 
1:9872b74:         List<ByteBuffer> mb = new ArrayList<>(m.size() * 2);
1:9872b74:         for (Map.Entry<String, Long> entry : m.entrySet())
1:9872b74:         {
1:9872b74:             mb.add(UTF8Type.instance.decompose(entry.getKey()));
1:9872b74:             mb.add(LongType.instance.decompose(entry.getValue()));
1:9872b74:         }
1:9872b74: 
1:9872b74:         assertEquals(m, mt.getSerializer().deserializeForNativeProtocol(CollectionSerializer.pack(mb, m.size(), version), version));
1:9872b74:     }
1:9872b74: 
1:9872b74:     @Test
1:9872b74:     public void eventSerDeserTest() throws Exception
1:9872b74:     {
1:e0adc16:         for (ProtocolVersion version : ProtocolVersion.SUPPORTED)
1:e0adc16:             eventSerDeserTest(version);
1:9872b74:     }
1:9872b74: 
1:e0adc16:     public void eventSerDeserTest(ProtocolVersion version) throws Exception
1:9872b74:     {
1:9872b74:         List<Event> events = new ArrayList<>();
1:9872b74: 
1:9872b74:         events.add(TopologyChange.newNode(FBUtilities.getBroadcastAddress(), 42));
1:9872b74:         events.add(TopologyChange.removedNode(FBUtilities.getBroadcastAddress(), 42));
1:9872b74:         events.add(TopologyChange.movedNode(FBUtilities.getBroadcastAddress(), 42));
1:9872b74: 
1:9872b74:         events.add(StatusChange.nodeUp(FBUtilities.getBroadcastAddress(), 42));
1:9872b74:         events.add(StatusChange.nodeDown(FBUtilities.getBroadcastAddress(), 42));
1:9872b74: 
1:9872b74:         events.add(new SchemaChange(SchemaChange.Change.CREATED, "ks"));
1:9872b74:         events.add(new SchemaChange(SchemaChange.Change.UPDATED, "ks"));
1:9872b74:         events.add(new SchemaChange(SchemaChange.Change.DROPPED, "ks"));
1:9872b74: 
1:9872b74:         events.add(new SchemaChange(SchemaChange.Change.CREATED, SchemaChange.Target.TABLE, "ks", "table"));
1:9872b74:         events.add(new SchemaChange(SchemaChange.Change.UPDATED, SchemaChange.Target.TABLE, "ks", "table"));
1:9872b74:         events.add(new SchemaChange(SchemaChange.Change.DROPPED, SchemaChange.Target.TABLE, "ks", "table"));
1:9872b74: 
1:e0adc16:         if (version.isGreaterOrEqualTo(ProtocolVersion.V3))
1:9872b74:         {
1:9872b74:             events.add(new SchemaChange(SchemaChange.Change.CREATED, SchemaChange.Target.TYPE, "ks", "type"));
1:9872b74:             events.add(new SchemaChange(SchemaChange.Change.UPDATED, SchemaChange.Target.TYPE, "ks", "type"));
1:9872b74:             events.add(new SchemaChange(SchemaChange.Change.DROPPED, SchemaChange.Target.TYPE, "ks", "type"));
1:9872b74:         }
1:9872b74: 
1:e0adc16:         if (version.isGreaterOrEqualTo(ProtocolVersion.V4))
1:dcc3bb0:         {
1:dcc3bb0:             List<String> moreTypes = Arrays.asList("text", "bigint");
1:9872b74: 
1:dcc3bb0:             events.add(new SchemaChange(SchemaChange.Change.CREATED, SchemaChange.Target.FUNCTION, "ks", "func", Collections.<String>emptyList()));
1:dcc3bb0:             events.add(new SchemaChange(SchemaChange.Change.UPDATED, SchemaChange.Target.FUNCTION, "ks", "func", moreTypes));
1:dcc3bb0:             events.add(new SchemaChange(SchemaChange.Change.DROPPED, SchemaChange.Target.FUNCTION, "ks", "func", moreTypes));
1:dcc3bb0: 
1:dcc3bb0:             events.add(new SchemaChange(SchemaChange.Change.CREATED, SchemaChange.Target.AGGREGATE, "ks", "aggr", Collections.<String>emptyList()));
1:dcc3bb0:             events.add(new SchemaChange(SchemaChange.Change.UPDATED, SchemaChange.Target.AGGREGATE, "ks", "aggr", moreTypes));
1:dcc3bb0:             events.add(new SchemaChange(SchemaChange.Change.DROPPED, SchemaChange.Target.AGGREGATE, "ks", "aggr", moreTypes));
1:dcc3bb0:         }
1:dcc3bb0: 
1:9872b74:         for (Event ev : events)
1:9872b74:         {
1:9872b74:             ByteBuf buf = Unpooled.buffer(ev.serializedSize(version));
1:9872b74:             ev.serialize(buf, version);
1:9872b74:             assertEquals(ev, Event.deserialize(buf, version));
1:9872b74:         }
1:9872b74:     }
1:9872b74: 
1:9872b74:     private static ByteBuffer bb(String str)
1:9872b74:     {
1:9872b74:         return UTF8Type.instance.decompose(str);
1:9872b74:     }
1:9872b74: 
1:4ed0060:     private static FieldIdentifier field(String field)
1:4ed0060:     {
1:4ed0060:         return FieldIdentifier.forQuoted(field);
1:4ed0060:     }
1:4ed0060: 
1:9872b74:     private static ColumnIdentifier ci(String name)
1:9872b74:     {
1:9872b74:         return new ColumnIdentifier(name, false);
1:9872b74:     }
1:9872b74: 
1:9872b74:     private static Constants.Literal lit(long v)
1:9872b74:     {
1:9872b74:         return Constants.Literal.integer(String.valueOf(v));
1:9872b74:     }
1:9872b74: 
1:9872b74:     private static Constants.Literal lit(String v)
1:9872b74:     {
1:9872b74:         return Constants.Literal.string(v);
1:9872b74:     }
1:9872b74: 
1:9872b74:     private static ColumnSpecification columnSpec(String name, AbstractType<?> type)
1:9872b74:     {
1:9872b74:         return new ColumnSpecification("ks", "cf", ci(name), type);
1:9872b74:     }
1:9872b74: 
1:9872b74:     @Test
1:9872b74:     public void udtSerDeserTest() throws Exception
1:9872b74:     {
1:e0adc16:         for (ProtocolVersion version : ProtocolVersion.SUPPORTED)
1:e0adc16:             udtSerDeserTest(version);
1:9872b74:     }
1:9872b74: 
1:9872b74: 
1:e0adc16:     public void udtSerDeserTest(ProtocolVersion version) throws Exception
1:9872b74:     {
1:ee55f36:         ListType<?> lt = ListType.getInstance(Int32Type.instance, true);
1:ee55f36:         SetType<?> st = SetType.getInstance(UTF8Type.instance, true);
1:ee55f36:         MapType<?, ?> mt = MapType.getInstance(UTF8Type.instance, LongType.instance, true);
1:dcc3bb0: 
1:9872b74:         UserType udt = new UserType("ks",
1:9872b74:                                     bb("myType"),
1:4ed0060:                                     Arrays.asList(field("f1"), field("f2"), field("f3"), field("f4")),
1:677230d:                                     Arrays.asList(LongType.instance, lt, st, mt),
1:677230d:                                     true);
1:9872b74: 
1:4ed0060:         Map<FieldIdentifier, Term.Raw> value = new HashMap<>();
1:4ed0060:         value.put(field("f1"), lit(42));
1:4ed0060:         value.put(field("f2"), new Lists.Literal(Arrays.<Term.Raw>asList(lit(3), lit(1))));
1:4ed0060:         value.put(field("f3"), new Sets.Literal(Arrays.<Term.Raw>asList(lit("foo"), lit("bar"))));
1:4ed0060:         value.put(field("f4"), new Maps.Literal(Arrays.<Pair<Term.Raw, Term.Raw>>asList(
1:9872b74:                                    Pair.<Term.Raw, Term.Raw>create(lit("foo"), lit(24)),
1:9872b74:                                    Pair.<Term.Raw, Term.Raw>create(lit("bar"), lit(12)))));
1:9872b74: 
1:9872b74:         UserTypes.Literal u = new UserTypes.Literal(value);
1:9872b74:         Term t = u.prepare("ks", columnSpec("myValue", udt));
1:9872b74: 
1:9872b74:         QueryOptions options = QueryOptions.DEFAULT;
1:9872b74: 
1:9872b74:         ByteBuffer serialized = t.bindAndGet(options);
1:9872b74: 
1:9872b74:         ByteBuffer[] fields = udt.split(serialized);
1:9872b74: 
1:9872b74:         assertEquals(4, fields.length);
1:9872b74: 
1:9872b74:         assertEquals(bytes(42L), fields[0]);
1:9872b74: 
1:9872b74:         // Note that no matter what the protocol version has been used in bindAndGet above, the collections inside
1:9872b74:         // a UDT should alway be serialized with version 3 of the protocol. Which is why we don't use 'version'
1:9872b74:         // on purpose below.
1:9872b74: 
1:e0adc16:         assertEquals(Arrays.asList(3, 1), lt.getSerializer().deserializeForNativeProtocol(fields[1], ProtocolVersion.V3));
1:9872b74: 
1:9872b74:         LinkedHashSet<String> s = new LinkedHashSet<>();
1:9872b74:         s.addAll(Arrays.asList("bar", "foo"));
1:e0adc16:         assertEquals(s, st.getSerializer().deserializeForNativeProtocol(fields[2], ProtocolVersion.V3));
1:9872b74: 
1:9872b74:         LinkedHashMap<String, Long> m = new LinkedHashMap<>();
1:9872b74:         m.put("bar", 12L);
1:9872b74:         m.put("foo", 24L);
1:e0adc16:         assertEquals(m, mt.getSerializer().deserializeForNativeProtocol(fields[3], ProtocolVersion.V3));
1:9872b74:     }
1:dca37a6: 
1:dca37a6:     @Test
1:dca37a6:     public void preparedMetadataSerializationTest()
1:dca37a6:     {
1:e0adc16:         for (ProtocolVersion version : ProtocolVersion.SUPPORTED)
1:e0adc16:             preparedMetadataSerializationTest(version);
1:e0adc16:     }
1:e0adc16: 
1:e0adc16:     private void preparedMetadataSerializationTest(ProtocolVersion version)
1:e0adc16:     {
1:dca37a6:         List<ColumnSpecification> columnNames = new ArrayList<>();
1:dca37a6:         for (int i = 0; i < 3; i++)
1:dca37a6:             columnNames.add(new ColumnSpecification("ks", "cf", new ColumnIdentifier("col" + i, false), Int32Type.instance));
1:dca37a6: 
1:e0adc16:         if (version == ProtocolVersion.V3)
1:e0adc16:         {
1:e0adc16:             // v3 encoding doesn't include partition key bind indexes
1:e0adc16:             ResultSet.PreparedMetadata meta = new ResultSet.PreparedMetadata(columnNames, new short[]{ 2, 1 });
1:e0adc16:             ByteBuf buf = Unpooled.buffer(ResultSet.PreparedMetadata.codec.encodedSize(meta, version));
1:e0adc16:             ResultSet.PreparedMetadata.codec.encode(meta, buf, version);
1:e0adc16:             ResultSet.PreparedMetadata decodedMeta = ResultSet.PreparedMetadata.codec.decode(buf, version);
1:e0adc16: 
1:e0adc16:             assertNotSame(meta, decodedMeta);
1:e0adc16: 
1:e0adc16:             // however, if there are no partition key indexes, they should be the same
1:e0adc16:             ResultSet.PreparedMetadata metaWithoutIndexes = new ResultSet.PreparedMetadata(columnNames, null);
1:e0adc16:             buf = Unpooled.buffer(metaWithoutIndexes.codec.encodedSize(metaWithoutIndexes, version));
1:e0adc16:             metaWithoutIndexes.codec.encode(metaWithoutIndexes, buf, version);
1:e0adc16:             ResultSet.PreparedMetadata decodedMetaWithoutIndexes = metaWithoutIndexes.codec.decode(buf, version);
1:e0adc16: 
1:e0adc16:             assertEquals(decodedMeta, decodedMetaWithoutIndexes);
1:e0adc16:         }
1:e0adc16:         else
1:e0adc16:         {
1:e0adc16:             ResultSet.PreparedMetadata meta = new ResultSet.PreparedMetadata(columnNames, new short[]{ 2, 1 });
1:e0adc16:             ByteBuf buf = Unpooled.buffer(ResultSet.PreparedMetadata.codec.encodedSize(meta, version));
1:e0adc16:             ResultSet.PreparedMetadata.codec.encode(meta, buf, version);
1:e0adc16:             ResultSet.PreparedMetadata decodedMeta = ResultSet.PreparedMetadata.codec.decode(buf, version);
1:e0adc16:             assertEquals(meta, decodedMeta);
1:e0adc16:         }
1:e0adc16:     }
1:e0adc16: 
1:e0adc16:     @Test
1:e0adc16:     public void metadataSerializationTest()
1:e0adc16:     {
1:e0adc16:         for (ProtocolVersion version : ProtocolVersion.SUPPORTED)
1:e0adc16:             metadataSerializationTest(version);
1:e0adc16:     }
1:e0adc16: 
1:e0adc16:     private void metadataSerializationTest(ProtocolVersion version)
1:e0adc16:     {
1:e0adc16:         List<ColumnSpecification> columnNames = new ArrayList<>();
1:e0adc16:         for (int i = 0; i < 3; i++)
1:e0adc16:             columnNames.add(new ColumnSpecification("ks", "cf", new ColumnIdentifier("col" + i, false), Int32Type.instance));
1:e0adc16: 
1:e0adc16:         ResultSet.ResultMetadata meta = new ResultSet.ResultMetadata(columnNames);
1:e0adc16:         ByteBuf buf = Unpooled.buffer(meta.codec.encodedSize(meta, version));
1:e0adc16:         meta.codec.encode(meta, buf, version);
1:e0adc16:         ResultSet.ResultMetadata decodedMeta = meta.codec.decode(buf, version);
1:dca37a6: 
1:dca37a6:         assertEquals(meta, decodedMeta);
1:e0adc16:     }
1:dca37a6: 
1:e0adc16:     @Test
1:e0adc16:     public void queryOptionsSerDeserTest() throws Exception
1:e0adc16:     {
1:e0adc16:         for (ProtocolVersion version : ProtocolVersion.SUPPORTED)
1:e0adc16:             queryOptionsSerDeserTest(version);
1:e0adc16:     }
1:dca37a6: 
1:e0adc16:     private void queryOptionsSerDeserTest(ProtocolVersion version) throws Exception
1:e0adc16:     {
1:e0adc16:         QueryOptions options = QueryOptions.create(ConsistencyLevel.ALL,
1:e0adc16:                                                    Collections.singletonList(ByteBuffer.wrap(new byte[] { 0x00, 0x01, 0x02 })),
1:e0adc16:                                                    false,
1:e0adc16:                                                    5000,
1:e0adc16:                                                    Util.makeSomePagingState(version),
1:e0adc16:                                                    ConsistencyLevel.SERIAL,
1:e0adc16:                                                    version
1:e0adc16:                                                    );
1:dca37a6: 
1:e0adc16:         ByteBuf buf = Unpooled.buffer(QueryOptions.codec.encodedSize(options, version));
1:e0adc16:         QueryOptions.codec.encode(options, buf, version);
1:e0adc16:         QueryOptions decodedOptions = QueryOptions.codec.decode(buf, version);
1:dca37a6: 
1:e0adc16:         assertNotNull(decodedOptions);
1:e0adc16:         assertEquals(options.getConsistency(), decodedOptions.getConsistency());
1:e0adc16:         assertEquals(options.getSerialConsistency(), decodedOptions.getSerialConsistency());
1:e0adc16:         assertEquals(options.getPageSize(), decodedOptions.getPageSize());
1:e0adc16:         assertEquals(options.getProtocolVersion(), decodedOptions.getProtocolVersion());
1:e0adc16:         assertEquals(options.getValues(), decodedOptions.getValues());
1:e0adc16:         assertEquals(options.getPagingState(), decodedOptions.getPagingState());
1:e0adc16:         assertEquals(options.skipMetadata(), decodedOptions.skipMetadata());
1:9872b74:     }
1:dca37a6: }
============================================================================
author:Stefania Alborghetti
-------------------------------------------------------------------------------
commit:e0adc16
/////////////////////////////////////////////////////////////////////////
1: import org.junit.BeforeClass;
1: 
1: import org.apache.cassandra.Util;
1: import org.apache.cassandra.config.DatabaseDescriptor;
1: import org.apache.cassandra.db.ConsistencyLevel;
1: import org.apache.cassandra.service.pager.PagingState;
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertNotNull;
/////////////////////////////////////////////////////////////////////////
1:     @BeforeClass
1:     public static void setupDD()
1:     {
1:         // required for making the paging state
1:         DatabaseDescriptor.daemonInitialization();
1:     }
1: 
1:         for (ProtocolVersion version : ProtocolVersion.SUPPORTED)
1:             collectionSerDeserTest(version);
1:     public void collectionSerDeserTest(ProtocolVersion version) throws Exception
/////////////////////////////////////////////////////////////////////////
1:         for (ProtocolVersion version : ProtocolVersion.SUPPORTED)
1:             eventSerDeserTest(version);
1:     public void eventSerDeserTest(ProtocolVersion version) throws Exception
/////////////////////////////////////////////////////////////////////////
1:         if (version.isGreaterOrEqualTo(ProtocolVersion.V3))
1:         if (version.isGreaterOrEqualTo(ProtocolVersion.V4))
/////////////////////////////////////////////////////////////////////////
1:         for (ProtocolVersion version : ProtocolVersion.SUPPORTED)
1:             udtSerDeserTest(version);
1:     public void udtSerDeserTest(ProtocolVersion version) throws Exception
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(Arrays.asList(3, 1), lt.getSerializer().deserializeForNativeProtocol(fields[1], ProtocolVersion.V3));
1:         assertEquals(s, st.getSerializer().deserializeForNativeProtocol(fields[2], ProtocolVersion.V3));
1:         assertEquals(m, mt.getSerializer().deserializeForNativeProtocol(fields[3], ProtocolVersion.V3));
1:         for (ProtocolVersion version : ProtocolVersion.SUPPORTED)
1:             preparedMetadataSerializationTest(version);
1:     }
1: 
1:     private void preparedMetadataSerializationTest(ProtocolVersion version)
1:     {
1:         if (version == ProtocolVersion.V3)
1:         {
1:             // v3 encoding doesn't include partition key bind indexes
1:             ResultSet.PreparedMetadata meta = new ResultSet.PreparedMetadata(columnNames, new short[]{ 2, 1 });
1:             ByteBuf buf = Unpooled.buffer(ResultSet.PreparedMetadata.codec.encodedSize(meta, version));
1:             ResultSet.PreparedMetadata.codec.encode(meta, buf, version);
1:             ResultSet.PreparedMetadata decodedMeta = ResultSet.PreparedMetadata.codec.decode(buf, version);
1: 
1:             assertNotSame(meta, decodedMeta);
1: 
1:             // however, if there are no partition key indexes, they should be the same
1:             ResultSet.PreparedMetadata metaWithoutIndexes = new ResultSet.PreparedMetadata(columnNames, null);
1:             buf = Unpooled.buffer(metaWithoutIndexes.codec.encodedSize(metaWithoutIndexes, version));
1:             metaWithoutIndexes.codec.encode(metaWithoutIndexes, buf, version);
1:             ResultSet.PreparedMetadata decodedMetaWithoutIndexes = metaWithoutIndexes.codec.decode(buf, version);
1: 
1:             assertEquals(decodedMeta, decodedMetaWithoutIndexes);
1:         }
1:         else
1:         {
1:             ResultSet.PreparedMetadata meta = new ResultSet.PreparedMetadata(columnNames, new short[]{ 2, 1 });
1:             ByteBuf buf = Unpooled.buffer(ResultSet.PreparedMetadata.codec.encodedSize(meta, version));
1:             ResultSet.PreparedMetadata.codec.encode(meta, buf, version);
1:             ResultSet.PreparedMetadata decodedMeta = ResultSet.PreparedMetadata.codec.decode(buf, version);
1:             assertEquals(meta, decodedMeta);
1:         }
1:     }
1: 
1:     @Test
1:     public void metadataSerializationTest()
1:     {
1:         for (ProtocolVersion version : ProtocolVersion.SUPPORTED)
1:             metadataSerializationTest(version);
1:     }
1: 
1:     private void metadataSerializationTest(ProtocolVersion version)
1:     {
1:         List<ColumnSpecification> columnNames = new ArrayList<>();
1:         for (int i = 0; i < 3; i++)
1:             columnNames.add(new ColumnSpecification("ks", "cf", new ColumnIdentifier("col" + i, false), Int32Type.instance));
1: 
1:         ResultSet.ResultMetadata meta = new ResultSet.ResultMetadata(columnNames);
1:         ByteBuf buf = Unpooled.buffer(meta.codec.encodedSize(meta, version));
1:         meta.codec.encode(meta, buf, version);
1:         ResultSet.ResultMetadata decodedMeta = meta.codec.decode(buf, version);
1:     }
1:     @Test
1:     public void queryOptionsSerDeserTest() throws Exception
1:     {
1:         for (ProtocolVersion version : ProtocolVersion.SUPPORTED)
1:             queryOptionsSerDeserTest(version);
1:     }
1:     private void queryOptionsSerDeserTest(ProtocolVersion version) throws Exception
1:     {
1:         QueryOptions options = QueryOptions.create(ConsistencyLevel.ALL,
1:                                                    Collections.singletonList(ByteBuffer.wrap(new byte[] { 0x00, 0x01, 0x02 })),
1:                                                    false,
1:                                                    5000,
1:                                                    Util.makeSomePagingState(version),
1:                                                    ConsistencyLevel.SERIAL,
1:                                                    version
1:                                                    );
1:         ByteBuf buf = Unpooled.buffer(QueryOptions.codec.encodedSize(options, version));
1:         QueryOptions.codec.encode(options, buf, version);
1:         QueryOptions decodedOptions = QueryOptions.codec.decode(buf, version);
1:         assertNotNull(decodedOptions);
1:         assertEquals(options.getConsistency(), decodedOptions.getConsistency());
1:         assertEquals(options.getSerialConsistency(), decodedOptions.getSerialConsistency());
1:         assertEquals(options.getPageSize(), decodedOptions.getPageSize());
1:         assertEquals(options.getProtocolVersion(), decodedOptions.getProtocolVersion());
1:         assertEquals(options.getValues(), decodedOptions.getValues());
1:         assertEquals(options.getPagingState(), decodedOptions.getPagingState());
1:         assertEquals(options.skipMetadata(), decodedOptions.skipMetadata());
author:Sylvain Lebresne
-------------------------------------------------------------------------------
commit:4ed0060
/////////////////////////////////////////////////////////////////////////
1:     private static FieldIdentifier field(String field)
1:     {
1:         return FieldIdentifier.forQuoted(field);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:                                     Arrays.asList(field("f1"), field("f2"), field("f3"), field("f4")),
1:         Map<FieldIdentifier, Term.Raw> value = new HashMap<>();
1:         value.put(field("f1"), lit(42));
1:         value.put(field("f2"), new Lists.Literal(Arrays.<Term.Raw>asList(lit(3), lit(1))));
1:         value.put(field("f3"), new Sets.Literal(Arrays.<Term.Raw>asList(lit("foo"), lit("bar"))));
1:         value.put(field("f4"), new Maps.Literal(Arrays.<Pair<Term.Raw, Term.Raw>>asList(
commit:9872b74
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.cassandra.transport;
1: 
1: import java.nio.ByteBuffer;
1: import java.util.*;
1: 
1: import io.netty.buffer.Unpooled;
1: import io.netty.buffer.ByteBuf;
1: 
1: import org.junit.Test;
1: import org.apache.cassandra.cql3.*;
0: import org.apache.cassandra.db.ConsistencyLevel;
1: import org.apache.cassandra.db.marshal.*;
1: import org.apache.cassandra.serializers.CollectionSerializer;
1: import org.apache.cassandra.transport.Event.TopologyChange;
1: import org.apache.cassandra.transport.Event.SchemaChange;
1: import org.apache.cassandra.transport.Event.StatusChange;
0: import org.apache.cassandra.utils.ByteBufferUtil;
1: import org.apache.cassandra.utils.FBUtilities;
1: import org.apache.cassandra.utils.Pair;
1: 
1: import static org.junit.Assert.assertEquals;
1: import static org.apache.cassandra.utils.ByteBufferUtil.bytes;
1: 
1: /**
1:  * Serialization/deserialization tests for protocol objects and messages.
1:  */
1: public class SerDeserTest
1: {
1:     @Test
1:     public void collectionSerDeserTest() throws Exception
1:     {
0:         collectionSerDeserTest(2);
0:         collectionSerDeserTest(3);
1:     }
1: 
0:     public void collectionSerDeserTest(int version) throws Exception
1:     {
1:         // Lists
0:         ListType<?> lt = ListType.getInstance(Int32Type.instance);
1:         List<Integer> l = Arrays.asList(2, 6, 1, 9);
1: 
1:         List<ByteBuffer> lb = new ArrayList<>(l.size());
1:         for (Integer i : l)
1:             lb.add(Int32Type.instance.decompose(i));
1: 
1:         assertEquals(l, lt.getSerializer().deserializeForNativeProtocol(CollectionSerializer.pack(lb, lb.size(), version), version));
1: 
1:         // Sets
0:         SetType<?> st = SetType.getInstance(UTF8Type.instance);
1:         Set<String> s = new LinkedHashSet<>();
1:         s.addAll(Arrays.asList("bar", "foo", "zee"));
1: 
1:         List<ByteBuffer> sb = new ArrayList<>(s.size());
1:         for (String t : s)
1:             sb.add(UTF8Type.instance.decompose(t));
1: 
1:         assertEquals(s, st.getSerializer().deserializeForNativeProtocol(CollectionSerializer.pack(sb, sb.size(), version), version));
1: 
1:         // Maps
0:         MapType<?, ?> mt = MapType.getInstance(UTF8Type.instance, LongType.instance);
1:         Map<String, Long> m = new LinkedHashMap<>();
1:         m.put("bar", 12L);
1:         m.put("foo", 42L);
1:         m.put("zee", 14L);
1: 
1:         List<ByteBuffer> mb = new ArrayList<>(m.size() * 2);
1:         for (Map.Entry<String, Long> entry : m.entrySet())
1:         {
1:             mb.add(UTF8Type.instance.decompose(entry.getKey()));
1:             mb.add(LongType.instance.decompose(entry.getValue()));
1:         }
1: 
1:         assertEquals(m, mt.getSerializer().deserializeForNativeProtocol(CollectionSerializer.pack(mb, m.size(), version), version));
1:     }
1: 
1:     @Test
1:     public void eventSerDeserTest() throws Exception
1:     {
0:         eventSerDeserTest(2);
0:         eventSerDeserTest(3);
1:     }
1: 
0:     public void eventSerDeserTest(int version) throws Exception
1:     {
1:         List<Event> events = new ArrayList<>();
1: 
1:         events.add(TopologyChange.newNode(FBUtilities.getBroadcastAddress(), 42));
1:         events.add(TopologyChange.removedNode(FBUtilities.getBroadcastAddress(), 42));
1:         events.add(TopologyChange.movedNode(FBUtilities.getBroadcastAddress(), 42));
1: 
1:         events.add(StatusChange.nodeUp(FBUtilities.getBroadcastAddress(), 42));
1:         events.add(StatusChange.nodeDown(FBUtilities.getBroadcastAddress(), 42));
1: 
1:         events.add(new SchemaChange(SchemaChange.Change.CREATED, "ks"));
1:         events.add(new SchemaChange(SchemaChange.Change.UPDATED, "ks"));
1:         events.add(new SchemaChange(SchemaChange.Change.DROPPED, "ks"));
1: 
1:         events.add(new SchemaChange(SchemaChange.Change.CREATED, SchemaChange.Target.TABLE, "ks", "table"));
1:         events.add(new SchemaChange(SchemaChange.Change.UPDATED, SchemaChange.Target.TABLE, "ks", "table"));
1:         events.add(new SchemaChange(SchemaChange.Change.DROPPED, SchemaChange.Target.TABLE, "ks", "table"));
1: 
0:         if (version >= 3)
1:         {
1:             events.add(new SchemaChange(SchemaChange.Change.CREATED, SchemaChange.Target.TYPE, "ks", "type"));
1:             events.add(new SchemaChange(SchemaChange.Change.UPDATED, SchemaChange.Target.TYPE, "ks", "type"));
1:             events.add(new SchemaChange(SchemaChange.Change.DROPPED, SchemaChange.Target.TYPE, "ks", "type"));
1:         }
1: 
1:         for (Event ev : events)
1:         {
1:             ByteBuf buf = Unpooled.buffer(ev.serializedSize(version));
1:             ev.serialize(buf, version);
1:             assertEquals(ev, Event.deserialize(buf, version));
1:         }
1:     }
1: 
1:     private static ByteBuffer bb(String str)
1:     {
1:         return UTF8Type.instance.decompose(str);
1:     }
1: 
1:     private static ColumnIdentifier ci(String name)
1:     {
1:         return new ColumnIdentifier(name, false);
1:     }
1: 
1:     private static Constants.Literal lit(long v)
1:     {
1:         return Constants.Literal.integer(String.valueOf(v));
1:     }
1: 
1:     private static Constants.Literal lit(String v)
1:     {
1:         return Constants.Literal.string(v);
1:     }
1: 
1:     private static ColumnSpecification columnSpec(String name, AbstractType<?> type)
1:     {
1:         return new ColumnSpecification("ks", "cf", ci(name), type);
1:     }
1: 
1:     @Test
1:     public void udtSerDeserTest() throws Exception
1:     {
0:         udtSerDeserTest(2);
0:         udtSerDeserTest(3);
1:     }
1: 
0:     public void udtSerDeserTest(int version) throws Exception
1:     {
0:         ListType<?> lt = ListType.getInstance(Int32Type.instance);
0:         SetType<?> st = SetType.getInstance(UTF8Type.instance);
0:         MapType<?, ?> mt = MapType.getInstance(UTF8Type.instance, LongType.instance);
1: 
1:         UserType udt = new UserType("ks",
1:                                     bb("myType"),
0:                                     Arrays.asList(bb("f1"), bb("f2"), bb("f3"), bb("f4")),
0:                                     Arrays.asList(LongType.instance, lt, st, mt));
1: 
0:         Map<ColumnIdentifier, Term.Raw> value = new HashMap<>();
0:         value.put(ci("f1"), lit(42));
0:         value.put(ci("f2"), new Lists.Literal(Arrays.<Term.Raw>asList(lit(3), lit(1))));
0:         value.put(ci("f3"), new Sets.Literal(Arrays.<Term.Raw>asList(lit("foo"), lit("bar"))));
0:         value.put(ci("f4"), new Maps.Literal(Arrays.<Pair<Term.Raw, Term.Raw>>asList(
1:                                    Pair.<Term.Raw, Term.Raw>create(lit("foo"), lit(24)),
1:                                    Pair.<Term.Raw, Term.Raw>create(lit("bar"), lit(12)))));
1: 
1:         UserTypes.Literal u = new UserTypes.Literal(value);
1:         Term t = u.prepare("ks", columnSpec("myValue", udt));
1: 
1:         QueryOptions options = QueryOptions.DEFAULT;
0:         if (version == 2)
0:             options = QueryOptions.fromProtocolV2(ConsistencyLevel.ONE, Collections.<ByteBuffer>emptyList());
0:         else if (version != 3)
0:             throw new AssertionError("Invalid protocol version for test");
1: 
1:         ByteBuffer serialized = t.bindAndGet(options);
1: 
1:         ByteBuffer[] fields = udt.split(serialized);
1: 
1:         assertEquals(4, fields.length);
1: 
1:         assertEquals(bytes(42L), fields[0]);
1: 
1:         // Note that no matter what the protocol version has been used in bindAndGet above, the collections inside
1:         // a UDT should alway be serialized with version 3 of the protocol. Which is why we don't use 'version'
1:         // on purpose below.
1: 
0:         assertEquals(Arrays.asList(3, 1), lt.getSerializer().deserializeForNativeProtocol(fields[1], 3));
1: 
1:         LinkedHashSet<String> s = new LinkedHashSet<>();
1:         s.addAll(Arrays.asList("bar", "foo"));
0:         assertEquals(s, st.getSerializer().deserializeForNativeProtocol(fields[2], 3));
1: 
1:         LinkedHashMap<String, Long> m = new LinkedHashMap<>();
1:         m.put("bar", 12L);
1:         m.put("foo", 24L);
0:         assertEquals(m, mt.getSerializer().deserializeForNativeProtocol(fields[3], 3));
1:     }
1: }
author:Robert Stupp
-------------------------------------------------------------------------------
commit:49d6045
/////////////////////////////////////////////////////////////////////////
0:         ResultSet.PreparedMetadata meta = new ResultSet.PreparedMetadata(columnNames, new short[]{2, 1});
commit:dcc3bb0
/////////////////////////////////////////////////////////////////////////
0:         eventSerDeserTest(4);
/////////////////////////////////////////////////////////////////////////
0:         if (version >= 4)
1:         {
1:             List<String> moreTypes = Arrays.asList("text", "bigint");
1: 
1:             events.add(new SchemaChange(SchemaChange.Change.CREATED, SchemaChange.Target.FUNCTION, "ks", "func", Collections.<String>emptyList()));
1:             events.add(new SchemaChange(SchemaChange.Change.UPDATED, SchemaChange.Target.FUNCTION, "ks", "func", moreTypes));
1:             events.add(new SchemaChange(SchemaChange.Change.DROPPED, SchemaChange.Target.FUNCTION, "ks", "func", moreTypes));
1: 
1:             events.add(new SchemaChange(SchemaChange.Change.CREATED, SchemaChange.Target.AGGREGATE, "ks", "aggr", Collections.<String>emptyList()));
1:             events.add(new SchemaChange(SchemaChange.Change.UPDATED, SchemaChange.Target.AGGREGATE, "ks", "aggr", moreTypes));
1:             events.add(new SchemaChange(SchemaChange.Change.DROPPED, SchemaChange.Target.AGGREGATE, "ks", "aggr", moreTypes));
1:         }
1: 
author:Tyler Hobbs
-------------------------------------------------------------------------------
commit:677230d
/////////////////////////////////////////////////////////////////////////
1:                                     Arrays.asList(LongType.instance, lt, st, mt),
1:                                     true);
commit:dca37a6
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertNotSame;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test
1:     public void preparedMetadataSerializationTest()
1:     {
1:         List<ColumnSpecification> columnNames = new ArrayList<>();
1:         for (int i = 0; i < 3; i++)
1:             columnNames.add(new ColumnSpecification("ks", "cf", new ColumnIdentifier("col" + i, false), Int32Type.instance));
1: 
0:         ResultSet.PreparedMetadata meta = new ResultSet.PreparedMetadata(columnNames, new Short[]{2, 1});
0:         ByteBuf buf = Unpooled.buffer(meta.codec.encodedSize(meta, Server.VERSION_4));
0:         meta.codec.encode(meta, buf, Server.VERSION_4);
0:         ResultSet.PreparedMetadata decodedMeta = meta.codec.decode(buf, Server.VERSION_4);
1: 
1:         assertEquals(meta, decodedMeta);
1: 
0:         // v3 encoding doesn't include partition key bind indexes
0:         buf = Unpooled.buffer(meta.codec.encodedSize(meta, Server.VERSION_3));
0:         meta.codec.encode(meta, buf, Server.VERSION_3);
0:         decodedMeta = meta.codec.decode(buf, Server.VERSION_3);
1: 
0:         assertNotSame(meta, decodedMeta);
1: 
0:         // however, if there are no partition key indexes, they should be the same
0:         ResultSet.PreparedMetadata metaWithoutIndexes = new ResultSet.PreparedMetadata(columnNames, null);
0:         buf = Unpooled.buffer(metaWithoutIndexes.codec.encodedSize(metaWithoutIndexes, Server.VERSION_4));
0:         metaWithoutIndexes.codec.encode(metaWithoutIndexes, buf, Server.VERSION_4);
0:         ResultSet.PreparedMetadata decodedMetaWithoutIndexes = metaWithoutIndexes.codec.decode(buf, Server.VERSION_4);
1: 
0:         assertEquals(decodedMeta, decodedMetaWithoutIndexes);
1:     }
commit:ee55f36
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         ListType<?> lt = ListType.getInstance(Int32Type.instance, true);
/////////////////////////////////////////////////////////////////////////
1:         SetType<?> st = SetType.getInstance(UTF8Type.instance, true);
/////////////////////////////////////////////////////////////////////////
1:         MapType<?, ?> mt = MapType.getInstance(UTF8Type.instance, LongType.instance, true);
/////////////////////////////////////////////////////////////////////////
1:         ListType<?> lt = ListType.getInstance(Int32Type.instance, true);
1:         SetType<?> st = SetType.getInstance(UTF8Type.instance, true);
1:         MapType<?, ?> mt = MapType.getInstance(UTF8Type.instance, LongType.instance, true);
author:blerer
-------------------------------------------------------------------------------
commit:8439e74
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         collectionSerDeserTest(4);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         udtSerDeserTest(4);
/////////////////////////////////////////////////////////////////////////
============================================================================