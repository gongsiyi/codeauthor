1:27d25c6: /*
1:27d25c6:  * Licensed to the Apache Software Foundation (ASF) under one
1:27d25c6:  * or more contributor license agreements.  See the NOTICE file
1:27d25c6:  * distributed with this work for additional information
1:27d25c6:  * regarding copyright ownership.  The ASF licenses this file
1:27d25c6:  * to you under the Apache License, Version 2.0 (the
1:27d25c6:  * "License"); you may not use this file except in compliance
1:27d25c6:  * with the License.  You may obtain a copy of the License at
1:27d25c6:  *
1:27d25c6:  *     http://www.apache.org/licenses/LICENSE-2.0
1:27d25c6:  *
1:27d25c6:  * Unless required by applicable law or agreed to in writing, software
1:27d25c6:  * distributed under the License is distributed on an "AS IS" BASIS,
1:27d25c6:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:27d25c6:  * See the License for the specific language governing permissions and
1:27d25c6:  * limitations under the License.
1:27d25c6:  */
1:27d25c6: 
1:27d25c6: package org.apache.cassandra.tools.nodetool.stats;
1:27d25c6: 
1:27d25c6: import java.util.*;
1:27d25c6: 
1:27d25c6: import javax.management.InstanceNotFoundException;
1:27d25c6: 
1:27d25c6: import com.google.common.collect.ArrayListMultimap;
1:27d25c6: 
1:27d25c6: import org.apache.cassandra.db.*;
1:27d25c6: import org.apache.cassandra.io.util.*;
1:27d25c6: import org.apache.cassandra.metrics.*;
1:27d25c6: import org.apache.cassandra.tools.*;
1:27d25c6: 
1:27d25c6: public class TableStatsHolder implements StatsHolder
1:27d25c6: {
1:27d25c6:     public final List<StatsKeyspace> keyspaces;
1:27d25c6:     public final int numberOfTables;
1:27d25c6: 
1:27d25c6:     public TableStatsHolder(NodeProbe probe, boolean humanReadable, boolean ignore, List<String> tableNames)
1:27d25c6:     {
1:27d25c6:         this.keyspaces = new ArrayList<>();
1:27d25c6:         this.numberOfTables = probe.getNumberOfTables();
1:27d25c6:         this.initializeKeyspaces(probe, humanReadable, ignore, tableNames);
1:27d25c6:     }
1:27d25c6: 
1:27d25c6:     @Override
1:27d25c6:     public Map<String, Object> convert2Map()
1:27d25c6:     {
1:27d25c6:         HashMap<String, Object> mpRet = new HashMap<>();
1:27d25c6:         mpRet.put("total_number_of_tables", numberOfTables);
1:27d25c6:         for (StatsKeyspace keyspace : keyspaces)
1:27d25c6:         {
1:27d25c6:             // store each keyspace's metrics to map
1:27d25c6:             HashMap<String, Object> mpKeyspace = new HashMap<>();
1:27d25c6:             mpKeyspace.put("read_latency", keyspace.readLatency());
1:27d25c6:             mpKeyspace.put("read_count", keyspace.readCount);
1:27d25c6:             mpKeyspace.put("read_latency_ms", keyspace.readLatency());
1:27d25c6:             mpKeyspace.put("write_count", keyspace.writeCount);
1:27d25c6:             mpKeyspace.put("write_latency_ms", keyspace.writeLatency());
1:27d25c6:             mpKeyspace.put("pending_flushes", keyspace.pendingFlushes);
1:27d25c6: 
1:27d25c6:             // store each table's metrics to map
1:27d25c6:             List<StatsTable> tables = keyspace.tables;
1:27d25c6:             Map<String, Map<String, Object>> mpTables = new HashMap<>();
1:27d25c6:             for (StatsTable table : tables)
1:27d25c6:             {
1:27d25c6:                 Map<String, Object> mpTable = new HashMap<>();
1:27d25c6: 
1:27d25c6:                 mpTable.put("sstables_in_each_level", table.sstablesInEachLevel);
1:27d25c6:                 mpTable.put("space_used_live", table.spaceUsedLive);
1:27d25c6:                 mpTable.put("space_used_total", table.spaceUsedTotal);
1:27d25c6:                 mpTable.put("space_used_by_snapshots_total", table.spaceUsedBySnapshotsTotal);
1:27d25c6:                 if (table.offHeapUsed)
1:27d25c6:                     mpTable.put("off_heap_memory_used_total", table.offHeapMemoryUsedTotal);
1:27d25c6:                 mpTable.put("sstable_compression_ratio", table.sstableCompressionRatio);
1:27d25c6:                 mpTable.put("number_of_keys_estimate", table.numberOfKeysEstimate);
1:27d25c6:                 mpTable.put("memtable_cell_count", table.memtableCellCount);
1:27d25c6:                 mpTable.put("memtable_data_size", table.memtableDataSize);
1:27d25c6:                 if (table.memtableOffHeapUsed)
1:27d25c6:                     mpTable.put("memtable_off_heap_memory_used", table.memtableOffHeapMemoryUsed);
1:27d25c6:                 mpTable.put("memtable_switch_count", table.memtableSwitchCount);
1:27d25c6:                 mpTable.put("local_read_count", table.localReadCount);
1:27d25c6:                 mpTable.put("local_read_latency_ms", String.format("%01.3f", table.localReadLatencyMs));
1:27d25c6:                 mpTable.put("local_write_count", table.localWriteCount);
1:27d25c6:                 mpTable.put("local_write_latency_ms", String.format("%01.3f", table.localWriteLatencyMs));
1:27d25c6:                 mpTable.put("pending_flushes", table.pendingFlushes);
1:27d25c6:                 mpTable.put("percent_repaired", table.percentRepaired);
1:27d25c6:                 mpTable.put("bloom_filter_false_positives", table.bloomFilterFalsePositives);
1:27d25c6:                 mpTable.put("bloom_filter_false_ratio", String.format("%01.5f", table.bloomFilterFalseRatio));
1:27d25c6:                 mpTable.put("bloom_filter_space_used", table.bloomFilterSpaceUsed);
1:27d25c6:                 if (table.bloomFilterOffHeapUsed)
1:27d25c6:                     mpTable.put("bloom_filter_off_heap_memory_used", table.bloomFilterOffHeapMemoryUsed);
1:27d25c6:                 if (table.indexSummaryOffHeapUsed)
1:27d25c6:                     mpTable.put("index_summary_off_heap_memory_used", table.indexSummaryOffHeapMemoryUsed);
1:27d25c6:                 if (table.compressionMetadataOffHeapUsed)
1:27d25c6:                     mpTable.put("compression_metadata_off_heap_memory_used",
1:27d25c6:                                 table.compressionMetadataOffHeapMemoryUsed);
1:27d25c6:                 mpTable.put("compacted_partition_minimum_bytes", table.compactedPartitionMinimumBytes);
1:27d25c6:                 mpTable.put("compacted_partition_maximum_bytes", table.compactedPartitionMaximumBytes);
1:27d25c6:                 mpTable.put("compacted_partition_mean_bytes", table.compactedPartitionMeanBytes);
1:27d25c6:                 mpTable.put("average_live_cells_per_slice_last_five_minutes",
1:27d25c6:                             table.averageLiveCellsPerSliceLastFiveMinutes);
1:27d25c6:                 mpTable.put("maximum_live_cells_per_slice_last_five_minutes",
1:27d25c6:                             table.maximumLiveCellsPerSliceLastFiveMinutes);
1:27d25c6:                 mpTable.put("average_tombstones_per_slice_last_five_minutes",
1:27d25c6:                             table.averageTombstonesPerSliceLastFiveMinutes);
1:27d25c6:                 mpTable.put("maximum_tombstones_per_slice_last_five_minutes",
1:27d25c6:                             table.maximumTombstonesPerSliceLastFiveMinutes);
1:27d25c6:                 mpTable.put("dropped_mutations", table.droppedMutations);
1:27d25c6: 
1:27d25c6:                 mpTables.put(table.name, mpTable);
1:27d25c6:             }
1:27d25c6:             mpKeyspace.put("tables", mpTables);
1:27d25c6:             mpRet.put(keyspace.name, mpKeyspace);
1:27d25c6:         }
1:27d25c6:         return mpRet;
1:27d25c6:     }
1:27d25c6: 
1:27d25c6:     private void initializeKeyspaces(NodeProbe probe, boolean humanReadable, boolean ignore, List<String> tableNames)
1:27d25c6:     {
1:27d25c6:         OptionFilter filter = new OptionFilter(ignore, tableNames);
1:27d25c6:         ArrayListMultimap<String, ColumnFamilyStoreMBean> selectedTableMbeans = ArrayListMultimap.create();
1:27d25c6:         Map<String, StatsKeyspace> keyspaceStats = new HashMap<>();
1:27d25c6: 
1:27d25c6:         // get a list of table stores
1:27d25c6:         Iterator<Map.Entry<String, ColumnFamilyStoreMBean>> tableMBeans = probe.getColumnFamilyStoreMBeanProxies();
1:27d25c6: 
1:27d25c6:         while (tableMBeans.hasNext())
1:27d25c6:         {
1:27d25c6:             Map.Entry<String, ColumnFamilyStoreMBean> entry = tableMBeans.next();
1:27d25c6:             String keyspaceName = entry.getKey();
1:27d25c6:             ColumnFamilyStoreMBean tableProxy = entry.getValue();
1:27d25c6: 
1:27d25c6:             if (filter.isKeyspaceIncluded(keyspaceName))
1:27d25c6:             {
1:27d25c6:                 StatsKeyspace stats = keyspaceStats.get(keyspaceName);
1:27d25c6:                 if (stats == null)
1:27d25c6:                 {
1:27d25c6:                     stats = new StatsKeyspace(probe, keyspaceName);
1:27d25c6:                     keyspaceStats.put(keyspaceName, stats);
1:27d25c6:                 }
1:27d25c6:                 stats.add(tableProxy);
1:27d25c6: 
1:27d25c6:                 if (filter.isTableIncluded(keyspaceName, tableProxy.getTableName()))
1:27d25c6:                     selectedTableMbeans.put(keyspaceName, tableProxy);
1:27d25c6:             }
1:27d25c6:         }
1:27d25c6: 
1:27d25c6:         // make sure all specified keyspace and tables exist
1:27d25c6:         filter.verifyKeyspaces(probe.getKeyspaces());
1:27d25c6:         filter.verifyTables();
1:27d25c6: 
1:27d25c6:         // get metrics of keyspace
1:27d25c6:         for (Map.Entry<String, Collection<ColumnFamilyStoreMBean>> entry : selectedTableMbeans.asMap().entrySet())
1:27d25c6:         {
1:27d25c6:             String keyspaceName = entry.getKey();
1:27d25c6:             Collection<ColumnFamilyStoreMBean> tables = entry.getValue();
1:27d25c6:             StatsKeyspace statsKeyspace = keyspaceStats.get(keyspaceName);
1:27d25c6: 
1:27d25c6:             // get metrics of table statistics for this keyspace
1:27d25c6:             for (ColumnFamilyStoreMBean table : tables)
1:27d25c6:             {
1:27d25c6:                 String tableName = table.getTableName();
1:27d25c6:                 StatsTable statsTable = new StatsTable();
1:27d25c6:                 statsTable.name = tableName;
1:27d25c6:                 statsTable.isIndex = tableName.contains(".");
1:27d25c6:                 statsTable.sstableCount = probe.getColumnFamilyMetric(keyspaceName, tableName, "LiveSSTableCount");
1:27d25c6:                 int[] leveledSStables = table.getSSTableCountPerLevel();
1:27d25c6:                 if (leveledSStables != null)
1:27d25c6:                 {
1:27d25c6:                     statsTable.isLeveledSstable = true;
1:27d25c6: 
1:27d25c6:                     for (int level = 0; level < leveledSStables.length; level++)
1:27d25c6:                     {
1:27d25c6:                         int count = leveledSStables[level];
1:27d25c6:                         long maxCount = 4L; // for L0
1:27d25c6:                         if (level > 0)
1:9fc14bc:                             maxCount = (long) Math.pow(table.getLevelFanoutSize(), level);
1:27d25c6:                         // show max threshold for level when exceeded
1:27d25c6:                         statsTable.sstablesInEachLevel.add(count + ((count > maxCount) ? "/" + maxCount : ""));
1:27d25c6:                     }
1:27d25c6:                 }
1:27d25c6: 
1:27d25c6:                 Long memtableOffHeapSize = null;
1:27d25c6:                 Long bloomFilterOffHeapSize = null;
1:27d25c6:                 Long indexSummaryOffHeapSize = null;
1:27d25c6:                 Long compressionMetadataOffHeapSize = null;
1:27d25c6:                 Long offHeapSize = null;
1:27d25c6:                 Double percentRepaired = null;
1:27d25c6: 
1:27d25c6:                 try
1:27d25c6:                 {
1:27d25c6:                     memtableOffHeapSize = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "MemtableOffHeapSize");
1:27d25c6:                     bloomFilterOffHeapSize = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "BloomFilterOffHeapMemoryUsed");
1:27d25c6:                     indexSummaryOffHeapSize = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "IndexSummaryOffHeapMemoryUsed");
1:27d25c6:                     compressionMetadataOffHeapSize = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "CompressionMetadataOffHeapMemoryUsed");
1:27d25c6:                     offHeapSize = memtableOffHeapSize + bloomFilterOffHeapSize + indexSummaryOffHeapSize + compressionMetadataOffHeapSize;
1:27d25c6:                     percentRepaired = (Double) probe.getColumnFamilyMetric(keyspaceName, tableName, "PercentRepaired");
1:27d25c6:                 }
1:27d25c6:                 catch (RuntimeException e)
1:27d25c6:                 {
1:27d25c6:                     // offheap-metrics introduced in 2.1.3 - older versions do not have the appropriate mbeans
1:27d25c6:                     if (!(e.getCause() instanceof InstanceNotFoundException))
1:27d25c6:                         throw e;
1:27d25c6:                 }
1:27d25c6: 
1:27d25c6:                 statsTable.spaceUsedLive = format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "LiveDiskSpaceUsed"), humanReadable);
1:27d25c6:                 statsTable.spaceUsedTotal = format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "TotalDiskSpaceUsed"), humanReadable);
1:27d25c6:                 statsTable.spaceUsedBySnapshotsTotal = format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "SnapshotsSize"), humanReadable);
1:27d25c6:                 if (offHeapSize != null)
1:27d25c6:                 {
1:27d25c6:                     statsTable.offHeapUsed = true;
1:27d25c6:                     statsTable.offHeapMemoryUsedTotal = format(offHeapSize, humanReadable);
1:27d25c6: 
1:27d25c6:                 }
1:27d25c6:                 if (percentRepaired != null)
1:27d25c6:                 {
1:27d25c6:                     statsTable.percentRepaired = Math.round(100 * percentRepaired) / 100.0;
1:27d25c6:                 }
1:27d25c6:                 statsTable.sstableCompressionRatio = probe.getColumnFamilyMetric(keyspaceName, tableName, "CompressionRatio");
1:27d25c6:                 Object estimatedPartitionCount = probe.getColumnFamilyMetric(keyspaceName, tableName, "EstimatedPartitionCount");
1:27d25c6:                 if (Long.valueOf(-1L).equals(estimatedPartitionCount))
1:27d25c6:                 {
1:27d25c6:                     estimatedPartitionCount = 0L;
1:27d25c6:                 }
1:27d25c6:                 statsTable.numberOfKeysEstimate = estimatedPartitionCount;
1:27d25c6: 
1:27d25c6:                 statsTable.memtableCellCount = probe.getColumnFamilyMetric(keyspaceName, tableName, "MemtableColumnsCount");
1:27d25c6:                 statsTable.memtableDataSize = format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "MemtableLiveDataSize"), humanReadable);
1:27d25c6:                 if (memtableOffHeapSize != null)
1:27d25c6:                 {
1:27d25c6:                     statsTable.memtableOffHeapUsed = true;
1:27d25c6:                     statsTable.memtableOffHeapMemoryUsed = format(memtableOffHeapSize, humanReadable);
1:27d25c6:                 }
1:27d25c6:                 statsTable.memtableSwitchCount = probe.getColumnFamilyMetric(keyspaceName, tableName, "MemtableSwitchCount");
1:27d25c6:                 statsTable.localReadCount = ((CassandraMetricsRegistry.JmxTimerMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, "ReadLatency")).getCount();
1:27d25c6: 
1:27d25c6:                 double localReadLatency = ((CassandraMetricsRegistry.JmxTimerMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, "ReadLatency")).getMean() / 1000;
1:27d25c6:                 double localRLatency = localReadLatency > 0 ? localReadLatency : Double.NaN;
1:27d25c6:                 statsTable.localReadLatencyMs = localRLatency;
1:27d25c6:                 statsTable.localWriteCount = ((CassandraMetricsRegistry.JmxTimerMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, "WriteLatency")).getCount();
1:27d25c6: 
1:27d25c6:                 double localWriteLatency = ((CassandraMetricsRegistry.JmxTimerMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, "WriteLatency")).getMean() / 1000;
1:27d25c6:                 double localWLatency = localWriteLatency > 0 ? localWriteLatency : Double.NaN;
1:27d25c6:                 statsTable.localWriteLatencyMs = localWLatency;
1:27d25c6:                 statsTable.pendingFlushes = probe.getColumnFamilyMetric(keyspaceName, tableName, "PendingFlushes");
1:27d25c6: 
1:27d25c6:                 statsTable.bloomFilterFalsePositives = probe.getColumnFamilyMetric(keyspaceName, tableName, "BloomFilterFalsePositives");
1:27d25c6:                 statsTable.bloomFilterFalseRatio = probe.getColumnFamilyMetric(keyspaceName, tableName, "RecentBloomFilterFalseRatio");
1:27d25c6:                 statsTable.bloomFilterSpaceUsed = format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "BloomFilterDiskSpaceUsed"), humanReadable);
1:27d25c6: 
1:27d25c6:                 if (bloomFilterOffHeapSize != null)
1:27d25c6:                 {
1:27d25c6:                     statsTable.bloomFilterOffHeapUsed = true;
1:27d25c6:                     statsTable.bloomFilterOffHeapMemoryUsed = format(bloomFilterOffHeapSize, humanReadable);
1:27d25c6:                 }
1:27d25c6: 
1:27d25c6:                 if (indexSummaryOffHeapSize != null)
1:27d25c6:                 {
1:27d25c6:                     statsTable.indexSummaryOffHeapUsed = true;
1:27d25c6:                     statsTable.indexSummaryOffHeapMemoryUsed = format(indexSummaryOffHeapSize, humanReadable);
1:27d25c6:                 }
1:27d25c6:                 if (compressionMetadataOffHeapSize != null)
1:27d25c6:                 {
1:27d25c6:                     statsTable.compressionMetadataOffHeapUsed = true;
1:27d25c6:                     statsTable.compressionMetadataOffHeapMemoryUsed = format(compressionMetadataOffHeapSize, humanReadable);
1:27d25c6:                 }
1:27d25c6:                 statsTable.compactedPartitionMinimumBytes = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "MinPartitionSize");
1:27d25c6:                 statsTable.compactedPartitionMaximumBytes = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "MaxPartitionSize");
1:27d25c6:                 statsTable.compactedPartitionMeanBytes = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "MeanPartitionSize");
1:27d25c6: 
1:27d25c6:                 CassandraMetricsRegistry.JmxHistogramMBean histogram = (CassandraMetricsRegistry.JmxHistogramMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, "LiveScannedHistogram");
1:27d25c6:                 statsTable.averageLiveCellsPerSliceLastFiveMinutes = histogram.getMean();
1:27d25c6:                 statsTable.maximumLiveCellsPerSliceLastFiveMinutes = histogram.getMax();
1:27d25c6: 
1:27d25c6:                 histogram = (CassandraMetricsRegistry.JmxHistogramMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, "TombstoneScannedHistogram");
1:27d25c6:                 statsTable.averageTombstonesPerSliceLastFiveMinutes = histogram.getMean();
1:27d25c6:                 statsTable.maximumTombstonesPerSliceLastFiveMinutes = histogram.getMax();
1:27d25c6:                 statsTable.droppedMutations = format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "DroppedMutations"), humanReadable);
1:27d25c6:                 statsKeyspace.tables.add(statsTable);
1:27d25c6:             }
1:27d25c6:             keyspaces.add(statsKeyspace);
1:27d25c6:         }
1:27d25c6:     }
1:27d25c6: 
1:27d25c6:     private String format(long bytes, boolean humanReadable)
1:27d25c6:     {
1:27d25c6:         return humanReadable ? FileUtils.stringifyFileSize(bytes) : Long.toString(bytes);
1:27d25c6:     }
1:27d25c6: 
1:27d25c6:     /**
1:27d25c6:      * Used for filtering keyspaces and tables to be displayed using the tablestats command.
1:27d25c6:      */
1:27d25c6:     private static class OptionFilter
1:27d25c6:     {
1:27d25c6:         private final Map<String, List<String>> filter = new HashMap<>();
1:27d25c6:         private final Map<String, List<String>> verifier = new HashMap<>(); // Same as filter initially, but we remove tables every time we've checked them for inclusion
1:27d25c6:         // in isTableIncluded() so that we detect if those table requested don't exist (verifyTables())
1:27d25c6:         private final List<String> filterList = new ArrayList<>();
1:27d25c6:         private final boolean ignoreMode;
1:27d25c6: 
1:27d25c6:         OptionFilter(boolean ignoreMode, List<String> filterList)
1:27d25c6:         {
1:27d25c6:             this.filterList.addAll(filterList);
1:27d25c6:             this.ignoreMode = ignoreMode;
1:27d25c6: 
1:27d25c6:             for (String s : filterList)
1:27d25c6:             {
1:27d25c6:                 String[] keyValues = s.split("\\.", 2);
1:27d25c6: 
1:27d25c6:                 // build the map that stores the keyspaces and tables to use
1:27d25c6:                 if (!filter.containsKey(keyValues[0]))
1:27d25c6:                 {
1:27d25c6:                     filter.put(keyValues[0], new ArrayList<>());
1:27d25c6:                     verifier.put(keyValues[0], new ArrayList<>());
1:27d25c6:                 }
1:27d25c6: 
1:27d25c6:                 if (keyValues.length == 2)
1:27d25c6:                 {
1:27d25c6:                     filter.get(keyValues[0]).add(keyValues[1]);
1:27d25c6:                     verifier.get(keyValues[0]).add(keyValues[1]);
1:27d25c6:                 }
1:27d25c6:             }
1:27d25c6:         }
1:27d25c6: 
1:27d25c6:         public boolean isTableIncluded(String keyspace, String table)
1:27d25c6:         {
1:27d25c6:             // supplying empty params list is treated as wanting to display all keyspaces and tables
1:27d25c6:             if (filterList.isEmpty())
1:27d25c6:                 return !ignoreMode;
1:27d25c6: 
1:27d25c6:             List<String> tables = filter.get(keyspace);
1:27d25c6: 
1:27d25c6:             // no such keyspace is in the map
1:27d25c6:             if (tables == null)
1:27d25c6:                 return ignoreMode;
1:27d25c6:                 // only a keyspace with no tables was supplied
1:27d25c6:                 // so ignore or include (based on the flag) every column family in specified keyspace
1:27d25c6:             else if (tables.isEmpty())
1:27d25c6:                 return !ignoreMode;
1:27d25c6: 
1:27d25c6:             // keyspace exists, and it contains specific table
1:27d25c6:             verifier.get(keyspace).remove(table);
1:27d25c6:             return ignoreMode ^ tables.contains(table);
1:27d25c6:         }
1:27d25c6: 
1:27d25c6:         public boolean isKeyspaceIncluded(String keyspace)
1:27d25c6:         {
1:27d25c6:             // supplying empty params list is treated as wanting to display all keyspaces and tables
1:27d25c6:             if (filterList.isEmpty())
1:27d25c6:                 return !ignoreMode;
1:27d25c6: 
1:27d25c6:             // Note that if there is any table for the keyspace, we want to include the keyspace irregarding
1:27d25c6:             // of the ignoreMode, since the ignoreMode then apply to the table inside the keyspace but the
1:27d25c6:             // keyspace itself is not ignored
1:27d25c6:             return filter.get(keyspace) != null || ignoreMode;
1:27d25c6:         }
1:27d25c6: 
1:27d25c6:         public void verifyKeyspaces(List<String> keyspaces)
1:27d25c6:         {
1:27d25c6:             for (String ks : verifier.keySet())
1:27d25c6:                 if (!keyspaces.contains(ks))
1:27d25c6:                     throw new IllegalArgumentException("Unknown keyspace: " + ks);
1:27d25c6:         }
1:27d25c6: 
1:27d25c6:         public void verifyTables()
1:27d25c6:         {
1:27d25c6:             for (String ks : filter.keySet())
1:27d25c6:                 if (!verifier.get(ks).isEmpty())
1:27d25c6:                     throw new IllegalArgumentException("Unknown tables: " + verifier.get(ks) + " in keyspace: " + ks);
1:27d25c6:         }
1:27d25c6:     }
1:27d25c6: }
============================================================================
author:Dikang Gu
-------------------------------------------------------------------------------
commit:9fc14bc
/////////////////////////////////////////////////////////////////////////
1:                             maxCount = (long) Math.pow(table.getLevelFanoutSize(), level);
author:Dave Brosius
-------------------------------------------------------------------------------
commit:087264f
/////////////////////////////////////////////////////////////////////////
author:Hiroyuki Nishi
-------------------------------------------------------------------------------
commit:27d25c6
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *     http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.cassandra.tools.nodetool.stats;
1: 
1: import java.util.*;
1: 
1: import javax.management.InstanceNotFoundException;
1: 
1: import com.google.common.collect.ArrayListMultimap;
1: 
1: import org.apache.cassandra.db.*;
1: import org.apache.cassandra.io.util.*;
1: import org.apache.cassandra.metrics.*;
1: import org.apache.cassandra.tools.*;
0: import org.apache.cassandra.tools.nodetool.*;
0: import org.apache.cassandra.tools.nodetool.stats.*;
1: 
1: public class TableStatsHolder implements StatsHolder
1: {
1:     public final List<StatsKeyspace> keyspaces;
1:     public final int numberOfTables;
1: 
1:     public TableStatsHolder(NodeProbe probe, boolean humanReadable, boolean ignore, List<String> tableNames)
1:     {
1:         this.keyspaces = new ArrayList<>();
1:         this.numberOfTables = probe.getNumberOfTables();
1:         this.initializeKeyspaces(probe, humanReadable, ignore, tableNames);
1:     }
1: 
1:     @Override
1:     public Map<String, Object> convert2Map()
1:     {
1:         HashMap<String, Object> mpRet = new HashMap<>();
1:         mpRet.put("total_number_of_tables", numberOfTables);
1:         for (StatsKeyspace keyspace : keyspaces)
1:         {
1:             // store each keyspace's metrics to map
1:             HashMap<String, Object> mpKeyspace = new HashMap<>();
1:             mpKeyspace.put("read_latency", keyspace.readLatency());
1:             mpKeyspace.put("read_count", keyspace.readCount);
1:             mpKeyspace.put("read_latency_ms", keyspace.readLatency());
1:             mpKeyspace.put("write_count", keyspace.writeCount);
1:             mpKeyspace.put("write_latency_ms", keyspace.writeLatency());
1:             mpKeyspace.put("pending_flushes", keyspace.pendingFlushes);
1: 
1:             // store each table's metrics to map
1:             List<StatsTable> tables = keyspace.tables;
1:             Map<String, Map<String, Object>> mpTables = new HashMap<>();
1:             for (StatsTable table : tables)
1:             {
1:                 Map<String, Object> mpTable = new HashMap<>();
1: 
1:                 mpTable.put("sstables_in_each_level", table.sstablesInEachLevel);
1:                 mpTable.put("space_used_live", table.spaceUsedLive);
1:                 mpTable.put("space_used_total", table.spaceUsedTotal);
1:                 mpTable.put("space_used_by_snapshots_total", table.spaceUsedBySnapshotsTotal);
1:                 if (table.offHeapUsed)
1:                     mpTable.put("off_heap_memory_used_total", table.offHeapMemoryUsedTotal);
1:                 mpTable.put("sstable_compression_ratio", table.sstableCompressionRatio);
1:                 mpTable.put("number_of_keys_estimate", table.numberOfKeysEstimate);
1:                 mpTable.put("memtable_cell_count", table.memtableCellCount);
1:                 mpTable.put("memtable_data_size", table.memtableDataSize);
1:                 if (table.memtableOffHeapUsed)
1:                     mpTable.put("memtable_off_heap_memory_used", table.memtableOffHeapMemoryUsed);
1:                 mpTable.put("memtable_switch_count", table.memtableSwitchCount);
1:                 mpTable.put("local_read_count", table.localReadCount);
1:                 mpTable.put("local_read_latency_ms", String.format("%01.3f", table.localReadLatencyMs));
1:                 mpTable.put("local_write_count", table.localWriteCount);
1:                 mpTable.put("local_write_latency_ms", String.format("%01.3f", table.localWriteLatencyMs));
1:                 mpTable.put("pending_flushes", table.pendingFlushes);
1:                 mpTable.put("percent_repaired", table.percentRepaired);
1:                 mpTable.put("bloom_filter_false_positives", table.bloomFilterFalsePositives);
1:                 mpTable.put("bloom_filter_false_ratio", String.format("%01.5f", table.bloomFilterFalseRatio));
1:                 mpTable.put("bloom_filter_space_used", table.bloomFilterSpaceUsed);
1:                 if (table.bloomFilterOffHeapUsed)
1:                     mpTable.put("bloom_filter_off_heap_memory_used", table.bloomFilterOffHeapMemoryUsed);
1:                 if (table.indexSummaryOffHeapUsed)
1:                     mpTable.put("index_summary_off_heap_memory_used", table.indexSummaryOffHeapMemoryUsed);
1:                 if (table.compressionMetadataOffHeapUsed)
1:                     mpTable.put("compression_metadata_off_heap_memory_used",
1:                                 table.compressionMetadataOffHeapMemoryUsed);
1:                 mpTable.put("compacted_partition_minimum_bytes", table.compactedPartitionMinimumBytes);
1:                 mpTable.put("compacted_partition_maximum_bytes", table.compactedPartitionMaximumBytes);
1:                 mpTable.put("compacted_partition_mean_bytes", table.compactedPartitionMeanBytes);
1:                 mpTable.put("average_live_cells_per_slice_last_five_minutes",
1:                             table.averageLiveCellsPerSliceLastFiveMinutes);
1:                 mpTable.put("maximum_live_cells_per_slice_last_five_minutes",
1:                             table.maximumLiveCellsPerSliceLastFiveMinutes);
1:                 mpTable.put("average_tombstones_per_slice_last_five_minutes",
1:                             table.averageTombstonesPerSliceLastFiveMinutes);
1:                 mpTable.put("maximum_tombstones_per_slice_last_five_minutes",
1:                             table.maximumTombstonesPerSliceLastFiveMinutes);
1:                 mpTable.put("dropped_mutations", table.droppedMutations);
1: 
1:                 mpTables.put(table.name, mpTable);
1:             }
1:             mpKeyspace.put("tables", mpTables);
1:             mpRet.put(keyspace.name, mpKeyspace);
1:         }
1:         return mpRet;
1:     }
1: 
1:     private void initializeKeyspaces(NodeProbe probe, boolean humanReadable, boolean ignore, List<String> tableNames)
1:     {
1:         OptionFilter filter = new OptionFilter(ignore, tableNames);
1:         ArrayListMultimap<String, ColumnFamilyStoreMBean> selectedTableMbeans = ArrayListMultimap.create();
1:         Map<String, StatsKeyspace> keyspaceStats = new HashMap<>();
1: 
1:         // get a list of table stores
1:         Iterator<Map.Entry<String, ColumnFamilyStoreMBean>> tableMBeans = probe.getColumnFamilyStoreMBeanProxies();
1: 
1:         while (tableMBeans.hasNext())
1:         {
1:             Map.Entry<String, ColumnFamilyStoreMBean> entry = tableMBeans.next();
1:             String keyspaceName = entry.getKey();
1:             ColumnFamilyStoreMBean tableProxy = entry.getValue();
1: 
1:             if (filter.isKeyspaceIncluded(keyspaceName))
1:             {
1:                 StatsKeyspace stats = keyspaceStats.get(keyspaceName);
1:                 if (stats == null)
1:                 {
1:                     stats = new StatsKeyspace(probe, keyspaceName);
1:                     keyspaceStats.put(keyspaceName, stats);
1:                 }
1:                 stats.add(tableProxy);
1: 
1:                 if (filter.isTableIncluded(keyspaceName, tableProxy.getTableName()))
1:                     selectedTableMbeans.put(keyspaceName, tableProxy);
1:             }
1:         }
1: 
1:         // make sure all specified keyspace and tables exist
1:         filter.verifyKeyspaces(probe.getKeyspaces());
1:         filter.verifyTables();
1: 
1:         // get metrics of keyspace
1:         for (Map.Entry<String, Collection<ColumnFamilyStoreMBean>> entry : selectedTableMbeans.asMap().entrySet())
1:         {
1:             String keyspaceName = entry.getKey();
1:             Collection<ColumnFamilyStoreMBean> tables = entry.getValue();
1:             StatsKeyspace statsKeyspace = keyspaceStats.get(keyspaceName);
1: 
1:             // get metrics of table statistics for this keyspace
1:             for (ColumnFamilyStoreMBean table : tables)
1:             {
1:                 String tableName = table.getTableName();
1:                 StatsTable statsTable = new StatsTable();
1:                 statsTable.name = tableName;
1:                 statsTable.isIndex = tableName.contains(".");
1:                 statsTable.sstableCount = probe.getColumnFamilyMetric(keyspaceName, tableName, "LiveSSTableCount");
1:                 int[] leveledSStables = table.getSSTableCountPerLevel();
1:                 if (leveledSStables != null)
1:                 {
1:                     statsTable.isLeveledSstable = true;
1: 
1:                     for (int level = 0; level < leveledSStables.length; level++)
1:                     {
1:                         int count = leveledSStables[level];
1:                         long maxCount = 4L; // for L0
1:                         if (level > 0)
0:                             maxCount = (long) Math.pow(10, level);
1:                         // show max threshold for level when exceeded
1:                         statsTable.sstablesInEachLevel.add(count + ((count > maxCount) ? "/" + maxCount : ""));
1:                     }
1:                 }
1: 
1:                 Long memtableOffHeapSize = null;
1:                 Long bloomFilterOffHeapSize = null;
1:                 Long indexSummaryOffHeapSize = null;
1:                 Long compressionMetadataOffHeapSize = null;
1:                 Long offHeapSize = null;
1:                 Double percentRepaired = null;
1: 
1:                 try
1:                 {
1:                     memtableOffHeapSize = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "MemtableOffHeapSize");
1:                     bloomFilterOffHeapSize = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "BloomFilterOffHeapMemoryUsed");
1:                     indexSummaryOffHeapSize = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "IndexSummaryOffHeapMemoryUsed");
1:                     compressionMetadataOffHeapSize = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "CompressionMetadataOffHeapMemoryUsed");
1:                     offHeapSize = memtableOffHeapSize + bloomFilterOffHeapSize + indexSummaryOffHeapSize + compressionMetadataOffHeapSize;
1:                     percentRepaired = (Double) probe.getColumnFamilyMetric(keyspaceName, tableName, "PercentRepaired");
1:                 }
1:                 catch (RuntimeException e)
1:                 {
1:                     // offheap-metrics introduced in 2.1.3 - older versions do not have the appropriate mbeans
1:                     if (!(e.getCause() instanceof InstanceNotFoundException))
1:                         throw e;
1:                 }
1: 
1:                 statsTable.spaceUsedLive = format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "LiveDiskSpaceUsed"), humanReadable);
1:                 statsTable.spaceUsedTotal = format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "TotalDiskSpaceUsed"), humanReadable);
1:                 statsTable.spaceUsedBySnapshotsTotal = format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "SnapshotsSize"), humanReadable);
1:                 if (offHeapSize != null)
1:                 {
1:                     statsTable.offHeapUsed = true;
1:                     statsTable.offHeapMemoryUsedTotal = format(offHeapSize, humanReadable);
1: 
1:                 }
1:                 if (percentRepaired != null)
1:                 {
1:                     statsTable.percentRepaired = Math.round(100 * percentRepaired) / 100.0;
1:                 }
1:                 statsTable.sstableCompressionRatio = probe.getColumnFamilyMetric(keyspaceName, tableName, "CompressionRatio");
1:                 Object estimatedPartitionCount = probe.getColumnFamilyMetric(keyspaceName, tableName, "EstimatedPartitionCount");
1:                 if (Long.valueOf(-1L).equals(estimatedPartitionCount))
1:                 {
1:                     estimatedPartitionCount = 0L;
1:                 }
1:                 statsTable.numberOfKeysEstimate = estimatedPartitionCount;
1: 
1:                 statsTable.memtableCellCount = probe.getColumnFamilyMetric(keyspaceName, tableName, "MemtableColumnsCount");
1:                 statsTable.memtableDataSize = format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "MemtableLiveDataSize"), humanReadable);
1:                 if (memtableOffHeapSize != null)
1:                 {
1:                     statsTable.memtableOffHeapUsed = true;
1:                     statsTable.memtableOffHeapMemoryUsed = format(memtableOffHeapSize, humanReadable);
1:                 }
1:                 statsTable.memtableSwitchCount = probe.getColumnFamilyMetric(keyspaceName, tableName, "MemtableSwitchCount");
1:                 statsTable.localReadCount = ((CassandraMetricsRegistry.JmxTimerMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, "ReadLatency")).getCount();
1: 
1:                 double localReadLatency = ((CassandraMetricsRegistry.JmxTimerMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, "ReadLatency")).getMean() / 1000;
1:                 double localRLatency = localReadLatency > 0 ? localReadLatency : Double.NaN;
1:                 statsTable.localReadLatencyMs = localRLatency;
1:                 statsTable.localWriteCount = ((CassandraMetricsRegistry.JmxTimerMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, "WriteLatency")).getCount();
1: 
1:                 double localWriteLatency = ((CassandraMetricsRegistry.JmxTimerMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, "WriteLatency")).getMean() / 1000;
1:                 double localWLatency = localWriteLatency > 0 ? localWriteLatency : Double.NaN;
1:                 statsTable.localWriteLatencyMs = localWLatency;
1:                 statsTable.pendingFlushes = probe.getColumnFamilyMetric(keyspaceName, tableName, "PendingFlushes");
1: 
1:                 statsTable.bloomFilterFalsePositives = probe.getColumnFamilyMetric(keyspaceName, tableName, "BloomFilterFalsePositives");
1:                 statsTable.bloomFilterFalseRatio = probe.getColumnFamilyMetric(keyspaceName, tableName, "RecentBloomFilterFalseRatio");
1:                 statsTable.bloomFilterSpaceUsed = format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "BloomFilterDiskSpaceUsed"), humanReadable);
1: 
1:                 if (bloomFilterOffHeapSize != null)
1:                 {
1:                     statsTable.bloomFilterOffHeapUsed = true;
1:                     statsTable.bloomFilterOffHeapMemoryUsed = format(bloomFilterOffHeapSize, humanReadable);
1:                 }
1: 
1:                 if (indexSummaryOffHeapSize != null)
1:                 {
1:                     statsTable.indexSummaryOffHeapUsed = true;
1:                     statsTable.indexSummaryOffHeapMemoryUsed = format(indexSummaryOffHeapSize, humanReadable);
1:                 }
1:                 if (compressionMetadataOffHeapSize != null)
1:                 {
1:                     statsTable.compressionMetadataOffHeapUsed = true;
1:                     statsTable.compressionMetadataOffHeapMemoryUsed = format(compressionMetadataOffHeapSize, humanReadable);
1:                 }
1:                 statsTable.compactedPartitionMinimumBytes = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "MinPartitionSize");
1:                 statsTable.compactedPartitionMaximumBytes = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "MaxPartitionSize");
1:                 statsTable.compactedPartitionMeanBytes = (Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "MeanPartitionSize");
1: 
1:                 CassandraMetricsRegistry.JmxHistogramMBean histogram = (CassandraMetricsRegistry.JmxHistogramMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, "LiveScannedHistogram");
1:                 statsTable.averageLiveCellsPerSliceLastFiveMinutes = histogram.getMean();
1:                 statsTable.maximumLiveCellsPerSliceLastFiveMinutes = histogram.getMax();
1: 
1:                 histogram = (CassandraMetricsRegistry.JmxHistogramMBean) probe.getColumnFamilyMetric(keyspaceName, tableName, "TombstoneScannedHistogram");
1:                 statsTable.averageTombstonesPerSliceLastFiveMinutes = histogram.getMean();
1:                 statsTable.maximumTombstonesPerSliceLastFiveMinutes = histogram.getMax();
1:                 statsTable.droppedMutations = format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "DroppedMutations"), humanReadable);
1:                 statsKeyspace.tables.add(statsTable);
1:             }
1:             keyspaces.add(statsKeyspace);
1:         }
1:     }
1: 
1:     private String format(long bytes, boolean humanReadable)
1:     {
1:         return humanReadable ? FileUtils.stringifyFileSize(bytes) : Long.toString(bytes);
1:     }
1: 
1:     /**
1:      * Used for filtering keyspaces and tables to be displayed using the tablestats command.
1:      */
1:     private static class OptionFilter
1:     {
1:         private final Map<String, List<String>> filter = new HashMap<>();
1:         private final Map<String, List<String>> verifier = new HashMap<>(); // Same as filter initially, but we remove tables every time we've checked them for inclusion
1:         // in isTableIncluded() so that we detect if those table requested don't exist (verifyTables())
1:         private final List<String> filterList = new ArrayList<>();
1:         private final boolean ignoreMode;
1: 
1:         OptionFilter(boolean ignoreMode, List<String> filterList)
1:         {
1:             this.filterList.addAll(filterList);
1:             this.ignoreMode = ignoreMode;
1: 
1:             for (String s : filterList)
1:             {
1:                 String[] keyValues = s.split("\\.", 2);
1: 
1:                 // build the map that stores the keyspaces and tables to use
1:                 if (!filter.containsKey(keyValues[0]))
1:                 {
1:                     filter.put(keyValues[0], new ArrayList<>());
1:                     verifier.put(keyValues[0], new ArrayList<>());
1:                 }
1: 
1:                 if (keyValues.length == 2)
1:                 {
1:                     filter.get(keyValues[0]).add(keyValues[1]);
1:                     verifier.get(keyValues[0]).add(keyValues[1]);
1:                 }
1:             }
1:         }
1: 
1:         public boolean isTableIncluded(String keyspace, String table)
1:         {
1:             // supplying empty params list is treated as wanting to display all keyspaces and tables
1:             if (filterList.isEmpty())
1:                 return !ignoreMode;
1: 
1:             List<String> tables = filter.get(keyspace);
1: 
1:             // no such keyspace is in the map
1:             if (tables == null)
1:                 return ignoreMode;
1:                 // only a keyspace with no tables was supplied
1:                 // so ignore or include (based on the flag) every column family in specified keyspace
1:             else if (tables.isEmpty())
1:                 return !ignoreMode;
1: 
1:             // keyspace exists, and it contains specific table
1:             verifier.get(keyspace).remove(table);
1:             return ignoreMode ^ tables.contains(table);
1:         }
1: 
1:         public boolean isKeyspaceIncluded(String keyspace)
1:         {
1:             // supplying empty params list is treated as wanting to display all keyspaces and tables
1:             if (filterList.isEmpty())
1:                 return !ignoreMode;
1: 
1:             // Note that if there is any table for the keyspace, we want to include the keyspace irregarding
1:             // of the ignoreMode, since the ignoreMode then apply to the table inside the keyspace but the
1:             // keyspace itself is not ignored
1:             return filter.get(keyspace) != null || ignoreMode;
1:         }
1: 
1:         public void verifyKeyspaces(List<String> keyspaces)
1:         {
1:             for (String ks : verifier.keySet())
1:                 if (!keyspaces.contains(ks))
1:                     throw new IllegalArgumentException("Unknown keyspace: " + ks);
1:         }
1: 
1:         public void verifyTables()
1:         {
1:             for (String ks : filter.keySet())
1:                 if (!verifier.get(ks).isEmpty())
1:                     throw new IllegalArgumentException("Unknown tables: " + verifier.get(ks) + " in keyspace: " + ks);
1:         }
1:     }
1: }
============================================================================